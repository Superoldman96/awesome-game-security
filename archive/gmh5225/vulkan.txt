Project Path: arc_gmh5225_vulkan_x8j2kkp8

Source Tree:

```txt
arc_gmh5225_vulkan_x8j2kkp8
├── CMakeLists.txt
├── CMakeSettings.json
├── LICENSE
├── README.md
├── include
│   ├── dumper.hpp
│   └── pe
│       ├── image.hpp
│       ├── import_directory.hpp
│       ├── section_headers.hpp
│       └── util.hpp
└── src
    ├── dumper.cpp
    ├── main.cpp
    └── pe
        ├── image.cpp
        ├── import_directory.cpp
        └── section_headers.cpp

```

`CMakeLists.txt`:

```txt
# CMakeList.txt : CMake project for vulkan, include source and define
# project specific logic here.
#
cmake_minimum_required (VERSION 3.8)

# Enable Hot Reload for MSVC compilers if supported.
if (POLICY CMP0141)
  cmake_policy(SET CMP0141 NEW)
  set(CMAKE_MSVC_DEBUG_INFORMATION_FORMAT "$<IF:$<AND:$<C_COMPILER_ID:MSVC>,$<CXX_COMPILER_ID:MSVC>>,$<$<CONFIG:Debug,RelWithDebInfo>:EditAndContinue>,$<$<CONFIG:Debug,RelWithDebInfo>:ProgramDatabase>>")
endif()

project (vulkan)

# Set our C++ standard
set(CMAKE_CXX_STANDARD 23)

# Include fetch content
include(FetchContent)

# Fetch the latest version of wincpp
FetchContent_Declare (
	wincpp 
	URL https://github.com/atrexus/wincpp/releases/download/v1.5.3.1/wincpp-src.zip
	DOWNLOAD_EXTRACT_TIMESTAMP TRUE
)
FetchContent_MakeAvailable (wincpp)

# Fetch the latest version of spdlog
FetchContent_Declare (
	spdlog 
	URL https://github.com/gabime/spdlog/archive/refs/tags/v1.15.0.zip
	DOWNLOAD_EXTRACT_TIMESTAMP TRUE
)
FetchContent_MakeAvailable (spdlog)

# Fetch the latest version of argparse
FetchContent_Declare (
	argparse 
	URL https://github.com/p-ranav/argparse/archive/refs/tags/v3.1.zip
	DOWNLOAD_EXTRACT_TIMESTAMP TRUE
)
FetchContent_MakeAvailable (argparse)


# Set the header files.
set (HDR
	"include/dumper.hpp"

	"include/pe/image.hpp"
	"include/pe/section_headers.hpp"
	"include/pe/import_directory.hpp"
	"include/pe/util.hpp"
)

# Set the source files.
set (SRC
	"src/main.cpp"
	"src/dumper.cpp"

	"src/pe/image.cpp"
	"src/pe/section_headers.cpp"
	"src/pe/import_directory.cpp"
)

# Add source to this project's executable.
add_executable (vulkan ${SRC} ${HDR})

# Set the include directories.
target_include_directories(vulkan PRIVATE "include")

# Link project dependencies.
target_link_libraries(vulkan PRIVATE wincpp)
target_link_libraries(vulkan PRIVATE spdlog::spdlog)
target_link_libraries(vulkan PRIVATE argparse)
```

`CMakeSettings.json`:

```json
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x64-Release",
      "generator": "Ninja",
      "configurationType": "RelWithDebInfo",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "variables": []
    }
  ]
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 atrexus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Vulkan

Vulkan restores PE images by dumping them from memory. It was specifically designed for processes protected by dynamic code encryption, implemented by the [hyperion](https://roblox.fandom.com/wiki/Hyperion) and [theia](https://reversingthread.info/index.php/2024/01/10/the-finals-defeating-theia-packer/) anti-tamper solutions. Vulkan can also dump regular images from memory as well as modules loaded by a process.

Vulkan has been tested on [Roblox](https://roblox.com) and [The Finals](https://www.reachthefinals.com/).

## How to use

After downloading the latest version from the [releases](https://github.com/atrexus/vulkan/releases) tab, you can run it from the command line like so:

```
vulkan.exe -p <TARGET_PROCESS> -o <OUTPUT_FILE> --resolve-imports
```

If no output file is specified, the file will be saved to the current working directory.

To view the help message use the `-h` or `--help` option.

### Decryption

As mentioned, Vulkan will continue to query pages of code in the target module untill all `NOACCESS` pages are resolved. Depending on the application, there might always be `NOACCESS` pages so decryption could end in an infinite loop. To terminate the decryption task, you can use the `Ctrl+C` keyboard shortcut (for best results wait until 50% of the module is decrypted).

If you would like to automate termination, you can use the `-d` or `--decryption-factor` option, and provide it with a threshold ranging from `0.0` to `1.0` (again, for best results provide a value of `0.5` or above):
```
vulkan.exe -p <TARGET_PROCESS> --decryption-factor 0.5
```

### Imports

To resolve imports for the main module, you can use the `i` or `--resolve-imports` flag. This will locate the custom IAT and restore the import directory in a new section. This may take a while, depending on how many pages were decrypted. This will have no effect on any modules other than the main one:
```
vulkan.exe -p <TARGET_PROCESS> --resolve-imports
```

## Contributing

If you have anything to contribute to this project, please send a pull request, and I will review it. If you want to contribute but are unsure what to do, check out the [issues](https://github.com/atrexus/vulkan/issues) tab for the latest stuff I need help with.

```

`include/dumper.hpp`:

```hpp
#pragma once

#include <atomic>
#include <map>
#include <memory>
#include <stop_token>
#include <string>
#include <vector>
#include <wincpp/process.hpp>

#include "pe/image.hpp"

namespace vulkan
{
    /// <summary>
    /// The dumper class rebuilds a PE file from a memory dump.
    /// </summary>
    class dumper final
    {
       public:
        /// <summary>
        /// The options for the dumper.
        /// </summary>
        class options final
        {
            std::string _module_name;
            float _target_decryption_factor;
            bool _resolve_imports;

            explicit options( ) noexcept;

           public:
            /// <summary>
            /// The default options for the dumper.
            /// </summary>
            /// <returns>A reference to the default options.</returns>
            static options default_value( ) noexcept;

            /// <summary>
            /// Gets the module name.
            /// </summary>
            std::string_view module_name( ) const noexcept;

            /// <summary>
            /// Sets the module name. This is the name of the module to dump.
            /// </summary>
            options& module_name( std::string_view value ) noexcept;

            /// <summary>
            /// Gets the target decryption factor.
            /// </summary>
            float target_decryption_factor( ) const noexcept;

            /// <summary>
            /// Sets the target decryption factor. This is the factor to use when decrypting the PE.
            /// </summary>
            options& target_decryption_factor( float factor ) noexcept;

            /// <summary>
            /// Gets whether to resolve imports.
            /// </summary>
            bool resolve_imports( ) const noexcept;

            /// <summary>
            /// Sets whether to resolve imports. This option will only work on the main module of the process.
            /// </summary>
            options& resolve_imports( bool value ) noexcept;
        };

       private:
        std::unique_ptr< pe::image > _image = nullptr;

        const wincpp::modules::module_t& _module;

        options _options;

        explicit dumper( const wincpp::modules::module_t& module, const options& options );

        /// <summary>
        /// Gets all imported functions from the modules.
        /// </summary>
        /// <param name="modules">The modules to get the imports from.</param>
        /// <returns>A list of exported functions used in the PE.</returns>
        std::list< std::pair< std::uintptr_t, std::shared_ptr< wincpp::modules::module_t::export_t > > > get_imports(
            const std::vector< std::shared_ptr< wincpp::modules::module_t > >& modules );

       public:
        /// <summary>
        /// Dumps the PE image from memory.
        /// </summary>
        /// <param name="process">The process to dump from.</param>
        /// <param name="options">The options for the dumper.</param>
        /// <param name="stop_token">The associated stop token.</param>
        /// <returns>A resolved PE image.</reru
        static std::unique_ptr< pe::image >
        dump( const std::unique_ptr< wincpp::process_t >& process, const dumper::options& options, std::stop_token stop_token );

        /// <summary>
        /// Resolves all of the sections in the PE file.
        /// </summary>
        /// <param name="stop_token">The associated stop token.</param>
        void resolve_sections( std::stop_token stop_token );

        /// <summary>
        /// Resolves all of the imports in the PE file.
        /// </summary>
        void resolve_imports( const std::vector< std::shared_ptr< wincpp::modules::module_t > >& modules );

        /// <summary>
        /// Saves the dumped PE file to a file.
        /// </summary>
        /// <param name="filepath">The path to save the file to.</param>
        void save_to_file( std::string_view filepath );
    };
}  // namespace vulkan
```

`include/pe/image.hpp`:

```hpp
#pragma once

#include <span>
#include <vector>
#include <wincpp/process.hpp>

#include "pe/import_directory.hpp"
#include "pe/section_headers.hpp"

namespace vulkan::pe
{
    /// <summary>
    /// Represents a PE image.
    /// </summary>
    class image
    {
        mutable std::vector< std::uint8_t > _buffer;
        mutable std::unique_ptr< section_headers > _section_headers;
        mutable std::unique_ptr< import_directory > _import_directory;

        PIMAGE_DOS_HEADER _dos_header = nullptr;
        PIMAGE_NT_HEADERS _nt_headers = nullptr;

        bool _is_valid = false;

        /// <summary>
        /// Computes the checksum of the image.
        /// </summary>
        /// <returns>The checksum of the image.</returns>
        std::uint32_t compute_checksum( ) const noexcept;

       public:
        /// <summary>
        /// Creates a new image from a loaded module.
        /// </summary>
        /// <param name="module">The module.</param>
        explicit image( const wincpp::modules::module_t& module );

        /// <summary>
        /// Returns a reference to the internal buffer.
        /// </summary>
        std::vector< std::uint8_t >& buffer( ) const noexcept;

        /// <summary>
        /// Gets the section headers of the image.
        /// </summary>
        /// <returns>A pointer to the section headers.</returns>
        std::unique_ptr< section_headers >& section_headers( ) const noexcept;

        /// <summary>
        /// Gets the import directory of the image.
        /// </summary>
        /// <returns>A pointer to the import directory.</returns>
        std::unique_ptr< import_directory >& import_directory( ) const noexcept;

        /// <summary>
        /// Gets the data directory of the image.
        /// </summary>
        /// <param name="id">The ID of the data directory.</param>
        /// <returns>The data directory.</returns>
        PIMAGE_DATA_DIRECTORY data_directory( std::uint32_t id ) const noexcept;

        /// <summary>
        /// Adds a new section to the image.
        /// </summary>
        /// <param name="name">The name of the section.</param>
        /// <param name="characteristics">The characteristics of the section.</param>
        /// <param name="data">The data to write to the section.</param>
        /// <returns>The section header.</returns>
        PIMAGE_SECTION_HEADER append_section( const std::string_view name, std::uint32_t characteristics, const std::span< std::uint8_t >& data );

        /// <summary>
        /// Adds a new section to the image.
        /// </summary>
        /// <param name="name">The name of the section.</param>
        /// <param name="characteristics">The characteristics of the section.</param>
        /// <param name="data">The size of the section in bytes.</param>
        /// <returns>The section header.</returns>
        PIMAGE_SECTION_HEADER append_section( const std::string_view name, std::uint32_t characteristics, std::uint32_t size );

        /// <summary>
        /// Extends a section in the image.
        /// </summary>
        /// <param name="name">The name of the section.</param>
        /// <param name="size">The number of bytes to extent by (delta).</param>
        /// <returns>A pointer to the section header.</returns>
        PIMAGE_SECTION_HEADER extend_section( const std::string_view name, std::uint32_t size );

        /// <summary>
        /// Refreshes the current image and its headers.
        /// </summary>
        /// <returns>True if the image is valid, false otherwise.</returns>
        bool refresh( ) noexcept;

        /// <summary>
        /// Converts a relative virtual address to a file offset.
        /// </summary>
        /// <param name="rva">The relative virtual address.</param>
        /// <returns>The file offset.</returns>
        std::uint32_t rva_to_offset( std::uint32_t rva ) const noexcept;

        /// <summary>
        /// Converts a file offset to a relative virtual address.
        /// </summary>
        /// <param name="offset">The file offset.</param>
        /// <returns>A relative virtual address.</returns>
        std::uint32_t offset_to_rva( std::uint32_t offset ) const noexcept;

        /// <summary>
        /// Returns whether the image is valid.
        /// </summary>
        /// <returns>True if the image is valid, false otherwise.</returns>
        constexpr bool is_valid( ) const noexcept
        {
            return _is_valid;
        }

        /// <summary>
        /// Gets the base address of the image.
        /// </summary>
        constexpr std::uintptr_t image_base( ) const noexcept
        {
            return static_cast< std::uintptr_t >( _nt_headers->OptionalHeader.ImageBase );
        }

        /// <summary>
        /// Saves the image to a file.
        /// </summary>
        /// <param name="filepath">The path to save the image to.</param>
        /// <returns>True if the image was saved successfully, false otherwise.</returns>
        bool save_to_file( std::string_view filepath );
    };

}  // namespace vulkan::pe
```

`include/pe/import_directory.hpp`:

```hpp
#pragma once

#include <windows.h>

#include <memory>
#include <string>
#include <tuple>
#include <vector>
#include <unordered_map>

namespace vulkan::pe
{
    class image;

    /// <summary>
    /// The abstract representation of an import directory in a PE image.
    /// </summary>
    class import_directory final
    {
        friend class image;

       public:
        /// <summary>
        /// An abstract representation of an import in the import directory.
        /// </summary>
        struct import_t
        {
            /// <summary>
            /// Creates a new import.
            /// </summary>
            /// <param name="module_name">The name of the module that the import is from.</param>
            /// <param name="import_name">The name of the import.</param>
            /// <param name="iat_rva">The relative virtual address of the import address table.</param>
            explicit import_t( const std::string_view module_name, const std::string_view import_name, std::uintptr_t iat_rva ) noexcept;

            /// <summary>
            /// The name of the module that the import is from.
            /// </summary>
            std::string module_name;

            /// <summary>
            /// The name of the import.
            /// </summary>
            std::string import_name;

            /// <summary>
            /// The relative virtual address of the import address table.
            /// </summary>
            std::uintptr_t iat_rva;
        };

       private:
        std::unordered_map< std::string, std::list< std::shared_ptr< import_t > > > _imports;

        PIMAGE_IMPORT_DESCRIPTOR _import_descriptor = nullptr;
        std::uintptr_t *_iat = nullptr;

        PIMAGE_DATA_DIRECTORY _import_data_directory = nullptr;
        PIMAGE_DATA_DIRECTORY _iat_data_directory = nullptr;

        std::size_t _import_descriptor_count = 0;

        std::size_t _import_section_size = 0;
        std::size_t _api_and_module_names_size = 0;
        std::size_t _iat_size = 0;

        /// <summary>
        /// Creates a new import directory class instance.
        /// </summary>
        explicit import_directory( ) noexcept;

        /// <summary>
        /// Refreshes the import directory.
        /// </summary>
        void refresh( image *img ) noexcept;

        /// <summary>
        /// Calculates the sizes of the import directory.
        /// </summary>
        void calculate_import_sizes( ) noexcept;

       public:
        /// <summary>
        /// Returns the IAT data directory.
        /// </summary>
        PIMAGE_DATA_DIRECTORY iat_data_directory( ) const noexcept;

        /// <summary>
        /// Gets the import data directory.
        /// </summary>
        PIMAGE_DATA_DIRECTORY import_data_directory( ) const noexcept;

        /// <summary>
        /// Returns the imports in the import directory.
        /// </summary>
        const std::list< std::shared_ptr< import_t > > imports( ) noexcept;

        /// <summary>
        /// Clears the import directory.
        /// </summary>
        void clear( ) noexcept;

        /// <summary>
        /// Adds a new import to the import directory.
        /// </summary>
        /// <param name="module_name">The name of the module that the import is from.</param>
        /// <param name="import_name">The name of the import.</param>
        /// <param name="iat_rva">The relative virtual address of the import address table.</param>
        void add( const std::string_view module_name, const std::string_view import_name, std::uintptr_t iat_rva ) noexcept;

        /// <summary>
        /// Recompiles the import directory into a new section.
        /// </summary>
        /// <param name="img">The image the import directory is associated with.</param>
        /// <param name="section_name">The name of the section to recompile to.</param>
        void recompile( image *img, const std::string_view section_name ) noexcept;
    };
}  // namespace vulkan::pe
```

`include/pe/section_headers.hpp`:

```hpp
#pragma once

#include <windows.h>

#include <cstdint>

namespace vulkan::pe
{
    class image;

    /// <summary>
    /// Represents a collection of section headers in a PE image.
    /// </summary>
    class section_headers
    {
        friend class image;

        PIMAGE_NT_HEADERS _nt_headers = nullptr;

        /// <summary>
        /// Creates a new instance of the section headers class.
        /// </summary>
        /// <param name="nt_headers">The NT headers to use.</param>
        explicit section_headers( PIMAGE_NT_HEADERS nt_headers ) noexcept;

        /// <summary>
        /// Fixes the alignment of the section headers.
        /// </summary>
        void realign( ) const noexcept;

       public:
        /// <summary>
        /// Returns the number of sections in the image.
        /// </summary>
        /// <returns>The number of sections.</returns>
        constexpr std::uint16_t count( ) const noexcept
        {
            return _nt_headers->FileHeader.NumberOfSections;
        }

        /// <summary>
        /// Returns the section header at the specified index.
        /// </summary>
        /// <param name="index">The index of the section header.</param>
        /// <returns>The section header.</returns>
        constexpr PIMAGE_SECTION_HEADER at( std::uint16_t index ) const noexcept
        {
            return IMAGE_FIRST_SECTION( _nt_headers ) + index;
        }

        /// <summary>
        /// Returns the section header at the specified index.
        /// </summary>
        /// <param name="index">The index of the section header.</param>
        /// <returns>The section header.</returns>
        constexpr PIMAGE_SECTION_HEADER operator[]( std::uint16_t index ) const noexcept
        {
            return at( index );
        }

        /// <summary>
        /// Returns the last section header in the image.
        /// </summary>
        constexpr PIMAGE_SECTION_HEADER last( ) const noexcept
        {
            return at( count( ) - 1 );
        }

        /// <summary>
        /// Returns the first section header in the image.
        /// </summary>
        constexpr PIMAGE_SECTION_HEADER first( ) const noexcept
        {
            return at( 0 );
        }

        /// <summary>
        /// Appends a section header to the image.
        /// </summary>
        /// <param name="header">The section header to append.</param>
        void append( IMAGE_SECTION_HEADER& header ) const noexcept;

        /// <summary>
        /// Returns the section header with the specified name.
        /// </summary>
        /// <param name="name">The name of the section header.</param>
        /// <returns>The section header.</returns>
        PIMAGE_SECTION_HEADER find( const char* name ) const noexcept;
    };

}  // namespace vulkan::pe
```

`include/pe/util.hpp`:

```hpp
#pragma once

#include <concepts>
#include <cstdint>

namespace vulkan::pe
{
    /// <summary>
    /// Pages are aligned to 4KB on both x86 and x64.
    /// </summary>
    static constexpr std::uint32_t PAGE_SIZE = 0x1000;

    /// <summary>
    /// Aligns a value to the specified alignment.
    /// </summary>
    /// <typeparam name="T">The type of value to align.</typeparam>
    /// <param name="value">The value to align.</param>
    /// <param name="alignment">The alignment.</param>
    /// <returns>The aligned value.</returns>
    template< typename T >
    constexpr __forceinline auto align( T value, std::uint32_t alignment ) noexcept
        requires std::unsigned_integral< T >
    {
        return ( value + alignment - 1 ) & ~static_cast< T >( alignment - 1 );
    }

}  // namespace vulkan::pe
```

`src/dumper.cpp`:

```cpp
#include "dumper.hpp"

#include <spdlog/spdlog.h>

#include <algorithm>
#include <print>
#include <unordered_map>
#include <wincpp/patterns/scanner.hpp>

#undef max

namespace vulkan
{
    dumper::dumper( const wincpp::modules::module_t& module, const dumper::options& options ) : _module( module ), _options( options )
    {
        spdlog::debug( "Module: \"{}\" @ 0x{:X} - {} bytes", _module.name( ), _module.address( ), _module.size( ) );

        _image.reset( new pe::image( _module ) );
    }

    std::list< std::pair< std::uintptr_t, std::shared_ptr< wincpp::modules::module_t::export_t > > > dumper::get_imports(
        const std::vector< std::shared_ptr< wincpp::modules::module_t > >& modules )
    {
        std::list< std::pair< std::uintptr_t, std::shared_ptr< wincpp::modules::module_t::export_t > > > imports;

        // Export map for resolving addresses
        std::unordered_map< std::uintptr_t, std::shared_ptr< wincpp::modules::module_t::export_t > > export_map;

        // Populate the export map
        for ( const auto& module : modules )
        {
            for ( const auto& e : module->exports( ) )
            {
                export_map[ e->address( ) ] = e;
            }
        }

        // Get the .rdata section
        if ( const auto& rdata = _module.fetch_section( ".rdata" ) )
        {
            // Read the entire section
            const auto& buffer = rdata->read( );

            // Iterate over each address in the section
            for ( std::size_t i = 0; i < rdata->size( ); ++i )
            {
                const auto& address = *reinterpret_cast< std::uintptr_t* >( buffer.get( ) + i );

                if ( !address )
                    continue;

                // Check if the address is in the export map
                if ( const auto& e = export_map.find( address ); e != export_map.end( ) )
                    imports.push_back( { address, e->second } );
            }
        }

        return imports;
    }

    std::unique_ptr< pe::image >
    dumper::dump( const std::unique_ptr< wincpp::process_t >& process, const dumper::options& options, std::stop_token stop_token )
    {
        const auto& m = process->module_factory[ options.module_name( ) ];

        std::unique_ptr< dumper > d( new dumper( m, options ) );

        d->resolve_sections( stop_token );

        if ( options.resolve_imports( ) )
            d->resolve_imports( process->module_factory.modules( ) );

        // Refresh the image one last time. This will recalculate the checksum.
        d->_image->refresh( );

        return std::move( d->_image );
    }

    void dumper::resolve_sections( std::stop_token stop_token )
    {
        for ( std::size_t idx = 0; idx < _image->section_headers( )->count( ); ++idx )
        {
            const auto& header = _image->section_headers( )->at( idx );

            const auto& absolute_address = _image->image_base( ) + header->VirtualAddress;
            const auto& name = reinterpret_cast< const char* >( header->Name );

            spdlog::info( "Resolving Section: \"{}\" @ 0x{:X} - {} bytes", name, absolute_address, header->Misc.VirtualSize );

            // We need to read code sections page by page.
            if ( header->Characteristics & IMAGE_SCN_CNT_CODE )
            {
                std::unordered_set< std::uintptr_t > pages_read;
                const auto total_pages = header->Misc.VirtualSize / 0x1000;

                // Before we do anything, fill the buffer with nop instructions.
                std::fill(
                    _image->buffer( ).begin( ) + header->PointerToRawData,
                    _image->buffer( ).begin( ) + header->PointerToRawData + header->SizeOfRawData,
                    0x90 );

                while ( !stop_token.stop_requested( ) && ( pages_read.size( ) < total_pages ) )
                {
                    for ( auto page = 0; page < total_pages; ++page )
                    {
                        const auto page_rva = page * 0x1000;

                        // If we've read this page, skip.
                        if ( pages_read.find( page ) != pages_read.end( ) )
                            continue;

                        const auto& region = *_module.factory[ absolute_address + page_rva ].regions( ).begin( );
                        const auto offset = header->PointerToRawData + page_rva;

                        // If the page is not accessible, skip.
                        if ( !region.protection( ).has( wincpp::memory::protection_t::noaccess_t ) )
                        {
                            if ( const auto& data = _module.factory.read( absolute_address + page_rva, 0x1000 ) )
                            {
                                const auto percent = static_cast< double >( pages_read.size( ) ) / total_pages * 100.0;

                                spdlog::debug(
                                    "Read page @ 0x{:X} ({}/{}) = {:.3f}%", absolute_address + page_rva, pages_read.size( ), total_pages, percent );

                                // Copy the data into the image buffer.
                                std::copy( data.get( ), data.get( ) + 0x1000, _image->buffer( ).begin( ) + offset );

                                // Mark the page as read.
                                pages_read.insert( page );
                                continue;
                            }
                        }
                    }
                }
            }
            else
            {
                if ( const auto& data = _module.factory.read( absolute_address, header->SizeOfRawData ) )
                {
                    // Copy the data into the image buffer.
                    std::copy( data.get( ), data.get( ) + header->SizeOfRawData, _image->buffer( ).begin( ) + header->PointerToRawData );
                    continue;
                }
                else
                {
                    spdlog::error( "Failed to read section: \"{}\". Filling with zeros.", name );
                }

                // Copy zeros into the image buffer.
                std::fill(
                    _image->buffer( ).begin( ) + header->PointerToRawData,
                    _image->buffer( ).begin( ) + header->PointerToRawData + header->SizeOfRawData,
                    0x00 );
            }
        }

        spdlog::debug( "Resolved all sections" );
    }

    void dumper::resolve_imports( const std::vector< std::shared_ptr< wincpp::modules::module_t > >& modules )
    {
        _image->refresh( );

        spdlog::debug( "Collecting all exports..." );

        // Get the imports from the modules
        const auto& imports = get_imports( modules );

        // Build the import pools
        for ( const auto& [ address, imp ] : imports )
        {
            // Add the import to the IAT
            _image->import_directory( )->add( imp->module( )->name( ), imp->name( ), address );
        }

        _image->import_directory( )->recompile( _image.get( ), ".vulkan" );

        // Refresh the image.
        _image->import_directory( )->clear( );
        _image->refresh( );

        // Now we create a map that maps the value of the IAT entries to their IAT entry rva.
        std::unordered_map< std::uintptr_t, std::uintptr_t > iat_map;

        // Iterate over the imports and add them to the map.
        for ( const auto& import : _image->import_directory( )->imports( ) )
        {
            // Read the IAT entry
            const auto& iat_entry = *reinterpret_cast< std::uintptr_t* >( _image->buffer( ).data( ) + _image->rva_to_offset( import->iat_rva ) );

            // Add the IAT entry to the map
            iat_map[ iat_entry ] = import->iat_rva;
        }

        spdlog::debug( "Locating cross references..." );

        struct reference_t
        {
            std::uintptr_t address;
            std::uint32_t offset;
            std::uint32_t len;
        };

        // An immutable list of patterns to search for. The first parameter is the pattern, the second is the offset and length of the relative
        // address. The `address` field is always set to zero, as it gets filled in later.
        const std::list< std::pair< wincpp::patterns::pattern_t, reference_t > > patterns = {
            { wincpp::patterns::pattern_t( "\xFF\x15\x00\x00\x00\x00", "xx????" ), { 0, 2, 6 } },
            { wincpp::patterns::pattern_t( "\x48\xFF\x25\x00\x00\x00\x00", "xx?????" ), { 0, 3, 7 } }
        };

        std::vector< reference_t > references;

        for ( const auto& [ pattern, reference ] : patterns )
        {
            const auto& results =
                wincpp::patterns::scanner::find_all< wincpp::patterns::scanner::algorithm_t::naive_t >( _image->buffer( ), pattern );

            for ( const auto& result : results )
                references.push_back( { result, reference.offset, reference.len } );
        }

        spdlog::debug( "Processing {} cross references", references.size( ) );

        for ( const auto& reference : references )
        {
            // Extract the relative offset from the instruction
            auto offset = reinterpret_cast< std::uint32_t* >( _image->buffer( ).data( ) + reference.address + reference.offset );

            // Compute the absolute address of the call instruction
            const auto next_instruction = reference.address + reference.len;
            const auto& absolute_address = next_instruction + *offset;

            // Dereference the absolute address
            const auto& export_address =
                *reinterpret_cast< std::uintptr_t* >( _image->buffer( ).data( ) + _image->rva_to_offset( absolute_address ) );

            // Quick check to see if the dereferenced address could be a code address
            if ( export_address < 0x00007FF000000000 || export_address > 0x00007FFFFFFFFFFF )
                continue;

            // Check if the old IAT entry is in the IAT map
            if ( const auto& iat_entry = iat_map.find( export_address ); iat_entry != iat_map.end( ) )
            {
                // Get the new IAT entry RVA
                const auto& new_iat_rva = iat_entry->second;

                // Compute the new relative offset
                const auto& new_offset = new_iat_rva - next_instruction;

                // Write the new relative offset
                *offset = new_offset;

                spdlog::debug( "Patched instruction @ 0x{:X} to 0x{:X}", _image->image_base( ) + reference.address, *offset );
            }
        }
    }

    dumper::options::options( ) noexcept : _module_name( ), _target_decryption_factor( 1.0f ), _resolve_imports( false )
    {
    }

    dumper::options dumper::options::default_value( ) noexcept
    {
        return options( );
    }

    std::string_view dumper::options::module_name( ) const noexcept
    {
        return _module_name;
    }

    dumper::options& dumper::options::module_name( std::string_view value ) noexcept
    {
        _module_name = std::string( value );
        return *this;
    }

    float dumper::options::target_decryption_factor( ) const noexcept
    {
        return _target_decryption_factor;
    }

    dumper::options& dumper::options::target_decryption_factor( float factor ) noexcept
    {
        _target_decryption_factor = factor;
        return *this;
    }

    bool dumper::options::resolve_imports( ) const noexcept
    {
        return _resolve_imports;
    }

    dumper::options& dumper::options::resolve_imports( bool value ) noexcept
    {
        _resolve_imports = value;
        return *this;
    }
}  // namespace vulkan
```

`src/main.cpp`:

```cpp
#include "argparse/argparse.hpp"
#include "dumper.hpp"
#include "spdlog/spdlog.h"

std::stop_source stop_source;

/// <summary>
/// The console control handler. Used to terminate the application when CTRL+C or CTRL+BREAK is pressed.
/// </summary>
static BOOL WINAPI console_ctrl_handler( DWORD ctrl_type )
{
    if ( ctrl_type == CTRL_C_EVENT || ctrl_type == CTRL_BREAK_EVENT )
    {
        stop_source.request_stop( );
        return TRUE;
    }

    return FALSE;
}

std::int32_t main( std::int32_t argc, char* argv[] )
{
    spdlog::set_level( spdlog::level::debug );

    argparse::ArgumentParser parser( "vulkan", "2.0.2" );

    parser.add_description(
        "A dumper for processes protected by hyperion. For best results, terminate page decryption when >50% of pages are decrypted.\nYou can "
        "terminate a task with `Ctrl+C`." );
    parser.add_epilog( "for more information, visit: https://github.com/atrexus/vulkan" );

    parser.add_argument( "-p", "--process" ).required( ).help( "the name of the process to dump" );
    parser.add_argument( "-m", "--module" ).help( "the name of the module to dump [default: \"<main-module>\"]" );
    parser.add_argument( "-o", "--output" ).help( "the name of the output file [default: \"<module>\"]" );
    parser.add_argument( "-d", "--decryption-factor" )
        .default_value< float >( 1.0f )
        .scan< 'g', float >( )
        .help( "the decryption factor to use when decrypting the PE" );
    parser.add_argument( "-i", "--resolve-imports" ).flag( ).default_value< bool >( false ).help( "rebuild the import table from scratch" );
    parser.add_argument( "-w", "--wait" ).flag( ).default_value< bool >( false ).help( "wait for the process to start" );

    // Parse the command line arguments
    try
    {
        parser.parse_args( argc, argv );
    }
    catch ( const std::exception& ex )
    {
        spdlog::error( "{}", ex.what( ) );
        return 1;
    }

    // Register the console control handler to terminate the application when CTRL+C or CTRL+BREAK is pressed.
    SetConsoleCtrlHandler( console_ctrl_handler, TRUE );

    try
    {
        std::unique_ptr< wincpp::process_t > process = nullptr;

        const auto& should_wait = parser.get< bool >( "wait" );

        do
        {
            process = wincpp::process_t::open( parser.get< std::string >( "process" ) );

            if ( should_wait )
                std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );

        } while ( !process && should_wait && !stop_source.stop_requested( ) );

        if ( !process )
        {
            spdlog::error( "Failed to open process" );
            return 1;
        }

        auto opts = vulkan::dumper::options::default_value( );

        if ( const auto& m = parser.present< std::string >( "-m" ) )
            opts.module_name( m.value( ) );
        else
            opts.module_name( process->name( ) );

        opts.target_decryption_factor( parser.get< float >( "decryption-factor" ) );
        opts.resolve_imports( parser.get< bool >( "resolve-imports" ) );

        const auto& image = vulkan::dumper::dump( process, opts, stop_source.get_token( ) );

        const auto& output = parser.present< std::string >( "-o" ).value_or( opts.module_name( ).data( ) );

        spdlog::info( "Dumping module: \"{}\" to \"{}\"", opts.module_name( ), output );

        image->save_to_file( output );
    }
    catch ( const std::exception& ex )
    {
        spdlog::error( "An error occurred: {}", ex.what( ) );
        return 1;
    }

    return 0;
}
```

`src/pe/image.cpp`:

```cpp
#include "pe/image.hpp"

#include <fstream>

#include "pe/util.hpp"

namespace vulkan::pe
{
    std::uint32_t image::compute_checksum( ) const noexcept
    {
        std::uint32_t sum = 0;

        const auto data = reinterpret_cast< std::uint32_t* >( _buffer.data( ) );
        const auto size = _buffer.size( ) / sizeof( std::uint32_t );

        for ( std::size_t i = 0; i < size; ++i )
        {
            if ( ( sum += data[ i ] ) > 0xFFFF )
                sum = ( sum & 0xFFFF ) + ( sum >> 0x10 );
        }

        if ( size % sizeof( std::uint32_t ) )
        {
            if ( ( sum += ( static_cast< std::uint16_t >( data[ size - 1 ] ) << 0x8 ) ) > 0xFFFF )
                sum = ( sum & 0xFFFF ) + ( sum >> 0x10 );
        }

        return ~sum;
    }

    image::image( const wincpp::modules::module_t& module )
    {
        _buffer.resize( module.size( ) );

        // The header is the first region in the module.
        const auto& header = *module.regions( ).begin( );
        const auto header_size = header.size( );

        header.read( _buffer.data( ) );

        // Create the import directory.
        _import_directory = std::unique_ptr< pe::import_directory >( new pe::import_directory( ) );

        if ( _is_valid = refresh( ) )
        {
            auto& headers = section_headers( );

            // Because we're mapping the image, we need to set the raw data to the virtual address.
            for ( std::uint16_t i = 0; i < headers->count( ); ++i )
            {
                const auto section = headers->at( i );
                section->PointerToRawData = section->VirtualAddress;
                section->SizeOfRawData = section->Misc.VirtualSize;
            }
        }
    }

    std::vector< std::uint8_t >& image::buffer( ) const noexcept
    {
        return _buffer;
    }

    std::unique_ptr< section_headers >& image::section_headers( ) const noexcept
    {
        return _section_headers;
    }

    std::unique_ptr< import_directory >& image::import_directory( ) const noexcept
    {
        return _import_directory;
    }

    PIMAGE_DATA_DIRECTORY image::data_directory( std::uint32_t id ) const noexcept
    {
        return &_nt_headers->OptionalHeader.DataDirectory[ id ];
    }

    PIMAGE_SECTION_HEADER image::append_section( const std::string_view name, std::uint32_t characteristics, const std::span< std::uint8_t >& data )
    {
        const auto file_alignment = _nt_headers->OptionalHeader.FileAlignment;
        const auto section_alignment = _nt_headers->OptionalHeader.SectionAlignment;

        if ( file_alignment == 0 || section_alignment == 0 )
            return nullptr;

        const auto& aligned_file_size = align< std::uint32_t >( static_cast< std::uint32_t >( data.size( ) ), file_alignment );

        // Create a new section header.
        IMAGE_SECTION_HEADER section_header = { };

        // Copy the name into the section header.
        std::copy( name.begin( ), name.end( ), section_header.Name );

        // Set the virtual size to the size of the data.
        section_header.SizeOfRawData = static_cast< std::uint32_t >( aligned_file_size + data.size( ) );
        section_header.Misc.VirtualSize = static_cast< std::uint32_t >( data.size( ) );

        // Set the characteristics of the section.
        section_header.Characteristics = characteristics;

        const auto& last_section = _section_headers->last( );

        // Set the virtual address and pointer to raw data.
        section_header.VirtualAddress = align( last_section->VirtualAddress + last_section->Misc.VirtualSize, section_alignment );
        section_header.PointerToRawData = align( last_section->PointerToRawData + last_section->SizeOfRawData, file_alignment );

        // Append the section to the raw section headers.
        section_headers( )->append( section_header );

        // Update the image size.
        _nt_headers->OptionalHeader.SizeOfImage += aligned_file_size;

        // Update the NT headers.
        _nt_headers->FileHeader.NumberOfSections += 1;
        _nt_headers->OptionalHeader.SizeOfHeaders += sizeof( section_header );
        _nt_headers->OptionalHeader.SizeOfCode += static_cast< std::uint32_t >( data.size( ) );

        // Insert the data into the buffer.
        _buffer.insert( _buffer.begin( ) + section_header.PointerToRawData, data.begin( ), data.end( ) );

        if ( _is_valid = refresh( ) )
            return _section_headers->last( );

        return nullptr;
    }

    PIMAGE_SECTION_HEADER image::append_section( const std::string_view name, std::uint32_t characteristics, std::uint32_t size )
    {
        std::vector< std::uint8_t > data( size, 0x0 );

        return append_section( name, characteristics, data );
    }

    PIMAGE_SECTION_HEADER image::extend_section( const std::string_view name, std::uint32_t size )
    {
        // Find the section header.
        const auto section = _section_headers->find( name.data( ) );

        if ( !section )
            return nullptr;

        // Get file and section alignment.
        const auto file_alignment = _nt_headers->OptionalHeader.FileAlignment;
        const auto section_alignment = _nt_headers->OptionalHeader.SectionAlignment;

        if ( file_alignment == 0 || section_alignment == 0 )
            return nullptr;

        const auto& old_size = section->SizeOfRawData;

        // Update size of raw data.
        section->SizeOfRawData = align( section->SizeOfRawData + size, file_alignment );

        // Update virtual size.
        section->Misc.VirtualSize = align( section->Misc.VirtualSize + size, section_alignment );

        // Update the image size.
        _nt_headers->OptionalHeader.SizeOfImage = align( _nt_headers->OptionalHeader.SizeOfImage + size, section_alignment );

        std::unique_ptr< std::uint8_t[] > data( new std::uint8_t[ size ] );

        // Insert the data into the buffer.
        _buffer.insert( _buffer.begin( ) + section->PointerToRawData + old_size, data.get( ), data.get( ) + size );

        if ( _is_valid = refresh( ) )
            return section;

        return nullptr;
    }

    bool image::refresh( ) noexcept
    {
        _dos_header = reinterpret_cast< PIMAGE_DOS_HEADER >( _buffer.data( ) );

        if ( _dos_header->e_magic != IMAGE_DOS_SIGNATURE )
            return false;

        _nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS >( _buffer.data( ) + _dos_header->e_lfanew );

        if ( !_nt_headers || _nt_headers->Signature != IMAGE_NT_SIGNATURE )
            return false;

        _section_headers.reset( new pe::section_headers( _nt_headers ) );

        if ( _nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
            return false;

        _import_directory->refresh( this );

        _nt_headers->OptionalHeader.CheckSum = compute_checksum( );

        // Remove the debug directory. It's useless since we don't have the PDB.
        //_nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ] = { 0 };

        return true;
    }

    std::uint32_t image::rva_to_offset( std::uint32_t rva ) const noexcept
    {
        for ( std::uint16_t i = 0; i < _section_headers->count( ); ++i )
        {
            const auto section = _section_headers->at( i );

            if ( rva >= section->VirtualAddress && rva < section->VirtualAddress + section->Misc.VirtualSize )
                return section->PointerToRawData + ( rva - section->VirtualAddress );
        }
        return 0;
    }

    std::uint32_t image::offset_to_rva( std::uint32_t offset ) const noexcept
    {
        for ( std::uint16_t i = 0; i < _section_headers->count( ); ++i )
        {
            const auto section = _section_headers->at( i );

            if ( offset >= section->PointerToRawData && offset < section->PointerToRawData + section->SizeOfRawData )
                return section->VirtualAddress + ( offset - section->PointerToRawData );
        }

        return 0;
    }

    bool image::save_to_file( std::string_view filepath )
    {
        std::ofstream file( filepath.data( ), std::ios::binary );

        if ( !file.is_open( ) )
            return false;

        file.write( reinterpret_cast< const char* >( _buffer.data( ) ), _buffer.size( ) );

        file.close( );

        return true;
    }

}  // namespace vulkan::pe
```

`src/pe/import_directory.cpp`:

```cpp
#include "pe/import_directory.hpp"

#include <spdlog/spdlog.h>

#include "pe/image.hpp"
#include "pe/util.hpp"

namespace vulkan::pe
{
    import_directory::import_directory( ) noexcept
    {
    }

    void import_directory::refresh( image* img ) noexcept
    {
        _import_data_directory = img->data_directory( IMAGE_DIRECTORY_ENTRY_IMPORT );
        _iat_data_directory = img->data_directory( IMAGE_DIRECTORY_ENTRY_IAT );

        _import_descriptor =
            reinterpret_cast< PIMAGE_IMPORT_DESCRIPTOR >( img->buffer( ).data( ) + img->rva_to_offset( _import_data_directory->VirtualAddress ) );

        _iat = reinterpret_cast< std::uintptr_t* >( img->buffer( ).data( ) + img->rva_to_offset( _iat_data_directory->VirtualAddress ) );

        // Parse the import directory
        while ( _import_descriptor->Name )
        {
            // Get the module name
            const auto& module_name = reinterpret_cast< const char* >( img->buffer( ).data( ) + img->rva_to_offset( _import_descriptor->Name ) );

            // Get the import lookup table
            const auto& lookup_table =
                reinterpret_cast< PIMAGE_THUNK_DATA >( img->buffer( ).data( ) + img->rva_to_offset( _import_descriptor->OriginalFirstThunk ) );

            // Get the import address table
            const auto& address_table =
                reinterpret_cast< PIMAGE_THUNK_DATA >( img->buffer( ).data( ) + img->rva_to_offset( _import_descriptor->FirstThunk ) );

            // Iterate over both the lookup and address tables
            for ( std::size_t i = 0; lookup_table[ i ].u1.AddressOfData; ++i )
            {
                // Get the import name
                const auto& import_name =
                    reinterpret_cast< PIMAGE_IMPORT_BY_NAME >( img->buffer( ).data( ) + img->rva_to_offset( lookup_table[ i ].u1.AddressOfData ) )
                        ->Name;

                // Get the IAT RVA
                const auto& iat_rva = static_cast< std::uintptr_t >( _import_descriptor->FirstThunk + ( i * sizeof( std::uintptr_t ) ) );

                // Add the import to the list
                add( module_name, import_name, iat_rva );
            }

            _import_descriptor++;
        }
    }

    void import_directory::calculate_import_sizes( ) noexcept
    {
        _import_section_size = 0;
        _api_and_module_names_size = 0;
        _iat_size = 0;

        // Calculate the sizes of the import directory (add an extra import descriptor for the null terminator)
        _import_descriptor_count = _imports.size( ) + 1;

        for ( const auto& [ module_name, imports ] : _imports )
        {
            // Add the size of the module name
            _api_and_module_names_size += module_name.size( ) + 1;

            for ( const auto& import : imports )
            {
                // Add the size of the import name
                _api_and_module_names_size += sizeof( IMAGE_IMPORT_BY_NAME );
                _api_and_module_names_size += import->import_name.size( ) + 1;

                // Add the import lookup table entry
                _api_and_module_names_size += sizeof( std::uintptr_t );

                // Add the entry size
                _iat_size += sizeof( std::uintptr_t );
            }

            // Add the size of the null terminator
            _api_and_module_names_size += sizeof( std::uintptr_t ) * 2;

            // Add the size of the null terminator
            _iat_size += sizeof( std::uintptr_t );
        }

        // Calculate the size of the import directory
        _import_section_size = _iat_size + _api_and_module_names_size + ( sizeof( IMAGE_IMPORT_DESCRIPTOR ) * _import_descriptor_count );
    }

    PIMAGE_DATA_DIRECTORY import_directory::iat_data_directory( ) const noexcept
    {
        return _iat_data_directory;
    }

    PIMAGE_DATA_DIRECTORY import_directory::import_data_directory( ) const noexcept
    {
        return _import_data_directory;
    }

    const std::list< std::shared_ptr< import_directory::import_t > > import_directory::imports( ) noexcept
    {
        std::list< std::shared_ptr< import_t > > result;

        for ( const auto& [ _, imports ] : _imports )
        {
            for ( const auto& import : imports )
            {
                result.push_back( import );
            }
        }

        return result;
    }

    void import_directory::clear( ) noexcept
    {
        _imports.clear( );
    }

    void import_directory::add( const std::string_view module_name, const std::string_view import_name, std::uintptr_t iat_rva ) noexcept
    {
        auto& import_list = _imports[ module_name.data( ) ];

        // Check if the import already exists
        for ( const auto& import : import_list )
        {
            if ( import->import_name == import_name )
                return;
        }

        import_list.emplace_back( new import_t{ module_name, import_name, iat_rva } );

        // Update the sizes
        calculate_import_sizes( );
    }

    void import_directory::recompile( image* img, const std::string_view section_name ) noexcept
    {
        // Create a new section that will hold the new import directory
        const auto& section = img->append_section( section_name, IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ, _import_section_size );

        // Get the section data
        auto data = img->buffer( ).data( ) + section->PointerToRawData;

        // Set the offsets
        std::size_t iat_offset = 0, offset = _iat_size + _import_descriptor_count * sizeof( IMAGE_IMPORT_DESCRIPTOR );

        // Get the first import descriptor
        auto import_descriptor = reinterpret_cast< PIMAGE_IMPORT_DESCRIPTOR >( data + _iat_size );

        // Iterate over the import pools
        for ( const auto& [ module_name, imports ] : _imports )
        {
            // Set the pointer to the IAT for the current module
            import_descriptor->FirstThunk = section->VirtualAddress + iat_offset;

            // Set the pointer to the lookup table for the current module
            import_descriptor->OriginalFirstThunk = section->VirtualAddress + offset;

            // Get the lookup table for the current module
            auto lookup_table = reinterpret_cast< PIMAGE_THUNK_DATA >( data + offset );

            // Update the offset for the lookup table
            offset += sizeof( IMAGE_THUNK_DATA ) * ( imports.size( ) + 2 );

            // Iterate over the imports in the pool
            for ( const auto& import : imports )
            {
                // Add the IAT entry for the import
                *reinterpret_cast< std::uintptr_t* >( data + iat_offset ) = import->iat_rva;

                // Add the import by name structure
                auto import_by_name = reinterpret_cast< PIMAGE_IMPORT_BY_NAME >( data + offset );

                // Set the hint to 0
                import_by_name->Hint = 0;

                // Set the name of the import
                std::copy( import->import_name.begin( ), import->import_name.end( ), import_by_name->Name );

                // Set the offset for the lookup table
                lookup_table->u1.AddressOfData = section->VirtualAddress + offset;

                // Update the IAT offset
                iat_offset += sizeof( std::uintptr_t );

                // Update the offset for the import by name structure
                offset += sizeof( IMAGE_IMPORT_BY_NAME ) + import->import_name.size( );

                // Update the lookup table
                lookup_table++;
            }

            // Set the name of the import descriptor
            import_descriptor->Name = section->VirtualAddress + offset;

            // Write the module name
            std::copy( module_name.begin( ), module_name.end( ), data + offset );

            // Update the offset for the module name
            offset += module_name.size( ) + 2;

            // Update the IAT offset for the null terminator
            iat_offset += sizeof( std::uintptr_t );

            // Increment the import descriptor
            import_descriptor++;
        }

        // Update the data directories
        _iat_data_directory->VirtualAddress = section->VirtualAddress;
        _iat_data_directory->Size = _iat_size;

        _import_data_directory->VirtualAddress = _iat_data_directory->VirtualAddress + _iat_data_directory->Size;
        _import_data_directory->Size = _import_descriptor_count * sizeof( IMAGE_IMPORT_DESCRIPTOR );
    }

    import_directory::import_t::import_t( const std::string_view module_name, const std::string_view import_name, std::uintptr_t iat_rva ) noexcept
    {
        this->module_name = module_name;
        this->import_name = import_name;
        this->iat_rva = iat_rva;
    }
}  // namespace vulkan::pe
```

`src/pe/section_headers.cpp`:

```cpp
#include "pe/section_headers.hpp"

#include <algorithm>

#include "pe/util.hpp"

#undef max

namespace vulkan::pe
{
    section_headers::section_headers( PIMAGE_NT_HEADERS nt_headers ) noexcept : _nt_headers( nt_headers )
    {
        realign( );
    }

    void section_headers::realign( ) const noexcept
    {
        const auto section_alignment = _nt_headers->OptionalHeader.SectionAlignment;
        const auto file_alignment = _nt_headers->OptionalHeader.FileAlignment;

        for ( std::uint16_t i = 0; i < count( ); ++i )
        {
            auto section = at( i );

            section->VirtualAddress = ( section->VirtualAddress / section_alignment ) * section_alignment;
            section->SizeOfRawData = ( section->SizeOfRawData / file_alignment ) * file_alignment;
        }
    }

    void section_headers::append( IMAGE_SECTION_HEADER& header ) const noexcept
    {
        auto last = at( count( ) );

        std::copy(
            reinterpret_cast< std::uint8_t* >( &header ),
            reinterpret_cast< std::uint8_t* >( &header ) + sizeof( IMAGE_SECTION_HEADER ),
            reinterpret_cast< std::uint8_t* >( last ) );
    }

    PIMAGE_SECTION_HEADER section_headers::find( const char* name ) const noexcept
    {
        for ( std::uint16_t i = 0; i < count( ); ++i )
        {
            const auto section = at( i );

            if ( strcmp( reinterpret_cast< const char* >( section->Name ), name ) == 0 )
                return section;
        }

        return nullptr;
    }
}  // namespace vulkan::pe
```