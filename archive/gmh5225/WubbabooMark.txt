Project Path: arc_gmh5225_WubbabooMark__ku96h9y

Source Tree:

```txt
arc_gmh5225_WubbabooMark__ku96h9y
├── Bin
│   └── Skilla.exe
├── Help
│   ├── ScanClean.png
│   ├── ScanDetect.png
│   ├── SeriousWubbaboo.png
│   └── Settings.png
├── LICENSE
├── README.md
├── Source
│   ├── Skilla.vcxproj
│   ├── Skilla.vcxproj.filters
│   ├── Skilla.vcxproj.user
│   ├── WubbabooMark.sln
│   ├── consts.h
│   ├── global.h
│   ├── hde
│   │   ├── hde32.c
│   │   ├── hde32.h
│   │   ├── hde64.c
│   │   ├── hde64.h
│   │   ├── pstdint.h
│   │   ├── table32.h
│   │   └── table64.h
│   ├── main.cpp
│   ├── minirtl
│   │   ├── _strcat.c
│   │   ├── _strcmp.c
│   │   ├── _strcmpi.c
│   │   ├── _strcpy.c
│   │   ├── _strcpyn.c
│   │   ├── _strend.c
│   │   ├── _strlen.c
│   │   ├── _strncmp.c
│   │   ├── _strncmpi.c
│   │   ├── _strncpy.c
│   │   ├── minirtl.h
│   │   ├── rtltypes.h
│   │   ├── u64tohex.c
│   │   ├── ultohex.c
│   │   └── ultostr.c
│   ├── ntbuilds.h
│   ├── ntcall.asm
│   ├── ntgdi.h
│   ├── ntos.h
│   ├── ntproto.h
│   ├── ntuser.h
│   ├── probes
│   │   ├── bootcfg.cpp
│   │   ├── common.cpp
│   │   ├── debugger.cpp
│   │   ├── handletrace.cpp
│   │   ├── memory.cpp
│   │   ├── modules.cpp
│   │   ├── objects.cpp
│   │   ├── processes.cpp
│   │   ├── reports.cpp
│   │   ├── syscall.cpp
│   │   ├── threads.cpp
│   │   ├── win32k.cpp
│   │   └── winver.cpp
│   ├── probes.cpp
│   ├── probes.h
│   ├── resource.h
│   ├── resource.rc
│   ├── rsrc
│   │   ├── CheckDetection.ico
│   │   ├── CheckFailed.ico
│   │   ├── CheckPassed.ico
│   │   ├── CheckWarning.ico
│   │   ├── CheckWubbaboo.ico
│   │   └── Main.ico
│   ├── skilla.manifest
│   ├── sup.cpp
│   └── sup.h
├── WubbabooMark.sha256
└── appveyor.yml

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 hfiref0x

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# WubbabooMark
## Debugger Anti-Detection Benchmark

[![Build status](https://ci.appveyor.com/api/projects/status/7dc9a2naqdn3ej4y?svg=true)](https://ci.appveyor.com/project/hfiref0x/wubbaboomark)

<img src="https://raw.githubusercontent.com/hfiref0x/WubbabooMark/master/Help/SeriousWubbaboo.png" width="150" />

**WubbabooMark** aimed to detect system anomalies caused by usage of software debuggers or special software designed to hide debuggers presence from debugee by tampering various aspects of system information.

Typical set of debuggers today is actually limited to a few most popular solutions like Ghidra/IDA/OllyDbg/x32+x64dbg/WinDbg and so on. There is a special class of software which aim is to "hide" debugger from being detected by debugee. Usually debugger detection used by another software class - software protectors (e.g. Themida/VMProtect/Obsidium/WinLicense). Sometimes software that counteracts these detections refered as "anti-anti-debug" or whatsoever. Personally I found all this "anti-anti-" kind of annoying because we can continue and it will be anti-anti-anti with all sense lost somewhere in the middle. 

What this class of software actually does is creating a landscape of additional of detection vectors, while some of most notorious in a sake of being able to work compromise operation system components integrity and thus security overall. And all of them, absolutely all of them brings multiple bugs due to inability correctly replicate system mechanics in most cases. Sounds scary? Not much that scary as most of this software users (they are called "reververs/crackers") know what they're doing and doing that on purpose... right? What they actually hiding then if they are largely expanding detection landscape? They work against known or reverse-engineered methods implemented in commercial protectors... sometimes work.

The continious VMProtect (one of the most notorious and long living software protectors) drama generates a lot of lulz so I just can't stay away of it. Since VMProtect recently became "open-sourced" under DGAF license I had an opportunity to look closer on it "anti-" stuff. What it have implemented clearly demonstrates author following mainstream "scene" with little own creativity in some aspects due to limits as commercial product and software support requirements. Direct syscalls, heavens gate? What year is it now? However reinventing this stuff even in 2018 seems have doomed to dead some of this so called "anti-anti" softwares.

Anyway, we have some debuggers, some "tampering tools/plugins" etc, lets see how good they are!

# System Requirements

x64 Windows 10/11 and above.

Anything below Windows 10 is unsupported, *well because it is actually no longer supported by Microsoft*. What a surprise! Forget Windows XP/7 and move on.

A note about Windows 11 preview/dev builds - since this program rely on completely undocumented stuff there can be problems with most recent versions that program doesn't know resulting in false-positives or program unexpected crashes.

# Implemented tests

(a short list, almost each actually does more but for readme technical details are too much)

* Common set of tests
  * Presence of Windows policy allowing custom kernel signers
  * Detection of Windows kernel debugger by NtSystemDebugControl behavior.
  * Check for unnecessary process privileges enablement  
* Process Environment Block (PEB) Loader entries verification
  * Must be all authenticode signed, have valid names
* Loaded Kernel Modules verification
  * Must be all authenticode signed, doesn't include anything from built-in blacklist
  * Detect lazy data tampering
* Blacklisted Driver Device Objects
  * Lookup devices object names in Object Manager namespace and compare them with blacklist
* Windows Version Information
  * Detect l33t and other BS changes
  * Cross-compare version information from several system modules that are in KnownDlls
  * Cross-compare version information from PEB with data obtained through WMI
  * Validate system call (syscall) layout for PEB version
  * Validate system build number acceptable range
* Running Processes
  * Check if process name is in blacklist
  * Cross-compare Native API query result with WMI data to detect hidden from client processes
  * Detect lazy Native API data tampering
  * Check client against console host information
  * Application Compatibility (AppCompat) parent information
* Client Threads
  * Verify that client threads instruction pointers belong to visible modules 
* NTDLL mapping validation
  * Map NTDLL using several methods and cross-compare results
* Examine program stack
  * Find a code that doesn't belong to any loaded module
* Validate Working Set (WS) information
  * Query WS and walk each page looking for suspicious flags
  * Use WS watch and look for page fault data
* Perform Handle Tracing
  * Enable handle tracing for client, perform bait call and examine results
  * Check NtClose misbehavior
* Validate NTDLL syscalls
  * Obtain system call data by various methods, use it and cross-compare results
* Validate WIN32U syscalls
  * Obtain system call data and compare results
* Detect Debugger presence
  * Process Debug Port with indirect syscall
  * Process Debug Handle with indirect syscall
  * Process Debug Flags with indirect syscall
  * DR registers
  * User Shared Data information
* Examine system handle dump
  * Find debug objects and debug handles
  * Detect lazy Native API data tampering
  * Detect client handles with suspicious rights
* Enumerate NtUser objects
  * Walk UserHandleTable to find objects which owners are invisible to client API calls
* Enumerate NtGdi objects
  * Walk GdiSharedHandleTable to find objects which owners are invisible to client API calls 
* Enumerate Boot Configuration Data (That one requires client elevation)
  * Search for option enablements: TestMode, WinPEMode, DisableIntegrityChecks, KernelDebugger
* Scan process memory regions
  * Search for regions with memory executable flags that doesn't belong to any loaded module
 
Program can be configured which tests you want to try. Go to menu "Probes -> Settings", apply changes and start scan. Note settings are saved to registry and read uppon program load.

<img src="https://raw.githubusercontent.com/hfiref0x/WubbabooMark/master/Help/Settings.png" width="600" />

# Output Examples
* Clean scan
<img src="https://raw.githubusercontent.com/hfiref0x/WubbabooMark/master/Help/ScanClean.png" width="600" />

* Wubbaboos found scan
<img src="https://raw.githubusercontent.com/hfiref0x/WubbabooMark/master/Help/ScanDetect.png" width="600" />

# How To Run Test And Don't Ask Questions Next

1. Download or Compile from source "Skilla.exe"
   * If you want to compile yourself: Use Microsoft Visual Studio 2019 and above with recent Windows SDK installed. Compile configuration is "Release", not "Debug".
   * If you want to download precompiled binary it is in Bin folder of this repository.
2. Load your debugger, setup your tampering plugins, load "Skilla.exe".
3. Run the program in debugger and watch output. If something crashed including your debugger - it is your own fault (maybe~).
4. Look for results. Normally there should be nothing detected, literally ZERO wubbaboos in list. 
5. If you want to repeat test - there is no need to restart "Skilla.exe" or repeat (2)(3) - go to menu and use "File -> Scan".

Do you found something that looks like a false-positive or a bug? Feel free to report in issues section!
You can save generated report using "Probes -> Save As ..." menu. File will be saved in comma separated values (CSV) format.

# False positives

Antimalware/anticheat software may cause false positives due to the way these software class works. Make sure you understand what you do. This is not AV/EDR benchmark nor testing tool.

# Driver Bugs

While encountering random BSODs from the best and funniest "super hide" software I was about to make a fuzzer test just because every driver I compiled contained improper handling of syscalls it intercepts. However since authors of these software doesn't care and usage of all these drivers limited to small group of masochists this idea was dropped at early stage. Well what can I say - never use anything from that super hiding stuff on a live machine or you risk to lose your data due to sudden bugcheck.

# Virtual Machine Detection

Not an aim of this tool and will never be added. This tool will work fine with VM.

# Links

Here I would like to put some useful links, enjoy.

Debuggers first!
* x64dbg (https://github.com/x64dbg/x64dbg) - x64 debugger with UI inspired by OllyDbg. Despite being overflown with annoying graphics, questionable features and tons of bugs it is currently one of the best of what we have.
* HexRays IDA (https://hex-rays.com/ida-pro/) - cost a lot, can a lot, everybody have it for free, "F5" is a industry standard in ISV reverse-engineering departments.
* Ghidra SRE from NSA (https://github.com/NationalSecurityAgency/ghidra) - not much to say about it, except it is freeware open-source competitor of the above product.
* WinDbg (https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools) Microsoft user/kernel debugger with support built into operation system. A bit of hardcore for a newcomers but the most powerful as R0 debugger.
* Immunity Debugger (https://www.immunityinc.com/products/debugger/) - Requires Python and doesn't support x64, trash for historical purposes.
* There exist some funny clone of ollydbg+x64dbg with number of different names (cpudbg64, asmdbg32, asmdbg64 - author can't decide) however author attitude demonstrate typical chaos in mind and development not to mention fishing schemes used on project domain. 
* HyperDbg (https://github.com/HyperDbg/HyperDbg) - hypervisor assisted kernel/user mode debugger.
* CheatEngine (https://github.com/cheat-engine/cheat-engine) - you can use it for debugging too, be aware that MSFT hates it, contains driver that is wormhole by design.

Debugger Anti-Detection
* ScyllaHide (https://github.com/x64dbg/ScyllaHide) - an "industry standard" in "anti-anti" software class.
* HyperHide (https://github.com/Air14/HyperHide) - a failed attempt to do something like ScyllaHide but hypervisor assisted.
* StrongOD (https://github.com/shellbombs/StrongOD) - SSDT intercepting driver built with Windows XP era in mind, never use it on a production machine, avoid at all cost.
* TitanHide (https://github.com/mrexodia/TitanHide) - another driver that intercept SSDT services, never use it on a production machine.
* QuickUnpack (https://github.com/fobricia/QuickUnpack) - contains a driver that is able to emulate rdtsc/cpuid instructions using SVM/VMX, never use it on a production machine.
* AntiDebuggerFuxker (https://github.com/AyinSama/Anti-AntiDebuggerDriver) - "InfinityHook" style driver aimed to bypass VMProtect detections, never use it on a production machine and better never use it at all :P
* VirtualDbgHide (https://github.com/Nukem9/VirtualDbgHide) - utilize LSTAR hook, a typical broken "anti-" driver, never use it on a production machine, avoid at all cost.
* ColdHide_V2 (https://github.com/Rat431/ColdHide_V2) - a basic and failed ScyllaHide clone.
* DBGHider (https://github.com/hi-T0day/DBGHider) - IDA plugin that does some trivial things.
* MineDebugHider (https://github.com/zhouzu/MineDebugHider) - C# based trivial API interceptor with invalid anti-detection logic in author mind.
* Themidie (https://github.com/VenTaz/Themidie) - Themida specific hooks based on MHook lib.
* Kernel-Anit-Anit-Debug-Plugins (https://github.com/DragonQuestHero/Kernel-Anit-Anit-Debug-Plugins) - some of them contain driver that do kernel Dbg* functions hooking. Avoid at all cost.
* xdbg (https://github.com/brock7/xdbg) - plugin for x64dbg and CE based on MSFT Detours lib.

Debugger Detection
* al-khaser (https://github.com/LordNoteworthy/al-khaser) - contains basic set of debugger/analysis detection methods.
* AntiDebugger (https://github.com/liltoba/AntiDebugger) - various trash in C#.
* AntiDebugging (https://github.com/revsic/AntiDebugging) - small collection of basic things.
* Anti-Debugging (https://github.com/ThomasThelen/Anti-Debugging) - another collection following P.Ferrie articles.
* Anti-DebugNET (https://github.com/Mecanik/Anti-DebugNET) - basics implemented on C#.
* antidebug (https://github.com/waleedassar/antidebug) - collections of methods from author blogposts.
* AntiDBG (https://github.com/HackOvert/AntiDBG) - collection of recycled known ideas.
* Anti-Debug-Collection (https://github.com/MrakDev/Anti-Debug-Collection) - name says it all.
* aadp (https://github.com/crackinglandia/aadp) - collection of mistakes.
* cpp-anti-debug (https://github.com/BaumFX/cpp-anti-debug) - basics implemented on C++.
* debugoff (https://github.com/0xor0ne/debugoff) - a rare Linux anti-analysis methods collection. Warning - cancerous Rust.
* makin (https://github.com/secrary/makin) - basics mostly following P.Ferrie articles.
* Lycosidae (fork)(https://github.com/fengjixuchui/Lycosidae) - it's soo bad, so it is even good. Original repo seems destroyed by ashamed author.
* khaleesi (fork)(https://github.com/fengjixuchui/khaleesi) - al-khaser with injected code from the Lycosidae and something called "XAntiDebug". Original repo again seems unavailable.
* VMProtect open-source edition, won't give any links to avoid possible DMCA or whatever, you can find it on github under different names.
* Unabomber (https://github.com/Ahora57/Unabomber) - collection of methods that are creatively abusing misbehavior and bugs of anti-detection software. 
* XAntiDebug (https://github.com/strivexjun/XAntiDebug) - few ideas from VMProtect "improved" by author.

Here I should put some links to what is now reinvented wheels about debuggers detection that you can easily find in the world wide web. It is mostly time-machine to where Windows XP was all new and shine.

* Collection of ancient stuff by Checkpoint (https://anti-debug.checkpoint.com/) Unsure where they copied some of these, probably from al-khaser (https://github.com/LordNoteworthy/al-khaser), or vice-versa.
* Peter Ferrie, Anti-Debugging Reference (http://pferrie.epizy.com/papers/antidebug.pdf?i=1) A must put, because literally everyone when you look at references have links to it, so I'm bit ashamed that I've never fully read it, however it must be something good, isn't it?
* Peter Ferrie, Anti-unpacker tricks (https://pferrie.tripod.com/papers/unpackers.pdf) I believe this one is where the above had roots in.
* Peter Ferrie, Anti-unpacker tricks VB series (https://www.virusbulletin.com/virusbulletin/2008/12/anti-unpacker-tricks-part-one) All parts of it I think have more details than above.
* An Anti-Reverse Engineering Guide By Josh Jackson (https://forum.tuts4you.com/files/file/1218-anti-reverse-engineering-guide/) Very ancient just like all the above.
* Enough of this museum.
* Anti Debugging Protection Techniques with Examples (https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software) A more recent combination of known stuff.

# Project Name
Wubbaboo is a mischievous spirit from Cognosphere videogame Honkai Star Rail. It likes to hide in unexpected places and does a lot of pranks just like the software class we are testing.

No wubbaboos were harmed during tests!

# Authors

+ (c) 2023 WubbabooMark Project

# License
MIT

```

`Source/Skilla.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dc386280-e889-49f3-9d16-929d77b106fe}</ProjectGuid>
    <RootNamespace>ScyllaRevealer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Skilla</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <ManifestResourceCompile />
    <Manifest>
      <AdditionalManifestFiles>skilla.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>false</ControlFlowGuard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntelJCCErratum>true</IntelJCCErratum>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <Version>10.0</Version>
      <MinimumRequiredVersion>10.0</MinimumRequiredVersion>
    </Link>
    <ManifestResourceCompile />
    <Manifest>
      <AdditionalManifestFiles>skilla.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="minirtl\u64tohex.c" />
    <ClCompile Include="minirtl\ultohex.c" />
    <ClCompile Include="minirtl\ultostr.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcmp.c" />
    <ClCompile Include="minirtl\_strcmpi.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strend.c" />
    <ClCompile Include="minirtl\_strlen.c" />
    <ClCompile Include="minirtl\_strncmpi.c" />
    <ClCompile Include="minirtl\_strncpy.c" />
    <ClCompile Include="probes.cpp" />
    <ClCompile Include="probes\bootcfg.cpp" />
    <ClCompile Include="probes\common.cpp" />
    <ClCompile Include="probes\debugger.cpp" />
    <ClCompile Include="probes\handletrace.cpp" />
    <ClCompile Include="probes\modules.cpp" />
    <ClCompile Include="probes\objects.cpp" />
    <ClCompile Include="probes\memory.cpp" />
    <ClCompile Include="probes\processes.cpp" />
    <ClCompile Include="probes\reports.cpp" />
    <ClCompile Include="probes\syscall.cpp" />
    <ClCompile Include="probes\threads.cpp" />
    <ClCompile Include="probes\win32k.cpp" />
    <ClCompile Include="probes\winver.cpp" />
    <ClCompile Include="sup.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="consts.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\pstdint.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
    <ClInclude Include="ntgdi.h" />
    <ClInclude Include="ntos.h" />
    <ClInclude Include="ntproto.h" />
    <ClInclude Include="ntuser.h" />
    <ClInclude Include="probes.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="sup.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="ntcall.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc\CheckDetection.ico" />
    <Image Include="rsrc\CheckFailed.ico" />
    <Image Include="rsrc\CheckPassed.ico" />
    <Image Include="rsrc\CheckWarning.ico" />
    <Image Include="rsrc\CheckWubbaboo.ico" />
    <Image Include="rsrc\Main.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Source/Skilla.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="sup.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcmp.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncpy.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcmpi.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="hde\hde64.c">
      <Filter>hde</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\u64tohex.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultohex.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strend.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultostr.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncmpi.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>Headers\minirtl</Filter>
    </ClCompile>
    <ClCompile Include="probes\debugger.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\win32k.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\objects.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="probes\memory.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\syscall.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\winver.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\modules.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\processes.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\bootcfg.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\threads.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\common.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\reports.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
    <ClCompile Include="probes\handletrace.cpp">
      <Filter>Source\probes</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="ntos.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="sup.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>Headers\minirtl</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>Headers\minirtl</Filter>
    </ClInclude>
    <ClInclude Include="hde\hde64.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\pstdint.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\table64.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="ntproto.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="consts.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="probes.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="ntuser.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="ntgdi.h">
      <Filter>Headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{8e62e288-7f95-476f-bed0-a0e700ac6156}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{8bc246d8-304c-4cce-850c-6e5750f4d755}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{23042a57-af4e-487f-901c-7e23ef2a5f92}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\minirtl">
      <UniqueIdentifier>{3400a2ea-2458-4bc4-8a0c-b3625f1dc691}</UniqueIdentifier>
    </Filter>
    <Filter Include="hde">
      <UniqueIdentifier>{27f625dd-6c20-4c2d-aa66-c8eaac60a5e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source\probes">
      <UniqueIdentifier>{0bc73214-ff4a-4ca5-860a-ed6d7eebe01a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resources</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc\CheckFailed.ico">
      <Filter>Resources</Filter>
    </Image>
    <Image Include="rsrc\CheckPassed.ico">
      <Filter>Resources</Filter>
    </Image>
    <Image Include="rsrc\CheckWarning.ico">
      <Filter>Resources</Filter>
    </Image>
    <Image Include="rsrc\CheckDetection.ico">
      <Filter>Resources</Filter>
    </Image>
    <Image Include="rsrc\CheckWubbaboo.ico">
      <Filter>Resources</Filter>
    </Image>
    <Image Include="rsrc\Main.ico">
      <Filter>Resources</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="ntcall.asm">
      <Filter>Source</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Source/Skilla.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/WubbabooMark.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33530.505
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WubbabooMark", "Skilla.vcxproj", "{DC386280-E889-49F3-9D16-929D77B106FE}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DC386280-E889-49F3-9D16-929D77B106FE}.Debug|x64.ActiveCfg = Debug|x64
		{DC386280-E889-49F3-9D16-929D77B106FE}.Debug|x64.Build.0 = Debug|x64
		{DC386280-E889-49F3-9D16-929D77B106FE}.Release|x64.ActiveCfg = Release|x64
		{DC386280-E889-49F3-9D16-929D77B106FE}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3D19A9C5-11AE-48DC-B6A9-0349E0A2CB02}
	EndGlobalSection
EndGlobal

```

`Source/consts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       CONSTS.H
*
*  VERSION:     1.00
*
*  DATE:        30 Jun 2023
*
*  Global consts definition file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define NTQSI_DBG_QUERY (LPWSTR)TEXT("SystemKernelDebuggerInformationEx")
#define NTQIP_PBI_QUERY (LPWSTR)TEXT("ProcessBasicInformation")

#define DT_UNSAFE_CIPOLICY (LPWSTR)TEXT("Unsafe CI Policy")

#define DT_DIRECT_SYSCALL (LPWSTR)TEXT("Direct Syscall")
#define DT_INDIRECT_SYSCALL (LPWSTR)TEXT("Indirect Syscall")
#define DT_INDIRECT_SYSCALL_VEH (LPWSTR)TEXT("Indirect Syscall (VEH)")
#define DT_NTDLL_IMAGEBASE_QUERY (LPWSTR)TEXT("ImageBase Query")
#define DT_NTDLL_SOURCE (LPWSTR)TEXT("NTDLL")

#define DT_SSN_MISMATCH (LPWSTR)TEXT("Syscall Mismatch")
#define DT_SSN_EXTRACTION_DIRECT (LPWSTR)TEXT("Direct Extract")
#define DT_SSN_EXTRACTION_INDIRECT (LPWSTR)TEXT("Indirect Extract")
#define DT_SSN_EXTRACTION_INDIRECT_RUNTIME (LPWSTR)TEXT("Indirect Runtime Extract")
#define DT_SSN_EXTRACTION_THREAD_INFORMATION (LPWSTR)TEXT("Thread Information")
#define DT_SSN_EXTRACTION_INVALID_DATA (LPWSTR)TEXT("Invalid Data")
#define DT_PARENT_MISMATCH (LPWSTR)TEXT("Parent Process")
#define DT_BAD_PROCESS_NAME (LPWSTR)TEXT("Blacklisted Name")

#define DT_SYSCALL_EXTRACT (LPWSTR)TEXT("Syscall")
#define DT_INJECTEDCODE (LPWSTR)TEXT("Injected Code")
#define DT_3RDPARTYCODE (LPWSTR)TEXT("3rd-party Code")
#define DT_BUILDNUMBER (LPWSTR)TEXT("Build Number")
#define DT_WINVERSION (LPWSTR)TEXT("Windows Version")
#define DT_SIGNATURE_INVALID (LPWSTR)TEXT("Invalid Signature")
#define DT_SIGNATURE_VERIFY (LPWSTR)TEXT("Signature Verify")
#define DT_WSSET_FAILED (LPWSTR)TEXT("Working Set")
#define DT_SYSINFO_FAILED (LPWSTR)TEXT("System Info")

#define DT_INVALID_SESSIONID (LPWSTR)TEXT("Invalid SessionId")
#define DT_INVALID_THREADCOUNT (LPWSTR)TEXT("Invalid ThreadCount")
#define DT_SUSPICIOUS_THREAD (LPWSTR)TEXT("Suspicious Thread")

#define DT_ERROR_OPEN_OBJECT (LPWSTR)TEXT("Cannot Open")

#define DT_TYPEINFO_MISMATCH (LPWSTR)TEXT("Type Info")
#define DT_KERNELDEBUGGER (LPWSTR)TEXT("Kernel Debugger")
#define DT_PRIVILEGES (LPWSTR)TEXT("Privileges")
#define DT_DATACORRUPTION (LPWSTR)TEXT("Data Corruption")
#define DT_UNKNOWNCODE (LPWSTR)TEXT("Unknown Code")
#define DT_APPCOMPAT (LPWSTR)TEXT("AppCompat")

#define DT_DRIVER_DEVICE (LPWSTR)TEXT("Driver Device")

#define DT_DEBUGGER_TFLAG_RDTSC (LPWSTR)TEXT("TF RDTSC")
#define DT_DEBUGGER_DRX (LPWSTR)TEXT("Debug Registers")

#define DT_WMIQUERY (LPWSTR)TEXT("WMI Query")
#define DT_HIDDENPROCESS (LPWSTR)TEXT("Hidden Process")
#define DT_USEROBJECT (LPWSTR)TEXT("USER Object")
#define DT_GDIOBJECT (LPWSTR)TEXT("GDI Object")

#define DT_BCDMISMATCH (LPWSTR)TEXT("BCD Mismatch")

#define DT_W32INIT_ERROR (LPWSTR)TEXT("Win32 Init Failed")

#define T_CSV_FILE_FILTER TEXT("CSV Files\0*.csv\0\0")

#define W32K_TABLE_INDEX_BASE 4096

#define PROC_INDEX_QIP 0
#define PROC_INDEX_QIT 1
#define PROC_INDEX_QSI 2
#define PROC_INDEX_SIT 3
#define PROC_INDEX_SIP 4

static LPCSTR g_NtTestSet[] = {
    "NtQueryInformationProcess",
    "NtQueryInformationThread",
    "NtQuerySystemInformation",
    "NtSetInformationThread",
    "NtSetInformationProcess",
    "NtGetContextThread",
    "NtSetContextThread",
    "NtClose",
    "NtDuplicateObject",
    "NtQueryObject",
    "NtOpenFile",
    "NtCreateSection",
    "NtMapViewOfSection",
    "NtQueryVirtualMemory",
    "NtContinue",
    "NtResumeThread",
    "NtCreateThreadEx",
    "NtQueryPerformanceCounter"
};

static LPCSTR g_NtUserTestSet[] = {
    "NtUserGetForegroundWindow",
    "NtUserQueryWindow",
    "NtUserBuildHwndList",
    "NtUserFindWindowEx",
    "NtUserBlockInput"
};

```

`Source/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.00
*
*  DATE:        11 Jun 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#if !defined UNICODE
#error ANSI build is not supported
#endif

#undef VERBOSE_OUTPUT

#define MAX_TEXT_LENGTH 256

//
// Ignored warnings
//
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4091) // 'typedef ': ignored on left of '%s' when no variable is declared
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1920)
#pragma comment(linker,"/merge:_RDATA=.rdata")
#endif
#endif

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "uxtheme.lib")
#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "wintrust.lib")
#pragma comment(lib, "crypt32.lib")

#if defined(__cplusplus)
#include <malloc.h>
#endif

#include <Windows.h>
#include <Windowsx.h>
#include <commctrl.h>
#include <Uxtheme.h>
#include <ShlObj.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <ntstatus.h>
#include <intrin.h>
#include <wbemidl.h> 
#include <oleauto.h>
#include <wintrust.h>


//
// Main window listview.
//
extern HWND hwndList;
extern HWND hwndStatusBar;
extern ULONG g_cAnomalies;

#include "consts.h"
#include "ntos.h"
#include "ntbuilds.h"
#include "ntuser.h"
#include "ntgdi.h"
#include "sup.h"
#include "ntproto.h"
#include "resource.h"
#include "probes.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include "minirtl/minirtl.h"
#include "minirtl/rtltypes.h"
#include "hde/hde64.h"

#ifdef __cplusplus
}
#endif

#define PROGRAM_NAME L"WubbabooMark"
#define SK_VERSION_MAJOR 1
#define SK_VERSION_MINOR 0
#define SK_VERSION_BUILD 2307 

#define PUSH_DISABLE_WARNING(Warning) \
  __pragma(warning(push)) \
  __pragma(warning(disable : Warning))

#define POP_DISABLE_WARNING(Warning) \
  __pragma(warning(pop))

#if defined(__cplusplus)
extern "C" {
#endif

    NTSTATUS SkiDirectSystemCall();
    NTSTATUS SkiIndirectSystemCall();

    extern DWORD KiSystemCallNumber;
    extern ULONG_PTR KiSystemCallAddress;

#ifdef __cplusplus
}
#endif

extern HANDLE gProbeWait;

```

`Source/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void *code, hde32s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde32s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde32s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde32_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde32_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde32_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde32_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde32_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde32_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde32_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (pref & PRE_66) {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
            p += 2;
        } else {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        }
    }

    if (cflags & C_IMM16) {
        if (hs->flags & F_IMM32) {
            hs->flags |= F_IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else if (hs->flags & F_IMM16) {
            hs->flags |= F_2IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
        }
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

```

`Source/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`Source/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"
#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`Source/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`Source/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2015 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`Source/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008, Veacheslav Patkov
 * aLL rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_PREFIXES     0x14d
#define DELTA_FPU_MODRM    0x115
#define DELTA_FPU_REG      0x10e
#define DELTA_OP_LOCK_OK   0x1bf
#define DELTA_OP2_LOCK_OK  0x1d7
#define DELTA_OP_ONLY_MEM  0x1e9
#define DELTA_OP2_ONLY_MEM 0x1f8

unsigned char hde32_table[] = {
  0xa1,0x9b,0xa1,0x9b,0xa1,0x9b,0xa1,0x9b,0xa1,0x9b,0xa1,0x9b,0xa1,0x9b,0xa1,
  0x9b,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9f,0x9d,0xd1,0x9d,0xb2,0xb2,
  0xb2,0xb2,0xc6,0xa1,0xa1,0xf6,0x9d,0x9d,0xc0,0x9d,0xa9,0x9d,0x9b,0x9d,0x98,
  0x98,0xa9,0xa9,0xd4,0xf2,0xd8,0xb9,0xa1,0xb6,0xa1,0xa1,0xb2,0x98,0xaf,0x9d,
  0x9d,0x9f,0x9d,0xfa,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xb4,
  0x95,0x97,0xa0,0x57,0x57,0x57,0x57,0x57,0x9d,0x57,0x57,0x53,0x97,0x9d,0x9d,
  0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0xb8,0x58,0x97,
  0x57,0x63,0x63,0x63,0x63,0x57,0x57,0x57,0x57,0x54,0x9b,0x54,0x81,0x57,0x57,
  0xc0,0x57,0x83,0xbc,0x53,0x53,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,
  0x57,0x57,0x92,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x02,0x02,0x02,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,
  0x00,0x01,0x00,0x03,0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,
  0x20,0x20,0x02,0x02,0x00,0x00,0x02,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x14,
  0x00,0x01,0x01,0x03,0x11,0x03,0x03,0x03,0x03,0x01,0x01,0x01,0x03,0x01,0x10,
  0x11,0x02,0x03,0x03,0x04,0x00,0x06,0x00,0x04,0x00,0x01,0x01,0x01,0xff,0x00,
  0x00,0x00,0xff,0xff,0x03,0x01,0xff,0xff,0xff,0xff,0x01,0x00,0x03,0x00,0x00,
  0xc0,0xc8,0x01,0x01,0xc0,0xc2,0x01,0x01,0x01,0xc4,0x00,0x00,0xc6,0xc8,0xc0,
  0xc2,0x01,0x01,0x03,0xc4,0xc6,0xc8,0x03,0x03,0x03,0xca,0x00,0xff,0xcc,0x01,
  0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,
  0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,
  0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,
  0x00,0x00,0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,
  0x57,0x43,0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,
  0x46,0x40,0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,
  0x01,0x06,0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,
  0x07,0x07,0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,
  0x04,0x04,0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`Source/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`Source/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  CodeName:    Skilla
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE
#include "global.h"

#define CLASSNAME L"WubbabooMarkClass"

// low area height plus the borders
#define BORDERHEIGHT 8
#define BORDRERSPACE 4

//
// Global variables.
//
HANDLE gProbeWait = NULL;
ATOM mainClass = 0;
HWND hwndList = NULL;
HWND hwndStatusBar = NULL;
HINSTANCE thisInstance = NULL;
PROBE_STARTUP_INFO gProbeParams;

/*
* InsertRunAsMainMenuEntry
*
* Purpose:
*
* Insert run as admin/local system menu entry.
*
*/
VOID InsertRunAsMainMenuEntry(
    _In_ HWND hwnd
)
{
    HMENU hMenu;
    SHSTOCKICONINFO sii;

    WCHAR szText[MAX_TEXT_LENGTH];

    if (!supUserIsFullAdmin()) {
        hMenu = GetSubMenu(GetMenu(hwnd), 0);
        InsertMenu(hMenu, 0, MF_BYPOSITION, ID_FILE_RUNASADMIN, TEXT("R&un as Administrator"));
        InsertMenu(hMenu, 1, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

        RtlSecureZeroMemory(&sii, sizeof(sii));
        sii.cbSize = sizeof(sii);
        if (SHGetStockIconInfo(SIID_SHIELD, SHGSI_ICON | SHGFI_SMALLICON, &sii) == S_OK) {
            MENUITEMINFO mii;
            RtlSecureZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_BITMAP | MIIM_DATA;
            mii.hbmpItem = HBMMENU_CALLBACK;
            mii.dwItemData = (ULONG_PTR)sii.hIcon;
            SetMenuItemInfo(hMenu, ID_FILE_RUNASADMIN, FALSE, &mii);
        }
        _strcpy(szText, PROGRAM_NAME);
    }
    else {
        StringCchPrintf(szText,
            RTL_NUMBER_OF(szText),
            TEXT("%ws (Administrator)"),
            PROGRAM_NAME);
    }
    SetWindowText(hwnd, szText);
}

VOID MainWindowOnResize(
    _In_ HWND hwndDlg
)
{
    RECT r, szr;

    RtlSecureZeroMemory(&r, sizeof(RECT));
    RtlSecureZeroMemory(&szr, sizeof(RECT));

    GetClientRect(hwndDlg, &r);
    GetClientRect(hwndStatusBar, &szr);

    SendMessage(hwndStatusBar, WM_SIZE, 0, 0);

    SetWindowPos(hwndList, NULL, BORDRERSPACE, BORDRERSPACE,
        r.right - BORDERHEIGHT,
        r.bottom - szr.bottom - BORDERHEIGHT,
        SWP_NOZORDER);
}

VOID SettingsReadWrite(
    _In_ HWND hwndDlg,
    _In_ BOOL bWrite)
{
    struct SettingsControlMap {
        ULONG FlagControlId;
        ULONG FlagValue;
    };

    SettingsControlMap ctrlMap[] = {
        { IDC_PROBES1, PROBE_FLAGS_COMMON_CHECKS },
        { IDC_PROBES2, PROBE_FLAGS_VERIFY_PEBLDR },
        { IDC_PROBES3, PROBE_FLAGS_VERIFY_LOADED_DRIVERS },
        { IDC_PROBES4, PROBE_FLAGS_CHECK_DEVICE_OBJECTS },
        { IDC_PROBES5, PROBE_FLAGS_VERIFY_WINVER },
        { IDC_PROBES6, PROBE_FLAGS_VALIDATE_PROCLIST },
        { IDC_PROBES7, PROBE_FLAGS_VALIDATE_THREADLIST },
        { IDC_PROBES8, PROBE_FLAGS_VALIDATE_NTDLLCOPIES },
        { IDC_PROBES9, PROBE_FLAGS_STACKWALK },
        { IDC_PROBES10, PROBE_FLAGS_WSSETWALK },
        { IDC_PROBES11, PROBE_FLAGS_WSSETWATCH },
        { IDC_PROBES12, PROBE_FLAGS_HANDLETRACING },
        { IDC_PROBES13, PROBE_FLAGS_CHECK_NTOS_SYSCALLS },
        { IDC_PROBES14, PROBE_FLAGS_CHECK_WIN32K_SYSCALLS },
        { IDC_PROBES15, PROBE_FLAGS_CHECK_DEBUG },
        { IDC_PROBES16, PROBE_FLAGS_CHECK_HANDLES },
        { IDC_PROBES17, PROBE_FLAGS_WALK_USERHADLETABLE },
        { IDC_PROBES18, PROBE_FLAGS_WALK_GDISHAREDHADLETABLE },
        { IDC_PROBES19, PROBE_FLAGS_CHECK_BCD },
        { IDC_PROBES20, PROBE_FLAGS_CHECK_PROCESS_MEMORY }
    };

    PROBE_SETTINGS probeSettings;
    WCHAR szErrorMsg[MAX_TEXT_LENGTH];

    if (bWrite) {

        probeSettings.Flags = 0;

        for (ULONG i = 0; i < RTL_NUMBER_OF(ctrlMap); i++) {
            if (IsDlgButtonChecked(hwndDlg, ctrlMap[i].FlagControlId)) {
                probeSettings.Flags |= ctrlMap[i].FlagValue;
            }
        }
      
        if (!supWriteConfiguration(&probeSettings)) {
                       
            StringCchPrintf(szErrorMsg,
                RTL_NUMBER_OF(szErrorMsg),
                TEXT("There is an error with code %lu while saving probes settings"),
                GetLastError());

            MessageBox(hwndDlg, szErrorMsg, PROGRAM_NAME, MB_ICONINFORMATION);
        }
    }
    else {

        if (!supReadConfiguration(&probeSettings)) {

            StringCchPrintf(szErrorMsg,
                RTL_NUMBER_OF(szErrorMsg),
                TEXT("There is an error with code %lu while reading probes settings, default will be used"),
                GetLastError());

            MessageBox(hwndDlg, szErrorMsg, PROGRAM_NAME, MB_ICONINFORMATION);
        }

        for (ULONG i = 0; i < RTL_NUMBER_OF(ctrlMap); i++) {
            CheckDlgButton(hwndDlg, ctrlMap[i].FlagControlId,
                (probeSettings.Flags & ctrlMap[i].FlagValue) ?
                BST_CHECKED : BST_UNCHECKED);
        }
    }
}

INT_PTR CALLBACK SettingsDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        SettingsReadWrite(hwndDlg, FALSE);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            return EndDialog(hwndDlg, ERROR_CANCELLED);
        case IDOK:
            SettingsReadWrite(hwndDlg, TRUE);
            return EndDialog(hwndDlg, ERROR_SUCCESS);
        }

    }
    return 0;
}

INT_PTR CALLBACK AboutDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    LITEM item;
    PNMLINK pNMLink;

    switch (uMsg) {

    case WM_NOTIFY:

        switch (((LPNMHDR)lParam)->code) {
        case NM_CLICK:
        case NM_RETURN:

            pNMLink = (PNMLINK)lParam;
            item = pNMLink->item;
            if ((((LPNMHDR)lParam)->hwndFrom == GetDlgItem(hwndDlg, IDC_SYSLINK))
                && (item.iLink == 0))
            {
                supShellExecInExplorerProcess(item.szUrl, NULL);
            }

            break;
        }

        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
        case IDOK:
            return EndDialog(hwndDlg, S_OK);
        }

    }
    return 0;
}

VOID MainWindowSetViewReady()
{
    HIMAGELIST hImageList;
    LVCOLUMNS_DATA columnData[] =
    {
        { (LPWSTR)TEXT("Event"), 360, LVCFMT_LEFT,  I_IMAGENONE },
        { (LPWSTR)TEXT("Description"), 200, LVCFMT_LEFT, I_IMAGENONE },
        { (LPWSTR)TEXT("Anomaly Type"), 150, LVCFMT_LEFT, I_IMAGENONE }
    };

    hImageList = supLoadImageList(thisInstance);

    supSetListViewSettings(hwndList,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        TRUE,
        hImageList,
        LVSIL_SMALL);

    supAddLVColumnsFromArray(
        hwndList,
        columnData,
        RTL_NUMBER_OF(columnData));

    WCHAR szText[200];

    LARGE_INTEGER startTime;
    TIME_FIELDS systemTime;

    GetSystemTimeAsFileTime((LPFILETIME)&startTime);
    FileTimeToLocalFileTime((PFILETIME)&startTime, (PFILETIME)&startTime);
    RtlTimeToTimeFields((PLARGE_INTEGER)&startTime, (PTIME_FIELDS)&systemTime);

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        L"%ws v%lu.%lu.%lu, started at %02hd.%02hd.%04hd %02hd:%02hd:%02hd",
        PROGRAM_NAME,
        SK_VERSION_MAJOR,
        SK_VERSION_MINOR,
        SK_VERSION_BUILD,
        systemTime.Day,
        systemTime.Month,
        systemTime.Year,
        systemTime.Hour,
        systemTime.Minute,
        systemTime.Second);

    supReportEvent(evtInformation,
        szText,
        NULL,
        NULL);
}

LRESULT CALLBACK MainWindowProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    switch (uMsg) {

    case WM_MEASUREITEM:

        LPMEASUREITEMSTRUCT pms;

        pms = (LPMEASUREITEMSTRUCT)lParam;
        if (pms && pms->CtlType == ODT_MENU) {
            pms->itemWidth = 16;
            pms->itemHeight = 16;
        }
        break;

    case WM_DRAWITEM:

        LPDRAWITEMSTRUCT pds;

        pds = (LPDRAWITEMSTRUCT)lParam;
        if (pds && pds->CtlType == ODT_MENU) {
            DrawIconEx(pds->hDC, pds->rcItem.left - 15,
                pds->rcItem.top,
                (HICON)pds->itemData,
                16, 16, 0, NULL, DI_NORMAL);
        }
        break;

    case WM_CLOSE:
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        MainWindowOnResize(hwnd);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case ID_FILE_SCAN:
            gProbeParams.IsFirstRun = FALSE;
            gProbeParams.MainWindow = hwnd;
            supReadConfiguration(&gProbeParams.Settings);
            SkStartProbe(&gProbeParams);
            break;

        case ID_HELP_ABOUT:
            DialogBoxParam(thisInstance, MAKEINTRESOURCE(IDD_ABOUT), hwnd, AboutDialogProc, 0);
            break;

        case IDCANCEL:
        case ID_FILE_EXIT:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case ID_PROBES_SAVETOFILE:
            supListViewExportToFile(TEXT("probes.csv"), hwnd, hwndList);
            break;

        case ID_PROBES_SETTINGS:
            DialogBoxParam(thisInstance, MAKEINTRESOURCE(IDD_SETTINGS), hwnd, SettingsDialogProc, 0);
            break;

        case ID_FILE_RUNASADMIN:
            supRunAsAdmin();
            break;

        }
        break;

    case WM_ACTIVATE:
    case WM_SETFOCUS:
        SetFocus(hwndList);
        break;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD RunMainDialog()
{
    HWND hwndMain;
    WNDCLASSEX wndClass;
    BOOL bResult;
    MSG message;
    INITCOMMONCONTROLSEX iccx;

    thisInstance = GetModuleHandle(NULL);

    gProbeWait = CreateMutex(NULL, FALSE, NULL);
    if (gProbeWait == NULL)
        return GetLastError();

    iccx.dwSize = sizeof(iccx);
    iccx.dwICC = ICC_LISTVIEW_CLASSES | ICC_LINK_CLASS;
    if (!InitCommonControlsEx(&iccx))
        return GetLastError();

    RtlSecureZeroMemory(&wndClass, sizeof(WNDCLASSEX));
    wndClass.cbSize = sizeof(WNDCLASSEX);
    wndClass.style = 0;
    wndClass.lpfnWndProc = &MainWindowProc;
    wndClass.cbClsExtra = 0;
    wndClass.cbWndExtra = DLGWINDOWEXTRA;
    wndClass.hInstance = thisInstance;

    wndClass.hIcon = (HICON)LoadImage(
        thisInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN),
        IMAGE_ICON,
        0,
        0,
        LR_SHARED);

    wndClass.hCursor = (HCURSOR)LoadImage(
        NULL,
        MAKEINTRESOURCE(OCR_NORMAL),
        IMAGE_CURSOR,
        0,
        0,
        LR_SHARED);

    wndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wndClass.lpszMenuName = NULL;
    wndClass.lpszClassName = CLASSNAME;
    wndClass.hIconSm = 0;

    mainClass = RegisterClassEx(&wndClass);
    if (mainClass == 0)
        return GetLastError();

    hwndMain = CreateDialogParam(thisInstance,
        MAKEINTRESOURCE(IDD_MAINDIALOG), NULL, MainWindowProc, 0);

    if (hwndMain) {

        hwndList = GetDlgItem(hwndMain, IDC_LIST);
        hwndStatusBar = GetDlgItem(hwndMain, IDC_STATUSBAR);
        MainWindowSetViewReady();

        ShowWindow(hwndMain, SW_SHOW);
        SendMessage(hwndMain, WM_SIZE, 0, 0);
        UpdateWindow(hwndMain);
        InsertRunAsMainMenuEntry(hwndMain);

        gProbeParams.IsFirstRun = TRUE;
        gProbeParams.MainWindow = hwndMain;
        supReadConfiguration(&gProbeParams.Settings);
        SkStartProbe(&gProbeParams);

        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (!IsDialogMessage(hwndMain, &message)) {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);

    }
    else {
        return GetLastError();
    }

    UnregisterClass(CLASSNAME, thisInstance);

    return 0;
}

INT EntryPoint()
{
    NTSTATUS ntStatus;
    DWORD exitProcessCode;

    RtlSetUnhandledExceptionFilter(supUnhandledExceptionFilter);
    HeapSetInformation(NtCurrentPeb()->ProcessHeap, HeapEnableTerminationOnCorruption, NULL, 0);
    supSetMitigationPolicies();
    supCacheKnownDllsEntries();       
    ntStatus = supInitializeKnownSids();
    if (!NT_SUCCESS(ntStatus)) {
        exitProcessCode = ntStatus;
    }
    else {
        exitProcessCode = RunMainDialog();
    }
    return exitProcessCode;
}

#if !defined(__cplusplus)
#pragma comment(linker, "/ENTRY:main")
void main()
{
    __security_init_cookie();
    ExitProcess(EntryPoint());

}
#else
#pragma comment(linker, "/ENTRY:WinMain")
int CALLBACK WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR     lpCmdLine,
    _In_ int       nCmdShow
)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    ExitProcess(EntryPoint());
}
#endif

```

`Source/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`Source/minirtl/_strcmp.c`:

```c
#include "rtltypes.h"

int _strcmp_a(const char *s1, const char *s2)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmp_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t	c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/minirtl/_strcmpi.c`:

```c
#include "rtltypes.h"

int _strcmpi_a(const char *s1, const char *s2)
{
	char c1, c2;
	
	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmpi_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`Source/minirtl/_strcpyn.c`:

```c
#include "rtltypes.h"

char *_strcpyn_a(char* dest, const char* src, size_t n)
{
    size_t i = 0;
    char *p;

    if ((dest == 0) || (src == 0))
        return dest;

    p = dest;

    while (i++ != n && (*p++ = *src++));

    *p = 0;

    return dest;
}

wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n)
{
    size_t i = 0;
    wchar_t *p;

    if ((dest == 0) || (src == 0))
        return dest;

    p = dest;

    while (i++ != n && (*p++ = *src++));

    *p = 0;

    return dest;
}

```

`Source/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`Source/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`Source/minirtl/_strncmp.c`:

```c
#include "rtltypes.h"

int _strncmp_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/minirtl/_strncmpi.c`:

```c
#include "rtltypes.h"

int _strncmpi_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/minirtl/_strncpy.c`:

```c
#include "rtltypes.h"

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc)
{
	char *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc)
{
	wchar_t *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

```

`Source/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	4 Oct 2020
*/

#pragma once

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

char *_strcpyn_a(char* dest, const char* src, size_t n);
wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

char *_strchr_a(const char *s, const char ch);
wchar_t *_strchr_w(const wchar_t *s, const wchar_t ch);


// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w
#define _strcpyn _strcpyn_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w
#define _strchr _strchr_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define _strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcpyn _strcpyn_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a
#define _strchr _strchr_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define _strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`Source/minirtl/rtltypes.h`:

```h
#pragma once

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`Source/minirtl/u64tohex.c`:

```c
#include "rtltypes.h"

size_t u64tohex_a(unsigned long long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c=0; c<16; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

size_t u64tohex_w(unsigned long long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c = 0; c<16; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

```

`Source/minirtl/ultohex.c`:

```c
#include "rtltypes.h"

size_t ultohex_a(unsigned long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

size_t ultohex_w(unsigned long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

```

`Source/minirtl/ultostr.c`:

```c
#include "rtltypes.h"

size_t ultostr_a(unsigned long x, char *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t ultostr_w(unsigned long x, wchar_t *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`Source/ntbuilds.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2023
*
*  TITLE:       NTBUILDS.H
*
*  VERSION:     1.16
*
*  DATE:        15 May 2023
*
*  Windows NT builds definition file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Defines for Major Windows NT release builds
//

// Windows 7 RTM
#define NT_WIN7_RTM             7600

// Windows 7 SP1
#define NT_WIN7_SP1             7601

// Windows 8 RTM
#define NT_WIN8_RTM             9200

// Windows 8.1
#define NT_WIN8_BLUE            9600

// Windows 10 TH1
#define NT_WIN10_THRESHOLD1     10240

// Windows 10 TH2
#define NT_WIN10_THRESHOLD2     10586

// Windows 10 RS1
#define NT_WIN10_REDSTONE1      14393

// Windows 10 RS2
#define NT_WIN10_REDSTONE2      15063

// Windows 10 RS3
#define NT_WIN10_REDSTONE3      16299

// Windows 10 RS4
#define NT_WIN10_REDSTONE4      17134

// Windows 10 RS5
#define NT_WIN10_REDSTONE5      17763

// Windows 10 19H1
#define NT_WIN10_19H1           18362

// Windows 10 19H2
#define NT_WIN10_19H2           18363

// Windows 10 20H1
#define NT_WIN10_20H1           19041

// Windows 10 20H2
#define NT_WIN10_20H2           19042

// Windows 10 21H1
#define NT_WIN10_21H1           19043

// Windows 10 21H2
#define NT_WIN10_21H2           19044

// Windows 10 22H2
#define NT_WIN10_22H2           19045

// Windows Server 2022
#define NT_WINSRV_21H1          20348

// Windows 11 21H2
#define NT_WIN11_21H2           22000

// Windows 11 22H2
#define NT_WIN11_22H2           22621

// Windows 11 Active Develepment Branch (23H2)
#define NTX_WIN11_ADB_DEV       23451
#define NTX_WIN11_ADB           25351 //canary

```

`Source/ntcall.asm`:

```asm
;*******************************************************************************
;
;  (C) COPYRIGHT AUTHORS, 2023
;
;  TITLE:       NTCALL.ASM
;
;  VERSION:     1.00
;
;  DATE:        20 Jun 2023
;
;  NT system call stubs, x64.
;
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
; ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
; TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
; PARTICULAR PURPOSE.
;
;*******************************************************************************/

_DATA$00 SEGMENT PARA 'DATA'

PUBLIC KiSystemCallNumber
PUBLIC KiSystemCallAddress

KiSystemCallAddress label qword
	dq  0
KiSystemCallNumber label dword
	dd  0

_DATA$00 ENDS

_TEXT$00 segment para 'CODE'

	ALIGN 16
	PUBLIC SkiDirectSystemCall
	PUBLIC SkiIndirectSystemCall

SkiDirectSystemCall PROC
	mov r10, rcx
	mov eax, KiSystemCallNumber
	syscall
	ret
SkiDirectSystemCall ENDP

SkiIndirectSystemCall PROC
	mov r10, rcx
	mov eax, KiSystemCallNumber
	jmp qword ptr [KiSystemCallAddress]
SkiIndirectSystemCall ENDP

_TEXT$00 ENDS
	
END

```

`Source/ntgdi.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2023
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTGDI.H
*
*  VERSION:     1.07
*
*  DATE:        15 Jun 2023
*
*  Common header file for the NtGdi API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*                 NtOs.h
*
*  Include:       Windows.h
*                 NtStatus.h
*                 NtOs.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTGDI_RTL
#define NTGDI_RTL



#define GDI_HANDLE_TO_INDEX(h) (DWORD)((ULONG_PTR)h & 0x0000ffff)

#define DEF_TYPE            0
#define DC_TYPE             1
#define UNUSED1_TYPE        2   // Unused
#define UNUSED2_TYPE        3   // Unused
#define RGN_TYPE            4
#define SURF_TYPE           5
#define CLIENTOBJ_TYPE      6
#define PATH_TYPE           7
#define PAL_TYPE            8
#define ICMLCS_TYPE         9
#define LFONT_TYPE          10
#define RFONT_TYPE          11
#define PFE_TYPE            12
#define PFT_TYPE            13
#define ICMCXF_TYPE         14
#define SPRITE_TYPE         15
#define BRUSH_TYPE          16
#define UMPD_TYPE           17
#define UNUSED4_TYPE        18  // Unused
#define SPACE_TYPE          19
#define UNUSED5_TYPE        20  // Unused
#define META_TYPE           21
#define EFSTATE_TYPE        22
#define UNUSED6_TYPE        23  // Unused
#define UNUSED7_TYPE        24  // Unused
#define UNUSED8_TYPE        25  // Unused
#define UNUSED9_TYPE        26  // Unused
#define UNUSED10_TYPE       27  // Unused
#define DRVOBJ_TYPE         28
#define UNUSED11_TYPE       29  // Unused
#define SPOOL_TYPE          30
#define MAX_TYPE            30 

#define GDI_INDEX_BITS         16
#define GDI_TYPE_BITS           5
#define GDI_ALTTYPE_BITS        2
#define GDI_STOCK_BITS          1
#define GDI_UNIQUE_BITS         8

#define GDI_TYPE_SHIFT          (GDI_INDEX_BITS)
#define GDI_ALTTYPE_SHIFT       (GDI_TYPE_SHIFT + GDI_TYPE_BITS)
#define GDI_STOCK_SHIFT         (GDI_ALTTYPE_SHIFT + GDI_ALTTYPE_BITS)

#define ALTTYPE1            (1 << ALTTYPE_SHIFT)
#define ALTTYPE2            (2 << ALTTYPE_SHIFT)
#define ALTTYPE3            (3 << ALTTYPE_SHIFT)

#define LO_BRUSH_TYPE       (BRUSH_TYPE     << GDI_TYPE_SHIFT)
#define LO_DC_TYPE          (DC_TYPE        << GDI_TYPE_SHIFT)
#define LO_BITMAP_TYPE      (SURF_TYPE      << GDI_TYPE_SHIFT)
#define LO_PALETTE_TYPE     (PAL_TYPE       << GDI_TYPE_SHIFT)
#define LO_FONT_TYPE        (LFONT_TYPE     << GDI_TYPE_SHIFT)
#define LO_REGION_TYPE      (RGN_TYPE       << GDI_TYPE_SHIFT)
#define LO_ICMLCS_TYPE      (ICMLCS_TYPE    << GDI_TYPE_SHIFT)
#define LO_CLIENTOBJ_TYPE   (CLIENTOBJ_TYPE << GDI_TYPE_SHIFT)

#define LO_ALTDC_TYPE       (LO_DC_TYPE        | ALTTYPE1)
#define LO_PEN_TYPE         (LO_BRUSH_TYPE     | ALTTYPE1)
#define LO_EXTPEN_TYPE      (LO_BRUSH_TYPE     | ALTTYPE2)
#define LO_DIBSECTION_TYPE  (LO_BITMAP_TYPE    | ALTTYPE1)
#define LO_METAFILE16_TYPE  (LO_CLIENTOBJ_TYPE | ALTTYPE1)
#define LO_METAFILE_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE2)
#define LO_METADC16_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE3)

typedef ULONG W32PID;
typedef UCHAR OBJTYPE;

typedef union _EINFO {
    PVOID pobj;
    PVOID hFree;
} EINFO;

#define OBJECT_OWNER_ERROR   (0x80000022)
#define OBJECT_OWNER_PUBLIC  (0x00000000)
#define OBJECT_OWNER_CURRENT (0x80000002)
#define OBJECT_OWNER_NONE    (0x80000012)

typedef struct _OBJECTOWNER_S {
    ULONG Lock : 1;
    W32PID Pid_Shifted : 31;
}OBJECTOWNER_S, * POBJECTOWNER_S;

typedef union _OBJECTOWNER {
    OBJECTOWNER_S Share;
    ULONG ulObj;
}OBJECTOWNER, * POBJECTOWNER;

typedef struct _GDI_HANDLE_ENTRY {
    EINFO einfo;
    OBJECTOWNER ObjectOwner;
    USHORT FullUnique;
    UCHAR Objt;
    UCHAR Flags;
    PVOID pUser;
} GDI_HANDLE_ENTRY, * PGDI_HANDLE_ENTRY;

#define LOCK_MASK 0x00000001
#define PID_MASK  0xfffffffe

#define PID_BITS 0xfffffffc
#define OBJECTOWNER_PID(ObjectOwner) \
    ((W32PID) ((ObjectOwner).ulObj & PID_MASK))

// entry.Flags flags

#define HMGR_ENTRY_UNDELETABLE      0x0001
#define HMGR_ENTRY_LAZY_DEL         0x0002
#define HMGR_ENTRY_INVALID_VIS      0x0004
#define HMGR_ENTRY_LOOKASIDE_ALLOC  0x0010

#define GDI_MAX_HANDLE_COUNT_V1 0x4000
#define GDI_MAX_HANDLE_COUNT_V2 0xFFFF
#define GDI_MAX_HANDLE_COUNT GDI_MAX_HANDLE_COUNT_V2

typedef struct _GDI_SHARED_MEMORY {
    GDI_HANDLE_ENTRY aentryHmgr[GDI_MAX_HANDLE_COUNT];
    //incomplete
} GDI_SHARED_MEMORY, * PGDI_SHARED_MEMORY;

#pragma warning(pop)

#endif NTGDI_RTL

```

`Source/ntos.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2023 
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.218
*
*  DATE:        13 Jul 2023
*
*  Common header file for the ntos API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*
*  Include:       Windows.h
*                 NtStatus.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTOS_RTL
#define NTOS_RTL

//
// NTOS_RTL HEADER BEGIN
//

//
// Enable LIST_ENTRY macroses.
//
#define NTOS_ENABLE_LIST_ENTRY_MACRO

#if defined(__cplusplus)

#ifndef MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
#endif

extern "C" {
#endif

#pragma comment(lib, "ntdll.lib")

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI //poi-poi
#define POI(addr) *(ULONG *)(addr)
#endif

typedef char CCHAR;
typedef unsigned char UCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;
typedef ULONG CLONG;
typedef LONG KPRIORITY;
typedef short CSHORT;
typedef ULONGLONG REGHANDLE, *PREGHANDLE;
typedef PVOID *PDEVICE_MAP;
typedef PVOID PHEAD;
typedef PVOID PEJOB;
typedef struct _IO_TIMER* PIO_TIMER;
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
typedef struct _EJOB* PESILO;

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef PVOID PMEM_EXTENDED_PARAMETER;
#endif

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && \
            ((ULONG_PTR)(x) <= (ULONG_PTR)(Base) + (ULONG_PTR)(Size)))
#endif

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentThreadEffectiveToken() ((HANDLE)(LONG_PTR)-6) //GetCurrentThreadEffectiveToken

enum _KPROCESSOR_MODE {
    KernelMode = 0,
    UserMode,
    MaximumMode
};

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#ifndef RTL_CONSTANT_OBJECT_ATTRIBUTES
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }
#endif

// This synonym is more appropriate for initializing what isn't actually const.
#ifndef RTL_INIT_OBJECT_ATTRIBUTES
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)
#endif

//
// ntdef.h end
//
#ifndef RtlOffsetToPointer
#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#endif

#ifndef RtlPointerToOffset
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L

#define OBJ_PROTECT_CLOSE                   0x00000001L
#define OBJ_AUDIT_OBJECT_CLOSE              0x00000004L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// CompositionSurface Access Rights
//
#ifndef COMPOSITIONSURFACE_READ
#define COMPOSITIONSURFACE_READ         0x0001L
#endif

#ifndef COMPOSITIONSURFACE_WRITE
#define COMPOSITIONSURFACE_WRITE        0x0002L
#endif

#ifndef COMPOSITIONSURFACE_ALL_ACCESS
#define COMPOSITIONSURFACE_ALL_ACCESS   (COMPOSITIONSURFACE_READ | COMPOSITIONSURFACE_WRITE)
#endif

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#ifndef EVENT_QUERY_STATE
#define EVENT_QUERY_STATE       0x0001
#endif

#ifndef EVENT_MODIFY_STATE      //SDK compatibility
#define EVENT_MODIFY_STATE      0x0002  
#endif

#ifndef EVENT_ALL_ACCESS        //SDK compatibility
#define EVENT_ALL_ACCESS(EVENT_QUERY_STATE | EVENT_MODIFY_STATE | STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)
#endif

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#ifndef MUTANT_QUERY_STATE      //SDK compatibility
#define MUTANT_QUERY_STATE      0x0001
#endif

#ifndef MUTANT_ALL_ACCESS //SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Filter Port Access Rights
//
#define FLT_PORT_CONNECT 0x0001
#define FLT_PORT_ALL_ACCESS (FLT_PORT_CONNECT|STANDARD_RIGHTS_ALL)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#ifndef SEMAPHORE_QUERY_STATE       //SDK compatibility
#define SEMAPHORE_QUERY_STATE       0x0001
#endif

#ifndef SEMAPHORE_MODIFY_STATE      //SDK compatibility
#define SEMAPHORE_MODIFY_STATE      0x0002 
#endif

#ifndef SEMAPHORE_ALL_ACCESS //SDK compatibility
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|SEMAPHORE_QUERY_STATE|SEMAPHORE_MODIFY_STATE)
#endif

//
// Time Object Access rights
//
#ifndef TIMER_QUERY_STATE
#define TIMER_QUERY_STATE 0x0001
#endif

#ifndef TIMER_MODIFY_STATE
#define TIMER_MODIFY_STATE 0x0002
#endif

#ifndef TIMER_ALL_ACCESS
#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|TIMER_QUERY_STATE|TIMER_MODIFY_STATE)
#endif

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY 0x0001
#define SYMBOLIC_LINK_SET   0x0002
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)
#define SYMBOLIC_LINK_ALL_ACCESS_EX (STANDARD_RIGHTS_REQUIRED | 0xFFFF)

//
// Thread Object Access Rights
//
#define THREAD_ALERT   (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020
#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE   0x00000040
#define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER       0x0001
#define WORKER_FACTORY_WAIT                 0x0002
#define WORKER_FACTORY_SET_INFORMATION      0x0004
#define WORKER_FACTORY_QUERY_INFORMATION    0x0008
#define WORKER_FACTORY_READY_WORKER         0x0010
#define WORKER_FACTORY_SHUTDOWN             0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_LOG_EVENT            0x0200 // used on Vista and greater
#define TRACELOG_CREATE_INPROC        0x0200 // used pre-Vista
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800
#define TRACELOG_JOIN_GROUP           0x1000

//
// Memory Partition Object Access Rights
//
#ifndef MEMORY_PARTITION_QUERY_ACCESS
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)
#endif

//
// Define special ByteOffset parameters for read and write operations
//
#ifndef FILE_WRITE_TO_END_OF_FILE
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#endif
#ifndef FILE_USE_FILE_POINTER_POSITION
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe
#endif

#ifndef FILE_SHARE_VALID_FLAGS
#define FILE_SHARE_VALID_FLAGS FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE
#endif

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#ifndef MAXUSHORT
#define MAXUSHORT   0xffff     
#endif
#ifndef MAX_USTRING
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )
#endif

typedef struct _EX_RUNDOWN_REF {
    union
    {
        ULONG Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

typedef struct _EX_FAST_REF {
    union {
        PVOID Object;
#if defined (_WIN64)
        ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
        ULONG_PTR Value;
    };
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;
typedef CONST char *PCSZ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#ifndef INTERFACE_TYPE
typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    ACPIBus,
    MaximumInterfaceType
} INTERFACE_TYPE, * PINTERFACE_TYPE;
#endif

/*
** FileCache and MemoryList START
*/

typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

typedef struct _SYSTEM_FILECACHE_INFORMATION {
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

/*
** FileCache and MemoryList END
*/

/*
** Processes START
*/

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef enum _THREAD_STATE {
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
    Executive = 0,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair, //has no effect after 7
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    WrIoRing,
    WrMdlCache,
    MaximumWaitReason
} KWAIT_REASON;

typedef VOID KSTART_ROUTINE(
    _In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID64 {
    ULONG64 UniqueProcess;
    ULONG64 UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

typedef struct _CLIENT_ID32 {
    ULONG32 UniqueProcess;
    ULONG32 UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} VM_COUNTERS;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebBase;
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryDelta;
    ULONG ThreadCount;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD_INFORMATION Threads[1]; //not a part of this structure
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry,
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

typedef struct _PROCESS_DISK_COUNTERS {
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

typedef union _ENERGY_STATE_DURATION {
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES {
    ULONGLONG Cycles[2][4];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset;
    PROCESS_ENERGY_VALUES EnergyValues;
    ULONG AppIdOffset;
    SIZE_T SharedCommitCharge;
    ULONG JobObjectId;
    ULONG SpareUlong;
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

typedef struct _SYSTEM_PROCESS_FULL_INFORMATION {
    SYSTEM_PROCESS_INFORMATION ProcessAndThreads;
    SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
} SYSTEM_PROCESS_FULL_INFORMATION, *PSYSTEM_PROCESS_FULL_INFORMATION;

typedef struct _SYSTEM_PROCESS_ID_INFORMATION {
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN EncryptionKeyAvailable : 1;
    BOOLEAN SpareFlags : 2;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN HvciDisableAllowed : 1;
    BOOLEAN SpareFlags2 : 6;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION { //chappell
    ULONGLONG ProcessorFeatureBits;
    ULONGLONG Reserved[3];
} SYSTEM_PROCESSOR_FEATURES_INFORMATION, * PSYSTEM_PROCESSOR_FEATURES_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, * PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
    SIZE_T TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, * PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOLTAG {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, * PSYSTEM_POOLTAG;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_POOLTAG_INFORMATION {
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_POOLTAG_INFORMATION, * PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_SESSION_POOLTAG_INFORMATION, * PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    UNICODE_STRING FirmwarePartition; // \Device\HarddiskX
} SYSTEM_FIRMWARE_PARTITION_INFORMATION, * PSYSTEM_FIRMWARE_PARTITION_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
    PCHAR SymbolicBackTrace;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[32];
} RTL_PROCESS_BACKTRACE_INFORMATION, * PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[1];
} RTL_PROCESS_BACKTRACES, * PRTL_PROCESS_BACKTRACES;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessConsoleHostProcess = 49, //ProcessOwnerInformation
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessActivityThrottleState = 77,
    ProcessActivityThrottlePolicy = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 94,
    ProcessCombineSecurityDomainsInformation = 95,
    ProcessEnableLogging = 96,
    ProcessLeapSecondInformation = 97,
    ProcessFiberShadowStackAllocation = 98,
    ProcessFreeFiberShadowStackAllocation = 99,
    ProcessAltSystemCallInformation = 100,
    ProcessDynamicEHContinuationTargets = 101,
    ProcessDynamicEnforcedCetCompatibleRanges = 102,
    ProcessCreateStateChange = 103,
    ProcessApplyStateChange = 104,
    ProcessEnableOptionalXStateFeatures = 105,
    ProcessAltPrefetchParam = 106,
    ProcessAssignCpuPartitions = 107,
    ProcessPriorityClassEx = 108,
    ProcessMembershipInformation = 109,
    ProcessEffectiveIoPriority = 110,
    ProcessEffectivePagePriority = 111,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context,
    ThreadGroupInformation,
    ThreadUmsInformation,
    ThreadCounterProfiling,
    ThreadIdealProcessorEx,
    ThreadCpuAccountingInformation,
    ThreadSuspendCount,
    ThreadHeterogeneousCpuPolicy,
    ThreadContainerId,
    ThreadNameInformation,
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,
    ThreadActualGroupAffinity,
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation,
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory,
    ThreadPowerThrottlingState,
    ThreadWorkloadClass,
    ThreadCreateStateChange,
    ThreadApplyStateChange,
    ThreadStrongerBadHandleChecks,
    ThreadEffectiveIoPriority,
    ThreadEffectivePagePriority,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// taken from ph2(whatever)
typedef struct _THREAD_LAST_SYSCALL_INFORMATION {
    PVOID FirstArgument;
    USHORT SystemCallNumber;
#ifdef WIN64
    USHORT Pad[0x3]; // since REDSTONE2
#else
    USHORT Pad[0x1]; // since REDSTONE2
#endif
    ULONG64 WaitTime;
} THREAD_LAST_SYSCALL_INFORMATION, * PTHREAD_LAST_SYSCALL_INFORMATION;

typedef struct _THREAD_NAME_INFORMATION {
    UNICODE_STRING ThreadName;
} THREAD_NAME_INFORMATION, * PTHREAD_NAME_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

typedef enum _PROCESS_STATE_CHANGE_TYPE {
    ProcessStateChangeSuspend,
    ProcessStateChangeResume,
    ProcessStateChangeMax,
} PROCESS_STATE_CHANGE_TYPE, *PPROCESS_STATE_CHANGE_TYPE;

typedef enum _THREAD_STATE_CHANGE_TYPE {
    ThreadStateChangeSuspend,
    ThreadStateChangeResume,
    ThreadStateChangeMax,
} THREAD_STATE_CHANGE_TYPE, *PTHREAD_STATE_CHANGE_TYPE;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//
typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS,
    PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION,
    PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES,
    PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY,
    PS_MITIGATION_OPTION_REDIRECTION_TRUST
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE {
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName,
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO {
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        struct
        {
            HANDLE FileHandle;
        } FailSection;

        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1;
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

typedef struct _PS_ATTRIBUTE {
    ULONG Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

#define PS_PROTECTED_SIGNER_MASK 0xFF
#define PS_PROTECTED_AUDIT_MASK 0x08
#define PS_PROTECTED_TYPE_MASK 0x07

// from ph2
#define PsProtectedValue(aSigner, aAudit, aType) ( \
    (((aSigner) & PS_PROTECTED_SIGNER_MASK) << 4) | \
    (((aAudit) & PS_PROTECTED_AUDIT_MASK) << 3) | \
    ((aType) & PS_PROTECTED_TYPE_MASK)\
    )

#define InitializePsProtection(aProtectionLevelPtr, aSigner, aAudit, aType) { \
    (aProtectionLevelPtr)->Signer = aSigner; \
    (aProtectionLevelPtr)->Audit = aAudit; \
    (aProtectionLevelPtr)->Type = aType; \
    }

typedef struct _PS_PROTECTION {
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

typedef enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess,
    PsAttributeDebugPort,
    PsAttributeToken,
    PsAttributeClientId,
    PsAttributeTebAddress,
    PsAttributeImageName,
    PsAttributeImageInfo,
    PsAttributeMemoryReserve,
    PsAttributePriorityClass,
    PsAttributeErrorMode,
    PsAttributeStdHandleInfo,
    PsAttributeHandleList,
    PsAttributeGroupAffinity,
    PsAttributePreferredNode,
    PsAttributeIdealProcessor,
    PsAttributeUmsThread,
    PsAttributeMitigationOptions,
    PsAttributeProtectionLevel,
    PsAttributeSecureProcess,
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,
    PsAttributeAllApplicationPackagesPolicy,
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeChpe,
    PsAttributeMitigationAuditOptions,
    PsAttributeMachineType,
    PsAttributeComponentFilter,
    PsAttributeEnableOptionalXStateFeatures,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_OBJECT \
    PsAttributeValue(PsAttributeDebugObject, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHPE \
    PsAttributeValue(PsAttributeChpe, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_MITIGATION_AUDIT_OPTIONS \
    PsAttributeValue(PsAttributeMitigationAuditOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_MACHINE_TYPE \
    PsAttributeValue(PsAttributeMachineType, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_COMPONENT_FILTER \
    PsAttributeValue(PsAttributeComponentFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ENABLE_OPTIONAL_XSTATE_FEATURES \
    PsAttributeValue(PsAttributeEnableOptionalXStateFeatures, TRUE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE {
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, * PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, * PPROCESS_HANDLE_TRACING_ENABLE_EX;

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

#define PROCESS_HANDLE_TRACE_TYPE_OPEN      1
#define PROCESS_HANDLE_TRACE_TYPE_CLOSE     2
#define PROCESS_HANDLE_TRACE_TYPE_BADREF    3

typedef struct _PROCESS_HANDLE_TRACING_ENTRY {
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, * PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY {
    HANDLE Handle;
    ULONG TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, * PPROCESS_HANDLE_TRACING_QUERY;

typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, * PPROCESS_WS_WATCH_INFORMATION;

typedef struct _PROCESS_WS_WATCH_INFORMATION_EX {
    PROCESS_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;
} PROCESS_WS_WATCH_INFORMATION_EX, * PPROCESS_WS_WATCH_INFORMATION_EX;

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
    ULONG Version;
    ULONG Reserved;
    PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, * PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

/*
** Processes END
*/

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemVsmProtectionInformation = 169, //ex SystemDmaProtectionInformation
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    SystemSecurityModelInformation = 208,
    SystemCodeIntegritySyntheticCacheInformation = 209,
    SystemFeatureConfigurationInformation = 210,
    SystemFeatureConfigurationSectionInformation = 211,
    SystemFeatureUsageSubscriptionInformation = 212,
    SystemSecureSpeculationControlInformation = 213,
    SystemSpacesBootInformation = 214,
    SystemFwRamdiskInformation = 215,
    SystemWheaIpmiHardwareInformation = 216,
    SystemDifSetRuleClassInformation = 217,
    SystemDifClearRuleClassInformation = 218,
    SystemDifApplyPluginVerificationOnDriver = 219,
    SystemDifRemovePluginVerificationOnDriver = 220,
    SystemShadowStackInformation = 221,
    SystemBuildVersionInformation = 222,
    SystemPoolLimitInformation = 223,
    SystemCodeIntegrityAddDynamicStore = 224,
    SystemCodeIntegrityClearDynamicStores = 225,
    SystemDifPoolTrackingInformation = 226,
    SystemPoolZeroingInformation = 227,
    SystemDpcWatchdogInformation = 228,
    SystemDpcWatchdogInformation2 = 229,
    SystemSupportedProcessorArchitectures2 = 230,
    SystemSingleProcessorRelationshipInformation = 231,
    SystemXfgCheckFailureInformation = 232,
    SystemIommuStateInformation = 233,
    SystemHypervisorMinrootInformation = 234,
    SystemHypervisorBootPagesInformation = 235,
    SystemPointerAuthInformation = 236,
    SystemSecureKernelDebuggerInformation = 237,
    SystemOriginalImageFeatureInformation = 238,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_VSM_PROTECTION_INFORMATION {
    CHAR DmaProtectionsAvailable;
    CHAR DmaProtectionsInUse;
    CHAR HardwareMbecAvailable;
    CHAR ApicVirtualizationAvailable;
} SYSTEM_VSM_PROTECTION_INFORMATION, * PSYSTEM_VSM_PROTECTION_INFORMATION;

//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION_V2 {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
    union {
        ULONG Flags2;
        struct {
            ULONG SbdrSsdpHardwareProtected : 1;
            ULONG FbsdpHardwareProtected : 1;
            ULONG PsdpHardwareProtected : 1;
            ULONG FbClearEnabled : 1;
            ULONG FbClearReported : 1;
            ULONG Reserved : 27;
        } SpeculationControlFlags2;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION_V2, * PSYSTEM_SPECULATION_CONTROL_INFORMATION_V2;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1;
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        } KvaShadowFlags;
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000
#define CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED     0x4000
#define CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED       0x8000

typedef struct _HV_DETAILS {
    ULONG Data[4];
} HV_DETAILS, * PHV_DETAILS;

typedef struct _HV_VENDOR_AND_MAX_FUNCTION {
    ULONG MaxFunction;
    CHAR VendorName[12];
} HV_VENDOR_AND_MAX_FUNCTION, * PHV_VENDOR_AND_MAX_FUNCTION;

typedef struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    HV_DETAILS HvVendorAndMaxFunction;
    HV_DETAILS HypervisorInterface;
    HV_DETAILS HypervisorVersion;
    HV_DETAILS HvFeatures;
    HV_DETAILS HwFeatures;
    HV_DETAILS EnlightenmentInfo;
    HV_DETAILS ImplementationLimits;
} SYSTEM_HYPERVISOR_DETAIL_INFORMATION, * PSYSTEM_HYPERVISOR_DETAIL_INFORMATION;

typedef struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    BOOLEAN HypervisorConnected;
    BOOLEAN HypervisorDebuggingEnabled;
    BOOLEAN HypervisorPresent;
    BOOLEAN Spare0[5];
    ULONGLONG EnabledEnlightenments;
} SYSTEM_HYPERVISOR_QUERY_INFORMATION, * PSYSTEM_HYPERVISOR_QUERY_INFORMATION;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

/*
** Boot Entry START
*/

typedef struct _FILE_PATH {
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST {
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

/*
** Boot Entry END
*/

/*
** File start
*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileObjectIdInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileAttributeTagInformation,
    FileTrackingInformation,
    FileIdBothDirectoryInformation,
    FileIdFullDirectoryInformation,
    FileValidDataLengthInformation,
    FileShortNameInformation,
    FileIoCompletionNotificationInformation,
    FileIoStatusBlockRangeInformation,
    FileIoPriorityHintInformation,
    FileSfioReserveInformation,
    FileSfioVolumeInformation,
    FileHardLinkInformation,
    FileProcessIdsUsingFileInformation,
    FileNormalizedNameInformation,
    FileNetworkPhysicalNameInformation,
    FileIdGlobalTxDirectoryInformation,
    FileIsRemoteDeviceInformation,
    FileUnusedInformation,
    FileNumaNodeInformation,
    FileStandardLinkInformation,
    FileRemoteProtocolInformation,
    FileRenameInformationBypassAccessCheck,
    FileLinkInformationBypassAccessCheck,
    FileVolumeNameInformation,
    FileIdInformation,
    FileIdExtdDirectoryInformation,
    FileReplaceCompletionInformation,
    FileHardLinkFullIdInformation,
    FileIdExtdBothDirectoryInformation,
    FileDispositionInformationEx,
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation,
    FileStatInformation,
    FileMemoryPartitionInformation,
    FileStatLxInformation,
    FileCaseSensitiveInformation,
    FileLinkInformationEx,
    FileLinkInformationExBypassAccessCheck,
    FileStorageReserveIdInformation,
    FileCaseSensitiveInformationForceAccessCheck,
    FileKnownFolderInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsDriverPathInformation,
    FileFsVolumeFlagsInformation,
    FileFsSectorSizeInformation,
    FileFsDataCopyInformation,
    FileFsMetadataSizeInformation,
    FileFsFullSizeInformationEx,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    UCHAR DeletePending;
    UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


typedef struct _FILE_PIPE_INFORMATION {
    ULONG ReadMode;
    ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
    ULONG NamedPipeType;
    ULONG NamedPipeConfiguration;
    ULONG MaximumInstances;
    ULONG CurrentInstances;
    ULONG InboundQuota;
    ULONG ReadDataAvailable;
    ULONG OutboundQuota;
    ULONG WriteQuotaAvailable;
    ULONG NamedPipeState;
    ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
    LARGE_INTEGER CollectDataTime;
    ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG         VolumeSerialNumber;
    ULONG         VolumeLabelLength;
    BOOLEAN       SupportsObjects;
    WCHAR         VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

/*
** File END
*/

/*
** Section START
*/

typedef enum _SECTION_INFORMATION_CLASS {
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation,
    SectionOriginalBaseInformation,
    SectionInternalImageInformation,
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFO {
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _MI_EXTRA_IMAGE_INFORMATION {
    ULONG SizeOfHeaders;
    ULONG SizeOfImage;
} MI_EXTRA_IMAGE_INFORMATION, *PMI_EXTRA_IMAGE_INFORMATION;

typedef struct _MI_SECTION_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION ExportedImageInformation;
    MI_EXTRA_IMAGE_INFORMATION InternalImageInformation;
} MI_SECTION_IMAGE_INFORMATION, *PMI_SECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG ImageCetShadowStacksReady : 1; // 20H1
            ULONG ImageXfgEnabled : 1; // 20H2
            ULONG ImageCetShadowStacksStrictMode : 1;
            ULONG ImageCetSetContextIpValidationRelaxedMode : 1;
            ULONG ImageCetDynamicApisAllowInProc : 1;
            ULONG ImageCetDowngradeReserved1 : 1;
            ULONG ImageCetDowngradeReserved2 : 1;
            ULONG Reserved : 24;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, * PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED          0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE      0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE           0x800000     
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE         0x1000000     
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE       0x4000000     
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000     
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE      0x10000000     
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL       0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES  0x80000000    
#endif

/*
** Section END
*/

/*
** System Table START
*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    ULONG_PTR Base; //e.g. KiServiceTable
    PULONG Count;
    ULONG Limit;//e.g. KiServiceLimit
    PUCHAR Number; //e.g. KiArgumentTable
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
/*
** System Table END
*/

/*
** System Boot Environment START
*/

// Size=20
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    union
    {
        ULONGLONG BootFlags;
        struct
        {
            ULONGLONG DbgMenuOsSelection : 1; // RS4
            ULONGLONG DbgHiberBoot : 1;
            ULONGLONG DbgSoftBoot : 1;
            ULONGLONG DbgMeasuredLaunch : 1;
            ULONGLONG DbgMeasuredLaunchCapable : 1; // 19H1
            ULONGLONG DbgSystemHiveReplace : 1;
            ULONGLONG DbgMeasuredLaunchSmmProtections : 1;
            ULONGLONG DbgMeasuredLaunchSmmLevel : 7; // 20H1
        };
    };
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

/*
** System Boot Environment END
*/

/*
** Key START
*/

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    KeyHandleTagsInformation,
    KeyTrustInformation,
    KeyLayerInformation,
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    KeySetHandleTagsInformation,
    KeySetLayerInformation,
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

/*
** Key END
*/


/*
** TIME_FIELDS START
*/

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

/*
** TIME_FIELDS END
*/

/*
** HANDLE START
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

/*
** HANDLE END
*/

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY_ENTRY {
    PVOID ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _EX_PUSH_LOCK {
    union {
        struct {
            ULONG_PTR Locked : 1;
            ULONG_PTR Waiting : 1;
            ULONG_PTR Waking : 1;
            ULONG_PTR MultipleShared : 1;
            ULONG_PTR Shared : sizeof(ULONG_PTR) * 8 - 4;
        };
        ULONG_PTR Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    union {
        struct {
            ULONG Expanded : 1;
            ULONG Transitioning : 1;
            ULONG Pageable : 1;
        };
        ULONG Value;
    };
} EX_PUSH_LOCK_AUTO_EXPAND_STATE, *PEX_PUSH_LOCK_AUTO_EXPAND_STATE; /* size: 0x0004 */

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND {
    EX_PUSH_LOCK LocalLock;
    EX_PUSH_LOCK_AUTO_EXPAND_STATE State;
    ULONG Stats;
} EX_PUSH_LOCK_AUTO_EXPAND, *PEX_PUSH_LOCK_AUTO_EXPAND; /* size: 0x0010 */

typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    ULONG NumberOfPrivateSpaces;
} OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

typedef struct _OBJECT_NAMESPACE_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID NamespaceRootDirectory;
    ULONG SizeOfBoundaryInformation;
    ULONG Reserved;
    UCHAR HashValue;
    ULONG_PTR Alignment;
} OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

typedef enum _BOUNDARY_ENTRY_TYPE {
    OBNS_Invalid = 0,
    OBNS_Name = 1,
    OBNS_SID = 2,
    OBNS_IntegrityLabel = 3
} BOUNDARY_ENTRY_TYPE;

typedef struct _OBJECT_BOUNDARY_ENTRY {
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    ULONG Reserved;
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_DIRECTORY_V2 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
    LONG Padding[1];
} OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

typedef struct _OBJECT_DIRECTORY_V3 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    PVOID NamespaceEntry;
    PVOID SessionObject;
    ULONG Flags;
    ULONG SessionId;
} OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
    LIST_ENTRY TypeList; // Size=16 Offset=0
    PVOID CreatorUniqueProcess; // Size=8 Offset=16
    USHORT CreatorBackTraceIndex; // Size=2 Offset=24
    USHORT Reserved; // Size=2 Offset=26
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
    PVOID Process; // Size=8 Offset=0
    struct
    {
        unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
        unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
    };
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
    union {
        PVOID HandleCountDataBase; // Size=8 Offset=0
        struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
    PVOID ExclusiveProcess; // Size=8 Offset=0
    PVOID Reserved; // Size=8 Offset=8
} OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge; //4
    ULONG NonPagedPoolCharge; //4 
    ULONG SecurityDescriptorCharge; //4
    PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
    unsigned __int64 Reserved; //sizeof(uint64)
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_PADDING_INFO {
    ULONG PaddingAmount;
} OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

typedef struct _OBJECT_HEADER_AUDIT_INFO {
    PVOID SecurityDescriptor;
    PVOID Reserved;
} OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

typedef struct _OBJECT_HEADER_EXTENDED_INFO {
    struct _OBJECT_FOOTER *Footer;
    PVOID Reserved;
} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

typedef struct _OB_HANDLE_REVOCATION_BLOCK
{
    LIST_ENTRY RevocationInfos;
    struct _EX_PUSH_LOCK Lock;
    struct _EX_RUNDOWN_REF Rundown;
} OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
    LIST_ENTRY ListEntry;
    OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
    unsigned char Padding1[4];
    unsigned char Padding2[4];
} OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

typedef struct _QUAD {
    union {
        INT64 UseThisFieldToCopy;
        float DoNotUseThisField;
    };
} QUAD, *PQUAD;

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    PVOID RootDirectory;
    CHAR ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PVOID SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
    void* ClientToken;
    UCHAR DirectlyAccessClientToken;
    UCHAR DirectAccessEffectiveOnly;
    UCHAR ServerIsRemote;
    struct _TOKEN_CONTROL ClientTokenControl;
    LONG __PADDING__[1];
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER_COMPATIBLE, *POBJECT_TYPE_INITIALIZER_COMPATIBLE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_COMPATIBLE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
} OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;
typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

//
// Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
//

typedef struct _OBJECT_TYPE_INITIALIZER_7 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_7, *POBJECT_TYPE_INITIALIZER_7;

//
// Windows 8, new object type flag, WaitObject* members added
//
typedef struct _OBJECT_TYPE_INITIALIZER_8 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_8, *POBJECT_TYPE_INITIALIZER_8;

//
// Windows 10 RS1, new ObjectTypeFlags2 flag added, 
// ParseProcedure now has two variants with different parameters.
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS1 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    union
    {
        UCHAR ObjectTypeFlags2; //for ParseProcedureEx
        struct
        {
            UCHAR UseExtendedParameters : 1;
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS1, *POBJECT_TYPE_INITIALIZER_RS1;

//
// ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
// It was that hard to do this since beginning?
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS2 {
    USHORT Length;
    union
    {
        USHORT ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
        struct
        {
            UCHAR UseExtendedParameters : 1;//for ParseProcedureEx
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS2, *POBJECT_TYPE_INITIALIZER_RS2;

//
// OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
//
typedef struct _OBJECT_TYPE_7 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_7 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_7, POBJECT_TYPE_7;

typedef struct _OBJECT_TYPE_8 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_8 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_8, POBJECT_TYPE_8;

typedef struct _OBJECT_TYPE_RS1 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

typedef struct _OBJECT_TYPE_RS2 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

/*
** brand new header starting from 6.1
*/

typedef struct _OBJECT_HEADER {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;
    UCHAR TraceFlags;
    UCHAR InfoMask;
    UCHAR Flags;
    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

//
// Actual object header from windows 10-11.
//
typedef struct _OBJECT_HEADER_X {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };

    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;

    union
    {
        UCHAR TraceFlags;
        struct
        {
            UCHAR DbgRefTrace : 1;
            UCHAR DbgTracePermanent : 1;
        };
    };

    UCHAR InfoMask;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR NewObject : 1;
            UCHAR KernelObject : 1;
            UCHAR KernelOnlyAccess : 1;
            UCHAR ExclusiveObject : 1;
            UCHAR PermanentObject : 1;
            UCHAR DefaultSecurityQuota : 1;
            UCHAR SingleHandleEntry : 1;
            UCHAR DeletedInline : 1;
        };
    };

    ULONG Reserved;

    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PVOID SecurityDescriptor;
    QUAD Body;

} OBJECT_HEADER_X, * POBJECT_HEADER_X;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

#define DOSDEVICE_DRIVE_UNKNOWN     0
#define DOSDEVICE_DRIVE_CALCULATE   1 //e.g. symlink
#define DOSDEVICE_DRIVE_REMOVABLE   2
#define DOSDEVICE_DRIVE_FIXED       3
#define DOSDEVICE_DRIVE_REMOTE      4
#define DOSDEVICE_DRIVE_CDROM       5
#define DOSDEVICE_DRIVE_RAMDISK     6

typedef struct _DEVICE_MAP_V1 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    ULONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V1, * PDEVICE_MAP_V1;

typedef struct _DEVICE_MAP_V1 DEVICE_MAP_COMPATIBLE;
typedef struct _DEVICE_MAP_V1* PDEVICE_MAP_COMPATIBLE;

//Since REDSTONE1 (14393)
typedef struct _DEVICE_MAP_V2 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    volatile LONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
    PEJOB ServerSilo;
} DEVICE_MAP_V2, * PDEVICE_MAP_V2;

//Since W11 (22000)
typedef struct _DEVICE_MAP_V3 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PEJOB ServerSilo;
    struct _DEVICE_MAP* GlobalDeviceMap;
    EX_FAST_REF DriveObject[26];
    LONGLONG ReferenceCount;
    PVOID DosDevicesDirectoryHandle;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V3, PDEVICE_MAP_V3;

/*
** OBJECT MANAGER END
*/

/*
* WDM START
*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR ThreadReservedControlFlags : 4;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _FAST_MUTEX {
    LONG_PTR Count;
    void *Owner;
    ULONG Contention;
    struct _KEVENT Event;
    ULONG OldIrql;
    LONG __PADDING__[1];
} FAST_MUTEX, *PFAST_MUTEX;

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    ULONG Processor;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PVOID DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE;

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

enum _KOBJECTS {
    EventNotificationObject = 0x0,
    EventSynchronizationObject = 0x1,
    MutantObject = 0x2,
    ProcessObject = 0x3,
    QueueObject = 0x4,
    SemaphoreObject = 0x5,
    ThreadObject = 0x6,
    GateObject = 0x7,
    TimerNotificationObject = 0x8,
    TimerSynchronizationObject = 0x9,
    Spare2Object = 0xa,
    Spare3Object = 0xb,
    Spare4Object = 0xc,
    Spare5Object = 0xd,
    Spare6Object = 0xe,
    Spare7Object = 0xf,
    Spare8Object = 0x10,
    Spare9Object = 0x11,
    ApcObject = 0x12,
    DpcObject = 0x13,
    DeviceQueueObject = 0x14,
    EventPairObject = 0x15,
    InterruptObject = 0x16,
    ProfileObject = 0x17,
    ThreadedDpcObject = 0x18,
    MaximumKernelObject = 0x19,
};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000
#define DO_DEVICE_TO_BE_RESET           0x04000000      
#define DO_DAX_VOLUME                   0x10000000    

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054
#define FILE_DEVICE_STORAGE_REPLICATION 0x00000055
#define FILE_DEVICE_TRUST_ENV           0x00000056
#define FILE_DEVICE_UCM                 0x00000057
#define FILE_DEVICE_UCMTCPCI            0x00000058
#define FILE_DEVICE_PERSISTENT_MEMORY   0x00000059
#define FILE_DEVICE_NVDIMM              0x0000005a
#define FILE_DEVICE_HOLOGRAPHIC         0x0000005b
#define FILE_DEVICE_SDFXHCI             0x0000005c
#define FILE_DEVICE_UCMUCSI             0x0000005d

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    __volatile PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT* PDEVICE_OBJECT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PVOID FastIoCheckIfPossible;
    PVOID FastIoRead;
    PVOID FastIoWrite;
    PVOID FastIoQueryBasicInfo;
    PVOID FastIoQueryStandardInfo;
    PVOID FastIoLock;
    PVOID FastIoUnlockSingle;
    PVOID FastIoUnlockAll;
    PVOID FastIoUnlockAllByKey;
    PVOID FastIoDeviceControl;
    PVOID AcquireFileForNtCreateSection;
    PVOID ReleaseFileForNtCreateSection;
    PVOID FastIoDetachDevice;
    PVOID FastIoQueryNetworkOpenInfo;
    PVOID AcquireForModWrite;
    PVOID MdlRead;
    PVOID MdlReadComplete;
    PVOID PrepareMdlWrite;
    PVOID MdlWriteComplete;
    PVOID FastIoReadCompressed;
    PVOID FastIoWriteCompressed;
    PVOID MdlReadCompleteCompressed;
    PVOID MdlWriteCompleteCompressed;
    PVOID FastIoQueryOpen;
    PVOID ReleaseForModWrite;
    PVOID AcquireForCcFlush;
    PVOID ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

// Public structure
typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PVOID AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

// Private, since 7.1
typedef struct _DRIVER_EXTENSION_V2 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
} DRIVER_EXTENSION_V2, * PDRIVER_EXTENSION_V2;

// Private, since 8.0
typedef struct _DRIVER_EXTENSION_V3 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
} DRIVER_EXTENSION_V3, * PDRIVER_EXTENSION_V3;

// Private, since 8.1
typedef struct _DRIVER_EXTENSION_V4 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
    PVOID VerifierContext;
} DRIVER_EXTENSION_V4, * PDRIVER_EXTENSION_V4;

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS* PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, * PIO_COMPLETION_CONTEXT;

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT* RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    __volatile ULONG Waiters;
    __volatile ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    __volatile PIO_COMPLETION_CONTEXT CompletionContext;
    KSPIN_LOCK IrpListLock;
    LIST_ENTRY IrpList;
    __volatile PVOID FileObjectExtension;
} FILE_OBJECT;
typedef struct _FILE_OBJECT* PFILE_OBJECT;

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD* PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

/*
* WDM END
*/

/*
* MM START
*/
typedef ULONG MMSECTION_FLAGS2;

typedef struct _MMEXTEND_INFO {
    ULONG_PTR CommittedSize;
    ULONG ReferenceCount;
} MMEXTEND_INFO, * PMMEXTEND_INFO; /* size: 0x0010 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _MMSECTION_FLAGS {
    struct {
        UINT BeingDeleted : 1; /* bit position: 0 */
        UINT BeingCreated : 1; /* bit position: 1 */
        UINT BeingPurged : 1; /* bit position: 2 */
        UINT NoModifiedWriting : 1; /* bit position: 3 */
        UINT FailAllIo : 1; /* bit position: 4 */
        UINT Image : 1; /* bit position: 5 */
        UINT Based : 1; /* bit position: 6 */
        UINT File : 1; /* bit position: 7 */
        UINT AttemptingDelete : 1; /* bit position: 8 */
        UINT PrefetchCreated : 1; /* bit position: 9 */
        UINT PhysicalMemory : 1; /* bit position: 10 */
        UINT ImageControlAreaOnRemovableMedia : 1; /* bit position: 11 */  //CopyOnWrite
        UINT Reserve : 1; /* bit position: 12 */
        UINT Commit : 1; /* bit position: 13 */
        UINT NoChange : 1; /* bit position: 14 */
        UINT WasPurged : 1; /* bit position: 15 */
        UINT UserReference : 1; /* bit position: 16 */
        UINT GlobalMemory : 1; /* bit position: 17 */
        UINT DeleteOnClose : 1; /* bit position: 18 */
        UINT FilePointerNull : 1; /* bit position: 19 */
        UINT PreferredNode : 6; /* bit position: 20 */
        UINT GlobalOnlyPerSession : 1; /* bit position: 26 */
        UINT UserWritable : 1; /* bit position: 27 */
        UINT SystemVaAllocated : 1; /* bit position: 28 */
        UINT PreferredFsCompressionBoundary : 1; /* bit position: 29 */
        UINT UsingFileExtents : 1; /* bit position: 30 */
        UINT PageSize64K : 1; /* bit position: 31 */
    };
} MMSECTION_FLAGS, * PMMSECTION_FLAGS; /* size: 0x0004 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _SEGMENT_FLAGS {
    union {
        struct {
            USHORT TotalNumberOfPtes4132 : 10; /* bit position: 0 */
            USHORT Spare0 : 2; /* bit position: 10 */
            USHORT LargePages : 1; /* bit position: 12 */
            USHORT DebugSymbolsLoaded : 1; /* bit position: 13 */
            USHORT WriteCombined : 1; /* bit position: 14 */
            USHORT NoCache : 1; /* bit position: 15 */
        }; 
        USHORT Short0;
    }; /* size: 0x0002 */
    union {
        struct {
            UCHAR FloppyMedia : 1; /* bit position: 0 */
            UCHAR DefaultProtectionMask : 5; /* bit position: 1 */
            UCHAR Binary32 : 1; /* bit position: 6 */
            UCHAR ContainsDebug : 1; /* bit position: 7 */
        };
        UCHAR UChar1;
    }; /* size: 0x0001 */
    union {
        struct {
            UCHAR ForceCollision : 1; /* bit position: 0 */
            UCHAR ImageSigningType : 3; /* bit position: 1 */
            UCHAR ImageSigningLevel : 4; /* bit position: 4 */
        };
        UCHAR UChar2;
    };
} SEGMENT_FLAGS, * PSEGMENT_FLAGS; /* size: 0x0004 */

typedef struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
    union {
        ULONGLONG NumberOfPtes : 6;
        ULONGLONG PartitionId : 10;
        ULONGLONG Spare : 2;
        ULONGLONG SectionOffset : 48;
    } u1;
} MI_SYSTEM_CACHE_VIEW_ATTRIBUTES, * PMI_SYSTEM_CACHE_VIEW_ATTRIBUTES;

#define VIEW_MAP_TYPE_PROCESS         1
#define VIEW_MAP_TYPE_SESSION         2
#define VIEW_MAP_TYPE_SYSTEM_CACHE    3

typedef struct _MI_REVERSE_VIEW_MAP {
    struct _LIST_ENTRY ViewLinks;
    union {
        VOID* SystemCacheVa;
        VOID* SessionViewVa;
        struct _EPROCESS* VadsProcess;
        ULONG Type : 2;
    } u1;
    union {
        struct _SUBSECTION* Subsection;
        ULONG SubsectionType : 1;
    } u2;
    union {
        struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES SystemCacheAttributes;
        ULONGLONG AllAttributes; //Since W11
        ULONGLONG SectionOffset;
    } u3;
} MI_REVERSE_VIEW_MAP, * PMI_REVERSE_VIEW_MAP; /* size: 0x0028 */

typedef struct _RTL_BALANCED_NODE {
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        };
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _SEGMENT {

    struct _CONTROL_AREA* ControlArea;
    unsigned long TotalNumberOfPtes;
    SEGMENT_FLAGS SegmentFlags;
    ULONG_PTR NumberOfCommittedPages;
    ULONG_PTR SizeOfSegment;

    union {
        struct _MMEXTEND_INFO* ExtendInfo;
        void* BasedAddress;
    } u1;

    EX_PUSH_LOCK SegmentLock;

    union {
        union {
            ULONG_PTR ImageCommitment;
            ULONG CreatingProcessId;
        };
    } u2;

    union {
        union {
            struct _MI_SECTION_IMAGE_INFORMATION* ImageInformation;
            void* FirstMappedVa;
        };
    } u3;

    struct _MMPTE* PrototypePte;

} SEGMENT, * PSEGMENT;  /* size: 0x0048 */

typedef struct _CONTROL_AREA_COMPAT {

    SEGMENT* Segment;
    LIST_ENTRY ListHead;
    ULONG_PTR NumberOfSectionReferences;
    ULONG_PTR NumberOfPfnReferences;
    ULONG_PTR NumberOfMappedViews;
    ULONG_PTR NumberOfUserReferences;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS Flags;
        };
    } u;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS2 Flags;
        };
    } u1;

    EX_FAST_REF FilePointer;
    volatile LONG ControlAreaLock;
    ULONG ModifiedWriteCount;
    struct _MI_CONTROL_AREA_WAIT_BLOCK* WaitList;

    union
    {
        struct
        {
            union
            {
                ULONG NumberOfSystemCacheViews;
                ULONG ImageRelocationStartBit;
            };
            union
            {
                volatile LONG WritableUserReferences;
                struct // version dependent, this bitset is not valid for w11
                {
                    unsigned long ImageRelocationSizeIn64k : 16; /* bit position: 0 */
                    unsigned long LargePage : 1; /* bit position: 16 */
                    unsigned long SystemImage : 1; /* bit position: 17 */
                    unsigned long StrongCode : 2; /* bit position: 18 */
                    unsigned long CantMove : 1; /* bit position: 20 */
                    unsigned long BitMap : 2; /* bit position: 21 */
                    unsigned long ImageActive : 1; /* bit position: 23 */
                };
            };
            union
            {
                ULONG FlushInProgressCount;
                ULONG NumberOfSubsections;
                struct _MI_IMAGE_SECURITY_REFERENCE* SeImageStub;
            };
        } e2;
    } u2;

    //
    // Incomplete definition, tail is version dependent.
    //

} CONTROL_AREA_COMPAT, * PCONTROL_AREA_COMPAT;

//
// N.B. 
// Only valid for Win10.
// Change between Win10 versions.
//
typedef struct _MMVAD_SHORT {
    union
    {
        struct
        {
            struct _MMVAD_SHORT* NextVad;
            void* ExtraCreateInfo;
        };
        struct _RTL_BALANCED_NODE VadNode;
    };

    ULONG StartingVpn;
    ULONG EndingVpn;
    UCHAR StartingVpnHigh;
    UCHAR EndingVpnHigh;
    UCHAR CommitChargeHigh;
    UCHAR SpareNT64VadUChar;
    LONG ReferenceCount;
    EX_PUSH_LOCK PushLock;

    ULONG LongFlags;
    ULONG LongFlags1;

    struct _MI_VAD_EVENT_BLOCK* EventList;

} MMVAD_SHORT, * PMMVAD_SHORT;  /* size: 0x0040 */

typedef struct _MI_VAD_SEQUENTIAL_INFO {

    struct {
#if defined(_AMD64_)
        ULONG_PTR Length : 12; /* bit position: 0 */
        ULONG_PTR Vpn : 52; /* bit position: 12 */
#else
        ULONG Length : 11; /* bit position: 0 */
        ULONG Vpn : 21; /* bit position: 11 */
#endif
    };

} MI_VAD_SEQUENTIAL_INFO, * PMI_VAD_SEQUENTIAL_INFO;

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS {
    struct
    {
        ULONG VadType : 3; /* bit position: 0 */
        ULONG Protection : 5; /* bit position: 3 */
        ULONG PreferredNode : 6; /* bit position: 8 */
        ULONG PrivateMemory : 1; /* bit position: 14 */
        ULONG PrivateFixup : 1; /* bit position: 15 */
        ULONG Enclave : 1; /* bit position: 16 */
        ULONG PageSize64K : 1; /* bit position: 17 */
        ULONG RfgControlStack : 1; /* bit position: 18 */
        ULONG Spare : 8; /* bit position: 19 */
        ULONG NoChange : 1; /* bit position: 27 */
        ULONG ManySubsections : 1; /* bit position: 28 */
        ULONG DeleteInProgress : 1; /* bit position: 29 */
        ULONG LockContended : 1; /* bit position: 30 */
        ULONG Lock : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS, * PMMVAD_FLAGS; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS1 {
    struct
    {
        ULONG CommitCharge : 31; /* bit position: 0 */
        ULONG MemCommit : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS1, * PMMVAD_FLAGS1; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS2 {
    struct
    {
        ULONG FileOffset : 24; /* bit position: 0 */
        ULONG Large : 1; /* bit position: 24 */
        ULONG TrimBehind : 1; /* bit position: 25 */
        ULONG Inherit : 1; /* bit position: 26 */
        ULONG NoValidationNeeded : 1; /* bit position: 27 */
        ULONG PrivateDemandZero : 1; /* bit position: 28 */
        ULONG Spare : 3; /* bit position: 29 */
    };
} MMVAD_FLAGS2, * PMMVAD_FLAGS2; /* size: 0x0004 */

typedef struct _MMVAD {

    struct _MMVAD_SHORT Core;

    union
    {
        union
        {
            ULONG LongFlags2;
            volatile struct _MMVAD_FLAGS2 VadFlags2;
        };
    } u2;

    struct _SUBSECTION* Subsection;
    struct _MMPTE* FirstPrototypePte;
    struct _MMPTE* LastContiguousPte;
    LIST_ENTRY ViewLinks;
    struct _EPROCESS* VadsProcess;

    union
    {
        union
        {
            struct _MI_VAD_SEQUENTIAL_INFO SequentialVa;
            struct _MMEXTEND_INFO* ExtendedInfo;
        };
    } u4;

    FILE_OBJECT* FileObject;

} MMVAD, * PMMVAD; /* size: 0x0088 */

typedef struct _MMVIEW {
    ULONGLONG Entry;
    union {
        ULONGLONG Writable : 1;
        struct _CONTROL_AREA* ControlArea; 
    };
    LIST_ENTRY ViewLinks; 
    PVOID SessionViewVa;
    ULONG SessionId;
} MMVIEW, *PMMVIEW;

typedef struct _MI_IMAGE_ENTRY_IN_SESSION {
    LIST_ENTRY Link;
    PVOID Address;

    //
    // Incomplete and incorrect.
    //

} MI_IMAGE_ENTRY_IN_SESSION, * PMI_IMAGE_ENTRY_IN_SESSION;

typedef struct _SUBSECTION_COMPAT {

    struct _CONTROL_AREA* ControlArea;
    struct _MMPTE* SubsectionBase;
    struct _SUBSECTION* NextSubsection;

    //
    // Incomplete definition.
    //

} SUBSECTION_COMPAT, * PSUBSECTION_COMPAT;

//
// This is Windows 10 only Section Object definition.
// 
// N.B. It completely differs from anything else.
//
typedef struct _SECTION_COMPAT {

    RTL_BALANCED_NODE SectionNode;
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;

    union {
        union {
            struct _CONTROL_AREA* ControlArea;
            struct _FILE_OBJECT* FileObject;
            struct {
                ULONG_PTR RemoteImageFileObject : 1; /* bit position: 0 */
                ULONG_PTR RemoteDataFileObject : 1; /* bit position: 1 */
            };
        };
    } u1;

    ULONG_PTR SizeOfSection;

    union {
        ULONG LongFlags;
        MMSECTION_FLAGS Flags;
    } u;

    struct {
        ULONG InitialPageProtection : 12; /* bit position: 0 */
        ULONG SessionId : 19; /* bit position: 12 */
        ULONG NoValidationNeeded : 1; /* bit position: 31 */
    };

} SECTION_COMPAT, * PSECTION_COMPAT;  /* size: 0x0040 */

/*
* MM END
*/

/*
*  Configuration Manager control vector
*/
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V1 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
} CM_SYSTEM_CONTROL_VECTOR_V1, * PCM_SYSTEM_CONTROL_VECTOR_V1;

//
// Since Windows 10 RS4
//
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V2 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
    ULONG Flags; //0 or 1 depends on flag from LOADER_PARAMETER_BLOCK attached hives
    ULONG Spare0;
} CM_SYSTEM_CONTROL_VECTOR_V2, * PCM_SYSTEM_CONTROL_VECTOR_V2;

/*
** Callbacks START
*/

typedef NTSTATUS(*PEX_CALLBACK_FUNCTION) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

typedef VOID(NTAPI* PEX_HOST_NOTIFICATION) (
    _In_ ULONG NotificationType,
    _In_opt_ PVOID Context);

typedef struct _EX_EXTENSION_INFORMATION {
    USHORT Id;
    USHORT Version;
    USHORT FunctionCount;
} EX_EXTENSION_INFORMATION, * PEX_EXTENSION_INFORMATION;

typedef struct _EX_HOST_PARAMS {
    EX_EXTENSION_INFORMATION HostInformation;
    POOL_TYPE PoolType;
    PVOID HostTable;
    PVOID NotificationRoutine;
    PVOID NotificationContext;
} EX_HOST_PARAMS, * PEX_HOST_PARAMS;

typedef struct _EX_HOST_ENTRY {
    LIST_ENTRY ListEntry;
    LONG RefCounter;
    EX_HOST_PARAMS HostParameters;
    EX_RUNDOWN_REF RundownProtection;
    EX_PUSH_LOCK PushLock;
    PVOID FunctionTable; //callbacks
    ULONG Flags;
} EX_HOST_ENTRY, * PEX_HOST_ENTRY;

typedef struct _EX_EXTENSION_REGISTRATION {
    EX_EXTENSION_INFORMATION Information;
    PVOID FunctionTable;
    PVOID* HostTable;
    PDRIVER_OBJECT DriverObject;
} EX_EXTENSION_REGISTRATION, * PEX_EXTENSION_REGISTRATION;

typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF RundownProtect;
    PVOID Function; //PEX_CALLBACK_FUNCTION
    PVOID Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages,
    KbCallbackSecondaryMultiPartDumpData,
    KbCallbackRemovePages,
    KbCallbackTriageDumpData
} KBUGCHECK_CALLBACK_REASON;

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    LONG PreCallListHead;
    LARGE_INTEGER Cookie;
    PVOID CallerContext; 
    PEX_CALLBACK_FUNCTION Function;
    UNICODE_STRING Altitude;
    LIST_ENTRY ObjectContextListHead;
} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
    struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION *Next;
    PVOID CallbackRoutine; //PSE_LOGON_SESSION_TERMINATED_ROUTINE
} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DriverObject; //PDRIVER_OBJECT
    PVOID NotificationRoutine; //PDRIVER_FS_NOTIFICATION
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DeviceObject; //PDEVICE_OBJECT
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

typedef struct _CALLBACK_OBJECT {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    UCHAR reserved[3];
} CALLBACK_OBJECT, *PCALLBACK_OBJECT;

// Since 8.1
typedef struct _CALLBACK_OBJECT_V2 {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    LIST_ENTRY ExpCallbackList;
} CALLBACK_OBJECT_V2, * PCALLBACK_OBJECT_V2;

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY Link;
    PCALLBACK_OBJECT CallbackObject;
    PVOID CallbackFunction; //PCALLBACK_FUNCTION
    PVOID CallbackContext;
    ULONG Busy;
    BOOLEAN UnregisterWaiting;
} CALLBACK_REGISTRATION, *PCALLBACK_REGISTRATION;

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE              0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE           0x00000002

typedef struct _OB_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    OB_OPERATION Operations;
    ULONG Flags;
    struct _OB_REGISTRATION* Registration;
    POBJECT_TYPE ObjectType;
    PVOID PreCallback;
    PVOID PostCallback;
    EX_RUNDOWN_REF RundownReference;
} OB_CALLBACK_CONTEXT_BLOCK, *POB_CALLBACK_CONTEXT_BLOCK;

typedef struct _OB_REGISTRATION {
    USHORT Version;
    USHORT RegistrationCount;
    PVOID  RegistrationContext;
    UNICODE_STRING Altitude;
    OB_CALLBACK_CONTEXT_BLOCK* CallbackContext;
} OB_REGISTRATION, * POB_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

typedef struct _POP_POWER_SETTING_REGISTRATION_V1 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V1, *PPOP_POWER_SETTING_REGISTRATION_V1;

//
// WARNING: this structure definition is incomplete. 
// Tail is incorrect/incomplete for newest Win10 versions.
//
typedef struct _POP_POWER_SETTING_REGISTRATION_V2 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD   
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    GUID Guid2;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V2, *PPOP_POWER_SETTING_REGISTRATION_V2;

typedef struct _RTL_CALLBACK_REGISTER {
    ULONG Flags;
    EX_RUNDOWN_REF RundownReference;
    PVOID DebugPrintCallback;
    LIST_ENTRY ListEntry;
} RTL_CALLBACK_REGISTER, *PRTL_CALLBACK_REGISTER;

typedef
VOID
(*PPO_COALESCING_CALLBACK) (
    _In_ ULONG Reason,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID Context);

typedef struct _PO_COALESCING_CALLBACK_V1 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
} PO_COALESCING_CALLBACK_V1, * PPO_COALESCING_CALLBACK_V1;

typedef struct _PO_COALESCING_CALLBACK_V2 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
    LIST_ENTRY Link;
    EX_CALLBACK ExCallback;
} PO_COALESCING_CALLBACK_V2, * PPO_COALESCING_CALLBACK_V2;

typedef
BOOLEAN
(*PNMI_CALLBACK)(
    __in_opt PVOID Context,
    __in BOOLEAN Handled
    );

typedef struct _KNMI_HANDLER_CALLBACK {
    struct _KNMI_HANDLER_CALLBACK* Next;
    PNMI_CALLBACK Callback;
    PVOID Context;
    PVOID Handle;
} KNMI_HANDLER_CALLBACK, * PKNMI_HANDLER_CALLBACK;

typedef
NTSTATUS
(NTAPI* SILO_MONITOR_CREATE_CALLBACK)(
    _In_ PESILO Silo
    );

typedef
VOID
(NTAPI* SILO_MONITOR_TERMINATE_CALLBACK)(
    _In_ PESILO Silo
    );

#define SILO_MONITOR_REGISTRATION_VERSION (1)

typedef struct _SERVER_SILO_MONITOR {
    LIST_ENTRY ListEntry;
    UCHAR Version;
    BOOLEAN MonitorHost;
    BOOLEAN MonitorExistingSilos;
    UCHAR Reserved[5];
    SILO_MONITOR_CREATE_CALLBACK CreateCallback;
    SILO_MONITOR_TERMINATE_CALLBACK TerminateCallback;
    union {
        PUNICODE_STRING DriverObjectName;
        PUNICODE_STRING ComponentName;
    };
} SERVER_SILO_MONITOR, * PSERVER_SILO_MONITOR;

//
// Errata Manager
//
typedef struct _EMP_CALLBACK_DB_RECORD {
    GUID CallbackId;
    PVOID CallbackFunc;
    LONG_PTR CallbackFuncReference;
    PVOID Context;
    SINGLE_LIST_ENTRY List;
    SINGLE_LIST_ENTRY CallbackDependencyListHead;
    ULONG NumberOfStrings;
    ULONG NumberOfNumerics;
    ULONG NumberOfEntries;
    struct _EMP_ENTRY_DB_RECORD* EntryList[1];
} EMP_CALLBACK_DB_RECORD, * PEMP_CALLBACK_DB_RECORD;

typedef struct _EMP_CALLBACK_LIST_ENTRY {
    EMP_CALLBACK_DB_RECORD* CallbackRecord;
    SINGLE_LIST_ENTRY CallbackListEntry;
} EMP_CALLBACK_LIST_ENTRY, * PEMP_CALLBACK_LIST_ENTRY;

/*
** Callbacks END
*/

/*
*  NTQSI Modules START
*/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

/*
*	NTQSI Modules END
*/

/*
** Virtual Memory START
*/

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation = 0,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    MemorySharedCommitInformation,
    MemoryImageInformation,
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation,
    MemoryBasicInformationCapped,
    MemoryPhysicalContiguityInformation,
    MemoryBadInformation,
    MemoryBadInformationAllProcesses,
    MaxMemoryInfoClass
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
    VmPrefetchInformation,
    VmPagePriorityInformation,
    VmCfgCallTargetInformation,
    VmPageDirtyStateInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1;
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_REGION_INFORMATION_V2 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
} MEMORY_REGION_INFORMATION_V2, * PMEMORY_REGION_INFORMATION_V2;

typedef struct _MEMORY_REGION_INFORMATION_V3 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // RS4
            ULONG MappedAwe : 1; // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
    ULONG_PTR NodePreference; // 20H1
} MEMORY_REGION_INFORMATION_V3, * PMEMORY_REGION_INFORMATION_V3;

typedef struct _MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

typedef struct _MEMORY_IMAGE_INFORMATION {
    PVOID ImageBase;
    SIZE_T SizeOfImage;
    union
    {
        ULONG ImageFlags;
        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4; // RS3
            ULONG Reserved : 26;
        };
    };
} MEMORY_IMAGE_INFORMATION, * PMEMORY_IMAGE_INFORMATION;

typedef struct _MEMORY_ENCLAVE_IMAGE_INFORMATION {
    MEMORY_IMAGE_INFORMATION ImageInfo;
    UCHAR UniqueID[32];
    UCHAR AuthorID[32];
} MEMORY_ENCLAVE_IMAGE_INFORMATION, * PMEMORY_ENCLAVE_IMAGE_INFORMATION;

typedef struct _MEMORY_WORKING_SET_BLOCK {
    ULONG_PTR Protection : 5;
    ULONG_PTR ShareCount : 3;
    ULONG_PTR Shared : 1;
    ULONG_PTR Node : 3;
#ifdef _WIN64
    ULONG_PTR VirtualPage : 52;
#else
    ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, * PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    _Field_size_(NumberOfEntries) MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, * PMEMORY_WORKING_SET_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_BLOCK {
    union {
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR ShareCount : 3;
            ULONG_PTR Win32Protection : 11;
            ULONG_PTR Shared : 1;
            ULONG_PTR Node : 6;
            ULONG_PTR Locked : 1;
            ULONG_PTR LargePage : 1;
            ULONG_PTR Priority : 3;
            ULONG_PTR Reserved : 3;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
            ULONG_PTR Win32GraphicsProtection : 4;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 28;
#endif
        };
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR Reserved0 : 14;
            ULONG_PTR Shared : 1;
            ULONG_PTR Reserved1 : 5;
            ULONG_PTR PageTable : 1;
            ULONG_PTR Location : 2;
            ULONG_PTR Priority : 3;
            ULONG_PTR ModifiedList : 1;
            ULONG_PTR Reserved2 : 2;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 32;
#endif
        } Invalid;
    };
} MEMORY_WORKING_SET_EX_BLOCK, * PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    union {
        MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
        ULONG_PTR Long;
    } u1;
} MEMORY_WORKING_SET_EX_INFORMATION, * PMEMORY_WORKING_SET_EX_INFORMATION;

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   // NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   // NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  // bigger than 5 bits!

#define MM_INVALID_PROTECTION ((ULONG)-1)  // bigger than 5 bits!

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55

/*
** Virtual Memory END
*/

/*
** System Firmware START
*/

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

/*
** System Firmware END
*/

//
//  PEB/TEB
//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

// 32-bit definitions
typedef struct _STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            WOW64_POINTER(PVOID) SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        WOW64_POINTER(PVOID) LoadedImports;
    };
    WOW64_POINTER(PVOID) EntryPointActivationContext;
    WOW64_POINTER(PVOID) PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;
    WOW64_POINTER(PVOID) ContextInformation;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32 {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PPVOID) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    // Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32 {
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) SystemReserved1[54];
    NTSTATUS ExceptionCode;
    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    BYTE SpareBytes[36];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif

#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif

#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

#ifndef DOS_MAX_COMPONENT_LENGTH
#define DOS_MAX_COMPONENT_LENGTH 255
#endif

#ifndef DOS_MAX_PATH_LENGTH
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)
#endif

typedef struct _ACTIVATION_CONTEXT_DATA * PACTIVATION_CONTEXT_DATA;
typedef struct _ASSEMBLY_STORAGE_MAP * PASSEMBLY_STORAGE_MAP;

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;

    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING RedirectionDllName; // RS4
    UNICODE_STRING HeapPartitionName; // 19H1
    ULONG_PTR DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
    ULONG DefaultThreadpoolThreadMaximum;
    ULONG HeapMemoryTypeMask; // WIN11
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PSLIST_HEADER AtlThunkSListPtr;
    PVOID IFEOKey;

    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // RS5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    struct _SILO_USER_SHARED_DATA* SharedData;
    PVOID* ReadOnlyStaticServerData;

    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    ULARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    KAFFINITY ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PACTIVATION_CONTEXT_DATA ActivationContextData;
    PASSEMBLY_STORAGE_MAP ProcessAssemblyStorageMap;
    PACTIVATION_CONTEXT_DATA SystemDefaultActivationContextData;
    PASSEMBLY_STORAGE_MAP SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PVOID SparePointers[2];
    PVOID PatchLoaderData;
    PVOID ChpeV2ProcessInfo; 

    ULONG AppModelFeatureState;
    ULONG SpareUlongs[2];

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;

    union
    {
        PVOID pContextData;
        PVOID pUnused;
        PVOID EcCodeBitMap;
    };

    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PRTL_CRITICAL_SECTION TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // RS3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // RS4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA* LeapSecondData; // RS5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11
} PEB, * PPEB;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME {
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG	Offset;
    UCHAR	Alignment[4];
    ULONG_PTR HDC;
    ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _ACTIVATION_CONTEXT_DATA {
    ULONG Magic; //'xtcA'
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG TotalSize;
    ULONG DefaultTocOffset;
    ULONG ExtendedTocOffset;
    ULONG AssemblyRosterOffset; 
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA, * PACTIVATION_CONTEXT_DATA;

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {
    ULONG Flags;
    UNICODE_STRING DosPath;
    HANDLE Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY, * PASSEMBLY_STORAGE_MAP_ENTRY;

typedef struct _ASSEMBLY_STORAGE_MAP {
    ULONG Flags;
    ULONG AssemblyCount;
    PASSEMBLY_STORAGE_MAP_ENTRY* AssemblyArray;
} ASSEMBLY_STORAGE_MAP, * PASSEMBLY_STORAGE_MAP;

typedef VOID(NTAPI* PACTIVATION_CONTEXT_NOTIFY_ROUTINE)(
    _In_ ULONG NotificationType,
    _In_ struct _ACTIVATION_CONTEXT* ActivationContext,
    _In_ PACTIVATION_CONTEXT_DATA ActivationContextData,
    _In_opt_ PVOID NotificationContext,
    _In_opt_ PVOID NotificationData,
    _Inout_ PBOOLEAN DisableThisNotification
    );

typedef struct _ACTIVATION_CONTEXT {
    LONG RefCount;
    ULONG Flags;
    PACTIVATION_CONTEXT_DATA ActivationContextData;
    PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine;
    PVOID NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ASSEMBLY_STORAGE_MAP StorageMap;
    PASSEMBLY_STORAGE_MAP_ENTRY InlineStorageMapEntries[32];
} ACTIVATION_CONTEXT, * PACTIVATION_CONTEXT;

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
    PACTIVATION_CONTEXT ActivationContext;
    ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, * PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _ACTIVATION_CONTEXT_STACK {
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef struct _TEB {
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif

    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif

    BOOLEAN InstrumentationCallbackDisabled;
#ifdef _WIN64
    BOOLEAN UnalignedLoadStoreExceptions;
#endif
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle; // tagSOleTlsData
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID* TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapData;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SkipFileAPIBrokering : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter;
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
} TEB, * PTEB;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

/*
** PEB/TEB END
*/

/*
**  MITIGATION POLICY START
*/

//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14
#define ProcessUserShadowStackPolicy        15
#define ProcessRedirectionTrustPolicy       16
#define ProcessUserPointerAuthPolicy        17
#define ProcessSEHOPPolicy                  18

typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD EnableXfg : 1;
            DWORD EnableXfgAuditMode : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG FilterId : 4;
            ULONG ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableExportAddressFilter : 1;
            ULONG AuditExportAddressFilter : 1;
            ULONG EnableExportAddressFilterPlus : 1;
            ULONG AuditExportAddressFilterPlus : 1;
            ULONG EnableImportAddressFilter : 1;
            ULONG AuditImportAddressFilter : 1;
            ULONG EnableRopStackPivot : 1;
            ULONG AuditRopStackPivot : 1;
            ULONG EnableRopCallerCheck : 1;
            ULONG AuditRopCallerCheck : 1;
            ULONG EnableRopSimExec : 1;
            ULONG AuditRopSimExec : 1;
            ULONG ReservedFlags : 20;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG NoChildProcessCreation : 1;
            ULONG AuditNoChildProcessCreation : 1;
            ULONG AllowSecureProcessCreation : 1;
            ULONG ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD SmtBranchTargetIsolation : 1;
            DWORD IsolateSecurityDomain : 1;
            DWORD DisablePageCombine : 1;
            DWORD SpeculativeStoreBypassDisable : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD DisallowFsctlSystemCalls : 1;
            DWORD AuditDisallowFsctlSystemCalls : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableUserShadowStack : 1;
            DWORD AuditUserShadowStack : 1;
            DWORD SetContextIpValidation : 1;
            DWORD AuditSetContextIpValidation : 1;
            DWORD EnableUserShadowStackStrictMode : 1;
            DWORD BlockNonCetBinaries : 1;
            DWORD BlockNonCetBinariesNonEhcont : 1;
            DWORD AuditBlockNonCetBinaries : 1;
            DWORD CetDynamicApisOutOfProcOnly : 1;
            DWORD ReservedFlags : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10, * PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnforceRedirectionTrust : 1;
            DWORD AuditRedirectionTrust : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10, * PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10;

typedef struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnablePointerAuthUserIp : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11, * PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11;

typedef struct _PROCESS_MITIGATION_SEHOP_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableSehop : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SEHOP_POLICY_W11, * PPROCESS_MITIGATION_SEHOP_POLICY_W11;

typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
        PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
        PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 UserShadowStackPolicy;
        PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 RedirectionTrustPolicy;
        PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 UserPointerAuthPolicy;
        PROCESS_MITIGATION_SEHOP_POLICY_W11 SEHOPPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

/*
**  MITIGATION POLICY END
*/

/*
** KUSER_SHARED_DATA START
*/
#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON  1
#define NX_SUPPORT_POLICY_OPTIN     2
#define NX_SUPPORT_POLICY_OPTOUT    3

#include <pshpack4.h>
typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

//
// Define Address of User Shared Data
//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA {

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;

    union {
        ULONG Reserved2[7];
        struct {
            ULONG AitSamplingValue;
            ULONG AppCompatFlag;
            struct {
                ULONG LowPart;
                ULONG HighPart;
            } RNGSeedVersion;
            ULONG GlobalValidationRunlevel;
            LONG TimeZoneBiasStamp;
            ULONG NtBuildNumber;
        };
    };

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
    ULONG Reserved1;
    ULONG Reserved3;
    volatile ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG AltArchitecturePad;
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;

    union {
        UCHAR MitigationPolicies;
        struct {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;
    volatile ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union {
        ULONG SharedDataFlags;
        struct {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG SpareBits : 21;
        };
    };
    ULONG DataFlagsPad[1];
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;
    ULONG SystemCallPad0;

    ULONGLONG SystemCallPad[2];

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;
    ULONG CookiedPad[1];

    LONGLONG ConsoleSessionForegroundProcessId;

    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;

    ULONG EnclaveFeatureMask[4];
    union {
        ULONG Reserved8;
        ULONG TelemetryCoverageRound;
    };

    USHORT UserModeGlobalLogger[16];

    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;

    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;

    union {
        USHORT QpcData;
        struct {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    XSTATE_CONFIGURATION XState;

    KSYSTEM_TIME FeatureConfigurationChangeStamp;
    ULONG Spare;

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

#if !defined(__midl) && !defined(MIDL_PASS)

//
// The overall size can change, but it must be the same for all architectures.
//

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountLowDeprecated) == 0x0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(__alignof(KSYSTEM_TIME) == 4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x08);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x014);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x020);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x02c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x02e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x030);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AitSamplingValue) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AppCompatFlag) == 0x24c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, RNGSeedVersion) == 0x250);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, GlobalValidationRunlevel) == 0x258);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasStamp) == 0x25c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtBuildNumber) == 0x260);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NativeProcessorArchitecture) == 0x26a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MitigationPolicies) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, VirtualizationFlags) == 0x2ed);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved12) == 0x2ee);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SharedDataFlags) == 0x2f0);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcFrequency) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x308);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad0) == 0x30c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x310);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeUpdateLock) == 0x340);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineSystemTimeQpc) == 0x348);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineInterruptTimeQpc) == 0x350);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrement) == 0x358);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrement) == 0x360);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrementShift) == 0x368);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrementShift) == 0x369);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UnparkedProcessorCount) == 0x36a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, EnclaveFeatureMask) == 0x36c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved8) == 0x37c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved4) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcBias) == 0x3b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved9) == 0x3c5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcData) == 0x3c6);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveStart) == 0x3c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveEnd) == 0x3d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8);

#endif /* __midl | MIDL_PASS */

/*
** KUSER_SHARED_DATA END
*/

/*
** MM UNLOADED DRIVERS START
*/

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, *PUNLOADED_DRIVERS;

#define MI_UNLOADED_DRIVERS 50

/*
** MM UNLOADED DRIVERS END
*/


/*
** FLT MANAGER START
*/
typedef enum _FLT_FILTER_FLAGS {
    FLTFL_MANDATORY_UNLOAD_IN_PROGRESS = 1,
    FLTFL_FILTERING_INITIATED = 2,
    FLTFL_NAME_PROVIDER = 4,
    FLTFL_SUPPORTS_PIPES_MAILSLOTS = 8,
    FLTFL_BACKED_BY_PAGEFILE = 16,
    FLTFL_SUPPORTS_DAX_VOLUME = 32,
    FLTFL_SUPPORTS_WCOS = 64,
    FLTFL_FILTERS_READ_WRITE = 128,
} FLT_FILTER_FLAGS, *PFLT_FILTER_FLAGS;

typedef enum _FLT_OBJECT_FLAGS {
    FLT_OBFL_DRAINING = 1,
    FLT_OBFL_ZOMBIED = 2,
    FLT_OBFL_TYPE_INSTANCE = 0x1000000,
    FLT_OBFL_TYPE_FILTER = 0x2000000,
    FLT_OBFL_TYPE_VOLUME = 0x4000000,
} FLT_OBJECT_FLAGS, *PFLT_OBJECT_FLAGS;

typedef struct _FLT_OBJECT {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
} FLT_OBJECT, *PFLT_OBJECT;

// Since w10 th1
typedef struct _FLT_OBJECT_V2 {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
    GUID UniqueIdentifier;
} FLT_OBJECT_V2, *PFLT_OBJECT_V2; /* size: 0x0030 */

typedef struct _FLT_SERVER_PORT_OBJECT {
    LIST_ENTRY FilterLink;
    PVOID ConnectNotify;
    PVOID DisconnectNotify;
    PVOID MessageNotify;
    PVOID Filter;
    PVOID Cookie;
    ULONG Flags;
    LONG NumberOfConnections;
    LONG MaxConnections;
    LONG __PADDING__[1];
} FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT; /* size: 0x0048 */

typedef struct _FLT_RESOURCE_LIST_HEAD {
    ERESOURCE rLock;
    LIST_ENTRY rList;
    ULONG rCount;
    LONG __PADDING__[1];
} FLT_RESOURCE_LIST_HEAD, *PFLT_RESOURCE_LIST_HEAD; /* size: 0x0080 */

typedef struct _FLT_MUTEX_LIST_HEAD {
    FAST_MUTEX mLock;
    LIST_ENTRY mList;
    union {
        ULONG mCount;
        struct {
            UCHAR mInvalid : 1;
            CHAR __PADDING__[7];
        };
    }; 
} FLT_MUTEX_LIST_HEAD, *PFLT_MUTEX_LIST_HEAD; /* size: 0x0050 */

// Windows 7 version
typedef struct _FLT_FILTER_V1 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[6];
    /* 0x0150 */ PVOID PreVolumeMount /* function */;
    /* 0x0158 */ PVOID PostVolumeMount /* function */;
    /* 0x0160 */ PVOID GenerateFileName /* function */;
    /* 0x0168 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0178 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0180 */ PVOID KtmNotification /* function */;
    /* 0x0188 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x0190 */ PVOID OldDriverUnload /* function */;
    /* 0x0198 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01e8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0238 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0288 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V1, * PFLT_FILTER_V1; /* size: 0x0290 */

// Windows 8/8.1 version
typedef struct _FLT_FILTER_V2 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0158 */ PVOID PreVolumeMount /* function */;
    /* 0x0160 */ PVOID PostVolumeMount /* function */;
    /* 0x0168 */ PVOID GenerateFileName /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0178 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0180 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0188 */ PVOID KtmNotification /* function */;
    /* 0x0190 */ PVOID SectionNotification /* function */; //SINCE 8.1
    /* 0x0198 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01a0 */ PVOID OldDriverUnload /* function */;
    /* 0x01a8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01f8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0248 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0298 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V2, * PFLT_FILTER_V2; /* size: 0x02a0 */

// Windows 10 version
typedef struct _FLT_FILTER_V3 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V3, *PFLT_FILTER_V3; /* size: 0x02b0 */

// Windows 10/11+ (22000)
typedef struct _FLT_FILTER_V4 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK_AUTO_EXPAND PortLock;
} FLT_FILTER_V4, * PFLT_FILTER_V4; /* size: 0x02b8 */

typedef FLT_FILTER_V4 FLT_FILTER_COMPATIBLE;
typedef PFLT_FILTER_V4 PFLT_FILTER_COMPATIBLE;

/*
** FLT MANAGER END
*/

/*
** SILO START
*/

typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

typedef struct _SILO_USER_SHARED_DATA {
    ULONG ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId; // since RS2
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
    ULONG TimeZoneId; // since 21H2
    LONG TimeZoneBiasStamp;
    KSYSTEM_TIME TimeZoneBias;
    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    ULONG GlobalDeviceMap;
    ULONG LocalDeviceCount[26];
} OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

typedef struct _OBP_SILODRIVERSTATE {
    PDEVICE_MAP SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

typedef struct _OBP_SILODRIVERSTATE_V2 {
    EX_FAST_REF SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE_V2, * POBP_SILODRIVERSTATE_V2; /* size: 0x02e0 */

//incomplete, values not important, change between versions.
typedef struct _ESERVERSILO_GLOBALS {
    OBP_SILODRIVERSTATE ObSiloState;
    //incomplete
} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

/*
** SILO END
*/

/*
** KSE START
*/

typedef enum _KSE_DISABLE_FLAGS {
    DisableNone = 0,
    DisableDriverShims = 1,
    DisableDeviceShims = 2,
    MaxDisableFlags
} KSE_DISABLE_FLAGS;

typedef enum _KSE_STATE {
    KseNotReady = 0,
    KseInProgress = 1,
    KseReady = 2
} KSE_STATE;

#define KseFlagsNone                0x0000
#define KseFlagsGroupPolicyOk       0x0002
#define KseFlagsVerifierEnabled     0x0040
#define KseFlagsNoDb                0x0080   
#define KseFlagsInitSafeMode        0x0100
#define KseFlagsDrvShimActive       0x0800
#define KseFlagsDevShimsActive      0x1000

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)_KSE_ENGINE {
    KSE_DISABLE_FLAGS DisableFlags;
    KSE_STATE State;
    ULONG Flags; //KseFlags*
    LIST_ENTRY ProvidersListHead;
    LIST_ENTRY ShimmedDriversListHead;
    PVOID KseGetIoCallbacksRoutine;
    PVOID KseSetCompletionHookRoutine;
    PVOID DeviceInfoCache;
    PVOID HardwareIdCache;
    PVOID ShimmedDriverHint;
} KSE_ENGINE, * PKSE_ENGINE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _KSE_SHIM {
    ULONG Size;
    GUID* Guid;
    PWCHAR Name;
    PVOID KseCallbackRoutines;
    PVOID RemoveNotificationRoutine;
    PVOID ApplyNotificationRoutine;
    PVOID HookCollectionsArray;
} KSE_SHIM, * PKSE_SHIM;

typedef enum _KSE_HOOK_COLLECTION_TYPE {
    HookNtOsImport = 0,
    HookHalImport = 1,
    HookNamedModuleImports = 2,
    HookCallbacks = 3,
    HookLastCollection = 4
} KSE_HOOK_COLLECTION_TYPE;

typedef struct _KSE_HOOK_COLLECTION {
    KSE_HOOK_COLLECTION_TYPE Type;
    PWCHAR TargetDriverName;
    PVOID HookArray;
} KSE_HOOK_COLLECTION, * PKSE_HOOK_COLLECTION;

typedef enum _KSE_HOOK_TYPE {
    HookFunction = 0,
    HookIrpCallback = 1,
    HookLast = 2
} KSE_HOOK_TYPE, * PKSE_HOOK_TYPE;

typedef struct _KSE_HOOK {
    KSE_HOOK_TYPE Type;
    union {
        PCHAR FunctionName;
        ULONG CallbackId;
    } DUMMYUNION;
    PVOID HookFunction;
    PVOID OriginalFunction;
} KSE_HOOK, * PKSE_HOOK;

typedef struct _KSE_PROVIDER {
    LIST_ENTRY ProviderList;
    PKSE_SHIM Shim;
} KSE_PROVIDER, * PKSE_PROVIDER;

typedef struct _KSE_SHIMMED_DRIVER {
    LIST_ENTRY ListEntry;
    PVOID DriverBaseAddress;
    ULONG RefCount;
    GUID* ShimGuid;
    //incomplete
} KSE_SHIMMED_DRIVER, * PKSE_SHIMMED_DRIVER;

/*
** KSE END
*/

/*
** SOFTWARE LICENSING START
*/
#pragma pack(push, 1)
typedef struct _SL_CACHE_VALUE_DESCRIPTOR {
    USHORT Size;
    USHORT NameLength;
    USHORT Type;
    USHORT DataLength;
    ULONG Attributes;
    ULONG Reserved;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_CACHE_VALUE_DESCRIPTOR, *PSL_CACHE_VALUE_DESCRIPTOR;
typedef SL_CACHE_VALUE_DESCRIPTOR SL_KMEM_CACHE_VALUE_DESCRIPTOR;
#pragma pack(pop)

typedef struct _SL_CACHE {
    ULONG TotalSize;
    ULONG SizeOfData;
    ULONG SignatureSize;
    ULONG Flags;
    ULONG Version;
    SL_KMEM_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_CACHE, *PSL_CACHE;
typedef SL_CACHE SL_KMEM_CACHE;

typedef struct _SL_APPX_CACHE_VALUE_DESCRIPTOR {
    UCHAR HashedName[32];
    ULONGLONG Expiration;
    ULONG DataSize;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_APPX_CACHE_VALUE_DESCRIPTOR, *PSL_APPX_CACHE_VALUE_DESCRIPTOR;

typedef struct _SL_APPX_CACHE {
    ULONG Version;
    ULONG Flags;
    ULONG DataSize;
    ULONGLONG DataCheckSum;
    SL_APPX_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_APPX_CACHE, *PSL_APPX_CACHE;


/*
** SOFTWARE LICENSING END
*/

/*
** List Entry macro START (wdm.h)
*/

#if defined (NTOS_ENABLE_LIST_ENTRY_MACRO)

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

FORCEINLINE
VOID
InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
)
{
    ListHead->Flink = ListHead->Blink = ListHead;
    return;
}

_Must_inspect_result_
BOOLEAN
CFORCEINLINE
IsListEmpty(
    _In_ const LIST_ENTRY* ListHead
)
{
    return (BOOLEAN)(ListHead->Flink == ListHead);
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
    _In_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}

FORCEINLINE
VOID
InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
    return;
}

FORCEINLINE
VOID
InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
    return;
}

FORCEINLINE
VOID
AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
)
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
    return;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
)
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;
    if (FirstEntry != NULL) {
        ListHead->Next = FirstEntry->Next;
    }

    return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PSINGLE_LIST_ENTRY Entry
)
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
    return;
}

#define ASSERT_LIST_ENTRY_VALID(ListEntry) {                    \
    if (ListEntry == NULL)                                      \
        return;                                                 \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return;                                                 \
}

#define ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, X) {         \
    if (ListEntry == NULL)                                      \
        return X;                                               \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return X;                                               \
}

#define ASSERT_LIST_ENTRY_VALID_BOOLEAN(ListEntry) ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, FALSE)

#endif /* NTOS_ENABLE_LIST_ENTRY_MACRO */

/*
** List Entry macro END
*/

/*
**  LDR START
*/

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency = 0,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary,
    LoadReasonEnclaveDependency,
    LoadReasonPatchImage,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

//
// Dll Characteristics for LdrLoadDll
//
#define LDR_IGNORE_CODE_AUTHZ_LEVEL                 0x00001000

//
// LdrAddRef Flags
//
#define LDR_ADDREF_DLL_PIN                          0x00000001

//
// LdrLockLoaderLock Flags
//
#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS   0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY          0x00000002

//
// LdrUnlockLoaderLock Flags
//
#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

//
// LdrGetDllHandleEx Flags
//
#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT    0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN                   0x00000002

//
// LdrGetProcedureAddressEx Flags
//
#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

typedef struct _LDR_RESOURCE_INFO {
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG Lang;
} LDR_RESOURCE_INFO, * PLDR_RESOURCE_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    } DUMMYUNION0;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
            ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
            ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
            ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
            ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
            ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
            ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
            ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
            ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
            ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
            ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
            ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
            ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
            ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
            ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
            ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
            ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
            ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
            ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
            ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
            ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
            ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
            ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
            ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
            ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
            ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
            ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
            ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
        };
    } ENTRYFLAGSUNION;
    WORD ObsoleteLoadCount;
    WORD TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    } DUMMYUNION1;
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    } DUMMYUNION2;
    //fields below removed for compatibility, if you need them use LDR_DATA_TABLE_ENTRY_FULL
} LDR_DATA_TABLE_ENTRY_COMPATIBLE, * PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE* PLDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;

typedef BOOLEAN(NTAPI* PLDR_INIT_ROUTINE)(
    _In_ PVOID DllHandle,
    _In_ ULONG Reason,
    _In_opt_ PVOID Context
    );

typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD* Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage = 0,
    LdrHotPatchNotApplied = 1,
    LdrHotPatchAppliedReverse = 2,
    LdrHotPatchAppliedForward = 3,
    LdrHotPatchFailedToPatch = 4,
    LdrHotPatchStateMax = 5,
} LDR_HOT_PATCH_STATE, * PLDR_HOT_PATCH_STATE;

//
// Full declaration of LDR_DATA_TABLE_ENTRY
//
typedef struct _LDR_DATA_TABLE_ENTRY_FULL
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PLDR_INIT_ROUTINE EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ChpeEmulatorImage : 1;
            ULONG ReservedFlags5 : 1;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID Lock;
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    PVOID LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel;
    ULONG CheckSum; 
    PVOID ActivePatchImageBase;
    LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_FULL, * PLDR_DATA_TABLE_ENTRY_FULL;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;
typedef const LDR_DLL_NOTIFICATION_DATA* PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID(NTAPI *PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_    PVOID Context,
    _Inout_ BOOLEAN *StopEnumeration
    );

typedef VOID(CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context);

#ifndef LDR_IS_DATAFILE
#define LDR_IS_DATAFILE(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)1)
#endif

#ifndef LDR_IS_IMAGEMAPPING
#define LDR_IS_IMAGEMAPPING(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)2)
#endif

#ifndef LDR_IS_RESOURCE
#define LDR_IS_RESOURCE(DllHandle) (LDR_IS_IMAGEMAPPING(DllHandle) || LDR_IS_DATAFILE(DllHandle))
#endif

#ifndef IMAGE_FILE_MACHINE_CHPE_X86
#define IMAGE_FILE_MACHINE_CHPE_X86 0x3A64
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    _Out_opt_ PVOID *Address,
    _Out_opt_ PULONG Size);

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_opt_ ULONG Flags,
    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID Context);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST ULONG_PTR* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID Address,
    _Out_ PLDR_DATA_TABLE_ENTRY *TableEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST ANSI_STRING* ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID* ProcedureAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_  PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _Out_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_ ULONG ModuleInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrResSearchResource(
    _In_ PVOID File,
    _In_ CONST ULONG_PTR* ResIds,
    _In_ ULONG ResIdCount,
    _In_ ULONG Flags,
    _Out_ LPVOID *Resource,
    _Out_ ULONG_PTR *Size,
    _In_opt_ USHORT *FoundLanguage,
    _In_opt_ ULONG *FoundLanguageLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ BOOLEAN Wow64Path,
    _Out_ PHANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
BOOLEAN
NTAPI
LdrIsModuleSxsRedirected( //LdrEntry->Flags->Redirected
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize,
    _In_ BOOLEAN Wow64Path);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_opt_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownProcess(
    VOID);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownThread(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID);

/*
**  LDR END
*/

/*
** Runtime Library API START
*/

/************************************************************************************
*
* CSR API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
CsrGetProcessId(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
CsrClientConnectToServer(
    _In_ PWSTR ObjectDirectory,
    _In_ ULONG ServerDllIndex,
    _Inout_ PVOID ConnectionInformation,
    _Inout_ ULONG *ConnectionInformationLength,
    _Out_ PBOOLEAN CalledFromServer);

/************************************************************************************
*
* RTL Strings API.
*
************************************************************************************/

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PSTR SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSZ SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut);

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ GUID *Guid,
    _Out_ PUNICODE_STRING GuidString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ GUID *Guid);

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath);

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Reserved_ PVOID Reserved);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PWCHAR String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PWCHAR String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _In_ PSTRING DestinationString,
    _In_ PSTRING SourceString);

//
// preallocated heap-growable buffers
//
typedef struct _RTL_BUFFER {
    PUCHAR    Buffer;
    PUCHAR    StaticBuffer;
    SIZE_T    Size;
    SIZE_T    StaticSize;
    SIZE_T    ReservedForAllocatedSize; // for future doubling
    PVOID     ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
    UNICODE_STRING String;
    RTL_BUFFER     ByteBuffer;
    UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

//
// These are OUT Disposition values.
//
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS   (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC         (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE       (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart);

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName);

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR lpFileName,
    _In_ ULONG nBufferLength,
    _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
    _Out_opt_ PWSTR *lpFilePart);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath);

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ const UNICODE_STRING *String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PWSTR Source);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

NTSYSAPI
NTSTATUS
NTAPI
RtlpEnsureBufferSize(
    _In_ ULONG Flags,
    _Inout_ PRTL_BUFFER Buffer,
    _In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize) \
    do {                                        \
        (Buff)->Buffer       = (StatBuff);      \
        (Buff)->Size         = (StatSize);      \
        (Buff)->StaticBuffer = (StatBuff);      \
        (Buff)->StaticSize   = (StatSize);      \
    } while (0)

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define RtlFreeBuffer(Buff)                              \
    do {                                                 \
        if ((Buff) != NULL && (Buff)->Buffer != NULL) {  \
            if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff)) {   \
                UNICODE_STRING UnicodeString;            \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer; \
                RtlFreeUnicodeString(&UnicodeString);    \
            }                                            \
            (Buff)->Buffer = (Buff)->StaticBuffer;       \
            (Buff)->Size = (Buff)->StaticSize;           \
        }                                                \
    } while (0)


NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _Inout_ PUCHAR Seed,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _Inout_ PUNICODE_STRING String);

/************************************************************************************
*
* RTL Integer conversion API.
*
************************************************************************************/

struct in6_addr;

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Addr,
    _Out_ PWSTR S);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ LPCWSTR *Terminator,
    _Out_ struct in_addr *Address);

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW(
    _In_ struct in6_addr*Address,
    _Out_writes_(46) PWSTR AddressString);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW(
    _In_ PCWSTR AddressString,
    _Out_ PCWSTR * Terminator,
    _Out_ struct in6_addr*Address);

//taken from ph2

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
    _In_ PSTR String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar(
    _In_ PLARGE_INTEGER Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
    _In_ ULONGLONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    _In_ PUNICODE_STRING String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

/************************************************************************************
*
* RTL Process/Thread API.
*
************************************************************************************/

typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_opt_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PCUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Out_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _Inout_opt_ PVOID* Environment,
    _In_ PUNICODE_STRING Name,
    _In_opt_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG Attributes,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_ ULONG StackZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T InitialStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId);

NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlFreeUserThreadStack(
    _In_ HANDLE hProcess,
    _In_ HANDLE hThread);

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID);

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr);

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr);

/************************************************************************************
*
* RTL Memory Buffer API.
*
************************************************************************************/

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_ PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern);

/************************************************************************************
*
* RTL PEB API.
*
************************************************************************************/

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID);

/************************************************************************************
*
* RTL Exception Handling API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle);

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord);

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert);

NTSYSAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance);

__analysis_noreturn
NTSYSAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage);

#define RTL_ASSERT(exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL), FALSE) : TRUE)
#define RTL_ASSERTMSG(msg, exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, msg), FALSE) : TRUE)
#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp), FALSE) : TRUE)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)), FALSE) : TRUE)

typedef ULONG(NTAPI* PRTLP_UNHANDLED_EXCEPTION_FILTER)(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
    );

NTSYSAPI
VOID
NTAPI
RtlSetUnhandledExceptionFilter(
    _In_ PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter);

NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers);

/************************************************************************************
*
* RTL Security API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR* OutputSecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_writes_bytes_to_opt_(*DaclSize, *DaclSize) PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_writes_bytes_to_opt_(*SaclSize, *SaclSize) PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_writes_bytes_to_opt_(*OwnerSize, *OwnerSize) PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_writes_bytes_to_opt_(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_ BOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL* Dacl,
    _Out_ PBOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_ BOOLEAN SaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL* Sacl,
    _Out_ PBOOLEAN SaclDefaulted);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_reads_bytes_(SecurityDescriptorLength) PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace);

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
PVOID
NTAPI
RtlFindAceByType(
    _In_ PACL pAcl,
    _In_ UCHAR AceType,
    _Out_opt_ PULONG pIndex);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL *Acl);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Out_ PSID *Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount);

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _In_ PSID DestinationSid,
    _In_ PSID SourceSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG ArrayLength,
    _In_ PSID_AND_ATTRIBUTES Source,
    _In_ ULONG TargetSidBufferSize,
    _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
    _Out_ PSID TargetSid,
    _Out_ PSID *NextTargetSid,
    _Out_ PULONG RemainingTargetSidBufferSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _In_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidEqualLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN EqualLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidIsHigherLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN HigherLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID OldSid,
    _In_ PSID NewSid,
    _Out_ ULONG* NumChanges);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsElevatedRid(
    _In_ PSID_AND_ATTRIBUTES SidAttr);

FORCEINLINE 
LUID 
NTAPI 
RtlConvertLongToLuid(
    _In_ LONG Long
)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

FORCEINLINE 
LUID 
RtlConvertUlongToLuid(
    _In_ ULONG Ulong
)
{
    LUID tempLuid;

    tempLuid.LowPart = Ulong;
    tempLuid.HighPart = 0;

    return tempLuid;
}

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled);

#define RTL_ACQUIRE_PRIVILEGE_REVERT 0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID* ReturnedState);

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer);

NTSYSAPI
NTSTATUS
NTAPI
RtlRemovePrivileges(
    _In_ HANDLE TokenHandle,
    _In_ PULONG PrivilegesToKeep,
    _In_ ULONG PrivilegeCount);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _In_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelfEx(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _In_opt_ ACCESS_MASK AdditionalAccess,
    _Out_opt_ PHANDLE ThreadToken);

/************************************************************************************
*
* RTL Version API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG MajorVersion,
    _Out_opt_ PULONG MinorVersion,
    _Out_opt_ PULONG BuildNumber);

/************************************************************************************
*
* RTL Error Status API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status);

/************************************************************************************
*
* RTL WOW64 Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID DisableFsRedirection,
    _Out_ PVOID *OldFsRedirectionLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext);

/************************************************************************************
*
* RTL Heap Management API.
*
************************************************************************************/

typedef NTSTATUS(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    _In_  PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_ SIZE_T ReserveSize,
    _In_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ PVOID HeapHandle);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_opt_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_ SIZE_T HeapInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps);

typedef NTSTATUS(NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter);

/************************************************************************************
*
* RTL Compression API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace);

/************************************************************************************
*
* RTL Image API.
*
************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID Base);

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS * OutHeaders);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection);

NTSYSAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID BaseOfImage,
    _In_ PSTR RoutineName);

NTSYSAPI
NTSTATUS
NTAPI
RtlGuardCheckLongJumpTarget(
    _In_ PVOID PcValue,
    _In_ BOOL IsFastFail,
    _Out_ PBOOL IsLongJumpTarget);

/************************************************************************************
*
* RTL Time API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);


NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime(
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime);

NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime(
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
ULONGLONG
NTAPI
RtlGetSystemTimePrecise(
    VOID);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlGetInterruptTimePrecise(
    _Out_ PLARGE_INTEGER PerformanceCounter);

NTSYSAPI
BOOLEAN
NTAPI
RtlQueryUnbiasedInterruptTime(
    _Out_ PLARGE_INTEGER InterruptTime);

NTSYSAPI
KSYSTEM_TIME
NTAPI
RtlGetSystemTimeAndBias(
    _Out_ KSYSTEM_TIME TimeZoneBias,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveStart,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveEnd);

/************************************************************************************
*
* RTL Debug Support API.
*
************************************************************************************/

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PCH Format,
    ...);

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PSTR Format,
    ...);

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process);

/************************************************************************************
*
* RTL AVL Tree API.
*
************************************************************************************/

typedef enum _TABLE_SEARCH_RESULT {
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

#if defined (__cplusplus)
struct _RTL_AVL_TABLE;
#else
typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE *_RTL_AVL_TABLE;
#endif

typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ ULONG ByteSize
    );

typedef VOID(NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS(NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table);

/************************************************************************************
*
* RTL Critical Section Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

/************************************************************************************
*
* RTL SRW Lock Support API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared);

/************************************************************************************
*
* RTL UAC Support API.
*
************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Inout_ ULONG *ElevationFlags);

/************************************************************************************
*
* RTL Misc Support API.
*
************************************************************************************/

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName);

NTSYSAPI
ULONG
NTAPI
RtlGetLongestNtPathLength(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreLongPathsEnabled(
    VOID);

/************************************************************************************
*
* RTL Boundary Descriptor API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags);

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ _Post_invalid_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel);

/************************************************************************************
*
* RTL work item/async IO.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueWorkItem(
    _In_ WORKERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    _In_ HANDLE FileHandle,
    _In_ APC_CALLBACK_FUNCTION CompletionProc,
    _In_ ULONG Flags);

/************************************************************************************
*
* RTL data exports.
*
************************************************************************************/

#ifndef _M_X64
#define RtlNtdllName L"ntdll.dll"
#define RtlDosPathSeperatorsString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\/"))
#define RtlAlternateDosPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"/"))
#define RtlNtPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\"))
#else
NTSYSAPI PWSTR RtlNtdllName;
NTSYSAPI UNICODE_STRING RtlDosPathSeperatorsString;
NTSYSAPI UNICODE_STRING RtlAlternateDosPathSeperatorString;
NTSYSAPI UNICODE_STRING RtlNtPathSeperatorString;
#endif

/************************************************************************************
*
* ETW API.
*
************************************************************************************/

typedef VOID(NTAPI *PETWENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ /*EVENT_FILTER_DESCRIPTOR*/ PVOID FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PETWENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle);

NTSYSAPI
ULONG
NTAPI
EtwEventWriteNoRegistration(
    _In_ LPCGUID ProviderId,
    _In_ /*PCEVENT_DESCRIPTOR*/ PVOID EventDescriptor,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) /*PEVENT_DATA_DESCRIPTOR*/PVOID UserData);


/*
** Runtime Library API END
*/

/*
** Native API START
*/

/************************************************************************************
*
* System Information API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
WINAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength);

/************************************************************************************
*
* Event (EventPair) API.
*
************************************************************************************/

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

/************************************************************************************
*
* Mutant API.
*
************************************************************************************/

typedef enum _MUTANT_INFORMATION_CLASS {
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION {
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Timer API.
*
************************************************************************************/

typedef VOID(*PTIMER_APC_ROUTINE) (
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _TIMER_INFORMATION_CLASS {
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN WakeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PVOID Parameters);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PVOID Parameters);

//ref from ph2

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime);


/************************************************************************************
*
* Semaphore API.
*
************************************************************************************/

typedef enum _SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Object and Handle API.
*
************************************************************************************/
typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION_V2 {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

NTSYSAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength);

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Time.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime);

/************************************************************************************
*
* Directory Object API.
*
************************************************************************************/

#define OBJDIR_FLAG_SHADOW_PRESENT 0x4
#define OBJDIR_FLAG_SANDBOX 0x10

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Private Namespace API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle);

/************************************************************************************
*
* Symbolic Link API.
*
************************************************************************************/

typedef enum _SYMBOLIC_LINK_INFO_CLASS {
    SymbolicLinkGlobalInformation = 1,
    SymbolicLinkAccessMask,
    MaxnSymbolicLinkInfoClass
} SYMBOLIC_LINK_INFO_CLASS;

typedef struct _OBJECT_SYMBOLIC_LINK_V1 { //pre Win10 TH1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
} OBJECT_SYMBOLIC_LINK_V1, *POBJECT_SYMBOLIC_LINK_V1;

typedef struct _OBJECT_SYMBOLIC_LINK_V2 { //Win10 TH1/TH2
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
} OBJECT_SYMBOLIC_LINK_V2, *POBJECT_SYMBOLIC_LINK_V2;

typedef struct _OBJECT_SYMBOLIC_LINK_V3 { //Win10 RS1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
} OBJECT_SYMBOLIC_LINK_V3, *POBJECT_SYMBOLIC_LINK_V3;

typedef struct _OBJECT_SYMBOLIC_LINK_V4 { //Win10 RS2+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    //long __PADDING__[1];
} OBJECT_SYMBOLIC_LINK_V4, *POBJECT_SYMBOLIC_LINK_V4; /* size: 0x0028 */

typedef struct _OBJECT_SYMBOLIC_LINK_V5 { //Win10 21H1+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    ULONG IntegrityLevel;
} OBJECT_SYMBOLIC_LINK_V5, * POBJECT_SYMBOLIC_LINK_V5; /* size: 0x0028 */

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget);

NTSYSAPI
NTSTATUS
WINAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG  ReturnedLength);

NTSTATUS
NTAPI
NtSetInformationSymbolicLink(
    _In_ HANDLE LinkHandle,
    _In_ SYMBOLIC_LINK_INFO_CLASS SymbolicLinkInformationClass,
    _In_reads_bytes_(SymbolicLinkInformationLength) PVOID SymbolicLinkInformation,
    _In_ ULONG SymbolicLinkInformationLength);

/************************************************************************************
*
* File API (+Driver&HotPatch).
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_bytecount_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadHotPatch(
    _In_ PUNICODE_STRING HotPatchName,
    _Reserved_ ULONG LoadFlag);

NTSYSAPI
NTSTATUS
NTAPI
NtManageHotPatch(
    _In_ ULONG HotPatchInformation,
    _In_ PVOID HotPatchData,
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Section API (+MemoryPartitions).
*
************************************************************************************/

#define MEM_EXECUTE_OPTION_ENABLE 0x1
#define MEM_EXECUTE_OPTION_DISABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
    SystemMemoryPartitionInformation,
    SystemMemoryPartitionMoveMemory,
    SystemMemoryPartitionAddPagefile,
    SystemMemoryPartitionCombineMemory,
    SystemMemoryPartitionInitialAddMemory,
    SystemMemoryPartitionGetMemoryEvents,
    SystemMemoryPartitionSetAttributes,
    SystemMemoryPartitionNodeInformation,
    SystemMemoryPartitionCreateLargePages,
    SystemMemoryPartitionDedicatedMemoryInformation,
    SystemMemoryPartitionOpenDedicatedMemory,
    SystemMemoryPartitionMemoryChargeAttributes,
    SystemMemoryPartitionClearAttributes,
    SystemMemoryPartitionSetMemoryThresholds,
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

typedef struct _MEMORY_PARTITION_PAGE_RANGE {
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
    PVOID StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;

    // Fields added RS1+
    ULONG_PTR StandbyPageCountByPriority[8];
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR MaximumCommitLimit;
    ULONG_PTR DonatedPagesToPartitions;
    ULONG PartitionId;
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, * PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSectionEx(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile);

//
// NtCreatePartition
//

//
// 10248
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV1)(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode);

//
// 10586
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV2)(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

//
// Actual NtCreatePartition definition since Win10 10586
//
NTSYSAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _Inout_updates_bytes_(PartitionInformationLength) PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength);

/************************************************************************************
*
* Token API.
*
************************************************************************************/
//
// This part is taken from PH ntseapi.h.
//

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

//
// endof ntseapi.h
//

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle);

#ifndef DISABLE_MAX_PRIVILEGE
#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#endif

#ifndef SANDBOX_INERT
#define SANDBOX_INERT           0x2 // winnt
#endif

#ifndef LUA_TOKEN
#define LUA_TOKEN               0x4 // winnt
#endif

#ifndef WRITE_RESTRICTED
#define WRITE_RESTRICTED        0x8 // winnt
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal);

NTSYSAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles);

/************************************************************************************
*
* Registry API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName);

NTSYSAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags);

//https://gist.github.com/tyranid/1db47869da253a912242c694e921009d#file-ntloadkeyex3-h

typedef enum _KEY_LOAD_HANDLE_TYPE {
    KeyLoadTrustKey = 1,
    KeyLoadEvent,
    KeyLoadToken
} KEY_LOAD_HANDLE_TYPE;

typedef struct _KEY_LOAD_HANDLE {
    KEY_LOAD_HANDLE_TYPE Type;
    HANDLE Handle;
} KEY_LOAD_HANDLE, *PKEY_LOAD_HANDLE;

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey3(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_ PKEY_LOAD_HANDLE LoadEntries,
    _In_ ULONG LoadEntryCount,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _In_ PVOID Unused);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI 
NtCreateRegistryTransaction(
    _Out_ PHANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess, //generic + TRANSACTION_*
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ DWORD Flags);

NTSYSAPI
NTSTATUS
NTAPI 
NtCommitRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenRegistryTransaction(
    _Out_ PHANDLE RegistryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI 
NtRollbackRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);


/************************************************************************************
*
* Job API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus);

/************************************************************************************
*
* Session API.
*
************************************************************************************/

typedef struct _SESSION_OBJECT {
    KEVENT Event;
    PVOID SessionGlobal; //MM_SESSION_SPACE ptr
} SESSION_OBJECT, * PSESSION_OBJECT;

//taken from ph2

typedef enum _IO_SESSION_EVENT {
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE {
    IoSessionStateCreated = 1,
    IoSessionStateInitialized,
    IoSessionStateConnected,
    IoSessionStateDisconnected,
    IoSessionStateDisconnectedLoggedOn,
    IoSessionStateLoggedOn,
    IoSessionStateLoggedOff,
    IoSessionStateTerminated,
    IoSessionStateMax
} IO_SESSION_STATE;

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize);

/************************************************************************************
*
* IO Completion API.
*
************************************************************************************/

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Count);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Transactions API.
*
************************************************************************************/

//TmTx
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_ ULONG CreateOptions,
    _In_ ULONG IsolationLevel,
    _In_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID);

//TmRm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmEn
NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmTm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_ ULONG CreateOptions,
    _In_ ULONG CommitStrength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_ ULONG OpenOptions);

/************************************************************************************
*
* Performance Counter.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency);

/************************************************************************************
*
* Process and Thread API.
*
************************************************************************************/

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, * PINITIAL_TEB;

#define PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS 0x00000001

#define QUEUE_USER_APC_FLAGS_NONE               0
#define QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC   1

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_opt_ PVOID ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, //THREAD_CREATE_FLAGS_*
    _In_opt_ ULONG_PTR ZeroBits,
    _In_opt_ SIZE_T StackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessStateChange(
    _Out_ PHANDLE ProcessStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeProcessState(
    _In_ HANDLE ProcessStateChangeHandle,
    _In_ HANDLE ProcessHandle,
    _In_ PROCESS_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadStateChange(
    _Out_ PHANDLE ThreadStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ThreadHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeThreadState(
    _In_ HANDLE ThreadStateChangeHandle,
    _In_ HANDLE ThreadHandle,
    _In_ THREAD_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

NTSYSAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength);

typedef VOID(*PPS_APC_ROUTINE) (
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx2(
    _In_ HANDLE ThreadHandle,
    _In_ HANDLE UserApcReserveHandle,
    _In_ ULONG QueueUserApcFlags, /*QUEUE_USER_APC_FLAGS*/
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2,
    _In_opt_ PVOID SystemArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThreadByThreadId(
    _In_ HANDLE ThreadId);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval);

NTSYSAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID);

/************************************************************************************
*
* License API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize);

/************************************************************************************
*
* Virtual Memory API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG PageProtection,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect);

#define MAP_PROCESS 1L
#define MAP_SYSTEM  2L

NTSYSAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSTATUS
NTAPI
NtFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ struct _IO_STATUS_BLOCK* IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length);

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority);

/************************************************************************************
*
* Port API.
*
************************************************************************************/

typedef struct _PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    HANDLE SectionHandle;               // Handle to section object with
                                        // SECTION_MAP_WRITE and SECTION_MAP_READ
    ULONG  SectionOffset;               // The offset in the section to map a view for
                                        // the port data area. The offset must be aligned 
                                        // with the allocation granularity of the system.
    SIZE_T ViewSize;                    // The size of the view (in bytes)
    PVOID  ViewBase;                    // The base address of the view in the creator
                                        // 
    PVOID  ViewRemoteBase;              // The base address of the view in the process
                                        // connected to the port.
} PORT_VIEW, * PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    SIZE_T ViewSize;                    // The size of the view (bytes)
    PVOID  ViewBase;                    // Base address of the view

} REMOTE_PORT_VIEW, * PREMOTE_PORT_VIEW;

typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        SIZE_T ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_MESSAGE32 {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID32 ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE32, * PPORT_MESSAGE32;

typedef struct _PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        ULONGLONG ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE64, * PPORT_MESSAGE64;

typedef struct _PORT_DATA_ENTRY {
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#ifndef InitializeMessageHeader
#define InitializeMessageHeader(ph, l, t)                              \
{                                                                      \
    (ph)->u1.s1.TotalLength      = (USHORT)(l);                        \
    (ph)->u1.s1.DataLength       = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->u2.s2.Type             = (USHORT)(t);                        \
    (ph)->u2.s2.DataInfoOffset   = 0;                                  \
    (ph)->ClientId.UniqueProcess = NULL;                               \
    (ph)->ClientId.UniqueThread  = NULL;                               \
    (ph)->MessageId              = 0;                                  \
    (ph)->ClientViewSize         = 0;                                  \
}
#endif

#define LPC_REQUEST                 1
#define LPC_REPLY                   2
#define LPC_DATAGRAM                3
#define LPC_LOST_REPLY              4
#define LPC_PORT_CLOSED             5
#define LPC_CLIENT_DIED             6
#define LPC_EXCEPTION               7
#define LPC_DEBUG_EVENT             8
#define LPC_ERROR_EVENT             9
#define LPC_CONNECTION_REQUEST      10
#define LPC_CONTINUATION_REQUIRED   0x2000


#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_ ULONG MaxPoolUsage);

NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtClosePort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_opt_ PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Out_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_	PVOID ConnectionInformation,
    _Inout_opt_	PULONG ConnectionInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView);

NTSYSAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_ PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength);

/************************************************************************************
*
* Boot Management API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength);

/************************************************************************************
*
* Reserve Objects API.
*
************************************************************************************/

typedef enum _MEMORY_RESERVE_TYPE {
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type);

/************************************************************************************
*
* Debug API.
*
************************************************************************************/

//
// Define the debug object thats used to attatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);


/************************************************************************************
*
* Profile API.
*
************************************************************************************/

typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity);

NTSYSAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source);

/************************************************************************************
*
* Signing Levels API.
*
************************************************************************************/
typedef UCHAR SE_SIGNING_LEVEL, * PSE_SIGNING_LEVEL;

#ifndef SE_SIGNING_LEVEL_UNCHECKED
#define SE_SIGNING_LEVEL_UNCHECKED         0x00000000
#endif

#ifndef SE_SIGNING_LEVEL_UNSIGNED
#define SE_SIGNING_LEVEL_UNSIGNED          0x00000001
#endif

#ifndef SE_SIGNING_LEVEL_ENTERPRISE
#define SE_SIGNING_LEVEL_ENTERPRISE        0x00000002
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_1
#define SE_SIGNING_LEVEL_CUSTOM_1          0x00000003
#endif

#ifndef SE_SIGNING_LEVEL_DEVELOPER
#define SE_SIGNING_LEVEL_DEVELOPER         SE_SIGNING_LEVEL_CUSTOM_1
#endif

#ifndef SE_SIGNING_LEVEL_AUTHENTICODE
#define SE_SIGNING_LEVEL_AUTHENTICODE      0x00000004
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_2
#define SE_SIGNING_LEVEL_CUSTOM_2          0x00000005
#endif

#ifndef SE_SIGNING_LEVEL_STORE
#define SE_SIGNING_LEVEL_STORE             0x00000006
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_3
#define SE_SIGNING_LEVEL_CUSTOM_3          0x00000007
#endif

#ifndef SE_SIGNING_LEVEL_ANTIMALWARE
#define SE_SIGNING_LEVEL_ANTIMALWARE       SE_SIGNING_LEVEL_CUSTOM_3
#endif

#ifndef SE_SIGNING_LEVEL_MICROSOFT
#define SE_SIGNING_LEVEL_MICROSOFT         0x00000008
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_4
#define SE_SIGNING_LEVEL_CUSTOM_4          0x00000009
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_5
#define SE_SIGNING_LEVEL_CUSTOM_5          0x0000000A
#endif

#ifndef SE_SIGNING_LEVEL_DYNAMIC_CODEGEN
#define SE_SIGNING_LEVEL_DYNAMIC_CODEGEN   0x0000000B
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS
#define SE_SIGNING_LEVEL_WINDOWS           0x0000000C
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_7
#define SE_SIGNING_LEVEL_CUSTOM_7          0x0000000D
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS_TCB
#define SE_SIGNING_LEVEL_WINDOWS_TCB       0x0000000E
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_6
#define SE_SIGNING_LEVEL_CUSTOM_6          0x0000000F
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile);

NTSYSAPI
NTSTATUS
NTAPI
NtGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm);

//REDSTONE 2 and above
NTSYSAPI
NTSTATUS
NTAPI
NtCompareSigningLevels(
    _In_ SE_SIGNING_LEVEL FirstSigningLevel,
    _In_ SE_SIGNING_LEVEL SecondSigningLevel);

/************************************************************************************
*
* Worker Factory API.
*
************************************************************************************/

typedef enum _WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle);

/************************************************************************************
*
* Event Tracing API.
*
************************************************************************************/

typedef enum _TRACE_CONTROL_INFORMATION_CLASS {
    TraceControlStartLogger = 1,
    TraceControlStopLogger = 2,
    TraceControlQueryLogger = 3,
    TraceControlUpdateLogger = 4,
    TraceControlFlushLogger = 5,
    TraceControlIncrementLoggerFile = 6,
    TraceControlInvalidClass1 = 7,
    TraceControlInvalidCalss2 = 8,
    TraceControlInvalidClass3 = 9,
    TraceControlInvalidClass4 = 10,
    TraceControlRealtimeConnect = 11,
    TraceControlWdiDispatchControl = 13,
    TraceControlRealtimeDisconnectConsumerByHandle = 14,
    TraceControlReceiveNotification = 16,
    TraceControlEnableGuid = 17,
    TraceControlSendReplyDataBlock = 18,
    TraceControlReceiveReplyDataBlock = 19,
    TraceControlWdiUpdateSem = 20,
    TraceControlGetTraceGuidList = 21,
    TraceControlGetTraceGuidInfo = 22,
    TraceControlEnumerateTraceGuids = 23,
    TraceControlInvalidClass5 = 24,
    TraceControlQueryReferenceTime = 25,
    TraceControlTrackProviderBinary = 26,
    TraceControlAddNotificationEvent = 27,
    TraceControlUpdateDisallowList = 28,
    TraceControlInvalidClass6 = 29,
    TraceControlInvalidClass7 = 30,
    TraceControlUseDescriptorTypeUm = 31,
    TraceControlGetTraceGroupList = 32,
    TraceControlGetTraceGroupInfo = 33,
    TraceControlTraceSetDisallowList = 34,
    TraceControlSetCompressionSettings = 35,
    TraceControlGetCompressionSettings = 36,
    TraceControlUpdatePeriodicCaptureState = 37,
    TraceControlGetPrivateSessionTraceHandle = 38,
    TraceControlRegisterPrivateSession = 39,
    TraceControlQuerySessionDemuxObject = 40,
    TraceControlSetProviderBinaryTracking = 41,
    TraceControlMaxLoggers = 42,
    TraceControlMaxPmcCounter = 43
} TRACE_CONTROL_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields);

NTSYSAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Enclave API.
*
************************************************************************************/

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef LPVOID(WINAPI* PENCLAVE_ROUTINE) (LPVOID lpThreadParameter);
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread);

NTSYSAPI
NTSTATUS
NTAPI
NtCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID* ReturnValue);


/************************************************************************************
*
* LUID/UUID API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid);


/************************************************************************************
*
* Kernel Debugger API.
*
************************************************************************************/

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump,
    SysDbgKdPullRemoteFile,
    SysDbgMaxInfoClass
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

NTSYSAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* HardError API.
*
************************************************************************************/

#ifndef HARDERROR_OVERRIDE_ERRORMODE
#define HARDERROR_OVERRIDE_ERRORMODE 0x10000000
#endif

typedef enum _HARDERROR_RESPONSE_OPTION {
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE {
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response);

/************************************************************************************
*
* Thread Pooling API and definitions.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL* PoolReturn,
    _Reserved_ PVOID Reserved);

NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK* WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron);

NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks);

/************************************************************************************
*
* Application Verifier API and definitions.
*
************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

typedef VOID(NTAPI *RTL_VERIFIER_DLL_LOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
    PVOID AllocationBase,
    SIZE_T AllocationSize);

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;
} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    DWORD Length;
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

//
// Application verifier standard flags.
//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

NTSYSAPI
VOID
NTAPI
RtlApplicationVerifierStop(
    _In_ ULONG_PTR Code,
    _In_ PSTR Message,
    _In_ ULONG_PTR Param1,
    _In_ PSTR Description1,
    _In_ ULONG_PTR Param2,
    _In_ PSTR Description2,
    _In_ ULONG_PTR Param3,
    _In_ PSTR Description3,
    _In_ ULONG_PTR Param4,
    _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif

//
// NTOS_RTL HEADER END
//

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTOS_RTL

```

`Source/ntproto.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       NTPROTO.H
*
*  VERSION:     1.00
*
*  DATE:        01 May 2023
*
*  Common header file for the NT API prototypes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

typedef NTSTATUS(NTAPI* pfnGenericCall)();

typedef NTSTATUS(NTAPI* pfnNtQuerySystemInformation)(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

typedef NTSTATUS(NTAPI* pfnNtOpenProcess)(
    PHANDLE ProcessHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PCLIENT_ID ClientId);

typedef NTSTATUS(NTAPI* pfnNtOpenFile)(
    PHANDLE FileHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK IoStatusBlock,
    ULONG ShareAccess,
    ULONG OpenOptions);

typedef NTSTATUS(NTAPI* pfnNtCreateSection)(
    PHANDLE SectionHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PLARGE_INTEGER MaximumSize,
    ULONG SectionPageProtection,
    ULONG AllocationAttributes,
    HANDLE FileHandle);

typedef NTSTATUS(NTAPI* pfnNtMapViewOfSection)(
    HANDLE SectionHandle,
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    ULONG_PTR ZeroBits,
    SIZE_T CommitSize,
    PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize,
    SECTION_INHERIT InheritDisposition,
    ULONG AllocationType,
    ULONG Win32Protect);

typedef NTSTATUS(NTAPI* pfnNtUnmapViewOfSection)(
    HANDLE ProcessHandle,
    PVOID BaseAddress);

typedef NTSTATUS(NTAPI* pfnNtQueryInformationProcess)(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

```

`Source/ntuser.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2023
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTUSER.H
*
*  VERSION:     1.18
*
*  DATE:        15 Jun 2023
*
*  Common header file for the NtUser API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*                 NtOs.h
*
*  Include:       Windows.h
*                 NtStatus.h
*                 NtOs.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTUSER_RTL
#define NTUSER_RTL

//
// NtUser definitions are incomplete and only valid for Windows 10 RS4+
//
enum HANDLE_TYPE {
    TYPE_FREE = 0,
    TYPE_WINDOW = 1,
    TYPE_MENU = 2,
    TYPE_CURSOR = 3,
    TYPE_SETWINDOWPOS = 4,
    TYPE_HOOK = 5,
    TYPE_CLIPDATA = 6,
    TYPE_CALLPROC = 7,
    TYPE_ACCELTABLE = 8,
    TYPE_DDEACCESS = 9,
    TYPE_DDECONV = 10,
    TYPE_DDEXACT = 11,
    TYPE_MONITOR = 12,
    TYPE_KBDLAYOUT = 13,
    TYPE_KBDFILE = 14,
    TYPE_WINEVENTHOOK = 15,
    TYPE_TIMER = 16,
    TYPE_INPUTCONTEXT = 17,
    TYPE_HIDDATA = 18,
    TYPE_DEVICEINFO = 19,
    TYPE_TOUCHINPUT = 20,
    TYPE_GESTUREINFO = 21,
    TYPE_CTYPES = 22,
    TYPE_GENERIC = 255
};

#define TIF_INCLEANUP               0x00000001
#define TIF_16BIT                   0x00000002
#define TIF_SYSTEMTHREAD            0x00000004
#define TIF_CSRSSTHREAD             0x00000008
#define TIF_TRACKRECTVISIBLE        0x00000010
#define TIF_ALLOWFOREGROUNDACTIVATE 0x00000020
#define TIF_DONTATTACHQUEUE         0x00000040
#define TIF_DONTJOURNALATTACH       0x00000080
#define TIF_WOW64                   0x00000100
#define TIF_INACTIVATEAPPMSG        0x00000200
#define TIF_SPINNING                0x00000400
#define TIF_PALETTEAWARE            0x00000800
#define TIF_SHAREDWOW               0x00001000
#define TIF_FIRSTIDLE               0x00002000
#define TIF_WAITFORINPUTIDLE        0x00004000
#define TIF_MOVESIZETRACKING        0x00008000
#define TIF_VDMAPP                  0x00010000
#define TIF_DOSEMULATOR             0x00020000
#define TIF_GLOBALHOOKER            0x00040000
#define TIF_DELAYEDEVENT            0x00080000
#define TIF_MSGPOSCHANGED           0x00100000
#define TIF_SHUTDOWNCOMPLETE        0x00200000
#define TIF_IGNOREPLAYBACKDELAY     0x00400000
#define TIF_ALLOWOTHERACCOUNTHOOK   0x00800000
#define TIF_GUITHREADINITIALIZED    0x02000000
#define TIF_DISABLEIME              0x04000000
#define TIF_INGETTEXTLENGTH         0x08000000
#define TIF_ANSILENGTH              0x10000000
#define TIF_DISABLEHOOKS            0x20000000

#define HANDLEF_DESTROY        0x01
#define HANDLEF_INDESTROY      0x02
#define HANDLEF_MARKED_OK      0x10
#define HANDLEF_GRANTED        0x20
#define HANDLEF_POOL           0x40
#define HANDLEF_VALID          0x7F

#if defined(__cplusplus)
extern "C" {
#endif

#ifdef _WIN32ULIB_PRESENT
#pragma comment(lib, "win32u.lib")
#endif

typedef struct _SERVERINFO {
    WORD wRIPFlags;
    WORD wSRVIFlags;
    WORD wRIPPID;
    WORD wRIPError;
    ULONG cHandleEntries; //+8 
    ULONG_PTR pDispInfo;
    // incomplete
} SERVERINFO, * PSERVERINFO;

typedef struct _HANDLEENTRY {
    HANDLE hWnd;
    HANDLE pti;
    PVOID rpdesk;
    BYTE bType;
    BYTE bFlags;
    USHORT wUniq;
} HANDLEENTRY, * PHANDLEENTRY;

typedef struct _tagWND {
    HANDLE hWnd;
    ULONG_PTR DesktopHeapOffset;
    ULONG_PTR UnknownFlags;
    DWORD dwExStyle;
    DWORD dwStyle;
    BYTE Spare[0x130];
} tagWND, * PWND; //sizeof 0x150

//win 11  v33 = HMAllocObject(v208, v255, v31, 328); 0x148

typedef struct _DESKINFO {
    PVOID rpdesk;
} DESKINFO, * PDESKINFO;

typedef struct _CLIENTINFO {
    ULONG_PTR CI_Flags;
    ULONG_PTR cSpins;
    DWORD dwExpWinVer;
    DWORD dwCompatFlags;
    DWORD dwCompatFlags2;
    DWORD dwTIFlags;
    PDESKINFO pDeskInfo;
    PVOID DesktopHeap;
    //incomplete
} CLIENTINFO, * PCLIENTINFO;

typedef struct _SHAREDINFO {
    PSERVERINFO	psi;
    PHANDLEENTRY aheList;
    ULONG HeEntrySize;
    // incomplete
} SHAREDINFO, * PSHAREDINFO;

#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define HMUNIQSHIFT             16              // bits to shift uniqueness
#define HMUNIQBITS              0xFFFF          // valid uniqueness bits
#define HMUniqFromHandle(h)     ((WORD)((((ULONG_PTR)h) >> HMUNIQSHIFT) & HMUNIQBITS))
#define HMIndexFromHandle(h)    ((ULONG)(((ULONG_PTR)(h)) & HMINDEXBITS))
#define PtiFromHe(p)            (((PHANDLEENTRY)p)->pti)

typedef enum tagPROCESS_UICONTEXT {
    PROCESS_UICONTEXT_DESKTOP = 0,
    PROCESS_UICONTEXT_IMMERSIVE = 1,
    PROCESS_UICONTEXT_IMMERSIVE_BROKER = 2,
    PROCESS_UICONTEXT_IMMERSIVE_BROWSER = 3
} PROCESS_UICONTEXT;

typedef enum tagPROCESS_UI_FLAGS {
    PROCESS_UIF_NONE = 0,
    PROCESS_UIF_AUTHORING_MODE = 1,
    PROCESS_UIF_RESTRICTIONS_DISABLED = 2
} PROCESS_UI_FLAGS;

typedef struct tagPROCESS_UICONTEXT_INFORMATION {
    DWORD processUIContext; //PROCESS_UICONTEXT
    DWORD dwFlags; //PROCESS_UI_FLAGS
} PROCESS_UICONTEXT_INFORMATION, * PPROCESS_UICONTEXT_INFORMATION;


typedef HWINSTA(NTAPI* pfnNtUserOpenWindowStation)(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ACCESS_MASK DesiredAccess);


#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTUSER_RTL

```

`Source/probes.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       PROBES.CPP
*
*  VERSION:     1.00
*
*  DATE:        30 Jun 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

ULONG g_cAnomalies = 0;

PROBE_CONTEXT* gProbeContext;

#define WINTRUST_INIT TEXT("Init->WinTrust")
#define CONTEXT_ALLOCATED TEXT("Init->Probe Context")

ULONG SkiGetAnomalyCount()
{
    return g_cAnomalies;
}

/*
* SkQueryNtdllBase
*
* Purpose:
*
* Find ntdll base by different methods and verify results.
*
*/
BOOL SkQueryNtdllBase(
    _In_ PPROBE_CONTEXT Context
)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    ULONG_PTR nt1 = 0, nt2 = 0;
    WCHAR szDescription[MAX_TEXT_LENGTH];

    nt1 = (ULONG_PTR)GetModuleHandle(RtlNtdllName);
    nt2 = (ULONG_PTR)supGetImageBaseUnsafe((ULONG_PTR)NtCurrentPeb()->LoaderLock);

    if (nt1 != nt2) {

        SkiIncreaseAnomalyCount();

        StringCchPrintf(szDescription,
            RTL_NUMBER_OF(szDescription),
            L"LDR: 0x%llX, MEMORY: 0x%llX",
            nt1,
            nt2);

        supReportEvent(evtError,
            (LPWSTR)TEXT("NTDLL base is ambiguous"),
            szDescription,
            DT_NTDLL_IMAGEBASE_QUERY);
    }

    Context->NtDllBase = (PVOID)nt1;

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

NTSTATUS SkValidateClientInfo(
    _In_ TEB* Teb,
    _In_ PEB* Peb,
    _Inout_ PCLIENT_ID ClientId
)
{
    NTSTATUS ntStatus;
    CLIENT_ID cid;
    OBJECT_ATTRIBUTES obja;
    HANDLE hObject = NULL;
    PROCESS_BASIC_INFORMATION pbi;
    ULONG returnLength = 0;

    //
    // Validate TEB->ClientId.
    //
    cid = Teb->ClientId;
    *ClientId = cid;

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

    ntStatus = NtOpenThread(&hObject, SYNCHRONIZE, &obja, &cid);
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    if (SkIsThreadInformationTampered(TRUE, NtCurrentThread(), hObject))
        ntStatus = STATUS_INVALID_CID;

    NtClose(hObject);
    hObject = NULL;

    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    cid.UniqueThread = NULL;
    ntStatus = NtOpenProcess(&hObject, PROCESS_QUERY_LIMITED_INFORMATION, &obja, &cid);
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    //
    // Validate PEB ptr for some stubborns.
    //
    ntStatus = NtQueryInformationProcess(hObject, 
        ProcessBasicInformation, 
        &pbi, 
        sizeof(pbi), 
        &returnLength);
    
    if (!NT_SUCCESS(ntStatus)) {
        NtClose(hObject);
        return ntStatus;
    }

    if (Peb != pbi.PebBaseAddress) {
        ntStatus = STATUS_CONFLICTING_ADDRESSES;
    }

    if (NT_SUCCESS(ntStatus)) {
        if (SkIsThreadInformationTampered(TRUE, NtCurrentProcess(), hObject))
            ntStatus = STATUS_INVALID_CID;
    }

    NtClose(hObject);

    if (!NT_SUCCESS(ntStatus))
        return ntStatus;


    //
    // Validate PEB->ImageBaseAddress.
    //
    PVOID pvImageBase = NULL;
    PUNICODE_STRING pusFileName;

    pusFileName = (PUNICODE_STRING)supGetProcessInfoVariableSize(ProcessImageFileName, &returnLength);
    if (pusFileName) {
        ntStatus = supMapImageNoExecute(pusFileName, &pvImageBase);
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = NtAreMappedFilesTheSame(Peb->ImageBaseAddress, pvImageBase);
            NtUnmapViewOfSection(NtCurrentProcess(),
                pvImageBase);
        }
        supHeapFree(pusFileName);
    }
    return ntStatus;
}

/*
* SkCreateContext
*
* Purpose:
*
* Intiialize global pointers.
*
*/
PPROBE_CONTEXT SkCreateContext(
    _In_ PPROBE_SETTINGS Settings
)
{
    HRESULT hr;
    NTSTATUS ntStatus;
    ULONG dummy;
    HMODULE hModule;
    PPROBE_CONTEXT ctx;
    WCHAR szBuffer[MAX_PATH * 2];

    TEB* Teb = NtCurrentTeb();
    PEB* Peb = Teb->ProcessEnvironmentBlock;

    SIZE_T size;
    MEMORY_IMAGE_INFORMATION mii;

    ctx = (PPROBE_CONTEXT)supHeapAlloc(sizeof(PROBE_CONTEXT));
    if (ctx == NULL)
        return NULL;

    ntStatus = SkValidateClientInfo(Teb, Peb, &ctx->ClientId);
    if (!NT_SUCCESS(ntStatus)) {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Client information is tampered"),
            (LPWSTR)__FUNCTIONW__,
            NULL);
    }

    if (Peb->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL) {
        SkReportNtCallRIP(STATUS_INVALID_ADDRESS_COMPONENT,
            (LPWSTR)TEXT("Sxs DotLocal is enabled for client"),
            (LPWSTR)__FUNCTIONW__,
            NULL);
    }

    supIsProcessElevated(ctx->ClientId.UniqueProcess, &ctx->IsClientElevated);

    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        supHeapFree(ctx);

        SkReportComCallRIP(hr,
            (LPWSTR)TEXT("COM initialization failed"),
            (LPWSTR)__FUNCTIONW__,
            NULL);

        return NULL;
    }

    RtlGetNtVersionNumbers(&ctx->WindowsMajorVersion, &ctx->WindowsMinorVersion, NULL);
    ntStatus = supQueryNtOsInformation(&ctx->ReferenceNtBuildNumber, &ctx->NtOsBase);
    if (!NT_SUCCESS(ntStatus)) {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query NTOS information"),
            (LPWSTR)__FUNCTIONW__,
            NULL);
    }
    else {
        ctx->Win10FeaturePack = IS_WIN10_FEATURE_PACK_RANGE(ctx->ReferenceNtBuildNumber);
    }

    ctx->SelfBase = Peb->ImageBaseAddress;
    ntStatus = NtQueryVirtualMemory(NtCurrentProcess(),
        ctx->SelfBase,
        MemoryImageInformation,
        &mii,
        sizeof(mii),
        &size);

    if (!NT_SUCCESS(ntStatus)) {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query own image information"),
            (LPWSTR)__FUNCTIONW__,
            NULL);
    }
    else {
        ctx->SelfSize = mii.SizeOfImage;
    }

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    _strcpy(szBuffer, USER_SHARED_DATA->NtSystemRoot);
    _strcat(szBuffer, TEXT("\\system32\\wintrust.dll"));
    hModule = LoadLibraryEx(szBuffer, NULL, 0);
    if (hModule != NULL) {
        ctx->WTGetSignatureInfo = (ptrWTGetSignatureInfo)GetProcAddress(hModule, "WTGetSignatureInfo");
    }

    ctx->Settings.Flags = Settings->Flags;

    ctx->SystemRangeStart = supQuerySystemRangeStart();
    if (ctx->SystemRangeStart == 0)
        if (ctx->WindowsMajorVersion > 8 ||
            (ctx->WindowsMajorVersion == 8 && ctx->WindowsMinorVersion == 1))
        {
            ctx->SystemRangeStart = 0xFFFF800000000000;
        }
        else {
            ctx->SystemRangeStart = 0xFFFF080000000000;
        }

    ntStatus = NtQuerySystemInformation(SystemBasicInformation,
        &ctx->SystemInfo,
        sizeof(SYSTEM_BASIC_INFORMATION),
        &dummy);

    if (!NT_SUCCESS(ntStatus)) {

        ctx->SystemInfo.MaximumUserModeAddress = 0x00007FFFFFFEFFFF;
        ctx->SystemInfo.MinimumUserModeAddress = 0x0000000000010000;

        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query system basic information"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemBasicInformation"));

    }
    return ctx;
}

VOID SkDestroyContext(
    _In_ PPROBE_CONTEXT* Context)
{
    if ((*Context)->NtOsBase)
        NtUnmapViewOfSection(NtCurrentProcess(),
            (*Context)->NtOsBase);
    supHeapFree(*Context);
    *Context = NULL;
}

/*
* SkStartProbe
*
* Purpose:
*
* Thread for all probing routines.
*
*/
DWORD SkpProbeThread(
    _In_ LPVOID Parameter
)
{
    BOOL bWinTrustInitialized;
    DWORD dwWaitResult;
    DR_EVENT_TYPE evt = evtInformation;
    PROBE_STARTUP_INFO si = *(PROBE_STARTUP_INFO*)Parameter;
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    dwWaitResult = WaitForSingleObject(gProbeWait, INFINITE);
    if (dwWaitResult == WAIT_OBJECT_0) {

        EnableMenuItem(GetMenu(si.MainWindow), ID_PROBES_SETTINGS, MF_BYCOMMAND | MF_DISABLED);
        EnableMenuItem(GetMenu(si.MainWindow), ID_PROBES_SAVETOFILE, MF_BYCOMMAND | MF_DISABLED);

        supStatusBarSetText(hwndStatusBar, 0, (LPCWSTR)TEXT("Scan in progress, please wait..."));

        szBuffer[0] = 0;
        SkiInitializeAnomalyCount();

        if (si.IsFirstRun == FALSE)
            ListView_DeleteAllItems(hwndList);

        if (gProbeContext) {
            SkDestroyContext(&gProbeContext);
        }

        gProbeContext = SkCreateContext(&si.Settings);
        if (gProbeContext == NULL) {
            REPORT_RIP(TEXT("Cannot allocate probe context, abort"));
            ExitThread(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            REPORT_TEST_PASSED(CONTEXT_ALLOCATED);
        }

        bWinTrustInitialized = (gProbeContext->WTGetSignatureInfo != NULL);

        if (bWinTrustInitialized)
            REPORT_TEST_PASSED(WINTRUST_INIT);
        else
            REPORT_RIP(WINTRUST_INIT);

        //
        // Locate ntdll base.
        //
        if (SkQueryNtdllBase(gProbeContext))
            REPORT_TEST_PASSED(TEXT("Testing->NTDLL Base"));

        //
        // Run common tests.
        //
        if (gProbeContext->Settings.CommonChecks) {
            if (SkQuerySafePolicy())
                REPORT_TEST_PASSED(TEXT("Testing->Unsafe CI Policy"));
            if (SkCheckSystemDebugControl())
                REPORT_TEST_PASSED(TEXT("Testing->System Debug Control"));
            if (SkCheckDebugPrivileges())
                REPORT_TEST_PASSED(TEXT("Testing->DebugPrivileges"));
        }

        //
        // Walk for various wubbaboos.
        //
        if (bWinTrustInitialized) {
            if (gProbeContext->Settings.VerifyPEBLdr) {
                if (SkWalkPEB(gProbeContext))
                    REPORT_TEST_PASSED(TEXT("Testing->Loader List Modules"));
            }
            if (gProbeContext->Settings.VerifyLoadedDrivers) {
                if (SkWalkLoadedDrivers(gProbeContext))
                    REPORT_TEST_PASSED(TEXT("Testing->Loaded Drivers Verification"));
            }
        }

        //
        // Detect kernel wubbaboos.
        //
        if (gProbeContext->Settings.CheckDeviceObjects) {
            if (SkNoKernelWubbaboos())
                REPORT_TEST_PASSED(TEXT("Testing->Suspicious Device Objects"));
        }

        //
        // Verify Windows version information.
        //
        if (gProbeContext->Settings.VerifyWinVer) {
            if (SkVerifyWinVersion(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Windows Version Information"));
        }

        //
        // Validate process lists.
        //
        if (gProbeContext->Settings.ValidateProcList) {
            if (SkValidateProcessList(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Process List"));
        }

        //
        // Validate own thread list.
        //
        if (gProbeContext->Settings.ValidateThreadList) {
            if (SkValidateThreadList(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Own Thread List"));
        }

        //
        // Analyze ntdll filtering.
        //
        if (gProbeContext->Settings.ValidateNtDllCopies) {
            if (SkLoadNtDllCopies())
                REPORT_TEST_PASSED(TEXT("Testing->NTDLL Mapping"));
        }

        //
        // Perform stack analysis.
        //
        if (gProbeContext->Settings.StackWalk) {
            if (SkStackWalk(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Stack Walk"));
        }

        //
        // WS check.
        //
        if (gProbeContext->Settings.WsSetWalk) {
            if (SkWsSetWalk())
                REPORT_TEST_PASSED(TEXT("Testing->Process Working Set (Page)"));
        }

        if (gProbeContext->Settings.WsSetWatch) {
            if (SkWsSetWatch(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Process Working Set (Watch)"));
        }

        //
        // Perform syscall tests.
        //
        if (gProbeContext->Settings.CheckNtOsSyscalls) {
            if (SkTestSyscalls(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->NTOS System Call Verification"));
        }
        if (gProbeContext->Settings.CheckWin32kSyscalls) {
            if (SkValidateWin32uSyscalls(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Win32k System Call Verification"));
        }

        //
        // Check debugging.
        //
        if (gProbeContext->Settings.CheckDebug) {
            if (SkCheckDebug(gProbeContext->NtDllBase))
                REPORT_TEST_PASSED(TEXT("Testing->Debugger Detection"));
        }

        //
        // Debug objects check.
        //
        if (gProbeContext->Settings.CheckHandles) {
            if (SkCheckHandles(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->NT Object Handles"));
        }

        //
        // Walk NtUser/NtGdi tables.
        // This is parsing of a new format available since W10 RS4.
        //
        if (gProbeContext->WindowsMajorVersion >= 10) {
            if (gProbeContext->Settings.WalkUserHandleTable) {
                if (SkUserHandleTableWalk(gProbeContext))
                    REPORT_TEST_PASSED(TEXT("Testing->UserHandleTable (Win10 RS4+)"));
            }
            if (gProbeContext->Settings.WalkGdiSharedHandleTable) {
                if (SkGdiSharedHandleTableWalk(gProbeContext))
                    REPORT_TEST_PASSED(TEXT("Testing->GdiSharedHandleTable (Win10 RS4+)"));
            }
        }

        //
        // Test boot configuration data. Requires elevated client.
        //
        if (gProbeContext->Settings.CheckBootConfiguration) {
            if (gProbeContext->IsClientElevated) {
                if (SkTestBootConfiguration())
                    REPORT_TEST_PASSED(TEXT("Testing->BootConfigurationData"));
            }
            else {
                REPORT_TEST_SKIPPED(TEXT("BootConfigurationData Test Skipped -> Elevation Required"));
            }

        }

        //
        // Test handle tracing.
        //
        if (gProbeContext->Settings.HandleTracing) {
            if (SkHandleTracing(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Handle Tracing"));
        }

        //
        // Scan process memory.
        //
        if (gProbeContext->Settings.CheckProcessMemory) {
            if (SkCheckProcessMemory(gProbeContext))
                REPORT_TEST_PASSED(TEXT("Testing->Process Memory Regions"));
        }

        ULONG count = SkiGetAnomalyCount();
        if (count == 0) {
            _strcpy(szBuffer, TEXT("No Wubbaboos are detected during tests (｀□′)╯┴┴"));
        }
        else {
            evt = evtWarning;
            StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
                TEXT("Number of Wubbaboos detected: %lu  ( ｡ᵘ ᵕ ᵘ ｡)"),
                count);
        }

        supReportEvent(evt,
            szBuffer,
            NULL,
            NULL);

        supStatusBarSetText(hwndStatusBar, 0, szBuffer);

        ReleaseMutex(gProbeWait);
        EnableMenuItem(GetMenu(si.MainWindow), ID_PROBES_SAVETOFILE, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem(GetMenu(si.MainWindow), ID_PROBES_SETTINGS, MF_BYCOMMAND | MF_ENABLED);
    }

    ExitThread(ERROR_SUCCESS);
}

/*
* SkStartProbe
*
* Purpose:
*
* Execute probing thread.
*
*/
VOID SkStartProbe(
    _In_ PROBE_STARTUP_INFO* StartupInfo
)
{
    DWORD threadId;

    if (StartupInfo->IsFirstRun)
    {
        if (FAILED(CoInitializeSecurity(NULL,
            -1,
            NULL,
            NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,
            EOAC_SECURE_REFS,
            NULL)))
        {
            REPORT_RIP(TEXT("Could not initialize COM security"));
            return;
        }
    }

    HANDLE threadHandle = CreateThread(NULL, 0,
        (LPTHREAD_START_ROUTINE)SkpProbeThread,
        (PVOID)StartupInfo, 0, &threadId);

    if (threadHandle) CloseHandle(threadHandle);
}

```

`Source/probes.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       PROBES.H
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Common header file for the program probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef struct _PROBE_SETTINGS {
    union {
        ULONG Flags;
        struct {
            ULONG CommonChecks : 1;
            ULONG VerifyPEBLdr : 1;
            ULONG VerifyLoadedDrivers : 1;
            ULONG CheckDeviceObjects : 1;
            ULONG VerifyWinVer : 1;
            ULONG ValidateProcList : 1;
            ULONG ValidateThreadList : 1;
            ULONG ValidateNtDllCopies : 1;
            ULONG StackWalk : 1;
            ULONG WsSetWalk : 1;
            ULONG WsSetWatch : 1;
            ULONG HandleTracing : 1;
            ULONG CheckNtOsSyscalls : 1;
            ULONG CheckWin32kSyscalls : 1;
            ULONG CheckDebug : 1;
            ULONG CheckHandles : 1;
            ULONG WalkUserHandleTable : 1;
            ULONG WalkGdiSharedHandleTable : 1;
            ULONG CheckBootConfiguration : 1;
            ULONG CheckProcessMemory : 1;
            ULONG Reserved : 12;
        };
    };
} PROBE_SETTINGS, * PPROBE_SETTINGS;

#define PROBE_FLAGS_COMMON_CHECKS               (0x0001)  
#define PROBE_FLAGS_VERIFY_PEBLDR               (0x0002)  
#define PROBE_FLAGS_VERIFY_LOADED_DRIVERS       (0x0004)  
#define PROBE_FLAGS_CHECK_DEVICE_OBJECTS        (0x0008)  
#define PROBE_FLAGS_VERIFY_WINVER               (0x0010)  
#define PROBE_FLAGS_VALIDATE_PROCLIST           (0x0020)  
#define PROBE_FLAGS_VALIDATE_THREADLIST         (0x0040)  
#define PROBE_FLAGS_VALIDATE_NTDLLCOPIES        (0x0080)  
#define PROBE_FLAGS_STACKWALK                   (0x0100)  
#define PROBE_FLAGS_WSSETWALK                   (0x0200)  
#define PROBE_FLAGS_WSSETWATCH                  (0x0400)  
#define PROBE_FLAGS_HANDLETRACING               (0x0800)  
#define PROBE_FLAGS_CHECK_NTOS_SYSCALLS         (0x1000)  
#define PROBE_FLAGS_CHECK_WIN32K_SYSCALLS       (0x2000) 
#define PROBE_FLAGS_CHECK_DEBUG                 (0x4000)  
#define PROBE_FLAGS_CHECK_HANDLES               (0x8000) 
#define PROBE_FLAGS_WALK_USERHADLETABLE         (0x10000) 
#define PROBE_FLAGS_WALK_GDISHAREDHADLETABLE    (0x20000) 
#define PROBE_FLAGS_CHECK_BCD                   (0x40000)
#define PROBE_FLAGS_CHECK_PROCESS_MEMORY        (0x80000)

typedef struct _PROBE_STARTUP_INFO {
    BOOL IsFirstRun;
    HWND MainWindow;
    PROBE_SETTINGS Settings;
} PROBE_STARTUP_INFO, * PPROBE_STARTUP_INFO;

typedef struct _PROBE_CONTEXT {
    BOOL IsClientElevated;
    BOOL Win10FeaturePack;
    ULONG WindowsMajorVersion;
    ULONG WindowsMinorVersion;
    ULONG ReferenceNtBuildNumber;
    HWND MainWindow;
    PROBE_SETTINGS Settings;
    PVOID NtDllBase;
    PVOID NtOsBase;
    PVOID SelfBase;
    SIZE_T SelfSize;
    CLIENT_ID ClientId;
    ULONG_PTR SystemRangeStart;
    ptrWTGetSignatureInfo WTGetSignatureInfo;
    SYSTEM_BASIC_INFORMATION SystemInfo;
} PROBE_CONTEXT, * PPROBE_CONTEXT;

typedef enum _PS_SCAN_TYPE {
    ScanTypeNative,
    ScanTypeWMI,
    ScanTypeAppCompat
} PS_SCAN_TYPE;

#define SkiInitializeAnomalyCount() {  g_cAnomalies = 0; }
#define SkiIncreaseAnomalyCount() { InterlockedIncrement((PLONG)&g_cAnomalies); }

ULONG SkiGetAnomalyCount();

//
// Reports start.
//
VOID SkReportThreadOpenError(
    _In_ HANDLE WindowHandle,
    _In_ HANDLE ThreadId,
    _In_ BOOL IsClientElevated,
    _In_ NTSTATUS NtStatus);

BOOL SkIsThreadInformationTampered(
    _In_ BOOL SuppressOutput,
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

VOID SkReportHiddenProcessWindow(
    _In_ HANDLE UniqueProcessId,
    _In_ HANDLE UniqueThreadId,
    _In_ HANDLE WindowHandle);

VOID SkReportGdiObject(
    _In_ HANDLE UniqueProcessId,
    _In_ OBJTYPE ObjectType);

VOID SkReportSuspectHandleEntry(
    _In_ BOOL IsProcess,
    _In_ PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry);

VOID SkReportParentProcessMismatch(
    _In_ ULONG_PTR InheritedFromUniqueProcessId,
    _In_ ULONG_PTR ParentPID);

VOID SkReportExtractionFailureEvent(
    _In_ LPCSTR lpName,
    _In_opt_ LPWSTR lpDescription,
    _In_ LPWSTR lpAnomalyType);

VOID SkReportInvalidHandleClosure(
    _In_ ULONG ConditionType);

VOID SkReportThreadCountRIP();

VOID SkReportSessionIdRIP(
    _In_ ULONG SessionId);

VOID SkReportThreadUnknownRip(
    _In_ ULONG64 Rip);

VOID SkReportInvalidExtractedSSN(
    _In_ LPWSTR lpQueryType);

VOID SkReportUnexpectedSSN(
    _In_ ULONG SsnGot,
    _In_ ULONG SsnExpected);

VOID SkReportNtdllMapRIP(
    _In_ NTDLL_MAP_METHOD Method);

VOID SkReportObTypeListCorruption(
    _In_ ULONG ReportedLength,
    _In_ ULONG ActualLength);

VOID SkReportHandleListCorruption(
    _In_ ULONG ReportedLength,
    _In_ ULONG ActualLength);

VOID SkReportProcListCorruption(
    _In_ ULONG NextEntryOffset,
    _In_ ULONG ExpectedOffset);

VOID SkReportUnknownCode(
    _In_ ULONG_PTR Address,
    _In_ KPROCESSOR_MODE Mode);

VOID SkReportNtCallRIP(
    _In_ NTSTATUS NtStatus,
    _In_ LPWSTR lpMessage,
    _In_opt_ LPWSTR lpApiName,
    _In_opt_ LPWSTR lpQueryName);

VOID SkReportComCallRIP(
    _In_ HRESULT Hresult,
    _In_ LPWSTR lpMessage,
    _In_opt_ LPWSTR lpApiName,
    _In_opt_ LPWSTR lpQueryName);

VOID SkReportWrongWinVersion(
    _In_ LPWSTR lpMessage,
    _In_ ULONG dwVersionMajor,
    _In_ ULONG dwVersionMinor,
    _In_ ULONG dwBuildNumber,
    _In_ LPWSTR lpType);

VOID SkReportVersionResourceBuildNumber(
    _In_ LPCWSTR DllName,
    _In_ ULONG RefBuildNumber,
    _In_ ULONG BuildNumber);

VOID SkReportDebugObjectHandleMismatch(
    _In_ ULONG NumberOfObjects,
    _In_ ULONG NumberOfObjectsThroughQuery);

VOID SkReportDebugObject(
    _In_ ULONG NumberOfObjects,
    _In_ BOOL IsHandlde);

VOID SkReportDeviceObject(
    _In_ LPWSTR DeviceName);

VOID SkReportDriverListModification(
    _In_ ULONG ReportedLength,
    _In_ ULONG ExpectedLength);

VOID SkReportDebugDetected(
    _In_ ULONG Type,
    _In_ LPWSTR RoutineName,
    _In_opt_ LPWSTR InformationClass);

VOID SkReportBcdProbeMismatch(
    _In_ ULONG ApiQueryData,
    _In_ LPWSTR BcdProbeDescription,
    _In_ ULONG BcdProbeValue);

VOID SkReportSuspectRegion(
    _In_ PMEMORY_BASIC_INFORMATION Information);

//
// Reports end.
//

ULONG SkiQueryAndValidateSSN(
    _In_ PROBE_CONTEXT* Context,
    _In_ LPCSTR lpName,
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ BOOL bValidate);

VOID SkStartProbe(
    _In_ PROBE_STARTUP_INFO* Params);

BOOL SkQuerySafePolicy();
BOOL SkCheckSystemDebugControl();
BOOL SkCheckDebugPrivileges();

BOOL SkCheckBadProcess(
    _In_ ULONG ProcessId,
    _In_ PUNICODE_STRING ProcessName,
    _In_ PS_SCAN_TYPE ScanType);

BOOL SkVerifyWinVersion(
    _In_ PROBE_CONTEXT* Context);

BOOL SkiSetSyscallIndex(
    _In_ PVOID ImageBase,
    _In_ LPCSTR lpName);

BOOL SkWalkPEB(
    _In_ PPROBE_CONTEXT Context);

BOOL SkWalkLoadedDrivers(
    _In_ PPROBE_CONTEXT Context);

BOOL SkLoadNtDllCopies();

BOOL SkTestSyscalls(
    _In_ PPROBE_CONTEXT Context);

BOOL SkTestVectoredCall(
    _In_ ULONG SystemCallNumber,
    _In_ ULONG_PTR SystemCallAddress,
    _In_ SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX* ReferenceInfo);

BOOL SkWsSetWalk(
    VOID);

BOOL SkWsSetWatch(
    _In_ PPROBE_CONTEXT Context);
BOOL SkStackWalk(
    _In_ PPROBE_CONTEXT Context);

BOOL SkNoKernelWubbaboos();

BOOL SkHandleTracing(
    _In_ PPROBE_CONTEXT Context);

BOOL SkCheckHandles(
    _In_ PROBE_CONTEXT* Context);

BOOL SkCheckDebug(
    _In_ PVOID NtDllBase);

BOOL SkValidateProcessList(
    _In_ PROBE_CONTEXT* Context);

BOOL SkValidateThreadList(
    _In_ PROBE_CONTEXT* Context);

BOOL SkValidateWin32uSyscalls(
    _In_ PROBE_CONTEXT* Context);

BOOL SkUserHandleTableWalk(
    _In_ PROBE_CONTEXT* Context);

BOOL SkGdiSharedHandleTableWalk(
    _In_ PROBE_CONTEXT* Context);

BOOL SkTestBootConfiguration();

BOOL SkCheckProcessMemory(
    _In_ PPROBE_CONTEXT Context);

```

`Source/probes/bootcfg.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       BOOTCFG.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Boot configuration probes.
*  Elevation required.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define	BcdLibraryBoolean_DebuggerEnabled            0x16000010
#define BcdLibraryBoolean_DisableIntegrityChecks     0x16000048
#define	BcdLibraryBoolean_AllowPrereleaseSignatures  0x16000049
#define BcdOSLoaderBoolean_WinPEMode                 0x26000022
#define	BcdOSLoaderBoolean_AllowPrereleaseSignatures 0x26000027
#define BcdOSLoaderBoolean_KernelDebuggerEnabled     0x260000a0

#define BCDPROBE_LIB_KDBG   0
#define BCDPROBE_LIB_NOIC   1
#define BCDPROBE_LIB_TEST   2
#define BCDPROBE_LDR_WINPE  3
#define BCDPROBE_LDR_TEST   4
#define BCDPROBE_LDR_KDBG   5

typedef struct _BCD_PROBE {
    ULONG ProbeValue;
    ULONG ProbeResult;
    LPWSTR Description;
} BCD_PROBE, * PBCD_PROBE;

BCD_PROBE bcdProbes[] = {
    { BcdLibraryBoolean_DebuggerEnabled, ERROR_NOT_FOUND, (LPWSTR)TEXT("KernelDebuggerEnabled") },
    { BcdLibraryBoolean_DisableIntegrityChecks, ERROR_NOT_FOUND, (LPWSTR)TEXT("DisableIntegrityChecks") },
    { BcdLibraryBoolean_AllowPrereleaseSignatures, ERROR_NOT_FOUND, (LPWSTR)TEXT("TestModeEnabled") },
    { BcdOSLoaderBoolean_WinPEMode, ERROR_NOT_FOUND, (LPWSTR)TEXT("WinPEMode") },
    { BcdOSLoaderBoolean_AllowPrereleaseSignatures, ERROR_NOT_FOUND, (LPWSTR)TEXT("TestModeEnabled") },
    { BcdOSLoaderBoolean_KernelDebuggerEnabled, ERROR_NOT_FOUND, (LPWSTR)TEXT("KernelDebuggerEnabled") },
};

#define GUID_CURRENT_BOOT_ENTRY TEXT("{FA926493-6F1C-4193-A414-58F0B2456D1E}")

/*
* BcdGetBoolFromArgName
*
* Purpose:
*
* Retrieve bool value from named argument.
*
*/
HRESULT BcdGetBoolFromArgName(
    _In_ LPWSTR Argument,
    _In_ IWbemClassObject* PropertyClass,
    _In_ PBOOL Result
)
{
    HRESULT	hr;
    VARIANT	var;
    CIMTYPE	vt_type;

    *Result = FALSE;

    VariantInit(&var);
    var.vt = VT_BOOL;

    hr = PropertyClass->Get(Argument, 0, &var, &vt_type, 0);
    if (hr == WBEM_S_NO_ERROR &&
        vt_type == VT_BOOL)
    {
        *Result = var.boolVal;
    }

    VariantClear(&var);

    return hr;
}

/*
* BcdSetDWORDArgument
*
* Purpose:
*
* Put DWORD value into call parameters.
*
*/
BOOL BcdSetDWORDArgument(
    _In_ IWbemClassObject* PropertyClass,
    _In_ LPWSTR Argument,
    _In_ DWORD Value
)
{
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = Value;

    hr = PropertyClass->Put(Argument, 0, &var, 0);
    VariantClear(&var);

    return hr == WBEM_S_NO_ERROR;
}

/*
* BcdSetStringArgument
*
* Purpose:
*
* Put BSTR string into call parameters.
*
*/
BOOL BcdSetStringArgument(
    _In_ IWbemClassObject* PropertyClass,
    _In_ LPWSTR Argument,
    _In_ LPWSTR String
)
{
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(String);
    if (var.bstrVal == NULL)
        return FALSE;

    hr = PropertyClass->Put(Argument, 0, &var, 0);

    SysFreeString(var.bstrVal);
    VariantClear(&var);
    return hr == WBEM_S_NO_ERROR;
}

/*
* BcdGetMethodResult
*
* Purpose:
*
* Extract method result as bool value.
*
*/
HRESULT BcdGetMethodResult(
    _In_ IWbemClassObject* pOutParamsObj,
    _Inout_ PBOOL Result)
{
    HRESULT hr;

    hr = BcdGetBoolFromArgName((LPWSTR)TEXT("ReturnValue"),
        pOutParamsObj, Result);

    if (SUCCEEDED(hr)) {

        if (*Result == FALSE)
            hr = E_FAIL;
    }

    return hr;
}

/*
* BcdGetObjectFromArgs
*
* Purpose:
*
* Extract method object from arguments.
*
*/
HRESULT BcdGetObjectFromArgs(
    _In_ IWbemClassObject* PropertyClass,
    _In_ LPWSTR Argument,
    _Inout_ IWbemClassObject** Result
)
{
    HRESULT	hr;
    VARIANT	var;
    CIMTYPE	vt_type;

    *Result = FALSE;

    VariantInit(&var);
    var.vt = VT_UNKNOWN;

    hr = PropertyClass->Get(Argument, 0, &var, &vt_type, 0);
    if (hr == WBEM_S_NO_ERROR &&
        vt_type == VT_UNKNOWN)
    {
        hr = var.punkVal->QueryInterface(IID_IWbemClassObject, (void**)Result);
    }

    VariantClear(&var);
    return hr;
}

/*
* BcdMethodCall
*
* Purpose:
*
* Execute object method.
*
*/
HRESULT BcdMethodCall(
    _In_ IWbemServices* WbemServices,
    _In_ IWbemClassObject* ObjectInstance,
    _In_ IWbemClassObject* pInParamsObj,
    _In_ IWbemClassObject** pOutParamsObj,
    _In_ BSTR MethodName
)
{
    BOOL bResult = FALSE;
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);

    hr = ObjectInstance->Get(TEXT("__Relpath"), 0, &var, NULL, NULL);
    if (FAILED(hr))
        return hr;

    hr = WbemServices->ExecMethod(var.bstrVal,
        MethodName,
        0,
        NULL,
        pInParamsObj,
        pOutParamsObj,
        NULL);

    if (FAILED(hr))
        return hr;

    if (*pOutParamsObj == NULL)
        return E_OUTOFMEMORY;

    hr = BcdGetMethodResult(*pOutParamsObj, &bResult);
    if (SUCCEEDED(hr)) {
        if (bResult == FALSE)
            hr = E_FAIL;
    }

    return hr;
}

/*
* BcdInitMethodCall
*
* Purpose:
*
* Get COM class object and it method by name.
*
*/
HRESULT BcdInitMethodCall(
    _In_ IWbemServices* WbemServices,
    _In_ LPWSTR ObjectClassName,
    _In_ LPWSTR MethodName,
    _Out_ IWbemClassObject** InParamsObj,
    _Out_ IWbemClassObject** ObjectClass,
    _Out_ BSTR* AllocatedMethodName
)
{
    BOOL bOk = FALSE;
    HRESULT hr = E_FAIL;
    IWbemClassObject* pObjectClass = NULL;
    IWbemClassObject* pInParamsClass = NULL;
    IWbemClassObject* pInParamsObj = NULL;
    BSTR objectClass = NULL, methodName = NULL;

    *InParamsObj = NULL;
    *ObjectClass = NULL;
    *AllocatedMethodName = NULL;

    do {

        objectClass = SysAllocString(ObjectClassName);
        if (objectClass == NULL)
            break;

        methodName = SysAllocString(MethodName);
        if (methodName == NULL)
            break;

        hr = WbemServices->GetObject(objectClass,
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            &pObjectClass,
            NULL);

        if (hr != WBEM_S_NO_ERROR)
            break;

        hr = pObjectClass->GetMethod(methodName, 0, &pInParamsClass, NULL);
        if (hr != WBEM_S_NO_ERROR)
            break;

        hr = pInParamsClass->SpawnInstance(0, &pInParamsObj);
        if (hr != WBEM_S_NO_ERROR)
            break;

        *InParamsObj = pInParamsObj;
        *ObjectClass = pObjectClass;
        *AllocatedMethodName = methodName;

        bOk = TRUE;

    } while (FALSE);

    if (pInParamsClass) pInParamsClass->Release();

    if (objectClass) SysFreeString(objectClass);

    if (bOk == FALSE && methodName)
        SysFreeString(methodName);

    return hr;
}

/*
* BcdOpenDefaultOsLoader
*
* Purpose:
*
* Retrieve default OsLoader object to work with.
*
*/
HRESULT BcdOpenDefaultOsLoader(
    _In_ IWbemServices* WbemServices,
    _In_ IWbemClassObject* pBCDStoreObject,
    _Out_ IWbemClassObject** OsLoaderObject)
{
    HRESULT hr;
    IWbemClassObject* pOsLoaderObject = NULL;
    IWbemClassObject* pObjectClass = NULL;
    IWbemClassObject* pInParamsObj = NULL;
    IWbemClassObject* pOutParamsObj = NULL;
    BSTR methodName = NULL;

    *OsLoaderObject = NULL;

    hr = BcdInitMethodCall(WbemServices,
        (LPWSTR)TEXT("BcdStore"),
        (LPWSTR)TEXT("OpenObject"),
        &pInParamsObj,
        &pObjectClass,
        &methodName);

    if (FAILED(hr))
        return hr;

    if (BcdSetStringArgument(pInParamsObj,
        (LPWSTR)TEXT("Id"),
        (LPWSTR)GUID_CURRENT_BOOT_ENTRY)) //{current} 
    {
        hr = BcdMethodCall(WbemServices,
            pBCDStoreObject,
            pInParamsObj,
            &pOutParamsObj,
            methodName);

        if (SUCCEEDED(hr) && pOutParamsObj) {
            hr = BcdGetObjectFromArgs(pOutParamsObj,
                (LPWSTR)TEXT("Object"), &pOsLoaderObject);

            if (SUCCEEDED(hr))
                *OsLoaderObject = pOsLoaderObject;
        }

    }

    if (methodName) SysFreeString(methodName);
    if (pOutParamsObj) pOutParamsObj->Release();
    if (pInParamsObj) pInParamsObj->Release();
    if (pObjectClass) pObjectClass->Release();

    return hr;
}

/*
* BcdOpenDefaultStore
*
* Purpose:
*
* Retrieve object to work with default BCD store.
*
*/
HRESULT BcdOpenDefaultStore(
    _In_ IWbemServices* WbemServices,
    _Out_ IWbemClassObject** BCDStoreObject)
{
    HRESULT hr;
    IWbemClassObject* pStoreObject = NULL;
    IWbemClassObject* pObjectClass = NULL;
    IWbemClassObject* pInParamsObj = NULL;
    IWbemClassObject* pOutParamsObj = NULL;
    BSTR methodName = NULL;

    *BCDStoreObject = NULL;

    hr = BcdInitMethodCall(WbemServices,
        (LPWSTR)TEXT("BcdStore"),
        (LPWSTR)TEXT("OpenStore"),
        &pInParamsObj,
        &pObjectClass,
        &methodName);

    if (FAILED(hr))
        return hr;

    if (pObjectClass == NULL)
        return E_FAIL;

    if (BcdSetStringArgument(pInParamsObj,
        (LPWSTR)TEXT("File"),
        (LPWSTR)TEXT("")))
    {
        hr = BcdMethodCall(WbemServices,
            pObjectClass,
            pInParamsObj,
            &pOutParamsObj,
            methodName);

        if (SUCCEEDED(hr) && pOutParamsObj) {
            hr = BcdGetObjectFromArgs(pOutParamsObj,
                (LPWSTR)TEXT("Store"), &pStoreObject);

            if (SUCCEEDED(hr))
                *BCDStoreObject = pStoreObject;
        }

    }

    if (methodName) SysFreeString(methodName);
    if (pOutParamsObj) pOutParamsObj->Release();
    if (pInParamsObj) pInParamsObj->Release();
    pObjectClass->Release();

    return hr;
}

/*
* BcdGetElementAsBool
*
* Purpose:
*
* Retrieve bool value from BCD store.
*
*/
BOOL BcdGetElementAsBool(
    _In_ IWbemServices* WbemServices,
    _In_ IWbemClassObject* OSLoaderObject,
    _In_ DWORD ElementID,
    _In_ PULONG Value)
{
    HRESULT hr;
    IWbemClassObject* pElementObject = NULL;
    IWbemClassObject* pObjectClass = NULL;
    IWbemClassObject* pInParamsObj = NULL;
    IWbemClassObject* pOutParamsObj = NULL;
    BSTR methodName;
    ULONG value = 0;

    *Value = 0;

    hr = BcdInitMethodCall(WbemServices,
        (LPWSTR)TEXT("BcdObject"),
        (LPWSTR)TEXT("GetElement"),
        &pInParamsObj,
        &pObjectClass,
        &methodName);

    if (SUCCEEDED(hr)) {

        if (BcdSetDWORDArgument(pInParamsObj,
            (LPWSTR)TEXT("Type"),
            ElementID))
        {
            hr = BcdMethodCall(WbemServices,
                OSLoaderObject,
                pInParamsObj,
                &pOutParamsObj,
                methodName);

            if (SUCCEEDED(hr) && pOutParamsObj) {

                hr = BcdGetObjectFromArgs(pOutParamsObj,
                    (LPWSTR)TEXT("Element"), &pElementObject);

                if (SUCCEEDED(hr)) {

                    hr = BcdGetBoolFromArgName(
                        (LPWSTR)TEXT("Boolean"),
                        pElementObject, (PBOOL)&value);

                    if (SUCCEEDED(hr)) {
                        *Value = value;
                    }

                    pElementObject->Release();
                }
            }
            else {
                if (hr == HRESULT_FROM_NT(STATUS_NOT_FOUND))
                    RtlSetLastWin32Error(ERROR_NOT_FOUND);
            }
        }
    }

    if (methodName) SysFreeString(methodName);
    if (pOutParamsObj) pOutParamsObj->Release();
    if (pInParamsObj) pInParamsObj->Release();
    if (pObjectClass) pObjectClass->Release();

    return SUCCEEDED(hr);
}

/*
* SkiBcdValidate
*
* Purpose:
*
* Compare results.
*
*/
VOID SkiBcdValidate(
    _In_ IWbemServices* WbemServices,
    _In_ IWbemClassObject* OsLoaderObject
)
{
    NTSTATUS ntStatus;
    ULONG probeResult = 0;
    ULONG returnLength;
    SYSTEM_CODEINTEGRITY_INFORMATION sci;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX skdi;

    BOOL ReportedTestMode = FALSE;
    BOOL ReportedCiEnabled = FALSE;

    sci.Length = sizeof(sci);

    ntStatus = NtQuerySystemInformation(SystemCodeIntegrityInformation,
        &sci,
        sizeof(sci),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        ReportedTestMode = sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_TESTSIGN;
        ReportedCiEnabled = sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED;
    }
    else {

        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query CI information"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemCodeIntegrityInformation"));

    }

    for (ULONG i = 0; i < RTL_NUMBER_OF(bcdProbes); i++) {

        if (BcdGetElementAsBool(WbemServices,
            OsLoaderObject,
            bcdProbes[i].ProbeValue,
            &probeResult))
        {
            bcdProbes[i].ProbeResult = probeResult;
        }
    }

    //
    // TEST MODE? SURE NOT.
    //
    if (ReportedTestMode == FALSE) {

        if (bcdProbes[BCDPROBE_LDR_TEST].ProbeResult > 0 &&
            bcdProbes[BCDPROBE_LDR_TEST].ProbeResult != ERROR_NOT_FOUND)
        {
            SkReportBcdProbeMismatch(ReportedTestMode, 
                bcdProbes[BCDPROBE_LDR_TEST].Description, 
                bcdProbes[BCDPROBE_LDR_TEST].ProbeValue);
        }

        if (bcdProbes[BCDPROBE_LIB_TEST].ProbeResult > 0 &&
            bcdProbes[BCDPROBE_LIB_TEST].ProbeResult != ERROR_NOT_FOUND)
        {
            SkReportBcdProbeMismatch(ReportedTestMode, 
                bcdProbes[BCDPROBE_LIB_TEST].Description, 
                bcdProbes[BCDPROBE_LIB_TEST].ProbeValue);
        }
    }

    //
    // CODEINTEGRITY? ALWAYS ENABLED.
    //
    if (ReportedCiEnabled) {
        if (bcdProbes[BCDPROBE_LDR_WINPE].ProbeResult > 0 &&
            bcdProbes[BCDPROBE_LDR_WINPE].ProbeResult != ERROR_NOT_FOUND)
        {
            SkReportBcdProbeMismatch(ReportedCiEnabled, 
                bcdProbes[BCDPROBE_LDR_WINPE].Description,
                bcdProbes[BCDPROBE_LDR_WINPE].ProbeValue);
        }

        if (bcdProbes[BCDPROBE_LIB_NOIC].ProbeResult > 0 &&
            bcdProbes[BCDPROBE_LIB_NOIC].ProbeResult != ERROR_NOT_FOUND)
        {
            SkReportBcdProbeMismatch(ReportedCiEnabled, 
                bcdProbes[BCDPROBE_LIB_NOIC].Description,
                bcdProbes[BCDPROBE_LIB_NOIC].ProbeValue);
        }
    }

    //
    // KERNEL DEBUG? OF COURSE NOT.
    //
    ntStatus = NtQuerySystemInformation(
        SystemKernelDebuggerInformationEx,
        &skdi,
        sizeof(skdi),
        &returnLength);

    if (NT_SUCCESS(ntStatus))
    {
        if (skdi.DebuggerEnabled == FALSE) {
            if (bcdProbes[BCDPROBE_LDR_KDBG].ProbeResult > 0 &&
                bcdProbes[BCDPROBE_LDR_KDBG].ProbeResult != ERROR_NOT_FOUND)
            {
                SkReportBcdProbeMismatch(skdi.DebuggerEnabled, 
                    bcdProbes[BCDPROBE_LDR_KDBG].Description,
                    bcdProbes[BCDPROBE_LDR_KDBG].ProbeValue);
            }

            if (bcdProbes[BCDPROBE_LIB_KDBG].ProbeResult > 0 &&
                bcdProbes[BCDPROBE_LIB_KDBG].ProbeResult != ERROR_NOT_FOUND)
            {
                SkReportBcdProbeMismatch(skdi.DebuggerEnabled, 
                    bcdProbes[BCDPROBE_LIB_KDBG].Description,
                    bcdProbes[BCDPROBE_LIB_KDBG].ProbeValue);
            }
        }
    }
    else {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query kernel debugger information"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemKernelDebuggerInformationEx"));
    }
}

/*
* SkTestBootConfiguration
*
* Purpose:
*
* Read specific values from Boot Configuration Data current entry and validate them against API.
*
*/
BOOL SkTestBootConfiguration()
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    HRESULT hr = S_OK;
    IWbemClassObject* pStoreObject = NULL;
    IWbemClassObject* pOsLoaderObject = NULL;
    IWbemLocator* WbemLocator = NULL;
    IWbemServices* WbemServices = NULL;
    BSTR bstrServer = NULL;

    bstrServer = SysAllocString(L"ROOT\\WMI");
    if (bstrServer == NULL) {

        SkReportComCallRIP(E_NOT_SUFFICIENT_BUFFER,
            (LPWSTR)TEXT("Failed to allocate memory for WMI root"),
            (LPWSTR)TEXT("SysAllocString"),
            NULL);

        return FALSE;
    }

    hr = CoCreateInstance(CLSID_WbemLocator,
        0,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID*)&WbemLocator);

    if (SUCCEEDED(hr)) {

        hr = WbemLocator->ConnectServer(bstrServer, NULL, NULL, NULL, 0, NULL, NULL, &WbemServices);
        if (SUCCEEDED(hr)) {

            hr = CoSetProxyBlanket(WbemServices,
                RPC_C_AUTHN_WINNT,
                RPC_C_AUTHZ_NONE,
                NULL,
                RPC_C_AUTHN_LEVEL_CALL,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,
                EOAC_NONE);

            if (SUCCEEDED(hr)) {

                hr = BcdOpenDefaultStore(WbemServices, &pStoreObject);
                if (SUCCEEDED(hr)) {

                    hr = BcdOpenDefaultOsLoader(WbemServices, pStoreObject, &pOsLoaderObject);
                    if (SUCCEEDED(hr)) {

                        SkiBcdValidate(WbemServices, pOsLoaderObject);
                        pOsLoaderObject->Release();

                    }
                    else {
                        SkReportComCallRIP(hr,
                            (LPWSTR)TEXT("Failed to open default OsLoader store"),
                            (LPWSTR)TEXT("BcdOpenDefaultOsLoader"),
                            NULL);
                    }

                    pStoreObject->Release();
                }
                else {

                    SkReportComCallRIP(hr,
                        (LPWSTR)TEXT("Failed to open default BCD store"),
                        (LPWSTR)TEXT("BcdOpenBCDStoreDefault"),
                        NULL);

                }

            }
            else {

                SkReportComCallRIP(hr,
                    (LPWSTR)TEXT("Failed to set authentification for proxy calls"),
                    (LPWSTR)TEXT("CoSetProxyBlanket"),
                    NULL);

            }

            WbemServices->Release();
        }
        else {

            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Failed to connect WMI server"),
                (LPWSTR)TEXT("ConnectServer"),
                NULL);

        }

        WbemLocator->Release();
    }
    else {

        SkReportComCallRIP(hr,
            (LPWSTR)TEXT("Failed to create WMI object"),
            (LPWSTR)TEXT("CoCreateInstance"),
            NULL);

    }

    SysFreeString(bstrServer);
    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/common.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       COMMON.CPP
*
*  VERSION:     1.00
*
*  DATE:        30 Jun 2023
*
*  Common probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* SkQuerySafePolicy
*
* Purpose:
*
* Check for custom kernel signers policy enabled.
*
*/
BOOL SkQuerySafePolicy()
{
    BOOLEAN bAllowed = FALSE;
    NTSTATUS ntStatus;

    ntStatus = supCICustomKernelSignersAllowed(&bAllowed);
    if (NT_SUCCESS(ntStatus)) {

        if (bAllowed) {

            SkiIncreaseAnomalyCount();
            supReportEvent(evtDetection,
                (LPWSTR)TEXT("Unsafe CI policy is enabled"),
                NULL,
                DT_UNSAFE_CIPOLICY);

            return FALSE;
        }
    }
    else {

        if (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to query license data"),
                (LPWSTR)TEXT("CustomKernelSigners"),
                (LPWSTR)TEXT("NtQueryLicenseValue"));

        }
    }

    return TRUE;
}

/*
* SkCheckSystemDebugControl
*
* Purpose:
*
* Check for proper retun of NtSystemDebugControl.
*
*/
BOOL SkCheckSystemDebugControl()
{
    NTSTATUS ntStatus = NtSystemDebugControl(SysDbgQueryModuleInformation,
        NULL, 0, NULL, 0, NULL);

    if (ntStatus == STATUS_DEBUGGER_INACTIVE)
        return TRUE;

    SkiIncreaseAnomalyCount();

    supReportEvent(evtDetection,
        (LPWSTR)TEXT("Kernel Debugger Is Active"),
        (LPWSTR)TEXT("NtSystemDebugControl"),
        DT_KERNELDEBUGGER);

    return FALSE;
}

/*
* SkCheckDebugPrivileges
*
* Purpose:
*
* Check for SeDebugPrivileges, we do not request them.
*
*/
BOOL SkCheckDebugPrivileges()
{
    BOOL bEnabled = FALSE;
    HANDLE tokenHandle = NULL;
    NTSTATUS ntStatus;

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = supPrivilegeEnabled(tokenHandle, SE_DEBUG_PRIVILEGE, &bEnabled);
        if (NT_SUCCESS(ntStatus)) {
            if (bEnabled) {
                supReportEvent(evtDetection,
                    (LPWSTR)TEXT("DebugPrivileges are enabled for client"),
                    NULL,
                    DT_PRIVILEGES);

                return FALSE;
            }
        }
        else {
            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to check process privileges"),
                (LPWSTR)TEXT("NtPrivilegeCheck"),
                DT_PRIVILEGES);
        }

        NtClose(tokenHandle);
    }
    else {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to open process token"),
            (LPWSTR)TEXT("NtOpenProcessToken"),
            DT_PRIVILEGES);
    }

    return TRUE;
}

```

`Source/probes/debugger.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       DEBUGGER.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Debugger detection probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

/*
* SkCheckDebug
*
* Purpose:
*
* Check for debugger presence.
*
*/
BOOL SkCheckDebug(
    _In_ PVOID NtDllBase
)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();

    if (supDetectDebug(CheckDrXReg)) {

        SkReportDebugDetected(
            0,
            (LPWSTR)TEXT("Context Registers"),
            DT_DEBUGGER_DRX);
    }

    if (KiSystemCallAddress && SkiSetSyscallIndex(NtDllBase, g_NtTestSet[PROC_INDEX_QIP])) {

        if (supDetectDebug(CheckDebugObjectHandle)) {
            SkReportDebugDetected(0,
                (LPWSTR)TEXT("ProcessDebugObjectHandle"),
                (LPWSTR)(TEXT("NtQueryInformationProcess")));
        }

        if (supDetectDebug(CheckDebugPort)) {
            SkReportDebugDetected(0,
                (LPWSTR)TEXT("ProcessDebugPort"),
                (LPWSTR)(TEXT("NtQueryInformationProcess")));
        }

        if (supDetectDebug(CheckDebugFlags)) {
            SkReportDebugDetected(0,
                (LPWSTR)TEXT("ProcessDebugFlags"),
                (LPWSTR)(TEXT("NtQueryInformationProcess")));
        }
    }

    if (supDetectDebug(CheckUSD)) {
        SkReportDebugDetected(1,
            (LPWSTR)TEXT("USER_SHARED_DATA"),
            NULL);
    }

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/handletrace.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       HANDLETRACE.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Trace handler probe.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

VOID TraceHandle(
    _In_ PROBE_CONTEXT *Context,
    _In_ HANDLE Handle,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;
    PROCESS_HANDLE_TRACING_QUERY trace;

    RtlSecureZeroMemory(&trace, sizeof(trace));
    trace.Handle = Handle;

    ntStatus = NtQueryInformationProcess(NtCurrentProcess(), ProcessHandleTracing, &trace, sizeof(trace), NULL);
    if (!NT_SUCCESS(ntStatus)) {

        //
        // That's an error that should never happen. Raise wubbaboos.
        //

        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Error cannot query handle tracing"),
            (LPWSTR)TEXT("NtQueryInformationProcess"),
            (LPWSTR)TEXT("ProcessHandleTracing"));

        return;
    }

    for (ULONG i = 0; i < trace.TotalTraces; i++) {
        for (ULONG j = 0; j < PROCESS_HANDLE_TRACING_MAX_STACKS; j++) {

            ULONG moduleIndex = 0;
            PVOID stackAddress = trace.HandleTrace[i].Stacks[j];

            if (stackAddress == NULL)
                continue;

            if (!supFindModuleEntryByAddress(pvModules,
                stackAddress,
                &moduleIndex))
            {

                if ((ULONG_PTR)stackAddress >= Context->SystemRangeStart) {

                    SkReportUnknownCode((ULONG_PTR)stackAddress, 0);

                }
                else {


                    PVOID cookie = NULL;
                    ntStatus = LdrLockLoaderLock(0, NULL, &cookie);

                    if (NT_SUCCESS(ntStatus)) {

                        PLDR_DATA_TABLE_ENTRY entry;

                        ntStatus = LdrFindEntryForAddress(stackAddress, (PLDR_DATA_TABLE_ENTRY*)&entry);
                        if (!NT_SUCCESS(ntStatus)) {

                            SkReportUnknownCode((ULONG_PTR)stackAddress, 1);

                        }

                        LdrUnlockLoaderLock(0, cookie);
                    }
                    else {
                        SkReportNtCallRIP(ntStatus,
                            (LPWSTR)TEXT("Error cannot lock loader list"),
                            (LPWSTR)TEXT("LdrLockLoaderLock"),
                            NULL);
                    }
                }
            }
        }
    }
}

VOID TraceSectionHandle(
    _In_ PROBE_CONTEXT *Context,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;
    HANDLE sectionHandle = NULL, fileHandle = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName;
    IO_STATUS_BLOCK iost;

    RtlInitUnicodeString(&usName, L"\\systemroot\\system32\\ntdll.dll"); //lay in trap
    InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    ntStatus = NtOpenFile(&fileHandle,
        SYNCHRONIZE | FILE_EXECUTE,
        &obja,
        &iost,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS(ntStatus)) {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Error cannot open test file"),
            (LPWSTR)TEXT("NtOpenFile"),
            NULL);
        return;
    }

    RtlInitUnicodeString(&usName, L"\\RPC Control\\hui32");

    ntStatus = NtCreateSection(&sectionHandle,
        SECTION_ALL_ACCESS,
        &obja,
        NULL,
        PAGE_EXECUTE,
        SEC_IMAGE,
        fileHandle);

    if (NT_SUCCESS(ntStatus)) {

        TraceHandle(Context, sectionHandle, pvModules);

        NtClose(sectionHandle);
    }
    else {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Error cannot create test section"),
            (LPWSTR)TEXT("NtCreateSection"),
            NULL);
    }

    NtClose(fileHandle);
}

/*
* SkHandleTracing
*
* Purpose:
*
* Trace handles.
*
*/
BOOL SkHandleTracing(
    _In_ PPROBE_CONTEXT Context)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    NTSTATUS ntStatus;
    PROCESS_HANDLE_TRACING_ENABLE traceEnable;
    PRTL_PROCESS_MODULES pvModules;

    traceEnable.Flags = 0;

    ntStatus = NtSetInformationProcess(NtCurrentProcess(),
        ProcessHandleTracing,
        &traceEnable,
        sizeof(traceEnable));

    if (!NT_SUCCESS(ntStatus)) {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Error cannot enable handle tracing"),
            (LPWSTR)TEXT("NtSetInformationProcess"),
            (LPWSTR)TEXT("ProcessHandleTracing"));
    }

    pvModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, NULL);
    if (pvModules) {
        TraceSectionHandle(Context, pvModules);
        supHeapFree(pvModules);
    }

    //
    // Handle tracing will also raise exceptions on invalid handles.
    //

#ifndef _DEBUG
    BOOL bAnomalyDetected;

    __try {
        NtClose((HANDLE)0xBADC0FFEE);
        bAnomalyDetected = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        bAnomalyDetected = FALSE;
    }
#endif
    NtSetInformationProcess(NtCurrentProcess(), ProcessHandleTracing, &traceEnable, NULL);

#ifndef _DEBUG
    if (bAnomalyDetected) {
        SkReportInvalidHandleClosure(0);
    }
#endif
    return SkiGetAnomalyCount() == oldAnomalyCount;
}

```

`Source/probes/memory.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       MEMORY.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Stack probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

#define MAX_WATCH_COUNT 256
#define NTQVM_MAX_BUFFER_LENGTH (256)*(256)*(1024)

BOOL SkpProbeForExecutable(ULONG_PTR addr)
{
    __volatile PFEFN probefn;

    __try {
        for (;; ++addr)
            if (0xc3 == *(PBYTE)addr) {
                probefn = (PFEFN)addr;
                probefn();
                return TRUE;
            }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    return FALSE;
}

VOID SkiCheckMemoryWsBlock(
    _In_ PMEMORY_WORKING_SET_BLOCK WsBlock
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];
    ULONG_PTR address = WsBlock->VirtualPage * PAGE_SIZE;

    if (WsBlock->Shared == 0 || WsBlock->ShareCount == 0) {
        SkiIncreaseAnomalyCount();
        StringCchPrintf(szBuffer,
            RTL_NUMBER_OF(szBuffer),
            TEXT("0x%llX"),
            address);

        supReportEventEx(evtDetection,
            (LPWSTR)TEXT("Suspicious memory page"),
            szBuffer,
            DT_INJECTEDCODE,
            address,
            TRUE);
    }
}

/*
* SkWsSetWalk
*
* Purpose:
*
* Check suspicious entries in a working set list.
*
*/
BOOL SkWsSetWalk(
    VOID
)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    NTSTATUS ntStatus;
    ULONG_PTR i;
    PMEMORY_WORKING_SET_INFORMATION pws = NULL;
    PMEMORY_WORKING_SET_BLOCK pwsBlock;
    SIZE_T bufferSize = PAGE_SIZE;

    pws = (PMEMORY_WORKING_SET_INFORMATION)supHeapAlloc(bufferSize);

    while ((ntStatus = NtQueryVirtualMemory(
        NtCurrentProcess(),
        NULL,
        MemoryWorkingSetInformation,
        pws,
        bufferSize,
        &bufferSize)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        supHeapFree(pws);
        bufferSize <<= 1;

        if (bufferSize > NTQVM_MAX_BUFFER_LENGTH) {
            pws = NULL;
            ntStatus = STATUS_TOO_MANY_SECRETS;
            break;
        }

        pws = (PMEMORY_WORKING_SET_INFORMATION)supHeapAlloc((SIZE_T)bufferSize);
        if (pws == NULL) {
            ntStatus = STATUS_MEMORY_NOT_ALLOCATED;
            break;
        }
    }

    if (pws == NULL) {
        SkReportNtCallRIP(STATUS_MEMORY_NOT_ALLOCATED,
            (LPWSTR)TEXT("Cannot allocate virtual memory"),
            (LPWSTR)TEXT("supHeapAlloc"),
            NULL);
        return FALSE;
    }

    if (!NT_SUCCESS(ntStatus)) {

        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Cannot query virtual memory"),
            (LPWSTR)TEXT("NtQueryVirtualMemory"),
            (LPWSTR)TEXT("MemoryWorkingSetInformation"));
   
    } else {

        for (i = 0; i < pws->NumberOfEntries; i++) {

            pwsBlock = &pws->WorkingSetInfo[i];

            if ((pwsBlock->Protection == MM_EXECUTE) ||
                (pwsBlock->Protection == MM_EXECUTE_READWRITE) ||
                (pwsBlock->Protection == MM_EXECUTE_WRITECOPY))
            {
                SkiCheckMemoryWsBlock(pwsBlock);
            }
        }

    }

    supHeapFree(pws);

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

/*
* SkStackWalk
*
* Purpose:
*
* Walk entire stack of suspicious values.
*
*/
BOOL SkStackWalk(
    _In_ PPROBE_CONTEXT Context
)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    ULONG_PTR maxAppAddress, minAppAddress;
    ULONG_PTR myRsp, p, lowRsp = 0, highRsp = 0;
    __volatile ULONG_PTR x;

    MEMORY_BASIC_INFORMATION mi;
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    maxAppAddress = Context->SystemInfo.MaximumUserModeAddress;
    minAppAddress = Context->SystemInfo.MinimumUserModeAddress;

    myRsp = (ULONG_PTR)_AddressOfReturnAddress() & ~(PAGE_SIZE - 1);
    lowRsp = myRsp;

    for (p = myRsp; p > 0; p -= PAGE_SIZE) {

        __try {
            x = *(ULONG_PTR*)p;
            *(ULONG_PTR*)p = x;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            break;
        }
        lowRsp = p;
    }

    for (p = myRsp; p < maxAppAddress; p += PAGE_SIZE) {

        __try {
            PUSH_DISABLE_WARNING(6011)
                x = *(ULONG_PTR*)p;
            POP_DISABLE_WARNING(6011)
                * (ULONG_PTR*)p = x;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            break;
        }
        highRsp = p;
    }
    highRsp += PAGE_SIZE - sizeof(ULONG_PTR);

    for (p = highRsp; p >= lowRsp; p -= sizeof(ULONG_PTR)) {

        x = *(ULONG_PTR*)p;
        if ((x >= minAppAddress) && (x < maxAppAddress)) {

            // if (ProbeForExecutable(x)) {

            SIZE_T length;

            if (NT_SUCCESS(NtQueryVirtualMemory(NtCurrentProcess(),
                (PVOID)x,
                MemoryBasicInformation,
                &mi,
                sizeof(mi),
                &length)))
            {
                if ((mi.Protect == PAGE_EXECUTE) ||
                    (mi.Protect == PAGE_EXECUTE_READ) ||
                    (mi.Protect == PAGE_EXECUTE_READWRITE) ||
                    (mi.Protect == PAGE_EXECUTE_WRITECOPY))
                {
                    PLDR_DATA_TABLE_ENTRY pvTableEntry = NULL;

                    if (!NT_SUCCESS(LdrFindEntryForAddress((PVOID)x, (PLDR_DATA_TABLE_ENTRY*)&pvTableEntry))) {

                        SkiIncreaseAnomalyCount();

                        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

                        StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
                            TEXT("0x%llX"),
                            x);

                        supReportEventEx(evtDetection,
                            (LPWSTR)TEXT("There are traces of injected code in a call stack"),
                            szBuffer,
                            DT_INJECTEDCODE,
                            x,
                            TRUE);

                    }
                }
            }
        }
    }

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

BOOL SkiVerifyWSValueUserMode(
    _In_ PVOID WsValue
)
{
    NTSTATUS ntStatus;
    PLDR_DATA_TABLE_ENTRY entry;
    WCHAR szText[MAX_TEXT_LENGTH];
    MEMORY_BASIC_INFORMATION mi;

    SIZE_T length;

    if (NT_SUCCESS(NtQueryVirtualMemory(NtCurrentProcess(),
        WsValue,
        MemoryBasicInformation,
        &mi,
        sizeof(mi),
        &length)))
    {
        if ((mi.Protect == PAGE_EXECUTE) ||
            (mi.Protect == PAGE_EXECUTE_READ) ||
            (mi.Protect == PAGE_EXECUTE_READWRITE) ||
            (mi.Protect == PAGE_EXECUTE_WRITECOPY))
        {
            ntStatus = LdrFindEntryForAddress(WsValue, (PLDR_DATA_TABLE_ENTRY*)&entry);
            if (!NT_SUCCESS(ntStatus)) {

                SkiIncreaseAnomalyCount();

                RtlSecureZeroMemory(&szText, sizeof(szText));

                StringCchPrintf(szText,
                    RTL_NUMBER_OF(szText),
                    TEXT("0x%llX"),
                    (ULONG_PTR)WsValue);

                supReportEventEx(evtDetection,
                    (LPWSTR)TEXT("There are traces of injected code in a working set"),
                    szText,
                    DT_INJECTEDCODE,
                    (ULONG_PTR)WsValue,
                    TRUE);

                return FALSE;
            }
        }
    }

    return TRUE;
}

/*
* SkWsSetWatch
*
* Purpose:
*
* Check suspicious entries in a working set by a watch.
*
*/
BOOL SkWsSetWatch(
    _In_ PPROBE_CONTEXT Context
)
{
    NTSTATUS ntStatus;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    PROCESS_WS_WATCH_INFORMATION_EX* pWatchInfo = NULL;
    ULONG_PTR maxAppAddress = 0;

    maxAppAddress = Context->SystemInfo.MaximumUserModeAddress;

    do {

        //
        // Set watch.
        //
        ntStatus = NtSetInformationProcess(
            NtCurrentProcess(),
            ProcessWorkingSetWatchEx,
            NULL,
            0);

        if (!NT_SUCCESS(ntStatus) && ntStatus != STATUS_PORT_ALREADY_SET) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to enable WS watch"),
                (LPWSTR)TEXT("NtSetInformationProcess"),
                DT_WSSET_FAILED);

            break;
        }

        //
        // Empty WS.
        //
        ntStatus = supEmptyWorkingSet();
        if (!NT_SUCCESS(ntStatus)) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to empty process working set"),
                (LPWSTR)TEXT("NtSetInformationProcess"),
                DT_WSSET_FAILED);

            break;
        }

        //
        // Watch changes.
        //
        SIZE_T size = 256 * sizeof(PROCESS_WS_WATCH_INFORMATION_EX);
        ULONG returnLength;

        pWatchInfo = (PROCESS_WS_WATCH_INFORMATION_EX*)supHeapAlloc(size);
        if (pWatchInfo == NULL) {

            SkReportNtCallRIP(STATUS_MEMORY_NOT_ALLOCATED,
                (LPWSTR)TEXT("Failed to allocate memory"),
                (LPWSTR)TEXT("RtlAllocateHeap"),
                DT_WSSET_FAILED);

            break;
        }

        ntStatus = NtQueryInformationProcess(
            NtCurrentProcess(),
            ProcessWorkingSetWatch,
            (PVOID*)pWatchInfo,
            (ULONG)size,
            &returnLength);

        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            supHeapFree(pWatchInfo);

            size = (256 * sizeof(PROCESS_WS_WATCH_INFORMATION_EX)) + returnLength;

            pWatchInfo = (PROCESS_WS_WATCH_INFORMATION_EX*)supHeapAlloc(size);

            ntStatus = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessWorkingSetWatch,
                (PVOID*)pWatchInfo,
                (ULONG)size,
                &returnLength);
        }

        if (!NT_SUCCESS(ntStatus)) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to query process working set change"),
                (LPWSTR)TEXT("NtQueryInformationProcess"),
                DT_WSSET_FAILED);

            break;
        }

        //
        // Find wubbaboos.
        //
        PVOID cookie;
        ntStatus = LdrLockLoaderLock(0, NULL, &cookie);
        if (NT_SUCCESS(ntStatus)) {

            for (ULONG i = 0; i < MAX_WATCH_COUNT; i++) {

                if (pWatchInfo[i].BasicInfo.FaultingPc && pWatchInfo[i].BasicInfo.FaultingVa) {

                    if ((ULONG_PTR)pWatchInfo[i].BasicInfo.FaultingPc < maxAppAddress)
                        SkiVerifyWSValueUserMode(pWatchInfo[i].BasicInfo.FaultingPc);

                    if ((ULONG_PTR)pWatchInfo[i].BasicInfo.FaultingVa < maxAppAddress)
                        SkiVerifyWSValueUserMode(pWatchInfo[i].BasicInfo.FaultingVa);
                }

            }

            LdrUnlockLoaderLock(0, cookie);
        }

    } while (FALSE);

    if (pWatchInfo) supHeapFree(pWatchInfo);

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

/*
* SkCheckProcessMemory
*
* Purpose:
*
* Scan process memory for various wubbaboos classic version.
*
*/
BOOL SkCheckProcessMemory(
    _In_ PPROBE_CONTEXT Context
)
{
    UNREFERENCED_PARAMETER(Context);
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    PVOID baseAddress = NULL;
    MEMORY_BASIC_INFORMATION mbi;

    PVOID pvImageBase = NULL;

    while (NT_SUCCESS(NtQueryVirtualMemory(
        NtCurrentProcess(),
        baseAddress,
        MemoryBasicInformation,
        &mbi,
        sizeof(MEMORY_BASIC_INFORMATION),
        NULL)))
    {
        if ((mbi.State != MEM_COMMIT) ||
            (mbi.Protect == PAGE_NOACCESS) ||
            (mbi.Protect & PAGE_GUARD))
        {
            goto Next;
        }

        if ((mbi.Protect & PAGE_EXECUTE) ||
            (mbi.Protect & PAGE_EXECUTE_READ) ||
            (mbi.Protect & PAGE_EXECUTE_READWRITE) ||
            (mbi.Protect & PAGE_EXECUTE_WRITECOPY))
        {
            switch (mbi.Type) {

            case MEM_IMAGE:

                if (!supLdrFindImageByAddress(baseAddress, &pvImageBase)) {
                    SkReportSuspectRegion(&mbi);
                }

                break;

            case MEM_MAPPED:
            case MEM_PRIVATE:
                SkReportSuspectRegion(&mbi);
                break;
            }
        }

    Next:
        baseAddress = RtlOffsetToPointer(baseAddress, mbi.RegionSize);
    }

    return SkiGetAnomalyCount() == oldAnomalyCount;
}

```

`Source/probes/modules.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       MODULES.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Image modules probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

typedef enum _DLL_REPORT_EVENT {
    NonSystemDll = 0,
    TamperedDll,
    MaxDllReportReport
} DLL_REPORT_EVENT;

typedef VOID(NTAPI* SkpEnumerationOutputCallback)(
    _In_ PLDR_DATA_TABLE_ENTRY DataEntry,
    _In_ DLL_REPORT_EVENT DllEvent
    );

typedef struct _LDR_ENUM_CTX {
    _In_ SkpEnumerationOutputCallback OutputCallback;
    _In_ PPROBE_CONTEXT Context;
} LDR_ENUM_CTX, PLDR_ENUM_CTX;

BOOL SkpValidateLoaderDataEntry(
    _In_ PPROBE_CONTEXT Context,
    _In_ PLDR_DATA_TABLE_ENTRY DataEntry
)
{
    PLDR_DATA_TABLE_ENTRY_FULL dataEntry = (PLDR_DATA_TABLE_ENTRY_FULL)DataEntry;
    OBJECT_NAME_INFORMATION* objectNameInfo = NULL;
    SIZE_T size;
    LPWSTR lpWin32Name = NULL;
    UNICODE_STRING usFullDllName;
    NTSTATUS ntStatus;
    BOOL bSeemsLegit = FALSE;
    PIMAGE_NT_HEADERS NtHeaders;

    ULONG hashValue = 0;

    do {

        __try {
            if (!NT_SUCCESS(RtlImageNtHeaderEx(0,
                dataEntry->DllBase, dataEntry->SizeOfImage, &NtHeaders)))
            {
                break;
            }

            if (dataEntry->EntryPoint) {
                if (!IN_REGION(dataEntry->EntryPoint, dataEntry->DllBase, dataEntry->SizeOfImage))
                    break;
            }

            //
            // Available since 8+
            //
            if (Context->WindowsMajorVersion >= 8) {
                if (NT_SUCCESS(RtlHashUnicodeString(&dataEntry->BaseDllName,
                    TRUE,
                    HASH_STRING_ALGORITHM_X65599,
                    &hashValue)))
                {
                    if (hashValue != dataEntry->BaseNameHashValue)
                        break;
                }
                else {
                    break;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }

        UNICODE_STRING ntFileName;
        PVOID mappedImage = NULL;

        //
        // Compare control area data.
        //
        if (RtlDosPathNameToNtPathName_U(dataEntry->FullDllName.Buffer, 
            &ntFileName, 
            NULL, 
            NULL)) 
        {
            ntStatus = supMapImageNoExecute(&ntFileName, &mappedImage);
            if (NT_SUCCESS(ntStatus)) {

                ntStatus = NtAreMappedFilesTheSame(dataEntry->DllBase, mappedImage);
                if (!NT_SUCCESS(ntStatus)) {
                    SkReportNtCallRIP(ntStatus,
                        (LPWSTR)TEXT("Loader entry FullDllName is tampered"),
                        (LPWSTR)__FUNCTIONW__,
                        NULL);
                }
                else {
                    bSeemsLegit = TRUE;
                }

                NtUnmapViewOfSection(NtCurrentProcess(), mappedImage);
            }
            else {
                SkReportNtCallRIP(ntStatus,
                    (LPWSTR)TEXT("Failed to map loader entry"),
                    (LPWSTR)TEXT("supMapImageNoExecute"),
                    NULL);
            }

            RtlFreeUnicodeString(&ntFileName);
        }
        else {
            //
            // The conversion has failed, switch to trivial comparison.
            //
            ntStatus = supGetMappedFileName(dataEntry->DllBase, &objectNameInfo);
            if (!NT_SUCCESS(ntStatus)) {
                SkReportNtCallRIP(ntStatus,
                    (LPWSTR)TEXT("Failed to query mapped filename"),
                    (LPWSTR)TEXT("supGetMappedFileName"),
                    NULL);
            }

            if (objectNameInfo == NULL)
                break;

            //
            // Check mapped fileName against DataEntry->FullDllName.
            //
            size = UNICODE_STRING_MAX_CHARS * sizeof(WCHAR);
            lpWin32Name = (LPWSTR)supHeapAlloc(size);

            if (lpWin32Name) {

                if (supConvertFileName(objectNameInfo->Name.Buffer,
                    lpWin32Name,
                    size / sizeof(WCHAR)))
                {
                    RtlInitUnicodeString(&usFullDllName, lpWin32Name);
                    bSeemsLegit = RtlEqualUnicodeString(&dataEntry->FullDllName, &usFullDllName, TRUE);
                }

                supHeapFree(lpWin32Name);
            }
        }

    } while (FALSE);

    if (objectNameInfo) supHeapFree(objectNameInfo);
    return bSeemsLegit;
}

/*
* SkpLdrEnumModulesCallback
*
* Purpose:
*
* Callback of LdrEnumerateLoadedModuels, check if module has system origin.
*
*/
VOID NTAPI SkpLdrEnumModulesCallback(
    _In_ PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_ PVOID Context,
    _Inout_ BOOLEAN* StopEnumeration
)
{
    NTSTATUS ntStatus;
    LDR_ENUM_CTX* enumContext = (LDR_ENUM_CTX*)Context;
    PVOID selfImageBase = enumContext->Context->SelfBase;
    SkpEnumerationOutputCallback callback = enumContext->OutputCallback;

    if (DataTableEntry->DllBase != selfImageBase) {

        ntStatus = supVerifyFileSignature(
            UserMode, 
            DataTableEntry->FullDllName.Buffer,
            FALSE,
            enumContext->Context->WTGetSignatureInfo);

        if (!NT_SUCCESS(ntStatus)) {

            SkiIncreaseAnomalyCount();
            callback(DataTableEntry, NonSystemDll);

        }
        else {
            //
            // File is signed, but is PEB loader information correct?
            //
            if (!SkpValidateLoaderDataEntry(enumContext->Context, DataTableEntry)) {
                SkiIncreaseAnomalyCount();
                callback(DataTableEntry, TamperedDll);
            }
        }
    }

    *StopEnumeration = FALSE;
}

VOID SkpLdrEnumerateOutput(
    _In_ PLDR_DATA_TABLE_ENTRY DataEntry,
    _In_ DLL_REPORT_EVENT DllEvent
)
{
    WCHAR szAddress[32];

    LPWSTR lpName;
    SIZE_T length = MAX_TEXT_LENGTH + (SIZE_T)DataEntry->FullDllName.MaximumLength;

    lpName = (LPWSTR)supHeapAlloc(length);
    if (lpName) {

        RtlSecureZeroMemory(&szAddress, sizeof(szAddress));

        if (DllEvent == NonSystemDll) {

            StringCchPrintf(lpName,
                length / sizeof(WCHAR),
                TEXT("Non system module %ws"),
                DataEntry->FullDllName.Buffer);

        }
        else {
            StringCchPrintf(lpName,
                length / sizeof(WCHAR),
                TEXT("Tampered module %ws"),
                DataEntry->FullDllName.Buffer);

        }

        StringCchPrintf(szAddress,
            RTL_NUMBER_OF(szAddress),
            TEXT("0x%llX"),
            (ULONG_PTR)DataEntry->DllBase);

        supReportEvent(evtDetection,
            lpName,
            szAddress,
            DT_3RDPARTYCODE);

        supHeapFree(lpName);
    }
}

/*
* SkWalkPEB
*
* Purpose:
*
* Walk PEB loaded and check if modules have system origin.
*
*/
BOOL SkWalkPEB(
    _In_ PPROBE_CONTEXT Context
)
{
    LDR_ENUM_CTX enumContext;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();

    enumContext.OutputCallback = (SkpEnumerationOutputCallback)SkpLdrEnumerateOutput;
    enumContext.Context = Context;

    LdrEnumerateLoadedModules(0,
        (PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)&SkpLdrEnumModulesCallback,
        (PVOID)&enumContext);

    return (oldAnomalyCount == SkiGetAnomalyCount());
}

/*
* SkWalkLoadedDrivers
*
* Purpose:
*
* Walk loaded kernel module list and check if modules are properly signed.
*
*/
BOOL SkWalkLoadedDrivers(
    _In_ PPROBE_CONTEXT Context
)
{
    NTSTATUS ntStatus;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    ULONG returnedLength = 0, expectedLength;
    PRTL_PROCESS_MODULES pModulesList = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, &returnedLength);
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;
    UNICODE_STRING fileName;
    LPWSTR lpWin32Name = NULL;

    if (pModulesList) {

        //
        // Lazy alteration check.
        //
        expectedLength = ((pModulesList->NumberOfModules * sizeof(RTL_PROCESS_MODULE_INFORMATION)) +
            FIELD_OFFSET(RTL_PROCESS_MODULES, Modules));

        if (returnedLength != expectedLength)
            SkReportDriverListModification(returnedLength, expectedLength);

        //
        // Braindead alteration check.
        //
        if (pModulesList->NumberOfModules < 16) {
            
            SkiIncreaseAnomalyCount();
            supReportEvent(evtDetection,
                (LPWSTR)TEXT("Invalid number of entries in modules list"),
                (LPWSTR)TEXT("NtQuerySystemInformation"),
                (LPWSTR)TEXT("SystemModuleInformation"));

        }

        for (ULONG i = 0; i < pModulesList->NumberOfModules; i++) {

            moduleEntry = &pModulesList->Modules[i];
            RtlInitEmptyUnicodeString(&fileName, NULL, 0);

            ntStatus = supConvertToUnicode(
                (LPCSTR)&moduleEntry->FullPathName,
                &fileName);

            if (NT_SUCCESS(ntStatus)) {
                if (fileName.Buffer != NULL) {
                    ntStatus = supGetWin32FileName(fileName.Buffer, &lpWin32Name);
                    if (NT_SUCCESS(ntStatus)) {

                        ntStatus = supVerifyFileSignature(KernelMode, 
                            lpWin32Name, 
                            FALSE, 
                            Context->WTGetSignatureInfo);
                        
                        if (!NT_SUCCESS(ntStatus)) {

                            SkiIncreaseAnomalyCount();

                            supReportEvent(evtWarning,
                                lpWin32Name,
                                (LPWSTR)TEXT("WinTrust"),
                                DT_SIGNATURE_INVALID);

                        }

                        supHeapFree(lpWin32Name);
                    }
                    else {
                        if (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

                            SkReportNtCallRIP(ntStatus,
                                (LPWSTR)TEXT("Failed to open driver file"),
                                (LPWSTR)TEXT("supGetWin32FileName"),
                                NULL);

                        }
                    }
                }
                RtlFreeUnicodeString(&fileName);
            }
            else {

                SkReportNtCallRIP(ntStatus,
                    (LPWSTR)TEXT("Failed to convert driver file to UNICODE"),
                    (LPWSTR)TEXT("supConvertToUnicode"),
                    NULL);
            }

        }
        supHeapFree(pModulesList);
    }
    else {

        SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
            (LPWSTR)TEXT("Failed to query loaded modules list"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemModuleInformation"));

    }

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/objects.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       OBJECTS.CPP
*
*  VERSION:     1.00
*
*  DATE:        04 Jul 2023
*
*  System object handles probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

BOOL SkIsThreadInformationTampered(
    _In_ BOOL SuppressOutput,
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle
)
{
    NTSTATUS ntStatus;
    ntStatus = NtCompareObjects(FirstObjectHandle,
        SecondObjectHandle);

    if (!NT_SUCCESS(ntStatus)) {

        if (!SuppressOutput) {
            LPWSTR lpText;

            if (ntStatus == STATUS_NOT_SAME_OBJECT) {
                lpText = (LPWSTR)TEXT("Thread information tampered");
            }
            else {
                lpText = (LPWSTR)TEXT("Failed verify handle equality");
            }

            SkReportNtCallRIP(ntStatus,
                lpText,
                (LPWSTR)__FUNCTIONW__,
                NULL);
        }
        return TRUE;
    }

    return FALSE;
}

VOID SkiQueryAndValidateHandleInformation(
    _In_ BOOL IsProcess,
    _In_ PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry
)
{
    NTSTATUS ntStatus;
    HANDLE hProcess = NULL, hObject = NULL;
    OBJECT_ATTRIBUTES obja;
    CLIENT_ID cid;

    ACCESS_MASK desiredAccess;

    if (IsProcess)
        desiredAccess = PROCESS_QUERY_LIMITED_INFORMATION;
    else
        desiredAccess = THREAD_QUERY_LIMITED_INFORMATION;

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
    cid.UniqueProcess = (HANDLE)HandleEntry->UniqueProcessId;
    cid.UniqueThread = NULL;

    // 
    // Insignificant failure, we maybe lacking enough privs to do that.
    //
    ntStatus = NtOpenProcess(&hProcess, PROCESS_DUP_HANDLE, &obja, &cid);
    if (NT_SUCCESS(ntStatus)) {

        //
        // Insignificant failure also.
        //
        ntStatus = NtDuplicateObject(hProcess,
            (HANDLE)HandleEntry->HandleValue,
            NtCurrentProcess(),
            &hObject,
            desiredAccess,
            0,
            0);

        if (NT_SUCCESS(ntStatus)) {

            ntStatus = NtCompareObjects(IsProcess ? NtCurrentProcess() : NtCurrentThread(), hObject);
            if (NT_SUCCESS(ntStatus)) {

                //
                // Handle is us.
                //
                if (IsProcess) {
                    if ((HandleEntry->GrantedAccess & PROCESS_VM_WRITE) ||
                        HandleEntry->GrantedAccess & PROCESS_SUSPEND_RESUME) 
                    {
                        SkReportSuspectHandleEntry(TRUE, HandleEntry);
                    }
                }
                else {
                    if ((HandleEntry->GrantedAccess & THREAD_SET_CONTEXT) ||
                        (HandleEntry->GrantedAccess & THREAD_GET_CONTEXT))
                    {
                        SkReportSuspectHandleEntry(FALSE, HandleEntry);
                    }
                }
            }

            NtClose(hObject);
        }
        NtClose(hProcess);
    }
}

BOOL SkiRetrieveOwnHandleTypesInformation(
    _In_ PROBE_CONTEXT* Context,
    _Out_ PULONG DebugObjectTypeIndex,
    _Out_ PULONG ProcessObjectTypeIndex,
    _Out_ PULONG ThreadObjectTypeIndex,
    _Out_ PHANDLE ProcessHandle,
    _Out_opt_ PHANDLE ThreadHandle
)
{
    BOOL bResult = FALSE;
    NTSTATUS ntStatus;
    ULONG returnLength = 0, dbgObjType = MAXULONG32, procObjType = MAXULONG32, threadObjType = MAXULONG32;
    HANDLE dbgObjRef = NULL, procObjRef = NULL, threadObjRef = NULL;

    OBJECT_ATTRIBUTES obja;
    CLIENT_ID cid;

    PPROCESS_HANDLE_SNAPSHOT_INFORMATION pHandleSnapshot = NULL;
    PPROCESS_HANDLE_TABLE_ENTRY_INFO pHandleEntry;

    do {

        InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
        ntStatus = NtCreateDebugObject(&dbgObjRef, DEBUG_ALL_ACCESS, &obja, 0);
        if (!NT_SUCCESS(ntStatus)) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to create debug object"),
                (LPWSTR)TEXT("NtCreateDebugObject"),
                NULL);

            break;
        }

        //
        // Duplicate CLIENT_ID check as it was done in SkValidateClientInfo however this one will
        // output wubbaboo warning.
        //

        cid = Context->ClientId;
        ntStatus = NtOpenThread(&threadObjRef, SYNCHRONIZE, &obja, &cid);
        if (!NT_SUCCESS(ntStatus)) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to open own thread"),
                (LPWSTR)TEXT("NtOpenThread"),
                NULL);

            break;
        }

        if (SkIsThreadInformationTampered(FALSE, NtCurrentThread(), threadObjRef))
            break;

        cid.UniqueThread = NULL;
        ntStatus = NtOpenProcess(&procObjRef, SYNCHRONIZE, &obja, &cid);
        if (!NT_SUCCESS(ntStatus)) {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to open own process"),
                (LPWSTR)TEXT("NtOpenProcess"),
                NULL);

            break;
        }

        if (SkIsThreadInformationTampered(FALSE, NtCurrentProcess(), procObjRef))
            break;

        pHandleSnapshot = (PPROCESS_HANDLE_SNAPSHOT_INFORMATION)supGetProcessInfoVariableSize(
            ProcessHandleInformation,
            &returnLength);

        if (pHandleSnapshot == NULL) {

            SkReportNtCallRIP(STATUS_MEMORY_NOT_ALLOCATED,
                (LPWSTR)TEXT("Failed to query own handles information"),
                (LPWSTR)TEXT("NtQueryInformationProcess"),
                NULL);

            break;
        }

        SIZE_T expectedLength = FIELD_OFFSET(PROCESS_HANDLE_SNAPSHOT_INFORMATION, Handles) +
            (pHandleSnapshot->NumberOfHandles * sizeof(PROCESS_HANDLE_TABLE_ENTRY_INFO));
        if (expectedLength != returnLength) {
            SkReportHandleListCorruption(returnLength, (ULONG)expectedLength);
        }

        for (ULONG i = 0; i < pHandleSnapshot->NumberOfHandles; i++) {
            pHandleEntry = &pHandleSnapshot->Handles[i];

            if (pHandleEntry->HandleValue == dbgObjRef && dbgObjType == MAXULONG32)
                dbgObjType = pHandleEntry->ObjectTypeIndex;

            if (pHandleEntry->HandleValue == procObjRef && procObjType == MAXULONG32)
                procObjType = pHandleEntry->ObjectTypeIndex;

            if (pHandleEntry->HandleValue == threadObjRef && threadObjType == MAXULONG32)
                threadObjType = pHandleEntry->ObjectTypeIndex;

            bResult = ((dbgObjType != MAXULONG32) &&
                (procObjType != MAXULONG32) && 
                (threadObjType != MAXULONG32));

            if (bResult)
                break;
        }

    } while (FALSE);

    if (pHandleSnapshot) supHeapFree(pHandleSnapshot);
    if (dbgObjRef) NtClose(dbgObjRef);

    if (!bResult) {
        if (procObjRef) NtClose(procObjRef);
        if (threadObjRef) NtClose(threadObjRef);
        procObjRef = NULL;
        threadObjRef = NULL;
    }

    if (ThreadHandle) {
        *ThreadHandle = threadObjRef;
    } 
    else {
        if (threadObjRef) NtClose(threadObjRef);
    }

    *ProcessHandle = procObjRef;
    *DebugObjectTypeIndex = dbgObjType;
    *ProcessObjectTypeIndex = procObjType;
    *ThreadObjectTypeIndex = threadObjType;

    return bResult;
}

/*
* SkCheckHandles
*
* Purpose:
*
* Analyze handle dump.
*
*/
BOOL SkCheckHandles(
    _In_ PROBE_CONTEXT* Context
)
{
    NTSTATUS ntStatus;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    PSYSTEM_HANDLE_INFORMATION_EX handleArray = NULL;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX pHandleEntry;
    POBJECT_TYPES_INFORMATION pObjectTypes;
    HANDLE processObjectHandle = NULL, threadObjectHandle = NULL;

    ULONG dbgObjType, procObjType, threadObjType;
    ULONG i, returnLength;
    SIZE_T expectedLength;

    POBJECT_TYPE_INFORMATION pObject;

    union {
        union {
            POBJECT_TYPE_INFORMATION Object;
            POBJECT_TYPE_INFORMATION_V2 ObjectV2;
        } u1;
        PBYTE Ref;
    } ObjectTypeEntry;

    do {

        if (!SkiRetrieveOwnHandleTypesInformation(
            Context,
            &dbgObjType,
            &procObjType,
            &threadObjType,
            &processObjectHandle,
            &threadObjectHandle))
        {
            break;
        }

        returnLength = NULL;
        handleArray = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation, &returnLength);
        if (handleArray == NULL) {

            SkReportNtCallRIP(STATUS_MEMORY_NOT_ALLOCATED,
                (LPWSTR)TEXT("Failed to query handle information"),
                (LPWSTR)TEXT("NtQuerySystemInformation"),
                (LPWSTR)TEXT("SystemExtendedHandleInformation"));

            break;
        }

        expectedLength = FIELD_OFFSET(SYSTEM_HANDLE_INFORMATION_EX, Handles) +
            (handleArray->NumberOfHandles * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));
        if (expectedLength != returnLength) {
            SkReportHandleListCorruption(returnLength, (ULONG)expectedLength);
        }

        ULONG debugObjectHandleCount = 0;
        ULONG currentProcessId = HandleToUlong(Context->ClientId.UniqueProcess);

        for (i = 0; i < handleArray->NumberOfHandles; i++) {

            pHandleEntry = &handleArray->Handles[i];

            if (pHandleEntry->ObjectTypeIndex == procObjType) {
                if (pHandleEntry->UniqueProcessId != currentProcessId) {
                    SkiQueryAndValidateHandleInformation(TRUE, pHandleEntry);
                }
            }

            if (pHandleEntry->ObjectTypeIndex == threadObjType) {
                if (pHandleEntry->UniqueProcessId != currentProcessId) {
                    SkiQueryAndValidateHandleInformation(FALSE, pHandleEntry);
                }
            }
            
            //
            // This is ambiguous detection, however why not?
            //
            if (pHandleEntry->ObjectTypeIndex == dbgObjType)
                debugObjectHandleCount++;

        }

        if (debugObjectHandleCount > 0)
            SkReportDebugObject(debugObjectHandleCount, TRUE);

        //
        // NtQueryObject handle compare.
        //

        ULONG handleCount = 0, objectsCount = 0;

        ntStatus = supGetObjectTypesInfo(&returnLength, (PVOID*)&pObjectTypes);
        if (NT_SUCCESS(ntStatus)) {

            __try {

                BOOL bObjFound = FALSE;
                ULONG size;

                pObject = OBJECT_TYPES_FIRST_ENTRY(pObjectTypes);
                size = ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR);

                for (i = 0; i < pObjectTypes->NumberOfTypes; i++) {

                    ObjectTypeEntry.Ref = (PBYTE)pObject;

                    if (!bObjFound) {

                        if (Context->WindowsMajorVersion >= 8) {
                            if (ObjectTypeEntry.u1.ObjectV2->TypeIndex == dbgObjType) {
                                handleCount = ObjectTypeEntry.u1.ObjectV2->TotalNumberOfHandles;
                                objectsCount = ObjectTypeEntry.u1.ObjectV2->TotalNumberOfObjects;
                                bObjFound = TRUE;
                            }
                        }
                        else {
                            if ((i + 2) == dbgObjType) {
                                handleCount = ObjectTypeEntry.u1.Object->TotalNumberOfHandles;
                                objectsCount = ObjectTypeEntry.u1.Object->TotalNumberOfObjects;
                                bObjFound = TRUE;
                            }
                        }

                    }

                    size += sizeof(OBJECT_TYPE_INFORMATION);
                    size += ALIGN_UP(ObjectTypeEntry.u1.Object->TypeName.MaximumLength, ULONG_PTR);

                    pObject = OBJECT_TYPES_NEXT_ENTRY(pObject);
                }

                if (size != returnLength) {
                    SkReportObTypeListCorruption(returnLength, size);
                }

            }
            __except (EXCEPTION_EXECUTE_HANDLER) {

                SkReportNtCallRIP(GetExceptionCode(),
                    (LPWSTR)TEXT("Exception during traversing objects list"),
                    (LPWSTR)TEXT("SkCheckDebugObjects"),
                    NULL);

            }

            //
            // Check a lazy filtering.
            //

            if (handleCount != debugObjectHandleCount) {
                SkReportDebugObjectHandleMismatch(handleCount, debugObjectHandleCount);
            }

            if (objectsCount > 0) {
                SkReportDebugObject(objectsCount, FALSE);
            }

        }
        else {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Failed to query object type information"),
                (LPWSTR)TEXT("NtQueryObject"),
                (LPWSTR)TEXT("ObjectTypesInformation"));

        }

    } while (FALSE);

    if (handleArray)
        supHeapFree(handleArray);

    if (processObjectHandle)
        NtClose(processObjectHandle);

    if (threadObjectHandle)
        NtClose(threadObjectHandle);

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

/*
* SkNoKernelWubbaboos
*
* Purpose:
*
* Detect suspicious driver device objects.
*
*/
BOOL SkNoKernelWubbaboos()
{
    BOOL bResult = TRUE;
    LPWSTR lpWubbabooDevices[] = {
        (LPWSTR)TEXT("HyperHideDrv"),
        (LPWSTR)TEXT("kldbgdrv"),
        (LPWSTR)TEXT("TitanHide"),
        (LPWSTR)TEXT("HyperDbgDebuggerDevice")
    };

    for (ULONG i = 0; i < RTL_NUMBER_OF(lpWubbabooDevices); i++) {
        if (supIsObjectExists((LPCWSTR)TEXT("\\Device"), lpWubbabooDevices[i])) {
            SkReportDeviceObject(lpWubbabooDevices[i]);
            bResult = FALSE;
        }
    }

    return bResult;
}

```

`Source/probes/processes.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       PROCESSES.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Process list probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

typedef struct _PS_LIST {
    struct _PS_LIST* Prev;
    ULONG UniqueProcessId;
    ULONG ParentProcessId;
    WCHAR szName[MAX_PATH];
} PS_LIST, * PPS_LIST;

//
// MSDN rip-on
//
#define SDB_MAX_EXES 16
#define SDB_MAX_LAYERS 8
#define SDB_MAX_SDBS 16

typedef DWORD TAGREF;

typedef struct tagSDBQUERYRESULT {
    TAGREF atrExes[SDB_MAX_EXES];
    DWORD  adwExeFlags[SDB_MAX_EXES];
    TAGREF atrLayers[SDB_MAX_LAYERS];
    DWORD  dwLayerFlags;
    TAGREF trApphelp;
    DWORD  dwExeCount;
    DWORD  dwLayerCount;
    GUID   guidID;
    DWORD  dwFlags;
    DWORD  dwCustomSDBMap;
    GUID   rgGuidDB[SDB_MAX_SDBS];
} SDBQUERYRESULT, * PSDBQUERYRESULT;
//
// MSDN rip-off
//

//
// Totally opaque structure, changes between Win versions, head remains same, 
// everything else is not - use with caution. Primary source of RE is apphelp.dll and leaked symbols, 
// ignore various trash like reactos, shims wasn't in win2k source so they don't give a clue about it.
//
#define APPCOMPAT_EXE_DATA_MAGIC 0xAC0DEDAB

typedef struct _APP_COMPAT_EXE_INFO {
    WCHAR szShimEngine[MAX_PATH];       //+0x0
    ULONG cbSize;                       //+0x208
    ULONG dwMagic;                      //+0x20C
    ULONG dwFlags;                      //+0x210
    ULONG dwMachine;                    //+0x214
    SDBQUERYRESULT SdbQueryResult;      //+0x218
    BYTE ApphelpDebug[1024];            //as it was on w8
    BYTE Undefined[0x358];
    ULONG dwParentProcessId;
    WCHAR szParentImageName[MAX_PATH];
    //incomplete
} APP_COMPAT_EXE_INFO, * PAPP_COMPAT_EXE_INFO;

//
// Copied from ScyllaHide with brave and courage and then improved to actually work.
// We just look for what they protect - very comfortable!
//
CONST WCHAR* WubbabooProcessList[] =
{
  L"ollydbg",
  L"ida.exe",
  L"ida64.exe",
  L"idag.exe",
  L"idag64.exe",
  L"idaw.exe",
  L"idaw64.exe",
  L"idaq.exe",
  L"idaq64.exe",
  L"idau.exe",
  L"idau64.exe",
  L"scylla",
  L"protection_id.exe",
  L"x64dbg",
  L"x32dbg",
  L"windbg",
  L"reshacker",
  L"ImportREC",
  L"immunitydebugger",
  L"devenv.exe",
  L"Procmon",
  L"apimonitor",
  L"cheatengine"
};

/*
* SkIsParentProcessExist
*
* Purpose:
*
* Find parent process in API query result.
*
*/
BOOL SkIsParentProcessExist(
    _In_ PVOID ProcessList,
    _In_ HANDLE ParentProcessId,
    _In_opt_ LPWSTR Description
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    if (NULL != supProcessEntryByProcessId(ParentProcessId, ProcessList)) {
        return TRUE;
    }
    else {
        SkiIncreaseAnomalyCount();

        StringCchPrintf(szBuffer,
            RTL_NUMBER_OF(szBuffer),
            TEXT("Process with id %lu doesn't exist in the native query"),
            HandleToUlong(ParentProcessId));

        supReportEvent(evtDetection,
            szBuffer,
            Description,
            DT_HIDDENPROCESS);

        return FALSE;
    }
}

/*
* SkCheckBadProcess
*
* Purpose:
*
* Find process name substring in a blacklist.
*
*/
BOOL SkCheckBadProcess(
    _In_ ULONG ProcessId,
    _In_ PUNICODE_STRING ProcessName,
    _In_ PS_SCAN_TYPE ScanType
)
{
    BOOL bResult = FALSE;
    WCHAR szBuffer[MAX_TEXT_LENGTH * 2];
    LPWSTR lpScanType;
    UNICODE_STRING usName;

    for (ULONG i = 0; i < RTL_NUMBER_OF(WubbabooProcessList); i++) {

        RtlInitUnicodeString(&usName, WubbabooProcessList[i]);
        SIZE_T pos = supFindUnicodeStringSubString(ProcessName, &usName);
        if (pos != ULLONG_MAX) {

            bResult = TRUE;

            SkiIncreaseAnomalyCount();

            switch (ScanType) {
            case ScanTypeWMI:
                lpScanType = (LPWSTR)TEXT("WMI Query");
                break;
            case ScanTypeAppCompat:
                lpScanType = (LPWSTR)TEXT("AppCompat Query");
                break;
            case ScanTypeNative:
            default:
                lpScanType = (LPWSTR)TEXT("Native Query");
                break;
            }

            StringCchPrintf(szBuffer,
                RTL_NUMBER_OF(szBuffer),
                TEXT("Process %lu with name substring \"%ws\" (%ws)"),
                ProcessId,
                WubbabooProcessList[i],
                lpScanType);

            supReportEvent(evtDetection,
                szBuffer,
                ProcessName->Buffer,
                DT_BAD_PROCESS_NAME);
        }

    }

    return bResult;
}

/*
* SkiAnyWubbaboosInProcessList
*
* Purpose:
*
* Find known wubbaboos by their names.
*
*/
VOID SkiAnyWubbaboosInProcessList(
    _In_ PPS_LIST List
)
{
    PS_LIST* currentEntry, * nextEntry;
    UNICODE_STRING usProcessName;

    currentEntry = List;

    while (currentEntry) {
        nextEntry = currentEntry->Prev;
        RtlInitUnicodeString(&usProcessName, currentEntry->szName);
        SkCheckBadProcess(currentEntry->UniqueProcessId, &usProcessName, ScanTypeWMI);
        currentEntry = nextEntry;
    }
}

/*
* SkiCheckConsoleHost
*
* Purpose:
*
* Query process console host and check it against list of processes from Windows API.
*
*/
VOID SkiCheckConsoleHost(
    _In_ PVOID ProcessList
)
{
    HANDLE consolePID = 0;

    if (NT_SUCCESS(supGetConsoleHostForSelf(&consolePID))) {

        consolePID = (HANDLE)((ULONG_PTR)consolePID & ~3);

        SkIsParentProcessExist(ProcessList,
            consolePID,
            (LPWSTR)TEXT("ProcessConsoleHostProcess"));

    }
}

/*
* SkiCheckAppCompat
*
* Purpose:
*
* Parse AppCompat data from PEB.
*
*/
VOID SkiCheckAppCompat(
    _In_ PVOID ProcessList
)
{
    PEB* peb = NtCurrentPeb();
    PAPP_COMPAT_EXE_INFO pAppCompatExe = (PAPP_COMPAT_EXE_INFO)peb->pShimData;

    if (pAppCompatExe) {

        MEMORY_BASIC_INFORMATION mbi;
        SIZE_T size;
        NTSTATUS ntStatus;

        ntStatus = NtQueryVirtualMemory(NtCurrentProcess(),
            pAppCompatExe,
            MemoryBasicInformation,
            &mbi,
            sizeof(mbi),
            &size);

        if (NT_SUCCESS(ntStatus)) {

            size = mbi.RegionSize;
            if ((pAppCompatExe->dwMagic == APPCOMPAT_EXE_DATA_MAGIC) &&
                (sizeof(APP_COMPAT_EXE_INFO) <= size) &&
                (pAppCompatExe->cbSize <= size))
            {
                PWCH p, pp = NULL;
                UNICODE_STRING usProcName;

                p = pAppCompatExe->szParentImageName;
                while (*p) {
                    if (*p++ == (WCHAR)'\\') {
                        pp = p;
                    }
                }

                RtlInitUnicodeString(&usProcName, pp);
                SkCheckBadProcess(pAppCompatExe->dwParentProcessId,
                    &usProcName,
                    ScanTypeAppCompat);

                SkIsParentProcessExist(ProcessList,
                    UlongToHandle(pAppCompatExe->dwParentProcessId),
                    pp);

            }
        }
        else {
            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Cannot query process AppCompat memory"),
                (LPWSTR)TEXT("NtQueryVirtualMemory"),
                (LPWSTR)TEXT("MemoryBasicInformation"));
        }
    }
}

/*
* SkiBuildProcessListWMI
*
* Purpose:
*
* Query process list with WMI RPC calls.
*
*/
BOOL SkiBuildProcessListWMI(
    _In_ HANDLE HeapHandle,
    _Out_ PPS_LIST* List
)
{
    BOOL bResult = FALSE;
    HRESULT hr = S_OK, hr2 = S_OK, hr3 = S_OK;
    IWbemLocator* WbemLocator = NULL;
    IWbemServices* WbemServices = NULL;
    IEnumWbemClassObject* enumWbem = NULL;
    IWbemClassObject* result = NULL;

    ULONG returnedCount = 0;

    BSTR bstrServer = NULL;
    BSTR bstrQuery = NULL, bstrQueryLanguage = NULL;
    VARIANT ProcessId, ProcessName, ParentPID;

    PS_LIST* psEntry;

    *List = NULL;

    do {

        VariantInit(&ProcessId);
        VariantInit(&ProcessName);
        VariantInit(&ParentPID);

        bstrServer = SysAllocString(L"ROOT\\CIMV2"); //CIMWin32
        bstrQuery = SysAllocString(L"SELECT * FROM Win32_Process");
        bstrQueryLanguage = SysAllocString(L"WQL");

        if ((bstrServer == NULL) ||
            (bstrQuery == NULL) ||
            (bstrQueryLanguage == NULL))
        {
            SkReportComCallRIP(E_FAIL,
                (LPWSTR)TEXT("Cannot allocate memory for string"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = CoCreateInstance(CLSID_WbemLocator,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IWbemLocator,
            (LPVOID*)&WbemLocator);

        if (FAILED(hr)) {
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Cannot create locator instance"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = WbemLocator->ConnectServer(bstrServer,
            NULL,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            &WbemServices);

        if (FAILED(hr)) {
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Cannot connect CIMV2 server"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = WbemServices->ExecQuery(bstrQueryLanguage,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &enumWbem);
        if (FAILED(hr)) {
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Failed to execute query"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        ULONG cProc = 0;

        while ((hr = enumWbem->Next(WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) {

            hr3 = result->Get(L"ParentProcessId", 0, &ParentPID, 0, 0);
            hr2 = result->Get(L"Name", 0, &ProcessName, 0, 0);
            hr = result->Get(L"ProcessId", 0, &ProcessId, 0, 0);
            if (SUCCEEDED(hr) && SUCCEEDED(hr2) && SUCCEEDED(hr3)) {

                psEntry = (PS_LIST*)RtlAllocateHeap(HeapHandle, HEAP_ZERO_MEMORY, sizeof(PS_LIST));
                if (psEntry) {

                    psEntry->UniqueProcessId = ProcessId.ulVal;
                    psEntry->Prev = *List;
                    psEntry->ParentProcessId = ParentPID.ulVal;

                    StringCchCopy(psEntry->szName,
                        RTL_NUMBER_OF(psEntry->szName),
                        ProcessName.bstrVal);

                    cProc += 1;
                }

                *List = psEntry;
            }

            VariantClear(&ProcessId);
            VariantClear(&ProcessName);
            VariantClear(&ParentPID);

            result->Release();
        }

        bResult = (cProc > 0);

    } while (FALSE);

    if (enumWbem) enumWbem->Release();
    if (WbemServices) WbemServices->Release();
    if (WbemLocator) WbemLocator->Release();

    if (bstrServer) SysFreeString(bstrServer);
    if (bstrQueryLanguage) SysFreeString(bstrQueryLanguage);
    if (bstrQuery) SysFreeString(bstrQuery);

    return bResult;
}

/*
* SkpGetProcessEntrySize
*
* Purpose:
*
* Calculate actual process entry size.
*
*/
ULONG SkpGetProcessEntrySize(
    _In_ PROBE_CONTEXT* Context,
    _In_ PSYSTEM_PROCESS_INFORMATION Entry
)
{
    ULONG entrySize;

    entrySize = FIELD_OFFSET(SYSTEM_PROCESS_INFORMATION, Threads);
    entrySize += Entry->ImageName.MaximumLength;
    entrySize += (Entry->ThreadCount * sizeof(SYSTEM_THREAD_INFORMATION));

    if (Context->WindowsMajorVersion >= 10) {
        //
        // Always present in enumeration even if not requested in Win10 and above.
        // Doesn't exist pre 8.1
        //
        entrySize += sizeof(SYSTEM_PROCESS_INFORMATION_EXTENSION);
    }
    return entrySize;
}

/*
* SkValidateProcessList
*
* Purpose:
*
* Do snapshots of running processes using different API and compare results.
*
*/
BOOL SkValidateProcessList(
    _In_ PROBE_CONTEXT* Context
)
{
    BOOL bWmiListWasReady = FALSE;
    ULONG oldAnomalyCount = SkiGetAnomalyCount(), returnedLength = 0, entrySize;
    PVOID processList;
    PS_LIST* currentEntry, * nextEntry, * WMIList = NULL;
    HANDLE enumHeap;
    ULONG_PTR parentPID = 0;
    ULONG nextEntryDelta = 0, prevEntryDelta = 0;
    ULONG currentPID = HandleToUlong(Context->ClientId.UniqueProcess);
    PROCESS_BASIC_INFORMATION pbi;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } NativeList;

    //
    // At first, walk list as usual.
    //
    __try {
        processList = supGetSystemInfo(SystemProcessInformation, &returnedLength);
        if (processList) {

            NativeList.ListRef = (PBYTE)processList;
            do {

                NativeList.ListRef += nextEntryDelta;
                prevEntryDelta = nextEntryDelta;

                SkCheckBadProcess(HandleToUlong(NativeList.Process->UniqueProcessId),
                    &NativeList.Process->ImageName, ScanTypeNative);

                //
                // Detect entry corruption.
                //
                entrySize = SkpGetProcessEntrySize(Context, NativeList.Process);
                nextEntryDelta = NativeList.Process->NextEntryDelta;
                if (nextEntryDelta && entrySize != nextEntryDelta) {
                    SkReportProcListCorruption(nextEntryDelta, entrySize);
                }

            } while (nextEntryDelta);

            //
            // Check against console host information.
            //
            SkiCheckConsoleHost(processList);

            //
            // Query AppCompat data.
            //
            SkiCheckAppCompat(processList);

            supHeapFree(processList);
            processList = NULL;
        }
        else {
            SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
                (LPWSTR)TEXT("Cannot query process list"),
                (LPWSTR)TEXT("NtQuerySystemInformation"),
                (LPWSTR)TEXT("SystemProcessInformation"));
        }

        //
        // Find detour/instrumentation hidden processes.
        //
        enumHeap = (HANDLE)RtlCreateHeap(HEAP_GROWABLE, NULL, 0, 0, NULL, NULL);
        if (enumHeap) {

            bWmiListWasReady = SkiBuildProcessListWMI(enumHeap, &WMIList);
            if (bWmiListWasReady) {

                processList = supGetSystemInfo(SystemProcessInformation, NULL);
                if (processList) {

                    currentEntry = WMIList;

                    while (currentEntry) {
                        nextEntry = currentEntry->Prev;

                        if (parentPID == 0 && currentEntry->UniqueProcessId == currentPID)
                            parentPID = currentEntry->ParentProcessId;

                        SkIsParentProcessExist(processList,
                            UlongToHandle(currentEntry->UniqueProcessId),
                            currentEntry->szName);

                        currentEntry = nextEntry;
                    }

                    supHeapFree(processList);
                }
                else {
                    SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
                        (LPWSTR)TEXT("Cannot query process list"),
                        (LPWSTR)TEXT("NtQuerySystemInformation"),
                        (LPWSTR)TEXT("SystemProcessInformation"));
                }
            }
            else {
                SkiIncreaseAnomalyCount();
                supReportEvent(evtDetection,
                    (LPWSTR)TEXT("WMI query failed"),
                    NULL,
                    DT_WMIQUERY);
            }

            SkiAnyWubbaboosInProcessList(WMIList);
            RtlDestroyHeap(enumHeap);
        }
        else {
            SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
                (LPWSTR)TEXT("Cannot create enumeration heap"),
                (LPWSTR)TEXT("RtlCreateHeap"),
                DT_WMIQUERY);
        }

        //
        // Parent process faking check.
        //
        if (bWmiListWasReady) {
            ULONG length;
            NTSTATUS ntStatus = NtQueryInformationProcess(NtCurrentProcess(),
                ProcessBasicInformation,
                &pbi,
                sizeof(PROCESS_BASIC_INFORMATION),
                &length);

            if (!NT_SUCCESS(ntStatus)) {

                SkReportNtCallRIP(ntStatus,
                    (LPWSTR)TEXT("Failed to query process basic information"),
                    (LPWSTR)TEXT("NtQueryInformationProcess"),
                    NTQIP_PBI_QUERY);

            }
            else {
                if (pbi.InheritedFromUniqueProcessId != parentPID) {

                    SkReportParentProcessMismatch(pbi.InheritedFromUniqueProcessId,
                        parentPID);

                }
            }
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SkReportNtCallRIP(STATUS_ACCESS_VIOLATION,
            (LPWSTR)TEXT("Access violation while parsing process list"),
            (LPWSTR)TEXT("SkValidateProcessList"),
            NULL);
    }
    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/reports.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       REPORTS.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Probe report workers.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

//
// Failure report policy.
//
// Since this code doesn't use anything that requires advanced privileges (except BootCfg queries)
// and entire class of "tested software" is a far from following any kind of software quality standards 
// -> MOST OF failures here will be traited as detects. Deal with it.
//

VOID SkReportVersionResourceBuildNumber(
    _In_ LPCWSTR DllName,
    _In_ ULONG RefBuildNumber,
    _In_ ULONG BuildNumber
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH], szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    RtlSecureZeroMemory(&szText, sizeof(szText));

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("%lu"),
        RefBuildNumber);

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Invalid build number in ntdll resources, %ws reports %lu"),
        DllName,
        BuildNumber);


    supReportEvent(evtError,
        szText,
        szBuffer,
        DT_BUILDNUMBER);
}

VOID SkReportWrongWinVersion(
    _In_ LPWSTR lpMessage,
    _In_ ULONG dwVersionMajor,
    _In_ ULONG dwVersionMinor,
    _In_ ULONG dwBuildNumber,
    _In_ LPWSTR lpType
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    szText[0] = 0;
    ultostr(dwVersionMajor, szText);
    _strcat(szText, TEXT("."));
    ultostr(dwVersionMinor, _strend(szText));
    _strcat(szText, TEXT("."));
    ultostr(dwBuildNumber, _strend(szText));

    supReportEvent(evtError,
        lpMessage,
        szText,
        lpType);
}

VOID SkReportInvalidHandleClosure(
    _In_ ULONG ConditionType
)
{
    WCHAR szText[MAX_TEXT_LENGTH];
    LPWSTR lpCondition;

    if (ConditionType == 0)
        lpCondition = (LPWSTR)TEXT("Handle trace");
    else
        lpCondition = (LPWSTR)TEXT("Unspecified");
    
    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
        TEXT("NtClose anomaly detected, condition: %ws"),
        lpCondition);

    SkiIncreaseAnomalyCount();
    supReportEvent(evtDetection,
        szText,
        (LPWSTR)TEXT("Invalid Handle Closure"),
        DT_INJECTEDCODE);
}

VOID SkReportSuspectRegion(
    _In_ PMEMORY_BASIC_INFORMATION Information
)
{
    WCHAR szText[MAX_TEXT_LENGTH], szDetails[MAX_TEXT_LENGTH];
    WCHAR szValue[20];
    LPWSTR lpType, lpProtect;

    SkiIncreaseAnomalyCount();

    switch (Information->Type) {

    case MEM_MAPPED:
        lpType = (LPWSTR)TEXT("Mapped");
        break;
    case MEM_PRIVATE:
        lpType = (LPWSTR)TEXT("Private");
        break;
    case MEM_IMAGE:
        lpType = (LPWSTR)TEXT("Image");
        break;
    default:
        lpType = (LPWSTR)TEXT("Unknown");
    }

    if (Information->Protect & PAGE_EXECUTE)
        lpProtect = (LPWSTR)TEXT("X");
    else
    if (Information->Protect & PAGE_EXECUTE_READ)
        lpProtect = (LPWSTR)TEXT("RX");
    else
    if (Information->Protect & PAGE_EXECUTE_READWRITE)
        lpProtect = (LPWSTR)TEXT("RWX");
    else
    if (Information->Protect & PAGE_EXECUTE_WRITECOPY)
        lpProtect = (LPWSTR)TEXT("WCX");
    else {
        szValue[0] = L'0';
        szValue[1] = L'x';
        szValue[2] = 0;
        ultohex(Information->Protect, &szValue[2]);
        lpProtect = (LPWSTR)&szValue;
    }

    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
        TEXT("Suspicious region with executable memory, size: 0x%llX, %ws, %ws"),
        Information->RegionSize, lpType, lpProtect);

    StringCchPrintf(szDetails, RTL_NUMBER_OF(szDetails),
        TEXT("0x%llX"),
        (ULONG_PTR)Information->BaseAddress);

    supReportEvent(evtDetection,
        szText,
        szDetails,
        DT_INJECTEDCODE);
}

VOID SkReportNtdllMapRIP(
    _In_ NTDLL_MAP_METHOD Method
)
{
    WCHAR szText[MAX_TEXT_LENGTH];
    LPWSTR lpMethodName = NULL;

    SkiIncreaseAnomalyCount();

    switch (Method) {
    case UseRelativePath:
        lpMethodName = (LPWSTR)TEXT("relative path");
        break;
    case UseKnownDllsAbsolute:
        lpMethodName = (LPWSTR)TEXT("Known Dlls absolute path");
        break;

    case UseKnownDllsRelative:
        lpMethodName = (LPWSTR)TEXT("KnownDlls relative path");
        break;

    case UseLdrKnownDllDirectoryHandle:
        lpMethodName = (LPWSTR)TEXT("KnownDlls cached directory handle");
        break;

    default:
        lpMethodName = (LPWSTR)TEXT("absolute path");
    }

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Unable to map ntdll copy using %ws"),
        lpMethodName);

    supReportEvent(evtError,
        szText,
        NULL,
        DT_NTDLL_SOURCE);
}

VOID SkReportComCallRIP(
    _In_ HRESULT Hresult,
    _In_ LPWSTR lpMessage,
    _In_opt_ LPWSTR lpApiName,
    _In_opt_ LPWSTR lpQueryName
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("%ws, HRESULT(0x%lX)"),
        lpMessage,
        Hresult);

    supReportEvent(evtError,
        szBuffer,
        lpQueryName,
        lpApiName);
}

VOID SkReportNtCallRIP(
    _In_ NTSTATUS NtStatus,
    _In_ LPWSTR lpMessage,
    _In_opt_ LPWSTR lpApiName,
    _In_opt_ LPWSTR lpQueryName
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("%ws, NTSTATUS(0x%lX)"),
        lpMessage,
        NtStatus);

    supReportEvent(evtError,
        szBuffer,
        lpQueryName,
        lpApiName);
}

VOID SkReportObTypeListCorruption(
    _In_ ULONG ReportedLength,
    _In_ ULONG ActualLength
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
        TEXT("Object type list corruption, expected length %lu, got length %lu"),
        ReportedLength, ActualLength);

    supReportEvent(evtDetection,
        szText,
        (LPWSTR)TEXT("ObjectTypesInformation"),
        DT_DATACORRUPTION);

}

VOID SkReportHandleListCorruption(
    _In_ ULONG ReportedLength,
    _In_ ULONG ActualLength
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
        TEXT("Handle list corruption, expected length %lu, got length %lu"),
        ReportedLength, ActualLength);

    supReportEvent(evtDetection,
        szText,
        (LPWSTR)TEXT("SystemExtendedHandleInformation"),
        DT_DATACORRUPTION);

}

VOID SkReportProcListCorruption(
    _In_ ULONG NextEntryOffset,
    _In_ ULONG ExpectedOffset
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
        TEXT("Process entry corruption, expected offset %lu, got offset %lu"),
        ExpectedOffset, NextEntryOffset);

    supReportEvent(evtDetection,
        szText,
        (LPWSTR)TEXT("SystemProcessInformation"),
        DT_DATACORRUPTION);

}

VOID SkReportThreadUnknownRip(
    _In_ ULONG64 Rip
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Thread with RIP outside known modules: 0x%llX"),
        Rip);

    supReportEvent(evtDetection,
        szText,
        NULL,
        DT_SUSPICIOUS_THREAD);
}

VOID SkReportThreadCountRIP()
{
    SkiIncreaseAnomalyCount();

    supReportEvent(evtDetection,
        (LPWSTR)TEXT("System reports invalid thread count for client"),
        NULL,
        DT_INVALID_THREADCOUNT);
}

VOID SkReportSessionIdRIP(
    _In_ ULONG SessionId
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("PEB: %lu, API: %lu"),
        NtCurrentPeb()->SessionId, SessionId);

    supReportEvent(evtDetection,
        (LPWSTR)TEXT("PEB->SessionId is different of what system reports"),
        szText,
        DT_INVALID_SESSIONID);
}

VOID SkReportInvalidExtractedSSN(
    _In_ LPWSTR lpQueryType
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("Invalid syscall id, ntdll copy mapped using %ws"),
        lpQueryType);

    supReportEvent(evtError,
        szBuffer,
        (LPWSTR)TEXT("0xFFFFFFFFFF"),
        DT_SSN_EXTRACTION_INVALID_DATA);
}

VOID SkReportUnexpectedSSN(
    _In_ ULONG SsnGot,
    _In_ ULONG SsnExpected
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("Syscall index mismatch detected, got 0x%lX, 0x%lX"),
        SsnGot,
        SsnExpected);

    supReportEvent(evtError,
        szBuffer,
        NULL,
        DT_SSN_EXTRACTION_INVALID_DATA);
}

VOID SkReportExtractionFailureEvent(
    _In_ LPCSTR lpName,
    _In_opt_ LPWSTR lpDescription,
    _In_ LPWSTR lpAnomalyType
)
{
    WCHAR szText[MAX_TEXT_LENGTH * 2];
    WCHAR szName[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    RtlSecureZeroMemory(&szName, sizeof(szName));
    MultiByteToWideChar(CP_ACP, 0, lpName, -1, szName, MAX_TEXT_LENGTH);

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Failure of SSN extraction for %ws"),
        szName);

    supReportEvent(evtError,
        szText,
        lpDescription,
        lpAnomalyType);
}

VOID SkReportParentProcessMismatch(
    _In_ ULONG_PTR InheritedFromUniqueProcessId,
    _In_ ULONG_PTR ParentPID
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("Parent process id mismatch: %llu, expected %llu"),
        InheritedFromUniqueProcessId,
        ParentPID);

    supReportEvent(evtDetection,
        szBuffer,
        NTQIP_PBI_QUERY,
        DT_PARENT_MISMATCH);
}

VOID SkReportSuspectHandleEntry(
    _In_ BOOL IsProcess,
    _In_ PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();
    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("Our %ws handle in %llu with suspicious access rights 0x%lX"),
        IsProcess ? TEXT("process") : TEXT("thread"),
        HandleEntry->UniqueProcessId,
        HandleEntry->GrantedAccess);

    supReportEvent(evtDetection,
        szBuffer,
        (LPWSTR)TEXT("SystemExtendedHandleInformation"),
        (LPWSTR)TEXT("NtQuerySystemInformation"));
}

VOID SkReportDebugObject(
    _In_ ULONG NumberOfObjects,
    _In_ BOOL IsHandlde
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        (IsHandlde != FALSE) ?
        TEXT("DebugObject type handles are found: %lu") : TEXT("DebugObject type objects are found: %lu"),
        NumberOfObjects);

    supReportEvent(evtDetection,
        szBuffer,
        (LPWSTR)TEXT("SystemExtendedHandleInformation"),
        (LPWSTR)TEXT("NtQuerySystemInformation"));
}

VOID SkReportDebugObjectHandleMismatch(
    _In_ ULONG NumberOfObjects,
    _In_ ULONG NumberOfObjectsThroughQuery
)
{
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();
    StringCchPrintf(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("Debug Objects handles mismatch, got %lu, expected %lu"),
        NumberOfObjects,
        NumberOfObjectsThroughQuery);

    supReportEvent(evtDetection,
        szBuffer,
        (LPWSTR)TEXT("ObjectTypesInformation"),
        (LPWSTR)TEXT("NtQueryObject"));
}

VOID SkReportDeviceObject(
    _In_ LPWSTR DeviceName
)
{
    SkiIncreaseAnomalyCount();

    supReportEvent(evtDetection,
        (LPWSTR)TEXT("Suspicious driver device has been detected"),
        DeviceName,
        DT_DRIVER_DEVICE);
}

VOID SkReportDriverListModification(
    _In_ ULONG ReportedLength,
    _In_ ULONG ExpectedLength
)
{
    WCHAR szText[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Driver list modified, length reported %lu, length expected %lu"),
        ReportedLength,
        ExpectedLength);

    supReportEvent(evtDetection,
        szText,
        (LPWSTR)TEXT("NtQuerySystemInformation"),
        (LPWSTR)TEXT("SystemModuleInformation"));
}

VOID SkReportDebugDetected(
    _In_ ULONG Type,
    _In_ LPWSTR RoutineName,
    _In_opt_ LPWSTR InformationClass
)
{
    SkiIncreaseAnomalyCount();

    supReportEvent(evtDetection,
        (Type == 0) ? (LPWSTR)TEXT("Process Is Under Debug") : (LPWSTR)TEXT("Kernel Debugger Is Active"),
        RoutineName,
        InformationClass);
}

VOID SkReportBcdProbeMismatch(
    _In_ ULONG ApiQueryData,
    _In_ LPWSTR BcdProbeDescription,
    _In_ ULONG BcdProbeValue
)
{
    WCHAR szText[MAX_TEXT_LENGTH];
    WCHAR szDetails[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Value %ws(%lX) mismatch with data from BCD query"),
        BcdProbeDescription, ApiQueryData);

    StringCchPrintf(szDetails,
        RTL_NUMBER_OF(szDetails),
        TEXT("Element: 0x%lX"),
        BcdProbeValue);

    supReportEvent(evtDetection,
        szText,
        szDetails,
        DT_BCDMISMATCH);
}

VOID SkReportThreadOpenError(
    _In_ HANDLE WindowHandle,
    _In_ HANDLE ThreadId,
    _In_ BOOL IsClientElevated,
    _In_ NTSTATUS NtStatus
)
{
    WCHAR szText[MAX_TEXT_LENGTH];
    WCHAR szStatus[MAX_TEXT_LENGTH];

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Error opening window %llu owner thread %llu, our client %s elevated"),
        (ULONG_PTR)WindowHandle,
        (ULONG_PTR)ThreadId,
        IsClientElevated ? TEXT("is") : TEXT("is not"));

    StringCchPrintf(szStatus,
        RTL_NUMBER_OF(szStatus),
        TEXT("0x%lX"),
        NtStatus);

    supReportEvent(evtError,
        szText,
        szStatus,
        DT_ERROR_OPEN_OBJECT);
}

VOID SkReportHiddenProcessWindow(
    _In_ HANDLE UniqueProcessId,
    _In_ HANDLE UniqueThreadId,
    _In_ HANDLE WindowHandle
)
{
    WCHAR szText[MAX_TEXT_LENGTH];
    WCHAR szDetails[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szText,
        RTL_NUMBER_OF(szText),
        TEXT("Window belongs to process that is invisible to client"));

    StringCchPrintf(szDetails,
        RTL_NUMBER_OF(szDetails),
        TEXT("PID: %llu, TID: %llu, WND: 0x%llX"),
        (ULONG_PTR)UniqueProcessId, (ULONG_PTR)UniqueThreadId, (ULONG_PTR)WindowHandle);

    supReportEvent(evtDetection,
        szText,
        szDetails,
        DT_USEROBJECT);
}

VOID SkReportGdiObject(
    _In_ HANDLE UniqueProcessId,
    _In_ OBJTYPE ObjectType
)
{
    LPWSTR lpObjectType;
    WCHAR szDetails[MAX_TEXT_LENGTH];
    WCHAR szType[20];

    SkiIncreaseAnomalyCount();

    switch (ObjectType) {
    case DC_TYPE:
        lpObjectType = (LPWSTR)TEXT("DC");
        break;
    case RGN_TYPE:
        lpObjectType = (LPWSTR)TEXT("Region");
        break;
    case PAL_TYPE:
        lpObjectType = (LPWSTR)TEXT("Palette");
        break;
    case SURF_TYPE:
        lpObjectType = (LPWSTR)TEXT("Surface");
        break;
    case LFONT_TYPE:
    case RFONT_TYPE:
        lpObjectType = (LPWSTR)TEXT("Font");
        break;
    case BRUSH_TYPE:
        lpObjectType = (LPWSTR)TEXT("Brush");
        break;
    default:
        szType[0] = L'0';
        szType[1] = L'x';
        szType[2] = 0;
        ultohex(ObjectType, &szType[2]);
        lpObjectType = (LPWSTR)&szType;
        break;
    }

    StringCchPrintf(szDetails,
        RTL_NUMBER_OF(szDetails),
        TEXT("PID: %llu, OBJTYPE: %ws"),
        (ULONG_PTR)UniqueProcessId, lpObjectType);

    supReportEvent(evtDetection,
        (LPWSTR)TEXT("GDI object belongs to process that is invisible to client"),
        szDetails,
        DT_GDIOBJECT);
}

VOID SkReportUnknownCode(
    _In_ ULONG_PTR Address,
    _In_ KPROCESSOR_MODE Mode
)
{ 
    WCHAR szDetails[MAX_TEXT_LENGTH];

    SkiIncreaseAnomalyCount();

    StringCchPrintf(szDetails,
        RTL_NUMBER_OF(szDetails),
        TEXT("0x%llX"),
        Address);

    supReportEvent(evtDetection,
        (Mode == 0) ? (LPWSTR)TEXT("Found executable code outside of drivers list") :
        (LPWSTR)TEXT("Found executable code outside of loader list"),
        szDetails,
        DT_UNKNOWNCODE);

}

```

`Source/probes/syscall.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       SYSCALL.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

BOOL SkiSetSyscallAddress(
    _In_ PVOID ImageBase,
    _In_ LPCSTR lpExtractFrom)
{
    //
    // Extract syscall address.
    //
    KiSystemCallAddress = supSyscallAddressFromServiceEntry(ImageBase, lpExtractFrom);
    if (KiSystemCallAddress == 0) {

        SkiIncreaseAnomalyCount();

        supReportEvent(evtError,
            (LPWSTR)TEXT("Failed to locate system call instruction address"),
            NULL,
            DT_SYSCALL_EXTRACT);

    }

    return (KiSystemCallAddress != 0);
}

BOOL SkpValidatePairOfSSN(
    _In_ ULONG TestSSN,
    _In_ ULONG TestSSN2,
    _In_ LPCSTR lpName,
    _In_ SSN_EXTRACT_METHOD Method
)
{
    WCHAR szText[MAX_TEXT_LENGTH], szName[MAX_TEXT_LENGTH];
    LPWSTR lpMethod;

    BOOL bResult = (TestSSN == TestSSN2);

    if (bResult == FALSE) {

        SkiIncreaseAnomalyCount();

        switch (Method) {

        case SsnSortedScan:
            lpMethod = (LPWSTR)TEXT("Sorting");
            break;
        case SsnRuntimeScan:
            lpMethod = (LPWSTR)TEXT("Runtime");
            break;
        case SsnThreadInformation:
            lpMethod = (LPWSTR)TEXT("Thread Information");
            break;

        default:
            lpMethod = (LPWSTR)TEXT("Instruction");
        }

        StringCchPrintf(szText,
            RTL_NUMBER_OF(szText),
            TEXT("SSN mismatch, got %lu expected %lu (Scan Type: %ws)"), 
            TestSSN, 
            TestSSN2, 
            lpMethod);

        RtlSecureZeroMemory(&szName, sizeof(szName));
        MultiByteToWideChar(CP_ACP, 0, lpName, -1, szName, MAX_TEXT_LENGTH);

        supReportEvent(evtError,
            szText,
            szName,
            DT_SSN_MISMATCH);

    }

    return bResult;
}

BOOL SkiSetSyscallIndex(
    _In_ PVOID ImageBase,
    _In_ LPCSTR lpName)
{
    KiSystemCallNumber = supExtractSSN(SsnSortedScan, ImageBase, TRUE, lpName);
    if (KiSystemCallNumber == INVALID_SYSCALL_ID) {

        SkReportExtractionFailureEvent(lpName,
            NULL,
            DT_SSN_EXTRACTION_DIRECT);

        return FALSE;
    }

    return TRUE;
}

/*
* SkiQueryAndValidateSSN
*
* Purpose:
*
* Extract and validate SSN for given syscall name.
*
*/
ULONG SkiQueryAndValidateSSN(
    _In_ PROBE_CONTEXT *Context,
    _In_ LPCSTR lpName,
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ BOOL bValidate
)
{
    BOOL bW10next = (Context->WindowsMajorVersion >= 10 && Context->ReferenceNtBuildNumber >= NT_WIN11_21H2);
    ULONG testSSN, testSSN2, testSSN3, testSSN4;
    WCHAR szBuffer[MAX_TEXT_LENGTH];

    testSSN2 = INVALID_SYSCALL_ID;
    testSSN3 = INVALID_SYSCALL_ID;
    testSSN4 = INVALID_SYSCALL_ID;

    testSSN = supExtractSSN(SsnInstructionScan, ImageBase, IsNtDll, lpName);
    if (testSSN == INVALID_SYSCALL_ID) {

        szBuffer[0] = 0;

        PBYTE ptrCode;
        ptrCode = (PBYTE)supLdrGetProcAddressEx(ImageBase, lpName);

        if (ptrCode) {
            StringCchPrintf(szBuffer,
                RTL_NUMBER_OF(szBuffer),
                TEXT("Got 0x%02X, 0x%02X, 0x%02X"),
                ptrCode[0], ptrCode[1], ptrCode[2]);
        }

        SkReportExtractionFailureEvent(lpName,
            szBuffer,
            DT_SSN_EXTRACTION_DIRECT);

    }

    if (bValidate) {

        if (!IsNtDll && bW10next) {

            //
            // HACK: Post Win10 win32u fast-failing and address sorting SSN query problem.
            // Since apfnSimpleCall removal MS decided to just fast fail in designated 
            // services instead of removing them. Thus completely ruins the address sorting extraction as 
            // number of fast-failing services are changing between versions and exported routines 
            // ARE NOT syscalls but usermode stubs excluded from SSN adjustment.
            // 
            testSSN2 = testSSN;
        }
        else {

            testSSN2 = supExtractSSN(SsnSortedScan, ImageBase, IsNtDll, lpName);
            if (testSSN2 == INVALID_SYSCALL_ID) {

                SkReportExtractionFailureEvent(lpName,
                    NULL,
                    DT_SSN_EXTRACTION_INDIRECT);

            }

        }

        if (!IsNtDll && bW10next) {

            //
            // HACK: Post Win10 win32u fast-failing and address sorting SSN query problem.
            // While it is all guarded by SEH we cannot use this method also as it will 
            // give as junk stubs ruining SSN adjustments.
            // 
            testSSN3 = testSSN2;
        }
        else {
            testSSN3 = supExtractSSN(SsnRuntimeScan, ImageBase, IsNtDll, lpName);
            if (testSSN3 == INVALID_SYSCALL_ID) {

                SkReportExtractionFailureEvent(lpName,
                    NULL,
                    DT_SSN_EXTRACTION_INDIRECT_RUNTIME);

            }
        }

        testSSN4 = supExtractSSN(SsnThreadInformation, ImageBase, IsNtDll, lpName);
        if (IsNtDll && testSSN4 == INVALID_SYSCALL_ID) {
            SkReportExtractionFailureEvent(lpName,
                NULL,
                DT_SSN_EXTRACTION_THREAD_INFORMATION);
        }

        if (testSSN != INVALID_SYSCALL_ID &&
            testSSN2 != INVALID_SYSCALL_ID &&
            testSSN3 != INVALID_SYSCALL_ID)
        {
            if (SkpValidatePairOfSSN(testSSN, testSSN2, lpName, SsnSortedScan))
                SkpValidatePairOfSSN(testSSN, testSSN3, lpName, SsnRuntimeScan);
        }

        if (IsNtDll && testSSN != INVALID_SYSCALL_ID && testSSN4 != INVALID_SYSCALL_ID) {
            SkpValidatePairOfSSN(testSSN, testSSN4, lpName, SsnThreadInformation);
        }
    }
    return testSSN;
}

/*
* SkpVectoredExceptionHandler
*
* Purpose:
*
* VEH handler for indirect syscall.
*
*/
LONG WINAPI SkpVectoredExceptionHandler(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
)
{
    PNTCALL_THREAD_CONTEXT Context;

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION &&
        ExceptionInfo->ExceptionRecord->ExceptionAddress == (PVOID)((ULONG64)~((ULONG64)0x1337))) {

        Context = (PNTCALL_THREAD_CONTEXT)RtlGetFrame();
        if (Context) {
            ExceptionInfo->ContextRecord->R10 = ExceptionInfo->ContextRecord->Rcx;
            ExceptionInfo->ContextRecord->Rax = Context->SystemCallNumber;
            ExceptionInfo->ContextRecord->Rip = Context->SystemCallAddress;
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

/*
* SkTestVectoredCall
*
* Purpose:
*
* Execute indirect syscall during VEH.
*
*/
BOOL SkTestVectoredCall(
    _In_ ULONG SystemCallNumber,
    _In_ ULONG_PTR SystemCallAddress,
    _In_ SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX* ReferenceInfo
)
{
    BOOL bCheckPassed = TRUE;
    NTCALL_THREAD_CONTEXT ctx;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX info;
    ULONG returnLength;
    NTSTATUS ntStatus;
    pfnNtQuerySystemInformation Function = (pfnNtQuerySystemInformation)((ULONG64)~((ULONG64)0x1337));

    RtlFillMemory(&ctx, sizeof(ctx), 0);
    ctx.SystemCallAddress = SystemCallAddress;
    ctx.SystemCallNumber = SystemCallNumber;

    if (RtlAddVectoredExceptionHandler(1, (PVECTORED_EXCEPTION_HANDLER)&SkpVectoredExceptionHandler)) {

        RtlPushFrame((PTEB_ACTIVE_FRAME)&ctx);

        {
            PUSH_DISABLE_WARNING(6011)
                ntStatus = Function(SystemKernelDebuggerInformationEx, &info, sizeof(info), &returnLength);
            POP_DISABLE_WARNING(6011)
        }

        RtlPopFrame((PTEB_ACTIVE_FRAME)&ctx);

        RtlRemoveVectoredExceptionHandler((PVECTORED_EXCEPTION_HANDLER)&SkpVectoredExceptionHandler);

        if (NT_SUCCESS(ntStatus)) {

            ULONG size = sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX);

            if (size != RtlCompareMemory(ReferenceInfo,
                &info,
                sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)))
            {
                WCHAR szText[MAX_TEXT_LENGTH];

                bCheckPassed = FALSE;

                SkiIncreaseAnomalyCount();

                StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                    TEXT("Modification of the output buffer"));

                supReportEvent(evtDetection,
                    szText,
                    NTQSI_DBG_QUERY,
                    DT_INDIRECT_SYSCALL_VEH);
            }

        }
        else {

            SkReportNtCallRIP(ntStatus,
                (LPWSTR)TEXT("Indirect call failed"),
                (LPWSTR)TEXT("NtQuerySystemInformation"),
                (LPWSTR)TEXT("SystemKernelDebuggerInformationEx"));

        }
    }

    return bCheckPassed;
}

/*
* SkTestSyscalls
*
* Purpose:
*
* Extract SSN's, test calls.
*
*/
BOOL SkTestSyscalls(
    _In_ PPROBE_CONTEXT Context
)
{
    BOOL bSyscallSet = FALSE;
    PVOID imageBase = Context->NtDllBase;
    NTSTATUS ntStatus, ntStatusNormal;
    ULONG i, oldCount = SkiGetAnomalyCount();
    ULONG length, size;
    WCHAR szText[MAX_TEXT_LENGTH];

    SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX infoBuffer, refInfoBuffer;
    pfnNtQuerySystemInformation pNtQuerySystemInformation;
    PROCESS_BASIC_INFORMATION pbiRef, pbi;
    pfnNtQueryInformationProcess pNtQueryInformationProcess;

    szText[0] = 0;

    //
    // Set syscall instruction address for indirect calls.
    //
    bSyscallSet = SkiSetSyscallAddress(imageBase, "NtAccessCheck");

    for (i = 0; i < RTL_NUMBER_OF(g_NtTestSet); i++) {
        
        SkiQueryAndValidateSSN(Context, 
            g_NtTestSet[i], 
            imageBase, 
            TRUE, 
            TRUE);

    }

    //
    // Calls validation.
    //

    size = sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX);
    RtlSecureZeroMemory(&refInfoBuffer, sizeof(refInfoBuffer));

    if (SkiSetSyscallIndex(imageBase, g_NtTestSet[PROC_INDEX_QSI])) {

        //
        // Perform a bait call to be our reference.
        //
        ntStatusNormal = NtQuerySystemInformation(SystemKernelDebuggerInformationEx,
            &refInfoBuffer,
            sizeof(refInfoBuffer),
            &length);

        //
        // Direct calls accessibility.
        //
        RtlSecureZeroMemory(&infoBuffer, sizeof(infoBuffer));
        pNtQuerySystemInformation = (pfnNtQuerySystemInformation)&SkiDirectSystemCall;
        ntStatus = pNtQuerySystemInformation(SystemKernelDebuggerInformationEx,
            &infoBuffer,
            sizeof(infoBuffer),
            &length);

        if (ntStatus != ntStatusNormal) {

            SkiIncreaseAnomalyCount();

            StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                TEXT("Return status mismatch: 0x%lX, expected 0x%lX"),
                ntStatus, ntStatusNormal);

            supReportEvent(evtDetection,
                szText,
                NTQSI_DBG_QUERY,
                DT_DIRECT_SYSCALL);
        }

        if (NT_SUCCESS(ntStatus)) {
            if (size != RtlCompareMemory(
                &refInfoBuffer,
                &infoBuffer,
                sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)))
            {
                SkiIncreaseAnomalyCount();

                StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                    TEXT("Modification of the output buffer"));

                supReportEvent(evtDetection,
                    szText,
                    NTQSI_DBG_QUERY,
                    DT_DIRECT_SYSCALL);
            }
        }

        if (bSyscallSet) {

            //
            // Indirect calls accessibility.
            //
            RtlSecureZeroMemory(&infoBuffer, sizeof(infoBuffer));
            pNtQuerySystemInformation = (pfnNtQuerySystemInformation)&SkiIndirectSystemCall;
            ntStatus = pNtQuerySystemInformation(SystemKernelDebuggerInformationEx,
                &infoBuffer,
                sizeof(infoBuffer),
                &length);

            if (ntStatus != ntStatusNormal) {

                SkiIncreaseAnomalyCount();

                StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                    TEXT("Return status mismatch: 0x%lX, expected 0x%lX"),
                    ntStatus, ntStatusNormal);

                supReportEvent(evtDetection,
                    szText,
                    NTQSI_DBG_QUERY,
                    DT_INDIRECT_SYSCALL);
            }

            if (NT_SUCCESS(ntStatus)) {

                if (size != RtlCompareMemory(&refInfoBuffer,
                    &infoBuffer,
                    sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)))
                {
                    SkiIncreaseAnomalyCount();

                    StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                        TEXT("Modification of the output buffer"));

                    supReportEvent(evtDetection,
                        szText,
                        NTQSI_DBG_QUERY,
                        DT_INDIRECT_SYSCALL);
                }

            }
            else {
                SkiIncreaseAnomalyCount();

                StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                    TEXT("NtQuerySystemInformation failed with NTSTATUS(%lX)"),
                    ntStatus);

                supReportEvent(evtError,
                    szText,
                    NTQSI_DBG_QUERY,
                    DT_INDIRECT_SYSCALL);
            }

            //
            // VEH based indirect call.
            //
#ifndef _DEBUG
            SkTestVectoredCall(KiSystemCallNumber, KiSystemCallAddress, &refInfoBuffer);
#endif
        }

    }

    //
    // Test NtQueryInformationProcess indirect call.
    //
    if (bSyscallSet && SkiSetSyscallIndex(imageBase, g_NtTestSet[PROC_INDEX_QIP])) {

        //
        // Perform a bait call to be our reference.
        //

        ntStatusNormal = NtQueryInformationProcess(NtCurrentProcess(),
            ProcessBasicInformation,
            &pbiRef,
            sizeof(PROCESS_BASIC_INFORMATION),
            &length);

        pNtQueryInformationProcess = (pfnNtQueryInformationProcess)SkiIndirectSystemCall;

        ntStatus = pNtQueryInformationProcess(NtCurrentProcess(),
            ProcessBasicInformation,
            &pbi,
            sizeof(PROCESS_BASIC_INFORMATION),
            &length);

        if (NT_SUCCESS(ntStatus)) {


            if (pbiRef.InheritedFromUniqueProcessId != pbi.InheritedFromUniqueProcessId) {

                SkReportParentProcessMismatch(pbiRef.InheritedFromUniqueProcessId,
                    pbi.InheritedFromUniqueProcessId);

            }

        }
        else {
            SkiIncreaseAnomalyCount();
            StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                TEXT("NtQuerySystemInformation failed with NTSTATUS(%lX)"),
                ntStatus);

            supReportEvent(evtError,
                szText,
                NTQIP_PBI_QUERY,
                DT_INDIRECT_SYSCALL);

        }

    }
    else {
        _strcpy(szText, (LPWSTR)TEXT("Failure of SSN extraction for NtQueryInformationProcess"));

        supReportEvent(evtError,
            szText,
            NTQIP_PBI_QUERY,
            DT_SSN_EXTRACTION_INDIRECT);
    }

    return (SkiGetAnomalyCount() == oldCount);
}

/*
* SkLoadNtDllCopies
*
* Purpose:
*
* Load ntdll copies using different approaches.
*
*/
BOOL SkLoadNtDllCopies()
{
    ULONG i, oldAnomalyCount = SkiGetAnomalyCount();
    NTSTATUS ntStatus;
    PVOID ntdllPointers[MapMethodMax];

    for (i = 0; i < MapMethodMax; i++) {                   
        ntStatus = supMapNtdllCopy((NTDLL_MAP_METHOD)i, &ntdllPointers[i]);
        if (!NT_SUCCESS(ntStatus))
            SkReportNtdllMapRIP((NTDLL_MAP_METHOD)i);
    }

    ULONG testSSN = supExtractSSN(SsnInstructionScan,
        ntdllPointers[UseAbsolutePath],
        TRUE,
        g_NtTestSet[PROC_INDEX_QSI]);

    if (testSSN == INVALID_SYSCALL_ID) {
        SkReportInvalidExtractedSSN((LPWSTR)TEXT("absolute path"));
    }

    ULONG testSSN2 = supExtractSSN(SsnInstructionScan,
        ntdllPointers[UseRelativePath],
        TRUE,
        g_NtTestSet[PROC_INDEX_QSI]);

    if (testSSN2 == INVALID_SYSCALL_ID) {
        SkReportInvalidExtractedSSN((LPWSTR)TEXT("relative path"));
    }

    ULONG testSSN3 = supExtractSSN(SsnInstructionScan,
        ntdllPointers[UseKnownDllsAbsolute],
        TRUE,
        g_NtTestSet[PROC_INDEX_QSI]);

    if (testSSN3 == INVALID_SYSCALL_ID) {
        SkReportInvalidExtractedSSN((LPWSTR)TEXT("KnownDlls (absolute)"));
    }

    ULONG testSSN4 = supExtractSSN(SsnInstructionScan,
        ntdllPointers[UseKnownDllsRelative],
        TRUE,
        g_NtTestSet[PROC_INDEX_QSI]);

    if (testSSN4 == INVALID_SYSCALL_ID) {
        SkReportInvalidExtractedSSN((LPWSTR)TEXT("KnownDlls (relative)"));
    }

    ULONG testSSN5 = supExtractSSN(SsnInstructionScan,
        ntdllPointers[UseLdrKnownDllDirectoryHandle],
        TRUE,
        g_NtTestSet[PROC_INDEX_QSI]);

    if (testSSN5 == INVALID_SYSCALL_ID) {
        SkReportInvalidExtractedSSN((LPWSTR)TEXT("KnownDlls (cached directory handle)"));
    }

    if (testSSN != INVALID_SYSCALL_ID &&
        testSSN2 != INVALID_SYSCALL_ID &&
        testSSN3 != INVALID_SYSCALL_ID &&
        testSSN4 != INVALID_SYSCALL_ID &&
        testSSN5 != INVALID_SYSCALL_ID)
    {
        if (testSSN2 != testSSN) {
            SkReportUnexpectedSSN(testSSN2, testSSN);
        }
        else {
            if (testSSN3 != testSSN2) {
                SkReportUnexpectedSSN(testSSN3, testSSN2);
            }
            else
                if (testSSN4 != testSSN3) {
                    SkReportUnexpectedSSN(testSSN4, testSSN3);
                }
                else if (testSSN5 != testSSN4) {
                    SkReportUnexpectedSSN(testSSN5, testSSN4);
                }
        }
    }

    for (i = 0; i < MapMethodMax; i++) {
        if (ntdllPointers[i]) {
            NtUnmapViewOfSection(NtCurrentProcess(), ntdllPointers[i]);
        }
    }

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/threads.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       THREADS.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Thread list probes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

/*
* SkValidateThreadList
*
* Purpose:
*
* Walk own process thread list and validate thread instruction pointers.
*
*/
BOOL SkValidateThreadList(
    _In_ PROBE_CONTEXT* Context
)
{
    NTSTATUS ntStatus;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    ULONG nextEntryDelta = 0;
    HANDLE selfPID = Context->ClientId.UniqueProcess, threadObject;

    PVOID processList;
    PSYSTEM_THREAD_INFORMATION threadEntry;

    OBJECT_ATTRIBUTES obja;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } NativeList;

    WCHAR szText[MAX_TEXT_LENGTH];

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

    processList = supGetSystemInfo(SystemProcessInformation, NULL);
    if (processList) {

        NativeList.ListRef = (PBYTE)processList;
        do {

            NativeList.ListRef += nextEntryDelta;

            if (NativeList.Process->UniqueProcessId == selfPID) {
                if (NtCurrentPeb()->SessionId != NativeList.Process->SessionId)
                    SkReportSessionIdRIP(NativeList.Process->SessionId);

                if (NativeList.Process->ThreadCount == 0)
                    SkReportThreadCountRIP();

                for (ULONG i = 0; i < NativeList.Process->ThreadCount; i++) {

                    threadEntry = &NativeList.Process->Threads[i];

                    threadObject = NULL;
                    ntStatus = NtOpenThread(&threadObject,
                        THREAD_GET_CONTEXT,
                        &obja,
                        &threadEntry->ClientId);

                    if (NT_SUCCESS(ntStatus)) {

                        DWORD64 threadRip = 0;
                        PLDR_DATA_TABLE_ENTRY tableEntry;

                        ntStatus = supQueryThreadInstructionPointer(threadObject, &threadRip);
                        if (NT_SUCCESS(ntStatus)) {

                            ntStatus = LdrFindEntryForAddress((PVOID)threadRip, &tableEntry);
                            if (!NT_SUCCESS(ntStatus)) {
                                SkReportThreadUnknownRip(threadRip);
                            }

                        }
                        else {

                            StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                                TEXT("Cannot query RIP of own thread 0x%llX"),
                                (ULONG_PTR)threadEntry->ClientId.UniqueThread);

                            SkReportNtCallRIP(ntStatus,
                                szText,
                                (LPWSTR)TEXT("NtGetContextThread"),
                                (LPWSTR)TEXT("CONTEXT_CONTROL"));

                        }

                        NtClose(threadObject);
                    }
                    else {
                        StringCchPrintf(szText, RTL_NUMBER_OF(szText),
                            TEXT("Cannot open own thread 0x%llX"),
                            (ULONG_PTR)threadEntry->ClientId.UniqueThread);

                        SkReportNtCallRIP(ntStatus,
                            szText,
                            (LPWSTR)TEXT("NtOpenThread"),
                            (LPWSTR)TEXT("THREAD_GET_CONTEXT"));
                    }
                }

                break;
            }

            nextEntryDelta = NativeList.Process->NextEntryDelta;

        } while (nextEntryDelta);

        supHeapFree(processList);
    }
    else {
        SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
            (LPWSTR)TEXT("Cannot query process list"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemProcessInformation"));
    }

    return SkiGetAnomalyCount() == oldAnomalyCount;
}

```

`Source/probes/win32k.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       WIN32K.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  NtUser/NtGdi probes (Windows 10 RS4 and above ONLY).
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

BOOL gFirstRun = TRUE;

PSERVERINFO gpsi;
PSHAREDINFO gSharedInfo;
PGDI_SHARED_MEMORY pGdiSharedMemory;

#define SkpWin32RIP()                                               \
    supReportEvent(evtError,                                        \
        (LPWSTR)TEXT("NTUSER/NTGDI internal information failure"),  \
        NULL,                                                       \
        DT_W32INIT_ERROR)                                           \

PWND HMValidateHandleNoSecure(
    _In_opt_ HWND hwnd,
    _In_ HANDLE_TYPE bType)
{
    PCLIENTINFO clientInfo = NULL;
    ULONG uniq, dw;
    PWND pobj = NULL;
    HANDLEENTRY* phe;
    PVOID rpdesk;
    DWORD dwError;

    //
    // Get handle index in a handle table.
    //
    dw = HMIndexFromHandle(hwnd);

    //
    // Make sure it is part of handle table.
    //
    if (dw < gpsi->cHandleEntries) {

        phe = &gSharedInfo->aheList[dw];
        uniq = HMUniqFromHandle(hwnd);

        //
        // Check uniq bits against uniq bits in the handle entry.
        //
        if ((uniq == phe->wUniq || uniq == HMUNIQBITS)
            && (!(phe->bFlags & HANDLEF_DESTROY)) // Make sure that the handle is not destroyed.
            && phe->bType == bType)
        {
            //
            // Validate desktop.
            //
            clientInfo = (PCLIENTINFO)NtCurrentTeb()->Win32ClientInfo;
            rpdesk = clientInfo->pDeskInfo->rpdesk;
            if (rpdesk && phe->rpdesk == rpdesk) {

                //
                // Calculate result object adddress.
                //
                pobj = (PWND)RtlOffsetToPointer(phe->hWnd,
                    clientInfo->DesktopHeap);
            }
            //else {               
            //  pobj = NtUserCallOneParam((ULONG_PTR)hwnd, SFI__MAPDESKTOPOBJECT);                              
            //}
        }
    }

    if (pobj) {
        return pobj;
    }

    switch (bType) {

    case TYPE_WINDOW:
        dwError = ERROR_INVALID_WINDOW_HANDLE;
        break;

    case TYPE_MENU:
        dwError = ERROR_INVALID_MENU_HANDLE;
        break;

    case TYPE_CURSOR:
        dwError = ERROR_INVALID_CURSOR_HANDLE;
        break;

    case TYPE_ACCELTABLE:
        dwError = ERROR_INVALID_ACCEL_HANDLE;
        break;

    case TYPE_HOOK:
        dwError = ERROR_INVALID_HOOK_HANDLE;
        break;

    case TYPE_SETWINDOWPOS:
        dwError = ERROR_INVALID_DWP_HANDLE;
        break;

    default:
        dwError = ERROR_INVALID_HANDLE;
        break;
    }

    RtlSetLastWin32Error(dwError);
    return NULL;
}

VOID NtUserTest()
{
    WCHAR szText[MAX_TEXT_LENGTH];

    PWND testWnd = HMValidateHandleNoSecure(GetDesktopWindow(), TYPE_WINDOW);
    if (testWnd) {
        StringCchPrintf(szText,
            RTL_NUMBER_OF(szText),
            TEXT("BEGIN TEST: PWND 0x%llX HWND 0x%llX DesktopHeapOffset 0x%llX\r\n"),
            (ULONG_PTR)testWnd, (ULONG_PTR)testWnd->hWnd, testWnd->DesktopHeapOffset);
    }
    else {
        StringCchPrintf(szText,
            RTL_NUMBER_OF(szText),
            TEXT("FAILURE: HMValidateHandleNoSecure %lu\r\n"), NtCurrentTeb()->LastErrorValue);
    }
    OutputDebugString(szText);
}

BOOL SkiWin32Initialize()
{
    HMODULE hUser32;
    HMODULE hGdi32;

    if (gFirstRun || 
        gSharedInfo == NULL) 
    {
        hUser32 = GetModuleHandle(TEXT("user32.dll"));
        if (hUser32 == NULL)
            return FALSE;

        hGdi32 = GetModuleHandle(TEXT("gdi32.dll"));
        if (hGdi32 == NULL)
            return FALSE;

        gSharedInfo = (PSHAREDINFO)GetProcAddress(hUser32, "gSharedInfo");
        if (gSharedInfo == NULL)
            return FALSE;

        gpsi = gSharedInfo->psi;

        pGdiSharedMemory = (PGDI_SHARED_MEMORY)NtCurrentPeb()->GdiSharedHandleTable;

        gFirstRun = FALSE;
    }
    return TRUE;
}

/*
* SkUserHandleTableWalk
*
* Purpose:
*
* Walk UserHandleTable and find windows that doesn't belong to any process that is visible through WINAPI query.
*
*/
BOOL SkUserHandleTableWalk(
    _In_ PROBE_CONTEXT* Context
)
{
    ULONG i, oldAnomalyCount = SkiGetAnomalyCount();
    HANDLEENTRY* phe;
    PVOID processList = NULL;
    PSYSTEM_PROCESS_INFORMATION pEntry;

    do {

        //
        // Execute any tests only after this call.
        //
        if (!SkiWin32Initialize()) {
            SkpWin32RIP();
            return FALSE;
        }

        //
        // TESTTESTTESTTESTPLACEHOLDER
        //

        //
        // Prepare process list enumeration.
        //
        processList = supGetSystemInfo(SystemProcessInformation, NULL);
        if (processList == NULL) {

            SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
                (LPWSTR)TEXT("Cannot query process list"),
                (LPWSTR)TEXT("NtQuerySystemInformation"),
                (LPWSTR)TEXT("SystemProcessInformation"));

            break;
        }

        //
        // Walk UserHandleTable.
        //
        for (i = 0; i < gpsi->cHandleEntries; i++) {

            phe = &gSharedInfo->aheList[i];

            if (phe->hWnd &&
                (!(phe->bFlags & HANDLEF_DESTROY))
                && phe->bType == TYPE_WINDOW)
            {
                HANDLE threadId = phe->pti;
                HANDLE hWnd = phe->hWnd;

                //
                // Find corresponding entry in process list.
                //
                if (!supThreadToProcessEntry(processList, threadId, &pEntry)) {

                    //
                    // Entry not found, find process id of thread.
                    //
                    HANDLE processId = NULL;
                    NTSTATUS ntStatus = supThreadToProcessHandle(threadId, &processId);
                    if (!NT_SUCCESS(ntStatus)) {
                        //
                        // Could be a synchronization issue or not enough privileges, however report.
                        // Don't raise wubbaboos count as we are not sure what the fuck is this.
                        //
                        SkReportThreadOpenError(hWnd, threadId, Context->IsClientElevated, ntStatus);
                    }
                    else {
                        SkReportHiddenProcessWindow(processId, threadId, hWnd);
                    }

                }
            }
        }

    } while (FALSE);

    if (processList) supHeapFree(processList);

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

/*
* SkGdiSharedHandleTableWalk
*
* Purpose:
*
* Walk Gdi handle table and find objects that doesn't belong to any process that is visible through WINAPI query.
*
*/
BOOL SkGdiSharedHandleTableWalk(
    _In_ PROBE_CONTEXT* Context)
{
    UNREFERENCED_PARAMETER(Context);

    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    SIZE_T i, cEntries, returnLength;
    PGDI_HANDLE_ENTRY pentry;
    MEMORY_BASIC_INFORMATION mbi;
    PVOID processList = NULL;

    //
    // Execute any tests only after this call.
    //
    if (!SkiWin32Initialize()) {
        SkpWin32RIP();
        return FALSE;
    }

    //
    // Prepare process list enumeration.
    //
    processList = supGetSystemInfo(SystemProcessInformation, NULL);
    if (processList == NULL) {

        SkReportNtCallRIP(STATUS_UNSUCCESSFUL,
            (LPWSTR)TEXT("Cannot query process list"),
            (LPWSTR)TEXT("NtQuerySystemInformation"),
            (LPWSTR)TEXT("SystemProcessInformation"));

        return FALSE;
    }

    if (NT_SUCCESS(NtQueryVirtualMemory(NtCurrentProcess(),
        pGdiSharedMemory,
        MemoryBasicInformation,
        &mbi,
        sizeof(mbi),
        &returnLength)))
    {
        //
        // Apprx. number of entries.
        // Warning shared memory contain more data than just handle table.
        //
        cEntries = mbi.RegionSize / sizeof(GDI_HANDLE_ENTRY);
        cEntries = __min(GDI_MAX_HANDLE_COUNT, cEntries);
    }
    else {
        cEntries = GDI_MAX_HANDLE_COUNT;
    }
    
    for (i = 0; i < cEntries; i++) {

        pentry = &pGdiSharedMemory->aentryHmgr[i];
        
        ULONG ownerPID = OBJECTOWNER_PID(pentry->ObjectOwner);
        OBJTYPE objType = pentry->Objt;

        //
        // Filter OBJECT_OWNER_*
        //
        if (ownerPID != OBJECT_OWNER_PUBLIC &&
            ownerPID != OBJECT_OWNER_CURRENT &&
            ownerPID != OBJECT_OWNER_NONE &&
            ownerPID != OBJECT_OWNER_ERROR)
        {
            //
            // Check if owner pid is visible to client enumeration.
            //
            if (NULL == supProcessEntryByProcessId(UlongToHandle(ownerPID), processList)) {
                SkReportGdiObject(UlongToHandle(ownerPID), objType);
            }
        }

    }

    supHeapFree(processList);

    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

/*
* SkValidateWin32uSyscalls
*
* Purpose:
*
* Verity win32u syscall integrity.
*
*/
BOOL SkValidateWin32uSyscalls(
    _In_ PROBE_CONTEXT* Context)
{
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    PVOID win32uBase = GetModuleHandle(TEXT("win32u.dll"));
    if (win32uBase) {
        for (ULONG i = 0; i < RTL_NUMBER_OF(g_NtUserTestSet); i++)
            SkiQueryAndValidateSSN(Context, 
                g_NtUserTestSet[i], 
                win32uBase, 
                FALSE, 
                TRUE);
    }
    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/probes/winver.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       WINVER.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* SkpValidateVersionDataWMI
*
* Purpose:
*
* Query windows version numbers by WMI call for CIMWin32.
*
*/
HRESULT SkpValidateVersionDataWMI(
    _In_ ULONG TestMajorVersion,
    _In_ ULONG TestMinorVersion,
    _In_ ULONG TestBuildNumber,
    _Out_ PBOOL ValidateResult
)
{
    BOOL bSeemsLegit = FALSE;
    HRESULT hr = S_OK, hrFunc = S_OK;
    IWbemLocator* WbemLocator = NULL;
    IWbemServices* WbemServices = NULL;
    IEnumWbemClassObject* enumWbem = NULL;
    IWbemClassObject* result = NULL;
    BSTR bstrServer = NULL;
    BSTR bstrQuery = NULL, bstrQueryLanguage = NULL;

    ULONG returnedCount = 0;

    do {
        bstrServer = SysAllocString(L"ROOT\\CIMV2"); //CIMWin32
        bstrQuery = SysAllocString(L"SELECT * FROM Win32_OperatingSystem");
        bstrQueryLanguage = SysAllocString(L"WQL");

        if ((bstrServer == NULL) ||
            (bstrQuery == NULL) ||
            (bstrQueryLanguage == NULL))
        {
            hrFunc = E_FAIL;
            SkReportComCallRIP(E_FAIL,
                (LPWSTR)TEXT("Cannot allocate memory for string"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = CoCreateInstance(CLSID_WbemLocator,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IWbemLocator,
            (LPVOID*)&WbemLocator);

        if (FAILED(hr)) {
            hrFunc = hr;
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Cannot create locator instance"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = WbemLocator->ConnectServer(bstrServer, NULL, NULL, NULL, 0, NULL, NULL, &WbemServices);
        if (FAILED(hr)) {
            hrFunc = hr;
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Cannot connect CIMV2 server"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        hr = WbemServices->ExecQuery(bstrQueryLanguage,
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &enumWbem);
        if (FAILED(hr)) {
            hrFunc = hr;
            SkReportComCallRIP(hr,
                (LPWSTR)TEXT("Failed to execute query"),
                (LPWSTR)__FUNCTIONW__,
                NULL);
            break;
        }

        VARIANT vtBuildNumber;
        VARIANT vtVersion;

        VariantInit(&vtBuildNumber);
        VariantInit(&vtVersion);

        while ((hr = enumWbem->Next(WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) {

            HRESULT hr2, hr3;
                
            hr2 = result->Get(L"BuildNumber", 0, &vtBuildNumber, 0, 0);

            if (SUCCEEDED(hr2)) {
                hr2 = VariantChangeType(&vtBuildNumber, &vtBuildNumber, 0, VT_UI4);
                if (SUCCEEDED(hr2))
                    bSeemsLegit = (vtBuildNumber.uintVal == TestBuildNumber);
            }

            //
            // Build seems same, compare full version string.
            //
            if (bSeemsLegit) {

                hr3 = result->Get(L"Version", 0, &vtVersion, 0, 0);
                if (SUCCEEDED(hr3) && vtVersion.vt == VT_BSTR) {

                    WCHAR szVersion[20];
                    StringCchPrintf(szVersion, _countof(szVersion),
                        TEXT("%lu.%lu.%lu"),
                        TestMajorVersion,
                        TestMinorVersion,
                        TestBuildNumber);

                    bSeemsLegit = (_strcmpi(szVersion, vtVersion.bstrVal) == 0);

                }
                else {
                    bSeemsLegit = FALSE; //unexpected failure
                    hrFunc = E_FAIL;
                    SkReportComCallRIP(hr3,
                        (LPWSTR)TEXT("Failed to get data"),
                        (LPWSTR)__FUNCTIONW__,
                        NULL);
                }

            }

            VariantClear(&vtBuildNumber);
            VariantClear(&vtVersion);
            result->Release();
        }

    } while (FALSE);

    if (enumWbem) enumWbem->Release();
    if (WbemServices) WbemServices->Release();
    if (WbemLocator) WbemLocator->Release();

    if (bstrServer) SysFreeString(bstrServer);
    if (bstrQueryLanguage) SysFreeString(bstrQueryLanguage);
    if (bstrQuery) SysFreeString(bstrQuery);

    *ValidateResult = bSeemsLegit;

    return hrFunc;
}

/*
* SkpValidateSyscallLayoutForVersionData
*
* Purpose:
*
* Find discrepancy between Windows version build and syscall layout.
*
*/
PVOID SkpValidateSyscallLayoutForVersionData(
    _In_ HMODULE NtDllBase,
    _In_ ULONG TestBuildNumber
)
{
    LPCSTR lpName = NULL;

    //
    // MSFT verified.
    //
    do {

        if (TestBuildNumber >= NT_WIN7_RTM && TestBuildNumber <= NT_WIN7_SP1) {
            lpName = (LPCSTR)"NtGetPlugPlayEvent";
            break;
        }

        if (TestBuildNumber == NT_WIN8_RTM) {
            lpName = (LPCSTR)"NtCreateIRTimer";
            break;
        }

        if (TestBuildNumber == NT_WIN8_BLUE) {
            lpName = (LPCSTR)"NtCancelTimer2";
            break;
        }

        switch (TestBuildNumber) {

        case NT_WIN10_THRESHOLD1:
            lpName = (LPCSTR)"NtSetInformationSymbolicLink";
            break;

        case NT_WIN10_THRESHOLD2:
            lpName = (LPCSTR)"NtCreateEnclave";
            break;

        case NT_WIN10_REDSTONE1:
            lpName = (LPCSTR)"NtOpenRegistryTransaction";
            break;

        case NT_WIN10_REDSTONE2:
            lpName = (LPCSTR)"NtCompareSigningLevels";
            break;

        case NT_WIN10_REDSTONE3:
            lpName = (LPCSTR)"NtNotifyChangeDirectoryFileEx";
            break;

        case NT_WIN10_REDSTONE4:
            lpName = (LPCSTR)"NtAllocateVirtualMemoryEx";
            break;

        case NT_WIN10_REDSTONE5:
            lpName = (LPCSTR)"NtCreateSectionEx";
            break;

        case NT_WIN10_19H1:
        case NT_WIN10_19H2: //feature pack
            lpName = (LPCSTR)"NtCreateCrossVmEvent";
            break;
        default:
            break;
        }

        if (lpName)
            break;

        if (TestBuildNumber >= NT_WIN10_20H1 && TestBuildNumber <= NT_WIN10_22H2) {
            lpName = (LPCSTR)"NtPssCaptureVaSpaceBulk";
            break;
        }

        if (TestBuildNumber == NT_WINSRV_21H1) {
            lpName = (LPCSTR)"NtReadVirtualMemoryEx";
            break;
        }

        if (TestBuildNumber == NT_WIN11_21H2) {
            lpName = (LPCSTR)"NtCreateIoRing";
            break;
        }

        if (TestBuildNumber == NT_WIN11_22H2) {
            lpName = (LPCSTR)"NtCreateCpuPartition";
            break;
        }

        //
        // This one could be missing in early win11 previews and dev builds as it was introduced later.
        // It doesn't matter, if you want to play this hard, okay.
        //
        if (TestBuildNumber > NT_WIN11_22H2) {
            lpName = (LPCSTR)"NtAlertThreadByThreadIdEx";
            break;
        }

        lpName = NULL;

    } while (FALSE);

    if (lpName == NULL)
        return NULL;

    return (PVOID)GetProcAddress(NtDllBase, lpName);
}

/*
* SkVerifyWinVersion
*
* Purpose:
*
* Query windows version numbers and verify them to be somewhat valid.
*
*/
BOOL SkVerifyWinVersion(
    _In_ PROBE_CONTEXT* Context
)
{
    struct {
        LPCWSTR DllName;
        ULONG VersionBuildNumber;
    } DllData[] = {
        { L"ntdll.dll", 0 },        //
        { L"kernel32.dll", 0 },     // Only KnownDlls 
        { L"kernelbase.dll", 0 },   //
        { L"user32.dll", 0 },
        { L"gdi32.dll", 0 },
        { L"combase.dll", 0 }
    };

    BOOL bRecognized = TRUE;
    ULONG oldAnomalyCount = SkiGetAnomalyCount();
    ULONG testBuildNumber = NtCurrentPeb()->OSBuildNumber;

    ULONG majorVersion = 0, minorVersion = 0, buildNumber = 0;
    ULONG buildNumberMin = 0, buildNumberMax = 0;

    //
    // Cross-check of system component versions.
    //

    for (int i = 0; i < RTL_NUMBER_OF(DllData); i++) {
        HMODULE hModule = GetModuleHandle(DllData[i].DllName);
        if (hModule) DllData[i].VersionBuildNumber = supParseOSBuildBumber((PVOID)hModule);
    }

    for (int i = 0; i < RTL_NUMBER_OF(DllData); i++) {

        if (DllData[0].VersionBuildNumber != DllData[i].VersionBuildNumber) {

            SkReportVersionResourceBuildNumber(DllData[i].DllName,
                DllData[0].VersionBuildNumber,
                DllData[i].VersionBuildNumber);

        }

    }

    //
    // Validate version numbers and build range.
    //

    RtlGetNtVersionNumbers(&majorVersion, &minorVersion, &buildNumber);

    if (majorVersion < 6 || majorVersion > 10) {

        SkReportWrongWinVersion((LPWSTR)TEXT("Suspicious Windows major version"),
            majorVersion,
            minorVersion,
            buildNumber,
            DT_WINVERSION);

    }

    if (minorVersion > 3) {

        //
        // No such exists.
        //

        SkReportWrongWinVersion((LPWSTR)TEXT("Suspicious Windows minor version"),
            majorVersion,
            minorVersion,
            buildNumber,
            DT_WINVERSION);

    }

    //
    // Find valid build range for version.
    // 
    //
    // Windows 7
    //
    if (majorVersion == 6 && minorVersion == 1) {
        buildNumberMin = NT_WIN7_RTM;
        buildNumberMax = NT_WIN7_SP1;
    }
    else {
        //
        // Windows 8/8.1
        //
        if (majorVersion == 6 && minorVersion <= 3) {
            if (minorVersion == 2) {
                //
                // Windows 8.
                //
                buildNumberMin = NT_WIN8_RTM;
                buildNumberMax = NT_WIN8_RTM;
            }
            else
            {
                //
                // Windows 8.1
                //
                if (minorVersion == 3) {
                    buildNumberMin = NT_WIN8_BLUE;
                    buildNumberMax = NT_WIN8_BLUE;
                }
            }

        }
        else {
            //
            // Windows 10+
            //
            if (majorVersion == 10) {
                if (testBuildNumber < NT_WIN10_THRESHOLD1) {
                    bRecognized = FALSE;
                }
                else {
                    if (testBuildNumber > NT_WIN10_22H2) {
                        if (USER_SHARED_DATA->NtProductType == NtProductServer) {
                            buildNumberMin = NT_WINSRV_21H1;
                            buildNumberMax = NT_WINSRV_21H1;
                        }
                        else {
                            buildNumberMin = NT_WIN11_21H2;
                            buildNumberMax = NTX_WIN11_ADB;
                        }
                    }
                    else {
                        buildNumberMin = NT_WIN10_THRESHOLD1;
                        buildNumberMax = NT_WIN10_22H2;
                    }
                }
            }
            else {
                bRecognized = FALSE;
            }
        }
    }

    if (bRecognized == FALSE) {

        SkReportWrongWinVersion((LPWSTR)TEXT("Suspicious Windows version"),
            majorVersion,
            minorVersion,
            buildNumber,
            DT_WINVERSION);
    }


    if (buildNumberMin && buildNumberMax) {
        if (!(testBuildNumber >= buildNumberMin && testBuildNumber <= buildNumberMax)) {

            SkReportWrongWinVersion((LPWSTR)TEXT("Suspicious Windows build number"),
                majorVersion,
                minorVersion,
                testBuildNumber,
                DT_BUILDNUMBER);
        }
    }

    if (Context->ReferenceNtBuildNumber) {
        if (!Context->Win10FeaturePack && !IS_WIN10_FEATURE_PACK_RANGE(testBuildNumber)) {
            if (Context->ReferenceNtBuildNumber != testBuildNumber)
                SkReportWrongWinVersion((LPWSTR)TEXT("Suspicious Windows build number"),
                    majorVersion,
                    minorVersion,
                    testBuildNumber,
                    DT_BUILDNUMBER);
        }
    }

    //
    // Syscall layout.
    //

    PVOID ntdllBase;
    ULONG dllChars = IMAGE_FILE_EXECUTABLE_IMAGE;
    UNICODE_STRING dllName;

    RtlInitUnicodeString(&dllName, RtlNtdllName);
    NTSTATUS ntStatus = LdrGetDllHandle(NULL, &dllChars, &dllName, &ntdllBase);
    if (NT_SUCCESS(ntStatus)) {
        if (!SkpValidateSyscallLayoutForVersionData((HMODULE)ntdllBase, testBuildNumber)) {
            SkReportWrongWinVersion((LPWSTR)TEXT("Tampered Windows build number (Syscall Layout)"),
                majorVersion,
                minorVersion,
                testBuildNumber,
                DT_BUILDNUMBER);
        }
    }
    else {
        SkReportNtCallRIP(ntStatus,
            (LPWSTR)TEXT("Failed to query ntdll base"),
            (LPWSTR)__FUNCTIONW__,
            NULL);
    }

    BOOL bValid = FALSE;
    if (SUCCEEDED(SkpValidateVersionDataWMI(majorVersion, minorVersion, testBuildNumber, &bValid))) {

        if (bValid == FALSE) {
            SkReportWrongWinVersion((LPWSTR)TEXT("Windows version data tampering detected (WMI Query)"),
                majorVersion,
                minorVersion,
                testBuildNumber,
                DT_WINVERSION);
        }
    } //func will throw errors automatically.
    
    return (SkiGetAnomalyCount() == oldAnomalyCount);
}

```

`Source/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDD_MAINDIALOG                  102
#define IDR_MENU                        105
#define IDD_ABOUT                       106
#define IDD_SETTINGS                    124
#define IDI_ICON_MAIN                   200
#define IDI_ICON_DETECTION              201
#define IDI_ICON_WUBBABOO               202
#define IDI_ICON_CHECK_FAILED           203
#define IDI_ICON_CHECK_PASSED           204
#define IDI_ICON_CHECK_WARNING          205
#define IDC_LIST                        1002
#define IDC_PROGRESS                    1003
#define IDC_SCAN                        1004
#define IDC_STATUSBAR                   1005
#define IDC_SYSLINK                     1006
#define IDC_PROBES1                     1007
#define IDC_PROBES2                     1008
#define IDC_PROBES3                     1009
#define IDC_PROBES4                     1010
#define IDC_PROBES5                     1011
#define IDC_PROBES6                     1012
#define IDC_PROBES7                     1013
#define IDC_PROBES8                     1014
#define IDC_PROBES9                     1015
#define IDC_PROBES10                    1016
#define IDC_PROBES11                    1017
#define IDC_PROBES12                    1018
#define IDC_PROBES13                    1019
#define IDC_PROBES14                    1020
#define IDC_PROBES15                    1021
#define IDC_PROBES16                    1022
#define IDC_PROBES17                    1023
#define IDC_PROBES18                    1024
#define IDC_PROBES19                    1025
#define IDC_PROBES20                    1026
#define ID_FILE_SCAN                    40001
#define ID_FILE_EXIT                    40002
#define ID_HELP_ABOUT                   40003
#define ID_PROBES_SAVETOFILE            40004
#define ID_FILE_RUNASADMIN              40005
#define ID_PROBES_SETTINGS              40006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MAINDIALOG DIALOGEX 0, 0, 501, 226
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
MENU IDR_MENU
CLASS "WubbabooMarkClass"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,4,1,493,203,WS_EX_CLIENTEDGE
    CONTROL         "",IDC_STATUSBAR,"msctls_statusbar32",WS_CLIPSIBLINGS | 0x10,3,209,494,15
END

IDD_ABOUT DIALOGEX 30, 30, 219, 76
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_NOFAILCREATE | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "About WubbabooMark"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    LTEXT           "WubbabooMark v1.0 (Skilla)",IDC_STATIC,40,6,90,8
    ICON            IDI_ICON_WUBBABOO,IDC_STATIC,6,4,20,20,0,WS_EX_TRANSPARENT
    PUSHBUTTON      "OK",1,160,7,47,12
    LTEXT           "Copyright © 2023 hfire&f0x",IDC_STATIC,40,18,114,8
    LTEXT           "Anti-anti detection software benchmark. ",IDC_STATIC,7,43,211,9
    CONTROL         "<a href=""https://github.com/hfiref0x"">hfiref0x on GitHub.com</a>",IDC_SYSLINK,
                    "SysLink",WS_TABSTOP,40,29,80,14
    LTEXT           "This is free software. You use it at your own risk, no software warranties are given.",IDC_STATIC,7,56,212,16
END

IDD_SETTINGS DIALOGEX 0, 0, 405, 274
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Probe Settings"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Save",IDOK,293,253,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,348,253,50,14
    CONTROL         "Common (Windows Policy, NtSystemDebugControl, DebugPrivileges, etc)",IDC_PROBES1,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,8,249,10
    CONTROL         "Verify Process Environment Block Loader List (analyze PEB loader list for signed modules and lazy tampering)",IDC_PROBES2,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,20,361,10
    CONTROL         "Verify System Module Information List (Analyze loaded modules list and verify signatures)",IDC_PROBES3,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,32,301,10
    CONTROL         "Check For Blacklisted Kernel Device Names (Lookup devices by blacklist in the Objects Manager namespace)",IDC_PROBES4,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,44,359,10
    CONTROL         "Verify Windows Version Information (Check for l33t version numbers and cross-compare results for known versions)",IDC_PROBES5,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,56,385,10
    CONTROL         "Validate Running Processes List (Check for hidden from Windows API instances)",IDC_PROBES6,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,68,270,10
    CONTROL         "Validate Program Own Thread List (Lookup every thread RIP and validate it to be in visible module)",IDC_PROBES7,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,80,331,10
    CONTROL         "Validate NTDLL Mappings (Map NTDLL by various methods and compare results)",IDC_PROBES8,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,92,269,10
    CONTROL         "Examine Program Stack (Walk entire program stack and lookup suspicious addresses)",IDC_PROBES9,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,104,287,10
    CONTROL         "Validate Program Working Set (Page) (Query process WS and walk it checking each page flags)",IDC_PROBES10,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,116,319,10
    CONTROL         "Validate Program Working Set (Watch) (Set WS  watch, empty WS and look for page fault data)",IDC_PROBES11,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,128,321,10
    CONTROL         "Perform Handle Tracing (Enable process handle tracing and perform bait call, examining API misbehavior)",IDC_PROBES12,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,140,351,10
    CONTROL         "Validate NTDLL System Calls (Acquire syscall number by various methods and cross-compare call results)",IDC_PROBES13,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,152,348,10
    CONTROL         "Validate WIN32U System Calls (Acquire syscall number by various methods and compare results)",IDC_PROBES14,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,164,323,10
    CONTROL         "Detect Debugger(s) Presence (Process debug: port, handle, flags, DRX registers state. Query USD values)",IDC_PROBES15,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,176,358,10
    CONTROL         "Check System Handles (Debug objects, object types and cross-compare results, detect lazy data tampering)",IDC_PROBES16,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,188,363,10
    CONTROL         "Enumerate NtUser Objects (Parse UserHandleHandle and find objects with owners hidden from Windows API)",IDC_PROBES17,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,200,365,10
    CONTROL         "Enumerate NtGDI Objects (Parse GdiSharedHandleTable and find objects with owners hidden from Windows API)",IDC_PROBES18,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,212,376,10
    CONTROL         "Enumerate Boot Configuration Data* (Query if default BCD library and loader store have dangerous enablements)",IDC_PROBES19,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,224,381,10
    LTEXT           "*Client elevation required",IDC_STATIC,7,259,83,8
    CONTROL         "Validate Process Memory Regions (Scan for regions with suspicious flags)",IDC_PROBES20,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,236,249,10
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_MAINDIALOG, DIALOG
    BEGIN
        RIGHTMARGIN, 400
    END

    IDD_ABOUT, DIALOG
    BEGIN
        LEFTMARGIN, 7
        TOPMARGIN, 7
        BOTTOMMARGIN, 71
    END

    IDD_SETTINGS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 398
        TOPMARGIN, 7
        BOTTOMMARGIN, 267
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "&Scan",                       ID_FILE_SCAN
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                       ID_FILE_EXIT
    END
    POPUP "&Probes"
    BEGIN
        MENUITEM "S&ave As...",                 ID_PROBES_SAVETOFILE
        MENUITEM SEPARATOR
        MENUITEM "Se&ttings",                   ID_PROBES_SETTINGS
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&About",                      ID_HELP_ABOUT
    END
END

#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON_MAIN           ICON                    "rsrc\\Main.ico"

IDI_ICON_DETECTION      ICON                    "rsrc\\CheckDetection.ico"

IDI_ICON_WUBBABOO       ICON                    "rsrc\\CheckWubbaboo.ico"

IDI_ICON_CHECK_FAILED   ICON                    "rsrc\\CheckFailed.ico"

IDI_ICON_CHECK_PASSED   ICON                    "rsrc\\CheckPassed.ico"

IDI_ICON_CHECK_WARNING  ICON                    "rsrc\\CheckWarning.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,2307
 PRODUCTVERSION 1,0,0,2307
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Sednit Compilation LLC, Slavik Int."
            VALUE "FileDescription", "WubbabooMark"
            VALUE "FileVersion", "1.0.0.2307"
            VALUE "InternalName", "Skilla"
            VALUE "LegalCopyright", "Copyright (C) 2023 APT29 branch prod. lab"
            VALUE "OriginalFilename", "WubbabooMark.exe"
            VALUE "ProductName", "WubbabooMark"
            VALUE "ProductVersion", "1.0.0.2307"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/skilla.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
    <assemblyIdentity 
        type="win32" 
        name="Skilla"
        version="1.0.0.0"
        processorArchitecture="*"
    />
    <description> Skilla </description>
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel
                    level="asInvoker"
                    uiAccess="false"
                />	
            </requestedPrivileges>
        </security>
    </trustInfo>
  <!--
      Defence-in-depth blyat.
  -->
    <file
      loadFrom="%systemroot%\system32\uxtheme.dll"
      name="uxtheme.dll"
      />
    <file
      loadFrom="%systemroot%\system32\profapi.dll"
      name="profapi.dll"
      />
    <file
      loadFrom="%systemroot%\system32\wldp.dll"
      name="wldp.dll"
      />
    <file
      loadFrom="%systemroot%\system32\CRYPTSP.dll"
      name="CRYPTSP.dll"
      />
    <file
      loadFrom="%systemroot%\system32\CRYPTBASE.dll"
      name="CRYPTBASE.dll"
      />
    <file
      loadFrom="%systemroot%\system32\cryptnet.dll"
      name="cryptnet.dll"
      />
    <file
      loadFrom="%systemroot%\system32\MSASN1.dll"
      name="MSASN1.dll"
      />
    <file
      loadFrom="%systemroot%\system32\msvcp110_win.dll"
      name="msvcp110_win.dll"
      />
    <file
      loadFrom="%systemroot%\system32\wbemcomn.dll"
      name="wbemcomn.dll"
      />
    <file
      loadFrom="%systemroot%\system32\WindowsCodecs.dll"
      name="WindowsCodecs.dll"
      />
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
        <application> 
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
        </application> 
    </compatibility>

  <dependency>
    <dependentAssembly>
      <assemblyIdentity                 
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        publicKeyToken="6595b64144ccf1df"
        language="*"
        processorArchitecture="*"
        />
    </dependentAssembly>
  </dependency>

</assembly>
```

`Source/sup.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       SUP.CPP
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

typedef union _GLOBAL_SID {
    SID sid;
    BYTE padding[SECURITY_MAX_SID_SIZE];
} GLOBAL_SID, * PGLOBAL_SID;

GLOBAL_SID gTrustedInstallerSid;
GLOBAL_SID gLocalSystemSid;
GLOBAL_SID gAdminsGroupSid;

typedef struct _SUP_KNOWNDLLS_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG NameHash;
    ULONG TypeHash;
} SUP_KNOWNDLLS_ENTRY, * PSUP_KNOWNDLLS_ENTRY;

#define DIRECTORY_SYSTEM32 L"\\systemroot\\system32"
#define DIRECTORY_KNOWNDLLS L"\\KnownDlls"
#define LDRP_MAX_MODULE_LOOP 10240

LIST_ENTRY gKnownDllsHead;

static const LPCSTR gPublisherAttributeObjId[] = {
    szOID_ORGANIZATION_NAME,
    szOID_LOCALITY_NAME,
    szOID_STATE_OR_PROVINCE_NAME,
    szOID_COUNTRY_NAME,
};

#define PUBLISHER_ATTR_CNT  RTL_NUMBER_OF(gPublisherAttributeObjId)

static const LPCWSTR gPublisherNameList[][PUBLISHER_ATTR_CNT] = {
    {
        L"Microsoft Corporation",
        L"Redmond",
        L"Washington",
        L"US"
    }
};
#define PUBLISHER_NAME_LIST_CNT  RTL_NUMBER_OF(gPublisherNameList)

#define IMAGELIST_COUNT 8

/*
* supWriteConfiguration
*
* Purpose:
*
* Write probe flags from registry if present.
*
*/
BOOL supWriteConfiguration(
    _In_ struct _PROBE_SETTINGS* Settings
)
{
    DWORD dwLastError = ERROR_SUCCESS;
    LSTATUS lResult;
    HKEY hKey = NULL;
    WCHAR szKey[MAX_PATH];

    StringCchPrintf(szKey, RTL_NUMBER_OF(szKey),
        TEXT("Software\\%ws"),
        PROGRAM_NAME);

    lResult = RegCreateKeyEx(HKEY_CURRENT_USER,
        szKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        NULL);

    if (ERROR_SUCCESS == lResult) {
        lResult = RegSetValueEx(hKey, TEXT("Settings"),
            0,
            REG_DWORD,
            (PBYTE)Settings,
            sizeof(PROBE_SETTINGS));

        if (lResult != ERROR_SUCCESS)
            dwLastError = GetLastError();
        
        RegCloseKey(hKey);
    }

    SetLastError(dwLastError);

    return lResult == ERROR_SUCCESS;
}

LSTATUS supxSetDefaultConfiguration(
    _In_ HKEY hKey,
    _In_ PROBE_SETTINGS* DefaultSettings
)
{
    LSTATUS lResult;

    lResult = RegSetValueEx(hKey, TEXT("Settings"),
        0,
        REG_DWORD,
        (PBYTE)DefaultSettings,
        sizeof(PROBE_SETTINGS));

    return lResult;
}

/*
* supReadConfiguration
*
* Purpose:
*
* Query probe flags from registry if present.
*
*/
BOOL supReadConfiguration(
    _Out_ struct _PROBE_SETTINGS* Settings
)
{
    DWORD dwLastError = ERROR_SUCCESS;
    LSTATUS lResult;
    HKEY hKey = NULL;
    WCHAR szKey[MAX_PATH];
    DWORD dwType = 0, dwSize, dwkeyDisposition = 0;
    PROBE_SETTINGS value;

    value.Flags = 0;
    Settings->Flags = 0xFFFFFFFF;

    StringCchPrintf(szKey, RTL_NUMBER_OF(szKey),
        TEXT("Software\\%ws"),
        PROGRAM_NAME);

    lResult = RegCreateKeyEx(HKEY_CURRENT_USER,
        szKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwkeyDisposition);

    if (ERROR_SUCCESS == lResult) {

        //
        // If there is something to read - do it, otherwise leave default values
        //
        if (REG_OPENED_EXISTING_KEY == dwkeyDisposition) {

            dwSize = sizeof(PROBE_SETTINGS);
            lResult = RegQueryValueEx(hKey,
                TEXT("Settings"),
                NULL,
                &dwType,
                (LPBYTE)&value,
                &dwSize);

            if (lResult == ERROR_SUCCESS) {
                if (dwType != REG_DWORD)
                    lResult = ERROR_BAD_CONFIGURATION;
                else
                    *Settings = value;

            }
            else {
                //
                // Value doesn't exist, set default.
                //
                lResult = supxSetDefaultConfiguration(hKey, Settings);
                if (lResult != ERROR_SUCCESS)
                    dwLastError = GetLastError();
            }
        }
        else {
            //
            // Key is created, first launch, set defaults.
            //
            lResult = supxSetDefaultConfiguration(hKey, Settings);
            if (lResult != ERROR_SUCCESS)
                dwLastError = GetLastError();

        }
        RegCloseKey(hKey);
    }

    SetLastError(dwLastError);
    return lResult == ERROR_SUCCESS;
}

/*
* supFindUnicodeStringSubString
*
* Purpose:
*
* Return offset to substring if found and ULLONG_MAX instead.
*
* Case Insensitive.
*
*/
SIZE_T supFindUnicodeStringSubString(
    _In_ PUNICODE_STRING String,
    _In_ PUNICODE_STRING SubString
)
{
    SIZE_T length1;
    SIZE_T length2;
    UNICODE_STRING string1;
    UNICODE_STRING string2;
    WCHAR c;
    SIZE_T i;

    if (SubString == NULL)
        return 0;

    length1 = String->Length / sizeof(WCHAR);
    length2 = SubString->Length / sizeof(WCHAR);

    if (length2 > length1)
        return ULLONG_MAX;

    if (length2 == 0)
        return 0;

    string1.Buffer = String->Buffer;
    string1.Length = SubString->Length - sizeof(WCHAR);
    string2.Buffer = SubString->Buffer;
    string2.Length = SubString->Length - sizeof(WCHAR);

    c = RtlUpcaseUnicodeChar(*string2.Buffer++);

    for (i = length1 - length2 + 1; i != 0; i--) {
        if (RtlUpcaseUnicodeChar(*string1.Buffer++) == c &&
            RtlEqualUnicodeString(&string1, &string2, TRUE))
        {
            return (ULONG_PTR)(string1.Buffer - String->Buffer - 1);
        }
    }

    return ULLONG_MAX;
}

/*
* supGetSystemInfo
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Caller must free buffer when it no longer needed.
*
*/
PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    PVOID buffer = NULL;
    ULONG bufferSize = PAGE_SIZE;
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;

    if (ReturnLength)
        *ReturnLength = 0;

    buffer = supHeapAlloc((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    while ((ntStatus = NtQuerySystemInformation(
        SystemInformationClass,
        buffer,
        bufferSize,
        &returnedLength)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        supHeapFree(buffer);
        bufferSize <<= 1;

        if (bufferSize > NTQSI_MAX_BUFFER_LENGTH)
            return NULL;

        buffer = supHeapAlloc((SIZE_T)bufferSize);
    }

    if (ReturnLength)
        *ReturnLength = returnedLength;

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    if (buffer)
        supHeapFree(buffer);

    return NULL;
}

/*
* supGetProcessInfoVariableSize
*
* Purpose:
*
* Returns buffer with system information by given ProcessInformationClass.
*
* Caller must free buffer when it no longer needed.
*
*/
PVOID supGetProcessInfoVariableSize(
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    PVOID buffer = NULL;
    ULONG bufferSize = PAGE_SIZE;
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;

    if (ReturnLength)
        *ReturnLength = 0;

    buffer = supHeapAlloc((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    ntStatus = NtQueryInformationProcess(
        NtCurrentProcess(),
        ProcessInformationClass,
        buffer,
        bufferSize,
        &returnedLength);

    if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {
        supHeapFree(buffer);
        bufferSize = returnedLength;
        buffer = supHeapAlloc((SIZE_T)bufferSize);

        ntStatus = NtQueryInformationProcess(
            NtCurrentProcess(),
            ProcessInformationClass,
            buffer,
            bufferSize,
            &returnedLength);
    }

    if (ReturnLength)
        *ReturnLength = returnedLength;

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    if (buffer)
        supHeapFree(buffer);

    return NULL;
}

/*
* supRunAsAdmin
*
* Purpose:
*
* Restarts application requesting full admin rights.
*
*/
VOID supRunAsAdmin(
    VOID
)
{
    SHELLEXECUTEINFO shinfo;
    WCHAR szPath[MAX_PATH + 1];

    RtlSecureZeroMemory(&szPath, sizeof(szPath));
    if (GetModuleFileName(NULL, szPath, MAX_PATH)) {
        RtlSecureZeroMemory(&shinfo, sizeof(shinfo));
        shinfo.cbSize = sizeof(shinfo);
        shinfo.lpVerb = TEXT("runas");
        shinfo.lpFile = szPath;
        shinfo.nShow = SW_SHOW;
        if (ShellExecuteEx(&shinfo)) {
            PostQuitMessage(0);
        }
    }
}

/*
* supLoadImageList
*
* Purpose:
*
* Create and load image list from icon resource type.
*
*/
HIMAGELIST supLoadImageList(
    _In_ HINSTANCE hInstance
)
{
    UINT       i;
    HIMAGELIST ImageList;
    HICON hIcon;

    ImageList = ImageList_Create(
        16,
        16,
        ILC_COLOR32 | ILC_MASK,
        IMAGELIST_COUNT,
        8);

    if (ImageList) {

        for (i = ICON_FIRST; i <= ICON_LAST; i++) {

            hIcon = (HICON)LoadImage(hInstance,
                MAKEINTRESOURCE(i),
                IMAGE_ICON,
                16,
                16,
                LR_DEFAULTCOLOR);

            if (hIcon) {
                ImageList_ReplaceIcon(ImageList, -1, hIcon);
                DestroyIcon(hIcon);
            }
        }

    }

    return ImageList;
}

/*
* supStatusBarSetText
*
* Purpose:
*
* Display status in status bar part.
*
*/
VOID supStatusBarSetText(
    _In_ HWND StatusBar,
    _In_ WPARAM Index,
    _In_ LPCWSTR Text
)
{
    SendMessage(StatusBar, SB_SETTEXT, Index, (LPARAM)Text);
}

/*
* supSetListViewSettings
*
* Purpose:
*
* Set listview imagelist, style flags and theme.
*
*/
VOID supSetListViewSettings(
    _In_ HWND hwndLV,
    _In_ DWORD dwExtendedStyle,
    _In_ BOOL fSetTheme,
    _In_opt_ HIMAGELIST hImageList,
    _In_ INT iImageList
)
{
    DWORD dwFlags = dwExtendedStyle;

    ListView_SetExtendedListViewStyle(hwndLV, dwFlags);

    if (hImageList) {
        ListView_SetImageList(hwndLV, hImageList, iImageList);
    }

    if (fSetTheme) {
        SetWindowTheme(hwndLV, TEXT("Explorer"), NULL);
    }
}

/*
* supAddListViewColumn
*
* Purpose:
*
* Wrapper for ListView_InsertColumn.
*
*/
INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width
)
{
    LVCOLUMN column;

    column.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_ORDER;
    column.fmt = Format;
    column.cx = Width;
    column.pszText = Text;
    column.iSubItem = SubItemIndex;
    column.iOrder = OrderIndex;

    return ListView_InsertColumn(ListViewHwnd, ColumnIndex, &column);
}

/*
* supAddLVColumnsFromArray
*
* Purpose:
*
* Add columns from array to the listview.
*
*/
ULONG supAddLVColumnsFromArray(
    _In_ HWND ListView,
    _In_ PLVCOLUMNS_DATA ColumnsData,
    _In_ ULONG NumberOfColumns
)
{
    ULONG iColumn;

    for (iColumn = 0; iColumn < NumberOfColumns; iColumn++) {

        if (-1 == supAddListViewColumn(ListView,
            iColumn,
            iColumn,
            iColumn,
            ColumnsData[iColumn].Format,
            ColumnsData[iColumn].Name,
            ColumnsData[iColumn].Width))
        {
            break;
        }
    }

    return iColumn;
}

/*
* supReportEventEx
*
* Purpose:
*
* Add item to the main window listview, filter duplicate if requested.
*
*/
VOID supReportEventEx(
    _In_ DR_EVENT_TYPE EventType,
    _In_ LPWSTR lpEvent,
    _In_opt_ LPWSTR lpDescription,
    _In_opt_ LPWSTR lpAnomalyType,
    _In_ ULONG_PTR lParam,
    _In_ BOOLEAN fCheckDuplicate
)
{
    INT iImage = IDI_ICON_CHECK_PASSED;
    INT lvItemIndex;
    LVITEM lvItem;

    if (fCheckDuplicate) {

        LVFINDINFO findInfo;

        RtlSecureZeroMemory(&findInfo, sizeof(findInfo));

        findInfo.flags = LVFI_PARAM;
        findInfo.lParam = lParam;

        if (-1 != ListView_FindItem(hwndList, 0, &findInfo))
            return;
    }

    switch (EventType) {

    case evtError:
        iImage = IDI_ICON_CHECK_FAILED;
        break;

    case evtWarning:
        iImage = IDI_ICON_CHECK_WARNING;
        break;

    case evtDetection:
        iImage = IDI_ICON_DETECTION;
        break;

    default:
        break;
    }

    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.pszText = lpEvent;
    lvItem.iImage = iImage - ICON_FIRST;
    lvItem.iItem = MAXINT;
    lvItem.lParam = lParam;
    lvItemIndex = ListView_InsertItem(hwndList, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iSubItem = 1;
    if (lpDescription) {
        lvItem.pszText = lpDescription;
    }
    else {
        lvItem.pszText = (LPWSTR)TEXT("");
    }
    lvItem.iItem = lvItemIndex;
    ListView_SetItem(hwndList, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iSubItem = 2;
    if (lpAnomalyType) {
        lvItem.pszText = lpAnomalyType;
    }
    else {
        lvItem.pszText = (LPWSTR)TEXT("");
    }
    lvItem.iItem = lvItemIndex;
    ListView_SetItem(hwndList, &lvItem);
}

/*
* supReportEvent
*
* Purpose:
*
* Add item to the main window listview.
*
*/
VOID supReportEvent(
    _In_ DR_EVENT_TYPE EventType,
    _In_ LPWSTR lpEvent,
    _In_opt_ LPWSTR lpDescription,
    _In_opt_ LPWSTR lpAnomalyType
)
{
    supReportEventEx(EventType,
        lpEvent,
        lpDescription,
        lpAnomalyType,
        0,
        FALSE);
}

/*
* supGetCurrentProcessToken
*
* Purpose:
*
* Return current process token value with TOKEN_QUERY access right.
*
*/
HANDLE supGetCurrentProcessToken(
    VOID)
{
    HANDLE tokenHandle = NULL;

    if (NT_SUCCESS(NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle)))
    {
        return tokenHandle;
    }
    return NULL;
}

/*
* supUserIsFullAdmin
*
* Purpose:
*
* Tests if the current user is admin with full access token.
*
*/
BOOL supUserIsFullAdmin(
    VOID
)
{
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    NTSTATUS status;
    DWORD i, Attributes;
    ULONG ReturnLength = 0;

    PTOKEN_GROUPS pTkGroups;

    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID adminGroup = NULL;

    status = NtOpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (!NT_SUCCESS(status))
        return bResult;

    do {
        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(
            &ntAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &adminGroup)))
        {
            break;
        }

        status = NtQueryInformationToken(hToken, TokenGroups, NULL, 0, &ReturnLength);
        if (status != STATUS_BUFFER_TOO_SMALL)
            break;

        pTkGroups = (PTOKEN_GROUPS)supHeapAlloc((SIZE_T)ReturnLength);
        if (pTkGroups == NULL)
            break;

        status = NtQueryInformationToken(hToken, TokenGroups, pTkGroups, ReturnLength, &ReturnLength);
        if (NT_SUCCESS(status)) {
            if (pTkGroups->GroupCount > 0)
                for (i = 0; i < pTkGroups->GroupCount; i++) {
                    Attributes = pTkGroups->Groups[i].Attributes;
                    if (RtlEqualSid(adminGroup, pTkGroups->Groups[i].Sid))
                        if (
                            (Attributes & SE_GROUP_ENABLED) &&
                            (!(Attributes & SE_GROUP_USE_FOR_DENY_ONLY))
                            )
                        {
                            bResult = TRUE;
                            break;
                        }
                }
        }
        supHeapFree(pTkGroups);

    } while (FALSE);

    if (adminGroup != NULL) {
        RtlFreeSid(adminGroup);
    }

    NtClose(hToken);
    return bResult;
}

/*
* supxGetShellViewForDesktop
*
* Purpose:
*
* Use the shell view for the desktop using the shell windows automation to find the
* desktop web browser and then grabs its view.
*
* N.B. Taken entirely from Windows SDK sample.
*
*/
HRESULT supxGetShellViewForDesktop(
    REFIID riid,
    void** ppv
)
{
    IShellWindows* psw;
    HRESULT hr;
    HWND hwnd;
    IDispatch* pdisp;
    IShellBrowser* psb;
    VARIANT vtEmpty;
    IShellView* psv;

    *ppv = NULL;

    hr = CoCreateInstance(CLSID_ShellWindows, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARGS(&psw));
    if (SUCCEEDED(hr))
    {
        VariantInit(&vtEmpty);

        if (S_OK == psw->FindWindowSW(&vtEmpty, &vtEmpty, SWC_DESKTOP, (long*)(LONG_PTR)&hwnd, SWFO_NEEDDISPATCH, &pdisp))
        {
            hr = IUnknown_QueryService(pdisp, SID_STopLevelBrowser, IID_PPV_ARGS(&psb));
            if (SUCCEEDED(hr))
            {

                hr = psb->QueryActiveShellView(&psv);
                if (SUCCEEDED(hr))
                {
                    hr = psv->QueryInterface(riid, ppv);
                    psv->Release();
                }
                psb->Release();
            }
            pdisp->Release();
        }
        else
        {
            hr = E_FAIL;
        }
        psw->Release();
    }

    return hr;
}

/*
* supxGetShellDispatchFromView
*
* Purpose:
*
* From a shell view object gets its automation interface and from that gets the shell
* application object that implements IShellDispatch2 and related interfaces.
*
* N.B. Taken entirely from Windows SDK sample.
*
*/
HRESULT supxGetShellDispatchFromView(IShellView* psv, REFIID riid, void** ppv)
{
    HRESULT hr;
    IDispatch* pdispBackground;
    IShellFolderViewDual* psfvd;
    IDispatch* pdisp;

    *ppv = NULL;

    hr = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARGS(&pdispBackground));
    if (SUCCEEDED(hr))
    {
        hr = pdispBackground->QueryInterface(IID_PPV_ARGS(&psfvd));
        if (SUCCEEDED(hr))
        {
            hr = psfvd->get_Application(&pdisp);
            if (SUCCEEDED(hr))
            {
                hr = pdisp->QueryInterface(riid, ppv);
                pdisp->Release();
            }
            psfvd->Release();
        }
        pdispBackground->Release();
    }

    return hr;
}

/*
* supShellExecInExplorerProcess
*
* Purpose:
*
* Run ShellExecute from Windows Explorer process through shell interfaces
* making it run with IL of Windows Explorer and not current process.
*
*/
HRESULT supShellExecInExplorerProcess(
    _In_ PCWSTR pszFile,
    _In_opt_ PCWSTR pszArguments
)
{
    HRESULT hr, hr_init;
    IShellView* psv;
    IShellDispatch2* psd;
    BSTR bstrFile, bstrArgs = NULL;
    VARIANT vtEmpty, vtArgs;

    hr_init = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);

    hr = supxGetShellViewForDesktop(IID_PPV_ARGS(&psv));
    if (SUCCEEDED(hr))
    {
        hr = supxGetShellDispatchFromView(psv, IID_PPV_ARGS(&psd));
        if (SUCCEEDED(hr))
        {
            bstrFile = SysAllocString(pszFile);
            hr = bstrFile ? S_OK : E_OUTOFMEMORY;
            if (SUCCEEDED(hr))
            {
                VariantInit(&vtArgs);
                VariantInit(&vtEmpty);

                if (pszArguments) {
                    bstrArgs = SysAllocString(pszArguments);
                    hr = bstrArgs ? S_OK : E_OUTOFMEMORY;

                    if (SUCCEEDED(hr)) {
                        vtArgs.vt = VT_BSTR;
                        vtArgs.bstrVal = bstrArgs;

                        hr = psd->ShellExecuteW(bstrFile,
                            vtArgs, vtEmpty, vtEmpty, vtEmpty);

                        SysFreeString(bstrFile);
                    }
                }
                else {

                    hr = psd->ShellExecuteW(bstrFile,
                        vtEmpty, vtEmpty, vtEmpty, vtEmpty);

                }

            }
            psd->Release();
        }
        psv->Release();
    }
    if (SUCCEEDED(hr_init)) CoUninitialize();
    return hr;
}

/*
* supSyscallAddressFromServiceEntry
*
* Purpose:
*
* Retrieve syscall instruction address from the given service entry.
*
*/
ULONG_PTR supSyscallAddressFromServiceEntry(
    _In_ PVOID ModuleBase,
    _In_ LPCSTR ServiceEntryName
)
{
    PBYTE ptrCode;
    hde64s hs;

    ptrCode = (PBYTE)supLdrGetProcAddressEx(ModuleBase, ServiceEntryName);

    if (ptrCode) {

        ULONG i = 0, maxLen = 32;

        do {

            hde64_disasm(RtlOffsetToPointer(ptrCode, i), &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 2) {

                if (hs.opcode == 0x0f &&
                    hs.opcode2 == 0x05 &&
                    hs.flags == 0)
                {
                    return (ULONG_PTR)RtlOffsetToPointer(ptrCode, i);
                }

            }

            i += hs.len;

        } while (i < maxLen);

    }

    return 0;
}

/*
* supxExtractSyscallNumberFromImage
*
* Purpose:
*
* Retrieve syscall service number value from function code.
*
*/
ULONG supxExtractSyscallNumberFromImage(
    _In_ PVOID ImageBase,
    _In_ LPCSTR FunctionName
)
{
    PBYTE ptrCode;

    ptrCode = (PBYTE)supLdrGetProcAddressEx(ImageBase, FunctionName);

    if (ptrCode) {

        if (ptrCode[0] == 0x4C &&
            ptrCode[1] == 0x8B &&
            (ptrCode[2] & 0xC0) == 0xC0)
        {
            return *(ULONG*)((BYTE*)ptrCode + 4);
        }

    }

    return INVALID_SYSCALL_ID;
}

/*
* supxExtractSyscallNumberFromImage2
*
* Purpose:
*
* Retrieve syscall service number value by address sorting.
*
*/
ULONG supxExtractSyscallNumberFromImage2(
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ LPCSTR FunctionName
)
{
    EXPORT_NODE* pExportTable;
    EXPORT_NODE* newHead = NULL, * node, * current;
    ULONG ulSSN, ulResult = INVALID_SYSCALL_ID;
    ULONG syscallBase = 0;

    if (ImageBase == NULL)
        return INVALID_SYSCALL_ID;

    PVOID pvEnumHeap = RtlCreateHeap(HEAP_GROWABLE, NULL, 0, 0, NULL, NULL);

    if (pvEnumHeap) {

        if (supEnumServiceExports((HANDLE)pvEnumHeap,
            ImageBase,
            IsNtDll,
            &pExportTable))
        {
            while (pExportTable) {

                node = pExportTable;
                pExportTable = pExportTable->Next;

                if (newHead == NULL || node->Address < newHead->Address) {
                    node->Next = newHead;
                    newHead = node;
                }
                else {
                    current = newHead;
                    while (current->Next && !(node->Address < current->Next->Address))
                        current = current->Next;

                    node->Next = current->Next;
                    current->Next = node;
                }
            }

            pExportTable = newHead;
            ulSSN = 0;

            if (!IsNtDll)
                syscallBase = W32K_TABLE_INDEX_BASE;

            while (pExportTable) {

                if (_strcmpi_a(pExportTable->Name, FunctionName) == 0) {
                    ulResult = ulSSN + syscallBase;
                    break;
                }

                pExportTable = pExportTable->Next;
                ulSSN += 1;
            }

        }

        RtlDestroyHeap(pvEnumHeap);
    }

    return ulResult;
}

/*
* supxExtractSyscallNumberFromImage3
*
* Purpose:
*
* Retrieve syscall service number value by runtime table walking.
*
*/
ULONG supxExtractSyscallNumberFromImage3(
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ LPCSTR FunctionName
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PIMAGE_RUNTIME_FUNCTION_ENTRY ImageRuntimeEntry = NULL;
    PULONG NameTableBase;
    PULONG AddressTableBase;
    PUSHORT NameOrdinalTableBase;
    PCHAR exportName;
    ULONG i, j, syscallNumber, syscallBase;
    DWORD RVA;
    USHORT servicePrefix;

    union {
        PIMAGE_NT_HEADERS64 nt64;
        PIMAGE_NT_HEADERS32 nt32;
        PIMAGE_NT_HEADERS nt;
    } NtHeaders;

    if (!NT_SUCCESS(RtlImageNtHeaderEx(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK,
        ImageBase, 0, &NtHeaders.nt)))
    {
        return INVALID_SYSCALL_ID;
    }

    if (NtHeaders.nt == NULL) {
        return INVALID_SYSCALL_ID;
    }

    if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {

        RVA = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (RVA == 0)
            return INVALID_SYSCALL_ID;

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer(ImageBase, RVA);

        RVA = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        if (RVA == 0)
            return INVALID_SYSCALL_ID;

        ImageRuntimeEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)RtlOffsetToPointer(ImageBase, RVA);

    }
    else if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {

        RVA = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (RVA == 0)
            return INVALID_SYSCALL_ID;

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer(ImageBase, RVA);

        RVA = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        if (RVA == 0)
            return INVALID_SYSCALL_ID;

        ImageRuntimeEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)RtlOffsetToPointer(ImageBase, RVA);

    }
    else
    {
        return INVALID_SYSCALL_ID;
    }

    if (ExportDirectory == NULL ||
        ImageRuntimeEntry == NULL)
    {
        return INVALID_SYSCALL_ID;
    }

    syscallNumber = 0;
    if (IsNtDll) {
        servicePrefix = 'wZ';
        syscallBase = 0;
    }
    else {
        servicePrefix = 'tN';
        syscallBase = W32K_TABLE_INDEX_BASE;
    }

    NameTableBase = (PULONG)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNames);
    NameOrdinalTableBase = (PUSHORT)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNameOrdinals);
    AddressTableBase = (PULONG)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfFunctions);

    for (i = 0; ImageRuntimeEntry[i].BeginAddress; i++) {
        for (j = 0; j < ExportDirectory->NumberOfFunctions; j++) {

            if (AddressTableBase[NameOrdinalTableBase[j]] == ImageRuntimeEntry[i].BeginAddress) {

                exportName = (PCHAR)RtlOffsetToPointer(ImageBase, NameTableBase[j]);

                if (_strcmpi_a(FunctionName, exportName) == 0) {
                    return syscallNumber + syscallBase;
                }

                if (*(USHORT*)exportName == servicePrefix)
                    syscallNumber++;
            }
        }
    }

    return INVALID_SYSCALL_ID;
}

enum {
    LockFree = 0,
    LockTaken = 1
};

volatile LONG SkiCallInProgress = LockTaken;
volatile LONG SkiCallWaitForMain = LockTaken;

ULONG supxSSNProbeThread(
    _In_ PFEFN Routine)
{
    Routine();

    InterlockedExchange(&SkiCallInProgress, LockFree);

    while (LockTaken == _InterlockedCompareExchange(&SkiCallWaitForMain,
        LockTaken,
        LockFree));

    return 0;
}

/*
* supExtractSyscallNumberFromRoutine
*
* Purpose:
*
* Retrieve syscall service number value by thread information.
*
*/
ULONG supExtractSyscallNumberFromRoutine(
    _In_ PFEFN Routine)
{
    ULONG syscallId = INVALID_SYSCALL_ID;
    HANDLE threadHandle;
    NTSTATUS ntStatus;
    DWORD threadId, dummy;
    THREAD_LAST_SYSCALL_INFORMATION lsi;

    threadHandle = CreateThread(NULL, 0,
        (LPTHREAD_START_ROUTINE)supxSSNProbeThread,
        (PVOID)Routine, 0, &threadId);

    if (threadHandle) {

        while (LockTaken == _InterlockedCompareExchange(
            &SkiCallInProgress,
            LockTaken,
            LockFree));

        ntStatus = NtSuspendThread(threadHandle, &dummy);
        if (NT_SUCCESS(ntStatus)) {

            SwitchToThread();

            ULONG retryCount = 100;

            do {

                ntStatus = NtQueryInformationThread(threadHandle, ThreadLastSystemCall,
                    &lsi, sizeof(lsi), &dummy);
                if (NT_SUCCESS(ntStatus)) {
                    syscallId = lsi.SystemCallNumber;
                    break;
                }

                Sleep(10);

            } while (--retryCount);

            InterlockedExchange(&SkiCallWaitForMain, LockFree);
            NtResumeThread(threadHandle, &dummy);
            if (WaitForSingleObject(threadHandle, 1000) == WAIT_TIMEOUT)
                NtTerminateThread(threadHandle, STATUS_ABANDONED_WAIT_0);
        }
        else {
            NtTerminateThread(threadHandle, ntStatus);
        }

        CloseHandle(threadHandle);
    }

    return syscallId;
}

/*
* supExtractSSN
*
* Purpose:
*
* Extract syscall system number by various methods.
*
*/
ULONG supExtractSSN(
    _In_ SSN_EXTRACT_METHOD Method,
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ LPCSTR FunctionName
)
{
    PFEFN pfnRoutine;

    switch (Method) {

    case SsnInstructionScan:
        return supxExtractSyscallNumberFromImage(ImageBase,
            FunctionName);

    case SsnSortedScan:
        return supxExtractSyscallNumberFromImage2(ImageBase,
            IsNtDll,
            FunctionName);

    case SsnRuntimeScan:
        return supxExtractSyscallNumberFromImage3(ImageBase,
            IsNtDll,
            FunctionName);

    case SsnThreadInformation:
        if (IsNtDll) {
            pfnRoutine = (PFEFN)supGetNtStubByName(FunctionName);
            if (pfnRoutine) {
                return supExtractSyscallNumberFromRoutine(pfnRoutine);
            }
        }
        break;
    }

    return INVALID_SYSCALL_ID;
}

/*
* supLdrGetProcAddressEx
*
* Purpose:
*
* Simplified GetProcAddress reimplementation.
*
*/
LPVOID supLdrGetProcAddressEx(
    _In_ LPVOID ImageBase,
    _In_ LPCSTR RoutineName
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    LONG Result;
    ULONG High, Low, Middle = 0;

    union {
        PIMAGE_NT_HEADERS64 nt64;
        PIMAGE_NT_HEADERS32 nt32;
        PIMAGE_NT_HEADERS nt;
    } NtHeaders;

    if (!NT_SUCCESS(RtlImageNtHeaderEx(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK,
        ImageBase, 0, &NtHeaders.nt)))
    {
        return NULL;
    }

    if (NtHeaders.nt == NULL) {
        return NULL;
    }

    if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer(ImageBase,
            NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    }
    else if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer(ImageBase,
            NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    }
    else
    {
        return NULL;
    }

    NameTableBase = (PULONG)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNames);
    NameOrdinalTableBase = (PUSHORT)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNameOrdinals);
    Low = 0;
    High = ExportDirectory->NumberOfNames - 1;
    while (High >= Low) {

        Middle = (Low + High) >> 1;

        Result = _strcmp_a(
            RoutineName,
            (char*)RtlOffsetToPointer(ImageBase, NameTableBase[Middle]));

        if (Result < 0) {
            High = Middle - 1;
        }
        else {
            if (Result > 0) {
                Low = Middle + 1;
            }
            else {
                break;
            }
        }
    }
    if (High < Low)
        return NULL;

    OrdinalNumber = NameOrdinalTableBase[Middle];
    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions)
        return NULL;

    Addr = (PULONG)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfFunctions);
    return (LPVOID)RtlOffsetToPointer(ImageBase, Addr[OrdinalNumber]);
}

/*
* supEnumServiceExports
*
* Purpose:
*
* Walk dll exports and collect every service entry.
*
*/
ULONG supEnumServiceExports(
    _In_ HANDLE HeapHandle,
    _In_ LPVOID ImageBase,
    _In_ BOOL IsNtDll,
    _Out_ EXPORT_NODE** ExportTable
)
{
    ULONG i, j, numberOfEntries;
    ULONG_PTR fnptr;

    LPCSTR lpfnName;

    DWORD numberOfRvaAndSizes;
    ULONG_PTR exportRva, expSize;
    PIMAGE_EXPORT_DIRECTORY	exportDirectory;
    PDWORD fnTable, nameTable;
    PWORD nameOrdTable;

    USHORT servicePrefix;

    EXPORT_NODE* pTableEntry;

    union {
        PIMAGE_NT_HEADERS64 nt64;
        PIMAGE_NT_HEADERS32 nt32;
        PIMAGE_NT_HEADERS nt;
    } NtHeaders;

    *ExportTable = NULL;

    SetLastError(ERROR_SUCCESS);

    if (!NT_SUCCESS(RtlImageNtHeaderEx(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK,
        ImageBase, 0, &NtHeaders.nt)))
    {
        return NULL;
    }

    if (NtHeaders.nt == NULL)
        return NULL;

    if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        numberOfRvaAndSizes = NtHeaders.nt64->OptionalHeader.NumberOfRvaAndSizes;
        exportRva = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        expSize = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    }
    else if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        numberOfRvaAndSizes = NtHeaders.nt32->OptionalHeader.NumberOfRvaAndSizes;
        exportRva = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        expSize = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    }
    else {
        SetLastError(ERROR_UNSUPPORTED_TYPE);
        return NULL;
    }

    if (numberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_EXPORT || exportRva == 0) {
        SetLastError(ERROR_UNSUPPORTED_TYPE);
        return NULL;
    }

    exportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer(ImageBase, exportRva);
    fnTable = (PDWORD)RtlOffsetToPointer(ImageBase, exportDirectory->AddressOfFunctions);
    nameTable = (PDWORD)RtlOffsetToPointer(ImageBase, exportDirectory->AddressOfNames);
    nameOrdTable = (PWORD)RtlOffsetToPointer(ImageBase, exportDirectory->AddressOfNameOrdinals);

    numberOfEntries = 0;

    if (IsNtDll)
        servicePrefix = 'wZ';
    else
        servicePrefix = 'tN';

    for (i = 0; i < exportDirectory->NumberOfFunctions; ++i)
    {
        fnptr = (ULONG_PTR)ImageBase + fnTable[i];

        for (j = 0; j < exportDirectory->NumberOfNames; ++j)
        {
            if (nameOrdTable[j] == i)
            {
                lpfnName = (LPCSTR)RtlOffsetToPointer(ImageBase, nameTable[j]);
                if (*(USHORT*)lpfnName == servicePrefix) {

                    pTableEntry = (EXPORT_NODE*)RtlAllocateHeap(HeapHandle, HEAP_ZERO_MEMORY, sizeof(EXPORT_NODE));
                    if (pTableEntry) {

                        _strncpy_a((char*)&pTableEntry->Name,
                            sizeof(pTableEntry->Name),
                            lpfnName,
                            sizeof(pTableEntry->Name));

                        //
                        // Hack for consistency.
                        //
                        if (IsNtDll) {
                            pTableEntry->Name[0] = L'N';
                            pTableEntry->Name[1] = L't';
                        }

                        pTableEntry->Address = (ULONG_PTR)RtlOffsetToPointer(ImageBase, fnTable[i]);
                        ++numberOfEntries;

                        *ExportTable = pTableEntry;
                        ExportTable = &pTableEntry->Next;
                    }

                    break;
                }

            }
        }

    }

    return numberOfEntries;
}

/*
* supLdrFindImageByAddressEx
*
* Purpose:
*
* Find base address for the given address value.
*
*/
PVOID supLdrFindImageByAddressEx(
    _In_ BOOL LockLoader,
    _In_opt_ PVOID AddressValue,
    _Out_ PVOID* ImageBase
)
{
    ULONG_PTR imageBounds;

    PLDR_DATA_TABLE_ENTRY ldrTableEntry;
    PLIST_ENTRY listHead;
    PLIST_ENTRY nextEntry;

    PIMAGE_NT_HEADERS NtHeaders;

    PVOID foundBase = NULL, pvImageBase = NULL;

    PPEB currentPeb = NtCurrentPeb();

    MEMORY_BASIC_INFORMATION mi;

    ULONG lockDisposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID;
    PVOID lockCookie = NULL;

    NTSTATUS ntStatus;

    *ImageBase = NULL;

    if (LockLoader) {
        ntStatus = LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY,
            &lockDisposition, &lockCookie);

        if (!NT_SUCCESS(ntStatus))
            return NULL;

        //
        // Loader lock failed. Query virtual memory.
        //

        if (lockDisposition == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED) {

            ntStatus = NtQueryVirtualMemory(
                NtCurrentProcess(),
                AddressValue,
                MemoryBasicInformation,
                &mi,
                sizeof(MEMORY_BASIC_INFORMATION),
                NULL);

            if (!NT_SUCCESS(ntStatus)) {
                mi.AllocationBase = NULL;
            }
            else {
                if (mi.Type == MEM_IMAGE) {
                    *ImageBase = mi.AllocationBase;
                }
                else {
                    mi.AllocationBase = NULL;;
                }
            }
            return mi.AllocationBase;
        }

    }

    //
    // Walk PEB.
    //

    __try {

        ULONG cLoops = 0;

        if (currentPeb->Ldr != NULL) {
            listHead = &currentPeb->Ldr->InLoadOrderModuleList;
            nextEntry = listHead->Flink;
            if (nextEntry != NULL) {
                while (nextEntry != listHead && cLoops < LDRP_MAX_MODULE_LOOP) {

                    ldrTableEntry = CONTAINING_RECORD(nextEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                    pvImageBase = ldrTableEntry->DllBase;

                    if (NT_SUCCESS(RtlImageNtHeaderEx(0, pvImageBase, ldrTableEntry->SizeOfImage, &NtHeaders))) {
                        imageBounds = (ULONG_PTR)RtlOffsetToPointer(pvImageBase, NtHeaders->OptionalHeader.SizeOfImage);
                        if (IN_REGION(AddressValue, pvImageBase, NtHeaders->OptionalHeader.SizeOfImage)) {
                            foundBase = pvImageBase;
                            break;
                        }

                    }

                    nextEntry = nextEntry->Flink;
                    cLoops += 1;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        foundBase = NULL;
    }

    if (LockLoader) {
        LdrUnlockLoaderLock(0, lockCookie);
    }

    *ImageBase = foundBase;
    return foundBase;
}

/*
* supLdrFindImageByAddress
*
* Purpose:
*
* Find base address for the given address value.
*
*/
PVOID supLdrFindImageByAddress(
    _In_opt_ PVOID AddressValue,
    _Out_ PVOID* ImageBase
)
{
    return supLdrFindImageByAddressEx(TRUE, AddressValue, ImageBase);
}

/*
* supUnhandledExceptionFilter
*
* Purpose:
*
* Say something before crash.
*
*/
ULONG NTAPI supUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
)
{
    DbgPrint((PCH)"[SK] Unhandled exception 0x%x at address %p\n",
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress);

    return EXCEPTION_EXECUTE_HANDLER;
}

/*
* supGetObjectTypesInfo
*
* Purpose:
*
* Returns buffer with system types information.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
NTSTATUS supGetObjectTypesInfo(
    _Out_ PULONG ReturnLength,
    _Out_ PVOID* Buffer
)
{
    PVOID buffer = NULL;
    ULONG bufferSize = 1024 * 16;
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;

    *ReturnLength = 0;
    *Buffer = NULL;

    buffer = supHeapAlloc((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    while ((ntStatus = NtQueryObject(
        NULL,
        ObjectTypesInformation,
        buffer,
        bufferSize,
        &returnedLength)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        supHeapFree(buffer);
        bufferSize <<= 1;

        if (bufferSize > (16 * 1024 * 1024))
            return NULL;

        buffer = supHeapAlloc((SIZE_T)bufferSize);
    }

    if (NT_SUCCESS(ntStatus)) {
        *ReturnLength = returnedLength;
        *Buffer = buffer;
        return ntStatus;
    }

    if (buffer) {
        supHeapFree(buffer);
    }

    return ntStatus;
}

/*
* supGetImageBaseUnsafe
*
* Purpose:
*
* Find base address for the given address value through brute-force.
*
*/
PVOID supGetImageBaseUnsafe(
    _In_ ULONG_PTR AddressValue
)
{
    PVOID baseAddress = NULL;
    ULONG returnLength = 0;
    SYSTEM_BASIC_INFORMATION sbi;
    ULONG_PTR probeAddress, allocationGranularity;

    if (NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi), &returnLength))) {

        allocationGranularity = sbi.AllocationGranularity;

        __try {

            probeAddress = AddressValue & ~(allocationGranularity - 1);

            do {

                if ((((IMAGE_DOS_HEADER*)probeAddress)->e_magic == IMAGE_DOS_SIGNATURE) &&
                    (((IMAGE_NT_HEADERS*)RtlOffsetToPointer(probeAddress,
                        ((IMAGE_DOS_HEADER*)probeAddress)->e_lfanew))->Signature == IMAGE_NT_SIGNATURE))
                {
                    return (PVOID)probeAddress;
                }

                probeAddress -= allocationGranularity;
            } while (TRUE);

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return NULL;
        }
    }
    return baseAddress;
}

/*
* supVirtualAlloc
*
* Purpose:
*
* Wrapper for NtAllocateVirtualMemory.
*
*/
PVOID supVirtualAlloc(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect)
{
    NTSTATUS ntStatus;
    PVOID bufferPtr = NULL;
    SIZE_T bufferSize;

    bufferSize = Size;
    ntStatus = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &bufferPtr,
        0,
        &bufferSize,
        AllocationType,
        Protect);

    if (NT_SUCCESS(ntStatus)) {
        return bufferPtr;
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NULL;
}

/*
* supVirtualFree
*
* Purpose:
*
* Wrapper for NtFreeVirtualMemory.
*
*/
BOOL supVirtualFree(
    _In_ PVOID Memory)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    SIZE_T sizeDummy = 0;

    if (Memory) {
        ntStatus = NtFreeVirtualMemory(
            NtCurrentProcess(),
            &Memory,
            &sizeDummy,
            MEM_RELEASE);
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NT_SUCCESS(ntStatus);
}

/*
* supConvertToUnicode
*
* Purpose:
*
* Convert ANSI string to UNICODE string.
*
* N.B.
* If function succeeded - use RtlFreeUnicodeString to release allocated string.
*
*/
NTSTATUS supConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString)
{
    ANSI_STRING ansiString;

    RtlInitString(&ansiString, AnsiString);
    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiString, TRUE);
}

/*
* supSignerIsMsft
*
* Purpose:
*
* Verify that signer is MSFT.
*
*/
BOOL supSignerIsMsft(
    _In_ PCCERT_CHAIN_CONTEXT pChainContext
)
{
    PCERT_SIMPLE_CHAIN pChain;
    PCCERT_CONTEXT pCertContext;

    pChain = pChainContext->rgpChain[0];
    pCertContext = pChain->rgpElement[0]->pCertContext;

    for (DWORD i = 0; i < PUBLISHER_NAME_LIST_CNT; i++) {

        BOOL trusted = TRUE;

        //
        // Check against all attributes.
        //
        for (DWORD j = 0; trusted && j < PUBLISHER_ATTR_CNT; j++) {

            LPWSTR attrString = NULL;
            DWORD attrStringLength;

            attrStringLength = CertGetNameString(
                pCertContext,
                CERT_NAME_ATTR_TYPE,
                0,
                (PVOID)gPublisherAttributeObjId[j],
                NULL,
                0);

            if (attrStringLength <= 1)
                return FALSE;

            attrString = (LPWSTR)supHeapAlloc(attrStringLength * sizeof(WCHAR));
            if (attrString == NULL)
                return FALSE;

            attrStringLength = CertGetNameString(
                pCertContext,
                CERT_NAME_ATTR_TYPE,
                0,
                (PVOID)gPublisherAttributeObjId[j],
                attrString,
                attrStringLength);

            if (attrStringLength <= 1 ||
                0 != _strcmp(attrString, gPublisherNameList[i][j]))
            {
                trusted = FALSE;
            }

            supHeapFree(attrString);
        }

        if (trusted)
            return TRUE;
    }

    return FALSE;
}

/*
* supVerifyFileSignature
*
* Purpose:
*
* Validate file to be signed with a valid signature.
*
*/
NTSTATUS supVerifyFileSignature(
    _In_ KPROCESSOR_MODE Mode,
    _In_ LPWSTR lpFileName,
    _In_ BOOL OsBinaryCheck,
    _In_ ptrWTGetSignatureInfo pWTGetSignatureInfo
)
{
    BOOL bValid = FALSE, bTrustedFileOwner = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE hFile = NULL;
    OBJECT_ATTRIBUTES attr;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING usFileName;
    SIGNATURE_INFO sigData;
    DWORD dwFlags = SIF_BASE_VERIFICATION | SIF_CATALOG_SIGNED;

    if (pWTGetSignatureInfo == NULL)
        return STATUS_INVALID_PARAMETER_3;

    do {
        //
        // Open file and map it.
        //
        RtlInitEmptyUnicodeString(&usFileName, NULL, 0);
        if (RtlDosPathNameToNtPathName_U(lpFileName, &usFileName, NULL, NULL) == FALSE)
            break;

        InitializeObjectAttributes(&attr, &usFileName,
            OBJ_CASE_INSENSITIVE, NULL, NULL);

        RtlSecureZeroMemory(&iosb, sizeof(iosb));
        ntStatus = NtCreateFile(&hFile, SYNCHRONIZE | FILE_READ_DATA | READ_CONTROL,
            &attr, &iosb, NULL, 0, FILE_SHARE_READ, FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

        if (!NT_SUCCESS(ntStatus))
            break;

        RtlSecureZeroMemory(&sigData, sizeof(sigData));
        sigData.cbSize = sizeof(sigData);

        ntStatus = supIsFileOwnedByTrustedInstallerSystemOrAdmins(Mode, hFile, &usFileName);
        bTrustedFileOwner = NT_SUCCESS(ntStatus);

        if (bTrustedFileOwner) {
            if (OsBinaryCheck) {
                dwFlags |= SIF_CHECK_OS_BINARY;
            }
            else {
                dwFlags |= SIF_AUTHENTICODE_SIGNED;
            }
        }
        else {
            //
            // FS object owner is untrusted, verify authenticode only.
            //
            dwFlags |= SIF_AUTHENTICODE_SIGNED;
        }

        HANDLE hWVTStateData;

        ntStatus = pWTGetSignatureInfo(lpFileName,
            hFile,
            dwFlags,
            &sigData,
            NULL,
            &hWVTStateData);

        NtClose(hFile);

        if (!NT_SUCCESS(ntStatus))
            break;

#if 0
        BOOL bTrustedPublisher = TRUE;

        if (Mode == UserMode) {
            //
            // Verify publisher.
            //
            CRYPT_PROVIDER_DATA* pCryptData;
            CRYPT_PROVIDER_SGNR* pSigner;

            pCryptData = WTHelperProvDataFromStateData(hWVTStateData);
            if (pCryptData) {
                pSigner = WTHelperGetProvSignerFromChain(pCryptData, 0, FALSE, 0);
                if (pSigner) {
                    bTrustedPublisher = supSignerIsMsft(pSigner->pChainContext);
                }
            }

            if (!bTrustedPublisher) {
                ntStatus = STATUS_IMAGE_CERT_REVOKED;
                break;
            }
        }
#endif

        if (bTrustedFileOwner) {
            if (OsBinaryCheck) {
                bValid = ((sigData.SignatureState == SIGNATURE_STATE_VALID) && (sigData.fOSBinary != FALSE));
            }
            else {
                bValid = (sigData.SignatureState == SIGNATURE_STATE_VALID);
            }
        }
        else {
            bValid = (sigData.SignatureState == SIGNATURE_STATE_VALID) &&
                (sigData.SignatureType == SIT_AUTHENTICODE);
        }

        if (!bValid)
            ntStatus = STATUS_UNSUCCESSFUL;
        else
            ntStatus = STATUS_SUCCESS;

    } while (FALSE);

    if (usFileName.Buffer != NULL)
        RtlFreeUnicodeString(&usFileName);

    return ntStatus;
}

/*
* supxFindFileVersion
*
* Purpose:
*
* Find VersionInfo block in data.
* (c) Vmprotect.
*
*/
PWSTR supxFindFileVersion(
    _In_ PBYTE DataPtr,
    _In_ SIZE_T DataSize
)
{
    PWCHAR data = (PWCHAR)DataPtr;
    SIZE_T i, dataSize = DataSize / sizeof(WCHAR);

    for (i = 0; i < dataSize; i++) {

        if (dataSize >= 13) {

            //
            // FileVersion + 00
            //
            if (data[i + 0] == L'F' && data[i + 1] == L'i' &&
                data[i + 2] == L'l' && data[i + 3] == L'e' &&
                data[i + 4] == L'V' && data[i + 5] == L'e' &&
                data[i + 6] == L'r' && data[i + 7] == L's' &&
                data[i + 8] == L'i' && data[i + 9] == L'o' &&
                data[i + 10] == L'n' && data[i + 11] == 0 && data[i + 12] == 0)
            {
                return data + i + 13;
            }
        }

        if (dataSize >= 15) {

            //
            // ProductVersion + 00
            //               
            if (data[i + 0] == L'P' && data[i + 1] == L'r' &&
                data[i + 2] == L'o' && data[i + 3] == L'd' &&
                data[i + 4] == L'u' && data[i + 5] == L'c' &&
                data[i + 6] == L't' && data[i + 7] == L'V' &&
                data[i + 8] == L'e' && data[i + 9] == L'r' &&
                data[i + 10] == L's' && data[i + 11] == L'i' &&
                data[i + 12] == L'o' && data[i + 13] == L'n' && data[i + 14] == 0)
            {
                return data + i + 15;
            }
        }
    }

    return NULL;
}

/*
* supParseOSBuildBumber
*
* Purpose:
*
* Extract build number from the version info resource.
* (c) Vmprotect.
*
*/
ULONG supParseOSBuildBumber(
    _In_ PVOID ImageBase
)
{
    ULONG result = 0, size;
    ULONG_PTR resStart, resEnd;
    ULONG RVA;
    PIMAGE_NT_HEADERS ntHeaders;

    if (!NT_SUCCESS(RtlImageNtHeaderEx(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK,
        ImageBase, 0, &ntHeaders)))
    {
        return 0;
    }

    if (ntHeaders == NULL)
        return 0;

    RVA = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
    if (RVA) {

        resStart = (ULONG_PTR)RtlOffsetToPointer(ImageBase, RVA);
        size = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
        resEnd = (ULONG_PTR)RtlOffsetToPointer(resStart, size);

        while (wchar_t* fileVersion = supxFindFileVersion((PBYTE)resStart, resEnd - resStart)) {

            for (size_t i = 0; *fileVersion; fileVersion++) {
                if (*fileVersion == L'.')
                    i++;
                else if (i == 2) {
                    while (wchar_t c = *fileVersion++) {
                        if (c >= L'0' && c <= L'9') {
                            result *= 10;
                            result += c - L'0';
                        }
                        else
                            break;
                    }
                    break;
                }
            }

            if (IS_KNOWN_WINDOWS_BUILD(result))
                break;

            resStart = (ULONG_PTR)fileVersion;
        }
    }
    return result;
}

/*
* supMapNtdllCopy
*
* Purpose:
*
* Load copy of ntdll using selected method.
*
* 1. Map using absolute NT path
* 2. Map using relative NT path
* 3. Map using absolute KnownDlls object path
* 4. Map using relative KnownDlls object path
* 5. Map using precached ntdll directory handle
* ...
* Wubbaboo!
*
*/
NTSTATUS supMapNtdllCopy(
    _In_ NTDLL_MAP_METHOD MapMethod,
    _Out_ PVOID* BaseAddress
)
{
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING us;
    IO_STATUS_BLOCK iost;
    LARGE_INTEGER offset;
    HANDLE hObject = NULL, hFile = NULL, hSection = NULL;
    SIZE_T fileSize = 0;
    NTSTATUS ntStatus;

    *BaseAddress = NULL;

    LPWSTR lpPath = (LPWSTR)DIRECTORY_SYSTEM32;

    if (MapMethod == UseLdrKnownDllDirectoryHandle) {

        ntStatus = LdrGetKnownDllSectionHandle(RtlNtdllName, FALSE, &hSection);

    }
    else {

        if (MapMethod != UseKnownDllsAbsolute && MapMethod != UseKnownDllsRelative) {

            if (MapMethod == UseAbsolutePath)
                lpPath = (LPWSTR)L"\\systemroot\\system32\\ntdll.dll";

            RtlInitUnicodeString(&us, lpPath);
            InitializeObjectAttributes(&obja, &us, OBJ_CASE_INSENSITIVE, NULL, NULL);

            ntStatus = NtOpenFile(&hObject,
                FILE_GENERIC_READ | SYNCHRONIZE,
                &obja,
                &iost,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT);

            if (MapMethod == UseRelativePath) {

                RtlInitUnicodeString(&us, RtlNtdllName);
                obja.RootDirectory = hObject;

                ntStatus = NtOpenFile(&hFile,
                    GENERIC_READ | SYNCHRONIZE,
                    &obja, &iost,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

            }
            else {
                hFile = hObject;
            }

            if (!NT_SUCCESS(ntStatus))
                return ntStatus;

            InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

            ntStatus = NtCreateSection(&hSection,
                SECTION_MAP_READ,
                &obja,
                NULL,
                PAGE_READONLY,
                SEC_IMAGE_NO_EXECUTE,
                hFile);

            if (hFile)
                NtClose(hFile);

        }
        else {

            InitializeObjectAttributes(&obja, NULL, OBJ_CASE_INSENSITIVE, NULL, NULL);

            if (MapMethod == UseKnownDllsAbsolute) {
                RtlInitUnicodeString(&us, L"\\KnownDlls\\ntdll.dll");
            }
            else {

                RtlInitUnicodeString(&us, DIRECTORY_KNOWNDLLS);
                obja.ObjectName = &us;
                ntStatus = NtOpenDirectoryObject(&obja.RootDirectory,
                    DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
                    &obja);

                if (!NT_SUCCESS(ntStatus))
                    return ntStatus;

                RtlInitUnicodeString(&us, RtlNtdllName);
            }

            obja.ObjectName = &us;

            ntStatus = NtOpenSection(&hSection,
                SECTION_MAP_READ,
                &obja);

            if (obja.RootDirectory != NULL)
                NtClose(obja.RootDirectory);

        }
    }

    if (NT_SUCCESS(ntStatus)) {

        offset.QuadPart = 0;

        ntStatus = NtMapViewOfSection(hSection,
            NtCurrentProcess(),
            BaseAddress,
            0,
            0,
            &offset,
            &fileSize,
            ViewShare,
            0,
            PAGE_READONLY);

        NtClose(hSection);

    }

    return ntStatus;
}

/*
* supDetectDebug
*
* Purpose:
*
* Detect debugger/debugging by using selected method.
*
*/
BOOLEAN supDetectDebug(
    _In_ DBG_CHECK_METHOD Method
)
{
    SIZE_T drX = 0;
    ULONG_PTR val;
    CONTEXT* ctx;
    NTSTATUS ntStatus;
    ULONG returnLength = 0, noDebugInherit = 0;
    HANDLE debugObjectHandle = NULL;
    HANDLE debugPort = NULL;

    pfnNtQueryInformationProcess pNtQueryInformationProcess;

    switch (Method) {

    case CheckDrXReg:

        //
        // Non zero DrX registers in context record when catching exception.
        // This is handled by ScyllaHide.
        //

        __try {
            __writeeflags(__readeflags() | 0x100);
            val = __rdtsc();
            __nop();
            return TRUE;
        }
        __except (ctx = (GetExceptionInformation())->ContextRecord,
            drX = (ctx->ContextFlags & CONTEXT_DEBUG_REGISTERS) ?
            ctx->Dr0 | ctx->Dr1 | ctx->Dr2 | ctx->Dr3 : 0,
            EXCEPTION_EXECUTE_HANDLER)
        {
            if (drX)
                return TRUE;
        }
        break;

        //
        // The only reliable methods of detecting debugger in a system.
        // Everything else are either bound to software bugs, 
        // user mode fake friendly or unstable and produces FP.
        //

    case CheckDebugObjectHandle:

        pNtQueryInformationProcess = (pfnNtQueryInformationProcess)SkiIndirectSystemCall;
        ntStatus = pNtQueryInformationProcess(NtCurrentProcess(),
            ProcessDebugObjectHandle,
            &debugObjectHandle,
            sizeof(debugObjectHandle),
            &returnLength);

        if (NT_SUCCESS(ntStatus)) {

            return (debugObjectHandle != NULL);
        }

        break;

    case CheckDebugPort:

        pNtQueryInformationProcess = (pfnNtQueryInformationProcess)SkiIndirectSystemCall;
        ntStatus = pNtQueryInformationProcess(NtCurrentProcess(),
            ProcessDebugPort,
            &debugPort,
            sizeof(debugPort),
            &returnLength);

        if (NT_SUCCESS(ntStatus)) {

            return (debugPort == (HANDLE)-1);
        }

        break;

    case CheckDebugFlags:

        pNtQueryInformationProcess = (pfnNtQueryInformationProcess)SkiIndirectSystemCall;
        ntStatus = pNtQueryInformationProcess(NtCurrentProcess(),
            ProcessDebugFlags,
            &noDebugInherit,
            sizeof(noDebugInherit),
            &returnLength);

        if (NT_SUCCESS(ntStatus)) {
            return (noDebugInherit == 0);
        }

        break;

    case CheckUSD:
        return USER_SHARED_DATA->KdDebuggerEnabled;

    }

    return FALSE;
}

/*
* supPrivilegeEnabled
*
* Purpose:
*
* Tests if the given token has the given privilege enabled/enabled by default.
*
*/
NTSTATUS supPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult
)
{
    NTSTATUS status;
    PRIVILEGE_SET Privs;
    BOOLEAN bResult = FALSE;

    Privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privs.PrivilegeCount = 1;
    Privs.Privilege[0].Luid.LowPart = Privilege;
    Privs.Privilege[0].Luid.HighPart = 0;
    Privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED;

    status = NtPrivilegeCheck(ClientToken, &Privs, &bResult);

    *pfResult = bResult;

    return status;
}

/*
* supGetLoadedModulesList
*
* Purpose:
*
* Read list of loaded kernel modules.
*
*/
PVOID supGetLoadedModulesList(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength
)
{
    NTSTATUS ntStatus;
    PVOID buffer;
    ULONG bufferSize = PAGE_SIZE;

    PRTL_PROCESS_MODULES pvModules;
    SYSTEM_INFORMATION_CLASS infoClass;

    if (ReturnLength)
        *ReturnLength = 0;

    if (ExtendedOutput)
        infoClass = SystemModuleInformationEx;
    else
        infoClass = SystemModuleInformation;

    buffer = supHeapAlloc((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    ntStatus = NtQuerySystemInformation(
        infoClass,
        buffer,
        bufferSize,
        &bufferSize);

    if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {
        supHeapFree(buffer);
        buffer = supHeapAlloc((SIZE_T)bufferSize);

        ntStatus = NtQuerySystemInformation(
            infoClass,
            buffer,
            bufferSize,
            &bufferSize);
    }

    if (ReturnLength)
        *ReturnLength = bufferSize;

    //
    // Handle unexpected return.
    //
    // If driver image path exceeds structure field size then 
    // RtlUnicodeStringToAnsiString will throw STATUS_BUFFER_OVERFLOW.
    // 
    // If this is the last driver in the enumeration service will return 
    // valid data but STATUS_BUFFER_OVERFLOW in result.
    //
    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        //
        // Force ignore this status if list is not empty.
        //
        pvModules = (PRTL_PROCESS_MODULES)buffer;
        if (pvModules->NumberOfModules != 0)
            return buffer;
    }

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    if (buffer)
        supHeapFree(buffer);

    return NULL;
}

//
// Conversion buffer size
//
#define CONVERT_NTNAME_BUFFER_SIZE 512

/*
* supConvertFileName
*
* Purpose:
*
* Translate Nt path name to Dos path name.
*
*/
BOOL supConvertFileName(
    _In_ LPWSTR NtFileName,
    _Inout_ LPWSTR DosFileName,
    _In_ SIZE_T ccDosFileName
)
{
    BOOL bFound = FALSE;

    SIZE_T nLen;

    WCHAR szDrive[3];
    WCHAR szName[MAX_PATH];
    WCHAR szTemp[CONVERT_NTNAME_BUFFER_SIZE];
    WCHAR* pszTemp;

    //
    // All input parameters are validated by caller before.
    //

    //
    // Drive template.
    //
    szDrive[0] = L'X';
    szDrive[1] = L':';
    szDrive[2] = 0;

    //
    // Query array of logical disk drive strings.
    //
    szTemp[0] = 0;
    if (GetLogicalDriveStrings(RTL_NUMBER_OF(szTemp), szTemp) == 0)
        return FALSE;

    pszTemp = szTemp;

    do {

        //
        // Copy the drive letter to the template string.
        //
        *szDrive = *pszTemp;
        szName[0] = 0;

        //
        // Lookup each device name.
        //
        if (QueryDosDevice(szDrive, szName, MAX_PATH)) {

            nLen = _strlen(szName);

            if (nLen < MAX_PATH) {

                //
                // Match device name.
                //
                bFound = ((_strncmpi(NtFileName, szName, nLen) == 0)
                    && *(NtFileName + nLen) == L'\\');

                if (bFound) {

                    //
                    // Build output name.
                    //
                    StringCchPrintf(DosFileName,
                        ccDosFileName,
                        TEXT("%ws%ws"),
                        szDrive,
                        NtFileName + nLen);

                }

            }

        }

        //
        // Go to the next NULL character, i.e. the next drive name.
        //
        while (*pszTemp++);

    } while (!bFound && *pszTemp);

    return bFound;
}

/*
* supQueryObjectInformation
*
* Purpose:
*
* Wrapper around NtQueryObject.
*
*/
NTSTATUS supQueryObjectInformation(
    _In_opt_ HANDLE ObjectHandle,
    _In_ OBJECT_INFORMATION_CLASS InformationClass,
    _Out_ PVOID* Buffer,
    _Out_opt_ PULONG ReturnLength
)
{
    NTSTATUS ntStatus;
    PVOID queryBuffer;
    ULONG returnLength = 0;

    *Buffer = NULL;
    if (ReturnLength) *ReturnLength = 0;

    ntStatus = NtQueryObject(ObjectHandle,
        InformationClass,
        NULL,
        0,
        &returnLength);

    //
    // Test all possible acceptable failures.
    //
    if (ntStatus != STATUS_BUFFER_OVERFLOW &&
        ntStatus != STATUS_BUFFER_TOO_SMALL &&
        ntStatus != STATUS_INFO_LENGTH_MISMATCH)
    {
        return ntStatus;
    }

    queryBuffer = supHeapAlloc(returnLength);
    if (queryBuffer == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    ntStatus = NtQueryObject(ObjectHandle,
        InformationClass,
        queryBuffer,
        returnLength,
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        *Buffer = queryBuffer;
        if (ReturnLength) *ReturnLength = returnLength;
    }
    else {
        supHeapFree(queryBuffer);
    }

    return ntStatus;
}

/*
* supGetWin32FileName
*
* Purpose:
*
* Query filename by handle.
*
*/
NTSTATUS supGetWin32FileName(
    _In_ LPCWSTR NtFileName,
    _Out_ LPWSTR* Win32FileName
)
{
    BOOL bResult = FALSE;
    LPWSTR lpWin32Name = NULL;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE hFile = NULL;
    UNICODE_STRING usNtFileName;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iost;
    ULONG size;

    BYTE* Buffer = NULL;
    *Win32FileName = NULL;

    RtlInitUnicodeString(&usNtFileName, NtFileName);
    InitializeObjectAttributes(&obja, &usNtFileName, OBJ_CASE_INSENSITIVE, 0, NULL);

    do {

        ntStatus = NtCreateFile(&hFile,
            SYNCHRONIZE,
            &obja,
            &iost,
            NULL,
            0,
            FILE_SHARE_VALID_FLAGS,
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
            NULL, 0);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = supQueryObjectInformation(hFile,
            ObjectNameInformation,
            (PVOID*)&Buffer,
            NULL);

        if (!NT_SUCCESS(ntStatus))
            break;

        size = UNICODE_STRING_MAX_CHARS * sizeof(WCHAR);
        lpWin32Name = (LPWSTR)supHeapAlloc(size);

        if (lpWin32Name == NULL) {
            ntStatus = STATUS_MEMORY_NOT_ALLOCATED;
            break;
        }

        bResult = supConvertFileName(((POBJECT_NAME_INFORMATION)Buffer)->Name.Buffer,
            lpWin32Name,
            size / sizeof(WCHAR));

        if (!bResult) {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

    } while (FALSE);

    if (Buffer) supHeapFree(Buffer);
    if (hFile) NtClose(hFile);
    if (bResult == FALSE && lpWin32Name) {
        supHeapFree(lpWin32Name);
        lpWin32Name = NULL;
    }
    *Win32FileName = lpWin32Name;

    return ntStatus;
}

/*
* supxDetectObjectCallback
*
* Purpose:
*
* Comparer callback routine used in objects enumeration.
*
*/
NTSTATUS NTAPI supxDetectObjectCallback(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ PVOID CallbackParam
)
{
    POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;

    if (Entry == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (CallbackParam == NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (Param->Buffer == NULL || Param->BufferSize == 0) {
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    if (Entry->Name.Buffer) {
        if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}

/*
* supxEnumSystemObjects
*
* Purpose:
*
* Lookup object by name in given directory.
*
*/
NTSTATUS NTAPI supxEnumSystemObjects(
    _In_opt_ LPCWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam
)
{
    ULONG ctx, rlen;
    HANDLE hDirectory = NULL;
    NTSTATUS status;
    NTSTATUS CallbackStatus;
    OBJECT_ATTRIBUTES attr;
    UNICODE_STRING sname;

    POBJECT_DIRECTORY_INFORMATION    objinf;

    if (CallbackProc == NULL) {
        return STATUS_INVALID_PARAMETER_4;
    }

    status = STATUS_UNSUCCESSFUL;

    // We can use root directory.
    if (pwszRootDirectory != NULL) {
        RtlSecureZeroMemory(&sname, sizeof(sname));
        RtlInitUnicodeString(&sname, pwszRootDirectory);
        InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);
        status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    else {
        if (hRootDirectory == NULL) {
            return STATUS_INVALID_PARAMETER_2;
        }
        hDirectory = hRootDirectory;
    }

    // Enumerate objects in directory.
    ctx = 0;
    do {

        rlen = 0;
        status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);
        if (status != STATUS_BUFFER_TOO_SMALL)
            break;

        objinf = (POBJECT_DIRECTORY_INFORMATION)supHeapAlloc(rlen);
        if (objinf == NULL)
            break;

        status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);
        if (!NT_SUCCESS(status)) {
            supHeapFree(objinf);
            break;
        }

        CallbackStatus = CallbackProc(objinf, CallbackParam);

        supHeapFree(objinf);

        if (NT_SUCCESS(CallbackStatus)) {
            status = STATUS_SUCCESS;
            break;
        }

    } while (TRUE);

    if (hDirectory != NULL) {
        NtClose(hDirectory);
    }

    return status;
}

/*
* supIsObjectExists
*
* Purpose:
*
* Return TRUE if the given object exists, FALSE otherwise.
*
*/
BOOLEAN supIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName
)
{
    OBJSCANPARAM Param;

    Param.Buffer = ObjectName;
    Param.BufferSize = (ULONG)_strlen(ObjectName);

    return NT_SUCCESS(supxEnumSystemObjects(RootDirectory, NULL, supxDetectObjectCallback, &Param));
}

/*
* supEmptyWorkingSet
*
* Purpose:
*
* Empty process working set.
*
*/
NTSTATUS supEmptyWorkingSet()
{
    NTSTATUS ntStatus;
    QUOTA_LIMITS quotaLimits;

    ntStatus = NtQueryInformationProcess(NtCurrentProcess(),
        ProcessQuotaLimits,
        &quotaLimits,
        sizeof(quotaLimits),
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    quotaLimits.MinimumWorkingSetSize = (SIZE_T)-1;
    quotaLimits.MaximumWorkingSetSize = (SIZE_T)-1;

    return NtSetInformationProcess(NtCurrentProcess(),
        ProcessQuotaLimits,
        &quotaLimits,
        sizeof(quotaLimits));
}

/*
* supFindModuleEntryByAddress
*
* Purpose:
*
* Find Module Entry for given Address.
*
*/
BOOL supFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES pModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex
)
{
    ULONG i, modulesCount = pModulesList->NumberOfModules;

    *ModuleIndex = 0;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            pModulesList->Modules[i].ImageBase,
            pModulesList->Modules[i].ImageSize))
        {
            *ModuleIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

size_t supxEscStrlen(wchar_t* s)
{
    size_t  result = 2;
    wchar_t* s0 = s;

    while (*s)
    {
        if (*s == L'"')
            ++result;
        ++s;
    }

    return result + (s - s0);
}

wchar_t* supxEscStrcpy(wchar_t* dst, wchar_t* src)
{
    *(dst++) = L'"';

    while ((*dst = *src) != L'\0')
    {
        if (*src == L'"')
            *(++dst) = L'"';

        ++src;
        ++dst;
    }

    *(dst++) = L'"';
    *dst = L'\0';

    return dst;
}

/*
* supxListViewExportCSV
*
* Purpose:
*
* Export listview entries into file in csv format.
*
*/
BOOL supxListViewExportCSV(
    _In_ HWND List,
    _In_ PWCHAR FileName)
{
    HWND hdr = ListView_GetHeader(List);
    int pass, i, c, col_count = Header_GetItemCount(hdr), icount = 1 + ListView_GetItemCount(List);
    HDITEM ih;
    LVITEM lvi;
    PWCHAR text, buffer0 = NULL, buffer = NULL;
    BOOL result = FALSE;
    SIZE_T total_length;
    DWORD iobytes;
    HANDLE hFile;

    text = (PWCHAR)supVirtualAlloc(32768 * sizeof(WCHAR),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (!text)
        return FALSE;

    RtlSecureZeroMemory(&ih, sizeof(HDITEM));
    RtlSecureZeroMemory(&lvi, sizeof(LVITEM));

    ih.pszText = lvi.pszText = text;
    ih.cchTextMax = lvi.cchTextMax = 32767;

    for (pass = 0; pass < 2; ++pass)
    {
        total_length = 0;

        for (i = 0; i < icount; ++i)
        {
            for (c = 0; c < col_count; ++c)
            {
                text[0] = L'\0';
                if (i == 0)
                {
                    ih.mask = HDI_TEXT | HDI_ORDER;
                    ih.iOrder = c;
                    Header_GetItem(hdr, c, &ih);
                }
                else
                {
                    lvi.mask = LVIF_TEXT;
                    lvi.iItem = i - 1;
                    lvi.iSubItem = c;
                    ListView_GetItem(List, &lvi);
                }
                total_length += supxEscStrlen(text) + 1;

                if (buffer)
                {
                    buffer = supxEscStrcpy(buffer, text);
                    if (c != col_count - 1)
                    {
                        *(buffer++) = L',';
                    }
                    else
                    {
                        *(buffer++) = L'\r';
                        *(buffer++) = L'\n';
                    }
                }
            }
            ++total_length;
        }

        if (buffer0 == NULL)
        {
            buffer0 = (PWCHAR)supVirtualAlloc((1 + total_length) * sizeof(WCHAR),
                MEM_COMMIT | MEM_RESERVE,
                PAGE_READWRITE);

            if (!buffer0)
                break;
        }
        else
        {
            hFile = CreateFile(FileName,
                GENERIC_WRITE | SYNCHRONIZE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                WriteFile(hFile,
                    buffer0,
                    (DWORD)(total_length * sizeof(WCHAR)),
                    &iobytes, NULL);

                CloseHandle(hFile);
                result = TRUE;
            }
            supVirtualFree(buffer0);
        }
        buffer = buffer0;
    }

    supVirtualFree(text);
    return result;
}

/*
* supSaveDialogExecute
*
* Purpose:
*
* Display SaveDialog.
*
*/
BOOL supSaveDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR SaveFileName,
    _In_ LPCWSTR DialogFilter
)
{
    OPENFILENAME tag1;

    RtlSecureZeroMemory(&tag1, sizeof(OPENFILENAME));

    tag1.lStructSize = sizeof(OPENFILENAME);
    tag1.hwndOwner = OwnerWindow;
    tag1.lpstrFilter = DialogFilter;
    tag1.lpstrFile = SaveFileName;
    tag1.nMaxFile = MAX_PATH;
    tag1.lpstrInitialDir = NULL;
    tag1.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    return GetSaveFileName(&tag1);
}

/*
* supSetWaitCursor
*
* Purpose:
*
* Sets cursor state.
*
*/
VOID supSetWaitCursor(
    _In_ BOOL fSet
)
{
    ShowCursor(fSet);
    SetCursor(LoadCursor(NULL, fSet ? IDC_WAIT : IDC_ARROW));
}

/*
* supListViewExportToFile
*
* Purpose:
*
* Export listview contents to the specified file.
*
*/
BOOL supListViewExportToFile(
    _In_ LPCWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView
)
{
    BOOL bResult = FALSE;
    WCHAR szExportFileName[MAX_PATH + 1];

    RtlSecureZeroMemory(&szExportFileName, sizeof(szExportFileName));

    _strcpy(szExportFileName, FileName);
    if (supSaveDialogExecute(WindowHandle,
        (LPWSTR)&szExportFileName,
        T_CSV_FILE_FILTER))
    {
        SetCapture(WindowHandle);
        supSetWaitCursor(TRUE);

        bResult = supxListViewExportCSV(ListView, szExportFileName);

        supSetWaitCursor(FALSE);
        ReleaseCapture();
    }

    return bResult;
}

/*
* supGetMappedFileName
*
* Purpose:
*
* Returns the name of the memory-mapped file if possible.
*
*/
NTSTATUS supGetMappedFileName(
    _In_ PVOID lpAddress,
    _Out_ POBJECT_NAME_INFORMATION* ObjectNameInformation
)
{
    NTSTATUS ntStatus;
    SIZE_T returnedLength = 0;
    POBJECT_NAME_INFORMATION objectNameInfo = NULL;

    do {
        ntStatus = NtQueryVirtualMemory(
            NtCurrentProcess(),
            lpAddress,
            MemoryMappedFilenameInformation,
            NULL,
            0,
            &returnedLength);

        if (ntStatus != STATUS_INFO_LENGTH_MISMATCH)
            break;

        objectNameInfo = (OBJECT_NAME_INFORMATION*)supHeapAlloc(returnedLength);
        if (objectNameInfo == NULL)
            break;

        ntStatus = NtQueryVirtualMemory(
            NtCurrentProcess(),
            lpAddress,
            MemoryMappedFilenameInformation,
            objectNameInfo,
            returnedLength,
            &returnedLength);

    } while (FALSE);

    *ObjectNameInformation = objectNameInfo;

    return ntStatus;
}

/*
* supGetConsoleHostForSelf
*
* Purpose:
*
* Return process console host pid.
*
*/
NTSTATUS supGetConsoleHostForSelf(
    _Out_ PHANDLE ConsoleHostId)
{
    ULONG returnLength;
    return NtQueryInformationProcess(NtCurrentProcess(),
        ProcessConsoleHostProcess,
        (PVOID)ConsoleHostId,
        sizeof(HANDLE),
        &returnLength);
}

/*
* supQueryImageInformation
*
* Purpose:
*
* Returns ImageBase/SizeOfImage for the given address if there is any image.
*
*/
NTSTATUS supQueryImageInformation(
    _In_ PVOID Address,
    _Out_ PVOID* ImageBase,
    _Out_ PSIZE_T SizeOfImage
)
{
    NTSTATUS ntStatus;
    SIZE_T memIO;
    MEMORY_IMAGE_INFORMATION mim;

    *ImageBase = NULL;
    *SizeOfImage = 0;

    ntStatus = NtQueryVirtualMemory(NtCurrentProcess(),
        Address,
        MemoryImageInformation,
        &mim,
        sizeof(MEMORY_IMAGE_INFORMATION),
        &memIO);

    if (NT_SUCCESS(ntStatus)) {
        *ImageBase = mim.ImageBase;
        *SizeOfImage = mim.SizeOfImage;
    }

    return ntStatus;
}

/*
* supQueryThreadStartAddress
*
* Purpose:
*
* Returns system and win32 thread entry points.
*
*/
NTSTATUS supQueryThreadStartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ SUP_THREAD_INFO* ThreadInformation
)
{
    NTSTATUS ntStatus;
    ULONG returnLength;
    PVOID threadStartAddress = NULL;
    SYSTEM_THREAD_INFORMATION sti;

    ntStatus = NtQueryInformationThread(ThreadHandle,
        ThreadSystemThreadInformation, &sti, sizeof(sti), &returnLength);

    ntStatus |= NtQueryInformationThread(ThreadHandle,
        ThreadQuerySetWin32StartAddress, &threadStartAddress, sizeof(threadStartAddress), &returnLength);

    ThreadInformation->StartAddress = sti.StartAddress;
    ThreadInformation->Win32StartAddress = threadStartAddress;

    return ntStatus;
}

/*
* supQueryThreadInstructionPointer
*
* Purpose:
*
* Return thread context rip.
*
*/
NTSTATUS supQueryThreadInstructionPointer(
    _In_ HANDLE Threadhandle,
    _Out_ PDWORD64 InstructionPointer
)
{
    CONTEXT threadCtx;
    NTSTATUS ntStatus;

    RtlSecureZeroMemory(&threadCtx, sizeof(threadCtx));
    threadCtx.ContextFlags = CONTEXT_CONTROL;

    ntStatus = NtGetContextThread(Threadhandle, &threadCtx);

    if (NT_SUCCESS(ntStatus))
        *InstructionPointer = threadCtx.Rip;
    else
        *InstructionPointer = 0;

    return ntStatus;
}

/*
*
* NT STUBS
*
*/

PUSH_DISABLE_WARNING(6387)

NTSTUB_ROUTINE(supStubNtQueryInformationProcess)
{
    ULONG returnLength;

    return NtQueryInformationProcess(NtCurrentProcess(),
        ProcessBasicInformation, NULL, 0, &returnLength);
}

NTSTUB_ROUTINE(supStubNtQueryInformationThread)
{
    ULONG returnLength;

    return NtQueryInformationThread(NtCurrentThread(),
        ThreadBasicInformation, NULL, 0, &returnLength);
}

NTSTUB_ROUTINE(supStubNtQuerySystemInformation)
{
    ULONG returnLength;

    return NtQuerySystemInformation(SystemBasicInformation,
        NULL, 0, &returnLength);
}

NTSTUB_ROUTINE(supStubNtSetInformationThread)
{
    return NtSetInformationThread(0,
        ThreadAffinityMask, NULL, 0);
}

NTSTUB_ROUTINE(supStubNtSetInformationProcess)
{
    return NtSetInformationProcess(NtCurrentProcess(),
        ProcessAffinityMask, NULL, 0);
}

NTSTUB_ROUTINE(supStubNtGetContextThread)
{
    return NtGetContextThread(NtCurrentThread(),
        NULL);
}

NTSTUB_ROUTINE(supStubNtSetContextThread)
{
    return NtSetContextThread(NtCurrentThread(),
        NULL);
}

NTSTUB_ROUTINE(supStubNtClose)
{
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent)
        return NtClose(hEvent);
    return STATUS_UNSUCCESSFUL;
}

NTSTUB_ROUTINE(supStubNtDuplicateObject)
{
    return NtDuplicateObject(NtCurrentProcess(),
        NULL,
        NtCurrentProcess(),
        NULL,
        MAXIMUM_ALLOWED,
        0,
        DUPLICATE_SAME_ACCESS);
}

NTSTUB_ROUTINE(supStubNtQueryObject)
{
    ULONG returnLength;

    return NtQueryObject(NtCurrentProcess(),
        ObjectBasicInformation,
        NULL,
        0,
        &returnLength);
}

NTSTUB_ROUTINE(supStubNtOpenFile)
{
    return NtOpenFile(NULL,
        GENERIC_ALL,
        NULL,
        NULL,
        0,
        0);
}

NTSTUB_ROUTINE(supStubNtCreateSection)
{
    return NtCreateSection(NULL,
        0,
        NULL,
        NULL,
        0,
        0,
        NULL);
}

NTSTUB_ROUTINE(supStubNtMapViewOfSection)
{
    return NtMapViewOfSection(NULL,
        NULL,
        NULL,
        0,
        0,
        NULL,
        NULL,
        ViewShare,
        0,
        0);
}

NTSTUB_ROUTINE(supStubNtQueryVirtualMemory)
{
    SIZE_T returnLength;

    return NtQueryVirtualMemory(NULL,
        NULL,
        MemoryBasicInformation,
        NULL,
        0,
        &returnLength);
}

NTSTUB_ROUTINE(supStubNtContinue)
{
    return NtContinue(NULL, FALSE);
}

NTSTUB_ROUTINE(supStubNtResumeThread)
{
    return NtResumeThread(NULL, NULL);
}

NTSTUB_ROUTINE(supStubNtCreateThreadEx)
{
    return NtCreateThreadEx(NULL,
        0,
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        0,
        0,
        0,
        NULL);
}

NTSTUB_ROUTINE(supStubNtQueryPerformanceCounter)
{
    return NtQueryPerformanceCounter(NULL, NULL);
}

POP_DISABLE_WARNING(6387)

SUP_NTSTUB supNtStubs[] = {
    {"NtQueryInformationProcess", supStubNtQueryInformationProcess },
    {"NtQueryInformationThread", supStubNtQueryInformationThread },
    {"NtQuerySystemInformation", supStubNtQuerySystemInformation },
    {"NtSetInformationThread", supStubNtSetInformationThread },
    {"NtSetInformationProcess", supStubNtSetInformationProcess },
    {"NtGetContextThread", supStubNtGetContextThread },
    {"NtSetContextThread", supStubNtSetContextThread },
    {"NtClose", supStubNtClose },
    {"NtDuplicateObject", supStubNtDuplicateObject },
    {"NtQueryObject", supStubNtQueryObject },
    {"NtOpenFile", supStubNtOpenFile },
    {"NtCreateSection", supStubNtCreateSection },
    {"NtMapViewOfSection", supStubNtMapViewOfSection },
    {"NtQueryVirtualMemory", supStubNtQueryVirtualMemory },
    {"NtContinue", supStubNtContinue },
    {"NtResumeThread", supStubNtResumeThread },
    {"NtCreateThreadEx", supStubNtCreateThreadEx },
    {"NtQueryPerformanceCounter", supStubNtQueryPerformanceCounter }
};

/*
* supGetNtStubByName
*
* Purpose:
*
* Return stub by name.
*
*/
PVOID supGetNtStubByName(
    _In_ LPCSTR lpName)
{
    ULONG i;

    for (i = 0; i < RTL_NUMBER_OF(supNtStubs); i++)
        if (_strcmpi_a(supNtStubs[i].Name, lpName) == 0)
            return supNtStubs[i].Stub;

    return NULL;
}

/*
* supInitializeKnownSids
*
* Purpose:
*
* Create some well-known sids.
*
*/
NTSTATUS supInitializeKnownSids()
{
    NTSTATUS ntStatus;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;

    ntStatus = RtlInitializeSid(&gLocalSystemSid, &NtAuth, 1);
    if (NT_SUCCESS(ntStatus)) {

        *RtlSubAuthoritySid(&gLocalSystemSid, 0) = SECURITY_LOCAL_SYSTEM_RID;

        ntStatus = RtlInitializeSid(&gAdminsGroupSid, &NtAuth, 2);
        if (NT_SUCCESS(ntStatus)) {

            *RtlSubAuthoritySid(&gAdminsGroupSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
            *RtlSubAuthoritySid(&gAdminsGroupSid, 1) = DOMAIN_ALIAS_RID_ADMINS;

            ntStatus = RtlInitializeSid(&gTrustedInstallerSid, &NtAuth, SECURITY_SERVICE_ID_RID_COUNT);
            if (NT_SUCCESS(ntStatus)) {

                //
                // Trusted Installer SID 956008885-3418522649-1831038044-1853292631-2271478464
                //
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 0) = SECURITY_SERVICE_ID_BASE_RID;
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 1) = 956008885;
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 2) = 3418522649;
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 3) = 1831038044;
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 4) = 1853292631;
                *RtlSubAuthoritySid(&gTrustedInstallerSid, 5) = 2271478464;

            }
        }
    }

    return ntStatus;
}

/*
* supLookupEntryInKnownDllsCache
*
* Purpose:
*
* Find cached entry.
*
*/
BOOL supLookupEntryInKnownDllsCache(
    _In_ PUNICODE_STRING LookupName,
    _In_ PUNICODE_STRING LookupType
)
{
    PLIST_ENTRY nextEntry;
    PSUP_KNOWNDLLS_ENTRY dllEntry;
    ULONG nameHash, typeHash;

    RtlHashUnicodeString(LookupName, FALSE, HASH_STRING_ALGORITHM_X65599, &nameHash);
    RtlHashUnicodeString(LookupType, FALSE, HASH_STRING_ALGORITHM_X65599, &typeHash);

    for (nextEntry = gKnownDllsHead.Flink;
        nextEntry != &gKnownDllsHead;
        nextEntry = nextEntry->Flink)
    {
        dllEntry = CONTAINING_RECORD(nextEntry, SUP_KNOWNDLLS_ENTRY, ListEntry);
        if (dllEntry->NameHash == nameHash &&
            dllEntry->TypeHash == typeHash)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*
* supCacheKnownDllsEntries
*
* Purpose:
*
* Create cache for KnownDlls directory entries.
*
*/
VOID supCacheKnownDllsEntries()
{
    NTSTATUS ntStatus;
    ULONG ctx, returnLength;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    HANDLE hDirectory = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING us;
    SUP_KNOWNDLLS_ENTRY* pEntry;

    InitializeListHead(&gKnownDllsHead);
    RtlInitUnicodeString(&us, DIRECTORY_KNOWNDLLS);
    InitializeObjectAttributes(&obja, &us, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ntStatus = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &obja);

    if (NT_SUCCESS(ntStatus)) {

        ctx = 0;
        do {

            returnLength = 0;
            ntStatus = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &returnLength);
            if (ntStatus != STATUS_BUFFER_TOO_SMALL)
                break;

            pDirInfo = (POBJECT_DIRECTORY_INFORMATION)supHeapAlloc(returnLength);
            if (pDirInfo == NULL)
                break;

            ntStatus = NtQueryDirectoryObject(hDirectory, pDirInfo, returnLength, TRUE, FALSE, &ctx, &returnLength);
            if (!NT_SUCCESS(ntStatus)) {
                supHeapFree(pDirInfo);
                break;
            }

            pEntry = (PSUP_KNOWNDLLS_ENTRY)supHeapAlloc(sizeof(SUP_KNOWNDLLS_ENTRY));
            if (pEntry) {

                RtlHashUnicodeString(&pDirInfo->Name, FALSE, HASH_STRING_ALGORITHM_X65599, &pEntry->NameHash);
                RtlHashUnicodeString(&pDirInfo->TypeName, FALSE, HASH_STRING_ALGORITHM_X65599, &pEntry->TypeHash);
                InsertTailList(&gKnownDllsHead, &pEntry->ListEntry);

            }
            supHeapFree(pDirInfo);

        } while (TRUE);

        NtClose(hDirectory);
    }
}

/*
* supMapImageNoExecute
*
* Purpose:
*
* Map image with SEC_IMAGE_NO_EXECUTE.
*
*/
NTSTATUS supMapImageNoExecute(
    _In_ PUNICODE_STRING ImagePath,
    _Out_ PVOID* BaseAddress
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    SIZE_T fileSize = 0;
    HANDLE hFile = NULL, hSection = NULL;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iost;
    LARGE_INTEGER li;

    *BaseAddress = NULL;

    do {

        InitializeObjectAttributes(&obja, ImagePath,
            OBJ_CASE_INSENSITIVE, NULL, NULL);

        RtlSecureZeroMemory(&iost, sizeof(iost));
        ntStatus = NtCreateFile(&hFile,
            SYNCHRONIZE | FILE_READ_DATA,
            &obja,
            &iost,
            NULL,
            0,
            FILE_SHARE_READ,
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
            NULL,
            0);

        if (!NT_SUCCESS(ntStatus))
            break;

        obja.ObjectName = NULL;

        ntStatus = NtCreateSection(&hSection,
            SECTION_MAP_READ,
            &obja,
            NULL,
            PAGE_READONLY,
            SEC_IMAGE_NO_EXECUTE,
            hFile);

        if (!NT_SUCCESS(ntStatus))
            break;

        li.QuadPart = 0;

        ntStatus = NtMapViewOfSection(hSection,
            NtCurrentProcess(),
            BaseAddress,
            0,
            0,
            &li,
            &fileSize,
            ViewShare,
            0,
            PAGE_READONLY);

        if (!NT_SUCCESS(ntStatus))
            break;

    } while (FALSE);

    if (hFile) NtClose(hFile);
    if (hSection) NtClose(hSection);
    return ntStatus;
}

/*
* supQueryNtOsInformation
*
* Purpose:
*
* Map ntoskrnl and query NtBuildNumber value.
*
*/
NTSTATUS supQueryNtOsInformation(
    _Out_ PULONG BuildNumber,
    _Out_opt_ PVOID* MappedNtOs
)
{
    PVOID Ptr;
    NTSTATUS ntStatus;
    PVOID baseAddress = NULL;
    UNICODE_STRING us;

    *BuildNumber = 0;
    if (ARGUMENT_PRESENT(MappedNtOs))
        *MappedNtOs = NULL;

    RtlInitUnicodeStringEx(&us, L"\\systemroot\\system32\\ntoskrnl.exe");
    ntStatus = supMapImageNoExecute(&us, &baseAddress);

    if (NT_SUCCESS(ntStatus)) {

        {
            PUSH_DISABLE_WARNING(4054)
                Ptr = (PVOID)supLdrGetProcAddressEx(baseAddress, "NtBuildNumber");
            POP_DISABLE_WARNING(4054)
        }

        if (Ptr) {
            *BuildNumber = (*(PULONG)Ptr & 0xffff);

            if (ARGUMENT_PRESENT(MappedNtOs))
                *MappedNtOs = baseAddress;

            ntStatus = STATUS_SUCCESS;
        }
        else {
            ntStatus = STATUS_INVALID_USER_BUFFER;
        }

    }

    return ntStatus;
}

/*
* supIsFileOwnedByTrustedInstallerSystemOrAdmins
*
* Purpose:
*
* Check whatever file is owner by TI/LocalSystem or Admins group.
*
*/
NTSTATUS supIsFileOwnedByTrustedInstallerSystemOrAdmins(
    _In_ KPROCESSOR_MODE Mode,
    _In_ HANDLE hFile,
    _In_ PUNICODE_STRING pusName
)
{
    NTSTATUS ntStatus;
    ULONG dummy;
    PSID ownerSid;

    union {
        SECURITY_DESCRIPTOR_RELATIVE RelativeSid;
        SECURITY_DESCRIPTOR AbsoluteSid;
        BYTE Buffer[256];
    } OwnerData;

    ntStatus = NtQuerySecurityObject(hFile,
        OWNER_SECURITY_INFORMATION,
        &OwnerData.AbsoluteSid,
        sizeof(OwnerData),
        &dummy);

    if (NT_SUCCESS(ntStatus)) {

        ownerSid = OwnerData.RelativeSid.Control & SE_SELF_RELATIVE ?
            &OwnerData.Buffer[OwnerData.RelativeSid.Owner] : OwnerData.AbsoluteSid.Owner;

        if (RtlEqualSid(ownerSid, &gTrustedInstallerSid))
            return STATUS_SUCCESS;

        if (Mode == UserMode) {

            //
            // Check if this module is in KnownDlls, if so its fucked.
            //

            PWCH p, pp = NULL;
            UNICODE_STRING usBaseFileName, usTypeName;

            p = pusName->Buffer;
            while (*p) {
                if (*p++ == (WCHAR)'\\') {
                    pp = p;
                }
            }

            RtlInitUnicodeString(&usBaseFileName, pp);
            RtlInitUnicodeString(&usTypeName, L"Section");

            BOOL cacheHit = supLookupEntryInKnownDllsCache(&usBaseFileName, &usTypeName);
            if (cacheHit)
                return STATUS_INVALID_IMAGE_HASH;

        }

        //
        // 3rd party code is often not owned by TI, nor LocalSystem, exclude to avoid mass fp's.
        //

        if (RtlEqualSid(ownerSid, &gLocalSystemSid))
            return STATUS_SUCCESS;
        if (RtlEqualSid(ownerSid, &gAdminsGroupSid))
            return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}

/*
* supProcessEntryByProcessId
*
* Purpose:
*
* Find corresponding process entry in a list.
*
*/
PVOID supProcessEntryByProcessId(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList
)
{
    ULONG nextEntryDelta = 0;

    union {
        PSYSTEM_PROCESS_INFORMATION Processes;
        PBYTE ListRef;
    } NativeList;

    NativeList.ListRef = (PBYTE)ProcessList;

    do {

        NativeList.ListRef += nextEntryDelta;

        if (UniqueProcessId == NativeList.Processes->UniqueProcessId) {
            return NativeList.Processes;
        }

        nextEntryDelta = NativeList.Processes->NextEntryDelta;

    } while (nextEntryDelta);

    return NULL;
}

/*
* supThreadToProcessEntry
*
* Purpose:
*
* Find corresponding process entry in a list by thread id.
*
*/
BOOL supThreadToProcessEntry(
    _In_ PVOID ProcessList,
    _In_ HANDLE ThreadId,
    _Out_ PSYSTEM_PROCESS_INFORMATION* ProcessListEntry
)
{
    ULONG nextEntryDelta = 0, i;
    PSYSTEM_PROCESS_INFORMATION entry;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } NativeList;

    *ProcessListEntry = NULL;

    NativeList.ListRef = (PBYTE)ProcessList;

    do {

        NativeList.ListRef += nextEntryDelta;
        entry = NativeList.Process;

        for (i = 0; i < entry->ThreadCount; i++) {
            if (entry->Threads[i].ClientId.UniqueThread == ThreadId) {
                *ProcessListEntry = entry;
                return TRUE;
            }
        }

        nextEntryDelta = NativeList.Process->NextEntryDelta;

    } while (nextEntryDelta);

    return FALSE;
}

/*
* supThreadToProcessHandle
*
* Purpose:
*
* Return process id for given thread.
*
*/
NTSTATUS supThreadToProcessHandle(
    _In_ HANDLE ThreadId,
    _Out_ PHANDLE ProcessId
)
{
    NTSTATUS ntStatus;
    HANDLE hThread = NULL;
    OBJECT_ATTRIBUTES obja;
    CLIENT_ID cid;
    THREAD_BASIC_INFORMATION tbi;
    ULONG returnLength;

    *ProcessId = NULL;

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
    cid.UniqueProcess = NULL;
    cid.UniqueThread = ThreadId;

    ntStatus = NtOpenThread(&hThread,
        THREAD_QUERY_LIMITED_INFORMATION, &obja, &cid);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtQueryInformationThread(hThread, ThreadBasicInformation, &tbi,
            sizeof(THREAD_BASIC_INFORMATION), &returnLength);

        if (NT_SUCCESS(ntStatus)) {
            *ProcessId = tbi.ClientId.UniqueProcess;
        }

        NtClose(hThread);
    }

    return ntStatus;
}

/*
* supIsProcessRunning
*
* Purpose:
*
* Return TRUE is given process respond.
*
*/
BOOL supIsProcessRunning(
    _In_ HANDLE ProcessId
)
{
    NTSTATUS ntStatus;
    DWORD ret = 0;
    HANDLE hProcess = NULL;
    OBJECT_ATTRIBUTES obja;
    CLIENT_ID cid;

    cid.UniqueProcess = ProcessId;
    cid.UniqueThread = 0;

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

    ntStatus = NtOpenProcess(&hProcess, SYNCHRONIZE, &obja, &cid);
    if (ntStatus == STATUS_ACCESS_DENIED) {
        return TRUE;
    }
    else {
        if (hProcess != NULL) {
            ret = WaitForSingleObject(hProcess, 0);
            NtClose(hProcess);
        }
    }
    return (BOOL)(ret == WAIT_TIMEOUT);
}

/*
* supIsProcessElevated
*
* Purpose:
*
* Returns process elevation state.
*
*/
NTSTATUS supIsProcessElevated(
    _In_ HANDLE ProcessId,
    _Out_ PBOOL Elevated)
{
    NTSTATUS ntStatus;
    ULONG returnedLength;
    HANDLE processHandle = NULL, tokenHandle = NULL;
    TOKEN_ELEVATION tokenInfo;
    CLIENT_ID cid;
    OBJECT_ATTRIBUTES obja;

    if (Elevated) *Elevated = FALSE;

    cid.UniqueProcess = ProcessId;
    cid.UniqueThread = 0;
    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
    ntStatus = NtOpenProcess(&processHandle,
        MAXIMUM_ALLOWED, &obja, &cid);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtOpenProcessToken(processHandle, TOKEN_QUERY, &tokenHandle);
        if (NT_SUCCESS(ntStatus)) {

            tokenInfo.TokenIsElevated = 0;
            ntStatus = NtQueryInformationToken(
                tokenHandle,
                TokenElevation,
                &tokenInfo,
                sizeof(TOKEN_ELEVATION),
                &returnedLength);

            if (NT_SUCCESS(ntStatus)) {

                if (Elevated)
                    *Elevated = (tokenInfo.TokenIsElevated > 0);

            }

            NtClose(tokenHandle);
        }
        NtClose(processHandle);
    }

    return ntStatus;
}

/*
* supCICustomKernelSignersAllowed
*
* Purpose:
*
* Return license state if present (EnterpriseG).
*
*/
NTSTATUS supCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed)
{
    NTSTATUS Status;
    ULONG Result = 0, DataSize;
    UNICODE_STRING usLicenseValue;

    *bAllowed = FALSE;

    RtlInitUnicodeString(&usLicenseValue, L"CodeIntegrity-AllowConfigurablePolicy-CustomKernelSigners");
    Status = NtQueryLicenseValue(&usLicenseValue,
        NULL,
        (PVOID)&Result,
        sizeof(DWORD),
        &DataSize);

    if (NT_SUCCESS(Status)) {
        *bAllowed = (Result != 0);
    }
    return Status;
}

/*
* supQuerySystemRangeStart
*
* Purpose:
*
* Return MmSystemRangeStart value.
*
*/
ULONG_PTR supQuerySystemRangeStart(
    VOID
)
{
    NTSTATUS ntStatus;
    ULONG_PTR systemRangeStart = 0;
    ULONG memIO = 0;

    ntStatus = NtQuerySystemInformation(
        SystemRangeStartInformation,
        (PVOID)&systemRangeStart,
        sizeof(ULONG_PTR),
        &memIO);

    if (!NT_SUCCESS(ntStatus)) {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }
    return systemRangeStart;
}

/*
* supSetMitigationPolicies
*
* Purpose:
*
* Set runtime mitigation policies for process.
*
*/
VOID supSetMitigationPolicies()
{
    PROCESS_MITIGATION_POLICY_INFORMATION policyInfo;

    policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessExtensionPointDisablePolicy;
    policyInfo.ExtensionPointDisablePolicy.Flags = 0;
    policyInfo.ExtensionPointDisablePolicy.DisableExtensionPoints = TRUE;
    NtSetInformationProcess(NtCurrentProcess(),
        ProcessMitigationPolicy,
        &policyInfo,
        sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessASLRPolicy;
    policyInfo.ASLRPolicy.Flags = 0;
    policyInfo.ASLRPolicy.EnableHighEntropy = TRUE;
    policyInfo.ASLRPolicy.EnableBottomUpRandomization = TRUE;
    policyInfo.ASLRPolicy.EnableForceRelocateImages = TRUE;
    NtSetInformationProcess(NtCurrentProcess(),
        ProcessMitigationPolicy,
        &policyInfo,
        sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessSignaturePolicy;
    policyInfo.SignaturePolicy.Flags = 0;
    policyInfo.SignaturePolicy.MicrosoftSignedOnly = TRUE;
    policyInfo.SignaturePolicy.MitigationOptIn = 1;
    NtSetInformationProcess(NtCurrentProcess(),
        ProcessMitigationPolicy,
        &policyInfo,
        sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessImageLoadPolicy;
    policyInfo.ImageLoadPolicy.Flags = 0;
    policyInfo.ImageLoadPolicy.PreferSystem32Images = TRUE;
    policyInfo.ImageLoadPolicy.NoRemoteImages = TRUE;
    policyInfo.ImageLoadPolicy.NoLowMandatoryLabelImages = TRUE;
    NtSetInformationProcess(NtCurrentProcess(),
        ProcessMitigationPolicy,
        &policyInfo,
        sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessFontDisablePolicy;
    policyInfo.FontDisablePolicy.Flags = 0;
    policyInfo.FontDisablePolicy.DisableNonSystemFonts = TRUE;
    NtSetInformationProcess(NtCurrentProcess(),
        ProcessMitigationPolicy,
        &policyInfo,
        sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));
}

```

`Source/sup.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       SUP.H
*
*  VERSION:     1.00
*
*  DATE:        01 Jul 2023
*
*  Common header file for the program support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define INVALID_SYSCALL_ID (DWORD)MAXDWORD
#define ICON_FIRST IDI_ICON_MAIN
#define ICON_LAST IDI_ICON_CHECK_WARNING

typedef enum _DR_EVENT_TYPE {
    evtInformation = 0,
    evtError,
    evtWarning,
    evtDetection,
    evtCheckPassed
} DR_EVENT_TYPE;

typedef enum _NTDLL_MAP_METHOD {
    UseAbsolutePath = 0,
    UseRelativePath,
    UseKnownDllsAbsolute,
    UseKnownDllsRelative,
    UseLdrKnownDllDirectoryHandle,
    MapMethodMax
} NTDLL_MAP_METHOD;

typedef enum _SSN_EXTRACT_METHOD {
    SsnInstructionScan,
    SsnSortedScan,
    SsnRuntimeScan,
    SsnThreadInformation
} SSN_EXTRACT_METHOD;

typedef enum _DBG_CHECK_METHOD {
    CheckDrXReg,
    CheckDebugObjectHandle,
    CheckDebugPort,
    CheckDebugFlags,
    CheckUSD
} DBG_CHECK_METHOD;

typedef VOID(NTAPI* PFEFN)();

//
// Ripped from vmprotect with brave and courage.
//

typedef enum _KNOWN_BUILD_NUMBER {
    WINDOWS_7 = 7600,
    WINDOWS_7_SP1 = 7601,
    WINDOWS_8 = 9200,
    WINDOWS_8_1 = 9600,
    WINDOWS_10_TH1 = 10240,
    WINDOWS_10_TH2 = 10586,
    WINDOWS_10_RS1 = 14393,
    WINDOWS_10_RS2 = 15063,
    WINDOWS_10_RS3 = 16299,
    WINDOWS_10_RS4 = 17134,
    WINDOWS_10_RS5 = 17763,
    WINDOWS_10_19H1 = 18362,
    WINDOWS_10_19H2 = 18363,
    WINDOWS_10_20H1 = 19041,
    WINDOWS_10_20H2 = 19042,
    WINDOWS_10_21H1 = 19043,
    WINDOWS_10_21H2 = 19044,
    WINDOWS_10_22H2 = 19045,
    WINDOWS_11_21H2 = 22000,
    WINDOWS_11_22H2 = 22621
} KNOWN_BUILD_NUMBER;

#define IS_KNOWN_WINDOWS_BUILD(b) ( \
                                    (b) == WINDOWS_7 || \
                                    (b) == WINDOWS_7_SP1 || \
                                    (b) == WINDOWS_8 || \
                                    (b) == WINDOWS_8_1 || \
                                    (b) == WINDOWS_10_TH1 || \
                                    (b) == WINDOWS_10_TH2 || \
                                    (b) == WINDOWS_10_RS1 || \
                                    (b) == WINDOWS_10_RS2 || \
                                    (b) == WINDOWS_10_RS3 || \
                                    (b) == WINDOWS_10_RS4 || \
                                    (b) == WINDOWS_10_RS5 || \
                                    (b) == WINDOWS_10_19H1 || \
                                    (b) == WINDOWS_10_19H2 || \
                                    (b) == WINDOWS_10_20H1 || \
                                    (b) == WINDOWS_10_20H2 || \
                                    (b) == WINDOWS_10_21H1 || \
                                    (b) == WINDOWS_10_21H2 || \
                                    (b) == WINDOWS_10_22H2 \
                                  )

//
// End of rip.
//

#define IS_WIN10_FEATURE_PACK_RANGE(b) ((b) >= WINDOWS_10_20H1 && (b) <= WINDOWS_10_22H2) //fake versions (all based on 19041)

typedef enum _SIGNATURE_INFO_TYPE {
    SIT_UNKNOWN = 0x0,
    SIT_AUTHENTICODE = 0x1,
    SIT_CATALOG = 0x2
} SIGNATURE_INFO_TYPE;

#define SIF_AUTHENTICODE_SIGNED 0x1
#define SIF_CATALOG_SIGNED      0x2
#define SIF_VERSION_INFO        0x4
#define SIF_CHECK_OS_BINARY     0x800
#define SIF_BASE_VERIFICATION   0x1000
#define SIF_CATALOG_FIRST       0x2000
#define SIF_MOTW                0x4000

typedef enum _SIGNATURE_STATE {
    SIGNATURE_STATE_UNSIGNED_MISSING = 0x0,
    SIGNATURE_STATE_UNSIGNED_UNSUPPORTED = 0x1,
    SIGNATURE_STATE_UNSIGNED_POLICY = 0x2,
    SIGNATURE_STATE_INVALID_CORRUPT = 0x3,
    SIGNATURE_STATE_INVALID_POLICY = 0x4,
    SIGNATURE_STATE_VALID = 0x5,
    SIGNATURE_STATE_TRUSTED = 0x6,
    SIGNATURE_STATE_UNTRUSTED = 0x7,
} SIGNATURE_STATE;

typedef enum _SIGNATURE_INFO_AVAILABILITY {
    SIA_DISPLAYNAME = 1,
    SIA_PUBLISHERNAME = 2,
    SIA_MOREINFOURL = 4,
    SIA_HASH = 8,
    SIA_PRODUCTVERSION = 16
} SIGNATURE_INFO_AVAILABILITY;

typedef struct _SIGNATURE_INFO {
    DWORD cbSize;
    SIGNATURE_STATE SignatureState;
    SIGNATURE_INFO_TYPE SignatureType;
    DWORD dwSignatureInfoAvailability;
    DWORD dwInfoAvailability;
    PWSTR pszDisplayName;
    DWORD cchDisplayName;
    PWSTR pszPublisherName;
    DWORD cchPublisherName;
    PWSTR pszMoreInfoURL;
    DWORD cchMoreInfoURL;
    LPBYTE prgbHash;
    DWORD cbHash;
    BOOL fOSBinary; //True if the item is signed as part of an operating system release
} SIGNATURE_INFO, * PSIGNATURE_INFO;

typedef LONG(WINAPI* ptrWTGetSignatureInfo)(
    LPWSTR pszFile,
    HANDLE hFile,
    ULONG sigInfoFlags, //SIF_*
    SIGNATURE_INFO* siginfo,
    VOID* ppCertContext,
    VOID* phWVTStateData
    );

typedef struct _SUP_THREAD_INFO {
    PVOID StartAddress;
    PVOID Win32StartAddress;
} SUP_THREAD_INFO, * PSUP_THREAD_INFO;

typedef struct _LVCOLUMNS_DATA {
    LPWSTR Name;
    INT Width;
    INT Format;
    INT ImageIndex;
} LVCOLUMNS_DATA, * PLVCOLUMNS_DATA;

typedef struct _EXPORT_NODE {
    CHAR Name[256];
    ULONG_PTR Address;
    struct _EXPORT_NODE* Next;
} EXPORT_NODE, * PEXPORT_NODE;

typedef struct _NTCALL_THREAD_CONTEXT {
    TEB_ACTIVE_FRAME Frame;
    ULONG SystemCallNumber;
    ULONG_PTR SystemCallAddress;
} NTCALL_THREAD_CONTEXT, * PNTCALL_THREAD_CONTEXT;

typedef struct _OBJSCANPARAM {
    PCWSTR Buffer;
    ULONG BufferSize;
} OBJSCANPARAM, * POBJSCANPARAM;

#define NTSTUB_ROUTINE(n) NTSTATUS NTAPI n()

typedef NTSTATUS(NTAPI* PNTSTUBFN)();

typedef struct _SUP_NTSTUB {
    LPCSTR Name;
    PNTSTUBFN Stub;
} SUP_NTSTUB, * PSUB_NTSTUB;

typedef NTSTATUS(NTAPI* PENUMOBJECTSCALLBACK)(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_opt_ PVOID CallbackParam);

#define NTQSI_MAX_BUFFER_LENGTH (512 * 1024 * 1024)

#define supHeapAlloc(Size) RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, HEAP_ZERO_MEMORY, Size)
#define supHeapFree(BaseAddress) RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, BaseAddress);

VOID supRunAsAdmin(
    VOID);

BOOL supWriteConfiguration(
    _In_ struct _PROBE_SETTINGS *Settings);

BOOL supReadConfiguration(
    _Out_ struct _PROBE_SETTINGS *Settings);

VOID supSetMitigationPolicies();

VOID supStatusBarSetText(
    _In_ HWND StatusBar,
    _In_ WPARAM Index,
    _In_ LPCWSTR Text);

VOID supReportEventEx(
    _In_ DR_EVENT_TYPE EventType,
    _In_ LPWSTR lpEvent,
    _In_opt_ LPWSTR lpDescription,
    _In_opt_ LPWSTR lpAnomalyType,
    _In_ ULONG_PTR lParam,
    _In_ BOOLEAN fCheckDuplicate);

VOID supReportEvent(
    _In_ DR_EVENT_TYPE EventType,
    _In_ LPWSTR lpEvent,
    _In_opt_ LPWSTR lpDescription,
    _In_opt_ LPWSTR lpAnomalyType);

#define REPORT_TEST_PASSED(TestType) supReportEvent(evtInformation, (LPWSTR)TestType, (LPWSTR)TEXT("PASSED"), NULL)
#define REPORT_TEST_SKIPPED(Text) supReportEvent(evtWarning, (LPWSTR)Text, (LPWSTR)TEXT("SKIPPED"), NULL)
#define REPORT_RIP(RipText) supReportEvent(evtError, (LPWSTR)RipText, (LPWSTR)TEXT("FAILURE"), NULL)

ULONG NTAPI supUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionInfo);

HANDLE supGetCurrentProcessToken(
    VOID);
BOOL supUserIsFullAdmin(
    VOID);

SIZE_T supFindUnicodeStringSubString(
    _In_ PUNICODE_STRING String,
    _In_ PUNICODE_STRING SubString);

BOOL supListViewExportToFile(
    _In_ LPCWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView);

BOOL supConvertFileName(
    _In_ LPWSTR NtFileName,
    _Inout_ LPWSTR DosFileName,
    _In_ SIZE_T ccDosFileName);

NTSTATUS supConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString);

NTSTATUS supGetObjectTypesInfo(
    _Out_ PULONG ReturnLength,
    _Out_ PVOID* Buffer);

NTSTATUS supGetWin32FileName(
    _In_ LPCWSTR NtFileName,
    _Out_ LPWSTR* Win32FileName);

NTSTATUS supInitializeKnownSids();
VOID supCacheKnownDllsEntries();

PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength);

PVOID supGetProcessInfoVariableSize(
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_opt_ PULONG ReturnLength);

PVOID supVirtualAlloc(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

BOOL supVirtualFree(
    _In_ PVOID Memory);

NTSTATUS supMapImageNoExecute(
    _In_ PUNICODE_STRING ImagePath,
    _Out_ PVOID* BaseAddress);

NTSTATUS supIsFileOwnedByTrustedInstallerSystemOrAdmins(
    _In_ KPROCESSOR_MODE Mode,
    _In_ HANDLE hFile,
    _In_ PUNICODE_STRING pusName);

NTSTATUS supPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult);

NTSTATUS supQueryNtOsInformation(
    _Out_ PULONG BuildNumber,
    _Out_opt_ PVOID* MappedNtOs);

NTSTATUS supGetConsoleHostForSelf(
    _Out_ PHANDLE ConsoleHostId);

NTSTATUS supEmptyWorkingSet();

HIMAGELIST supLoadImageList(
    _In_ HINSTANCE hInstance);

VOID supSetListViewSettings(
    _In_ HWND hwndLV,
    _In_ DWORD dwExtendedStyle,
    _In_ BOOL fSetTheme,
    _In_opt_ HIMAGELIST hImageList,
    _In_ INT iImageList);

ULONG supAddLVColumnsFromArray(
    _In_ HWND ListView,
    _In_ PLVCOLUMNS_DATA ColumnsData,
    _In_ ULONG NumberOfColumns);

INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width);

HRESULT supShellExecInExplorerProcess(
    _In_ PCWSTR pszFile,
    _In_opt_ PCWSTR pszArguments);

ULONG supExtractSSN(
    _In_ SSN_EXTRACT_METHOD Method,
    _In_ PVOID ImageBase,
    _In_ BOOL IsNtDll,
    _In_ LPCSTR FunctionName);

LPVOID supLdrGetProcAddressEx(
    _In_ LPVOID ImageBase,
    _In_ LPCSTR RoutineName);

PVOID supLdrFindImageByAddress(
    _In_opt_ PVOID AddressValue,
    _Out_ PVOID* ImageBase);

PVOID supLdrFindImageByAddressEx(
    _In_ BOOL LockLoader,
    _In_opt_ PVOID AddressValue,
    _Out_ PVOID* ImageBase);

PVOID supGetImageBaseUnsafe(
    _In_ ULONG_PTR AddressValue);

ULONG supEnumServiceExports(
    _In_ HANDLE HeapHandle,
    _In_ LPVOID ImageBase,
    _In_ BOOL IsNtDll,
    _Out_ EXPORT_NODE** ExportTable);

ULONG_PTR supSyscallAddressFromServiceEntry(
    _In_ PVOID ImageBase,
    _In_ LPCSTR FunctionName);

NTSTATUS supVerifyFileSignature(
    _In_ KPROCESSOR_MODE Mode,
    _In_ LPWSTR lpFileName,
    _In_ BOOL OsBinaryCheck,
    _In_ ptrWTGetSignatureInfo pWTGetSignatureInfo);

NTSTATUS supQueryThreadStartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ SUP_THREAD_INFO* ThreadInformation);

NTSTATUS supQueryThreadInstructionPointer(
    _In_ HANDLE Threadhandle,
    _Out_ PDWORD64 InstructionPointer);

ULONG supParseOSBuildBumber(
    _In_ PVOID ImageBase);

NTSTATUS supMapNtdllCopy(
    _In_ NTDLL_MAP_METHOD MapMethod,
    _Out_ PVOID* BaseAddress);

BOOLEAN supDetectDebug(
    _In_ DBG_CHECK_METHOD Method);

PVOID supGetLoadedModulesList(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength);

BOOLEAN supIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName);

BOOL supFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES pModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex);

NTSTATUS supGetMappedFileName(
    _In_ PVOID lpAddress,
    _Out_ POBJECT_NAME_INFORMATION* ObjectNameInformation);

NTSTATUS supQueryImageInformation(
    _In_ PVOID Address,
    _Out_ PVOID* ImageBase,
    _Out_ PSIZE_T SizeOfImage);

ULONG supExtractSyscallNumberFromRoutine(
    _In_ PFEFN Routine);

PVOID supGetNtStubByName(
    _In_ LPCSTR lpName);

PVOID supProcessEntryByProcessId(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList);

BOOL supThreadToProcessEntry(
    _In_ PVOID ProcessList,
    _In_ HANDLE ThreadId,
    _Out_ PSYSTEM_PROCESS_INFORMATION* ProcessListEntry);

NTSTATUS supThreadToProcessHandle(
    _In_ HANDLE ThreadId,
    _Out_ PHANDLE ProcessId);

NTSTATUS supIsProcessElevated(
    _In_ HANDLE ProcessId,
    _Out_ PBOOL Elevated);

NTSTATUS supCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed);

ULONG_PTR supQuerySystemRangeStart(
    VOID);

```

`WubbabooMark.sha256`:

```sha256
e60a832b335ff95f37ddf1db1d8c958df003223e18660548e28c090f712a6dd1 *Bin\Skilla.exe
3728d4e6d2833e81023bc2ac78207055903bd7432646e968e450266d68c040a6 *Help\ScanClean.png
876c2057edba680ee7dfa582b13e922ceb35e6830827ca6c24f6f5aa57d1dfa7 *Help\ScanDetect.png
b602cb4be43031181bed38c71bea30c15e99236e3d2fc9f5a3b46eb7b61606ea *Help\SeriousWubbaboo.png
2150cdbe87405a3d08972641faf5d6b7986f234df0888f29285371660423c2eb *Help\Settings.png
463b7afc49294ee9e8f5bc23c029a837c7b5394153eaf21b9ca7b41236a6d04c *Source\consts.h
e181ac77c9d202758ced028bb3339751b167a5e19fc568aece692a604983c7e6 *Source\global.h
3393caf8f9248591d493a01f6fa3af7df8c631765d55082ad46076ca8ebf8daa *Source\main.cpp
1424fde08d6994062fc8a795ff8d80d30060c4991103c4af59228dcf60171eca *Source\ntbuilds.h
9f83d3fde0670ff3b4a4f0e80aaf384b23a5dae8fe5ac2e913455df78b3c5ed3 *Source\ntcall.asm
2f76fd2d973a2e5ef32034e9e526d4aa2664a452301d00a5f4462c3316f025d3 *Source\ntgdi.h
6f54d252d4d3deb5c8176ed3b064100e495fb03cc3a64d309bb752620d8a4400 *Source\ntos.h
203380dfae2502de471f33beef04fea2909205db8b99e5c66e231c6769c40d04 *Source\ntproto.h
cbbb973fd24c2ed1834b10d4f1a7c4ec124a572a727dda40717c08a02dd9f116 *Source\ntuser.h
07e4f2cf1044b79f8cd36bf5e431b69cb41392f877a7b8cce02ff4f20fd5f3f9 *Source\probes.cpp
a560f3f7319eccec68844d95f4003372dfccb0b15261bc3fb4871a92950cc03b *Source\probes.h
8cc908b426836606588b76865748bdb9ca5f0ff52433782b3243e3765036410d *Source\resource.h
0d205042e5dbb76b016e543ef80932013d040a4ecfe857987128f8d6921d0621 *Source\resource.rc
0bab72ea7d4e86050edb2c59fa4417ce58b6659f2126e0c1895bd8627c7723fd *Source\skilla.manifest
6cf776c7caa72ab9f2d72367093a90aca51a38a9aa3756f78a6eae2ebc8356e6 *Source\Skilla.vcxproj
85ee01cb0dbbcd31a17a15271d9348c2c0cb8a131bf5cb9d53a7ddff550bfae6 *Source\Skilla.vcxproj.filters
c06a75b13f855a94d46616796e024c52b499f8f92cf00ccb571ddbc6ff574676 *Source\Skilla.vcxproj.user
04abafc0fafc9f9f7069e4ea5beec1420768068b41c05621949dc7073f7ea6b2 *Source\sup.cpp
1503d8032670215d88183176776dbb2d715f3a255a6ae1584681f667d25f5892 *Source\sup.h
63f8e032f106297d9a7a9cc7945ab39680542c5e652f583abf781e0eb75f5991 *Source\WubbabooMark.sln
3bd9d779eedeaf0e28b2c4355511fccf9e85ea1504bad1da769b8d94d008050d *Source\hde\hde32.c
754579fbcec5f64fa229646ceecb241c0b7f31c8a0bb12370e604c316c569315 *Source\hde\hde32.h
53a7ce27591e040b63880a3dd326b8ba8c97a0fa34d5e2d32aba89a0147434f6 *Source\hde\hde64.c
e99aa4997bda14b534c614c3d8cb78a72c4aca91a1212c8b03ec605d1d75e36e *Source\hde\hde64.h
f8e6a0be357726bee35c7247b57408b54bb38d94e8324a6bb84b91c462b2be30 *Source\hde\pstdint.h
cb8b5face76719ce3a81275171c94f9575561d0ccf94634e4cde519f19f3676d *Source\hde\table32.h
b774446d2f110ce954fb0a710f4693c5562ddbd8d56fe84106f2ee80db8b50a2 *Source\hde\table64.h
2a08385892845104b4f07d693ca395eba3a09e4aa89ad791be3807919316ed67 *Source\minirtl\minirtl.h
d7fbfd69df3840022dab1f8f2d529ce04abac8cee0234448bfd0a67feb6aea22 *Source\minirtl\rtltypes.h
e56e67b10a67f0d5ef4128c7ab0c6cb9ba9966916720525edfa6abf3101dfe13 *Source\minirtl\u64tohex.c
f81c975acd016c97776dd3a8e3218e148682b0336ff3fcd77fad6d9b86ddf107 *Source\minirtl\ultohex.c
9cbedf9b92abaef3ea28de28dd523ac44079592178ef727c7003c339a5a54712 *Source\minirtl\ultostr.c
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *Source\minirtl\_strcat.c
2a67c7690ec6df8e233207116b0e4fe76c02ae43595d9e606e123572b6ac88a1 *Source\minirtl\_strcmp.c
ef1b18997ea473ac8d516ef60efc64b9175418b8f078e088d783fdaef2544969 *Source\minirtl\_strcmpi.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *Source\minirtl\_strcpy.c
988c1c61ada9893fb13ee2efe4fc5f5ca22b10f095c12cd57407a624b3811a28 *Source\minirtl\_strcpyn.c
27159b8ff67d3f8e6c7fdb4b57b9f57f899bdfedf92cf10276269245c6f4e066 *Source\minirtl\_strend.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *Source\minirtl\_strlen.c
97e0720ed22d2d99e8148aab7ab2cb2cc3df278225669828b2d8d4d9ef856d94 *Source\minirtl\_strncmp.c
87cc72bb8e3f1534bee09ee278ecd928d975ebb94aeffc767b67249815a0bf3a *Source\minirtl\_strncmpi.c
0434d69daa20fbf87d829ffc17e43dcc2db3386aff434af888011fdec2f645a4 *Source\minirtl\_strncpy.c
33cd2f6cd1f700773473e06e0ca708ca28014725baf9ced97696dbba5aa68b58 *Source\probes\bootcfg.cpp
29b3f928807729f00ff097aad5585e78102d5b0b3b59fdbf7002e56ae56228c7 *Source\probes\common.cpp
71135b02d889687510a068431cdb4b1a38f5a49098f8afe8cdd4cf9f9bc9a89d *Source\probes\debugger.cpp
aa9bae09066d1536f6f1c1f86eb28e570a65d5522fd3ed9d41ba6cbec434edd5 *Source\probes\handletrace.cpp
1938bdab40a16aea28456cefde48b06fd5c7fd50be0bb3dd2b6ab1e4c37a24cf *Source\probes\memory.cpp
c2f45cabf6efaaeda7015335b462d6ff7906377ea6f900ddd90a0d3018e94a54 *Source\probes\modules.cpp
6eb34ee72200470ce8953f93cbc3141f6733118985cccc1c42bf26b93c56ae1c *Source\probes\objects.cpp
78bba68efa00db1293f481554f08f2c9af98150a7beb821540d15caa4f85f848 *Source\probes\processes.cpp
025d1bf7aa235499b2f239b4fa0b3f8dcff2011382b9e23e41392c0b5b9ffb7c *Source\probes\reports.cpp
0afec06d381ff1851cd89727e68848814c56cba6672eec949cb14e1ae2629c53 *Source\probes\syscall.cpp
63996fafee58a8a1f26505cfc3d23fcd7fa39e8c2ba59a89707ec179ba459931 *Source\probes\threads.cpp
03eecefd40e5beec23251efe4aea10bfc8e275eb1b42302334a932dbb8cc92d2 *Source\probes\win32k.cpp
7797c5dcf8051b396fe49adf124d4c3dd79c19965e77c22ce0f130c225fff1ab *Source\probes\winver.cpp
b3aeff8039ad49e3a8c66aeebba183e5e8c9872f186e43f6f5a88e34275aca3a *Source\rsrc\CheckDetection.ico
2185820e177f29b937c0a50fc0d8febeca4a7a9f4c61572066fcc5e7321354b0 *Source\rsrc\CheckFailed.ico
054ffab2899d1d5fc3a6d88c25b5ebdab8b34dca1949e645ebf7240701929b7a *Source\rsrc\CheckPassed.ico
47cd5e5ed508de1c5b0dd38006b5d8745f9322ea4482b35c7f1d8244239620c2 *Source\rsrc\CheckWarning.ico
432deea90bad952fd2d96069fd052511fd58db2d9fde1f0e4ba8b6eb6e913cba *Source\rsrc\CheckWubbaboo.ico
c59c36052ee2a026961b380461d9c997d67890b532024b663c4a23a8167e1807 *Source\rsrc\Main.ico

```

`appveyor.yml`:

```yml
version: 1.0.{build}
image: Visual Studio 2022
configuration: Release
platform: x64
build:
  project: Source/WubbabooMark.sln
  verbosity: minimal
```