Project Path: arc_gmh5225_cpp-veh-dbi_8f3tfn0k

Source Tree:

```txt
arc_gmh5225_cpp-veh-dbi_8f3tfn0k
├── CMakeLists.txt
├── LICENSE
├── README.md
├── lib
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── impl
│   │   │   ├── asm_support.hpp
│   │   │   ├── branch_tracer.hpp
│   │   │   ├── dbi.hpp
│   │   │   ├── handler.hpp
│   │   │   ├── logger.hpp
│   │   │   ├── tracer.hpp
│   │   │   └── utils.hpp
│   │   └── vehdbi.hpp
│   └── src
│       ├── asm_support.cpp
│       ├── branch_tracer.cpp
│       ├── dbi.cpp
│       ├── logger.cpp
│       └── utils.cpp
├── sample
│   ├── CMakeLists.txt
│   ├── branchtracer
│   │   ├── CMakeLists.txt
│   │   └── dllmain.cpp
│   ├── dllinjector
│   │   ├── CMakeLists.txt
│   │   └── dllinjector.cpp
│   └── readme_sample
│       ├── CMakeLists.txt
│       └── dllmain.cpp
└── script
    ├── build.ps1
    └── setup.ps1

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(vehdbg)

add_subdirectory(lib)
# add_subdirectory(sample)

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 YoungJoong Kim

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# cpp-veh-dbi
C++ Implementation of VEH based windows dynamic binary instrumentation

- Copyright (c) 2019 YoungJoong Kim, cpp-veh-dbi is licensed under the [MIT license](./LICENSE).
- This repository aims to write simple and fast programmable DBI tool.

## Environments
Tested environments
- Windows 10
- Visual Studio 2019
- CMake 3.14.0

## Usage
To build library and samples,
```
.\script\setup
.\script\build
```
Then executables can be found in the `bin` directory.
```
ls bin
```
To run sample branch tracer for notepad,
```
.\bin\dllinjector C:\Windows\notepad.exe .\bin\branchtracer.dll
```
Then console will log the Windows API call.
```
+00007FF66FF9AC85,00007FFCEF55CD30,KERNEL32.DLL,GetStartupInfoW
+00007FF66FF9AD18,00007FFCF038FC10,ntdll.dll,RtlRetrieveNtUserPfn
+00007FF66FF9AD18,00007FFCF038FC10,ntdll.dll,RtlRetrieveNtUserPfn
+00007FF66FF9AD5A,00007FFCEEE6A6A0,msvcrt.dll,initterm
+00007FF66FF9AE4A,00007FFCEEE513B0,msvcrt.dll,ismbblead
+00007FF66FF9AE4A,00007FFCEEE513B0,msvcrt.dll,ismbblead
```

## Structure
Struct `VehDBI` has three ways to instrument binary.
1. [Handler](#1-handler) : Trigger on specified address.
2. [Tracer](#2-tracer) : Tracing instruction with debugging event.
3. [BTCallback](#3-btcallback) : Callback on every instruction in text section.

### 1. Handler
Sample handler which triggered on entrypoint.
```c++
struct EntrypointHandler : Handler {
    void Handle(PCONTEXT context) override {
        std::ofstream("CONOUT$") << "trigged on entrypoint" << std::endl;
    }
};

// create dbi
VehDBI dbi;
// handler sample
size_t entrypoint = Utils::GetEntryPointAddress();
dbi.AddHandler(entrypoint, std::make_unique<EntrypointHandler>());
```

`VehDBI::AddHandler` get two arguments, address(`size_t`) and handler(`std::unique_ptr<Handler>`).

`Handler` require only one method, which will be invoked in specified address.
```c++
// Interface for debug event handler.
struct Handler {
    // Default virtual destructor.
    virtual ~Handler() = default;
    // Handle debug event.
    virtual void Handle(PCONTEXT context) = 0;
};
```

### 2. Tracer
Sample tracer which tracing branch instruction, [branch_tracer](./lib/src/branch_tracer.cpp).

`Tracer` require two methods.
- HandleSingleStep: Handle single step exception.
- HandleBreakpoint: Handle breakpoint exception.

If tracer set software bp, `HandleBreakpoint` should recover the opcode.
```c++
// Interface for code trace handler.
struct Tracer {
    // Default virtual destructor.
    virtual ~Tracer() = default;
    // Handle single step exception.
    virtual void HandleSingleStep(PCONTEXT context, Utils::SoftwareBP& bp) = 0;
    // Handle software breakpoint exception.
    virtual void HandleBreakpoint(PCONTEXT context, Utils::SoftwareBP& bp) = 0;
};
```

`VehDBI::AddTracer` get three arguments, tracer start point(`size_t`), end point(`size_t`) and tracer(`std::unique_ptr<Tracer>`).
- If start point is 0, dbi automatically start tracer on entrypoint.
- If end point is 0, tracer doesn't stop until process termination.
```c++
dbi.AddTracer(0, 0, std::make_unique<BranchTracer>());
```

### 3. BTCallback
Indeed, BTCallback is callback for branch tracer, which call `BTCallback::run` at every instruction. 

VehDBI basically run branch tracer on text section. And `VehDBI::AddBTCallback` add given callback to the default branch tracer. Then added callback will be invoked on every instruction in text section.

Sample BTCallback which log branch instruction, [logger](./lib/src/logger.cpp).
```c++
// btcallback sample
auto logger = std::make_unique<Logger>("CONOUT$");
// tracer sample
dbi.AddTracer(0, 0, std::make_unique<BranchTracer>(std::move(logger)));
```

Which is same with `VehDBI::AddBTCallback`, if tracer (start, end) point is (0, 0).
```c++
dbi.AddBTCallback(std::make_unique<Logger>("CONOUT$"));
```

`BTCallback` require only one method, which will be invoked on every instruction.
```c++
// Callback for branch tracer.
struct BTCallback {
    // Default destructor.
    virtual ~BTCallback() = default;
    // Callback.
    virtual void run(BTInfo const& info, PCONTEXT context) = 0;
};
```
```

`lib/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(libvehdbg)

set(CMAKE_CXX_STANDARD 17)

file(GLOB SOURCES "src/*.cpp")
include_directories(${CMAKE_SOURCE_DIR}/lib/include/impl)

add_library(libvehdbg STATIC ${SOURCES})
target_link_libraries(libvehdbg DbgHelp.lib)

```

`lib/include/impl/asm_support.hpp`:

```hpp
#ifndef ASM_SUPPORT_HPP
#define ASM_SUPPORT_HPP

#include <Windows.h>

#include <tuple>

namespace ASMSupport {
    // Disassemble and return branching address and return address.
    std::tuple<size_t, size_t> GetBranchingAddress(BYTE* opc, PCONTEXT context);
    // Parse SIB and return next opcode pointer and branching address.
    std::tuple<BYTE*, size_t> SIBParser(BYTE* opc, PCONTEXT context);
}

// if x64 environment
#ifdef _WIN64
// declare register with rax-family
#define RegisterAx Rax
#define RegisterCx Rcx
#define RegisterDx Rdx
#define RegisterBx Rbx
#define RegisterSp Rsp
#define RegisterBp Rbp
#define RegisterSi Rsi
#define RegisterDi Rdi
#define RegisterIp Rip
// if x86 environment
#else
// declare register with eax-familty
#define RegisterAx Eax
#define RegisterCx Ecx
#define RegisterDx Edx
#define RegisterBx Ebx
#define RegisterSp Esp
#define RegisterBp Ebp
#define RegisterSi Esi
#define RegisterDi Edi
#define RegisterIp Eip
#endif

#endif
```

`lib/include/impl/branch_tracer.hpp`:

```hpp
#ifndef BRANCH_TRACER_HPP
#define BRANCH_TRACER_HPP

#include <Windows.h>

#include <mutex>

#include "tracer.hpp"
#include "utils.hpp"

// Branch data from branch tracer.
struct BTInfo {
    size_t source = 0;
    size_t called = 0;
    size_t retn = 0;
    bool e8_branch = false;
    bool ff_branch = false;
};

// Callback for branch tracer.
struct BTCallback {
    // Default destructor.
    virtual ~BTCallback() = default;
    // Callback.
    virtual void run(BTInfo const& info, PCONTEXT context) = 0;
};

// Implementation of branch tracer.
struct BranchTracer : Tracer {
    // Constructor.
    BranchTracer(size_t start, size_t end, std::unique_ptr<BTCallback> callback = nullptr);
    // Text section based tracer.
    BranchTracer(std::unique_ptr<BTCallback> callback = nullptr);

    // Handle single step exception.
    void HandleSingleStep(PCONTEXT context, Utils::SoftwareBP& bp) override;
    // Handle software breakpoint exception.
    void HandleBreakpoint(PCONTEXT context, Utils::SoftwareBP& bp) override;

private:
    // Trace given context.
    void Trace(PCONTEXT context, Utils::SoftwareBP& bp);

    size_t start;
    size_t end;
    std::unique_ptr<BTCallback> callback;

    static std::once_flag init_sym;
};

#endif
```

`lib/include/impl/dbi.hpp`:

```hpp
#ifndef DBI_HPP
#define DBI_HPP

#include <Windows.h>

#include <memory>
#include <tuple>
#include <unordered_map>
#include <vector>

#include "branch_tracer.hpp"
#include "handler.hpp"
#include "tracer.hpp"
#include "utils.hpp"

// Pack multiple BTCallbacks.
struct MultipleBTCallback : BTCallback {
    std::vector<std::unique_ptr<BTCallback>> callbacks;

    // Consturctor.
    MultipleBTCallback(std::vector<std::unique_ptr<BTCallback>> callbacks);
    // Callback.
    void run(BTInfo const& info, PCONTEXT context) override;
};

// VEH based DBI.
struct VehDBI {
    // Constructor.
    VehDBI();

    // Add handler to the DBI.
    void AddHandler(size_t target, std::unique_ptr<Handler> handler);
    // Add tracer to the DBI.
    void AddTracer(size_t start, size_t end, std::unique_ptr<Tracer> tracer);
    // Add BTCallback to the DBI.
    void AddBTCallback(std::unique_ptr<BTCallback> callbacks);

    // Set initial breakpoints.
    void SetInitialBreakPoint();

    // Run DBI.
    static void Run(VehDBI&& dbi);
    // Set DBI.
    static void SetDBI(VehDBI&& dbi);
    // Real VEH handler.
    static long WINAPI DebugHandler(PEXCEPTION_POINTERS exception);

private:
    static VehDBI dbi;

    // Handle single step exception.
    static void HandleSingleStep(PCONTEXT context);
    // Handle breakpoint exception.
    static bool HandleBreakpoint(PCONTEXT context);

    // Set tracer flag.
    inline void SetTracer(size_t idx) {
        trace_flag |= (1LL << idx);
    }
    // Release tracer flag.
    inline void ReleaseTracer(size_t idx) {
        trace_flag ^= (1LL << idx);
    }
    // Check tracer set.
    inline bool CheckTracer(size_t idx) const {
        return (trace_flag >> idx) & 1;
    }

    Utils::SoftwareBP bps;
    std::vector<std::unique_ptr<BTCallback>> btcallbacks;

    size_t last_bp;
    size_t trace_flag;

    struct TracerPack {
        size_t start;
        size_t end;
        std::unique_ptr<Tracer> tracer;
    };

    std::unordered_map<size_t, std::unique_ptr<Handler>> handlers;
    std::vector<TracerPack> tracers;
};

#endif
```

`lib/include/impl/handler.hpp`:

```hpp
#ifndef HANDLER_HPP
#define HANDLER_HPP

#include <Windows.h>

// Interface for debug event handler.
struct Handler {
    // Default virtual destructor.
    virtual ~Handler() = default;
    // Handle debug event.
    virtual void Handle(PCONTEXT context) = 0;
};

#endif
```

`lib/include/impl/logger.hpp`:

```hpp
#ifndef LOGGER_HPP
#define LOGGER_HPP

#include <fstream>

#include "branch_tracer.hpp"

// Logger for branch tracer.
struct Logger : BTCallback {
    // Text section based constructor. 
    Logger(std::string filename, bool only_api = false);
    // Constructor.
    Logger(size_t start, size_t end, std::string filename, bool only_api = false);

    // Callback.
    void run(BTInfo const& info, PCONTEXT context) override;

private:
    size_t start;
    size_t end;
    
    std::string filename;
    std::ofstream output;

    bool only_api;
};

#endif
```

`lib/include/impl/tracer.hpp`:

```hpp
#ifndef TRACER_HPP
#define TRACER_HPP

#include <Windows.h>

#include "utils.hpp"

// Interface for code trace handler.
struct Tracer {
    // Default virtual destructor.
    virtual ~Tracer() = default;
    // Handle single step exception.
    virtual void HandleSingleStep(PCONTEXT context, Utils::SoftwareBP& bp) = 0;
    // Handle software breakpoint exception.
    virtual void HandleBreakpoint(PCONTEXT context, Utils::SoftwareBP& bp) = 0;
};

#endif
```

`lib/include/impl/utils.hpp`:

```hpp
#ifndef UTILS_HPP
#define UTILS_HPP

#include <Windows.h>

#include <string>
#include <unordered_map>

namespace Utils {
    // Get module name which includes given address.
    std::tuple<bool, std::string> GetModuleNameByAddr(size_t address);
    // Get symbol name of given address.
    std::string GetSymbolName(size_t address);

    // Set trap flag.
    void SetSingleStep(PCONTEXT context);

    struct SoftwareBP {
        // Set software breakpoint.
        void Set(size_t address);
        // Release breakpoint.
        bool Recover(size_t address);

        std::unordered_map<size_t, std::tuple<BYTE, bool>> bp;
    };

    // Get entry point address.
    size_t GetEntryPointAddress();
    // Get text section address.
    std::tuple<size_t, size_t> GetTextSectionAddress();
}

#endif
```

`lib/include/vehdbi.hpp`:

```hpp
#ifndef VEHDBI_HPP
#define VEHDBI_HPP

#include "impl/asm_support.hpp"
#include "impl/branch_tracer.hpp"
#include "impl/dbi.hpp"
#include "impl/handler.hpp"
#include "impl/logger.hpp"
#include "impl/tracer.hpp"
#include "impl/utils.hpp"

#endif
```

`lib/src/asm_support.cpp`:

```cpp
#include <asm_support.hpp>

namespace ASMSupport {
    // RnM bit
    enum class RnM {
        AX = 0,
        CX = 1,
        DX = 2,
        BX = 3,
        SP = 4,
        BP = 5,
        SI = 6,
        DI = 7,
    };

    // Disassemble and return branching address and return address.
    std::tuple<size_t, size_t> GetBranchingAddress(BYTE* opc, PCONTEXT context) {
        BYTE mod = opc[1] >> 0x6; // high 2bits
        BYTE reg = (opc[1] >> 0x3) & 0x7; // mid 3bits
        RnM rnm = static_cast<RnM>(opc[1] & 0x7); // low 3bits

        size_t called = 0;
        size_t register_ip = reinterpret_cast<size_t>(opc);

        switch (rnm) {
        case RnM::AX: 
            called = context->RegisterAx; 
            break;
        case RnM::CX:
            called = context->RegisterCx;
            break;
        case RnM::DX:
            called = context->RegisterDx;
            break;
        case RnM::BX:
            called = context->RegisterBx;
            break;
        case RnM::SP:
            if (mod != 0x3) { // binary 11
                auto[parsed_opc, parsed_called] = SIBParser(opc, context);

                opc = parsed_opc;
                called = parsed_called;
            } else {
                called = context->RegisterSp;
            }
            break;
        case RnM::BP:
            if (mod == 0x00) {
#ifdef _WIN64
                called = register_ip + *reinterpret_cast<long*>(opc + 2) + 6;
#else
                called = *reinterpret_cast<long*>(opc + 2);
#endif
                opc += 4;
            } else {
                called = context->RegisterBp;
            }
            break;
        case RnM::SI:
            called = context->RegisterSi;
            break;
        case RnM::DI:
            called = context->RegisterDi;
            break;
        }

        if (mod == 0x1) { //binary 01
            called += static_cast<char>(opc[2]);
            ++opc;
        } else if (mod == 0x2) { //binary 10
            called += *reinterpret_cast<long*>(opc + 2);
            opc += 4;
        }

        if (mod != 0x3) { //binary 11
            called = *reinterpret_cast<size_t*>(called);
        }

        size_t retn = 0;
        if (reg == 2 || reg == 3) { //binary 010 (near call) , 011 (far call)
            retn = reinterpret_cast<size_t>(opc + 2);
        } else if (reg == 4 || reg == 5) { //binary 100 (near jmp) , 101 (far jmp)
            retn = *reinterpret_cast<size_t*>(context->RegisterSp);
        }

        return std::make_tuple(called, retn);
    }

    // Parse SIB and return next opcode pointer and branching address.
    std::tuple<BYTE*, size_t> SIBParser(BYTE* opc, PCONTEXT context) {
        BYTE sib = opc[2];
        BYTE scale = sib >> 0x6; // high 2bits
        RnM index = static_cast<RnM>((sib >> 0x3) & 0x7); // mid 3bits
        RnM base = static_cast<RnM>(sib & 0x7); // low 3bits

        size_t called = 0;
        switch (index) {
        case RnM::AX: called = context->RegisterAx; break;
        case RnM::CX: called = context->RegisterCx; break;
        case RnM::DX: called = context->RegisterDx; break;
        case RnM::BX: called = context->RegisterBx; break;
        case RnM::SP: break; //None
        case RnM::BP: called = context->RegisterBp; break;
        case RnM::SI: called = context->RegisterSi; break;
        case RnM::DI: called = context->RegisterDi; break;
        }

        called = called * (1LL << scale);

        switch (base) {
        case RnM::AX: called += static_cast<long>(context->RegisterAx); break;
        case RnM::CX: called += static_cast<long>(context->RegisterCx); break;
        case RnM::DX: called += static_cast<long>(context->RegisterDx); break;
        case RnM::BX: called += static_cast<long>(context->RegisterBx); break;
        case RnM::SP: called += static_cast<long>(context->RegisterSp); break;
        case RnM::BP: {
            BYTE Mod = opc[1] >> 6;
            switch (Mod) {
            case 0: //binary 00
                called += *reinterpret_cast<long*>(opc + 3);
                opc += 4;
                break;
            case 1: //binary 01
                called += static_cast<char>(opc[3]) + context->RegisterBp;
                ++opc;
                break;
            case 2: //binary 10
                called += *reinterpret_cast<long*>(opc + 3) + context->RegisterBp;
                opc += 4;
                break;
            }
            break;
        }
        case RnM::SI: called += static_cast<long>(context->RegisterSi); break;
        case RnM::DI: called += static_cast<long>(context->RegisterDi); break;
        }

        return std::make_tuple(opc + 1, called);
    }
}
```

`lib/src/branch_tracer.cpp`:

```cpp
#include <Windows.h>
#include <DbgHelp.h>

#include <asm_support.hpp>
#include <branch_tracer.hpp>

std::once_flag BranchTracer::init_sym;

// Constructor.
BranchTracer::BranchTracer(size_t start, size_t end, std::unique_ptr<BTCallback> callback) :
    start(start), end(end), callback(std::move(callback))
{
    std::call_once(init_sym, []{ SymInitialize(GetCurrentProcess(), NULL, TRUE); });
}

// Text section based tracer.
BranchTracer::BranchTracer(std::unique_ptr<BTCallback> callback) : callback(std::move(callback)) {
    auto[text_start, text_end] = Utils::GetTextSectionAddress();
    start = text_start;
    end = text_end;

    std::call_once(init_sym, []{ SymInitialize(GetCurrentProcess(), NULL, TRUE); });
}

// Handle single step exception.
void BranchTracer::HandleSingleStep(PCONTEXT context, Utils::SoftwareBP& bp) {
    Trace(context, bp);
}

// Handle software breakpoint exception.
void BranchTracer::HandleBreakpoint(PCONTEXT context, Utils::SoftwareBP& bp) {
    bp.Recover(context->RegisterIp);
    Trace(context, bp);
}

// Trace given context.
void BranchTracer::Trace(PCONTEXT context, Utils::SoftwareBP& bp) {
    bool bp_set = false;
    auto jmp_call = [](BYTE* opc) {
        if (opc[0] == 0xFF) {
            BYTE reg = (opc[1] >> 0x3) & 0x7;
            // Binary 010(near call) or 011(far call) 
            //        100(near jmp)  or 101(far jmp)
            return reg >= 2 && reg <= 5;
        }
        return false;
    };

    auto bp_on_retn = [&, this](size_t called, size_t retn) {
        if (!(start <= called && called <= end)) {
            bp.Set(retn);
            bp_set = true;
        }
    };

    BTInfo info;
    BYTE* opc = reinterpret_cast<BYTE*>(context->RegisterIp);

    // instruction call
    if (opc[0] == 0xE8) {
        size_t called = context->RegisterIp + *reinterpret_cast<long*>(opc + 1) + 5;
        BYTE* called_opc = reinterpret_cast<BYTE*>(called);

        // set brancing information
        info = BTInfo{context->RegisterIp, called, context->RegisterIp + 5, true, false};

        // if instruction jump to windows api
        if (jmp_call(called_opc)) {
            auto[api, retn] = ASMSupport::GetBranchingAddress(called_opc, context);
            bp_on_retn(api, context->RegisterIp + 5);

            // set for ff branch
            info.ff_branch = true;
            info.called = api;
        }
    } else if (jmp_call(opc)) {
        auto[called, retn] = ASMSupport::GetBranchingAddress(opc, context);
        bp_on_retn(called, retn);

        // set brancing information
        info = BTInfo{context->RegisterIp, called, retn, false, true};
    }

    // callback
    if (callback != nullptr) {
        callback->run(info, context);
    }

    if (!bp_set) {
        Utils::SetSingleStep(context);
    }
}

```

`lib/src/dbi.cpp`:

```cpp
#include <asm_support.hpp>
#include <branch_tracer.hpp>
#include <dbi.hpp>

VehDBI VehDBI::dbi;

// Consturctor.
MultipleBTCallback::MultipleBTCallback(std::vector<std::unique_ptr<BTCallback>> callbacks) :
    callbacks(std::move(callbacks))
{
    // Do nothing
}

// Callback.
void MultipleBTCallback::run(BTInfo const& info, PCONTEXT context) {
    for (auto& callback : callbacks) {
        if (callback != nullptr) {
            callback->run(info, context);
        }
    }
}

// Consturctor.
VehDBI::VehDBI() : bps(), last_bp(0), trace_flag(0), handlers(), tracers() {
    // Do nothing
}

// Add handler to the DBI.
void VehDBI::AddHandler(size_t target, std::unique_ptr<Handler> handler) {
    handlers.emplace(target, std::move(handler));
}

// Add tracer to the DBI.
void VehDBI::AddTracer(size_t start, size_t end, std::unique_ptr<Tracer> tracer) {
    tracers.push_back({start, end, std::move(tracer)});
}

// Add BTCallback to the DBI.
void VehDBI::AddBTCallback(std::unique_ptr<BTCallback> callback) {
    btcallbacks.push_back(std::move(callback));
}

// Set initial breakpoints.
void VehDBI::SetInitialBreakPoint() {
    // add bp on specified address for handlers
    for (auto const&[addr, value] : handlers) {
        bps.Set(addr);
    }

    // set default start point as entrypoint
    size_t entrypoint = Utils::GetEntryPointAddress();
    // add bp on specified address for tracers
    for (auto& pack : tracers) {
        if (pack.start == 0) {
            pack.start = entrypoint;
        }

        bps.Set(pack.start);
        if (pack.end != 0) {
            bps.Set(pack.end);
        }
    }
}

// Run DBI.
void VehDBI::Run(VehDBI&& target) {
    // Add default branch tracer
    auto btcallbacks = std::make_unique<MultipleBTCallback>(std::move(target.btcallbacks));
    target.AddTracer(0, 0, std::make_unique<BranchTracer>(std::move(btcallbacks)));

    // set initial breakpoints
    target.SetInitialBreakPoint();

    // set target as global context
    SetDBI(std::move(target));
    // add DBI veh handler
    AddVectoredExceptionHandler(1, DebugHandler);
}

// Set DBI.
void VehDBI::SetDBI(VehDBI&& target) {
    dbi = std::move(target);
}

// Handle single step exception.
void VehDBI::HandleSingleStep(PCONTEXT context) {
    // rewrite breakpoint
    if (dbi.last_bp) {
        dbi.bps.Set(dbi.last_bp);
        dbi.last_bp = 0;
    }

    // processing trace handler
    size_t iter = 0;
    for (auto& pack : dbi.tracers) {
        if (dbi.CheckTracer(iter)) {
            pack.tracer->HandleSingleStep(context, dbi.bps);
        }
        ++iter;
    }
}
// Handle breakpoint exception.
bool VehDBI::HandleBreakpoint(PCONTEXT context) {
    bool processed = false;
    auto recover = [&] {
        if (!processed) {
            dbi.last_bp = context->RegisterIp;
            dbi.bps.Recover(context->RegisterIp);
            processed = true;
        }
    };

    if (auto iter = dbi.handlers.find(context->Rip); iter != dbi.handlers.end()) {
        auto& handler = (*iter).second;
        handler->Handle(context);

        Utils::SetSingleStep(context);
        recover();
    }

    size_t iter = 0;
    for (auto& pack : dbi.tracers) {
        // start tracer
        if (pack.start == context->RegisterIp) {
            dbi.SetTracer(iter);
            recover();
        }
        // finish tracer
        if (pack.end == context->RegisterIp) {
            dbi.ReleaseTracer(iter);
            recover();
        }

        if (dbi.CheckTracer(iter)) {
            pack.tracer->HandleBreakpoint(context, dbi.bps);
            // for checking side effect
            if (*reinterpret_cast<BYTE*>(context->RegisterIp) != 0xCC) {
                processed = true;
            }
        }
        ++iter;
    }
    return processed;
}

// Real VEH handler.
long WINAPI VehDBI::DebugHandler(PEXCEPTION_POINTERS exception) {
    PEXCEPTION_RECORD record = exception->ExceptionRecord;
    PCONTEXT context = exception->ContextRecord;

    if (record->ExceptionCode == EXCEPTION_SINGLE_STEP) {
        HandleSingleStep(context);
        return EXCEPTION_CONTINUE_EXECUTION;
    } else if (record->ExceptionCode == EXCEPTION_BREAKPOINT) {
        bool processed = HandleBreakpoint(context);
        if (processed) {
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

```

`lib/src/logger.cpp`:

```cpp
#include <asm_support.hpp>
#include <logger.hpp>
#include <utils.hpp>

// Text section based constructor. 
Logger::Logger(std::string filename, bool only_api) :
    filename(filename), output(filename), only_api(only_api)
{
    auto[text_start, text_end] = Utils::GetTextSectionAddress();
    start = text_start;
    end = text_end;
}

// Constructor.
Logger::Logger(size_t start, size_t end, std::string filename, bool only_api) : 
    start(start), end(end), filename(filename), output(filename), only_api(only_api)
{
    // Do nothing
}

// Callback.
void Logger::run(BTInfo const& info, PCONTEXT context) {
    // if callback is invoked in non-branching context.
    if (!info.e8_branch && !info.ff_branch) {
        return;
    }

    void* src_ptr = reinterpret_cast<void*>(info.source);
    void* called_ptr = reinterpret_cast<void*>(info.called);

    // if api call
    if (!(start <= info.source && info.source <= end)) {
        auto[load_module, module_name] = Utils::GetModuleNameByAddr(info.called);
        // if module is loaded
        if (load_module) {
            std::string symbol_name = Utils::GetSymbolName(info.called);
            output << '+' << src_ptr << ',' << called_ptr << ',' << module_name << ',' << symbol_name << std::endl;
        } else {
            output << '+' << src_ptr << ',' << called_ptr << ",," << std::endl;
        }
    } else if (!only_api) {
        // for inner call
        output << '+' << src_ptr << ',' << called_ptr << ",," << std::endl;
    }
}

```

`lib/src/utils.cpp`:

```cpp
#include <Windows.h>
#include <DbgHelp.h>
#include <Psapi.h>
#include <TlHelp32.h>
#include <strsafe.h>

#include <memory>

#include <utils.hpp>

namespace Utils {
    // Get module name which includes given address.
    std::tuple<bool, std::string> GetModuleNameByAddr(size_t address) {
        std::string res;
        std::wstring wname;

        bool load_module = false;

        HANDLE process = GetCurrentProcess();
        DWORD pid = GetCurrentProcessId();

        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
        MODULEENTRY32W entry;
        entry.dwSize = sizeof(entry);

        if (Module32FirstW(snapshot, &entry)) {
            do {
                MODULEINFO info;
                GetModuleInformation(process, entry.hModule, &info, sizeof(info));

                size_t start = reinterpret_cast<size_t>(info.lpBaseOfDll);
                size_t end = start + info.SizeOfImage;

                if (start <= address && address <= end) {
                    wname = entry.szModule;
                    res.assign(wname.begin(), wname.end());

                    size_t dllbase = reinterpret_cast<size_t>(info.lpBaseOfDll);
                    if (SymLoadModule(process, NULL, res.c_str(), 0, dllbase, 0) || !GetLastError()) {
                        load_module = true;
                    }
                    break;
                }

            } while (Module32NextW(snapshot, &entry));
            CloseHandle(snapshot);
        }

        return std::make_tuple(load_module, std::move(res));
    }

    // Get symbol name of given address.
    std::string GetSymbolName(size_t address) {
        std::string name;
        auto buffer = std::make_unique<BYTE[]>(sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_NAME);
        auto symbol = reinterpret_cast<IMAGEHLP_SYMBOL*>(buffer.get());

        std::memset(symbol, 0, sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_NAME);
        symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        symbol->MaxNameLength = MAX_SYM_NAME;

        size_t disp;
        if (SymGetSymFromAddr(GetCurrentProcess(), address, &disp, symbol)) {
            name = symbol->Name;
        }

        return name;
    }

    // Set trap flag.
    void SetSingleStep(PCONTEXT context) {
        context->EFlags |= (1 << 8);
    }

    // Set software breakpoint.
    void SoftwareBP::Set(size_t address) {
        if (auto iter = bp.find(address); iter != bp.end()) {
            auto&[backup, set] = (*iter).second;
            if (!set) {
                set = true;
                *reinterpret_cast<BYTE*>(address) = 0xCC;
            }
        }

        DWORD protect;
        VirtualProtect(reinterpret_cast<LPVOID>(address), 1, PAGE_EXECUTE_READWRITE, &protect);

        BYTE* ptr = reinterpret_cast<BYTE*>(address);
        BYTE backup = *ptr;
        *ptr = 0xCC;

        bp.emplace(address, std::make_tuple(backup, true));
    }

    // Release breakpoint.
    bool SoftwareBP::Recover(size_t address) {
        if (auto iter = bp.find(address); iter != bp.end()) {
            auto&[backup, set] = (*iter).second;
            if (set) {
                set = false;
                *reinterpret_cast<BYTE*>(address) = backup;
            }
            return true;
        }
        return false;
    }
    
    // Get entry point address.
    size_t GetEntryPointAddress() {
        MODULEENTRY32W entry;
        entry.dwSize = sizeof(entry);

        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());

        Module32FirstW(snapshot, &entry);
        CloseHandle(snapshot);

        PIMAGE_DOS_HEADER doshdr = reinterpret_cast<PIMAGE_DOS_HEADER>(entry.modBaseAddr);
        PIMAGE_NT_HEADERS nthdr = ImageNtHeader(doshdr);
        PIMAGE_OPTIONAL_HEADER opthdr = &nthdr->OptionalHeader;

        size_t entrypoint = reinterpret_cast<size_t>(entry.modBaseAddr) + opthdr->AddressOfEntryPoint;
        return entrypoint;
    }

    // Get text section address.
    std::tuple<size_t, size_t> GetTextSectionAddress() {
        MODULEENTRY32W entry;
        entry.dwSize = sizeof(entry);

        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());

        Module32FirstW(snapshot, &entry);
        CloseHandle(snapshot);

        PIMAGE_DOS_HEADER doshdr = reinterpret_cast<PIMAGE_DOS_HEADER>(entry.modBaseAddr);
        PIMAGE_NT_HEADERS nthdr = ImageNtHeader(doshdr);
        PIMAGE_SECTION_HEADER section = reinterpret_cast<PIMAGE_SECTION_HEADER>(nthdr + 1);

        DWORD entrypoint = nthdr->OptionalHeader.AddressOfEntryPoint;

        DWORD num_sections = nthdr->FileHeader.NumberOfSections;
        for (DWORD i = 0; i < num_sections; ++i) {
            size_t start = section->VirtualAddress;
            size_t end = start + section->SizeOfRawData;

            if (start <= entrypoint && entrypoint <= end) {
                return std::make_tuple(start, end);
            }
            ++section;
        }
        return std::make_tuple(0, 0);    
    }
}

```

`sample/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(sample)

add_subdirectory(branchtracer)
add_subdirectory(dllinjector)
add_subdirectory(readme_sample)

```

`sample/branchtracer/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(branchtracer)

set(CMAKE_CXX_STANDARD 17)

add_library(branchtracer SHARED dllmain.cpp)
include_directories(${CMAKE_SOURCE_DIR}/../lib/include)

set(LIBRARY_DIRECTORY ${CMAKE_BINARY_DIR}/../lib/Release)
target_link_libraries(branchtracer Dbghelp.lib ${LIBRARY_DIRECTORY}/libvehdbg.lib)

```

`sample/branchtracer/dllmain.cpp`:

```cpp
#include <Windows.h>

#include <vehdbi.hpp>

VehDBI CreateDBI() {
    // allocate console
    AllocConsole();
    // create dbi
    VehDBI dbi;
    dbi.AddBTCallback(std::make_unique<Logger>("CONOUT$"));
    return std::move(dbi);
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    static VehDBI dbi = CreateDBI();

    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        VehDBI::Run(std::move(dbi));
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

`sample/dllinjector/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(dllinjector)

set(CMAKE_CXX_STANDARD 17)

add_executable(dllinjector dllinjector.cpp)

```

`sample/dllinjector/dllinjector.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

int wmain(int argc, wchar_t *argv[]) {
    if (argc < 3) {
        std::cout << "usage: helper [TARGET] [DLL]" << std::endl;
        return 1;
    }

    WCHAR *target = argv[1];
    WCHAR *lib = argv[2];

    std::wcout << L"[*] target: " << target << std::endl;
    std::wcout << L"[*] lib: " << lib << std::endl;

    STARTUPINFOW si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    memset(&pi, 0, sizeof(pi));

    // Create process of target binary with CREATE_SUSPENDED flag.
    if (!CreateProcessW(target, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
        std::cout << "[*] CreateProcess fail " << GetLastError() << std::endl;
        return 1;
    }

    // Get address of kernel32.LoadLibraryW
    HMODULE hKernel32 = LoadLibraryW(L"kernel32.dll");
    LPTHREAD_START_ROUTINE lpLoadLibraryW = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");

    // Remote memory allocation
    SIZE_T dwLength = (wcslen(lib) + 1) * 2;
    LPVOID lpLibName = VirtualAllocEx(pi.hProcess, NULL, dwLength, MEM_COMMIT, PAGE_READWRITE);
    if (lpLibName == NULL) {
        std::cout << "[*] VirtualAllocEx fail " << GetLastError() << std::endl;
        return 1;
    }

    // Write Brancher dll path.
    SIZE_T written;
    if (!WriteProcessMemory(pi.hProcess, lpLibName, lib, dwLength, &written)) {
        std::cout << "[*] WriteProcessMemory fail " << GetLastError() << std::endl;
        return 1;
    }

    // Run LoadLibraryW with allocated memory.
    HANDLE hThread = CreateRemoteThread(pi.hProcess, NULL, NULL, lpLoadLibraryW, lpLibName, NULL, NULL);
    if (hThread == NULL) {
        std::cout << "[*] CreateRemoteThread fail " << GetLastError() << std::endl;
        return 1;
    }

    WaitForSingleObject(hThread, INFINITE);

    // Run process.
    CloseHandle(hThread);
    ResumeThread(pi.hThread);

    // Free allocated memory,
    VirtualFreeEx(pi.hProcess, lpLibName, dwLength, MEM_RELEASE);

    std::cout << "[*] Waiting for process.." << std::endl;

    // Waiting for termination of target process.
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Close handle.
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return 0;
}
```

`sample/readme_sample/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(readme_sample)

set(CMAKE_CXX_STANDARD 17)

add_library(readme_sample SHARED dllmain.cpp)
include_directories(${CMAKE_SOURCE_DIR}/../lib/include)

set(LIBRARY_DIRECTORY ${CMAKE_BINARY_DIR}/../lib/Release)
target_link_libraries(readme_sample Dbghelp.lib ${LIBRARY_DIRECTORY}/libvehdbg.lib)

```

`sample/readme_sample/dllmain.cpp`:

```cpp
#include <Windows.h>

#include <vehdbi.hpp>

struct EntrypointHandler : Handler {
    void Handle(PCONTEXT context) override {
        std::ofstream("CONOUT$") << "trigged on entrypoint" << std::endl;
    }
};

VehDBI CreateDBI() {
    AllocConsole();
    // create dbi
    VehDBI dbi;

    // handler sample
    size_t entrypoint = Utils::GetEntryPointAddress();
    dbi.AddHandler(entrypoint, std::make_unique<EntrypointHandler>());

    // dbi.AddTracer(0, 0, std::make_unique<BranchTracer>());

    // btcallback sample
    auto logger = std::make_unique<Logger>("CONOUT$");
    // tracer sample
    dbi.AddTracer(0, 0, std::make_unique<BranchTracer>(std::move(logger)));

    // above is same as under
    // dbi.AddBTCallback(std::make_unique<Logger>("CONOUT$"));

    return std::move(dbi);
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    static VehDBI dbi = CreateDBI();

    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        VehDBI::Run(std::move(dbi));
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

`script/build.ps1`:

```ps1
Set-Location build
msbuild vehdbg.sln /p:configuration=Release

Copy-Item lib\Release\libvehdbg.lib ..\bin\libvehdbg.lib

Set-Location sample
msbuild sample.sln /p:configuration=Release

Copy-Item branchtracer\Release\branchtracer.dll ..\..\bin\branchtracer.dll
Copy-Item dllinjector\Release\dllinjector.exe ..\..\bin\dllinjector.exe
Copy-Item readme_sample\Release\readme_sample.dll ..\..\bin\readme_sample.dll

Set-Location ..\..

```

`script/setup.ps1`:

```ps1
mkdir build
Push-Location build
cmake ..

mkdir sample
Push-Location sample
cmake ..\..\sample

Pop-Location
Pop-Location

mkdir bin

```