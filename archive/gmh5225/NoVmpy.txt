Project Path: arc_gmh5225_NoVmpy_ixxnv6qa

Source Tree:

```txt
arc_gmh5225_NoVmpy_ixxnv6qa
├── LICENSE
├── imgs
│   └── 1.gif
├── novmpy
│   ├── __init__.py
│   ├── bridge.py
│   ├── handler.py
│   ├── match_helper.py
│   ├── ui.py
│   ├── views
│   │   ├── hview.py
│   │   └── vtil_graph.py
│   ├── vm.py
│   ├── vm_const.py
│   ├── vm_lifter.py
│   └── x86_deobf.py
├── novmpy.py
├── readme.md
├── requirements.txt
└── test.py

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2022, wallds
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`novmpy.py`:

```py
# idapython fix <= 7.6
# DO NOT REMOVE ME
import sys
sys.stdout.encoding = 'utf-8'


# for test
# ida_loader.load_plugin('F:/NoVmpy/novmpy.py')
import idaapi

NOVMPY_VERSION = "0.1"


class NoVmpyPlugin(idaapi.plugin_t):
    flags = 0
    comment = ""
    help = ""
    wanted_name = "NoVmpy"
    wanted_hotkey = ""

    def __init__(self):
        super(NoVmpyPlugin, self).__init__()

    def init(self):
        from novmpy.ui import UIManager
        self.ui = UIManager()

        return idaapi.PLUGIN_KEEP

    def run(self, args):
        pass

    def term(self):
        from novmpy.handler import vm_handlers
        vm_handlers.clear()


def PLUGIN_ENTRY():
    return NoVmpyPlugin()

```

`novmpy/bridge.py`:

```py
from capstone import *


class BridgeBase:
    def __init__(self):
        # arch size
        self.size = 8 if self.is64bit() else 4

        if self.is64bit():
            self.md = Cs(CS_ARCH_X86, CS_MODE_64)
        else:
            self.md = Cs(CS_ARCH_X86, CS_MODE_32)
        self.md.detail = True

    def read(self, addr, size, dir_=1):
        raise NotImplementedError()

    def is_readable(self, addr, size, dir_):
        raise NotImplementedError()

    def is_writeable(self, addr, size, dir_):
        raise NotImplementedError()

    def get_bytes(self, addr, size):
        raise NotImplementedError()

    def get_segs(self):
        raise NotImplementedError()

    def get_base(self):
        raise NotImplementedError()

    def is64bit(self):
        raise NotImplementedError()

    def update_msg(self, msg):
        raise NotImplementedError()

    def disasm(self, code, offset, count=0):
        return self.md.disasm(code, offset, count)

    def disasm_one(self, offset, size=20):
        for x in self.md.disasm(self.get_bytes(offset, size), offset, 1):
            return x
        return None

    def reg_name(self, reg_id, default=None):
        return self.md.reg_name(reg_id, default)


class BridgeLocal(BridgeBase):  # bridge for local
    def __init__(self, exe_path):
        import cle
        self.ld = cle.Loader(exe_path, False)
        super().__init__()

    def read(self, addr, size, dir_=1):
        addr_ = addr
        if dir_ < 0:
            addr_ -= size
        b = self.get_bytes(addr_, size)
        return int.from_bytes(b, byteorder='little')

    def is_readable(self, addr, size, dir_=1):
        if dir_ > 0:
            return addr >= self.ld.main_object.min_addr and addr+size < self.ld.main_object.max_addr
        else:
            return addr-size >= self.ld.main_object.min_addr and addr <= self.ld.main_object.max_addr

    def is_writeable(self, addr, size, dir_=1):
        for seg in self.get_segs():
            if seg.vaddr <= addr < seg.vaddr+seg.memsize:
                return seg.is_writable
        return False

    def get_bytes(self, addr, size):
        return self.ld.memory.load(addr, size)

    def get_segs(self):
        return self.ld.main_object.sections

    def get_base(self):
        return self.ld.main_object.mapped_base

    def is64bit(self):
        return self.ld.main_object.arch.name == 'AMD64'

    def update_msg(self, msg):
        pass


class BridgeIda(BridgeBase):  # bridge for ida:
    def __init__(self):
        super().__init__()

    def read(self, addr, size, dir_=1):
        addr_ = addr
        if dir_ < 0:
            addr_ -= size
        b = self.get_bytes(addr_, size)
        return int.from_bytes(b, byteorder='little')

    def is_readable(self, addr, size, dir_=1):
        import idc
        if dir_ < 0:
            return idc.is_mapped(addr-size)
        if addr == 0xffffffffffffffff:
            return False
        return idc.is_mapped(addr) and idc.is_loaded(addr)

    def is_writeable(self, addr, size, dir_=1):
        import ida_segment
        if dir_ < 0:
            addr -= size
        seg = ida_segment.getseg(addr)
        if seg is not None:
            return (seg.perm & ida_segment.SEGPERM_WRITE) != 0
        return False

    def get_segs(self):
        class dummy_seg():
            pass

        import ida_segment
        n = 0
        seg = ida_segment.getnseg(n)
        while seg is not None:
            dummy = dummy_seg()
            dummy.is_executable = (seg.perm & ida_segment.SEGPERM_EXEC) != 0
            dummy.vaddr = seg.start_ea
            dummy.memsize = seg.size()
            dummy.min_addr = seg.start_ea
            dummy.max_addr = seg.end_ea
            yield dummy
            n += 1
            seg = ida_segment.getnseg(n)

    def get_base(self):
        return 0

    def get_bytes(self, addr, size):
        import ida_bytes
        return ida_bytes.get_bytes(addr, size)

    def is64bit(self):
        import idaapi
        return idaapi.inf_is_64bit()

    def update_msg(self, msg):
        import ida_kernwin
        ida_kernwin.replace_wait_box(msg)
        return not ida_kernwin.user_cancelled()


class BridgeDummy(BridgeBase):  # bridge for dummy
    def __init__(self):
        super().__init__()

    def is64bit(self):
        return True


try:
    local_mode = False
    import idaapi
except:
    local_mode = True


bridge = None

if local_mode:
    bridge = BridgeLocal(
        r'F:\VMP_Sample\Sample_vmp3.4\test_misc\test_misc.x86.vmp.exe')
else:
    bridge = BridgeIda()

```

`novmpy/handler.py`:

```py
from unicorn import *
from unicorn.x86_const import *
from novmpy.match_helper import *
from novmpy.x86_deobf import *
from novmpy.vm import *
from novmpy.vm_const import *
import struct
from pyvtil import *
from typing import List

vm_handlers = {}

FLAG_CF = vtil.REG_FLAGS.select(1, 0)
FLAG_PF = vtil.REG_FLAGS.select(1, 2)
FLAG_AF = vtil.REG_FLAGS.select(1, 4)
FLAG_ZF = vtil.REG_FLAGS.select(1, 6)
FLAG_SF = vtil.REG_FLAGS.select(1, 7)
FLAG_DF = vtil.REG_FLAGS.select(1, 10)
FLAG_OF = vtil.REG_FLAGS.select(1, 11)

if vtil.arch.size == 4:
    ZAX = vtil.x86_reg.EAX
    ZBX = vtil.x86_reg.EBX
    ZCX = vtil.x86_reg.ECX
    ZDX = vtil.x86_reg.EDX
else:
    ZAX = vtil.x86_reg.RAX
    ZBX = vtil.x86_reg.RBX
    ZCX = vtil.x86_reg.RCX
    ZDX = vtil.x86_reg.RDX


def make_virtual_register(context_offset, size):
    return vtil.register_desc(vtil.register_virtual,
                              int(context_offset//vtil.arch.size),
                              size*8,
                              int(context_offset % vtil.arch.size)*8)


class VMIns(object):
    def __init__(self):
        self.address = 0
        self.id = VM_INS_INVALID
        self.mne = ''
        self.opstr = ''
        self.opsize = 0
        self.data = 0
        self.haddr = 0  # vm handler address
        self.comment = ''

    def __str__(self) -> str:
        if not self.opstr:
            s = '{:08X}| {}'.format(self.address, self.mne)
        else:
            s = '{:08X}| {} {}'.format(self.address, self.mne, self.opstr)
        if self.comment:
            s += ';'+self.comment
        return s


def align_size(v):
    if v == 1:
        return 2
    return v


def same_size(x, y):
    return align_size(x) == align_size(y)


def size2name(size):
    s = ''
    if size == 1:
        s = 'byte'
    elif size == 2:
        s = 'word'
    elif size == 4:
        s = 'dword'
    elif size == 8:
        s = 'qword'
    else:
        assert(False)
    return s


def reg2name(index, off, size):
    prefix = 'vm_r{}'.format(index)
    suffix = ''
    if size == 1:
        suffix = 'b'
    elif size == 2:
        suffix = 'w'
    elif size == 4:
        suffix = 'd'
    elif size == 8:
        suffix = 'q'
    if size <= 2:
        if off != 0:
            suffix += 'h'
        else:
            suffix += 'l'
    return prefix+suffix


class VMBase(object):
    def __init__(self, **kwargs):
        self.name = 'vmp_base'
        self.bytecode_size = 0
        self.opsize = 0
        self.address = kwargs.get('address', 0)
        self.hbase = kwargs.get('hbase', 0)
        self.insns = kwargs.get('insns', [])
        self.body = kwargs.get('body', [])
        self.connect = kwargs.get('connect', [])
        self.config: VMConfig = kwargs.get('config', None)
        self.conn_config: VMConfig = kwargs.get('conn_config', None)

    def get_next(self, vmstate: VMState):
        val = vmstate.fetch(self.dec_size)
        off = vmstate.decode_emu(
            self.dec_conn, val, self.dec_reg, self.dec_size)
        b1 = struct.pack('<I', off)
        (off,) = struct.unpack('<i', b1)
        next_h = (self.hbase+off) & get_mask(8*bridge.size)
        return next_h

    def get_instr(self, vmstate):
        raise NotImplementedError('')

    def parse_connect(self):
        mh = MatchHelper(self.connect, self.conn_config)
        args = {}
        if mh.decode(args):
            self.dec_conn = args['decoder']
            self.dec_reg = args['reg']
            self.dec_size = args['size']  # DWORD
            return True
        return False

    def parse_hbase(self, insn: CsInsn, reg_base: int):
        hbase = None
        is64bit = bridge.is64bit()
        if instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [reg_base, {'index': X86_REG_INVALID, 'scale': 1}]):
            op1, op2 = insn.operands
            if op2.mem.base != (X86_REG_RIP if is64bit else X86_REG_INVALID):
                return None
            if is64bit and op2.mem.disp != -7:
                return None
            if not is64bit:
                # lea base, [disp]
                hbase = op2.mem.disp
            else:
                # lea base, [rip+disp]
                hbase = insn.address + insn.size + op2.mem.disp
        return hbase

    def match(self):
        raise NotImplementedError('')

    def generator(self, ins: VMIns, block: vtil.basic_block):
        raise NotImplementedError(str(ins))


class VMNop(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_nop'

    def match(self):
        if len(self.body) != 1:
            return False
        insn: CsInsn = self.body[0]
        new_base = self.parse_hbase(insn, self.config.reg_base)
        if new_base != None:
            self.hbase = new_base
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_NOP
        i.address = vmstate.get_address()
        i.mne = 'nop'
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.nop()


class VMPushReg(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_push_reg'
        self.bytecode_size = 1

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        if mh.fetch_byte() and\
                mh.decode(args) and\
                mh.read({'size': 'size1'}) and\
                mh.store(0, {'size': align_size(mh.get_ph('size1'))}):
            self.decoder = args['decoder']
            self.reg = args['reg']
            self.opsize = mh.get_ph('size1')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_PUSH_REG
        i.address = vmstate.get_address()
        v = vmstate.decode_emu(self.decoder, vmstate.fetch(1), self.reg, 1)
        index, off = divmod(v, bridge.size)
        i.mne = 'push_reg{}'.format(self.opsize)
        i.opstr = reg2name(index, off, self.opsize)
        i.data = v
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.push(make_virtual_register(ins.data, ins.opsize))


class VMPopReg(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_pop_reg'
        self.bytecode_size = 1

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        mh.reset()
        if mh.load(0, {'size': 'size1'}) and\
                mh.fetch_byte() and\
                mh.decode(args) and\
                mh.write({'size': 'size2'}) and\
                same_size(mh.get_ph('size1'), mh.get_ph('size2')):
            self.decoder = args['decoder']
            self.reg = args['reg']
            self.opsize = mh.get_ph('size2')
            return True
        # template 2
        args = {}
        mh.reset()
        if mh.fetch_byte() and\
                mh.decode(args) and\
                mh.load(0, {'size': 'size1'}) and\
                mh.write({'size': 'size2'}) and\
                same_size(mh.get_ph('size1'), mh.get_ph('size2')):
            self.decoder = args['decoder']
            self.reg = args['reg']
            self.opsize = mh.get_ph('size2')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_POP_REG
        i.address = vmstate.get_address()
        v = vmstate.decode_emu(self.decoder, vmstate.fetch(1), self.reg, 1)
        index, off = divmod(v, bridge.size)
        i.mne = 'pop_reg{}'.format(self.opsize)
        i.opstr = reg2name(index, off, self.opsize)
        i.data = v
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.pop(make_virtual_register(ins.data, ins.opsize))


class VMPushImm(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_push_imm'

    def match(self):
        args = {}
        mh = MatchHelper(self.body, self.config)
        if mh.fetch({'size': 'size1'}) and\
                mh.decode(args) and\
                mh.store(0, {'size': align_size(mh.get_ph('size1'))}):
            self.decoder = args['decoder']
            self.reg = args['reg']
            self.bytecode_size = args['size']
            self.opsize = args['size']
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_PUSH_IMM
        i.address = vmstate.get_address()
        imm = vmstate.decode_emu(self.decoder, vmstate.fetch(
            self.bytecode_size), self.reg, self.bytecode_size)
        i.mne = 'push_imm{}'.format(self.opsize)
        if self.opsize == 1 or self.opsize == 2:
            i.opstr = '0x{:04X}'.format(imm)
        elif self.opsize == 4:
            i.opstr = '0x{:08X}'.format(imm)
        else:
            i.opstr = '0x{:X}'.format(imm)
        i.data = imm
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.push(vtil.make_uint(ins.data, ins.opsize*8))


class VMCall(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_call'
        self.bytecode_size = 1

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        if mh.fetch_byte() and mh.decode(args) and mh.batch(X86_INS_CALL):
            self.decoder = args['decoder']
            self.reg = args['reg']
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_CALL
        i.address = vmstate.get_address()
        imm = vmstate.decode_emu(self.decoder, vmstate.fetch(
            self.bytecode_size), self.reg, self.bytecode_size)
        i.mne = 'call'
        i.opstr = '#{}_args'.format(imm)
        i.data = imm
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0 = block.tmp(vtil.arch.bit_count)
        for i in range(ins.data):
            t = block.tmp(vtil.arch.bit_count)
            block.pop(t)
        block.pop(a0)
        block.vemits('int 3')


class VMCrc(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_crc'
        self.bytecode_size = 0
        self.table = 0
        self.xorkey = 0

    def calc_crc(self, addr, size):
        hash = 0
        code = bridge.get_bytes(addr, size)
        for b in code:
            v = bridge.read(self.table+((b ^ hash) & 0xFF)*4, 4)
            hash >>= 8
            hash ^= v
            hash ^= self.xorkey
        return hash ^ 0xFFFFFFFF

    def match(self):
        if len(self.body) < 15:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        # movzx esi, byte ptr [eax]
        # mov esi, dword ptr [esi*4 + 0x7b06b8]
        # XOR
        # INC
        # DEC
        # NOT
        if (mh.load(0, {'reg': 'ph1'}) and
            mh.load(bridge.size, {'reg': 'ph2'}) and
                mh.batch([X86_INS_XOR, X86_INS_INC, X86_INS_DEC, X86_INS_NOT]) and
                mh.store_dword(0)):
            for i in self.body:
                i: CsInsn
                if bridge.is64bit():
                    if (instr_match(i, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [None, {'base': X86_REG_RIP, 'index': X86_REG_INVALID, 'scale': 1}])):
                        (op1, op2) = i.operands
                        self.table = i.address+op2.mem.disp+i.size
                elif (instr_match(i, X86_INS_MOV, [X86_OP_REG, X86_OP_MEM], [None, {'base': X86_REG_INVALID, 'scale': 4}])):
                    (op1, op2) = i.operands
                    if op1.reg == op2.mem.base:
                        self.table = op2.mem.disp
                if instr_match(i, X86_INS_XOR, [X86_OP_REG, X86_OP_IMM]):
                    (op1, op2) = i.operands
                    self.xorkey = op2.imm
                    break
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_CRC
        i.address = vmstate.get_address()
        i.mne = 'crc'
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0, a1 = block.tmp(vtil.arch.bit_count, vtil.arch.bit_count)
        a2 = block.tmp(32)
        block.pop(a0)
        block.pop(a1)

        block.push(a2)


class VMAdd(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_add'

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        if mh.load(0, {'size': 'size'}) and\
                mh.load(align_size(mh.get_ph('size'))) and\
                mh.match(X86_INS_ADD, [X86_OP_REG, X86_OP_REG]) and\
                mh.store(bridge.size) and\
                mh.store_eflags():
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_ADD
        i.address = vmstate.get_address()
        i.mne = 'add{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1, t2 = block.tmp(ins.opsize*8, ins.opsize*8, ins.opsize*8)
        b0, b1, b2, b3 = block.tmp(1, 1, 1, 1)
        block.pop(t0)
        block.pop(t1)

        block.mov(t2, t1)
        block.add(t1, t0)

        block.tl(FLAG_SF, t1, 0)
        block.te(FLAG_ZF, t1, 0)
        block.tul(FLAG_CF, t1, t2)

        block.tl(b2, t2, 0)
        block.tl(b3, t0, 0)
        block.te(b0, b2, b3)

        block.tl(b2, t2, 0)
        block.tl(b3, t1, 0)
        block.tne(b1, b2, b3)

        block.mov(FLAG_OF, b0)
        block.band(FLAG_OF, b1)

        block.push(t1)
        block.pushf()


class VMNor(VMBase):  # not not and
    # (~a)&(~b) = ~(a|b)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_nor'

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        if (mh.load(0, {'size': 'size'}) and mh.load(align_size(mh.get_ph('size'))) and
                mh.batch([X86_INS_NOT, X86_INS_NOT, X86_INS_AND]) and
                mh.store(bridge.size) and mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_NOR
        i.address = vmstate.get_address()
        i.mne = 'nor{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1 = block.tmp(ins.opsize*8, ins.opsize*8)
        block.pop(t0)
        block.pop(t1)
        block.bnot(t0)
        block.bnot(t1)
        block.band(t0, t1)
        block.tl(FLAG_SF, t0, 0)
        block.te(FLAG_ZF, t0, 0)
        block.mov(FLAG_OF, 0)
        block.mov(FLAG_CF, 0)
        block.push(t0)
        block.pushf()


class VMNand(VMBase):  # not not or
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_nand'

    def match(self):
        mh = MatchHelper(self.body, self.config)
        args = {}
        if (mh.load(0, {'size': 'size'}) and mh.load(align_size(mh.get_ph('size'))) and
                mh.batch([X86_INS_NOT, X86_INS_NOT, X86_INS_OR]) and
                mh.store(bridge.size) and mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_NAND
        i.address = vmstate.get_address()
        i.mne = 'nand{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1 = block.tmp(ins.opsize*8, ins.opsize*8)
        block.pop(t0)
        block.pop(t1)
        block.bnot(t0)
        block.bnot(t1)
        block.bor(t0, t1)
        block.tl(FLAG_SF, t0, 0)
        block.te(FLAG_ZF, t0, 0)
        block.mov(FLAG_OF, 0)
        block.mov(FLAG_CF, 0)
        block.push(t0)
        block.pushf()


class VMStr(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_str'

    def match(self):
        if abs(len(self.body) - 4) > 2:
            return False
        mh = MatchHelper(self.body, self.config)
        if mh.load_zword(0, {'reg': 'ph1'}) and\
                mh.load(bridge.size, {'reg': 'ph2', 'size': 'size'}) and\
                mh.mem_write({'addr': 'ph1', 'val': 'ph2', 'segment': 'ph3', 'size': 'size'}):
            self.segment = mh.get_ph('ph3')
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_STR
        i.address = vmstate.get_address()
        i.mne = 'store'
        s = size2name(self.opsize)
        if self.segment == X86_REG_INVALID:
            i.opstr = s+' '+bridge.reg_name(X86_REG_DS)
        else:
            i.opstr = s+' '+bridge.reg_name(self.segment)
        i.data = self.segment
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1 = block.tmp(vtil.arch.bit_count, ins.opsize*8)
        block.pop(t0)
        block.pop(t1)
        if self.segment == X86_REG_GS:
            block.vemits("mov rax, gs:0x30")
            block.vpinw(ZAX)
            block.add(t0, ZAX)
        elif self.segment == X86_REG_FS:
            block.vemits("mov eax, fs:0x18")
            block.vpinw(ZAX)
            block.add(t0, ZAX)
        block.str(t0, 0, t1)


class VMLdr(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_ldr'

    def match(self):
        if abs(len(self.body) - 3) > 2:
            return False
        mh = MatchHelper(self.body, self.config)
        if mh.load_zword(0, {'reg': 'ph1'}) and \
                mh.mem_read({'addr': 'ph1', 'val': 'ph2', 'segment': 'ph3', 'size': 'size'}) and \
                mh.store(0):
            self.segment = mh.get_ph('ph3')
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_LDR
        i.address = vmstate.get_address()
        i.mne = 'load'
        s = size2name(self.opsize)
        if self.segment == X86_REG_INVALID:
            i.opstr = s+' '+bridge.reg_name(X86_REG_DS)
        else:
            i.opstr = s+' '+bridge.reg_name(self.segment)
        i.data = self.segment
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1 = block.tmp(vtil.arch.bit_count, ins.opsize*8)
        block.pop(t0)
        if self.segment == X86_REG_GS:
            block.vemits("mov rax, gs:0x30")
            block.vpinw(ZAX)
            block.add(t0, ZAX)
        elif self.segment == X86_REG_FS:
            block.vemits("mov eax, fs:0x18")
            block.vpinw(ZAX)
            block.add(t0, ZAX)
        block.ldd(t1, t0, 0)
        block.push(t1)


class VMShift(VMBase):
    # X86_INS_RCL, X86_INS_RCR, X86_INS_ROL, X86_INS_ROR,
    # X86_INS_SAL, X86_INS_SAR, X86_INS_SHL, X86_INS_SHR
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_shift'
        self.ins = X86_INS_INVALID

    def match(self):
        if len(self.body) < 5:
            return False
        mh = MatchHelper(self.body, self.config)
        shi = [X86_INS_RCL, X86_INS_RCR, X86_INS_ROL, X86_INS_ROR,
               X86_INS_SAL, X86_INS_SAR, X86_INS_SHL, X86_INS_SHR]
        args = {}
        if mh.load(0, {'reg': 'ph1', 'size': 'size'}) and \
                mh.load_byte(align_size(mh.get_ph('size')), {'reg': 'p2'}) and\
                mh.among(shi, {'ins': 'ph3'}) and\
                mh.store(bridge.size, {'reg': 'ph1'}) and\
                mh.store_eflags():
            self.ins = mh.get_ph('ph3')
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        m = {
            X86_INS_RCL: VM_INS_RCL,
            X86_INS_RCR: VM_INS_RCR,
            X86_INS_ROL: VM_INS_ROL,
            X86_INS_ROR: VM_INS_ROR,
            X86_INS_SAL: VM_INS_SAL,
            X86_INS_SAR: VM_INS_SAR,
            X86_INS_SHL: VM_INS_SHL,
            X86_INS_SHR: VM_INS_SHR
        }
        i2n = {
            VM_INS_RCL: 'rcl',
            VM_INS_RCR: 'rcr',
            VM_INS_ROL: 'rol',
            VM_INS_ROR: 'ror',
            VM_INS_SAL: 'sal',
            VM_INS_SAR: 'sar',
            VM_INS_SHL: 'shl',
            VM_INS_SHR: 'shr',
        }
        i = VMIns()
        i.haddr = self.address
        i.id = m[self.ins]
        i.address = vmstate.get_address()
        i.mne = '{}{}'.format(i2n[i.id], self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1, t2 = block.tmp(ins.opsize*8, ins.opsize*8, 8)
        cf = t1.select(1, t1.bit_count - 1)
        ofx = t0.select(1, t0.bit_count - 1)

        block.pop(t0)
        block.pop(t2)
        block.mov(t1, t0)
        if self.ins == X86_INS_SHL:
            block.bshl(t0, t2)
        elif self.ins == X86_INS_SHR:
            block.bshr(t0, t2)
        elif self.ins == X86_INS_ROL:
            block.brol(t0, t2)
        elif self.ins == X86_INS_ROR:
            block.bror(t0, t2)
        else:
            assert False
        block.tl(FLAG_SF, t0, 0)
        block.te(FLAG_ZF, t0, 0)
        block.mov(FLAG_OF, ofx)
        block.mov(FLAG_CF, cf)
        block.bxor(FLAG_OF, cf)
        block.push(t0)
        block.pushf()


class VMShld(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_shld'

    def match(self):
        if len(self.body) < 7:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.load(0, {'reg': 'ph1', 'size': 'size'}) and
            mh.load(mh.get_ph('size'), {'reg': 'ph2'}) and
                mh.load_byte(mh.get_ph('size')*2, {'reg': 'ph3'}) and
                mh.batch([X86_INS_SHLD]) and
                mh.store(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_SHLD
        i.address = vmstate.get_address()
        i.mne = 'shld{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1, t2, t3 = block.tmp(ins.opsize*8, ins.opsize*8, 8, 8)

        block.pop(t0)
        block.pop(t1)
        block.pop(t2)

        block.bshl(t0, t2)

        block.mov(t3, vtil.make_uint(ins.opsize*8, 8))
        block.sub(t3, t2)

        block.bshr(t1, t3)

        block.bor(t0, t1)

        block.tl(FLAG_SF, t0, 0)
        block.te(FLAG_ZF, t0, 0)
        block.mov(FLAG_OF, vtil.UNDEFINED)
        block.mov(FLAG_CF, vtil.UNDEFINED)
        block.push(t0)
        block.pushf()


class VMShrd(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_shrd'

    def match(self):
        if len(self.body) < 7:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.load(0, {'reg': 'ph1', 'size': 'size'}) and
            mh.load(mh.get_ph('size'), {'reg': 'ph2'}) and
                mh.load_byte(mh.get_ph('size')*2, {'reg': 'ph3'}) and
                mh.batch([X86_INS_SHRD]) and
                mh.store(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_SHRD
        i.address = vmstate.get_address()
        i.mne = 'shrd{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        t0, t1, t2, t3 = block.tmp(ins.opsize*8, ins.opsize*8, 8, 8)

        block.pop(t0)
        block.pop(t1)
        block.pop(t2)

        block.bshr(t0, t2)

        block.mov(t3, vtil.make_uint(ins.opsize*8, 8))
        block.sub(t3, t2)

        block.bshl(t1, t3)

        block.bor(t0, t1)

        block.tl(FLAG_SF, t0, 0)
        block.te(FLAG_ZF, t0, 0)
        block.mov(FLAG_OF, vtil.UNDEFINED)
        block.mov(FLAG_CF, vtil.UNDEFINED)
        block.push(t0)
        block.pushf()


class VMMul(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_mul'

    def match(self):
        if len(self.body) < 7:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        if (mh.load_byte(2, {'reg': 'ph1'}) and
            mh.load_byte(0, {'reg': 'ph2'}) and
                mh.batch([X86_INS_MUL]) and
                mh.store_word(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = 1
            return True
        mh.reset()
        if (mh.load(None, {'reg': 'ph1', 'size': 'size1'}) and
                mh.load(0, {'reg': 'ph2', 'size': 'size1'}) and
                mh.batch([X86_INS_MUL]) and
                mh.store(bridge.size, {'reg': 'ph2'}) and
                mh.store(bridge.size+mh.get_ph('size1'), {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size1')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_MUL
        i.address = vmstate.get_address()
        i.mne = 'mul{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0, a1, d = block.tmp(ins.opsize*8, ins.opsize*8, ins.opsize*8)
        if ins.opsize == 1:
            a2 = block.tmp(16)
            block.pop(d)
            block.pop(a0)
            block.mov(a2, a0)

            block.mul(a2, d)

            block.push(a2)
            block.pushf()
        else:
            block.pop(d)
            block.pop(a0)
            block.mov(a1, a0)

            block.mul(a0, d)
            block.mulhi(a1, d)

            block.push(a0)
            block.push(a1)
            block.pushf()


class VMImul(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_imul'

    def match(self):
        if len(self.body) < 6:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.load_byte(2, {'reg': 'ph1'}) and
            mh.load_byte(0, {'reg': 'ph2'}) and
                mh.batch([X86_INS_IMUL]) and
                mh.store_word(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = 1
            return True
        mh.reset()
        if (mh.load(None, {'reg': 'ph1', 'size': 'size1'}) and
                mh.load(0, {'reg': 'ph2', 'size': 'size1'}) and
                mh.batch([X86_INS_IMUL]) and
                mh.store(bridge.size, {'reg': 'ph2'}) and
                mh.store(bridge.size+mh.get_ph('size1'), {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size1')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_IMUL
        i.address = vmstate.get_address()
        i.mne = 'imul{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0, a1, d = block.tmp(ins.opsize*8, ins.opsize*8, ins.opsize*8)
        if ins.opsize == 1:
            a2, a3 = block.tmp(16, 16)
            block.pop(d)
            block.pop(a0)
            block.movsx(a2, a0)
            block.movsx(a3, d)

            block.imul(a2, a3)

            block.mov(FLAG_SF, vtil.UNDEFINED)
            block.mov(FLAG_ZF, vtil.UNDEFINED)
            block.mov(FLAG_OF, vtil.UNDEFINED)
            block.mov(FLAG_CF, vtil.UNDEFINED)

            block.push(a2)
            block.pushf()
        else:
            block.pop(d)
            block.pop(a0)
            block.mov(a1, a0)

            block.imul(a0, d)
            block.imulhi(a1, d)

            block.mov(FLAG_SF, vtil.UNDEFINED)
            block.mov(FLAG_ZF, vtil.UNDEFINED)
            block.mov(FLAG_OF, vtil.UNDEFINED)
            block.mov(FLAG_CF, vtil.UNDEFINED)

            block.push(a0)
            block.push(a1)
            block.pushf()


class VMDiv(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_div'

    def match(self):
        if len(self.body) < 7:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.load_byte(0, {'reg': 'ph1'}) and
            mh.load_byte(2, {'reg': 'ph2'}) and
                mh.batch([X86_INS_DIV]) and
                mh.store_word(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = 1
            return True
        mh.reset()
        if (mh.load(None, {'reg': 'ph1', 'size': 'size'}) and
            mh.load(0, {'reg': 'ph2'}) and
            mh.load(None, {'reg': 'ph3'}) and
                mh.batch([X86_INS_DIV]) and
                mh.store(bridge.size, {'reg': 'ph2'}) and
                mh.store(bridge.size+mh.get_ph('size'), {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_DIV
        i.address = vmstate.get_address()
        i.mne = 'div{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0, a1, d, c = block.tmp(
            ins.opsize*8, ins.opsize*8, ins.opsize*8, ins.opsize*8)
        if ins.opsize == 1:
            ax0 = block.tmp(16)
            block.pop(a0)
            block.pop(c)
            block.mov(a1, a0)

            block.div(a0, 0, c)
            block.rem(a1, 0, c)

            block.mov(ax0, a1)
            block.bshl(ax0, 8)
            block.bor(ax0, a0)

            block.push(ax0)
            block.pushf()
        else:
            block.pop(d)
            block.pop(a0)
            block.pop(c)
            block.mov(a1, a0)

            block.div(a0, d, c)
            block.rem(a1, d, c)

            block.push(a0)
            block.push(a1)
            block.pushf()


class VMIdiv(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_idiv'

    def match(self):
        if len(self.body) < 7:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.load_byte(0, {'reg': 'ph1'}) and
            mh.load_byte(2, {'reg': 'ph2'}) and
                mh.batch([X86_INS_IDIV]) and
                mh.store_word(bridge.size, {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = 1
            return True
        mh.reset()
        if (mh.load(None, {'reg': 'ph1', 'size': 'size'}) and
            mh.load(0, {'reg': 'ph2'}) and
            mh.load(None, {'reg': 'ph3'}) and
                mh.batch([X86_INS_IDIV]) and
                mh.store(bridge.size, {'reg': 'ph2'}) and
                mh.store(bridge.size+mh.get_ph('size'), {'reg': 'ph1'}) and
                mh.store_eflags()):
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_IDIV
        i.address = vmstate.get_address()
        i.mne = 'idiv{}'.format(self.opsize)
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        a0, a1, d, c = block.tmp(
            ins.opsize*8, ins.opsize*8, ins.opsize*8, ins.opsize*8)
        if ins.opsize == 1:
            ax0 = block.tmp(16)
            block.pop(a0)
            block.pop(c)
            block.mov(a1, a0)

            block.idiv(a0, 0, c)
            block.irem(a1, 0, c)

            block.mov(ax0, a1)
            block.bshl(ax0, 8)
            block.bor(ax0, a0)

            block.push(ax0)
            block.pushf()
        else:
            block.pop(d)
            block.pop(a0)
            block.pop(c)
            block.mov(a1, a0)

            block.idiv(a0, d, c)
            block.irem(a1, d, c)

            block.push(a0)
            block.push(a1)
            block.pushf()


class VMRdtsc(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_rdtsc'

    def match(self):
        if len(self.body) < 3:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        mh.reset()
        if (mh.batch([X86_INS_RDTSC]) and
            mh.store_dword(0, {'reg': X86_REG_EDX}) and
                mh.store_dword(4, {'reg': X86_REG_EAX})):
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_RDTSC
        i.address = vmstate.get_address()
        i.mne = 'rdtsc'
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.vemits('rdtsc')
        block.vpinw(ZDX)
        block.vpinw(ZAX)

        block.push(vtil.x86_reg.EAX)
        block.push(vtil.x86_reg.EDX)


class VMCpuid(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_cpuid'

    def match(self):
        if len(self.body) < 6:
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        if (mh.load_dword(0, {'reg': 'ph1'}) and
            mh.batch([X86_INS_CPUID]) and
            mh.store_dword(12) and
                mh.store_dword(8) and
                mh.store_dword(4) and
                mh.store_dword(0)):
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_CPUID
        i.address = vmstate.get_address()
        i.mne = 'cpuid'
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.pop(vtil.x86_reg.EAX)

        block.vpinr(ZCX)
        block.vpinr(ZAX)
        block.vemits('cpuid')
        block.vpinw(ZDX)
        block.vpinw(ZCX)
        block.vpinw(ZBX)
        block.vpinw(ZAX)

        block.push(vtil.x86_reg.EAX)
        block.push(vtil.x86_reg.EBX)
        block.push(vtil.x86_reg.ECX)
        block.push(vtil.x86_reg.EDX)


class VMLockExchange(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_lock_xchg'

    def match(self):
        if len(self.body) > 5:
            return False

        def is_lock_xchg(insn: CsInsn):
            if insn.id != X86_INS_XCHG:
                return False
            if X86_PREFIX_LOCK not in insn.prefix:
                return False
            op1, op2 = insn.operands
            if op1.type == X86_OP_MEM and op2.type == X86_OP_REG:
                self.opsize = op1.size
                return True
            return False
        args = {}
        mh = MatchHelper(self.body, self.config)
        if (mh.load(0, {'reg': 'ph1'}) and
                mh.load(bridge.size, {'reg': 'ph2'}) and
                mh.match_for(is_lock_xchg) and
                mh.store(0)):
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_LOCK_XCHG
        i.address = vmstate.get_address()
        i.mne = 'lock_xchg'
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        table = {1: (X86_REG_AL, 'byte'),
                 2: (X86_REG_AX, 'word'),
                 4: (X86_REG_EAX, 'dword'),
                 8: (X86_REG_RAX, 'qword')}
        reg, str_type = table[self.opsize]
        # vr = remap(ZAX, opsize)
        vr = vtil.x86_reg(reg)
        block.pop(ZDX)
        block.pop(vr)
        block.vpinr(ZDX)
        block.vpinr(ZAX)
        block.vemits(
            f'lock xchg {str_type} ptr [{bridge.reg_name(ZDX)}], {bridge.reg_name(reg)}')
        block.vpinw(ZAX)

        block.push(vr)


class VMPushCRX(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_push_crx'
        self.cr = X86_REG_INVALID

    def match(self):
        if len(self.body) > 4:
            return False
        mh = MatchHelper(self.body, self.config)
        for cr in [X86_REG_CR0, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR8]:
            mh.reset()
            if mh.match(X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [None, cr]) and mh.store(0):
                self.cr = cr
                self.name = f'vmp_push_{bridge.reg_name(self.cr)}'
                return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_PUSH_CRX
        i.address = vmstate.get_address()
        i.mne = f'push_{bridge.reg_name(self.cr)}'
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.vemits(f'mov {bridge.reg_name(ZAX)}, {bridge.reg_name(self.cr)}')
        block.vpinw(ZAX)
        block.push(ZAX)


class VMPopCRX(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_pop_crx'
        self.cr = X86_REG_INVALID

    def match(self):
        if len(self.body) > 4:
            return False
        mh = MatchHelper(self.body, self.config)
        for cr in [X86_REG_CR0, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR8]:
            mh.reset()
            if mh.load(0) and mh.match(X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [cr, None]):
                self.cr = cr
                self.name = f'vmp_pop_{bridge.reg_name(self.cr)}'
                return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_POP_CRX
        i.address = vmstate.get_address()
        i.mne = f'pop_{bridge.reg_name(self.cr)}'
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.pop(ZAX)
        block.vpinr(ZAX)
        block.vemits(f'mov {bridge.reg_name(self.cr)}, {bridge.reg_name(ZAX)}')


class VMPushSP(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_push_sp'

    def match(self):
        if len(self.body) > 4:
            return False
        mh = MatchHelper(self.body, self.config)
        a = {}
        if mh.get_sp({'reg': 'ph1'}) and mh.store(0, a):
            self.opsize = a['size']
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_PUSH_SP
        i.address = vmstate.get_address()
        i.mne = 'push_sp{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        if ins.opsize == vtil.arch.size:
            block.push(vtil.REG_SP)
        else:
            t0 = block.tmp(ins.opsize*8)
            block.mov(t0, vtil.REG_SP)
            block.push(t0)


class VMPopSP(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_pop_sp'

    def match(self):
        if len(self.body) != 1:
            return False
        mh = MatchHelper(self.body, self.config)
        if mh.load(0, {'reg': 'ph1', 'size': 'size'}) and mh.get_ph('ph1') == self.config.reg_sp:
            self.opsize = mh.get_ph('size')
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_POP_SP
        i.address = vmstate.get_address()
        i.mne = 'pop_sp{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        block.pop(vtil.REG_SP)


class VMPopFlag(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_pop_flag'

    def match(self):
        if len(self.body) != 3:
            return False
        mh = MatchHelper(self.body, self.config)
        if (mh.match(X86_INS_PUSH, [X86_OP_MEM], [{'base': self.config.reg_sp}]) and
                mh.among([X86_INS_POPFD, X86_INS_POPFQ])):
            self.opsize = bridge.size
            return True
        return False

    def get_instr(self, vmstate: VMState):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_POP_EFLAGS
        i.address = vmstate.get_address()
        i.mne = 'pop_flag{}'.format(self.opsize)
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        assert ins.opsize == vtil.arch.size
        block.popf()


def feeling_good(insns_connect: List[CsInsn]):
    """
    dir
    reg_base
    reg_key
    reg_ip
    """
    config = VMConfig()
    config.dir = 1
    config.reg_base, reg_off = get_regbase(insns_connect), X86_REG_INVALID
    for insn in reversed(insns_connect):
        # find add edi(base), edx(off)
        if (reg_off == X86_REG_INVALID and instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_REG], [config.reg_base])):
            op1, op2 = insn.operands
            reg_off = op2.reg
        if reg_off == X86_REG_INVALID:
            continue
        # xor r(off), r(key)
        if instr_match(insn, X86_INS_XOR, [X86_OP_REG, X86_OP_REG], [get_reg32(reg_off), None]):
            op1, op2 = insn.operands
            config.reg_key = op2.reg
            if bridge.is64bit():
                config.reg_key = get_reg64(config.reg_key)
            break

    config.dir = 1
    # get reg_ip
    for insn in insns_connect[:3]:
        r, imm = crease_match(insn)
        if r != X86_REG_INVALID and imm == -4:
            config.dir = -1
        # mov edx(off), dword ptr [ip] ;
        if instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_MEM], [get_reg32(reg_off), {'disp': 0, 'index': X86_REG_INVALID, 'scale': 1}]):
            config.reg_ip = insn.operands[1].mem.base
            return config

    return None


class VMInit(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = "vmp_init"

    def parse_vminit(self):
        self.config = feeling_good(self.connect)
        if not self.config:
            return False
        i_save_regs = 0
        i_decode_ip = -1
        i_set_sp = -1
        i_set_vregs = -1
        i_set_hbase = -1
        self.config.rebase = -1
        for i, v in enumerate(self.body):
            if self.config.rebase == -1 and i_decode_ip == -1:
                if instr_match(v, [X86_INS_MOV, X86_INS_MOVABS], [X86_OP_REG, X86_OP_IMM]):
                    op1, op2 = v.operands
                    self.config.rebase = op2.imm
            # mov {vIP}, dword ptr [esp + 0x28] ; decode vIP
            if instr_match(v, X86_INS_MOV, [X86_OP_REG, X86_OP_MEM], [self.config.reg_ip]):
                i_decode_ip = i
            if instr_match(v, X86_INS_MOV, [X86_OP_REG, X86_OP_REG]):
                op1, op2 = v.operands
                # mov {vESP}, esp ;
                if op2.reg in [X86_REG_ESP, X86_REG_RSP]:
                    self.config.reg_sp = op1.reg
                    i_set_sp = i
            # mov ebx, {vIP}; set key
            if instr_match(v, X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [self.config.reg_key, self.config.reg_ip]):
                i_set_key = i
            # sub esp({vRegs}), 0xc0
            if instr_match(v, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM]):
                # lea esp({vRegs}), [esp - 0xc0]
                op1, op2 = v.operands
                # if op1.reg == self.config.reg_regs:
                #     i_set_vregs = i
                # lea ebp, [L_SetHBase]
                if op1.reg == self.config.reg_base:
                    i_set_hbase = i
                    i_connect = i+1
                    if bridge.is64bit() and op2.mem.base == X86_REG_RIP:
                        # x64 <CsInsn :lea rbx, [rip - 7]>
                        self.hbase = v.address + v.size + op2.mem.disp
                    else:
                        self.hbase = op2.mem.disp
        assert(i_decode_ip != -1 and i_set_sp != -1)
        # parse push list
        m = {}
        self.save_regs = self.body[i_save_regs:i_decode_ip]
        self.pushs = []
        for insn in self.save_regs:
            if instr_match(insn, [X86_INS_MOV, X86_INS_MOVABS], [X86_OP_REG, X86_OP_IMM]):
                m[insn.operands[0].reg] = (X86_OP_IMM, insn.operands[1].imm)
            if instr_match(insn, X86_INS_PUSH, [X86_OP_REG]):
                if insn.operands[0].reg in m:
                    self.pushs.append(m[insn.operands[0].reg])
                else:
                    self.pushs.append((X86_OP_REG, insn.operands[0].reg))
            if insn.id in [X86_INS_PUSHFD, X86_INS_PUSHFQ]:
                self.pushs.append((X86_OP_REG, X86_REG_EFLAGS))
        self.conn_config = self.config
        self.ip_decoder = self.body[i_decode_ip+1:i_set_sp]
        return True

    def decode_ip(self, ct, vmstate: VMState):
        v = vmstate.decode_emu(self.ip_decoder, ct,
                               get_reg32(self.config.reg_ip), 4)
        v &= get_mask(bridge.size*8)
        return v

    def match(self):
        return True


class VMExit(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = "vmp_exit"
        self.pops = []
        return

    def match(self):
        if not instr_match(self.body[-1], X86_INS_RET):
            return False

        for insn in self.body:
            if instr_match(insn, X86_INS_POP, [X86_OP_REG]):
                self.pops.append(insn.operands[0].reg)
            elif insn.id in [X86_INS_POPFD, X86_INS_POPFQ]:
                self.pops.append(X86_REG_EFLAGS)

        if len(self.pops) >= 7:
            return True

        # x64
        # pop 15 times + popfq
        return False

    def get_instr(self, vmstate):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_EXIT
        i.address = vmstate.get_address()
        i.mne = 'exit'
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        pass


class VMUnknown(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = "vmp_unknown"

    def calc_bytecode_size(self):
        n = 0
        for insn in self.body:
            insn: CsInsn
            regs_read, regs_write = insn.regs_access()
            if self.config.reg_ip in regs_write:
                # lea vm_ip, [vm_ip+disp]
                if instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [self.config.reg_ip, {'base': self.config.reg_ip, 'index': X86_REG_INVALID, 'scale': 1}]):
                    n += insn.operands[1].mem.disp
                # add vm_ip, imm
                elif instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_IMM], [self.config.reg_ip]):
                    n += insn.operands[1].imm
                # sub vm_ip, imm
                elif instr_match(insn, X86_INS_SUB, [X86_OP_REG, X86_OP_IMM], [self.config.reg_ip]):
                    n -= insn.operands[1].imm
                elif instr_match(insn, X86_INS_LODSD):
                    n += 4
                elif instr_match(insn, X86_INS_LODSQ):
                    n += 8
                # mov vm_ip, vm_ip
                elif instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [self.config.reg_ip, self.config.reg_ip]):
                    n += 0
                else:
                    print(self.config)
                    dump_insns(self.body)
                    raise NotImplementedError('calc_bytecode_size'+str(insn))
        return abs(n)

    def match(self):
        self.bytecode_size = self.calc_bytecode_size()
        if self.bytecode_size != 0:
            mh = MatchHelper(self.body, self.config)
            args = {}
            if not mh.decode(args):
                return False
            self.decoder = args['decoder']
            self.reg = args['reg']
        return True

    def get_instr(self, vmstate):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_UNKNOWN
        i.address = vmstate.get_address()
        bytecode = 0
        if self.bytecode_size:
            bytecode = vmstate.decode_emu(self.decoder, vmstate.fetch(
                self.bytecode_size), self.reg, self.bytecode_size)

        i.mne = 'unknown'
        i.opstr = '{}'.format(bytecode)
        i.data = bytecode
        i.opsize = self.bytecode_size
        return i


class VMInvalid(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_invalid'

    def match(self):
        return True

    def get_instr(self, vmstate):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_INVALID
        i.address = vmstate.get_address()
        i.mne = 'invalid'
        i.opstr = ''
        i.data = 0
        i.opsize = self.opsize
        return i


def hook_code(uc: Uc, address, size, user_data):
    emu = user_data
    ins = bridge.disasm_one(address, size)
    sp = uc.reg_read(UC_X86_REG_RSP if bridge.is64bit() else UC_X86_REG_ESP)
    diff_sp = sp-emu.entry_sp
    # print(f'{address:08X} {diff_sp} {ins.mnemonic} {ins.op_str}')
    if ins.group(CS_GRP_JUMP):
        return
    emu.trace.append((ins, diff_sp))
    if emu.has_lea_stack and ins.id == X86_INS_CALL and ins.operands[0].type == CS_OP_IMM:
        if diff_sp < 0:
            fmt = '<q' if bridge.is64bit() else '<i'
            emu.vm_imm = struct.unpack(fmt, uc.mem_read(sp, bridge.size))[0]
            emu.vm_init_addr = ins.operands[0].imm & get_mask(bridge.size*8)

            for i in range(len(emu.trace)-1, -1, -1):
                if emu.trace[i][1] == (diff_sp+bridge.size):
                    emu.stub_addr = emu.trace[i][0].address
                    for _ins, _ in emu.trace[:i]:
                        emu.vm_unimpl_insn.append(_ins)
                    emu.success = True
                    emu.vm_imm2 = ins.address+ins.size
                    break
        uc.emu_stop()
        return
    if ins.id == X86_INS_LEA and ins.operands[0].reg in [X86_REG_ESP, X86_REG_RSP]:
        emu.has_lea_stack = True


def hook_mem_unmapped(uc, access, address, size, value, user_data):
    print(f'[hook_mem_unmapped]: ', access, hex(address), size, value)
    seg = None
    for _seg in bridge.get_segs():
        if _seg.min_addr <= address < _seg.max_addr:
            seg = _seg
            break
    if not seg:
        start = address & (~0xFFF)
        end = start+0x1000
    else:
        start, end = seg.min_addr, seg.max_addr
    start &= ~0xFFF
    end = (end+0xFFF) & (~0xFFF)

    uc.mem_map(start, end-start, UC_PROT_ALL)
    uc.mem_write(start, bridge.get_bytes(start, end-start))
    return True


class Emu():
    def __init__(self):
        self.has_lea_stack = False
        self.trace = []
        self.entry_sp = 0x20007F00
        self.vm_imm = 0
        self.stub_addr = 0
        self.vm_imm2 = 0
        self.vm_init_addr = 0
        self.vm_unimpl_insn = []
        self.success = False
        mode = UC_MODE_64 if bridge.is64bit() else UC_MODE_32
        self.uc = Uc(UC_ARCH_X86, mode)

        self.uc.mem_map(0x20000000, 0x8000, UC_PROT_ALL)
        reg = UC_X86_REG_RSP if bridge.is64bit() else UC_X86_REG_ESP
        self.uc.reg_write(reg, self.entry_sp)

        self.uc.hook_add(UC_HOOK_CODE, hook_code, self)
        self.uc.hook_add(UC_HOOK_MEM_UNMAPPED, hook_mem_unmapped)

    def run(self, address):
        try:
            self.uc.emu_start(address, -1, 0, 80)
        except:
            return False
        return self.success


class VMEntryParseResult:
    def __init__(self, vmstate, vminit, stub_addr, vm_imm, vm_imm2, vm_unimpl_insn) -> None:
        self.vmstate = vmstate
        self.vminit = vminit
        self.stub_addr = stub_addr
        self.vm_imm = vm_imm
        self.vm_imm2 = vm_imm2
        self.vm_unimpl_insn = vm_unimpl_insn


def vmentry_parse(addr):
    # [unimpl insn]
    # push <imm>
    # call <vm_init>
    insn_x = x86_simple_decode(addr, 5, True)
    if len(insn_x) >= 2:
        if (instr_match(insn_x[-2], X86_INS_PUSH, [X86_OP_IMM]) and
                instr_match(insn_x[-1], X86_INS_CALL, [X86_OP_IMM])):
            vm_imm = insn_x[-2].operands[0].imm
            vm_init = insn_x[-1].operands[0].imm & get_mask(bridge.size*8)
            vm_unimpl_insn = insn_x[:-2]
            h = factory(vm_init, None)
            if h and isinstance(h, VMInit):
                mask = get_mask(bridge.size*8)
                vmstate = VMState()
                vmstate.config = h.config
                vmstate.ip = h.decode_ip(vm_imm, vmstate)
                vmstate.key = (vmstate.ip-vmstate.config.rebase) & mask
                return VMEntryParseResult(vmstate, h, insn_x[-2].address, vm_imm, vm_init, vm_unimpl_insn)
    # vmp version >= 3.6
    emu = Emu()
    res = emu.run(addr)
    if not res:
        return None

    h = factory(emu.vm_init_addr, None)
    if h and isinstance(h, VMInit):
        mask = get_mask(bridge.size*8)
        vmstate = VMState()
        vmstate.config = h.config
        vmstate.ip = h.decode_ip(emu.vm_imm, vmstate)
        vmstate.key = (vmstate.ip-vmstate.config.rebase) & mask
        return VMEntryParseResult(vmstate, h, emu.stub_addr, emu.vm_imm, emu.vm_imm2, emu.vm_unimpl_insn)
    return None


class VMJmp(VMBase):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = 'vmp_jmp'

    def simple_parse(self):
        # breakpoint()
        self.conn_config = feeling_good(self.connect)
        if not self.conn_config:
            return False
        self.conn_config.rebase = self.config.rebase
        if bridge.is64bit():
            new_sp = [self.config.reg_sp]
            for insn in self.body:
                if instr_match(insn, X86_INS_XCHG, [X86_OP_REG, X86_OP_REG]):
                    op1, op2 = insn.operands
                    if op1.reg in new_sp:
                        new_sp.remove(op1.reg)
                        new_sp.append(op2.reg)
                    if op2.reg in new_sp:
                        new_sp.remove(op2.reg)
                        new_sp.append(op1.reg)
                elif instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_REG]):
                    op1, op2 = insn.operands
                    if op1.reg != op2.reg and op2.reg in new_sp:
                        new_sp.append(op1.reg)
            assert new_sp
            if len(new_sp) > 1:
                print(f'warning! new_sp -> {new_sp} too much')
            self.conn_config.reg_sp = new_sp[-1]
        else:
            # 32 only
            self.conn_config.reg_sp = X86_REG_EBP ^ X86_REG_EDI ^ X86_REG_ESI ^ self.conn_config.reg_ip ^ self.conn_config.reg_base
        return True

    def match(self):
        matched = False
        reg_newip = X86_REG_INVALID
        if not self.simple_parse():
            return False
        for insn in self.body:
            if reg_newip == X86_REG_INVALID:
                # mov conn_config.reg_ip, reg
                if instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_MEM], [None, {'base': self.config.reg_sp, 'disp': 0, 'index': X86_REG_INVALID, 'scale': 1}]):
                    reg_newip = insn.operands[0].reg
                    if reg_newip == self.conn_config.reg_ip:
                        matched = True
            elif instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [self.conn_config.reg_ip, reg_newip]):
                matched = True
            elif instr_match(insn, X86_INS_XCHG, [X86_OP_REG, X86_OP_REG], [reg_newip, self.conn_config.reg_ip]):
                matched = True
            if self.conn_config.reg_sp:
                if instr_match(insn, X86_INS_XCHG, [X86_OP_REG, X86_OP_REG], [reg_newip, self.conn_config.reg_ip]):
                    pass
            if matched:
                new_base = self.parse_hbase(insn, self.conn_config.reg_base)
                if new_base != None:
                    self.hbase = new_base
                    return True
        return False

    def get_instr(self, vmstate):
        i = VMIns()
        i.haddr = self.address
        i.id = VM_INS_JMP
        i.address = vmstate.get_address()
        i.mne = 'jmp'
        i.opstr = ''
        i.data = 0
        i.opsize = 0
        return i

    def generator(self, ins: VMIns, block: vtil.basic_block):
        pass
        # t0 = block.tmp(vtil.arch.bit_count)
        # block.pop(t0)
        # block.jmp(t0)


def crease_match(insn, reg=None):
    # add r, i
    if instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_IMM], [reg]):
        return (insn.operands[0].reg, insn.operands[1].imm)
    # lea r, [r + i]
    if instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [reg, {'base': reg, 'index': X86_REG_INVALID, 'scale': 1}]):
        if insn.operands[0].reg == insn.operands[1].mem.base:
            return (insn.operands[0].reg, insn.operands[1].mem.disp)
    # sub r, i
    if instr_match(insn, X86_INS_SUB, [X86_OP_REG, X86_OP_IMM], [reg]):
        return (insn.operands[0].reg, -insn.operands[1].imm)
    return (X86_REG_INVALID, 0)


def get_regbase(insns):
    if instr_match(insns[-1], X86_INS_JMP, [X86_OP_REG]):
        return insns[-1].operands[0].reg
    elif (instr_match(insns[-1], X86_INS_RET) and
            instr_match(insns[-2], X86_INS_PUSH, [X86_OP_REG])):
        return insns[-2].operands[0].reg
    return X86_REG_INVALID


def get_splitline(insns: CsInsn):
    reg_off = X86_REG_INVALID
    reg_base = X86_REG_INVALID
    splitline = -1
    reg_ip = X86_REG_INVALID
    ph = X86_REG_INVALID
    # parse connect
    reg_base = get_regbase(insns)
    if reg_base == X86_REG_INVALID:
        return splitline
    for insn in reversed(insns):
        # find add edi(base), edx(off)
        if (reg_off == X86_REG_INVALID and
                instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_REG])):
            op1, op2 = insn.operands
            if op1.reg == reg_base:
                reg_off = op2.reg
        if reg_off == X86_REG_INVALID:
            continue
        # mov edx(off), dword ptr [ip] ;
        if instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_MEM], [get_reg32(reg_off), {'disp': 0, 'index': X86_REG_INVALID, 'scale': 1}]):
            reg_ip = insn.operands[1].mem.base
            if ph == reg_ip:
                splitline = insns.index(insn)
                break
        r, imm = crease_match(insn)
        if r != X86_REG_INVALID:
            if imm == -4 and r == reg_ip:
                splitline = insns.index(insn)
                break
            elif imm == 4:
                ph = r
    return splitline


h_seq = [VMPushReg, VMPopReg,
         VMPushImm,
         VMNor, VMNand, VMShift,
         VMStr, VMLdr,
         VMPushCRX, VMPopCRX,
         VMPushSP, VMPopSP,
         VMShld, VMShrd,
         VMAdd,
         VMMul, VMImul, VMDiv, VMIdiv,
         VMRdtsc, VMCpuid,
         VMLockExchange,
         VMCrc,
         VMPopFlag,
         VMNop, VMJmp, VMCall,
         VMUnknown]


def factory(address, config: VMConfig):
    if address in vm_handlers:
        return vm_handlers[address]
    insns = x86_simple_decode(address, 150, True)
    if not insns:
        print(f'shit {address:X}')
        breakpoint()
    if (splitline := get_splitline(insns)) > 0:
        body = insns[:splitline]
        connect = insns[splitline:]
        if config is None:  # test vminit
            h = VMInit(insns=insns,
                       body=body,
                       connect=connect,
                       address=address)
            if h.parse_vminit() and h.match() and h.parse_connect():
                vm_handlers[address] = h
                return h
            return None
        for g in h_seq:
            h = g(config=config, insns=insns, body=body, connect=connect,
                  conn_config=config, hbase=address, address=address)
            if h.match() and h.parse_connect():
                vm_handlers[address] = h
                return h
    else:
        h = VMExit(config=config,
                   insns=insns,
                   body=insns,
                   hbase=address,
                   address=address)
        if h.match():
            vm_handlers[address] = h
            return h
    # vm invalid
    return VMInvalid(config=config, address=address, insns=insns)

```

`novmpy/match_helper.py`:

```py
from capstone import *
from capstone.x86 import *
from novmpy.x86_deobf import *
from novmpy.bridge import *


class MatchHelper:
    """
    fetch: vm_bytecode
    load, store: stack
    mem: memory pointer
    read, write: vm_regs
    """

    # TODO: zword -> arch size 4 or 8

    def __init__(self, body, config):
        self.body = body
        self.index = 0
        self.config = config
        self.placeholder = {}

    def reset(self):
        self.index = 0
        self.placeholder = {}
        return True

    def update_index(self, new_index):
        self.index = new_index

    # maybe we can use __getitem__
    def get_ph(self, key):
        if key in self.placeholder:
            return self.placeholder[key]
        raise KeyError()

    def check_placeholder(self, args, k, v):
        # placeholder mode when args[k] is a str
        if k in args:
            if isinstance(args[k], str):
                ph_name = args[k]
                # do match when ph in dict
                if ph_name in self.placeholder:
                    if self.placeholder[ph_name] != v:
                        return False
                else:
                    self.placeholder[ph_name] = v
            else:
                return args[k] == v
        else:
            # not a placeholder, so just put in dict
            args[k] = v
        return True
    # match functions

    def get_sp(self, args):
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_MOV, [X86_OP_REG, X86_OP_REG], [None, self.config.reg_sp]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'reg', op1.reg):
                    continue
                self.update_index(i+1)
                return True
        return False

    # stack
    def _load(self, off, args):
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, [X86_INS_MOV, X86_INS_MOVZX], [X86_OP_REG, X86_OP_MEM], [None, {'base': self.config.reg_sp, 'disp': off, 'index': X86_REG_INVALID, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'reg', op1.reg):
                    continue
                if not self.check_placeholder(args, 'size', op2.size):
                    continue
                self.update_index(i+1)
                return True
        return False

    def _store(self, off, args):
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_MOV, [X86_OP_MEM, X86_OP_REG], [{'base': self.config.reg_sp, 'disp': off, 'index': X86_REG_INVALID, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'reg', op2.reg):
                    continue
                if not self.check_placeholder(args, 'size', op1.size):
                    continue
                self.update_index(i+1)
                return True
        return False

    def load_byte(self, off=0, args=None):
        # movzx cx, byte ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 1
        return self._load(off, args)

    def load_word(self, off=0, args=None):
        # movzx cx, word ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 2
        return self._load(off, args)

    def load_dword(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 4
        return self._load(off, args)

    def load_qword(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 8
        return self._load(off, args)

    def load_zword(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = bridge.size
        return self._load(off, args)

    def load(self, off=0, args=None):
        if args is None:
            args = {}
        # mov eax, dword ptr [{sp}]
        return self._load(off, args)

    def store_byte(self, off=0, args=None):
        # movzx cx, byte ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 1
        return self._store(off, args)

    def store_word(self, off=0, args=None):
        # movzx cx, word ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 2
        return self._store(off, args)

    def store_dword(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 4
        return self._store(off, args)

    def store_qword(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        args['size'] = 8
        return self._store(off, args)

    def store(self, off=0, args=None):
        # mov eax, dword ptr [{sp}]
        if args is None:
            args = {}
        return self._store(off, args)

    def _read(self, args):
        id = [X86_INS_MOV, X86_INS_MOVZX]
        # movzx eax, byte ptr []
        # mov eax, dword ptr []
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, id, [X86_OP_REG, X86_OP_MEM], [None, {'base': self.config.reg_regs, 'disp': 0, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'reg', op1.reg):
                    continue
                if not self.check_placeholder(args, 'size', op2.size):
                    continue
                self.update_index(i)
                return True
        return False

    # vm_regs
    def read_byte(self, args=None):
        if args is None:
            args = {}
        args['size'] = 1
        return self._read(args)

    def read_word(self, args=None):
        if args is None:
            args = {}
        args['size'] = 2
        return self._read(args)

    def read_dword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 4
        return self._read(args)

    def read_qword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 8
        return self._read(args)

    def read(self, args=None):
        if args is None:
            args = {}
        return self._read(args)

    def _write(self, args):
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_MOV, [X86_OP_MEM, X86_OP_REG], [{'base': self.config.reg_regs, 'disp': 0, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'reg', op2.reg):
                    continue
                if not self.check_placeholder(args, 'size', op1.size):
                    continue
                self.update_index(i)
                return True
        return False

    def write_byte(self, args=None):
        if args is None:
            args = {}
        args['size'] = 1
        return self._write(args)

    def write_word(self, args=None):
        if args is None:
            args = {}
        args['size'] = 2
        return self._write(args)

    def write_dword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 4
        return self._write(args)

    def write_qword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 8
        return self._write(args)

    def write(self, args=None):
        if args is None:
            args = {}
        return self._write(args)

    def _mem_write(self, args):
        # mov dword ptr ds:[ecx], al
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_MOV, [X86_OP_MEM, X86_OP_REG], [{'index': X86_REG_INVALID, 'disp': 0, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'addr', op1.mem.base):
                    continue
                if not self.check_placeholder(args, 'val', op2.reg):
                    continue
                if not self.check_placeholder(args, 'segment', op1.mem.segment):
                    continue
                if not self.check_placeholder(args, 'size', op1.size):
                    continue
                self.update_index(i)
                return True
        return False

    def mem_write_byte(self, args=None):
        if args is None:
            args = {}
        args['size'] = 1
        return self._mem_write(args)

    def mem_write_word(self, args=None):
        if args is None:
            args = {}
        args['size'] = 2
        return self._mem_write(args)

    def mem_write_dword(self, args=None):
        if args is None:
            args = {}
        # mov dword ptr [ecx], eax
        args['size'] = 4
        return self._mem_write(args)

    def mem_write_qword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 8
        return self._mem_write(args)

    def mem_write_zword(self, args=None):
        if args is None:
            args = {}
        args['size'] = bridge.size
        return self._mem_write(args)

    def mem_write(self, args=None):
        if args is None:
            args = {}
        return self._mem_write(args)

    def _mem_read(self, args):
        # mov al, dword ptr ds:[ecx],
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, [X86_INS_MOV, X86_INS_MOVZX], [X86_OP_REG, X86_OP_MEM], [None, {'index': X86_REG_INVALID, 'disp': 0, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'addr', op2.mem.base):
                    continue
                if not self.check_placeholder(args, 'val', op1.reg):
                    continue
                if not self.check_placeholder(args, 'segment', op2.mem.segment):
                    continue
                if not self.check_placeholder(args, 'size', op2.size):
                    continue
                self.update_index(i)
                return True
        return False

    def mem_read_byte(self, args=None):
        if args is None:
            args = {}
        args['size'] = 1
        return self._mem_read(args)

    def mem_read_word(self, args=None):
        if args is None:
            args = {}
        args['size'] = 2
        return self._mem_read(args)

    def mem_read_dword(self, args=None):
        if args is None:
            args = {}
        # mov eax, dword ptr [ecx]
        args['size'] = 4
        return self._mem_read(args)

    def mem_read_qword(self, args=None):
        if args is None:
            args = {}
        args['size'] = 8
        return self._mem_read(args)

    def mem_read(self, args=None):
        if args is None:
            args = {}
        return self._mem_read(args)

    def decode(self, args=None):
        if args is None:
            args = {}
        # find decode begin: xor ecx, ebx
        begin = -1
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_XOR, [X86_OP_REG, X86_OP_REG]):
                op1, op2 = insn.operands
                if extend_reg(op2.reg) == self.config.reg_key:
                    reg1 = op1.reg
                    begin = i
                    break
        if begin == -1:
            return False

        # find decode end: xor ebx, ecx
        end = -1
        for i in range(begin, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_XOR, [X86_OP_REG, X86_OP_REG]):
                op1, op2 = insn.operands
                if extend_reg(op1.reg) == self.config.reg_key:
                    reg2 = op2.reg
                    end = i
                    size = op2.size
                    break

        # <CsInsn 0x1406e9dbb [4152]: push r10>
        # <CsInsn 0x1406e9dc4 [310c24]: xor dword ptr [rsp], ecx>
        # <CsInsn 0x1406e9dd6 [415a]: pop r10>
        if end == -1 and bridge.is64bit():
            for i in range(begin, len(self.body)):
                insn: CsInsn = self.body[i]
                if instr_match(insn, X86_INS_XOR, [X86_OP_MEM, X86_OP_REG]):
                    op1, op2 = insn.operands
                    reg2 = op2.reg
                    end = i
                    size = op1.size
                    break

        if end == -1:
            return False

        if reg1 == reg2:
            args['reg'] = reg1
            args['decoder'] = self.body[begin:end+1]
            args['size'] = size
            self.update_index(end+1)
            return True
        return False

    def _fetch(self, args=None):
        if args is None:
            args = {}
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, [X86_INS_MOV, X86_INS_MOVZX], [X86_OP_REG, X86_OP_MEM],
                           [None, {'base': self.config.reg_ip, 'disp': 0, 'index': X86_REG_INVALID, 'scale': 1}]):
                op1, op2 = insn.operands
                if not self.check_placeholder(args, 'size', op2.size):
                    continue
                self.update_index(i+1)
                return True
        return False

    # find movzx ecx, byte ptr [ip]
    def fetch_byte(self):
        return self._fetch({'size': 1})

    def fetch_word(self):
        return self._fetch({'size': 2})

    def fetch_dword(self):
        return self._fetch({'size': 4})

    def fetch_qword(self):
        return self._fetch({'size': 8})

    def fetch(self, args=None):
        if args is None:
            args = []
        return self._fetch(args)

    def batch(self, id):
        ids = id if isinstance(id, list) else [id]
        if len(ids) == 0:
            return False
        match_count = 0
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if insn.id == ids[match_count]:
                match_count += 1
                if match_count >= len(ids):
                    self.update_index(i+1)
                    return True
        return False

    def among(self, id, args=None):
        if args is None:
            args = {}
        ids = id if isinstance(id, list) else [id]
        if len(ids) == 0:
            return False
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if insn.id in ids:
                self.update_index(i+1)
                if not self.check_placeholder(args, 'ins', insn.id):
                    continue
                return True
        return False

    def store_eflags(self):
        eflags = X86_INS_PUSHFQ if bridge.is64bit() else X86_INS_PUSHFD
        # find pushfd
        tmp = -1
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if insn.id == eflags:
                tmp = i+1
                break
        if tmp < 0:
            return False

        for i in range(tmp, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, X86_INS_POP, [X86_OP_MEM], [{'base': self.config.reg_sp, 'disp': 0, 'index': X86_REG_INVALID, 'scale': 1}]):
                self.update_index(i+1)
                return True
        return False

    def match_for(self, callback):
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if callback(insn):
                self.update_index(i+1)
                return True
        return False

    def match(self, id, optype=None, opx=None):
        if optype is None:
            optype = []
        if opx is None:
            opx = []
        for i in range(self.index, len(self.body)):
            insn: CsInsn = self.body[i]
            if instr_match(insn, id, optype, opx):
                self.update_index(i+1)
                return True
        return False

# id  X86_INS_ADD     [X86_INS_ADD, X86_INS_SUB]
# optype [X86_OP_REG, X86_OP_MEM]
# opx [X86_REG_EAX, {'base': X86_REG_EBP, 'disp': 4}]


def instr_match(insn: CsInsn, id, optype=None, opx=None):
    if optype is None:
        optype = []
    if opx is None:
        opx = []
    ids = id if isinstance(id, list) else [id]
    if insn.id not in ids:
        return False
    if len(insn.operands) < len(optype):
        return False
    for i, item in enumerate(optype):
        op: X86Op = insn.operands[i]
        if op.type != item:
            return False
        # [X86_OP_REG, X86_OP_MEM], [reg, {'base': reg, 'index': X86_REG_INVALID, 'scale': 1}])
        if len(opx) > i:
            if opx[i] is None:
                continue
            if item == X86_OP_REG:
                if op.reg != opx[i]:
                    return False
            elif item == X86_OP_IMM:
                if op.imm != opx[i]:
                    return False
            elif item == X86_OP_MEM:
                # 'segment', 'base', 'index','scale','disp',
                if 'segment' in opx[i] and opx[i]['segment'] != None and op.mem.segment != opx[i]['segment']:
                    return False
                elif 'base' in opx[i] and opx[i]['base'] != None and op.mem.base != opx[i]['base']:
                    return False
                elif 'index' in opx[i] and opx[i]['index'] != None and op.mem.index != opx[i]['index']:
                    return False
                elif 'scale' in opx[i] and opx[i]['scale'] != None and op.mem.scale != opx[i]['scale']:
                    return False
                elif 'disp' in opx[i] and opx[i]['disp'] != None and op.mem.disp != opx[i]['disp']:
                    return False
    return True

```

`novmpy/ui.py`:

```py
from __future__ import print_function
import ida_kernwin
import idaapi

from novmpy.vm_lifter import search_vmstubs
from novmpy.views import vtil_graph


class novmpy_letsgo_action(ida_kernwin.action_handler_t):
    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def activate(self, ctx):
        # breakpoint()
        ea = idaapi.get_screen_ea()
        print('ea:', hex(ea))
        vtil_graph.show_graph(ea)
        return 1

    def update(self, ctx):
        if ctx.widget_type == ida_kernwin.BWN_DISASM:
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


class novmpy_search_action(ida_kernwin.action_handler_t):
    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def activate(self, ctx):
        # breakpoint()
        for entry, is_mid_routine in search_vmstubs():
            print('entry:', hex(entry), 'is_mid_routine:', is_mid_routine)
        return 1

    def update(self, ctx):
        if ctx.widget_type == ida_kernwin.BWN_DISASM:
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


class novmpy_handler_view_action(ida_kernwin.action_handler_t):
    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def activate(self, ctx):
        # breakpoint()
        from novmpy.views.hview import show_handler_list_view
        show_handler_list_view()
        return 1

    def update(self, ctx):
        if ctx.widget_type == ida_kernwin.BWN_DISASM:
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


_act_dests = [
    ida_kernwin.action_desc_t(
        "novmpy:letsgo", "LetsGo", novmpy_letsgo_action()),
    ida_kernwin.action_desc_t(
        "novmpy:search", "Search", novmpy_search_action()),
    ida_kernwin.action_desc_t(
        "novmpy:handler_view", "Handler List", novmpy_handler_view_action())
]


class HooksUI(ida_kernwin.UI_Hooks):
    def finish_populating_widget_popup(self, widget, popup):
        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_DISASM:
            for act_dest in _act_dests:
                ida_kernwin.attach_action_to_popup(
                    widget, popup, act_dest.name, "NoVmpy/")


class UIManager():
    def __init__(self) -> None:
        self.ui_action_handler_register()
        self.hooks_ui = HooksUI()
        self.hooks_ui.hook()

    def __del__(self):
        self.hooks_ui = None
        self.ui_action_handler_unregister()

    def ui_action_handler_unregister(self):
        for act_dest in _act_dests:
            ida_kernwin.detach_action_from_menu(
                f"Edit/novmpy/{act_dest.name}", act_dest.name)
            # ida_kernwin.unregister_action(act_dest.name)

    def ui_action_handler_register(self):
        for act_dest in _act_dests:
            if not ida_kernwin.register_action(act_dest):
                print(f'warning failed register_action({act_dest.name})')
            ida_kernwin.attach_action_to_menu(
                f"Edit/novmpy/{act_dest.name}", act_dest.name, ida_kernwin.SETMENU_APP)

```

`novmpy/views/hview.py`:

```py
from __future__ import print_function

from capstone import CsInsn
from ida_kernwin import Choose
from novmpy.handler import vm_handlers
from novmpy.handler import VMJmp
import ida_kernwin
import idaapi
import ida_lines


class HandlerViewer(ida_kernwin.simplecustviewer_t):
    def Create(self, handler):
        if ida_kernwin.find_widget('handler view'):
            self.handler = handler
            self.reload()
            return True
        # Create the customviewer
        if not ida_kernwin.simplecustviewer_t.Create(self, 'handler view'):
            return False
        self.handler = handler
        self.reload()
        return True

    def Show(self, *args):
        return ida_kernwin.simplecustviewer_t.Show(self, *args)

    def reload(self):
        self.ClearLines()
        self.AddLine(ida_lines.COLSTR(
            str(self.handler.config), ida_lines.SCOLOR_AUTOCMT))
        for i in self.handler.body:
            i: CsInsn
            self.AddLine(ida_lines.COLSTR(
                f'{i.address:016X} {i.mnemonic:<8} {i.op_str}', ida_lines.SCOLOR_INSN))

        if isinstance(self.handler, VMJmp):
            self.AddLine(ida_lines.COLSTR(
                str(self.handler.conn_config), ida_lines.SCOLOR_AUTOCMT))
        else:
            self.AddLine('')
        for i in self.handler.connect:
            i: CsInsn
            self.AddLine(ida_lines.COLSTR(
                f'{i.address:016X} {i.mnemonic:<8} {i.op_str}', ida_lines.SCOLOR_INSN))
        self.Refresh()

    @staticmethod
    def get_instance():
        return _handler_viewer

    def show_win(self, handler):
        if not self.Create(handler):
            return False
        ida_kernwin.display_widget(
            self.GetWidget(), idaapi.PluginForm.WOPN_DP_TAB | idaapi.PluginForm.WOPN_RESTORE)
        ida_kernwin.set_dock_pos(
            self.title, "HandlerListView", ida_kernwin.DP_RIGHT)
        self.Show()
        return True


class HandlerListView(Choose):
    class Item():
        def __init__(self, address, name, body_len) -> None:
            self.address = address
            self.name = name
            self.body_len = body_len

        def to_strings(self):
            s = [f'{self.address:016X}', self.name, str(self.body_len)]
            return s

    def __init__(self, title, flags=0):
        Choose.__init__(self, title,
                        [["Address", 15], ["Name", 20], ["BodyLen", 5]],
                        flags=flags | Choose.CH_CAN_REFRESH)

        self.items = []
        self.reload()

    def reload(self):
        self.items = []
        for k, v in vm_handlers.items():
            self.items.append(HandlerListView.Item(
                k, f'{v.name}@{v.opsize}', len(v.body)))

    def OnInit(self):
        return True

    def OnGetSize(self):
        return len(self.items)

    def OnGetLine(self, n):
        return self.items[n].to_strings()

    def OnGetIcon(self, n):
        return 81

    def OnGetLineAttr(self, n):
        # return [0xFF0000, 0]
        return None

    def OnRefresh(self, n):
        self.reload()
        return None  # call standard refresh

    def OnSelectLine(self, n):
        ea = self.items[n].address
        print(hex(ea))
        h = vm_handlers.get(ea, None)
        if h is not None:
            print(h.name)
            HandlerViewer.get_instance().show_win(h)
        return (Choose.NOTHING_CHANGED, )

    def OnClose(self):
        return

    def show(self):
        self.reload()
        return self.Show(False) >= 0


# -----------------------------------------------------------------------


_handler_viewer = HandlerViewer()
_handler_list_viewer = HandlerListView("HandlerListView")


def show_handler_list_view():
    _handler_list_viewer.show()

```

`novmpy/views/vtil_graph.py`:

```py
import collections
import idautils
import ida_lines
# -----------------------------------------------------------------------
# This is an example illustrating how to use the user graphing functionality
# in Python
# (c) Hex-Rays
#
import ida_dbg
import ida_graph
import ida_kernwin
import ida_ida
import ida_name
from ida_nalt import get_str_type
from ida_bytes import is_strlit, get_flags, get_strlit_contents

from pyvtil import *
from novmpy.vm_lifter import VMLifter
from novmpy.vm import VMState
import os
from novmpy.bridge import *


class _base_graph_action_handler_t(ida_kernwin.action_handler_t):
    def __init__(self, graph):
        ida_kernwin.action_handler_t.__init__(self)
        self.graph: MyGraph = graph

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_FOR_WIDGET


def ask_list(str_list):
    class ListForm(ida_kernwin.Form):
        def __init__(self, _str_list):
            F = ida_kernwin.Form
            F.__init__(self, r"""BUTTON YES OK

                <pass:{str_list}>
                """, {'str_list': F.DropdownListControl(items=_str_list, readonly=True)})

    f = ListForm(str_list)
    f, args = f.Compile()
    ok = f.Execute()
    result = ''
    if ok and f.str_list.value >= 0:
        result = str_list[f.str_list.value]
    f.Free()
    return result


class GraphOptimizer(_base_graph_action_handler_t):
    def activate(self, ctx):
        print('Optimizer')
        if self.graph.rtn is None:
            return 0
        node_id = ida_graph.viewer_get_curnode(
            ida_graph.get_graph_viewer(self.graph.GetWidget()))
        print('node_id', node_id)
        block = None
        if node_id >= 0:
            if self.graph.rtn is None:
                return 0
            for vip, b in self.graph.rtn.explored_blocks.items():
                if vip == self.graph.list_vip[node_id]:
                    block = b
                    break
        optimizers = {
            'apply_all': vtil.optimizer.apply_all,
            'stack_pinning_pass': vtil.optimizer.stack_pinning_pass,
            'istack_ref_substitution_pass': vtil.optimizer.istack_ref_substitution_pass,
            'bblock_extension_pass': vtil.optimizer.bblock_extension_pass,
            'stack_propagation_pass': vtil.optimizer.stack_propagation_pass,
            'dead_code_elimination_pass': vtil.optimizer.dead_code_elimination_pass,
            'fast_dead_code_elimination_pass': vtil.optimizer.fast_dead_code_elimination_pass,
            'mov_propagation_pass': vtil.optimizer.mov_propagation_pass,
            'symbolic_rewrite_pass_force': vtil.optimizer.symbolic_rewrite_pass_force,
            'symbolic_rewrite_pass': vtil.optimizer.symbolic_rewrite_pass,
            'branch_correction_pass': vtil.optimizer.branch_correction_pass,
            'register_renaming_pass': vtil.optimizer.register_renaming_pass,
            'collective_cross_pass': vtil.optimizer.collective_cross_pass,
        }
        if choose := ask_list(list(optimizers.keys())):
            optimizer = optimizers[choose]
            if block is None:
                optimizer(self.graph.rtn)
            else:
                optimizer(block)
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_FOR_WIDGET


class GraphLoad(_base_graph_action_handler_t):
    def activate(self, ctx):
        print('Load')
        _path = ida_kernwin.ask_file(False, '*.vtil', 'Choose vtil file:')
        if _path:
            self.graph.rtn = vtil.routine.load(_path)
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_FOR_WIDGET


class GraphSave(_base_graph_action_handler_t):
    def activate(self, ctx):
        print('Save')
        if self.graph.rtn is None:
            return 0
        _path = ida_kernwin.ask_file(
            True, '*.vtil', 'Enter name of vtil file:')
        if _path:
            self.graph.rtn.save(_path)
        return 0

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_FOR_WIDGET


class JumptoAction(_base_graph_action_handler_t):
    def activate(self, ctx):
        gv = ida_graph.get_graph_viewer(ctx.widget)
        print('whoooooops, not impl')
        # s = ida_kernwin.ask_str('', 0, 'addr')
        # if s:
        #     ea = ida_kernwin.str2ea(s)
        #     self.graph.jumpto(nid, lnnum)
        return 0

    def update(self, ctx):
        # FIXME:
        if not self.graph.focus or self.graph.GetWidget() != ctx.widget:
            return ida_kernwin.AST_DISABLE_FOR_WIDGET
        return ida_kernwin.AST_ENABLE_FOR_WIDGET


def pack_operands(ins: vtil.instruction):
    operands = ins.operands
    opstr = []
    for op in operands:
        color = ida_lines.SCOLOR_REG if op.is_register() else ida_lines.SCOLOR_DNUM
        if ins.base.name == 'js' and op.is_immediate():
            s = hex(op.imm().uval)
        else:
            s = str(op)
        _opstr = ida_lines.COLSTR(s, color)
        opstr.append(_opstr)
    return opstr


dict_cond = {
    'tg': '>', 'tge': '>=',
    'te': '==', 'tne': '!=',
    'tl': '<', 'tle': '<=',
    'tug': 'u>', 'tuge': 'u>=',
    'tul': 'u<', 'tule': 'u<=',
}


def instruction_tostring(basic_block: vtil.basic_block, it, args=None):
    if args is None:
        args = dict()
    # @https://github.com/vtil-project/VTIL-BinaryNinja/blob/master/vtil/vtil.py
    ins: vtil.instruction = it.get()
    s = ''
    comment = ''
    s += ida_lines.COLSTR(f'{ins.base.to_string(ins.access_size()):6}',
                          ida_lines.SCOLOR_INSN)
    s += ' '
    opstr = pack_operands(ins)
    if ins.base.name in dict_cond:
        # op0 = op1 cond op2
        s += opstr[0]
        s += ida_lines.COLSTR(' := (', ida_lines.SCOLOR_SYMBOL)
        s += opstr[1]
        s += ida_lines.COLSTR(f' {dict_cond[ins.base.name]} ',
                              ida_lines.SCOLOR_SYMBOL)
        s += opstr[2]
        s += ida_lines.COLSTR(')', ida_lines.SCOLOR_SYMBOL)
    elif ins.base.name == 'js':
        # op0 ? op1: op2
        s += opstr[0]
        s += ida_lines.COLSTR(' ? ', ida_lines.SCOLOR_SYMBOL)
        s += opstr[1]
        s += ida_lines.COLSTR(' : ', ida_lines.SCOLOR_SYMBOL)
        s += opstr[2]
    elif ins.base.name == 'str':
        # [op0+op1], op2
        s += ida_lines.COLSTR('[', ida_lines.SCOLOR_SYMBOL) + opstr[0]
        s += ida_lines.COLSTR('+', ida_lines.SCOLOR_SYMBOL) + opstr[1]
        s += ida_lines.COLSTR('], ', ida_lines.SCOLOR_SYMBOL) + opstr[2]
    elif ins.base.name == 'ldd':
        # op0, [op1, op2]
        s += opstr[0]
        s += ida_lines.COLSTR(', ', ida_lines.SCOLOR_SYMBOL)
        s += ida_lines.COLSTR('[', ida_lines.SCOLOR_SYMBOL)
        s += opstr[1]
        s += ida_lines.COLSTR('+', ida_lines.SCOLOR_SYMBOL)
        s += opstr[2]
        s += ida_lines.COLSTR(']', ida_lines.SCOLOR_SYMBOL)
    else:
        for i, op in enumerate(ins.operands):
            # chr(cvar.COLOR_ADDR+i+1)
            color = ida_lines.SCOLOR_DNUM
            if op.is_register():
                color = ida_lines.SCOLOR_REG
            s += ida_lines.COLSTR(f'{str(op)}', color)
            if i+1 != len(ins.operands):
                s += ida_lines.COLSTR(', ', ida_lines.SCOLOR_SYMBOL)
    imm = 0
    for i, op in enumerate(ins.operands):
        if op.is_immediate() and op.imm().ival > imm:
            imm = op.imm().ival
    if imm > 0:
        if is_strlit(get_flags(imm)):
            content = get_strlit_contents(imm, -1, get_str_type(imm))
            content = content.decode('UTF-8', 'replace')
            comment += repr(content[:30])
            if len(content) > 30:
                comment += '...'
        else:
            comment += ida_name.get_name(imm)
    bs_size = args.get('bs_size', 0)
    skip_size = args.get('skip_size', 0)
    if ins.base == vtil.ins.vemit:
        asm_bytecode = b''
        if bs_size == 0:
            bs_size = ins.operands[0].size()
            it2 = it
            while it2 != basic_block.end():
                i2: vtil.instruction = it2.get()
                if i2.base != vtil.ins.vemit:
                    break
                uval = i2.operands[0].imm().uval
                for _ in range(i2.operands[0].size()):
                    asm_bytecode += bytes([uval & 0xFF])
                    uval >>= 8
                it2 = it2.next()
            if asm_bytecode:
                asm_vip = ins.vip if ins.vip != vtil.invalid_vip else 0
                for a in bridge.disasm(asm_bytecode, asm_vip):
                    comment = a.mnemonic+' '+a.op_str
                    skip_size = a.size
                    break
        else:
            bs_size += ins.operands[0].size()
    if bs_size >= skip_size or ins.base != vtil.ins.vemit:
        skip_size = 0
        bs_size = 0
    args['bs_size'] = bs_size
    args['skip_size'] = skip_size
    if comment:
        s += ida_lines.COLSTR(' ; '+comment, ida_lines.SCOLOR_AUTOCMT)
    return s


class MyGraph(ida_graph.GraphViewer):
    def __init__(self, title):
        self.list_vip = []
        self.focus = True
        self.title = title
        self.rtn: vtil.routine = None
        ida_graph.GraphViewer.__init__(self, self.title, True)
        self.color = 0xffffff
        self.jump_to_desc = ida_kernwin.action_desc_t(
            f"graph_{title}:jumpto", "jumpto", JumptoAction(self), "G", "")
        ida_kernwin.register_action(self.jump_to_desc)

    def Show(self):
        if not ida_graph.GraphViewer.Show(self):
            return False
        ida_graph.viewer_set_titlebar_height(self.GetWidget(), 15)
        ida_kernwin.attach_action_to_popup(
            self.GetWidget(), None, self.jump_to_desc.name)
        self.cmd_refresh = self.AddCommand("Refresh", "")
        self.cmd_trace = self.AddCommand("Trace", "")
        self.cmd_patch = self.AddCommand("Patch Instruction", "")
        self.cmd_erase = self.AddCommand("Erase Instruction", "")
        self.cmd_hview = self.AddCommand("Handler list", "")
        return True

    def OnCommand(self, cmd_id):
        print('OnCommand', cmd_id)

        if cmd_id == self.cmd_refresh:
            self.Refresh()
            return 1
        elif cmd_id == self.cmd_hview:
            from novmpy.views.hview import show_handler_list_view
            show_handler_list_view()
            return 0
        widget = ida_graph.get_graph_viewer(self.GetWidget())
        place, _, _ = ida_kernwin.get_custom_viewer_place(widget, False)
        node_id = ida_graph.viewer_get_curnode(widget)
        print(node_id, place.lnnum)
        ln = place.lnnum - 1
        if node_id < 0 or ln < 0:
            return 0
        block = None
        if self.rtn is None:
            return 0
        for vip, b in self.rtn.explored_blocks.items():
            if vip == self.list_vip[node_id]:
                block = b
                break
        if block:
            it = block.begin()
            if cmd_id in [self.cmd_patch, self.cmd_erase] and block.size() == ln + 1:
                return 0
            for i in range(ln):
                it = it.next()
            ins = it.get()
            if cmd_id == self.cmd_trace:
                if not it.get().base.is_branching():
                    it = it.next()
                tracer = vtil.tracer()
                for i in ins.operands:
                    if i.is_register() and i.reg() != vtil.REG_IMGBASE:
                        print(
                            f'{i} = {tracer.rtrace(vtil.symbolic.variable(it, i.reg())).simplify(True)}')
            elif cmd_id == self.cmd_patch:
                val = ida_kernwin.ask_long(0, 'patch: mov reg, {imm}')
                if val is not None and len(ins.operands) >= 2:
                    ins.base = vtil.ins.mov
                    op0 = ins.operands[0]
                    ins.operands = [op0, vtil.make_uint(val, op0.bit_count())]
                    self.Refresh()
                    return 1
            elif cmd_id == self.cmd_erase:
                msg = ida_lines.tag_remove(instruction_tostring(block, it))
                if ida_kernwin.ask_yn(ida_kernwin.ASKBTN_NO, f'Erase:\n{msg}') != ida_kernwin.ASKBTN_YES:
                    return 0
                block.erase(it)
                self.Refresh()
                return 1
        return 0

    def OnActivate(self):
        self.focus = True

    def OnDeactivate(self):
        self.focus = False

    def OnRefresh(self):
        self.Clear()
        self.list_vip = []
        if self.rtn is None:
            return True
        for vip, b in self.rtn.explored_blocks.items():
            args = {}
            b: vtil.basic_block
            s = hex(vip)+':\n'
            it = b.begin()
            while it != b.end():
                i: vtil.instruction = it.get()
                _prefix = ''
                # _prefix = f'[ {i.vip:016X} ]' if i.vip != vtil.invalid_vip else '[    PSEUDOCODE    ]'
                _prefix += f'[{i.sp_index:>2}] ' if i.sp_index > 0 else '     '
                x = '>' if i.sp_reset > 0 else ' '
                x += '+' if i.sp_offset > 0 else '-'
                x += hex(abs(i.sp_offset))
                _prefix += f'{x:<6} '
                if ida_ida.inf_show_line_pref():
                    s += ida_lines.COLSTR(_prefix, ida_lines.SCOLOR_PREFIX)
                s += instruction_tostring(b, it, args) + '\n'
                it = it.next()
            color = self.color
            self.AddNode((s.rstrip('\n'), color))
            self.list_vip.append(vip)

        for vip, b in self.rtn.explored_blocks.items():
            s = self.list_vip.index(vip)
            # if b.size() > 0:
            #     back = b.back()
            #     if back.base.name == 'js':
            #         cond, dst1, dst2 = back.operands
            #         # op1 op2 is imm -> mark tbranch and fbranch
            #         if dst1.is_immediate() and dst2.is_immediate():
            #             # WTF? how to set edge color
            #             # SHIT! They ignore the `edge_info` parameter!
            # https://github.com/idapython/src/blob/3ce5b7f06dfdba36eb84d679c08248734a12036a/pywraps/py_graph.hpp#L431-L432
            #             self.AddEdge(s, list_vip.index(dst1.imm().u64)) # T
            #             self.AddEdge(s, list_vip.index(dst2.imm().u64)) # F
            #             continue

            for next_b in b.next:
                d = self.list_vip.index(next_b.entry_vip)
                self.AddEdge(s, d)
        return True

    def OnGetText(self, node_id):
        return self[node_id]

    def OnPopup(self, form, popup_handle):
        ida_graph.GraphViewer.OnPopup(self, form, popup_handle)
        popup = collections.OrderedDict({
            'Optimizer': GraphOptimizer(self),
            'Load': GraphLoad(self),
            'Save': GraphSave(self),
        })
        for k, v in popup.items():
            ida_kernwin.attach_dynamic_action_to_popup(
                form, popup_handle,
                ida_kernwin.action_desc_t(k + ":" + self.title, k, v))

    def OnClose(self):
        print('close', self.GetWidget())
        ida_kernwin.detach_action_from_popup(
            self.GetWidget(), self.jump_to_desc.name)
        ida_kernwin.unregister_action(self.jump_to_desc.name)

    def OnHint(self, node_id):
        # cursor in title return [-1, -1]
        tmp = ida_kernwin.get_custom_viewer_place(
            ida_graph.get_graph_viewer(self.GetWidget()), True)
        if len(tmp) != 3:
            return 'node:'+str(node_id)
        place, _, _ = tmp
        return 'nid:'+str(node_id)+'lnnum:'+str(place.lnnum)

    def OnDblClick(self, node_id):
        """
        Triggerd when a node is double-clicked.
        @return: False to ignore the click and True otherwise
        """
        # print("dblclicked on", self[node_id])
        hl = ida_kernwin.get_highlight(self.GetWidget())
        if hl and hl[0].startswith('0x'):
            addr, flag = int(hl[0], 16), hl[1]
            if addr in self.list_vip:
                self.jumpto(self.list_vip.index(addr), 0)
            else:
                ida_kernwin.jumpto(addr)

        return True

    def jumpto(self, nid, lnnum):
        place = ida_graph.create_user_graph_place(nid, lnnum)
        ida_kernwin.jumpto(self.GetWidget(), place, -1, -1)


def show_graph(ea):
    widegt = ida_kernwin.find_widget(f'VTIL: {ea:016X}')
    if widegt:
        ida_kernwin.activate_widget(widegt, True)
        return None
    g = MyGraph(f'VTIL: {ea:016X}')
    root = os.path.join(idautils.GetIdbDir(), 'vms')
    if not os.path.exists(root):
        os.mkdir(root)
    premature = os.path.join(root, f'{ea:016X}.premature.vtil')
    optimized = os.path.join(root, f'{ea:016X}.optimized.vtil')
    if os.path.exists(optimized):
        print(f'Load VTIL from filecache {optimized}')
        g.rtn = vtil.routine.load(optimized)
    else:
        lifter = VMLifter()
        ida_kernwin.show_wait_box("lifting")
        try:
            lifter.lift_il(None, VMState(current_handler=ea))
            print('Saving premature')
            lifter.rtn.save(premature)
            ida_kernwin.replace_wait_box('apply_all_profiled')
            vtil.optimizer.apply_all_profiled(lifter.rtn)
            print('Saving optimized')
            lifter.rtn.save(optimized)
        except KeyboardInterrupt as e:
            print(e)
            lifter.rtn = None
        finally:
            ida_kernwin.hide_wait_box()
        # vtil.debug.dump(lifter.rtn)
        g.rtn = lifter.rtn
    if g.Show():
        # jumpto(g.GetWidget(), ida_graph.create_user_graph_place(0,1), 0, 0)
        # ida_graph.viewer_attach_menu_item(g.GetWidget(), )
        return g
    else:
        return None

```

`novmpy/vm.py`:

```py
from novmpy.bridge import *
from capstone import *
from capstone.x86 import *
from novmpy.x86_deobf import *
from novmpy.match_helper import *


class VMConfig:
    def __init__(self):
        self.reg_key = X86_REG_INVALID
        self.reg_ip = X86_REG_INVALID
        self.reg_sp = X86_REG_INVALID
        self.reg_regs = extend_reg(X86_REG_ESP)
        self.reg_base = X86_REG_INVALID
        self.dir = 0
        self.rebase = 0

    def __str__(self):
        return 'VMConfig : r_key({}) r_ip({}) r_sp({}) r_regs({}) r_base({}) dir({}) rebase({})'.format(
            bridge.reg_name(self.reg_key), bridge.reg_name(
                self.reg_ip), bridge.reg_name(self.reg_sp),
            bridge.reg_name(self.reg_regs), bridge.reg_name(self.reg_base), self.dir, hex(self.rebase))

    def __repr__(self) -> str:
        return self.__str__()


class VMState:
    def __init__(self, **kwargs):
        self.ip = kwargs.get('ip', 0)
        self.key = kwargs.get('key', 0)
        self.current_handler = kwargs.get('current_handler', 0)
        self.config: VMConfig = kwargs.get('config', None)

    def get_address(self):
        return self.ip-self.config.dir*4

    def decode_emu(self, decoder, ct, reg, size):
        mask = get_mask(size*8)
        reg_key_op = X86_REG_INVALID
        cached_regs = {}
        if size == 1:
            reg_key_op = get_reg8(self.config.reg_key)
        elif size == 2:
            reg_key_op = get_reg16(self.config.reg_key)
        elif size == 4:
            reg_key_op = get_reg32(self.config.reg_key)
        elif size == 8:
            reg_key_op = get_reg64(self.config.reg_key)
        else:
            raise NotImplementedError('')
        pt = ct & mask
        for insn in decoder:
            insn: CsInsn
            regs_read, regs_write = insn.regs_access()
            # xor r11d, imm  regs_write = [??,r11d]
            if reg in regs_write:
                if insn.id == X86_INS_INC:
                    pt += 1
                elif insn.id == X86_INS_DEC:
                    pt -= 1
                elif insn.id == X86_INS_NOT:
                    pt = ~pt
                elif insn.id == X86_INS_NEG:
                    pt = 0-pt
                elif insn.id == X86_INS_BSWAP:
                    if insn.operands[0].size == 8:
                        pt = ((pt & 0xFF) << (7*8)) |\
                            ((pt & 0xFF00) << (5*8)) |\
                            ((pt & 0xFF0000) << (3*8)) | \
                            ((pt & 0xFF000000) << (1*8)) |\
                            ((pt & 0xFF00000000) >> (1*8)) | \
                            ((pt & 0xFF0000000000) >> (3*8)) |\
                            ((pt & 0xFF000000000000) >> (5*8)) | \
                            ((pt & 0xFF00000000000000) >> (7*8))
                    elif insn.operands[0].size == 4:
                        pt = ((pt & 0xFF) << 24) | ((pt & 0xFF00) << 8) |\
                            ((pt & 0xFF0000) >> 8) | ((pt & 0xFF000000) >> 24)
                elif instr_match(insn, [X86_INS_XOR, X86_INS_ADD, X86_INS_SUB], [X86_OP_REG, X86_OP_IMM], [reg]):
                    if insn.id == X86_INS_XOR:
                        pt ^= insn.operands[1].imm
                    elif insn.id == X86_INS_ADD:
                        pt += insn.operands[1].imm
                    elif insn.id == X86_INS_SUB:
                        pt -= insn.operands[1].imm
                elif instr_match(insn, [X86_INS_ROL, X86_INS_ROR], [X86_OP_REG, X86_OP_IMM], [reg]):
                    n = insn.operands[1].imm & 0x1F
                    if insn.id == X86_INS_ROL:
                        pt = ((pt & mask) << n) | (
                            (pt & mask) >> ((8 * size) - n))
                    elif insn.id == X86_INS_ROR:
                        pt = ((pt & mask) >> n) | (
                            (pt & mask) << ((8 * size) - n))
                elif instr_match(insn, X86_INS_XOR, [X86_OP_REG, X86_OP_REG], [reg, reg_key_op]):
                    pt ^= self.key
                elif instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_REG]):
                    # add ip, rebase
                    pt += self.config.rebase
                elif instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [reg, {'base': reg, 'index': X86_REG_INVALID, 'scale': 1}]):
                    pt += insn.operands[1].mem.disp
                elif instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [reg, {'base': reg, 'disp': 0, 'scale': 1}]):
                    # fix lea ip, [ip+ecx]
                    pt += self.config.rebase
                else:
                    print(decoder)
                    raise NotImplementedError(insn)
                pt &= mask
            elif bridge.is64bit() and size == 4:
                if instr_match(insn, [X86_INS_MOV, X86_INS_MOVABS], [X86_OP_REG, X86_OP_IMM]):
                    cached_regs[insn.operands[0].reg] = insn.operands[1].imm
                reg_64 = extend_reg(reg)
                if reg_64 in regs_write:
                    if (instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [self.config.reg_ip, {'base': self.config.reg_ip, 'disp': 0, 'scale': 1}]) or
                        instr_match(insn, X86_INS_LEA, [X86_OP_REG, X86_OP_MEM], [self.config.reg_ip, {'index': self.config.reg_ip, 'disp': 0, 'scale': 1}]) or
                            instr_match(insn, X86_INS_ADD, [X86_OP_REG, X86_OP_REG], [self.config.reg_ip])):
                        if insn.id == X86_INS_ADD:
                            src = insn.operands[1].reg
                        else:
                            mem = insn.operands[1].mem
                            src = mem.index if mem.base == self.config.reg_ip else mem.base
                        pt += cached_regs.get(src, self.config.rebase)
                    else:
                        print('warning decode_emu 64', insn)
                    pt &= get_mask(64)
            # update key   -> xor reg_key_op, reg
            if instr_match(insn, X86_INS_XOR, [X86_OP_REG, X86_OP_REG], [reg_key_op, reg]):
                self.key ^= pt & mask
            if instr_match(insn, X86_INS_XOR, [X86_OP_MEM, X86_OP_REG], [None, reg]):
                self.key ^= pt & mask
        return pt

    def fetch(self, size) -> int:
        i = bridge.read(self.ip, size, self.config.dir)
        self.ip += self.config.dir*size
        return i

```

`novmpy/vm_const.py`:

```py
VM_INS_INVALID = 0
VM_INS_UNKNOWN = 1
VM_INS_NOP = 2
VM_INS_JMP = 3

VM_INS_PUSH_REG = 4
VM_INS_POP_REG = 5

VM_INS_PUSH_IMM = 6

VM_INS_PUSH_SP = 7
VM_INS_POP_SP = 8

VM_INS_ADD = 9
VM_INS_NAND = 10
VM_INS_NOR = 11

VM_INS_STR = 12
VM_INS_LDR = 13
VM_INS_CRC = 14
VM_INS_CALL = 15
VM_INS_EXIT = 16

VM_INS_RCL = 18
VM_INS_RCR = 19
VM_INS_ROL = 20
VM_INS_ROR = 21
VM_INS_SAL = 22
VM_INS_SAR = 23
VM_INS_SHL = 24
VM_INS_SHR = 25

VM_INS_SHLD = 26
VM_INS_SHRD = 27

VM_INS_MUL = 28
VM_INS_IMUL = 29

VM_INS_DIV = 30
VM_INS_IDIV = 31


VM_INS_RDTSC = 32
VM_INS_CPUID = 33

VM_INS_PUSH_EFLAGS = 34
VM_INS_POP_EFLAGS = 35

VM_INS_PUSH_CRX = 36
VM_INS_POP_CRX = 37

VM_INS_LOCK_XCHG = 38
```

`novmpy/vm_lifter.py`:

```py
from capstone import *
from capstone.x86 import *

from novmpy import handler
from novmpy.bridge import *
from novmpy.match_helper import *
from novmpy.x86_deobf import *
from novmpy.vm_const import *
from novmpy.vm import *
from pyvtil import *

# ref: https://github.com/can1357/NoVmp/blob/master/NoVmp/vmprotect/vtil_lifter.cpp


def search_vmstubs():
    """
    jmp_call stub
    stub:
    push imm4
    call vminit
    """
    stubs = []
    for seg in bridge.get_segs():
        if not seg.is_executable:
            continue
        for i, b in enumerate(bridge.get_bytes(seg.vaddr, seg.memsize)):
            addr = seg.vaddr + i
            if b == 0xE8 or b == 0xE9:
                dst = addr+bridge.read(addr+1, 4)+5
                if bridge.is_readable(dst, 1) and not (dst >= seg.min_addr and dst < seg.max_addr):
                    if bridge.read(dst, 1) == 0x68 and bridge.read(dst+5, 1) == 0xE8:
                        print(f'Discovered vmenter at 0x{addr:X}...')
                        stubs.append((dst-bridge.get_base(), b == 0xE9))
    return stubs


def fix_constant_pool(block: vtil.basic_block, rel_base=0):
    vtil.optimizer.stack_pinning_pass(block)
    vtil.optimizer.istack_ref_substitution_pass(block)

    reloc_base = vtil.symbolic.pointer(vtil.symbolic.variable(
        block.begin(), vtil.REG_SP).to_expression())

    def exp_eval(uid):
        var = uid.get_variable()
        if var.is_register() and var.reg().is_image_base():
            return 0
        if var.is_memory() and ((var.mem().base - reloc_base) == 0):
            return rel_base & get_mask(bridge.size*8)
        return None

    tracer = vtil.cached_tracer()

    it = block.begin()
    while it != block.end():
        ins = it.get()
        if ins.base != vtil.ins.ldd:
            it = it.next()
            continue
        base, off = ins.memory_location()
        if base.is_stack_pointer():
            it = it.next()
            continue

        exp = tracer(vtil.symbolic.variable(it, base))
        res = exp.evaluate(exp_eval)

        if res.is_known():
            rva = (res.get_uint64() + off) & get_mask(bridge.size*8)
            if bridge.is_readable(rva, ins.access_size()//8) and\
                    not bridge.is_writeable(rva, ins.access_size()//8):
                value = bridge.read(rva, ins.access_size()//8)
                print(f'fix_constant_pool [{rva:016X}] = {value:016X}')
                ins.base = vtil.ins.mov
                ins.operands = [ins.operands[0],
                                vtil.make_uint(value, ins.access_size())]
        it = it.next()


class VMLifter:
    def __init__(self) -> None:
        self.rtn = vtil.routine()
        self.rel_base = 0  # default_base - real_base

    def is_valid_vmentry(self, vmentry):
        return handler.vmentry_parse(vmentry) != None

    def lift_il(self, block: vtil.basic_block, state: VMState):
        if state.ip == 0:
            vmp_entry = state.current_handler
            parse_result = handler.vmentry_parse(vmp_entry)
            assert parse_result

            tmp_state = parse_result.vmstate
            # stub.extend(vminit.save_regs)

            print('vmstate.ip: {:x}'.format(tmp_state.ip))
            # 0x0048AFF0| vm_init 0x4514a9
            vip = tmp_state.ip
            vip += 0 if tmp_state.config.dir >= 0 else -1
            tmp_state.current_handler = parse_result.vminit.get_next(tmp_state)
            if block is None:
                block, _ = self.rtn.create_block(vmp_entry)
            else:
                new_block = block.fork(vmp_entry)
                if new_block is None:
                    return self.rtn.get_block(vmp_entry)
                block = new_block
            # push imm
            block.push(vtil.make_int(parse_result.vm_imm))
            # call vm_init
            block.push(parse_result.vm_imm2)
            for i, j in parse_result.vminit.pushs:
                if i == CS_OP_IMM:
                    self.rel_base = j
                    treloc = block.tmp(vtil.arch.bit_count)
                    block.mov(treloc, vtil.REG_IMGBASE)  # 0x140000000
                    block.sub(treloc, vtil.make_int(-self.rel_base))
                    block.push(treloc)
                elif i == CS_OP_REG:
                    if j == X86_REG_EFLAGS:
                        block.pushf()
                    else:
                        block.push(vtil.x86_reg(j))
            # 得切分成两个基本块，因为存在从其它基本块直接跳入vip的情况。
            block.jmp(vip)
            new_block = block.fork(vip)
            if new_block is None:
                return self.rtn.get_block(vip)
            block = new_block
        else:
            if block is None:
                return None
            tmp_state = state
        # Messages cannot be updated frequently, which can slow down performance.
        if not bridge.update_msg(f'lifting {block.entry_vip:08X}'):
            raise KeyboardInterrupt('User interrupted')
        while True:
            h = handler.factory(tmp_state.current_handler, tmp_state.config)
            if h is None:
                break
            i: handler.VMIns = h.get_instr(tmp_state)

            if isinstance(h, handler.VMInvalid):
                print(f'invalid handler {hex(h.address)}')

            print(block.sp_offset, i)
            block.label_begin(i.address)
            h.generator(i, block)
            block.label_end()
            assert not isinstance(h, handler.VMInvalid)
            assert not isinstance(h, handler.VMUnknown)

            if isinstance(h, handler.VMNop):
                dst = tmp_state.ip
                if tmp_state.config.dir < 0:
                    dst -= 1
                block.jmp(dst)
                fix_constant_pool(block, self.rel_base)
                tmp_state.current_handler = h.get_next(tmp_state)
                self.lift_il(block.fork(dst), tmp_state)
                return block
            elif isinstance(h, handler.VMJmp):
                jmp_dest = block.tmp(vtil.arch.bit_count)
                block.pop(jmp_dest)
                if h.conn_config.dir < 0:
                    block.sub(jmp_dest, 1)
                block.jmp(jmp_dest)

                fix_constant_pool(block, self.rel_base)

                # block.owner.local_opt_count += vtil.optimizer.apply_all(block, False)

                flag = vtil.optimizer.aux.branch_analysis_flags(pack=True)
                tracer = vtil.tracer()
                branch_info = vtil.optimizer.aux.analyze_branch(
                    block, tracer, flag)

                print(f"CC {branch_info.cc}")
                print(f"VJMP {branch_info.destinations}")

                def eval_base_remove(uid):
                    var = uid.get_variable()
                    if var.is_register() and var.reg().is_image_base():
                        return 0
                    return None

                targets = []
                for branch in branch_info.destinations:
                    if not branch.is_constant():
                        branch = tracer.rtrace_pexp(branch)
                    if not branch.is_constant():
                        res = branch.evaluate(eval_base_remove)
                        if res.is_known():
                            targets.append(res.get_uint64())
                            continue
                    if not branch.is_constant():
                        continue
                    print(f'Exploring branch => {branch}')
                    targets.append(branch.get_uint64())
                for target in targets:
                    ip = target
                    if h.conn_config.dir < 0:
                        ip += 1
                    if ip > 0x1000 and bridge.is_readable(ip, 1, h.conn_config.dir):
                        tmp_state2 = copy.deepcopy(tmp_state)
                        tmp_state2.config = h.conn_config
                        tmp_state2.ip = ip
                        tmp_state2.key = (tmp_state2.ip-tmp_state2.config.rebase) & get_mask(bridge.size*8)
                        next_h = h.get_next(tmp_state2)
                        if bridge.is_readable(next_h, 4):
                            tmp_state2.current_handler = next_h
                            self.lift_il(block.fork(target), tmp_state2)
                break
            elif isinstance(h, handler.VMExit):
                for r in h.pops:
                    if r == X86_REG_EFLAGS:
                        block.popf()
                    else:
                        block.pop(vtil.x86_reg(r))
                jmp_dest = block.tmp(vtil.arch.bit_count)
                block.pop(jmp_dest)
                block.vexit(jmp_dest)

                fix_constant_pool(block, self.rel_base)

                jmp_dest = block.back().operands[0]

                tracer = vtil.tracer()
                stack_0 = vtil.symbolic.variable(
                    block.owner.entry_point.begin(), vtil.REG_SP).to_expression()
                stack_1 = tracer.rtrace_p(vtil.symbolic.variable(
                    block.end().prev(), vtil.REG_SP)) + vtil.symbolic.expression(block.sp_offset, vtil.arch.bit_count)
                offset = stack_1 - stack_0
                print(f'sp offset => {offset}')
                if offset.is_constant() and offset.get_int() < 0:
                    mem = vtil.symbolic.variable.memory_t(tracer(vtil.symbolic.variable(
                        block.end().prev(), vtil.REG_SP)) + vtil.symbolic.expression(block.sp_offset, vtil.arch.bit_count), vtil.arch.bit_count)
                    var = vtil.symbolic.variable(block.end().prev(), mem)
                    base_exp = vtil.symbolic.variable(
                        vtil.REG_IMGBASE).to_expression()
                    continue_from = tracer.rtrace_p(var) - base_exp
                    print(f'continue => {continue_from}')
                    if continue_from.is_constant() and self.is_valid_vmentry(continue_from.get_uint()):
                        # block.pop_back()
                        # block.vxcall(jmp_dest)
                        block.wback().base = vtil.ins.vxcall
                        block.wback().vip = tmp_state.ip
                        block.shift_sp(vtil.arch.size, False, block.end())

                        tmp_state = VMState()
                        tmp_state.current_handler = continue_from.get_uint()
                        self.lift_il(block, tmp_state)
                        break

                if jmp_dest.is_immediate():
                    exit_destination = vtil.symbolic.expression(
                        jmp_dest.imm().uval, jmp_dest.bit_count)
                else:
                    var = vtil.symbolic.variable(
                        block.end().prev(), jmp_dest.reg())
                    exit_destination = tracer.rtrace_p(
                        var) - vtil.symbolic.variable(vtil.REG_IMGBASE).to_expression()

                print(f'exit => {exit_destination}')
                if exit_destination.is_constant() and self.is_valid_vmentry(exit_destination.get_uint()):
                    block.pop_back()
                    parse_result = handler.vmentry_parse(
                        exit_destination.get_uint())
                    for _ins in parse_result.vm_unimpl_insn:
                        if _ins.id in [X86_INS_PUSHFD, X86_INS_PUSHFQ]:
                            block.pushf()
                            continue
                        elif _ins.id in [X86_INS_POPFD, X86_INS_POPFQ]:
                            block.popf()
                            continue
                        reads, writes = _ins.regs_access()
                        for reg_read in reads:
                            op = vtil.x86_reg(reg_read)
                            if reg_read in [X86_REG_ESP, X86_REG_RSP]:
                                op = vtil.REG_SP
                            if reg_read == X86_REG_EFLAGS:
                                op = vtil.REG_FLAGS
                            block.vpinr(op)
                        block.label_begin(_ins.address)
                        for b in _ins.bytes:
                            block.vemit(vtil.make_uint(b, 8))
                        block.label_end()
                        for reg_write in writes:
                            op = vtil.x86_reg(reg_write)
                            assert reg_write not in [X86_REG_ESP, X86_REG_RSP]
                            if reg_write == X86_REG_EFLAGS:
                                op = vtil.REG_FLAGS
                            block.vpinw(op)
                    block.jmp(vtil.invalid_vip)

                    state = VMState(current_handler=parse_result.stub_addr)
                    block_next = self.lift_il(block, state)

                    # block.pop_back()
                    # block.jmp(block_next.entry_vip)
                    block.wback().operands = [vtil.make_uint(
                        block_next.entry_vip, vtil.arch.bit_count)]
                break
            elif isinstance(h, handler.VMCrc):
                # TODO:
                # create new block
                # translate crc
                # jump back
                # assert(False)
                pass
            tmp_state.current_handler = h.get_next(tmp_state)
        return block

# for k, h in handler.vm_handlers.items():
#     if isinstance(h, handler.VMUnknown):
#         print('-----------------')
#         print(h.config)
#         for i in h.body:
#             print(i)

```

`novmpy/x86_deobf.py`:

```py
from capstone import *
from capstone.x86 import *

import copy
from novmpy.bridge import *


def get_mask(bits):
    if bits < 0:
        return 0
    return 2**bits-1


def shit_disasm(ea, max_insn_count=-1, term_call_imm=False):
    insn_count = 0
    bbs = []
    bb = []
    addr = ea
    branches = [addr]
    walk = {}
    while True:
        if addr in walk:
            break
        walk[addr] = True
        insn: CsInsn = bridge.disasm_one(addr)
        if insn is None:
            break
        if insn.id == X86_INS_INVALID:
            break
        if max_insn_count > 0 and insn_count >= max_insn_count:
            break
        # op1: X86Op = insn.op_find(X86_OP_IMM,1)
        if insn.group(X86_GRP_JUMP):
            op1: X86Op = insn.operands[0]
            if insn.id != X86_INS_JMP and op1.type == X86_OP_IMM:
                branches.append(op1.imm & get_mask(bridge.size*8))
                branches.append(addr+insn.size)
            # jmp imm
            if insn.id == X86_INS_JMP:
                if op1.type == X86_OP_IMM:
                    addr = op1.imm & get_mask(bridge.size*8)
                    continue
                # jmp reg | jmp [mem]
                else:
                    bb.append(insn)
                    insn_count += 1
                    break
        bb.append(insn)
        insn_count += 1
        if insn.group(X86_GRP_RET):
            break
        if term_call_imm:
            if insn.id == X86_INS_CALL and insn.operands[0].type == X86_OP_IMM:
                break
        addr += insn.size
    cur = 0
    cbb = []
    for i in bb:
        if i.address in branches and cur != i.address:
            if cur != 0:
                bbs.append(cbb)
                cbb = []
            cur = i.address
        cbb.append(i)
    if cbb:
        bbs.append(cbb)
    return bbs


map_reg = [
    [X86_REG_RAX, X86_REG_EAX, X86_REG_AX, X86_REG_AH, X86_REG_AL],
    [X86_REG_RCX, X86_REG_ECX, X86_REG_CX, X86_REG_CH, X86_REG_CL],
    [X86_REG_RDX, X86_REG_EDX, X86_REG_DX, X86_REG_DH, X86_REG_DL],
    [X86_REG_RBX, X86_REG_EBX, X86_REG_BX, X86_REG_BH, X86_REG_BL],

    [X86_REG_RSI, X86_REG_ESI, X86_REG_SI, X86_REG_INVALID, X86_REG_SIL],
    [X86_REG_RDI, X86_REG_EDI, X86_REG_DI, X86_REG_INVALID, X86_REG_DIL],
    [X86_REG_RBP, X86_REG_EBP, X86_REG_BP, X86_REG_INVALID, X86_REG_BPL],
    [X86_REG_RSP, X86_REG_ESP, X86_REG_SP, X86_REG_INVALID, X86_REG_SPL],

    [X86_REG_R8, X86_REG_R8D, X86_REG_R8W, X86_REG_INVALID, X86_REG_R8B],
    [X86_REG_R9, X86_REG_R9D, X86_REG_R9W, X86_REG_INVALID, X86_REG_R9B],
    [X86_REG_R10, X86_REG_R10D, X86_REG_R10W, X86_REG_INVALID, X86_REG_R10B],
    [X86_REG_R11, X86_REG_R11D, X86_REG_R11W, X86_REG_INVALID, X86_REG_R11B],
    [X86_REG_R12, X86_REG_R12D, X86_REG_R12W, X86_REG_INVALID, X86_REG_R12B],
    [X86_REG_R13, X86_REG_R13D, X86_REG_R13W, X86_REG_INVALID, X86_REG_R13B],
    [X86_REG_R14, X86_REG_R14D, X86_REG_R14W, X86_REG_INVALID, X86_REG_R14B],
    [X86_REG_R15, X86_REG_R15D, X86_REG_R15W, X86_REG_INVALID, X86_REG_R15B],
    [X86_REG_EFLAGS, X86_REG_INVALID, X86_REG_INVALID,
        X86_REG_INVALID, X86_REG_INVALID]
]

MASK_EFLAGS_SHIFT = {
    'CF': (1 << 0, X86_EFLAGS_MODIFY_CF | X86_EFLAGS_SET_CF | X86_EFLAGS_RESET_CF | X86_EFLAGS_UNDEFINED_CF, X86_EFLAGS_TEST_CF),
    'PF': (1 << 2, X86_EFLAGS_MODIFY_PF | X86_EFLAGS_SET_PF | X86_EFLAGS_RESET_PF | X86_EFLAGS_UNDEFINED_PF, X86_EFLAGS_TEST_PF),
    'AF': (1 << 4, X86_EFLAGS_MODIFY_AF | X86_EFLAGS_SET_AF | X86_EFLAGS_RESET_AF | X86_EFLAGS_UNDEFINED_AF, X86_EFLAGS_TEST_AF),
    'ZF': (1 << 6, X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_SET_ZF | X86_EFLAGS_RESET_ZF | X86_EFLAGS_UNDEFINED_ZF, X86_EFLAGS_TEST_ZF),
    'SF': (1 << 7, X86_EFLAGS_MODIFY_SF | X86_EFLAGS_SET_SF | X86_EFLAGS_RESET_SF | X86_EFLAGS_UNDEFINED_SF, X86_EFLAGS_TEST_SF),
    'OF': (1 << 11, X86_EFLAGS_MODIFY_OF | X86_EFLAGS_SET_OF | X86_EFLAGS_RESET_OF | X86_EFLAGS_UNDEFINED_OF, X86_EFLAGS_TEST_OF),
    'DF': (1 << 10, X86_EFLAGS_MODIFY_DF | X86_EFLAGS_SET_DF | X86_EFLAGS_RESET_DF, X86_EFLAGS_TEST_DF),
}

dict_regs = {
    X86_REG_INVALID: [X86_REG_INVALID, 0, 0],
    X86_REG_RAX: [X86_REG_RAX, 0, 64],
    X86_REG_EAX: [X86_REG_RAX, 0, 32],
    X86_REG_AX: [X86_REG_RAX, 0, 16],
    X86_REG_AH: [X86_REG_RAX, 8, 8],
    X86_REG_AL: [X86_REG_RAX, 0, 8],
    X86_REG_RCX: [X86_REG_RCX, 0, 64],
    X86_REG_ECX: [X86_REG_RCX, 0, 32],
    X86_REG_CX: [X86_REG_RCX, 0, 16],
    X86_REG_CH: [X86_REG_RCX, 8, 8],
    X86_REG_CL: [X86_REG_RCX, 0, 8],
    X86_REG_RDX: [X86_REG_RDX, 0, 64],
    X86_REG_EDX: [X86_REG_RDX, 0, 32],
    X86_REG_DX: [X86_REG_RDX, 0, 16],
    X86_REG_DH: [X86_REG_RDX, 8, 8],
    X86_REG_DL: [X86_REG_RDX, 0, 8],
    X86_REG_RBX: [X86_REG_RBX, 0, 64],
    X86_REG_EBX: [X86_REG_RBX, 0, 32],
    X86_REG_BX: [X86_REG_RBX, 0, 16],
    X86_REG_BH: [X86_REG_RBX, 8, 8],
    X86_REG_BL: [X86_REG_RBX, 0, 8],
    X86_REG_RSI: [X86_REG_RSI, 0, 64],
    X86_REG_ESI: [X86_REG_RSI, 0, 32],
    X86_REG_SI: [X86_REG_RSI, 0, 16],
    X86_REG_SIL: [X86_REG_RSI, 0, 8],
    X86_REG_RDI: [X86_REG_RDI, 0, 64],
    X86_REG_EDI: [X86_REG_RDI, 0, 32],
    X86_REG_DI: [X86_REG_RDI, 0, 16],
    X86_REG_DIL: [X86_REG_RDI, 0, 8],
    X86_REG_RBP: [X86_REG_RBP, 0, 64],
    X86_REG_EBP: [X86_REG_RBP, 0, 32],
    X86_REG_BP: [X86_REG_RBP, 0, 16],
    X86_REG_BPL: [X86_REG_RBP, 0, 8],
    X86_REG_RSP: [X86_REG_RSP, 0, 64],
    X86_REG_ESP: [X86_REG_RSP, 0, 32],
    X86_REG_SP: [X86_REG_RSP, 0, 16],
    X86_REG_SPL: [X86_REG_RSP, 0, 8],
    X86_REG_R8: [X86_REG_R8, 0, 64],
    X86_REG_R8D: [X86_REG_R8, 0, 32],
    X86_REG_R8W: [X86_REG_R8, 0, 16],
    X86_REG_R8B: [X86_REG_R8, 0, 8],
    X86_REG_R9: [X86_REG_R9, 0, 64],
    X86_REG_R9D: [X86_REG_R9, 0, 32],
    X86_REG_R9W: [X86_REG_R9, 0, 16],
    X86_REG_R9B: [X86_REG_R9, 0, 8],
    X86_REG_R10: [X86_REG_R10, 0, 64],
    X86_REG_R10D: [X86_REG_R10, 0, 32],
    X86_REG_R10W: [X86_REG_R10, 0, 16],
    X86_REG_R10B: [X86_REG_R10, 0, 8],
    X86_REG_R11: [X86_REG_R11, 0, 64],
    X86_REG_R11D: [X86_REG_R11, 0, 32],
    X86_REG_R11W: [X86_REG_R11, 0, 16],
    X86_REG_R11B: [X86_REG_R11, 0, 8],
    X86_REG_R12: [X86_REG_R12, 0, 64],
    X86_REG_R12D: [X86_REG_R12, 0, 32],
    X86_REG_R12W: [X86_REG_R12, 0, 16],
    X86_REG_R12B: [X86_REG_R12, 0, 8],
    X86_REG_R13: [X86_REG_R13, 0, 64],
    X86_REG_R13D: [X86_REG_R13, 0, 32],
    X86_REG_R13W: [X86_REG_R13, 0, 16],
    X86_REG_R13B: [X86_REG_R13, 0, 8],
    X86_REG_R14: [X86_REG_R14, 0, 64],
    X86_REG_R14D: [X86_REG_R14, 0, 32],
    X86_REG_R14W: [X86_REG_R14, 0, 16],
    X86_REG_R14B: [X86_REG_R14, 0, 8],
    X86_REG_R15: [X86_REG_R15, 0, 64],
    X86_REG_R15D: [X86_REG_R15, 0, 32],
    X86_REG_R15W: [X86_REG_R15, 0, 16],
    X86_REG_R15B: [X86_REG_R15, 0, 8],
    X86_REG_EFLAGS: [X86_REG_EFLAGS, 0, 64],
}


class Taint64:
    def __init__(self):
        self._taint = {}

    def set_(self, reg):
        return self.or_(reg, get_mask(64))

    def cls_(self, reg):
        return self.and_(reg, 0)

    def update(self, insn: CsInsn):
        ignore_reg = False
        result = True

        if insn.id == X86_INS_CWD:
            self.or_(X86_REG_EDX, get_mask(16))
            return result
        elif insn.id == X86_INS_CDQ:
            self.or_(X86_REG_EDX, get_mask(32))
            return result
        elif insn.id == X86_INS_CQO:
            self.or_(X86_REG_EDX, get_mask(64))
            return result

        if insn.id == X86_INS_MOVZX:
            pass

        if insn.id == X86_INS_TEST:
            ignore_reg = True
        if not ignore_reg:
            regs_read, regs_write = insn.regs_access()
            for w in regs_write:
                if w == X86_REG_EFLAGS:
                    continue
                if bridge.is64bit():
                    base, off, bits = self.get_info(w)
                    if off == 0 and bits == 32:
                        w = base
                if not self.set_(w):
                    result = False
        if insn.group(X86_GRP_FPU):
            result = False
        else:
            eflags = insn.eflags
            if eflags:
                for k, v in MASK_EFLAGS_SHIFT.items():
                    shift, set_flags, test_flags = v
                    if eflags & set_flags:
                        self.or_(X86_REG_EFLAGS, shift)
        return result

    def get_info(self, reg):
        if reg in dict_regs:
            return dict_regs[reg]
        return dict_regs[X86_REG_INVALID]

    def or_(self, reg, value):
        base, off, bits = self.get_info(reg)
        if base == X86_REG_INVALID:
            return False
        self._taint[base] = self._taint.get(
            base, 0) | (value & get_mask(bits)) << off
        return True

    def and_(self, reg, value):
        base, off, bits = self.get_info(reg)
        if base == X86_REG_INVALID:
            return False
        self._taint[base] = self._taint.get(base, 0) & (
            ((value | (~get_mask(bits))) << off) | get_mask(off))
        return True

    def fetch(self, reg):
        base, off, bits = self.get_info(reg)
        if base == X86_REG_INVALID:
            return 0
        return (self._taint.get(base, 0) >> off) & get_mask(bits)

    def check_read(self, insn: CsInsn):
        regs_read, regs_write = insn.regs_access()
        for rr in regs_read:
            if rr == X86_REG_EFLAGS:
                continue
            if self.fetch(rr):
                return False
        if not insn.group(X86_GRP_FPU):
            eflags = insn.eflags
            if eflags:
                value = self.fetch(X86_REG_EFLAGS)
                for k, v in MASK_EFLAGS_SHIFT.items():
                    shift, set_flags, test_flags = v
                    if (eflags & test_flags) and (value & shift):
                        return False
        return True

    def empty(self):
        flag = 0
        m = get_mask(bridge.size*8)
        for k, v in self._taint.items():
            flag |= v & m
        return flag == 0

    def check(self, rf, reg):
        v = self.fetch(reg)
        if v != 0:
            self.and_(reg, ~rf.fetch(reg))

    def check_overwrite(self, rf):
        regs = [
            X86_REG_RAX, X86_REG_RBX, X86_REG_RCX, X86_REG_RDX,
            X86_REG_RSI, X86_REG_RDI, X86_REG_RSP, X86_REG_RBP,
            X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
            X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
            X86_REG_EFLAGS
        ]
        for r in regs:
            self.check(rf, r)
        return self.empty()


def x86_deobfusctor(insn_array, dump=False):
    # very slow!
    if len(insn_array) < 2:
        return insn_array
    new_array = []
    useless = [False]*len(insn_array)
    taints = [Taint64() for i in insn_array]
    for i in reversed(range(0, len(insn_array))):
        insn: CsInsn = insn_array[i]
        if insn.id == X86_INS_NOP:
            useless[i] = True
        reg_read, reg_write = insn.regs_access()
        if len(reg_write) == 0:
            continue
        if insn.id == X86_INS_XCHG or insn.id == X86_INS_MOV or insn.group(X86_GRP_CMOV):
            op1, op2 = insn.operands
            if op1.type == op2.type and op1.size == op2.size and op1.reg == op2.reg:
                if (not bridge.is64bit()) or op1.size == bridge.size or op1.size < 4:
                    useless[i] = True
        if (not taints[i].update(insn)) or taints[i].empty():
            continue
        # skip call or memory access instruction
        if insn.id == X86_INS_CALL or insn.op_count(CS_OP_MEM) > 0:
            continue
        taint = copy.deepcopy(taints[i])
        for j in range(i+1, len(insn_array)):
            if useless[j]:
                continue
            if not taint.check_read(insn_array[j]):
                break
            reg_read, reg_write = insn_array[j].regs_access()
            if reg_write and taint.check_overwrite(taints[j]):
                useless[i] = True
                break

    for i, e in enumerate(insn_array):
        insn: CsInsn = insn_array[i]
        if not useless[i]:
            if dump:
                print(f'0x{insn.address:X} {insn.mnemonic} {insn.op_str}')
            new_array.append(e)
        else:
            if dump:
                print(f'; 0x{insn.address:X} {insn.mnemonic} {insn.op_str}')
    return new_array


def x86_simple_decode(ea, max_insn_count=-1, term_call_imm=False):
    s = []
    bbs = shit_disasm(ea, max_insn_count, term_call_imm)
    for bb in bbs:
        s += x86_deobfusctor(bb)
    return s


def get_reg8(reg):
    if reg == X86_REG_INVALID:
        return X86_REG_INVALID
    for elems in map_reg:
        if reg in elems:
            return elems[4]
    return X86_REG_INVALID


def get_reg16(reg):
    if reg == X86_REG_INVALID:
        return X86_REG_INVALID
    for elems in map_reg:
        if reg in elems:
            return elems[2]
    return X86_REG_INVALID


def get_reg32(reg):
    if reg == X86_REG_INVALID:
        return X86_REG_INVALID
    for elems in map_reg:
        if reg in elems:
            return elems[1]
    return X86_REG_INVALID


def extend_reg(reg):
    if bridge.is64bit():
        return get_reg64(reg)
    return get_reg32(reg)


def get_reg64(reg):
    if reg == X86_REG_INVALID:
        return X86_REG_INVALID
    for elems in map_reg:
        if reg in elems:
            return elems[0]
    return X86_REG_INVALID


def dump_insns(insns):
    for i in insns:
        print(i)

```

`readme.md`:

```md
# Introduction
This project is just a POC and only works with VMProtect 3.x (not including the demo version).

NOT CLEAN CODE.

Although x86 is now available, unfortunately x86 cannot coexist with x64.


## 1. Install pyvtil first

```bash
git clone -b dev-1 https://github.com/wallds/VTIL-Python.git --recursive
cd VTIL-Python
py setup.py install --old-and-unmanageable
```
**To use x86 you need to replace `dev-1` with `dev-x86`.**

**If you are using Visual Studio 2022 build tools, then you need to update `extras` in setup.py from `Visual Studio 16 2019` to `Visual Studio 17 2022`**
## 2. Install plugin
Copy novmpy&novmpy.py to IDA plugin directory.

## 3. Usage
![1](./imgs/1.gif)

## Support list
Version       | x86 | amd64 | arm64
:------------ | :-------------| :-------------| :-------------
VMProtect 3.x | :heavy_check_mark: |  :heavy_check_mark: |


# Reference

https://github.com/can1357/NoVmp

https://github.com/0xnobody/vmpattack

https://github.com/vtil-project/VTIL-BinaryNinja

```

`requirements.txt`:

```txt
cle
capstone
unicorn
```

`test.py`:

```py
from novmpy.bridge import *
from novmpy.vm_lifter import VMLifter
from novmpy.vm_lifter import search_vmstubs
from novmpy.vm import VMState
from pyvtil import *


def main():
    for jmp_rva, is_mid_routine in search_vmstubs():
        print(f'Lifting virtual-machine at 0x{jmp_rva:X}...')
        lifter = VMLifter()
        state = VMState(current_handler=bridge.get_base()+jmp_rva)
        lifter.lift_il(None, state)

        print(f'Saving premature')
        lifter.rtn.save('./test.premature.vtil')
        vtil.optimizer.apply_all_profiled(lifter.rtn)
        print(f'Saving optimized')
        lifter.rtn.save('./test.optimized.vtil')
        vtil.debug.dump(lifter.rtn)


if __name__ == '__main__':
    main()

```