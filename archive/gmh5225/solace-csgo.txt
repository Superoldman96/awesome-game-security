Project Path: arc_gmh5225_solace-csgo_6xj73zzq

Source Tree:

```txt
arc_gmh5225_solace-csgo_6xj73zzq
├── README.md
├── solace-csgo
│   ├── address.h
│   ├── aimbot.cpp
│   ├── aimbot.h
│   ├── animstate.cpp
│   ├── animstate.h
│   ├── app_system.h
│   ├── base_client.h
│   ├── block_bot.cpp
│   ├── block_bot.h
│   ├── bones.cpp
│   ├── bones.h
│   ├── buy_bot.cpp
│   ├── buy_bot.h
│   ├── chams.cpp
│   ├── chams.h
│   ├── checksum_crc.cpp
│   ├── checksum_crc.h
│   ├── client_state.h
│   ├── console.h
│   ├── controls
│   │   ├── base_control.hh
│   │   ├── button.hh
│   │   ├── column.hh
│   │   ├── combobox.hh
│   │   ├── groupbox.hh
│   │   ├── key_bind.hh
│   │   ├── multiselect.hh
│   │   ├── slider.hh
│   │   ├── tab.hh
│   │   ├── toggle.hh
│   │   ├── window.cc
│   │   └── window.hh
│   ├── cpp.hint
│   ├── datamap.cpp
│   ├── datamap.h
│   ├── debug_overlay.h
│   ├── delaunator.h
│   ├── detours.h
│   ├── dllmain.cpp
│   ├── engine_client.h
│   ├── engine_cvar.h
│   ├── engine_trace.h
│   ├── entity_list.h
│   ├── esp.cpp
│   ├── esp.h
│   ├── event_listener.h
│   ├── events.cpp
│   ├── events.h
│   ├── fnv.h
│   ├── g.cpp
│   ├── g.h
│   ├── global_vars.h
│   ├── hooks.cpp
│   ├── hooks.h
│   ├── hvh.cpp
│   ├── hvh.h
│   ├── includes.h
│   ├── input.h
│   ├── input_helper
│   │   └── input_helper.hh
│   ├── interfaces.h
│   ├── material_system.h
│   ├── math_funcs.cpp
│   ├── math_funcs.h
│   ├── mdlcache.h
│   ├── mem_alloc.h
│   ├── memory_shit.h
│   ├── menu.cc
│   ├── menu.hh
│   ├── model_info.h
│   ├── movement.cpp
│   ├── movement.h
│   ├── netvar_manager.cpp
│   ├── netvar_manager.h
│   ├── netvars.cpp
│   ├── netvars.h
│   ├── notification.cpp
│   ├── notification.h
│   ├── offsets.h
│   ├── penetration.cpp
│   ├── penetration.h
│   ├── physics.h
│   ├── player.cpp
│   ├── player.h
│   ├── player_manager.cpp
│   ├── player_manager.h
│   ├── player_movement.h
│   ├── prediction.cpp
│   ├── prediction.h
│   ├── predictioncopy.cpp
│   ├── predictioncopy.h
│   ├── render.cpp
│   ├── render.h
│   ├── resolver.cpp
│   ├── resolver.h
│   ├── sdk.h
│   ├── settings.h
│   ├── solace-csgo.vcxproj
│   ├── solace-csgo.vcxproj.filters
│   ├── studio.cpp
│   ├── studio.h
│   ├── tfm.h
│   ├── thread_hander.cpp
│   ├── thread_handler.h
│   ├── utils.h
│   ├── vec3.cpp
│   ├── vec3.h
│   ├── view_matrix.cpp
│   ├── view_matrix.hpp
│   ├── view_setup.h
│   ├── vmt.h
│   ├── weapon_info.h
│   └── weapon_system.h
└── solace-csgo.sln

```

`README.md`:

```md
## solace-csgo. An internal csgo cheat for legacy hvh.

- I prefer to use github issues but, emily#4986 is my discord if you need any help.
- I've spent the past couple of years working on this in my freetime solo, due to this the project remains relatively undoccumented.
- I'm going to attempt to fully doccument and refactor this project over the coming months

```

`solace-csgo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "solace-csgo", "solace-csgo\solace-csgo.vcxproj", "{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release Profiling|x86 = Release Profiling|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Debug|x86.ActiveCfg = Debug|Win32
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Debug|x86.Build.0 = Debug|Win32
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Release Profiling|x86.ActiveCfg = Release Profiling|Win32
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Release Profiling|x86.Build.0 = Release Profiling|Win32
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Release|x86.ActiveCfg = Release|Win32
		{3176C7DB-DE15-4CE4-8641-3E90D58D53D8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {14192BF3-50A1-4363-8E73-5020C40CF9D5}
	EndGlobalSection
EndGlobal

```

`solace-csgo/address.h`:

```h
#pragma once
#define BASE_TEMPLATE template<typename t = address>
#include "utils.h"

class address {
public:
	uintptr_t m_base{};
	__forceinline ~address ( ) {};
	__forceinline address( const void* a ) : m_base{ reinterpret_cast< uintptr_t >(a) } { }
	__forceinline operator void* ( ) const { return ( void* )m_base; }
	__forceinline operator const void *( ) const { return ( const void * )m_base; }
	__forceinline operator const bool( ) const { return valid( ); }
	
	__forceinline bool operator!=( address other ) const { return m_base != other.m_base; }

	address( ) {
		m_base = 0;
	}

	address( const uintptr_t addr ) {
		m_base = addr;
	}

	__forceinline operator uintptr_t( ) { return m_base; }

	BASE_TEMPLATE
	t as ( const uintptr_t offset = 0 ) {
		//cast
		return valid( ) ? reinterpret_cast< t >(m_base + offset) : 0;
	}

	template< typename t = address >
	__forceinline t get( size_t n = 1 ) {

		if ( !m_base )
			return t{};

		uintptr_t out = m_base;

		for ( size_t i{ n }; i > 0; --i ) {
			// can't dereference, return null.
			if ( !valid( ) )
				return t{};

			out = *reinterpret_cast< uintptr_t * >(out);
		}

		return (t)( out );
	}

	BASE_TEMPLATE
		t sub( const uintptr_t offset = 0 ) {
		//cast
		return valid( ) ? static_cast< t >( m_base -= offset ) : 0;
	}
	
	BASE_TEMPLATE
		t add( const uintptr_t offset = 0 ) {
		//cast
		return valid( ) ? static_cast< t >( m_base += offset ) : 0;
	}

	BASE_TEMPLATE
	t to ( const uintptr_t offset = 0 ) {
		return valid( ) ? *reinterpret_cast< t * >(m_base + offset) : 0;
	}
	BASE_TEMPLATE
	t deref( int n = 1 ) {
		auto new_addr = m_base;
		for ( auto i = 1; i < n; i++ )
			new_addr = *reinterpret_cast< uintptr_t * >(new_addr);
		return *reinterpret_cast< t * >(new_addr);
	}

	BASE_TEMPLATE
	t at ( const uintptr_t offset ) {
		return valid( ) ? *reinterpret_cast< t * >(m_base + offset) : 0;
	}

	[[nodiscard]] bool valid ( ) const {
		//nulltptr?
		return m_base != 0;
	}

	BASE_TEMPLATE
	t rel32 ( const size_t offset ) {
		if ( !m_base )
			return t{};

		auto out = m_base + offset;

		// get rel32 offset.
		const auto r = *reinterpret_cast< uintptr_t * >(out);
		if ( !r )
			return t{};

		// relative to address of next instruction.
		out = (out + 4) + r;

		return static_cast< t >(out);
	}
};

#undef BASE_TEMPLATE

```

`solace-csgo/aimbot.cpp`:

```cpp
#include "aimbot.h"

#include "movement.h"
#include "bones.h"
#include "hooks.h"
#include "penetration.h"
#include "resolver.h"
#include "thread_handler.h"

// class hcThreadObject {
// public:
//	bool ret_state = false;
//	bool read = false;
//	weapon_t* weapon;
//	ang_t view;
//	int id = 0;
//	bool finished = false;
//
//	std::vector<RayTracer::Hitbox> hit_boxes = {};
//	void run( );
//	hcThreadObject( weapon_t* weapon_, ang_t view_, int id_, std::vector<RayTracer::Hitbox> hitboxes_ ) {
//		weapon = weapon_;
//		view = view_;
//		id = id_;
//		hit_boxes = hitboxes_;
//	}
// };
//
// void hcThreadObject::run ( ) {
//	size_t     total_hits{ };
//	const auto needed_hits{ static_cast< size_t >( ( settings::rage::selection::hitchance * 255 / 100.f ) ) };
//
//	const auto inaccuracy = g.m_weapon->inaccuracy( );
//	const auto spread = g.m_weapon->get_spread( );
//	const auto start{ g.m_shoot_pos };
//
//	static auto surface_predicate = [ ]( const RayTracer::Hitbox& a, const RayTracer::Hitbox& b ) {
//		const float area_1 = ( M_PI * powf( a.m_radius, 2 ) * a.m_len ) + ( 4.f / 3.f * M_PI * a.m_radius );
//		const float area_2 = ( M_PI * powf( b.m_radius, 2 ) * b.m_len ) + ( 4.f / 3.f * M_PI * b.m_radius );
//
//		return area_1 < area_2;
//	};
//	std::sort( hit_boxes.begin( ), hit_boxes.end( ), surface_predicate );
//
//
//	vec3_t forward{}, right{}, up{};
//
//	view.vectors( &forward, &right, &up );
//
//	vec3_t origin;
//	ang_t angles;
//	for ( auto i = 0; i < 255; i++ ) {
//		const auto weapon_spread = math::calculate_spread( g.m_weapon, i, inaccuracy, spread, false );
//
//		auto dir = ( forward + ( right * weapon_spread.x ) + ( up * weapon_spread.y ) );
//		dir /= dir.length( );
//		const auto end = start + ( dir * g.m_weapon_info->m_range );
//
//		math::custom_ray_t ray( g.m_shoot_pos, end );
//
//		RayTracer::Ray ray_1( ray.m_start, ray.m_end );
//		for ( auto& box : hit_boxes ) {
//			RayTracer::Trace trace;
//			float m1, m2;
//			auto dist = math::distSegmentToSegmentSqr( ray.m_start, ray.m_end, box.m_mins, box.m_maxs, m1, m2 );
//			//RayTracer::TraceHitbox( ray_1, box, trace, RayTracer::Flags_NONE );
//			if ( dist <= box.m_radius * box.m_radius ) {
//				total_hits++;
//				finished = true;
//				break;
//			}
//			//RayTracer::TraceHitbox( ray_1, box, trace, RayTracer::Flags_NONE );
//			//if ( trace.m_hit ) {
//			//	total_hits++;
//			//	break;
//			//}
//		}
//		//for ( auto &box : hit_boxes ) {
//		//	trace_t trace;
//		//	if ( !box.m_box ) {
//		//		if ( box.m_radius >= math::dist_Segment_to_Segment( ray, box.m_min, box.m_max ) ) {
//		//			total_hits++;
//		//			break;
//		//		}
//		//	}
//		//	else {
//		//
//		//		matrix_t rot_matrix;
//		//		math::AngleMatrix( box.m_rot, &rot_matrix );
//		//
//		//		// apply the rotation to the entity input space (local).
//		//		matrix_t matrix;
//		//		math::ConcatTransforms( record->m_bones[ box.m_bone ], rot_matrix, &matrix );
//		//
//		//		if ( math::IntersectRayWithOBB( ray.m_start, ray.m_ray_dir, matrix, box.m_min, box.m_max, 0.0f, &trace ) )
//{
//		//			total_hits++;
//		//			break;
//		//		}
//		//	}
//		//}
//		if ( total_hits >= needed_hits ) {
//			ret_state = true;
//			finished = true;
//			return;
//		}
//		if ( ( ( 255 - i ) + total_hits ) < needed_hits ) {
//			ret_state = false;
//			finished = true;
//			return;
//		}
//	}
//	ret_state = false;
//	finished = true;
// }

bool aimbot_t::valid(ent_info_t* ent)
{
    return ent->m_ent && ent->m_valid && !ent->m_teamate && !ent->m_dormant && !ent->m_ent->gun_game_immunity();
}
void aimbot_t::get_targets()
{
    m_targets.clear();
    for (auto& ent : g_player_manager.m_ents)
    {
        ent.m_damage *= 1 * valid(&ent); // reset damage for every target
        if (valid(&ent))
            m_targets.push_back(&ent);
    }
}

enum body_aim_conditions
{
    LETHAL = 0,
    IN_AIR
};

void aimbot_t::get_points(ent_info_t* info, studio_hdr_t* studio_model)
{
    info->m_hitboxes.clear();
    vec3_t center;
    int mode;
    float r;
    for (auto hitbox_num = hitboxes::hitbox_max - 1; hitbox_num >= 0; hitbox_num--)
    {
        auto* hitbox = studio_model->hitbox_set(info->m_ent->hitbox_set())->hitbox(hitbox_num);
        if (!hitbox)
            return;
        auto n = 5; // TODO: Add option on menu to adjust points per hitbox
        auto scale = settings::rage::hitbox::point_scale;
        int select = -1;
        switch (hitbox_num)
        {
            case hitbox_head:
                select = 0;
                break;

            case hitbox_chest:
            case hitbox_thorax:
            case hitbox_upper_chest:
                select = 1;
                break;

            case hitbox_pelvis:
            case hitbox_body:
                select = 2;
                scale = settings::rage::hitbox::body_scale;
                break;
            case hitbox_l_upper_arm:
            case hitbox_r_upper_arm:
                select = 3;
                break;
            case hitbox_l_calf:
            case hitbox_r_calf:
            case hitbox_l_thigh:
            case hitbox_r_thigh:
                select = 4;
                break;

            default:
                continue;
        }

        if (select == -1 || !(settings::rage::hitbox::hitboxes & (1 << select)))
            continue;

        if (settings::rage::hitbox::baim_conditions & (1 << IN_AIR) && select != 2 &&
            info->m_selected_record->m_mode == resolver::RESOLVE_AIR) // force baim in air
            continue;

        hitbox_helper_t point_list{hitbox_num};

        center = (hitbox->mins + hitbox->maxs) / 2.f;

        mode = settings::rage::hitbox::baim_conditions;
        r = hitbox->radius * (scale / 100.f);

        matrix_t bone_transform;
        memcpy(&bone_transform, &info->m_selected_record->m_bones[hitbox->bone], sizeof(matrix_t));
        if (hitbox->angle != ang_t())
        {
            matrix_t temp;

            math::AngleMatrix(hitbox->angle, &temp);
            math::ConcatTransforms(bone_transform, temp, &bone_transform);
        }

        ang_t view = g.m_shoot_pos.look(center);
        vec3_t right;
        view.vectors(nullptr, &right, nullptr);
        vec3_t point;
        switch (hitbox_num)
        {
            case hitbox_head:

                // top/back 45 deg.
                // this is the best spot to shoot at.
                math::VectorTransform(hitbox->maxs, bone_transform, point);
                point.z += r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(hitbox->maxs, bone_transform, point);
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(hitbox->maxs, bone_transform, point);
                point += right * r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(hitbox->maxs, bone_transform, point);
                point += right * -r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(hitbox->mins, bone_transform, point);
                point += right * r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(hitbox->mins, bone_transform, point);
                point += right * -r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;
            case hitbox_pelvis:
            case hitbox_body:

                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, mode, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * r;
                point_list.m_points.emplace_back(point, mode, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * -r;
                point_list.m_points.emplace_back(point, mode, hitbox_num);

                break;
            case hitbox_thorax:
            case hitbox_upper_chest:
                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * -r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;
            case hitbox_chest:
                point = center;
                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, mode, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);

                math::VectorTransform(center, bone_transform, point);
                point += right * -r;
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;
            case hitbox_r_calf:
            case hitbox_l_calf:
                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;
            case hitbox_r_thigh:
            case hitbox_l_thigh:
                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;

                // arms get only one point.
            case hitbox_r_upper_arm:
            case hitbox_l_upper_arm:
                math::VectorTransform(center, bone_transform, point);
                point_list.m_points.emplace_back(point, 0, hitbox_num);
                break;
            default:;
                break;
        }

        point_list.hdr = studio_model;
        point_list.info = info;
        {
            info->m_hitboxes.push_back(point_list);
        }
    }
}

bool aimbot_t::collides(math::custom_ray_t ray, ent_info_t* info, bone_array_t bones[128], float mult)
{
    auto* studio_model = info->m_ent->model();
    if (!studio_model)
        return false;
    auto* hdr = g.m_interfaces->model_info()->get_studio_model(studio_model);
    if (!hdr)
        return false;
    auto* hitbox_set = hdr->hitbox_set(info->m_ent->hitbox_set());
    if (!hitbox_set)
        return false;
    vec3_t mins{}, maxs{};
    for (auto i = 0; i < hitbox_set->hitbox_count; i++)
    {
        auto* hitbox = hitbox_set->hitbox(i);
        if (!hitbox)
            return false;

        if (hitbox && hitbox->radius > 0)
        {
            vec3_t vMin, vMax;
            math::VectorTransform(hitbox->mins, bones[hitbox->bone], vMin);
            math::VectorTransform(hitbox->maxs, bones[hitbox->bone], vMax);

            float m1, m2;
            const auto dist = math::distSegmentToSegmentSqr(ray.m_start, ray.m_end, vMin, vMax, m1, m2);
            if (dist <= (hitbox->radius * hitbox->radius) * mult)
            {
                return true;
            }
        }
    }
    return false;
}

bool aimbot_t::get_aim_matrix(ang_t angle, bone_array_t* bones)
{
    auto* state = g.m_local->get_anim_state();
    if (!state)
        return false;

    float backup_pose[24];
    animation_layer_t backup_layers[15];

    g.m_local->GetAnimLayers(backup_layers);
    g.m_local->GetPoseParameters(backup_pose);

    g.m_local->SetAnimLayers(g.m_layers);
    g.m_local->SetPoseParameters(g.m_poses);

    float flPitch = (angle.x + 90.f) / 180.f;

    g.m_local->pose_parameters()[12] = flPitch;

    g.m_local->set_abs_angles(ang_t(0.f, g.m_abs_yaw, 0.f));

    CIKContext backup_ik;
    memcpy(&backup_ik, &g.m_ipk, sizeof(CIKContext));

    g.m_interfaces->mdlcache()->begin_coarse_lock();
    g.m_interfaces->mdlcache()->begin_lock();
    // we have setup this record bones.
    const auto ret =
        g_bones.BuildBonesStripped(g.m_local, bone_used_by_anything & ~bone_used_by_bone_merge, bones, &g.m_ipk);
    g.m_interfaces->mdlcache()->end_lock();
    g.m_interfaces->mdlcache()->end_coarse_lock();

    memcpy(&g.m_ipk, &backup_ik, sizeof(CIKContext));

    g.m_local->SetAnimLayers(backup_layers);
    g.m_local->SetPoseParameters(backup_pose);

    return ret;
}

bool aimbot_t::get_best_point(ent_info_t* info, bone_array_t* bones, vec3_t& eye)
{
    // g.m_interfaces->mem_alloc( )->free( bones );
    // if ( info->m_shot_wanted > info->m_selected_record->m_sim_time )
    //	return false;
    float max_damage = 0;
    vec3_t selected_eye;
    aim_point_t* selected_point = nullptr;
    ang_t view;
    int max_safe_points;
    hitbox_helper_t* box;
    ang_t new_look;
    float max_weight = 0.f;
    float weight;
    int safe_points;
    math::custom_ray_t ray;
    penetration::PenetrationInput_t in;
    g.m_interfaces->engine()->get_view_angles(view);
    int bone_index;
    ang_t look;
    for (ent_info_t::helper_array::size_type i = 0; i < info->m_hitboxes.size(); i++)
    {
        max_safe_points = 0;
        box = &info->m_hitboxes[i];
        for (auto& point : box->m_points)
        {
            new_look = eye.look(point.m_point);
            /// It turns out, source doesn't actually force the pose and bonesetup when shooting, last update is fine
            // if ( !found_match ) {
            // if ( get_aim_matrix( g.m_shoot_pos.look( point.m_point ) - g.m_local->aim_punch() * 2, bones ) ) {
            //	auto *const bone_cache = &g.m_local->bone_cache( );
            //	if ( bone_cache ) {
            //		bone_array_t *backup_cache = bone_cache->m_pCachedBones;
            //		bone_cache->m_pCachedBones = bones;
            //		g.m_local->get_eye_pos( &g.m_shoot_pos );
            //		new_look = g.m_shoot_pos.look( point.m_point );
            //		//m_list_eye_pos.emplace_back( new_look.x, g.m_shoot_pos );
            //		bone_cache->m_pCachedBones = backup_cache;
            //	}
            // }
            // }
            if (settings::rage::selection::fov > 0 &&
                fabsf(g.m_shoot_pos.look(point.m_point).delta(view)) > settings::rage::selection::fov)
                continue;

            weight = 0.f;
            safe_points = 0;
            if ((!info->m_selected_record->m_body_reliable &&
                 info->m_selected_record->m_mode == resolver::RESOLVE_BODY) ||
                info->m_selected_record->m_mode == resolver::RESOLVE_WALK)
            { // check these safepoints on walk/lby flick
                ray.init(eye, point.m_point);

                bool should_continue = false;
                for (auto& i : info->m_selected_record->m_fake_bones)
                    if (collides(ray, info, i))
                    { // if this shot collides with the fake hitboxes add on to our safepoints
                        if (info->m_selected_record->m_mode == resolver::RESOLVE_WALK)
                            safe_points++;
                        else
                        {
                            should_continue = true;
                            break;
                        }
                    }

                if (should_continue)
                    continue;

                weight += static_cast<float>(safe_points) / info->m_selected_record->m_fake_bones.size();
            }

            in.m_from = g.m_local;
            in.m_start = eye;
            in.m_pos = point.m_point;
            in.m_target = info->m_ent;
            int damage = min(100, info->m_ent->health() + settings::rage::selection::lethal_damage);
            in.m_damage = in.m_damage_pen = min(settings::rage::selection::min_damage, damage);
            if (info->m_selected_record->m_mode == resolver::RESOLVE_STAND1 ||
                info->m_selected_record->m_mode == resolver::RESOLVE_STAND2)
            {
                ray.init(eye, point.m_point);
                bone_index = 0;
                // auto& mode_data = info->m_resolver_data.m_mode_data[ !( info->m_selected_record->m_mode ==
                // resolver::RESOLVE_STAND1 ) ]; int possible = 0; for ( auto i1 = 0; i1 < mode_data.m_dir_data.size( );
                // i1++ ) { 	if ( mode_data.m_index == i1 ) 		continue; 	auto& dir_data = mode_data.m_dir_data[ i1 ]; 	if (
                //dir_data.dir_enabled ) { 		if ( collides( ray, info, info->m_selected_record->m_fake_bones[ bone_index ]
                //) ) // if this shot collides with the fake hitboxes add on to our safepoints 			safe_points++;
                //		possible++;
                //	}
                //	bone_index++;
                // }
                // if( possible > 0 )
                //	weight += static_cast< float >( safe_points ) / static_cast< float >( possible );
            }

            penetration::PenetrationOutput_t out;

            info->m_selected_record->cache(-1);
            if (run(&in, &out))
            { // check wall penetration
                if (out.m_target != in.m_target || in.m_damage > out.m_damage)
                    continue;

                if (point.m_mode & (1 << LETHAL) &&
                    (out.m_damage >= info->m_ent->health() + settings::rage::selection::lethal_damage))
                {
                    selected_eye = eye;
                    selected_point = &point;
                    break;
                }

                weight += out.m_damage / info->m_ent->health();

                look = eye.look(point.m_point);

                if (safe_points > max_safe_points)
                    max_safe_points = safe_points;

                if (weight < max_weight)
                    continue;

                max_weight = weight;

                selected_eye = eye;
                selected_point = &point;
                max_damage = out.m_damage;
            }
        }
    }
    if (selected_point)
    {
        info->m_aim_point = selected_point;
        info->m_damage = max_damage;
        selected_point->m_shoot_pos = selected_eye;
        return true;
    }
    return false;
}

bool aimbot_t::best_target(ent_info_t*& info) const
{
    if (!m_best_target)
        return true;

    if ((info->m_ent->origin() - g.m_shoot_pos).length_sqr() <
        (m_best_target->m_ent->origin() - g.m_shoot_pos).length_sqr())
        return true;

    return false;
}

void aimbot_t::apply()
{
    if (m_best_target == nullptr ||
        m_best_target->m_aim_point == nullptr) // was there no good targets to shoot? m_aim_point should always be non
                                               // null at this point but for safety sake
        return;
    if (m_best_target != m_last_target)
        m_best_target->m_shot_wanted = m_best_target->m_selected_record->m_sim_time +
                                       settings::rage::general::delay_shot; // Unused for now, used for

    g_movement.set_should_stop(true);

    g.m_shoot_pos = m_best_target->m_aim_point->m_shoot_pos;
    auto look = g.m_shoot_pos.look(m_best_target->m_aim_point->m_point);
    if (!check_hitchance(m_best_target, look, m_best_target->m_selected_record, m_best_target->m_aim_point))
        return;

    g_movement.set_should_unpeek(true);

    draw_hitboxes();
    g.m_cmd->m_tick_count = g.time_to_ticks(m_best_target->m_selected_record->m_pred_time + g.m_lerp);
    g.m_cmd->m_viewangles = look - g.m_local->aim_punch() * 2;
    g.m_cmd->m_buttons |= IN_ATTACK;
    g.m_shot = true;
    *g.m_packet = false;

    g_resolver.add_shot(m_best_target, m_best_target->m_damage, g.m_weapon_info->m_bullets,
                        m_best_target->m_selected_record);
}

void aimbot_t::draw_hitboxes(player_t* player, bone_array_t* bones) const
{
    if (!player)
        player = m_best_target->m_ent;
    auto* hdr = g.m_interfaces->model_info()->get_studio_model(player->model());
    auto* set = hdr->hitbox_set(player->hitbox_set());

    if (bones == nullptr)
        bones = m_best_target->m_selected_record->m_bones;

    vec3_t origin;
    ang_t angles;

    for (auto i = 0; i < set->hitbox_count; i++)
    {
        auto* hitbox = set->hitbox(i);

        if (!hitbox)
            continue;
        if (hitbox->radius > 0)
        {
            matrix_t temp;

            math::AngleMatrix(hitbox->angle, &temp);
            matrix_t bone_transform;
            memcpy(&bone_transform, &bones[hitbox->bone], sizeof(matrix_t));
            if (hitbox->angle != ang_t())
                math::ConcatTransforms(bone_transform, temp, &bone_transform);

            vec3_t vMin, vMax;
            math::VectorTransform(hitbox->mins, bone_transform, vMin);
            math::VectorTransform(hitbox->maxs, bone_transform, vMax);

            g.m_interfaces->debug_overlay()->AddCapsuleOverlay(vMin, vMax, hitbox->radius, 255, 0, 0, 255, 4);
        }
        else
        {

            // convert rotation angle to a matrix.
            matrix_t rot_matrix;
            math::AngleMatrix(hitbox->angle, &rot_matrix);

            // apply the rotation to the entity input space (local).
            matrix_t matrix;
            math::ConcatTransforms(bones[hitbox->bone], rot_matrix, &matrix);

            // extract the compound rotation as an angle.
            ang_t bbox_angle;
            math::MatrixAngles(matrix, bbox_angle);

            // extract hitbox origin.
            auto origin1 = matrix.get_origin();
            g.m_interfaces->debug_overlay()->AddBoxOverlay(origin1, hitbox->mins, hitbox->maxs, bbox_angle, 255, 0, 0,
                                                           255, 4);
        }
    }
}

bool aimbot_t::check_hitchance(ent_info_t* info, ang_t& view, std::shared_ptr<player_record_t> record,
                               aim_point_t* point)
{
    size_t total_hits{};
    const auto needed_hits{static_cast<size_t>((settings::rage::selection::hitchance * 255 / 100.f))};

    const auto inaccuracy = g.m_weapon->inaccuracy();
    const auto spread = g.m_weapon->get_spread();
    const auto start{g.m_shoot_pos};

    auto* studio_model = g.m_interfaces->model_info()->get_studio_model((info)->m_ent->model());
    if (!studio_model)
        return false;

    auto* hitbox_set = studio_model->hitbox_set(info->m_ent->hitbox_set());
    vec3_t mins{}, maxs{};

    if (point->m_hitbox < 0 || point->m_hitbox >= hitbox_set->hitbox_count)
        return false;
    auto* hitbox = hitbox_set->hitbox(point->m_hitbox);

    if (!(hitbox && hitbox->radius > 0))
        return false;

    matrix_t bone_transform;
    memcpy(&bone_transform, &record->m_bones[hitbox->bone], sizeof(matrix_t));
    if (hitbox->angle != ang_t())
    {
        matrix_t temp;

        math::AngleMatrix(hitbox->angle, &temp);
        math::ConcatTransforms(bone_transform, temp, &bone_transform);
    }

    vec3_t vMin, vMax;
    math::VectorTransform(hitbox->mins, bone_transform, vMin);
    math::VectorTransform(hitbox->maxs, bone_transform, vMax);

    vec3_t forward{}, right{}, up{};

    view.vectors(&forward, &right, &up);

    vec3_t origin;
    ang_t angles;
    float m1, m2;
    for (auto i = 0; i < 255; i++)
    {
        const auto weapon_spread = math::calculate_spread(g.m_weapon, i, inaccuracy, spread, false);

        vec3_t dir = (forward + (right * weapon_spread.x) + (up * weapon_spread.y));
        dir /= dir.length();
        const auto end = start + (dir * g.m_weapon_info->m_range);

        float dist = math::distSegmentToSegmentSqr(g.m_shoot_pos, end, vMin, vMax, m1, m2);
        // RayTracer::TraceHitbox( ray_1, box, trace, RayTracer::Flags_NONE );
        if (dist <= hitbox->radius * hitbox->radius)
        {
            total_hits++;
            if (total_hits >= needed_hits)
                return true;
        }
        if (((255 - i) + total_hits) < needed_hits)
            return false;
    }
    return false;
}

std::shared_ptr<player_record_t> aimbot_t::last_record(ent_info_t* info)
{
    std::shared_ptr<player_record_t> best = nullptr;
    for (auto& i : info->m_records)
    {
        if (!i || !i->m_setup || !i->valid())
            continue;
        if (i->m_dormant)
            break;
        best = i;
    }
    return best;
}

player_record_t* aimbot_t::best_record(ent_info_t* info)
{
    player_record_t* best = nullptr;
    for (auto& i : info->m_records)
    {
        if (!i->m_setup || !i->valid())
            continue;
        if (i->m_dormant)
            break;
        if (i->m_shot)
            continue;
        if (i->m_mode == resolver::RESOLVE_BODY || i->m_mode == resolver::RESOLVE_WALK)
            return i.get();
        if (!best)
            best = i.get();
    }
    return best;
}

void aimbot_t::backup_players(const bool restore)
{
    for (auto i{1}; i <= g.m_interfaces->globals()->m_max_clients; ++i)
    {
        const auto& player_data = g_player_manager.m_ents[i - 1];

        if (!player_data.m_valid)
            continue;
        if (!player_data.m_ent)
            continue;

        if (restore)
            m_backup[i - 1].restore(player_data.m_ent);
        else
            m_backup[i - 1].store(player_data.m_ent);
    }
}

//			Scrapping this since it ended up causing more lag than it was worth
//			Just check best target that we can find

// bool add_to_threads( std::vector<std::shared_ptr<hcThreadObject>> &objects, ent_info_t* info, int id ) {
//	if ( !info->m_aim_point )
//		return false;
//	auto look = g.m_shoot_pos.look( info->m_aim_point->m_point );
//	auto* studio_model = g.m_interfaces->model_info( )->get_studio_model( ( info )->m_ent->model( ) );
//	if ( !studio_model )
//		return false;
//	auto* hitbox_set = studio_model->hitbox_set( info->m_ent->hitbox_set( ) );
//	std::vector<math::hitbox_t> hit_boxes;
//	vec3_t mins{}, maxs{};
//
//	for ( auto i = 0; i < hitbox_set->hitbox_count; i++ ) {
//		if ( i != info->m_aim_point->m_hitbox )
//			continue;
//		auto* hitbox = hitbox_set->hitbox( i );
//
//		if ( hitbox && hitbox->radius > 0 ) {
//			matrix_t bone_transform;
//			memcpy( &bone_transform, &info->m_selected_record->m_bones[ hitbox->bone ], sizeof( matrix_t ) );
//			if ( hitbox->angle != ang_t( ) ) {
//				matrix_t temp;
//
//				math::AngleMatrix( hitbox->angle, &temp );
//				math::ConcatTransforms( bone_transform, temp, &bone_transform );
//			}
//
//			vec3_t vMin, vMax;
//			math::VectorTransform( hitbox->mins, bone_transform, vMin );
//			math::VectorTransform( hitbox->maxs, bone_transform, vMax );
//			hit_boxes.emplace_back( vMin, vMax, hitbox->radius );
//		}
//	}
//	if ( hit_boxes.empty( ) )
//		return false;
//	//g_thread_handler.wait( ); // wait until all threads are finished
//	objects.emplace_back( std::make_shared<hcThreadObject>(g.m_weapon, look, id, hit_boxes) );
//	return true;
// }

class mpThreadObject
{
public:
    bool ret_state = false;
    bool finished = false;
    bool read = false;
    ent_info_t* info = nullptr;
    vec3_t eye;
    void run();
    mpThreadObject(ent_info_t* info_, vec3_t eye) : eye(eye)
    {
        info = info_;
    }
};

void mpThreadObject::run()
{
    auto* studio_model = g.m_interfaces->model_info()->get_studio_model(info->m_ent->model());
    if (!studio_model)
    {
        ret_state = false;
        finished = true;
        return;
    }
    info->m_selected_record = g_resolver.FindIdealRecord(info);
    if (info->m_selected_record)
    {
        aimbot_t::get_points(info, studio_model);
        if (/*best_target( info ) && */ g_aimbot.get_best_point(info, nullptr, eye))
        {
            // m_best_target = info;
            std::unique_lock<std::mutex> lock(g_thread_handler.queue_mutex2);
            ret_state = true;
            finished = true;
            return;
            // valid_targets.push_back( info );
            // if ( info->m_damage >= info->m_ent->health( ) )
            //	break;
            // continue;
        }
    }
    info->m_selected_record = g_resolver.FindIdealBackRecord(info);
    if (info->m_selected_record)
    {
        aimbot_t::get_points(info, studio_model);
        if (/*best_target( info ) && */ g_aimbot.get_best_point(info, nullptr, eye))
        {
            // m_best_target = info;
            std::unique_lock<std::mutex> lock(g_thread_handler.queue_mutex2);
            ret_state = true;
            finished = true;
            return;
            // valid_targets.push_back( info );
            // if ( info->m_damage >= info->m_ent->health( ) )
            //	break;
        }
    }
    info->m_selected_record = aimbot_t::last_record(info);
    if (info->m_selected_record)
    {
        aimbot_t::get_points(info, studio_model);
        if (/*best_target( info ) && */ g_aimbot.get_best_point(info, nullptr, eye))
        {
            // m_best_target = info;
            std::unique_lock<std::mutex> lock(g_thread_handler.queue_mutex2);
            ret_state = true;
            finished = true;
            return;
            // valid_targets.push_back( info );
            // if ( info->m_damage >= info->m_ent->health( ) )
            //	break;
        }
    }
    std::unique_lock<std::mutex> lock(g_thread_handler.queue_mutex2);
    ret_state = false;
    finished = true;
}

std::vector<ent_info_t*> aimbot_t::mp_threading() const
{
    std::vector<ent_info_t*> targets = {};
    std::vector<std::shared_ptr<mpThreadObject>> objects = {};

    g_thread_handler.start();

    auto bones = static_cast<bone_array_t*>(g.m_interfaces->mem_alloc()->alloc(sizeof(bone_array_t) * 128));
    vec3_t eye;
    ang_t look;
    bone_array_t* backup_cache;

    for (auto& info : m_targets)
    {
        look = g.m_shoot_pos.look(info->m_ent->world_space_center());
        if (get_aim_matrix(look - g.m_local->aim_punch() * 2, bones))
        {
            auto bone_cache = &g.m_local->bone_cache();
            if (bone_cache)
            {
                backup_cache = bone_cache->m_pCachedBones;
                int backup_bone_count = bone_cache->m_CachedBoneCount;
                bone_cache->m_pCachedBones = bones;
                g.m_local->get_eye_pos(&eye);
                bone_cache->m_pCachedBones = backup_cache;
                bone_cache->m_CachedBoneCount = backup_bone_count;

                objects.push_back(std::make_shared<mpThreadObject>(info, eye));
                std::weak_ptr<mpThreadObject> ptr = objects.back();
                g_thread_handler.QueueJob([ptr] { ptr.lock()->run(); });
            }
        }
    }

    g.m_interfaces->mem_alloc()->free(bones);

    while (g_thread_handler.busy())
        continue;

    g_thread_handler.stop();

    {
        bool all_finished = true;
        while (!all_finished)
        {
            all_finished = true;
            for (auto& i : objects)
                if (!i->finished)
                    all_finished = false;
        }
        for (const auto& object : objects)
        {
            if (object->ret_state)
                targets.push_back(object->info);
        }
    }
    return targets;
}

void aimbot_t::on_tick()
{
    m_list_eye_pos.clear();
    // g.m_cmd->m_viewangles -= g.m_local->aim_punch( ) * 2;
    if (!settings::rage::general::enabled)
        return;

    if (!g.m_weapon_info)
        return;

    if (g.m_lag == 0)
        return;

    if (!g.m_can_fire)
    {
        return;
    }

    if (!settings::rage::general::key)
        return;

    if (!settings::rage::general::auto_shoot && !(g.m_cmd->m_buttons & IN_ATTACK))
        return;

    backup_players(false); // backup player vars before we change them

    m_last_target = m_best_target;
    m_best_target = nullptr;

    get_targets(); // get all possible targets

    std::vector<ent_info_t*> valid_targets = mp_threading();

    for (auto& i : valid_targets)
    {
        if (best_target(i)) // only set if the player is the best overall target
            m_best_target = i;
    }

    // g_thread_handler.start( );
    //
    // std::vector<std::shared_ptr<hcThreadObject>> objects = {};
    // for ( auto i = 0; i < valid_targets.size( ); i++ ) {
    //	if ( add_to_threads( objects, valid_targets[ i ], i ) ) // this is a very jank thread hander, will update soon
    //	{
    //		auto ptr = objects.back( );
    //		g_thread_handler.QueueJob( [ ptr ] {
    //			ptr->run( );
    //			} );
    //	}
    // }
    //
    // while ( g_thread_handler.busy( ) );
    //
    // g_thread_handler.stop( );

    // for ( auto &i : g_thread_handler.objects )
    //	i->run( );

    //{
    //	bool all_finished = true;
    //	while ( !all_finished ) {
    //		all_finished = true;
    //		for ( auto &i : objects )
    //			if ( !i->finished )
    //				all_finished = false;
    //	}
    //
    //	for ( const auto& object : objects ) {
    //		if ( object->ret_state ) // did the player pass?
    //	}
    //
    //}

    apply(); // look and shoot at the best point

    backup_players(true); // restore
}

```

`solace-csgo/aimbot.h`:

```h
#pragma once
#include "includes.h"



class aimbot_t {
public:

	struct hitbox_t {
		int m_bone = 0;
		bool m_box = false;
		vec3_t m_center = vec3_t( );
		vec3_t m_min = vec3_t( ), m_max = vec3_t();
		ang_t m_rot = ang_t();
		float m_radius = 0;
		hitbox_t( vec3_t min, vec3_t max, float radius ) : m_min( min ), m_max( max ), m_radius( radius ) { m_box = false; };
		hitbox_t( int bone, vec3_t center, vec3_t min, vec3_t max, ang_t rot ) : m_bone( bone ), m_center( center ), m_min( min ), m_max( max ), m_rot( rot ) { m_box = true; };
	};
	struct saved_eye_pos {
		saved_eye_pos( float& pitch, vec3_t& eye ) : pitch( pitch ), eye( eye ) {}
		float pitch;
		vec3_t eye;
	};
	std::vector < saved_eye_pos > m_list_eye_pos = {};
	std::vector< ent_info_t * > m_targets;
	backup_record_t m_backup[64] = {};
	ent_info_t *m_best_target = nullptr;
	ent_info_t * m_last_target = nullptr;
	vec3_t m_shoot_pos;
	static bool valid ( ent_info_t *ent );
	void get_targets ( );
	static void get_points( ent_info_t *info, studio_hdr_t *studio_model );
	static bool collides( math::custom_ray_t ray, ent_info_t* info, bone_array_t bones[ 128 ], float add = 0.f );
	static bool get_aim_matrix ( ang_t angle, bone_array_t *ret );
	bool get_best_point( ent_info_t* info, bone_array_t* bones, vec3_t &eye );
	bool best_target ( ent_info_t *&info ) const;
	void apply ( );
	static player_record_t *best_record( ent_info_t *info );
	void backup_players ( bool restore );
	std::vector<ent_info_t *> mp_threading ( ) const;
	static std::shared_ptr<player_record_t> last_record( ent_info_t *info );
	void draw_hitboxes ( player_t* ent = nullptr, bone_array_t *bones = nullptr ) const;
	bool check_hitchance( ent_info_t* info, ang_t& view, std::shared_ptr<player_record_t> record, aim_point_t* point );
	void StripAttack( );
	virtual void on_tick ( );
} inline g_aimbot;



```

`solace-csgo/animstate.cpp`:

```cpp
#include "animstate.h"
#include "player.h"

void anim_state::ModifyEyePosition( matrix_t* mat, vec3_t* pos ) {
	//  if ( *(this + 0x50) && (*(this + 0x100) || *(this + 0x94) != 0.0 || !sub_102C9480(*(this + 0x50))) )
	m_bSmoothHeightValid = false;
	if ( m_player &&
		( m_land || m_player->duck_amount( ) != 0.f || !m_player->m_ground_entity( ) ) ) {
		const auto v5 = 8;

		if constexpr ( v5 != -1 ) {
			const vec3_t head_pos(
				mat[ 8 ][ 0 ][ 3 ],
				mat[ 8 ][ 1 ][ 3 ],
				mat[ 8 ][ 2 ][ 3 ] );

			const auto v12 = head_pos;
			const float v7 = v12.z + 1.7;

			const auto v8 = pos->z;
			if ( v8 > v7 ) // if (v8 > (v12 + 1.7))
			{
				auto v13 = 0.f;
				const auto v3 = pos->z - v7;

				const float v4 = ( v3 - 4.f ) * 0.16666667;
				if ( v4 >= 0.f )
					v13 = std::fminf( v4, 1.f );

				pos->z = static_cast<float>( ( ( v7 - ( *pos ).z ) ) * ( ( static_cast< double >( v13 ) * v13 * 3.0 ) - ( static_cast< double >( v13 ) * v13 * 2.0 * v13 ) ) ) + ( *pos ).z;
			}
		}
	}
}

using CreateAnimState_t = void( __thiscall* ) ( anim_state*, player_t* );
void anim_state::CreateAnimationState( player_t* holder ) {

	static auto func = util::find( "client.dll", "55 8B EC 56 8B F1 B9 ? ? ? ? C7 46" );
	if ( !func )
		return;

	reinterpret_cast< CreateAnimState_t >( func )( this, holder );
}

typedef void( __vectorcall* fnUpdateAnimState ) ( PVOID, PVOID, float, float, float, char );
void anim_state::UpdateAnimationState( ang_t ang ) {

	static auto UpdateAnimState = address( util::find( "client.dll", "E8 ? ? ? ? 0F 57 C0 0F 11 86" ) ).rel32<
		uintptr_t >( 0x1 );

	if ( !UpdateAnimState || ( this == nullptr ) )
		return;

	__asm {
		push 1
		mov ecx, this
		movss xmm1, dword ptr[ ang + 4 ]
		movss xmm2, dword ptr[ ang ]
		call UpdateAnimState
	}
}

using ResetAnimState_t = void( __thiscall* ) ( anim_state* );
void anim_state::ResetAnimationState( ) {

	static auto func = reinterpret_cast< ResetAnimState_t >( util::find( "client.dll", "56 6A 01 68 ? ? ? ? 8B F1" ) );
	if ( !func )
		return;

	func( this );
}
```

`solace-csgo/animstate.h`:

```h
#pragma once

class player_t;
class entity_t;
class CStudioHdr;

#define ANIM_TRANSITION_WALK_TO_RUN 0
#define ANIM_TRANSITION_RUN_TO_WALK 1

#define CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED 2.0f

const float CS_PLAYER_SPEED_WALK_MODIFIER = 0.52f;

const float CS_PLAYER_SPEED_RUN = 260.0f;

class animation_layer_t {
public:
	float   m_anim_time;			// 0x0000
	float   m_fade_out_time;		// 0x0004
	CStudioHdr* m_pDispatchedStudioHdr;				// 0x0008
	int     m_nDispatchedSrc;				// 0x000C
	int     m_nDispatchedDst;				// 0x0010
	int     m_order;				// 0x0014
	int     m_sequence;				// 0x0018
	float   m_prev_cycle;			// 0x001C
	float   m_weight;				// 0x0020
	float   m_weight_delta_rate;	// 0x0024
	float   m_playback_rate;		// 0x0028
	float   m_cycle;				// 0x002C
	entity_t* m_owner;				// 0x0030
	int     m_bits;					// 0x0034
}; // size: 0x0038

class activity_modifiers_wrapper {
private:
	uint32_t gap[ 0x4D ]{ 0 };
	CUtlVector<uint16_t> modifiers{};

public:
	activity_modifiers_wrapper( ) = default;

	explicit activity_modifiers_wrapper( CUtlVector<uint16_t> current_modifiers ) {
		modifiers.RemoveAll( );
		modifiers.GrowVector( current_modifiers.Count( ) );

		for ( auto i = 0; i < current_modifiers.Count( ); i++ )
			modifiers[ i ] = current_modifiers[ i ];
	}

	void add_modifier( const char* name ) {
		using add_activity_modifier_fn_t = void( __thiscall* )( activity_modifiers_wrapper*, const char* );
		static const auto add_activity_modifier =
			reinterpret_cast< add_activity_modifier_fn_t >( util::find( "server.dll", "55 8B EC 8B 55 ? 83 EC ? 56" ) );

		if ( add_activity_modifier && name )
			add_activity_modifier( this, name );
	};

	CUtlVector<uint16_t> get( ) const {
		return modifiers;
	}
};

class anim_state {
public:
	PAD( 0x1C );				// 0x0000
	player_t *m_outer;			// 0x001C
	PAD( 0x40 );				// 0x0020
	player_t *m_player;			// 0x0060
	PAD( 0x8 );					// 0x0064
	float   m_time;				// 0x006C
	int     m_frame;			// 0x0070
	float   m_update_delta;		// 0x0074
	float   m_eye_yaw;			// 0x0078
	float   m_eye_pitch;		// 0x007C
	float   m_goal_feet_yaw;	// 0x0080
	float   m_cur_feet_yaw;		// 0x0084
	float m_flCurrentTorsoYaw;                // 0x88
	float m_flUnknownVelocityLean;            // 0x8C changes when moving/jumping/hitting ground
	float m_flLeanAmount;                     // 0x90
	float m_flUnknown1;                       // 0x94
	float feetCycle;
	float feetYawRate;
	PAD( 0x4 );				// 0x0088
	float   m_dip_cycle;        // 0x00A4
	float   m_dip_adj;          // 0x00A8
	float m_fUnknown3;								  // 0xAC
	vec3_t m_vOrigin;								  // 0xB0, 0xB4, 0xB8
	vec3_t m_vLastOrigin;							  // 0xBC, 0xC0, 0xC4
	vec3_t m_vecVelocity;							  // 0xC8
	vec3_t m_vecNormalizedVelocity;
	vec3_t m_vecVelocityNormalizedNonZero;
	float   m_speed;			// 0x00EC
	float   m_fall_velocity;    // 0x00F0
	float					m_flSpeedAsPortionOfRunTopSpeed;
	float					m_flSpeedAsPortionOfWalkTopSpeed;
	float					m_flSpeedAsPortionOfCrouchTopSpeed;
	float m_flTimeSinceStartedMoving;			  // 0x100
	float m_flTimeSinceStoppedMoving;
	bool    m_ground;			// 0x0108
	bool    m_land;             // 0x0109

	float					m_flJumpToFall;
	float					m_flDurationInAir;
	float					m_flLeftGroundHeight;
	float					m_flLandAnimMultiplier;

	float					m_flWalkToRunTransition;

	bool					m_bLandedOnGroundThisFrame;
	bool					m_bLeftTheGroundThisFrame;

	float					m_flInAirSmoothValue;

	bool					m_bOnLadder;
	float					m_flLadderWeight;
	float					m_flLadderSpeed;

	bool					m_bWalkToRunTransitionState;

	PAD(0x1F9);				// 0x010C
	bool    m_dip_air;			// 0x0328
	bool					m_bSmoothHeightValid;
	vec3_t					m_flLastTimeVelocityOverTen;

	float					m_flAimYawMin;
	float					m_flAimYawMax;
	float   m_min_pitch;        // 0x033C
	float   m_max_pitch;        // 0x033C
	PAD( 0x4 );					// 0x0340


	using CreateAnimState_t = void( __thiscall * ) ( anim_state *, player_t * );
	inline void CreateAnimationState ( player_t *holder ) {

		static auto func = util::find( "client.dll", "55 8B EC 56 8B F1 B9 ? ? ? ? C7 46" );
		if ( !func )
			return;

		reinterpret_cast< CreateAnimState_t >(func)( this, holder );
	}

	typedef void( __vectorcall *fnUpdateAnimState ) ( PVOID, PVOID, float, float, float, char );
	inline void UpdateAnimationState ( ang_t ang ) {

		static auto UpdateAnimState = address( util::find( "client.dll", "E8 ? ? ? ? 0F 57 C0 0F 11 86" ) ).rel32<
			uintptr_t >( 0x1 );

		if ( !UpdateAnimState || (this == nullptr) )
			return;

		__asm {
			push 1
			mov ecx, this
			movss xmm1, dword ptr[ ang + 4 ]
			movss xmm2, dword ptr[ ang ]
			call UpdateAnimState
			}
	}

	using ResetAnimState_t = void( __thiscall * ) ( anim_state * );
	inline void ResetAnimationState ( ) {

		static auto func = reinterpret_cast< ResetAnimState_t >(util::find( "client.dll", "56 6A 01 68 ? ? ? ? 8B F1" ));
		if ( !func )
			return;

		func( this );
	}

};

```

`solace-csgo/app_system.h`:

```h
#pragma once
#include "render.h"

class i_app_system;

typedef void *( *create_interface_fn )( const char *name, int *return_code );

class i_app_system {
public:
	virtual bool connect( create_interface_fn factory ) = 0;
	virtual void disconnect( ) = 0;
	virtual void *query_interface( const char *interface_name ) = 0;
	virtual int init( ) = 0;
	virtual void shutdown( ) = 0;
	virtual const void *get_dependencies( ) = 0;
	virtual int  get_tier( ) = 0;
	virtual void reconnect( create_interface_fn factory, const char *interface_name ) = 0;
	virtual void unknown( ) = 0;
};

typedef unsigned long HFont;
typedef unsigned int VPANEL;

class c_surface : public i_app_system {
public:

	virtual void          RunFrame( ) = 0;
	virtual VPANEL		  GetEmbeddedPanel( ) = 0;
	virtual void          SetEmbeddedPanel( VPANEL pPanel ) = 0;
	virtual void          PushMakeCurrent( VPANEL panel, bool useInsets ) = 0;
	virtual void          PopMakeCurrent( VPANEL panel ) = 0;
	virtual void          DrawSetColor( int r, int g, int b, int a ) = 0;
	virtual void          DrawSetColor( color col ) = 0;
	virtual void          DrawFilledRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual void          DrawFilledRectArray( void* pRects, int numRects ) = 0;
	virtual void          DrawOutlinedRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual void          DrawLine( int x0, int y0, int x1, int y1 ) = 0;
	virtual void          DrawPolyLine( int* px, int* py, int numPoints ) = 0;
	virtual void          DrawSetApparentDepth( float f ) = 0;
	virtual void          DrawClearApparentDepth( void ) = 0;
	virtual void          DrawSetTextFont( HFont font ) = 0;
	virtual void          DrawSetTextColor( int r, int g, int b, int a ) = 0;
	virtual void          DrawSetTextColor( color col ) = 0;
	virtual void          DrawSetTextPos( int x, int y ) = 0;
	virtual void          DrawGetTextPos( int& x, int& y ) = 0;
	virtual void          DrawPrintText( const wchar_t* text, int textLen, int drawType = 0 ) = 0;
	virtual void          DrawUnicodeChar( wchar_t wch, int drawType = 0 ) = 0;
	virtual void          DrawFlushText( ) = 0;
	virtual void* CreateHTMLWindow( void* events, VPANEL context ) = 0;
	virtual void          PaintHTMLWindow( void* htmlwin ) = 0;
	virtual void          DeleteHTMLWindow( void* htmlwin ) = 0;
	virtual int           DrawGetTextureId( char const* filename ) = 0;
	virtual bool          DrawGetTextureFile( int id, char* filename, int maxlen ) = 0;
	virtual void          DrawSetTextureFile( int id, const char* filename, int hardwareFilter, bool forceReload ) = 0;
	virtual void          DrawSetTextureRGBA( int id, const unsigned char* rgba, int wide, int tall ) = 0;
	virtual void          DrawSetTexture( int id ) = 0;
	virtual void          DeleteTextureByID( int id ) = 0;
	virtual void          DrawGetTextureSize( int id, int& wide, int& tall ) = 0;
	virtual void          DrawTexturedRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual bool          IsTextureIDValid( int id ) = 0;
	virtual int           CreateNewTextureID( bool procedural = false ) = 0;
	virtual void          GetScreenSize( int& wide, int& tall ) = 0;
	virtual void          SetAsTopMost( VPANEL panel, bool state ) = 0;
	virtual void          BringToFront( VPANEL panel ) = 0;
	virtual void          SetForegroundWindow( VPANEL panel ) = 0;
	virtual void          SetPanelVisible( VPANEL panel, bool state ) = 0;
	virtual void          SetMinimized( VPANEL panel, bool state ) = 0;
	virtual bool          IsMinimized( VPANEL panel ) = 0;
	virtual void          FlashWindow( VPANEL panel, bool state ) = 0;
	virtual void          SetTitle( VPANEL panel, const wchar_t* title ) = 0;
	virtual void          SetAsToolBar( VPANEL panel, bool state ) = 0;
	virtual void          CreatePopup( VPANEL panel, bool minimised, bool showTaskbarIcon = true, bool disabled = false, bool mouseInput = true, bool kbInput = true ) = 0;
	virtual void          SwapBuffers( VPANEL panel ) = 0;
	virtual void          Invalidate( VPANEL panel ) = 0;
	virtual void          SetCursor( unsigned long cursor ) = 0;
	virtual bool          IsCursorVisible( ) = 0;
	virtual void          ApplyChanges( ) = 0;
	virtual bool          IsWithin( int x, int y ) = 0;
	virtual bool          HasFocus( ) = 0;
	virtual bool          SupportsFeature( int /*SurfaceFeature_t*/ feature ) = 0;
	virtual void          RestrictPaintToSinglePanel( VPANEL panel, bool bForceAllowNonModalSurface = false ) = 0;
	virtual void          SetModalPanel( VPANEL ) = 0;
	virtual VPANEL		  GetModalPanel( ) = 0;
	virtual void          UnlockCursor( ) = 0;
	virtual void          LockCursor( ) = 0;
};
```

`solace-csgo/base_client.h`:

```h
#pragma once
#include "includes.h"

struct recv_prop_t;

class d_variant {
public:
	union {
		float	m_Float;
		long	m_Int;
		char *string;
		void *data;
		vec3_t vector;
	};
};

enum class send_prop_type {
	DPT_Int = 0,
	DPT_Float,
	DPT_vector,
	DPT_vectorXY, // Only encodes the XY of a vector, ignores Z
	DPT_String,
	DPT_Array,     // An array of the base types (can't be of datatables).
	DPT_DataTable,
	DPT_Int64,
	DPT_NUMSendPropTypes
};

class c_recv_proxy_data {
public:
	const recv_prop_t *m_recv_prop;
	char _pad[ 4 ];
	d_variant		m_value;
	int				m_element;
	int				m_object_id;
};

typedef void( *recv_var_proxy_fn )( const c_recv_proxy_data *pData, void *pStruct, void *pOut );

struct decoder_t {
	//recv_table_t* m_pTable;
	//char buf[0x134];
	//CClientSendTable* m_pClientSendTable;
	//
	//// This is from the data that we've received from the server.
	//CSendTablePrecalc	m_Precalc;
	//
	//// This mirrors m_Precalc.m_Props. 
	//CUtlVector<const recv_prop_t*>	m_Props;
	//CUtlVector<const recv_prop_t*>	m_DatatableProps;
	//
	//void* send_props;
};

struct recv_table_t {
	recv_prop_t *m_props;
	int				m_prop_count;
	decoder_t *m_decoder;
	char *m_net_table_name;
	bool			m_initialized;
	bool			m_in_main_list;
};


struct recv_prop_t {
	char *m_var_name;
	int						m_recv_type;
	int						m_flags;
	int						m_string_buffer_size;
	bool					m_inside_array;
	const void *m_extra_data;
	recv_prop_t *m_array_prop;
	void *m_array_length_proxy;
	recv_var_proxy_fn m_proxy_fn;
	void *m_data_table_proxy_fn;
	recv_table_t *m_data_table;
	int						m_offset;
	int						m_element_stride;
	int						m_elements;
	const char *m_parent_array_prop_name;
};
enum client_frame_stage_t {
	FRAME_UNDEFINED = -1,			// (haven't run any frames yet)
	FRAME_START,

	// A network packet is being recieved
	FRAME_NET_UPDATE_START,
	// Data has been received and we're going to start calling PostDataUpdate
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	// Data has been received and we've called PostDataUpdate on all data recipients
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	// We've received all packets, we can now do interpolation, prediction, etc..
	FRAME_NET_UPDATE_END,

	// We're about to start rendering the scene
	FRAME_RENDER_START,
	// We've finished rendering the scene.
	FRAME_RENDER_END
};
enum ClassId {
	ClassId_CAI_BaseNPC = 0,
	ClassId_CAK47,
	ClassId_CBaseAnimating,
	ClassId_CBaseAnimatingOverlay,
	ClassId_CBaseAttributableItem,
	ClassId_CBaseButton,
	ClassId_CBaseCombatCharacter,
	ClassId_CBaseCombatWeapon,
	ClassId_CBaseCSGrenade,
	ClassId_CBaseCSGrenadeProjectile,
	ClassId_CBaseDoor,
	ClassId_CBaseEntity,
	ClassId_CBaseFlex,
	ClassId_CBaseGrenade,
	ClassId_CBaseParticleEntity,
	ClassId_CBasePlayer,
	ClassId_CBasePropDoor,
	ClassId_CBaseTeamObjectiveResource,
	ClassId_CBaseTempEntity,
	ClassId_CBaseToggle,
	ClassId_CBaseTrigger,
	ClassId_CBaseViewModel,
	ClassId_CBaseVPhysicsTrigger,
	ClassId_CBaseWeaponWorldModel,
	ClassId_CBeam,
	ClassId_CBeamSpotlight,
	ClassId_CBoneFollower,
	ClassId_CBRC4Target,
	ClassId_CBreachCharge,
	ClassId_CBreachChargeProjectile,
	ClassId_CBreakableProp,
	ClassId_CBreakableSurface,
	ClassId_CBumpMine,
	ClassId_CBumpMineProjectile,
	ClassId_CC4,
	ClassId_CCascadeLight,
	ClassId_CChicken,
	ClassId_CColorCorrection,
	ClassId_CColorCorrectionVolume,
	ClassId_CCSGameRulesProxy,
	ClassId_CCSPlayer,
	ClassId_CCSPlayerResource,
	ClassId_CCSRagdoll,
	ClassId_CCSTeam,
	ClassId_CDangerZone,
	ClassId_CDangerZoneController,
	ClassId_CDEagle,
	ClassId_CDecoyGrenade,
	ClassId_CDecoyProjectile,
	ClassId_CDrone,
	ClassId_CDronegun,
	ClassId_CDynamicLight,
	ClassId_CDynamicProp,
	ClassId_CEconEntity,
	ClassId_CEconWearable,
	ClassId_CEmbers,
	ClassId_CEntityDissolve,
	ClassId_CEntityFlame,
	ClassId_CEntityFreezing,
	ClassId_CEntityParticleTrail,
	ClassId_CEnvAmbientLight,
	ClassId_CEnvDetailController,
	ClassId_CEnvDOFController,
	ClassId_CEnvGasCanister,
	ClassId_CEnvParticleScript,
	ClassId_CEnvProjectedTexture,
	ClassId_CEnvQuadraticBeam,
	ClassId_CEnvScreenEffect,
	ClassId_CEnvScreenOverlay,
	ClassId_CEnvTonemapController,
	ClassId_CEnvWind,
	ClassId_CFEPlayerDecal,
	ClassId_CFireCrackerBlast,
	ClassId_CFireSmoke,
	ClassId_CFireTrail,
	ClassId_CFish,
	ClassId_CFists,
	ClassId_CFlashbang,
	ClassId_CFogController,
	ClassId_CFootstepControl,
	ClassId_CFunc_Dust,
	ClassId_CFunc_LOD,
	ClassId_CFuncAreaPortalWindow,
	ClassId_CFuncBrush,
	ClassId_CFuncConveyor,
	ClassId_CFuncLadder,
	ClassId_CFuncMonitor,
	ClassId_CFuncMoveLinear,
	ClassId_CFuncOccluder,
	ClassId_CFuncReflectiveGlass,
	ClassId_CFuncRotating,
	ClassId_CFuncSmokeVolume,
	ClassId_CFuncTrackTrain,
	ClassId_CGameRulesProxy,
	ClassId_CGrassBurn,
	ClassId_CHandleTest,
	ClassId_CHEGrenade,
	ClassId_CHostage,
	ClassId_CHostageCarriableProp,
	ClassId_CIncendiaryGrenade,
	ClassId_CInferno,
	ClassId_CInfoLadderDismount,
	ClassId_CInfoMapRegion,
	ClassId_CInfoOverlayAccessor,
	ClassId_CItem_Healthshot,
	ClassId_CItemCash,
	ClassId_CItemDogtags,
	ClassId_CKnife,
	ClassId_CKnifeGG,
	ClassId_CLightGlow,
	ClassId_CMaterialModifyControl,
	ClassId_CMelee,
	ClassId_CMolotovGrenade,
	ClassId_CMolotovProjectile,
	ClassId_CMovieDisplay,
	ClassId_CParadropChopper,
	ClassId_CParticleFire,
	ClassId_CParticlePerformanceMonitor,
	ClassId_CParticleSystem,
	ClassId_CPhysBox,
	ClassId_CPhysBoxMultiplayer,
	ClassId_CPhysicsProp,
	ClassId_CPhysicsPropMultiplayer,
	ClassId_CPhysMagnet,
	ClassId_CPhysPropAmmoBox,
	ClassId_CPhysPropLootCrate,
	ClassId_CPhysPropRadarJammer,
	ClassId_CPhysPropWeaponUpgrade,
	ClassId_CPlantedC4,
	ClassId_CPlasma,
	ClassId_CPlayerPing,
	ClassId_CPlayerResource,
	ClassId_CPointCamera,
	ClassId_CPointCommentaryNode,
	ClassId_CPointWorldText,
	ClassId_CPoseController,
	ClassId_CPostProcessController,
	ClassId_CPrecipitation,
	ClassId_CPrecipitationBlocker,
	ClassId_CPredictedViewModel,
	ClassId_CProp_Hallucination,
	ClassId_CPropCounter,
	ClassId_CPropDoorRotating,
	ClassId_CPropJeep,
	ClassId_CPropVehicleDriveable,
	ClassId_CRagdollManager,
	ClassId_CRagdollProp,
	ClassId_CRagdollPropAttached,
	ClassId_CRopeKeyframe,
	ClassId_CSCAR17,
	ClassId_CSceneEntity,
	ClassId_CSensorGrenade,
	ClassId_CSensorGrenadeProjectile,
	ClassId_CShadowControl,
	ClassId_CSlideshowDisplay,
	ClassId_CSmokeGrenade,
	ClassId_CSmokeGrenadeProjectile,
	ClassId_CSmokeStack,
	ClassId_CSnowball,
	ClassId_CSnowballPile,
	ClassId_CSnowballProjectile,
	ClassId_CSpatialEntity,
	ClassId_CSpotlightEnd,
	ClassId_CSprite,
	ClassId_CSpriteOriented,
	ClassId_CSpriteTrail,
	ClassId_CStatueProp,
	ClassId_CSteamJet,
	ClassId_CSun,
	ClassId_CSunlightShadowControl,
	ClassId_CSurvivalSpawnChopper,
	ClassId_CTablet,
	ClassId_CTeam,
	ClassId_CTeamplayRoundBasedRulesProxy,
	ClassId_CTEArmorRicochet,
	ClassId_CTEBaseBeam,
	ClassId_CTEBeamEntPoint,
	ClassId_CTEBeamEnts,
	ClassId_CTEBeamFollow,
	ClassId_CTEBeamLaser,
	ClassId_CTEBeamPoints,
	ClassId_CTEBeamRing,
	ClassId_CTEBeamRingPoint,
	ClassId_CTEBeamSpline,
	ClassId_CTEBloodSprite,
	ClassId_CTEBloodStream,
	ClassId_CTEBreakModel,
	ClassId_CTEBSPDecal,
	ClassId_CTEBubbles,
	ClassId_CTEBubbleTrail,
	ClassId_CTEClientProjectile,
	ClassId_CTEDecal,
	ClassId_CTEDust,
	ClassId_CTEDynamicLight,
	ClassId_CTEEffectDispatch,
	ClassId_CTEEnergySplash,
	ClassId_CTEExplosion,
	ClassId_CTEFireBullets,
	ClassId_CTEFizz,
	ClassId_CTEFootprintDecal,
	ClassId_CTEFoundryHelpers,
	ClassId_CTEGaussExplosion,
	ClassId_CTEGlowSprite,
	ClassId_CTEImpact,
	ClassId_CTEKillPlayerAttachments,
	ClassId_CTELargeFunnel,
	ClassId_CTEMetalSparks,
	ClassId_CTEMuzzleFlash,
	ClassId_CTEParticleSystem,
	ClassId_CTEPhysicsProp,
	ClassId_CTEPlantBomb,
	ClassId_CTEPlayerAnimEvent,
	ClassId_CTEPlayerDecal,
	ClassId_CTEProjectedDecal,
	ClassId_CTERadioIcon,
	ClassId_CTEShatterSurface,
	ClassId_CTEShowLine,
	ClassId_CTesla,
	ClassId_CTESmoke,
	ClassId_CTESparks,
	ClassId_CTESprite,
	ClassId_CTESpriteSpray,
	ClassId_CTest_ProxyToggle_Networkable,
	ClassId_CTestTraceline,
	ClassId_CTEWorldDecal,
	ClassId_CTriggerPlayerMovement,
	ClassId_CTriggerSoundOperator,
	ClassId_CVGuiScreen,
	ClassId_CVoteController,
	ClassId_CWaterBullet,
	ClassId_CWaterLODControl,
	ClassId_CWeaponAug,
	ClassId_CWeaponAWP,
	ClassId_CWeaponBaseItem,
	ClassId_CWeaponBizon,
	ClassId_CWeaponCSBase,
	ClassId_CWeaponCSBaseGun,
	ClassId_CWeaponCycler,
	ClassId_CWeaponElite,
	ClassId_CWeaponFamas,
	ClassId_CWeaponFiveSeven,
	ClassId_CWeaponG3SG1,
	ClassId_CWeaponGalil,
	ClassId_CWeaponGalilAR,
	ClassId_CWeaponGlock,
	ClassId_CWeaponHKP2000,
	ClassId_CWeaponM249,
	ClassId_CWeaponM3,
	ClassId_CWeaponM4A1,
	ClassId_CWeaponMAC10,
	ClassId_CWeaponMag7,
	ClassId_CWeaponMP5Navy,
	ClassId_CWeaponMP7,
	ClassId_CWeaponMP9,
	ClassId_CWeaponNegev,
	ClassId_CWeaponNOVA,
	ClassId_CWeaponP228,
	ClassId_CWeaponP250,
	ClassId_CWeaponP90,
	ClassId_CWeaponSawedoff,
	ClassId_CWeaponSCAR20,
	ClassId_CWeaponScout,
	ClassId_CWeaponSG550,
	ClassId_CWeaponSG552,
	ClassId_CWeaponSG556,
	ClassId_CWeaponShield,
	ClassId_CWeaponSSG08,
	ClassId_CWeaponTaser,
	ClassId_CWeaponTec9,
	ClassId_CWeaponTMP,
	ClassId_CWeaponUMP45,
	ClassId_CWeaponUSP,
	ClassId_CWeaponXM1014,
	ClassId_CWorld,
	ClassId_CWorldVguiText,
	ClassId_DustTrail,
	ClassId_MovieExplosion,
	ClassId_ParticleSmokeGrenade,
	ClassId_RocketTrail,
	ClassId_SmokeTrail,
	ClassId_SporeExplosion,
	ClassId_SporeTrail,
};
using CreateClientClass_t = void *( __cdecl * )( int index, int serial );
using CreateEvent_t = void *( __cdecl * )( );
class c_client_class {
public:
	CreateClientClass_t m_pCreate;
	CreateEvent_t	    m_pCreateEvent;
	char *m_pNetworkName;
	recv_table_t *m_pRecvTable;
	c_client_class *m_pNext;
	int					m_ClassID;
};

class c_base_client {
public:
	VFUNC( get_all_classes( ), 8, c_client_class* ( __thiscall* )( decltype(this) ) )
};
```

`solace-csgo/block_bot.cpp`:

```cpp
#include "block_bot.h"
#include "includes.h"
#include "movement.h"

void block_bot_t::on_draw( ) const {
	if ( m_draw.empty( ) )
		return;
	static vec3_t last_world;
	math::world_to_screen( m_draw[ 0 ], last_world );
	for ( auto i = 1; i < m_draw.size( ); i++ ) {
		vec3_t world;
		math::world_to_screen( m_draw[ i ], world );
		g.m_render->line( last_world.x, last_world.y, world.x, world.y, color( 255, 255, 255 ), 1);
		last_world = world;
	}
}

void block_bot_t::friction ( float surface_friction, vec3_t *velocity ) {
	static auto sv_friction = g.m_interfaces->console( )->get_convar( "sv_friction" );
	static auto sv_stopspeed = g.m_interfaces->console( )->get_convar( "sv_stopspeed" );
	auto speed = velocity->length_2d( );
	if ( speed > 0.f ) {
		auto friction = sv_friction->GetFloat(  );
		auto stop_speed = std::max< float >( speed, sv_stopspeed->GetFloat( ) );
		auto control = fminf( speed, stop_speed );
		auto drop = control * friction * surface_friction * g.m_interfaces->globals( )->m_interval_per_tick;
		auto newspeed = speed - drop;
		if ( newspeed < 0 )
			newspeed = 0;

		newspeed /= speed;
		*velocity *= newspeed;

		speed = velocity->length_2d( );
	}
	velocity->z = 0;
}

void block_bot_t::on_tick ( ) {
	m_draw.clear( );
	if ( !settings::misc::griefing::block_bot ) {
		target = nullptr;
		return;
	}
	if ( !g.m_local )
		return;
	static auto original_origin = vec3_t( );
	static auto original_local = vec3_t( );
	const auto &local_origin = g.m_local->origin( );
	auto valid = [ ]( ent_info_t *ent ) {
		if ( !ent )
			return false;
		if ( !ent->m_valid )
			return false;
		if ( !ent->m_teamate )
			return false;
		auto delta = ent->m_ent->origin( ) - g.m_local->origin( );
		if ( delta.length( ) > 7000.f )
			return false;
		return true;
	};
	
	if ( !valid(target) )
		target = nullptr; // lost target, find someone new

	static auto axis = ang_t( );
	if ( target == nullptr) {
		std::vector<ent_info_t *> possible_targets = {};
		for ( auto &i : g_player_manager.m_ents ) {
			if ( valid( &i ) )
				possible_targets.push_back( &i );
		}
		struct compare {
			vec3_t m_local;
			compare( vec3_t local ) : m_local( local ) { };
			bool operator() ( ent_info_t *struct1, ent_info_t *struct2 ) const {
				return ( struct1->m_ent->origin( ) - m_local ).length_sqr( ) < ( struct2->m_ent->origin( ) - m_local ).length_sqr( );
			}
		};
		std::sort( possible_targets.begin( ), possible_targets.end( ), compare( local_origin ) );
		if ( possible_targets.empty( ) )
			return;
		target = possible_targets[ 0 ];
		auto parellel = static_cast<int>(roundf( local_origin.look( possible_targets[ 0 ]->m_ent->origin( ) ).y ));
		const auto remainder = parellel % 90;
		if ( remainder >= 45 )
			parellel += 90 - remainder;
		else
			parellel -= remainder;
		
		axis = ang_t(0, parellel + 90, 0);
		original_origin = possible_targets[ 0 ]->m_ent->origin( );
		const auto plane = axis.forward( );
		
		original_local = (local_origin + plane * ( original_origin - local_origin ).dot(plane)) / g.m_interfaces->globals( )->m_interval_per_tick;
	}

	if ( target == nullptr )
		return;

	if ( target->m_records.size( ) < 2 )
		return;

	if ( !target->m_records[ 0 ] || target->m_records[ 0 ]->m_dormant )
		return;

	if ( !target->m_records[ 1 ] || target->m_records[ 1 ]->m_dormant )
		return;
	

	auto target_velocity = target->m_records[ 0 ]->m_velocity;
	auto old_dir = RAD2DEG( std::atan2( target->m_records[1]->m_velocity.y, target->m_records[ 1 ]->m_velocity.x ) );
	auto dir = RAD2DEG( std::atan2( target_velocity.y, target_velocity.x ) );

	auto change = dir - old_dir;

	target_velocity.z = 0;

	// only over predict if they're moving in a consistent direction
	if ( change < 5.f ) {
		auto hyp = target_velocity.length_2d( );
		
		target_velocity.x = std::cos( DEG2RAD( dir + change ) ) * hyp;
		target_velocity.y = std::sin( DEG2RAD( dir + change ) ) * hyp;
	}
	else {
		target_velocity.reset();
	}
	
	

	static auto last_origin = local_origin;
	auto velocity = ( local_origin - last_origin ) / g.m_interfaces->globals( )->m_interval_per_tick;
	velocity.z = 0;

	static auto sv_accelerate = g.m_interfaces->console( )->get_convar( "sv_accelerate" );
	friction( g.m_local->surface_friction(  ), &velocity );

	float max_accel = 450;
	auto accel_speed = sv_accelerate->GetFloat(  ) * g.m_interfaces->globals( )->m_interval_per_tick * 450;
	if ( max_accel > accel_speed )
		max_accel = accel_speed;

	if ( auto *ground_ent = static_cast< player_t * >(g.m_interfaces->entity_list( )->get_client_entity_handle( g.m_local->m_ground_entity( ) ) ) ) {
		auto target_origin = target->m_ent->origin( ) + target_velocity * g.m_interfaces->globals( )->m_interval_per_tick;
		if ( ground_ent->index() != target->m_ent->index() ) {
			auto delta = target_origin - original_origin;
			delta.z = 0;
			const auto plane = axis.forward( );
			const auto fraction = delta.dot( plane );
			const auto projected_origin = original_local + plane * fraction;

			auto local_delta = (projected_origin - local_origin) / g.m_interfaces->globals( )->m_interval_per_tick;
			local_delta.z = 0;

			local_delta -= velocity;

			float speed = local_delta.length_2d( );

			g.m_view_angles = ang_t( 0, static_cast< float >( atan2( local_delta.y, local_delta.x ) * ( 180.f / M_PI ) ), 0 );;
			const auto current_speed = velocity.dot( local_delta.normalized( ) );
			auto projected_delta = fminf( 450.f, local_delta.length_2d( ) + current_speed );

			if ( g.m_weapon_info && g.m_weapon_info->m_max_player_speed > 0.f ) {
				const auto fRatio = projected_delta / g.m_weapon_info->m_max_player_speed;
				if ( fRatio > 0.f )
					projected_delta /= fRatio;
			}

			const auto add_speed = projected_delta - current_speed;
			if ( max_accel < add_speed ) {
				//distance is farther than we can account for
				//go as fast as we can
				g.m_cmd->m_forwardmove = 450;
				g.m_cmd->m_sidemove = 0;
			} else {
				// const float kAccelerationScale = MAX( 250.0f, wishspeed );
				// accelspeed = accel * gpGlobals->frametime * kAccelerationScale * player->m_surfaceFriction;
				accel_speed = sv_accelerate->GetFloat( ) * g.m_interfaces->globals( )->m_interval_per_tick * fmaxf( 250, projected_delta );

				g.m_cmd->m_forwardmove = 0;
				if ( accel_speed <= add_speed ) {
					projected_delta /= ( sv_accelerate->GetFloat( ) * g.m_interfaces->globals( )->m_interval_per_tick );
				}
				g.m_cmd->m_forwardmove = projected_delta;
				g.m_cmd->m_sidemove = 0;
			}
		} else {
			//distance to compensate
			auto local_delta = (target_origin - local_origin) / g.m_interfaces->globals( )->m_interval_per_tick;
			local_delta.z = 0;

			// remove our velocity
			// local_delta is now the desired velocity change 
			local_delta -= velocity;

			g.m_view_angles = ang_t( 0, static_cast< float >( atan2( local_delta.y, local_delta.x ) * ( 180.f / M_PI ) ), 0 );

			const auto current_speed = velocity.dot( local_delta.normalized( ) );

			auto projected_delta = fminf( 450.f, local_delta.length_2d( ) + current_speed );

			if ( g.m_weapon_info && g.m_weapon_info->m_max_player_speed > 0.f ) {
				const auto fRatio = projected_delta / g.m_weapon_info->m_max_player_speed;
				if ( fRatio > 0.f )
					projected_delta /= fRatio;
			}

			const auto add_speed = projected_delta - current_speed;
			if ( max_accel < add_speed ) {
				//distance is farther than we can account for
				//go as fast as we can
				g.m_cmd->m_forwardmove = 450;
				g.m_cmd->m_sidemove = 0;
			} else {
				// const float kAccelerationScale = MAX( 250.0f, wishspeed );
				// accelspeed = accel * gpGlobals->frametime * kAccelerationScale * player->m_surfaceFriction;
				accel_speed = sv_accelerate->GetFloat( ) * g.m_interfaces->globals( )->m_interval_per_tick * fmaxf( 250, projected_delta );

				g.m_cmd->m_forwardmove = 0;
				if ( accel_speed <= add_speed ) {
					//add speed is too high, try to correct the accelspeed
					projected_delta /= ( sv_accelerate->GetFloat( ) * g.m_interfaces->globals( )->m_interval_per_tick );
				}
				g.m_cmd->m_forwardmove = std::clamp<float>( projected_delta, -450.f, 450.f );
				g.m_cmd->m_sidemove = 0.f;
			}
		}
	}
	else {
		auto target_origin = target->m_ent->origin( );
		g.m_view_angles = ang_t( 0, local_origin.look( target_origin ).y, 0 );
		g_movement.set_force_strafe( true );
		g.m_cmd->m_forwardmove = 450;
		g.m_cmd->m_sidemove = 0;
	}
	last_origin = local_origin;
}
	

```

`solace-csgo/block_bot.h`:

```h
#pragma once
#include <vector>

#include "console.h"
class vec3_t;
struct ent_info_t;
class block_bot_t {
	ent_info_t *target = nullptr;
	std::vector<vec3_t> m_draw;

public:
	void on_draw ( ) const;
	void friction ( float surface_friction, vec3_t *velocity );
	void on_tick( );
} inline g_block_bot;


```

`solace-csgo/bones.cpp`:

```cpp
#include "bones.h"
#include "includes.h"
#include "thread_handler.h"


bool bones_t::setup( player_t *player, bone_array_t *out, std::shared_ptr<player_record_t> record, CIKContext *ipk ) {
	// if the record isnt setup yet.

	//std::unique_lock<std::mutex> lock( g_thread_handler.queue_mutex );
	// run setupbones rebuilt.
	g.m_interfaces->mdlcache( )->begin_coarse_lock( );
	g.m_interfaces->mdlcache( )->begin_lock( );

	record->m_setup = BuildBones( player, bone_used_by_anything & ~bone_used_by_bone_merge, out, record, ipk );

	g.m_interfaces->mdlcache( )->end_lock( );
	g.m_interfaces->mdlcache( )->end_coarse_lock( );

	return record->m_setup;
}


class PoseDebugger;

class _BoneSetup {
public:
	void init( const CStudioHdr* pStudioHdr, int boneMask, const float poseParameter[ ], PoseDebugger* pPoseDebugger = nullptr ) {
		m_boneMask = boneMask;
		m_flPoseParameters = poseParameter;
		m_pStudioHdr = pStudioHdr;
		m_pPoseDebugger = pPoseDebugger;
	}
	_BoneSetup( const CStudioHdr* pStudioHdr, int boneMask, const float poseParameter[ ], PoseDebugger* pPoseDebugger = nullptr ) {
		m_boneMask = boneMask;
		m_flPoseParameters = poseParameter;
		m_pStudioHdr = pStudioHdr;
		m_pPoseDebugger = pPoseDebugger;
	}

	void InitPose( vec3_t* pos, quaternion_t* q ) const {
		static void* fn = nullptr;
		if ( !fn ) fn = util::find( "server.dll", "55 8B EC 83 EC 10 53 8B D9 89 55" );

		auto studioHdr = m_pStudioHdr;
		auto boneMask = m_boneMask;

		__asm
		{
			pushad
			pushfd

			mov ecx, studioHdr
			mov edx, pos
			push boneMask
			push q
			call fn
			add esp, 8

			popfd
			popad
		}
	}

	void AccumulatePose( vec3_t pos[ ], quaternion_t q[ ], int iSequence, float flCycle, float flWeight, float flTime, CIKContext* pIKContext ) const {
#ifdef _DEBUG
		//Remove breakpoint when debugger is attached
		static bool onceOnly = false;
		if ( !onceOnly ) {
			onceOnly = true;
			auto pattern = util::find( "server.dll", "? F3 0F 10 4D ? 0F 57 C0 0F 2F C1 F3 0F 11 44 24 ?" );
			if ( pattern ) {
				DWORD oldProt;
				VirtualProtect( pattern, 1, PAGE_EXECUTE_READWRITE, &oldProt );
				*pattern = 0x90;
				VirtualProtect( pattern, 1, oldProt, &oldProt );
			}
		}
#endif

		static void* fn = nullptr;
		if ( !fn ) fn = ( util::find( "server.dll", "B8 ? ? ? ? E8 ? ? ? ? A1 ? ? ? ? 56 57 8B F9 B9" ) - 0x6 );

		__asm
		{
			pushad
			pushfd

			mov ecx, this
			push pIKContext
			push flTime
			push flWeight
			push flCycle
			push iSequence
			push q
			push pos
			call fn

			popfd
			popad
		}
	}

	void CalcAutoplaySequences( vec3_t pos[ ], quaternion_t q[ ], float flRealTime, CIKContext* pIKContext ) const {
		static void* fn = nullptr;
		if ( !fn ) fn = ( util::find( "server.dll", "55 8B EC 83 EC 10 53 56 57 8B 7D 10" ) );
		auto* globals = g.m_interfaces->globals( ).operator void* ( );
		__asm
		{
			mov     eax, globals
			mov     ecx, this
			push    0
			push    q
			push    pos
			movss   xmm3, flRealTime
			call    fn
		}
	}

	void CalcBoneAdj( vec3_t pos[ ], quaternion_t q[ ], const float* encodedControllerArray ) const {
		static void* fn = nullptr;
		if ( !fn ) fn = ( util::find( "server.dll", "55 8B EC 83 E4 F8 81 EC ? ? ? ? 8B C1 89" ) );

		const auto* studioHdr = m_pStudioHdr;
		auto boneMask = m_boneMask;

		__asm
		{
			pushad
			pushfd

			mov ecx, studioHdr
			mov edx, pos
			push boneMask
			push encodedControllerArray
			push q
			call fn
			add esp, 0ch

			popfd
			popad
		}

	}

	const CStudioHdr* m_pStudioHdr;
	int m_boneMask;
	const float* m_flPoseParameters;
	PoseDebugger* m_pPoseDebugger;
};



class BoneSetup {
public:
	BoneSetup( const CStudioHdr *pStudioHdr, int boneMask, const float *poseParameter ) {
		m_pBoneSetup = ( _BoneSetup* )malloc( sizeof( _BoneSetup ) );
		m_pBoneSetup->init( pStudioHdr, boneMask, poseParameter );
	}
	~BoneSetup( ) {
		free( m_pBoneSetup );
	}
	void InitPose( vec3_t *pos, quaternion_t *q ) const {
		m_pBoneSetup->InitPose( pos, q );
	}
	void AccumulatePose( vec3_t pos[ ], quaternion_t q[ ], int sequence, float cycle, float flWeight, float flTime, CIKContext *pIKContext ) const {
		m_pBoneSetup->AccumulatePose( pos, q, sequence, cycle, flWeight, flTime, pIKContext );
	}
	void CalcAutoplaySequences( vec3_t pos[ ], quaternion_t q[ ], float flRealTime, CIKContext *pIKContext ) const {
		m_pBoneSetup->CalcAutoplaySequences( pos, q, flRealTime, pIKContext );
	}
	void CalcBoneAdj( vec3_t pos[ ], quaternion_t q[ ], const float *encodedControllerArray ) const {
		m_pBoneSetup->CalcBoneAdj( pos, q, encodedControllerArray );
	}
private:
	_BoneSetup *m_pBoneSetup;
};

void GetSkeleton( player_t *player, CStudioHdr *studioHdr, vec3_t *pos, quaternion_t *q, int boneMask, float sim_time, CIKContext *ik, ang_t angles, vec3_t origin, float *poses, animation_layer_t*layers ) {
    const BoneSetup boneSetup(studioHdr, boneMask, poses);
	boneSetup.InitPose( pos, q );
	boneSetup.AccumulatePose( pos, q, player->sequence( ), player->cycle( ), 1.f, sim_time, ik );

	constexpr const auto MAX_LAYER_COUNT = 15;
	int layer[ MAX_LAYER_COUNT ]{};
	for ( auto i = 0; i < 15; i++ ) {
		layer[ i ] = MAX_LAYER_COUNT;
	}

	for ( auto i = 0; i < 15; i++ ) {
        auto* pLayer = &layers[i];
		pLayer->m_owner = player;
		if ( ( pLayer->m_weight > 0.f ) && pLayer->m_sequence != -1 && pLayer->m_order >= 0 && pLayer->m_order < 15 ) {
			layer[ pLayer->m_order ] = i;
		}
	}
	weapon_world_model_t *weapon_world_model = nullptr;
	CBoneMergeCache *bone_merge_cache = nullptr;
	CBoneMergeCache *bone_merge_backup = nullptr;

	auto do_weapon_setup = false;

	auto *weapon = static_cast< weapon_t * >(g.m_interfaces->entity_list( )->get_client_entity_handle(
		                                           player->active_weapon( ) ));
	if ( weapon ) {
		weapon_world_model = static_cast< weapon_world_model_t * >(g.m_interfaces->entity_list( )->get_client_entity_handle(
			weapon->weapon_model( ) ));
		// Currently just return true in HoldsPlayerAnimations, something fucked on knives and I can't be bothered
		if ( weapon_world_model && weapon_world_model->GetModelPtr( ) ) {
			//bone_merge_backup = weapon_world_model->m_pBoneMergeCache( );
			//
			//bone_merge_cache = ( CBoneMergeCache::init( weapon_world_model ));
			//weapon_world_model->m_pBoneMergeCache( ) = bone_merge_cache;
	
			if ( weapon_world_model->m_pBoneMergeCache( ) )
				do_weapon_setup = true;
		}
	}

	if ( do_weapon_setup ) {

		const auto weapon_studio_hdr = weapon_world_model->GetModelPtr( );
		if ( weapon_studio_hdr ) {

			weapon_world_model->m_pBoneMergeCache( )->MergeMatchingPoseParams( );

			CIKContext weaponIK;
            weaponIK.Init(weapon_studio_hdr, angles, origin, sim_time, 0, BONE_USED_BY_BONE_MERGE);

			const BoneSetup weaponSetup( weapon_studio_hdr, BONE_USED_BY_BONE_MERGE, weapon_world_model->pose_parameters( ) );
			alignas( 16 ) vec3_t weaponPos[ 128 ];
			alignas( 16 ) quaternion_t weaponQ[ 128 ];

			weaponSetup.InitPose( weaponPos, weaponQ );

			for ( auto i = 0; i < 15; i++ ) {
                auto* pLayer = &layers[i];
				if ( pLayer->m_sequence <= 1 || pLayer->m_cycle <= 0.f ) {
					//if ( weapon_studio_hdr->m_pVModel )
					//	seq_count = ((CUtlVector< virtualsequence_t > *)(weapon_studio_hdr->m_pVModel + 20))->Count( );

					if ( pLayer->m_nDispatchedDst <= 0 || pLayer->m_nDispatchedDst >= studioHdr->GetNumSeq( ) ) {
						boneSetup.AccumulatePose( pos, q, pLayer->m_sequence, pLayer->m_cycle, pLayer->m_weight, sim_time, ik );
					} else {
						weapon_world_model->m_pBoneMergeCache( )->CopyFromFollow( pos, q, BONE_USED_BY_BONE_MERGE, weaponPos, weaponQ );

						if ( ik ) {
							auto &seqdesc = studioHdr->pSeqdesc( pLayer->m_sequence );
                            ik->AddDependencies(seqdesc, pLayer->m_sequence, pLayer->m_cycle, poses, pLayer->m_weight);
						}

						weaponSetup.AccumulatePose( weaponPos, weaponQ, pLayer->m_nDispatchedDst, pLayer->m_cycle, pLayer->m_weight, sim_time, &weaponIK );

						weapon_world_model->m_pBoneMergeCache( )->CopyToFollow( weaponPos, weaponQ, BONE_USED_BY_BONE_MERGE, pos, q );

						weaponIK.CopyTo( ik, *( int * )( weapon_world_model->m_pBoneMergeCache( ) + 160 ) );
					}
				}
				boneSetup.AccumulatePose( pos, q, pLayer->m_sequence, pLayer->m_cycle, pLayer->m_weight, sim_time, ik );
			}

		}
	}
	else {
		for ( auto i = 0; i < 15; i++ ) {
			if ( layer[ i ] >= 0 && layer[ i ] < 15 ) {
                const auto pLayer = layers[layer[i]];
				boneSetup.AccumulatePose( pos, q, pLayer.m_sequence, pLayer.m_cycle, pLayer.m_weight, sim_time, ik );
			}
		}
	}

	CIKContext auto_ik;
	auto_ik.Init( studioHdr, angles, origin, sim_time, 0, boneMask );
	boneSetup.CalcAutoplaySequences( pos, q, sim_time, &auto_ik );

	if ( studioHdr->m_pStudioHdr->bone_controllers_count > 0 ) {
		boneSetup.CalcBoneAdj( pos, q, player->encoder_controller( ) );
	}

	//if ( weapon_world_model && bone_merge_cache ) {
	//	weapon_world_model->m_pBoneMergeCache( ) = bone_merge_backup;
	//	g.m_interfaces->mem_alloc( )->free( bone_merge_cache );
	//}
}
void Studio_BuildMatrices( const studio_hdr_t *pStudioHdr, const ang_t &angles, const vec3_t &origin,
						   const vec3_t pos[ ], const quaternion_t q[ ], int iBone, float flScale,
						   matrix_t bonetoworld[ 128 ], int boneMask ) {
	int i;

	int chain[ 128 ] = {};
	auto chainlength = 0;

	if ( iBone < -1 || iBone >= pStudioHdr->bones_count )
		iBone = 0;

	// build list of what bones to use
	if ( iBone == -1 ) {
		// all bones
		chainlength = pStudioHdr->bones_count;
		for ( i = 0; i < pStudioHdr->bones_count; i++ ) {
			chain[ chainlength - i - 1 ] = i;
		}
	} else {
		// only the parent bones
		i = iBone;
		while ( i != -1 ) {
			chain[ chainlength++ ] = i;
			i = pStudioHdr->boneParent( i );
		}
	}

	matrix_t bonematrix;
	matrix_t rotationmatrix; // model to world transformation

	auto q2 = angles;
	q2.z = 0;
	math::angle_matrix( q2, origin, &rotationmatrix );

	// Account for a change in scale
	if ( flScale < 1.0f - FLT_EPSILON || flScale > 1.0f + FLT_EPSILON ) {
		vec3_t vecOffset;
		math::MatrixGetColumn( rotationmatrix, 3, vecOffset );
		vecOffset -= origin;
		vecOffset *= flScale;
		vecOffset += origin;
		math::MatrixSetColumn( vecOffset, 3, rotationmatrix );

		// Scale it uniformly
		math::VectorScale( rotationmatrix[ 0 ], flScale, rotationmatrix[ 0 ] );
		math::VectorScale( rotationmatrix[ 1 ], flScale, rotationmatrix[ 1 ] );
		math::VectorScale( rotationmatrix[ 2 ], flScale, rotationmatrix[ 2 ] );
	}

	for ( int j = chainlength - 1; j >= 0; j-- ) {
		i = chain[ j ];
		if ( pStudioHdr->boneFlags( i ) & boneMask ) {
			math::QuaternionMatrix( q[ i ], pos[ i ], &bonematrix );

			const auto boneParent = pStudioHdr->boneParent( i );

			if ( boneParent == -1 ) {
				math::ConcatTransforms( rotationmatrix, bonematrix, &bonetoworld[ i ] );
			} else {
				math::ConcatTransforms( bonetoworld[ boneParent ], bonematrix, &bonetoworld[ i ] );
			}
		}
	}
}

bool bones_t::BuildBonesStripped( player_t *target, int mask, bone_array_t *out, CIKContext *ipk ) {
	alignas( 16 ) vec3_t		     pos[ 128 ];
	alignas( 16 ) quaternion_t     q[ 128 ];
	// get hdr.
	const auto hdr = target->GetModelPtr( );
	if ( !hdr ) 
		return false;

	// get ptr to bone accessor.
	const auto accessor = &target->GetBoneAccessor( );
	if ( !accessor )
		return false;
	// store origial output matrix.
	// likely cachedbonedata.
	const auto backup_matrix = accessor->m_pBones;
	if ( !backup_matrix ) 
		return false;
	//force game to call AccumulateLayers - pvs fix.
   //auto ipk = target->m_Ipk();
   //if (ipk) {
   //	ipk->ClearTargets();
   //	ipk->New();
   //}
    const int backup_eflags = target->iEFlags();
	const auto backup = target->m_Ipk( );
	target->m_Ipk( ) = ipk;
    m_running = true;
    target->InvalidatePhysicsRecursive(entity_t::ANGLES_CHANGED);
    target->InvalidatePhysicsRecursive(entity_t::ANIMATION_CHANGED);
    target->InvalidatePhysicsRecursive(entity_t::SEQUENCE_CHANGED);
    target->iEFlags() &= ~(1 << 11);
    target->iEFlags() |= (1 << 3);

	// set bone array for write.
	accessor->m_pBones = out;

	auto* computed = static_cast< uint8_t* >( g.m_interfaces->mem_alloc( )->alloc( sizeof( uint8_t[ 0x100 ] ) ) );
	//auto* computed = static_cast< uint8_t* >( malloc( sizeof( uint8_t[ 0x100 ] ) ) );
	std::memset( computed, 0, 0x100 );

	//target->StandardBlendingRules(hdr, pos, q, record->m_sim_time, mask);
	if ( ipk ) {
		ipk->Init( hdr, target->abs_angles( ), target->abs_origin( ), g.m_interfaces->globals( )->m_curtime, g.m_interfaces->globals( )->m_tickcount, mask );
		target->UpdateIKLocks( g.m_interfaces->globals( )->m_curtime );
		GetSkeleton( target, hdr, pos, q, mask, g.m_interfaces->globals( )->m_curtime, ipk, target->abs_angles(), target->abs_origin(), target->pose_parameters(), target->anim_overlay() );
		ipk->UpdateTargets( pos, q, accessor->m_pBones, &computed[ 0 ] );
		target->CalculateIKLocks( g.m_interfaces->globals( )->m_curtime );
		ipk->SolveDependencies( pos, q, accessor->m_pBones, computed );

		// target->DoExtraBoneProcessing(hdr, pos, q, accessor->m_pBones, computed, ipk);

	}
	else 
		return false; 
	// compute and build bones.
	Studio_BuildMatrices( hdr->m_pStudioHdr, target->abs_angles( ), target->abs_origin( ), pos, q, -1, 1, accessor->m_pBones, mask );

	g.m_interfaces->mem_alloc( )->free( computed );
	accessor->m_pBones = backup_matrix;
    target->m_Ipk() = backup;
    target->iEFlags() = backup_eflags;
	return true;
}
bool bones_t::BuildBones( player_t *target, int mask, bone_array_t *out, std::shared_ptr<player_record_t> record, CIKContext *ipk ) {
	alignas(16) vec3_t		     pos[ 128 ];
	alignas(16) quaternion_t     q[ 128 ];

	// get hdr.

	const auto hdr = target->GetModelPtr( );
	if ( !hdr ) 
		return false;

	// get ptr to bone accessor.
	const auto accessor = &target->GetBoneAccessor( );
	if ( !accessor ) 
		return false;
	// store origial output matrix.
	// likely cachedbonedata.
	const auto backup_matrix = accessor->m_pBones;
	if ( !backup_matrix )
        return false;


	const auto curtime = g.m_interfaces->globals( )->m_curtime;
	const auto frametime = g.m_interfaces->globals( )->m_frametime;

	g.m_interfaces->globals( )->m_curtime = record->m_pred_time;
	g.m_interfaces->globals( )->m_frametime = g.m_interfaces->globals( )->m_interval_per_tick;

	// backup original.
	const auto mins = target->mins( ), maxs = target->maxs( );
    const int backup_eflags = target->iEFlags();

	// set non interpolated data.
    const auto old_effects = target->m_fEffects();
    target->iEFlags() &= ~0x1000;
    //target->iEFlags() &= ~(1 << 11);
    //target->iEFlags() |= (1 << 3);
    //target->InvalidatePhysicsRecursive(entity_t::ANGLES_CHANGED);
    //target->InvalidatePhysicsRecursive(entity_t::ANIMATION_CHANGED);
    //target->InvalidatePhysicsRecursive(entity_t::SEQUENCE_CHANGED);
	target->SetPoseParameters( record->m_poses );
	target->SetAnimLayers( record->m_layers );

	//target->setup_bones( record->m_render_bones, 128, bone_used_by_anything, record->m_pred_time );

	const auto backup = target->m_Ipk( );
	target->m_Ipk( ) = ipk;
	
	//force game to call AccumulateLayers - pvs fix.
   //auto ipk = target->m_Ipk();
   //if (ipk) {
   //	ipk->ClearTargets();
   //	ipk->New();
   //}

	auto* computed = static_cast< uint8_t* >( g.m_interfaces->mem_alloc( )->alloc( sizeof( uint8_t[ 0x100 ] ) ) );
	std::memset( computed, 0, 0x100 );
	{
		m_running = true;

		// set bone array for write.
		accessor->m_pBones = out;

		//target->StandardBlendingRules(hdr, pos, q, record->m_sim_time, mask);
		if ( ipk ) {
            ipk->Init(hdr, record->m_abs_angles, record->m_pred_origin, record->m_pred_time,
                      g.time_to_ticks(record->m_pred_time), mask);
			target->UpdateIKLocks( record->m_pred_time );
			GetSkeleton( target, hdr, pos, q, mask, record->m_pred_time, ipk, record->m_abs_angles, record->m_origin, record->m_poses, record->m_layers );
			ipk->UpdateTargets( pos, q, accessor->m_pBones, &computed[ 0 ] );
			target->CalculateIKLocks( record->m_pred_time );
			ipk->SolveDependencies( pos, q, accessor->m_pBones, computed );

			// target->DoExtraBoneProcessing(hdr, pos, q, accessor->m_pBones, computed, ipk);

		}
		// compute and build bones.
        Studio_BuildMatrices(hdr->m_pStudioHdr, record->m_abs_angles, record->m_origin, pos, q, -1, 1,
                             accessor->m_pBones, mask);

		accessor->m_pBones = backup_matrix;
	}
	target->m_Ipk( ) = backup;
	// restore original interpolated entity data.
	target->mins( ) = mins;
	target->maxs( ) = maxs;

	// revert to old game behavior.
	m_running = false;

	target->m_fEffects( ) = old_effects;
    target->iEFlags() = backup_eflags;
	g.m_interfaces->mem_alloc(  )->free( computed );
	g.m_interfaces->globals( )->m_curtime = curtime;
	g.m_interfaces->globals( )->m_frametime = frametime;
	return true;
}

```

`solace-csgo/bones.h`:

```h
#pragma once

#include "vec3.h"
class CStudioHdr;


struct player_record_t;
class bone_array_t;
class player_t;
class CIKContext;

class bones_t {
public:
	bool setup( player_t* player, bone_array_t* out, std::shared_ptr<player_record_t> record, CIKContext* ipk );
	bool BuildBonesStripped( player_t *target, int mask, bone_array_t *out, CIKContext *ipk );
	bool BuildBones( player_t* target, int mask, bone_array_t* out, std::shared_ptr<player_record_t> record, CIKContext* ipk );
	bool m_running = false;
} inline g_bones;


```

`solace-csgo/buy_bot.cpp`:

```cpp
#include "buy_bot.h"

```

`solace-csgo/buy_bot.h`:

```h
#pragma once
// todo: build this out
class buy_bot {
	
};


```

`solace-csgo/chams.cpp`:

```cpp
#include "chams.h"

#include "aimbot.h"
#include "includes.h"
#include "resolver.h"

void chams_t::create_materials( ) {
	full = g.m_interfaces->material_system()->find_material( "debug/debugambientcube", "Model textures" );
	full->increment_reference_count( );

	flat = g.m_interfaces->material_system( )->find_material( "debug/debugdrawflat", "Model textures" );
	flat->increment_reference_count( );
}

void chams_t::reset() {
	g.m_interfaces->model_render( )->override_material( nullptr );
	g.m_interfaces->render_view( )->modulate_color( color( 255, 255, 255 ) );
	g.m_interfaces->render_view( )->set_blend( 1.f );
}

bool chams_t::IsInViewPlane( const vec3_t &world ) {
	const auto &matrix = g.m_interfaces->engine(  )->world_to_screen(  );

	const auto w = matrix[3][0] * world.x + matrix[3][1] * world.y + matrix[3][2] * world.z + matrix[3][3];

	return w > 0.001f;
}

bool chams_t::SortPlayers( ) {
	// lambda-callback for std::sort.
	// to sort the players based on distance to the local-player.
	static auto distance_predicate = [ ]( player_t *a, player_t *b ) {
		auto local = g.m_local->abs_origin( );

		// note - dex; using squared length to save out on sqrt calls, we don't care about it anyway.
		auto len1 = ( a->abs_origin( ) - local ).length_sqr( );
		auto len2 = ( b->abs_origin( ) - local ).length_sqr( );

		return len1 < len2;
	};

	// reset player container.
	m_players.clear( );

	// find all players that should be rendered.
	for ( auto i{ 1 }; i <= g.m_interfaces->globals()->m_max_clients; ++i ) {
		// get player ptr by idx.
		auto player = static_cast< player_t * >(g.m_interfaces->entity_list( )->get_client_entity( i ));

		// validate.
		if ( !player || !player->is_player( ) || !player->alive( ) || player->dormant( ) || player == g.m_local )
			continue;

		// do not draw players occluded by view plane.
		if ( !IsInViewPlane( player->world_space_center( ) ) )
			continue;

		m_players.push_back( player );
	}

	// any players?
	if ( m_players.empty( ) )
		return false;

	// sorting fixes the weird weapon on back flickers.
	// and all the other problems regarding Z-layering in this shit game.
	std::sort( m_players.begin( ), m_players.end( ), distance_predicate );

	return true;
}
void chams_t::SceneEnd( ) {
	g.m_rendering = true;
	// store and sort ents by distance.
	if ( SortPlayers( ) ) {
		// iterate each player and render them.
		for ( const auto &p : m_players )
			p->draw_model( );
	}

	// restore.
	g.m_interfaces->model_render(  )->override_material( nullptr );
	g.m_interfaces->render_view( )->modulate_color( color(255,255,255,255));
	g.m_interfaces->render_view( )->set_blend( 1.f );
	g.m_rendering = false;
}

void chams_t::player( player_t *player, uintptr_t ctx, void *state, const model_render_info_t &info, matrix_t *bone ) {
	if ( !g.m_rendering && (player != g.m_local || player == nullptr) )
		return;
	static float flash_alpha = 0;

	static auto draw_model = reinterpret_cast< void( __thiscall * )( void *, uintptr_t, void *, const model_render_info_t &, matrix_t * ) >( g.m_interfaces->model_render( ).hook( )->get_original( 21 ) );
	if ( player == g.m_local ) {
		if ( g.m_bones_setup && g.m_running_client ) {
			const auto abs_origin = g.m_local->abs_origin( );
			for ( auto i = 0; i < 128; i++ ) {
				g.m_real_bones[i].mat_val[ 0 ][ 3 ] += abs_origin.x;
				g.m_real_bones[i].mat_val[ 1 ][ 3 ] += abs_origin.y;
				g.m_real_bones[i].mat_val[ 2 ][ 3 ] += abs_origin.z;
			}
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, g.m_real_bones );
			for ( auto i = 0; i < 128; i++ ) {
				g.m_real_bones[ i ].mat_val[ 0 ][ 3 ] -= abs_origin.x;
				g.m_real_bones[ i ].mat_val[ 1 ][ 3 ] -= abs_origin.y;
				g.m_real_bones[ i ].mat_val[ 2 ][ 3 ] -= abs_origin.z;
			}
		}
		else
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, bone );
		return;
	}
	
	auto ent_info = &g_player_manager.m_ents[ player->index( ) - 1 ];
	auto auto_draw = !ent_info->m_valid || ent_info->m_teamate || ent_info->m_records.empty( ) || !ent_info->m_records.front( ) || !ent_info->m_records.front( )->m_setup;
	if ( auto_draw ) {
		if ( ent_info->m_teamate ) {
			if ( settings::visuals::players::chams_team_covered != 0 ) {
				( (settings::visuals::players::chams_team_covered == 1) ? full : flat )->set_material_var_flag( material_var_ignorez, true );
				g.m_interfaces->model_render( )->override_material( settings::visuals::players::chams_team_covered == 1 ? full : flat );
				g.m_interfaces->render_view( )->modulate_color( color( 0x57, 0x03, 0x57 ) );
				g.m_interfaces->render_view( )->set_blend( 1.f );

				draw_model( g.m_interfaces->model_render( ), ctx, state, info, bone );
			}

			if ( settings::visuals::players::chams_team != 0 ) {
				( settings::visuals::players::chams_team == 1 ? full : flat )->set_material_var_flag( material_var_ignorez, false );
				g.m_interfaces->model_render( )->override_material( settings::visuals::players::chams_team == 1 ? full : flat );
				g.m_interfaces->render_view( )->modulate_color( color( 0xFF, 0x08, 0xFF ) );
				g.m_interfaces->render_view( )->set_blend( 1.f );

				draw_model( g.m_interfaces->model_render( ), ctx, state, info, bone );
			}

			reset( );

			if ( settings::visuals::players::chams_team == 0 ) {
				draw_model( g.m_interfaces->model_render( ), ctx, state, info, bone );
			}
		}
		else
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, bone );
		return;
	}

	if ( settings::visuals::players::chams_covered != 0 ) {
		( settings::visuals::players::chams_covered == 1 ? full : flat )->set_material_var_flag( material_var_ignorez, true );
		( settings::visuals::players::chams_covered == 1 ? full : flat )->set_material_var_flag( material_var_nocull, true );
		g.m_interfaces->model_render( )->override_material( settings::visuals::players::chams_covered == 1 ? full : flat );
		g.m_interfaces->render_view( )->modulate_color( color( 0x4F,0x9C,0x14 ) );
		g.m_interfaces->render_view( )->set_blend( 1.f );

		draw_model( g.m_interfaces->model_render( ), ctx, state, info, ent_info->m_records.front( )->m_bones );
		
		g.m_interfaces->render_view( )->set_blend( 0.5f );
		auto const record = g_aimbot.last_record( ent_info );
		if ( record )
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, record->m_bones );
	}

	if ( settings::visuals::players::chams != 0 ) {
		( settings::visuals::players::chams == 1 ? full : flat )->set_material_var_flag( material_var_ignorez, false );
		( settings::visuals::players::chams == 1 ? full : flat )->set_material_var_flag( material_var_nocull, false );
		g.m_interfaces->model_render( )->override_material( settings::visuals::players::chams == 1 ? full : flat );
		g.m_interfaces->render_view( )->modulate_color( color( 0x81, 0xFF, 0x21 ) );
		g.m_interfaces->render_view( )->set_blend( 1.f );
		const auto &front = ent_info->m_records.front( );
#ifdef _DEBUG
		if ( front )
			for( auto &i : front->m_fake_bones )
				draw_model( g.m_interfaces->model_render( ), ctx, state, info, i );
#endif
		
		if( front )
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, front->m_bones );
		

	}
	
	reset( );
	
	if ( settings::visuals::players::chams == 0 && ent_info->m_records.size() ) {
		if( ent_info->m_records.front( ) )
			draw_model( g.m_interfaces->model_render( ), ctx, state, info, ent_info->m_records.front( )->m_bones );
	}

}
```

`solace-csgo/chams.h`:

```h
#pragma once
#include <cstdint>

#include "block_bot.h"
struct model_render_info_t;
class player_t;
struct matrix_t;
class i_material;
class chams_t {
	i_material *flat = nullptr;
	i_material *full = nullptr;
	std::vector< player_t * > m_players;
public:
	bool override_model( int i );
	void create_materials( );
	static void reset ( );
	bool IsInViewPlane ( const vec3_t &world );
	bool SortPlayers ( );
	void SceneEnd ( );
	void player ( player_t *player, uintptr_t ctx, void *state, const model_render_info_t &info, matrix_t *bone );
} inline g_chams;


```

`solace-csgo/checksum_crc.cpp`:

```cpp
//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: Generic CRC functions
//
//=============================================================================//

#include "checksum_crc.h"
#define LittleLong( val )			( val )

// memdbgon must be the last include file in a .cpp file!!!

#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

#define NUM_BYTES 256
static const CRC32_t pulCRCTable[NUM_BYTES] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init( CRC32_t* pulCRC )
{
	*pulCRC = CRC32_INIT_VALUE;
}

void CRC32_Final( CRC32_t* pulCRC )
{
	*pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t CRC32_GetTableEntry( unsigned int slot )
{
	return pulCRCTable[ static_cast< unsigned char >(slot) ];
}

void CRC32_ProcessBuffer( CRC32_t* pulCRC, const void* pBuffer, int nBuffer )
{
	CRC32_t ulCrc = *pulCRC;
	auto * pb = ( unsigned char * )pBuffer;

JustAfew:

	switch( nBuffer )
	{
		case 7:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 6:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 5:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 4:
			ulCrc ^= LittleLong( *reinterpret_cast< CRC32_t * >(pb) );
			ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
			ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
			ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
			ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
			*pulCRC = ulCrc;
			return;

		case 3:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 2:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 1:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );

		case 0:
			*pulCRC = ulCrc;
			return;
	}

	// We may need to do some alignment work up front, and at the end, so that
	// the main loop is aligned and only has to worry about 8 byte at a time.
	//
	// The low-order two bits of pb and nBuffer in total control the
	// upfront work.
	//
	const unsigned int nFront = reinterpret_cast< unsigned int >(pb) & 3;
	nBuffer -= nFront;
	switch( nFront )
	{
		case 3:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		case 2:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		case 1:
			ulCrc = pulCRCTable[ *pb++ ^ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
	}

	int nMain = nBuffer >> 3;
	while( nMain-- )
	{
		ulCrc ^= LittleLong( *reinterpret_cast< CRC32_t * >(pb) );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc ^= LittleLong( *reinterpret_cast< CRC32_t * >(pb + 4) );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		ulCrc = pulCRCTable[ static_cast< unsigned char >(ulCrc) ] ^ ( ulCrc >> 8 );
		pb += 8;
	}

	nBuffer &= 7;
	goto JustAfew;
}

```

`solace-csgo/checksum_crc.h`:

```h
//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: Generic CRC functions
//
// $NoKeywords: $
//=============================================================================//
#pragma once

typedef unsigned long CRC32_t;

extern void CRC32_Init( CRC32_t* pulCRC );

extern void CRC32_ProcessBuffer( CRC32_t* pulCRC, const void* p, int len );

extern void CRC32_Final( CRC32_t* pulCRC );

CRC32_t CRC32_GetTableEntry( unsigned int slot );

inline CRC32_t CRC32_ProcessSingleBuffer( const void* p, int len )
{
	CRC32_t crc;

	CRC32_Init( &crc );
	CRC32_ProcessBuffer( &crc, p, len );
	CRC32_Final( &crc );

	return crc;
}

```

`solace-csgo/client_state.h`:

```h
#pragma once
#include "includes.h"
#include <cstdint>

#include "vec3.h"
class i_net_channel;
class c_client_class;
class event_info_t {
public:
	enum {
		EVENT_INDEX_BITS = 8,
		EVENT_DATA_LEN_BITS = 11,
		MAX_EVENT_DATA = 192,  // ( 1<<8 bits == 256, but only using 192 below )
	};

	// 0 implies not in use
	short					m_class_id;
	float					m_fire_delay;
	const void *m_send_table;
	const c_client_class *m_client_class;
	int						m_bits;
	uint8_t *m_data;
	int						m_flags;
	PAD( 0x18 );
	event_info_t *m_next;
};

struct CClockDriftMgr
{
private:
    uint8_t m_pad_00[72];

public:
    int32_t m_iCurClockOffset;
    int32_t m_nServerTick;
    int32_t m_nClientTick;
};

class client_state_t
{
public:
    int& m_nMaxClients()
    {
        return *(int*)((uintptr_t)this + 0x0310);
    }
    void* m_vmt_1;
    void* m_vmt_2;
    void* m_vmt_3;

private:
    uint8_t m_pad_00[144];

public:
    i_net_channel* m_NetChannel;

private:
    uint8_t m_pad_01[104];

public:
    int32_t m_nSignonState;

private:
    uint8_t m_pad_02[4];

public:
    double m_flNextCmdTime;
    int32_t m_nServerCount;
    int32_t m_nCurrentSequence;
    CClockDriftMgr m_ClockDriftMgr;
    int32_t m_nDeltaTick;

private:
    uint8_t m_pad_03[19252];

public:
    int32_t lastoutgoingcommand;
    int32_t chokedcommands;
    int32_t last_command_ack;
    int32_t last_server_tick;
    int32_t command_ack;
    PAD(0x12C);             // 0x4CB8
    event_info_t* m_events; // 0x4DEC
};
```

`solace-csgo/console.h`:

```h
#pragma once
#include <cstdint>

#include "app_system.h"

class convar;
using fn_change_callback_t = void( * )( convar *var, const char *old_value, float f_old_value );

template <typename T>
class utl_vector {
public:
	constexpr T &operator[]( int i ) { return memory[ i ]; };

	T *memory;
	int allocation_count;
	int grow_size;
	int size;
	T *elements;
};

enum cvar_flags {
	fcvar_none = 0,
	fcvar_unregistered = ( 1 << 0 ),
	fcvar_developmentonly = ( 1 << 1 ),
	fcvar_gamedll = ( 1 << 2 ),
	fcvar_clientdll = ( 1 << 3 ),
	fcvar_hidden = ( 1 << 4 ),
	fcvar_protected = ( 1 << 5 ),
	fcvar_sponly = ( 1 << 6 ),
	fcvar_archive = ( 1 << 7 ),
	fcvar_notify = ( 1 << 8 ),
	fcvar_userinfo = ( 1 << 9 ),
	fcvar_printableonly = ( 1 << 10 ),
	fcvar_unlogged = ( 1 << 11 ),
	fcvar_never_as_string = ( 1 << 12 ),
	fcvar_replicated = ( 1 << 13 ),
	fcvar_cheat = ( 1 << 14 ),
	fcvar_ss = ( 1 << 15 ),
	fcvar_demo = ( 1 << 16 ),
	fcvar_dontrecord = ( 1 << 17 ),
	fcvar_ss_added = ( 1 << 18 ),
	fcvar_release = ( 1 << 19 ),
	fcvar_reload_materials = ( 1 << 20 ),
	fcvar_reload_textures = ( 1 << 21 ),
	fcvar_not_connected = ( 1 << 22 ),
	fcvar_material_system_thread = ( 1 << 23 ),
	fcvar_archive_xbox = ( 1 << 24 ),
	fcvar_accessible_from_threads = ( 1 << 25 ),
	fcvar_server_can_execute = ( 1 << 28 ),
	fcvar_server_cannot_query = ( 1 << 29 ),
	fcvar_clientcmd_can_execute = ( 1 << 30 ),
	fcvar_unused = ( 1 << 31 ),
	fcvar_material_thread_mask = ( fcvar_reload_materials | fcvar_reload_textures | fcvar_material_system_thread )
};

class convar {
public:
	void set_value( const char *value ) {
		using original_fn = void( __thiscall * )( convar *, const char * );
		return ( *( original_fn ** )this )[ 14 ]( this, value );
	}
	void set_value( float value ) {
		using original_fn = void( __thiscall * )( convar *, float );
		return ( *( original_fn ** )this )[ 15 ]( this, value );
	}
	void set_value( int value ) {
		using original_fn = void( __thiscall * )( convar *, int );
		return ( *( original_fn ** )this )[ 16 ]( this, value );
	}
	void set_value( bool value ) {
		using original_fn = void( __thiscall * )( convar *, int );
		return ( *( original_fn ** )this )[ 16 ]( this, static_cast< int >( value ) );
	}

private:
	char pad_0x0000[ 0x4 ];

public:
	convar *next;
	__int32 is_registered;
	char *name;
	char *help_string;
	__int32 flags;

private:
	char pad_0x0018[ 0x4 ];

public:
	__forceinline float GetFloat( ) {
		using original_fn = float( __thiscall * )( convar * );
		return ( *( original_fn ** )this )[ 12 ]( this );
	}
	__forceinline float GetString( ) {
		using original_fn = float( __thiscall * )( convar * );
		return ( *( original_fn ** )this )[ 11 ]( this );
	}
	__forceinline float GetBool( ) {
		using original_fn = float( __thiscall * )( convar * );
		return ( *( original_fn ** )this )[ 13 ]( this );
	}
	__forceinline int GetInt( ) {
		using original_fn = int( __thiscall * )( convar * );
		return ( *( original_fn ** )this )[ 13 ]( this );
	}
	convar *parent;
	char *default_value;
	char *string;
	__int32 string_length;
	float float_value;
	__int32 numerical_value;
	__int32 has_min;
	float min;
	__int32 has_max;
	float max;
	utl_vector<fn_change_callback_t> callbacks;
};
class color;
class i_console;
class convar;
class con_command;
class con_command_base;

typedef int cvar_dll_indentifier_t;

class i_console_display_func {
public:
	virtual void color_print( const uint8_t *clr, const char *msg ) = 0;
	virtual void print( const char *msg ) = 0;
	virtual void drint( const char *msg ) = 0;
};

class i_console : public i_app_system {
public:
	virtual cvar_dll_indentifier_t	allocate_dll_indentifier( ) = 0;
	virtual void			register_con_command( con_command_base *base ) = 0;
	virtual void			unregister_con_command( con_command_base *base ) = 0;
	virtual void			unregister_con_commands( cvar_dll_indentifier_t id ) = 0;
	virtual const char *get_command_line_value( const char *name ) = 0;
	virtual con_command_base *find_command_base( const char *name ) = 0;
	virtual const con_command_base *find_command_base( const char *name ) const = 0;
	virtual convar *get_convar( const char *var_name ) = 0;
	virtual const convar *get_convar( const char *var_name ) const = 0;
	virtual con_command *find_command( const char *name ) = 0;
	virtual const con_command *find_command( const char *name ) const = 0;
	virtual void			install_global_change_callback( fn_change_callback_t callback ) = 0;
	virtual void			remove_global_change_callback( fn_change_callback_t callback ) = 0;
	virtual void			call_global_change_callbacks( convar *var, const char *old_str, float old_val ) = 0;
	virtual void			install_console_display_func( i_console_display_func *func ) = 0;
	virtual void			remove_console_display_func( i_console_display_func *func ) = 0;
	virtual void			console_color_printf( const uintptr_t &clr, const char *format, ... ) const = 0;
	virtual void			console_printf( const char *format, ... ) const = 0;
	virtual void			dconsole_dprintf( const char *format, ... ) const = 0;
	virtual void			rever_flagged_convars( int flag ) = 0;
};

```

`solace-csgo/controls/base_control.hh`:

```hh
#pragma once
#include "../includes.h"
#include "../menu.hh"

enum e_control_type {
	control_type_invalid = -1,
	control_type_toggle,
	control_type_slider,
	control_type_button,
	control_type_combobox,
	control_type_key_bind,
	control_type_tab
};

class c_base_control {
public:
	virtual ~c_base_control ( ) = default;
	virtual auto draw( ) -> void = 0;
	virtual auto update( ) -> void = 0;
	virtual auto disable( ) -> void {}
	virtual void save() = 0;
	virtual void load() = 0;

	const char* name{ "c_base_control" };
	area_t area{ 0, 0, 0, 0 }, original_area{ 0, 0, 0, 0 };
	e_control_type type{ control_type_invalid };

	auto adjust_area( const area_t area ) -> void {
		this->area = original_area;
		this->area = area;
	}

	auto adjust_position( const vector_2d pos ) {
		this->area.x += pos.x;
		this->area.y += pos.y;
	}
};
```

`solace-csgo/controls/button.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_button : public c_base_control {
	typedef void( *button_fn )( void );
	std::function<void( )> function_{ nullptr };
	bool holding_{ false };
public:
	c_button( const char* name, std::function<void( )> function ) {
		this->name = name;
		this->function_ = function;
		this->type = control_type_button;
	}

	auto disable( ) -> void override {
		this->holding_ = false;
	}

	auto draw( ) -> void override {
		menu.main_theme.set_a( 50 );
		g.m_render->gradient( this->area.x + 1, this->area.y + 1, this->area.w - 2, this->area.h - 2, this->holding_ ? menu.main_theme : color{ 0, 0, 0, 0 }, color{ 0, 0, 0, 0 } );
		menu.main_theme.set_a( 255 );
		g.m_render->outlined_rect( this->area.x, this->area.y, this->area.w, this->area.h, { 240,240,240, 7 } );

		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x + ( this->area.w / 2 ), this->area.y + this->area.h / 2, { 240, 240, 240 }, this->name, Horizontal | Vertical );
	}

	auto update( ) -> void override {
		if ( input_helper.hovering( this->area ) && input_helper.key_down( VK_LBUTTON ) ) {
			if ( !this->holding_ )
				this->holding_ = input_helper.key_pressed( VK_LBUTTON );
		} else this->holding_ = false;

		if ( input_helper.hovering( this->area ) && input_helper.key_pressed( VK_LBUTTON ) && this->function_ != nullptr ) {
			input_helper.set_key( VK_LBUTTON, false );
			this->function_( );
		}
	}

	void save( ) override {
	}
	void load( )  override {
	}
};

```

`solace-csgo/controls/column.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_column : public c_base_control {
	vector_2d drag_offset_{ 0, 0 };
	std::vector<std::shared_ptr<c_base_control>> children_{ };
public:

	explicit c_column( ) {
		type = control_type_tab;
	}

	auto draw( ) -> void  override {
		//g.m_render->gradient( this->area.x, this->area.y, this->area.w, this->area.h, { 0x00, 0x4e, 0x9a }, { 0x42, 0x9c, 0xd4 } );
		////g.m_render->filled_rect( this->area.x, this->area.y, this->area.w, this->area.h, { 60, 60, 60 } );
		//g.m_render->outlined_rect( this->area.x, this->area.y, this->area.w, this->area.h, { 240, 240, 240 } );
		//g.m_render->filled_rect( this->area.x, this->area.y, this->area.w, this->area.h, { 255, 255, 255 } );
		//// child handling.
		if ( !this->children_.empty( ) ) {
			// handle position.

			float column_width = roundf( ( this->area.w - 20 * static_cast< float >( children_.size( ) ) ) / children_.size( ) );
			const float group_height = floorf( ( ( area.h - 10 ) - 10 * static_cast< float >( children_.size( ) ) ) / children_.size( ) );
			
			
			vector_2d child_offset{ 0, 10 };
			for ( const auto &child : this->children_ ) {

				switch ( child->type ) {
				case control_type_invalid: /* invalid control, do nothing. */ break;
				default:
				{
					child->adjust_area( { this->area.x, this->area.y, this->area.w, group_height } );
					child->adjust_position( child_offset );
					child_offset.y += group_height + 10.f;
				} break;
				}
			}

			// draw.
			for ( const auto &child : this->children_ ) {
				child->draw( );
			}
		}
		//this->area.h = ( 16 * this->children_.size( ) );
	}

	auto update( ) -> void  override {
		// ugh... ghetto...
		const auto mouse_position = input_helper.m_mouse_position( );

		// child handling.
		if ( !this->children_.empty( ) ) {
			for ( const auto &child : this->children_ ) {
				child->update( );
			}
		}
	}
	auto disable( ) -> void  override {
		for ( const auto &child : this->children_ ) {
			child->disable( );
		}
	}
	auto finish( ) {
	}
	auto add_child( std::shared_ptr<c_base_control> control ) -> void {
		this->children_.push_back( control );
	}
	void save() override {
		for (auto i : children_) {
			i->save();
		}
	}
	void load() override {
		for (auto i : children_) {
			i->load();
		}
	}
};
```

`solace-csgo/controls/combobox.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_combobox : public c_base_control {
	int* value_;
	area_t item_area_{ 0, 0, 0, 0 };
	area_t button_area_{ 0,0,0,0 };
	bool open_{ false };
	std::vector<const char*> items_{ };
public:
	c_combobox( const char* name, int* value, std::vector<const char*> items, const int sub_tab = -1 ) {
		this->name = name;
		this->value_ = value;
		this->items_ = std::move( items );
		this->type = control_type_combobox;
	}

	auto disable() -> void override {
		this->open_ = false;
	}

	auto draw( ) -> void override {
		button_area_ = { this->area.x, this->area.y + this->area.h / 2.f, this->area.w, this->area.h / 2.f };
		auto text_size = g.m_render->get_text_width( this->items_[ *this->value_ ], g.m_render->m_constantia_12( ) );
		auto text_height = g.m_render->get_text_height( "A", g.m_render->m_constantia_12( ) );

		if ( !this->open_ )
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h, { 240,240,240, 7 } );
		else {
			this->item_area_ = { button_area_.x, button_area_.y + button_area_.h - 1, button_area_.w, button_area_.h * static_cast< int >( this->items_.size( ) ) };
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, menu.dark );
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 * 4 } );
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 } );
		}

		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x, this->area.y + button_area_.h / 2 - text_height / 2.f, menu.bright, this->name );
		g.m_render->text( g.m_render->m_constantia_12( ), this->button_area_.x + 5, (this->button_area_.y + (this->button_area_.h / 2)) - (text_height/ 2.f ), menu.main_theme, this->items_[ *this->value_ ] );

		// item drawing.
		if ( !this->open_ )
			return;
		

		for ( auto i{ 0 }; i < static_cast< int >( this->items_.size( ) ); i++ ) {
			const auto* item{ this->items_[ i ] };
			const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * button_area_.h ), this->item_area_.w, button_area_.h };
			const auto selected = i == *this->value_;

			text_size = g.m_render->get_text_width( item, g.m_render->m_constantia_12( ) );
			text_height = g.m_render->get_text_height( item, g.m_render->m_constantia_12( ) );
			g.m_render->text( g.m_render->m_constantia_12( ), item_area.x + 5, item_area.y + item_area.h / 2 - text_height / 2, selected ? menu.main_theme : menu.bright, item );
		}

		//g.m_render->outlined_rect( this->item_area_.x, this->item_area_.y, this->item_area_.w, this->item_area_.h, { 240,240,240 } );
	}

	auto update( ) -> void override {
		if ( menu.focused_control && menu.focused_control != this )
			return;

		if ( input_helper.hovering( this->area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
			this->open_ = !this->open_;
			if ( !this->open_ )
				menu.focused_control = nullptr;
			input_helper.set_key( VK_LBUTTON, false );
		}

		*this->value_ = std::clamp( *this->value_, 0, static_cast< int >( this->items_.size( ) ) );

		if ( this->open_ && !input_helper.hovering( this->button_area_ ) && !input_helper.hovering( this->item_area_ ) && input_helper.key_pressed_prestine( VK_LBUTTON ) ) {
			menu.focused_control = nullptr;
			this->open_ = false;
			input_helper.set_key( VK_LBUTTON, false );
			return;
		}

		if ( !this->open_ )
			return;

		menu.focused_control = this;

		for ( auto i{ 0 }; i < static_cast< int >( this->items_.size( ) ); i++ ) {
			const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * 17 ), this->item_area_.w, 17 };

			if ( input_helper.hovering( item_area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
				input_helper.set_key( VK_LBUTTON, false );
				*this->value_ = i;
				menu.focused_control = nullptr;
				this->open_ = false;
			}
		}
	}
	void save()  override {
		std::cout << *this->value_ << "\n";
	}
	void load() override {
		std::string line;
		std::getline(std::cin, line);
		std::istringstream(line) >> *this->value_;
	}
};
```

`solace-csgo/controls/groupbox.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>
class c_group_tab : public c_base_control
{
public:
    vector_2d drag_offset_{0, 0};
    c_base_control* selected_tab = nullptr;
    std::vector<std::shared_ptr<c_base_control>> children_{};

public:
    float offset = 0.f;
    float scroll_y = 0;
    explicit c_group_tab(const char* name_)
    {
        name = name_;
        type = control_type_tab;
    }
    auto draw() -> void override
    {
        // child handling.
        if (!this->children_.empty())
        {
            // handle position.
            vector_2d child_offset{0, 6};
            for (const auto& child : this->children_)
            {

                switch (child->type)
                {
                    case control_type_invalid: /* invalid control, do nothing. */
                        break;
                    case control_type_key_bind:
                    case control_type_slider:
                    case control_type_combobox:
                    {
                        child->adjust_area({this->area.x + 6, this->area.y + 2.f, this->area.w - 12, 32});
                        child->adjust_position(child_offset);
                        child_offset.y += 38;
                        break;
                    }
                    default:
                    {
                        child->adjust_area({this->area.x + 6, this->area.y + 2.f, this->area.w - 12, 16});
                        child->adjust_position(child_offset);
                        child_offset.y += 22;
                    }
                    break;
                }
            }
            offset = child_offset.y + 6;
            // draw.
            auto has_focus = false;
            for (const auto& child : this->children_)
            {
                if (child.get() == menu.focused_control)
                {
                    has_focus = true;
                    continue;
                }

                child->draw();
            }

            if (has_focus && menu.focused_control)
                menu.focused_control->draw();
        }
    }
    auto disable() -> void override
    {
        for (const auto& child : this->children_)
        {
            if (child.get() == menu.focused_control)
            {
                child->disable();
                menu.focused_control = nullptr;
                break;
            }
        }
    }
    auto finish()
    {
    }
    auto add_child(std::shared_ptr<c_base_control> control) -> void
    {
        this->children_.push_back(control);
    }

    auto update() -> void override
    {
        auto has_focus = false;
        for (const auto& child : this->children_)
        {
            if (child.get() == menu.focused_control)
            {
                has_focus = true;
                continue;
            }
        }

        if (has_focus && menu.focused_control)
            menu.focused_control->update();
        else
            for (const auto& child : this->children_)
            {
                child->update();
            }
    }
    void save() override
    {
        for (auto i : children_)
        {
            i->save();
        }
    }
    void load() override
    {
        for (auto i : children_)
        {
            i->load();
        }
    }
};
class c_group_box : public c_base_control
{
    vector_2d drag_offset_{0, 0};
    c_group_tab* selected_tab = nullptr;
    std::vector<std::shared_ptr<c_group_tab>> children_{};

public:
    float scroll_y = 0;

    explicit c_group_box(const char* name_)
    {
        name = name_;
        type = control_type_tab;
    }

    auto draw() -> void override
    {
        g.m_render->filled_rect(this->area.x, this->area.y, this->area.w, this->area.h, color{240, 240, 240, 7});
        auto text_height = g.m_render->get_text_height(this->name, g.m_render->m_constantia_12());
        g.m_render->text(g.m_render->m_constantia_12(), this->area.x + 5, this->area.y + 10 - (text_height / 2.f),
                         menu.main_theme, this->name);
        g.m_render->outlined_rect(this->area.x, this->area.y, this->area.w, this->area.h, {240, 240, 240, 7});
        g.m_render->filled_rect(this->area.x, this->area.y + 20, this->area.w, this->area.h - 20,
                                input_helper.hovering(this->area) ? color{240, 240, 240, 8} : color{240, 240, 240, 7});

        // child handling.
        if (!this->children_.empty())
        {
            // handle position.
            const vector_2d child_offset{0, scroll_y};
            for (const auto& child : this->children_)
            {
                child->adjust_area({this->area.x, this->area.y + 20, this->area.w, this->area.h - 20});
                child->adjust_position(child_offset);
            }

            if (children_.size() > 1)
            {
                auto text_x = this->area.x + this->area.w - 10.f;
                for (int i = children_.size() - 1; i >= 0; i--)
                {
                    auto* const child = children_[i].get();
                    const auto name_width = g.m_render->get_text_width(child->name, g.m_render->m_constantia_12());
                    text_height = g.m_render->get_text_height(this->name, g.m_render->m_constantia_12());
                    text_x -= name_width;
                    render_t::text(g.m_render->m_constantia_12(), text_x, this->area.y + 10 - (text_height / 2.f),
                                   child == selected_tab ? menu.main_theme : menu.bright, child->name);
                    text_x -= 7.f;
                }
            }

            // draw.
            auto has_focus = false;
            g.m_render->push_clip(this->area.x + 1, this->area.y + 20, this->area.w, this->area.h - 21);
            for (const auto& child : this->children_)
            {
                if (!selected_tab)
                    selected_tab = child.get();
                if (child.get() != selected_tab)
                {
                    continue;
                }

                child->draw();
            }

            g.m_render->pop_clip();
        }
        // this->area.h = ( 16 * this->children_.size( ) );
    }

    auto update() -> void override
    {
        // ugh... ghetto...
        for (const auto& child : this->children_)
        {
            if (child.get() == menu.focused_control)
            {
                child->disable();
                menu.focused_control = nullptr;
                break;
            }
        }
        if (input_helper.hovering({static_cast<float>(area.x), area.y, area.w, area.h}))
            scroll_y = fminf(0, roundf(scroll_y + input_helper.scroll()));
        if (this->children_.size() > 1)
        {
            int text_x = this->area.x + this->area.w - 6.f;
            for (int i = children_.size() - 1; i >= 0; i--)
            {
                const auto child = children_[i].get();
                const auto name_width = g.m_render->get_text_width(child->name, g.m_render->m_constantia_12());
                const auto name_height = g.m_render->get_text_height(child->name, g.m_render->m_constantia_12());
                text_x -= int(name_width + 7.f);
                if (input_helper.hovering({static_cast<float>(text_x), this->area.y + 1, static_cast<float>(name_width),
                                           static_cast<float>(name_height)}) &&
                    input_helper.key_pressed(VK_LBUTTON))
                {
                    input_helper.set_key(VK_LBUTTON, false);
                    selected_tab = child;
                    for (auto i : children_)
                        if (i.get() != selected_tab)
                            i->disable();
                    break;
                }
            }
        }
        if (this->selected_tab != nullptr)
        {
            // if ( input_helper.hovering( { this->area.x + 1, this->area.y + 20, this->area.w - 2, this->area.h - 21.f
            // } ) )
            float max_scroll = fmaxf(0,this->selected_tab->offset - (this->area.h - 20));
            if (-max_scroll > scroll_y)
                scroll_y = -max_scroll;
            this->selected_tab->update();
        }
    }
    auto disable() -> void override
    {
        for (const auto& child : this->children_)
        {
            child->disable();
        }
    }
    auto finish()
    {
    }
    auto add_child(std::shared_ptr<c_group_tab> control) -> void
    {
        this->children_.push_back(control);
    }
    void save() override
    {
        for (auto i : children_)
        {
            i->save();
        }
    }
    void load() override
    {
        for (auto i : children_)
        {
            i->load();
        }
    }
};
```

`solace-csgo/controls/key_bind.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_key_bind : public c_base_control {
	area_t item_area_{ 0, 0, 0, 0 };
	bool open_{ false }, capturing_{ false };
	key_bind_t value_;
	std::vector<const char*> key_bind_types_{ "Always", "Hold", "Toggle", "Off Key" };
	area_t button_area_{0,0,0,0};
public:
	c_key_bind( const char* name, bool *value, int default_type = 0 ) {
		this->name = name;
		this->value_ = key_bind_t(name, value, default_type );
		this->type = control_type_key_bind;
		menu.append_bind( &this->value_ );
	}

	virtual auto disable() -> void override {
		this->open_ = false;
	}

	virtual auto draw( ) -> void override {
		if ( this->capturing_ ) {
			for ( auto i = 0; i < 255; ++i ) {
				if ( GetAsyncKeyState( i ) && i != 3 ) {
					if ( i == VK_LBUTTON && input_helper.hovering( this->area ) )
						continue;

					if ( i == VK_ESCAPE ) {
						this->value_.key = 0;
						menu.focused_control = nullptr;
						this->capturing_ = false;
						break;
					} else if ( strcmp( "No bind", input_helper.m_key( i ) ) != 0 ) {
						this->value_.key = i;
						menu.focused_control = nullptr;
						this->capturing_ = false;
						break;
					}
				}
			}
		}
		
		button_area_ = { this->area.x, this->area.y + this->area.h / 2.f, this->area.w, this->area.h / 2.f };
		const auto text_size = g.m_render->get_text_width( input_helper.m_key( this->value_.key ), g.m_render->m_constantia_12( ) );
		const auto text_height = g.m_render->get_text_height( "A", g.m_render->m_constantia_12( ) );

		if ( !this->open_ ) {
			if ( this->capturing_ )
				g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h, { 240,240,240, 7 } );
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h, { 240,240,240, 7 } );
		}
		else {
			this->item_area_ = { button_area_.x, button_area_.y + button_area_.h - 1, button_area_.w, button_area_.h * static_cast< int >( this->key_bind_types_.size( ) ) };
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, menu.dark );
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 * 4 } );
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 } );
		}

		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x, this->area.y + button_area_.h / 2 - text_height / 2.f, menu.bright, this->name );
		g.m_render->text( g.m_render->m_constantia_12( ), this->button_area_.x + this->button_area_.w / 2 - ( text_size / 2.f ), ( this->button_area_.y + ( this->button_area_.h / 2 ) ) - ( text_height / 2.f ), menu.main_theme, input_helper.m_key( this->value_.key ) );

		if ( !this->open_ )
			return;

		
		for ( auto i{ 0 }; i < static_cast< int >( this->key_bind_types_.size( ) ); i++ ) {
			const auto* item{ this->key_bind_types_[ i ] };
			const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * button_area_.h ), this->item_area_.w, button_area_.h };
			const auto selected = i == this->value_.type;

			g.m_render->text( g.m_render->m_constantia_12( ), item_area.x + 6, item_area.y + item_area.h / 2.f - text_height / 2.f, selected ? menu.main_theme : menu.bright , item );
		}
	}

	virtual auto update( ) -> void override {
		if ( menu.focused_control && menu.focused_control != this )
			return;

		if ( !this->open_ && input_helper.hovering( button_area_ ) && input_helper.key_pressed( VK_LBUTTON ) ) {
			input_helper.set_key( VK_LBUTTON, false );
			this->capturing_ = true;
		}

		if ( !this->capturing_ && input_helper.hovering( button_area_ ) && input_helper.key_pressed( VK_RBUTTON ) )
			this->open_ = true;

		

		if ( this->open_ && !input_helper.hovering( this->item_area_ ) && ( input_helper.key_pressed( VK_LBUTTON ) ) ) {
			input_helper.set_key( VK_LBUTTON, false );
			menu.focused_control = nullptr;
			this->open_ = false;
			return;
		}

		if ( !this->capturing_ && !this->open_ )
			return;

		menu.focused_control = this;

		if ( this->open_ ) {
			for ( auto i{ 0 }; i < static_cast< int >( this->key_bind_types_.size( ) ); i++ ) {
				const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * 17 ), this->item_area_.w, 17 };

				if ( input_helper.hovering( item_area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
					input_helper.set_key( VK_LBUTTON, false );
					this->value_.type = i;
					menu.focused_control = nullptr;
					this->open_ = false;
				}
			}
		}
	}
	virtual void save() override {
		std::cout << this->value_.type << "\n";
		std::cout << this->value_.key << "\n";
	}
	virtual void load() override {
		std::string line;
		std::getline(std::cin, line);
		std::istringstream(line) >> this->value_.type;
		line = "";
		std::getline(std::cin, line);
		std::istringstream(line) >> this->value_.key;
	}
};
```

`solace-csgo/controls/multiselect.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_multiselect : public c_base_control {
	int *value_;
	area_t item_area_{ 0, 0, 0, 0 };
	bool open_{ false };
	std::vector<const char *> items_{ };
	area_t button_area_{0,0,0,0};
public:
	c_multiselect( const char *name, int *value, std::vector<const char *> items, const int sub_tab = -1 ) {
		this->name = name;
		this->value_ = value;
		this->items_ = std::move( items );
		this->type = control_type_combobox;
	}

	auto disable( ) -> void override {
		this->open_ = false;
	}


	auto draw( ) -> void override {
		button_area_ = { this->area.x, this->area.y + this->area.h / 2.f, this->area.w, this->area.h / 2.f };
		std::stringstream string;
		bool first = true;
		for ( auto i = 0; i < this->items_.size( ); i++ )
			if ( *value_ & ( 1 << i ) ) {
				if ( !first )
					string << ", ";
				first = false;
				string << this->items_[ i ];
			}

		auto str = string.str( );
		if ( str.length( ) > 20 )
			str.substr( 0, 17 ) + "...";

		auto text = _strdup( str.c_str( ) );

		auto text_size = g.m_render->get_text_width( text, g.m_render->m_constantia_12( ) );
		auto text_height = g.m_render->get_text_height( "A", g.m_render->m_constantia_12( ) );

		if ( !this->open_ )
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h, { 240,240,240, 7 } );
		else {
			this->item_area_ = { button_area_.x, button_area_.y + button_area_.h - 1, button_area_.w, button_area_.h * static_cast< int >( this->items_.size( ) ) };
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, menu.dark );
			g.m_render->filled_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 * 4 } );
			g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h + this->item_area_.h - 1, { 240,240,240, 7 } );
		}

		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x, this->area.y + button_area_.h / 2 - text_height / 2.f, menu.bright, this->name );
		g.m_render->text( g.m_render->m_constantia_12( ), this->button_area_.x + this->button_area_.w - (5 + text_size), ( this->button_area_.y + ( this->button_area_.h / 2 ) ) - ( text_height / 2.f ), menu.main_theme, text );

		// item drawing.
		if ( !this->open_ )
			return;

		for ( auto i{ 0 }; i < static_cast< int >( this->items_.size( ) ); i++ ) {
			const auto *item{ this->items_[ i ] };
			const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * 17 ), this->item_area_.w, 17 };
			const auto selected = *this->value_ & (1 << i);

			text_size = g.m_render->get_text_width( item, g.m_render->m_constantia_12( ) );
			text_height = g.m_render->get_text_height( item, g.m_render->m_constantia_12( ) );
			g.m_render->text( g.m_render->m_constantia_12( ), item_area.x + 5, item_area.y + item_area.h / 2 - text_height / 2, selected ? menu.main_theme : menu.bright, item );
		}

		//g.m_render->outlined_rect( this->item_area_.x, this->item_area_.y, this->item_area_.w, this->item_area_.h, { 240,240,240 } );
	}

	auto update( ) -> void override {
		if ( menu.focused_control && menu.focused_control != this )
			return;

		if ( input_helper.hovering( this->area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
			this->open_ = !this->open_;
			if( !this->open_ )
				menu.focused_control = nullptr;
			input_helper.set_key( VK_LBUTTON, false );
		}

		if ( this->open_ && !input_helper.hovering( this->button_area_ ) && !input_helper.hovering( this->item_area_ ) && input_helper.key_pressed_prestine( VK_LBUTTON ) ) {
			menu.focused_control = nullptr;
			this->open_ = false;
			input_helper.set_key( VK_LBUTTON, false );
			return;
		}

		if ( !this->open_ )
			return;

		menu.focused_control = this;

		for ( auto i{ 0 }; i < static_cast< int >( this->items_.size( ) ); i++ ) {
			const area_t item_area{ this->item_area_.x, this->item_area_.y + ( i * 17 ), this->item_area_.w, 17 };

			if ( input_helper.hovering( item_area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
				input_helper.set_key( VK_LBUTTON, false );
				if( *this->value_ & ( 1 << i ) )
					*this->value_ &= ~( 1 << i );
				else
					*this->value_ |= (1 << i);
				//menu.focused_control = nullptr;
				//this->open_ = false;
			}
		}
	}
	void save() override {
		std::cout << *this->value_ << "\n";
	}
	void load() override {
		std::string line;
		std::getline(std::cin, line);
		std::istringstream(line) >> *this->value_;
	}
};

```

`solace-csgo/controls/slider.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_slider : public c_base_control {
	float* value_;
	float minimum_{ 0.f }, maximum_{ 100.f };
	bool dragging_{ false };
	area_t button_area_{ 0,0,0,0 };
public:
	c_slider( const char* name, float* value, float minimum = 0.f, float maximum = 100.f ) {
		this->name = name;
		this->value_ = value;
		this->minimum_ = minimum;
		this->maximum_ = maximum;
		this->type = control_type_slider;
	}

	auto disable( ) -> void override {
		this->dragging_ = false;
	}
	
	auto draw( ) -> void override {
		button_area_ = { this->area.x, this->area.y + ( this->area.h / 2 ) + ( this->area.h / 2 ) / 4.f, this->area.w, ( ( this->area.h / 2 ) / 2.f ) };
		const auto slider_fill{ ( ( *this->value_ - this->minimum_ ) / ( this->maximum_ - this->minimum_ ) * ( button_area_.w-2.f ) ) };
		
		auto text_height = g.m_render->get_text_height( this->name, g.m_render->m_constantia_12( ) );

		g.m_render->filled_rect( button_area_.x + 1.f, button_area_.y + 1.f, slider_fill, button_area_.h - 2.f, menu.main_theme );
		g.m_render->outlined_rect( button_area_.x, button_area_.y, button_area_.w, button_area_.h, { 240,240,240, 14 } );

		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x, this->area.y + this->area.h/4 - text_height/2, menu.bright, this->name );

		// display.
		char display[ 32 ];
		sprintf_s( display, "%.1f / %.1f", *this->value_, this->maximum_ );
		const auto text_size = g.m_render->get_text_width( display, g.m_render->m_constantia_12( ) );

		g.m_render->text( g.m_render->m_constantia_12( ), button_area_.x + button_area_.w - ( text_size ), this->area.y + this->area.h/4 - text_height / 2, menu.main_theme, display );
	}

	auto update( ) -> void override {
		if ( menu.focused_control && menu.focused_control != this )
			return;

		if ( input_helper.hovering( this->button_area_ ) && input_helper.key_pressed( VK_LBUTTON ) ) {
			this->dragging_ = true;
		}

		if ( this->dragging_ && !GetAsyncKeyState( VK_LBUTTON ) ) {
			menu.focused_control = nullptr;
			this->dragging_ = false;
		}

		if ( !this->dragging_ )
			return;

		menu.focused_control = this;

		*this->value_ = this->minimum_ + ( this->maximum_ - this->minimum_ ) * ( input_helper.m_mouse_position( ).x - ( button_area_.x ) ) / ( button_area_.w );
		*this->value_ = std::clamp( *this->value_, this->minimum_, this->maximum_ );
	}

	void save() override {
		std::cout << *this->value_ << "\n";
	}
	void load() override {
		std::string line;
		std::getline(std::cin, line);
		std::istringstream(line) >> *this->value_;
	}
};
```

`solace-csgo/controls/tab.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_tab : public c_base_control {
	vector_2d drag_offset_{ 0, 0 };
	std::vector<std::shared_ptr<c_base_control>> children_{ };
public:

	explicit c_tab( const char *name_ ) {
		name = name_;
		type = control_type_tab;
	}

	auto draw( ) -> void  override {
		g.m_render->Rounded( this->area.x, this->area.y, this->area.w, this->area.h, 10, color( 240,240,240, 10) );
		//g.m_render->outlined_rect( this->area.x, this->area.y, this->area.w, this->area.h, { 240,240,240 } );
		// child handling.
		if ( !this->children_.empty( ) ) {
			// handle position.
			const auto column_width = floorf( ((this->area.w-10) - 10 * static_cast< float >(children_.size( ))) / children_.size( ) );
			vector_2d child_offset{ 10, 0 };
			for ( const auto &child : this->children_ ) {

				switch ( child->type ) {
				case control_type_invalid: /* invalid control, do nothing. */ break;
				default:
				{
					child->adjust_area( { this->area.x, this->area.y, column_width, this->area.h } );
					child->adjust_position( child_offset );
					child_offset.x += column_width + 10;
				} break;
				}
			}

			// draw.
			for ( const auto &child : this->children_ ) {
				child->draw( );
			}
		}
		//this->area.h = ( 16 * this->children_.size( ) );
	}

	auto update( ) -> void  override {
		// ugh... ghetto...
		const auto mouse_position = input_helper.m_mouse_position( );

		// child handling.
		if ( !this->children_.empty( ) ) {
			for ( const auto &child : this->children_ ) {
				child->update( );
			}
		}
	}
	auto disable( ) -> void  override {
		for ( const auto &child : this->children_ ) {
			child->disable( );
		}
	}
	auto finish () {
	}
	auto add_child( std::shared_ptr<c_base_control> control ) -> void {
		this->children_.push_back( control );
	}
	void save() override {
		for (auto i : children_) {
			i->save();
		}
	}
	void load()  override {
		for (auto i : children_) {
			i->load();
		}
	}
};
```

`solace-csgo/controls/toggle.hh`:

```hh
#pragma once
#include "base_control.hh"
#include "../input_helper/input_helper.hh"
#include <iostream>
#include <fstream>

class c_toggle : public c_base_control {
	bool* enabled_;
	area_t button_area{0,0,0,0};
public:
	c_toggle( const char* name, bool* enabled ) {
		this->name = name;
		this->enabled_ = enabled;
		this->type = control_type_toggle;
	}

	auto draw( ) -> void override {
		button_area = { this->area.x + this->area.w - (this->area.h), this->area.y, this->area.h, this->area.h };
		if ( *this->enabled_ )
			g.m_render->filled_rect( button_area.x + 1, button_area.y+1, button_area.h - 2, button_area.h-2, menu.main_theme );
		g.m_render->outlined_rect( button_area.x, button_area.y, button_area.h, button_area.h, { 240,240,240, 14 } );
		auto text_height = g.m_render->get_text_height( this->name, g.m_render->m_constantia_12( ) );
		g.m_render->text( g.m_render->m_constantia_12( ), this->area.x, this->area.y + (area.h / 2) - text_height/2, menu.bright, this->name );
	}

	auto update( ) -> void override {
		if ( input_helper.hovering( button_area ) && input_helper.key_pressed( VK_LBUTTON ) ) {
			input_helper.set_key( VK_LBUTTON, false );
			*this->enabled_ = !*this->enabled_;
		}
	}

	void save() override {
		std::cout << *enabled_ << "\n";
	}
	void load()  override {
		std::string line;
		std::getline(std::cin, line);
		std::istringstream(line) >> *enabled_;
	}
};
```

`solace-csgo/controls/window.cc`:

```cc
#include "window.hh"
#include "../input_helper/input_helper.hh"

auto c_form::draw ( ) -> void {

	//menu.dark_accent.set_a( 50 );
	//g.m_render->Rounded( this->area_.x - 1, this->area_.y - 1, this->area_.w + 2, this->area_.h + 2, 40, menu.dark_accent );
	//menu.dark_accent.set_a( 255 );

	g.m_render->Rounded( this->area_.x - 1, this->area_.y - 1, this->area_.w + 2, this->area_.h + 2, 10, menu.dark );

	auto text_height = g.m_render->get_text_height( this->name_, g.m_render->m_tahoma_14( ) );
	g.m_render->text( g.m_render->m_tahoma_14( ), this->area_.x + 10, this->area_.y + 10 - ( text_height / 2.f ), menu.main_theme, this->name_ );


	// child handling.
	if ( !this->children_.empty( ) ) {
		// handle position.
		vector_2d child_offset{0, 0};
		for ( const auto &child : this->children_ ) {

			switch ( child->type ) {
			case control_type_invalid : /* invalid control, do nothing. */ break;
			default : {	
				child->adjust_area( { this->area_.x, this->area_.y + 20.f, this->area_.w, this->area_.h - 20.f } );
			}
			break;
			}
		}

		auto text_x = this->area_.x + this->area_.w - 10;
		for ( int i = children_.size( ) - 1; i >= 0; i-- ) {
			auto *const child = children_[ i ].get(  );
			const auto name_width = g.m_render->get_text_width( child->name, g.m_render->m_constantia_12( ) );
			text_height = g.m_render->get_text_height( this->name_, g.m_render->m_constantia_12( ) );
			text_x -= name_width;
			g.m_render->text( g.m_render->m_constantia_12( ), text_x, this->area_.y + 10 - ( text_height / 2.f ), child == selected_tab ? menu.main_theme : menu.bright, child->name );
			text_x -= 7.f;
		}
		// draw.
		for ( auto child : this->children_ ) {
			if ( child.get( ) != selected_tab )
				continue;

			child->draw( );
		}
	}
	//this->area_.h = 15;
	//if ( this->selected_tab != nullptr )
	//	this->area_.h += this->selected_tab->area_.h;
}

auto c_form::update ( ) -> void {
	// ugh... ghetto...
	const auto mouse_position = input_helper.m_mouse_position( );

	if ( input_helper.key_pressed( VK_LBUTTON ) && input_helper.hovering( this->area_ ) )
		menu.focused_form = this;

	if ( input_helper.hovering( {this->area_.x, this->area_.y, this->area_.w, 15} ) && input_helper.
		key_pressed( VK_LBUTTON ) )
		this->clicked_ = true;

	if ( !GetAsyncKeyState( VK_LBUTTON ) )
		this->clicked_ = false;

	if ( this->should_drag_ && !this->clicked_ )
		this->should_drag_ = false;

	if ( this->should_drag_ && this->clicked_ ) {
		this->area_.x = mouse_position.x - this->drag_offset_.x;
        this->area_.y = mouse_position.y - this->drag_offset_.y;
        this->area_.x = std::clamp<float>(this->area_.x, 0, g.m_render->m_screen_size().Width - this->area_.w); 
        this->area_.y = std::clamp<float>(this->area_.y, 0, g.m_render->m_screen_size().Height - this->area_.h); 
	}

	if ( input_helper.hovering( {this->area_.x, this->area_.y, this->area_.w, 15} ) ) {
		this->should_drag_ = true;
		this->drag_offset_.x = mouse_position.x - this->area_.x;
		this->drag_offset_.y = mouse_position.y - this->area_.y;
	}

	if ( !this->children_.empty( ) ) {
		int text_x = this->area_.x + this->area_.w - 6.f;
		for ( int i = children_.size( ) - 1; i >= 0; i-- ) {
			const auto child = children_[ i ].get( );
			const auto name_width = g.m_render->get_text_width( child->name, g.m_render->m_constantia_12( ) );
			const auto name_height = g.m_render->get_text_height( child->name, g.m_render->m_constantia_12( ) );
			text_x -= int(name_width + 7.f);
			if ( input_helper.hovering( { static_cast<float>(text_x), this->area_.y + 1, static_cast< float >( name_width ), static_cast<float>(name_height) } ) && input_helper.key_pressed( VK_LBUTTON ) ) {
				input_helper.set_key( VK_LBUTTON, false );
				selected_tab = child;
				for ( auto i : children_ )
					if( i.get() != selected_tab )
						i->disable( );
				break;
			}
		}
		// child handling.
		if ( this->selected_tab != nullptr ) {
			this->selected_tab->update( );
		}
	}
}

```

`solace-csgo/controls/window.hh`:

```hh
#pragma once
#include <memory>
#include <vector>

#include <iostream>
#include <fstream>

#include "base_control.hh"

class c_form : public c_base_control {
	const char* name_{ "Test" };
	bool should_drag_{ false }, clicked_{ false }, enabled_{ true };
	vector_2d drag_offset_{ 0, 0 };
	area_t area_{ 50, 50, 640, 480 };
	std::vector<std::shared_ptr<c_base_control>> children_{ };
	c_base_control *selected_tab = nullptr;
public:
	c_form( ) {
	}
	
	c_form( const char* name, const area_t area ) {
		this->name_ = name;
		this->area_ = area;
	}

	auto draw ( ) -> void override;

	auto update ( ) -> void override;

	auto m_enabled( ) const -> const bool {
		return this->enabled_;
	}

	auto set_enabled( bool enabled ) -> void {
		this->enabled_ = enabled;
	}

	auto add_child( std::shared_ptr<c_base_control> control ) -> void {
		if ( !selected_tab )
			selected_tab = control.get( );
		this->children_.push_back( control );
	}

	static auto finish( ) -> void {
	}
	void save() override {
		for (auto i : children_) {
			i->save();
		}
	}
	void load() override {
		for (auto i : children_) {
			i->load();
		}
	}
};

```

`solace-csgo/cpp.hint`:

```hint
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define OFFSET(type, var, offset) type& var() { return *( type* )( uintptr_t( this ) + offset ); }
#define NETVAR(table, prop, name) uintptr_t name = netvar_manager::get_net_var( fnv::hash( table ), fnv::hash( prop ) );

```

`solace-csgo/debug_overlay.h`:

```h
#pragma once
#include "includes.h"
#include "vec3.h"

class debug_overlay_t {
public:
	using world_to_screen_t = int( __thiscall * )( debug_overlay_t *, const vec3_t &, vec3_t & );
	bool world_to_screen( const vec3_t &in, vec3_t &out ) {
		auto return_value = ( *( world_to_screen_t ** )this )[ 13 ]( this, in, out );
		return static_cast< bool >( return_value != 1 );
	}

	using screen_position_t = bool( __thiscall * )( debug_overlay_t *, const vec3_t &, vec3_t & );
	bool screen_position( const vec3_t &in, vec3_t &out ) {
		return ( *( screen_position_t ** )this )[ 11 ]( this, std::ref( in ), std::ref( out ) );
	}

	using AddLineOverlay_t = void( __thiscall * )( debug_overlay_t *, const vec3_t &origin, const vec3_t &dest, int r, int g, int b, bool noDepthTest, float duration );
	void AddLineOverlay( const vec3_t &origin, const vec3_t &dest, int r, int g, int b, bool noDepthTest, float duration ) {
		return util::get_virtual_function< AddLineOverlay_t >( this, 5 )( this, origin, dest, r, g, b, noDepthTest, duration );
	}
	using AddBoxOverlay_t = void( __thiscall * )( void *, vec3_t const &start, vec3_t const &min, vec3_t const &max, ang_t const &angle, int r, int g, int b, int a, float duration );
	void AddBoxOverlay( vec3_t const &start, vec3_t const &min, vec3_t const &max, ang_t const &angle, int r, int g, int b, int a, float duration ) {
		return ( *( AddBoxOverlay_t ** )this )[ 1 ]( this, start, min, max, angle, r, g, b, a, duration );
	}
	using original_fn = void( __thiscall * )( void *, vec3_t const &start, vec3_t const &end, vec3_t const &min, vec3_t const &max, ang_t const &angle, int r, int g, int b, int a, float duration );
	void AddSweptBoxOverlay( vec3_t const &start, vec3_t const &end, vec3_t const &min, vec3_t const &max, ang_t const &angle, int r, int g, int b, int a, float duration ) {
		return ( *( original_fn ** )this )[ 9 ]( this, start, end, min, max, angle, r, g, b, a, duration );
	}
	using AddCapsuleOverlay_t = void( __thiscall * )( void *, vec3_t const &, vec3_t const &, float const &, int, int, int, int, float );
	void AddCapsuleOverlay( vec3_t const &start, vec3_t const &end, float const &radius, int r, int g, int b, int a, float duration ) {
		return ( *( AddCapsuleOverlay_t ** )this )[ 24 ]( this, start, end, radius, r, g, b, a, duration );
	}
};

class panel_t {
public:
	enum indices : size_t {
		GETNAME = 36,
		PAINTTRAVERSE = 41,
	};

public:
	__forceinline const char *GetName( long vgui_panel ) {
		return util::get_virtual_function< const char *( __thiscall * )( decltype( this ), uint32_t ) >( this, GETNAME )( this, vgui_panel );
	}
};
```

`solace-csgo/delaunator.h`:

```h
#pragma once
#pragma once

#include <algorithm>
#include <cmath>
#include <exception>
#include <iostream>
#include <limits>
#include <memory>
#include <utility>
#include <vector>

#undef min
#undef max

namespace delaunator {

    //@see https://stackoverflow.com/questions/33333363/built-in-mod-vs-custom-mod-function-improve-the-performance-of-modulus-op/33333636#33333636
    inline size_t fast_mod( const size_t i, const size_t c ) {
        return i >= c ? i % c : i;
    }

    // Kahan and Babuska summation, Neumaier variant; accumulates less FP error
    inline double sum( const std::vector<double>& x ) {
        auto sum = x[ 0 ];
        auto err = 0.0;

        for ( size_t i = 1; i < x.size( ); i++ ) {
            const auto k = x[ i ];
            const auto m = sum + k;
            err += std::fabs( sum ) >= std::fabs( k ) ? sum - m + k : k - m + sum;
            sum = m;
        }
        return sum + err;
    }

    inline double dist(
        const double ax,
        const double ay,
        const double bx,
        const double by ) {
        const auto dx = ax - bx;
        const auto dy = ay - by;
        return dx * dx + dy * dy;
    }

    inline double circumradius(
        const double ax,
        const double ay,
        const double bx,
        const double by,
        const double cx,
        const double cy ) {
        const auto dx = bx - ax;
        const auto dy = by - ay;
        const auto ex = cx - ax;
        const auto ey = cy - ay;

        const auto bl = dx * dx + dy * dy;
        const auto cl = ex * ex + ey * ey;
        const auto d = dx * ey - dy * ex;

        const auto x = ( ey * bl - dy * cl ) * 0.5 / d;
        const auto y = ( dx * cl - ex * bl ) * 0.5 / d;

        if ( ( bl > 0.0 || bl < 0.0 ) && ( cl > 0.0 || cl < 0.0 ) && ( d > 0.0 || d < 0.0 ) ) {
            return x * x + y * y;
        }
        else {
            return std::numeric_limits<double>::max( );
        }
    }

    inline bool orient(
        const double px,
        const double py,
        const double qx,
        const double qy,
        const double rx,
        const double ry ) {
        return ( qy - py ) * ( rx - qx ) - ( qx - px ) * ( ry - qy ) < 0.0;
    }

    inline std::pair<double, double> circumcenter(
        const double ax,
        const double ay,
        const double bx,
        const double by,
        const double cx,
        const double cy ) {
        const auto dx = bx - ax;
        const auto dy = by - ay;
        const auto ex = cx - ax;
        const auto ey = cy - ay;

        const auto bl = dx * dx + dy * dy;
        const auto cl = ex * ex + ey * ey;
        const auto d = dx * ey - dy * ex;

        const auto x = ax + ( ey * bl - dy * cl ) * 0.5 / d;
        const auto y = ay + ( dx * cl - ex * bl ) * 0.5 / d;

        return std::make_pair( x, y );
    }

    struct compare {

        std::vector<double> const& coords;
        double cx;
        double cy;

        bool operator()( std::size_t i, std::size_t j ) const {
            const auto d1 = dist( coords[ 3 * i ], coords[ 3 * i + 1 ], cx, cy );
            const auto d2 = dist( coords[ 3 * j ], coords[ 3 * j + 1 ], cx, cy );
            const auto diff1 = d1 - d2;
            const auto diff2 = coords[ 3 * i ] - coords[ 3 * j ];
            const auto diff3 = coords[ 3 * i + 1 ] - coords[ 3 * j + 1 ];

            if ( diff1 > 0.0 || diff1 < 0.0 ) {
                return diff1 < 0;
            }
            else if ( diff2 > 0.0 || diff2 < 0.0 ) {
                return diff2 < 0;
            }
            else {
                return diff3 < 0;
            }
        }
    };

    inline bool in_circle(
        const double ax,
        const double ay,
        const double bx,
        const double by,
        const double cx,
        const double cy,
        const double px,
        const double py ) {
        const auto dx = ax - px;
        const auto dy = ay - py;
        const auto ex = bx - px;
        const auto ey = by - py;
        const auto fx = cx - px;
        const auto fy = cy - py;

        const auto ap = dx * dx + dy * dy;
        const auto bp = ex * ex + ey * ey;
        const auto cp = fx * fx + fy * fy;

        return ( dx * ( ey * cp - bp * fy ) -
            dy * ( ex * cp - bp * fx ) +
            ap * ( ex * fy - ey * fx ) ) < 0.0;
    }

    constexpr double EPSILON = std::numeric_limits<double>::epsilon( );
    constexpr std::size_t INVALID_INDEX = std::numeric_limits<std::size_t>::max( );

    inline bool check_pts_equal( double x1, double y1, double x2, double y2 ) {
        return std::fabs( x1 - x2 ) <= EPSILON &&
            std::fabs( y1 - y2 ) <= EPSILON;
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    inline double pseudo_angle( const double dx, const double dy ) {
        const auto p = dx / ( std::abs( dx ) + std::abs( dy ) );
        return ( dy > 0.0 ? 3.0 - p : 1.0 + p ) / 4.0; // [0..1)
    }

    struct DelaunatorPoint {
        std::size_t i;
        double x;
        double y;
        std::size_t t;
        std::size_t prev;
        std::size_t next;
        bool removed;
    };

    class Delaunator {

    public:
        std::vector<double> const& coords;
        std::vector<std::size_t> triangles;
        std::vector<std::size_t> halfedges;
        std::vector<std::size_t> hull_prev;
        std::vector<std::size_t> hull_next;
        std::vector<std::size_t> hull_tri;
        std::size_t hull_start;

        Delaunator( std::vector<double> const& in_coords );

        double get_hull_area( );

    private:
        std::vector<std::size_t> m_hash;
        double m_center_x;
        double m_center_y;
        std::size_t m_hash_size;
        std::vector<std::size_t> m_edge_stack;

        std::size_t legalize( std::size_t a );
        std::size_t hash_key( double x, double y ) const;
        std::size_t add_triangle(
            std::size_t i0,
            std::size_t i1,
            std::size_t i2,
            std::size_t a,
            std::size_t b,
            std::size_t c );
        void link( std::size_t a, std::size_t b );
    };

    Delaunator::Delaunator( std::vector<double> const& in_coords )
        : coords( in_coords ),
        triangles( ),
        halfedges( ),
        hull_prev( ),
        hull_next( ),
        hull_tri( ),
        hull_start( ),
        m_hash( ),
        m_center_x( ),
        m_center_y( ),
        m_hash_size( ),
        m_edge_stack( ) {
        auto n = ( ( coords.size( ) / 3 ) * 2 ) >> 1;

        auto max_x = std::numeric_limits<double>::min( );
        auto max_y = std::numeric_limits<double>::min( );
        auto min_x = std::numeric_limits<double>::max( );
        auto min_y = std::numeric_limits<double>::max( );
        std::vector<std::size_t> ids;
        ids.reserve( n );

        for ( std::size_t i = 0; i < n; i++ ) {
            const auto x = coords[ 3 * i ];
            const auto y = coords[ 3 * i + 1 ];

            if ( x < min_x ) min_x = x;
            if ( y < min_y ) min_y = y;
            if ( x > max_x ) max_x = x;
            if ( y > max_y ) max_y = y;

            ids.push_back( i );
        }
        const auto cx = ( min_x + max_x ) / 2;
        const auto cy = ( min_y + max_y ) / 2;
        auto min_dist = std::numeric_limits<double>::max( );

        auto i0 = INVALID_INDEX;
        auto i1 = INVALID_INDEX;
        auto i2 = INVALID_INDEX;

        // pick a seed point close to the centroid
        for ( std::size_t i = 0; i < n; i++ ) {
            const auto d = dist( cx, cy, coords[ 3 * i ], coords[ 3 * i + 1 ] );
            if ( d < min_dist ) {
                i0 = i;
                min_dist = d;
            }
        }

        const auto i0x = coords[ 3 * i0 ];
        const auto i0y = coords[ 3 * i0 + 1 ];

        min_dist = std::numeric_limits<double>::max( );

        // find the point closest to the seed
        for ( std::size_t i = 0; i < n; i++ ) {
            if ( i == i0 ) continue;
            const auto d = dist( i0x, i0y, coords[ 3 * i ], coords[ 3 * i + 1 ] );
            if ( d < min_dist && d > 0.0 ) {
                i1 = i;
                min_dist = d;
            }
        }

        auto i1x = coords[ 3 * i1 ];
        auto i1y = coords[ 3 * i1 + 1 ];

        auto min_radius = std::numeric_limits<double>::max( );

        // find the third point which forms the smallest circumcircle with the first two
        for ( std::size_t i = 0; i < n; i++ ) {
            if ( i == i0 || i == i1 ) continue;

            const auto r = circumradius(
                i0x, i0y, i1x, i1y, coords[ 3 * i ], coords[ 3 * i + 1 ] );

            if ( r < min_radius ) {
                i2 = i;
                min_radius = r;
            }
        }

        if ( !( min_radius < std::numeric_limits<double>::max( ) ) ) {
            throw std::runtime_error( "not triangulation" );
        }

        auto i2x = coords[ 3 * i2 ];
        auto i2y = coords[ 3 * i2 + 1 ];

        if ( orient( i0x, i0y, i1x, i1y, i2x, i2y ) ) {
            std::swap( i1, i2 );
            std::swap( i1x, i2x );
            std::swap( i1y, i2y );
        }

        std::tie( m_center_x, m_center_y ) = circumcenter( i0x, i0y, i1x, i1y, i2x, i2y );

        // sort the points by distance from the seed triangle circumcenter
        std::sort( ids.begin( ), ids.end( ), compare{ coords, m_center_x, m_center_y } );

        // initialize a hash table for storing edges of the advancing convex hull
        m_hash_size = static_cast< std::size_t >( std::llround( std::ceil( std::sqrt( n ) ) ) );
        m_hash.resize( m_hash_size );
        std::fill( m_hash.begin( ), m_hash.end( ), INVALID_INDEX );

        // initialize arrays for tracking the edges of the advancing convex hull
        hull_prev.resize( n );
        hull_next.resize( n );
        hull_tri.resize( n );

        hull_start = i0;

        size_t hull_size = 3;

        hull_next[ i0 ] = hull_prev[ i2 ] = i1;
        hull_next[ i1 ] = hull_prev[ i0 ] = i2;
        hull_next[ i2 ] = hull_prev[ i1 ] = i0;

        hull_tri[ i0 ] = 0;
        hull_tri[ i1 ] = 1;
        hull_tri[ i2 ] = 2;

        m_hash[ hash_key( i0x, i0y ) ] = i0;
        m_hash[ hash_key( i1x, i1y ) ] = i1;
        m_hash[ hash_key( i2x, i2y ) ] = i2;

        auto max_triangles = n < 3 ? 1 : 2 * n - 5;
        triangles.reserve( max_triangles * 3 );
        halfedges.reserve( max_triangles * 3 );
        add_triangle( i0, i1, i2, INVALID_INDEX, INVALID_INDEX, INVALID_INDEX );
        auto xp = std::numeric_limits<double>::quiet_NaN( );
        auto yp = std::numeric_limits<double>::quiet_NaN( );
        for ( std::size_t k = 0; k < n; k++ ) {
            const auto i = ids[ k ];
            const auto x = coords[ 3 * i ];
            const auto y = coords[ 3 * i + 1 ];

            // skip near-duplicate points
            if ( k > 0 && check_pts_equal( x, y, xp, yp ) ) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (
                check_pts_equal( x, y, i0x, i0y ) ||
                check_pts_equal( x, y, i1x, i1y ) ||
                check_pts_equal( x, y, i2x, i2y ) ) continue;

            // find a visible edge on the convex hull using edge hash
            std::size_t start = 0;

            auto key = hash_key( x, y );
            for ( size_t j = 0; j < m_hash_size; j++ ) {
                start = m_hash[ fast_mod( key + j, m_hash_size ) ];
                if ( start != INVALID_INDEX && start != hull_next[ start ] ) break;
            }

            start = hull_prev[ start ];
            auto e = start;
            size_t q;

            while ( q = hull_next[ e ], !orient( x, y, coords[ 3 * e ], coords[ 3 * e + 1 ], coords[ 3 * q ], coords[ 3 * q + 1 ] ) ) { //TODO: does it works in a same way as in JS
                e = q;
                if ( e == start ) {
                    e = INVALID_INDEX;
                    break;
                }
            }

            if ( e == INVALID_INDEX ) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            auto t = add_triangle(
                e,
                i,
                hull_next[ e ],
                INVALID_INDEX,
                INVALID_INDEX,
                hull_tri[ e ] );

            hull_tri[ i ] = legalize( t + 2 );
            hull_tri[ e ] = t;
            hull_size++;

            // walk forward through the hull, adding more triangles and flipping recursively
            auto next = hull_next[ e ];
            while (
                q = hull_next[ next ],
                orient( x, y, coords[ 3 * next ], coords[ 3 * next + 1 ], coords[ 3 * q ], coords[ 3 * q + 1 ] ) ) {
                t = add_triangle( next, i, q, hull_tri[ i ], INVALID_INDEX, hull_tri[ next ] );
                hull_tri[ i ] = legalize( t + 2 );
                hull_next[ next ] = next; // mark as removed
                hull_size--;
                next = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if ( e == start ) {
                while (
                    q = hull_prev[ e ],
                    orient( x, y, coords[ 3 * q ], coords[ 3 * q + 1 ], coords[ 3 * e ], coords[ 3 * e + 1 ] ) ) {
                    t = add_triangle( q, i, e, INVALID_INDEX, hull_tri[ e ], hull_tri[ q ] );
                    legalize( t + 2 );
                    hull_tri[ q ] = t;
                    hull_next[ e ] = e; // mark as removed
                    hull_size--;
                    e = q;
                }
            }

            // update the hull indices
            hull_prev[ i ] = e;
            hull_start = e;
            hull_prev[ next ] = i;
            hull_next[ e ] = i;
            hull_next[ i ] = next;

            m_hash[ hash_key( x, y ) ] = i;
            m_hash[ hash_key( coords[ 3 * e ], coords[ 3 * e + 1 ] ) ] = e;
        }
    }

    double Delaunator::get_hull_area( ) {
        std::vector<double> hull_area;
        auto e = hull_start;
        do {
            hull_area.push_back( ( coords[ 3 * e ] - coords[ 3 * hull_prev[ e ] ] ) * ( coords[ 3 * e + 1 ] + coords[ 3 * hull_prev[ e ] + 1 ] ) );
            e = hull_next[ e ];
        } while ( e != hull_start );
        return sum( hull_area );
    }

    std::size_t Delaunator::legalize( std::size_t a ) {
        std::size_t i = 0;
        std::size_t ar = 0;
        m_edge_stack.clear( );

        // recursion eliminated with a fixed-size stack
        while ( true ) {
            const auto b = halfedges[ a ];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
            * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
            * then do the same check/flip recursively for the new pair of triangles
            *
            *           pl                    pl
            *          /||\                  /  \
            *       al/ || \bl            al/    \a
            *        /  ||  \              /      \
            *       /  a||b  \    flip    /___ar___\
            *     p0\   ||   /p1   =>   p0\---bl---/p1
            *        \  ||  /              \      /
            *       ar\ || /br             b\    /br
            *          \||/                  \  /
            *           pr                    pr
            */
            const auto a0 = 3 * ( a / 3 );
            ar = a0 + ( a + 2 ) % 3;

            if ( b == INVALID_INDEX ) {
                if ( i > 0 ) {
                    i--;
                    a = m_edge_stack[ i ];
                    continue;
                }
                else {
                    //i = INVALID_INDEX;
                    break;
                }
            }

            const auto b0 = 3 * ( b / 3 );
            const auto al = a0 + ( a + 1 ) % 3;
            const auto bl = b0 + ( b + 2 ) % 3;

            const auto p0 = triangles[ ar ];
            const auto pr = triangles[ a ];
            const auto pl = triangles[ al ];
            const auto p1 = triangles[ bl ];

            const auto illegal = in_circle(
                coords[ 3 * p0 ],
                coords[ 3 * p0 + 1 ],
                coords[ 3 * pr ],
                coords[ 3 * pr + 1 ],
                coords[ 3 * pl ],
                coords[ 3 * pl + 1 ],
                coords[ 3 * p1 ],
                coords[ 3 * p1 + 1 ] );

            if ( illegal ) {
                triangles[ a ] = p1;
                triangles[ b ] = p0;

                const auto hbl = halfedges[ bl ];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if ( hbl == INVALID_INDEX ) {
                    auto e = hull_start;
                    do {
                        if ( hull_tri[ e ] == bl ) {
                            hull_tri[ e ] = a;
                            break;
                        }
                        e = hull_next[ e ];
                    } while ( e != hull_start );
                }
                link( a, hbl );
                link( b, halfedges[ ar ] );
                link( ar, bl );
                auto br = b0 + ( b + 1 ) % 3;

                if ( i < m_edge_stack.size( ) ) {
                    m_edge_stack[ i ] = br;
                }
                else {
                    m_edge_stack.push_back( br );
                }
                i++;

            }
            else {
                if ( i > 0 ) {
                    i--;
                    a = m_edge_stack[ i ];
                    continue;
                }
                else {
                    break;
                }
            }
        }
        return ar;
    }

    inline std::size_t Delaunator::hash_key( const double x, const double y ) const {
        const auto dx = x - m_center_x;
        const auto dy = y - m_center_y;
        return fast_mod(
            static_cast< std::size_t >( std::llround( std::floor( pseudo_angle( dx, dy ) * static_cast< double >( m_hash_size ) ) ) ),
            m_hash_size );
    }

    std::size_t Delaunator::add_triangle(
        std::size_t i0,
        std::size_t i1,
        std::size_t i2,
        std::size_t a,
        std::size_t b,
        std::size_t c ) {
        const auto t = triangles.size( );
        triangles.push_back( i0 );
        triangles.push_back( i1 );
        triangles.push_back( i2 );
        link( t, a );
        link( t + 1, b );
        link( t + 2, c );
        return t;
    }

    void Delaunator::link( const std::size_t a, const std::size_t b ) {
        const auto s = halfedges.size( );
        if ( a == s ) {
            halfedges.push_back( b );
        }
        else if ( a < s ) {
            halfedges[ a ] = b;
        }
        else {
            throw std::runtime_error( "Cannot link edge" );
        }
        if ( b != INVALID_INDEX ) {
            const auto s2 = halfedges.size( );
            if ( b == s2 ) {
                halfedges.push_back( a );
            }
            else if ( b < s2 ) {
                halfedges[ b ] = a;
            }
            else {
                throw std::runtime_error( "Cannot link edge" );
            }
        }
    }

} //namespace delaunator
```

`solace-csgo/detours.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.5 (Build 46)
//
//  Copyright 1995-2001, Microsoft Corporation
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

//////////////////////////////////////////////////////////////////////////////
//
#ifdef IMAGEAPI // defined by IMAGEHLP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
                                       IN HANDLE hFile,
                                       IN PSTR ImageName,
                                       IN PSTR ModuleName,
                                       IN DWORD BaseOfDll,
                                       IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
                                          IN DWORD dwAddr,
                                          OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
                                           IN LPSTR Name,
                                           OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
                                   IN LPSTR pszDllPath,
                                   IN LPSTR pszSymbolPath);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                   hProcess;
    HMODULE                  hImageHlp;
    PF_ImagehlpApiVersionEx  pfImagehlpApiVersionEx;
    PF_SymInitialize         pfSymInitialize;
    PF_SymSetOptions         pfSymSetOptions;
    PF_SymGetOptions         pfSymGetOptions;
    PF_SymLoadModule         pfSymLoadModule;
    PF_SymGetModuleInfo      pfSymGetModuleInfo;
    PF_SymGetSymFromName     pfSymGetSymFromName;
    PF_BindImage             pfBindImage;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

//////////////////////////////////////////////////////////////////////////////
//
class CDetourEnableWriteOnCodePage
{
public:
    CDetourEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
    {
        m_pbCode = pbCode;
        m_cbCode = cbCode;
        m_dwOldPerm = 0;
        m_hProcess = GetCurrentProcess();

        if (m_pbCode && m_cbCode) {
            if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
                return;
            }
            if (!VirtualProtect(pbCode,
                                cbCode,
                                PAGE_EXECUTE_READWRITE,
                                &m_dwOldPerm)) {
                return;
            }
        }
    }

    ~CDetourEnableWriteOnCodePage()
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            DWORD dwTemp = 0;
            if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
                return;
            }
            if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
                return;
            }
        }
    }

    BOOL SetPermission(DWORD dwPerms)
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            m_dwOldPerm = dwPerms;
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsValid(VOID)
    {
        return m_pbCode && m_cbCode && m_dwOldPerm;
    }

private:
    HANDLE  m_hProcess;
    PBYTE   m_pbCode;
    LONG    m_cbCode;
    DWORD   m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
inline PBYTE DetourGenMovEax(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB8;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBB;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEcx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB9;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBA;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBE;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBF;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBD;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBC;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPush(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0x68;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPushad(PBYTE pbCode)
{
    *pbCode++ = 0x60;
    return pbCode;
}

inline PBYTE DetourGenPopad(PBYTE pbCode)
{
    *pbCode++ = 0x61;
    return pbCode;
}

inline PBYTE DetourGenJmp(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE9;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenCall(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE8;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenBreak(PBYTE pbCode)
{
    *pbCode++ = 0xcc;
    return pbCode;
}

inline PBYTE DetourGenRet(PBYTE pbCode)
{
    *pbCode++ = 0xc3;
    return pbCode;
}

inline PBYTE DetourGenNop(PBYTE pbCode)
{
    *pbCode++ = 0x90;
    return pbCode;
}
#endif DETOURS_INTERAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`solace-csgo/dllmain.cpp`:

```cpp
#include "aimbot.h"
#include "sdk.h"
#include "hooks.h"


unsigned long _stdcall initialize ( void *instance ) {
	while ( !GetModuleHandleA( "serverbrowser.dll" ) )
		Sleep( 200 );

	interfaces_t m_interfaces;
	g.m_interfaces = &m_interfaces;
	offsets_t m_offsets;
	g.m_offsets = &m_offsets;
	hooks_t m_hooks;
	g.m_hooks = &m_hooks;
	render_t m_render;
	g.m_render = &m_render;

	try {
		g.init_cheat( );
	}
	catch ( const std::runtime_error &error ) {
		MessageBoxA( nullptr, error.what( ), "major cheat error!", MB_OK | MB_ICONERROR );
		FreeLibraryAndExitThread( static_cast< HMODULE >(instance), 0 );
	}
	//CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr );
	//CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr );
	//CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr );
	//CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr );
	//if ( auto* const handle = CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr ) )
	//	CloseHandle( handle );
	//if ( auto* const handle = CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr ) )
	//	CloseHandle( handle );
	//if ( auto* const handle = CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr ) )
	//	CloseHandle( handle );
	//if ( auto* const handle = CreateThread( nullptr, NULL, hc_thread, instance, NULL, nullptr ) )
	//	CloseHandle( handle );

	while ( !GetAsyncKeyState( VK_END ) ) {
		std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );
	}

	FreeLibraryAndExitThread( static_cast< HMODULE >(instance), 0 );
	return TRUE;
}

std::int32_t WINAPI DllMain ( const HMODULE instance, const unsigned long reason, [[maybe_unused]] const void *reserved ) {
	DisableThreadLibraryCalls( instance );

	switch ( reason ) {
	case DLL_PROCESS_ATTACH :
		if ( auto* const handle = CreateThread( nullptr, NULL, initialize, instance, NULL, nullptr ) )
			CloseHandle( handle );
		break;

	case DLL_PROCESS_DETACH :
		g.release( );
		break;

	}

	return true;
}

```

`solace-csgo/engine_client.h`:

```h
#pragma once
#include "includes.h"

struct engine_player_info_t {
	int64_t __pad0;
	union {
		int64_t xuid;
		struct {
			int xuidlow;
			int xuidhigh;
		};
	};
	char name[ 128 ];
	int userid;
	char guid[ 33 ];
	unsigned int friendsid;
	char friendsname[ 128 ];
	bool fakeplayer;
	bool ishltv;
	unsigned int customfiles[ 4 ];
	unsigned char filesdownloaded;
};

class i_net_channel {
private:
	PAD( 0x14 );

public:
	bool m_processing_messages;		// 0x0014
	bool m_should_delete;			// 0x0015

private:
	PAD( 0x2 );

public:
	int m_out_seq;					// 0x0018 last send outgoing sequence number
	int m_in_seq;					// 0x001C last received incoming sequnec number
	int m_out_seq_ack;				// 0x0020 last received acknowledge outgoing sequnce number
	int m_out_rel_state;			// 0x0024 state of outgoing reliable data (0/1) flip flop used for loss detection
	int m_in_rel_state;				// 0x0028 state of incoming reliable data
	int m_choked_packets;			// 0x002C number of choked packets

private:
	PAD( 0x414 );					// 0x0030
public:
	VFUNC( GetLatency( int flow ), 9, float( __thiscall * )( decltype( this ), int flow ), flow );
	VFUNC( GetAvgLatency( int flow ), 10, float( __thiscall * )( decltype( this ), int flow ), flow );
	VFUNC( SendDatagram( void *data = nullptr ), 48, int( __thiscall * )( decltype( this ), void* ), data );
	VFUNC( CanPacket( ), 58, bool( __thiscall * )( decltype( this ) ) );
	VFUNC( IsLoopBack( ), 6, bool( __thiscall * )( decltype( this ) ) );
	VFUNC( SetChoked( ), 47, void( __thiscall * )( decltype( this ) ) );
	VFUNC( IsTimingOut( ), 7, bool( __thiscall * )( decltype( this ) ) );
};


class c_engine_client {
public:
	const matrix_t &world_to_screen( ) {
		typedef const matrix_t &( __thiscall *oWorldToScreenMatrix )( PVOID );
		return util::get_virtual_function<oWorldToScreenMatrix>( this, 37 )( this );
	}
	__forceinline int GetPlayerForUserID( int uid ) {
		return util::get_virtual_function< int( __thiscall * )( decltype( this ), int ) >( this, 9 )( this, uid );
	}
	__forceinline void FireEvents( ) {
		return util::get_virtual_function< void( __thiscall * )( decltype( this ) ) >( this, 59 )( this );
	}

	VFUNC( get_screen_size( int& width, int& height ), 5, void( __thiscall* )( decltype( this ), int&, int& ), width, height );
	VFUNC( in_game( ), 26, bool( __thiscall* )( decltype( this ) ) );
	VFUNC( is_connected( ), 27, bool( __thiscall* )( decltype( this ) ) );
	VFUNC( client_cmd_urestricted( const char* cmd_string ), 108, void( __thiscall* )( decltype( this ), const char* ), cmd_string );
	VFUNC( local_player_index( ), 12, int( __thiscall * )( decltype( this ) ) );
	VFUNC( set_view_angles( ang_t &angles ), 19, void( __thiscall * )( decltype( this ), ang_t & ), angles );
	void get_view_angles( ang_t &angles ) {
		return util::get_virtual_function<void( __thiscall * )( void *, ang_t & )>( this, 18 )( this, angles );
	}
	i_net_channel *get_net_channel_info( ) {
		using original_fn = i_net_channel * ( __thiscall * )( decltype(this) );
		return ( *( original_fn ** )this )[ 78 ]( this );
	}
	bool get_player_info( int index, engine_player_info_t *info ) {
		using original_fn = bool( __thiscall * )( decltype(this), int, engine_player_info_t * );
		return ( *( original_fn ** )this )[ 8 ]( this, index, info );
	}
};
```

`solace-csgo/engine_cvar.h`:

```h
#pragma once

class c_engine_cvar {
	
};
```

`solace-csgo/engine_trace.h`:

```h
#pragma once
#include "includes.h"

class player_t;

#define	SURF_LIGHT		0x0001		// value will hold the light strength
#define	SURF_SKY2D		0x0002		// don't draw, indicates we should skylight + draw 2d sky but not draw the 3D skybox
#define	SURF_SKY		0x0004		// don't draw, but add to skybox
#define	SURF_WARP		0x0008		// turbulent water warp
#define	SURF_TRANS		0x0010
#define SURF_NOPORTAL	0x0020	// the surface can not have a portal placed on it
#define	SURF_TRIGGER	0x0040	// FIXME: This is an xbox hack to work around elimination of trigger surfaces, which breaks occluders
#define	SURF_NODRAW		0x0080	// don't bother referencing the texture
#define	SURF_HINT		0x0100	// make a primary bsp splitter
#define	SURF_SKIP		0x0200	// completely ignore, allowing non-closed brushes
#define SURF_NOLIGHT	0x0400	// Don't calculate light
#define SURF_BUMPLIGHT	0x0800	// calculate three lightmaps for the surface for bumpmapping
#define SURF_NOSHADOWS	0x1000	// Don't receive shadows
#define SURF_NODECALS	0x2000	// Don't receive decals
#define SURF_NOPAINT	0x2000	// the surface can not have paint placed on it
#define SURF_NOCHOP		0x4000	// Don't subdivide patches on this surface
#define SURF_HITBOX		0x8000	// surface is part of a hitbox

#define CHAR_TEX_ANTLION		'A'
#define CHAR_TEX_BLOODYFLESH	'B'
#define	CHAR_TEX_CONCRETE		'C'
#define CHAR_TEX_DIRT			'D'
#define CHAR_TEX_EGGSHELL		'E' ///< the egg sacs in the tunnels in ep2.
#define CHAR_TEX_FLESH			'F'
#define CHAR_TEX_GRATE			'G'
#define CHAR_TEX_ALIENFLESH		'H'
#define CHAR_TEX_CLIP			'I'
//#define CHAR_TEX_UNUSED		'J'
#define CHAR_TEX_SNOW			'K'
#define CHAR_TEX_PLASTIC		'L'
#define CHAR_TEX_METAL			'M'
#define CHAR_TEX_SAND			'N'
#define CHAR_TEX_FOLIAGE		'O'
#define CHAR_TEX_COMPUTER		'P'
//#define CHAR_TEX_UNUSED		'Q'
#define CHAR_TEX_REFLECTIVE		'R'
#define CHAR_TEX_SLOSH			'S'
#define CHAR_TEX_TILE			'T'
#define CHAR_TEX_CARDBOARD		'U'
#define CHAR_TEX_VENT			'V'
#define CHAR_TEX_WOOD			'W'
//#define CHAR_TEX_UNUSED		'X' ///< do not use - "fake" materials use this (ladders, wading, clips, etc)
#define CHAR_TEX_GLASS			'Y'
#define CHAR_TEX_WARPSHIELD		'Z' ///< wierd-looking jello effect for advisor shield.

#define	CONTENTS_EMPTY			0		/**< No contents. */
#define	CONTENTS_SOLID			0x1		/**< an eye is never valid in a solid . */
#define	CONTENTS_WINDOW			0x2		/**< translucent, but not watery (glass). */
#define	CONTENTS_AUX			0x4
#define	CONTENTS_GRATE			0x8		/**< alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't. */
#define	CONTENTS_SLIME			0x10
#define	CONTENTS_WATER			0x20
#define	CONTENTS_MIST			0x40
#define CONTENTS_OPAQUE			0x80		/**< things that cannot be seen through (may be non-solid though). */
#define	LAST_VISIBLE_CONTENTS	0x80
#define ALL_VISIBLE_CONTENTS 	(LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))
#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED5		0x200
#define CONTENTS_UNUSED6		0x4000
#define CONTENTS_TEAM1			0x800		/**< per team contents used to differentiate collisions. */
#define CONTENTS_TEAM2			0x1000		/**< between players and objects on different teams. */
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000		/**< ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW. */
#define CONTENTS_MOVEABLE		0x4000		/**< hits entities which are MOVETYPE_PUSH (doors, plats, etc) */
#define	CONTENTS_AREAPORTAL		0x8000		/**< remaining contents are non-visible, and don't eat brushes. */
#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000

/**
* @section currents can be added to any other contents, and may be mixed
*/
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000

/**
* @endsection
*/

#define	CONTENTS_ORIGIN			0x1000000	/**< removed before bsping an entity. */
#define	CONTENTS_MONSTER		0x2000000	/**< should never be on a brush, only in game. */
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	/**< brushes to be added after vis leafs. */
#define	CONTENTS_TRANSLUCENT	0x10000000	/**< auto set if any surface has trans. */
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	/**< use accurate hitboxes on trace. */

/**
* @section Trace masks.
*/
#define	MASK_ALL				(0xFFFFFFFF)
#define	MASK_SOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE) 			/**< everything that is normally solid */
#define	MASK_PLAYERSOLID		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE) 	/**< everything that blocks player movement */
#define	MASK_NPCSOLID			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE) /**< blocks npc movement */
#define	MASK_WATER				(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME) 							/**< water physics in these contents */
#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE) 							/**< everything that blocks line of sight for AI, lighting, etc */
#define MASK_OPAQUE_AND_NPCS	(MASK_OPAQUE|CONTENTS_MONSTER)										/**< everything that blocks line of sight for AI, lighting, etc, but with monsters added. */
#define	MASK_VISIBLE			(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE) 								/**< everything that blocks line of sight for players */
#define MASK_VISIBLE_AND_NPCS	(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE) 							/**< everything that blocks line of sight for players, but with monsters added. */
#define MASK_SHOT_HULL			(MASK_SOLID | CONTENTS_DEBRIS) 	/**< non-raycasted weapons see this as solid (includes grates) */
#define	MASK_SHOT				(MASK_SHOT_HULL|CONTENTS_HITBOX) 	/**< bullets see these as solid */
#define MASK_SHOT_PORTAL		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW) 							/**< hits solids (not grates) and passes through everything else */
#define MASK_SOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE) 					/**< everything normally solid, except monsters (world+brush only) */
#define MASK_PLAYERSOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE) 			/**< everything normally solid for player movement, except monsters (world+brush only) */
#define MASK_NPCSOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE) 			/**< everything normally solid for npc movement, except monsters (world+brush only) */
#define MASK_NPCWORLDSTATIC		(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE) 					/**< just the world, used for route rebuilding */
#define MASK_SPLITAREAPORTAL	(CONTENTS_WATER|CONTENTS_SLIME) 									/**< These are things that can split areaportals */

class IHandleEntity {
public:
	virtual ~IHandleEntity( ) {}
	virtual void SetRefEHandle( const int& handle ) = 0;
	virtual const int& GetRefEHandle( ) const = 0;
};

struct ray_t {
	vec_aligned_t m_start; // starting point, centered within the extents
	vec_aligned_t m_delta; // direction + length of the ray
	vec_aligned_t m_start_offset; // Add this to m_Start to get the actual ray start
	vec_aligned_t m_extents; // Describes an axis aligned box extruded along a ray
	const matrix_t *m_world_axis_transform = nullptr;
	//const matrix_t *m_pWorldAxisTransform;
	bool m_is_ray = false; // are the extents zero?
	bool m_is_swept = false; // is delta != 0?

	void initialize( const vec3_t &start, const vec3_t &end ) {
		m_delta = vec_aligned_t{end - start };
		m_world_axis_transform = nullptr;

		m_is_swept = ( m_delta.length_sqr( ) != 0 );

		m_extents.x = m_extents.y = m_extents.z = 0.0f;
		m_is_ray = true;

		m_start_offset.x = m_start_offset.y = m_start_offset.z = 0.0f;

		m_start = start;
	}

	void initialize( const vec3_t &vecStart, const vec3_t &vecEnd, const vec3_t &min, const vec3_t &max ) {
		m_delta = vec_aligned_t{ vecEnd - vecStart };
		m_world_axis_transform = nullptr;
		m_is_swept = m_delta.length_sqr( ) != 0.f;
		m_extents = vec_aligned_t{ max - min };
		m_extents *= 0.5f;
		m_is_ray = m_extents.length_sqr( ) < 1e-6;
		m_start_offset = vec_aligned_t{ min + max };
		m_start_offset *= 0.5f;
		m_start = vec_aligned_t{ vecStart + m_start_offset };
		m_start_offset *= -1.f;
	}
	ray_t( ) { }
	ray_t( vec3_t vecStart, vec3_t vecEnd ) {
		initialize( vecStart, vecEnd );
	}
	ray_t( vec3_t vecStart, vec3_t vecEnd, vec3_t min, vec3_t max ) {
		initialize( vecStart, vecEnd, min, max );
	}
};

struct csurface_t {
	const char *name;
	short surfaceProps;
	unsigned short flags;
};

struct cplane_t {
	vec3_t normal;
	float m_dist;
	BYTE m_type;
	BYTE m_sign_bits;
	BYTE m_pad[ 2 ];
};

struct trace_t {
	vec3_t start;
	vec3_t end;
	cplane_t plane;
	float flFraction{};
	int contents{};
	unsigned short dispFlags{};
	bool allsolid{};
	bool startSolid{};
	float fractionLeftSolid{};
	csurface_t surface{};
	int hitGroup{};
	short physicsBone{};
	player_t *entity{};
	int hitbox{};

	bool did_hit( ) const {
		return flFraction < 1.f;
	}

	bool did_hit_world( ) const {
		return false;
	}

	bool did_hit_non_world_entity( ) const {
		return entity != NULL && !did_hit_world( );
	}
};

enum class TraceType_t {
	TRACE_EVERYTHING = 0,
	TRACE_WORLD_ONLY, // NOTE: This does *not* test static props!!!
	TRACE_ENTITIES_ONLY, // NOTE: This version will *not* test static props
	TRACE_EVERYTHING_FILTER_PROPS, // NOTE: This version will pass the IHandleEntity for props through the filter, unlike all other filters
};


class c_trace_filter {
public:
	virtual bool should_hit_entity( void *pEntity, int contentsMask ) = 0;
	virtual TraceType_t get_type( ) const = 0;
};


class i_trace_filter {
public:
	virtual bool ShouldHitEntity( void *pEntity, int contentsMask ) = 0;
	virtual TraceType_t GetTraceType( ) const = 0;
};

class trace_filter : public i_trace_filter {
public:
	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return ( pEntityHandle != skip );
	}

	TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_EVERYTHING;
	}

	void *skip = nullptr;
};

class trace_filter_one_entity : public i_trace_filter {
public:
	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return ( pEntityHandle == pEntity );
	}

	[[nodiscard]] TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_EVERYTHING;
	}

	void *pEntity = nullptr;
};

class trace_filter_one_entity2 : public i_trace_filter {
public:
	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return ( pEntityHandle == pEntity );
	}

	TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_ENTITIES_ONLY;
	}

	void *pEntity = nullptr;
};

class trace_filter_skip_two_entities : public i_trace_filter {
public:
	trace_filter_skip_two_entities( void *pPassEnt1, void *pPassEnt2 ) {
		passentity1 = pPassEnt1;
		passentity2 = pPassEnt2;
	}

	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return !( pEntityHandle == passentity1 || pEntityHandle == passentity2 );
	}

	TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_EVERYTHING;
	}

	void *passentity1 = nullptr;
	void *passentity2 = nullptr;
};

class trace_filter_skip_one_entity : public i_trace_filter {
public:
	trace_filter_skip_one_entity( void* pPassEnt1 ) {
		passentity1 = pPassEnt1;
	}

	virtual bool ShouldHitEntity( void* pEntityHandle, int contentsMask ) {
		return !( pEntityHandle == passentity1 );
	}

	virtual TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_EVERYTHING;
	}

	void* passentity1 = nullptr;
};

class trace_entity : public i_trace_filter {
public:
	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return !( pEntityHandle == pSkip1 );
	}

	TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_ENTITIES_ONLY;
	}

	void *pSkip1 = nullptr;
};

class trace_world_only : public i_trace_filter {
public:
	bool ShouldHitEntity( void *pEntityHandle, int contentsMask ) {
		return false;
	}

	TraceType_t GetTraceType( ) const {
		return TraceType_t::TRACE_EVERYTHING;
	}

	void *pSkip1 = nullptr;
};
class c_collideable;

class c_engine_trace {
	public: // no need to use vtables here.
	virtual int get_point_contents( const vec3_t &pos, int mask = MASK_ALL, IHandleEntity **ent = nullptr ) = 0;
	virtual int get_point_contents_world( const vec3_t &pos, int mask = MASK_ALL ) = 0;
	virtual int get_point_contents_collideable( c_collideable *collide, const vec3_t &pos ) = 0;
	virtual void clip_ray_to_entity( const ray_t &ray, unsigned int mask, player_t *ent, trace_t *trace ) = 0;
	virtual void clip_ray_to_collideable( const ray_t &ray, unsigned int mask, c_collideable *collide, trace_t *trace ) = 0;
	virtual void trace_ray( const ray_t &ray, unsigned int mask, i_trace_filter *filter, trace_t *trace ) {
		return util::get_virtual_function< void( __thiscall * )( decltype( this ), const ray_t &, unsigned int, i_trace_filter *, trace_t * ) >( this, 5 )( this, ray, mask, filter, trace );
	}
};
```

`solace-csgo/entity_list.h`:

```h
#pragma once
#include "includes.h"

class c_entity_list {
public:
	VFUNC( get_client_entity( int index ), 3, void *( __thiscall * )( decltype( this ), int ), index )
	VFUNC( get_client_entity_handle( uintptr_t handle ), 4, void *( __thiscall * )( decltype( this ), uintptr_t ), handle )
	VFUNC( get_highest_index( ), 6, int( __thiscall * )( decltype( this ) ) )
};

```

`solace-csgo/esp.cpp`:

```cpp
#include "esp.h"
#include "sdk.h"
#include "includes.h"
#include "menu.hh"
#include "delaunator.h"

#define render g.m_render
void esp_t::run ( ) {
	if ( !g.m_local )
		return;
	auto weapon = static_cast< weapon_t * >(g.m_interfaces->entity_list( )->get_client_entity_handle( g.m_local->active_weapon( ) ));
	if( weapon )
		render->text( render->m_tahoma_12( ), 100, 100, color( 255, 255, 255 ), std::to_string( weapon->index( ) ).c_str( ) );
	for ( auto i = 0; i < g.m_interfaces->entity_list( )->get_highest_index( ); i++ ) {
		auto *const ent = static_cast< player_t * >( g.m_interfaces->entity_list( )->get_client_entity( i ) );
		if ( !ent )
			continue;
		auto *networkable = ent->networkable( );
		if ( !networkable )
			continue;
		const auto client_class_id = networkable->client_class( );
		if ( client_class_id->m_ClassID == 35 )
			player( ent );
		else if ( strcmp( client_class_id->m_pNetworkName, "CInferno" ) == 0 )
			inferno( ent );
		else if ( strcmp( client_class_id->m_pNetworkName, "CSmokeGrenadeProjectile" ) == 0 )
			smoke( ent );
		else if ( strcmp( client_class_id->m_pNetworkName, "CMolotovProjectile" ) == 0 )
			molotov( ent );
		else if ( strcmp( client_class_id->m_pNetworkName, "CBaseCSGrenadeProjectile" ) == 0 )
			flying_grenade( ent );
	}
}

void esp_t::smoke( entity_t* ent ) {
	if ( !settings::visuals::world::wire_smoke )
		return;
	if ( ((weapon_t*)ent)->smoke_effect_begin_tick() )
		g.m_render->world_circle( ent->abs_origin( ), 144, menu.main_theme );
	else {
		vec3_t screen;
		if ( !math::world_to_screen( ent->abs_origin( ), screen ) )
			return;
		g.m_render->text( g.m_render->m_tahoma_14( ), screen.x, screen.y, menu.dark_accent, "SMOKE", Horizontal | Vertical );
	}
}

void esp_t::flying_grenade( entity_t *ent ) {
	const model_t* model = ent->model( );

	if ( model ) {
		// grab modelname.
		std::string name{ model->name };

		vec3_t screen;
		if ( !math::world_to_screen( ent->abs_origin( ), screen ) )
			return;

		if ( name.find( "flashbang" ) != std::string::npos )
			render->text( render->m_tahoma_14( ), screen.x, screen.y, menu.dark_accent, "FLASH", Horizontal | Vertical );

		else if ( name.find( "fraggrenade" ) != std::string::npos ) {
			render->text(render->m_tahoma_14(), screen.x, screen.y, menu.dark_accent, "FRAG", Horizontal | Vertical );
		}
	}
}

void esp_t::molotov( entity_t* ent ) {
	if ( !settings::visuals::world::molotov )
		return;
	vec3_t screen;
	if ( !math::world_to_screen( ent->abs_origin( ), screen ) )
		return;
	g.m_render->text( g.m_render->m_tahoma_14( ), screen.x, screen.y, menu.dark_accent, "MOLOTOV", Horizontal | Vertical );
}

void esp_t::inferno(entity_t* ent) {
	if (!settings::visuals::world::molotov)
		return;
	auto* inferno = reinterpret_cast<inferno_t*>(ent);
	auto* thrower = static_cast<player_t*>(g.m_interfaces->entity_list()->get_client_entity_handle(inferno->m_thrower()));
	bool team = false;
	if (thrower)
		team = thrower->on_team(g.m_local);
	const auto origin = ent->origin();
	auto* const fire_x = inferno->m_fire_x();
	auto* const fire_y = inferno->m_fire_y();
	auto* const fire_z = inferno->m_fire_z();
	auto* const burning = inferno->m_fire_burning();
	const int fire_count = inferno->m_fire_count();
	
	std::vector<double> points = {};
	for (auto k = 0; k < fire_count; k++) {
		if (!burning[k])
			continue;
		const auto point = vec3_t{ static_cast<float>(fire_x[k]), static_cast<float>(fire_y[k]), static_cast<float>(fire_z[k]) };
		vec3_t screen = origin + point;
		//			m_render->text( m_render->m_tahoma_12( ), screen.x, screen.y, color( 255, 255, 255 ), std::to_string( k ).c_str( ) );
		points.push_back(screen.x);
		points.push_back(screen.y);
		points.push_back(screen.z);
	}
	if (points.size() < 9)
		return;
	delaunator::Delaunator delaunator(points);

	menu.main_theme.set_a( 100 );
	menu.dark_accent.set_a( 100 );
	color point_color = team ? menu.main_theme : menu.dark_accent;
	menu.main_theme.set_a( 255 );
	menu.dark_accent.set_a( 255 );
	render_t::vertex_t verts[3] = {};
	vec3_t point;
	for (std::size_t i = 0; i < delaunator.triangles.size(); i += 3) {
	
		point = vec3_t(static_cast<float>(delaunator.coords[3 * delaunator.triangles[i]]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i] + 1]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i] + 2]));
		vec3_t screen;
		if (!math::world_to_screen(point, screen))
			continue;
		verts[0] = render_t::vertex_t{ screen.x, screen.y, 0, 1, point_color };
	
		point = vec3_t(static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 1]]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 1] + 1]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 1] + 2]));
		if (!math::world_to_screen(point, screen))
			continue;
		verts[1] = render_t::vertex_t{ screen.x, screen.y, 0, 1, point_color };
	
		point = vec3_t(static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 2]]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 2] + 1]), static_cast<float>(delaunator.coords[3 * delaunator.triangles[i + 2] + 2]));
		if (!math::world_to_screen(point, screen))
			continue;
		verts[2] = render_t::vertex_t{ screen.x, screen.y, 0, 1, point_color };
	
		g.m_render->render_triangle(verts, 1);
	
		g.m_render->line(verts[0].x, verts[0].y, verts[1].x, verts[1].y, color(255, 255, 255, 30), 1);
		g.m_render->line(verts[2].x, verts[2].y, verts[0].x, verts[0].y, color(255, 255, 255, 30), 1);
		g.m_render->line(verts[2].x, verts[2].y, verts[1].x, verts[1].y, color(255, 255, 255, 30), 1);
	}

	//for ( std::size_t i = 0; i < delaunator.halfedges.size( ); i += 3 ) {
	//	//verts[ 0 ] = ( render_t::vertex_t{ static_cast< float >( delaunator.coords[ 2 * delaunator.halfedges[ i ] ] ), static_cast< float >( delaunator.coords[ 2 * delaunator.halfedges[ i ] + 1 ] ), 0, 1, color( 180, 0,0, 100 ) } );
	//	//verts[ 1 ] = ( render_t::vertex_t{ static_cast< float >( delaunator.coords[ 2 * delaunator.halfedges[ i + 1 ] ] ), static_cast< float >( delaunator.coords[ 2 * delaunator.halfedges[ i + 1 ] + 1 ] ), 0, 1, color( 180, 0,0, 100 ) } );
	//	g.m_render->line( static_cast< float >(delaunator.coords[3 * delaunator.halfedges[i]]),
	//	                  static_cast< float >(delaunator.coords[3 * delaunator.halfedges[i] + 1]),
	//	                  static_cast< float >(delaunator.coords[3 * delaunator.halfedges[i + 1]]),
	//	                  static_cast< float >(delaunator.coords[3 * delaunator.halfedges[i + 1] + 1]),
	//	                  color( 180, 0, 0, 100 ) );
	//}
}

void esp_t::NoSmoke( ) {
	static i_material *smoke1;
	static i_material *smoke2;
	static i_material *smoke3;
	static i_material *smoke4;
	if ( !smoke1 )
		smoke1 = g.m_interfaces->material_system(  )->find_material(  "particle/vistasmokev1/vistasmokev1_fire", "Other textures" );

	if ( !smoke2 )
		smoke2 = g.m_interfaces->material_system( )->find_material( "particle/vistasmokev1/vistasmokev1_smokegrenade" ,  "Other textures"  );

	if ( !smoke3 )
		smoke3 = g.m_interfaces->material_system( )->find_material(  "particle/vistasmokev1/vistasmokev1_emods" ,  "Other textures"  );

	if ( !smoke4 )
		smoke4 = g.m_interfaces->material_system( )->find_material( "particle/vistasmokev1/vistasmokev1_emods_impactdust" ,  "Other textures"  );

	if ( settings::visuals::world::wire_smoke ) {
		if ( !smoke1->get_material_var_flag( material_var_wireframe ) )
			smoke1->set_material_var_flag( material_var_wireframe, true );

		if ( !smoke2->get_material_var_flag( material_var_wireframe ) )
			smoke2->set_material_var_flag( material_var_wireframe, true );

		if ( !smoke3->get_material_var_flag( material_var_wireframe ) )
			smoke3->set_material_var_flag( material_var_wireframe, true );

		if ( !smoke4->get_material_var_flag( material_var_wireframe ) )
			smoke4->set_material_var_flag( material_var_wireframe, true );
	}

	else {
		if ( smoke1->get_material_var_flag( material_var_wireframe ) )
			smoke1->set_material_var_flag( material_var_wireframe, false );

		if ( smoke2->get_material_var_flag( material_var_wireframe ) )
			smoke2->set_material_var_flag( material_var_wireframe, false );

		if ( smoke3->get_material_var_flag( material_var_wireframe ) )
			smoke3->set_material_var_flag( material_var_wireframe, false );

		if ( smoke4->get_material_var_flag( material_var_wireframe ) )
			smoke4->set_material_var_flag( material_var_wireframe, false );
	}
}

bool esp_t::get_player_box( player_t *player, area_t *box ) {
	vec3_t bottom, top;

	// get hitbox bounds.
	auto origin = player->origin( );
	auto mins = player->mins( );
	auto maxs = player->maxs( );
	auto &info = g_player_manager.m_ents[ player->index( ) - 1 ];
	if ( !info.m_records.empty(  ) ) {
		auto const &record = info.m_records[ 0 ];
		if ( record ) {
			origin = record->m_origin;
			mins = record->m_mins;
			maxs = record->m_maxs;
		}
	}

	// correct x and y coordinates.
	mins = { origin.x, origin.y, origin.z + mins.z - 0.8f };
	maxs = { origin.x, origin.y, origin.z + maxs.z };

	if ( !math::world_to_screen( mins, bottom ) || !math::world_to_screen( maxs, top ) )
		return false;

	box->h = floorf(bottom.y - top.y);
	box->w = ceilf(box->h / 2.f);
	box->x = floorf(bottom.x - box->w / 2.f);
	box->y = ceilf(bottom.y - box->h);
	auto size = g.m_render->m_screen_size();
	if (box->h + box->y < size.Y)
		return false;
	if (box->x + box->w < size.X)
		return false;

	if ( box->y > size.Y + size.Height )
		return false;
	if ( box->x > size.X + size.Width)
		return false;

	return true;
}

void esp_t::offscreen( player_t *ent ) {
	if ( !g.m_local )
		return;
	const auto vec_delta = ent->origin( ) - g.m_shoot_pos;
	const auto yaw = RAD2DEG( atan2( vec_delta.y, vec_delta.x ) );
	ang_t angles;
	g.m_interfaces->engine( )->get_view_angles( angles );
	const auto yaw_delta = DEG2RAD((angles.y - yaw) - 90.f );

	const auto clr = ent->on_team( g.m_local ) ? color{ 0xFF, 0x08, 0xFF } : color{ 0x81, 0xFF, 0x21 };
	auto r_x = settings::visuals::players::offscreen, r_y = settings::visuals::players::offscreen;
	const auto screen_size = g.m_render->m_screen_size( );
	r_x *= screen_size.Width / 2.f;
	r_y *= screen_size.Height / 2.f;

	const auto triangle_size = 15.f;
	
	render_t::vertex_t triag[ 3 ] = {
		{screen_size.Width / 2.f + cos( yaw_delta ) * ( r_x ), screen_size.Height / 2.f + sin( yaw_delta ) * ( r_y ),0, 1, clr},
		{screen_size.Width / 2.f + ( cos( yaw_delta ) * ( r_x - triangle_size ) ) + ( cos( yaw_delta + DEG2RAD(90) ) * triangle_size ), screen_size.Height / 2.f + ( sin( yaw_delta ) * ( r_y - triangle_size ) + ( sin( yaw_delta + DEG2RAD(90) ) * triangle_size ) ),0, 1, clr},
		{screen_size.Width / 2.f + ( cos( yaw_delta ) * ( r_x - triangle_size ) ) + ( cos( yaw_delta + DEG2RAD(90) ) * -triangle_size ), screen_size.Height / 2.f + ( sin( yaw_delta ) * ( r_y - triangle_size ) + ( sin( yaw_delta + DEG2RAD(90) ) * -triangle_size ) ),0, 1, clr},
	};
	
	g.m_render->render_triangle( triag, 1 );
}

void esp_t::player ( player_t *ent ) {
	if ( !ent->alive( ) )
		return;
	if ( ent->dormant( ) )
		return;
	const auto on_team = ent->on_team( g.m_local );
	if ( on_team && !settings::visuals::players::team )
		return;
	area_t box(0,0,0,0);
	if ( !get_player_box( ent, &box ) ) {
		offscreen( ent );
		return;
	}
	if ( settings::visuals::players::box ) {
		g.m_render->outlined_rect( box.x - 1, box.y - 1, box.w + 2, box.h + 2, color( 0, 0, 0, 200 ) );
		g.m_render->outlined_rect( box.x, box.y, box.w, box.h, on_team ? color{ 0xFF, 0x08, 0xFF } : color{ 0x81, 0xFF, 0x21 } );
		g.m_render->outlined_rect( box.x + 1, box.y + 1, box.w - 2, box.h - 2, color( 0, 0, 0, 200 ) );
	}
    if (settings::visuals::players::health)
    {
        const area_t health_box(box.x - 7, box.y, 3, box.h);
		
		g.m_render->outlined_rect( health_box.x - 1, health_box.y - 1, health_box.w + 2, health_box.h + 2, color( 50, 50, 50, 150 ) );
		g.m_render->filled_rect( health_box.x, health_box.y, health_box.w, health_box.h, color( 40, 40, 40 ));
		const auto health_percent = static_cast< float >( ent->health( ) ) / 100.f;
		g.m_render->filled_rect( health_box.x,
		                         health_box.y + health_box.h * (1 - health_percent ),
		                         health_box.w, health_box.h * health_percent,
		                         color( 255.f *(1 - health_percent),
		                                255.f * health_percent, 0 ) );
	}
	if ( settings::visuals::players::name ) {
		engine_player_info_t info{};
		g.m_interfaces->engine( )->get_player_info( ent->index( ), &info );
		const auto height = g.m_render->get_text_height( info.name, g.m_render->m_tahoma_12( ) );
		g.m_render->text( g.m_render->m_tahoma_12( ), box.x + box.w / 2.f, box.y - (height + 1), color( 255, 255, 255 ), info.name, Horizontal );
	}
	if ( settings::visuals::players::weapon ) {
		auto *weapon = static_cast< weapon_t * >(g.m_interfaces->entity_list( )->get_client_entity_handle( ent->active_weapon( ) ));
		if ( weapon ) {
			auto *const weapon_data = g.m_interfaces->weapon_system( )->get_weapon_data( weapon->item_definition_index( ) );
			if ( weapon_data ) {
				std::string name = weapon_data->m_weapon_name;
				if ( name.find( "weapon_" ) != std::string::npos )
					name = name.substr( 7 );
				g.m_render->text( g.m_render->m_tahoma_12( ), box.x + box.w / 2.f, box.y + box.h + 1, color( 255, 255, 255 ), name.c_str( ), Horizontal );
			}
		}
	}
	//	auto& info = g_player_manager.m_ents[ent->index() - 1];
	//	if (!info.m_records.empty()) {
	//		auto const& record = info.m_records[0];
	//		if ( record ) {
	//			std::string name = std::to_string( record->m_anim_velocity.length( ) );
	//			g.m_render->text( g.m_render->m_tahoma_12( ), box.x + box.w / 2.f, box.y + box.h + 1, color( 255, 255, 255 ), name.c_str( ), 1 );
	//		}
	//	}
}

void esp_t::weapon ( entity_t *ent ) {
	
}

```

`solace-csgo/esp.h`:

```h
#pragma once
#include "windows.h"
class area_t;
class player_t;
class entity_t;
class esp_t {
public:
	static void run ( );
	static void smoke( entity_t* ent );
	static void flying_grenade ( entity_t *ent );
	static void molotov(entity_t* ent);
	static void inferno( entity_t* ent );
	static void NoSmoke ( );
	static bool get_player_box( player_t *player, area_t *box );
	static void offscreen ( player_t *ent );
	static void player ( player_t *ent );
	static void weapon( entity_t *ent );
} inline g_esp;


```

`solace-csgo/event_listener.h`:

```h
#pragma once

#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <string>

#include "memory_shit.h"

enum CSRoundEndReason {
	UNKNOWN1 = 0,
	BOMB_DETONATED,			// terrorists planted bomb and it detonated.
	UNKNOWN2,
	UNKNOWN3,
	T_ESCAPED,				// dunno if used.
	CT_STOPPED_ESCAPE,		// dunno if used.
	T_STOPPED,				// dunno if used
	BOMB_DEFUSED,			// counter-terrorists defused the bomb.
	CT_WIN,					// counter-terrorists killed all terrorists.
	T_WIN,					// terrorists killed all counter-terrorists.
	ROUND_DRAW,				// draw ( likely due to time ).
	HOSTAGE_RESCUED,		// counter-terrorists rescued a hostage.
	CT_WIN_TIME,
	T_WIN_TIME,
	T_NOT_ESACPED,
	UNKNOWN4,
	GAME_START,
	T_SURRENDER,
	CT_SURRENDER,
};


class CKeyValuesSystem {
public:
	virtual void		RegisterSizeofKeyValues( int size ) = 0;
	virtual void *AllocKeyValuesMemory( int size ) = 0;
	virtual void		FreeKeyValuesMemory( void *pMem ) = 0;
	virtual int			GetSymbolForString( const char *name, bool bCreate = true ) = 0;
	virtual const char *GetStringForSymbol( int symbol ) = 0;
	virtual void		AddKeyValuesToMemoryLeakList( void *pMem, int name ) = 0;
	virtual void		RemoveKeyValuesFromMemoryLeakList( void *pMem ) = 0;

	template< typename T = CKeyValuesSystem * >
	static __forceinline T KeyValuesSystem( ) {
		static auto KeyValuesFactory = reinterpret_cast< uintptr_t >(GetProcAddress( GetModuleHandleA( "vstdlib.dll" ),
		                                                                             ("KeyValuesSystem") ));
		return reinterpret_cast< T(*) ( ) >(KeyValuesFactory)( );
	}
};

class KeyValues {
protected:
	enum types_t {
		TYPE_NONE = 0,
		TYPE_STRING,
		TYPE_INT,
		TYPE_FLOAT,
		TYPE_PTR,
		TYPE_WSTRING,
		TYPE_COLOR,
		TYPE_UINT64,
		TYPE_NUMTYPES,
	};

public:
	__forceinline KeyValues *FindKey( std::string name ) {

		CKeyValuesSystem *system = CKeyValuesSystem::KeyValuesSystem( );

		if ( !system )
			return nullptr;

		for ( KeyValues *dat = this->m_sub; dat != nullptr; dat = dat->m_peer ) {
			const char *string = system->GetStringForSymbol( dat->m_key_name_id );

			if ( string && string == name )
				return dat;
		}

		return nullptr;
	}

	int __forceinline GetInt( int default_value = 0 ) const {
		int result{};

		switch ( this->m_data_type ) {
		case TYPE_STRING:
			result = atoi( this->m_string );
			break;
		case TYPE_WSTRING:
			result = _wtoi( this->m_wide_string );
			break;
		case TYPE_FLOAT:
			result = static_cast< signed int >(std::floor( this->m_float_value ));
			break;
		case TYPE_UINT64:
			result = 0;
			break;
		default:
			result = this->m_int_value;
			break;
		}

		return( result ? result : default_value );
	}

	bool __forceinline GetBool( ) const {
		return !!GetInt( );
	}

	float __forceinline GetFloat( ) const {
		switch ( this->m_data_type ) {
		case TYPE_STRING:
			return static_cast< float >(atof( this->m_string ));
		case TYPE_WSTRING:
			return static_cast< float >(_wtof( this->m_wide_string ));
		case TYPE_FLOAT:
			return this->m_float_value;
		case TYPE_INT:
			return static_cast< float >(this->m_int_value);
		case TYPE_UINT64:
			return static_cast< float >(*((uint64_t *)this->m_string));
		case TYPE_PTR:
		default:
			return 0.0f;
		};
	}

	uint32_t m_key_name_id : 24;
	uint32_t m_key_name_case_sensitive : 8;

	char *m_string;
	wchar_t *m_wide_string;

	union {
		int           m_int_value;
		float         m_float_value;
		void *m_ptr_value;
		unsigned char m_color_value[ 4 ];
	};

	char m_data_type;
	char m_has_escape_sequences;

	char pad[ 0x2 ];

	KeyValues *m_peer;
	KeyValues *m_sub;
	KeyValues *m_chain;
};

class CGameEventCallback {
public:
	void *m_callback;
	int   m_listener_type;
};

class CGameEventDescriptor {
public:
	char							  m_name[ 32 ];
	int								  m_id;
	KeyValues *m_keys;
	bool							  m_is_local;
	bool							  m_is_reliable;
	CUtlVector< CGameEventCallback * > m_listeners;
};

class IGameEvent {
public:
	CGameEventDescriptor *m_descriptor;
	KeyValues *m_keys;

	virtual ~IGameEvent( ) { };
	virtual const char *GetName( ) const = 0;
	virtual bool IsReliable( ) const = 0;
	virtual bool IsLocal( ) const = 0;
	virtual bool IsEmpty( const char *keyName = nullptr ) = 0;
	virtual bool GetBool( const char *keyName = nullptr, bool defaultValue = false ) = 0;
	virtual int GetInt( const char *keyName = nullptr, int defaultValue = 0 ) = 0;
	virtual unsigned long long GetUint64( char const *keyName = nullptr, unsigned long long defaultValue = 0 ) = 0;
	virtual float GetFloat( const char *keyName = nullptr, float defaultValue = 0.0f ) = 0;
	virtual const char *GetString( const char *keyName = nullptr, const char *defaultValue = "" ) = 0;
	virtual const wchar_t *GetWString( char const *keyName = nullptr, const wchar_t *defaultValue = L"" ) = 0;
	virtual void SetBool( const char *keyName, bool value ) = 0;
	virtual void SetInt( const char *keyName, int value ) = 0;
	virtual void SetUInt64( const char *keyName, unsigned long long value ) = 0;
	virtual void SetFloat( const char *keyName, float value ) = 0;
	virtual void SetString( const char *keyName, const char *value ) = 0;
	virtual void SetWString( const char *keyName, const wchar_t *value ) = 0;
};

class IGameEventListener2 {
public:
	virtual	~IGameEventListener2( void ) { };
	virtual void FireGameEvent( IGameEvent *event ) = 0;
	virtual int getEventDebugId( ) { return 42; }
};

class IGameEventManager2 {
public:

	bool AddListener( IGameEventListener2 *listener, const char *name, bool bServerSide ) {
		return util::get_virtual_function<bool( __thiscall * )( void *, IGameEventListener2 *, const char *, bool )>( this, 3 )( this, listener, name, bServerSide );
	}
	void RemoveListener( IGameEventListener2 *listener ){
		util::get_virtual_function<void( __thiscall * )( void *, IGameEventListener2 * )>( this, 5 )( this, listener );
	}

	/*bool __forceinline add_listener_internal( IGameEventListener2 *listener, CGameEventDescriptor *descriptor, bool serverside ) {
		// char __thiscall CGameEventManager::AddListener_Internal( void *this, int listener, int a3, bool serverside )
		// 55 8B EC 83 EC 08 8B C1 56 57
		// return GameEventManager::AddListener_Internal( this, listener, descriptor, serverside == false );
	}
	bool __forceinline add_listener_by_hash( IGameEventListener2 *listener, hash_t hash, bool serverside ) {
		CGameEventDescriptor *descriptor;
		for( int i{}; i < m_events.count( ); i++ ) {
			descriptor = &m_events.element( i );
			if( !descriptor )
				continue;
			if( hash::fnv1a( descriptor->m_name ) == hash )
				break;
			else
				descriptor = nullptr;
		}
		if( !descriptor )
			return false;
		return add_listener_internal( listener, descriptor, serverside );
	}*/
};
```

`solace-csgo/events.cpp`:

```cpp
#include "events.h"

#include "resolver.h"

#include "includes.h"

class hurt_listener final : IGameEventListener2 {
	void FireGameEvent( IGameEvent *evt ) override {
		g_resolver.OnHurt( evt );
	}
public:
	void init( IGameEventManager2 *game_events ) {
		game_events_ = ( game_events );
		game_events_->AddListener( this, "player_hurt", false );
	}
	~hurt_listener( ) {
		game_events_->RemoveListener( this );
	}
private:
	IGameEventManager2 *game_events_;
} hurt_listener;

class impact_listener final : IGameEventListener2 {
	void FireGameEvent( IGameEvent *evt ) override {
		g_resolver.on_impact( evt );
	}
public:
	void init( IGameEventManager2 *game_events ) {
		game_events_ = ( game_events );
		game_events_->AddListener( this, "bullet_impact", false );
	}
	~impact_listener( ) {
		game_events_->RemoveListener( this );
	}
private:
	IGameEventManager2 *game_events_;
} impact_listener;

class start_listener final : public IGameEventListener2 {
	void FireGameEvent( IGameEvent *evt ) override {
		g_resolver.clear( );
		g.m_valid_round = true;
	}
public:
	void init( IGameEventManager2 *game_events ) {
		game_events_ = ( game_events );
		game_events_->AddListener( this, "round_start", false );
	}
	~start_listener( ) {
		game_events_->RemoveListener( this );
	}
private:
	IGameEventManager2 *game_events_;
} start_listener;

class end_listener final : public IGameEventListener2 {
	void FireGameEvent( IGameEvent *evt ) override {
		g.m_valid_round = false;
		g.m_cmds.clear( );
	}
public:
	void init( IGameEventManager2* game_events ) {
		game_events_ = ( game_events );
		game_events_->AddListener( this, "round_end", false );
	}
	~end_listener( ) {
		game_events_->RemoveListener( this );
	}
private:
	IGameEventManager2 *game_events_;
} end_listener;

void events::init( ) {
	hurt_listener.init( g.m_interfaces->events( ) );
	impact_listener.init( g.m_interfaces->events( ) );
	start_listener.init( g.m_interfaces->events( ) );
	end_listener.init( g.m_interfaces->events( ) );
}

void events::destroy( ) {
	hurt_listener.~hurt_listener( );
	impact_listener.~impact_listener( );
	start_listener.~start_listener( );
	end_listener.~end_listener( );
}

void events::player_hurt( IGameEvent *evt ) {
	g_resolver.OnHurt( evt );
}

void events::bullet_impact( IGameEvent *evt ) {
	g_resolver.on_impact( evt );
}

void events::round_start( IGameEvent *evt ) {
	g_resolver.clear( );
	g.m_valid_round = true;
}

void events::round_end ( IGameEvent *evt ) {
	g.m_valid_round = false;
}

```

`solace-csgo/events.h`:

```h
#pragma once
#include <map>
#include <string>
#include <vector>

#include "includes.h"

namespace events {
	void round_start( IGameEvent *evt );
	void init( );
	void destroy( );
	void player_hurt ( IGameEvent *evt );
	void bullet_impact ( IGameEvent *evt );
	void round_end( IGameEvent *evt );
}
```

`solace-csgo/fnv.h`:

```h
#pragma once

namespace fnv_1a {
	template< typename S >
	struct fnv_internal;
	template< typename S >
	struct fnv1a;

	template< >
	struct fnv_internal< uint32_t > {
		constexpr static uint32_t default_offset_basis = 0x811C9DC5;
		constexpr static uint32_t prime = 0x01000193;
	};

	template< >
	struct fnv1a< uint32_t > : public fnv_internal< uint32_t > {
		constexpr static uint32_t hash( char const *string, const uint32_t val = default_offset_basis ) {
			return ( string[ 0 ] == '\0' )
				? val
				: hash( &string[ 1 ], ( val ^ uint32_t( string[ 0 ] ) ) * prime );
		}

		constexpr static uint32_t hash( wchar_t const *string, const uint32_t val = default_offset_basis ) {
			return ( string[ 0 ] == L'\0' )
				? val
				: hash( &string[ 1 ], ( val ^ uint32_t( string[ 0 ] ) ) * prime );
		}
	};
}

using fnv = fnv_1a::fnv1a< uint32_t >;
```

`solace-csgo/g.cpp`:

```cpp
#include <mutex>



#include "aimbot.h"
#include "block_bot.h"
#include "bones.h"
#include "includes.h"
#include "hooks.h"
#include "esp.h"
#include "events.h"
#include "hvh.h"
#include "menu.hh"
#include "movement.h"
#include "notification.h"
#include "prediction.h"
#include "predictioncopy.h"
#include "resolver.h"
#include "input_helper/input_helper.hh"
#include <cassert>

void c_g::init_cheat( ) {
	random_seed = reinterpret_cast< random_seed_t >( GetProcAddress( GetModuleHandleA( "vstdlib.dll" ), "RandomSeed" ) );
	random_int = reinterpret_cast< random_int_t >( GetProcAddress( GetModuleHandleA( "vstdlib.dll" ), "RandomInt" ) );
	random_float = reinterpret_cast< random_float_t >( GetProcAddress( GetModuleHandleA( "vstdlib.dll" ), "RandomFloat" ) );
	events::init( );
	menu.init( );
}

void c_g::ModifyEyePosition( anim_state* state, matrix_t* mat, vec3_t* pos ) {
	//  if ( *(this + 0x50) && (*(this + 0x100) || *(this + 0x94) != 0.0 || !sub_102C9480(*(this + 0x50))) )
	state->m_bSmoothHeightValid = false;
	if ( state->m_player &&
		( state->m_land || state->m_player->duck_amount( ) != 0.f || !state->m_player->m_ground_entity( ) ) ) {
		const auto v5 = 8;

		if constexpr ( v5 != -1 ) {
			const vec3_t head_pos(
				mat[ 8 ][ 0 ][ 3 ],
				mat[ 8 ][ 1 ][ 3 ],
				mat[ 8 ][ 2 ][ 3 ] );

			const auto v12 = head_pos;
			const float v7 = v12.z + 1.7;

			const auto v8 = pos->z;
			if ( v8 > v7 ) // if (v8 > (v12 + 1.7))
			{
				auto v13 = 0.f;
				const auto v3 = pos->z - v7;

				const float v4 = ( v3 - 4.f ) * 0.16666667;
				if ( v4 >= 0.f )
					v13 = std::fminf( v4, 1.f );

				pos->z = static_cast< float >( ( ( v7 - ( *pos ).z ) ) * ( ( static_cast< double >( v13 ) * v13 * 3.0 ) - ( static_cast< double >( v13 ) * v13 * 2.0 * v13 ) ) ) + ( *pos ).z;
			}
		}
	}
}

void c_g::release ( ) const {
	if ( m_pStartData ) {
		g.m_interfaces->mem_alloc( )->free( m_pStartData );
		g.m_interfaces->mem_alloc( )->free( m_pEndData );
		g.m_interfaces->mem_alloc( )->free( m_pPostPred );
	}
	events::destroy( );
}

void c_g::on_render ( IDirect3DDevice9 *device ) {
	m_render->setup(device);
	m_render->start( );

	input_helper.update( );
	

	for ( auto &it : menu.n_binds )
		it->update( );
	
	menu.update( );
	
	m_local = static_cast< player_t * >( m_interfaces->entity_list(  )->get_client_entity(m_interfaces->engine()->local_player_index( ) ) );
	g_movement.draw( );
	g_esp.run( );
	g_block_bot.on_draw( );

	if ( settings::visuals::weapons::noscope ) {
		if ( g.m_local && g.m_local->is_scoped( ) ) {
			m_render->line( m_render->m_screen_size( ).Width / 2, 0, m_render->m_screen_size( ).Width / 2, m_render->m_screen_size( ).Height, color( 0, 0, 0 ), 1);
			m_render->line( 0, m_render->m_screen_size( ).Height / 2, m_render->m_screen_size( ).Width, m_render->m_screen_size( ).Height / 2, color( 0, 0, 0 ), 1);
		}
	}
	
	g_notification.think( );

	menu.draw( );

	m_render->finish( );
}

void c_g::on_tick(cmd_t* cmd) {
  m_local =
      static_cast<player_t*>(m_interfaces->entity_list()->get_client_entity(
          m_interfaces->engine()->local_player_index()));

  if (!cmd || !cmd->m_command_number) return;

  m_cmd = cmd;  // save everything we need from the engine
  m_view_angles = cmd->m_viewangles;

  if (menu.open) {
    m_cmd->m_buttons &= ~IN_ATTACK;
    m_cmd->m_buttons &= ~IN_ATTACK2;
  }

  auto* nci = g.m_interfaces->engine()->get_net_channel_info();
  if (nci) m_latency = nci->GetLatency(0);

  static auto* cl_updaterate =
      g.m_interfaces->console()->get_convar("cl_updaterate");
  static auto* sv_minupdaterate =
      g.m_interfaces->console()->get_convar("sv_minupdaterate");
  static auto* sv_maxupdaterate =
      g.m_interfaces->console()->get_convar("sv_maxupdaterate");

  static auto* sv_client_min_interp_ratio =
      g.m_interfaces->console()->get_convar("sv_client_min_interp_ratio");
  static auto* sv_client_max_interp_ratio =
      g.m_interfaces->console()->get_convar("sv_client_max_interp_ratio");

  static auto* cl_interp = g.m_interfaces->console()->get_convar("cl_interp");
  static auto* cl_interp_ratio =
      g.m_interfaces->console()->get_convar("cl_interp_ratio");

  float updaterate = cl_updaterate->GetFloat();

  float minupdaterate = sv_minupdaterate->GetFloat();
  float maxupdaterate = sv_maxupdaterate->GetFloat();

  float min_interp = sv_client_min_interp_ratio->GetFloat();
  float max_interp = sv_client_max_interp_ratio->GetFloat();

  float flLerpAmount = cl_interp->GetFloat();
  float flLerpRatio = cl_interp_ratio->GetFloat();

  flLerpRatio = std::clamp<float>(flLerpRatio, min_interp, max_interp);
  if (flLerpRatio == 0.0f) flLerpRatio = 1.0f;

  float updateRate =
      std::clamp<float>(updaterate, minupdaterate, maxupdaterate);
  m_lerp = std::fmaxf(cl_interp->GetFloat(), cl_interp_ratio->GetFloat() / cl_updaterate->GetFloat());

  if (m_local && m_local->alive()) {
    prediction::update();

    m_running_client = true;
    m_flags = m_local->flags();
    m_onground = (m_flags & fl_onground);
  } else {
    m_running_client = false;
    return;
  }

  // if ( m_local ) {
  //	CPredictionCopy CopyHelper( PC_EVERYTHING, m_pStartData, PC_DATA_PACKED,
  //m_local, PC_DATA_NORMAL ); 	memcpy( m_pEndData, m_pStartData, sz );
  //}

  m_last_lag = m_lag;
  m_lag = g.m_interfaces->client_state()->chokedcommands;

  // cmd->m_buttons |= IN_BULLRUSH; // allow unlimited ducking

  g_block_bot
      .on_tick();  // run all of our movement changing code before prediction
  g_movement.auto_strafe();
  g_movement.DoPrespeed();
  // g_movement.edge_bug( );
  g_movement.bhop();
  g_hvh.fake_walk();
  g_movement.auto_peek();
  g_movement.PreciseMove();
  g_hvh.SendPacket();
  g_hvh.break_resolver();
  g_movement.QuickStop();


  if (start_move(m_cmd)) {
    if (g.m_weapon) {
      if (g.m_weapon->postpone_fire_time() - 0.1f >
              g.ticks_to_time(g.m_local->tick_base()) &&
          g.m_weapon->postpone_fire_time() < FLT_MAX) {
        g.m_cmd->m_buttons &= ~IN_ATTACK;
      }
    }  // else
     //g.m_cmd->m_buttons |= IN_ATTACK;
    g_aimbot.on_tick();
    ang_t view_angles;
    g.m_interfaces->engine()->get_view_angles(view_angles);
    g_hvh.m_view_angle = view_angles.y;
    g_hvh.AntiAim();

    if (g.m_can_shift && g.m_can_fire && (m_cmd->m_buttons & IN_ATTACK))
      g.m_shift = true;

    if (g.m_shift) *g.m_packet = false;

    m_cmd->m_viewangles.y = math::normalize_angle(
        m_cmd->m_viewangles.y, 180.f);  // clamp view to bounds, avoid kicks etc
    m_cmd->m_viewangles.x =
        std::clamp<float>(m_cmd->m_viewangles.x, -89.f, 89.f);
    m_cmd->m_viewangles.z = 0;
    math::correct_movement(m_cmd);
  }
  end_move(m_cmd);
}

void c_g::SetAngles( ) const {
	if ( !m_local || !m_running_client )
		return;

	// set the nointerp flag.
	m_local->m_fEffects( ) |= 0x008;

	// apply the rotation.
	m_local->set_abs_angles( m_rotation );
	m_local->m_angRotation( ) = m_rotation;
	//m_local->m_angNetworkAngles( ) = m_rotation;

	// set radar angles.
	//if ( m_interfaces->input(  )->camera_is_third_person( ) )
	//	m_interfaces->prediction(  )->SetLocalViewAngles( m_radar );
}

void c_g::UpdateAnimations( ) const {
	if ( !m_local || !m_running_client )
		return;

	auto* state = m_local->get_anim_state( );
	if ( !state )
		return;

	// prevent model sway on player.
	m_local->anim_overlay( )[ 12 ].m_weight = 0.f;

	// update animations with last networked data.
	m_local->SetPoseParameters( g.m_poses );

	// update abs yaw with last networked abs yaw.
	m_local->set_abs_angles( ang_t( 0.f, g.m_abs_yaw, 0.f ) );
}

const char* const g_szWeaponPrefixLookupTable[] = {"knife",  "pistol", "smg", "rifle",   "shotgun",
                                                   "sniper", "heavy",  "c4",  "grenade", "knife"};
const char* c_g::GetWeaponPrefix(anim_state *state)
{
    static auto sig = util::find("client.dll", "53 56 8B F1 57 33 FF 8B 4E ? 8B 01");
    return ((const char*(__thiscall*)(void*))sig)(state);
}

void c_g::UpdateInformation( ) {
	if ( g.m_lag > 0 ) {
		//float flPitch = ( g.m_cmd->m_viewangles.x + 90.f ) / 180.f;
		//
		//g.m_poses[ 12 ] = flPitch;
		//
		//g.m_local->SetAnimLayers( g.m_layers );
		//g.m_local->SetPoseParameters( g.m_poses );
		//m_local->set_abs_angles( ang_t( 0.f, g.m_abs_yaw, 0.f ) );
		//
		//g.m_interfaces->mdlcache( )->begin_coarse_lock( );
		//g.m_interfaces->mdlcache( )->begin_lock( );
		//g.m_bones_setup = g_bones.BuildBonesStripped( m_local, bone_used_by_anything, g.m_real_bones, &g.m_ipk );
		//g.m_interfaces->mdlcache( )->end_lock( );
		//g.m_interfaces->mdlcache( )->end_coarse_lock( );
		//if ( g.m_bones_setup ) {
		//	const auto abs_origin = g.m_local->origin( );
		//	for ( auto i = 0; i < 128; i++ ) {
		//		g.m_real_bones[ i ].mat_val[ 0 ][ 3 ] -= abs_origin.x;
		//		g.m_real_bones[ i ].mat_val[ 1 ][ 3 ] -= abs_origin.y;
		//		g.m_real_bones[ i ].mat_val[ 2 ][ 3 ] -= abs_origin.z;
		//	}
		//}
		return;
	}
	auto* state = g.m_local->get_anim_state( );
	if ( !state )
		return;
	if ( !g.m_real_bones )
		g.m_real_bones = static_cast< bone_array_t* >( g.m_interfaces->mem_alloc( )->alloc( sizeof( bone_array_t ) * 128 ) );
	if (g.m_local->spawn_time() != spawn_time) {
		// reset animation state.
        state->ResetAnimationState();
	
		// note new spawn time.
		spawn_time = g.m_local->spawn_time();
	}
	g_hvh.m_side = -g_hvh.m_side;
	// update time.
	m_anim_frame = g.m_interfaces->globals(  )->m_curtime - m_anim_time;
	m_anim_time = g.m_interfaces->globals()->m_curtime;

	// current angle will be animated.
	m_angle = g.m_cmd->m_viewangles;

	m_angle.x = std::clamp( m_angle.x, -90.f, 90.f );
	

	// write angles to model.
	g.m_interfaces->prediction(  )->SetLocalViewAngles( m_angle );

	// set lby to predicted value.
	m_local->lower_body_yaw( ) = m_body;
	m_local->eye_angles() = m_angle;

	// call original, bypass hook.
	bool moveRight = (g.m_cmd->m_buttons & (IN_MOVERIGHT)) != 0;
	bool moveLeft = (g.m_cmd->m_buttons & (IN_MOVELEFT)) != 0;
	bool moveForward = (g.m_cmd->m_buttons & (IN_FORWARD)) != 0;
	bool moveBackward = (g.m_cmd->m_buttons & (IN_BACK)) != 0;

	//Vector vForward, vRight;
	//AngleVectors( QAngle(0,m_flEyeYaw,0), &vForward, &vRight, NULL );
	//vForward *= 10;
	//vRight *= 10;
	//if ( moveRight )
	//	debugoverlay->AddTriangleOverlay( m_vecPositionCurrent + vRight * 2, m_vecPositionCurrent - vForward, m_vecPositionCurrent + vForward, 200, 0, 0, 255, true, 0 );
	//if ( moveLeft )
	//	debugoverlay->AddTriangleOverlay( m_vecPositionCurrent - vRight * 2, m_vecPositionCurrent + vForward, m_vecPositionCurrent - vForward, 200, 0, 0, 255, true, 0 );
	//if ( moveForward )
	//	debugoverlay->AddTriangleOverlay( m_vecPositionCurrent + vForward * 2, m_vecPositionCurrent + vRight, m_vecPositionCurrent - vRight, 200, 0, 0, 255, true, 0 );
	//if ( moveBackward )
	//	debugoverlay->AddTriangleOverlay( m_vecPositionCurrent - vForward * 2, m_vecPositionCurrent + vRight, m_vecPositionCurrent - vRight, 200, 0, 0, 255, true, 0 );

	vec3_t vecForward;
	vec3_t vecRight;
	ang_t(0, state->m_cur_feet_yaw, 0).vectors(&vecForward, &vecRight, nullptr);
	vecRight.normalize();
	float m_flVelocityLengthXY = fminf(g.m_local->velocity().length(), 260.0f); 
	vec3_t m_vecVelocityNormalizedNonZero = state->m_vecVelocityNormalizedNonZero;
	if (m_flVelocityLengthXY > 0)
	{
		m_vecVelocityNormalizedNonZero = g.m_local->velocity().normalized();
	}

	float flMaxSpeedRun = g.m_weapon_info ? fmaxf(g.m_weapon_info->m_max_player_speed, 0.001f) : 260.0f;
	float m_flSpeedAsPortionOfWalkTopSpeed = m_flVelocityLengthXY / (flMaxSpeedRun * 0.52f);


	float flVelToRightDot = m_vecVelocityNormalizedNonZero.dot(vecRight);
	float flVelToForwardDot = m_vecVelocityNormalizedNonZero.dot(vecForward);

	//bool bPreviouslyOnLadder = state->m_bOnLadder;
	//bool m_bOnLadder = !m_local->m_ground_entity( ) && m_local->move_type( ) == MoveType_t::MOVETYPE_LADDER;
	//bool bStartedLadderingThisFrame = ( !bPreviouslyOnLadder && m_bOnLadder );
	//bool bStoppedLadderingThisFrame = ( bPreviouslyOnLadder && !m_bOnLadder );
	//
	//if ( state->m_flLadderWeight > 0 || m_bOnLadder ) {
	//	if ( bStartedLadderingThisFrame ) {
	//		m_local->anim_overlay()[ ]( ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB, SelectSequenceFromActMods( ACT_CSGO_CLIMB_LADDER ) );
	//	}
	//}
	
	// We're interested in if the player's desired direction (indicated by their held buttons) is opposite their current velocity.
	// This indicates a strafing direction change in progress.
	bool bStrafeRight = (m_flSpeedAsPortionOfWalkTopSpeed >= 0.73f && moveRight && !moveLeft && flVelToRightDot < -0.63f);
	bool bStrafeLeft = (m_flSpeedAsPortionOfWalkTopSpeed >= 0.73f && moveLeft && !moveRight && flVelToRightDot > 0.63f);
	bool bStrafeForward = (m_flSpeedAsPortionOfWalkTopSpeed >= 0.65f && moveForward && !moveBackward && flVelToForwardDot < -0.55f);
	bool bStrafeBackward = (m_flSpeedAsPortionOfWalkTopSpeed >= 0.65f && moveBackward && !moveForward && flVelToForwardDot > 0.55f);
	*(bool*)(g.m_local + 14816) = (bStrafeRight || bStrafeLeft || bStrafeForward || bStrafeBackward);
	g.m_hooks->players_hook( g.m_local->index( ) - 1 )->get_original< void( __thiscall * ) ( player_t * ) >( 218 )( g.m_local );

    m_activity.add_modifier(GetWeaponPrefix(state));

	if ( state->m_flSpeedAsPortionOfWalkTopSpeed > 0.25 )
		m_activity.add_modifier( "moving" );
	if ( state->m_dip_cycle > 0.55000001 )
		m_activity.add_modifier( "crouch" );

	// store updated abs yaw.
	m_abs_yaw = state->m_goal_feet_yaw;// *(float*)(m_animstate + 112);

	// we landed.
	if ( !m_ground && state->m_ground ) {// *(bool*)(m_animstate + 248)) {

		m_body = m_angle.y;
		m_body_pred = m_anim_time;
	}

	// walking, delay lby update by .22.
	else if ( state->m_speed > 0.1f ) { //if (*(float*)(m_animstate + 55) > 0.1f ) {
		if ( state->m_ground )//if (*(bool*)(m_animstate + 248) )
			m_body = m_angle.y;

		m_body_pred = m_anim_time + 0.22f;
	}

	// standing update every 1.1s
	else if ( m_anim_time >= g.m_body_pred ) {
		m_body = m_angle.y;
		m_body_pred = m_anim_time + 1.1f;
	}

	// save updated data.
	m_rotation = m_local->m_angAbsRotation( );
	m_speed = state->m_speed;// *(float*)(m_animstate + 55);
	m_ground = state->m_ground;// *(bool*)(m_animstate + 248);

	m_local->GetPoseParameters( m_poses );
	m_local->GetAnimLayers( m_layers );

	weapon_world_model_t* weapon_world_model = nullptr;
	if ( g.m_weapon ) {
		weapon_world_model = static_cast< weapon_world_model_t* >( g.m_interfaces->entity_list( )->get_client_entity_handle(
			g.m_weapon->weapon_model( ) ) );
		if ( weapon_world_model ) {

			const auto weapon_studio_hdr = weapon_world_model->GetModelPtr( );
			if ( weapon_studio_hdr ) {
				for ( auto i = 0; i < 15; i++ ) {
					auto* pLayer = &g.m_local->anim_overlay( )[ i ];
					if ( pLayer->m_sequence <= 1 || pLayer->m_cycle <= 0.f ) {
						g.m_local->UpdateDispatchLayer( pLayer, weapon_studio_hdr, pLayer->m_sequence );
					}
				}
			}
		}
	}

	//if (state->m_ground) {
	//	if (state->m_land) {
	//		
	//	}
	//}

	//m_animstate->update( g.m_local->eye_angles( ) );

	g.m_interfaces->mdlcache()->begin_coarse_lock();
	g.m_interfaces->mdlcache()->begin_lock();
	g.m_bones_setup = g_bones.BuildBonesStripped( m_local, bone_used_by_anything & ~bone_used_by_bone_merge, g.m_real_bones, &g.m_ipk );
	g.m_interfaces->mdlcache()->end_lock();
	g.m_interfaces->mdlcache()->end_coarse_lock();
	if( g.m_bones_setup ) {
		const auto abs_origin = g.m_local->origin( );
		for ( auto i = 0; i < 128; i++ ) {
			g.m_real_bones[i].mat_val[ 0 ][ 3 ] -= abs_origin.x;
			g.m_real_bones[i].mat_val[ 1 ][ 3 ] -= abs_origin.y;
			g.m_real_bones[i].mat_val[ 2 ][ 3 ] -= abs_origin.z;
		}
	}

}

int c_g::time_to_ticks ( float time ) const {
	return static_cast< int >( 0.5f + (time / m_interfaces->globals( )->m_interval_per_tick));
}

float c_g::ticks_to_time( int ticks) const {
	return static_cast< float >( ticks ) * m_interfaces->globals( )->m_interval_per_tick;
}

bool c_g::can_weapon_fire( ) const {
	// the player cant fire.
	if ( !m_player_fire )
		return false;

	if ( m_weapon_type == WEAPONTYPE_GRENADE )
		return false;

	if ( m_weapon_type == WEAPONTYPE_KNIFE || m_weapon->clip1_count( ) < 1 )
		return false;
	
	if ( ( static_cast< float >(g.m_local->tick_base( )) * g.m_interfaces->globals( )->m_interval_per_tick ) >= m_weapon->next_primary_attack( ) )
		return true;

	return false;
}

void UTIL_FieldHighLowTickBase(int* high, int* low, int* ideal) {
	auto* sv_clockcorrection_msecs = g.m_interfaces->console()->get_convar("sv_clockcorrection_msecs");
	float flCorrectionSeconds = std::clamp(sv_clockcorrection_msecs->GetFloat() / 1000.0f, 0.0f, 1.0f);
	int nCorrectionTicks = g.time_to_ticks(flCorrectionSeconds);

	// Set the target tick flCorrectionSeconds (rounded to ticks) ahead in the future. this way the client can
	//  alternate around this target tick without getting smaller than gpGlobals->tickcount.
	// After running the commands simulation time should be equal or after current gpGlobals->tickcount, 
	//  otherwise the simulation time drops out of the client side interpolated var history window.

	auto latency = 0.f;
	auto* net = g.m_interfaces->engine( )->get_net_channel_info( );
	if ( net )
		latency += net->GetLatency( 0 );

	int	nIdealFinalTick = g.m_interfaces->globals()->m_tickcount + g.time_to_ticks( latency ) + nCorrectionTicks;
	auto simulation_ticks = g.m_interfaces->client_state()->chokedcommands;

	// If client gets ahead of this, we'll need to correct
	*high = nIdealFinalTick + nCorrectionTicks;
	// If client falls behind this, we'll also need to correct
	*low = nIdealFinalTick - nCorrectionTicks;

	*ideal = nIdealFinalTick - simulation_ticks;
}

void UTIL_EmplaceTickBaseShift(int high, int low, int ideal, int ticks) {
    auto simulation_ticks = g.m_interfaces->client_state()->chokedcommands;
	int nEstimatedFinalTick = g.m_local->tick_base( ) + simulation_ticks;
	if ( nEstimatedFinalTick > high ||
		nEstimatedFinalTick < low ) {
		int nCorrectedTick = ideal - simulation_ticks + ticks + 1;
		g.m_local->tick_base( ) = nCorrectedTick;
	}
}

void c_g::add_tickbase_log( int cmd_num, int tick_base ) {
	m_tick_base_log.emplace_back( cmd_num, tick_base );
	if ( m_tick_base_log.size( ) > 256 )
		m_tick_base_log.pop_back( );
}
void c_g::get_tickbase_log( int cmd_num, int *tick_base ) {
	for ( auto& i : m_tick_base_log ) {
		if ( i.first == cmd_num )
			*tick_base = i.second;
	}
}

void c_g::on_move ( float accumulated_extra_samples, bool bFinalTick, cl_move_t cl_move ) { // doesnt work for now, will update later

	//static auto *sv_maxusrcmdprocessticks = g.m_interfaces->console( )->get_convar( "sv_maxusrcmdprocessticks" );
	//const auto iProcessTicks = sv_maxusrcmdprocessticks->GetInt( );
	//auto iMaxExtraTicks = 15;
	//m_local = static_cast<player_t*>(m_interfaces->entity_list()->get_client_entity(m_interfaces->engine()->local_player_index()));
	//if (!m_local || !m_local->alive()) {
	//	cl_move(accumulated_extra_samples, bFinalTick);
	//	return;
	//}
	//
	//if ( iMaxExtraTicks > iProcessTicks - 1 ) {
	//	iMaxExtraTicks = iProcessTicks - 1;
	//}
	//
	//if ( m_available_ticks < iMaxExtraTicks ) {
	//	m_available_ticks++;
	//	m_can_shift = false;
	//	m_shift = false;
	//	return;
	//}
	//
	//m_can_shift = true;
	static auto* frame_ticks = util::find( "engine.dll", "2B 05 ? ? ? ? 03 05 ? ? ? ? 83 CF ?" ) + 2;
	auto iTicksThisCommand = **reinterpret_cast< int** >( frame_ticks );
	cl_move( accumulated_extra_samples, bFinalTick );

	if ( g.m_local && g.m_local->alive() ) {
		int high, low, ideal;
		UTIL_FieldHighLowTickBase( &high, &low, &ideal );

		const int iSequence =
            g.m_interfaces->client_state()->lastoutgoingcommand + g.m_interfaces->client_state()->chokedcommands;
		const cmd_t* const pCmd = g.m_interfaces->input( )->get_user_cmd( 0, iSequence );

		assert( pCmd );
		if ( pCmd ) {
			//make sure we start in the right spot

			get_tickbase_log( pCmd->m_command_number, &g.m_local->tick_base( ) );
		}
		UTIL_EmplaceTickBaseShift( high, low, ideal, iTicksThisCommand );
	}
	//m_can_shift = false;

	//auto iExtraTicks = 0;
	//if( m_shift )
	//	for ( auto i = 1; i < m_available_ticks; i++ ) {
	//		if ( iTicksThisCommand >= iProcessTicks ||
	//			 iTicksThisCommand > 15 ||
	//			 iExtraTicks >= 15 ) {
	//			break;
	//		}
	//		
	//		m_available_ticks--;
	//		iTicksThisCommand++;
	//		iExtraTicks++;
	//
	//		m_shift = (iTicksThisCommand >= iProcessTicks ||
	//			iTicksThisCommand > 15 ||
	//			iExtraTicks >= 15);
	//
	//		cl_move( accumulated_extra_samples, m_shift );
	//	}
	//m_shift = false;
}

void c_g::UpdateIncomingSequences( i_net_channel *net ) {
	if ( m_sequences.empty( ) || net->m_in_seq > m_sequences.front( ).m_seq ) {
		// store new stuff.
		m_sequences.emplace_front( g.m_interfaces->globals(  )->m_curtime, net->m_in_rel_state, net->m_in_seq );
	}

	// do not save too many of these.
	while ( m_sequences.size( ) > 2048 )
		m_sequences.pop_back( );
}

void c_g::net_data_received ( ) const {
	if ( m_pEndData ) {
		CPredictionCopy CopyHelper( PC_EVERYTHING, m_pEndData, TD_OFFSET_PACKED, reinterpret_cast< byte * >(m_local), TD_OFFSET_NORMAL, CPredictionCopy::TRANSFERDATA_COPYONLY );
		CopyHelper.TransferData( "net_data_received", m_local->index( ), m_local->GetPredDescMap( ) );
	}
}

bool c_g::start_move( cmd_t *cmd ) {
	add_tickbase_log( cmd->m_command_number, g.m_local->tick_base() );
	m_can_fire = false;
	m_weapon = static_cast< weapon_t * >( g.m_interfaces->entity_list( )->get_client_entity_handle( m_local->active_weapon( ) ) );
	m_origin = m_local->origin( );
	m_max_lag = ( m_local->flags( ) & fl_onground ) ? 16 : 15; // set max packet choking

	auto* map = m_local->GetPredDescMap( );

	if ( map ) {
		const auto size = max( map->m_packed_size, 4 );
		if ( !m_pStartData ) {
			m_pStartData = static_cast< byte* >(g.m_interfaces->mem_alloc()->alloc( sizeof(byte) * size ) ); // setup all of the datamap storage
			memset( g.m_pStartData, 0, size );
			m_pEndData = static_cast< byte* >( g.m_interfaces->mem_alloc( )->alloc( sizeof( byte ) * size ) );
			memset( g.m_pEndData, 0, size );
			m_pPostPred = static_cast< byte* >( g.m_interfaces->mem_alloc( )->alloc( sizeof( byte ) * size ) );
			memset( g.m_pPostPred, 0, size );
		}

		auto CopyHelper = CPredictionCopy( PC_EVERYTHING, static_cast< byte* >( m_pStartData ), true, reinterpret_cast< const byte* >( g.m_local ), false, CPredictionCopy::TRANSFERDATA_COPYONLY );
		CopyHelper.TransferData( "CM_Start", m_local->index( ), map ); // copy off a prestie local player datamap, used if we want to repredict

		memcpy( m_pEndData, m_pStartData, sizeof( byte ) * size ); // override 
	}

	prediction::start( cmd );
	m_speed = m_local->velocity().length();

	m_player_fire = ( g.m_local->tick_base( ) * g.m_interfaces->globals( )->m_interval_per_tick ) >= m_local->next_attack( ) && !( g.m_flags & fl_frozen );
	if ( m_weapon ) {
		m_weapon_info = g.m_interfaces->weapon_system( )->get_weapon_data( m_weapon->item_definition_index( ) );
		if ( m_weapon_info )
			m_weapon_type = m_weapon_info->m_weapon_type;
		m_can_fire = can_weapon_fire( );
	}

	generate_shoot_position( );

	if ( m_weapon )
		if ( m_weapon_type != WEAPONTYPE_GRENADE ) // ensure weapon spread values / etc are up to date.
			m_weapon->update_accuracy_penalty( );

	m_shot = false;

	if ( m_pStartData && map ) {
		CPredictionCopy CopyHelper( PC_EVERYTHING, static_cast< byte * >(m_pPostPred), true, reinterpret_cast< const byte * >(g.m_local), false, CPredictionCopy::TRANSFERDATA_COPYONLY ); //after prediction save local player datamap away incase we want to restore this
		CopyHelper.TransferData( "PostPred", m_local->index( ), map );
	}
	
	return true;
}

void c_g::generate_shoot_position( ) {
	const auto abs_origin = g.m_local->origin( ); //restore bones to the ones that will be used by the server
	auto* bone_cache = &g.m_local->bone_cache( );
	bone_array_t* backup_cache = nullptr;
	if ( bone_cache && g.m_bones_setup ) {
		for ( auto i = 0; i < 128; i++ ) {
			g.m_real_bones[ i ].mat_val[ 0 ][ 3 ] += abs_origin.x; // adjust bones positions to player origin
			g.m_real_bones[ i ].mat_val[ 1 ][ 3 ] += abs_origin.y;
			g.m_real_bones[ i ].mat_val[ 2 ][ 3 ] += abs_origin.z;
		}
		backup_cache = bone_cache->m_pCachedBones;
		bone_cache->m_pCachedBones = g.m_real_bones;
	}
	m_local->get_eye_pos( &m_shoot_pos ); // get proper shoot position, we can regenerate a more accurate one where its needed
	if ( g.m_bones_setup && bone_cache ) {
		g.ModifyEyePosition( g.m_local->get_anim_state(), g.m_real_bones, &m_shoot_pos );
		for ( auto i = 0; i < 128; i++ ) {
			g.m_real_bones[ i ].mat_val[ 0 ][ 3 ] -= abs_origin.x; // adjust bones positions back to 3d origin
			g.m_real_bones[ i ].mat_val[ 1 ][ 3 ] -= abs_origin.y;
			g.m_real_bones[ i ].mat_val[ 2 ][ 3 ] -= abs_origin.z;
		}
		bone_cache->m_pCachedBones = backup_cache;
	}
}

void c_g::end_move ( cmd_t *cmd ) {
	cmd->m_forwardmove = std::clamp<float>( cmd->m_forwardmove, -450.f, 450.f );
	cmd->m_sidemove = std::clamp<float>( cmd->m_sidemove, -450.f, 450.f );
	auto *map = g.m_local->GetPredDescMap( );
	if ( m_pStartData && map ) {
		prediction::end( ); // finish up prediction
		CPredictionCopy CopyHelper( PC_EVERYTHING, ( byte * )g.m_local, false, static_cast< const byte * >(m_pStartData), true, CPredictionCopy::TRANSFERDATA_COPYONLY );
		CopyHelper.TransferData( "CM_REPREDICT", m_local->index( ), map );
		prediction::start( g.m_cmd ); // repredict to assure, if there are any changes to the usercmd that affect the player, we wont get compounding prediction errors
	}

	if ( *m_packet ) {
		g_hvh.m_step_switch = static_cast< bool >( g.random_int( 0, 1 ) );

		// we are sending a packet, so this will be reset soon.
		// store the old value.
		m_old_lag = m_lag;

		// get radar angles.
		m_radar = cmd->m_viewangles;

		// get current origin.
		auto cur = m_local->origin( );

		// get prevoius origin.
		const auto prev = m_net_pos.empty( ) ? cur : m_net_pos.front( ).m_pos;

		// check if we broke lagcomp.
		m_lagcomp = ( cur - prev ).length_sqr( ) > 4096.f;

		// save sent origin and time.
		m_net_pos.emplace_front( g.m_interfaces->globals( )->m_curtime, cur );
	}

	UpdateInformation( );

	prediction::end( ); // finish up prediction
	if ( m_pEndData && map ) {
		CPredictionCopy CopyHelper( PC_EVERYTHING, static_cast< byte * >(m_pEndData), true, ( const byte * )g.m_local, false, CPredictionCopy::TRANSFERDATA_COPYONLY );
		CopyHelper.TransferData( "CM_END", m_local->index( ), map ); // save away final copy of our datamap for this cmd
	}

	if ( m_pStartData && map ) {
		CPredictionCopy CopyHelper( PC_EVERYTHING, ( byte * )g.m_local, false, static_cast< const byte * >(m_pStartData), true, CPredictionCopy::TRANSFERDATA_COPYONLY );
		CopyHelper.TransferData( "CM_RESTORE", m_local->index( ), map ); // restore starting datamap to allow the game to use the player normally
	}
	
	m_old_packet = *m_packet;
	m_old_shot = m_shot;
}

```

`solace-csgo/g.h`:

```h
#pragma once

#include <deque>


#include "hvh.h"
#include "vec3.h"
#include "animstate.h"

class cmd_t;
class interfaces_t;
class offsets_t;
class hooks_t;
class render_t;
class weapon_t;
class weapon_info_t;
class player_t;
class IDirect3DDevice9;
class i_net_channel;

using cl_move_t = void( __cdecl * ) ( float, bool );

class NetPos {
public:
	float  m_time;
	vec3_t m_pos;

public:
	__forceinline NetPos( ) : m_time{}, m_pos{} {};
	__forceinline NetPos( float time, vec3_t pos ) : m_time{ time }, m_pos{ pos } {};
};

class Sequence {
public:
	float m_time;
	int   m_state;
	int   m_seq;

public:
	__forceinline Sequence( ) : m_time{}, m_state{}, m_seq{} {};
	__forceinline Sequence( float time, int state, int seq ) : m_time{ time }, m_state{ state }, m_seq{ seq } {};
};

enum CSWeaponType : int;

class c_g {
public:
	interfaces_t *m_interfaces = nullptr;
	offsets_t *m_offsets = nullptr;
	hooks_t *m_hooks = nullptr;
	render_t *m_render = nullptr;

	player_t *m_local = nullptr;
	weapon_t *m_weapon = nullptr;
	weapon_info_t *m_weapon_info = nullptr;

	vec3_t m_shoot_pos = vec3_t( );

	bool m_running_client = false;
	float spawn_time = 0;
     
	
	bool m_in_pred = false;
	ang_t m_view_angles = ang_t();
	bool  m_onground = false;;
	int   m_lag = 0;;
	int   m_last_lag = 0;
	int   m_max_lag = 0;
	vec3_t m_origin = vec3_t( );
	
	bool  m_force_view = false;
	HWND m_window;
	WNDPROC m_old_window;
	float m_latency;
	float m_lerp;
	ang_t m_rotation;
	int m_stage;
	bool m_can_fire = false;
	int m_player_fire;
	CSWeaponType m_weapon_type;
	int m_flags;
	bool m_shift = false;
	int m_available_ticks = 0;
	bool m_can_shift = false;
	int m_tickbase = false;
	bool m_old_packet = false;
	int m_old_lag = 0;
	ang_t m_radar;
	std::deque< NetPos >   m_net_pos;
	bool m_lagcomp = false;
	float m_body_pred =0;
	float m_anim_frame = 0;
	float m_speed = 0;
	int m_buttons = 0;
	bool m_old_shot = 0;
	bool  *m_packet;
	bool  *m_final_packet;
	bool m_shot = false;
	float m_poses[ 24 ];
	animation_layer_t m_layers[ 15 ];
	float m_abs_yaw = 0;
	float m_anim_time = 0;
	ang_t m_angle;
	float m_body = 0;
	bool m_ground = 0;

	std::deque< Sequence > m_sequences = {};
	bool m_datamap_updated;
	unsigned char*m_pStartData;
	unsigned char *m_pEndData;
	alignas( 16 ) bone_array_t * m_real_bones = nullptr;
	CIKContext m_ipk;
	bool m_bones_setup = false;
	bool m_map_setup = false;
	bool m_resolving = false;
	std::vector<int> m_cmds = {};
	bool m_rendering = false;
	bool m_valid_round = false;
	unsigned char *m_pPostPred;
	bool ran;
	int restore_choke;
	void * m_unpred_ground;
	bool m_ran;
	activity_modifiers_wrapper m_activity;

	struct choked_log {
		vec3_t shoot_pos;
		vec3_t origin;
		ang_t view_angles;
		float m_body_pred;
		float m_anim_frame;
		vec3_t m_velocity;
		int commandnr;
		int flags;
		float curtime;
		float view_angle;
		float sidemove;
		float forwardmove;
	};
	std::deque<choked_log> m_choked_logs;

	void  init_cheat( );

	void ModifyEyePosition( anim_state* state, matrix_t* mat, vec3_t* pos );
	void release ( ) const;
	void on_render ( IDirect3DDevice9 *device );
	void on_tick ( cmd_t * cmd );
	void SetAngles ( ) const;
	void UpdateAnimations ( ) const;
    const char* GetWeaponPrefix(anim_state* state);
    void UpdateInformation();
	int time_to_ticks ( float time ) const;
	float ticks_to_time ( int ticks ) const;
	bool can_weapon_fire ( ) const;
	std::vector<std::pair<int, int>> m_tick_base_log;
	void add_tickbase_log( int cmd_num, int tick_base );
	void get_tickbase_log( int cmd_num, int* tick_base );
	void on_move ( float, bool, cl_move_t original_cl_move );
	void UpdateIncomingSequences ( i_net_channel *net );
	void net_data_received ( ) const;

	cmd_t *m_cmd = nullptr;
	
	using random_seed_t = void(__cdecl *)(int);
	using random_int_t = int(__cdecl *)(int, int);
	using random_float_t = float(__cdecl *)(float, float);
	random_seed_t  random_seed;
	random_int_t   random_int ;
	random_float_t random_float;

	bool start_move ( cmd_t *cmd );
	void generate_shoot_position( );
	void end_move( cmd_t *cmd );
} inline g;

```

`solace-csgo/global_vars.h`:

```h
#pragma once

class c_global_vars {
public:
	float m_realtime;
	int m_framecount;
	float m_abs_frametime;
	float m_abs_frame_start_time;
	float m_curtime;
	float m_frametime;
	int m_max_clients;
	int m_tickcount;
	float m_interval_per_tick;
	float m_interp_amount;
	int m_frame_simulation_ticks;
	int m_network_protocol;
	void* m_save_data;
	bool m_client;
	bool m_remote_client;
	int m_timestamp_networking_base;
	int m_timestamp_randomize_window;
};
```

`solace-csgo/hooks.cpp`:

```cpp
#include "hooks.h"

#include <fstream>
#include <future>
#include <iostream>

#include "detours.h"
#include "esp.h"
#include "grenade_pred.h"
#include "hvh.h"
#include "input_helper/input_helper.hh"
#include "movement.h"
#include "netvar_manager.h"
#include "prediction.h"
#include "predictioncopy.h"
#include "resolver.h"
#include "thread_handler.h"
#include "windowsx.h"

void _stdcall paint_traverse(long panel, bool repaint, bool force)
{
    static long tools{}, zoom{};

    // cache CHudZoom panel once.
    if (!zoom && fnv::hash(g.m_interfaces->panel()->GetName(panel)) == fnv::hash("HudZoom"))
        zoom = panel;

    if (panel == zoom && settings::visuals::weapons::noscope)
        return;

    using PaintTraverse_t = void(__thiscall*)(void*, long, bool, bool);
    g.m_interfaces->panel().hook()->get_original<PaintTraverse_t>(panel_t::PAINTTRAVERSE)(
        g.m_interfaces->panel().operator void*(), panel, repaint, force);
}

bool _stdcall create_move(float input_sample_frametime, cmd_t* cmd)
{
    g.m_interfaces->client_mode().hook()->get_original<bool(_stdcall*)(float, cmd_t*)>(24)(input_sample_frametime, cmd);

    uintptr_t* frame_pointer;
    __asm mov frame_pointer, ebp;

    g.m_packet = reinterpret_cast<bool*>(*frame_pointer - 0x1C);
    g.m_final_packet = reinterpret_cast<bool*>(*frame_pointer - 0x1b);

    g.on_tick(cmd);

    // if ( *g.m_final_packet && *g.m_packet && cmd->m_command_number )
    //	g.m_cmds.push_back( cmd->m_command_number );

    // auto this_ptr = g.m_interfaces->engine( )->get_net_channel_info( );
    // if ( this_ptr && g.m_local && g.m_shot &&
    // settings::hvh::antiaim::lag_enable && settings::hvh::antiaim::lag_mode == 5
    // && this_ptr->m_choked_packets > 7 && !settings::hvh::antiaim::fakewalk ) {
    //	int nextcommandnr = g.m_interfaces->client_state(
    //)->m_last_outgoing_command + 1;
    //
    //	cmd_t *cmdlist = *reinterpret_cast< cmd_t ** >( g.m_interfaces->input(
    //).operator address( ) + 0xEC ); 	cmd_t *old_cmd = &cmdlist[ nextcommandnr
    //% 150 ]; 	verified_cmd_t *verifiedCmdList = *reinterpret_cast<
    // verified_cmd_t
    //** >( g.m_interfaces->input( ).operator address( ) + 0xF0 );
    // verified_cmd_t
    //*verified = &verifiedCmdList[ nextcommandnr % 150 ]; 	if ( old_cmd &&
    // old_cmd->m_command_number ) { 		for ( auto i : g.m_choked_logs ) {
    // if ( i.commandnr == old_cmd->m_command_number ) {
    // float backup_time = g.m_interfaces->globals( )->m_curtime;
    // float backup_body_pred =
    // g.m_body_pred; 				float backup_body = g.m_body; 				vec3_t
    // backup_velocity =
    // g.m_local->velocity( ); 				vec3_t backup_origin =
    // g.m_local->origin( ); 				g.m_flags = i.flags; 				g.m_interfaces->globals(
    //)->m_curtime =
    // i.curtime; 				g.m_body_pred = i.m_body_pred;
    // g.m_local->velocity( ) =
    // i.m_velocity; 				g.m_local->origin( ) = i.origin;
    // g.m_view_angles =
    // i.view_angles; 				g_hvh.m_view_angle = i.view_angle;
    // old_cmd->m_forwardmove =
    // i.forwardmove; 				old_cmd->m_sidemove = i.sidemove;
    // g.m_shoot_pos = i.shoot_pos; 				g.m_cmd =
    // old_cmd;
    //
    //				g.m_cmds.push_back( i.commandnr );
    //				g.m_weapon = nullptr;
    //				g.m_can_fire = false;
    //				*g.m_packet = true;
    //				bool backup_final = *g.m_final_packet;
    //				*g.m_final_packet = true;
    //				g_hvh.AntiAim( );
    //				*g.m_final_packet = backup_final;
    //				math::correct_movement( old_cmd );
    //				g.m_interfaces->globals( )->m_curtime =
    // backup_time; 				g.m_body_pred = backup_body_pred;
    // g.m_body = backup_body; 				g.m_local->velocity( ) = backup_velocity;
    //				g.m_local->origin( ) = backup_origin;
    //				verified->m_cmd = *old_cmd;
    //				verified->m_crc = old_cmd->GetChecksum( );
    //				g.ran = true;
    //			}
    //		}
    //	}
    //	const auto current_choke = this_ptr->m_choked_packets;
    //	this_ptr->m_choked_packets -= 7;
    //	g.m_interfaces->client_state( )->m_choked_commands -= 7;
    //
    //	//*reinterpret_cast< bool * >( *frame_pointer - 0x1C ) = true;
    //	g.restore_choke = ( current_choke - this_ptr->m_choked_packets );
    //}
    return g.m_force_view;
}

// void __stdcall draw_model_execute( uintptr_t ctx, const draw_model_state_t
// &state, const model_render_info_t &info, matrix3x4_t *bone ) {
//	// do chams.
//	g_cl.m_local = static_cast< player_t * >(
// interfaces::entity_list->get_client_entity(
// interfaces::engine->get_local_player( ) ) ); 	if ( g_chams.draw_model(
// info ) ) { 		model_render_target.GetOldMethod< fn >( 21 )(
// interfaces::model_render, ctx, state, info, bone ); 	} else {
//
//	}
//
//	// disable material force for next call.
//	//g_csgo.m_studio_render->ForcedMaterialOverride( nullptr );
//}

void __stdcall scene_end()
{
}

long __stdcall end_scene(IDirect3DDevice9* pDevice)
{
    static auto end_scene_target = g.m_interfaces->device().hook()->get_original<decltype(&end_scene)>(42);
    if (!pDevice)
        return end_scene_target(pDevice);

    static std::uintptr_t gameoverlay_return_address = 0;
    //
    // MEMORY_BASIC_INFORMATION info;
    // VirtualQuery( _ReturnAddress( ), &info, sizeof( MEMORY_BASIC_INFORMATION )
    // );
    //
    // char mod[ MAX_PATH ];
    // GetModuleFileNameA( static_cast< HMODULE >( info.AllocationBase ), mod,
    // MAX_PATH );
    //
    // if ( strstr( mod, "gameoverlay" ) )
    //	gameoverlay_return_address = reinterpret_cast< std::uintptr_t >(
    //_ReturnAddress( ) );
    //
    // if ( gameoverlay_return_address != reinterpret_cast< std::uintptr_t >(
    // _ReturnAddress( ) ) ) 	 return end_scene_target( pDevice );

    g.on_render(pDevice);
    return end_scene_target(pDevice);
}

LRESULT __stdcall wndproc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_MOUSEMOVE)
        input_helper.set_mouse_position(
            {static_cast<float>(GET_X_LPARAM(lParam)), static_cast<float>(GET_Y_LPARAM(lParam))});
    if (uMsg == WM_MOUSEWHEEL)
        input_helper.set_scroll_position(static_cast<float>(GET_WHEEL_DELTA_WPARAM(wParam)) /
                                         static_cast<float>(WHEEL_DELTA));
    return CallWindowProc(g.m_old_window, hWnd, uMsg, wParam, lParam);
}

void __fastcall update_anims(player_t* player, uint32_t edx)
{
    auto* vmt = g.m_hooks->players_hook(player->index() - 1);

    if (player == g.m_local)
    {
        if (g.m_running_client)
            g.SetAngles();
        else
        {
            vmt->get_original<void(__fastcall*)(player_t*, uint32_t)>(218)(player, edx);
            //__asm {
            //	mov     ecx, player
            //	call original
            //}
        }
    }
    else if (g_player_manager.m_animating)
    {
        vmt->get_original<void(__fastcall*)(player_t*, uint32_t)>(218)(player, edx);
        //__asm {
        //	mov     ecx, player
        //	call original
        //}
    }
    else if (!g_player_manager.m_ents[player->index() - 1].m_valid)
    {
        vmt->get_original<void(__fastcall*)(player_t*, uint32_t)>(218)(player, edx);
        //__asm {
        //	mov     ecx, player
        //	call original
        //}
    }
}

bool __fastcall setupbones(animating_t* anim, uint32_t edx, matrix_t* out, int max, int mask, float time)
{
    auto player = reinterpret_cast<player_t*>(reinterpret_cast<uintptr_t>(anim) - 0x4);
    auto* vmt = g.m_hooks->players_hook(player->index() - 1);
    auto* info = &g_player_manager.m_ents[player->index() - 1];
    if (info && info->m_valid && !info->m_teamate && !info->m_records.empty())
    {
        auto& record = info->m_records.front();
        if (record && record->m_setup)
        {
            memcpy(out, record->m_bones, sizeof(matrix_t));
            return true;
        }
    }
    return vmt->get_original<bool(__thiscall*)(void*, matrix_t*, int, int, float)>(13)(player, out, max, mask, time);
}

bool __fastcall is_player(player_t* player, uint32_t edx)
{
    auto* vmt = g.m_hooks->players_hook(player->index() - 1);
    static auto shouldskipanim = util::find("client.dll", "84 C0 75 ? 5F C3 8B 0D ? ? ? ?");
    if (g_player_manager.m_animating && _ReturnAddress() == shouldskipanim)
        return false;
    return vmt->get_original<bool(__thiscall*)(player_t*)>(152)(player);
}

void __fastcall EstimateAbsVelocity(player_t* _this, uint32_t edx, vec3_t& vec)
{
    const auto velocity = _this->abs_vel();
    vec.x = velocity.x;
    vec.y = velocity.y;
    vec.z = velocity.z;
}
void __fastcall AllocateIntermediateData(player_t* _this, uint32_t edx)
{
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    if (_this != g.m_local)
        return;
    const auto map = g.m_local->GetPredDescMap();
    if (!map)
        return;
    const typedescription_t type_description{
        FIELD_FLOAT,   "m_velocityModifier", static_cast<int>(g.m_offsets->m_player.velocity_modifier), 1, 0x100, "",
        sizeof(float), 0.00390625f};
    const auto type_array = new typedescription_t[map->m_num_fields + 1];
    memcpy(type_array, map->m_desc, sizeof(typedescription_t) * map->m_num_fields);
    type_array[map->m_num_fields] = type_description;
    map->m_desc = type_array;
    map->m_pOptimizedDataMap = nullptr;
    map->m_num_fields++;
    map->m_packed_size = 0;
    g.m_map_setup = CPredictionCopy::PrepareDataMap(map);
}

void hooks_t::CustomEntityListener::OnEntityCreated(entity_t* ent)
{
    if (!ent || !ent->is_player())
        return;
    auto* vmt = g.m_hooks->players_hook(ent->index() - 1);
    if (vmt)
    {
        vmt->reset();
        vmt->init(reinterpret_cast<uintptr_t>(ent));
        vmt->add(update_anims, 218);
        vmt->add(is_player, 152);
        vmt->add(EstimateAbsVelocity, 141);
    }
    // vmt = g.m_hooks->renderables_hook( ent->index( ) - 1 );
    // if ( vmt ) {
    //	vmt->reset( );
    //	vmt->init( reinterpret_cast< uintptr_t >( ent->animating(  ) ) );
    //	//vmt->add( setupbones, 13 );
    //}
}

void hooks_t::CustomEntityListener::OnEntityDeleted(entity_t* ent)
{
    if (ent && ent->index() >= 1 && ent->index() <= 64)
    {
        auto* vmt = g.m_hooks->players_hook(ent->index() - 1);
        if (vmt)
        {
            vmt->reset();
        }
    }
}

void __stdcall frame_stage_notify(client_frame_stage_t stage)
{
    if (stage != FRAME_START)
        g.m_stage = stage;

    if (!g.m_interfaces->engine()->is_connected() || !g.m_interfaces->engine()->in_game() || !g.m_local)
        return g.m_interfaces->client().hook()->get_original<decltype(&frame_stage_notify)>(36)(stage);

    if (stage == FRAME_RENDER_START && g.m_local->alive())
    {
        // apply local player animated angles.
        g.SetAngles();

        // apply local player animation fix.
        g.UpdateAnimations();

        if (settings::visuals::world::wire_smoke)
        {
            static auto smoke_count =
                *reinterpret_cast<uintptr_t*>(util::find("client.dll", "A3 ? ? ? ? 57 8B CB") + 0x1);
            if (smoke_count)
                *reinterpret_cast<int*>(smoke_count) = 0;
        }
    }

    g.m_interfaces->client().hook()->get_original<decltype(&frame_stage_notify)>(36)(stage);

    if (stage == FRAME_NET_UPDATE_POSTDATAUPDATE_END)
    {
        g_player_manager.update();
    }
    // else if ( stage == FRAME_NET_UPDATE_START ) {
    //	g_esp.NoSmoke( );
    //}
}

void __fastcall draw_model_execute(void* this_ptr, uint32_t edx, uintptr_t ctx, void* state,
                                   const model_render_info_t& info, matrix_t* bone)
{
    static auto original_draw_model =
        reinterpret_cast<decltype(&draw_model_execute)>(g.m_interfaces->model_render().hook()->get_original(21));

    if (!info.pRenderable)
        return original_draw_model(this_ptr, edx, ctx, state, info, bone);

    auto* const base_entity =
        static_cast<entity_t*>(g.m_interfaces->entity_list()->get_client_entity(info.entity_index));

    if (!base_entity || !base_entity->is_player())
        return original_draw_model(this_ptr, edx, ctx, state, info, bone);

    g_chams.player(reinterpret_cast<player_t*>(base_entity), ctx, state, info, bone);
}

void __stdcall override_view(view_setup_t* view)
{
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    const auto alive = g.m_local && g.m_local->alive();
    if (alive)
    {
        g_grenade_pred.View();
        if (settings::misc::misc::thirdperson && !g.m_interfaces->input()->camera_is_third_person())
            g.m_interfaces->input()->camera_to_third_person();
        else if (!settings::misc::misc::thirdperson && g.m_interfaces->input()->camera_is_third_person())
        {
            g.m_interfaces->input()->camera_to_first_person();
            g.m_interfaces->input()->m_camera_offset.z = 0.f;
        }
    }
    if (g.m_interfaces->input()->camera_is_third_person())
    {
        // get camera angles.
        ang_t ang;
        g.m_interfaces->engine()->get_view_angles(ang);
        auto offset = ang;

        // get our viewangle's forward directional vector.
        vec3_t forward;
        forward = (offset.forward());

        // cam_idealdist convar.
        offset.z = 150.f;

        // start pos.
        auto origin = g.m_shoot_pos;

        // setup trace filter and trace.
        trace_filter filter;
        filter.skip = g.m_local;

        trace_t tr;

        {
            // std::unique_lock<std::mutex> lock( g_thread_handler.queue_mutex2 );
            g.m_interfaces->trace()->trace_ray(
                ray_t(origin, origin - (forward * offset.z), {-16.f, -16.f, -16.f}, {16.f, 16.f, 16.f}),
                MASK_NPCWORLDSTATIC, &filter, &tr);
        }

        // adapt distance to travel time.
        tr.flFraction = fminf(fmaxf(tr.flFraction, 0.f), 1.f);
        offset.z *= tr.flFraction;

        // override camera angles.
        g.m_interfaces->input()->m_camera_offset = {offset.x, offset.y, offset.z};
    }
    if (settings::visuals::misc::fov != 0)
        view->fov = settings::visuals::misc::fov;
    g.m_interfaces->client_mode().hook()->get_original<decltype(&override_view)>(18)(view);
}

using cl_move_t = void(__cdecl*)(float, bool);
cl_move_t original_cl_move;

void cl_move(float accumulated_extra_samples, bool bFinalTick)
{
    g.on_move(accumulated_extra_samples, bFinalTick, original_cl_move);
    // g.ran = false;
    // g.m_final_packet = &bFinalTick;
    // original_cl_move( accumulated_extra_samples, bFinalTick );
}
c_hook m_net_hook;
using LevelInitPostEntity_t = void(__stdcall*)();
using ProcessPacket_t = void(__thiscall*)(void*, void*, bool);
using SendDatagram_t = int(__thiscall*)(void*, void*);

#define NET_FRAMES_BACKUP 64 // must be power of 2.
#define NET_FRAMES_MASK (NET_FRAMES_BACKUP - 1)

int __fastcall SendDatagram(i_net_channel* this_ptr, uint32_t edx, void* data)
{
    const int backup1 = this_ptr->m_in_rel_state;
    const auto backup2 = this_ptr->m_in_seq;

    if (settings::misc::misc::fake_latency)
    {
        const auto ping = static_cast<int>(settings::misc::misc::fake_latency_amt);

        // the target latency.
        const auto correct = fmaxf(0.f, (ping / 1000.f) - g.m_latency - g.m_lerp);

        // this_ptr->m_in_seq += 2 * ( 64 - 3 ) - static_cast< uint32_t >( ( 64 - 3
        // ) * correct );

        for (const auto& sequence : g.m_sequences)
        {
            if (g.m_interfaces->globals()->m_curtime - sequence.m_time >= ping / 1000.f)
            {
                this_ptr->m_in_rel_state = sequence.m_state;
                this_ptr->m_in_seq = sequence.m_seq;
                break;
            }
        }
    }

    g_resolver.update_shot_timing(this_ptr->m_choked_packets);

    const auto ret = m_net_hook.get_original<SendDatagram_t>(48)(this_ptr, data);

    this_ptr->m_in_rel_state = backup1;
    this_ptr->m_in_seq = backup2;

    if (!g.m_ran && g.m_valid_round)
    {
        g.m_cmds.push_back(ret);
    }
    else if (!g.m_valid_round)
    {
        g.m_sequences.clear();
        g.m_cmds.clear();
    }

    return ret;
}

void __fastcall ProcessPacket(i_net_channel* this_ptr, uint32_t edx, void* packet, bool header)
{
    m_net_hook.get_original<ProcessPacket_t>(41)(this_ptr, packet, header);

    g.UpdateIncomingSequences(this_ptr);

    // get this from CL_FireEvents string "Failed to execute event for classId" in
    // engine.dll
    for (event_info_t* it{g.m_interfaces->client_state()->m_events}; it != nullptr; it = it->m_next)
    {
        if (!it->m_client_class)
            continue;

        // set all delays to instant.
        it->m_fire_delay = 0.f;
    }

    // game events are actually fired in OnRenderStart which is WAY later after
    // they are received effective delay by lerp time, now we call them right
    // after theyre received (all receive proxies are invoked without delay).
    g.m_interfaces->engine()->FireEvents();
}

void __fastcall SetChoked(i_net_channel* this_ptr, uint32_t edx)
{
    g.m_ran = true;
    using packet_start_t = void(__thiscall*)(i_net_channel*);
    // m_net_hook.get_original<packet_start_t>( 47 )( this_ptr );
    static auto ret = util::find("engine.dll", "FF 90 ? ? ? ? FF 87 ? ? ? ?") + 6;

    const auto addr = _ReturnAddress();
    auto local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    if (ret != addr || !local || !local->alive() || !g.m_valid_round || !g.m_interfaces->engine()->is_connected() ||
        !g.m_interfaces->engine()->in_game())
        return m_net_hook.get_original<packet_start_t>(47)(this_ptr);
    const auto current_choke = this_ptr->m_choked_packets;
    this_ptr->m_choked_packets = 0;
    this_ptr->SendDatagram();
    this_ptr->m_choked_packets = current_choke + 1;
    g.m_ran = false;
    // using packet_start_t = void( __thiscall * )( i_net_channel * );
    // m_net_hook.get_original<packet_start_t>( 47 )( this_ptr );
}

void __stdcall LevelInitPostEntity()
{
    g_pred_manager.reset();
    g.m_sequences.clear();
    g.m_datamap_updated = false;

    auto net = g.m_interfaces->engine()->get_net_channel_info();
    if (net)
    {
        m_net_hook.reset();
        m_net_hook.init(reinterpret_cast<uintptr_t>(net));
        m_net_hook.add(ProcessPacket, 41);
        m_net_hook.add(SetChoked, 47);
        m_net_hook.add(SendDatagram, 48);
    }
    // invoke original method.
    g.m_interfaces->client().hook()->get_original<LevelInitPostEntity_t>(6)();
}

c_hook m_cl_hook;
using TempEntities_t = bool(__thiscall*)(void*, void*);

bool __fastcall TempEntities(client_state_t* this_ptr, uint32_t edx, void* msg)
{
    if (!g.m_running_client)
    {
        return m_cl_hook.get_original<TempEntities_t>(36)(this_ptr, msg);
    }
    int backup = g.m_interfaces->client_state()->m_nMaxClients();
    g.m_interfaces->client_state()->m_nMaxClients() = 1;
    const auto ret = m_cl_hook.get_original<TempEntities_t>(36)(this_ptr, msg);
    g.m_interfaces->client_state()->m_nMaxClients() = backup;

    return ret;
}

using RenderSmokeOverlay_t = void(__thiscall*)(void*, bool);
c_hook view_render;
void __fastcall RenderSmokeOverlay(i_render_view* this_ptr, uint32_t edx, bool unk)
{
    // do not render smoke overlay.
    // if ( !settings::visuals::world::wire_smoke )
    //	g.m_interfaces->viewrender( ).hook( )->get_original<
    // RenderSmokeOverlay_t >( 40 )( this_ptr, unk );
}

recv_var_proxy_fn m_nSmokeEffectTickBegin_original;
void m_nSmokeEffectTickBegin(c_recv_proxy_data* pData, void* pStruct, void* pOut)
{
    if (!pData || !pStruct || !pOut)
        return;

    m_nSmokeEffectTickBegin_original(pData, pStruct, pOut);
    if (settings::visuals::world::wire_smoke)
    {
        *reinterpret_cast<bool*>(reinterpret_cast<uintptr_t>(pOut) + 0x1) = true;
    }
}

recv_var_proxy_fn m_Body_original;
void Body_proxy(c_recv_proxy_data* data, address ptr, address out)
{
    address stack{reinterpret_cast<uintptr_t>(_AddressOfReturnAddress()) - sizeof(uintptr_t)};

    static address RecvTable_Decode{util::find("engine.dll", "EB 0D FF 77 10")};

    // call from entity going into pvs.
    if ((stack.get(2) + sizeof(uintptr_t)) != RecvTable_Decode)
    {
        // convert to player.
        auto player = ptr.as<player_t*>();

        // store data about the update.
        if (player)
        {
            auto* ent = &g_player_manager.m_ents[player->index() - 1];
            if (ent)
                g_resolver.OnBodyUpdate(ent, data->m_value.m_Float);
        }
    }

    // call original proxy.
    if (m_Body_original)
        m_Body_original(data, ptr, out);
}
c_hook net_show_fragments;
using GetBool_t = bool(__thiscall*)(void*);
bool __fastcall NetShowFragmentsGetBool(void* this_ptr, uint32_t edx)
{
    if (!g.m_interfaces->engine()->in_game())
        return net_show_fragments.get_original<GetBool_t>(13)(this_ptr);

    static auto read_sub_channel_data_ret =
        static_cast<address>(util::find("engine.dll", "85 C0 74 12 53 FF 75 0C 68 ? ? ? ? FF 15 ? ? ? ? 83 C4 0C"))
            .as<uintptr_t*>();
    static auto check_receiving_list_ret =
        static_cast<address>(util::find("engine.dll", "8B 1D ? ? ? ? 85 C0 74 16 FF B6")).as<uintptr_t*>();

    static uint32_t last_fragment = 0;

    if (_ReturnAddress() == reinterpret_cast<void*>(read_sub_channel_data_ret) && last_fragment > 0)
    {
        const auto data = &reinterpret_cast<uint32_t*>(g.m_interfaces->client_state()->m_NetChannel)[0x56];
        const auto bytes_fragments = reinterpret_cast<uint32_t*>(data)[0x43];

        if (bytes_fragments == last_fragment)
        {
            auto& buffer = reinterpret_cast<uint32_t*>(data)[0x42];
            buffer = 0;
        }
    }

    if (_ReturnAddress() == check_receiving_list_ret)
    {
        const auto data = &reinterpret_cast<uint32_t*>(g.m_interfaces->client_state()->m_NetChannel)[0x56];
        const auto bytes_fragments = reinterpret_cast<uint32_t*>(data)[0x43];

        last_fragment = bytes_fragments;
    }

    return net_show_fragments.get_original<GetBool_t>(13)(this_ptr);
}

void __stdcall run_command(player_t* player, cmd_t* cmd, player_move_helper* helper)
{
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    typedef void(__thiscall * o_run_command)(void*, player_t*, cmd_t*, player_move_helper*);
    // if ( player == g.m_local ) {
    //	prediction::finish_partial_frame( player, cmd );
    //}
    // else
    g.m_interfaces->prediction().hook()->get_original<o_run_command>(19)(g.m_interfaces->prediction(), player, cmd,
                                                                         helper);
}

bool __stdcall InPrediction()
{
    typedef void(__thiscall * o_run_command)(void*);
    if (g.m_in_pred)
        return true;
    g.m_interfaces->prediction().hook()->get_original<o_run_command>(14)(g.m_interfaces->prediction());
}

void __stdcall PreEntityPacketReceived(int commands_acknowledged, int current_world_update_packet,
                                       int server_ticks_elapsed)
{
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    if (g.m_local && g.m_local->alive())
    {
        g_pred_manager.pre_update(g.m_local);
    }
    typedef void(__thiscall * o_PostNetworkDataReceived)(void*, int, int, int);
    g.m_interfaces->prediction().hook()->get_original<o_PostNetworkDataReceived>(4)(
        g.m_interfaces->prediction(), commands_acknowledged, current_world_update_packet, server_ticks_elapsed);
}
void __stdcall PostNetworkDataReceived(int commands_acknowledged)
{
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    if (g.m_local)
    {
        const auto map = g.m_local->GetPredDescMap();
        if (map)
        {
            if (!g.m_map_setup)
            {
                const typedescription_t type_description{FIELD_FLOAT,
                                                         "m_velocityModifier",
                                                         static_cast<int>(g.m_offsets->m_player.velocity_modifier),
                                                         1,
                                                         0x100,
                                                         "",
                                                         sizeof(float),
                                                         0.00390625f};
                const auto type_array = new typedescription_t[map->m_num_fields + 1];
                memcpy(type_array, map->m_desc, sizeof(typedescription_t) * map->m_num_fields);
                type_array[map->m_num_fields] = type_description;
                map->m_desc = type_array;
                map->m_pOptimizedDataMap = nullptr;
                map->m_num_fields++;
                map->m_packed_size = 0;
                g.m_map_setup = CPredictionCopy::PrepareDataMap(map);
                if (g.m_map_setup)
                    g_pred_manager.init(map);
            }
        }
    }
    if (g.m_local && g.m_local->alive())
    {
        g_pred_manager.post_update(g.m_local);
    }
    typedef void(__thiscall * o_PostNetworkDataReceived)(void*, int);
    g.m_interfaces->prediction().hook()->get_original<o_PostNetworkDataReceived>(6)(g.m_interfaces->prediction(),
                                                                                    commands_acknowledged);
    g.net_data_received();
}

void __stdcall PostEntityPacketReceived()
{
    typedef void(__thiscall * o_PostNetworkDataReceived)(void*);
    g.m_interfaces->prediction().hook()->get_original<o_PostNetworkDataReceived>(5)(g.m_interfaces->prediction());
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
}

using FireEventFn = bool(__thiscall*)(void*, IGameEvent*);
bool __fastcall FireEventClientSide(void* ecx, void* edx, IGameEvent* pEvent)
{
    if (strcmp(pEvent->GetName(), "bullet_impact"))
        g_resolver.on_impact(pEvent);
    return g.m_interfaces->events().hook()->get_original<FireEventFn>(8)(g.m_interfaces->events(), pEvent);
}

void __stdcall SceneEnd()
{
    g.m_interfaces->render_view().hook()->get_original<void(__thiscall*)(void*)>(9)(g.m_interfaces->render_view());
    g_chams.SceneEnd();
}

void __fastcall PacketStart(client_state_t* this_ptr, void* edx, int incoming_sequence, int outgoing_acknowledged)
{
    auto local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    using packet_start_t = void(__thiscall*)(client_state_t*, int, int);
    if (!local || !local->alive() || !g.m_valid_round || !g.m_interfaces->engine()->is_connected() ||
        !g.m_interfaces->engine()->in_game())
        return m_cl_hook.get_original<packet_start_t>(5)(this_ptr, incoming_sequence, outgoing_acknowledged);
    
    // if( this_ptr->m_last_command_ack == this_ptr->m_last_outgoing_command )
    // m_cl_hook.get_original<packet_start_t>( 5 )( this_ptr, incoming_sequence,
    // outgoing_acknowledged );; return;
    for (auto it = g.m_cmds.begin(); it != g.m_cmds.end(); ++it)
        if (*it == outgoing_acknowledged)
        {
            m_cl_hook.get_original<packet_start_t>(5)(this_ptr, incoming_sequence, outgoing_acknowledged);
            break;
        }
    for (size_t i = 0; i < g.m_cmds.size(); i++)
        if (g.m_cmds[i] < outgoing_acknowledged - 100)
        {
            g.m_cmds.erase(g.m_cmds.begin() + i);
            i--;
        }
    // this_ptr->current_sequence = incoming_sequence;
}

float __fastcall Hook_GetScreenAspectRatio(void* pEcx, void* pEdx, int32_t iWidth, int32_t iHeight)
{
    if (settings::visuals::misc::aspectratio != 0)
        iWidth = int(iWidth * ((settings::visuals::misc::aspectratio) / 100.f));
    return g.m_interfaces->engine().hook()->get_original<float(__thiscall*)(void*, int32_t, int32_t)>(101)(pEcx, iWidth,
                                                                                                           iHeight);
}
void __stdcall Hooked_ClientCmd(const char* str, bool force)
{
    std::string name = str;
    if (name.length() > 5 && strcmp(name.substr(0, 5).c_str(), "save ") == 0)
    {
        name = name.substr(5, name.length() - 1) + ".cfg";
        remove(name.c_str());
        std::ofstream file(name.c_str());
        std::streambuf* coutbuf = std::cout.rdbuf(); // save old buf
        std::cout.rdbuf(file.rdbuf());               // redirect std::cin to in.txt!

        if (file.good())
        {
            menu.save();
        }

        std::cout.rdbuf(coutbuf); // reset to standard output again

        file.close();
    }
    else if (name.length() > 5 && strcmp(name.substr(0, 5).c_str(), "load ") == 0)
    {
        name = name.substr(5, name.length() - 1) + ".cfg";
        std::ifstream in(name.c_str());
        std::streambuf* cinbuf = std::cin.rdbuf(); // save old buf
        std::cin.rdbuf(in.rdbuf());                // redirect std::cin to in.txt!

        menu.load();

        std::cin.rdbuf(cinbuf); // reset to standard output again
        in.close();
    }
    else
        g.m_interfaces->engine().hook()->get_original<void(__thiscall*)(void*, const char*, bool)>(114)(
            g.m_interfaces->engine(), str, force);
}

long __stdcall reset(LPDIRECT3DDEVICE9 device, D3DPRESENT_PARAMETERS* presentation_parameters)
{
    g.m_render->on_lost_device();
    auto result = g.m_interfaces->device().hook()->get_original<decltype(&reset)>(16)(device, presentation_parameters);

    if (result == D3D_OK)
    {
        g.m_render->on_reset_device();
    }

    return result;
}
using setup_movment_t = int(__thiscall*)(anim_state*);
setup_movment_t o_setupmovement;
int __fastcall SetUpMovement(anim_state* _this, void* pEcx, void* pEdx)
{
    if (_this->m_player == g.m_local)
    {
    }
    return o_setupmovement(_this);
}

using lock_cursor_t = int(__thiscall*)(void*);
lock_cursor_t oLockCursor;
void __stdcall LockCursor()
{
    oLockCursor(g.m_interfaces->surface());

    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));

    bool state = true;
    if (!g.m_interfaces->engine()->in_game() || (g.m_local && !g.m_local->alive()))
    {
        state = !menu.open;
    }

    g.m_interfaces->input_system()->EnableInput(state);

    if (menu.open)
        g.m_interfaces->surface()->UnlockCursor();
}
hooks_t::hooks_t()
{
    while (!((g.m_window = FindWindowA("Valve001", nullptr))))
        Sleep(100);

    g_chams.create_materials();

    m_custom_entity_listener.init();
    auto net_show_fragments_v = g.m_interfaces->console()->get_convar("net_showfragments");
    net_show_fragments.init((uintptr_t)net_show_fragments_v);
    net_show_fragments.add(static_cast<void*>(NetShowFragmentsGetBool), 13);

    g.m_old_window =
        reinterpret_cast<WNDPROC>(SetWindowLongPtr(g.m_window, GWL_WNDPROC, reinterpret_cast<LONG_PTR>(wndproc)));
    g.m_interfaces->model_render().hook()->add(draw_model_execute, 21);
    g.m_interfaces->engine().hook()->add(Hook_GetScreenAspectRatio, 101);
    g.m_interfaces->engine().hook()->add(Hooked_ClientCmd, 114);
    // g.m_interfaces->events( ).hook( )->add( static_cast< void * >(
    // FireEventClientSide ), 8 );
    g.m_interfaces->client().hook()->add(frame_stage_notify, 36);
    g.m_interfaces->client().hook()->add(LevelInitPostEntity, 6);
    oLockCursor = (lock_cursor_t)g.m_interfaces->surface().hook()->add(LockCursor, 67);
    //g.m_interfaces->client().hook()->add(LevelInitPostEntity, 6);
    g.m_interfaces->surface().hook()->add(LockCursor, 67);
    // g.m_interfaces->viewrender( ).hook( )->add( static_cast< void * >(
    // RenderSmokeOverlay ), 40 );

    g.m_interfaces->client_mode().hook()->add(create_move, 24);
    g.m_interfaces->client_mode().hook()->add(override_view, 18);
    g.m_interfaces->prediction().hook()->add(run_command, 19);
    g.m_interfaces->prediction().hook()->add(PostNetworkDataReceived, 6);
    g.m_interfaces->prediction().hook()->add(PostEntityPacketReceived, 5);
    g.m_interfaces->prediction().hook()->add(PreEntityPacketReceived, 4);
    g.m_interfaces->prediction().hook()->add(InPrediction, 14);

    g.m_interfaces->device().hook()->add(end_scene, 42);
    g.m_interfaces->device().hook()->add(reset, 16);
    g.m_interfaces->render_view().hook()->add(SceneEnd, 9);
    g.m_interfaces->panel().hook()->add(paint_traverse, panel_t::PAINTTRAVERSE);
    m_cl_hook.init(reinterpret_cast<uintptr_t>(g.m_interfaces->hookable_client_state()));
    m_cl_hook.add(TempEntities, 36);
    m_cl_hook.add(PacketStart, 5);

    // o_setupmovement = reinterpret_cast<setup_movment_t>(DetourFunction(
    // (PBYTE)util::find("client.dll", "55 8B EC 83 E4 ? 81 EC ? ? ? ? 56 57 8B 3D
    // ? ? ? ? 8B F1"), (PBYTE)SetUpMovement));

    netvar_manager::set_proxy(fnv::hash("DT_CSPlayer"), fnv::hash("m_flLowerBodyYawTarget"), Body_proxy,
                              m_Body_original);
    netvar_manager::set_proxy(fnv::hash("DT_SmokeGrenadeProjectile"), fnv::hash("m_bDidSmokeEffect"),
                              m_nSmokeEffectTickBegin, m_nSmokeEffectTickBegin_original);

    original_cl_move = reinterpret_cast<decltype(&cl_move)>(
        DetourFunction(util::find("engine.dll", "55 8B EC 81 EC ? ? ? ? 53 56 57 8B 3D ? ? ? ? 8A F9"),
                       reinterpret_cast<PBYTE>(cl_move)));

    // render_view_hook( )->hook( scene_end, 9 );

    // model_render_hook( )->hook( 21, &draw_model_execute );
}

hooks_t::~hooks_t()
{
    for (auto& p : m_players)
        p.reset();
}

```

`solace-csgo/hooks.h`:

```h
#pragma once
#include "vmt.h"
#include "includes.h"

class hooks_t {
	c_hook m_players[ 64 ];

	class IEntityListener {
	public:
		virtual void OnEntityCreated( entity_t *ent ) = 0;
		// virtual void OnEntitySpawned( Entity *ent ) = 0; // note - dex; doesn't seem used on the client?
		virtual void OnEntityDeleted( entity_t *ent ) = 0;
	};

	class CustomEntityListener : public IEntityListener {
	public:
		void OnEntityCreated( entity_t *ent ) override;
		void OnEntityDeleted( entity_t *ent ) override;

		using AddListenerEntity_t = void( __stdcall * )( IEntityListener * );
		__forceinline void init( ) {
			static auto AddListenerEntity = ( AddListenerEntity_t )( util::find( "client.dll", "55 8B EC 8B 0D ? ? ? ? 33 C0 56 85 C9 7E 32 8B 55 08 8B 35" ) );
			AddListenerEntity( this );
		}
	}  m_custom_entity_listener{};
	
public:
	hooks_t( );

	~hooks_t( );

	auto *players_hook( const int index ) {
		return &m_players[ index ];
	}
};

```

`solace-csgo/hvh.cpp`:

```cpp
#include "hvh.h"
#include "includes.h"
#include "aimbot.h"
#include "prediction.h"
#include "predictioncopy.h"

#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

class AdaptiveAngle
{
public:
    float m_yaw;
    float m_dist;

public:
    // ctor.
    __forceinline AdaptiveAngle(float yaw, float penalty = 0.f);
};

AdaptiveAngle::AdaptiveAngle ( float yaw, float penalty ) {
	// set yaw.
	m_yaw = math::normalize_angle( yaw, 180 );

	// init distance.
	m_dist = 0.f;

	// remove penalty.
	m_dist -= penalty;
}

void hvh::fake_walk() const {
  vec3_t velocity{g.m_local->velocity()};
  int ticks{}, max{16};

  if (!settings::hvh::antiaim::fakewalk) return;

  if (!g.m_local->m_ground_entity()) return;

  // user was running previously and abrubtly held the fakewalk key
  // we should quick-stop under this circumstance to hit the 0.22 flick
  // perfectly, and speed up our fakewalk after running even more.
  // if( g_cl.m_initial_flick ) {
  //	Movement::QuickStop( );
  //	return;
  //}

  // reference:
  // https://github.com/ValveSoftware/source-sdk-2013/blob/master/mp/src/game/shared/gamemovement.cpp#L1612

  // calculate friction.
  static auto sv_friction =
      g.m_interfaces->console()->get_convar("sv_friction");
  static auto sv_stopspeed =
      g.m_interfaces->console()->get_convar("sv_stopspeed");
  float friction = sv_friction->GetFloat() * g.m_local->surface_friction();

  for (; ticks < g.m_max_lag; ++ticks) {
    // calculate speed.
    float speed = velocity.length();

    // if too slow return.
    if (speed <= 0.1f) break;

    // bleed off some speed, but if we have less than the bleed, threshold,
    // bleed the threshold amount.
    float control = std::max(speed, sv_stopspeed->GetFloat());

    // calculate the drop amount.
    float drop = control * friction * g.m_interfaces->globals()->m_interval_per_tick;

    // scale the velocity.
    float newspeed = std::max(0.f, speed - drop);

    if (newspeed != speed) {
      // determine proportion of old speed we are using.
      newspeed /= speed;

      // adjust velocity according to proportion.
      velocity *= newspeed;
    }
  }

  // zero forwardmove and sidemove.
  if (ticks > ((max - 1) -
               g.m_interfaces->client_state()->chokedcommands) ||
      !g.m_interfaces->client_state()->chokedcommands)
  {
    g.m_cmd->m_forwardmove = g.m_cmd->m_sidemove = 0.f;
  }
}

void hvh::break_resolver() {
	if (!settings::hvh::antiaim::fakehead) {
		m_breaking = false;
		return;
	}
	const auto stand = settings::hvh::antiaim::body_fake_stand > 0 && !g.m_cmd->m_forwardmove && !g.m_cmd->m_sidemove;
	if ( stand ) {
		m_switch = !m_switch;
		g.m_cmd->m_forwardmove = 2.4f / ((!m_switch) + 1 );

		m_breaking = m_switch;
		*g.m_packet = m_switch;
	}
}

void hvh::IdealPitch( ) {
	const auto state = g.m_local->get_anim_state( );
	if ( !state )
		return;

	g.m_cmd->m_viewangles.x = state->m_min_pitch;
}

void hvh::AntiAimPitch( ) const {
	const auto safe = true;

	switch ( m_pitch ) {
	case 1:
		// down.
		g.m_cmd->m_viewangles.x = safe ? 89.f : 720.f;
		break;

	case 2:
		// up.
		g.m_cmd->m_viewangles.x = safe ? -89.f : -720.f;
		break;

	case 3:
		// random.
		g.m_cmd->m_viewangles.x = ( safe ? -89.f : -720.f, safe ? 89.f : 720.f );
		break;

	default:
		break;
	}
}


void hvh::AutoDirection( ) {
	// constants.
	constexpr const auto STEP{ 1.f };
	constexpr const auto RANGE{ 32.f };

	// best target.
	struct AutoTarget_t { float fov; player_t *player; };
	AutoTarget_t target{ 180.f + 1.f, nullptr };

	// iterate players.
	for ( size_t i = 0; i < g_player_manager.m_ents.size( ); i++ ) {
		auto *player = &g_player_manager.m_ents[ i ];
		// validate player.
		if ( !player || !g_aimbot.valid( player ) )
			continue;

		// skip dormant players.
		if ( player->m_ent->dormant( ) )
			continue;

		// get best target based on fov.
		auto fov = math::get_fov( ang_t(0, m_view_angle, 0), g.m_shoot_pos, player->m_ent->world_space_center( ) );

		const auto set = fov < target.fov;
		target.fov = set ? fov : target.fov;
		target.player = set ? player->m_ent : target.player;
	}

	if ( !target.player ) {
		// set angle to backwards.
		const auto set = m_auto_last > 0.f && m_auto_time > 0.f && g.m_interfaces->globals( )->m_curtime < ( m_auto_last + m_auto_time );
		m_auto = !set ? math::normalize_angle( m_view - 180.f, 180 ) : m_auto;
		m_auto_dist = !set ? -1.f : m_auto_dist;
		return;
	}

	/*
	* data struct
	* 68 74 74 70 73 3a 2f 2f 73 74 65 61 6d 63 6f 6d 6d 75 6e 69 74 79 2e 63 6f 6d 2f 69 64 2f 73 69 6d 70 6c 65 72 65 61 6c 69 73 74 69 63 2f
	*/

	// construct vector of angles to test.
	std::vector< AdaptiveAngle > angles{ };
	angles.emplace_back( m_view - 180.f );
	angles.emplace_back( m_view + 90.f );
	angles.emplace_back( m_view - 90.f );

	// start the trace at the enemy shoot pos.
	vec3_t start;
	target.player->get_eye_pos( &start );
	

	// see if we got any valid result.
	// if this is false the path was not obstructed with anything.
	auto valid{ false };

	// iterate vector of angles.
	for ( auto it = angles.begin( ); it != angles.end( ); ++it ) {

		// compute the 'rough' estimation of where our head will be.
		vec3_t end{ g.m_shoot_pos.x + std::cos( DEG2RAD( it->m_yaw ) ) * RANGE,
			g.m_shoot_pos.y + std::sin( DEG2RAD( it->m_yaw ) ) * RANGE,
			g.m_shoot_pos.z };

		// draw a line for debugging purposes.
		//g_csgo.m_debug_overlay->AddLineOverlay( start, end, 255, 0, 0, true, 0.1f );

		// compute the direction.
		auto dir = end - start;
		const auto len = dir.length( );
		dir /= len;
		// should never happen.
		if ( len <= 0.f )
			continue;

		// step thru the total distance, 4 units per step.
		for ( auto i{ 0.f }; i < len; i += STEP ) {
			// get the current step position.
			auto point = start + ( dir * i );

			// get the contents at this point.
			const auto contents = g.m_interfaces->trace(  )->get_point_contents( point, MASK_SHOT_HULL );

			// contains nothing that can stop a bullet.
			if ( !( contents & MASK_SHOT_HULL ) )
				continue;

			auto mult = 1.f;

			// over 50% of the total length, prioritize this shit.
			const auto set = (i > ( len * 0.5f )) ||
						  (i > ( len * 0.75f )) ||
						  (i > ( len * 0.9f ));

			mult = (i > len * 0.5f) * 1.25f +
				   (i > len * 0.75f) * 1.25f +
				   (i > len * 0.9f) * 2.f + !set * mult;

			// append 'penetrated distance'.
			it->m_dist += ( STEP * mult );

			// mark that we found anything.
			valid = true;
		}
	}

	if ( !valid ) {
		// set angle to backwards.
		m_auto = math::normalize_angle( m_view - 180.f, 180 );
		m_auto_dist = -1.f;
		return;
	}

	// put the most distance at the front of the container.
	std::sort( angles.begin( ), angles.end( ),
			   [ ]( const AdaptiveAngle &a, const AdaptiveAngle &b ) {
				   return a.m_dist > b.m_dist;
			   } );

	// the best angle should be at the front now.
	const auto best = &angles.front( );

	// check if we are not doing a useless change.
	const auto set = best->m_dist != m_auto_dist;
	// set yaw to the best result.
	m_auto = set * math::normalize_angle( best->m_yaw, 180 ) + !set * m_auto;
	m_auto_dist = set * best->m_dist + !set * m_auto_dist;
	m_auto_last = set * g.m_interfaces->globals(  )->m_curtime + !set * m_auto_last;
}

void hvh::GetAntiAimDirection( ) {

	// lock while standing..
	const auto lock = settings::hvh::antiaim::dir_lock;

	// save view, depending if locked or not.
	if ( ( lock && g.m_local->velocity(  ).length(  ) > 0.1f ) || !lock )
		m_view = m_view_angle;

	if ( m_base_angle > 0 ) {
		// 'static'.
		if ( m_base_angle == 1 )
			m_view = 0.f;

		// away options.
		else {
			auto best_fov{ std::numeric_limits< float >::max( ) };
			auto best_dist{ std::numeric_limits< float >::max( ) };
			ent_info_t *best_target{ nullptr };

			for ( auto i = 0; i < g_player_manager.m_ents.size( ); i++ ) {
				auto *target = &g_player_manager.m_ents[ i ];

				if ( !target || !g_aimbot.valid( target ) )
					continue;

				if ( target->m_ent->dormant( ) )
					continue;

				// 'away crosshair'.
				if ( m_base_angle == 2 ) {

					// check if a player was closer to our crosshair.
					const auto fov = math::get_fov( ang_t(0,m_view_angle,0), g.m_shoot_pos, target->m_ent->world_space_center( ) );
					const auto set = fov < best_fov;
					best_fov = set * fov + !set * best_fov;
					best_target = reinterpret_cast< ent_info_t * >(set * reinterpret_cast< uintptr_t >(target) +
								  reinterpret_cast< uintptr_t >( best_target ) * !set);
				}

				// 'away distance'.
				else if ( m_base_angle == 3 ) {

					// check if a player was closer to us.
					const auto dist = (target->m_ent->origin( ) - g.m_local->origin( )).length_sqr( );
					const auto set = dist < best_dist;
					best_dist = set * dist + !set * best_dist;
					best_target = reinterpret_cast< ent_info_t * >( set * reinterpret_cast< uintptr_t >( target ) +
																	reinterpret_cast< uintptr_t >( best_target ) * !set );
				}
			}

			if ( best_target )
				m_view = g.m_local->origin( ).look( best_target->m_ent->origin( ) ).y;
		}
	}

	// switch direction modes.
	switch ( m_dir ) {

		// auto.
	case 0:
		AutoDirection( );
		m_direction = m_auto;
		break;

		// backwards.
	case 1:
		m_direction = m_view + 180.f;
		break;

		// left.
	case 2:
		m_direction = m_view + 90.f;
		break;

		// right.
	case 3:
		m_direction = m_view - 90.f;
		break;

	default:
		m_direction = m_view;
		break;
	}

	// normalize the direction.
	m_direction = math::normalize_angle( m_direction, 180 );
}

void hvh::DoRealAntiAim( ) {
	// if we have a yaw antaim.
	if ( m_yaw > 0 ) {

		// if we have a yaw active, which is true if we arrived here.
		// set the yaw to the direction before applying any other operations.
		g.m_cmd->m_viewangles.y = m_direction;

		const auto stand = settings::hvh::antiaim::body_fake_stand > 0 && m_mode == AntiAimMode::STAND;
		const auto air = settings::hvh::antiaim::body_fake_air > 0 && m_mode == AntiAimMode::AIR;
		auto breaker = true;

		if ( m_mode == AntiAimMode::WALK ) {
			m_break_dir = 0;
			breaker = false;
		}


		static float flLastMoveTime = FLT_MAX;
		static float flLastMoveYaw = FLT_MAX;
		static bool bGenerate = true;
		static float flGenerated = 0.f;
		static bool needs_adjust = false;
		const float time = g.ticks_to_time(g.m_local->tick_base());
		bool bDoDistort = true;
		if (g.m_local->velocity().length_sqr() > 0.01f && g.m_local->m_ground_entity() && !settings::hvh::antiaim::fakewalk) {
			flLastMoveTime = time;
			flLastMoveYaw = g.m_local->lower_body_yaw();

			bDoDistort = false;
			needs_adjust = false;
		}
		if (m_just_updated_body)
			flLastMoveTime = time;
		float flDistortion = ((flLastMoveTime - time) / 1.1f);
		auto animstate = g.m_local->get_anim_state();
		float m_flWalkToRunTransition = 0;
		if (animstate) {
			auto vel = g.m_local->velocity();
			float m_flVelocityLengthXY = vel.length_2d();
			m_flWalkToRunTransition = animstate->m_flWalkToRunTransition;
			if (m_flWalkToRunTransition > 0 && m_flWalkToRunTransition < 1)
			{
				//currently transitioning between walk and run
				if (animstate->m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN)
				{
					m_flWalkToRunTransition += g.ticks_to_time(g.m_last_lag) * CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED;
				}
				else // m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK
				{
					m_flWalkToRunTransition -= g.ticks_to_time(g.m_last_lag) * CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED;
				}
				m_flWalkToRunTransition = std::clamp<float>(m_flWalkToRunTransition, 0, 1);
			}

			if (m_flVelocityLengthXY > (CS_PLAYER_SPEED_RUN * CS_PLAYER_SPEED_WALK_MODIFIER) && animstate->m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK)
			{
				//crossed the walk to run threshold
				m_flWalkToRunTransition = fmaxf(0.01f, m_flWalkToRunTransition);
			}
			else if (m_flVelocityLengthXY < (CS_PLAYER_SPEED_RUN * CS_PLAYER_SPEED_WALK_MODIFIER) && animstate->m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN)
			{
				//crossed the run to walk threshold
				m_flWalkToRunTransition = fmaxf(0.99f, m_flWalkToRunTransition);
			}
		}
		// one tick before the update.
		//if ( stand && !g.m_lag && g.m_interfaces->globals( )->m_curtime >= ( g.m_body_pred - g.m_anim_frame ) && g.m_interfaces->globals( )->m_curtime < g.m_body_pred ) {
		//	// z mode.
		//	float body = g.m_cmd->m_viewangles.y;
		//	body += 110.f * (settings::hvh::antiaim::body_fake_stand == 1);
		//	body -= 110.f * (settings::hvh::antiaim::body_fake_stand == 2);
		//	body += 180.f * (settings::hvh::antiaim::body_fake_stand == 3);
		//	body += (155.f * (m_lby_side * -1)) * (settings::hvh::antiaim::body_fake_stand == 4);
		//	body = math::normalize_angle(body, 180);
		//	
		//	float offset = fmaxf(fabsf(math::normalize_angle(std::copysignf(179.f, -body) - body, 180.f)), 70);
		//
		//	g.m_cmd->m_viewangles.y = body + offset;
		//}

		// check if we will have a lby fake this tick.
		//else 
		if ( !g.m_lag && ((g.m_interfaces->globals()->m_curtime >= g.m_body_pred && (stand || air)))) {
			
			m_just_updated_body = true;
			//if ( breaker ) {
			//	//m_rot_range = 0;
			//	if ( m_break_dir == 90 )
			//		m_break_dir = 0;
			//	else if ( m_break_dir == 0 )
			//		m_break_dir = -90;
			//	else if ( m_break_dir == -90 )
			//		m_break_dir = 90;
			//	
			//	g.m_cmd->m_viewangles.y += m_break_dir;
			//}
			// there will be an lbyt update on this tick.
			if ( stand || !m_breaking) {
				//switch ( settings::hvh::antiaim::body_fake_stand ) {
				//
				//	// left.
				//case 1:
					g.m_cmd->m_viewangles.y += 110.f * (settings::hvh::antiaim::body_fake_stand == 1);
					g.m_cmd->m_viewangles.y -= 110.f * (settings::hvh::antiaim::body_fake_stand == 2);
					g.m_cmd->m_viewangles.y += 180.f * (settings::hvh::antiaim::body_fake_stand == 3);

					//float break_yaw = 85.f; ;
					//if (animstate && !m_breaking)
					//	break_yaw = fmaxf( 45, fminf( 89, g.ticks_to_time(g.m_last_lag) * (30.0f + 20.0f * m_flWalkToRunTransition)));
					//g.m_cmd->m_viewangles.y += (std::copysignf(90, m_lby_side *= -1) + (break_yaw * m_lby_side)) * (settings::hvh::antiaim::body_fake_stand == 4);
				//	break;
				//
				//default:
				//	break;
				//}
			}

			else if ( air ) {
				switch ( settings::hvh::antiaim::body_fake_air ) {
				case 1:// left.
					g.m_cmd->m_viewangles.y += 90.f;
					break;
				case 2:// right.
					g.m_cmd->m_viewangles.y -= 90.f;
					break;
				case 3:// opposite.
					g.m_cmd->m_viewangles.y += 180.f;
					break;

				default:
					break;
				}
			}
		}

		// run normal aa code.
		else {
			float break_yaw = 0.f;
			if( breaker )
				g.m_cmd->m_viewangles.y += m_break_dir;
			switch ( m_yaw ) {

				// direction.
			case 1:
				// do nothing, yaw already is direction.
				break;

				// jitter.
			case 2:
			{

				// get the range from the menu.
				const auto range = m_jitter_range / 2.f;

				// set angle.
				g.m_cmd->m_viewangles.y += g.random_float( -range, range );
				break;
			}

			// rotate.
			case 3:
			{
				// set base angle.
				g.m_cmd->m_viewangles.y = ( m_direction - m_rot_range / 2.f );

				// apply spin.
				g.m_cmd->m_viewangles.y += std::fmod( g.m_interfaces->globals()->m_curtime * ( m_rot_speed * 20.f ), m_rot_range );

				break;
			}

			// random.
			case 4:
				// check update time.
				if ( g.m_interfaces->globals()->m_curtime >= m_next_random_update ) {

					// set new random angle.
					m_random_angle = math::RandomFloat( -180.f, 180.f );

					// set next update time
					m_next_random_update = g.m_interfaces->globals()->m_curtime + m_rand_update;
				}

				// apply angle.
				g.m_cmd->m_viewangles.y = m_random_angle;
				break;
			case 5: // distortion

				if (m_mode == AntiAimMode::WALK) {
					break_yaw = ((g.ticks_to_time(g.m_last_lag) * (30.0f + 20.0f * m_flWalkToRunTransition)));
					g.m_cmd->m_viewangles.y += ( break_yaw * 4.f * (m_side));
				}
				else {

					//if (g_Vars.globals.manual_aa != -1 && !g_Vars.antiaim.distort_manual_aa)
					//	bDoDistort = false;

					if (flLastMoveTime == FLT_MAX)
						break;

					if (flLastMoveYaw == FLT_MAX)
						break;


					// don't distort for longer than this

					//if (g_Vars.antiaim.distort_twist) {
					if (animstate) {
						g.m_cmd->m_viewangles.y = 90.f + animstate->m_cur_feet_yaw + (360.f * flDistortion);
					}
				}
				break;

			default:
				break;
			}
			if ( stand && !g.m_lag && m_just_updated_body ) {
				//if (settings::hvh::antiaim::body_fake_stand == 4) {
				//	const auto diff = math::normalize_angle(g.m_body - g.m_cmd->m_viewangles.y, 180);
				//	if (fabsf(diff) >= (120.f / (g.m_interfaces->globals()->m_curtime - g.m_anim_time))) {
				//		g.m_cmd->m_viewangles.y = g.m_body + std::copysignf(119.f / (g.m_interfaces->globals()->m_curtime - g.m_anim_time), diff);
				//	}
				//}
				m_just_updated_body = false;
			}
		}
	}

	// normalize angle.
	g.m_cmd->m_viewangles.y = math::normalize_angle( g.m_cmd->m_viewangles.y, 180 );
}

void hvh::DoFakeAntiAim( ) const {
	// do fake yaw operations.

	// enforce this otherwise low fps dies.
	// cuz the engine chokes or w/e
	// the fake became the real, think this fixed it.
	*g.m_packet = true;
	switch ( settings::hvh::antiaim::fake_yaw ) {

		// default.
	case 1:
		// set base to opposite of direction.
		g.m_cmd->m_viewangles.y = m_direction + 180.f;

		// apply 45 degree jitter.
		g.m_cmd->m_viewangles.y += math::RandomFloat( -45.f, 45.f );
		break;

		// relative.
	case 2:
		// set base to opposite of direction.
		g.m_cmd->m_viewangles.y = m_direction + 180.f;

		// apply offset correction.
		g.m_cmd->m_viewangles.y += settings::hvh::antiaim::fake_relative;
		break;

		// relative jitter.
	case 3:
	{
		// get fake jitter range from menu.
		const auto range = settings::hvh::antiaim::fake_jitter_range / 2.f;

		// set base to opposite of direction.
		g.m_cmd->m_viewangles.y = m_direction + 180.f;

		// apply jitter.
		g.m_cmd->m_viewangles.y += math::RandomFloat( -range, range );
		break;
	}

	// rotate.
	case 4:
		g.m_cmd->m_viewangles.y = m_direction + 90.f + std::fmod( g.m_interfaces->globals()->m_curtime * 360.f, 180.f );
		break;

		// random.
	case 5:
		g.m_cmd->m_viewangles.y = math::RandomFloat( -180.f, 180.f );
		break;

		// local view.
	case 6:
		g.m_cmd->m_viewangles.y = m_view_angle;
		break;

	default:
		break;
	}

	// normalize fake angle.
	const auto breaker = true;
	if ( breaker )
		g.m_cmd->m_viewangles.y += m_break_dir;
	g.m_cmd->m_viewangles.y = math::normalize_angle( g.m_cmd->m_viewangles.y, 180 );
}

void hvh::AntiAim( ) {

	if ( !settings::hvh::antiaim::enabled )
		return;

	const bool attack = g.m_cmd->m_buttons & IN_ATTACK;
	const bool attack2 = g.m_cmd->m_buttons & IN_ATTACK2;

	if ( g.m_weapon && g.m_can_fire ) {
		const auto knife = g.m_weapon_type == WEAPONTYPE_KNIFE;// &&g.m_weapon_id != ZEUS;
		const auto revolver = g.m_weapon->item_definition_index() == 64;

		// if we are in attack and can fire, do not anti-aim.
		if ( attack || ( attack2 && ( knife || revolver ) ) )
			return;
	}

	// disable conditions.
	if ( ( g.m_flags & fl_frozen ) || ( g.m_cmd->m_buttons & IN_USE ) )
		return;

	// grenade throwing
	// CBaseCSGrenade::ItemPostFrame()
	// https://github.com/VSES/SourceEngine2007/blob/master/src_main/game/shared/cstrike/weapon_basecsgrenade.cpp#L209
	if ( g.m_weapon && g.m_weapon_type == WEAPONTYPE_GRENADE
		 && ( !g.m_weapon->pin_pulled( ) || attack || attack2 )
		 && g.m_weapon->throw_time( ) > 0.f && g.m_weapon->throw_time( ) < g.m_interfaces->globals()->m_curtime )
		return;

	m_mode = AntiAimMode::STAND;

	if ( ( g.m_buttons & IN_JUMP ) || !( g.m_flags & fl_onground ) )
		m_mode = AntiAimMode::AIR;

	else if ( g.m_speed > 0.1f )
		m_mode = AntiAimMode::WALK;

	// load settings.
	if ( m_mode == AntiAimMode::STAND ) {
		m_pitch = settings::hvh::antiaim::pitch_stand;
		m_yaw = settings::hvh::antiaim::yaw_stand;
		m_jitter_range = settings::hvh::antiaim::jitter_range_stand;
		m_rot_range = settings::hvh::antiaim::rot_range_stand;
		m_rot_speed = settings::hvh::antiaim::rot_speed_stand;
		m_rand_update = settings::hvh::antiaim::rand_update_stand;
		m_dir = settings::hvh::antiaim::dir_stand;
		m_dir_custom = settings::hvh::antiaim::dir_custom_stand;
		m_base_angle = settings::hvh::antiaim::base_angle_stand;
		m_auto_time = settings::hvh::antiaim::dir_time_stand;
	}
	//
	else if ( m_mode == AntiAimMode::WALK ) {
		m_pitch = settings::hvh::antiaim::pitch_walk;
		m_yaw = settings::hvh::antiaim::yaw_walk;
		m_jitter_range = settings::hvh::antiaim::jitter_range_walk;
		m_rot_range = settings::hvh::antiaim::rot_range_walk;
		m_rot_speed = settings::hvh::antiaim::rot_speed_walk;
		m_rand_update = settings::hvh::antiaim::rand_update_walk;
		m_dir = settings::hvh::antiaim::dir_walk;
		m_dir_custom = settings::hvh::antiaim::dir_custom_walk;
		m_base_angle = settings::hvh::antiaim::base_angle_walk;
		m_auto_time = settings::hvh::antiaim::dir_time_walk;
	}
	//
	else if ( m_mode == AntiAimMode::AIR ) {
		m_pitch = settings::hvh::antiaim::pitch_air;
		m_yaw = settings::hvh::antiaim::yaw_air;
		m_jitter_range = settings::hvh::antiaim::jitter_range_air;
		m_rot_range = settings::hvh::antiaim::rot_range_air;
		m_rot_speed = settings::hvh::antiaim::rot_speed_air;
		m_rand_update = settings::hvh::antiaim::rand_update_air;
		m_dir = settings::hvh::antiaim::dir_air;
		m_dir_custom = settings::hvh::antiaim::dir_custom_air;
		m_base_angle = settings::hvh::antiaim::base_angle_air;
		m_auto_time = settings::hvh::antiaim::dir_time_air;
	}

	// set pitch.
	AntiAimPitch( );

	// if we have any yaw.
	if ( m_yaw > 0 ) {
		// set direction.
		GetAntiAimDirection( );
	}

	// we have no real, but we do have a fake.
	else if ( settings::hvh::antiaim::fake_yaw > 0 )
		m_direction = g.m_cmd->m_viewangles.y;

	//const auto stand = settings::hvh::antiaim::body_fake_stand > 0 && m_mode == AntiAimMode::STAND;
	//if(stand) {
	//	if (g.m_lag > 0 && (m_breaking || (g.m_interfaces->globals()->m_curtime + g.ticks_to_time(3) >= g.m_body_pred && (stand)) || (g.m_interfaces->globals()->m_curtime + g.ticks_to_time(1) >= g.m_body_pred && (stand)))) {
	//		*g.m_packet = true;
	//	}
	//}
	if ( settings::hvh::antiaim::fake_yaw ) {
		// do not allow 2 consecutive sendpacket true if faking angles.
		if ( *g.m_packet && g.m_old_packet )
			*g.m_packet = false;

		// run the real on sendpacket false.
		if ( !*g.m_packet || *g.m_final_packet )
			DoRealAntiAim( );

		// run the fake on sendpacket true.
		else DoFakeAntiAim( );
	}

	// no fake, just run real.
	else DoRealAntiAim( );
	//if ( !*g.m_packet ) {
	//	c_g::choked_log log;
	//	log.flags = g.m_flags;
	//	log.commandnr = g.m_cmd->m_command_number;
	//	log.origin = g.m_local->origin( );
	//	log.shoot_pos = g.m_shoot_pos;
	//	log.view_angles = g.m_view_angles;
	//	log.view_angle = m_view_angle;
	//	log.m_body_pred = g.m_body_pred;
	//	log.m_anim_frame = g.m_anim_frame;
	//	log.sidemove = g.m_cmd->m_sidemove;
	//	log.forwardmove = g.m_cmd->m_forwardmove;
	//	log.m_velocity = g.m_local->velocity( );
	//	log.curtime = g.m_interfaces->globals( )->m_curtime;
	//	g.m_choked_logs.push_back( log );
	//	if ( g.m_choked_logs.size( ) > 150 )
	//		g.m_choked_logs.pop_front( );
	//}
}

void hvh::SendPacket( ) {
	// if not the last packet this shit wont get sent anyway.
	// fix rest of hack by forcing to false.
	if ( !*g.m_final_packet )
		*g.m_packet = false;

	// fake-lag enabled.
	if ( settings::hvh::antiaim::lag_enable && !( g.m_flags & fl_frozen ) ) {
		// limit of lag.
		const auto limit = std::min( static_cast< int >(settings::hvh::antiaim::lag_limit), g.m_max_lag );

		// indicates wether to lag or not.
		bool active{ };

		// get current origin.
		auto cur = g.m_local->origin( );

		// get prevoius origin.
		const auto prev = g.m_net_pos.empty( ) ? g.m_local->origin( ) : g.m_net_pos.front( ).m_pos;

		// delta between the current origin and the last sent origin.
		const auto delta = ( cur - prev ).length_sqr( );

		const auto activation = settings::hvh::antiaim::lag_active;
		// move.
		if ( activation & ( 1 << 0 ) && (g.m_speed > 0.1f || (g.m_cmd && (g.m_cmd->m_forwardmove != 0.f || g.m_cmd->m_sidemove != 0)))) {
			active = true;
		}

		// air.
		else if ( activation & (1 << 1) && ( ( g.m_buttons & IN_JUMP ) || !( g.m_flags & fl_onground ) ) ) {
			active = true;
		}

		// crouch.
		else if ( activation & (1 << 2) && g.m_local->ducking( ) ) {
			active = true;
		}

		const auto mode = settings::hvh::antiaim::lag_mode;
		if ( active ) {

			// max.

			// break.
			if ( mode == 0 || (mode == 1 && delta <= 4096.f) || mode == 5  )
				*g.m_packet = false;

			// random.
			else if ( mode == 2 ) {
				// compute new factor.
				if ( g.m_lag >= m_random_lag )
					m_random_lag = math::RandomInt( 2, limit );

				// factor not met, keep choking.
				else *g.m_packet = false;
			}

			// break step.
			else if ( mode == 3 ) {
				// normal break.
				if ( m_step_switch ) {
					if ( delta <= 4096.f )
						*g.m_packet = false;
				}

				// max.
				else *g.m_packet = false;
			}

			if ( g.m_lag >= limit )
				*g.m_packet = true;
		}
		if (g.m_lag < 2)
			*g.m_packet = false;
		if (settings::hvh::antiaim::fakehead) {
			if (g.m_lag < g.m_max_lag)
				*g.m_packet = false;
			else
				*g.m_packet = true;
		}
	}
	
	//if ( settings::hvh::antiaim::lag_land ) {
	//	if( !g.m_unpred_ground && g.m_interfaces->entity_list(  )->get_client_entity_handle( g.m_local->m_ground_entity(  ) ) )
	//		*g.m_packet = false;
	//}

	// force fake-lag to 14 when fakewalking.
	if ( settings::hvh::antiaim::fakewalk ) {
		*g.m_packet = false;
	}
	else if( g.m_old_shot )
		*g.m_packet = true;


	// we somehow reached the maximum amount of lag.
	// we cannot lag anymore and we also cannot shoot anymore since we cant silent aim.
	if ( g.m_lag >= g.m_max_lag ) {
		// set bSendPacket to true.
		*g.m_packet = true;

		// disable firing, since we cannot choke the last packet.
		g.m_can_fire = false;
	}
}
```

`solace-csgo/hvh.h`:

```h
#pragma once

class ang_t;
class player_t;


enum AntiAimMode : size_t {
	STAND = 0,
	WALK,
	AIR,
};

class hvh {
public:
	float last_lby_update = -1;
	int m_pitch = 0;
	float m_view = 0;
	float m_auto = 0;
	float m_auto_dist = 0;
	float m_auto_last = 0;
	float m_auto_time = 0;
	float m_direction = 0;
	int m_break_dir = 0;
	int m_base_angle = 0;
	int m_dir = 0;
	int m_yaw = 0;
	bool m_breaking = false;
	float m_jitter_range = 0;
	float m_rot_range = 0;
	float m_rot_speed = 0;
	float m_next_random_update = 0;
	float m_random_angle = 0;
	float m_rand_update = 0;
	int m_dir_custom = 0;
	int m_mode = 0;
	int m_random_lag = 0;
	bool m_step_switch = 0;
	float m_view_angle;
	bool m_just_updated_body;
	bool m_switch = false;
	int m_lby_side = 1;
	int m_side = 1.f;
	void fake_walk ( ) const;
	void break_resolver();
	static void IdealPitch ( );
	void AntiAimPitch ( ) const;
	void AutoDirection ( );
	void GetAntiAimDirection ( );
	void DoRealAntiAim ( );
	void DoFakeAntiAim ( ) const;
	void AntiAim ( );
	void SendPacket ( );
} inline g_hvh;

```

`solace-csgo/includes.h`:

```h
#pragma once

#include <stdexcept>
#include <cstdint>
#include <thread>
#include <Windows.h>
#include "any"

#include "fnv.h"
#include "utils.h"
#include "vec3.h"
#include "studio.h"
#include "address.h"
#include "math_funcs.h"
#include "settings.h"

#include "offsets.h"
#include "g.h"
#include "render.h"
#include "player.h"
#include "player_manager.h"
#include "animstate.h"
#include "chams.h"
#include "sdk.h"
```

`solace-csgo/input.h`:

```h
#pragma once
#include "includes.h"
#include "checksum_crc.h"

#define IN_ATTACK		(1 << 0)
#define IN_JUMP			(1 << 1)
#define IN_DUCK			(1 << 2)
#define IN_FORWARD		(1 << 3)
#define IN_BACK			(1 << 4)
#define IN_USE			(1 << 5)
#define IN_CANCEL		(1 << 6)
#define IN_LEFT			(1 << 7)
#define IN_RIGHT		(1 << 8)
#define IN_MOVELEFT		(1 << 9)
#define IN_MOVERIGHT	(1 << 10)
#define IN_ATTACK2		(1 << 11)
#define IN_RUN			(1 << 12)
#define IN_RELOAD		(1 << 13)
#define IN_ALT1			(1 << 14)
#define IN_ALT2			(1 << 15)
#define IN_SCORE		(1 << 16)   // Used by client.dll for when scoreboard is held down
#define IN_SPEED		(1 << 17)	// Player is holding the speed key
#define IN_WALK			(1 << 18)	// Player holding walk key
#define IN_ZOOM			(1 << 19)	// Zoom key for HUD zoom
#define IN_WEAPON1		(1 << 20)	// weapon defines these bits
#define IN_WEAPON2		(1 << 21)	// weapon defines these bits
#define IN_BULLRUSH		(1 << 22)
#define IN_GRENADE1		(1 << 23)	// grenade 1
#define IN_GRENADE2		(1 << 24)	// grenade 2
#define	IN_ATTACK3		(1 << 25)

class c_input_system {
public:
	void EnableInput( bool state ) {
		using original_fn = void( __thiscall* )( c_input_system*, bool );
		return ( *( original_fn** )this )[ 11 ]( this, state );
	}
};

class cmd_t {
public:
	int m_pad = 0;
	int m_command_number = 0;
	int m_tick_count = 0;
	ang_t m_viewangles;
	vec3_t m_aimdirection;
	float m_forwardmove = 0;
	float m_sidemove = 0;
	float m_upmove = 0;
	int m_buttons = 0;
	char m_impulse = 0;
	int m_weaponselect = 0;
	int m_weaponsubtype = 0;
	int m_randomseed = 0;
	short m_mousedx = 0;
	short m_mousedy = 0;
	bool m_predicted = false;
	vec3_t ulk;
	vec3_t uk;
	CRC32_t GetChecksum( void ) const {
		CRC32_t crc;
		CRC32_Init( &crc );
		CRC32_ProcessBuffer( &crc, &m_command_number, sizeof( m_command_number ) );
		CRC32_ProcessBuffer( &crc, &m_tick_count, sizeof( m_tick_count ) );
		CRC32_ProcessBuffer( &crc, &m_viewangles, sizeof( m_viewangles ) );
		CRC32_ProcessBuffer( &crc, &m_aimdirection, sizeof( m_aimdirection ) );
		CRC32_ProcessBuffer( &crc, &m_forwardmove, sizeof( m_forwardmove ) );
		CRC32_ProcessBuffer( &crc, &m_sidemove, sizeof( m_sidemove ) );
		CRC32_ProcessBuffer( &crc, &m_upmove, sizeof( m_upmove ) );
		CRC32_ProcessBuffer( &crc, &m_buttons, sizeof( m_buttons ) );
		CRC32_ProcessBuffer( &crc, &m_impulse, sizeof( m_impulse ) );
		CRC32_ProcessBuffer( &crc, &m_weaponselect, sizeof( m_weaponselect ) );
		CRC32_ProcessBuffer( &crc, &m_weaponsubtype, sizeof( m_weaponsubtype ) );
		CRC32_ProcessBuffer( &crc, &m_randomseed, sizeof( m_randomseed ) );
		CRC32_ProcessBuffer( &crc, &m_mousedx, sizeof( m_mousedx ) );
		CRC32_ProcessBuffer( &crc, &m_mousedy, sizeof( m_mousedy ) );
		CRC32_Final( &crc );
		return crc;
	}
};
class verified_cmd_t {
public:
	cmd_t m_cmd;
	unsigned long m_crc;
};

class i_input {
public:
	void *vtable;
	// 0x00
	bool              m_trackir;					// 0x04
	bool              m_mouse_init;					// 0x05
	bool              m_mouse_active;				// 0x06
	bool              m_joystick_adv_init;			// 0x07
	char p[ 0x2C ];									// 0x08
	void *m_keys;						// 0x34
	char p_1[ 0x6C ];									// 0x38
	bool              m_camera_intercepting_mouse;	// 0x9C
	bool              m_camera_in_third_person;		// 0x9D
	bool              m_camera_moving_with_mouse;	// 0x9E
	vec3_t            m_camera_offset;				// 0xA0
	bool              m_camera_distance_move;		// 0xAC
	int               m_camera_old_x;				// 0xB0
	int               m_camera_old_y;				// 0xB4
	int               m_camera_x;					// 0xB8
	int               m_camera_y;					// 0xBC
	bool              m_camera_is_orthographic;		// 0xC0
	vec3_t             m_previous_view_angles;		// 0xC4
	vec3_t             m_previous_view_angles_tilt;	// 0xD0
	float             m_last_forward_move;			// 0xDC
	int               m_clear_input_state;			// 0xE0
	cmd_t *m_commands;					// 0xEC
	void *m_verified;					// 0xF0
public:
	vec3_t camera_offset;

	VFUNC( get_user_cmd( int slot, int sequence_num ), 8, cmd_t *( __thiscall * )( decltype( this ), int, int ), slot, sequence_num );
	VFUNC( camera_to_third_person( ), 35, void( __thiscall * )( decltype( this ) ) )
	VFUNC( camera_to_first_person( ), 36, void( __thiscall * )( decltype( this ) ) )
	VFUNC( camera_is_third_person( int slot = -1 ), 32, bool( __thiscall * )( decltype( this ), int ) , slot )
};
```

`solace-csgo/input_helper/input_helper.hh`:

```hh
#pragma once
#include "../menu.hh"

class c_input_helper {
	vector_2d mouse_position_{ 0, 0 };
	float scroll_y{ 0 };
	bool key_state_[ 256 ]{ };
	bool prestine_key_state_[ 256 ]{ };
	bool previous_key_state_[ 256 ]{ };
	const char* keys_[ 253 ] = { "Unassigned", "Left Mouse", "Right Mouse", "Control+Break", "Middle Mouse", "Mouse 4", "Mouse 5", "No bind", "Backspace", "TAB", "No bind", "No bind", "No bind", "ENTER", "No bind", "No bind", "SHIFT", "CTRL", "ALT", "PAUSE", "CAPS LOCK", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "ESC", "No bind", "No bind", "No bind", "No bind", "Spacebar", "Page up", "Page down", "End", "Home", "Left", "Up", "Right", "Down", "No bind", "Print", "No bind", "Print Screen", "Insert", "Delete", "No bind", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "Left Windows", "Right Windows", "No bind", "No bind", "No bind", "NUM 0", "NUM 1", "NUM 2", "NUM 3", "NUM 4", "NUM 5", "NUM 6", "NUM 7", "NUM 8", "NUM 9", "*", "+", "_", "-", ".", "/", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "NUM LOCK", "SCROLL LOCK", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "LSHIFT", "RSHIFT", "LCONTROL", "RCONTROL", "LMENU", "RMENU", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "Next Track", "Previous Track", "Stop", "Play/Pause", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", ";", "+", ",", "-", ".", "/?", "~", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "[{", "\\|", "}]", "'\"", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind", "No bind" };
public:
	auto update( ) -> void {
		for ( auto i { 0 }; i < 256; i++ ) {
			previous_key_state_[ i ] = prestine_key_state_[ i ];
			key_state_[ i ] = GetAsyncKeyState( i );
			prestine_key_state_[ i ] = key_state_[ i ];
		}
	}

	auto scroll( ) -> float {
		float ret = scroll_y;
		if ( abs(ret) > 1 )
			ret /= 10;
		scroll_y -= ret;
		return ret;
	}

	auto key_pressed( const int key ) const -> bool {
		return key_state_[ key ] && !previous_key_state_[ key ];
	}
	
	auto key_pressed_prestine( const int key ) const -> bool {
		return prestine_key_state_[ key ] && !previous_key_state_[ key ];
	}

	auto set_key( const int key, bool set ) -> void {
		key_state_[ key ] = set;
	}

	auto key_down( const int key ) const -> bool {
		return prestine_key_state_[ key ];
	}

	auto hovering( const area_t area ) const -> bool {
		return this->mouse_position_.x > area.x && this->mouse_position_.y > area.y && this->mouse_position_.x < area.x + area.w && this->mouse_position_.y < area.y + area.h;
	}

	auto m_mouse_position( ) const -> vector_2d {
		return this->mouse_position_;
	}

	auto set_mouse_position( const int x, const int y ) -> void {
		this->mouse_position_.x = x;
		this->mouse_position_.y = y;
	}
	
	void set_scroll_position( float i ) {
		this->scroll_y = 0;
		this->scroll_y = i*30.f;
	}

	auto set_mouse_position( const vector_2d mouse_position ) -> void {
		this->mouse_position_ = mouse_position;
	}

	[[nodiscard]] auto m_key( const int index ) const -> const char* {
		return this->keys_[ index ];
	}

}; inline c_input_helper input_helper;
```

`solace-csgo/interfaces.h`:

```h
#pragma once

#include <d3d9.h>
#include "vmt.h"

class interfaces_t {
public:
	template<typename t = address>
	class c_base_interface {
		const char *lib = "";
		const char *ver = "";
		t *ptr = nullptr;
		c_hook m_hook;
	public:
		~c_base_interface( ) { m_hook.reset( ); }
		c_base_interface( const char *lib, const char *ver, bool hook = true ) : lib( lib ), ver( ver ) { 
			ptr = util::capture_interface< t *>( lib, ver ); 
			if ( hook ) m_hook.init( reinterpret_cast< uintptr_t >( ptr ) ); 
		}
		c_base_interface( void *ptr_, bool hook = true ) { 
			ptr = static_cast< t * >( ptr_ ); 
			if ( hook ) m_hook.init( reinterpret_cast< uintptr_t >( ptr ) );
		}
		__forceinline t *operator->( ) { return ptr; }
		__forceinline operator t *( ) { return ptr; }
		explicit __forceinline operator bool( ) const { return ptr; }
		explicit __forceinline operator address( ) const { return address( ptr ); }
		explicit __forceinline operator void *( ) const { return ptr; }
		__forceinline c_hook *hook( ) { return &m_hook; }
	};
protected:


	c_base_interface<c_input_system> m_input_system{ "inputsystem.dll", "InputSystemVersion001", false };
	c_base_interface<c_base_client> m_client{ "client.dll", "VClient018" };
	c_base_interface<c_surface> m_surface{ "vguimatsurface.dll", "VGUI_Surface031" };
	c_base_interface<c_global_vars> m_globals{ static_cast< void * >( *address( m_client ).to< address * >( )[ 11 ].to< address * >( 10 ) ), false };
	c_base_interface<c_engine_client> m_engine{ "engine.dll", "VEngineClient014" };
	c_base_interface<c_engine_trace> m_trace{ "engine.dll", "EngineTraceClient004" };
	c_base_interface<debug_overlay_t> m_debug_overlay{ "engine.dll", "VDebugOverlay004" };
	c_base_interface<c_entity_list> m_entity_list{ "client.dll", "VClientEntityList003" };
	c_base_interface<i_render_view> m_render_view{ "engine.dll", "VEngineRenderView014" };
	c_base_interface<i_material_system> m_material_system{ "materialsystem.dll", "VMaterialSystem080" };
	c_base_interface<iv_model_render> m_model_render{ "engine.dll", "VEngineModel016" };
	c_base_interface<i_console> m_console{ "vstdlib.dll", "VEngineCvar007" };
	c_base_interface<model_info_t> m_model_info{ "engine.dll", "VModelInfoClient004" };
	c_base_interface<phys_surface_props_t> m_phys_surface{ "vphysics.dll", "VPhysicsSurfaceProps001" };
	c_base_interface<i_mdl_cache> m_mdlcache{ "datacache.dll", "MDLCache004", false };
	c_base_interface<address> m_studio_render{ "studiorender.dll", "VStudioRender026" };
	c_base_interface<player_prediction> m_prediction{ "client.dll", "VClientPrediction001" };
	c_base_interface<player_game_movement> m_game_movement{ "client.dll", "GameMovement001" };
	c_base_interface<IGameEventManager2> m_event{ "engine.dll", "GAMEEVENTSMANAGER002" };
	c_base_interface<panel_t> m_panel{ "vgui2.dll", "VGUI_Panel009" };
	c_base_interface<i_weapon_system> m_weapon_system{ *reinterpret_cast< void ** >( util::find( "client.dll", "8B 35 ? ? ? ? FF 10 0F B7 C0" ) + 2 ), false };
	c_base_interface<mem_alloc_t> m_mem_alloc{ *reinterpret_cast< void ** >( GetProcAddress( GetModuleHandleA( "tier0.dll" ), "g_pMemAlloc" ) ), false };
	c_base_interface<IDirect3DDevice9> m_device{ **reinterpret_cast< void *** >( util::find( "shaderapidx9.dll", "A1 ? ? ? ? 50 8B 08 FF 51 0C" ) + 0x1 ) };
	//c_base_interface<void> m_viewrender{ **reinterpret_cast< void *** >( util::find( "client.dll",  "8B 0D ? ? ? ? 8B 01 FF 50 4C 8B 06" ) + 2 ), false };
	c_base_interface<client_state_t> m_client_state{ **reinterpret_cast< client_state_t *** > ( ( *reinterpret_cast< uintptr_t ** > ( m_engine.operator c_engine_client *(  ) ) )[ 12 ] + 0x10 ), false };
	c_base_interface<player_move_helper> m_move_helper{ **reinterpret_cast< void *** >( util::find( "client.dll", "8B 0D ? ? ? ? 8B 46 08 68" ) + 2 ) };
	c_base_interface<i_input> m_input{ *reinterpret_cast< i_input ** >( util::find( "client.dll", "B9 ? ? ? ? F3 0F 11 04 24 FF 50 10" ) + 1 ) };
	c_base_interface<void> m_client_mode{ address( util::get_virtual_function<uintptr_t>( m_client, 10 ) + 0x5  ).get<void*>(2) };
	void *m_hookable_state = reinterpret_cast< void * >( reinterpret_cast< uintptr_t * >( reinterpret_cast< uintptr_t >( m_client_state.operator client_state_t * ( ) ) + 0x8 ) );

public:


	interfaces_t( ) = default;

	[[nodiscard]] decltype( m_render_view )& render_view( ) {
		return m_render_view;
	}
	[[nodiscard]] decltype( m_input_system )& input_system( ) {
		return m_input_system;
	}
	[[nodiscard]] decltype( m_surface )& surface( ) {
		return m_surface;
	}
	
	[[nodiscard]] decltype( m_panel ) &panel( ) {
		return m_panel;
	}
	
	[[nodiscard]] decltype( m_mdlcache ) &mdlcache( ) {
		return m_mdlcache;
	}
	
	[[nodiscard]] decltype( m_input ) &input( ) {
		return m_input;
	}

	[[nodiscard]] decltype( m_material_system ) &material_system( ) {
		return m_material_system;
	}
	[[nodiscard]] decltype( m_event ) &events( ) {
		return m_event;
	}
	
	[[nodiscard]] decltype( m_game_movement ) &game_movement( ) {
		return m_game_movement;
	}
	
	[[nodiscard]] decltype( m_move_helper ) &move_helper( ) {
		return m_move_helper;
	}
	
	[[nodiscard]] decltype( m_prediction ) &prediction( ) {
		return m_prediction;
	}
	
	[[nodiscard]] decltype( m_studio_render ) &studio_render( ) {
		return m_studio_render;
	}

	[[nodiscard]] decltype( m_weapon_system ) &weapon_system( ) {
		return m_weapon_system;
	}
	
	[[nodiscard]] decltype( m_debug_overlay ) &debug_overlay( ) {
		return m_debug_overlay;
	}
	
	[[nodiscard]] decltype( m_phys_surface ) &phys_surface( ) {
		return m_phys_surface;
	}

	[[nodiscard]] decltype( m_model_render ) &model_render( ) {
		return m_model_render;
	}

	[[nodiscard]] decltype( m_console ) &console( ) {
		return m_console;
	}
	
	[[nodiscard]] decltype( m_model_info ) &model_info( ) {
		return m_model_info;
	}

	[[nodiscard]] decltype( m_globals ) &globals( ) {
		return m_globals;
	}

	[[nodiscard]] decltype( m_client ) &client( ) {
		return m_client;
	}

	[[nodiscard]] decltype( m_engine ) &engine( ) {
		return m_engine;
	}

	[[nodiscard]] decltype( m_trace ) &trace( ) {
		return m_trace;
	}

	[[nodiscard]] decltype( m_client_mode ) &client_mode( ) {
		return m_client_mode;
	}

	[[nodiscard]] decltype( m_entity_list ) &entity_list( ) {
		return m_entity_list;
	}

	[[nodiscard]] decltype( m_device ) &device( ) {
		return m_device;
	}

	[[nodiscard]] decltype( m_mem_alloc ) &mem_alloc( ) {
		return m_mem_alloc;
	}

	[[nodiscard]] decltype( m_client_state ) &client_state( ) {
		return m_client_state;
	}
	
	[[nodiscard]] void *hookable_client_state( ) const {
		return m_hookable_state;
	}
};

```

`solace-csgo/material_system.h`:

```h
#pragma once
#include "includes.h"

class vec3_t;

enum image_format {
	IMAGE_FORMAT_UNKNOWN = -1,
	IMAGE_FORMAT_RGBA8888 = 0,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_R32F,
	IMAGE_FORMAT_RGB323232F,
	IMAGE_FORMAT_RGBA32323232F,
	IMAGE_FORMAT_NV_DST16,
	IMAGE_FORMAT_NV_DST24,
	IMAGE_FORMAT_NV_INTZ,
	IMAGE_FORMAT_NV_RAWZ,
	IMAGE_FORMAT_ATI_DST16,
	IMAGE_FORMAT_ATI_DST24,
	IMAGE_FORMAT_NV_NULL,
	IMAGE_FORMAT_ATI2N,
	IMAGE_FORMAT_ATI1N,
	IMAGE_FORMAT_DXT1_RUNTIME,
	IMAGE_FORMAT_DXT5_RUNTIME,
	NUM_IMAGE_FORMATS
};

enum material_var_flags_t {
	material_var_debug = ( 1 << 0 ),
	material_var_no_debug_override = ( 1 << 1 ),
	material_var_no_draw = ( 1 << 2 ),
	material_var_use_in_fillrate_mode = ( 1 << 3 ),
	material_var_vertexcolor = ( 1 << 4 ),
	material_var_vertexalpha = ( 1 << 5 ),
	material_var_selfillum = ( 1 << 6 ),
	material_var_additive = ( 1 << 7 ),
	material_var_alphatest = ( 1 << 8 ),
	//material_var_unused = (1 << 9),
	material_var_znearer = ( 1 << 10 ),
	material_var_model = ( 1 << 11 ),
	material_var_flat = ( 1 << 12 ),
	material_var_nocull = ( 1 << 13 ),
	material_var_nofog = ( 1 << 14 ),
	material_var_ignorez = ( 1 << 15 ),
	material_var_decal = ( 1 << 16 ),
	material_var_envmapsphere = ( 1 << 17 ), // obsolete
	material_var_unused = ( 1 << 18 ), // unused
	material_var_envmapcameraspace = ( 1 << 19 ), // obsolete
	material_var_basealphaenvmapmask = ( 1 << 20 ),
	material_var_translucent = ( 1 << 21 ),
	material_var_normalmapalphaenvmapmask = ( 1 << 22 ),
	material_var_needs_software_skinning = ( 1 << 23 ), // obsolete
	material_var_opaquetexture = ( 1 << 24 ),
	material_var_envmapmode = ( 1 << 25 ), // obsolete
	material_var_suppress_decals = ( 1 << 26 ),
	material_var_halflambert = ( 1 << 27 ),
	material_var_wireframe = ( 1 << 28 ),
	material_var_allowalphatocoverage = ( 1 << 29 ),
	material_var_alpha_modified_by_proxy = ( 1 << 30 ),
	material_var_vertexfog = ( 1 << 31 ),
};

enum preview_image_retval_t {
	material_preview_image_bad = 0,
	material_preview_image_ok,
	material_no_preview_image,
};

typedef int ImageFormat;
class IMaterialVar;
typedef int VertexFormat_t;
typedef int MaterialPropertyTypes_t;
class i_material_var;
struct model_t;
class i_material;
class c_studio_hdr;
class c_key_values;
class i_material_var;
struct studiohwdata_t;
struct color_mesh_info_t;
struct draw_model_info_t;
class i_client_renderable;
class data_cache_handle_t;
class i_mat_render_context;
struct material_lighting_state_t;
typedef int vertex_format_t;
typedef void *light_cache_handle_t;
typedef void *studio_decal_handle_t;
typedef int material_property_types_t;
typedef unsigned short model_instance_handle_t;
using material_handle_t = unsigned short;

class i_material {
public:
	virtual const char *get_name( ) const = 0;
	virtual const char *get_texture_group_name( ) const = 0;
	virtual preview_image_retval_t get_preview_image_properties( int *width, int *height, image_format *image_format, bool *is_translucent ) const = 0;
	virtual preview_image_retval_t get_preview_image( unsigned char *data, int width, int height, image_format image_format ) const = 0;
	virtual int get_mapping_width( ) = 0;
	virtual int get_mapping_height( ) = 0;
	virtual int get_num_animation_frames( ) = 0;
	virtual bool in_material_page( void ) = 0;
	virtual void get_material_offset( float *offset ) = 0;
	virtual void get_material_scale( float *scale ) = 0;
	virtual i_material *get_material_page( void ) = 0;
	virtual i_material_var *find_var( const char *var_name, bool *found, bool complain = true ) = 0;
	virtual void increment_reference_count( void ) = 0;
	virtual void decrement_reference_count( void ) = 0;
	inline void add_ref( ) { increment_reference_count( ); }
	inline void release( ) { decrement_reference_count( ); }
	virtual int get_enumeration_id( void ) const = 0;
	virtual void get_low_res_color_sample( float s, float t, float *color ) const = 0;
	virtual void recompute_state_snapshots( ) = 0;
	virtual bool is_translucent( ) = 0;
	virtual bool is_alpha_tested( ) = 0;
	virtual bool is_vertex_lit( ) = 0;
	virtual vertex_format_t get_vertex_format( ) const = 0;
	virtual bool has_proxy( void ) const = 0;
	virtual bool uses_env_cubemap( void ) = 0;
	virtual bool needs_tangent_space( void ) = 0;
	virtual bool needs_power_of_two_frame_buffer_texture( bool check_specific_to_this_frame = true ) = 0;
	virtual bool needs_full_frame_buffer_texture( bool check_specific_to_this_frame = true ) = 0;
	virtual bool needs_software_skinning( void ) = 0;
	virtual void alpha_modulate( float alpha ) = 0;
	virtual void color_modulate( float r, float g, float b ) = 0;
	virtual void set_material_var_flag( material_var_flags_t flag, bool on ) = 0;
	virtual bool get_material_var_flag( material_var_flags_t flag ) const = 0;
	virtual void get_reflectivity( vec3_t &reflect ) = 0;
	virtual bool get_property_flag( material_property_types_t  type ) = 0;
	virtual bool is_two_sided( ) = 0;
	virtual void set_shader( const char *shader_name ) = 0;
	virtual int get_num_passes( void ) = 0;
	virtual int get_texture_memory_bytes( void ) = 0;
	virtual void refresh( ) = 0;
	virtual bool needs_lightmap_blend_alpha( void ) = 0;
	virtual bool needs_software_lighting( void ) = 0;
	virtual int shader_param_count( ) const = 0;
	virtual i_material_var **get_shader_params( void ) = 0;
	virtual bool is_error_material( ) const = 0;
	virtual void unused( ) = 0;
	virtual float get_alpha_modulation( ) = 0;
	virtual void get_color_modulation( float *r, float *g, float *b ) = 0;
	virtual bool is_translucent_under_modulation( float alpha_modulation = 1.0f ) const = 0;
	virtual i_material_var *find_var_fast( char const *var_name, unsigned int *token ) = 0;
	virtual void set_shader_and_params( c_key_values *key_values ) = 0;
	virtual const char *get_shader_name( ) const = 0;
	virtual void delete_if_unreferenced( ) = 0;
	virtual bool is_sprite_card( ) = 0;
	virtual void call_bind_proxy( void *proxy_data ) = 0;
	virtual void refresh_preserving_material_vars( ) = 0;
	virtual bool was_reloaded_from_whitelist( ) = 0;
	virtual bool set_temp_excluded( bool set, int excluded_dimension_limit ) = 0;
	virtual int get_reference_count( ) const = 0;
};


#define DECLARE_POINTER_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#define MAXSTUDIOSKINS		32

// These are given to FindMaterial to reference the texture groups that Show up on the
#define TEXTURE_GROUP_LIGHTMAP				"Lightmaps"
#define TEXTURE_GROUP_WORLD				"World textures"
#define TEXTURE_GROUP_MODEL				"Model textures"
#define TEXTURE_GROUP_VGUI				"VGUI textures"
#define TEXTURE_GROUP_PARTICLE				"Particle textures"
#define TEXTURE_GROUP_DECAL				"Decal textures"
#define TEXTURE_GROUP_SKYBOX				"SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS			"ClientEffect textures"
#define TEXTURE_GROUP_OTHER				"Other textures"
#define TEXTURE_GROUP_PRECACHED				"Precached"
#define TEXTURE_GROUP_CUBE_MAP				"CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET			"RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED			"Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER		"Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER		"Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER		"Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER			"DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL			"ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS			"Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS			"Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE		"RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS			"Morph Targets"

class	i_ms_mat;
class	i_ms_mesh;
class	i_ms_vertex_buffer;
class	i_ms_index_buffer;
struct	i_ms_system_config_t;
class	i_ms_v_matrix;
class	matrix3x4_t;
class	i_ms_texture;
struct	i_ms_hwid_t;
class	i_ms_key_values;
class	i_ms_shader;
class	i_ms_vtx_texture;
class	i_ms_morph;
class	i_mat_render_ctx;
class	i_ms_call_queue;
struct	i_ms_morph_weight_t;
class	i_ms_file_list;
struct	i_ms_vtx_stream_spec_t;
struct	i_ms_shader_stencil_state_t;
struct	i_ms_mesh_instance_data_t;
class	i_ms_client_mat_sys;
class	i_ms_paint_mat;
class	i_ms_paint_map_data_mgr;
class	i_ms_paint_map_texture_mgr;
class	i_ms_gpu_mem_stats;
struct	i_ms_aspect_ratio_info_t;
struct	i_ms_cascaded_shadow_mapping_state_t;

class	i_ms_proxy_factory;
class	i_ms_texture;
class	i_ms_sys_hardware_cfg;
class	i_ms_shadow_mgr;

enum i_ms_compiled_vtf_flags {
	TEXTURE_FLAGS_POINT_SAMPLE = 1 << 0,
	TEXTURE_FLAGS_TRILINEAR = 1 << 1,
	TEXTURE_FLAGS_CLAMPS = 1 << 2,
	TEXTURE_FLAGS_CLAMPT = 1 << 3,
	TEXTURE_FLAGS_ANISOTROPIC = 1 << 4,
	TEXTURE_FLAGS_HINT_DXT5 = 1 << 5,
	TEXTURE_FLAGS_PWL_CORRECTED = 1 << 6,
	TEXTURE_FLAGS_NORMAL = 1 << 7,
	TEXTURE_FLAGS_NO_MIP = 1 << 8,
	TEXTURE_FLAGS_NO_LOD = 1 << 9,
	TEXTURE_FLAGS_ALL_MIPS = 1 << 10,
	TEXTURE_FLAGS_PROCEDURAL = 1 << 11,
	TEXTURE_FLAGS_ONE_BIT_ALPHA = 1 << 12,
	TEXTURE_FLAGS_EIGHT_BIT_ALPHA = 1 << 13,
	TEXTURE_FLAGS_ENVMAP = 1 << 14,
	TEXTURE_FLAGS_RENDER_TARGET = 1 << 15,
	TEXTURE_FLAGS_DEPTH_RENDER_TARGET = 1 << 16,
	TEXTURE_FLAGS_NO_DEBUG_OVERRIDE = 1 << 17,
	TEXTURE_FLAGS_SINGLE_COPY = 1 << 18,
	TEXTURE_FLAGS_PRE_SRGB = 1 << 19,
	TEXTURE_FLAGS_UNUSED_0x001 = 1 << 20,
	TEXTURE_FLAGS_UNUSED_0x002 = 1 << 21,
	TEXTURE_FLAGS_UNUSED_0x004 = 1 << 22,
	TEXTURE_FLAGS_NO_DEPTH_BUFFER = 1 << 23,
	TEXTURE_FLAGS_UNUSED_0x01 = 1 << 24,
	TEXTURE_FLAGS_CLAMPU = 1 << 25,
	TEXTURE_FLAGS_VERTEX_TEXTURE = 1 << 26,
	TEXTURE_FLAGS_SSBUMP = 1 << 27,
	TEXTURE_FLAGS_UNUSED_0x1 = 1 << 28,
	TEXTURE_FLAGS_BORDER = 1 << 29,
	TEXTURE_FLAGS_UNUSED_0x4 = 1 << 30,
	TEXTURE_FLAGS_UNUSED_0x8 = 1 << 31
};

enum i_ms_standard_lightmap_t {
	MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE = -1,
	MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE_BUMP = -2,
	MATERIAL_SYSTEM_LIGHTMAP_PAGE_USER_DEFINED = -3
};

struct i_ms_sort_info_t {
	i_ms_mat *material;
	int		lightmap_page_id;
};

enum i_matsys_material_thread_mode_t {
	MATERIAL_SINGLE_THREADED,
	MATERIAL_QUEUED_SINGLE_THREADED,
	MATERIAL_QUEUED_THREADED
};

enum i_ms_material_ctx_type_t {
	MATERIAL_HARDWARE_CONTEXT,
	MATERIAL_QUEUED_CONTEXT,
	MATERIAL_NULL_CONTEXT
};

enum {
	MATERIAL_ADAPTER_NAME_LENGTH = 1 << 9
};

struct i_ms_material_texture_info_t {
	int exclude_information;
};

struct i_ms_app_perf_counters_info_t {
	float ms_main;
	float ms_mst;
	float ms_gpu;
	float ms_flip;
	float ms_total;
};

struct i_ms_app_instant_counters_info_t {
	uint32_t cpu_activity_mask;
	uint32_t deferred_words_allocated;
};

struct i_matsys_material_adapter_info_t {
	char		driver_name[ MATERIAL_ADAPTER_NAME_LENGTH ];
	unsigned int	vendor_id;
	unsigned int	device_id;
	unsigned int	sub_sys_id;
	unsigned int	revision;
	int		dx_support_level;
	int		min_dx_support_level;
	int		max_dx_support_level;
	unsigned int	driver_version_high;
	unsigned int	driver_version_low;
};

struct i_ms_mat_video_mode_t {
	int		width;
	int		height;
	image_format 	format;
	int		refresh_rate;
};

enum i_ms_hdr_type_t {
	HDR_TYPE_NONE,
	HDR_TYPE_INTEGER,
	HDR_TYPE_FLOAT,
};

enum i_ms_res_change_flags_t {
	MATERIAL_RESTORE_VERTEX_FORMAT_CHANGED = 1,
	MATERIAL_RESTORE_RELEASE_MANAGED_RESOURCES
};

enum i_ms_render_target_size_mode_t {
	RT_SIZE_NO_CHANGE,
	RT_SIZE_DEFAULT,
	RT_SIZE_PICMIP,
	RT_SIZE_HDR,
	RT_SIZE_FULL_FRAME_BUFFER,
	RT_SIZE_OFFSCREEN,
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP
};

enum i_ms_mat_render_target_depth_t {
	MATERIAL_RT_DEPTH_SHARED,
	MATERIAL_RT_DEPTH_SEPARATE,
	MATERIAL_RT_DEPTH_NONE,
	MATERIAL_RT_DEPTH_ONLY
};

typedef void( *mat_buffer_release_func_t )( int flags );
typedef void( *mat_buffer_restore_func_t )( int flags );
typedef void( *mode_change_callback_function_t )( void );
typedef void( *end_frame_cleanup_function_t )( void );
typedef bool( *end_frame_prior_to_next_ctx_function_t )( void );
typedef void( *on_level_shutdown_function_t )( void *data );

typedef unsigned short mat_handle_t;
DECLARE_POINTER_HANDLE( mat_lock_t );

class i_material_system {
public:
	i_material *find_material( char const *material_name, const char *group_name, bool complain = true, const char *complain_prefix = 0 ) {
		using fn = i_material * ( __thiscall * )( i_material_system *, char const *, const char *, bool, const char * );
		return ( *( fn ** )this )[ 84 ]( this, material_name, group_name, complain, complain_prefix );
	}
	material_handle_t first_material( ) {
		using fn = material_handle_t( __thiscall * )( i_material_system * );
		return ( *( fn ** )this )[ 86 ]( this );
	}
	material_handle_t next_material( material_handle_t handle ) {
		using fn = material_handle_t( __thiscall * )( i_material_system *, material_handle_t );
		return ( *( fn ** )this )[ 87 ]( this, handle );
	}
	material_handle_t invalid_material_handle( ) {
		using fn = material_handle_t( __thiscall * )( i_material_system * );
		return ( *( fn ** )this )[ 88 ]( this );
	}
	i_material *get_material( material_handle_t handle ) {
		using fn = i_material * ( __thiscall * )( i_material_system *, material_handle_t );
		return ( *( fn ** )this )[ 89 ]( this, handle );
	}
	int	get_materials_count( ) {
		using fn = int( __thiscall * )( i_material_system * );
		return ( *( fn ** )this )[ 90 ]( this );
	}
};


class iv_model_render {
public:
	void override_material( i_material *material ) {
		using fn = void( __thiscall * )( iv_model_render *, i_material *, int, int );
		return ( *( fn ** )this )[ 1 ]( this, material, 0, 0 );
	}
};


class i_render_view {
private:
	virtual void __pad0( );
	virtual void __pad1( );
	virtual void __pad2( );
	virtual void __pad3( );

public:
	virtual void set_blend( float blend ) = 0;
	virtual float get_blend( void ) = 0;

	virtual void SetColorModulation( float const *blend ) = 0;
	virtual void get_color_modulation( float *blend ) = 0;

	__forceinline void modulate_color( color col ) {
		float color[ ] = { ( float )col.m_r(  ) / 255,  ( float )col.m_g(  ) / 255, ( float )col.m_b(  ) / 255,  1.f };
		SetColorModulation( color );
	}
};
```

`solace-csgo/math_funcs.cpp`:

```cpp
#include "math_funcs.h"
#include "includes.h"
#include "view_matrix.hpp"
#include "sdk.h"

bool math::world_to_screen( const vec3_t &origin, vec3_t &screen ) {
	static std::uintptr_t view_matrix;
	if ( !view_matrix )
		view_matrix = *reinterpret_cast< std::uintptr_t * >( reinterpret_cast< std::uintptr_t >( util::find( "client.dll", "0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9" ) ) + 3 ) + 176;

	const auto &matrix = *reinterpret_cast< view_matrix_t * >( view_matrix );

	const auto w = matrix.m[ 3 ][ 0 ] * origin.x + matrix.m[ 3 ][ 1 ] * origin.y + matrix.m[ 3 ][ 2 ] * origin.z + matrix.m[ 3 ][ 3 ];
	if ( w < 0.001f )
		return false;

	int x, y;
	g.m_interfaces->engine( )->get_screen_size( x, y );

	screen.x = static_cast< float >( x ) / 2.0f;
	screen.y = static_cast< float >( y ) / 2.0f;

	screen.x *= 1.0f + ( matrix.m[ 0 ][ 0 ] * origin.x + matrix.m[ 0 ][ 1 ] * origin.y + matrix.m[ 0 ][ 2 ] * origin.z + matrix.m[ 0 ][ 3 ] ) / w;
	screen.y *= 1.0f - ( matrix.m[ 1 ][ 0 ] * origin.x + matrix.m[ 1 ][ 1 ] * origin.y + matrix.m[ 1 ][ 2 ] * origin.z + matrix.m[ 1 ][ 3 ] ) / w;

	return true;
}
float math::distSegmentToSegment(
	const vec3_t &p1, const vec3_t &p2,
	const vec3_t &q1, const vec3_t &q2,
	float &invariant1, float &invariant2 ) {
	return sqrtf( distSegmentToSegmentSqr(p1, p2, q1, q2, invariant1, invariant2 ) );
}

float math::distSegmentToSegmentSqr(
	const vec3_t& p1, const vec3_t& p2,
	const vec3_t& q1, const vec3_t& q2,
	float& invariant1, float& invariant2 ) {

	static const auto kSmallNumber = 0.0001f;
	const auto u = p2 - p1;
	const auto v = q2 - q1;
	const auto w = p1 - q1;
	const auto a = u.dot( u );
	const auto b = u.dot( v );
	const auto c = v.dot( v );
	const auto d = u.dot( w );
	const auto e = v.dot( w );
	const auto f = a * c - b * b;
	// s1,s2 and t1,t2 are the parametric representation of the intersection.
		// they will be the invariants at the end of this simple computation.
	float s1;
	auto s2 = f;
	float t1;
	auto t2 = f;

	if ( f < kSmallNumber ) {
		s1 = 0.0;
		s2 = 1.0;
		t1 = e;
		t2 = c;

	}
	else {
		s1 = ( b * e - c * d );
		t1 = ( a * e - b * d );
		if ( s1 < 0.0 ) {
			s1 = 0.0;
			t1 = e;
			t2 = c;

		}
		else if ( s1 > s2 ) {
			s1 = s2;
			t1 = e + b;
			t2 = c;

		}

	}

	if ( t1 < 0.0f ) {
		t1 = 0.0f;
		if ( -d < 0.0f )
			s1 = 0.0f;
		else if ( -d > a )
			s1 = s2;
		else {
			s1 = -d;
			s2 = a;

		}

	}
	else if ( t1 > t2 ) {
		t1 = t2;
		if ( ( -d + b ) < 0.0f )
			s1 = 0;
		else if ( ( -d + b ) > a )
			s1 = s2;
		else {
			s1 = ( -d + b );
			s2 = a;
		}
	}
	invariant1 = ( ( std::abs( s1 ) < kSmallNumber ) ? 0.0f : s1 / s2 );
	invariant2 = ( std::abs( t1 ) < kSmallNumber ? 0.0f : t1 / t2 );

	return ( w + ( u * invariant1 ) - ( v * invariant2 ) ).length_sqr( );

}
void math::correct_movement( cmd_t *cmd ) {
	vec3_t wish_forward, wish_right, wish_up, cmd_forward, cmd_right, cmd_up;

	auto movedata = vec3_t( cmd->m_forwardmove, cmd->m_sidemove, cmd->m_upmove );

	if ( !( g.m_local->flags( ) & fl_onground ) && cmd->m_viewangles.z != 0.f )
		movedata.y = 0.f;

	g.m_view_angles.vectors( &wish_forward, &wish_right, &wish_up );
	cmd->m_viewangles.vectors( &cmd_forward, &cmd_right, &cmd_up );

	const auto v8 = sqrt( wish_forward.x * wish_forward.x + wish_forward.y * wish_forward.y ), v10 = sqrt(
		           wish_right.x * wish_right.x + wish_right.y * wish_right.y ), v12 = sqrt( wish_up.z * wish_up.z );

	const vec3_t wish_forward_norm( 1.0f / v8 * wish_forward.x, 1.0f / v8 * wish_forward.y, 0.f ),
		wish_right_norm( 1.0f / v10 * wish_right.x, 1.0f / v10 * wish_right.y, 0.f ),
		wish_up_norm( 0.f, 0.f, 1.0f / v12 * wish_up.z );

	const auto v14 = sqrt( cmd_forward.x * cmd_forward.x + cmd_forward.y * cmd_forward.y ), v16 = sqrt(
		cmd_right.x * cmd_right.x + cmd_right.y * cmd_right.y ), v18 = sqrt( cmd_up.z * cmd_up.z );

	const vec3_t cmd_forward_norm( 1.0f / v14 * cmd_forward.x, 1.0f / v14 * cmd_forward.y, 1.0f / v14 * 0.0f ),
		cmd_right_norm( 1.0f / v16 * cmd_right.x, 1.0f / v16 * cmd_right.y, 1.0f / v16 * 0.0f ),
		cmd_up_norm( 0.f, 0.f, 1.0f / v18 * cmd_up.z );

	const auto v22 = wish_forward_norm.x * movedata.x, v26 = wish_forward_norm.y * movedata.x, v28 =
		wish_forward_norm.z * movedata.x, v24 = wish_right_norm.x * movedata.y, v23 =
		wish_right_norm.y * movedata.y, v25 = wish_right_norm.z * movedata.y, v30 =
		wish_up_norm.x * movedata.z, v27 = wish_up_norm.z * movedata.z, v29 =
		wish_up_norm.y * movedata.z;

	vec3_t correct_movement;
	correct_movement.x = cmd_forward_norm.x * v24 + cmd_forward_norm.y * v23 + cmd_forward_norm.z * v25
		+ ( cmd_forward_norm.x * v22 + cmd_forward_norm.y * v26 + cmd_forward_norm.z * v28 )
		+ ( cmd_forward_norm.y * v30 + cmd_forward_norm.x * v29 + cmd_forward_norm.z * v27 );
	correct_movement.y = cmd_right_norm.x * v24 + cmd_right_norm.y * v23 + cmd_right_norm.z * v25
		+ ( cmd_right_norm.x * v22 + cmd_right_norm.y * v26 + cmd_right_norm.z * v28 )
		+ ( cmd_right_norm.x * v29 + cmd_right_norm.y * v30 + cmd_right_norm.z * v27 );
	correct_movement.z = cmd_up_norm.x * v23 + cmd_up_norm.y * v24 + cmd_up_norm.z * v25
		+ ( cmd_up_norm.x * v26 + cmd_up_norm.y * v22 + cmd_up_norm.z * v28 )
		+ ( cmd_up_norm.x * v30 + cmd_up_norm.y * v29 + cmd_up_norm.z * v27 );

	cmd->m_forwardmove = std::clamp( correct_movement.x, -450.f, 450.f );
	cmd->m_sidemove = std::clamp( correct_movement.y, -450.f, 450.f );
	cmd->m_upmove = std::clamp( correct_movement.z, -320.f, 320.f );
}

float math::minimum_distance( vec3_t v, vec3_t w, vec3_t p ) {
	// Return minimum distance between line segment vw and point p
	const float l2 = ( v - w ).length_sqr( );  // i.e. |w-v|^2 -  avoid a sqrt
	if ( l2 == 0.0 ) return ( p - v ).length( );   // v == w case
												   // Consider the line extending the segment, parameterized as v + t (w - v).
												   // We find projection of point p onto the line. 
												   // It falls where t = [(p-v) . (w-v)] / |w-v|^2
												   // We clamp t from [0,1] to handle points outside the segment vw.
	const float t = max( 0, min( 1, ( p - v ).dot( w - v ) / l2 ) );
	const vec3_t projection = v + ( w - v ) * t;  // Projection falls on the segment
	return ( p - projection ).length( );
}

float math::normalize_angle( float ang, float max ) {
	while ( ang > max )
		ang -= max * 2;
	while ( ang < -max )
		ang += max * 2;
	return ang;
}

float math::AngleDiff( float destAngle, float srcAngle ) {
	float delta;

	delta = fmodf( destAngle - srcAngle, 360.0f );
	if ( destAngle > srcAngle ) {
		if ( delta >= 180 )
			delta -= 360;
	}
	else {
		if ( delta <= -180 )
			delta += 360;
	}
	return delta;
}

void math::sin_cos ( float r, float *s, float *c ) {
	*s = std::sin( r );
	*c = std::cos( r );
}





math::custom_ray_t::custom_ray_t ( vec3_t start, vec3_t end ) {
	init( start, end );
}

void math::custom_ray_t::init( vec3_t start, vec3_t end ) {
	m_start = start;
	m_end = end;
	m_ray_dir = ( m_end - m_start ).normalized( );

}

vec3_t math::get_closest_on_line ( vec3_t start, vec3_t end, vec3_t target ) {
	const auto line_delta = end - start;
	const auto target_delta = target - start;
	const auto line_length_sqr = line_delta.length_sqr( );
	auto fraction = (target_delta.length_sqr( )) / line_length_sqr;
	if ( fraction < 0 )
		fraction = 0;
	if ( fraction > 1 )
		fraction = 1;
	return start + line_delta * fraction;
}

vec3_t math::closest_to_point ( const custom_ray_t &ray, const vec3_t &point ) {
	const auto delta = point - ray.m_start;
	const auto magnitude = delta.dot( ray.m_ray_dir );

	return ray.m_ray_dir * magnitude + ray.m_start;
}
float math::dist_Segment_to_Segment( const custom_ray_t &ray, const vec3_t &min, const vec3_t &max ) {
	const auto u = max - min;
	const auto v = ray.m_end - ray.m_start;
	const auto w = min - ray.m_start;
	const auto a = u.dot( u );
	const auto b = u.dot( v );
	const auto c = v.dot( v );
	const auto d = u.dot( w );
	const auto e = v.dot( w );
	const auto D = a * c - b * b;
	float    sc, sN, sD = D;
	float    tc, tN, tD = D;

	if ( D < FLT_MIN ) {
		sN = 0.0;
		sD = 1.0;
		tN = e;
		tD = c;
	} else {
		sN = ( b * e - c * d );
		tN = ( a * e - b * d );
		if ( sN < 0.0 ) {
			sN = 0.0;
			tN = e;
			tD = c;
		} else if ( sN > sD ) {
			sN = sD;
			tN = e + b;
			tD = c;
		}
	}

	if ( tN < 0.0 ) {
		tN = 0.0;

		if ( -d < 0.0 )
			sN = 0.0;
		else if ( -d > a )
			sN = sD;
		else {
			sN = -d;
			sD = a;
		}
	} else if ( tN > tD ) {
		tN = tD;

		if ( ( -d + b ) < 0.0 )
			sN = 0;
		else if ( ( -d + b ) > a )
			sN = sD;
		else {
			sN = ( -d + b );
			sD = a;
		}
	}

	sc = ( abs( sN ) < FLT_MIN ? 0.0 : sN / sD );
	tc = ( abs( tN ) < FLT_MIN ? 0.0 : tN / tD );

	const auto dP = w + ( u * sc ) - ( v * tc );

	return dP.length(  );
}
bool math::intersects_capsule ( const custom_ray_t &ray, const vec3_t &min, const vec3_t &max,
                                const float &radius ) {
	const auto RC = ray.m_start - min;
	const auto axis = max - min;
	auto n = ray.m_ray_dir.cross( axis );
	float d;
	vec3_t D;
	const auto ln = n.normalize( );
	if ( ln == 0 ) {	/* ray parallel to cyl	*/
		d = RC.dot( axis );
		D.x = RC.x - d * axis.x;
		D.y = RC.y - d * axis.y;
		D.z = RC.z - d * axis.z;
		d = D.length(  );
		return ( d <= radius );		/* true if ray is in cyl*/
	}

	n.normalize(  );
	d = fabs( RC.dot(n) );		/* shortest distance	*/
	return ( d <= radius );
}

typedef float( *RandomFloat_t )( float, float );
typedef void( *RandomSeed_t )( UINT );
float math::RandomFloat( float fMin, float fMax ) {

	static RandomFloat_t m_RandomFloat;

	if ( !m_RandomFloat )
		m_RandomFloat = ( RandomFloat_t )GetProcAddress( GetModuleHandleA( static_cast< LPCSTR >("vstdlib.dll") ), "RandomFloat" );

	return m_RandomFloat( fMin, fMax );
}


float math::RandomInt( int fMin, int fMax ) {

	static RandomFloat_t m_RandomInt;

	if ( !m_RandomInt )
		m_RandomInt = ( RandomFloat_t )GetProcAddress( GetModuleHandleA( static_cast< LPCSTR >("vstdlib.dll") ), "RandomInt" );

	return m_RandomInt( fMin, fMax );
}

void math::RandomSeed( int Seed ) {

	static RandomSeed_t m_RandomSeed;

	if ( !m_RandomSeed )
		m_RandomSeed = ( RandomSeed_t )GetProcAddress( GetModuleHandleA( static_cast< LPCSTR >("vstdlib.dll") ), "RandomSeed" );

	m_RandomSeed( Seed );
}

vec3_t math::calculate_spread ( weapon_t *weapon, int seed, float inaccuracy, float spread, bool revolver ) {
	int item_def_index;
	float recoil_index, r1, r2, r3, r4, s1, c1, s2, c2;

	// if we have no bullets, we have no spread.
	item_def_index = weapon->item_definition_index( );
	const auto wep_info = g.m_interfaces->weapon_system( )->get_weapon_data( weapon->item_definition_index( ) );;
	if ( !wep_info || !wep_info->m_bullets )
		return {};

	// get some data for later.

	// seed randomseed.
	RandomSeed( ( seed & 0xff ) + 1 );

	// generate needed floats.
	r1 = RandomFloat( 0.f, 1.f );
	r2 = RandomFloat( 0.f, M_PI_2 );

	//if ( /*wep_info->m_weapon_type == WEAPONTYPE_SHOTGUN &&*/ g_csgo.weapon_accuracy_shotgun_spread_patterns->GetInt() > 0)
	//	g_csgo.GetShotgunSpread(item_def_index, 0, 0 /*bullet_i*/ + wep_info->m_bullets * recoil_index, &r4, &r3);


	r3 = RandomFloat( 0.f, 1.f );
	r4 = RandomFloat( 0.f, M_PI );

	// revolver secondary spread.
	if ( item_def_index == WEAPON_REVOLVER && revolver ) {
		r1 = 1.f - ( r1 * r1 );
		r3 = 1.f - ( r3 * r3 );
	}

	// get needed sine / cosine values.
	c1 = std::cos( r2 );
	c2 = std::cos( r4 );
	s1 = std::sin( r2 );
	s2 = std::sin( r4 );

	// calculate spread vector.
	return {
		( c1 * ( r1 * inaccuracy ) ) + ( c2 * ( r3 * spread ) ),
		( s1 * ( r1 * inaccuracy ) ) + ( s2 * ( r3 * spread ) ),
		0.f
	};
}

vec3_t math::get_bone_position ( matrix_t bone_matrices ) {
	return vec3_t{bone_matrices[0][3], bone_matrices[1][3], bone_matrices[2][3]};
}

void math::VectorRotate( vec3_t in1, matrix_t in2, vec3_t &out ) {
	out.x = in1.dot( in2[ 0 ] );
	out.y = in1.dot( in2[ 1 ] );
	out.z = in1.dot( in2[ 2 ] );
}

void math::VectorTransform( vec3_t in1, matrix_t &in2, vec3_t &out ) {
	out.x = in1.dot( in2[ 0 ] ) + in2[ 0 ][ 3 ];
	out.y = in1.dot( in2[ 1 ] ) + in2[ 1 ][ 3 ];
	out.z = in1.dot( in2[ 2 ] ) + in2[ 2 ][ 3 ];
}

void math::AngleMatrix ( const ang_t angles, matrix_t *matrix ) {
	auto SinCos = [ ]( float radians, float *sine, float *cosine ) {
		*sine = sin( radians );
		*cosine = cos( radians );
	};

	float sr, sp, sy, cr, cp, cy;

	SinCos( DEG2RAD( angles[ 1 ] ), &sy, &cy );
	SinCos( DEG2RAD( angles[ 0 ] ), &sp, &cp );
	SinCos( DEG2RAD( angles[ 2 ] ), &sr, &cr );

	// matrix = (YAW * PITCH) * ROLL
	matrix->mat_val[ 0 ][ 0 ] = cp * cy;
	matrix->mat_val[ 1 ][ 0 ] = cp * sy;
	matrix->mat_val[ 2 ][ 0 ] = -sp;

	const auto crcy = cr * cy;
	const auto crsy = cr * sy;
	const auto srcy = sr * cy;
	const auto srsy = sr * sy;
	matrix->mat_val[ 0 ][ 1 ] = sp * srcy - crsy;
	matrix->mat_val[ 1 ][ 1 ] = sp * srsy + crcy;
	matrix->mat_val[ 2 ][ 1 ] = sr * cp;

	matrix->mat_val[ 0 ][ 2 ] = sp * crcy + srsy;
	matrix->mat_val[ 1 ][ 2 ] = sp * crsy - srcy;
	matrix->mat_val[ 2 ][ 2 ] = cr * cp;

	matrix->mat_val[ 0 ][ 3 ] = 0.0f;
	matrix->mat_val[ 1 ][ 3 ] = 0.0f;
	matrix->mat_val[ 2 ][ 3 ] = 0.0f;
}

void math::angle_matrix ( const ang_t ang, const vec3_t &pos, matrix_t *out ) {
	AngleMatrix( ang, out );
	out->set_origin( pos );
}

void math::MatrixAngles( matrix_t &matrix, ang_t &angles ) {
	float forward[ 3 ];
	float left[ 3 ];
	float up[ 3 ];
	//
	// Extract the basis vectors from the matrix. Since we only need the Z
	// component of the up vector, we don't get X and Y.
	//
	forward[ 0 ] = matrix[ 0 ][ 0 ];
	forward[ 1 ] = matrix[ 1 ][ 0 ];
	forward[ 2 ] = matrix[ 2 ][ 0 ];
	left[ 0 ] = matrix[ 0 ][ 1 ];
	left[ 1 ] = matrix[ 1 ][ 1 ];
	left[ 2 ] = matrix[ 2 ][ 1 ];
	up[ 2 ] = matrix[ 2 ][ 2 ];

	const auto xyDist = sqrtf( forward[ 0 ] * forward[ 0 ] + forward[ 1 ] * forward[ 1 ] );

	// enough here to get angles?
	if ( xyDist > 0.001f ) {
		// (yaw)	y = ATAN( forward.y, forward.x );		-- in our space, forward is the X axis
		angles.y = RAD2DEG( atan2f( forward[ 1 ], forward[ 0 ] ) );

		// (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
		angles.x = RAD2DEG( atan2f( -forward[ 2 ], xyDist ) );

		// (roll)	z = ATAN( left.z, up.z );
		angles.z = RAD2DEG( atan2f( left[ 2 ], up[ 2 ] ) );
	} else	// forward is mostly Z, gimbal lock-
	{
		// (yaw)	y = ATAN( -left.x, left.y );			-- forward is mostly z, so use right for yaw
		angles.y = RAD2DEG( atan2f( -left[ 0 ], left[ 1 ] ) );

		// (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
		angles.x = RAD2DEG( atan2f( -forward[ 2 ], xyDist ) );

		// Assume no roll in this case as one degree of freedom has been lost (i.e. yaw == roll)
		angles.z = 0;
	}
}
void math::MatrixGetColumn( matrix_t &in, int column, vec3_t &out ) {
	out.x = in[ 0 ][ column ];
	out.y = in[ 1 ][ column ];
	out.z = in[ 2 ][ column ];
}
void math::MatrixSetColumn( vec3_t &in, int column, matrix_t &out ) {
	out[ 0 ][ column ] = in.x;
	out[ 1 ][ column ] = in.y;
	out[ 2 ][ column ] = in.z;
}
void math::VectorScale( const float *in, float scale, float *out ) {
	out[ 0 ] = in[ 0 ] * scale;
	out[ 1 ] = in[ 1 ] * scale;
	out[ 2 ] = in[ 2 ] * scale;
}
void math::MatrixAngles( matrix_t &matrix, ang_t &angles, vec3_t &position ) {
	MatrixGetColumn( matrix, 3, position );
	MatrixAngles( matrix, angles );
}

void MatrixCopy( matrix_t *src, matrix_t *dst ) {
	if ( src != dst ) {
		memcpy( dst, src, sizeof( matrix_t ) );
	}
}

void math::QuaternionMatrix( const quaternion_t &q, matrix_t *matrix ) {
	matrix->mat_val[ 0 ][ 0 ] = 1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z;
	matrix->mat_val[ 1 ][ 0 ] = 2.0 * q.x * q.y + 2.0 * q.w * q.z;
	matrix->mat_val[ 2 ][ 0 ] = 2.0 * q.x * q.z - 2.0 * q.w * q.y;
	
	matrix->mat_val[ 0 ][ 1 ] = 2.0f * q.x * q.y - 2.0f * q.w * q.z;
	matrix->mat_val[ 1 ][ 1 ] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.z * q.z;
	matrix->mat_val[ 2 ][ 1 ] = 2.0f * q.y * q.z + 2.0f * q.w * q.x;
	
	matrix->mat_val[ 0 ][ 2 ] = 2.0f * q.x * q.z + 2.0f * q.w * q.y;
	matrix->mat_val[ 1 ][ 2 ] = 2.0f * q.y * q.z - 2.0f * q.w * q.x;
	matrix->mat_val[ 2 ][ 2 ] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.y * q.y;
	
	matrix->mat_val[ 0 ][ 3 ] = 0.0f;
	matrix->mat_val[ 1 ][ 3 ] = 0.0f;
	matrix->mat_val[ 2 ][ 3 ] = 0.0f;
}

void math::QuaternionMatrix ( const quaternion_t &q, const vec3_t &pos, matrix_t *matrix ) {

	QuaternionMatrix( q, matrix );

	matrix->mat_val[0][3] = pos.x;
	matrix->mat_val[1][3] = pos.y;
	matrix->mat_val[2][3] = pos.z;
}

void math::ConcatTransforms ( matrix_t in1, matrix_t in2, matrix_t *out ) {
	if ( &in1 == out ) {
		matrix_t in1b;
		MatrixCopy( &in1, &in1b );
		ConcatTransforms( in1b, in2, out );
		return;
	}
	if ( &in2 == out ) {
		matrix_t in2b;
		MatrixCopy( &in2, &in2b );
		ConcatTransforms( in1, in2b, out );
		return;
	}
	out->mat_val[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
		in1[0][2] * in2[2][0];
	out->mat_val[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
		in1[0][2] * in2[2][1];
	out->mat_val[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
		in1[0][2] * in2[2][2];
	out->mat_val[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
		in1[0][2] * in2[2][3] + in1[0][3];
	out->mat_val[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
		in1[1][2] * in2[2][0];
	out->mat_val[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
		in1[1][2] * in2[2][1];
	out->mat_val[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
		in1[1][2] * in2[2][2];
	out->mat_val[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
		in1[1][2] * in2[2][3] + in1[1][3];
	out->mat_val[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
		in1[2][2] * in2[2][0];
	out->mat_val[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
		in1[2][2] * in2[2][1];
	out->mat_val[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
		in1[2][2] * in2[2][2];
	out->mat_val[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
		in1[2][2] * in2[2][3] + in1[2][3];
}

float math::get_fov ( const ang_t &view_angles, const vec3_t &start, const vec3_t &end ) {
	vec3_t dir, fw;

	// get direction and normalize.
	dir = (end - start).normalized( );

	// get the forward direction vector of the view angles.
	fw = view_angles.forward();

	// get the angle between the view angles forward directional vector and the target location.
	return max( RAD2DEG( std::acos( fw.dot( dir ) ) ), 0.f );
}
bool math::IntersectRayWithBox( const vec3_t &start, const vec3_t &delta, const vec3_t &mins, const vec3_t &maxs, float tolerance, custom_ray_t *out_info ) {
	int   i;
	float d1, d2, f;

	for ( i = 0; i < 6; ++i ) {
		if ( i >= 3 ) {
			d1 = start[ i - 3 ] - maxs[ i - 3 ];
			d2 = d1 + delta[ i - 3 ];
		}

		else {
			d1 = -start[ i ] + mins[ i ];
			d2 = d1 - delta[ i ];
		}

		// if completely in front of face, no intersection.
		if ( d1 > 0.f && d2 > 0.f ) {
			out_info->m_startsolid = false;

			return false;
		}

		// completely inside, check next face.
		if ( d1 <= 0.f && d2 <= 0.f )
			continue;

		if ( d1 > 0.f )
			out_info->m_startsolid = false;

		// crosses face.
		if ( d1 > d2 ) {
			f = max( 0.f, d1 - tolerance );

			f = f / ( d1 - d2 );
			if ( f > out_info->m_t1 ) {
				out_info->m_t1 = f;
				out_info->m_hitside = i;
			}
		}

		// leave.
		else {
			f = ( d1 + tolerance ) / ( d1 - d2 );
			if ( f < out_info->m_t2 )
				out_info->m_t2 = f;
		}
	}

	return out_info->m_startsolid || ( out_info->m_t1 < out_info->m_t2 &&out_info->m_t1 >= 0.f );
}

bool math::IntersectRayWithBox( const vec3_t &start, const vec3_t &delta, const vec3_t &mins, const vec3_t &maxs, float tolerance, trace_t *out_tr, float *fraction_left_solid ) {
	custom_ray_t box_tr;

	// note - dex; this is Collision_ClearTrace.
	out_tr->start = start;
	out_tr->end = start;
	out_tr->end += delta;
	out_tr->startSolid = false;
	out_tr->allsolid = false;
	out_tr->flFraction = 1.f;
	out_tr->contents = 0;

	if ( IntersectRayWithBox( start, delta, mins, maxs, tolerance, &box_tr ) ) {
		out_tr->startSolid = box_tr.m_startsolid;

		if ( box_tr.m_t1 < box_tr.m_t2 && box_tr.m_t1 >= 0.f ) {
			out_tr->flFraction = box_tr.m_t1;

			// VectorMA( pTrace->startpos, trace.t1, vecRayDelta, pTrace->endpos );

			out_tr->contents = CONTENTS_SOLID;
			out_tr->plane.normal = vec3_t{};

			if ( box_tr.m_hitside >= 3 ) {
				box_tr.m_hitside -= 3;

				out_tr->plane.m_dist = maxs[ box_tr.m_hitside ];
				out_tr->plane.normal[ box_tr.m_hitside ] = 1.f;
				out_tr->plane.m_type = box_tr.m_hitside;
			}

			else {
				out_tr->plane.m_dist = -mins[ box_tr.m_hitside ];
				out_tr->plane.normal[ box_tr.m_hitside ] = -1.f;
				out_tr->plane.m_type = box_tr.m_hitside;
			}

			return true;
		}

		if ( out_tr->startSolid ) {
			out_tr->allsolid = ( box_tr.m_t2 <= 0.f ) || ( box_tr.m_t2 >= 1.f );
			out_tr->flFraction = 0.f;

			if ( fraction_left_solid )
				*fraction_left_solid = box_tr.m_t2;

			out_tr->end = out_tr->start;
			out_tr->contents = CONTENTS_SOLID;
			out_tr->plane.m_dist = out_tr->start.x;
			out_tr->plane.normal = { 1.f, 0.f, 0.f };
			out_tr->plane.m_type = 0;
			out_tr->start = start + ( delta * box_tr.m_t2 );

			return true;
		}
	}

	return false;
}
void math::VectorITransform( const vec3_t &in, const matrix_t &matrix, vec3_t &out ) {
	vec3_t diff;

	diff = {
		in.x - matrix[ 0 ][ 3 ],
		in.y - matrix[ 1 ][ 3 ],
		in.z - matrix[ 2 ][ 3 ]
	};

	out = {
		diff.x * matrix[ 0 ][ 0 ] + diff.y * matrix[ 1 ][ 0 ] + diff.z * matrix[ 2 ][ 0 ],
		diff.x * matrix[ 0 ][ 1 ] + diff.y * matrix[ 1 ][ 1 ] + diff.z * matrix[ 2 ][ 1 ],
		diff.x * matrix[ 0 ][ 2 ] + diff.y * matrix[ 1 ][ 2 ] + diff.z * matrix[ 2 ][ 2 ]
	};
}

using VMatrixRaw_t = float[ 4 ];

void math::MatrixMultiply( matrix_t &src1, matrix_t &src2, matrix_t &dst ) {
	// Make sure it works if src1 == dst or src2 == dst
	matrix_t tmp1, tmp2;
	const VMatrixRaw_t *s1 = ( &src1 == &dst ) ? tmp1.mat_val : src1.mat_val;
	const VMatrixRaw_t *s2 = ( &src2 == &dst ) ? tmp2.mat_val : src2.mat_val;

	if ( &src1 == &dst ) {
		MatrixCopy( &src1, &tmp1 );
	}
	if ( &src2 == &dst ) {
		MatrixCopy( &src2, &tmp2 );
	}

	dst[ 0 ][ 0 ] = s1[ 0 ][ 0 ] * s2[ 0 ][ 0 ] + s1[ 0 ][ 1 ] * s2[ 1 ][ 0 ] + s1[ 0 ][ 2 ] * s2[ 2 ][ 0 ] + s1[ 0 ][ 3 ] * s2[ 3 ][ 0 ];
	dst[ 0 ][ 1 ] = s1[ 0 ][ 0 ] * s2[ 0 ][ 1 ] + s1[ 0 ][ 1 ] * s2[ 1 ][ 1 ] + s1[ 0 ][ 2 ] * s2[ 2 ][ 1 ] + s1[ 0 ][ 3 ] * s2[ 3 ][ 1 ];
	dst[ 0 ][ 2 ] = s1[ 0 ][ 0 ] * s2[ 0 ][ 2 ] + s1[ 0 ][ 1 ] * s2[ 1 ][ 2 ] + s1[ 0 ][ 2 ] * s2[ 2 ][ 2 ] + s1[ 0 ][ 3 ] * s2[ 3 ][ 2 ];
	dst[ 0 ][ 3 ] = s1[ 0 ][ 0 ] * s2[ 0 ][ 3 ] + s1[ 0 ][ 1 ] * s2[ 1 ][ 3 ] + s1[ 0 ][ 2 ] * s2[ 2 ][ 3 ] + s1[ 0 ][ 3 ] * s2[ 3 ][ 3 ];

	dst[ 1 ][ 0 ] = s1[ 1 ][ 0 ] * s2[ 0 ][ 0 ] + s1[ 1 ][ 1 ] * s2[ 1 ][ 0 ] + s1[ 1 ][ 2 ] * s2[ 2 ][ 0 ] + s1[ 1 ][ 3 ] * s2[ 3 ][ 0 ];
	dst[ 1 ][ 1 ] = s1[ 1 ][ 0 ] * s2[ 0 ][ 1 ] + s1[ 1 ][ 1 ] * s2[ 1 ][ 1 ] + s1[ 1 ][ 2 ] * s2[ 2 ][ 1 ] + s1[ 1 ][ 3 ] * s2[ 3 ][ 1 ];
	dst[ 1 ][ 2 ] = s1[ 1 ][ 0 ] * s2[ 0 ][ 2 ] + s1[ 1 ][ 1 ] * s2[ 1 ][ 2 ] + s1[ 1 ][ 2 ] * s2[ 2 ][ 2 ] + s1[ 1 ][ 3 ] * s2[ 3 ][ 2 ];
	dst[ 1 ][ 3 ] = s1[ 1 ][ 0 ] * s2[ 0 ][ 3 ] + s1[ 1 ][ 1 ] * s2[ 1 ][ 3 ] + s1[ 1 ][ 2 ] * s2[ 2 ][ 3 ] + s1[ 1 ][ 3 ] * s2[ 3 ][ 3 ];

	dst[ 2 ][ 0 ] = s1[ 2 ][ 0 ] * s2[ 0 ][ 0 ] + s1[ 2 ][ 1 ] * s2[ 1 ][ 0 ] + s1[ 2 ][ 2 ] * s2[ 2 ][ 0 ] + s1[ 2 ][ 3 ] * s2[ 3 ][ 0 ];
	dst[ 2 ][ 1 ] = s1[ 2 ][ 0 ] * s2[ 0 ][ 1 ] + s1[ 2 ][ 1 ] * s2[ 1 ][ 1 ] + s1[ 2 ][ 2 ] * s2[ 2 ][ 1 ] + s1[ 2 ][ 3 ] * s2[ 3 ][ 1 ];
	dst[ 2 ][ 2 ] = s1[ 2 ][ 0 ] * s2[ 0 ][ 2 ] + s1[ 2 ][ 1 ] * s2[ 1 ][ 2 ] + s1[ 2 ][ 2 ] * s2[ 2 ][ 2 ] + s1[ 2 ][ 3 ] * s2[ 3 ][ 2 ];
	dst[ 2 ][ 3 ] = s1[ 2 ][ 0 ] * s2[ 0 ][ 3 ] + s1[ 2 ][ 1 ] * s2[ 1 ][ 3 ] + s1[ 2 ][ 2 ] * s2[ 2 ][ 3 ] + s1[ 2 ][ 3 ] * s2[ 3 ][ 3 ];

	dst[ 3 ][ 0 ] = s1[ 3 ][ 0 ] * s2[ 0 ][ 0 ] + s1[ 3 ][ 1 ] * s2[ 1 ][ 0 ] + s1[ 3 ][ 2 ] * s2[ 2 ][ 0 ] + s1[ 3 ][ 3 ] * s2[ 3 ][ 0 ];
	dst[ 3 ][ 1 ] = s1[ 3 ][ 0 ] * s2[ 0 ][ 1 ] + s1[ 3 ][ 1 ] * s2[ 1 ][ 1 ] + s1[ 3 ][ 2 ] * s2[ 2 ][ 1 ] + s1[ 3 ][ 3 ] * s2[ 3 ][ 1 ];
	dst[ 3 ][ 2 ] = s1[ 3 ][ 0 ] * s2[ 0 ][ 2 ] + s1[ 3 ][ 1 ] * s2[ 1 ][ 2 ] + s1[ 3 ][ 2 ] * s2[ 2 ][ 2 ] + s1[ 3 ][ 3 ] * s2[ 3 ][ 2 ];
	dst[ 3 ][ 3 ] = s1[ 3 ][ 0 ] * s2[ 0 ][ 3 ] + s1[ 3 ][ 1 ] * s2[ 1 ][ 3 ] + s1[ 3 ][ 2 ] * s2[ 2 ][ 3 ] + s1[ 3 ][ 3 ] * s2[ 3 ][ 3 ];
}

bool math::IntersectRayWithOBB( const vec3_t &start, const vec3_t &delta, matrix_t &obb_to_world, const vec3_t &mins, const vec3_t &maxs, float tolerance, trace_t *out_tr ) {
	vec3_t box_extents, box_center, extent{}, uextent, segment_center, cross, new_start, tmp_end;
	float  coord, tmp, cextent, sign;

	// note - dex; this is Collision_ClearTrace.
	out_tr->start = start;
	out_tr->end = start;
	out_tr->end += delta;
	out_tr->startSolid = false;
	out_tr->allsolid = false;
	out_tr->flFraction = 1.f;
	out_tr->contents = 0;

	// compute center in local space and transform to world space.
	box_extents = ( mins + maxs ) / 2.f;
	VectorTransform( box_extents, obb_to_world, box_center );

	// calculate extents from local center.
	box_extents = maxs - box_extents;

	// save the extents of the ray.
	segment_center = start + delta - box_center;

	// check box axes for separation.
	for ( auto i = 0; i < 3; ++i ) {
		extent[ i ] = delta.x * obb_to_world[ 0 ][ i ] + delta.y * obb_to_world[ 1 ][ i ] + delta.z * obb_to_world[ 2 ][ i ];
		uextent[ i ] = std::abs( extent[ i ] );

		coord = segment_center.x * obb_to_world[ 0 ][ i ] + segment_center.y * obb_to_world[ 1 ][ i ] + segment_center.z * obb_to_world[ 2 ][ i ];
		coord = std::abs( coord );
		if ( coord > ( box_extents[ i ] + uextent[ i ] ) )
			return false;
	}

	// now check cross axes for separation.
	cross = delta.cross( segment_center );
	
	cextent = cross.x * obb_to_world[ 0 ][ 0 ] + cross.y * obb_to_world[ 1 ][ 0 ] + cross.z * obb_to_world[ 2 ][ 0 ];
	cextent = std::abs( cextent );
	tmp = box_extents.y * uextent.z + box_extents.z * uextent.y;
	if ( cextent > tmp )
		return false;

	cextent = cross.x * obb_to_world[ 0 ][ 1 ] + cross.y * obb_to_world[ 1 ][ 1 ] + cross.z * obb_to_world[ 2 ][ 1 ];
	cextent = std::abs( cextent );
	tmp = box_extents.x * uextent.z + box_extents.z * uextent.x;
	if ( cextent > tmp )
		return false;

	cextent = cross.x * obb_to_world[ 0 ][ 2 ] + cross.y * obb_to_world[ 1 ][ 2 ] + cross.z * obb_to_world[ 2 ][ 2 ];
	cextent = std::abs( cextent );
	tmp = box_extents.x * uextent.y + box_extents.y * uextent.x;
	if ( cextent > tmp )
		return false;

	// we hit this box, compute intersection point and return.
	// compute ray start in bone space.
	VectorITransform( start, obb_to_world, new_start );

	// extent is ray.m_Delta in bone space, recompute delta in bone space.
	extent *= 2.f;

	// delta was prescaled by the current t, so no need to see if this intersection is closer.
	if ( !IntersectRayWithBox( start, extent, mins, maxs, tolerance, out_tr ) )
		return false;

	// fix up the start/end pos and fraction
	VectorTransform( out_tr->end, obb_to_world, tmp_end );

	out_tr->end = tmp_end;
	out_tr->start = start;
	out_tr->flFraction *= 2.f;

	// fix up the plane information
	sign = out_tr->plane.normal[ out_tr->plane.m_type ];

	out_tr->plane.normal.x = sign * obb_to_world[ 0 ][ out_tr->plane.m_type ];
	out_tr->plane.normal.y = sign * obb_to_world[ 1 ][ out_tr->plane.m_type ];
	out_tr->plane.normal.z = sign * obb_to_world[ 2 ][ out_tr->plane.m_type ];
	out_tr->plane.m_dist = out_tr->end.dot( out_tr->plane.normal );
	out_tr->plane.m_type = 3;

	return true;
}
bool math::IntersectRayWithOBB( custom_ray_t ray,
						  const vec3_t &vecBoxOrigin, const ang_t &angBoxRotation,
						  const vec3_t &vecOBBMins, const vec3_t &vecOBBMaxs, float flTolerance, trace_t *pTrace ) {
	if ( angBoxRotation == ang_t{} ) {
		vec3_t vecAbsMins, vecAbsMaxs;
		vecAbsMins = vecBoxOrigin + vecOBBMins;
		vecAbsMaxs = vecBoxOrigin + vecOBBMaxs;
		return math::IntersectRayWithBox( ray.m_start, ray.m_ray_dir, vecAbsMins, vecAbsMaxs, flTolerance, pTrace );
	}

	matrix_t obbToWorld;
	angle_matrix( angBoxRotation, vecBoxOrigin, &obbToWorld );
	return IntersectRayWithOBB( ray.m_start, ray.m_ray_dir, obbToWorld, vecOBBMins, vecOBBMaxs, flTolerance, pTrace );
}
```

`solace-csgo/math_funcs.h`:

```h
#pragma once
#include "vec3.h"

struct trace_t;
class ang_t;
class cmd_t;
class weapon_t;
class vec3_t;
struct matrix_t;
namespace math {
	struct custom_ray_t {
		vec3_t m_ray_dir;
		vec3_t m_start;
		vec3_t m_end;
		bool m_startsolid;
		float m_t1;
		int m_hitside;
		float m_t2;
		custom_ray_t( ) : m_t1 { -1.f }, m_t2{ 1.f }, m_hitside{ -1 }, m_startsolid{ true } {}
		custom_ray_t( vec3_t start, vec3_t end );
		void init( vec3_t start, vec3_t end );
	};
	struct hitbox_t {
		vec3_t m_mins, m_maxs;
		float m_radius, m_len_sqr;
		hitbox_t( vec3_t mins, vec3_t maxs, float radius ) : m_mins( mins ), m_maxs( maxs ), m_radius( radius ) {
			m_len_sqr = ( maxs - mins ).length_2d_sqr( );
		}
	};
	bool world_to_screen( const vec3_t &point, vec3_t &screen );
	float distSegmentToSegment( const vec3_t &p1, const vec3_t &p2, const vec3_t &q1, const vec3_t &q2, float &invariant1, float &invariant2 );
	float distSegmentToSegmentSqr( const vec3_t& p1, const vec3_t& p2, const vec3_t& q1, const vec3_t& q2, float& invariant1, float& invariant2 );
	void correct_movement( cmd_t *cmd );
	float minimum_distance( vec3_t v, vec3_t w, vec3_t p );
	float normalize_angle( float ang, float max );

	float AngleDiff( float destAngle, float srcAngle );

	void sin_cos ( float r, float *s, float *c );

	vec3_t get_closest_on_line ( vec3_t start, vec3_t end, vec3_t target );

	vec3_t closest_to_point ( const custom_ray_t &ray, const vec3_t &point );

	float dist_Segment_to_Segment( const custom_ray_t &ray, const vec3_t &min, const vec3_t &max );

	bool intersects_capsule( const custom_ray_t &ray, const vec3_t &min, const vec3_t &max, const float &radius );

	float RandomFloat( float fMin, float fMax );
	float RandomInt( int fMin, int fMax );
	void RandomSeed( int Seed );
	vec3_t calculate_spread( weapon_t *weapon, int seed, float inaccuracy, float spread, bool revolver );

	vec3_t get_bone_position ( matrix_t bone_matrices );
	void VectorRotate ( vec3_t in1, matrix_t in2, vec3_t &out );
	void VectorTransform( vec3_t in1, matrix_t &in2, vec3_t &out );
	void MatrixGetColumn( matrix_t &in, int column, vec3_t &out );
	void MatrixSetColumn( vec3_t &in, int column, matrix_t &out );
	void VectorScale( const float *in, float scale, float *out );
	void AngleMatrix ( const ang_t angles, matrix_t *matrix );

	using AngleMatrix_t = void( __fastcall * )( const vec3_t &, matrix_t & );
	void angle_matrix( const ang_t ang, const vec3_t &pos, matrix_t *out );
	void MatrixAngles( matrix_t &matrix, ang_t &angles );
	void MatrixAngles( matrix_t &matrix, ang_t &angles, vec3_t &position );
	void QuaternionMatrix( const quaternion_t &q, matrix_t *matrix );
	void QuaternionMatrix ( const quaternion_t &q, const vec3_t &pos, matrix_t *matrix );
	void ConcatTransforms ( matrix_t in1, matrix_t in2, matrix_t *out );
	float get_fov ( const ang_t &view_angles, const vec3_t &start, const vec3_t &end );
	bool IntersectRayWithBox( const vec3_t &start, const vec3_t &delta, const vec3_t &mins, const vec3_t &maxs, float tolerance, trace_t *out_tr, float *fraction_left_solid = nullptr );
	void VectorITransform( const vec3_t &in, const matrix_t &matrix, vec3_t &out );
	void MatrixMultiply( matrix_t &src1, matrix_t &src2, matrix_t &dst );
	bool IntersectRayWithOBB( const vec3_t &start, const vec3_t &delta, matrix_t &obb_to_world, const vec3_t &mins, const vec3_t &maxs, float
	                          tolerance, trace_t *out_tr );
	bool IntersectRayWithOBB( custom_ray_t ray, const vec3_t &vecBoxOrigin, const ang_t &angBoxRotation, const vec3_t &vecOBBMins, const vec3_t &
	                          vecOBBMaxs, float flTolerance, trace_t *pTrace );
	bool IntersectRayWithBox( const vec3_t &start, const vec3_t &delta, const vec3_t &mins, const vec3_t &maxs, float tolerance, custom_ray_t *
	                          out_info );
}

```

`solace-csgo/mdlcache.h`:

```h
#pragma once
class mdlcache_t {
public:
};
```

`solace-csgo/mem_alloc.h`:

```h
#pragma once
#include "utils.h"

class mem_alloc_t {
public:
    //virtual ~IMemAlloc();

    VFUNC( alloc( size_t nSize ), 1, void *( __thiscall * )( decltype( this ), size_t ), nSize );

    VFUNC( re_alloc( void *pMem, size_t nSize ), 3, void *( __thiscall * )( decltype( this ), size_t, void * ), nSize, pMem );
    VFUNC( free( void *pMem ), 5, void( __thiscall * )( decltype( this ), void * ), pMem );
};

```

`solace-csgo/memory_shit.h`:

```h
#pragma once
#include <Windows.h>
#define UTLMEMORY_TRACK_ALLOC() ((void)0)
#define UTLMEMORY_TRACK_FREE() ((void)0)
#define MEM_ALLOC_CREDIT_CLASS()
#define Assert(num)

template <class T> inline T* CopyConstruct(T* pMemory, T const& src)
{
    return reinterpret_cast<T*>(::new (pMemory) T(src));
}

template <class T> inline void Destruct(T* pMemory)
{
    pMemory->~T();

#ifdef _DEBUG
    memset(reinterpret_cast<void*>(pMemory), 0xDD, sizeof(T));
#endif
}

// The above will error when binding to a type of: foo(*)[] -- there is no provision in c++ for knowing how many objects
// to destruct without preserving the count and calling the necessary destructors.
template <class T, size_t N> inline void Destruct(T (*pMemory)[N])
{
    for (size_t i = 0; i < N; i++)
    {
        (pMemory[i])->~T();
    }

#ifdef _DEBUG
    memset(reinterpret_cast<void*>(pMemory), 0xDD, sizeof(*pMemory));
#endif
}

//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template <class T, class I = int> class CUtlMemory
{
public:
    // constructor, destructor
    CUtlMemory(int nGrowSize = 0, int nInitSize = 0);
    CUtlMemory(T* pMemory, int numElements);
    CUtlMemory(const T* pMemory, int numElements);
    ~CUtlMemory();

    // Set the size by which the memory grows
    void Init(int nGrowSize = 0, int nInitSize = 0);

    class Iterator_t
    {
    public:
        Iterator_t(I i) : index(i)
        {
        }
        I index;

        bool operator==(const Iterator_t it) const
        {
            return index == it.index;
        }
        bool operator!=(const Iterator_t it) const
        {
            return index != it.index;
        }
    };
    Iterator_t First() const
    {
        return Iterator_t(IsIdxValid(0) ? 0 : InvalidIndex());
    }
    Iterator_t Next(const Iterator_t& it) const
    {
        return Iterator_t(IsIdxValid(it.index + 1) ? it.index + 1 : InvalidIndex());
    }
    I GetIndex(const Iterator_t& it) const
    {
        return it.index;
    }
    bool IsIdxAfter(I i, const Iterator_t& it) const
    {
        return i > it.index;
    }
    bool IsValidIterator(const Iterator_t& it) const
    {
        return IsIdxValid(it.index);
    }
    Iterator_t InvalidIterator() const
    {
        return Iterator_t(InvalidIndex());
    }

    // element access
    T& operator[](I i);
    const T& operator[](I i) const;
    T& Element(I i);
    const T& Element(I i) const;

    // Can we use this index?
    bool IsIdxValid(I i) const;

    // Specify the invalid ('null') index that we'll only return on failure
    static const I INVALID_INDEX = (I)-1; // For use with COMPILE_TIME_ASSERT
    static I InvalidIndex()
    {
        return INVALID_INDEX;
    }

    // Gets the base address (can change when adding elements!)
    T* Base();
    const T* Base() const;

    // Attaches the buffer to external memory....
    void SetExternalBuffer(T* pMemory, int numElements);
    void SetExternalBuffer(const T* pMemory, int numElements);
    void AssumeMemory(T* pMemory, int nSize);
    T* Detach();
    void* DetachMemory();

    // Fast swap
    void Swap(CUtlMemory<T, I>& mem);

    // Switches the buffer from an external memory buffer to a reallocatable buffer
    // Will copy the current contents of the external buffer to the reallocatable buffer
    void ConvertToGrowableMemory(int nGrowSize);

    // Size
    int NumAllocated() const;
    int Count() const;

    // Grows the memory, so that at least allocated + num elements are allocated
    void Grow(int num = 1);

    // Makes sure we've got at least this much memory
    void EnsureCapacity(int num);

    // Memory deallocation
    void Purge();

    // Purge all but the given number of elements
    void Purge(int numElements);

    // is the memory externally allocated?
    bool IsExternallyAllocated() const;

    // is the memory read only?
    bool IsReadOnly() const;

    // Set the size by which the memory grows
    void SetGrowSize(int size);

protected:
    void ValidateGrowSize()
    {
#ifdef _X360
        if (m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER)
        {
            // Max grow size at 128 bytes on XBOX
            const int MAX_GROW = 128;
            if (m_nGrowSize * sizeof(T) > MAX_GROW)
            {
                m_nGrowSize = max(1, MAX_GROW / sizeof(T));
            }
        }
#endif
    }

    enum
    {
        EXTERNAL_BUFFER_MARKER = -1,
        EXTERNAL_CONST_BUFFER_MARKER = -2,
    };

    T* m_pMemory;
    int m_nAllocationCount;
    int m_nGrowSize;
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(int nGrowSize, int nInitAllocationCount)
    : m_pMemory(0), m_nAllocationCount(nInitAllocationCount), m_nGrowSize(nGrowSize)
{
    ValidateGrowSize();
    Assert(nGrowSize >= 0);
    if (m_nAllocationCount)
    {
        UTLMEMORY_TRACK_ALLOC();
        MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(T* pMemory, int numElements) : m_pMemory(pMemory), m_nAllocationCount(numElements)
{
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(const T* pMemory, int numElements)
    : m_pMemory((T*)pMemory), m_nAllocationCount(numElements)
{
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template <class T, class I> CUtlMemory<T, I>::~CUtlMemory()
{
    Purge();

#ifdef _DEBUG
    m_pMemory = reinterpret_cast<T*>(0xFEFEBAAD);
    m_nAllocationCount = 0x7BADF00D;
#endif
}

template <class T, class I> void CUtlMemory<T, I>::Init(int nGrowSize /*= 0*/, int nInitSize /*= 0*/)
{
    Purge();

    m_nGrowSize = nGrowSize;
    m_nAllocationCount = nInitSize;
    ValidateGrowSize();
    Assert(nGrowSize >= 0);
    if (m_nAllocationCount)
    {
        UTLMEMORY_TRACK_ALLOC();
        MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Fast swap
//-----------------------------------------------------------------------------
template <class T, class I> void CUtlMemory<T, I>::Swap(CUtlMemory<T, I>& mem)
{
    V_swap(m_nGrowSize, mem.m_nGrowSize);
    V_swap(m_pMemory, mem.m_pMemory);
    V_swap(m_nAllocationCount, mem.m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Switches the buffer from an external memory buffer to a reallocatable buffer
//-----------------------------------------------------------------------------
template <class T, class I> void CUtlMemory<T, I>::ConvertToGrowableMemory(int nGrowSize)
{
    if (!IsExternallyAllocated())
        return;

    m_nGrowSize = nGrowSize;
    if (m_nAllocationCount)
    {
        UTLMEMORY_TRACK_ALLOC();
        MEM_ALLOC_CREDIT_CLASS();

        int nNumBytes = m_nAllocationCount * sizeof(T);
        T* pMemory = (T*)malloc(nNumBytes);
        memcpy(pMemory, m_pMemory, nNumBytes);
        m_pMemory = pMemory;
    }
    else
    {
        m_pMemory = nullptr;
    }
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template <class T, class I> void CUtlMemory<T, I>::SetExternalBuffer(T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = pMemory;
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template <class T, class I> void CUtlMemory<T, I>::SetExternalBuffer(const T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = const_cast<T*>(pMemory);
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template <class T, class I> void CUtlMemory<T, I>::AssumeMemory(T* pMemory, int numElements)
{
    // Blow away any existing allocated memory
    Purge();

    // Simply take the pointer but don't mark us as external
    m_pMemory = pMemory;
    m_nAllocationCount = numElements;
}

template <class T, class I> void* CUtlMemory<T, I>::DetachMemory()
{
    if (IsExternallyAllocated())
        return nullptr;

    void* pMemory = m_pMemory;
    m_pMemory = 0;
    m_nAllocationCount = 0;
    return pMemory;
}

template <class T, class I> inline T* CUtlMemory<T, I>::Detach()
{
    return (T*)DetachMemory();
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template <class T, class I> inline T& CUtlMemory<T, I>::operator[](I i)
{
    // Assert(!IsReadOnly());
    // Assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I> inline const T& CUtlMemory<T, I>::operator[](I i) const
{
    // Assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I> inline T& CUtlMemory<T, I>::Element(I i)
{
    // Assert(!IsReadOnly());
    // Assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I> inline const T& CUtlMemory<T, I>::Element(I i) const
{
    Assert(IsIdxValid(i));
    return m_pMemory[i];
}

//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template <class T, class I> bool CUtlMemory<T, I>::IsExternallyAllocated() const
{
    return (m_nGrowSize < 0);
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template <class T, class I> bool CUtlMemory<T, I>::IsReadOnly() const
{
    return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}

template <class T, class I> void CUtlMemory<T, I>::SetGrowSize(int nSize)
{
    // Assert(!IsExternallyAllocated());
    // Assert(nSize >= 0);
    m_nGrowSize = nSize;
    ValidateGrowSize();
}

//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template <class T, class I> inline T* CUtlMemory<T, I>::Base()
{
    // Assert(!IsReadOnly());
    return m_pMemory;
}

template <class T, class I> inline const T* CUtlMemory<T, I>::Base() const
{
    return m_pMemory;
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template <class T, class I> inline int CUtlMemory<T, I>::NumAllocated() const
{
    return m_nAllocationCount;
}

template <class T, class I> inline int CUtlMemory<T, I>::Count() const
{
    return m_nAllocationCount;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template <class T, class I> inline bool CUtlMemory<T, I>::IsIdxValid(I i) const
{
    // GCC warns if I is an unsigned type and we do a ">= 0" against it (since the comparison is always 0).
    // We get the warning even if we cast inside the expression. It only goes away if we assign to another variable.
    long x = i;
    return (x >= 0) && (x < m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
inline int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem)
{
    if (nGrowSize)
    {
        nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
    }
    else
    {
        if (!nAllocationCount)
        {
            // Compute an allocation which is at least as big as a cache line...
            nAllocationCount = (31 + nBytesItem) / nBytesItem;
        }

        while (nAllocationCount < nNewSize)
        {
#ifndef _X360
            nAllocationCount *= 2;
#else
            int nNewAllocationCount = (nAllocationCount * 9) / 8; // 12.5 %
            if (nNewAllocationCount > nAllocationCount)
                nAllocationCount = nNewAllocationCount;
            else
                nAllocationCount *= 2;
#endif
        }
    }

    return nAllocationCount;
}

template <class T, class I> void CUtlMemory<T, I>::Grow(int num)
{
    // Assert(num > 0);

    if (IsExternallyAllocated())
    {
        // Can't grow a buffer whose memory was externally allocated
        // Assert(0);
        return;
    }

    // Make sure we have at least numallocated + num allocations.
    // Use the grow rules specified for this memory (in m_nGrowSize)
    int nAllocationRequested = m_nAllocationCount + num;

    // UTLMEMORY_TRACK_FREE();

    int nNewAllocationCount =
        UtlMemory_CalcNewAllocationCount(m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T));

    // if m_nAllocationRequested wraps index type I, recalculate
    if ((int)(I)nNewAllocationCount < nAllocationRequested)
    {
        if ((int)(I)nNewAllocationCount == 0 && (int)(I)(nNewAllocationCount - 1) >= nAllocationRequested)
        {
            --nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
        }
        else
        {
            if ((int)(I)nAllocationRequested != nAllocationRequested)
            {
                // we've been asked to grow memory to a size s.t. the index type can't address the requested amount of
                // memory
                // Assert(0);
                return;
            }
            while ((int)(I)nNewAllocationCount < nAllocationRequested)
            {
                nNewAllocationCount = (nNewAllocationCount + nAllocationRequested) / 2;
            }
        }
    }

    m_nAllocationCount = nNewAllocationCount;

    // UTLMEMORY_TRACK_ALLOC();

    if (m_pMemory)
    {
        // MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
        // Assert(m_pMemory);
    }
    else
    {
        // MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
        // Assert(m_pMemory);
    }
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template <class T, class I> inline void CUtlMemory<T, I>::EnsureCapacity(int num)
{
    if (m_nAllocationCount >= num)
        return;

    if (IsExternallyAllocated())
    {
        // Can't grow a buffer whose memory was externally allocated
        Assert(0);
        return;
    }

    UTLMEMORY_TRACK_FREE();

    m_nAllocationCount = num;

    UTLMEMORY_TRACK_ALLOC();

    if (m_pMemory)
    {
        MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
    }
    else
    {
        MEM_ALLOC_CREDIT_CLASS();
        m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template <class T, class I> void CUtlMemory<T, I>::Purge()
{
    if (!IsExternallyAllocated())
    {
        if (m_pMemory)
        {
            UTLMEMORY_TRACK_FREE();
            free((void*)m_pMemory);
            m_pMemory = 0;
        }
        m_nAllocationCount = 0;
    }
}

template <class T, class I> void CUtlMemory<T, I>::Purge(int numElements)
{
    Assert(numElements >= 0);

    if (numElements > m_nAllocationCount)
    {
        // Ensure this isn't a grow request in disguise.
        Assert(numElements <= m_nAllocationCount);
        return;
    }

    // If we have zero elements, simply do a purge:
    if (numElements == 0)
    {
        Purge();
        return;
    }

    if (IsExternallyAllocated())
    {
        // Can't shrink a buffer whose memory was externally allocated, fail silently like purge
        return;
    }

    // If the number of elements is the same as the allocation count, we are done.
    if (numElements == m_nAllocationCount)
    {
        return;
    }

    if (!m_pMemory)
    {
        // Allocation count is non zero, but memory is null.
        Assert(m_pMemory);
        return;
    }

    UTLMEMORY_TRACK_FREE();

    m_nAllocationCount = numElements;

    UTLMEMORY_TRACK_ALLOC();

    // Allocation count > 0, shrink it down.
    MEM_ALLOC_CREDIT_CLASS();
    m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
}

template <class T, class A = CUtlMemory<T>> class CUtlVector
{
public:
    typedef A CAllocator;
    typedef T ElemType_t;

    // constructor, destructor
    CUtlVector(int growSize = 0, int initSize = 0);
    CUtlVector(T* pMemory, int allocationCount, int numElements = 0);
    ~CUtlVector();

    // Copy the array.
    CUtlVector<T, A>& operator=(const CUtlVector<T, A>& other);

    // element access
    T& operator[](int i);
    const T& operator[](int i) const;
    T& Element(int i);
    const T& Element(int i) const;
    T& Head();
    const T& Head() const;
    T& Tail();
    const T& Tail() const;

    // Gets the base address (can change when adding elements!)
    T* Base()
    {
        return m_Memory.Base();
    }
    const T* Base() const
    {
        return m_Memory.Base();
    }

    // Returns the number of elements in the vector
    int Count() const;

    // Is element index valid?
    bool IsValidIndex(int i) const;
    static int InvalidIndex();

    // Adds an element, uses default constructor
    int AddToHead();
    int AddToTail();
    int InsertBefore(int elem);
    int InsertAfter(int elem);

    // Adds an element, uses copy constructor
    int AddToHead(const T& src);
    int AddToTail(const T& src);
    int InsertBefore(int elem, const T& src);
    int InsertAfter(int elem, const T& src);

    // Adds multiple elements, uses default constructor
    int AddMultipleToHead(int num);
    int AddMultipleToTail(int num);
    int AddMultipleToTail(int num, const T* pToCopy);
    int InsertMultipleBefore(int elem, int num);
    int InsertMultipleBefore(int elem, int num, const T* pToCopy);
    int InsertMultipleAfter(int elem, int num);

    // Calls RemoveAll() then AddMultipleToTail.
    void SetSize(int size);
    void SetCount(int count);
    void SetCountNonDestructively(int count); // sets count by adding or removing elements to tail TODO: This should
                                              // probably be the default behavior for SetCount

    // Calls SetSize and copies each element.
    void CopyArray(const T* pArray, int size);

    // Fast swap
    void Swap(CUtlVector<T, A>& vec);

    // Add the specified array to the tail.
    int AddVectorToTail(CUtlVector<T, A> const& src);

    // Finds an element (element needs operator== defined)
    int Find(const T& src) const;
    void FillWithValue(const T& src);

    bool HasElement(const T& src) const;

    // Makes sure we have enough memory allocated to store a requested # of elements
    void EnsureCapacity(int num);

    // Makes sure we have at least this many elements
    void EnsureCount(int num);

    // Element removal
    void FastRemove(int elem);              // doesn't preserve order
    void Remove(int elem);                  // preserves order, shifts elements
    bool FindAndRemove(const T& src);       // removes first occurrence of src, preserves order, shifts elements
    bool FindAndFastRemove(const T& src);   // removes first occurrence of src, doesn't preserve order
    void RemoveMultiple(int elem, int num); // preserves order, shifts elements
    void RemoveMultipleFromHead(int num);   // removes num elements from tail
    void RemoveMultipleFromTail(int num);   // removes num elements from tail
    void RemoveAll();                       // doesn't deallocate memory

    // Memory deallocation
    void Purge();

    // Purges the list and calls delete on each element in it.
    void PurgeAndDeleteElements();

    // Compacts the vector to the number of elements actually in use
    void Compact();

    // Set the size by which it grows when it needs to allocate more memory.
    void SetGrowSize(int size)
    {
        m_Memory.SetGrowSize(size);
    }

    int NumAllocated() const; // Only use this if you really know what you're doing!

    void Sort(int(__cdecl* pfnCompare)(const T*, const T*));

    // Call this to quickly sort non-contiguously allocated vectors
    void InPlaceQuickSort(int(__cdecl* pfnCompare)(const T*, const T*));

#ifdef DBGFLAG_VALIDATE
    void Validate(CValidator& validator, char* pchName); // Validate our internal structures
#endif                                                   // DBGFLAG_VALIDATE

    // Can't copy this unless we explicitly do it!
    CUtlVector(CUtlVector const& vec)
    {
        Assert(0);
    }

    // Grows the vector
    void GrowVector(int num = 1);

    // Shifts elements....
    void ShiftElementsRight(int elem, int num = 1);
    void ShiftElementsLeft(int elem, int num = 1);

    CAllocator m_Memory;
    int m_Size;

#ifndef _X360
    // For easier access to the elements through the debugger
    // it's in release builds so this can be used in libraries correctly
    T* m_pElements;

    inline void ResetDbgInfo()
    {
        m_pElements = Base();
    }
#else
    inline void ResetDbgInfo()
    {
    }
#endif

    void InPlaceQuickSort_r(int(__cdecl* pfnCompare)(const T*, const T*), int nLeft, int nRight);
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template <typename T, class A>
inline CUtlVector<T, A>::CUtlVector(int growSize, int initSize) : m_Memory(growSize, initSize), m_Size(0)
{
    ResetDbgInfo();
}

template <typename T, class A>
inline CUtlVector<T, A>::CUtlVector(T* pMemory, int allocationCount, int numElements)
    : m_Memory(pMemory, allocationCount), m_Size(numElements)
{
    ResetDbgInfo();
}

template <typename T, class A> inline CUtlVector<T, A>::~CUtlVector()
{
    Purge();
}

template <typename T, class A> inline CUtlVector<T, A>& CUtlVector<T, A>::operator=(const CUtlVector<T, A>& other)
{
    int nCount = other.Count();
    SetSize(nCount);
    for (int i = 0; i < nCount; i++)
    {
        (*this)[i] = other[i];
    }
    return *this;
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template <typename T, class A> inline T& CUtlVector<T, A>::operator[](int i)
{
    // Assert(i < m_Size);
    return m_Memory[i];
}

template <typename T, class A> inline const T& CUtlVector<T, A>::operator[](int i) const
{
    // Assert(i < m_Size);
    return m_Memory[i];
}

template <typename T, class A> inline T& CUtlVector<T, A>::Element(int i)
{
    // Assert(i < m_Size);
    return m_Memory[i];
}

template <typename T, class A> inline const T& CUtlVector<T, A>::Element(int i) const
{
    // Assert(i < m_Size);
    return m_Memory[i];
}

template <typename T, class A> inline T& CUtlVector<T, A>::Head()
{
    // Assert(m_Size > 0);
    return m_Memory[0];
}

template <typename T, class A> inline const T& CUtlVector<T, A>::Head() const
{
    // Assert(m_Size > 0);
    return m_Memory[0];
}

template <typename T, class A> inline T& CUtlVector<T, A>::Tail()
{
    // Assert(m_Size > 0);
    return m_Memory[m_Size - 1];
}

template <typename T, class A> inline const T& CUtlVector<T, A>::Tail() const
{
    // Assert(m_Size > 0);
    return m_Memory[m_Size - 1];
}

//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------
template <typename T, class A> inline int CUtlVector<T, A>::Count() const
{
    return m_Size;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template <typename T, class A> inline bool CUtlVector<T, A>::IsValidIndex(int i) const
{
    return (i >= 0) && (i < m_Size);
}

//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template <typename T, class A> inline int CUtlVector<T, A>::InvalidIndex()
{
    return -1;
}

//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::GrowVector(int num)
{
    if (m_Size + num > m_Memory.NumAllocated())
    {
        // MEM_ALLOC_CREDIT_CLASS();
        m_Memory.Grow(m_Size + num - m_Memory.NumAllocated());
    }

    m_Size += num;
    ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Sorts the vector
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::Sort(int(__cdecl* pfnCompare)(const T*, const T*))
{
    typedef int(__cdecl * QSortCompareFunc_t)(const void*, const void*);
    if (Count() <= 1)
        return;

    if (Base())
    {
        qsort(Base(), Count(), sizeof(T), (QSortCompareFunc_t)(pfnCompare));
    }
    else
    {
        // Assert(0);
        //  this path is untested
        //  if you want to sort vectors that use a non-sequential memory allocator,
        //  you'll probably want to patch in a quicksort algorithm here
        //  I just threw in this bubble sort to have something just in case...

        for (int i = m_Size - 1; i >= 0; --i)
        {
            for (int j = 1; j <= i; ++j)
            {
                if (pfnCompare(&Element(j - 1), &Element(j)) < 0)
                {
                    V_swap(Element(j - 1), Element(j));
                }
            }
        }
    }
}

//----------------------------------------------------------------------------------------------
// Private function that does the in-place quicksort for non-contiguously allocated vectors.
//----------------------------------------------------------------------------------------------
template <typename T, class A>
void CUtlVector<T, A>::InPlaceQuickSort_r(int(__cdecl* pfnCompare)(const T*, const T*), int nLeft, int nRight)
{
    int nPivot;
    int nLeftIdx = nLeft;
    int nRightIdx = nRight;

    if (nRight - nLeft > 0)
    {
        nPivot = (nLeft + nRight) / 2;

        while ((nLeftIdx <= nPivot) && (nRightIdx >= nPivot))
        {
            while ((pfnCompare(&Element(nLeftIdx), &Element(nPivot)) < 0) && (nLeftIdx <= nPivot))
            {
                nLeftIdx++;
            }

            while ((pfnCompare(&Element(nRightIdx), &Element(nPivot)) > 0) && (nRightIdx >= nPivot))
            {
                nRightIdx--;
            }

            V_swap(Element(nLeftIdx), Element(nRightIdx));

            nLeftIdx++;
            nRightIdx--;

            if ((nLeftIdx - 1) == nPivot)
            {
                nPivot = nRightIdx = nRightIdx + 1;
            }
            else if (nRightIdx + 1 == nPivot)
            {
                nPivot = nLeftIdx = nLeftIdx - 1;
            }
        }

        InPlaceQuickSort_r(pfnCompare, nLeft, nPivot - 1);
        InPlaceQuickSort_r(pfnCompare, nPivot + 1, nRight);
    }
}

//----------------------------------------------------------------------------------------------
// Call this to quickly sort non-contiguously allocated vectors. Sort uses a slower bubble sort.
//----------------------------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::InPlaceQuickSort(int(__cdecl* pfnCompare)(const T*, const T*))
{
    InPlaceQuickSort_r(pfnCompare, 0, Count() - 1);
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::EnsureCapacity(int num)
{
    MEM_ALLOC_CREDIT_CLASS();
    m_Memory.EnsureCapacity(num);
    ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::EnsureCount(int num)
{
    if (Count() < num)
    {
        AddMultipleToTail(num - Count());
    }
}

//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::ShiftElementsRight(int elem, int num)
{
    // Assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
    int numToMove = m_Size - elem - num;
    if ((numToMove > 0) && (num > 0))
        memmove(&Element(elem + num), &Element(elem), numToMove * sizeof(T));
}

template <typename T, class A> void CUtlVector<T, A>::ShiftElementsLeft(int elem, int num)
{
    // Assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
    int numToMove = m_Size - elem - num;
    if ((numToMove > 0) && (num > 0))
    {
        memmove(&Element(elem), &Element(elem + num), numToMove * sizeof(T));

#ifdef _DEBUG
        memset(&Element(m_Size - num), 0xDD, num * sizeof(T));
#endif
    }
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------
template <typename T, class A> inline int CUtlVector<T, A>::AddToHead()
{
    return InsertBefore(0);
}

template <typename T, class A> inline int CUtlVector<T, A>::AddToTail()
{
    return InsertBefore(m_Size);
}

template <typename T, class A> inline int CUtlVector<T, A>::InsertAfter(int elem)
{
    return InsertBefore(elem + 1);
}

template <typename T, class A> int CUtlVector<T, A>::InsertBefore(int elem)
{
    // Can insert at the end
    // Assert((elem == Count()) || IsValidIndex(elem));

    GrowVector();
    ShiftElementsRight(elem);
    Construct(&Element(elem));
    return elem;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------
template <typename T, class A> inline int CUtlVector<T, A>::AddToHead(const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(0, src);
}

template <typename T, class A> inline int CUtlVector<T, A>::AddToTail(const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(m_Size, src);
}

template <typename T, class A> inline int CUtlVector<T, A>::InsertAfter(int elem, const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
    return InsertBefore(elem + 1, src);
}

template <typename T, class A> int CUtlVector<T, A>::InsertBefore(int elem, const T& src)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));

    // Can insert at the end
    // Assert((elem == Count()) || IsValidIndex(elem));

    GrowVector();
    ShiftElementsRight(elem);
    CopyConstruct(&Element(elem), src);
    return elem;
}

//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------
template <typename T, class A> inline int CUtlVector<T, A>::AddMultipleToHead(int num)
{
    return InsertMultipleBefore(0, num);
}

template <typename T, class A> inline int CUtlVector<T, A>::AddMultipleToTail(int num)
{
    return InsertMultipleBefore(m_Size, num);
}

template <typename T, class A> inline int CUtlVector<T, A>::AddMultipleToTail(int num, const T* pToCopy)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || !pToCopy || (pToCopy + num <= Base()) || (pToCopy >= (Base() + Count())));

    return InsertMultipleBefore(m_Size, num, pToCopy);
}

template <typename T, class A> int CUtlVector<T, A>::InsertMultipleAfter(int elem, int num)
{
    return InsertMultipleBefore(elem + 1, num);
}

template <typename T, class A> void CUtlVector<T, A>::SetCount(int count)
{
    RemoveAll();
    AddMultipleToTail(count);
}

template <typename T, class A> inline void CUtlVector<T, A>::SetSize(int size)
{
    SetCount(size);
}

template <typename T, class A> void CUtlVector<T, A>::SetCountNonDestructively(int count)
{
    int delta = count - m_Size;
    if (delta > 0)
        AddMultipleToTail(delta);
    else if (delta < 0)
        RemoveMultipleFromTail(-delta);
}

template <typename T, class A> void CUtlVector<T, A>::CopyArray(const T* pArray, int size)
{
    // Can't insert something that's in the list... reallocation may hose us
    // Assert((Base() == NULL) || !pArray || (Base() >= (pArray + size)) || (pArray >= (Base() + Count())));

    SetSize(size);
    for (int i = 0; i < size; i++)
    {
        (*this)[i] = pArray[i];
    }
}

template <typename T, class A> void CUtlVector<T, A>::Swap(CUtlVector<T, A>& vec)
{
    m_Memory.Swap(vec.m_Memory);
    swap(m_Size, vec.m_Size);
#ifndef _X360
    swap(m_pElements, vec.m_pElements);
#endif
}

template <typename T, class A> int CUtlVector<T, A>::AddVectorToTail(CUtlVector const& src)
{
    // Assert(&src != this);

    int base = Count();

    // Make space.
    int nSrcCount = src.Count();
    EnsureCapacity(base + nSrcCount);

    // Copy the elements.
    m_Size += nSrcCount;
    for (int i = 0; i < nSrcCount; i++)
    {
        CopyConstruct(&Element(base + i), src[i]);
    }
    return base;
}

template <typename T, class A> inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num)
{
    if (num == 0)
        return elem;

    // Can insert at the end
    // Assert((elem == Count()) || IsValidIndex(elem));

    GrowVector(num);
    ShiftElementsRight(elem, num);

    // Invoke default constructors
    for (int i = 0; i < num; ++i)
    {
        Construct(&Element(elem + i));
    }

    return elem;
}

template <typename T, class A> inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num, const T* pToInsert)
{
    if (num == 0)
        return elem;

    // Can insert at the end
    // Assert((elem == Count()) || IsValidIndex(elem));

    GrowVector(num);
    ShiftElementsRight(elem, num);

    // Invoke default constructors
    if (!pToInsert)
    {
        for (int i = 0; i < num; ++i)
        {
            Construct(&Element(elem + i));
        }
    }
    else
    {
        for (int i = 0; i < num; i++)
        {
            CopyConstruct(&Element(elem + i), pToInsert[i]);
        }
    }

    return elem;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template <typename T, class A> int CUtlVector<T, A>::Find(const T& src) const
{
    for (int i = 0; i < Count(); ++i)
    {
        if (Element(i) == src)
            return i;
    }
    return -1;
}

template <typename T, class A> void CUtlVector<T, A>::FillWithValue(const T& src)
{
    for (int i = 0; i < Count(); i++)
    {
        Element(i) = src;
    }
}

template <typename T, class A> bool CUtlVector<T, A>::HasElement(const T& src) const
{
    return (Find(src) >= 0);
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------
template <typename T, class A> void CUtlVector<T, A>::FastRemove(int elem)
{
    // Assert(IsValidIndex(elem));

    Destruct(&Element(elem));
    if (m_Size > 0)
    {
        if (elem != m_Size - 1)
            memcpy(&Element(elem), &Element(m_Size - 1), sizeof(T));
        --m_Size;
    }
}

template <typename T, class A> void CUtlVector<T, A>::Remove(int elem)
{
    Destruct(&Element(elem));
    ShiftElementsLeft(elem);
    --m_Size;
}

template <typename T, class A> bool CUtlVector<T, A>::FindAndRemove(const T& src)
{
    int elem = Find(src);
    if (elem != -1)
    {
        Remove(elem);
        return true;
    }
    return false;
}

template <typename T, class A> bool CUtlVector<T, A>::FindAndFastRemove(const T& src)
{
    int elem = Find(src);
    if (elem != -1)
    {
        FastRemove(elem);
        return true;
    }
    return false;
}

template <typename T, class A> void CUtlVector<T, A>::RemoveMultiple(int elem, int num)
{
    // Assert(elem >= 0);
    // Assert(elem + num <= Count());

    for (int i = elem + num; --i >= elem;)
        Destruct(&Element(i));

    ShiftElementsLeft(elem, num);
    m_Size -= num;
}

template <typename T, class A> void CUtlVector<T, A>::RemoveMultipleFromHead(int num)
{
    // Assert(num <= Count());

    for (int i = num; --i >= 0;)
        Destruct(&Element(i));

    ShiftElementsLeft(0, num);
    m_Size -= num;
}

template <typename T, class A> void CUtlVector<T, A>::RemoveMultipleFromTail(int num)
{
    // Assert(num <= Count());

    for (int i = m_Size - num; i < m_Size; i++)
        Destruct(&Element(i));

    m_Size -= num;
}

template <typename T, class A> void CUtlVector<T, A>::RemoveAll()
{
    for (int i = m_Size; --i >= 0;)
    {
        Destruct(&Element(i));
    }

    m_Size = 0;
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template <typename T, class A> inline void CUtlVector<T, A>::Purge()
{
    RemoveAll();
    m_Memory.Purge();
    ResetDbgInfo();
}

template <typename T, class A> inline void CUtlVector<T, A>::PurgeAndDeleteElements()
{
    for (int i = 0; i < m_Size; i++)
    {
        delete Element(i);
    }
    Purge();
}

template <typename T, class A> inline void CUtlVector<T, A>::Compact()
{
    m_Memory.Purge(m_Size);
}

template <typename T, class A> inline int CUtlVector<T, A>::NumAllocated() const
{
    return m_Memory.NumAllocated();
}

template <class T, class M = CUtlMemory<T>> class CUtlStack
{
public:
    // constructor, destructor
    CUtlStack(int growSize = 0, int initSize = 0);
    ~CUtlStack();

    void CopyFrom(const CUtlStack<T, M>& from);

    // element access
    T& operator[](int i);
    T const& operator[](int i) const;
    T& Element(int i);
    T const& Element(int i) const;

    // Gets the base address (can change when adding elements!)
    T* Base();
    T const* Base() const;

    // Looks at the stack top
    T& Top();
    T const& Top() const;

    // Size
    int Count() const;

    // Is element index valid?
    bool IsIdxValid(int i) const;

    // Adds an element, uses default constructor
    int Push();

    // Adds an element, uses copy constructor
    int Push(T const& src);

    // Pops the stack
    void Pop();
    void Pop(T& oldTop);
    void PopMultiple(int num);

    // Makes sure we have enough memory allocated to store a requested # of elements
    void EnsureCapacity(int num);

    // Clears the stack, no deallocation
    void Clear();

    // Memory deallocation
    void Purge();

private:
    // Grows the stack allocation
    void GrowStack();

    // For easier access to the elements through the debugger
    void ResetDbgInfo();

    M m_Memory;
    int m_Size;

    // For easier access to the elements through the debugger
    T* m_pElements;
};

//-----------------------------------------------------------------------------
// For easier access to the elements through the debugger
//-----------------------------------------------------------------------------

template <class T, class M> inline void CUtlStack<T, M>::ResetDbgInfo()
{
    m_pElements = m_Memory.Base();
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template <class T, class M>
CUtlStack<T, M>::CUtlStack(int growSize, int initSize) : m_Memory(growSize, initSize), m_Size(0)
{
    ResetDbgInfo();
}

template <class T, class M> CUtlStack<T, M>::~CUtlStack()
{
    Purge();
}

//-----------------------------------------------------------------------------
// copy into
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::CopyFrom(const CUtlStack<T, M>& from)
{
    Purge();
    EnsureCapacity(from.Count());
    for (int i = 0; i < from.Count(); i++)
    {
        Push(from[i]);
    }
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------

template <class T, class M> inline T& CUtlStack<T, M>::operator[](int i)
{
    // assert(IsIdxValid(i));
    return m_Memory[i];
}

template <class T, class M> inline T const& CUtlStack<T, M>::operator[](int i) const
{
    // assert(IsIdxValid(i));
    return m_Memory[i];
}

template <class T, class M> inline T& CUtlStack<T, M>::Element(int i)
{
    // assert(IsIdxValid(i));
    return m_Memory[i];
}

template <class T, class M> inline T const& CUtlStack<T, M>::Element(int i) const
{
    // assert(IsIdxValid(i));
    return m_Memory[i];
}

//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------

template <class T, class M> inline T* CUtlStack<T, M>::Base()
{
    return m_Memory.Base();
}

template <class T, class M> inline T const* CUtlStack<T, M>::Base() const
{
    return m_Memory.Base();
}

//-----------------------------------------------------------------------------
// Returns the top of the stack
//-----------------------------------------------------------------------------

template <class T, class M> inline T& CUtlStack<T, M>::Top()
{
    // assert(m_Size > 0);
    return Element(m_Size - 1);
}

template <class T, class M> inline T const& CUtlStack<T, M>::Top() const
{
    // assert(m_Size > 0);
    return Element(m_Size - 1);
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------

template <class T, class M> inline int CUtlStack<T, M>::Count() const
{
    return m_Size;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------

template <class T, class M> inline bool CUtlStack<T, M>::IsIdxValid(int i) const
{
    return (i >= 0) && (i < m_Size);
}

//-----------------------------------------------------------------------------
// Grows the stack
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::GrowStack()
{
    if (m_Size >= m_Memory.NumAllocated())
        m_Memory.Grow();

    ++m_Size;

    ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::EnsureCapacity(int num)
{
    m_Memory.EnsureCapacity(num);
    ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------

template <class T, class M> int CUtlStack<T, M>::Push()
{
    GrowStack();
    Construct(&Element(m_Size - 1));
    return m_Size - 1;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------

template <class T, class M> int CUtlStack<T, M>::Push(T const& src)
{
    GrowStack();
    CopyConstruct(&Element(m_Size - 1), src);
    return m_Size - 1;
}

//-----------------------------------------------------------------------------
// Pops the stack
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::Pop()
{
    // assert(m_Size > 0);
    Destruct(&Element(m_Size - 1));
    --m_Size;
}

template <class T, class M> void CUtlStack<T, M>::Pop(T& oldTop)
{
    // assert(m_Size > 0);
    oldTop = Top();
    Pop();
}

template <class T, class M> void CUtlStack<T, M>::PopMultiple(int num)
{
    // assert(m_Size >= num);
    for (int i = 0; i < num; ++i)
        Destruct(&Element(m_Size - i - 1));
    m_Size -= num;
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::Clear()
{
    for (int i = m_Size; --i >= 0;)
        Destruct(&Element(i));

    m_Size = 0;
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template <class T, class M> void CUtlStack<T, M>::Purge()
{
    Clear();
    m_Memory.Purge();
    ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// forward declarations
//-----------------------------------------------------------------------------
class CUtlSymbolTable;
class CUtlSymbolTableMT;

//-----------------------------------------------------------------------------
// This is a symbol, which is a easier way of dealing with strings.
//-----------------------------------------------------------------------------
typedef unsigned short UtlSymId_t;

#define UTL_INVAL_SYMBOL ((UtlSymId_t)~0)

class CUtlSymbol
{
public:
    // constructor, destructor
    CUtlSymbol() : m_Id(UTL_INVAL_SYMBOL)
    {
    }
    CUtlSymbol(UtlSymId_t id) : m_Id(id)
    {
    }

    CUtlSymbol(CUtlSymbol const& sym) : m_Id(sym.m_Id)
    {
    }

    // operator=
    CUtlSymbol& operator=(CUtlSymbol const& src)
    {
        m_Id = src.m_Id;
        return *this;
    }

    // operator==
    bool operator==(CUtlSymbol const& src) const
    {
        return m_Id == src.m_Id;
    }

    // Is valid?
    bool IsValid() const
    {
        return m_Id != UTL_INVAL_SYMBOL;
    }

    // Gets at the symbol
    operator UtlSymId_t() const
    {
        return m_Id;
    }

protected:
    UtlSymId_t m_Id;

    /*
    // The standard global symbol table
    static CUtlSymbolTableMT* s_pSymbolTable;

    static bool s_bAllowStaticSymbolTable;

    friend class CCleanupUtlSymbolTable;*/
};

```

`solace-csgo/menu.cc`:

```cc
#include "menu.hh"

#include "includes.h"
#include "controls/multiselect.hh"
#include "controls/tab.hh"
#include "controls/window.hh"
#include "controls/button.hh"
#include "controls/combobox.hh"
#include "controls/key_bind.hh"
#include "controls/slider.hh"
#include "controls/toggle.hh"
#include "controls/column.hh"
#include "controls/groupbox.hh"

std::array<std::string, 3> config_names = { "Auto", "Scout", "Pistol" };

auto c_menu::init( ) -> void {
	auto main_form = std::make_shared<c_form>( "Solace", area_t{ 200, 400, 580, 424 } );
	this->m_forms.push_back( main_form );
	
	auto aim_tab = std::make_shared<c_tab>( "Rage aim" );
	{
		auto left_column = std::make_shared<c_column>( );
		{
			auto general_group = std::make_shared<c_group_box>( "General" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "General" );
				general_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::rage::general::enabled ) );
				general_tab->add_child( std::make_shared<c_key_bind>( "Key", &settings::rage::general::key ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Auto shoot", &settings::rage::general::auto_shoot ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Silent", &settings::rage::general::silent ) );
				general_group->add_child( general_tab );
			};
			left_column->add_child( general_group );
			auto hitbox_group = std::make_shared<c_group_box>( "Hitboxes" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Selection" );
				general_tab->add_child( std::make_shared<c_multiselect>( "Hitboxes", &settings::rage::hitbox::hitboxes, std::vector<const char*> { "Head", "Chest", "Body", "Arms", "Legs" } ) );
				general_tab->add_child( std::make_shared<c_slider>( "Head scale", &settings::rage::hitbox::point_scale ) );
				general_tab->add_child( std::make_shared<c_slider>( "Body scale", &settings::rage::hitbox::body_scale ) );
				general_tab->add_child( std::make_shared<c_multiselect>( "Body-aim conditions", &settings::rage::hitbox::baim_conditions, std::vector<const char*> { "Prefer Lethal", "Force In-Air" } ) );
				hitbox_group->add_child( general_tab );
			}
			left_column->add_child( hitbox_group );
		}
		aim_tab->add_child( left_column );
		auto right_column = std::make_shared<c_column>( );
		{
			auto selection_group = std::make_shared<c_group_box>( "Selection" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Selection" );
				general_tab->add_child( std::make_shared<c_slider>( "Fov", &settings::rage::selection::fov, 0, 180 ) );
				general_tab->add_child( std::make_shared<c_slider>( "Hitchance", &settings::rage::selection::hitchance ) );
				general_tab->add_child( std::make_shared<c_slider>( "Minimum damage", &settings::rage::selection::min_damage ) );
				general_tab->add_child( std::make_shared<c_slider>( "Extra lethal damage", &settings::rage::selection::lethal_damage ) );
				selection_group->add_child( general_tab );
			}
			right_column->add_child( selection_group );
		}
		aim_tab->add_child( right_column );
	}
	main_form->add_child( aim_tab );
	auto visual_tab = std::make_shared<c_tab>( "Visuals" );
	{
		auto left_column = std::make_shared<c_column>( );
		{
			auto esp_tab = std::make_shared<c_group_box>( "Players" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_toggle>( "Box", &settings::visuals::players::box ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Team", &settings::visuals::players::team ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Name", &settings::visuals::players::name ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Health", &settings::visuals::players::health ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Weapon", &settings::visuals::players::weapon ) );
				general_tab->add_child( std::make_shared<c_combobox>( "Chams - enemy", &settings::visuals::players::chams, std::vector<const char *> {"Off", "Full", "Flat"} ) );
				general_tab->add_child( std::make_shared<c_combobox>( "Chams - enemy covered", &settings::visuals::players::chams_covered, std::vector<const char *> {"Off", "Full", "Flat"} ) );
				general_tab->add_child( std::make_shared<c_combobox>( "Chams - team", &settings::visuals::players::chams_team, std::vector<const char *> {"Off", "Full", "Flat"} ) );
				general_tab->add_child( std::make_shared<c_combobox>( "chams - team covered", &settings::visuals::players::chams_team_covered, std::vector<const char *> {"Off", "Full", "Flat"} ) );
				esp_tab->add_child( general_tab );
			}
			left_column->add_child( esp_tab );
			auto chams_group = std::make_shared<c_group_box>( "Weapons" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_toggle>( "Box", &settings::visuals::weapons::box ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Name", &settings::visuals::weapons::name ) );
				general_tab->add_child( std::make_shared<c_toggle>( "No scope", &settings::visuals::weapons::noscope ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Grendae Prediction", &settings::visuals::weapons::grenade_prediction ) );
				chams_group->add_child( general_tab );
			}
			left_column->add_child( chams_group );
		} visual_tab->add_child( left_column );


		auto right_column = std::make_shared<c_column>( );
		{
			auto world_group = std::make_shared<c_group_box>( "World" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_toggle>( "Molotov", &settings::visuals::world::molotov ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Wireframe smoke", &settings::visuals::world::wire_smoke ) );
				world_group->add_child( general_tab );
			}
			right_column->add_child( world_group );
			auto misc_group = std::make_shared<c_group_box>( "Misc" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_slider>( "Fov", &settings::visuals::misc::fov, 0, 180 ) );
				general_tab->add_child( std::make_shared<c_slider>( "Aspect ratio", &settings::visuals::misc::aspectratio, 0, 200 ) );
				misc_group->add_child( general_tab );
			}
			right_column->add_child( misc_group );
		} visual_tab->add_child( right_column );
	}
	main_form->add_child( visual_tab );
	/// This was left in from when this wasn't a legacy cheat, no real point in a game ver only used for hvh
	/*	auto legit_tab = std::make_shared<c_tab>( "Legit aim" );
	{
		auto left_column = std::make_shared<c_column>( );
		{
			auto general_group = std::make_shared<c_group_box>( "General" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::legit::general::enabled ) );
				general_tab->add_child( std::make_shared<c_key_bind>( "Key", &settings::legit::general::key ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Auto shoot", &settings::legit::general::auto_shoot ) );
				general_tab->add_child( std::make_shared<c_toggle>( "Silent", &settings::legit::general::silent ) );
				general_tab->add_child( std::make_shared<c_slider>( "Smoothing", &settings::legit::general::smoothing, 0, 100 ) );
				general_group->add_child( general_tab );
			};
			left_column->add_child( general_group );
		} legit_tab->add_child( left_column );
		auto right_column = std::make_shared<c_column>( );
		{
			auto selection_tab = std::make_shared<c_group_box>( "Selection" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_slider>( "Fov", &settings::legit::selection::fov, 0, 180 ) );
				general_tab->add_child( std::make_shared<c_slider>( "Minimum damage", &settings::legit::selection::min_damage ) );
				general_tab->add_child( std::make_shared<c_multiselect>( "Hitboxes", &settings::legit::selection::hitboxes, std::vector<const char *> { "Head", "Chest", "Body", "Arms", "Legs" } ) );
				selection_tab->add_child( general_tab );
			}
			right_column->add_child( selection_tab );
			auto recoil_group = std::make_shared<c_group_box>( "Recoil" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "Players" );
				general_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::legit::recoil::enabled ) );
				general_tab->add_child( std::make_shared<c_slider>( "X factor", &settings::legit::recoil::x_factor ) );
				general_tab->add_child( std::make_shared<c_slider>( "Y factor", &settings::legit::recoil::y_factor ) );
				recoil_group->add_child( general_tab );
			}
			right_column->add_child( recoil_group );
		} legit_tab->add_child( right_column );
	}
	main_form->add_child( legit_tab );*/

	auto hvh_form = std::make_shared<c_tab>( "Hvh" );
	{
		auto left_column = std::make_shared<c_column>( );
		{
			auto antiaim_tab = std::make_shared<c_group_box>( "Angles" );
			{
				auto stand_tab = std::make_shared<c_group_tab>( "Stand" ); //todo: reformat this to look a bit cleaner
				{
					stand_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::hvh::antiaim::enabled ) );
					stand_tab->add_child( std::make_shared<c_combobox>( "Body", &settings::hvh::antiaim::body_fake_stand, std::vector<const char *> { "Off", "Left", "Right", "Opposite", "Z" } ) );
					stand_tab->add_child( std::make_shared<c_combobox>( "Fake", &settings::hvh::antiaim::fake_yaw, std::vector<const char *> { "Off", "Default", "Relative", "Relative jitter", "Rotate", "Random", "Local view" } ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Fake relative", &settings::hvh::antiaim::fake_relative, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Fake jitter range", &settings::hvh::antiaim::fake_jitter_range, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_combobox>( "Pitch", &settings::hvh::antiaim::pitch_stand, std::vector<const char *> { "Off", "Down", "Up", "Random" } ) );
					stand_tab->add_child( std::make_shared<c_combobox>( "Yaw offset", &settings::hvh::antiaim::yaw_stand, std::vector<const char *> { "Off", "Direction", "Jitter", "Rotate", "Random", "Distort" }));
					stand_tab->add_child( std::make_shared<c_combobox>( "Yaw dir", &settings::hvh::antiaim::dir_stand, std::vector<const char *> { "Direction", "Backwards", "Left", "Right" } ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Stand jitter range", &settings::hvh::antiaim::jitter_range_stand, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Rot range", &settings::hvh::antiaim::rot_range_stand, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Rot speed", &settings::hvh::antiaim::rot_speed_stand, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_slider>( "Random update speed", &settings::hvh::antiaim::rand_update_stand, -180, 180 ) );
					stand_tab->add_child( std::make_shared<c_combobox>( "Base angle", &settings::hvh::antiaim::base_angle_stand, std::vector<const char *> { "Off", "Static", "Away crosshair", "Away distance" } ) );
				} antiaim_tab->add_child( stand_tab );
				auto move_tab = std::make_shared<c_group_tab>( "Move" );
				{
					move_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::hvh::antiaim::enabled ) );
					move_tab->add_child( std::make_shared<c_combobox>( "Fake", &settings::hvh::antiaim::fake_yaw, std::vector<const char *> { "Off", "Default", "Relative", "Relative jitter", "Rotate", "Random", "Local view" } ) );
					move_tab->add_child( std::make_shared<c_slider>( "Fake relative", &settings::hvh::antiaim::fake_relative, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_slider>( "Fake jitter range", &settings::hvh::antiaim::fake_jitter_range, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_combobox>( "Pitch", &settings::hvh::antiaim::pitch_walk, std::vector<const char *> { "Off", "Down", "Up", "Random" } ) );
					move_tab->add_child( std::make_shared<c_combobox>( "Yaw offset walking", &settings::hvh::antiaim::yaw_walk, std::vector<const char *> { "Off", "Direction", "Jitter", "Rotate", "Random", "Break" } ) );
					move_tab->add_child( std::make_shared<c_combobox>( "Yaw dir walking", &settings::hvh::antiaim::dir_walk, std::vector<const char *> { "Direction", "Backwards", "Left", "Right" } ) );
					move_tab->add_child( std::make_shared<c_slider>( "Walk jitter range", &settings::hvh::antiaim::jitter_range_walk, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_slider>( "Rot range walk", &settings::hvh::antiaim::rot_range_walk, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_slider>( "Rot speed walk", &settings::hvh::antiaim::rot_speed_walk, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_slider>( "Random update speed walk", &settings::hvh::antiaim::rand_update_walk, -180, 180 ) );
					move_tab->add_child( std::make_shared<c_combobox>( "Base angle walk", &settings::hvh::antiaim::base_angle_walk, std::vector<const char *> { "Off", "Static", "Away crosshair", "Away distance" } ) );

				} antiaim_tab->add_child( move_tab );
				auto air_tab = std::make_shared<c_group_tab>( "Air" );
				{
					air_tab->add_child( std::make_shared<c_toggle>( "Enabled", &settings::hvh::antiaim::enabled ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Body", &settings::hvh::antiaim::body_fake_air, std::vector<const char *> { "Off", "Left", "Right", "Opposite" } ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Fake", &settings::hvh::antiaim::fake_yaw, std::vector<const char *> { "Off", "Default", "Relative", "Relative jitter", "Rotate", "Random", "Local view" } ) );
					air_tab->add_child( std::make_shared<c_slider>( "Fake relative", &settings::hvh::antiaim::fake_relative, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_slider>( "Fake jitter range", &settings::hvh::antiaim::fake_jitter_range, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Pitch", &settings::hvh::antiaim::pitch_air, std::vector<const char *> { "Off", "Down", "Up", "Random" } ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Yaw offset", &settings::hvh::antiaim::yaw_air, std::vector<const char *> { "Off", "Direction", "Jitter", "Rotate", "Random" } ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Yaw dir", &settings::hvh::antiaim::dir_air, std::vector<const char *> { "Direction", "Backwards", "Left", "Right" } ) );
					air_tab->add_child( std::make_shared<c_slider>( "Air jitter range", &settings::hvh::antiaim::jitter_range_air, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_slider>( "Rot range", &settings::hvh::antiaim::rot_range_air, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_slider>( "Rot speed", &settings::hvh::antiaim::rot_speed_air, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_slider>( "Random update speed", &settings::hvh::antiaim::rand_update_air, -180, 180 ) );
					air_tab->add_child( std::make_shared<c_combobox>( "Base angle", &settings::hvh::antiaim::base_angle_air, std::vector<const char *> { "Off", "Static", "Away crosshair", "Away distance" } ) );

				} antiaim_tab->add_child( air_tab );
				
				
			}
			left_column->add_child( antiaim_tab );
		} hvh_form->add_child( left_column );
		auto right_column = std::make_shared<c_column>( );
		{
			auto lag_tab = std::make_shared<c_group_box>( "Lag" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "" );
				{
					general_tab->add_child( std::make_shared<c_toggle>( "Lag", &settings::hvh::antiaim::lag_enable ) );
					general_tab->add_child( std::make_shared<c_multiselect>( "Lag activation", &settings::hvh::antiaim::lag_active, std::vector<const char *> { "Move", "Air", "Crouch" } ) );
					general_tab->add_child( std::make_shared<c_combobox>( "Lag mode", &settings::hvh::antiaim::lag_mode, std::vector<const char *> { "Max", "Random", "Break step", "Rotate", "Random", "Peek" } ) );
					general_tab->add_child( std::make_shared<c_slider>( "Lag limit", &settings::hvh::antiaim::lag_limit, 0, 15 ) );
				}
				lag_tab->add_child( general_tab );
			}
			right_column->add_child( lag_tab );
			auto misc_tab = std::make_shared<c_group_box>( "Misc" );
			{
				auto general_tab = std::make_shared<c_group_tab>( "" );
				{
					general_tab->add_child(std::make_shared<c_key_bind>("Fake walk", &settings::hvh::antiaim::fakewalk, 1));
					general_tab->add_child(std::make_shared<c_key_bind>("Fake head", &settings::hvh::antiaim::fakehead, 1));
					general_tab->add_child( std::make_shared<c_key_bind>( "Auto peek", &settings::hvh::antiaim::auto_peek, 1 ) );
				}
				misc_tab->add_child( general_tab );
			} right_column->add_child( misc_tab );
		} hvh_form->add_child( right_column );
	} main_form->add_child( hvh_form );
	
	auto misc_form = std::make_shared<c_tab>( "Misc");
	{
		auto left_column = std::make_shared<c_column>( );
		{
			auto movement_group = std::make_shared<c_group_box>( "Movement" );
			{
				auto movement_tab = std::make_shared<c_group_tab>( "Movement" );
				movement_tab->add_child( std::make_shared<c_toggle>( "Bhop", &settings::misc::movement::bhop ) );
				movement_tab->add_child( std::make_shared<c_key_bind>( "Pre speed", &settings::misc::movement::pre_speed, key_bind_type_toggle ) );
				movement_tab->add_child( std::make_shared<c_combobox>( "Auto Strafer", &settings::misc::movement::autostrafe, std::vector<const char *> { "Off", "Normal", "Directional" } ) );
				movement_group->add_child( movement_tab );
			}
			left_column->add_child( movement_group );
		} misc_form->add_child( left_column );
		auto right_column = std::make_shared<c_column>( );
		{
			auto griefing_tab = std::make_shared<c_group_box>( "Griefing" );
			{
				auto movement_tab = std::make_shared<c_group_tab>( "Movement" );
				movement_tab->add_child( std::make_shared<c_key_bind>( "Block bot", &settings::misc::griefing::block_bot, key_bind_type_toggle ) );
				griefing_tab->add_child( movement_tab );
			}
			right_column->add_child( griefing_tab );
			auto misc_tab = std::make_shared<c_group_box>( "Misc" );
			{
				auto misc_tab2 = std::make_shared<c_group_tab>( "Misc" ); {
					misc_tab2->add_child( std::make_shared<c_toggle>( "Ping exploit", &settings::misc::misc::fake_latency ) );
					misc_tab2->add_child( std::make_shared<c_slider>( "Ping amount", &settings::misc::misc::fake_latency_amt, 0, 1000 ) );
					misc_tab2->add_child( std::make_shared<c_key_bind>( "Thirdperson", &settings::misc::misc::thirdperson, 2 ) );
					misc_tab->add_child( misc_tab2 );
				}
				auto movement_tab = std::make_shared<c_group_tab>( "Config" ); {
					movement_tab->add_child( std::make_shared<c_combobox>( "Config", &settings::misc::config::slot, std::vector<const char*> { "Auto", "Scout", "Pistol" } ) );
					movement_tab->add_child( std::make_shared<c_button>( "Save", [ ] {
						std::string name = config_names[ settings::misc::config::slot ];
						std::ofstream file( name.c_str( ) );
						std::streambuf* coutbuf = std::cout.rdbuf( ); //save old buf
						std::cout.rdbuf( file.rdbuf( ) ); //redirect std::cin to in.txt!

						if ( file.good( ) ) {
							menu.save( );
						}

						std::cout.rdbuf( coutbuf ); //reset to standard output again

						file.close( );
						} ) );
					movement_tab->add_child( std::make_shared<c_button>( "Load", [ ] {
						std::string name = config_names[ settings::misc::config::slot ];
						std::ifstream in( name.c_str( ) );
						std::streambuf* cinbuf = std::cin.rdbuf( ); //save old buf
						std::cin.rdbuf( in.rdbuf( ) ); //redirect std::cin to in.txt!

						menu.load( );

						std::cin.rdbuf( cinbuf ); //reset to standard output again
						in.close( );
						} ) );
					misc_tab->add_child( movement_tab );
				}
			}
			right_column->add_child( misc_tab );
		} misc_form->add_child( right_column );
	} main_form->add_child( misc_form );
}

auto c_menu::draw( ) -> void {
	if ( !open )
		return;

	for ( auto form : this->m_forms ) {
		if ( !form->m_enabled( ) ) {
			if ( form.get( ) == this->focused_form )	
				menu.focused_form = nullptr;

			continue;
		}

		// we want to draw the focused form later.
		if ( form.get( ) == this->focused_form )
			continue;

		form->draw( );
	}

	if ( this->focused_form )
		this->focused_form->draw( );
}

auto c_menu::update( ) -> void {
	if ( input_helper.key_pressed( VK_INSERT ) )
		open = !open;
	if ( !open )
		return;
	for ( auto form : this->m_forms ) {
		if ( form->m_enabled( ) )
			form->update( );
	}
}

void c_menu::append_bind ( key_bind_t *value ) {
	n_binds.push_back( value );
}

void c_menu::save() {
	for (auto &i : m_forms) {
		i->save();
	}
}

void c_menu::load() {
	for (auto &i : m_forms) {
		i->load();
	}
}

void key_bind_t::update ( ) {
	type = std::clamp( type, 0, static_cast< int >(this->key_bind_types_.size( )) );

	switch ( type ) {
	case key_bind_type_always : *enabled = true;
		break;
	case key_bind_type_hold : *enabled = input_helper.key_down( key );
		break;
	case key_bind_type_toggle : {
		if ( input_helper.key_pressed_prestine( key ) )
			*enabled = !*enabled;
	}
	break;
	case key_bind_type_off_key : *enabled = !GetAsyncKeyState( key );
		break;
	default : *enabled = true;
		break;
	}
}

```

`solace-csgo/menu.hh`:

```hh
#pragma once
#include <algorithm>
#include <memory>
#include <vector>

#include "render.h"

enum key_bind_type_t {
	key_bind_type_always = 0,
	key_bind_type_hold,
	key_bind_type_toggle,
	key_bind_type_off_key
};

struct key_bind_t {
	key_bind_t(){}
	key_bind_t( const char *name, bool *value, int default_type ) {
		this->name = name;
		enabled = value;
		type = default_type;
	}
	std::vector<const char *> key_bind_types_{ "Always", "Hold", "Toggle", "Off Key" };
	void update ( );
	const char *name = "";
	int key = 0;
	int type = key_bind_type_always;
	bool *enabled = nullptr;
};

class c_form;
class c_base_control;
class vector_2d {
public:
	float x = 0, y = 0;
	vector_2d( float x, float y ) : x( x ), y( y ){}
};
class c_menu {
public:
	bool open = true;
	color main_theme = color( 0x8A, 0x86, 0xA6, 0xFF );
	color bright = color( 0xBF,0xBE,0xBD, 0xFF );
	color bright_accent = color( 209, 176, 194, 0xFF );
	color dark = color( 0x1B, 0x17, 0x26, 0xFF );
	color dark_accent = color( 0x8A, 0x86, 0xA6, 0xFF );
	auto init( ) -> void;
	auto draw( ) -> void;
	auto update( ) -> void;
	void append_bind ( key_bind_t * value );

	std::vector< key_bind_t * > n_binds = {};
	
	c_base_control* focused_control = nullptr;
	c_form* focused_form = nullptr;
	std::vector<std::shared_ptr<c_form>> m_forms = {};


	void save();
	void load();
	// simple render wrapper so it'll be easy to port to opengl / surface.
}; inline c_menu menu;
```

`solace-csgo/model_info.h`:

```h
#pragma once
#include "includes.h"

struct model_t {
	void *handle;
	char	name[ 260 ];
	int	load_flags;
	int	server_count;
	int	type;
	int	flags;
	vec3_t	vec_mins;
	vec3_t	vec_maxs;
	float	radius;
};

typedef unsigned short ModelInstanceHandle_t;
struct model_render_info_t {
	vec3_t                  origin;
	ang_t                  angles;
	void *pRenderable;
	const model_t *pModel;
	const matrix_t *pModelToWorld;
	const matrix_t *pLightingOffset;
	const vec3_t *pLightingOrigin;
	int                     flags;
	int                     entity_index;
	int                     skin;
	int                     body;
	int                     hitboxset;
	ModelInstanceHandle_t   instance;

	model_render_info_t( ) {
		pModelToWorld = NULL;
		pLightingOffset = NULL;
		pLightingOrigin = NULL;
	}
};

class i_mdl_cache {
public:
	void begin_lock() {
		using original_fn = void( __thiscall * )( i_mdl_cache * );
		return ( *( original_fn ** )this )[ 32 ]( this );
	}
	void end_lock() {
		using original_fn = void(__thiscall*)(i_mdl_cache*);
		return (*(original_fn**)this)[33](this);
	}
	void begin_coarse_lock() {
		using original_fn = void(__thiscall*)(i_mdl_cache*);
		return (*(original_fn**)this)[34](this);
	}
	void end_coarse_lock() {
		using original_fn = void(__thiscall*)(i_mdl_cache*);
		return (*(original_fn**)this)[35](this);
	}
};

class studio_hdr_t;

class model_info_t {
public:
	model_t *get_model( int index ) {
		using original_fn = model_t * ( __thiscall * )( model_info_t *, int );
		return ( *( original_fn ** )this )[ 1 ]( this, index );
	}
	int get_model_index( const char *filename ) {
		using original_fn = int( __thiscall * )( model_info_t *, const char * );
		return ( *( original_fn ** )this )[ 2 ]( this, filename );
	}
	const char *get_model_name( const model_t *model ) {
		using original_fn = const char *( __thiscall * )( model_info_t *, const model_t * );
		return ( *( original_fn ** )this )[ 3 ]( this, model );
	}
	studio_hdr_t *get_studio_model( const model_t *model ) {
		using original_fn = studio_hdr_t * ( __thiscall * )( model_info_t *, const model_t * );
		return ( *( original_fn ** )this )[ 30 ]( this, model );
	}
};
```

`solace-csgo/movement.cpp`:

```cpp
#include "movement.h"

#include "includes.h"
#include "prediction.h"
#include "predictioncopy.h"
#include "render.h"

void movement::draw()
{
    if (!g.m_running_client)
        return;

    // auto s = std::to_string(jump_count);
    //
    // g.m_render->text(g.m_render->m_tahoma_14(), 960, 540, color(255, 255, 255),
    // s.c_str(), 2);

    if (settings::hvh::antiaim::auto_peek)
        m_time_left += g.m_interfaces->globals()->m_abs_frametime;
    else
        m_time_left -= g.m_interfaces->globals()->m_abs_frametime;
    m_time_left = fminf(0.5f, fmaxf(m_time_left, 0.f));
    const auto radius = 17.f * (m_time_left / 0.5f);
    if (radius > 0)
    {
        const auto origin = m_stop_pos;
        vec3_t origin_w2s;

        if (!math::world_to_screen(origin, origin_w2s))
            return;

        render_t::vertex_t verts[3] = {};
        auto point_color = color{0xFF, 0x08, 0xFF};
        for (auto i = 0; i < 360; i += 5)
        {
            auto rot = origin + ang_t(0, i, 0).forward() * radius;
            auto rot_2 = origin + ang_t(0, i + 5.f, 0).forward() * radius;

            vec3_t point_wts;
            vec3_t point_wts_2;

            if (!math::world_to_screen(rot, point_wts))
                continue;
            if (!math::world_to_screen(rot_2, point_wts_2))
                continue;

            point_color.set_a(20);
            verts[0] = {roundf(point_wts.x), roundf(point_wts.y), 0, 1, point_color};
            verts[1] = {roundf(point_wts_2.x), roundf(point_wts_2.y), 0, 1, point_color};
            point_color.set_a(100);
            verts[2] = {roundf(origin_w2s.x), roundf(origin_w2s.y), 0, 1, point_color};
            g.m_render->render_triangle(verts, 1);
            point_color.set_a(50);
            g.m_render->line(roundf(point_wts.x), roundf(point_wts.y), roundf(point_wts_2.x), roundf(point_wts_2.y),
                             point_color, 1);
        }
    }
}

void movement::bhop()
{
    if (!settings::misc::movement::bhop)
        return;
    if (!(g.m_cmd->m_buttons & IN_JUMP))
        return;
    if (g.m_interfaces->entity_list()->get_client_entity_handle(g.m_local->m_ground_entity()))
        return;

    g.m_cmd->m_buttons &= ~IN_JUMP;
}

void movement::QuickStop()
{
    if (!m_should_stop)
        return;

    set_should_stop(false);

    if (!g.m_interfaces->entity_list()->get_client_entity_handle(g.m_local->m_ground_entity()))
        return;

    static auto sv_friction = g.m_interfaces->console()->get_convar("sv_friction");
    static auto sv_stopspeed = g.m_interfaces->console()->get_convar("sv_stopspeed");
    const auto friction = sv_friction->GetFloat() * g.m_local->surface_friction();

    const auto speed = g.m_local->velocity().length();
    // calculate speed.

    if (speed <= 0.1f)
    {
        g.m_cmd->m_forwardmove = 0.f;
        g.m_cmd->m_sidemove = 0.f;
        return;
    }

    // bleed off some speed, but if we have less than the bleed, threshold, bleed
    // the threshold amount.
    const auto control = fmaxf(speed, sv_stopspeed->GetFloat());

    // calculate the drop amount.
    const auto drop = control * friction * g.m_interfaces->globals()->m_interval_per_tick;

    // scale the velocity.
    const auto newspeed = fmaxf(0.f, speed - drop);

    g.m_view_angles = g.m_local->velocity().look(vec3_t());

    if (newspeed > 0.1f)
    {
        g.m_cmd->m_forwardmove = newspeed;
        g.m_cmd->m_sidemove = 0.f;
    }
    else
    {
        g.m_cmd->m_forwardmove = 0.f;
        g.m_cmd->m_sidemove = 0.f;
    }
}

void movement::PreciseMove()
{
    if (!g.m_interfaces->entity_list()->get_client_entity_handle(g.m_local->m_ground_entity()) ||
        settings::hvh::antiaim::fakewalk)
        return;
    if (g.m_cmd->m_buttons & IN_JUMP)
        return;
    if (g.m_cmd->m_forwardmove != 0.f || g.m_cmd->m_sidemove != 0.f)
        return;
    static auto sv_friction = g.m_interfaces->console()->get_convar("sv_friction");
    static auto sv_stopspeed = g.m_interfaces->console()->get_convar("sv_stopspeed");
    const auto friction = sv_friction->GetFloat() * g.m_local->surface_friction();

    const auto speed = g.m_local->velocity().length();
    // calculate speed.

    if (speed <= 0.1f)
    {
        g.m_cmd->m_forwardmove = 0.f;
        g.m_cmd->m_sidemove = 0.f;
        return;
    }

    // bleed off some speed, but if we have less than the bleed, threshold, bleed
    // the threshold amount.
    const auto control = fmaxf(speed, sv_stopspeed->GetFloat());

    // calculate the drop amount.
    const auto drop = control * friction * g.m_interfaces->globals()->m_interval_per_tick;

    // scale the velocity.
    const auto newspeed = fmaxf(0.f, speed - drop);
    g.m_view_angles = g.m_local->velocity().look(vec3_t());

    if (newspeed > 0.1f)
    {
        g.m_cmd->m_forwardmove = newspeed;
        g.m_cmd->m_sidemove = 0.f;
    }
    else
    {
        g.m_cmd->m_forwardmove = 0.f;
        g.m_cmd->m_sidemove = 0.f;
    }
}

void movement::auto_peek()
{
    // set to invert if we press the button.
    static auto last = false;
    if (settings::hvh::antiaim::auto_peek)
    {
        if (last != true)
        {
            m_stop_pos = g.m_local->origin();
            m_time_left = 0;
        }

        if (m_should_unpeek)
            m_invert = true;

        if (m_invert)
        {
            move_to(m_stop_pos);
            set_should_stop(false);
        }
    }

    else
    {
        m_invert = false;
    }
    set_should_unpeek(false);
    last = settings::hvh::antiaim::auto_peek;
}

void movement::move_to(vec3_t target_origin) const
{
    const auto local_origin = g.m_local->origin();
    static auto sv_friction = g.m_interfaces->console()->get_convar("sv_friction");
    static auto sv_stopspeed = g.m_interfaces->console()->get_convar("sv_stopspeed");

    auto velocity = g.m_local->velocity();
    auto speed = velocity.length_2d();

    if (speed > 0.1f)
    {
        const auto friction = sv_friction->GetFloat() * g.m_local->surface_friction();
        auto stop_speed = std::max<float>(speed, sv_stopspeed->GetFloat());
        auto control = fminf(speed, stop_speed);
        auto drop = control * friction * g.m_interfaces->globals()->m_interval_per_tick;
        auto newspeed = speed - drop;
        if (newspeed < 0)
            newspeed = 0;

        newspeed /= speed;
        velocity *= newspeed;
    }

    auto local_delta = (target_origin - local_origin) / g.m_interfaces->globals()->m_interval_per_tick;
    local_delta -= velocity;
    local_delta.z = 0.f;

    // if (local_delta.length_2d() > 0.1f) {
    //	drop = sv_stopspeed->GetFloat() * friction *
    // g.m_interfaces->globals()->m_interval_per_tick; 	newspeed = speed + drop;
    //
    //	local_delta *= newspeed / speed;
    //}

    static auto sv_accelerate = g.m_interfaces->console()->get_convar("sv_accelerate");

    float max_accel = 450;
    auto accel_speed = sv_accelerate->GetFloat() * g.m_interfaces->globals()->m_interval_per_tick * 450;
    if (max_accel > accel_speed)
        max_accel = accel_speed;

    auto current_speed = velocity.dot(local_delta.normalized());

    auto projected_delta = fminf(450.f, local_delta.length_2d() + current_speed);

    if (g.m_weapon_info && g.m_weapon_info->m_max_player_speed > 0.f)
    {
        const auto fRatio = projected_delta / g.m_weapon_info->m_max_player_speed;
        if (fRatio > 0.f)
            projected_delta /= fRatio;
    }

    g.m_view_angles = ang_t(0, static_cast<float>(atan2(local_delta.y, local_delta.x) * (180.f / M_PI)), 0);
    ;

    const auto add_speed = projected_delta - current_speed;
    if (max_accel <= add_speed)
    {
        // distance is farther than we can account for
        // go as fast as we can
        g.m_cmd->m_forwardmove = 450;
        g.m_cmd->m_sidemove = 0;
    }
    else
    {
        // const float kAccelerationScale = MAX( 250.0f, wishspeed );
        // accelspeed = accel * gpGlobals->frametime * kAccelerationScale *
        // player->m_surfaceFriction; accel_speed = sv_accelerate->GetFloat( ) *
        // g.m_interfaces->globals( )->m_interval_per_tick * fmaxf( 250,
        // projected_delta );

        if (accel_speed <= add_speed)
        {
            // add speed is too high, try to correct the accelspeed
            projected_delta =
                projected_delta / (sv_accelerate->GetFloat() * g.m_interfaces->globals()->m_interval_per_tick);
        }
        g.m_cmd->m_forwardmove = std::clamp<float>(projected_delta, -450.f, 450.f);
        g.m_cmd->m_sidemove = 0.f;
    }
}

bool bCheck() // checks for edgebug
{
    if (g.m_local->velocity().z >= -7.f && floorf(g.m_local->velocity().z) != 7.f &&
        !(g.m_local->flags() & fl_onground))
        return true;
    else
        return false;
}

void movement::edge_bug()
{
    // return;
    auto* map = g.m_local->GetPredDescMap();

    if (map)
    {
        const auto size = max(map->m_packed_size, 4);
        static auto startdata = new byte[size];
        auto CopyHelper =
            CPredictionCopy(PC_EVERYTHING, static_cast<byte*>(startdata), true,
                            reinterpret_cast<const byte*>(g.m_local), false, CPredictionCopy::TRANSFERDATA_COPYONLY);
        CopyHelper.TransferData("edgebug_pre", g.m_local->index(), map);
        float backup_fmove = g.m_cmd->m_forwardmove;
        float backup_smove = g.m_cmd->m_sidemove;
        bool hit = false;

        static bool found = false;
        if (found)
        {
            if (bCheck() || g.m_local->flags() & fl_onground)
                found = false;
            else
            {
                g.m_cmd->m_forwardmove = g.m_cmd->m_sidemove = 0.f;
            }
        }

        if (!found)
        {
            g.m_cmd->m_forwardmove = g.m_cmd->m_sidemove = 0.f;
            bool ran = false;
            vec3_t original_orig = g.m_local->origin();
            for (auto i = 0; i < 1 / (g.m_interfaces->globals()->m_interval_per_tick / 10.f); i++)
            {
                if (g.m_local->flags() & fl_onground)
                {
                    break;
                }
                ran = true;
                prediction::start(g.m_cmd);
                if (bCheck() && original_orig.z > g.m_local->origin().z)
                {
                    hit = true;
                    found = true;
                    break;
                }
            }
            if (!hit)
            {
                g.m_cmd->m_forwardmove = backup_fmove;
                g.m_cmd->m_sidemove = backup_smove;
            }
            if (ran)
                prediction::end();
        }

        CopyHelper = CPredictionCopy(PC_EVERYTHING, reinterpret_cast<byte*>(g.m_local), false,
                                     static_cast<const byte*>(startdata), true, CPredictionCopy::TRANSFERDATA_COPYONLY);
        CopyHelper.TransferData("edgebug_post", g.m_local->index(), map);
    }
}

void movement::auto_strafe()
{
    if (settings::misc::movement::autostrafe == 0)
        return;

    if (!(g.m_cmd->m_buttons & IN_JUMP) && !m_force_strafe)
        return;

    m_force_strafe = false; // this will be reset every tick anyways

    if (g.m_interfaces->entity_list()->get_client_entity_handle(g.m_local->m_ground_entity()))
        return;

    const auto velocity = g.m_local->velocity();

    const float speed = velocity.length_2d();

    // compute the ideal strafe angle for our velocity.
    const float ideal = (speed > 0.f) ? RAD2DEG(std::asin(15.f / speed)) : 90.f;
    const float ideal2 = (speed > 0.f) ? RAD2DEG(std::asin(30.f / speed)) : 90.f;

    m_switch *= -1;

    auto direction = vec3_t();
    if (g.m_cmd->m_sidemove == 0 && g.m_cmd->m_forwardmove == 0)
        direction += vec3_t(1, 0, 0);

    if (g.m_cmd->m_forwardmove < 0)
        direction += vec3_t(-1, 0, 0);
    else if (g.m_cmd->m_forwardmove > 0)
        direction += vec3_t(1, 0, 0);

    if (g.m_cmd->m_sidemove > 0)
        direction += vec3_t(0, -1, 0);
    else if (g.m_cmd->m_sidemove < 0)
        direction += vec3_t(0, 1, 0);

    g.m_view_angles.y += static_cast<float>(atan2(direction.y, direction.x) * (180.f / M_PI));

    const auto delta = math::normalize_angle(g.m_view_angles.y - m_old_yaw, 180);

    // convert to absolute change.
    const auto abs_delta = std::abs(delta);

    g.m_cmd->m_sidemove = 0;
    g.m_cmd->m_forwardmove = 0;
    // set strafe direction based on mouse direction change.
    if (delta > 0.f)
        g.m_cmd->m_sidemove = -450.f;

    else if (delta < 0.f)
        g.m_cmd->m_sidemove = 450.f;

    // we can accelerate more, because we strafed less then needed
    // or we got of track and need to be retracked.

    /*
     * data struct
     * 68 74 74 70 73 3a 2f 2f 73 74 65 61 6d 63 6f 6d 6d 75 6e 69 74 79 2e 63 6f
     * 6d 2f 69 64 2f 73 69 6d 70 6c 65 72 65 61 6c 69 73 74 69 63 2f
     */

    if (abs_delta <= ideal2 || abs_delta >= 30.f)
    {
        // compute angle of the direction we are traveling in.
        const auto velocity_angle = RAD2DEG(atan2(velocity.y, velocity.x));

        // get the delta between our direction and where we are looking at.
        auto velocity_delta = velocity_angle - g.m_view_angles.y;
        while (velocity_delta > 180)
            velocity_delta -= 360;
        while (velocity_delta < -180)
            velocity_delta += 360;

        // correct our strafe amongst the path of a circle.
        if (fabsf(velocity_delta) > ideal2)
        {
            g.m_view_angles.y = velocity_angle - std::copysignf(ideal2, velocity_delta);
            g.m_cmd->m_sidemove = std::copysignf(450.f, velocity_delta);
        }
        else
        {
            g.m_view_angles.y += std::copysignf(ideal, delta);
            g.m_cmd->m_sidemove = std::copysignf(450.f, delta);
        }
    }

    m_old_yaw = g.m_view_angles.y;
}

class pre_speed_node
{
    float angle;
    vec3_t position, velocity;
    bool calculated = false;
    std::vector<pre_speed_node*> m_child_nodes = {};
    pre_speed_node(float angle, vec3_t pos, vec3_t vel) : angle(angle), position(pos), velocity(vel)
    {
    }
    int recur(int& iter)
    {
    }
};

void movement::DoPrespeed()
{
    if (!settings::misc::movement::pre_speed || !(g.m_cmd->m_buttons & IN_JUMP))
    {
        m_circle_yaw = g.m_view_angles.y;
        return;
    }

    if (g.m_interfaces->entity_list()->get_client_entity_handle(g.m_local->m_ground_entity()))
        return;

    if (isnan(m_circle_yaw))
    {
        m_circle_yaw = 0.f;
    }

    float mod, min, max, step, strafe, time, angle;
    vec3_t plane;
    const auto velocity = g.m_local->velocity();
    const float speed = velocity.length_2d();
    float ideal = (speed > 1.f) ? RAD2DEG(std::asinf(30.f / speed)) : 90.f;

    if (isnan(ideal))
    {
        ideal = 0.f;
    }

    m_mins = g.m_local->mins();
    m_maxs = g.m_local->maxs();

    m_origin = g.m_local->origin();

    // min and max values are based on 128 ticks.
    mod = g.m_interfaces->globals()->m_interval_per_tick * 128.f;

    // scale min and max based on tickrate.
    max = ideal * 2.f;
    min = ideal * 2.f;

    // compute ideal strafe angle for moving in a circle.
    strafe = ideal;

    // calculate time.
    time = 320.f / speed;

    // clamp time.
    time = std::clamp<float>(time, 0.7f, 3.f);

    // init step.
    step = strafe;

    while (true)
    {
        // if we will not collide with an object or we wont accelerate from such a
        // big step anymore then stop.
        if (!WillCollide(time, step, m_circle_yaw) || max < step)
            break;

        // if we will collide with an object with the current strafe step then
        // increment step to prevent a collision.
        step += 0.1f;
    }

    if (step > max)
    {
        // reset step.
        step = strafe;

        while (true)
        {
            // if we will not collide with an object or we wont accelerate from such a
            // big step anymore then stop.
            if (!WillCollide(time, step, m_circle_yaw) || step < 0.f)
                break;

            // if we will collide with an object with the current strafe step
            // decrement step to prevent a collision.
            step -= 0.1f;
        }

        if (step < 0.f)
        {
            step = -min;

            while (true)
            {
                // if we will not collide with an object or we wont accelerate from such
                // a big step anymore then stop.
                if (!WillCollide(time, step, m_circle_yaw) || step > 0.f)
                    break;

                // if we will collide with an object with the current strafe step
                // decrement step to prevent a collision.
                step += 0.1f;
            }

            if (step > 0)
            {
                if (GetClosestPlane(plane))
                {
                    // grab the closest object normal
                    // compute the angle of the normal
                    // and push us away from the object.
                    angle = RAD2DEG(std::atan2(plane.y, plane.x));
                    step = -math::normalize_angle(m_circle_yaw - angle, 180.f) * 0.1f;
                }
            }

            else
                step -= 0.1f;
        }
    }

    else
        step += 0.1f;

    // add the computed step to the steps of the previous circle iterations.
    m_circle_yaw = math::normalize_angle(m_circle_yaw + step, 180.f);

    // apply data to usercmd.
    g.m_view_angles.y = m_circle_yaw;
    g.m_cmd->m_sidemove = (step >= 0.f) ? -450.f : 450.f;
}

inline bool movement::GetClosestPlane(vec3_t& plane)
{
    trace_t trace;
    trace_world_only filter;
    vec3_t start{m_origin};
    float smallest{1.f};
    const float dist{75.f};

    // trace around us in a circle
    for (float step{}; step <= M_PI_2_F; step += (M_PI_F / 10.f))
    {
        // extend endpoint x units.
        vec3_t end = start;
        end.x += std::cos(step) * dist;
        end.y += std::sin(step) * dist;

        g.m_interfaces->trace()->trace_ray(ray_t(start, end, m_mins, m_maxs), CONTENTS_SOLID, &filter, &trace);

        // we found an object closer, then the previouly found object.
        if (trace.flFraction < smallest)
        {
            // save the normal of the object.
            plane = trace.plane.normal;
            smallest = trace.flFraction;
        }
    }

    // did we find any valid object?
    return smallest != 1.f && plane.z < 0.1f;
}

void air_acceletate(vec3_t& wishdir, vec3_t& velocity, const float wishspeed, const float accel)
{
    float wishspd = wishspeed;

    // Cap speed
    if (wishspd > 30.f)
        wishspd = 30.f;

    // Determine veer amount
    const float currentspeed = velocity.dot(wishdir);

    // See how much to add
    const float addspeed = wishspd - currentspeed;

    // If not adding any, done.
    if (addspeed <= 0)
        return;

    // Determine acceleration speed after acceleration
    float accelspeed = accel * wishspeed * g.m_interfaces->globals()->m_interval_per_tick;

    // Cap it
    if (accelspeed > addspeed)
        accelspeed = addspeed;

    // Adjust pmove vel.
    for (int i = 0; i < 2; i++)
    {
        velocity[i] += accelspeed * wishdir[i];
    }
}

class trace_filter_skip_players : public i_trace_filter
{
public:
    trace_filter_skip_players()
    {
    }

    virtual bool ShouldHitEntity(void* pEntityHandle, int contentsMask)
    {
        return (((entity_t*)pEntityHandle)->index() == 0 ||
                ((entity_t*)pEntityHandle)->index() >= g.m_interfaces->globals()->m_max_clients);
    }

    virtual TraceType_t GetTraceType() const
    {
        return TraceType_t::TRACE_EVERYTHING;
    }
};

void try_touch_ground(const vec3_t& start, const vec3_t& end, const vec3_t& mins, const vec3_t& maxs,
                      unsigned int fMask, trace_t& pm)
{
    ray_t ray;
    ray.initialize(start, end, mins, maxs);
    trace_filter_skip_players traceFilter;
    g.m_interfaces->trace()->trace_ray(ray, fMask, &traceFilter, &pm);
}

void movement::try_touch_ground_in_quadrants(const vec3_t& start, const vec3_t& end, unsigned int fMask, trace_t& pm)
{
    vec3_t maxs;
    const vec3_t minsSrc = m_mins;
    const vec3_t maxsSrc = m_maxs;

    const float fraction = pm.flFraction;
    const vec3_t endpos = pm.end;

    // Check the -x, -y quadrant
    vec3_t mins = minsSrc;
    maxs.init(fminf(0, maxsSrc.x), fminf(0, maxsSrc.y), maxsSrc.z);
    try_touch_ground(start, end, mins, maxs, fMask, pm);
    if (pm.entity && pm.plane.normal[2] >= 0.7)
    {
        pm.flFraction = fraction;
        pm.end = endpos;
        return;
    }

    // Check the +x, +y quadrant
    mins.init(fmaxf(0, minsSrc.x), fmaxf(0, minsSrc.y), minsSrc.z);
    maxs = maxsSrc;
    try_touch_ground(start, end, mins, maxs, fMask, pm);
    if (pm.entity && pm.plane.normal[2] >= 0.7)
    {
        pm.flFraction = fraction;
        pm.end = endpos;
        return;
    }

    // Check the -x, +y quadrant
    mins.init(minsSrc.x, fmaxf(0, minsSrc.y), minsSrc.z);
    maxs.init(fminf(0, maxsSrc.x), maxsSrc.y, maxsSrc.z);
    try_touch_ground(start, end, mins, maxs, fMask, pm);
    if (pm.entity && pm.plane.normal[2] >= 0.7)
    {
        pm.flFraction = fraction;
        pm.end = endpos;
        return;
    }

    // Check the +x, -y quadrant
    mins.init(fmaxf(0, minsSrc.x), minsSrc.y, minsSrc.z);
    maxs.init(maxsSrc.x, fminf(0, maxsSrc.y), maxsSrc.z);
    try_touch_ground(start, end, mins, maxs, fMask, pm);
    if (pm.entity && pm.plane.normal[2] >= 0.7)
    {
        pm.flFraction = fraction;
        pm.end = endpos;
        return;
    }

    pm.flFraction = fraction;
    pm.end = endpos;
}
// bool TryPlayerMove(vec3_t* pFirstDest, trace_t* pFirstTrace, vec3_t velocity, vec3_t origin) {
//   int bumpcount, numbumps;
//   vec3_t dir;
//   float d;
//   int numplanes;
//   vec3_t planes[5];
//   vec3_t primal_velocity, original_velocity;
//   vec3_t new_velocity;
//   int i, j;
//   trace_t pm;
//   vec3_t end;
//   float time_left, allFraction;
//   int blocked;
//
//   numbumps = 4;  // Bump up to four times
//
//   blocked = 0;    // Assume not blocked
//   numplanes = 0;  //  and not sliding along any planes
//
//   original_velocity = velocity;  // Store original velocity
//   primal_velocity = velocity;
//
//   allFraction = 0;
//   time_left = g.m_interfaces->globals()->m_interval_per_tick;  // Total time for this movement operation.
//
//   new_velocity.init(0,0,0);
//
//   for (bumpcount = 0; bumpcount < numbumps; bumpcount++) {
//     if (velocity.length() == 0.0) break;
//
//     // Assume we can move all the way from the current origin to the
//     //  end point.
//     origin, time_left, mv->m_vecVelocity, end);
//
//     // See if we can make it from origin to end point.
//
//     TracePlayerBBox(mv->GetAbsOrigin(), end, PlayerSolidMask(),
//                     COLLISION_GROUP_PLAYER_MOVEMENT, pm);
//
//     if (pm.fraction > 0 && pm.fraction < MINIMUM_MOVE_FRACTION) {
//       // HACK: extremely tiny move fractions cause problems in later
//       // computations that determine values using portions of distance moved.
//       pm.fraction = 0;
//     }
//
//     allFraction += pm.fraction;
//
//     // If we started in a solid object, or we were in solid space
//     //  the whole way, zero out our velocity and return that we
//     //  are blocked by floor and wall.
//     if (pm.allsolid) {
//       // entity is trapped in another solid
//       VectorCopy(vec3_origin, mv->m_vecVelocity);
//       return 4;
//     }
//
//     // If we moved some portion of the total distance, then
//     //  copy the end position into the pmove.origin and
//     //  zero the plane counter.
//     if (pm.fraction > 0) {
//       if (numbumps > 0 && pm.fraction == 1) {
//         // There's a precision issue with terrain tracing that can cause a swept
//         // box to successfully trace when the end position is stuck in the
//         // triangle.  Re-run the test with an uswept box to catch that case
//         // until the bug is fixed. If we detect getting stuck, don't allow the
//         // movement
//         trace_t stuck;
//         TracePlayerBBox(pm.endpos, pm.endpos, PlayerSolidMask(),
//                         COLLISION_GROUP_PLAYER_MOVEMENT, stuck);
//         if (stuck.startsolid || stuck.fraction != 1.0f) {
//           // Msg( "Player will become stuck!!!\n" );
//           VectorCopy(vec3_origin, mv->m_vecVelocity);
//           break;
//         }
//       }
//
// #if defined(PLAYER_GETTING_STUCK_TESTING)
//       trace_t foo;
//       TracePlayerBBox(pm.endpos, pm.endpos, PlayerSolidMask(),
//                       COLLISION_GROUP_PLAYER_MOVEMENT, foo);
//       if (foo.startsolid || foo.fraction != 1.0f) {
//         Msg("Player will become stuck!!!\n");
//       }
// #endif
//       // actually covered some distance
//       mv->SetAbsOrigin(pm.endpos);
//       VectorCopy(mv->m_vecVelocity, original_velocity);
//       numplanes = 0;
//     }
//
//     // If we covered the entire distance, we are done
//     //  and can return.
//     if (pm.fraction == 1) {
//       break;  // moved the entire distance
//     }
//
//     // Save entity that blocked us (since fraction was < 1.0)
//     //  for contact
//     // Add it if it's not already in the list!!!
//     MoveHelper()->AddToTouched(pm, mv->m_vecVelocity);
//
//     // If the plane we hit has a high z component in the normal, then
//     //  it's probably a floor
//     if (pm.plane.normal[2] > 0.7) {
//       blocked |= 1;  // floor
//     }
//     // If the plane has a zero z component in the normal, then it's a
//     //  step or wall
//     if (abs(pm.plane.normal[2]) < EFFECTIVELY_HORIZONTAL_NORMAL_Z) {
//       pm.plane.normal[2] = 0;
//       blocked |= 2;  // step / wall
//     }
//
//     // Reduce amount of m_flFrameTime left by total time left * fraction
//     //  that we covered.
//     time_left -= time_left * pm.fraction;
//
//     // Did we run out of planes to clip against?
//     if (numplanes >= MAX_CLIP_PLANES) {
//       // this shouldn't really happen
//       //  Stop our movement if so.
//       VectorCopy(vec3_origin, mv->m_vecVelocity);
//       // Con_DPrintf("Too many planes 4\n");
//
//       break;
//     }
//
//     // Set up next clipping plane
//     VectorCopy(pm.plane.normal, planes[numplanes]);
//     numplanes++;
//
//     // modify original_velocity so it parallels all of the clip planes
//     //
//
//     // reflect player velocity
//     // Only give this a try for first impact plane because you can get yourself
//     // stuck in an acute corner by jumping in place
//     //  and pressing forward and nobody was really using this bounce/reflection
//     //  feature anyway...
//     if (numplanes == 1 && player->GetMoveType() == MOVETYPE_WALK &&
//         player->GetGroundEntity() == NULL) {
//       for (i = 0; i < numplanes; i++) {
//         if (planes[i][2] > 0.7) {
//           // floor or slope
//           ClipVelocity(original_velocity, planes[i], new_velocity, 1);
//           VectorCopy(new_velocity, original_velocity);
//         } else {
//           ClipVelocity(
//               original_velocity, planes[i], new_velocity,
//               1.0 + sv_bounce.GetFloat() * (1 - player->m_surfaceFriction));
//         }
//       }
//
//       VectorCopy(new_velocity, mv->m_vecVelocity);
//       VectorCopy(new_velocity, original_velocity);
//     } else {
//       for (i = 0; i < numplanes; i++) {
//         ClipVelocity(original_velocity, planes[i], mv->m_vecVelocity, 1);
//
//         for (j = 0; j < numplanes; j++) {
//           if (j != i) {
//             // Are we now moving against this plane?
//             if (mv->m_vecVelocity.Dot(planes[j]) < 0) break;  // not ok
//           }
//         }
//
//         if (j == numplanes)  // Didn't have to clip, so we're ok
//           break;
//       }
//
//       // Did we go all the way through plane set
//       if (i != numplanes) {  // go along this plane
//         // pmove.velocity is set in clipping call, no need to set again.
//         ;
//       } else {  // go along the crease
//         if (numplanes != 2) {
//           VectorCopy(vec3_origin, mv->m_vecVelocity);
//           break;
//         }
//         CrossProduct(planes[0], planes[1], dir);
//         dir.NormalizeInPlace();
//         d = dir.Dot(mv->m_vecVelocity);
//         VectorScale(dir, d, mv->m_vecVelocity);
//       }
//
//       //
//       // if original velocity is against the original velocity, stop dead
//       // to avoid tiny occilations in sloping corners
//       //
//       d = mv->m_vecVelocity.Dot(primal_velocity);
//       if (d <= 0) {
//         // Con_DPrintf("Back\n");
//         VectorCopy(vec3_origin, mv->m_vecVelocity);
//         break;
//       }
//     }
//   }
//
//   if (allFraction == 0) {
//     VectorCopy(vec3_origin, mv->m_vecVelocity);
//   }
//
//   // Check if they slammed into a wall
//   float fSlamVol = 0.0f;
//
//   float fLateralStoppingAmount =
//       primal_velocity.Length2D() - mv->m_vecVelocity.Length2D();
//   if (fLateralStoppingAmount > PLAYER_MAX_SAFE_FALL_SPEED * 2.0f) {
//     fSlamVol = 1.0f;
//   } else if (fLateralStoppingAmount > PLAYER_MAX_SAFE_FALL_SPEED) {
//     fSlamVol = 0.85f;
//   }
//
//   if (fSlamVol > 0.0f) {
//     PlayerRoughLandingEffects(fSlamVol);
//   }
//
//   return blocked;
// }
inline bool movement::WillCollide(float time, float change, float start)
{
    struct PredictionData_t
    {
        vec3_t start;
        vec3_t end;
        vec3_t velocity;
        float direction;
        bool ground;
        float predicted;
    };

    PredictionData_t data;
    trace_t trace;
    trace_filter_skip_players filter;
    static auto sv_staminajumpcost = g.m_interfaces->console()->get_convar("sv_staminajumpcost");
    static auto sv_staminalandcost = g.m_interfaces->console()->get_convar("sv_staminalandcost");
    static auto sv_staminarecoveryrate = g.m_interfaces->console()->get_convar("sv_staminarecoveryrate");
    static auto sv_staminamax = g.m_interfaces->console()->get_convar("sv_staminamax");

    float stamina = g.m_local->stamina();
    bool hit_ground = false;
    // set base data.
    data.ground = g.m_local->flags() & fl_onground;
    data.start = m_origin;
    data.end = m_origin;
    data.velocity = g.m_local->velocity();
    data.direction = start;

    for (data.predicted = 0.f; data.predicted < time; data.predicted += g.m_interfaces->globals()->m_interval_per_tick)
    {
        // predict movement direction by adding the direction change.
        // make sure to normalize it, in case we go over the -180/180 turning point.
        data.direction = math::normalize_angle(data.direction + change, 180.f);

        vec3_t forward, right, up;
        ang_t(0, data.direction, 0).vectors(&forward, &right, &up); // Determine movement angles

        // Zero out z components of movement vectors
        forward[2] = 0;
        right[2] = 0;
        forward.normalize(); // Normalize remainder of vectors
        right.normalize();   //

        vec3_t wishvel, wishdir;
        for (int i = 0; i < 2; i++) // Determine x and y parts of velocity
            wishvel[i] = right[i] * (change * -450.f);
        wishvel[2] = 0; // Zero out z part of velocity

        wishdir = wishvel; // Determine maginitude of speed of move
        float wishspeed = wishdir.normalize();

        // vector wishdir = wishvel;   // Determine maginitude of speed of move
        // float wishspeed = wishdir.normalize_in_place( );

        static auto sv_accelerate = g.m_interfaces->console()->get_convar("sv_airaccelerate");
        air_acceletate(wishdir, data.velocity, wishspeed, sv_accelerate->GetFloat());

        // assume we bhop, set upwards impulse.
        static auto sv_jump_impulse = g.m_interfaces->console()->get_convar("sv_jump_impulse");
        static auto sv_gravity = g.m_interfaces->console()->get_convar("sv_gravity");
        if (data.ground)
        {
            stamina = std::clamp<float>(stamina + sv_staminalandcost->GetFloat() * data.velocity.z, 0.0f,
                                        sv_staminamax->GetFloat());
            stamina = std::clamp<float>(stamina + sv_staminajumpcost->GetFloat() * sv_jump_impulse->GetFloat(), 0.0f,
                                        sv_staminamax->GetFloat());
            data.velocity.z = sv_jump_impulse->GetFloat();
        }

        else
            data.velocity.z -= sv_gravity->GetFloat() * g.m_interfaces->globals()->m_interval_per_tick * 0.5f;
        stamina -= g.m_interfaces->globals()->m_interval_per_tick * sv_staminarecoveryrate->GetFloat();
        // we adjusted the velocity for our new direction.
        // see if we can move in this direction, predict our new origin if we were
        // to travel at this velocity.
        data.end += (data.velocity * g.m_interfaces->globals()->m_interval_per_tick);

        // trace
        g.m_interfaces->trace()->trace_ray(ray_t(data.start, data.end, m_mins, m_maxs), MASK_PLAYERSOLID, &filter,
                                           &trace);

        // check if we hit any objects.
        if (trace.flFraction != 1.f && trace.plane.normal.z <= 0.9f && trace.plane.normal.z > -.9f)
            return true;
        if (trace.startSolid || trace.allsolid)
            return true;

        // adjust start and end point.
        data.start = data.end = trace.end;

        try_touch_ground(data.start, data.end - vec3_t{0.f, 0.f, 2.f}, m_mins, m_maxs, MASK_PLAYERSOLID, trace);
        if (trace.plane.normal[2] < 0.7f)
        {
            // Test four sub-boxes, to see if any of them would have found shallower
            // slope we could actually stand on
            try_touch_ground_in_quadrants(data.start, data.end - vec3_t{0.f, 0.f, 2.f}, MASK_PLAYERSOLID, trace);

            if (trace.entity == nullptr || trace.plane.normal[2] < 0.7f)
            {
                data.ground = false;
            }
            else
            {
                data.ground = trace.entity != nullptr;
            }
        }
        else
        {
            data.ground = trace.entity != nullptr;
        }

        if (data.ground)
            hit_ground = true;
        else
            data.velocity.z -= sv_gravity->GetFloat() * g.m_interfaces->globals()->m_interval_per_tick * 0.5f;
    }

    // the entire loop has ran
    // we did not hit shit.
    return !hit_ground;
}

```

`solace-csgo/movement.h`:

```h
#pragma once
#include "global_vars.h"
#include "math_funcs.h"
#include "vec3.h"

class movement {
	bool m_force_strafe = false;
	bool m_should_stop = false;
	bool m_should_unpeek = false;
	float m_circle_yaw = 0.f;
	vec3_t m_origin;
	vec3_t m_mins;
	vec3_t m_maxs;
    float m_direction = 1;

public:
	void set_should_stop( bool state ) { m_should_stop = state; };
	void set_force_strafe( bool state ) { m_force_strafe = state; };
	void set_should_unpeek( bool state ) { m_should_unpeek = state; };
	void draw ( );
	void bhop ( );
	void QuickStop ( );
	static void PreciseMove ( );
	void auto_peek ( );
	void move_to ( vec3_t target_origin ) const;
	void edge_bug();
	void auto_strafe( );
	float m_old_yaw;
	int m_switch = 1;
	bool m_invert;
	vec3_t m_stop_pos;
	float m_time_left;
	

    bool check_rotations(float start_yaw, vec3_t origin, vec3_t velocity, float& end_speed, float stamina, int iter);

    void DoPrespeed();

	bool try_player_move( vec3_t& velocity, vec3_t& position, bool on_ground );
	bool GetClosestPlane( vec3_t& plane );
    void try_touch_ground_in_quadrants(const vec3_t& start, const vec3_t& end, unsigned int fMask, trace_t& pm);
    bool WillCollide(float time, float change, float start);
} inline g_movement;


```

`solace-csgo/netvar_manager.cpp`:

```cpp
#include "netvar_manager.h"
#include "includes.h"

float get_new( float old, float new_, float tol ) {
	const float delta = new_ - old;
	if ( fabsf( delta ) <= tol )
		return old;
	return new_;
}

void shared_netvar::post_update ( player_t *player ) {
	m_value = *reinterpret_cast< float* >( player + m_offset );
	*reinterpret_cast< float* >( player + m_offset ) = get_new( m_old_value, m_value, m_tolerance );
}

void shared_netvar::pre_update( player_t *player ) {
	m_old_value = *reinterpret_cast< float * >( player + m_offset );
}

void managed_vec::pre_update ( player_t *player ) {
	m_old_value = *reinterpret_cast< vec3_t * >(player + m_offset);
}

void managed_vec::post_update( player_t *player ) {
	m_value = *reinterpret_cast< vec3_t * >( player + m_offset );

	*reinterpret_cast< float* >( player + m_offset ) = get_new( m_old_value.x, m_value.x, m_tolerance );
	*reinterpret_cast< float* >( player + m_offset + 0x4 ) = get_new( m_old_value.y, m_value.y, m_tolerance );
	*reinterpret_cast< float* >( player + m_offset + 0x8 ) = get_new( m_old_value.z, m_value.z, m_tolerance );
}

void prediction_netvar_manager::pre_update( player_t *player ) {
    called_once = true;
	for ( auto *var : vars )
		var->pre_update( player );
}

void prediction_netvar_manager::post_update( player_t *player ) {
    if (!called_once)
        return;
	for ( auto *var : vars )
		var->post_update( player );
}
#define	EQUAL_EPSILON	0.001 
inline bool CloseEnough( float a, float b, float epsilon = EQUAL_EPSILON ) {
	return fabs( a - b ) <= epsilon;
}
float AssignRangeMultiplier( int nBits, double range ) {
	unsigned long iHighValue;
	if ( nBits == 32 )
		iHighValue = 0xFFFFFFFE;
	else
		iHighValue = ( ( 1 << ( unsigned long )nBits ) - 1 );

	float fHighLowMul = iHighValue / range;
	if ( CloseEnough( range, 0 ) )
		fHighLowMul = iHighValue;

	// If the precision is messing us up, then adjust it so it won't.
	if ( ( unsigned long )( fHighLowMul * range ) > iHighValue ||
		( fHighLowMul * range ) > ( double )iHighValue ) {
		// Squeeze it down smaller and smaller until it's going to produce an integer
		// in the valid range when given the highest value.
		float multipliers[ ] = { 0.9999f, 0.99f, 0.9f, 0.8f, 0.7f };
		int i;
		for ( i = 0; i < ARRAYSIZE( multipliers ); i++ ) {
			fHighLowMul = ( float )( iHighValue / range ) * multipliers[ i ];
			if ( ( unsigned long )( fHighLowMul * range ) > iHighValue ||
				( fHighLowMul * range ) > ( double )iHighValue ) {
			}
			else {
				break;
			}
		}

		if ( i == ARRAYSIZE( multipliers ) ) {
			// Doh! We seem to be unable to represent this range.
			return 0;
		}
	}

	return fHighLowMul;
}

void prediction_netvar_manager::init ( datamap_t *map ) {
    if (initalized)
        return;
    initalized = true;
	float val = ( 1.f / AssignRangeMultiplier( 17, 4096.f - ( -4096.f ) ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_fall_velocity, val, "m_flFallVelocity" ) );
	val = ( 1.f / AssignRangeMultiplier( 16, 128.f ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_step_size, val, "m_flStepSize" ) );
	val = ( 1.f / AssignRangeMultiplier( 12, 2048.0f ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_max_speed, val, "max_speed" ) );
	val = ( 1.f / AssignRangeMultiplier( 14, 100.f ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_stamina, val, "stamina" ) );
	val = ( 1.f / AssignRangeMultiplier( 8.f, 1.f ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.velocity_modifier, val, "velocity_modifier" ) );
	val = ( 1.f / AssignRangeMultiplier( 8, 32.0f - ( -32.0f ) ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_view_offset, val, "view_offset_x" ) );
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_view_offset + 0x4, val, "view_offset_y" ) );
	val = ( 1.f / AssignRangeMultiplier( 10, 128.f ));
	vars.push_back( new shared_netvar( g.m_offsets->m_player.m_view_offset + 0x8, val, "view_offset_z" ) );
	//val = ( 1.f / AssignRangeMultiplier( 8, 1. ) );
	//vars.push_back( new shared_netvar( g.m_offsets->m_player.velocity_modifier, val, "m_velocityModifier" ) );
	val = ( 1.f / AssignRangeMultiplier( 20, 2000. ) );
	vars.push_back( new managed_vec( g.m_offsets->m_player.m_vecBaseVelocity, val, "m_vecBaseVelocity" ) );

	//vars.push_back( new managed_vec( g.m_offsets->m_player.m_network_origin, 0.031250, "network_origin", true ) );
	vars.push_back( new managed_vec( g.m_offsets->m_player.m_velocity, 0.031250, "m_velocity", true ) );

	vars.push_back( new managed_vec( g.m_offsets->m_player.m_punch_angle, 0.031250, "m_viewPunchAngle", true ) );
	vars.push_back( new managed_vec( g.m_offsets->m_player.m_aim_punch_angle, 0.031250, "m_aimPunchAngle", true) );
	vars.push_back( new managed_vec( g.m_offsets->m_player.m_aim_punch_angle_vel, 0.031250, "m_aimPunchAngleVel", true) );
	//var = map->find_var( "m_nDuckTimeMsecs" );
	//vars.push_back( new shared_netvar( g.m_offsets->m_player.m_nDuckTimeMsecs, var->m_tolerance, "m_nDuckTimeMsecs" ) );
	//var = map->find_var( "m_nDuckJumpTimeMsecs" );
	//vars.push_back( new shared_netvar( g.m_offsets->m_player.m_nDuckJumpTimeMsecs, var->m_tolerance, "m_nDuckJumpTimeMsecs" ) );
	//var = map->find_var( "m_nJumpTimeMsecs" );
	//vars.push_back( new shared_netvar( g.m_offsets->m_player.m_nJumpTimeMsecs, var->m_tolerance, "m_nJumpTimeMsecs" ) );
}

```

`solace-csgo/netvar_manager.h`:

```h
#pragma once
#include <deque>

#include "vec3.h"
#include "Windows.h"

class datamap_t;
class player_t;

class managed_netvar {
public:
	uintptr_t m_offset = 0;
	virtual void pre_update( player_t *player ) = 0;
	virtual void post_update( player_t *player ) = 0;
};
class shared_netvar : public managed_netvar {
public:
	float m_value;
	float m_old_value;
	float m_tolerance;
	char *m_name;
	shared_netvar(uintptr_t offset, float tolerance, const char * name) : m_tolerance(tolerance) {
		m_offset = offset;
		m_name = _strdup(name);
	}

	void pre_update( player_t *player ) override;
	void post_update( player_t *player ) override;
};
class managed_vec : public managed_netvar {
public:
	vec3_t m_value;
	vec3_t m_old_value;
	float m_tolerance = 0;
	char *m_name;
	bool m_coord;
	managed_vec( uintptr_t offset, float tolerance, const char *name, bool coord = false ) : m_tolerance( tolerance ), m_coord(coord) {
		m_offset = offset;
		m_name = _strdup( name );
	}

	void pre_update( player_t *player ) override;
	void post_update( player_t *player ) override;
};

class prediction_netvar_manager {
public:
    bool initalized = false;
	bool setup_vars = false;
	std::vector<managed_netvar*> vars;
	std::vector<managed_netvar*> weapon_vars;
    bool called_once = false;
    void reset()
    {
        called_once = false;
	}
	void pre_update( player_t * );
	void post_update( player_t * );
	void init ( datamap_t * map );
} inline g_pred_manager;


```

`solace-csgo/netvars.cpp`:

```cpp
#include "netvars.h"
#include <unordered_map>
#include <map>
#include "sdk.h"

namespace netvar_manager {
	struct netvar_data_t {
		bool        m_datamap_var; // we can't do proxies on stuff from datamaps :).
		recv_prop_t *m_prop_ptr;
		size_t      m_offset;
		int	        m_prop;

		__forceinline netvar_data_t() : m_datamap_var{}, m_prop_ptr{}, m_offset{}, m_prop{}{ }
	};
	using netvar_key_value_map = std::unordered_map< uint32_t, netvar_data_t >;
	using netvar_table_map = std::unordered_map< uint32_t, netvar_key_value_map >;
	void initialize_props( netvar_table_map &table_map );
	void add_props_for_table( netvar_table_map &table_map, const uint32_t table_name_hash, const std::string &table_name, recv_table_t *table, const bool dump_vars, const size_t child_offset = 0 ) {
		
		for ( auto i = 0; i < table->m_prop_count; ++i ) {
			auto &prop = table->m_props[ i ];
			if ( prop.m_data_table && prop.m_elements > 0 ) {
				if ( std::string( prop.m_var_name ).substr( 0, 1 ) == std::string( "0" ) )
					continue;
				
				add_props_for_table( table_map, table_name_hash, table_name, prop.m_data_table, dump_vars, prop.m_offset + child_offset );
			}

			auto name = std::string( prop.m_var_name );

			if ( name.substr( 0, 1 ) != "m" /*&& name.substr( 0, 1 ) != "b"*/ )
				continue;

			const auto name_hash = fnv::hash( prop.m_var_name );
			const auto offset = uintptr_t( prop.m_offset ) + child_offset;

			table_map[ table_name_hash ][ name_hash ].m_datamap_var = false;
			table_map[ table_name_hash ][ name_hash ].m_offset = offset;
			table_map[ table_name_hash ][ name_hash ].m_prop_ptr = &prop;
			table_map[ table_name_hash ][name_hash].m_prop = i;
		}
	}

	netvar_table_map map = {};
	uintptr_t get_net_var( const uint32_t table,
						   const uint32_t prop ) {
		if ( map.empty( ) )
			initialize_props( map );

		auto &table_map = map.at( table );
		if ( table_map.find( prop ) == table_map.end( ) )
			return 0;

		if ( map.find( table ) == map.end( ) )
			return 0;

		return table_map.at( prop ).m_offset;
	}

	void set_proxy( uint32_t table, uint32_t prop, void *proxy, recv_var_proxy_fn &original ) {
		auto netvar_entry = map[table][prop];

		// we can't set a proxy on a datamap.
		if ( netvar_entry.m_datamap_var )
			return;

		// save original.
		original = netvar_entry.m_prop_ptr->m_proxy_fn;

		// redirect.
		netvar_entry.m_prop_ptr->m_proxy_fn = static_cast< recv_var_proxy_fn >(proxy);
	}

	void StoreDataMap( address ptr, netvar_table_map &var_map );
	// iterate client module and find all datamaps.
	void FindAndStoreDataMaps( netvar_table_map &map ) {
		auto matches = util::FindAll( "client.dll", "C7 05 ? ? ? ? ? ? ? ? C7 05 ? ? ? ? ? ? ? ? C3 CC" );
		if ( matches.empty( ) )
			return;
	
		for ( auto &m : matches )
			StoreDataMap( m, map );
	}
	void StoreDataMap( address ptr, netvar_table_map &var_map ) {
		// get datamap and verify.
		auto *const map = ptr.at( 2 ).sub( 4 ).as< datamap_t * >( );
	
		if ( !map || !map->m_num_fields || map->m_num_fields > 200 || !map->m_desc || !map->m_name )
			return;
	
		// hash table name.
		const auto base = fnv::hash( map->m_name );
	
		for ( int i{}; i < map->m_num_fields; ++i ) {
			auto entry = &map->m_desc[i];
			if ( !entry->m_name )
				continue;
	
			// hash var name.
			auto var = fnv::hash( entry->m_name );
	
			// if we dont have this var stored yet.
			if ( !var_map[ base ][ var ].m_offset ) {
				var_map[ base ][ var ].m_datamap_var = true;
				var_map[ base ][ var ].m_offset = static_cast< size_t >(entry->fieldOffset);
				var_map[ base ][ var ].m_prop_ptr = nullptr;
			}
		}
	}
	
	void initialize_props( netvar_table_map &table_map ) {
		const auto dump_vars = true;  //true if netvar dump

		netvar_table_map var_dump;
		for ( auto *client_class = g.m_interfaces->client( )->get_all_classes( );
			  client_class;
			  client_class = client_class->m_pNext ) {
			auto *const table = client_class->m_pRecvTable;
			auto *const table_name = table->m_net_table_name;
			const auto table_name_hash = fnv::hash( table_name );

			if ( table == nullptr )
				continue;

			add_props_for_table( table_map, table_name_hash, table_name, table, dump_vars );
		}
		FindAndStoreDataMaps( table_map );
	}
}

```

`solace-csgo/netvars.h`:

```h

#include <cstdint>

class c_recv_proxy_data;
typedef void( *recv_var_proxy_fn )( const c_recv_proxy_data *pData, void *pStruct, void *pOut );

namespace netvar_manager { // ripped this from designer, same method everyone uses
	uintptr_t get_net_var( const uint32_t table,
						   const uint32_t prop );
	void set_proxy( uint32_t table, uint32_t prop, void *proxy, recv_var_proxy_fn &original );
};

// more macro abuse.. if only resharper could convert macro calls to code
#define NETVAR( table, prop, name ) uintptr_t name = netvar_manager::get_net_var( fnv::hash( table ), fnv::hash( prop ) );
#define OFFSET( type, var, offset ) type& var() { \
    return *reinterpret_cast< type* >( uintptr_t( this ) + (offset) ); \
}
#define OFFSETPTR( type, var, offset ) type* var() { \
    return reinterpret_cast< type* >( uintptr_t( this ) + (offset) ); \
}
```

`solace-csgo/notification.cpp`:

```cpp
#include "notification.h"
#include "includes.h"

void notification::add ( const std::string text, color _color, float time, bool console ) {
	// modelled after 'CConPanel::AddToNotify'
	m_notify_text.emplace_back( text, _color, g.m_interfaces->globals( )->m_curtime + time );

	va_list list;
	std::string buf;

	if ( text.empty( ) )
		return;

	va_start( list, text );

	// count needed size.
	const int size = std::vsnprintf( 0, 0, text.c_str( ), list );

	// allocate.
	buf.resize( size );

	// print to buffer.
	std::vsnprintf( buf.data( ), size + 1, text.c_str( ), list );

	va_end( list );

	// print to console.
	g.m_interfaces->console( )->console_color_printf( color( 0xDB, 0x2E, 0x2C, 20 ), "[solace] " );
	g.m_interfaces->console( )->console_color_printf( color( 255, 255, 255 ), buf.c_str( ) );
}

void notification::think ( ) {
	auto x{8}, y{5};
	const auto size{g.m_render->get_text_height( "A", g.m_render->m_courier_new_13( ) ) + 1};

	// update lifetimes.
	for ( size_t i{}; i < m_notify_text.size( ); ++i ) {
		const auto &notify = m_notify_text[i];
		const auto delta_time = notify.m_time - g.m_interfaces->globals( )->m_curtime;

		if ( delta_time <= 0.f ) {
			m_notify_text.erase( m_notify_text.begin( ) + i );
			i--;
		}
	}

	// we have nothing to draw.
	if ( m_notify_text.empty( ) )
		return;

	// iterate entries.
	for ( size_t i{}; i < m_notify_text.size( ); ++i ) {
		const auto &notify = m_notify_text[i];

		const auto left = notify.m_time - g.m_interfaces->globals( )->m_curtime;
		auto color = notify.m_color;

		if ( left < .5f ) {
			auto f = left;
			f = std::clamp( f, 0.f, .5f );

			f /= .5f;

			color.set_a( static_cast< int >(f * 255.f) );

			if ( i == 0 && f < 0.2f )
				y -= size * int(1.f - f / 0.2f);
		}

		else
			color.set_a( 255 );

		g.m_render->text( g.m_render->m_courier_new_13( ), x, y, color, notify.m_text.c_str( ) );
		y += size;
	}
}

```

`solace-csgo/notification.h`:

```h
#pragma once


#include <memory>
#include <string>

#include "render.h"

class notification {
	class NotifyText {
	public:
		std::string m_text;
		color		m_color;
		float		m_time;

	public:
		__forceinline NotifyText( const std::string &text, color color, float time ) : m_text{ text }, m_color{ color }, m_time{ time } {}
	};

	private:
		std::vector< NotifyText > m_notify_text;

	public:
		__forceinline notification( ) : m_notify_text{} { }

	void add ( const std::string text, color _color = color( 255, 255, 255, 255 ), float time = 8.f,
	                         bool console = true );

		// modelled after 'CConPanel::DrawNotify' and 'CConPanel::ShouldDraw'
	void think ( );
} inline g_notification;


```

`solace-csgo/offsets.h`:

```h
#pragma once
#include "netvars.h"
#include "datamap.h"

class offsets_t {
public:
	void load_buffer( char* offset_buffer ) { }

	explicit offsets_t( char* offset_buffer = nullptr ) {
	#ifdef _DEBUG || 1
		// temporarily getting offsets dynamically
		// still use this when debugging -- e
	#else
		if ( offset_buffer )
			load_buffer( offset_buffer );
	#endif
	}

	struct {

	} m_sigs;


	struct {

	} m_entity;
	struct {
        uint32_t m_last_bone_setup_time = *(uint32_t*)(util::find("client.dll", "80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81") + 0x11);
		NETVAR( "DT_CSPlayer", "m_flSimulationTime", m_simulation_time )
		NETVAR( "DT_BasePlayer", "m_vecViewOffset[0]", m_view_offset )
		NETVAR( "DT_CSPlayer", "m_iTeamNum", m_team )
		NETVAR( "DT_BaseEntity", "m_bSpotted", m_spotted )
		NETVAR( "DT_BasePlayer", "m_nSurvivalTeam", m_survival_team )
		NETVAR( "DT_BasePlayer", "m_flHealthShotBoostExpirationTime", m_health_boost_time )
		NETVAR( "DT_CSPlayer", "m_vecOrigin", m_origin )
		NETVAR( "DT_BasePlayer", "m_hViewModel[0]", m_view_model )
		NETVAR( "DT_CSPlayer", "m_bHasDefuser", m_defuser )
		NETVAR( "DT_CSPlayer", "m_bGunGameImmunity", m_gun_game_immunity )
		NETVAR( "DT_CSPlayer", "m_iShotsFired", m_shots_fired )
		NETVAR( "DT_CSPlayer", "m_angEyeAngles", m_eye_angles )
		NETVAR( "DT_CSPlayer", "m_ArmorValue", m_armor )
		NETVAR( "DT_CSPlayer", "m_bHasHelmet", m_has_helmet )
		NETVAR( "DT_CSPlayer", "m_bIsScoped", m_is_scoped )
		NETVAR( "DT_CSPlayer", "m_bIsDefusing", m_defusing )
		NETVAR( "DT_CSPlayer", "m_iAccount", m_money )
		NETVAR( "DT_CSPlayer", "m_flLowerBodyYawTarget", m_lower_body_yaw )
		NETVAR( "DT_CSPlayer", "m_flVelocityModifier", velocity_modifier )
		NETVAR( "DT_CSPlayer", "m_flNextAttack", m_next_attack )
		NETVAR( "DT_CSPlayer", "m_flFlashDuration", m_flash_duration )
		NETVAR( "DT_CSPlayer", "m_flFlashMaxAlpha", m_flash_alpha )
		NETVAR( "DT_CSPlayer", "m_bHasNightVision", m_has_night_vision )
		NETVAR( "DT_CSPlayer", "m_bNightVisionOn", m_night_vision_enabled )
		NETVAR( "DT_CSPlayer", "m_iHealth", m_health )
		NETVAR( "C_BasePlayer", "m_lifeState", m_life_state )
		NETVAR( "DT_CSPlayer", "m_fFlags", m_flags )
		NETVAR( "DT_BasePlayer", "m_viewPunchAngle", m_punch_angle )

		NETVAR( "C_BaseEntity", "m_vecNetworkOrigin", m_network_origin )

		NETVAR( "DT_BaseEntity", "m_vecMins", m_mins )
		NETVAR( "DT_BaseEntity", "m_vecMaxs", m_maxs )
		NETVAR( "DT_BasePlayer", "m_aimPunchAngle", m_aim_punch_angle )
		NETVAR( "DT_BasePlayer", "m_vecBaseVelocity", m_vecBaseVelocity )
		NETVAR( "DT_BasePlayer", "m_aimPunchAngleVel", m_aim_punch_angle_vel )
		NETVAR( "DT_CSPlayer", "m_flFallVelocity", m_fall_velocity )
		NETVAR( "DT_CSPlayer", "m_flStepSize", m_step_size )
		NETVAR( "DT_CSPlayer", "m_nDuckTimeMsecs", m_nDuckTimeMsecs )
		NETVAR( "DT_CSPlayer", "m_nDuckJumpTimeMsecs", m_nDuckJumpTimeMsecs )
		NETVAR( "DT_CSPlayer", "m_nJumpTimeMsecs", m_nJumpTimeMsecs )
		NETVAR( "DT_BasePlayer", "m_vecVelocity[0]", m_velocity )
		NETVAR( "C_BasePlayer", "m_flMaxspeed", m_max_speed )
		NETVAR( "DT_CSPlayer", "m_flStamina ", m_stamina )
		NETVAR( "DT_BaseEntity", "m_flShadowCastDistance", m_fov_time )
		NETVAR( "DT_BasePlayer", "m_hObserverTarget", m_observer_target )
		NETVAR( "DT_BasePlayer", "m_nHitboxSet", m_hitbox_set )
		NETVAR( "C_BasePlayer", "m_hGroundEntity", m_ground_ent )
		NETVAR("DT_CSPlayer", "m_flDuckAmount", m_duck_amount)
		NETVAR("DT_CSPlayer", "m_flDuckSpeed", m_duck_speed)
		NETVAR( "DT_CSPlayer", "m_bDucking", m_ducking )
		NETVAR( "DT_CSPlayer", "m_bHasHeavyArmor", m_heavy_armor )
		NETVAR( "DT_SmokeGrenadeProjectile", "m_nSmokeEffectTickBegin", m_smoke_grenade_tick_begin )
		NETVAR( "C_BasePlayer", "m_nTickBase", m_tick_base )
		NETVAR( "DT_BaseEntity", "m_hOwnerEntity", m_hOwnerEntity )
		NETVAR( "DT_CSPlayer", "m_flPoseParameter", m_pose_parameters )
		NETVAR( "DT_CSPlayer", "m_flEncodedController", m_encoded_controller )
		NETVAR( "DT_CSPlayer", "m_bKilledByTaser", m_killed_by_taser )
		NETVAR( "DT_CSPlayer", "m_hActiveWeapon", m_active_weapon )
		NETVAR("DT_Inferno", "m_bFireIsBurning", m_fire_burning)
		NETVAR("DT_Inferno", "m_fireXDelta", m_fire_x)
		NETVAR("DT_Inferno", "m_fireYDelta", m_fire_y)
		NETVAR("DT_Inferno", "m_fireZDelta", m_fire_z)
		NETVAR("DT_Inferno", "m_fireCount", m_fire_count)

		NETVAR( "DT_BaseAnimating", "m_bClientSideAnimation", m_client_side_animation )
		NETVAR( "DT_CSPlayer", "m_nSequence", m_nSequence )
		NETVAR( "DT_CSPlayer", "m_flCycle", m_flCycle )
		NETVAR( "DT_BasePlayer", "m_MoveType", m_move_type );
		NETVAR( "C_BaseEntity", "m_angAbsRotation", m_angAbsRotation );
		NETVAR( "C_BaseEntity", "m_angRotation", m_angRotation );
		NETVAR( "C_BaseEntity", "m_angNetworkAngles", m_angNetworkAngles );
		NETVAR( "C_BasePlayer", "m_surfaceFriction", m_surfaceFriction );
	} m_player;
	struct {
		NETVAR( "DT_BaseCombatWeapon", "m_flNextPrimaryAttack", next_primary_attack )
		NETVAR( "DT_BaseCombatWeapon", "m_flNextSecondaryAttack", next_secondary_attack )
		NETVAR( "DT_BaseCSGrenade", "m_flThrowStrength", m_throw_strength )
		NETVAR( "DT_BaseAttributableItem", "m_iItemDefinitionIndex", item_definition_index )
		NETVAR( "DT_BaseCombatWeapon", "m_iClip1", clip1_count )
		NETVAR( "DT_BaseCombatWeapon", "m_iClip2", clip2_count )
		NETVAR( "DT_BaseCombatWeapon", "m_iPrimaryReserveAmmoCount", primary_reserve_ammo_acount )
		NETVAR( "DT_WeaponCSBase", "m_flRecoilIndex", recoil_index )
		NETVAR( "DT_WeaponCSBase", "m_fLastShotTime", last_shot_time )
		NETVAR( "DT_SmokeGrenadeProjectile", "m_nSmokeEffectTickBegin", smoke_effect_begin_tick )
		NETVAR( "DT_WeaponCSBase", "m_flPostponeFireReadyTime", m_flPostponeFireReadyTime )
		NETVAR( "DT_WeaponCSBaseGun", "m_zoomLevel", zoom_level )
		NETVAR( "DT_BaseCombatWeapon", "m_iEntityQuality", entity_quality )
		NETVAR( "DT_BaseCombatWeapon", "m_hWeaponWorldModel", weapon_model )
		NETVAR( "DT_BaseCSGrenade", "m_bPinPulled", m_pin_pulled )
		NETVAR( "DT_BaseCSGrenade", "m_fThrowTime", m_throw_time )
	} m_weapon;
};

```

`solace-csgo/penetration.cpp`:

```cpp
#include "penetration.h"


#include "includes.h"
#include "thread_handler.h"

using IsBreakableEntity_t = bool( __thiscall * )( entity_t * );
bool penetration::IsBreakable( entity_t *ent ) {
    bool        ret;
    c_client_class *cc;
    const char *name;
    char *takedmg, old_takedmg;

    static auto IsBreakableEntity = ( IsBreakableEntity_t )util::find( "client.dll", "55 8B EC 51 56 8B F1 85 F6 74 68 83 BE" );

    static size_t m_takedamage_offset{ *( size_t * )( ( uintptr_t )IsBreakableEntity + 38 ) };

    // skip null ents and the world ent.
    if ( !ent || ent->index( ) == 0 )
        return false;

    // get m_takedamage and save old m_takedamage.
    takedmg = ( char * )( ( uintptr_t )ent + m_takedamage_offset );
    old_takedmg = *takedmg;

    // get clientclass.
    cc = ent->networkable( )->client_class(  );

    if ( cc ) {
        // get clientclass network name.
        name = cc->m_pNetworkName;

        // CBreakableSurface, CBaseDoor, ...
        if ( name[ 1 ] != 'F'
             || name[ 4 ] != 'c'
             || name[ 5 ] != 'B'
             || name[ 9 ] != 'h' ) {
            *takedmg = 2;
        }
    }

    ret = IsBreakableEntity( ent );
    *takedmg = old_takedmg;

    return ret;
}
static bool UTIL_ClipTraceToPlayers( const vec3_t &vecAbsStart, const vec3_t &vecAbsEnd, unsigned int mask, trace_filter *filter, trace_t *tr, float range ) {
    static auto clptrtp = util::find( "client.dll", "E8 ? ? ? ? 83 C4 14 8A 56 37" ) + 0x1;

    if ( !clptrtp )
        return false;

    __asm {
        mov  ecx, vecAbsStart
        mov	 edx, vecAbsEnd
        push range
        push tr
        push filter
        push mask
        call clptrtp
        add	 esp, 16
    }
    return true;
}

float penetration::scale( player_t *player, float damage, float armor_ratio, int hitgroup ) {
    bool  has_heavy_armor;
    int   armor;
    float heavy_ratio, bonus_ratio, ratio, new_damage;

    static auto is_armored = [ ]( player_t *player, int armor, int hitgroup ) {
        // the player has no armor.
        if ( armor <= 0 )
            return false;

        // if the hitgroup is head and the player has a helment, return true.
        // otherwise only return true if the hitgroup is not generic / legs / gear.
        if ( hitgroup == hitgroup_head && player->has_helment( ) )
            return true;

        else if ( hitgroup >= hitgroup_chest && hitgroup <= hitgroup_rightarm )
            return true;

        return false;
    };

    // check if the player has heavy armor, this is only really used in operation stuff.
    has_heavy_armor = player->heavy_armor( );

    // scale damage based on hitgroup.
    switch ( hitgroup ) {
    case hitgroup_head:
        if ( has_heavy_armor )
            damage = ( damage * 4.f ) * 0.5f;
        else
            damage *= 4.f;
        break;

    case hitgroup_stomach:
        damage *= 1.25f;
        break;

    case hitgroup_leftleg:
    case hitgroup_rightleg:
        damage *= 0.75f;
        break;

    default:
        break;
    }

    // grab amount of player armor.
    armor = player->armor( );

    // check if the ent is armored and scale damage based on armor.
    if ( is_armored( player, armor, hitgroup ) ) {
        heavy_ratio = 1.f;
        bonus_ratio = 0.5f;
        ratio = armor_ratio * 0.5f;

        // player has heavy armor.
        if ( has_heavy_armor ) {
            // calculate ratio values.
            bonus_ratio = 0.33f;
            ratio = armor_ratio * 0.25f;
            heavy_ratio = 0.33f;

            // calculate new damage.
            new_damage = ( damage * ratio ) * 0.85f;
        }

        // no heavy armor, do normal damage calculation.
        else
            new_damage = damage * ratio;

        if ( ( ( damage - new_damage ) * ( heavy_ratio * bonus_ratio ) ) > armor )
            new_damage = damage - ( armor / bonus_ratio );

        damage = new_damage;
    }

    return std::floor( damage );
}

bool penetration::TraceToExit( vec3_t &start, const vec3_t &dir, vec3_t &out, trace_t *enter_trace, trace_t *exit_trace ) {
    static trace_filter filter{};

    float  dist{};
    vec3_t new_end;
    int    contents, first_contents{};

    // max pen distance is 90 units.
    while ( dist <= 90.f ) {
        // step forward a bit.
        dist += 4.f;

        // set out pos.
        out = start + ( dir * dist );

        {
            if ( !first_contents )
                first_contents = g.m_interfaces->trace( )->get_point_contents( out, MASK_SHOT, nullptr );

            contents = g.m_interfaces->trace( )->get_point_contents( out, MASK_SHOT, nullptr );

            if ( ( contents & MASK_SHOT_HULL ) && ( !( contents & CONTENTS_HITBOX ) || ( contents == first_contents ) ) )
                continue;

            // move end pos a bit for tracing.
            new_end = out - ( dir * 4.f );

            // do first trace aHR0cHM6Ly9zdGVhbWNvbW11bml0eS5jb20vaWQvc2ltcGxlcmVhbGlzdGlj.
            g.m_interfaces->trace( )->trace_ray( ray_t( out, new_end ), MASK_SHOT, nullptr, exit_trace );


            // note - dex; this is some new stuff added sometime around late 2017 ( 10.31.2017 update? ).
            //static auto sv_clip_penetration_traces_to_players = g.m_interfaces->console(  )->get_convar( "sv_clip_penetration_traces_to_players" );
            //if ( sv_clip_penetration_traces_to_players->GetBool( ) )
            //    UTIL_ClipTraceToPlayers( out, new_end, MASK_SHOT, nullptr, exit_trace, -60.f );

            // we hit an ent's hitbox, do another trace.
            if ( exit_trace->startSolid && ( exit_trace->surface.flags & SURF_HITBOX ) ) {
                filter.skip = exit_trace->entity;
                g.m_interfaces->trace( )->trace_ray( ray_t( out, start ), MASK_SHOT_HULL, &filter, exit_trace );

                if ( exit_trace->did_hit( ) && !exit_trace->startSolid ) {
                    out = exit_trace->end;
                    return true;
                }

                continue;
            }
        }

        if ( !exit_trace->did_hit( ) || exit_trace->startSolid ) {
            if ( IsBreakable( enter_trace->entity ) ) {
                *exit_trace = *enter_trace;
                exit_trace->end = start + dir;
                return true;
            }

            continue;
        }

        if ( ( exit_trace->surface.flags & SURF_NODRAW ) ) {
            // note - dex; ok, when this happens the game seems to not ignore world?
            if ( IsBreakable( exit_trace->entity ) && IsBreakable( enter_trace->entity ) ) {
                out = exit_trace->end;
                return true;
            }

            if ( !( enter_trace->surface.flags & SURF_NODRAW ) )
                continue;
        }

        if ( exit_trace->plane.normal.dot( dir ) <= 1.f ) {
            out -= ( dir * ( exit_trace->flFraction * 4.f ) );
            return true;
        }
    }

    return false;
}

void penetration::ClipTraceToPlayer( vec3_t &start, const vec3_t &end, uint32_t mask, trace_t *tr, player_t *player, float min ) {
    vec3_t     pos, to, dir, on_ray;
    float      len, range_along, range;
    ray_t        ray;
    trace_t new_trace;

    // reference: https://github.com/alliedmodders/hl2sdk/blob/3957adff10fe20d38a62fa8c018340bf2618742b/game/shared/util_shared.h#L381

    // set some local vars.
    pos = player->origin( ) + ( ( player->mins( ) + player->maxs( ) ) * 0.5f );
    to = pos - start;
    dir = end - start;
    len = dir.length( );
    dir /= len;
    range_along = dir.dot( to );

    // off start point.
    if ( range_along < 0.f )
        range = -( to ).length( );

    // off end point.
    else if ( range_along > len )
        range = -( pos - end ).length( );

    // within ray bounds.
    else {
        on_ray = start + ( dir * range_along );
        range = ( pos - on_ray ).length( );
    }

    if ( range >= 0.f && range <= 60.f ) {
        // clip to player.
        g.m_interfaces->trace(  )->clip_ray_to_entity( ray_t( start, end ), mask, player, &new_trace );

        if ( tr->flFraction > new_trace.flFraction )
            *tr = new_trace;
    }
}

#define CS_MASK_SHOOT (MASK_SOLID | CONTENTS_DEBRIS)

bool penetration::run( PenetrationInput_t *in, PenetrationOutput_t *out ) {

    int			  pen{ 4 }, enter_material, exit_material;
    float		  damage, penetration, player_damage;
    surfacedata_t *enter_surface, *exit_surface;
    bool		  nodraw, grate;
    vec3_t		  start, dir, end, pen_end;
    trace_t	  trace, exit_trace;
    weapon_info_t *weapon_info;

    // if we are tracing from our local player perspective.
    if ( in->m_from == g.m_local ) {
        weapon_info = g.m_weapon_info;
        start = in->m_start;
    }

    // not local player.
    else {
        weapon_t *weapon;
        weapon = static_cast< weapon_t * >( g.m_interfaces->entity_list( )->get_client_entity_handle( in->m_from->active_weapon( ) ) );
        if ( !weapon )
            return false;

        // get weapon info.
        weapon_info = g.m_interfaces->weapon_system( )->get_weapon_data( weapon->item_definition_index( ) );;
        if ( !weapon_info )
            return false;

        // set trace start.
        if ( !in->m_resolving )
            start = g.m_shoot_pos;
        else
            start = in->m_start;
    }
    if ( !weapon_info )
        return false;
    // get some weapon data.
    float fPenetrationPower = 35;
    float flPenetrationDistance = 3000.0;
    float damage_mod = 0.5f;
    float pen_mod = 1.f;
    damage = static_cast< float >(weapon_info->m_damage);
    penetration = weapon_info->m_penetration;
    float flCurrentDistance = 0.f;
    // used later in calculations.

    // get direction to end point.
    dir = ( in->m_pos - start );
    dir /= dir.length( );

    auto *studio_model = g.m_interfaces->model_info( )->get_studio_model( in->m_target->model( ) );
    if ( !studio_model )
        return false;

    float flTraceDistance = 0;

    float flPenMod = 0;

    float flPercentDamageChunk = 0;

    float flLostDamageObject = 0;
    float lost = 0;

    // setup trace filter for later.
    static trace_filter filter; filter.skip = ( in->m_from );

    while ( true ) {
        // set trace end.
        end = start + (dir * (weapon_info->m_range - flCurrentDistance));

        // setup ray and trace.
        // TODO; use UTIL_TraceLineIgnoreTwoEntities?
        {
            g.m_interfaces->trace()->trace_ray(ray_t(start, end), CS_MASK_SHOOT | CONTENTS_HITBOX, &filter, &trace);


            // check for player hitboxes extending outside their collision bounds.
            // if no target is passed we clip the trace to a specific player, otherwise we clip the trace to any player.

            if ( in->m_target ) {
                ClipTraceToPlayer(start, end + (dir * 40.f), CS_MASK_SHOOT | CONTENTS_HITBOX, &trace, in->m_target,
                                  -60.f);
            }
            else
                return false;// UTIL_ClipTraceToPlayers( start, end + ( dir * 40.f ), MASK_SHOT, ( trace_filter * )&filter, &trace, -60.f );
        }


        // calculate damage based on the distance the bullet traveled.
        flCurrentDistance += trace.flFraction * (weapon_info->m_range - flCurrentDistance);
        damage *= std::pow( weapon_info->m_range_modifier, flCurrentDistance / 500.f );
    	
        // we didn't hit anything.
        if ( trace.flFraction == 1.f ) {
            if ( in->m_simulated_shot ) {
                //reached end point of trace, calculate damage as if it were a headshot
                scale( in->m_target, damage, weapon_info->m_armor_ratio, hitgroup_head );
                return true;
            }

            return false;
        }

        // if a target was passed.
        if ( in->m_target ) {

            // validate that we hit the target we aimed for.
            if ( trace.entity && trace.entity == in->m_target ) {
                if ( damage < 0 ) {
                    out->m_damage = damage;
                    return false;
                }

                // scale damage based on the hitgroup we hit.
                player_damage = scale( in->m_target, damage, weapon_info->m_armor_ratio, in->m_simulated_shot ? hitgroup_head : trace.hitGroup );

                // set result data for when we hit a player.
                out->m_pen = pen != 4;
                out->m_hitgroup = trace.hitGroup;
                out->m_damage = player_damage;
                out->m_target = in->m_target;

                // non-penetrate damage.
                if ( pen == 4 )
                    return player_damage >= in->m_damage;

                // penetration damage.
                return player_damage >= in->m_damage_pen;
            }
        }

        // no target was passed, check for any player hit or just get final damage done.
        else {
            out->m_pen = pen != 4;

            // todo - dex; team checks / other checks / etc.
            if ( trace.entity && trace.entity->is_player( ) ) {
                if ( damage < 0 ) {
                    out->m_damage = damage;
                    return false;
                }

                player_damage = scale( static_cast< player_t * >(trace.entity), damage, weapon_info->m_armor_ratio, in->m_simulated_shot ? hitgroup_head : trace.hitGroup );

                // set result data for when we hit a player.
                out->m_hitgroup = trace.hitGroup;
                out->m_damage = player_damage;
                out->m_target = static_cast< player_t * >(trace.entity);

                // non-penetrate damage.
                if ( pen == 4 )
                    return player_damage >= in->m_damage;

                // penetration damage.
                return player_damage >= in->m_damage_pen;
            }

            // if we've reached here then we didn't hit a player yet, set damage and hitgroup.
            out->m_damage = damage;
        }

        // don't run pen code if it's not wanted.
        if ( !in->m_can_pen )
            return false;

        // get surface at entry point.
        enter_surface = g.m_interfaces->phys_surface(  )->GetSurfaceData( trace.surface.surfaceProps );

        pen_mod = enter_surface->game.m_penetration_modifier;
        damage_mod = enter_surface->game.m_damage_modifier;

        // this happens when we're too far away from a surface and can penetrate walls or the surface's pen modifier is too low.
        if ((flCurrentDistance > flPenetrationDistance && penetration > 0.f) || pen_mod < 0.1f)
        {
            return false;
        }

        // store data about surface flags / contents.
        grate = (trace.contents & CONTENTS_GRATE);
        nodraw = !!(trace.surface.flags & SURF_NODRAW);

        // get material at entry point.
        enter_material = enter_surface->game.m_material;

        // note - dex; some extra stuff the game does.
        if ( pen == 0 && !nodraw && !grate && enter_material != CHAR_TEX_GRATE && enter_material != CHAR_TEX_GLASS )
            return false;

        // no more pen.
        if ( penetration <= 0.f || pen <= 0 ) {
            return false;
        }

        // try to penetrate object.
        if ( !TraceToExit( trace.end, dir, pen_end, &trace, &exit_trace ) ) {
            if ((g.m_interfaces->trace()->get_point_contents(pen_end, CS_MASK_SHOOT) & CS_MASK_SHOOT) == 0)
            {
                return false;
            }
        }
      
        // get surface / material at exit point.
        exit_surface = g.m_interfaces->phys_surface(  )->GetSurfaceData( exit_trace.surface.surfaceProps );
        exit_material = exit_surface->game.m_material;

        float temp_pen_mod = pen_mod;
        float temp_damage_mod = damage_mod;

        // todo - dex; check for CHAR_TEX_FLESH and ff_damage_bullet_penetration / ff_damage_reduction_bullets convars?
        //             also need to check !isbasecombatweapon too.
        float flDamLostPercent = 0.16;
        static auto ff_damage_reduction_bullets = g.m_interfaces->console()->get_convar("ff_damage_reduction_bullets");
        if (grate || nodraw || enter_material == CHAR_TEX_GLASS || enter_material == CHAR_TEX_GRATE)
        {
            // If we're a concrete grate (TOOLS/TOOLSINVISIBLE texture) allow more penetrating power.
            if (enter_material == CHAR_TEX_GLASS || enter_material == CHAR_TEX_GRATE)
            {
                temp_pen_mod = 3.0f;
                flDamLostPercent = 0.05;
            }
            else
                temp_pen_mod = 1.0f;

            temp_damage_mod = 0.99f;
        }
        else
        {
            // check the exit material and average the exit and entrace values
            float flExitPenetrationModifier = exit_surface->game.m_penetration_modifier;
            float flExitDamageModifier = exit_surface->game.m_damage_modifier;
            temp_pen_mod = (temp_pen_mod + flExitPenetrationModifier) / 2;
            temp_damage_mod = (temp_damage_mod + flExitDamageModifier) / 2;
        }


        // thin metals, wood and plastic get a penetration bonus.
        if ( enter_material == exit_material ) {
            if ( exit_material == CHAR_TEX_CARDBOARD || exit_material == CHAR_TEX_WOOD )
                temp_pen_mod = 3;

            else if ( exit_material == CHAR_TEX_PLASTIC )
                temp_pen_mod = 2;
        }

        // set some local vars.
        flTraceDistance = ( exit_trace.end - trace.end ).length();

        flPenMod = fmaxf(0, (1 / temp_pen_mod));

        flPercentDamageChunk = damage * flDamLostPercent;
        float flPenWepMod = flPercentDamageChunk + fmaxf( 0.f,  3.f / fPenetrationPower ) * 1.25f * ( flPenMod * 3.0f );

        flLostDamageObject = ( ( flPenMod * ( flTraceDistance * flTraceDistance ) ) / 24 );
        lost = flPenWepMod + flLostDamageObject;
        //flCurrentDistance += flTraceDistance;
        //trace_len = ( exit_trace.end - trace.end ).length( );
        //modifier = fmaxf( 0.f, 1.f / total_pen_mod );
        //damage_lost = ( ( modifier * 3.f ) * penetration_mod + ( damage * damage_mod ) ) + ( ( ( trace_len * trace_len ) * modifier ) / 24.f );

        // subtract from damage.
        damage -= fmaxf( 0.f, lost );
        if ( damage < 1.f )
            return false;

        // set new start pos for successive trace.
        start = exit_trace.end;

        // decrement pen.
        --pen;
    }

    return false;
}
```

`solace-csgo/penetration.h`:

```h
#pragma once

#include "vec3.h"
struct trace_t;
class player_t;
class entity_t;

namespace penetration {
    struct PenetrationInput_t {
        player_t *m_from = nullptr;
        player_t *m_target = nullptr;
        vec3_t  m_pos;
        float	m_damage;
        float   m_damage_pen;
        bool	m_can_pen = true;
        int m_group = -1;
        vec3_t m_start = vec3_t(0,0,0);
        bool m_resolving = false;
        bool m_simulated_shot = false;
        int m_hitgroup = 0;
    };

    struct PenetrationOutput_t {
        player_t *m_target = nullptr;
        float   m_damage = 0;
        int     m_hitgroup = -1;
        bool    m_pen = false;

        __forceinline PenetrationOutput_t( ) = default;
    };

    bool IsBreakable( entity_t* ent );
    float scale( player_t *player, float damage, float armor_ratio, int hitgroup );
    bool  TraceToExit( vec3_t &start, const vec3_t &dir, vec3_t &out, trace_t *enter_trace, trace_t *exit_trace );
    void  ClipTraceToPlayer( vec3_t &start, const vec3_t &end, uint32_t mask, trace_t *tr, player_t *player, float min );
    bool  run( PenetrationInput_t *in, PenetrationOutput_t *out );
}
```

`solace-csgo/physics.h`:

```h
#pragma once
#include "includes.h"

struct surfacephysicsparams_t {
	float m_friction;
	float m_elasticity;
	float m_density;
	float m_thickness;
	float m_dampening;
};

struct surfaceaudioparams_t {
	float m_audio_reflectivity;
	float m_audio_hardness_factor;
	float m_audio_roughness_factor;
	float m_scrape_rough_threshold;
	float m_impact_hard_threshold;
	float m_audio_hard_min_velocity;
	float m_high_pitch_occlusion;
	float m_mid_pitch_occlusion;
	float m_low_pitch_occlusion;
};

struct surfacegameprops_t {
	float    m_max_speed_factor;
	float    m_jump_factor;
	float    m_penetration_modifier;
	float    m_damage_modifier;
	uint16_t m_material;
	uint8_t  m_climbable;
};

struct surfacesoundnames_t {
	short m_walk_left;
	short m_walk_right;
	short m_run_left;
	short m_run_right;
	short m_impact_soft;
	short m_impact_hard;
	short m_scrape_smooth;
	short m_scrape_rough;
	short m_bullet_impact;
	short m_rolling;
	short m_break_sound;
	short m_strain;
};

struct surfacedata_t {
    surfacephysicsparams_t physics;
    surfaceaudioparams_t audio;
    surfacesoundnames_t sounds;
    surfacegameprops_t game;
    char pad[ 48 ];
};

class phys_surface_props_t {
public:
    virtual ~phys_surface_props_t( void ) { }
    // parses a text file containing surface prop keys
    virtual int ParseSurfaceData( const char *pFilename, const char *pTextfile ) = 0;
    // current number of entries in the database
    virtual int SurfacePropCount( void ) const = 0;

    virtual int GetSurfaceIndex( const char *pSurfacePropName ) const = 0;
    virtual void GetPhysicsProperties( int surfaceDataIndex, float *density, float *thickness, float *friction,
                                       float *elasticity ) const = 0;

    virtual surfacedata_t *GetSurfaceData( int surfaceDataIndex ) = 0;
    virtual const char *GetString( unsigned short stringTableIndex ) const = 0;


    virtual const char *GetPropName( int surfaceDataIndex ) const = 0;

    // sets the global index table for world materials
    // UNDONE: Make this per-CPhysCollide
    virtual void SetWorldMaterialIndexTable( int *pMapArray, int mapSize ) = 0;

    // NOTE: Same as GetPhysicsProperties, but maybe more convenient
    virtual void GetPhysicsParameters( int surfaceDataIndex, surfacephysicsparams_t *pParamsOut ) const = 0;
};

```

`solace-csgo/player.h`:

```h
#pragma once
class anim_state;
class c_client_class;
#include "weapon_info.h"
#include "animstate.h"

class networkable_t {
public:
	VFUNC( client_class( ), 2, c_client_class *( __thiscall * )( void * ) );
	VFUNC(dormant(), 9, bool( __thiscall * )( void * ) );
};


enum player_flags {
	fl_onground = ( 1 << 0 ), 	
	fl_ducking = ( 1 << 1 ),	
	fl_waterjump = ( 1 << 2 ),	
	fl_ontrain = ( 1 << 3 ),	
	fl_inrain = ( 1 << 4 ),		
	fl_frozen = ( 1 << 5 ),		
	fl_atcontrols = ( 1 << 6 ),	
	fl_client = ( 1 << 7 ),		
	fl_fakeclient = ( 1 << 8 ),	
	fl_inwater = ( 1 << 10 ),	
};
enum item_definition_indexes {
	WEAPON_NONE = 0,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG556,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_BAYONET = 500,
	WEAPON_KNIFE_CSS = 503,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034,
	GLOVE_HYDRA = 5035
};

class CStudioHdr;
class entity_t;

class bone_accessor_t {
public:
	void *m_pAnimating;
	bone_array_t *m_pBones;
	int        m_ReadableBones;
	int        m_WritableBones;
};

class bone_cache_t {
public:
	bone_array_t *m_pCachedBones;
	char		u4[ 0x8 ];
	int        m_CachedBoneCount;
};

class CBoneCacheHandler {
public:
	float			m_timeValid;
	int				m_boneMask;
	unsigned int	m_size;
	unsigned short	m_cachedBoneCount;
	unsigned short	m_matrixOffset;
	unsigned short	m_cachedToStudioOffset;
	unsigned short	m_boneOutOffset;
};

struct model_t;

class animating_t {
public:
	VFUNC( setup_bones( matrix_t *out, int max_bones, int mask, float time ), 13, bool( __thiscall * )( void *, matrix_t *, int, int, float ), out, max_bones, mask, time )
};

struct RenderableInstance_t {
	uint8_t m_alpha;
	__forceinline RenderableInstance_t( ) : m_alpha{ 255ui8 } { }
};
enum class PoseParam_t : int {
	STRAFE_YAW = 0,
	STAND,
	LEAN_YAW,
	SPEED,
	LADDER_YAW,
	LADDER_SPEED,
	JUMP_FALL,
	MOVE_YAW,
	MOVE_BLEND_CROUCH,
	MOVE_BLEND_WALK,
	MOVE_BLEND_RUN,
	BODY_YAW,
	BODY_PITCH,
	AIM_BLEND_STAND_IDLE,
	AIM_BLEND_STAND_WALK,
	AIM_BLEND_STAND_RUN,
	AIM_BLEND_COURCH_IDLE,
	AIM_BLEND_CROUCH_WALK,
	DEATH_YAW
}; 
enum animstate_layer_t {
	ANIMATION_LAYER_AIMMATRIX = 0,
	ANIMATION_LAYER_WEAPON_ACTION,
	ANIMATION_LAYER_WEAPON_ACTION_RECROUCH,
	ANIMATION_LAYER_ADJUST,
	ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL,
	ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB,
	ANIMATION_LAYER_MOVEMENT_MOVE,
	ANIMATION_LAYER_MOVEMENT_STRAFECHANGE,
	ANIMATION_LAYER_WHOLE_BODY,
	ANIMATION_LAYER_FLASHED,
	ANIMATION_LAYER_FLINCH,
	ANIMATION_LAYER_ALIVELOOP,
	ANIMATION_LAYER_LEAN,
	ANIMATION_LAYER_COUNT,
};
enum MoveType_t {
	MOVETYPE_NONE = 0,	// never moves
	MOVETYPE_ISOMETRIC,			// For players -- in TF2 commander view, etc.
	MOVETYPE_WALK,				// Player only - moving on the ground
	MOVETYPE_STEP,				// gravity, special edge handling -- monsters use this
	MOVETYPE_FLY,				// No gravity, but still collides with stuff
	MOVETYPE_FLYGRAVITY,		// flies through the air + is affected by gravity
	MOVETYPE_VPHYSICS,			// uses VPHYSICS for simulation
	MOVETYPE_PUSH,				// no clip to world, push and crush
	MOVETYPE_NOCLIP,			// No gravity, no collisions, still do velocity/avelocity
	MOVETYPE_LADDER,			// Used by players only when going onto a ladder
	MOVETYPE_OBSERVER,			// Observer movement, depends on player's observer mode
	MOVETYPE_CUSTOM,			// Allows the entity to describe its own physics

	// should always be defined as the last item in the list
	MOVETYPE_LAST = MOVETYPE_CUSTOM,

	MOVETYPE_MAX_BITS = 4
};
class entity_t {
public:
	template< typename t >
	__forceinline t &get( size_t offset ) {
		return *reinterpret_cast< t * >(reinterpret_cast< uintptr_t >(this) + offset);
	}
	animating_t *animating( ) {
		return reinterpret_cast< animating_t * >( uintptr_t( this ) + 0x4 );
	}
	networkable_t *networkable( ) {
		return reinterpret_cast< networkable_t * >( uintptr_t( this ) + 0x8 );
	}

	int index( ) {
		using original_fn = int( __thiscall * )( void * );
		return ( *( original_fn ** )networkable( ) )[ 10 ]( networkable( ) );
	}
	
	bone_cache_t &bone_cache( ) {
		return get< bone_cache_t>( 0x2900 );
	}

	vec3_t &abs_origin( ) {
		using original_fn = vec3_t & ( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 10 ]( this );;
	}
	ang_t &abs_angles( ) {
		using original_fn = ang_t & ( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 11 ]( this );;
	}

	void *bone_merge_cache() {
		return reinterpret_cast< void * >( reinterpret_cast< uintptr_t >( this ) + 0x28FC );
	}

	model_t *model( ) {
		using original_fn = model_t * ( __thiscall * )( void * );
		return ( *( original_fn ** )animating( ) )[ 8 ]( animating( ) );
	}
	void set_abs_angles( ang_t ang ) {
		static auto func = util::find( "client.dll", "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8" );
		using SetAbsAngles_t = void( __thiscall * )( decltype( this ), const ang_t & );
		reinterpret_cast< SetAbsAngles_t >(func)( this, ang );
	}

	void set_abs_origin( vec3_t org ) {
		static auto func = util::find( "client.dll", "55 8B EC 83 E4 F8 51 53 56 57 8B F1" );
		using SetAbsAngles_t = void( __thiscall * )( decltype( this ), const vec3_t & );
		reinterpret_cast< SetAbsAngles_t >(func)( this, org );
	}
	
	void set_abs_velocity( vec3_t org ) {
		static auto func = util::find( "client.dll", "55 8B EC 83 E4 F8 83 EC 0C 53 56 57 8B 7D 08 8B F1" );
		using SetAbsAngles_t = void( __thiscall * )( decltype( this ), const vec3_t & );
		reinterpret_cast< SetAbsAngles_t >( func )( this, org );
	}


	void PreThink( ) {
		using think_t = void( __thiscall * )( void * );
		return util::get_virtual_function< think_t >( this, 307 )( this );
	}
	void Think( ) {
		using think_t = void( __thiscall * )( void * );
		return util::get_virtual_function< think_t >( this, 137 )( this );
	}
	void PostThink( ) {
		using think_t = void( __thiscall * )( void * );
		return util::get_virtual_function< think_t >( this, 308 )( this );
	}

	void StandardBlendingRules( void *hdr, vec3_t *pos, quaternion_t *q, float time, int mask ) {
		using StandardBlendingRules_t = void( __thiscall * )( void *, void *, vec3_t *, quaternion_t *, float, int );
		return util::get_virtual_function< StandardBlendingRules_t >( this, 205 )( this, hdr, pos, q, time, mask );
	}
	void BuildTransformations( void *hdr, vec3_t pos[], quaternion_t q[], const matrix_t &transform, int mask, uint8_t *computed ) {
		using BuildTransformations_t = void( __thiscall * )( void *, void *, vec3_t *, quaternion_t *, matrix_t const &, int, uint8_t * );
		return util::get_virtual_function< BuildTransformations_t >( this, 184 )( this, hdr, pos, q, transform, mask, computed );
	}

	void DoExtraBoneProcessing( void *hdr, vec3_t pos[], quaternion_t q[], matrix_t *bones, uint8_t *computed, CIKContext *ik ) {
		using BuildTransformations_t = void( __thiscall * )( void *, void *, vec3_t *, quaternion_t *, matrix_t *, uint8_t *, CIKContext * );
		return util::get_virtual_function< BuildTransformations_t >( this, 197 )( this, hdr, pos, q, bones, computed, ik );
	}

	void UpdateIKLocks( float time ) {
		using BuildTransformations_t = void( __thiscall * )( void *, float );
		return util::get_virtual_function< BuildTransformations_t >( this, 186 )( this, time );
	}

	void CalculateIKLocks( float time ) {
		using BuildTransformations_t = void( __thiscall * )( void *, float );
		return util::get_virtual_function< BuildTransformations_t >( this, 187 )( this, time );
	}

	inline void Wrap_UpdateTargets( uintptr_t ik, vec3_t *pos, quaternion_t *q, matrix_t *bones, uint8_t *computed ) const {
		using CreateAnimState_t = void( __thiscall * )( uintptr_t, vec3_t *, quaternion_t *, matrix_t *, uint8_t * );

		static auto func = util::find( "client.dll", "55 8B EC 83 E4 ? 81 EC ? ? ? ? 33 D2" );
		if ( !func )
			return;

		( ( CreateAnimState_t )func )( ik, pos, q, bones, computed );
	}

	inline void Wrap_SolveDependencies( uintptr_t ik, vec3_t *pos, quaternion_t *q, matrix_t *bones, uint8_t *computed ) const {
		using CreateAnimState_t = void( __thiscall * )( uintptr_t, vec3_t *, quaternion_t *, matrix_t *, uint8_t * );

		static auto func = util::find( "client.dll", "55 8B EC 83 E4 ? 81 EC ? ? ? ? 8B 81 ? ? ? ? 56" );
		if ( !func )
			return;

		( ( CreateAnimState_t )func )( ik, pos, q, bones, computed );
	}

	OFFSET( bool, client_side_anim, g.m_offsets->m_player.m_client_side_animation);
	
	void update_client_side_animation( ) {
		using update_client_side_animation_t = void( __thiscall * )( decltype( this ) );
		return util::get_virtual_function< update_client_side_animation_t >( this, 218 )( this );
	}

	enum InvalidatePhysicsBits_t : int {
		POSITION_CHANGED = 0x1,
		ANGLES_CHANGED = 0x2,
		VELOCITY_CHANGED = 0x4,
		ANIMATION_CHANGED = 0x8,
		BOUNDS_CHANGED = 0x10,
		SEQUENCE_CHANGED = 0x20
	};

	__forceinline void InvalidatePhysicsRecursive( InvalidatePhysicsBits_t bits ) {
		using InvalidatePhysicsRecursive_t = void( __thiscall* )( decltype( this ), InvalidatePhysicsBits_t );
		static auto addr = util::find( "client.dll", "55 8B EC 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3 56" );
		(( InvalidatePhysicsRecursive_t ) addr )( this, bits );
	}

	float spawn_time( ) {
		static auto SpawnTime = *( uintptr_t * )( util::find( "client.dll", "F3 0F 5C 88 ? ? ? ? 0F" ) + 4 );
		return *(float*)( this + SpawnTime );
    }
    __forceinline CUtlVector<animation_layer_t>& anim_overlay_vec()
    {
        static auto anim_overlay = *(uintptr_t*)(util::find("client.dll", "8B 80 ? ? ? ? 03 C1 74 ?") + 2);
        return *reinterpret_cast<CUtlVector<animation_layer_t>*>(this + anim_overlay);
    }
	__forceinline animation_layer_t *&anim_overlay(  ) {
		static auto anim_overlay = *( uintptr_t * )( util::find( "client.dll", "8B 80 ? ? ? ? 03 C1 74 ?") + 2 );
		return *reinterpret_cast< animation_layer_t ** >(this + anim_overlay);
	}
	__forceinline void GetAnimLayers( animation_layer_t *layers ) {
		std::memcpy( layers, anim_overlay( ), sizeof( animation_layer_t ) * 15 );
	}

	OFFSETPTR( float, pose_parameters, g.m_offsets->m_player.m_pose_parameters );
	__forceinline void GetPoseParameters( float *poses ) {
		std::memcpy( poses, pose_parameters( ), sizeof( float ) * 24 );
	}
	__forceinline void SetPoseParameters( float *poses ) {
		std::memcpy( pose_parameters( ), poses, sizeof( float ) * 24 );
	}
	__forceinline void SetAnimLayers( animation_layer_t *layers ) {
		std::memcpy( anim_overlay( ), layers, sizeof( animation_layer_t ) * 15 );
	}
	void handle_taser( ) {
		using handle_taser_t = void( __thiscall * )( void * );
		static auto handle_taser = reinterpret_cast< handle_taser_t >(util::find( "client.dll",
		                                                                          "55 8B EC 83 EC ? 56 8B F1 80 BE ? ? ? ? ? 0F 84 ? ? ? ? 80 BE ? ? ? ? ? 0F 84 ? ? ? ? A1 ? ? ? ?" ) );
		if ( killed_by_taser( ) )
			handle_taser( this );
	}
	bool on_team( entity_t *target ) {
		return target->team( ) == team( );
    }
    OFFSET(int, team, g.m_offsets->m_player.m_team);
    OFFSET(float, last_bone_setup_time, g.m_offsets->m_player.m_last_bone_setup_time);
	OFFSET( bool, killed_by_taser, g.m_offsets->m_player.m_killed_by_taser );
	OFFSET( int, iEFlags, 0xE8 );
	OFFSETPTR( float, encoder_controller, g.m_offsets->m_player.m_encoded_controller )
	OFFSET( int, move_type, g.m_offsets->m_player.m_move_type )
	OFFSET( float, surface_friction, g.m_offsets->m_player.m_surfaceFriction )
	OFFSET( int, sequence, g.m_offsets->m_player.m_nSequence )
		OFFSET( float, cycle, g.m_offsets->m_player.m_flCycle )
		OFFSET( vec3_t, mins, g.m_offsets->m_player.m_mins )
		OFFSET( vec3_t, maxs, g.m_offsets->m_player.m_maxs )
	__forceinline ang_t &m_angAbsRotation( ) {
		return get< ang_t >( g.m_offsets->m_player.m_angAbsRotation );
	}

	
	__forceinline ang_t &m_angRotation( ) {
		return get< ang_t >( g.m_offsets->m_player.m_angRotation );
	}

	__forceinline ang_t &m_angNetworkAngles( ) {
		return get< ang_t >( g.m_offsets->m_player.m_angNetworkAngles );
	}

	bool  UpdateDispatchLayer( animation_layer_t *pLayer, CStudioHdr *studio_hdr, int sequence ) {
		///static auto func = util::find( "client.dll", "55 8B EC 81 EC ? ? ? ? 56 57 8B 7D ? 8B D1" );
		using SetAbsAngles_t = bool( __thiscall * )( void *, animation_layer_t *, CStudioHdr *, int );
		///return reinterpret_cast< SetAbsAngles_t >(func)( animating(), pLayer, studio_hdr, sequence );

		return util::get_virtual_function< SetAbsAngles_t>( this, 241 )( this, pLayer, studio_hdr, sequence );
		if ( !studio_hdr || !pLayer ) {
			if ( pLayer )
				pLayer->m_nDispatchedDst = -1;
			return false;
		}
		auto v4 = *( DWORD * )( studio_hdr + 4 );
		auto v5 = ( v4 != 0) ? *( int * )( v4 + 20 ) : *( int * )( *( int * )studio_hdr + 0xBC );
		if ( pLayer->m_pDispatchedStudioHdr != studio_hdr || pLayer->m_nDispatchedSrc != sequence ||
			 pLayer->m_nDispatchedDst >= v5 ) {
			pLayer->m_pDispatchedStudioHdr = studio_hdr;
			pLayer->m_nDispatchedSrc = sequence;
			using GetSequenceName_t = const char *( __thiscall * )( void *, int );
			static auto GetSequenceName = (GetSequenceName_t)( util::find( "client.dll",
																				 "55 8B EC 83 7D ? ? 56 8B F1 75 ? B8 ? ? ? ?" ) );

			auto pszSeqName = GetSequenceName( this, sequence );

			using LookupSequence_t = int( __thiscall * )( void *, const char * );
			static auto LookupSequence = reinterpret_cast< LookupSequence_t >( util::find( "client.dll",
																			   "55 8B EC 83 EC ? 53 8B 5D ? 56 57 8B F9 85 DB" ) );

			pLayer->m_nDispatchedDst = LookupSequence( studio_hdr, pszSeqName );
		}
		return pLayer->m_nDispatchedDst != -1;
	}

	vec3_t GetSequenceLinearMotion( CStudioHdr* pstudiohdr, int iSequence, const float *poseParameter) {
		static auto studioHdr = (util::find("client.dll", "55 8B EC 83 EC ? 56 8B F1 57 8B FA 85 F6 75 ? 68 ? ? ? ?"));
		vec3_t out;
		_asm{
			
			mov ecx, pstudiohdr
			mov edx, iSequence
			lea eax, [out]
			push eax
			push poseParameter
			call studioHdr
			add     esp, 8
		}
		//studioHdr( pstudiohdr, iSequence, poseParameter, &out);
		return out;
	}

	CStudioHdr *m_studioHdr( ) {
		static auto studioHdr = *( uintptr_t * )( util::find( "client.dll", "8B 86 ? ? ? ? 89 44 24 10 85 C0" ) + 2 );
		return *reinterpret_cast< CStudioHdr ** >( this + 0x293C );// studioHdr);
	}

	CIKContext *&m_Ipk( ) {
		return *( CIKContext ** )( (uintptr_t)this + 0x266C );
	}
	
	CStudioHdr *GetModelPtr( ) {
		using LockStudioHdr_t = int( __thiscall * )( void * );
		static auto LockStudioHdr = ( LockStudioHdr_t )util::find( "client.dll", "55 8B EC 51 53 8B D9 56 57 8D B3" );
		if ( !m_studioHdr( ) )
			LockStudioHdr( this );

		return m_studioHdr( );
	}
	bone_accessor_t &GetBoneAccessor( ) {
		static auto offset = *( uintptr_t * )( util::find( "client.dll", "8D 81 ? ? ? ? 50 8D 84 24" ) + 2 );

		return *( bone_accessor_t * )( ( uintptr_t )this + offset );
	}
	int &m_fEffects( ) {
		return *( int * )( ( uintptr_t )this + 0xEC );
	}

	CBoneMergeCache *&m_pBoneMergeCache( ) {
		//static auto offset = *( uintptr_t * )( util::find( "client.dll", "8B 8E ? ? ? ? E8 ? ? ? ? 8B 06" ) + 2 );

		return *( CBoneMergeCache ** )( ( uintptr_t )this + 0x28FC );

	}
	OFFSET( vec3_t, abs_vel, 0x94 );
	OFFSET( float, sim_time, g.m_offsets->m_player.m_simulation_time );
	OFFSET( vec3_t, origin, g.m_offsets->m_player.m_origin );
	OFFSET( int, active_weapon, g.m_offsets->m_player.m_active_weapon );
	VFUNC( is_player( ), 152, bool( __thiscall * )( decltype( this ) ) )
};
class CBoneMergeCache;
class weapon_world_model_t : public entity_t {
public:
	bool HoldsPlayerAnim( ) {
		using LockStudioHdr_t = bool( __thiscall * )( void * );
		static auto LockStudioHdr = ( LockStudioHdr_t )util::find( "server.dll", "57 8B F9 83 BF ? ? ? ? ? 75 ? 83 BF ? ? ? ? ?" );
		return LockStudioHdr( this );
	}
};

class weapon_t : public entity_t {
public:
	float inaccuracy( ) {
		using original_fn = float( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 469 ]( this );
	}

	float get_spread( ) {
		using original_fn = float( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 439 ]( this );
	}

	void update_accuracy_penalty( ) {
		using original_fn = void( __thiscall * )( void * );
		( *( original_fn ** )this )[ 471 ]( this );
	}
	float get_max_speed( ) {
		using original_fn = float( __thiscall* )( void* );
		return ( *( original_fn** )this )[ 429 ]( this );
	}
	//VFUNC( get_weapon_info( ), 446, weapon_info_t *( __thiscall * )( void * ) )
    OFFSET( float, postpone_fire_time,  g.m_offsets->m_weapon.m_flPostponeFireReadyTime);
	OFFSET( bool, pin_pulled, g.m_offsets->m_weapon.m_pin_pulled );
	OFFSET( bool, smoke_effect_begin_tick, g.m_offsets->m_weapon.smoke_effect_begin_tick );
	OFFSET( float, throw_time, g.m_offsets->m_weapon.m_throw_time );
	OFFSET( float, throw_strength, g.m_offsets->m_weapon.m_throw_strength );
	OFFSET( float, next_primary_attack, g.m_offsets->m_weapon.next_primary_attack );
	OFFSET( float, next_secondary_attack, g.m_offsets->m_weapon.next_secondary_attack );
	OFFSET( int, item_definition_index, g.m_offsets->m_weapon.item_definition_index );
	OFFSET( int, clip1_count, g.m_offsets->m_weapon.clip1_count );
	OFFSET( int, clip2_count, g.m_offsets->m_weapon.clip2_count );
	OFFSET( int, primary_reserve_ammo_acount, g.m_offsets->m_weapon.primary_reserve_ammo_acount );
	OFFSET( float, recoil_index, g.m_offsets->m_weapon.recoil_index );
	OFFSET( float, last_shot_time, g.m_offsets->m_weapon.last_shot_time );
	OFFSET( float, zoom_level, g.m_offsets->m_weapon.zoom_level );
	OFFSET( int, entity_quality, g.m_offsets->m_weapon.entity_quality );
	OFFSET( int, weapon_model, g.m_offsets->m_weapon.weapon_model );
};

class collideable_t {
public:
	vec3_t &mins( ) {
		using original_fn = vec3_t & ( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 1 ]( this );
	}
	vec3_t &maxs( ) {
		using original_fn = vec3_t & ( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 2 ]( this );
	}
};

class player_t : public entity_t {
public:
	bool dormant( ) {
		auto networkable_ = networkable( );
		if ( !networkable_ )
			return false;
		return networkable_->dormant( );
	}
	bool setup_bones( matrix_t *out, int max_bones, int mask, float time ) {
		auto animating_ = animating( );
		if ( !animating_ )
			return false;
		return animating_->setup_bones( out, max_bones, mask, time );
	}

	void set_angles( ang_t angles ) {
		using original_fn = void( __thiscall * )( void *, const ang_t & );
		static auto set_angles_fn = ( original_fn )( util::find( "client.dll", "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1" ) );
		set_angles_fn( this, angles );
	}
	
	collideable_t *collideable( ) {
		using original_fn = collideable_t * ( __thiscall * )( void * );
		return ( *( original_fn ** )this )[ 3 ]( this );
	}
	anim_state *get_anim_state( ) {
		static auto anim_state_w = *( uintptr_t * )( util::find( "client.dll", "8B 8E ? ? ? ? 85 C9 74 3E" ) + 2 );
		return *reinterpret_cast< anim_state ** >( this + anim_state_w );
	}

	static void UpdateButtons( player_t *target, int buttons ) {
		const auto buttons_changed = buttons ^ target->m_buttons( );
		target->m_last_buttons( ) = target->m_buttons( );
		target->m_buttons( ) = buttons;
		target->m_buttons_pressed( ) = buttons & buttons_changed;
		target->m_buttons_unpressed( ) = buttons_changed & ~buttons;
	}

	__forceinline void draw_model( int flags = 0x00000001, const RenderableInstance_t &instance = {} ) {
		return util::get_virtual_function< void( __thiscall * )( void *, int, const RenderableInstance_t & )>( animating( ), 9 )( animating( ), flags, instance );
	}

	datamap_t *GetDataDescMap( ) {
		typedef datamap_t *( __thiscall *o_GetDataDescMap )( void * );
		return util::get_virtual_function<o_GetDataDescMap>( this, 15 )( this );
	}

	datamap_t *GetPredDescMap( ) {
		typedef datamap_t *( __thiscall *o_GetPredDescMap )( void * );
		return util::get_virtual_function<o_GetPredDescMap>( this, 17 )( this );
	}

	/*void update_dispatch_layer( animation_layer_t *layer, CStudioHdr *studio_hdr ) {
		if( !studio_hdr || !layer )
		{
		  if( layer )
		  {
		    layer->m_nDispatchedDst = ACT_INVALID;
		  }
		
		  return;
		}
		
		if( layer->m_pDispatchedStudioHdr != studio_hdr || layer->m_nDispatchedSrc != layer->m_nSequence || layer->m_nDispatchedDst >= studio_hdr->GetNumSeq() )
		{
		  layer->m_pDispatchedStudioHdr = studio_hdr;
		  layer->m_nDispatchedSrc = layer->m_nSequence;
		
		  const char* pszLayerName = GetSequenceName( layer->m_nSequence );
		  layer->m_nDispatchedDst = studio_hdr->LookupSequence( pszLayerNAme );
		}
	}*/

	void calc_abs_velocity() {
		static auto fn_ptr = util::find("client.dll", "55 8B EC 83 E4 F8 83 EC 1C 53 56 57 8B F9 F7 87", 0);
		if (fn_ptr) {
			auto fn = (void(__thiscall*)(void*))(fn_ptr);
			fn(this);
		}
	}

	VFUNC ( world_space_center( ), 78, const vec3_t &( __thiscall * )( decltype( this ) ) )
	VFUNC( get_eye_pos( vec3_t *pos ), 163, void( __thiscall * )( decltype( this ), vec3_t * ), pos )
		OFFSET( int, m_buttons, 0x31E8 )
		OFFSET( int, m_last_buttons, 0x31DC )
		OFFSET( int, m_buttons_pressed, 0x31E0 )
		OFFSET( int, m_buttons_unpressed, 0x31E4 )
		OFFSET( int, m_next_think, 0xF8 )
		OFFSET( cmd_t *, m_cmd, 0x3314 )
                OFFSET(cmd_t, m_cmd_ukn, 0x326C)
                OFFSET(int, m_ground_entity,
                       g.m_offsets->m_player.m_ground_ent);
                OFFSET(float, stamina, g.m_offsets->m_player.m_stamina);
	OFFSET( ang_t, aim_punch, g.m_offsets->m_player.m_aim_punch_angle );
	OFFSET( ang_t, punch, g.m_offsets->m_player.m_punch_angle );
	OFFSET( int, armor, g.m_offsets->m_player.m_armor );
	OFFSET(float, duck_amount, g.m_offsets->m_player.m_duck_amount);
	OFFSET(float, duck_speed, g.m_offsets->m_player.m_duck_speed);
	OFFSET( bool, ducking, g.m_offsets->m_player.m_ducking );
	OFFSET( ang_t, eye_angles, g.m_offsets->m_player.m_eye_angles );
	OFFSET( int, flags, g.m_offsets->m_player.m_flags );
	OFFSET( float, flash_alpha, g.m_offsets->m_player.m_flash_alpha );
	OFFSET( float, flash_duration, g.m_offsets->m_player.m_flash_duration );
	OFFSET( float, fov_time, g.m_offsets->m_player.m_fov_time );
	OFFSET( bool, defuser, g.m_offsets->m_player.m_defuser );
	OFFSET( bool, gun_game_immunity, g.m_offsets->m_player.m_gun_game_immunity );
	OFFSET( bool, heavy_armor, g.m_offsets->m_player.m_heavy_armor );
	OFFSET( int, health, g.m_offsets->m_player.m_health );
	OFFSET( bool, alive, g.m_offsets->m_player.m_health );
	OFFSET( int, hitbox_set, g.m_offsets->m_player.m_hitbox_set );
	OFFSET( bool, defusing, g.m_offsets->m_player.m_defusing );
	OFFSET( bool, has_helment, g.m_offsets->m_player.m_has_helmet );
	OFFSET( bool, is_scoped, g.m_offsets->m_player.m_is_scoped );
	OFFSET( int, life_state, g.m_offsets->m_player.m_life_state );
	OFFSET( float, lower_body_yaw, g.m_offsets->m_player.m_lower_body_yaw );
	OFFSET( float, velocity_modifier, g.m_offsets->m_player.velocity_modifier );
	OFFSET( float, max_speed, g.m_offsets->m_player.m_max_speed );
	OFFSET( int, money, g.m_offsets->m_player.m_money );
	OFFSET( float, next_attack, g.m_offsets->m_player.m_next_attack );
	OFFSET( bool, night_vision_enabled, g.m_offsets->m_player.m_night_vision_enabled );
	OFFSET( int, observer_target, g.m_offsets->m_player.m_observer_target );
	OFFSET( int, shots_fired, g.m_offsets->m_player.m_shots_fired );
	OFFSET( int, smoke_grenade_tick_begin, g.m_offsets->m_player.m_smoke_grenade_tick_begin );
	OFFSET( int, tick_base, g.m_offsets->m_player.m_tick_base );
	OFFSET( vec3_t, velocity, g.m_offsets->m_player.m_velocity );
	OFFSET( void *, view_model, g.m_offsets->m_player.m_view_model );
	OFFSET( bool, has_night_vision, g.m_offsets->m_player.m_has_night_vision );
	OFFSET( float, old_sim_time, g.m_offsets->m_player.m_simulation_time + 4 );
};
class inferno_t : public entity_t {
public:
	OFFSET(int, m_thrower, g.m_offsets->m_player.m_hOwnerEntity);
	OFFSETPTR(int, m_fire_x, g.m_offsets->m_player.m_fire_x);
	OFFSETPTR(int, m_fire_y, g.m_offsets->m_player.m_fire_y);
	OFFSETPTR(int, m_fire_z, g.m_offsets->m_player.m_fire_z);
	OFFSETPTR(bool, m_fire_burning, g.m_offsets->m_player.m_fire_burning);
	OFFSET(int, m_fire_count, g.m_offsets->m_player.m_fire_count);
};
```

`solace-csgo/player_manager.cpp`:

```cpp
#include "player_manager.h"

#include "bones.h"
#include "resolver.h"
#include "thread_handler.h"

player_record_t::~player_record_t()
{
    // free heap allocated game mem.
    g.m_interfaces->mem_alloc()->free(m_bones);
    for (auto pObj = m_fake_bones.begin(); pObj != m_fake_bones.end(); ++pObj)
        g.m_interfaces->mem_alloc()->free(*pObj);
    m_fake_bones.clear();
    m_resolver_data.m_dir_data.clear();
}

void player_record_t::cache(int index) const
{
    // get bone cache ptr.
    auto* const cache = &m_ent->bone_cache();

    if (index == -1)
        cache->m_pCachedBones = m_bones;
    else
        cache->m_pCachedBones = m_fake_bones[index];
    cache->m_CachedBoneCount = 128;

    m_ent->last_bone_setup_time() = FLT_MAX;
    m_ent->origin() = m_pred_origin;
    m_ent->mins() = m_mins;
    m_ent->maxs() = m_maxs;

    m_ent->set_abs_angles(m_abs_angles);
    m_ent->set_abs_origin(m_pred_origin);
}

bool player_record_t::valid() const
{
    if (!g.m_interfaces->client_state()->m_NetChannel)
        return false;
    // use prediction curtime for this.
    float curtime = g.ticks_to_time(g.m_local->tick_base());
    static auto* sv_maxunlag = g.m_interfaces->console()->get_convar("sv_maxunlag");
    if (floorf(curtime - sv_maxunlag->GetFloat()) > g.ticks_to_time(m_tick))
        return false;

    // correct is the amount of time we have to correct game time,
    float correct = g.m_lerp;

    // stupid fake latency goes into the incoming latency.
    auto* nci = g.m_interfaces->engine()->get_net_channel_info();
    if (nci)
        correct += nci->GetLatency(1) + nci->GetLatency(0);
    // check bounds [ 0, sv_maxunlag ]
    correct = std::clamp<float>(correct, 0.f, sv_maxunlag->GetFloat());

    // calculate difference between tick sent by player and our latency based
    // tick. ensure this record isn't too old.
    return std::fabsf(correct - (curtime - g.ticks_to_time(m_tick))) < 0.19f;
}

// bool player_record_t::valid() const {
//	if (!m_setup)
//		return false;
//	// use prediction curtime for this.
//	static auto* sv_maxunlag =
// g.m_interfaces->console()->get_convar("sv_maxunlag"); 	auto* net =
// g.m_interfaces->engine()->get_net_channel_info();
//	//const auto curtime = g.ticks_to_time( g.m_local->tick_base( ) );
//	//
//	//// correct is the amount of time we have to correct game time,
//	//float correct = g.m_lerp;
//	//
//	//// stupid fake latency goes into the incoming latency.
//	//float in = net->GetAvgLatency( 1 );;
//	//correct += in;
//	//
//	//// check bounds [ 0, sv_maxunlag ]
//	//correct = std::clamp( correct, 0.f, sv_maxunlag->GetFloat( ) );
//	//
//	//// calculate difference between tick sent by player and our latency
// based tick.
//	//// ensure this record isn't too old.
//	//return std::abs( correct - (curtime - m_pred_time) ) <= 0.2f;
//
//	const auto tickcount = g.time_to_ticks(m_pred_time + g.m_lerp);
//
//	const auto avg_latency = net->GetAvgLatency(1) + net->GetAvgLatency(0);
//
//	int tick_delay = 1;
//	if (settings::hvh::antiaim::fakewalk)
//		tick_delay = 15 - g.m_lag;
//	const auto arrival_tick = g.m_local->tick_base() +
// g.time_to_ticks(avg_latency) + tick_delay;
//
//	const auto correct = std::clamp( g.m_lerp + net->GetLatency( 0 ), 0.f,
// sv_maxunlag->GetFloat( ) ) - g.ticks_to_time( arrival_tick + g.time_to_ticks(
// g.m_lerp ) - tickcount );
//
//	return std::abs( correct ) < 0.2f - g.m_interfaces->globals(
//)->m_interval_per_tick;
//}

player_record_t::player_record_t(ent_info_t* info, float last_sim)
{
    m_info = info;
    m_ent = info->m_ent;

    m_pred_time = m_sim_time = info->m_ent->sim_time();
    m_old_sim_time = last_sim;
    m_anim_time = m_old_sim_time + g.m_interfaces->globals()->m_interval_per_tick;
    m_lag = g.time_to_ticks(m_sim_time - m_old_sim_time);
    m_pred_origin = m_origin = info->m_ent->origin();
    m_abs_origin = info->m_ent->abs_origin();
    m_eye_angles = info->m_ent->eye_angles();
    m_maxs = info->m_ent->maxs();
    m_mins = info->m_ent->mins();
    m_duck = info->m_ent->duck_amount();
    m_duck_speed = info->m_ent->duck_speed();
    m_pred_flags = m_flags = info->m_ent->flags();
    m_setup = false;
    m_pred_velocity = m_velocity = info->m_ent->velocity();
    m_body = info->m_ent->lower_body_yaw();

    m_tick = g.m_interfaces->client_state()->m_ClockDriftMgr.m_nServerTick;
    m_ent->GetAnimLayers(m_layers);
    g.m_interfaces->mdlcache()->begin_lock();
    feet_cycle = m_layers[6].m_cycle;
    feet_yaw_rate = m_layers[6].m_weight;
    {
        auto hdr = m_ent->GetModelPtr();
        for (int i = 0; i < 15; i++)
        {
            m_layers[i].m_owner = m_ent;
            m_layers[i].m_pDispatchedStudioHdr = hdr;
        }
    }
    g.m_interfaces->mdlcache()->end_lock();
    m_ent->GetPoseParameters(m_poses);
    m_cycle = m_ent->cycle();
    m_sequence = m_ent->sequence();

    m_bones = static_cast<bone_array_t*>(g.m_interfaces->mem_alloc()->alloc(sizeof(bone_array_t) * 128));
}

template <class T> T Lerp(float flPercent, T const& A, T const& B)
{
    return A + ((B - A) * flPercent);
}

float Approach(float target, float value, float speed)
{
    float delta = target - value;

    if (delta > speed)
        value += speed;
    else if (delta < -speed)
        value -= speed;
    else
        value = target;

    return value;
}
float InvSqrt(float x)
{
    float xhalf = 0.5f * x;
    int i = *(int*)&x;              // store floating-point bits in integer
    i = 0x5f3759df - (i >> 1);      // initial guess for Newton's method
    x = *(float*)&i;                // convert new bits into float
    x = x * (1.5f - xhalf * x * x); // One round of Newton's method
    return x;
}
float ent_info_t::test_velocity(std::shared_ptr<player_record_t> record, float speed, float pVec)
{
    auto weapon = (weapon_t*)g.m_interfaces->entity_list()->get_client_entity_handle(record->m_ent->active_weapon());
    float max_speed = record->m_ent->max_speed();
    auto info = weapon ? g.m_interfaces->weapon_system()->get_weapon_data(weapon->item_definition_index()) : nullptr;
    if (info)
    {
        max_speed = info->m_max_player_speed;
    }

    float flMoveCycleRate = 1.f / speed;
    float flSequenceGroundSpeed = 0.001f;

    float ukn = 1.0 / (float)(1.f / flMoveCycleRate);
    if ((pVec * (float)(1.f / (float)(1.0f / ukn)), 2) > 0.001f)
    {
        flSequenceGroundSpeed = powf(pVec, 2.f) * ukn;
    }
    flSequenceGroundSpeed = fmaxf(flSequenceGroundSpeed, 0.001f);
    return (speed / flSequenceGroundSpeed) * flMoveCycleRate;
}
inline float SimpleSpline(float value)
{
    float valueSquared = value * value;

    // Nice little ease-in, ease-out spline-like curve
    return (3 * valueSquared - 2 * valueSquared * value);
}
// remaps a value in [startInterval, startInterval+rangeInterval] from linear to
// spline using SimpleSpline
inline float SimpleSplineRemapValClamped(float val, float A, float B, float C, float D)
{
    if (A == B)
        return val >= B ? D : C;
    float cVal = (val - A) / (B - A);
    cVal = std::clamp<float>(cVal, 0.0f, 1.0f);
    return C + (D - C) * SimpleSpline(cVal);
}
float ent_info_t::solve_velocity_len(std::shared_ptr<player_record_t> record)
{
    auto weapon = (weapon_t*)g.m_interfaces->entity_list()->get_client_entity_handle(record->m_ent->active_weapon());
    float max_speed = 260.0f;
    auto info = weapon ? g.m_interfaces->weapon_system()->get_weapon_data(weapon->item_definition_index()) : nullptr;
    if (info)
    {
        max_speed = fmaxf(0.001f, info->m_max_player_speed);
    }

    float comp_value = record->m_layers[ANIMATION_LAYER_ALIVELOOP].m_weight;
    if (comp_value == 0.f)
        return -1;
    float best = -1;
    float closest = -1;

    for (float i = 0.f; i < max_speed; i += 0.5f)
    {
        float val = SimpleSplineRemapValClamped(i / max_speed, 0.55f, 0.9f, 1.0f, 0.f);
        if (closest == -1 || fabsf(comp_value - val) < best)
        {
            best = fabsf(comp_value - val);
            closest = i;
        }
    }

    return closest;

    auto state = record->m_ent->get_anim_state();
    if (!state)
        return record->m_anim_velocity.length();
    float cycle_dif = record->m_layers[6].m_playback_rate;
    if (cycle_dif == 0.f)
    {
        if (record->m_layers[6].m_cycle >= 0.999f)
        {
            return (record->m_anim_velocity.length_2d_sqr() != 0.f) ? record->m_anim_velocity.length_2d() : 0.f;
        }
        return 0.f;
    }

    float flMoveCycleRate = cycle_dif / g.ticks_to_time(record->m_lag);
    float walk_to_run_max = 1;
    float walk_to_run_min = 0.f;
    float walk_to_run = 0;
    bool switch_1 = false;
    static auto sv_friction = g.m_interfaces->console()->get_convar("sv_friction");
    const auto friction = sv_friction->GetFloat() * g.m_local->surface_friction();
    // while (fabsf(walk_to_run_max - walk_to_run_min) > 0.00001) {
    //	float test = ((walk_to_run_max - walk_to_run_min) / 2) +
    // walk_to_run_min;
    //
    //	float min_dif = fabsf(Lerp(walk_to_run_min, 1.f, 0.14999998f *
    //*(float*)(state + 284)) - flMoveCycleRate); 	float max_dif =
    // fabsf(Lerp(walk_to_run_max, 1.f, 0.14999998f * *(float*)(state + 284)) -
    // flMoveCycleRate);
    //
    //	if (min_dif > max_dif) {
    //		walk_to_run = test;
    //		walk_to_run_min = test;
    //	}
    //	else if (min_dif < max_dif) {
    //		walk_to_run = test;
    //		walk_to_run_max = test;
    //	}
    //	else {
    //		float dif = fabsf(Lerp(test, 1.f, 0.14999998f * *(float*)(state +
    // 284)) - flMoveCycleRate); 		float test_2 = ((walk_to_run_max - test) / 2) +
    // walk_to_run_min;
    //
    //		float dif_2 = fabsf(Lerp(test_2, 1.f, 0.14999998f * *(float*)(state
    //+ 284)) - flMoveCycleRate);
    //
    //		if (dif > dif_2) {
    //			walk_to_run = test_2;
    //			walk_to_run_min = test;
    //			continue;
    //		}
    //
    //		test_2 = ((test - walk_to_run_min) / 2) + test;
    //		float idk = flMoveCycleRate / Lerp(test_2, 1.f, 0.14999998f *
    //*(float*)(state + 284)); 		dif_2 = fabsf(Lerp(test_2, 1.f, 0.14999998f *
    //*(float*)(state + 284) ) - flMoveCycleRate);
    //
    //		if (dif > dif_2) {
    //			walk_to_run = test_2;
    //			walk_to_run_max = test;
    //			continue;
    //		}
    //		break;
    //	}
    //}
    // float best_2 = -1;
    // float test_2 = walk_to_run_min;
    // while (test_2 <= walk_to_run_max)
    //{
    //	float val = fabsf(Lerp(test_2, 1.f, 0.14999998f * *(float*)(state +
    // 284)) - flMoveCycleRate); 	if (best_2 == -1 || val < best_2) { 		walk_to_run =
    // test_2; 		best_2 = val;
    //	}
    //	test_2 += 0.000005f;
    //}

    // auto state = record->m_ent->get_anim_state();

    // float m_flAnimDuckAmount = std::clamp(Approach(std::clamp(record->m_duck +
    // *(float*)(state + 0xA8), 0.f, 1.f), *(float*)(state + 164),
    // g.ticks_to_time(record->m_lag) * 6.0f), 0.f, 1.f);

    // record->m_poses[(int)PoseParam_t::MOVE_BLEND_WALK] = (1.0f - walk_to_run) *
    // (1.0f - m_flAnimDuckAmount);
    // record->m_poses[(int)PoseParam_t::MOVE_BLEND_RUN] = (walk_to_run) * (1.0f -
    // m_flAnimDuckAmount); record->m_poses[(int)PoseParam_t::MOVE_BLEND_CROUCH] =
    // m_flAnimDuckAmount;

    auto hdr = record->m_ent->GetModelPtr();
    if (!hdr)
    {
        return (record->m_anim_velocity.length_2d_sqr() != 0.f) ? record->m_anim_velocity.length_2d() : 0.f;
    }
    // if (flMoveCycleRate == 0)
    //	return 0;
    // return 1 / flMoveCycleRate;

    int nWeaponMoveSeq = record->m_layers[6].m_sequence;

    float m_flWalkToRunTransition = *(float*)(record->m_ent->get_anim_state() + 284);

    bool set = (*(BYTE*)(record->m_ent->get_anim_state() + 308)) == 1;
    if (m_flWalkToRunTransition > 0 && m_flWalkToRunTransition < 1)
    {
        // currently transitioning between walk and run
        if (set)
        {
            m_flWalkToRunTransition += g.ticks_to_time(record->m_lag) * 2.f;
        }
        else // m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK
        {
            m_flWalkToRunTransition -= g.ticks_to_time(record->m_lag) * 2.f;
        }
        m_flWalkToRunTransition = std::clamp(m_flWalkToRunTransition, 0.f, 1.f);
    }

    if (!set)
        m_flWalkToRunTransition = fmaxf(0.99f, m_flWalkToRunTransition);

    float m_flAnimDuckAmount =
        std::clamp(Approach(std::clamp(record->m_duck + *(float*)(record->m_ent->get_anim_state() + 168), 0.f, 1.f),
                            *(float*)(record->m_ent->get_anim_state() + 164), g.ticks_to_time(record->m_lag) * 6.0f),
                   0.f, 1.f);

    record->m_poses[(int)PoseParam_t::MOVE_BLEND_WALK] = (1.0f - m_flWalkToRunTransition) * (1.0f - m_flAnimDuckAmount);
    record->m_poses[(int)PoseParam_t::MOVE_BLEND_RUN] = (m_flWalkToRunTransition) * (1.0f - m_flAnimDuckAmount);
    record->m_poses[(int)PoseParam_t::AIM_BLEND_CROUCH_WALK] = m_flAnimDuckAmount;

    vec3_t pVec1;
    pVec1 = record->m_ent->GetSequenceLinearMotion(hdr, nWeaponMoveSeq, record->m_poses);
    for (auto i = 0; i < 3; i++)
        if (isnan(fabsf(pVec1[i])))
            return (record->m_anim_velocity.length_2d_sqr() != 0.f) ? record->m_anim_velocity.length_2d() : 0.f;

    float m_flWalkToRunTransition_1 = *(float*)(record->m_ent->get_anim_state() + 284);

    set = (*(BYTE*)(record->m_ent->get_anim_state() + 308)) == 1;
    if (m_flWalkToRunTransition_1 > 0 && m_flWalkToRunTransition_1 < 1)
    {
        // currently transitioning between walk and run
        if (set)
        {
            m_flWalkToRunTransition_1 += g.ticks_to_time(record->m_lag) * 2.f;
        }
        else // m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK
        {
            m_flWalkToRunTransition_1 -= g.ticks_to_time(record->m_lag) * 2.f;
        }
        m_flWalkToRunTransition_1 = std::clamp(m_flWalkToRunTransition_1, 0.f, 1.f);
    }
    if (set)
        m_flWalkToRunTransition_1 = fmaxf(0.01f, m_flWalkToRunTransition_1);

    record->m_poses[(int)PoseParam_t::MOVE_BLEND_WALK] =
        (1.0f - m_flWalkToRunTransition_1) * (1.0f - m_flAnimDuckAmount);
    record->m_poses[(int)PoseParam_t::MOVE_BLEND_RUN] = (m_flWalkToRunTransition_1) * (1.0f - m_flAnimDuckAmount);

    vec3_t pVec2;
    pVec2 = record->m_ent->GetSequenceLinearMotion(hdr, nWeaponMoveSeq, record->m_poses);
    for (auto i = 0; i < 3; i++)
        if (isnan(fabsf(pVec1[i])))
            return (record->m_anim_velocity.length_2d_sqr() != 0.f) ? record->m_anim_velocity.length_2d() : 0.f;

    float pVec_len = pVec1.length();
    float pVec1_len = pVec2.length();

    float vel_x_y = 0.f;
    // float min_x_y = 0.1f - FLT_MIN;
    float max_x_y = 300.f;
    double test_1 = 0.1 - 0.01;
    while (test_1 <= max_x_y)
    {
        float w =
            flMoveCycleRate /
            (float)(1.0 - (float)((test_1 > 135.2) ? m_flWalkToRunTransition : m_flWalkToRunTransition_1) * 0.14999998);
        float val = test_velocity(record, test_1, (test_1 > 135.2) ? pVec1_len : pVec_len);
        if (val != -1)
        {
            const auto comp = fabsf(val - w);

            if (best == -1 || comp < best)
            {
                vel_x_y = test_1;
                best = comp;
            }
        }

        test_1 += 0.01;
    }

    // while (true) {
    //	test_1 = (max_x_y - min_x_y) / 2;
    //	test_1 += min_x_y;
    //	float test_2[2] = { (max_x_y - test_1) / 2, (test_1 - min_x_y) / 2 };
    //	test_2[0] += test_1;
    //	test_2[1] += min_x_y;
    //
    //	float val = test_velocity(record, test_1, (test_1 > 135.2) ? pVec1_len :
    // pVec_len); 	if( val == -1 ) 		return (record->m_anim_velocity.length_2d_sqr()
    //!= 0.f) ? record->m_anim_velocity.length_2d() : 0.f;
    //
    //	float comp = fabsf(val - w);
    //	if (comp <= 0.001f)
    //		return test_1;
    //
    //	val = test_velocity(record, test_2[0], (test_2[0] > 135.2) ? pVec1_len :
    // pVec_len); 	if (val == -1) 		return (record->m_anim_velocity.length_2d_sqr() !=
    // 0.f) ? record->m_anim_velocity.length_2d() : 0.f;
    //
    //	if (fabsf(val - w) < comp) {
    //		min_x_y = test_1;
    //	}
    //	else {
    //		val = test_velocity(record, test_2[1], (test_2[1] > 135.2) ?
    // pVec1_len : pVec_len); 		if (val == -1) 			return
    //(record->m_anim_velocity.length_2d_sqr() != 0.f) ?
    // record->m_anim_velocity.length_2d() : 0.f; 		if (fabsf(val - w) < comp)
    //		{
    //			max_x_y = test_1;
    //		}
    //		else {
    //			return test_1;
    //		}
    //	}
    //}

    if (best == -1)
        return (record->m_anim_velocity.length_2d_sqr() != 0.f) ? record->m_anim_velocity.length_2d() : 0.f;
    return vel_x_y;

    // while (max_x_y - min_x_y > 1) {
    //	float flSequenceGroundSpeed = 0.001f;
    //	float speed_est = ((max_x_y - min_x_y) / 2) + min_x_y;
    //	//float comp = fabsf((flMoveCycleRate / test(speed_est, pVec)) -
    // speed_est);
    //
    //	float min_dif = fabsf((flMoveCycleRate / test(max_x_y, pVec)) -
    // max_x_y); 	float max_dif = fabsf((flMoveCycleRate / test(min_x_y, pVec)) -
    // min_x_y);
    //
    //	if (min_dif > max_dif) {
    //		min_x_y = speed_est;
    //		vel_x_y = speed_est;
    //	}
    //	else if (min_dif < max_dif) {
    //		vel_x_y = speed_est;
    //		max_x_y = speed_est;
    //	}
    //	else {
    //		float dif = fabsf((flMoveCycleRate / test(speed_est, pVec)) -
    // speed_est); 		float new_speed = ((max_x_y - speed_est) / 2) + speed_est; 		float
    // dif_2 = fabsf((flMoveCycleRate / test(new_speed, pVec)) - new_speed);
    //
    //		if (dif > dif_2) {
    //			min_x_y = speed_est;
    //			vel_x_y = new_speed;
    //			continue;
    //		}
    //
    //		new_speed = ((speed_est - min_x_y) / 2) + min_x_y;
    //		dif_2 = fabsf((flMoveCycleRate / test(new_speed, pVec)) -
    // max_x_y);
    //
    //		if (dif > dif_2) {
    //			max_x_y = speed_est;
    //			vel_x_y = new_speed;
    //			continue;
    //		}
    //		break;
    //	}
    //
    //
    //}
}

void ent_info_t::UpdateAnimations(std::shared_ptr<player_record_t> record)
{
    auto* state = m_ent->get_anim_state();
    if (!state)
        return;

    // player respawned.
    if (m_ent->spawn_time() != m_spawn)
    {
        memset(&m_ik, 0, sizeof(CIKContext));
        m_ik.init();
        // reset animation state.
        state->ResetAnimationState();

        // note new spawn time.
        m_spawn = m_ent->spawn_time();

        for (auto& i : m_resolver_data.m_states)
        {
            memcpy(&i, state, sizeof(anim_state));
        }
    }

    // backup stuff that we do not want to fuck with.
    animation_backup_t backup;

    backup.m_origin = m_ent->origin();
    backup.m_abs_origin = m_ent->abs_origin();
    backup.m_velocity = m_ent->velocity();
    backup.m_abs_velocity = m_ent->abs_vel();
    backup.m_flags = m_ent->flags();
    backup.m_eflags = m_ent->iEFlags();
    backup.m_duck = m_ent->duck_amount();
    backup.m_body = m_ent->lower_body_yaw();
    m_ent->GetAnimLayers(backup.m_layers);
    m_ent->GetPoseParameters(backup.m_poses);

    const auto bot = m_fake_player;

    // fix velocity.
    // https://github.com/VSES/SourceEngine2007/blob/master/se2007/game/client/c_baseplayer.cpp#L659
    if (record->m_lag > 0 && record->m_lag < 16 && m_records.size() >= 2)
    {
        // get pointer to previous record.
        auto const& previous = m_records[1];

        if (previous && !previous->m_dormant)
        {
            record->m_velocity = (record->m_origin - previous->m_origin) * (1.f / g.ticks_to_time(record->m_lag));
            // float m_flAccelerationWeight = record->m_layers[ 12 ].m_weight;
            // float prev = previous->m_origin.length_sqr();
            // float weapon_speed = 260.f;
            // auto weapon = static_cast< weapon_t* >( g.m_interfaces->entity_list(
            // )->get_client_entity_handle( m_ent->active_weapon( ) ) );; if ( weapon
            // ) { 	weapon_speed = max( 0.001, weapon->get_max_speed( ) );
            //}
            // if ( m_flAccelerationWeight != 0 ) {
            //	auto dir = record->m_velocity - previous->m_velocity;
            //	record->m_velocity = record->m_velocity.normalized( ) * ( sqrtf(
            // prev ) + sqrtf( 1040 * fminf( 0.1f, record->m_sim_time -
            // record->m_old_sim_time ) * weapon_speed * m_flAccelerationWeight + prev
            //) ) * 0.5f;
            //}
        }
    }
    // set this fucker, it will get overriden.
    record->m_anim_velocity = record->m_velocity;

    // fix various issues with the game eW91dHViZS5jb20vZHlsYW5ob29r
    // these issues can only occur when a player is choking data.
    // if ((record->m_flags & fl_onground) && !m_teamate) {
    // g.m_interfaces->mdlcache()->begin_lock();
    // vec3_t w;
    // if (record->m_anim_velocity.length_2d_sqr() != 0)
    //	w = record->m_anim_velocity.normalized();
    // else
    //	w = { 0.5,0.5, 0 };
    // float speed = solve_velocity_len(record);
    // if( speed >= 0.f )
    //	record->m_anim_velocity = vec3_t(w.x * speed, w.y * speed,
    // record->m_anim_velocity.z); g.m_interfaces->mdlcache()->end_lock();
    //}
    if (record->m_lag > 1 && !bot)
    {
        auto speed = record->m_velocity.length();
        if (speed > 0.1f && record->m_layers[6].m_cycle == 0.0f && (record->m_flags & fl_onground))
            record->m_fake_walk = true;

        // detect players abusing micromovements or other trickery
        // record->m_fake_walk = record->m_layers[6].m_playback_rate == 0.f;
        if (record->m_fake_walk)
            record->m_anim_velocity = vec3_t(0, 0, 0);
        // we need atleast 2 updates/records
        // to fix these issues.
        if (m_records.size() >= 2 && m_records[1])
        {
            if (speed < 20.f && record->m_layers[6].m_weight != 1.0f && record->m_layers[6].m_weight != 0.0f &&
                record->m_layers[6].m_weight != m_records[1]->m_layers[6].m_weight && (record->m_flags & fl_onground))
                record->m_ukn_vel = true;
            // auto weapon = ( weapon_t* )g.m_interfaces->entity_list(
            // )->get_client_entity_handle( record->m_ent->active_weapon( ) ); auto
            // max_speed = 260.f; if ( weapon ) { 	auto data =
            // g.m_interfaces->weapon_system( )->get_weapon_data(
            // weapon->item_definition_index( ) ); 	if ( data )
            // max_speed = fmaxf( data->m_max_player_speed, 0.001f );
            //}
            // float temp = ( max_speed * 0.52f );
            // if ( temp > 0.f ) {
            //	float walk_speed = 1.1f / temp;
            //	float max_dist = ( 1.f - ( 2.f * g.ticks_to_time( record->m_lag
            //) ) ) - walk_speed; 	if ( speed < 40.f
            //		&& record->m_layers[ 6 ].m_weight != 1.0f
            //		&& record->m_layers[ 6 ].m_weight != 0.0f
            //		&& fabsf( record->m_layers[ 6 ].m_weight - walk_speed )
            //> max_dist
            //		&& ( record->m_flags & fl_onground ) )
            //		record->m_ukn_vel = true;
            //}
            if (record->m_ukn_vel)
                record->m_anim_velocity = vec3_t(0, 0, 0);
            // get pointer to previous record.
            auto const& previous = m_records[1];

            if (previous && !previous->m_dormant)
            {
                // strip the on ground flag.
                m_ent->flags() &= ~fl_onground;

                //float flLandTime = 0.0f;
                //bool bLandedOnServer = false;
                //if (record->m_layers[4].m_cycle != previous->m_layers[4].m_cycle &&
                //    record->m_layers[5].m_cycle != previous->m_layers[5].m_cycle && record->m_layers[5].m_cycle != 0)
                //{
                //    m_ent->flags() |= fl_onground;
                //}
                //else if (record->m_layers[4].m_cycle != previous->m_layers[4].m_cycle &&
                //         record->m_layers[5].m_cycle == previous->m_layers[5].m_cycle)
                //{
                //    m_ent->flags() &= ~fl_onground;
                //}

                
			    float flLandTime = 0.0f;
                bool bJumped = false;
                bool bLandedOnServer = false;
                if (record->m_layers[4].m_cycle< 0.5f &&
                    (!(record->m_flags & fl_onground) || !(previous->m_flags & fl_onground)))
                {
                    // note - VIO (violations btw);
                    // well i guess when llama wrote v3, he was drunk or sum cuz this is incorrect. -> cuz he changed
                    // this in v4. and alpha didn't realize this but i did, so its fine. improper way to do this ->
                    // flLandTime = record->m_flSimulationTime - float( record->m_serverAnimOverlays[ 4
                    // ].m_flPlaybackRate * record->m_serverAnimOverlays[ 4 ].m_flCycle ); we need to divide instead of
                    // multiplication.
                    flLandTime = record->m_sim_time -
                                 float(record->m_layers[4].m_playback_rate / record->m_layers[4].m_playback_rate);
                    bLandedOnServer = flLandTime >= previous->m_sim_time;
                }

                bool bOnGround = record->m_flags & fl_onground;
                // jump_fall fix
                if (bLandedOnServer && !bJumped)
                {
                    if (flLandTime <= record->m_anim_time)
                    {
                        bJumped = true;
                        bOnGround = true;
                    }
                    else
                    {
                        bOnGround = previous->m_flags & fl_onground;
                    }
                }

                // fix crouching players.
                // the duck amount we receive when people choke is of the last
                // simulation. if a player chokes packets the issue here is that we will
                // always receive the last duckamount. but we need the one that was
                // animated. therefore we need to compute what the duckamount was at
                // animtime.

                // delta in duckamt and delta in time..
                const auto duck = record->m_duck - previous->m_duck;
                float time = record->m_sim_time - previous->m_sim_time;

                // fix crouching players.
                m_ent->duck_amount() = std::clamp<float>(
                    previous->m_duck +
                        std::copysignf(previous->m_duck_speed * g.m_interfaces->globals()->m_interval_per_tick, duck),
                    0.f, 1.f);

                if (!record->m_fake_walk && !record->m_ukn_vel)
                {
                    // fix the velocity till the moment of animation.
                    vec3_t velo = record->m_velocity - previous->m_velocity;

                    // accel per tick.
                    vec3_t accel = (velo / time) * g.m_interfaces->globals()->m_interval_per_tick;

                    // set the anim velocity to the previous velocity.
                    // and predict one tick ahead.
                    record->m_anim_velocity = previous->m_velocity + accel;
                }
            }
        }
    }

    // set stuff before animating.
    m_ent->origin() = record->m_origin;
    m_ent->velocity() = m_ent->abs_vel() = record->m_anim_velocity;
    m_ent->lower_body_yaw() = record->m_body;

    // write potentially resolved angles.

    // for ( auto i = 0; i < info->m_lag; i++ ) {
    //
    //	//console::log(("cycle " + std::to_string(record->m_layers[6].m_cycle) +
    //"\n").c_str());
    //	//console::log(("m_playback_rate " +
    // std::to_string(info->m_layers[6].m_playback_rate) + "\n").c_str());
    //	//console::log(("sequence " +
    // std::to_string(info->m_layers[6].m_sequence) + "\n").c_str());
    //	//console::log(("m_weight " + std::to_string(info->m_layers[6].m_weight)
    //+ "\n").c_str());
    //	//console::log(("yaw " + std::to_string(record->m_eye_angles.y) +
    //"\n").c_str());
    //
    //	// 'm_animating' returns true if being called from SetupVelocity, passes
    // raw velocity to animstate.
    //
    //auto backup_overlay_count = m_ent->anim_overlay_vec().Count();
    //m_ent->anim_overlay_vec().m_Size = (0);

    m_ent->eye_angles() = record->m_eye_angles;
    m_ent->client_side_anim() = true;
    {
        std::unique_lock<std::mutex> lock(g_thread_handler.queue_mutex);
        // backup curtime.
        const auto curtime = g.m_interfaces->globals()->m_curtime;
        const auto frametime = g.m_interfaces->globals()->m_frametime;

        g.m_interfaces->globals()->m_curtime = record->m_anim_time;
        g.m_interfaces->globals()->m_frametime = g.m_interfaces->globals()->m_interval_per_tick;

        if (!m_teamate)
        {
            g_resolver.resolve(*this, record);
            state->feetYawRate = 0.f;

            resolver_data::mode_data* mode_data = nullptr;
            bool lby_or_move = (!record->m_body_reliable && record->m_mode == resolver::RESOLVE_BODY) ||
                               record->m_mode == resolver::RESOLVE_WALK;
            if (lby_or_move)
            {
                mode_data = &m_resolver_data.m_mode_data[resolver_data::LBY_MOVING];
                float val = 30.f;
                if (record->m_mode == resolver::RESOLVE_WALK)
                    val += 20.f;

                record->m_resolver_data.m_dir_data.emplace_back(record->m_body);
                record->m_resolver_data.m_dir_data.emplace_back(record->m_body + val);
                record->m_resolver_data.m_dir_data.emplace_back(record->m_body - val);
            }
            else if (record->m_mode == resolver::RESOLVE_STAND1)
                mode_data = &m_resolver_data.m_mode_data[resolver_data::STAND1];
            else if (record->m_mode == resolver::RESOLVE_STAND2)
                mode_data = &m_resolver_data.m_mode_data[resolver_data::STAND2];

            anim_state backup_anim_state{};
            std::memcpy(&backup_anim_state, state, sizeof(anim_state));
            anim_state index_state{};
            bool index_found = false;
            if (mode_data && record->m_resolver_data.m_dir_data.size() == mode_data->m_dir_data.size())
            {
                for (uint32_t i = 0; i < mode_data->m_dir_data.size(); i++)
                {
                    auto& record_dir_data = record->m_resolver_data.m_dir_data[i];
                    std::memcpy( state, &m_resolver_data.m_states[ i ], sizeof(anim_state));

                    m_ent->eye_angles().y = math::normalize_angle(record_dir_data.angles, 180);

                    if (state->m_frame >= g.m_interfaces->globals()->m_framecount)
                        state->m_frame = g.m_interfaces->globals()->m_framecount - 1;
                    if (m_records.size() >= 2 && m_records[1])
                    {
                        state->feetYawRate = m_records[1]->feet_yaw_rate;
                        state->feetCycle = m_records[1]->feet_cycle;

                        m_ent->SetAnimLayers(record->m_layers);
                    }
                    else
                    {
                        state->feetYawRate = record->feet_yaw_rate;
                        state->feetCycle = record->feet_cycle;

                        m_ent->SetAnimLayers(record->m_layers);
                    }
                    //m_ent->iEFlags() &= ~0x1000;
                    m_ent->update_client_side_animation();

                    m_ent->GetPoseParameters(record_dir_data.poses);
                    record_dir_data.m_abs_angles = m_ent->abs_angles();

                    std::memcpy( &m_resolver_data.m_states[ i ], state, sizeof( anim_state ) );

                    if (mode_data->m_index == i)
                    {
                        record->m_abs_angles = m_ent->abs_angles();
                        index_found = true;
                        std::memcpy(&index_state, state, sizeof(anim_state));
                        m_ent->GetPoseParameters(record->m_poses);
                    }

                    memcpy(state, &backup_anim_state, sizeof(anim_state));
                    m_ent->SetPoseParameters(backup.m_poses);
                    m_ent->SetAnimLayers(backup.m_layers);
                }
            }
            if (index_found)
            {
                std::memcpy(state, &index_state, sizeof(anim_state));
            }
            else
            {
                m_ent->eye_angles() = record->m_eye_angles;
                if (state->m_frame >= g.m_interfaces->globals()->m_framecount)
                    state->m_frame = g.m_interfaces->globals()->m_framecount - 1;
                if (m_records.size() >= 2 && m_records[1])
                {
                    state->feetYawRate = m_records[1]->feet_yaw_rate;
                    state->feetCycle = m_records[1]->feet_cycle;

                    m_ent->SetAnimLayers(record->m_layers);
                }
                else
                {
                    state->feetYawRate = record->feet_yaw_rate;
                    state->feetCycle = record->feet_cycle;

                    m_ent->SetAnimLayers(record->m_layers);
                }

                //m_ent->iEFlags() &= ~0x1000;
                m_ent->update_client_side_animation();
                record->m_abs_angles = m_ent->abs_angles();
                // store updated/animated poses and rotation in lagrecord.
                m_ent->GetPoseParameters(record->m_poses);
                m_ent->SetAnimLayers(backup.m_layers);
            }
        }
        else
        {
            m_ent->eye_angles() = record->m_eye_angles;
            if (state->m_frame >= g.m_interfaces->globals()->m_framecount)
                state->m_frame = g.m_interfaces->globals()->m_framecount - 1;

            if (m_records.size() >= 2 && m_records[1])
            {
                state->feetYawRate = m_records[1]->feet_yaw_rate;
                state->feetCycle = m_records[1]->feet_cycle;

                m_ent->SetAnimLayers(record->m_layers);
            }
            else
            {
                state->feetYawRate = record->feet_yaw_rate;
                state->feetCycle = record->feet_cycle;

                m_ent->SetAnimLayers(record->m_layers);
            }

            //m_ent->iEFlags() &= ~0x1000;
            m_ent->update_client_side_animation();
            record->m_abs_angles = m_ent->abs_angles();
            // store updated/animated poses and rotation in lagrecord.
            m_ent->GetPoseParameters(record->m_poses);
            m_ent->SetAnimLayers(backup.m_layers);
        }

        g.m_interfaces->globals()->m_curtime = curtime;
        g.m_interfaces->globals()->m_frametime = frametime;
    }
    //m_ent->anim_overlay_vec().m_Size = (backup_overlay_count);
    m_ent->client_side_anim() = false;
    //}

    // restore backup data.
    m_ent->origin() = backup.m_origin;
    m_ent->velocity() = backup.m_velocity;
    m_ent->abs_vel() = backup.m_abs_velocity;
    m_ent->flags() = backup.m_flags;
    m_ent->iEFlags() = backup.m_eflags;
    m_ent->duck_amount() = backup.m_duck;
    m_ent->lower_body_yaw() = backup.m_body;
    m_ent->set_abs_origin(backup.m_abs_origin);
    m_ent->SetAnimLayers(backup.m_layers);
    m_ent->SetPoseParameters(backup.m_poses);
}

float player_record_t::set_lerped_time(player_record_t* prev, player_record_t* next)
{
    static auto sv_lagpushticks = g.m_interfaces->console()->get_convar("sv_lagpushticks");
    int tick = g.time_to_ticks(m_sim_time + g.m_lerp);
    float target_time = g.ticks_to_time(tick) - g.m_lerp;
    target_time += g.ticks_to_time(sv_lagpushticks->GetInt());
    float delta = (target_time - m_sim_time);
    if ( delta > 0.f )
    {
        if (prev->m_sim_time <= m_sim_time)
            return 0.f;
        if (target_time >= prev->m_sim_time)
            return 0.f;

        // calc fraction between both records
        float frac = (target_time - m_sim_time) / (prev->m_sim_time - m_sim_time);

        if (frac <= 0.f || frac >= 1.f)
            return 0.f;

        m_eye_angles = Lerp(frac, m_abs_angles, prev->m_abs_angles);
        m_pred_origin = Lerp(frac, m_origin, prev->m_origin);
        m_mins = Lerp(frac, m_mins, prev->m_mins);
        m_maxs = Lerp(frac, m_maxs, prev->m_maxs);
    }
    else if (delta < 0)
    {
        if (prev->m_sim_time >= m_sim_time)
            return 0.f;
        if (target_time <= prev->m_sim_time)
            return 0.f;
        // calc fraction between both records
        float frac = (m_sim_time - target_time) / (m_sim_time - next->m_sim_time);

        if (frac <= 0.f || frac >= 1.f)
            return 0.f;

        m_eye_angles = Lerp(frac, next->m_abs_angles, m_abs_angles);
        m_pred_origin = Lerp(frac, next->m_origin, m_origin);
        m_mins = Lerp(frac, next->m_mins, m_mins);
        m_maxs = Lerp(frac, next->m_maxs, m_maxs);
    }
    return delta;
}

void ent_info_t::update(player_t* ent)
{
    m_ent = ent;
    m_teamate = ent->on_team(g.m_local);

    m_dormant = ent->dormant();

    if (m_dormant)
    {
        m_walk_record.m_sim_time = 0.0f;
        auto insert = true;

        // we have any records already?
        if (!m_records.empty())
        {
            auto const front = m_records.front();

            // we already have a dormancy separator.
            if (front && front->m_dormant)
                insert = false;
        }

        if (insert)
        {
            // add new record.
            auto rec = std::make_shared<player_record_t>(this, 0);
            rec->m_dormant = true;
            m_records.push_front(rec);
        }
    }

    float last_sim = 0;
    auto update = m_records.empty() || !m_records[0];
    if (!update)
    {
        last_sim = m_records.front()->m_sim_time;
        update = last_sim < ent->sim_time();
    }

    if (update)
    {
        m_setup = false;

        // g_thread_handler.queue_mutex.lock( );
        m_records.push_front(std::make_shared<player_record_t>(this, last_sim));
        // g_thread_handler.queue_mutex.unlock( );

        auto& current = m_records.front();
        
        current->m_dormant = false;
        UpdateAnimations(current);

        if (!m_teamate)
        {
            if (m_records.size() > 2 && m_records[1] && !m_records[1]->m_dormant && m_records[2] &&
                !m_records[2]->m_dormant)
            {
                auto last = m_records[1];
                float lerp_delta = last->set_lerped_time(current.get(), m_records[2].get());
                if (lerp_delta > 0 || lerp_delta < 0)
                {
                    animation_layer_t backup_layers[15];
                    memcpy(backup_layers, last->m_layers, sizeof(last->m_layers));
                    bool setup = true;
                    if (((!last->m_body_reliable && last->m_mode == resolver::RESOLVE_BODY) ||
                         last->m_mode == resolver::RESOLVE_WALK) ||
                        (last->m_mode == resolver::RESOLVE_STAND1 || last->m_mode == resolver::RESOLVE_STAND2))
                    {
                        for (auto pObj = last->m_fake_bones.begin(); pObj != last->m_fake_bones.end(); ++pObj)
                            g.m_interfaces->mem_alloc()->free(*pObj);
                        last->m_fake_bones.clear();
                        if (!build_fake_bones(last))
                            setup = false;
                    }
                    else
                    {
                        last->m_ent->SetAnimLayers(last->m_layers);
                        if (!g_bones.setup(m_ent, last->m_bones, last, &m_ik))
                            setup = false;
                    }
                    last->m_setup = setup;
                    last->m_ent->SetAnimLayers(backup_layers);
                }
            }

            auto* weapon =
                static_cast<weapon_t*>(g.m_interfaces->entity_list()->get_client_entity_handle(m_ent->active_weapon()));
            weapon_world_model_t* weapon_world_model = nullptr;
            if (weapon)
            {
                weapon_world_model = static_cast<weapon_world_model_t*>(
                    g.m_interfaces->entity_list()->get_client_entity_handle(weapon->weapon_model()));
                if (weapon_world_model)
                {
                    const auto weapon_studio_hdr = weapon_world_model->GetModelPtr();
                    if (weapon_studio_hdr)
                    {
                        for (auto i = 0; i < 15; i++)
                        {
                            auto* pLayer = &current->m_layers[i];
                            if (pLayer->m_sequence <= 1 || pLayer->m_cycle <= 0.f)
                            {
                                m_ent->UpdateDispatchLayer(pLayer, weapon_studio_hdr, pLayer->m_sequence);
                            }
                        }
                    }
                }
            }
            animation_layer_t backup_layers[15];
            memcpy(backup_layers, current->m_layers, sizeof(current->m_layers));

            if (((!current->m_body_reliable && current->m_mode == resolver::RESOLVE_BODY) ||
                 current->m_mode == resolver::RESOLVE_WALK) ||
                (current->m_mode == resolver::RESOLVE_STAND1 || current->m_mode == resolver::RESOLVE_STAND2))
            {
                m_setup = build_fake_bones(current);
            }
            else
            {
                current->m_ent->SetAnimLayers(current->m_layers);
                m_setup = g_bones.setup(m_ent, current->m_bones, current, &m_ik);
            }
            current->m_ent->SetAnimLayers(backup_layers);

        }
    }

    while (m_records.size() > 256)
        m_records.pop_back();
}

class plThreadObject
{
public:
    bool ret_state = false;
    bool read = false;
    ent_info_t* info;
    player_t* player;
    bool finished = false;
    void run();
    plThreadObject(ent_info_t* info_, player_t* player_)
    {
        info = info_;
        player = player_;
    }
};

void plThreadObject::run()
{
    info->update(player);
    finished = true;
}

void update_player()
{
}

void player_manager_t::update()
{
    if (!g.m_local)
        return;

    g_resolver.update_shots();
    m_animating = true;
    std::vector<std::shared_ptr<plThreadObject>> objects = {};
    g_thread_handler.start();
    for (auto i{1}; i <= g.m_interfaces->globals()->m_max_clients; ++i)
    {
        auto* const player = static_cast<player_t*>(g.m_interfaces->entity_list()->get_client_entity(i));
        auto* data = &m_ents[i - 1];
        data->m_valid = player && player != g.m_local && player->is_player() && player->alive();
        if (!data->m_valid)
        {
            data->m_records.clear();
            data->m_ent = nullptr;
            continue;
        }

        if (data->m_ent != player)
        {
            data->m_resolver_data.init();
            data->m_records.clear();
            // engine_player_info_t info{};
            // g.m_interfaces->engine( )->get_player_info( player->index( ), &info );
            // data->m_fake_player = info.fakeplayer;
        }
        if (data->m_spawn != player->spawn_time())
        {
            data->m_resolver_data.init();
            data->m_records.clear();
        }
        {
            objects.push_back(std::make_shared<plThreadObject>(&m_ents[i - 1], player));
            std::weak_ptr<plThreadObject> ptr = objects.back();
            g_thread_handler.QueueJob([ptr] { ptr.lock()->run(); });
        }

        // data->update( player );
    }
    while (g_thread_handler.busy())
        continue;

    g_thread_handler.stop();
    bool all_finished = true;
    while (!all_finished)
    {
        all_finished = true;
        for (auto& i : objects)
            if (!i->finished)
                all_finished = false;
    }
    // g_thread_handler.start( );
    // g_thread_handler.mutex_condition.notify_all( );
    //
    // while ( g_thread_handler.busy( ) );
    //
    //{
    //	g_thread_handler.queue_mutex2.lock( );
    //	g_thread_handler.objects.clear( );
    //	g_thread_handler.queue_mutex2.unlock( );
    //}
    //
    m_animating = false;
}

bool ent_info_t::build_fake_bones(std::shared_ptr<player_record_t> current)
{
    resolver_data::mode_data* mode_data = nullptr;

    if (current->m_mode == resolver::RESOLVE_STAND1)
        mode_data = &m_resolver_data.m_mode_data[resolver_data::STAND1];
    else if (current->m_mode == resolver::RESOLVE_STAND2)
        mode_data = &m_resolver_data.m_mode_data[resolver_data::STAND2];
    else if (((!current->m_body_reliable && current->m_mode == resolver::RESOLVE_BODY) ||
              current->m_mode == resolver::RESOLVE_WALK))
        mode_data = &m_resolver_data.m_mode_data[resolver_data::LBY_MOVING];

    if (!mode_data)
        return false;

    const auto backup_ang = current->m_abs_angles;
    float backup_poses[24];
    memcpy(backup_poses, current->m_poses, sizeof(current->m_poses));

    bool all_setup = true;

    int bone_ix = 0;
    for (auto i = 0; i < current->m_resolver_data.m_dir_data.size(); i++)
    {
        auto& record_dir_data = current->m_resolver_data.m_dir_data[i];
        memcpy(current->m_poses, record_dir_data.poses, sizeof(current->m_poses));
        // memcpy( current->m_layers, current->m_fake_layers[ i ], sizeof(
        // animation_layer_t ) * 13 ); memcpy( current->m_layers, backup_layers,
        // sizeof( animation_layer_t ) * 13 );
        current->m_abs_angles = record_dir_data.m_abs_angles;
        if (i == mode_data->m_index)
        {
            {
                if (!g_bones.setup(current->m_ent, current->m_bones, current, &m_ik))
                    all_setup = false;
            }
        }
        else
        {
            {
                current->m_fake_bones.push_back(
                    static_cast<bone_array_t*>(g.m_interfaces->mem_alloc()->alloc(sizeof(bone_array_t) * 128)));
                if (!g_bones.setup(current->m_ent, current->m_fake_bones.back(), current, &m_ik))
                    all_setup = false;
            }
            bone_ix++;
        }
        // memcpy( &m_ik, &backup_context, sizeof( CIKContext ) );
    }

    current->m_abs_angles = backup_ang;
    memcpy(current->m_poses, backup_poses, sizeof(current->m_poses));
    return all_setup;
}

void backup_record_t::store(player_t* player)
{
    // get bone cache ptr.
    bone_cache_t* cache = &player->bone_cache();

    // store bone data.
    m_last_bone_setup = player->last_bone_setup_time();
    m_bones = cache->m_pCachedBones;
    m_bone_count = cache->m_CachedBoneCount;
    m_origin = player->origin();
    m_mins = player->mins();
    m_maxs = player->maxs();
    m_abs_origin = player->abs_origin();
    m_abs_ang = player->abs_angles();
}

void backup_record_t::restore(player_t* player) const
{
    // get bone cache ptr.
    bone_cache_t* cache = &player->bone_cache();

    cache->m_pCachedBones = m_bones;
    cache->m_CachedBoneCount = m_bone_count;
    player->last_bone_setup_time() = m_last_bone_setup;
    player->origin() = m_origin;
    player->mins() = m_mins;
    player->maxs() = m_maxs;
    player->set_abs_angles(m_abs_ang);
    player->set_abs_origin(m_abs_origin);
}

```

`solace-csgo/player_manager.h`:

```h
#pragma once
#include <memory>
#include <array>
#include <deque>

#include "includes.h"
#include "animstate.h"

struct ent_info_t;
class backup_record_t {
public:
	bone_array_t *m_bones;
	int        m_bone_count;
	vec3_t     m_origin, m_abs_origin;
	vec3_t     m_mins;
	vec3_t     m_maxs;
	ang_t      m_abs_ang;
    float m_last_bone_setup;

public:
	void store( player_t* player );

	void restore( player_t* player ) const;
};
struct player_record_t {
	player_record_t( ) = default ;
	bone_array_t *m_bones = nullptr;
	player_t *m_ent = nullptr;
	ent_info_t* m_info = nullptr;
	
	bool m_setup = false;
	bool m_ukn_vel = false;
	int m_tick{};
	int m_lag = 0;
	bool m_dormant = false;
	float m_duck_speed = 0.f;
	float m_sim_time = 0.0f;
	float m_old_sim_time = 0.0f;
	float m_anim_time = 0.0f;
	float m_cycle = 0.f;
	float feet_cycle = 0.f;
	float feet_yaw_rate = 0.f;
	int m_sequence = 0;
	animation_layer_t m_layers[ 15 ]{};
	vec3_t           m_origin, m_abs_origin;
	vec3_t           m_mins, m_maxs;
	vec3_t           m_velocity;
	int              m_flags{};
	float            m_duck{}, m_body{};
	vec3_t m_anim_velocity;
	ang_t m_eye_angles, m_abs_angles;
	float            m_poses[ 24 ]{};
	bone_array_t * m_render_bones = nullptr;
	bool m_fake_walk = false;
	bool m_body_reliable = false;
	
	struct resolver_data {
		struct dir_data {
			dir_data( float angle ) {
				angles = angle;
			}
			ang_t m_abs_angles{};
			float angles{};
			float poses[ 24 ]{};
		};
		int m_index = 0;
		std::vector< dir_data > m_dir_data;
	} m_resolver_data;

	int m_mode = 0;
	bool m_body_update = false;
	float m_base_angle{};
	std::vector<bone_array_t*> m_fake_bones = {};
	
	~player_record_t ( );

	void cache( int index = -1 ) const;

	bool valid ( ) const;
    player_record_t(ent_info_t* info, float last_sim);
    float set_lerped_time(player_record_t* prev, player_record_t* next);
	// lagfix stuff.
	bool   m_broke_lc = false;
	vec3_t m_pred_origin;
	vec3_t m_pred_velocity;
	float  m_pred_time = 0.0f;
	int    m_pred_flags = 0;

	enum aim_flags {
		NONE,
		SHOT,
		PRIORITY
	};
	aim_flags m_aim_flags = NONE;
	bool m_shot = false;
};

enum hitscan_mode : int {
	prefer_safe_point = (1 << 0),
	lethal = ( 1 << 1 ),
	prefer = ( 1 << 2 )
};

struct aim_point_t {
	vec3_t m_point = vec3_t();
	int m_mode = 0;
	int m_hitbox = 0;
	vec3_t m_shoot_pos = vec3_t( );
	aim_point_t( ) = default;
	aim_point_t( vec3_t point, int mode, int hitbox ) : m_point(point), m_mode( mode ), m_hitbox(hitbox) {}
};

struct hitbox_helper_t {
	int         m_index;
	using point_helper = std::vector< aim_point_t >;
	point_helper m_points = {};
	studio_hdr_t* hdr;
	ent_info_t* info;
};


struct resolver_data {
	resolver_data( ) {};
	enum modes : int {
		STAND1,
		STAND2,
		LBY_MOVING
	};
	struct mode_data {
		struct dir_data {
			dir_data( bool dir_enabled, bool backup_enabled ) : dir_enabled( dir_enabled ), backup_enabled( backup_enabled ) {};
			bool dir_enabled = true;
			bool backup_enabled = true;
		};
		std::vector< dir_data > m_dir_data = {};
		uint32_t m_index = 0;
	} m_mode_data[ 3 ];
	std::vector<anim_state> m_states = {};

	void init( ) {
		m_missed_shots = 0;
		m_body_update = false;
		m_body_update_time = -1.f;
		m_last_body_update = 0.f;
		m_body = 0;
		m_moved = false;
		m_shots = 0;
		m_old_body = 0.f;
		float m_old_body = 0.f;
		for ( auto i = 0; i < 3; i++ ) {
			auto& mode_data = m_mode_data[ i ];

			mode_data.m_index = 0;
			mode_data.m_dir_data.clear( );
			if ( i == 0 ) {
				for ( auto k = 0; k < 7; k++ ) {
					mode_data.m_dir_data.emplace_back( true, true );
				}
			}
			else if ( i == 1 ) {
				for ( auto k = 0; k < 6; k++ ) {
					mode_data.m_dir_data.emplace_back( true, true );
				}
			}
			else for ( auto k = 0; k < 3; k++ ) {
				mode_data.m_dir_data.emplace_back( true, true );
			}
		}
		m_states.clear( );
		for ( auto k = 0; k < 11; k++ ) {
			m_states.emplace_back( );
		}
	}

	int m_missed_shots = 0;
	bool m_body_update = false;
	float m_body_update_time = -1.f;
	float m_last_body_update = 0.f;
	float m_body = 0;
	bool m_moved = false;
	int m_shots = 0;
	float m_old_body = 0.f;
};

struct ent_info_t {
	ent_info_t( ) {};

	std::deque< std::shared_ptr< player_record_t > > m_records = {};
	std::shared_ptr<player_record_t> m_selected_record = nullptr;

	bool m_manual_update = true;
	float m_damage = 0;
	vec3_t m_shoot_pos = vec3_t();
	using helper_array = std::vector< hitbox_helper_t >;
	helper_array m_hitboxes = {};
	player_t *m_ent = nullptr;
	bool m_fake_player = false;
	CIKContext m_ik;
	aim_point_t* m_aim_point{};
	player_record_t m_walk_record;
	float m_shot_wanted{};

	
	resolver_data m_resolver_data;
	bool build_fake_bones( std::shared_ptr<player_record_t> current );

	__forceinline player_t *operator->( ) const { return m_ent; }
	
	bool m_valid = false;
	bool m_teamate = false;
	bool m_setup = false;
	float m_spawn = -1.f;

	bool m_dormant = false;
	bone_array_t *m_used_bones = nullptr;

	float test_velocity(std::shared_ptr<player_record_t> record, float speed, float pVec);

	float solve_velocity_len(std::shared_ptr<player_record_t> record);

	void UpdateAnimations (std::shared_ptr<player_record_t> record );
	void update( player_t *ent );
};
struct animation_backup_t {
	vec3_t           m_origin, m_abs_origin;
	vec3_t           m_velocity, m_abs_velocity;
	int              m_flags{}, m_eflags{};
	float            m_duck{}, m_body{};
	animation_layer_t m_layers[ 15 ]{};
	float m_poses[24]{};
};
class player_manager_t {
public:
	player_manager_t( ) {
		
	}
	std::array< ent_info_t , 64 > m_ents{};
	bool m_animating = false;
	void update( );
} inline g_player_manager;


```

`solace-csgo/player_movement.h`:

```h
#pragma once
#include "includes.h"
#include <cstdint>

#include "vec3.h"

class player_t;
class cmd_t;

class player_move_helper {
public:
	bool	first_run_of_iunctions : 1;
	bool	game_code_moved_player : 1;
	int	player_handle;
	int	impulse_command;
	vec3_t	view_angles;
	vec3_t	abs_view_angles;
	int	buttons;
	int	old_buttons;
	float	forward_move;
	float	side_move;
	float	up_move;
	float	max_speed;
	float	client_max_speed;
	vec3_t	velocity;
	vec3_t	angles;
	vec3_t	old_angles;
	float	out_step_height;
	vec3_t	wish_velocity;
	vec3_t	jump_velocity;
	vec3_t	constraint_center;
	float	constraint_radius;
	float	constraint_width;
	float	constraint_speed_factor;
	float	u0[ 5 ];
	vec3_t	abs_origin;
	virtual	void u1( ) = 0;
	virtual void set_host( player_t *host ) = 0;
};

struct player_move_data {
public:
	bool    first_run_of_instructions : 1;
	bool    game_code_moved_player : 1;
	int     player_handle;
	int     impulse_command;
	ang_t	view_angles;
	vec3_t	abs_view_angles;
	int     buttons;
	int     old_buttons;
	float   fw_move;
	float   sd_move;
	float   up_move;
	float   max_speed;
	float   client_max_speed;
	vec3_t	velocity;
	vec3_t	angles;
	vec3_t	old_angles;
	float   step_height;
	vec3_t	wish_velocity;
	vec3_t	jump_velocity;
	vec3_t	constraint_center;
	float   constraint_radius;
	float   constraint_width;
	float   constraint_speed_factor;
	float   u0[ 5 ];
	vec3_t	abs_origin;
};

class virtual_game_movement {

public:
	virtual				~virtual_game_movement( void ) { }
	virtual void			process_movement( player_t *player, player_move_data *move ) = 0;
	virtual void			reset( void ) = 0;
	virtual void			start_track_prediction_errors( player_t *player ) = 0;
	virtual void			finish_track_prediction_errors( player_t *player ) = 0;
	virtual void			diff_print( char const *fmt, ... ) = 0;
	virtual vec3_t const &get_player_mins( bool ducked ) const = 0;
	virtual vec3_t const &get_player_maxs( bool ducked ) const = 0;
	virtual vec3_t const &get_player_view_offset( bool ducked ) const = 0;
	virtual bool			is_moving_player_stuck( void ) const = 0;
	virtual player_t *get_moving_player( void ) const = 0;
	virtual void			unblock_posher( player_t *player, player_t *pusher ) = 0;
	virtual void			setup_movement_bounds( player_move_data *move ) = 0;
};

class player_game_movement : public virtual_game_movement {
public:
	virtual ~player_game_movement( void ) { }
};

class player_prediction {
public:
	uint8_t		pad0[ 0x4 ];				// 0x0000
	std::uintptr_t	hLastGround;			// 0x0004
	bool			bInPrediction;			// 0x0008
	bool			bOldCLPredictValue;		// 0x0009
	bool			bEnginePaused;			// 0x000A
	uint8_t		pad2[ 0xD ];				// 0x000B
	bool			bIsFirstTimePredicted;	// 0x0018
public:

	void SuppressHostEvents(void* player) {
		static auto addr = **address(util::find("client.dll", "A1 ? ? ? ? 0F 94 C1 85 C0")).as< DWORD** >(1);
		auto next = addr;
		while (next)
		{
			*(DWORD*)(next + 12) = (int)player;
			*(DWORD*)(next + 8) = player != nullptr;
			if (*(DWORD*)(next + 16) > 0)
				*(DWORD*)(next + 16) = 0;
			next = *(DWORD*)( next + 4);
		}
	}

	bool in_prediction( ) {
		typedef bool( __thiscall *o_in_prediction )( void * );
		return util::get_virtual_function<o_in_prediction>( this, 14 )( this );
	}

	void run_command( player_t *player, cmd_t *cmd, player_move_helper *helper ) {
		typedef void( __thiscall *o_run_command )( void *, player_t *, cmd_t *, player_move_helper * );
		return util::get_virtual_function<o_run_command>( this, 19 )( this, player, cmd, helper );
	}

	void setup_move( player_t *player, cmd_t *cmd, player_move_helper *helper, void *data ) {
		typedef void( __thiscall *o_setup_move )( void *, player_t *, cmd_t *, player_move_helper *, void * );
		return util::get_virtual_function<o_setup_move>( this, 20 )( this, player, cmd, helper, data );
	}

	void check_moving_ground( player_t *player, double dbFrametime ) {
		typedef void( __thiscall *check_moving_ground_t )( void *, player_t *, double dbFrametime );
		util::get_virtual_function< check_moving_ground_t >( this, 18 )( this, player, dbFrametime );
	}

	void update( int startframe, bool validframe, int incoming_acknowledged, int outgoing_command ) {
		typedef void( __thiscall *o_update )( void *, int, bool, int, int );
		return util::get_virtual_function<o_update>( this, 3 )( this, startframe, validframe, incoming_acknowledged, outgoing_command );
	}

	void SetLocalViewAngles( const ang_t &ang ) {
		return util::get_virtual_function< void( __thiscall * )( decltype( this ), const ang_t & ) >( this, 13 )( this, ang );
	}

	void finish_move( player_t *player, cmd_t *cmd, void *data ) {
		typedef void( __thiscall *o_finish_move )( void *, player_t *, cmd_t *, void * );
		return util::get_virtual_function<o_finish_move>( this, 21 )( this, player, cmd, data );
	}
};

```

`solace-csgo/prediction.cpp`:

```cpp
#include "prediction.h"
#include "includes.h"
#include "sdk.h"

void adjust_time()
{
    static auto sv_clockcorrection_msecs = g.m_interfaces->console()->get_convar("sv_clockcorrection_msecs");
    float flCorrectionSeconds = std::clamp(sv_clockcorrection_msecs->GetFloat() / 1000.0f, 0.0f, 1.0f);
    int nCorrectionTicks = g.time_to_ticks(flCorrectionSeconds);

    // Set the target tick flCorrectionSeconds (rounded to ticks) ahead in the future. this way the client can
    //  alternate around this target tick without getting smaller than gpGlobals->tickcount.
    // After running the commands simulation time should be equal or after current gpGlobals->tickcount,
    //  otherwise the simulation time drops out of the client side interpolated var history window.

    auto* nci = g.m_interfaces->engine()->get_net_channel_info();
    int nIdealFinalTick = g.m_interfaces->globals()->m_tickcount + nCorrectionTicks + nci->GetLatency(2);
    ;

    int nEstimatedFinalTick = g.m_local->tick_base() + 1;

    // If client gets ahead of this, we'll need to correct
    int too_fast_limit = nIdealFinalTick + nCorrectionTicks;
    // If client falls behind this, we'll also need to correct
    int too_slow_limit = nIdealFinalTick - nCorrectionTicks;

    // See if we are too fast
    if (nEstimatedFinalTick > too_fast_limit || nEstimatedFinalTick < too_slow_limit)
    {
        int nCorrectedTick = nIdealFinalTick - g.m_interfaces->client_state()->chokedcommands;

        g.m_local->tick_base() = nCorrectedTick;
    }
}

void prediction::start(cmd_t* cmd)
{
    if (!g.m_local)
        return;

    g.m_interfaces->prediction()->SuppressHostEvents(g.m_local);
    g.m_in_pred = true;
    static player_move_data data;
    if (!prediction_random_seed)
        prediction_random_seed = address{g.m_interfaces->prediction().hook()->get_original(19)}.add(0x30).get<int*>();
    if (!prediction_player)
        prediction_player = address{g.m_interfaces->prediction().hook()->get_original(19)}.add(0x54).get<player_t*>();

    *prediction_random_seed = cmd->m_randomseed;
    prediction_player = g.m_local;

    g.m_interfaces->move_helper()->set_host(g.m_local);

    typedef char(__thiscall * start_command_t)(void*, void*);
    static auto start_command = reinterpret_cast<start_command_t>(util::find("client.dll", "55 8B EC 8B 55 ? 3B CA"));

    auto dummy_cmd = *cmd;

    g.m_local->m_cmd() = &dummy_cmd;
    dummy_cmd.m_buttons |= IN_ATTACK;
    start_command(&g.m_local->m_cmd_ukn(), &dummy_cmd);

    old_cur_time = g.m_interfaces->globals()->m_curtime;
    old_frame_time = g.m_interfaces->globals()->m_frametime;

    g.m_interfaces->globals()->m_curtime = g.ticks_to_time(g.m_local->tick_base());
    g.m_interfaces->globals()->m_frametime = g.m_interfaces->globals()->m_interval_per_tick;

    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    g.m_interfaces->prediction()->bInPrediction = true;

    g.m_interfaces->game_movement()->start_track_prediction_errors(g.m_local);
    if (dummy_cmd.m_weaponselect != 0)
    {
        /// TODO: reverse and implement weapon selection
    }

    dummy_cmd.m_buttons |= *(int*)((uintptr_t)g.m_local + 0x3310);

    g.m_local->UpdateButtons(g.m_local, dummy_cmd.m_buttons);
    g.m_local->set_angles(dummy_cmd.m_viewangles);

    g.m_interfaces->prediction()->check_moving_ground(g.m_local, g.m_interfaces->globals()->m_frametime);

    typedef char(__thiscall * physics_run_think_t)(void*, int);
    static auto physics_run_think = reinterpret_cast<physics_run_think_t>(
        util::find("client.dll", "55 8B EC 83 EC ? 53 56 57 8B F9 8B 87 ? ? ? ? C1 E8 ?"));
    if (physics_run_think(g.m_local, 0))
        g.m_local->PreThink();

    typedef void(__thiscall * set_next_think_t)(void*, char);
    static auto set_next_think =
        reinterpret_cast<set_next_think_t>(util::find("client.dll", "55 8B EC 56 57 8B F9 8B B7 ? ? ? ? 8B C6"));
    const auto next_think = g.m_local->m_next_think();
    if (next_think > 0 && next_think <= *(int*)(g.m_local + 0x3430))
    {
        g.m_local->m_next_think() = -1;
        set_next_think(g.m_local, next_think);
        g.m_local->Think(); // pPlayer->Think();
    }

    memset(&data, 0, sizeof(data));

    g.m_interfaces->prediction()->setup_move(g.m_local, &dummy_cmd, g.m_interfaces->move_helper(), &data);

    g.m_interfaces->game_movement()->process_movement(g.m_local, &data);

    g.m_interfaces->prediction()->finish_move(g.m_local, &dummy_cmd, &data);

    // g.m_local->PostThink( );
    g.m_interfaces->game_movement()->finish_track_prediction_errors(g.m_local);

    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    g.m_local->tick_base()++;
    g.m_interfaces->prediction()->SuppressHostEvents(nullptr);
    g.m_in_pred = false;
}

void prediction::update()
{
    // render start was not called.
    if (g.m_stage == FRAME_NET_UPDATE_END)
    {
        const auto start = g.m_interfaces->client_state()->last_command_ack;
        const auto stop =
            g.m_interfaces->client_state()->lastoutgoingcommand + g.m_interfaces->client_state()->chokedcommands;

        // call CPrediction::Update.
        g.m_interfaces->prediction()->update(g.m_interfaces->client_state()->m_nDeltaTick,
                                             g.m_interfaces->client_state()->m_nDeltaTick > 0, start, stop);
    }

    static auto unlocked_fakelag = false;
    if (!unlocked_fakelag)
    {
        auto* const cl_move_clamp = util::find("engine.dll", "B8 ? ? ? ? 3B F0 0F 4F F0 89 5D FC") + 1;
        unsigned long protect = 0;

        VirtualProtect(static_cast<void*>(cl_move_clamp), 4, PAGE_EXECUTE_READWRITE,
                       &protect); // allow more cmds to be sent from the buffer at a time
        *reinterpret_cast<std::uint32_t*>(cl_move_clamp) = 62;
        VirtualProtect(static_cast<void*>(cl_move_clamp), 4, protect, &protect);
        unlocked_fakelag = true;
    }
}
void prediction::end()
{
    if (!g.m_local)
        return;

    g.m_interfaces->prediction()->bInPrediction = false; // reset all engine prediction states

    g.m_interfaces->move_helper()->set_host(nullptr);
    g.m_local->m_cmd() = nullptr;

    *prediction_random_seed = -1;
    prediction_player = nullptr;

    g.m_interfaces->globals()->m_curtime = old_cur_time;
    g.m_interfaces->globals()->m_frametime = old_cur_time;
}
void prediction::finish_partial_frame(player_t* player, cmd_t* cmd)
{ // replace
    if (!g.m_local)
        return;

    g.m_in_pred = true;
    static player_move_data data;
    if (!prediction_random_seed)
        prediction_random_seed = address{g.m_interfaces->prediction().hook()->get_original(19)}.add(0x30).get<int*>();
    if (!prediction_player)
        prediction_player = address{g.m_interfaces->prediction().hook()->get_original(19)}.add(0x54).get<player_t*>();

    *prediction_random_seed = cmd->m_randomseed;
    prediction_player = g.m_local;

    g.m_interfaces->move_helper()->set_host(g.m_local);

    typedef char(__thiscall * start_command_t)(void*, void*);
    static auto start_command = reinterpret_cast<start_command_t>(util::find("client.dll", "55 8B EC 8B 55 ? 3B CA"));
    g.m_local->m_cmd() = cmd;
    start_command(&g.m_local->m_cmd_ukn(), cmd);

    // pPlayer->SetLocalViewAngles(pCmd->viewangles);
    // g_cl.m_weapon->update_accuracy_penalty();

    old_cur_time = g.m_interfaces->globals()->m_curtime;
    old_frame_time = g.m_interfaces->globals()->m_frametime;

    g.m_interfaces->globals()->m_curtime = g.ticks_to_time(g.m_local->tick_base());
    g.m_interfaces->globals()->m_frametime = g.m_interfaces->globals()->m_interval_per_tick;

    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    g.m_interfaces->prediction()->bInPrediction = true;

    g.m_interfaces->prediction()->bIsFirstTimePredicted = true;
    g.m_interfaces->prediction()->bInPrediction = true;

    g.m_interfaces->game_movement()->start_track_prediction_errors(g.m_local);
    if (cmd->m_weaponselect != 0)
    {
    }

    const auto backup_buttons = cmd->m_buttons;
    cmd->m_buttons |= *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(g.m_local) + 0x3310);

    g.m_local->UpdateButtons(g.m_local, cmd->m_buttons);
    g.m_local->set_angles(cmd->m_viewangles);

    cmd->m_buttons = backup_buttons;

    g.m_interfaces->prediction()->check_moving_ground(g.m_local, g.m_interfaces->globals()->m_frametime);

    typedef char(__thiscall * physics_run_think_t)(void*, int);
    static auto physics_run_think = reinterpret_cast<physics_run_think_t>(
        util::find("client.dll", "55 8B EC 83 EC ? 53 56 57 8B F9 8B 87 ? ? ? ? C1 E8 ?"));
    if (physics_run_think(g.m_local, 0))
        g.m_local->PreThink();

    typedef void(__thiscall * set_next_think_t)(void*, char);
    static auto set_next_think =
        reinterpret_cast<set_next_think_t>(util::find("client.dll", "55 8B EC 56 57 8B F9 8B B7 ? ? ? ? 8B C6"));
    const auto next_think = g.m_local->m_next_think();
    if (next_think > 0 && next_think <= *(int*)(g.m_local + 0x3430))
    {
        g.m_local->m_next_think() = -1;
        set_next_think(g.m_local, next_think);
        g.m_local->Think();
    }

    memset(&data, 0, sizeof(data));

    g.m_interfaces->prediction()->setup_move(g.m_local, cmd, g.m_interfaces->move_helper(), &data);

    g.m_interfaces->game_movement()->process_movement(g.m_local, &data);

    g.m_interfaces->prediction()->finish_move(g.m_local, cmd, &data);

    g.m_local->PostThink();
    g.m_interfaces->game_movement()->finish_track_prediction_errors(g.m_local);

    player->tick_base()++;

    prediction::end();
    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    cmd->m_predicted = true;
    g.m_in_pred = false;
}
void prediction::re_predict(cmd_t* cmd)
{
    if (!g.m_local)
        return;

    g.m_in_pred = true;
    g.m_interfaces->prediction()->SuppressHostEvents(g.m_local);
    static player_move_data data;

    if (!prediction_random_seed)
        prediction_random_seed =
            address{util::get_virtual_function(g.m_interfaces->prediction(), 19)}.add(0x30).get<int*>();
    if (!prediction_player)
        prediction_player =
            address{util::get_virtual_function(g.m_interfaces->prediction(), 19)}.add(0x54).get<player_t*>();

    *prediction_random_seed = cmd->m_randomseed;
    prediction_player = g.m_local;

    g.m_interfaces->move_helper()->set_host(g.m_local);

    typedef char(__thiscall * start_command_t)(void*, void*);
    static auto start_command = (start_command_t)util::find("client.dll", "55 8B EC 8B 55 ? 3B CA");
    g.m_local->m_cmd() = cmd;
    start_command(&g.m_local->m_cmd_ukn(), cmd);

    // pPlayer->SetLocalViewAngles(pCmd->viewangles);
    // g_cl.m_weapon->update_accuracy_penalty();

    old_cur_time = g.m_interfaces->globals()->m_curtime;
    old_frame_time = g.m_interfaces->globals()->m_frametime;

    g.m_interfaces->globals()->m_curtime = (g.m_local->tick_base() * g.m_interfaces->globals()->m_interval_per_tick);
    g.m_interfaces->globals()->m_frametime = g.m_interfaces->globals()->m_interval_per_tick;

    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    g.m_interfaces->prediction()->bInPrediction = true;

    g.m_interfaces->game_movement()->start_track_prediction_errors(g.m_local);
    if (cmd->m_weaponselect != 0)
    {
        /// TODO: reverse and implement weapon selection
    }

    const auto backup_buttons = cmd->m_buttons;
    cmd->m_buttons |= *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(g.m_local) + 0x3310);

    g.m_local->UpdateButtons(g.m_local, cmd->m_buttons);
    g.m_local->set_angles(cmd->m_viewangles);

    cmd->m_buttons = backup_buttons;
    auto backup_ground = g.m_local->m_ground_entity();
    g.m_interfaces->prediction()->check_moving_ground(g.m_local, g.m_interfaces->globals()->m_frametime);

    typedef char(__thiscall * physics_run_think_t)(void*, int);
    static auto physics_run_think = reinterpret_cast<physics_run_think_t>(
        util::find("client.dll", "55 8B EC 83 EC ? 53 56 57 8B F9 8B 87 ? ? ? ? C1 E8 ?"));
    if (physics_run_think(g.m_local, 0))
        g.m_local->PreThink();

    typedef void(__thiscall * set_next_think_t)(void*, char);
    static auto set_next_think = (set_next_think_t)util::find("client.dll", "55 8B EC 56 57 8B F9 8B B7 ? ? ? ? 8B C6");
    int next_think = g.m_local->m_next_think();
    if (next_think > 0 && next_think <= *(int*)(g.m_local + 0x3430))
    {
        g.m_local->m_next_think() = -1;
        set_next_think(g.m_local, next_think);
        g.m_local->Think(); // pPlayer->Think();
    }

    memset(&data, 0, sizeof(data));
    g.m_interfaces->move_helper()->set_host(g.m_local);

    g.m_interfaces->prediction()->setup_move(g.m_local, cmd, g.m_interfaces->move_helper(), &data);

    g.m_interfaces->game_movement()->process_movement(g.m_local, &data);

    g.m_interfaces->prediction()->finish_move(g.m_local, cmd, &data);

    g.m_interfaces->game_movement()->finish_track_prediction_errors(g.m_local);

    g.m_local->PostThink();

    g.m_interfaces->prediction()->bIsFirstTimePredicted = false;
    g.m_interfaces->prediction()->bInPrediction = false;

    g.m_local->tick_base()++;

    end();
    g.m_interfaces->prediction()->SuppressHostEvents(nullptr);
    g.m_in_pred = false;
}

```

`solace-csgo/prediction.h`:

```h
#pragma once
class cmd_t;
class player_t;
namespace prediction {
	void start( cmd_t *cmd );
	void update( );
	void end( );
	void finish_partial_frame( player_t *player, cmd_t *cmd );
	void re_predict( cmd_t *cmd );

	inline float old_cur_time;
	inline float old_frame_time;
	inline int *prediction_random_seed;
	inline player_t *prediction_player;
	inline int *should_predict;
};

```

`solace-csgo/predictioncopy.cpp`:

```cpp
#include "predictioncopy.h"

#include "datamap.h"
#include "utils.h"

CPredictionCopy::CPredictionCopy( int type, byte *dest, bool dest_packed, const byte *src, bool src_packed,
                                  optype_t opType, FN_FIELD_COMPARE func /*= NULL*/ ) {
	m_OpType = opType;
	m_nType = type;
	m_pDest = dest;
	m_pSrc = src;
	m_nDestOffsetIndex = dest_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;
	m_nSrcOffsetIndex = src_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;

	m_nErrorCount = 0;
	m_nEntIndex = -1;

	m_pWatchField = nullptr;
	m_FieldCompareFunc = func;
}

int CPredictionCopy::TransferData( const char *operation, int entindex, datamap_t *dmap ) {
	static auto pat = util::find( "client.dll", "55 8B EC 8B 45 10 53 56 8B F1 57" );
	using PrepDataMap = int( __thiscall * )( CPredictionCopy *, const char *, int, datamap_t * );
	return reinterpret_cast< PrepDataMap >( pat )( this, operation, entindex, dmap );
}

bool CPredictionCopy::PrepareDataMap( datamap_t *dmap ) {
	dmap->m_packed_size = 0;
	static auto pat = util::find( "client.dll", "55 8B EC 83 EC ? 57 8B F9 89 7D ? 83 7F ? ?" );
	using PrepDataMap = bool( __thiscall * )( datamap_t * );
	return reinterpret_cast< PrepDataMap >( pat )( dmap );
}

```

`solace-csgo/predictioncopy.h`:

```h
#pragma once
#include "Windows.h"

#include "memory_shit.h"
class datamap_t;
class typedescription_t;

typedef void ( *FN_FIELD_COMPARE )( const char *classname, const char *fieldname, const char *fieldtype,
									bool networked, bool noterrorchecked, bool differs, bool withintolerance, const char *value );

class CPredictionCopy {
public:
	typedef enum {
		DIFFERS = 0,
		IDENTICAL,
		WITHINTOLERANCE,
	} difftype_t;

	typedef enum {
		TRANSFERDATA_COPYONLY = 0,  // Data copying only (uses runs)
		TRANSFERDATA_ERRORCHECK_NOSPEW, // Checks for errors, returns after first error found
		TRANSFERDATA_ERRORCHECK_SPEW,   // checks for errors, reports all errors to console
		TRANSFERDATA_ERRORCHECK_DESCRIBE, // used by hud_pdump, dumps values, etc, for all fields
	} optype_t;

	CPredictionCopy( int type, byte *dest, bool dest_packed, const byte *src, bool src_packed,
					 optype_t opType, FN_FIELD_COMPARE func = nullptr );

	int		TransferData( const char *operation, int entindex, datamap_t *dmap );

	static bool PrepareDataMap( datamap_t *dmap );

private:

	optype_t		m_OpType;
	int				m_nType;
	byte *m_pDest;
	const byte *m_pSrc;
	int				m_nDestOffsetIndex;
	int				m_nSrcOffsetIndex;
	int				m_nErrorCount;
	int				m_nEntIndex;

	FN_FIELD_COMPARE	m_FieldCompareFunc;

	const typedescription_t *m_pWatchField;
	char const *m_pOperation;

	CUtlStack< const typedescription_t * > m_FieldStack;
};

#undef CUtilStack
#undef CUtlMemory
```

`solace-csgo/render.cpp`:

```cpp
#include "render.h"

#include <future>

#include "includes.h"

void font_t::create(IDirect3DDevice9 *device, const char *font_name, int size,
                    int weight, int flags) {
  this->flags = flags;
  D3DXCreateFontA(device, size, 0, weight, 1, false, ANSI_CHARSET,
                  OUT_DEFAULT_PRECIS,
                  this->flags & fontflag_antialias ? ANTIALIASED_QUALITY
                                                   : NONANTIALIASED_QUALITY,
                  DEFAULT_PITCH, font_name, &this->font);
}

auto render_t::create_fonts() -> void {
  this->tahoma_14_.create(this->device_, "Tahoma", 12, 900,
                          fontflag_antialias | fontflag_none);
  this->courier_new_13_.create(this->device_, "Courier New", 13, 200,
                               fontflag_antialias | fontflag_none);
  this->segoe_ui_13_.create(this->device_, "Segoe UI", 13, 300,
                            fontflag_antialias | fontflag_none);
  this->constantia_12_.create(this->device_, "Tahoma", 12, 300,
                              fontflag_antialias | fontflag_none);
  this->tahoma_12_.create(this->device_, "Tahoma", 12, FW_DONTCARE,
                          fontflag_antialias | fontflag_none);
}

RECT render_t::get_text_rect(const char *text, font_t &font) {
  RECT rect = {0, 0, 0, 0};

  if (font.font)
    font.font->DrawTextA(nullptr, text, strlen(text), &rect, DT_CALCRECT,
                         D3DCOLOR_XRGB(0, 0, 0));

  return rect;
}

int render_t::get_text_width(const char *text, font_t &font) {
  RECT rect = {0, 0, 0, 0};

  if (font.font)
    font.font->DrawTextA(nullptr, text, strlen(text), &rect, DT_CALCRECT,
                         D3DCOLOR_XRGB(0, 0, 0));

  return rect.right - rect.left;
}

auto render_t::get_text_height(const char *text, font_t &font) -> int {
  RECT rect = {0, 0, 0, 0};

  if (font.font)
    font.font->DrawTextA(nullptr, text, strlen(text), &rect, DT_CALCRECT,
                         D3DCOLOR_XRGB(0, 0, 0));

  return rect.bottom - rect.top;
}

auto render_t::setup(IDirect3DDevice9 *device) -> void {
  static bool setup{false};
  if (!setup) {
    this->device_ = device;
    this->create_fonts();
    this->device_->GetViewport(&this->screen_size_);
  }
  setup = true;
}

auto render_t::text(font_t &font, float x, float y, color col, const char *text,
                    const int centered) -> void {
  RECT rect = {0, 0, 0, 0};

  auto text_size = get_text_width(text, font);

  const auto draw_text = [text_size, centered, text, font](
                             RECT &rect, color &col, unsigned short x,
                             unsigned short y) -> void {
    const auto set_rect = [](RECT &rect, const float x, const float y) {
      SetRect(&rect, x, y, x, y);
    };

    if (font.flags & fontflag_none) {
      set_rect(rect, x, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP, col);
    } else if (font.flags & fontflag_dropshadow) {
      set_rect(rect, x + 1, y + 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           color(0, 0, 0, col.m_a()));

      set_rect(rect, x, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP, col);
    } else if (font.flags & fontflag_outline) {
      const auto outline_color = color(0, 0, 0, col.m_a());

      set_rect(rect, x, y + 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x + 1, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x, y - 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x - 1, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);

      set_rect(rect, x + 1, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x, y + 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x - 1, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x, y - 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);

      set_rect(rect, x + 1, y + 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x - 1, y - 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x + 1, y - 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);
      set_rect(rect, x - 1, y + 1);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP,
                           outline_color);

      set_rect(rect, x, y);
      font.font->DrawTextA(nullptr, text, -1, &rect, DT_LEFT | DT_NOCLIP, col);
    }
  };

  if (centered & Horizontal) x -= text_size / 2.f;

  text_size = get_text_height(text, font);

  if (centered & Vertical) y -= text_size / 2.f;

  draw_text(rect, col, x, y);
}

void render_t::DrawLine(long Xa, long Ya, long Xb, long Yb, DWORD dwWidth,
                        color Color) {}
auto render_t::render_triangle(vertex_t *vert, int count) const -> void {
  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  this->device_->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, count, vert,
                                 sizeof(vertex_t));
}
auto render_t::render_trianglefan(vertex_t *vert, int count) const -> void {
  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  this->device_->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, count, vert,
                                 sizeof(vertex_t));
}
auto render_t::render_lines(vertex_t *vert, int count) const -> void {
  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  for (auto i = 0; i < count; i++)
    this->device_->DrawPrimitiveUP(D3DPT_LINESTRIP, count, vert,
                                   sizeof(vertex_t));
}

auto render_t::filled_rect(const float x, const float y, const float w,
                           const float h, const color col) const -> void {
  vertex_t vertices[4] = {{x, y, 1.f, 1.0f, col},
                          {x + w, y, 1.f, 1.0f, col},
                          {x, y + h, 1.f, 1.0f, col},
                          {x + w, y + h, 1.f, 1.0f, col}};

  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  this->device_->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertices,
                                 sizeof(vertex_t));
}

auto render_t::outlined_rect(const float x, const float y, float w, float h,
                             const color col) const -> void {
  w -= 1;
  h -= 1;
  vertex_t vertices[5] = {{x, y, 1.0f, 1.0f, col},
                          {x + w, y, 1.0f, 1.0f, col},
                          {x + w, y + h, 1.0f, 1.0f, col},
                          {x, y + h, 1.0f, 1.0f, col},
                          {x, y, 1.0f, 1.0f, col}};

  this->device_->SetTexture(0, nullptr);
  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  this->device_->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, &vertices,
                                 sizeof(vertex_t));
}

auto render_t::line(const float x, const float y, const float x2,
                    const float y2, const color color, const int dwWidth) const
    -> void {
  static LPD3DXLINE line;
  if (!line) D3DXCreateLine(device_, &line);
  D3DXVECTOR2 vLine[2];      // Two points
  line->SetAntialias(TRUE);  // To smooth edges

  line->SetWidth(dwWidth);  // Width of the line
  line->Begin();

  vLine[0][0] = x;  // Set points into array
  vLine[0][1] = y;
  vLine[1][0] = x2;
  vLine[1][1] = y2;

  line->Draw(vLine, 2, color);  // Draw with Line, number of lines, and color
  line->End();                  // finish
}

auto render_t::gradient(const float x, const float y, const float w,
                        const float h, const color col, const color col2,
                        const bool vertical) const -> void {
  vertex_t vertices[4] = {{x, y, 1.f, 1.0f, col},
                          {x + w, y, 1.f, 1.0f, (vertical ? col : col2)},
                          {x, y + h, 1.f, 1.0f, (vertical ? col2 : col)},
                          {x + w, y + h, 1.f, 1.0f, (col2)}};

  this->device_->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  this->device_->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices,
                                 sizeof(vertex_t));
}

auto render_t::push_clip(const float x, const float y, const float w,
                         const float h) -> void {
  RECT clip_rect = {static_cast<LONG>(x), static_cast<LONG>(y),
                    static_cast<LONG>(x + w), static_cast<LONG>(y + h)};

  this->device_->SetScissorRect(&clip_rect);
  scissor_buffer.emplace(scissor_buffer.begin(), clip_rect);
}

auto render_t::push_clip(area_t area) -> void {
  RECT clip_rect = {static_cast<LONG>(area.x), static_cast<LONG>(area.y),
                    static_cast<LONG>(area.x + area.w),
                    static_cast<LONG>(area.y + area.h)};

  this->device_->SetScissorRect(&clip_rect);
  scissor_buffer.emplace(scissor_buffer.begin(), clip_rect);
}

auto render_t::pop_clip() -> void {
  scissor_buffer.erase(scissor_buffer.begin());
  if (!scissor_buffer.empty())
    this->device_->SetScissorRect(scissor_buffer.begin()._Ptr);
  else
    this->device_->SetScissorRect(&this->backup_scissor_rect_);
}

auto render_t::start() -> void {
  // setup state-block.
  this->device_->GetVertexDeclaration(&this->vertex_declaration_);
  this->device_->CreateStateBlock(D3DSBT_PIXELSTATE, &this->state_block_);

  // store.
  this->device_->GetRenderState(D3DRS_COLORWRITEENABLE,
                                &this->dwold_d3drs_colorwriteenable_);
  this->device_->GetRenderState(D3DRS_ANTIALIASEDLINEENABLE,
                                &this->dwold_d3drs_antialiasedlineenable_);
  this->device_->GetRenderState(D3DRS_MULTISAMPLEANTIALIAS,
                                &this->dwold_d3drs_multisampleantialias_);
  this->device_->GetRenderState(D3DRS_SCISSORTESTENABLE,
                                &this->dwold_d3drs_scissortestenable_);
  this->device_->GetTextureStageState(0, D3DTSS_COLORARG0,
                                      &this->dwold_d3dtexturestagestate_);
  this->device_->GetScissorRect(&this->backup_scissor_rect_);
  this->device_->GetVertexShader(&this->vertex_shader2_);
  this->device_->GetPixelShader(&this->pixel_shader_);
  this->device_->SetRenderState(D3DRS_COLORWRITEENABLE, 0xffffffff);
  this->device_->SetRenderState(D3DRS_SRGBWRITEENABLE, false);
  this->device_->SetSamplerState(NULL, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
  this->device_->SetSamplerState(NULL, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
  this->device_->SetSamplerState(NULL, D3DSAMP_ADDRESSW, D3DTADDRESS_WRAP);
  this->device_->SetSamplerState(NULL, D3DSAMP_SRGBTEXTURE, NULL);
  this->device_->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  // setup.
  this->device_->SetVertexShader(nullptr);
  this->device_->SetPixelShader(nullptr);
  this->device_->SetRenderState(D3DRS_FOGENABLE, FALSE);
  this->device_->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
  this->device_->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
  this->device_->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
  this->device_->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
  this->device_->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
  this->device_->SetRenderState(D3DRS_STENCILENABLE, FALSE);
  this->device_->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
  this->device_->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
  this->device_->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
  this->device_->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
  this->device_->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
  this->device_->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
  this->device_->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_INVDESTALPHA);
  this->device_->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
  this->device_->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ONE);
  this->device_->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
  this->device_->SetRenderState(
      D3DRS_COLORWRITEENABLE,
      D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN |
          D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
  this->device_->SetTexture(0, nullptr);
}

auto render_t::finish() const -> void {
  // restore.
  this->device_->SetTextureStageState(0, D3DTSS_COLORARG0,
                                      this->dwold_d3dtexturestagestate_);
  this->device_->SetRenderState(D3DRS_COLORWRITEENABLE,
                                this->dwold_d3drs_colorwriteenable_);
  this->device_->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE,
                                this->dwold_d3drs_antialiasedlineenable_);
  this->device_->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS,
                                this->dwold_d3drs_multisampleantialias_);
  this->device_->SetScissorRect(&this->backup_scissor_rect_);
  this->device_->SetRenderState(D3DRS_SCISSORTESTENABLE,
                                this->dwold_d3drs_scissortestenable_);
  this->device_->SetRenderState(D3DRS_COLORWRITEENABLE,
                                this->dwold_d3drs_colorwriteenable_);
  this->device_->SetRenderState(D3DRS_SRGBWRITEENABLE, true);
  this->device_->SetVertexShader(this->vertex_shader2_);
  this->device_->SetPixelShader(this->pixel_shader_);

  // apply state-block.
  this->state_block_->Apply();
  this->state_block_->Release();
  this->device_->SetVertexDeclaration(this->vertex_declaration_);
}
auto render_t::world_circle(vec3_t origin, float radius, color clr) const
    -> void {
  vec3_t origin_w2s;
  if (!math::world_to_screen(origin, origin_w2s)) return;

  render_t::vertex_t verts[3] = {};
  for (auto i = 0; i < 360; i += 5) {
    auto rot = origin + ang_t(0, i, 0).forward() * radius;
    auto rot_2 = origin + ang_t(0, i + 5.f, 0).forward() * radius;

    vec3_t point_wts;
    vec3_t point_wts_2;

    if (!math::world_to_screen(rot, point_wts)) continue;
    if (!math::world_to_screen(rot_2, point_wts_2)) continue;

    clr.set_a(20);
    verts[0] = {roundf(point_wts.x), roundf(point_wts.y), 0, 1, clr};
    verts[1] = {roundf(point_wts_2.x), roundf(point_wts_2.y), 0, 1, clr};
    clr.set_a(100);
    verts[2] = {roundf(origin_w2s.x), roundf(origin_w2s.y), 0, 1, clr};
    g.m_render->render_triangle(verts, 1);
    clr.set_a(50);
    g.m_render->line(roundf(point_wts.x), roundf(point_wts.y),
                     roundf(point_wts_2.x), roundf(point_wts_2.y), clr, 1);
  }
}

void render_t::Rounded(int x, int y, int w, int h, int iSmooth, color Color) {
  POINT pt[4];

  // Get all corners

  pt[0].x = x + (w - iSmooth);
  pt[0].y = y + (h - iSmooth);

  pt[1].x = x + iSmooth;
  pt[1].y = y + (h - iSmooth);

  pt[2].x = x + iSmooth;
  pt[2].y = y + iSmooth;

  pt[3].x = x + w - iSmooth;
  pt[3].y = y + iSmooth;

  filled_rect(x + iSmooth, y + iSmooth, w - iSmooth * 2, h - iSmooth * 2,
              Color);

  filled_rect(x + iSmooth, y, w - iSmooth * 2, iSmooth, Color);
  filled_rect(x + (w - iSmooth), y + iSmooth, iSmooth, h - iSmooth * 2.f,
              Color);

  filled_rect(x + iSmooth, y + (h - iSmooth), w - iSmooth * 2, iSmooth, Color);
  filled_rect(x, y + iSmooth, iSmooth, h - iSmooth * 2.f, Color);

  float fDegree = 0;

  for (int i = 0; i < 4; i++) {
    std::vector<render_t::vertex_t> verts = {
        {float(pt[i].x), float(pt[i].y), 0, 1, Color}};
    for (float k = fDegree; k <= fDegree + 90.f; k += 1) {
      float new_x = pt[i].x + round(cos(k * (M_PI / 180.)) * iSmooth);
      float new_y = pt[i].y + round(sin(k * (M_PI / 180.)) * iSmooth);
      verts.push_back({new_x, new_y, 0, 1, Color});
    }
    render_trianglefan(verts.data(), verts.size() - 2);

    fDegree += 90.f;
  }
}

auto render_t::circle(int x, int y, float radius, int segments, color clr) const
    -> void {
  float step = (M_PI * 2.f) / segments;
  for (float i{0.f}; i < (M_PI * 2.f); i += step) {
    vertex_t verts[3];
    clr.set_a(20);
    verts[0] = {roundf(x + (radius * std::cos(i))),
                roundf(y + (radius * std::sin(i))), 0, 1, clr};
    verts[1] = {roundf(x + (radius * std::cos(i + step))),
                roundf(y + (radius * std::sin(i + step))), 0, 1, clr};
    clr.set_a(100);
    verts[2] = {roundf(x), roundf(y), 0, 1, clr};
    g.m_render->render_triangle(verts, 1);
  }
}

auto render_t::is_steam_overlay() const -> bool {
  static std::uintptr_t gameoverlay_return_address = 0;

  if (!gameoverlay_return_address) {
    MEMORY_BASIC_INFORMATION info;
    VirtualQuery(_ReturnAddress(), &info, sizeof(MEMORY_BASIC_INFORMATION));

    char mod[MAX_PATH];
    GetModuleFileNameA(static_cast<HMODULE>(info.AllocationBase), mod,
                       MAX_PATH);

    if (strstr(mod, "gameoverlay"))
      gameoverlay_return_address =
          reinterpret_cast<std::uintptr_t>(_ReturnAddress());
  }

  return gameoverlay_return_address ==
         reinterpret_cast<std::uintptr_t>(_ReturnAddress());
}
```

`solace-csgo/render.h`:

```h
#pragma once

#include <vector>
#include "vec3.h"

#include "d3d9.h"
#pragma comment(lib, "d3dx9.lib")
#include "d3dx9.h"

enum fontflags {
	fontflag_none = ( 1 << 0 ),
	fontflag_antialias = ( 1 << 1 ),
	fontflag_dropshadow = ( 1 << 2 ),
	fontflag_outline = ( 1 << 3 ),
	
};

class area_t {
public:
	float x = 0, y = 0, w = 0, h = 0;
	area_t( float x, float y, float w, float h ) : x( x ), y( y ), w( w ), h( h ) { }
	auto add( const area_t area, const bool add_w = false, const bool add_h = false ) -> area_t {
		this->x += area.x;
		this->y += area.y;

		if ( add_w )
			this->w += area.w;

		if ( add_h )
			this->h += area.h;

		return *this;
	}
};

class font_t {
public:
	void create ( IDirect3DDevice9 *device, const char *font_name, int size, int weight, int flags );

	int flags;
	LPD3DXFONT font;
};

class color {
	unsigned char _color[ 4 ];
public:
	color( ) = default;
	color( const int r, const int g, const int b, const int a = 255 ) {
		_color[ 0 ] = r;
		_color[ 1 ] = g;
		_color[ 2 ] = b;
		_color[ 3 ] = a;
	}

	auto m_r( ) const -> int {
		return _color[ 0 ];
	}

	auto m_g( ) const -> int {
		return _color[ 1 ];
	}

	auto m_b( ) const -> int {
		return _color[ 2 ];
	}

	auto m_a( ) const -> int {
		return _color[ 3 ];
	}

	auto set_r( const int r ) -> void {
		_color[ 0 ] = r;
	}

	auto set_g( const int g ) -> void {
		_color[ 1 ] = g;
	}

	auto set_b( const int b ) -> void {
		_color[ 2 ] = b;
	}

	auto set_a( const int a ) -> void {
		_color[ 3 ] = a;
	}

	operator const D3DCOLOR( ) const {
		return D3DCOLOR_RGBA( ( int )_color[ 0 ], ( int )_color[ 1 ], ( int )_color[ 2 ], ( int )_color[ 3 ] );
	}

	
};
enum Alignment {
	Vertical = ( 1 << 0 ),
	Horizontal = ( 1 << 1 )
};
class render_t {
	font_t tahoma_14_{ 0, nullptr };
	font_t segoe_ui_13_{ 0, nullptr };
	font_t courier_new_13_{ 0, nullptr };
	font_t tahoma_12_{ 0, nullptr }; 
	font_t constantia_12_{ 0, nullptr };

	IDirect3DDevice9 *device_{ nullptr };
	IDirect3DVertexDeclaration9 *vertex_declaration_{ nullptr };
	IDirect3DVertexShader9 *vertex_shader2_{ nullptr };
	IDirect3DPixelShader9 *pixel_shader_{ nullptr };
	DWORD dwold_d3drs_colorwriteenable_{ 0 };
	DWORD dwold_d3dtexturestagestate_{ 0 };
	DWORD dwold_d3drs_antialiasedlineenable_{ 0 };
	DWORD dwold_d3drs_multisampleantialias_{ 0 };
	DWORD dwold_d3drs_scissortestenable_{ 0 };

	std::vector<RECT> scissor_buffer = {};
	RECT backup_scissor_rect_{ 0, 0, 0, 0 };
	D3DVIEWPORT9 screen_size_{ 0, 0, 0, 0, 0, 0 };
	IDirect3DStateBlock9 *state_block_{ nullptr };

	auto create_fonts( ) -> void;


public:
	void on_lost_device() {
		if (tahoma_14_.font)
			tahoma_14_.font->OnLostDevice();

		if (segoe_ui_13_.font)
			segoe_ui_13_.font->OnLostDevice();

		if (courier_new_13_.font)
			courier_new_13_.font->OnLostDevice();

		if (tahoma_12_.font)
			tahoma_12_.font->OnLostDevice();

		if (constantia_12_.font)
			constantia_12_.font->OnLostDevice();
	}

	void on_reset_device() {
		if (tahoma_14_.font)
			tahoma_14_.font->OnResetDevice();

		if (segoe_ui_13_.font)
			segoe_ui_13_.font->OnResetDevice();

		if (courier_new_13_.font)
			courier_new_13_.font->OnResetDevice();

		if (tahoma_12_.font)
			tahoma_12_.font->OnResetDevice();

		if (constantia_12_.font)
			constantia_12_.font->OnResetDevice();
	}
	struct vertex_t {
		float x, y, z, h;
		D3DCOLOR col;

		vertex_t( ) {
			this->x = 0.0f;
			this->y = 0.0f;
			this->z = 1.0f;
			this->h = 1.0f;
			this->col = D3DCOLOR_RGBA( 255, 255, 255, 255 );
		}

		vertex_t( float x_, float y_, float z_, float rhw_, D3DCOLOR color_ ) {
			this->x = x_;
			this->y = y_;
			this->z = z_;
			this->h = rhw_;
			this->col = color_;
		}
	};
	
	auto setup( IDirect3DDevice9 *device ) -> void;
	static RECT get_text_rect( const char* text, font_t& font );
	static int get_text_width( const char* text, font_t& font );
	static auto get_text_height( const char* text, font_t& font ) -> int;
	static auto text( font_t& font, float x, float y, color col, const char* text, const int centered = 0) -> void;
	bool draw_rounded_box( int x, int y, int width, int height, int precision, int offset_x, int offset_y, color col ) const;
	static void DrawLine ( long Xa, long Ya, long Xb, long Yb, DWORD dwWidth, color Color );
	void rounded ( int x, int y, int w, int h, int iSmooth, color Color );
	void rounded ( int x, int y, int w, int h, int iSmooth, D3DCOLOR Color );
	auto render_triangle( vertex_t* vert, int count ) const -> void;
	auto render_trianglefan( vertex_t* vert, int count ) const -> void;
	auto render_lines( vertex_t* vert, int count ) const -> void;
	auto filled_rect( const float x, const float y, const float w, const float h, const color col ) const -> void;
	auto outlined_rect( const float x, const float y, float w, float h, const color col ) const -> void;
	auto line( const float x, const float y, const float x2, const float y2, const color color, const int dwWidth = 1) const -> void;
	auto line( D3DXVECTOR2* lines, int count, const color color, const int dwWidth ) const -> void;
	auto gradient( const float x, const float y, const float w, const float h, const color col, const color col2, const bool vertical = 0 ) const -> void;
	auto push_clip( const float x, const float y, const float w, const float h ) -> void;
	auto push_clip( area_t area ) -> void;
	auto pop_clip( ) -> void;
	auto start( ) -> void;
	auto finish( ) const -> void;
	auto world_circle( vec3_t origin, float radius, color clr ) const -> void;

	void Rounded( int x, int y, int w, int h, int iSmooth, color Color );

	auto circle( int x, int y, float radius, int segments, color clr ) const -> void;

	[[nodiscard]] auto is_steam_overlay( ) const -> bool;

	[[nodiscard]] font_t& m_tahoma_14( ) {
		return this->tahoma_14_;
	}

	[[nodiscard]] font_t& m_segoe_ui_13( ) {
		return this->segoe_ui_13_;
	}
	
	[[nodiscard]] font_t& m_courier_new_13( ) {
		return this->courier_new_13_;
	}

	[[nodiscard]] font_t& m_tahoma_12( ) {
		return this->tahoma_12_;
	}
	[[nodiscard]] font_t& m_constantia_12( ) {
		return this->constantia_12_;
	}

	[[nodiscard]] D3DVIEWPORT9& m_screen_size( ) {
		return this->screen_size_;
	}
};
```

`solace-csgo/resolver.cpp`:

```cpp
#include "resolver.h"

#include <memory>

#include "aimbot.h"
#include "penetration.h"
#include "notification.h"
#include "tfm.h"

#include "includes.h"

#ifdef max
#undef max
#endif
#include "thread_handler.h"

shot_record_t::~shot_record_t()
{
}

std::shared_ptr<player_record_t> resolver::FindIdealRecord(ent_info_t* data)
{
    if (data->m_records.empty())
        return nullptr;

    bool set = false;
    std::shared_ptr<player_record_t> first_valid = nullptr;

    // iterate records.
    for (const auto& it : data->m_records)
    {
        auto const& current = it;
        if (!current || !current->m_setup || current->m_dormant || !current->valid())
            continue;

        // get current record.

        // first record that was valid, store it for later.
        if (!first_valid)
            first_valid = current;

        // try to find a record with a shot, lby update, walking or no anti-aim.
        if (it->m_mode == RESOLVE_WALK)
            return current;
        if (it->m_mode == RESOLVE_BODY && !(first_valid && first_valid->m_mode == RESOLVE_BODY))
            first_valid = current;
    }

    // none found above, return the first valid record if possible.
    return first_valid;
}

std::shared_ptr<player_record_t> resolver::FindIdealBackRecord(ent_info_t* data)
{
    if (data->m_records.empty())
        return nullptr;

    bool set = false;
    std::shared_ptr<player_record_t> first_valid = nullptr;

    // iterate records.
    for (const auto& it : data->m_records)
    {
        auto const& current = it;
        if (!current || !current->m_setup || current->m_dormant || !current->valid())
            continue;

        // get current record.

        // first record that was valid, store it for later.
        if (!first_valid)
            first_valid = current;

        // try to find a record with a shot, lby update, walking or no anti-aim.
        if (it->m_mode == RESOLVE_WALK)
            first_valid = current;
        if (it->m_mode == RESOLVE_BODY && !(first_valid && first_valid->m_mode != RESOLVE_WALK))
            first_valid = current;
    }

    // none found above, return the first valid record if possible.
    return first_valid;
}

void resolver::MatchShot(ent_info_t* data, std::shared_ptr<player_record_t> record)
{
    // do not attempt to do this in nospread mode.
    // if ( g_menu.main.config.mode.get( ) == 1 )
    //	return;

    auto shoot_time = -1.f;

    auto* weapon =
        static_cast<weapon_t*>(g.m_interfaces->entity_list()->get_client_entity_handle(data->m_ent->active_weapon()));
    if (weapon)
    {
        // with logging this time was always one tick behind.
        // so add one tick to the last shoot time.
        shoot_time = weapon->last_shot_time();
    }

    // this record has a shot on it.
    if (g.time_to_ticks(shoot_time) > g.time_to_ticks(record->m_sim_time) - record->m_lag &&
        g.time_to_ticks(shoot_time) <= g.time_to_ticks(record->m_sim_time))
    {
        if (g.time_to_ticks(shoot_time) == g.time_to_ticks(record->m_sim_time))
            record->m_shot = true;

        // more then 1 choke, cant hit pitch, apply prev pitch.
        else
            for (auto i = 1; i < data->m_records.size(); i++)
            {
                if (static_cast<int>(data->m_records.size()) > i)
                {
                    auto const& previous = data->m_records[i];

                    if (previous && !previous->m_dormant && !previous->m_shot)
                    {
                        record->m_eye_angles.x = previous->m_eye_angles.x;
                        record->m_poses[12] = (previous->m_eye_angles.x + 90.f) / 180.f;
                        break;
                    }
                }
                if (i == static_cast<int>(data->m_records.size() - 1))
                {
                    record->m_poses[12] = (89.f + 90.f) / 180.f;
                    record->m_eye_angles.x = 89.f;
                }
            }
    }
}

void resolver::update_shot_timing(int sent_tick)
{
    for (int i = 0; i < m_shots.size(); i++)
    {

        const auto delta = g.m_interfaces->globals()->m_curtime - m_shots[i]->m_time;

        // fuck this.
        if (delta > 2.f)
        {
            m_shots.erase(m_shots.begin() + i);
            i--;
            continue;
        }
        auto& shot = m_shots[i];
        if (!shot->m_updated_time)
        {
            shot->m_time += g.ticks_to_time(sent_tick - shot->m_tick);
            shot->m_updated_time = true;
        }
    }
}

void resolver::SetMode(std::shared_ptr<player_record_t> record)
{
    // the resolver has 3 modes to chose from.
    // these modes will vary more under the hood depending on what data we have about the player
    // and what kind of hack vs. hack we are playing (mm/nospread).

    const auto speed = record->m_anim_velocity.length();

    // if on ground, moving, and not fakewalking.
    if ((record->m_flags & fl_onground) && speed > 0.1f && !(record->m_fake_walk || record->m_ukn_vel))
        record->m_mode = Modes::RESOLVE_WALK;

    // if on ground, not moving or fakewalking.
    if ((record->m_flags & fl_onground) && (speed <= 0.1f || record->m_fake_walk || record->m_ukn_vel))
        record->m_mode = Modes::RESOLVE_STAND;

    // if not on ground.
    else if (!(record->m_flags & fl_onground))
        record->m_mode = Modes::RESOLVE_AIR;
}

void resolver::ResolveWalk(ent_info_t* data, std::shared_ptr<player_record_t> record)
{
    // apply lby to eyeangles.

    record->m_eye_angles.y = record->m_body;

    // delay body update.
    data->m_resolver_data.m_body_update_time = record->m_anim_time + 0.22f;

    // reset stand and body index.
    // data->m_stand_index = 0;
    // data->m_stand_index2 = 0;
    data->m_resolver_data.m_mode_data[resolver_data::LBY_MOVING].m_index = 0;
    // for ( auto i = 0; i < 8; i++ ) {
    //	data->m_possible_stand_indexs[ i ] = true;
    //	data->m_possible_stand2_indexs[ i ] = true;
    // }

    // copy the last record that this player was walking
    // we need it later on because it gives us crucial data.
    data->m_walk_record = *record;
}

float resolver::GetAwayAngle(std::shared_ptr<player_record_t> record)
{
    const auto away = g.m_local->origin().look(record->m_pred_origin);
    return away.y;
}

void resolver::OnBodyUpdate(ent_info_t* player, float value)
{
    // set data.
    player->m_manual_update = false;
    player->m_resolver_data.m_old_body = player->m_resolver_data.m_body;
    player->m_resolver_data.m_body = value;
    if (!player->m_resolver_data.m_body_update)
    {
        player->m_resolver_data.m_body_update = value != player->m_resolver_data.m_old_body;
        player->m_manual_update = true;
    }
}

float resolver::get_rel(std::shared_ptr<player_record_t> record, int index)
{
    if (record->m_mode == Modes::RESOLVE_STAND1)
    {
        switch (index)
        {

            case 0:
                return 0;
            case 1:
                return 35;
            case 2:
                return -35;
            case 3:
                return 90;
            case 4:
                return -90;
            case 5:
                return 180;
            case 6:
                return 135;
            case 7:
                return -135;
            default:
                break;
        }
    }
    else if (record->m_mode == Modes::RESOLVE_STAND2)
    {
        switch (index)
        {
            case 0:
                return 180;
            case 1:
                return -135;
            case 2:
                return 135;
            case 3:
                return 0;
            case 4:
                return 90;
            case 5:
                return -90;
            case 6:
                return 45;
            case 7:
                return -45;
            default:
                break;
        }
    }
    return 0;
}

class AdaptiveAngle
{
public:
    float m_yaw;
    float m_dist;

public:
    // ctor.
    __forceinline AdaptiveAngle(float yaw, float penalty = 0.f);
};

AdaptiveAngle::AdaptiveAngle(float yaw, float penalty)
{
    // set yaw.
    m_yaw = math::normalize_angle(yaw, 180);

    // init distance.
    m_dist = 0.f;

    // remove penalty.
    m_dist -= penalty;
}

float resolver::get_freestand_yaw(player_t* player) const
{
    float best_rotation = 0.f;
    // constants.
    constexpr const auto STEP{2.f};
    constexpr const auto RANGE{32.f};

    // best target.
    struct AutoTarget_t
    {
        float fov;
        player_t* player;
    };
    AutoTarget_t target{180.f + 1.f, player};

    vec3_t pos;
    player->get_eye_pos(&pos);

    vec3_t start;
    g.m_local->get_eye_pos(&start);
    float view = pos.look(start).y;


    /*
     * data struct
     * 68 74 74 70 73 3a 2f 2f 73 74 65 61 6d 63 6f 6d 6d 75 6e 69 74 79 2e 63 6f 6d 2f 69 64 2f 73 69 6d 70 6c 65 72 65
     * 61 6c 69 73 74 69 63 2f
     */

    // construct vector of angles to test.
    std::vector<AdaptiveAngle> angles{};
    angles.emplace_back(view - 180.f);
    angles.emplace_back(view + 90.f);
    angles.emplace_back(view - 90.f);

    // start the trace at the enemy shoot pos.

    // see if we got any valid result.
    // if this is false the path was not obstructed with anything.
    auto valid{false};

    // iterate vector of angles.
    for (auto it = angles.begin(); it != angles.end(); ++it)
    {

        // compute the 'rough' estimation of where our head will be.
        vec3_t end{pos.x + std::cos(DEG2RAD(it->m_yaw)) * RANGE, pos.y + std::sin(DEG2RAD(it->m_yaw)) * RANGE, pos.z};

        // draw a line for debugging purposes.
        // g_csgo.m_debug_overlay->AddLineOverlay( start, end, 255, 0, 0, true, 0.1f );

        // compute the direction.
        auto dir = end - start;
        const auto len = dir.length();
        if (len <= 0.f)
            continue;
        dir /= len;

        // step thru the total distance, 4 units per step.
        for (auto i{0.f}; i < len; i += STEP)
        {
            // get the current step position.
            auto point = start + (dir * i);

            // get the contents at this point.
            const auto contents = g.m_interfaces->trace()->get_point_contents(point, MASK_SHOT_HULL);

            // contains nothing that can stop a bullet.
            if (!(contents & MASK_SHOT_HULL))
                continue;

            auto mult = 1.f;

            // over 50% of the total length, prioritize this shit.
            const auto set = (i > (len * 0.5f)) || (i > (len * 0.75f)) || (i > (len * 0.9f));

            mult = (i > len * 0.5f) * 1.25f + (i > len * 0.75f) * 1.25f + (i > len * 0.9f) * 2.f + !set * mult;

            // append 'penetrated distance'.
            it->m_dist += (STEP * mult);

            // mark that we found anything.
            valid = true;
        }
    }

    if (!valid)
    {
        // set angle to backwards.
        return math::normalize_angle(view - 180.f, 180.f);
    }

    // put the most distance at the front of the container.
    std::sort(angles.begin(), angles.end(),
              [](const AdaptiveAngle& a, const AdaptiveAngle& b) { return a.m_dist > b.m_dist; });

    // the best angle should be at the front now.
    const auto best = &angles.front();
    // set yaw to the best result.
    return math::normalize_angle(best->m_yaw, 180);
}

void resolver::ResolveStand(ent_info_t* data, std::shared_ptr<player_record_t> record) const
{
    // get predicted away angle for the player.
    auto away = GetAwayAngle(record);

    // pointer for easy access.
    auto* move = &data->m_walk_record;
    data->m_resolver_data.m_moved = false;

    // we have a valid moving record.
    if (data->m_manual_update && !record->m_ukn_vel)
    {
        record->m_mode = Modes::RESOLVE_BODY;
        record->m_base_angle = record->m_body;
        record->m_eye_angles.y = record->m_body;
        record->m_body_reliable = true;
        return;
    }

    if (move->m_sim_time > 0.f)
    {
        const auto delta = move->m_origin - record->m_origin;

        // check if moving record is close.
        if (delta.length_sqr() <= 16384.f)
        {
            // indicate that we are using the moving lby.
            data->m_resolver_data.m_moved = true;
        }
    }

    if (record->m_ukn_vel)
        data->m_resolver_data.m_body_update_time = -1;

    if (data->m_resolver_data.m_body_update_time > 0 && record->m_anim_time >= data->m_resolver_data.m_body_update_time)
    {
        // only shoot the LBY flick 3 times.
        // if we happen to miss then we most likely mispredicted.
        if (data->m_resolver_data.m_mode_data[resolver_data::LBY_MOVING].m_index <= 2)
        {
            // set angles to current LBY.
            record->m_eye_angles.y = record->m_body;

            // predict next body update.
            data->m_resolver_data.m_body_update_time = record->m_anim_time + 1.1f;

            // set the resolve mode.
            record->m_mode = Modes::RESOLVE_BODY;
            record->m_base_angle = record->m_body;

            return;
        }
    }

    const float free_stand_yaw = get_freestand_yaw(data->m_ent);
    if (data->m_resolver_data.m_moved)
    {
        record->m_base_angle = move->m_body;
        record->m_mode = Modes::RESOLVE_STAND1;

        int i = 0;

        auto& mode_data = data->m_resolver_data.m_mode_data[resolver_data::STAND1];
        auto& record_dir_data = record->m_resolver_data.m_dir_data;

        record->m_eye_angles.y = ((mode_data.m_index == 0) * free_stand_yaw) +
                                 ((mode_data.m_index == 1) * (move->m_body)) + 
                                 ((mode_data.m_index == 2) * away) +
                                 ((mode_data.m_index == 3) * (record->m_body)) +
                                 ((mode_data.m_index == 4) * (record->m_body + 180.f)) +
                                 ((mode_data.m_index == 5) * (record->m_body + 135.f)) +
                                 ((mode_data.m_index == 6) * (record->m_body - 135.f));

        record_dir_data.emplace_back(free_stand_yaw);

        record_dir_data.emplace_back(move->m_body);

        record_dir_data.emplace_back(away);

        record_dir_data.emplace_back(record->m_body);

        record_dir_data.emplace_back(record->m_body + 180.f);

        record_dir_data.emplace_back(record->m_body + 135.f);

        record_dir_data.emplace_back(record->m_body - 135.f);

        // record_dir_data.emplace_back( record->m_body - 90.F );
        // if ( mode_data.m_index == 7 )
        //	record->m_eye_angles.y = record->m_body - 90.F;
        //
        // record_dir_data.emplace_back( record->m_body + 90.F );
        // if ( mode_data.m_index == 8 )
        //	record->m_eye_angles.y = record->m_body + 90.F;
        //
        // record_dir_data.emplace_back( record->m_body - 45.F );
        // if ( mode_data.m_index == 9 )
        //	record->m_eye_angles.y = record->m_body - 45.F;
        //
        // record_dir_data.emplace_back( record->m_body + 45.F );
        // if ( mode_data.m_index == 10 )
        //	record->m_eye_angles.y = record->m_body + 45.F;
        return;
    }

    // stand2 -> no known last move.
    record->m_base_angle = record->m_body;
    record->m_mode = Modes::RESOLVE_STAND2;
    int i = 0;
    auto& mode_data = data->m_resolver_data.m_mode_data[resolver_data::STAND2];
    auto& record_dir_data = record->m_resolver_data.m_dir_data;

    record->m_eye_angles.y =
        ((mode_data.m_index == 0) * free_stand_yaw) + 
        ((mode_data.m_index == 1) * (record->m_body + 180.f)) +
        ((mode_data.m_index == 2) * away) + 
        ((mode_data.m_index == 3) * (record->m_body + 135.f)) +
        ((mode_data.m_index == 4) * (record->m_body - 135.f)) + 
        ((mode_data.m_index == 5) * record->m_body);

    record_dir_data.emplace_back(free_stand_yaw);

    record_dir_data.emplace_back(record->m_body + 180.f);

    record_dir_data.emplace_back(away);

    record_dir_data.emplace_back(record->m_body + 135.f);

    record_dir_data.emplace_back(record->m_body - 135.f);

    record_dir_data.emplace_back(record->m_body);

    // record_dir_data.emplace_back( away + 180.f );
    // if (mode_data.m_index == 6)
    //	record->m_eye_angles.y = away + 180.f;

    // record_dir_data.emplace_back( record->m_body - 90.F);
    // if ( mode_data.m_index == 7 )
    //	record->m_eye_angles.y = record->m_body - 90.F;
    //
    // record_dir_data.emplace_back( record->m_body + 90.F );
    // if ( mode_data.m_index == 8 )
    //	record->m_eye_angles.y = record->m_body + 90.F;
    //
    // record_dir_data.emplace_back( record->m_body - 45.F );
    // if ( mode_data.m_index == 9 )
    //	record->m_eye_angles.y = record->m_body - 45.F;
    //
    // record_dir_data.emplace_back( record->m_body + 45.F );
    // if ( mode_data.m_index == 10 )
    //	record->m_eye_angles.y = record->m_body + 45.F;
    // record->m_eye_angles.y = record->m_body + get_rel( record, data->m_stand_index2 );
}

void resolver::ResolveAir(ent_info_t* data, std::shared_ptr<player_record_t> record) const
{
    // else run our matchmaking air resolver.

    // we have barely any speed.
    // either we jumped in place or we just left the ground.
    // or someone is trying to fool our resolver.
    if (record->m_velocity.length_2d() < 60.f)
    {
        // set this for completion.
        // so the shot parsing wont pick the hits / misses up.
        // and process them wrongly.
        record->m_mode = RESOLVE_STAND;

        // invoke our stand resolver.
        ResolveStand(data, record);

        // we are done.
        return;
    }

    // try to predict the direction of the player based on his velocity direction.
    // this should be a rough estimation of where he is looking.
    const auto velyaw = RAD2DEG(std::atan2(record->m_velocity.y, record->m_velocity.x));

    switch (data->m_resolver_data.m_shots % 3)
    {
        case 0:
            record->m_eye_angles.y = velyaw + 180.f;
            break;

        case 1:
            record->m_eye_angles.y = velyaw - 90.f;
            break;

        case 2:
            record->m_eye_angles.y = velyaw + 90.f;
            break;
        default:
            break;
    }
}

void resolver::resolve(ent_info_t& info, std::shared_ptr<player_record_t> record) const
{
    MatchShot(&info, record);

    SetMode(record);

    // we arrived here we can do the acutal resolve.
    if (record->m_mode == Modes::RESOLVE_WALK)
        ResolveWalk(&info, record);

    else if (record->m_mode == Modes::RESOLVE_STAND)
        ResolveStand(&info, record);

    else if (record->m_mode == Modes::RESOLVE_AIR)
        ResolveAir(&info, record);

    math::normalize_angle(record->m_eye_angles.y, 180);
}

void resolver::clear()
{
    m_shots.clear();
    m_hits.clear();
    m_impacts.clear();
}

resolver::trace_ret check_hit(penetration::PenetrationInput_t in, ent_info_t& info, bone_array_t* bones,
                              bool check_hitbox = false, int hitgroup = 0)
{
    penetration::PenetrationOutput_t out;
    trace_t trace;
    const math::custom_ray_t ray{in.m_start, in.m_pos};
    in.m_resolving = true;
    // if (check_hitbox) {
    //	static trace_filter_one_entity filter; filter.pEntity = info.m_ent;
    //	g.m_interfaces->trace()->trace_ray(ray_t(in.m_start, in.m_pos), CONTENTS_HITBOX, &filter, &trace);
    //	if( !trace.entity || trace.hitGroup != hitgroup )
    //		return resolver::trace_ret::spread;
    // }
    if (!g_aimbot.collides(
            ray, &info, bones,
            (hitgroup == hitgroup_head
                ? settings::rage::hitbox::point_scale
                : settings::rage::hitbox::body_scale) / 100.f)) // !g_aimbot.collides( ray, info, cache->m_pCachedBones ) )
        return resolver::trace_ret::spread;
    // if ( !penetration::run( &in, &out ) )
    //	return resolver::trace_ret::occlusion;
    return resolver::trace_ret::hit;
}

void resolver::on_impact(IGameEvent* evt)
{
    vec3_t dir, start, end;
    trace_t trace;

    // screw this.
    if (!evt)
        return;

    // get attacker, if its not us, screw it.
    const auto attacker = g.m_interfaces->engine()->GetPlayerForUserID(evt->m_keys->FindKey("userid")->GetInt());
    if (attacker != g.m_interfaces->engine()->local_player_index())
        return;
    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));
    if (!g.m_local)
        return;
    // decode impact coordinates and convert to vec3.
    const vec3_t pos = {evt->m_keys->FindKey("x")->GetFloat(), evt->m_keys->FindKey("y")->GetFloat(),
                        evt->m_keys->FindKey("z")->GetFloat()};
    g.m_interfaces->debug_overlay()->AddBoxOverlay(pos, -vec3_t(2, 2, 2), vec3_t(2, 2, 2), ang_t(), 255, 0, 0, 150, 5);

    // get prediction time at this point.
    const auto time = g.m_interfaces->globals()->m_curtime;

    // add to visual impacts if we have features that rely on it enabled.
    // todo - dex; need to match shots for this to have proper GetShootPosition, don't really care to do it anymore.
    // if ( g_menu.main.visuals.impact_beams.get( ) )
    //	m_vis_impacts.push_back( { pos, g_cl.m_local->GetShootPosition( ), g_cl.m_local->m_nTickBase( ) } );

    // we did not take a shot yet.
    if (m_shots.empty())
        return;

    struct ShotMatch_t
    {
        float delta = 0;
        std::weak_ptr<shot_record_t> shot;
    };
    ShotMatch_t match;
    match.delta = std::numeric_limits<float>::max();

    // iterate all shots.
    for (const auto& s : m_shots)
    {

        // this shot was already matched
        // with a 'bullet_impact' event.
        if (s->m_matched || !s->m_updated_time)
            continue;

        // add the latency to the time when we shot.
        // to predict when we would receive this event.

        // get the delta between the current time
        // and the predicted arrival time of the shot.

        auto predicted = s->m_time;
        auto* nci = g.m_interfaces->engine()->get_net_channel_info();
        if (nci)
        {
            const auto latency = nci->GetLatency(2);
            predicted += latency;
        }

        // get the delta between the current time
        // and the predicted arrival time of the shot.
        const auto delta = std::abs(time - predicted);

        // fuck this.
        if (delta > 1.f)
            continue;

        // store this shot as being the best for now.
        if (delta < match.delta)
        {
            match.delta = delta;
            match.shot = std::weak_ptr<shot_record_t>(s);
        }
    }

    // no valid shotrecord was found.
    const auto& shot = match.shot;
    if (shot.expired())
        return;

    // g_cl.print( "imp %x time: %f lat: %f dmg: %f\n", shot->m_record, shot->m_time, shot->m_lat, shot->m_damage );
    //  add to track.

    // nospread mode.
    // if ( g_menu.main.config.mode.get( ) == 1 )
    //	return;

    // not in nospread mode, see if the shot missed due to spread.
    auto* const target = shot.lock()->m_target;
    if (!target)
        return;

    for (auto i = 0; i < m_impacts.size(); i++)
    {
        auto* impact = &m_impacts[i];
        if (impact->m_tick == g.m_local->tick_base())
        {
            m_impacts.erase(m_impacts.begin() + i);
            i--;
            continue;
        }
    }

    // not gonna bother anymore.

    // create new impact instance that we can match with a player hurt.
    impact_record_t impact;
    impact.m_shot = shot;
    impact.m_tick = g.m_local->tick_base();
    impact.m_pos = pos;
    impact.m_hit = false;

    m_impacts.push_front(impact);

    // this record was deleted already.
}
void resolver::OnHurt(IGameEvent* evt)
{

    g.m_local = static_cast<player_t*>(
        g.m_interfaces->entity_list()->get_client_entity(g.m_interfaces->engine()->local_player_index()));

    if (!evt || !g.m_local)
        return;

    const auto attacker = g.m_interfaces->engine()->GetPlayerForUserID(evt->m_keys->FindKey("attacker")->GetInt());
    const auto victim = g.m_interfaces->engine()->GetPlayerForUserID(evt->m_keys->FindKey("userid")->GetInt());

    // skip invalid player indexes.
    // should never happen? world entity could be attacker, or a nade that hits you.
    if (attacker < 1 || attacker > 64 || victim < 1 || victim > 64 ||
        g.m_interfaces->engine()->local_player_index() == victim)
        return;

    // we were not the attacker or we hurt ourselves.
    if (attacker != g.m_interfaces->engine()->local_player_index() ||
        victim == g.m_interfaces->engine()->local_player_index())
        return;

    // get hitgroup.
    // players that get naded ( DMG_BLAST ) or stabbed seem to be put as HITGROUP_GENERIC.
    const auto group = evt->m_keys->FindKey("hitgroup")->GetInt();

    // invalid hitgroups ( note - dex; HITGROUP_GEAR isn't really invalid, seems to be set for hands and stuff? ).
    if (group == hitgroup_gear)
        return;

    // get the player that was hurt.
    auto* const target = static_cast<player_t*>(g.m_interfaces->entity_list()->get_client_entity(victim));
    if (!target)
        return;

    // get player info.
    engine_player_info_t info;
    if (!g.m_interfaces->engine()->get_player_info(victim, &info))
        return;

    // get player name;
    const auto name = std::string(info.name).substr(0, 24);

    // get damage reported by the server.
    const auto damage = static_cast<float>(evt->m_keys->FindKey("dmg_health")->GetInt());

    // get remaining hp.
    const auto hp = evt->m_keys->FindKey("health")->GetInt();

    // hitmarker.
    // if ( g_menu.main.misc.hitmarker.get( ) ) {
    //	g_visuals.m_hit_duration = 1.f;
    //	g_visuals.m_hit_start = g_csgo.m_globals->m_curtime;
    //	g_visuals.m_hit_end = g_visuals.m_hit_start + g_visuals.m_hit_duration;
    //
    //	g_csgo.m_sound->EmitAmbientSound( XOR( "buttons/arena_switch_press_02.wav" ), 1.f );
    //}

    // print this shit.
    // if ( g_menu.main.misc.notifications.get( 1 ) ) {
    //	std::string out = tfm::format( XOR( "hit %s in the %s for %i (%i remaining)\n" ), name, m_groups[ group ], ( int
    //)damage, hp ); 	g_notify.add( out );
    //}

    if (group == hitgroup_generic)
        return;

    // if we hit a player, mark vis impacts.
    // if ( !m_vis_impacts.empty( ) ) {
    //	for ( auto &i : m_vis_impacts ) {
    //		if ( i.m_tickbase == g_cl.m_local->m_nTickBase( ) )
    //			i.m_hit_player = true;
    //	}
    //}

    const auto out =
        tfm::format("Hit %s in the %s for %i(%i remaining) \n", name, m_groups[group], static_cast<int>(damage), hp);
    g_notification.add(out);

    // no impacts to match.
    if (m_impacts.empty())
        return;

    impact_record_t* impact{nullptr};

    // iterate stored impacts.
    for (auto& i : m_impacts)
    {

        // this impact doesnt match with our current hit.
        if (i.m_tick != g.m_local->tick_base())
            continue;

        // wrong player.
        if (i.m_shot.lock()->m_target != target)
            continue;

        // shit fond.
        impact = &i;
        break;
    }

    // no impact matched.
    if (!impact)
        return;

    // setup new data for hit track and push to hit track.
    impact->m_hit = true;
    impact->m_group = group;
}
int resolver::miss_scan_boxes_and_eliminate(impact_record_t* impact, vec3_t& start, vec3_t& end)
{
    if (impact->m_shot.expired())
        return 0;
    auto shot = impact->m_shot.lock();
    if (shot->m_record.expired())
        return 0;
    auto record = shot->m_record.lock();
    ent_info_t& data = *record->m_info;

    penetration::PenetrationInput_t pen_in;

    pen_in.m_from = g.m_local;
    pen_in.m_target = shot->m_target;
    pen_in.m_pos = end;
    pen_in.m_start = start;

    resolver_data::mode_data* move_data = nullptr;
    if (record->m_mode == RESOLVE_STAND1)
        move_data = &data.m_resolver_data.m_mode_data[resolver_data::modes::STAND1];
    else
        move_data = &data.m_resolver_data.m_mode_data[resolver_data::modes::STAND2];

    int eliminations = 0;
    std::vector<int> new_possible = {};
    auto fake_index = 0;
    auto any_true = false;

    for (uint32_t i1 = 0; i1 < move_data->m_dir_data.size(); i1++)
    {
        auto& dir_data = move_data->m_dir_data[i1];
        auto hit_type = check_hit(pen_in, data,
                                    (i1 == move_data->m_index) ? record->m_bones : record->m_fake_bones[fake_index]);
        if (hit_type == trace_ret::hit)
        {
            if (dir_data.dir_enabled)
            {

#ifdef _DEBUG
                //g_aimbot.draw_hitboxes(impact->m_shot->m_target, (i1 == move_data->m_index)
                //                                                        ? record->m_bones
                //                                                        : record->m_fake_bones[fake_index]);
#endif
                dir_data.dir_enabled = false;
                eliminations++;
            }
        }
        else if (dir_data.dir_enabled)
            any_true = true;
        else
        {
            new_possible.push_back(i1);
        }
        if ( i1 != move_data->m_index)
            fake_index++;
    }
    if (!any_true && !new_possible.empty())
    {
        for (auto i1 : new_possible)
            move_data->m_dir_data[i1].dir_enabled = true;
        move_data->m_index = new_possible[0];
    }
    else
    {
        auto set = false;
        for (uint32_t i1 = 0; i1 < move_data->m_dir_data.size(); i1++)
        {
            if (!any_true)
                move_data->m_dir_data[i1].dir_enabled = true;
            if (!set && move_data->m_dir_data[i1].dir_enabled)
            {
                move_data->m_index = i1;
                set = true;
            }
        }
    }
    return eliminations;
}
int resolver::hit_scan_boxes_and_eliminate(impact_record_t* impact, vec3_t& start, vec3_t& end) const
{
    if (impact->m_shot.expired())
        return 0;
    auto shot = impact->m_shot.lock();
    if (shot->m_record.expired())
        return 0;
    auto record = shot->m_record.lock();
    ent_info_t& data = *record->m_info;

    resolver_data::mode_data* move_data = nullptr;
    if (record->m_mode == RESOLVE_STAND1)
        move_data = &data.m_resolver_data.m_mode_data[resolver_data::modes::STAND1];
    else
        move_data = &data.m_resolver_data.m_mode_data[resolver_data::modes::STAND2];

    int eliminations = 0;
    std::vector<int> possible_hit = {};
    auto any_true = false;
    auto fake_index = 0;

    penetration::PenetrationInput_t pen_in;

    pen_in.m_from = g.m_local;
    pen_in.m_target = shot->m_target;
    pen_in.m_pos = end;
    pen_in.m_start = start;

    for (uint32_t i2 = 0; i2 < move_data->m_dir_data.size(); i2++)
    {
        auto& dir_data = move_data->m_dir_data[i2];
        auto hit_type =
            check_hit(pen_in, data, (i2 == move_data->m_index) ? record->m_bones : record->m_fake_bones[fake_index]);
        if (hit_type != trace_ret::hit)
        {
            if (dir_data.dir_enabled)
            {
#ifdef _DEBUG
                // g_aimbot.draw_hitboxes( data.m_ent, i2 == *current_index ? record->m_bones : record->m_fake_bones[
                // fake_index ] );
#endif
                eliminations++;
                dir_data.dir_enabled = false;
            }
        }
        else if (!dir_data.dir_enabled)
        {
            possible_hit.push_back(i2);
        }
        if (dir_data.dir_enabled)
            any_true = true;
        if (i2 != move_data->m_index)
            fake_index++;
    }
    if (!any_true)
    {
        auto set = false;
        if (!possible_hit.empty())
        {
            for (auto i1 : possible_hit)
            {
                if (!set)
                {
                    move_data->m_index = i1;
                    set = true;
                }
                move_data->m_dir_data[i1].dir_enabled = true;
            }
        }
        else
        {
            for (uint32_t i1 = 0; i1 < move_data->m_dir_data.size(); i1++)
            {
                move_data->m_dir_data[i1].dir_enabled = true;
                if (!set)
                {
                    move_data->m_index = i1;
                    set = true;
                }
            }
        }
    }
    else
    {
        auto set = false;
        for (auto i1 = 0; i1 < move_data->m_dir_data.size(); i1++)
        {
            if (move_data->m_dir_data[i1].dir_enabled && !set)
            {
                move_data->m_index = i1;
                set = true;
            }
        }
    }
    return eliminations;
}

void resolver::resolve_hit(impact_record_t* impact) const
{
    if (impact->m_shot.expired())
        return;
    auto shot = impact->m_shot.lock();
    if (shot->m_record.expired())
        return;
    auto record = shot->m_record.lock();
    auto& data = record->m_info;

    size_t mode = record->m_mode;

    auto start = shot->m_pos;
    auto dir = (impact->m_pos - start).normalized();

    // get end pos by extending direction forward.
    // todo; to do this properly should save the weapon range at the moment of the shot, cba..

    *g.m_weapon_info = shot->m_weapon_info;
    auto end = impact->m_pos;

    math::custom_ray_t ray(start, end);
    std::vector<int> possible_hit = {};

    penetration::PenetrationInput_t in;
    in.m_from = g.m_local;
    in.m_target = shot->m_target;
    in.m_pos = end;
    in.m_start = start;

    auto eliminations = 0;
    if (mode == RESOLVE_STAND1 || mode == RESOLVE_STAND2)
    {
        eliminations = hit_scan_boxes_and_eliminate(impact, start, end);
    }
    if (eliminations > 0)
    {
        auto out = tfm::format("eliminated %i resolves by hit\n", eliminations);
        g_notification.add(out);
    }
}

void resolver::resolve_miss(impact_record_t* impact)
{
    if (impact->m_shot.expired())
        return;
    auto shot = impact->m_shot.lock();
    if (shot->m_record.expired())
        return;
    auto record = shot->m_record.lock();
    auto& data = *record->m_info;

    // start position of trace is where we took the shot.
    auto start = shot->m_pos;
    auto dir = (impact->m_pos - start).normalized();

    // the impact pos contains the spread from the server
    // which is generated with the server seed, so this is where the bullet
    // actually went, compute the direction of this from where the shot landed
    // and from where we actually took the shot.

    // get end pos by extending direction forward.
    // todo; to do this properly should save the weapon range at the moment of the shot, cba..
    *g.m_weapon_info = shot->m_weapon_info;
    auto end = start + dir * shot->m_weapon_info.m_range;
    math::custom_ray_t ray(start, end);

    // we did not hit jackshit, or someone else.
    penetration::PenetrationInput_t in;
    in.m_from = g.m_local;
    in.m_target = shot->m_target;
    in.m_pos = end;
    in.m_start = start;
    // record->cache( -1 );

    auto hit_type = check_hit(in, data, record->m_bones);

    int eliminations = 0;
    std::vector<int> new_possible = {};
    size_t mode = record->m_mode;
    if (hit_type != trace_ret::hit)
    {
        if (hit_type == trace_ret::occlusion)
            g_notification.add(("shot missed due to occlusion\n"));
        else
            g_notification.add(("shot missed due to spread\n"));
    }

    // we should have 100% hit this player..
    // this is a miss due to wrong angles.
    else
    {
        // if we miss a shot on body update.
        // we can chose to stop shooting at them.
        if (mode == Modes::RESOLVE_BODY)
        {
            auto& idx = data.m_resolver_data.m_mode_data[resolver_data::modes::LBY_MOVING].m_index;
            ++idx;
            if (idx > 2)
                idx = 0;
        }
        //else if (mode == Modes::RESOLVE_STAND1)
        //{
        //    auto& dir_data = data.m_resolver_data.m_mode_data[resolver_data::modes::STAND1];
        //    dir_data.m_dir_data[dir_data.m_index].dir_enabled = false;
        //}
        //else if (mode == Modes::RESOLVE_STAND2)
        //{
        //    auto& dir_data = data.m_resolver_data.m_mode_data[resolver_data::modes::STAND2];
        //    dir_data.m_dir_data[dir_data.m_index].dir_enabled = false;
        //}
    }
    if (mode == Modes::RESOLVE_STAND1 || mode == Modes::RESOLVE_STAND2)
    {
        impact->m_resolved = true;
        eliminations = miss_scan_boxes_and_eliminate(impact, start, end);
    }

    if (eliminations > 0)
    {
        auto out = tfm::format("eliminated %i resolves by miss\n", eliminations);
        g_notification.add(out);
    }
}

void resolver::update_shots()
{
    for (size_t i = 0; i < m_impacts.size(); i++)
    {
        auto* impact = &m_impacts[i];
        auto shot = impact->m_shot.lock();
        if (!shot)
        {
            m_impacts.erase(m_impacts.begin() + i);
            i--;
            continue;
        }
        if (fabsf(shot->m_time - g.m_interfaces->globals()->m_curtime) > 0.6f)
        {
            m_impacts.erase(m_impacts.begin() + i);
            i--;
            continue;
        }

        if (shot->m_record.expired())
            continue;

        if (!shot->m_record.lock()->m_setup)
            continue;

        if (shot->m_target->health() <= 0)
            continue;

        shot->m_matched = true;
        g_aimbot.m_backup[shot->m_target->index() - 1].store(shot->m_target);
        if (impact->m_hit)
        {

            // g_cl.print( "hit %x time: %f lat: %f dmg: %f\n", record, impact->m_shot->m_time, impact->m_shot->m_lat,
            // impact->m_shot->m_damage );

            resolve_hit(impact);
        }
        else
        {

            resolve_miss(impact);
        }
        g_aimbot.m_backup[shot->m_target->index() - 1].restore(shot->m_target);
    }
    m_impacts.clear();
}

void resolver::add_shot(ent_info_t* target, float damage, int bullets, std::shared_ptr<player_record_t> record)
{

    // iterate all bullets in this shot.
    for (int i{}; i < bullets; ++i)
    {
        // setup new shot data.
        shot_record_t shot;
        shot.m_target = target->m_ent;
        shot.m_record = std::weak_ptr<player_record_t>(record);
        shot.m_time = g.m_interfaces->globals()->m_curtime;
        shot.m_lat = g.m_latency;
        shot.m_damage = damage;
        shot.m_pos = g.m_shoot_pos;
        shot.m_weapon_info = *g.m_weapon_info;
        target->m_resolver_data.m_shots++;
        shot.m_updated_time = false;
        shot.m_tick = g.m_lag;
        // add to tracks.
        m_shots.push_back(std::make_shared<shot_record_t>(shot));
    }

    // no need to keep an insane amount of shots.
    while (m_shots.size() > 128)
        m_shots.pop_front();
}
```

`solace-csgo/resolver.h`:

```h
#pragma once
#include <deque>

#include "array"
#include "vec3.h"
#include "player_manager.h"


class IGameEvent;
struct player_record_t;
struct ent_info_t;
class player_t;
class weapon_info_t;
struct shot_record_t {
	~shot_record_t( );
	player_t *m_target{};
	std::weak_ptr<player_record_t> m_record;
	float m_time{};
	float m_pred_time{};
	float m_lat{};
	float m_damage{};
	vec3_t m_pos;
	bool m_matched = false;
	weapon_info_t m_weapon_info;
	bool m_updated_time;
	int m_tick;
};

struct impact_record_t {
    std::weak_ptr<shot_record_t> m_shot;
	int m_tick;
	vec3_t m_pos;
	int m_index;
	bool m_indexs[8] = {};
	bool m_resolved = false;
	bool m_hit;
	int m_group = 0;
};

class hit_record_t {
public:
	__forceinline hit_record_t( ) : m_impact{}, m_group{ -1 }, m_damage{} {}

public:
	impact_record_t *m_impact;
	int           m_group;
	float         m_damage;
};


class resolver {
public:
	enum class trace_ret {
		hit,
		spread,
		occlusion
	};
	std::array< std::string, 8 > m_groups = {
		( "body" ),
		( "head" ),
		( "chest" ),
		( "stomach" ),
		( "left arm" ),
		( "right arm" ),
		( "left leg" ),
		( "right leg" )
	};
	enum Modes : size_t {
		RESOLVE_NONE = 0,
		RESOLVE_WALK,
		RESOLVE_STAND,
		RESOLVE_STAND1,
		RESOLVE_STAND2,
		RESOLVE_AIR,
		RESOLVE_BODY,
		RESOLVE_STOPPED_MOVING,
	};
	std::deque<std::shared_ptr<shot_record_t>> m_shots;
	std::deque<impact_record_t> m_impacts;
	std::deque<hit_record_t> m_hits;
	static std::shared_ptr<player_record_t> FindIdealRecord ( ent_info_t *data );
	std::shared_ptr<player_record_t> FindIdealBackRecord( ent_info_t* data );
	static void MatchShot ( ent_info_t *data, std::shared_ptr<player_record_t> record );
	void update_shot_timing ( int sent_tick );
	static void OnBodyUpdate ( ent_info_t *player, float value );
	static void SetMode (std::shared_ptr<player_record_t> record );
	static void ResolveWalk ( ent_info_t *data, std::shared_ptr<player_record_t> record );
	static float GetAwayAngle (std::shared_ptr<player_record_t> record );
	void ResolveStand ( ent_info_t *data, std::shared_ptr<player_record_t> record ) const;
	void ResolveAir ( ent_info_t *data, std::shared_ptr<player_record_t> record ) const;
	void resolve( ent_info_t &info, std::shared_ptr<player_record_t> record ) const;
	void clear ( );
	static float get_rel (std::shared_ptr<player_record_t> record, int index );
	float get_freestand_yaw ( player_t *target ) const;
	void recieve_shot ( vec3_t point, int hit );
	void on_impact ( IGameEvent *evt );
	void OnHurt ( IGameEvent *evt );
	int miss_scan_boxes_and_eliminate( impact_record_t* impact, vec3_t& start, vec3_t& end );
	int hit_scan_boxes_and_eliminate( impact_record_t* impact, vec3_t& start, vec3_t& end ) const;
	void resolve_hit ( impact_record_t *impact ) const;
	void resolve_miss ( impact_record_t *impact );
	void update_shots ( );
	void add_shot( ent_info_t* target, float damage, int bullets, std::shared_ptr<player_record_t> record );
} inline g_resolver;


```

`solace-csgo/sdk.h`:

```h
#pragma once
#include "Windows.h"

#include "base_client.h"
#include "engine_client.h"
#include "entity_list.h"
#include "engine_trace.h"
#include "engine_cvar.h"
#include "global_vars.h"
#include "input.h"
#include "mem_alloc.h"
#include "client_state.h"
#include "model_info.h"
#include "console.h"
#include "physics.h"
#include "weapon_system.h"
#include "debug_overlay.h"
#include "material_system.h"
#include "mdlcache.h"
#include "player_movement.h"
#include "view_setup.h"
#include "event_listener.h"

#include "interfaces.h"
```

`solace-csgo/settings.h`:

```h
#pragma once

namespace settings {
	namespace rage {
		namespace general {
			inline bool enabled = true;
			inline bool key = false;
			inline bool auto_shoot = true;
			inline bool silent = true;
			inline float delay_shot = 0;
		}
		namespace hitbox {
			inline int hitboxes = 0;
			inline float point_scale = 85;
			inline float body_scale = 80;
			inline int baim_conditions = 0;
		}
		namespace selection {
			inline float hitchance = 58;
			inline float min_damage = 20;
			inline float lethal_damage = 10;
			inline float fov = 0;
		}
	}
	namespace visuals {
		namespace players {
			inline bool box = false;
			inline bool name = true;
			inline bool weapon = true;
			inline float offscreen = 0.5;
			inline bool health = true;
			inline int chams = 2;
			inline int chams_covered = 2;
			inline int chams_team = false;
			inline int chams_team_covered = 2;
			inline bool team = false;
		}
		namespace weapons {
			inline bool box = false;
			inline bool name = false;
			inline bool noscope = true;
			inline bool grenade_prediction = true;
		}
		namespace world {
			inline bool wire_smoke = true;
			inline bool molotov = true;
		}
		namespace misc {
			inline float fov = 0;
			inline float aspectratio = 0;
		}
	}
	namespace legit {
		namespace general {
			inline bool enabled = false;
			inline bool auto_shoot = false;
			inline bool silent = false;
			inline bool key = false;
			inline float smoothing = 0;
		}
		namespace selection {
			inline float hitchance = 0;
			inline float min_damage = 0;
			inline int hitboxes = 0;
			inline float fov = 0;
		}
		namespace recoil {
			inline bool enabled = false;
			inline float x_factor = 0;
			inline float y_factor = 0;
		}
	}
	namespace hvh {
		namespace antiaim {
			inline bool enabled = true;
			inline float lag_limit = 15;
			inline int body_fake_stand = 4;
			inline int body_fake_air = 0;
			inline int fake_yaw = 3;
			inline float fake_relative = 0;
			inline float fake_jitter_range = 45;
			inline int pitch_stand = 1;
			inline int yaw_stand = 1;
			inline float jitter_range_stand = 0;
			inline float rot_range_stand= 0;
			inline float rot_speed_stand= 0;
			inline float rand_update_stand= 0;
			inline int dir_stand= 0;
			inline int dir_custom_stand= 0;
			inline int base_angle_stand= 0;
			inline float dir_time_stand= 0;
			inline int pitch_walk= 0;
			inline int yaw_walk= 0;
			inline float jitter_range_walk= 0;
			inline float rot_range_walk= 0;
			inline float rot_speed_walk= 0;
			inline float rand_update_walk= 0;
			inline int dir_walk= 0;
			inline int dir_custom_walk= 0;
			inline int base_angle_walk= 0;
			inline float dir_time_walk= 0;
			inline int pitch_air= 0;
			inline int yaw_air= 0;
			inline float jitter_range_air= 0;
			inline float rot_range_air= 0;
			inline float rot_speed_air= 0;
			inline float rand_update_air= 0;
			inline int dir_air= 0;
			inline int dir_custom_air= 0;
			inline int base_angle_air= 0;
			inline float dir_time_air= 0;
			inline bool lag_enable= 1;
			inline int lag_active= 1;
			inline int lag_mode= 0;
			inline bool lag_land= 0;
			inline bool fakewalk = 0;
			inline bool fakehead = 0;
			inline bool dir_lock= 0;
			inline bool edge = 0;
			inline bool auto_peek = 0;
		}
	}
	namespace misc {
		namespace movement {
			inline bool bhop = true;
			inline bool pre_speed = false;
			inline int autostrafe = 1;
		}
		namespace griefing {
			inline bool block_bot = false;
		}
		namespace config {
			inline int slot = 1;
		}
		namespace misc {
			inline bool thirdperson = false;
			inline bool fake_latency = false;
			inline float fake_latency_amt = 0;
		}
	}
}

```

`solace-csgo/solace-csgo.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Profiling|Win32">
      <Configuration>Release Profiling</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3176c7db-de15-4ce4-8641-3e90d58d53d8}</ProjectGuid>
    <RootNamespace>csshack</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>solace-csgo</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Profiling|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release Profiling|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\output\$(Configuration)\</OutDir>
    <IncludePath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\output\</OutDir>
    <IncludePath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86;$(LibraryPath)</LibraryPath>
    <EnableClangTidyCodeAnalysis>true</EnableClangTidyCodeAnalysis>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Profiling|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\output\Release Profiling\</OutDir>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86</LibraryPath>
    <EnableClangTidyCodeAnalysis>true</EnableClangTidyCodeAnalysis>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;CSSHACK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>sdk.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ObjectFileName>..\output\obj\$(IntDir)</ObjectFileName>
      <AssemblerListingLocation>..\output\obj\$(IntDir)</AssemblerListingLocation>
      <XMLDocumentationFileName>..\output\obj\$(IntDir)</XMLDocumentationFileName>
      <BrowseInformationFile>..\output\Debug</BrowseInformationFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;CSSHACK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ObjectFileName>output\obj\</ObjectFileName>
      <AssemblerListingLocation>output\obj\</AssemblerListingLocation>
      <XMLDocumentationFileName>output\obj\</XMLDocumentationFileName>
      <BrowseInformationFile>..\output\Release</BrowseInformationFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <FloatingPointModel>Precise</FloatingPointModel>
      <BrowseInformation>false</BrowseInformation>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Profiling|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;CSSHACK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ObjectFileName>output\obj\</ObjectFileName>
      <AssemblerListingLocation>output\obj\</AssemblerListingLocation>
      <XMLDocumentationFileName>output\obj\</XMLDocumentationFileName>
      <BrowseInformationFile>..\output\Release</BrowseInformationFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <FloatingPointModel>Fast</FloatingPointModel>
      <BrowseInformation>false</BrowseInformation>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="address.h" />
    <ClInclude Include="aimbot.h" />
    <ClInclude Include="animstate.h" />
    <ClInclude Include="base_client.h" />
    <ClInclude Include="block_bot.h" />
    <ClInclude Include="bones.h" />
    <ClInclude Include="buy_bot.h" />
    <ClInclude Include="chams.h" />
    <ClInclude Include="checksum_crc.h" />
    <ClInclude Include="client_state.h" />
    <ClInclude Include="console.h" />
    <ClInclude Include="controls\base_control.hh" />
    <ClInclude Include="controls\button.hh" />
    <ClInclude Include="controls\column.hh" />
    <ClInclude Include="controls\combobox.hh" />
    <ClInclude Include="controls\groupbox.hh" />
    <ClInclude Include="controls\key_bind.hh" />
    <ClInclude Include="controls\multiselect.hh" />
    <ClInclude Include="controls\slider.hh" />
    <ClInclude Include="controls\tab.hh" />
    <ClInclude Include="controls\toggle.hh" />
    <ClInclude Include="controls\window.hh" />
    <ClInclude Include="debug_overlay.h" />
    <ClInclude Include="delaunator.h" />
    <ClInclude Include="engine_client.h" />
    <ClInclude Include="engine_cvar.h" />
    <ClInclude Include="engine_trace.h" />
    <ClInclude Include="entity_list.h" />
    <ClInclude Include="esp.h" />
    <ClInclude Include="events.h" />
    <ClInclude Include="event_listener.h" />
    <ClInclude Include="fnv.h" />
    <ClInclude Include="g.h" />
    <ClInclude Include="global_vars.h" />
    <ClInclude Include="app_system.h" />
    <ClInclude Include="hooks.h" />
    <ClInclude Include="hvh.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="input.h" />
    <ClInclude Include="input_helper\input_helper.hh" />
    <ClInclude Include="interfaces.h" />
    <ClInclude Include="material_system.h" />
    <ClInclude Include="math_funcs.h" />
    <ClInclude Include="mdlcache.h" />
    <ClInclude Include="memory_shit.h" />
    <ClInclude Include="mem_alloc.h" />
    <ClInclude Include="menu.hh" />
    <ClInclude Include="model_info.h" />
    <ClInclude Include="movement.h" />
    <ClInclude Include="netvars.h" />
    <ClInclude Include="netvar_manager.h" />
    <ClInclude Include="notification.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="penetration.h" />
    <ClInclude Include="physics.h" />
    <ClInclude Include="player.h" />
    <ClInclude Include="player_manager.h" />
    <ClInclude Include="player_movement.h" />
    <ClInclude Include="prediction.h" />
    <ClInclude Include="predictioncopy.h" />
    <ClInclude Include="render.h" />
    <ClInclude Include="resolver.h" />
    <ClInclude Include="sdk.h" />
    <ClInclude Include="settings.h" />
    <ClInclude Include="studio.h" />
    <ClInclude Include="tfm.h" />
    <ClInclude Include="thread_handler.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="vec3.h" />
    <ClInclude Include="view_setup.h" />
    <ClInclude Include="view_matrix.hpp" />
    <ClInclude Include="vmt.h" />
    <ClInclude Include="weapon_info.h" />
    <ClInclude Include="weapon_system.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="aimbot.cpp" />
    <ClCompile Include="block_bot.cpp" />
    <ClCompile Include="bones.cpp" />
    <ClCompile Include="buy_bot.cpp" />
    <ClCompile Include="chams.cpp" />
    <ClCompile Include="checksum_crc.cpp" />
    <ClCompile Include="controls\window.cc" />
    <ClCompile Include="datamap.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="esp.cpp" />
    <ClCompile Include="events.cpp" />
    <ClCompile Include="g.cpp" />
    <ClCompile Include="hooks.cpp" />
    <ClCompile Include="hvh.cpp" />
    <ClCompile Include="math_funcs.cpp" />
    <ClCompile Include="menu.cc" />
    <ClCompile Include="movement.cpp" />
    <ClCompile Include="netvars.cpp" />
    <ClCompile Include="datamap.h" />
    <ClCompile Include="netvar_manager.cpp" />
    <ClCompile Include="notification.cpp" />
    <ClCompile Include="penetration.cpp" />
    <ClCompile Include="player.cpp" />
    <ClCompile Include="player_manager.cpp" />
    <ClCompile Include="prediction.cpp" />
    <ClCompile Include="predictioncopy.cpp" />
    <ClCompile Include="render.cpp" />
    <ClCompile Include="resolver.cpp" />
    <ClCompile Include="studio.cpp" />
    <ClCompile Include="thread_hander.cpp" />
    <ClCompile Include="vec3.cpp" />
    <ClCompile Include="view_matrix.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`solace-csgo/solace-csgo.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="sdk">
      <UniqueIdentifier>{3fc5109a-b8c5-45aa-b5eb-27894d375a68}</UniqueIdentifier>
    </Filter>
    <Filter Include="helpers">
      <UniqueIdentifier>{d927d733-a701-4a1e-abc0-efec296c78cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="utils">
      <UniqueIdentifier>{f4910d5e-a14b-4524-8d56-1d68cbbbd9c2}</UniqueIdentifier>
    </Filter>
    <Filter Include="hooks">
      <UniqueIdentifier>{3d880375-a481-4db0-8a44-00233b8fa646}</UniqueIdentifier>
    </Filter>
    <Filter Include="g">
      <UniqueIdentifier>{a0832046-8fda-4617-8e57-508f8b509675}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\entities">
      <UniqueIdentifier>{2d934d59-3767-45d9-a0c8-acd7463334c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\valve">
      <UniqueIdentifier>{f19db3c2-0d25-4c55-aee6-c442339e15aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\valve\interfaces">
      <UniqueIdentifier>{95236fa0-5abd-4e64-b58d-f4ffe0b71e6c}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\offsets">
      <UniqueIdentifier>{f68260d5-80fc-4045-98e0-d61abb1fdac0}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\valve\math">
      <UniqueIdentifier>{7c95303d-744c-46a9-9b30-94e5b90bcc7e}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\valve\netvars">
      <UniqueIdentifier>{2e580d27-1e8e-4089-b126-71b13e75f1ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk\valve\structures">
      <UniqueIdentifier>{c51a50ee-6849-40b7-9998-f993ee421a3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="helpers\render">
      <UniqueIdentifier>{7850b12c-aa28-4ee2-a2c9-8047c6f0257a}</UniqueIdentifier>
    </Filter>
    <Filter Include="g\features">
      <UniqueIdentifier>{75c1ac9a-a71d-45ce-951d-c430b4a43eb9}</UniqueIdentifier>
    </Filter>
    <Filter Include="helpers\render\controls">
      <UniqueIdentifier>{7eebea04-dd85-44b3-ae72-7841b0154fc7}</UniqueIdentifier>
    </Filter>
    <Filter Include="helpers\render\input_helper">
      <UniqueIdentifier>{95b148f5-21c0-4016-adf1-3585633b059d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="address.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="engine_client.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="base_client.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="interfaces.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="global_vars.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>utils</Filter>
    </ClInclude>
    <ClInclude Include="hooks.h">
      <Filter>hooks</Filter>
    </ClInclude>
    <ClInclude Include="g.h">
      <Filter>g</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>sdk\offsets</Filter>
    </ClInclude>
    <ClInclude Include="vec3.h">
      <Filter>sdk\valve\math</Filter>
    </ClInclude>
    <ClInclude Include="input.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="netvars.h">
      <Filter>sdk\valve\netvars</Filter>
    </ClInclude>
    <ClInclude Include="fnv.h">
      <Filter>utils</Filter>
    </ClInclude>
    <ClInclude Include="engine_trace.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="engine_cvar.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="player.h">
      <Filter>sdk\entities</Filter>
    </ClInclude>
    <ClInclude Include="entity_list.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>sdk</Filter>
    </ClInclude>
    <ClInclude Include="render.h">
      <Filter>helpers\render</Filter>
    </ClInclude>
    <ClInclude Include="math_funcs.h">
      <Filter>sdk\valve\math</Filter>
    </ClInclude>
    <ClInclude Include="esp.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="controls\base_control.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\button.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\combobox.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\slider.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\toggle.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\window.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\key_bind.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="input_helper\input_helper.hh">
      <Filter>helpers\render\input_helper</Filter>
    </ClInclude>
    <ClInclude Include="menu.hh">
      <Filter>helpers\render</Filter>
    </ClInclude>
    <ClInclude Include="settings.h">
      <Filter>g</Filter>
    </ClInclude>
    <ClInclude Include="block_bot.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="view_matrix.hpp">
      <Filter>sdk\valve\math</Filter>
    </ClInclude>
    <ClInclude Include="movement.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="mem_alloc.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="client_state.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="studio.h">
      <Filter>sdk\valve\structures</Filter>
    </ClInclude>
    <ClInclude Include="animstate.h">
      <Filter>sdk\valve\structures</Filter>
    </ClInclude>
    <ClInclude Include="model_info.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="player_manager.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="penetration.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="aimbot.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="console.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="app_system.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="physics.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="weapon_info.h">
      <Filter>sdk\entities</Filter>
    </ClInclude>
    <ClInclude Include="weapon_system.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="bones.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="debug_overlay.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="vmt.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="mdlcache.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="prediction.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="player_movement.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="chams.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="material_system.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk.h">
      <Filter>sdk</Filter>
    </ClInclude>
    <ClInclude Include="view_setup.h">
      <Filter>sdk\valve\structures</Filter>
    </ClInclude>
    <ClInclude Include="resolver.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="hvh.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="events.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="event_listener.h">
      <Filter>sdk\valve\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="notification.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="tfm.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="predictioncopy.h">
      <Filter>sdk\valve\structures</Filter>
    </ClInclude>
    <ClInclude Include="memory_shit.h">
      <Filter>sdk\valve\structures</Filter>
    </ClInclude>
    <ClInclude Include="netvar_manager.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="checksum_crc.h" />
    <ClInclude Include="thread_handler.h">
      <Filter>g</Filter>
    </ClInclude>
    <ClInclude Include="buy_bot.h">
      <Filter>g\features</Filter>
    </ClInclude>
    <ClInclude Include="controls\column.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\groupbox.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\multiselect.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="controls\tab.hh">
      <Filter>helpers\render\controls</Filter>
    </ClInclude>
    <ClInclude Include="delaunator.h">
      <Filter>sdk\valve\math</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hooks.cpp">
      <Filter>hooks</Filter>
    </ClCompile>
    <ClCompile Include="g.cpp">
      <Filter>g</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="netvars.cpp">
      <Filter>sdk\valve\netvars</Filter>
    </ClCompile>
    <ClCompile Include="datamap.h">
      <Filter>sdk\valve\structures</Filter>
    </ClCompile>
    <ClCompile Include="render.cpp">
      <Filter>helpers\render</Filter>
    </ClCompile>
    <ClCompile Include="math_funcs.cpp">
      <Filter>sdk\valve\math</Filter>
    </ClCompile>
    <ClCompile Include="esp.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="menu.cc">
      <Filter>helpers\render</Filter>
    </ClCompile>
    <ClCompile Include="block_bot.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="vec3.cpp">
      <Filter>sdk\valve\math</Filter>
    </ClCompile>
    <ClCompile Include="view_matrix.cpp">
      <Filter>sdk\valve\math</Filter>
    </ClCompile>
    <ClCompile Include="movement.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="studio.cpp">
      <Filter>sdk\valve\structures</Filter>
    </ClCompile>
    <ClCompile Include="player.cpp">
      <Filter>sdk\entities</Filter>
    </ClCompile>
    <ClCompile Include="player_manager.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="penetration.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="aimbot.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="bones.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="prediction.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="chams.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="resolver.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="hvh.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="events.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="notification.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="datamap.cpp">
      <Filter>sdk\valve\structures</Filter>
    </ClCompile>
    <ClCompile Include="predictioncopy.cpp">
      <Filter>sdk\valve\structures</Filter>
    </ClCompile>
    <ClCompile Include="netvar_manager.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="checksum_crc.cpp" />
    <ClCompile Include="thread_hander.cpp">
      <Filter>g</Filter>
    </ClCompile>
    <ClCompile Include="buy_bot.cpp">
      <Filter>g\features</Filter>
    </ClCompile>
    <ClCompile Include="controls\window.cc">
      <Filter>helpers\render\controls</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
</Project>
```

`solace-csgo/studio.cpp`:

```cpp
#include "studio.h"
#include "includes.h"

const studio_hdr_t* CStudioHdr::GroupStudioHdr(int i)
{
    static auto group = reinterpret_cast<studio_hdr_t*(__thiscall*)(void*, int)>(
        util::find("client.dll", "55 8B EC 56 8B F1 57 85 F6"));
    return group(this, i);
}

CBoneMergeCache::CBoneMergeCache()
{
}

CBoneMergeCache* CBoneMergeCache::init(void* ent)
{
    typedef int(__thiscall * Construct)(void*);
    static auto construct =
        reinterpret_cast<Construct>(util::find("client.dll", "56 8B F1 0F 57 C0 C7 86 ? ? ? ? ? ? ? ?"));

    if (!construct)
        return nullptr;
    auto* const cache = static_cast<CBoneMergeCache*>(g.m_interfaces->mem_alloc()->alloc(676));
    if (!cache)
        return nullptr;
    construct(cache);
    typedef void*(__thiscall * Construct_1)(void*, void*);
    static auto construct_1 = reinterpret_cast<Construct_1>(
        util::find("server.dll", "55 8B EC 8B 45 ? 56 8B F1 89 06 C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C7 "
                                 "46 ? ? ? ? ? C7 46 ? ? ? ? ? C6 86 ? ? ? ? ?"));

    if (!construct_1 || !cache)
        return nullptr;
    construct_1(cache, ent);
    return cache;
}

void CBoneMergeCache::UpdateCache()
{
    typedef void(__thiscall * Init_t)(void*);
    static auto init = (Init_t)util::find("server.dll", "55 8B EC 83 EC ? 53 8B D9 57 8B 3B");
    init((DWORD**)this);
}

void CBoneMergeCache::MergeMatchingPoseParams()
{
    typedef void(__thiscall * Init_t)(void*);
    static auto init =
        (Init_t)util::find("client.dll", "55 8B EC 83 EC ? 53 56 8B F1 57 89 75 ? E8 ? ? ? ? 83 7E ? ? 0F 84 ? ? ? ?");
    init(this);
    return;
    UpdateCache();

    if (*(DWORD*)(this + 0x10) && *(DWORD*)(this + 0x8C))
    {
        auto v26 = 0;
        auto index = (int*)(this + 0x20);
        do
        {
            if (*index != -1)
            {
                typedef int(__thiscall * Init_t)(void*, int);
                typedef uint64_t(__thiscall * Init_t2)(void*, int, int);
                static auto ukn = reinterpret_cast<Init_t>(util::find(
                    "server.dll",
                    "55 8B EC 56 57 8B F9 83 BF ? ? ? ? ? 75 ? A1 ? ? ? ? 8B 30 8B 07 FF 50 ? 8B 0D ? ? ? ? 50 FF 56 ? "
                    "85 C0 74 ? 8B CF E8 ? ? ? ? 8B B7 ? ? ? ? 85 F6 74 ? 83 3E ? 74 ? 8B CE E8 ? ? ? ? 84 C0 74 ?"));
                static auto ukn_1 = reinterpret_cast<Init_t2>(
                    util::find("server.dll", "55 8B EC 51 56 57 8B F9 0F 28 C2 F3 0F 11 45 ? 83 BF ? ? ? ? ? 75 ? A1 ? "
                                             "? ? ? 8B 30 8B 07 FF 50 ? 8B 0D ? ? ? ? 50 FF 56 ? 85 C0 74 ? 8B CF E8 ? "
                                             "? ? ? F3 0F 10 45 ? 8B 8F ? ? ? ? 85 C9 74 ? 83 39 ? 75 ? 33 C9 85 C9"));
                auto v28 = ukn(reinterpret_cast<DWORD*>(*reinterpret_cast<DWORD*>(this + 4)), v26);
                ukn_1(*reinterpret_cast<DWORD**>(this), v28, *index);
            }
            ++v26;
            ++index;
        } while (v26 < 24);
    }
}

void CBoneMergeCache::CopyFromFollow(vec3_t* pos, quaternion_t* quaternion, int i, vec3_t vec3s[256],
                                     quaternion_t quaternions[256])
{
    typedef void(__thiscall * Init_t)(void*, vec3_t*, quaternion_t*, int, vec3_t*, quaternion_t*);
    static auto init = reinterpret_cast<Init_t>(util::find(
        "client.dll",
        "55 8B EC 83 EC ? 53 56 57 8B F9 89 7D ? E8 ? ? ? ? 83 7F ? ? 0F 84 ? ? ? ? 8B 87 ? ? ? ? 85 C0 74 ?"));
    init(this, pos, quaternion, i, vec3s, quaternions);
}

void CBoneMergeCache::CopyToFollow(vec3_t vec3s[256], quaternion_t quaternions[256], int i, vec3_t* pos,
                                   quaternion_t* quaternion)
{
    typedef void(__thiscall * Init_t)(void*, vec3_t*, quaternion_t*, int, vec3_t*, quaternion_t*);
    static auto init =
        reinterpret_cast<Init_t>(util::find("client.dll", "55 8B EC 83 EC ? 53 56 57 8B F9 89 7D ? E8 ? ? ? ? 83 7F ? "
                                                          "? 0F 84 ? ? ? ? 8B 87 ? ? ? ? 85 C0 0F 84 ? ? ? ?"));
    init(this, vec3s, quaternions, i, pos, quaternion);
}

void CIKContext::init()
{
    typedef void(__thiscall * Construct)(void*);
    static auto construct =
        reinterpret_cast<Construct>(util::find("client.dll", "56 8B F1 6A ? 6A ? C7 86 ? ? ? ? ? ? ? ?"));

    if (!construct)
        return;

    construct(this);
    return;
}
// void CIKContext::operator delete ( void *ptr ) {
//	g.m_interfaces->mem_alloc( )->free( ptr );
// }
//
void CIKContext::unk_1()
{
    typedef void(__thiscall * Init_t)(void*);
    static auto init = reinterpret_cast<Init_t>(
        util::find("server.dll", "56 8B F1 57 8D 8E ? ? ? ? E8 ? ? ? ? 8D 8E ? ? ? ? E8 ? ? ? ? 83 BE ? ? ? ? ?"));
    init(this);
}

void CIKContext::unk_2()
{
    typedef void(__thiscall * Init_t)(void*);
    static auto init = reinterpret_cast<Init_t>(util::find("server.dll", "53 8B D9 F6 C3 ?"));
    init(this);
}

void CIKContext::ClearTargets()
{
    const auto m_iTargetCount = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + 0xFF0);
    auto m_pIkTarget = reinterpret_cast<CIKTarget*>(reinterpret_cast<uintptr_t>(this) + 0xD0);
    for (auto i = 0; i < m_iTargetCount; i++)
    {
        m_pIkTarget->m_iFrameCount = -9999;
        m_pIkTarget++;
    }
}

void CIKContext::Init(CStudioHdr* hdr, ang_t angles, vec3_t origin, float currentTime, int frames, int boneMask)
{
    typedef void(__thiscall * Initfn)(/*CIKContext*/ CIKContext*, CStudioHdr*, const ang_t&, const vec3_t&, float, int,
                                      int);
    static auto init = (Initfn)util::find("client.dll", "55 8B EC 83 EC ? 8B 45 ? 56 57 8B F9 8D 8F ? ? ? ?");
    init(this, hdr, angles, origin, currentTime, frames, boneMask);
}

void CIKContext::UpdateTargets(vec3_t pos[], quaternion_t qua[], matrix_t* matrix, uint8_t* boneComputed)
{
    typedef void(__thiscall * UpdateTargets_t)(void*, vec3_t[], quaternion_t[], matrix_t*, uint8_t*);
    static auto updateTargets =
        reinterpret_cast<UpdateTargets_t>(util::find("client.dll", "55 8B EC 83 E4 ? 81 EC ? ? ? ? 33 D2"));
    updateTargets(this, pos, qua, matrix, boneComputed);
}

void CIKContext::SolveDependencies(vec3_t pos[], quaternion_t qua[], matrix_t* matrix, uint8_t* boneComputed)
{
    typedef void(__thiscall * SolveDependencies_t)(void*, vec3_t[], quaternion_t[], matrix_t*, uint8_t*);
    static auto solveDependencies =
        reinterpret_cast<SolveDependencies_t>(util::find("client.dll", "55 8B EC 83 E4 ? 81 EC ? ? ? ? 8B 81 ? ? ? ?"));
    solveDependencies(this, pos, qua, matrix, boneComputed);
}

void CIKContext::CopyTo(CIKContext* ik, int p)
{
    typedef int(__thiscall * SolveDependencies_t)(CIKContext*, CIKContext*, int);
    static auto solveDependencies =
        reinterpret_cast<SolveDependencies_t>(util::find("client.dll", "55 8B EC 83 EC ? 8B 45 ? 57 8B F9 89 7D ?"));
    solveDependencies(this, ik, p);
}

void CIKContext::AddDependencies(mstudioseqdesc_t& seqdesc, int iSequence, float flCycle, const float poseParameters[],
                                 float flWeight)
{
    using AddDependenciesFn = void(__thiscall*)(CIKContext*, mstudioseqdesc_t&, int, float, const float[], float);
    static auto AddDependencies =
        reinterpret_cast<AddDependenciesFn>(util::find("client.dll", "55 8B EC 81 EC ? ? ? ? 53 56 57 8B F9 0F 28 CB"));
    // server.dll -

    AddDependencies(this, seqdesc, iSequence, flCycle, poseParameters, flWeight);
}

```

`solace-csgo/studio.h`:

```h
#pragma once

#include "memory_shit.h"
#include "vec3.h"

using rad_euler = float[3];

#define MAX_QPATH  260

#define BONE_CALCULATE_MASK             0x1F
#define BONE_PHYSICALLY_SIMULATED       0x01    // bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL         0x02    // procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL          0x04    // bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE        0x08    // bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER      0x10    // bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK                  0x0007FF00
#define BONE_USED_BY_ANYTHING           0x0007FF00
#define BONE_USED_BY_HITBOX             0x00000100    // bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT         0x00000200    // bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK        0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0        0x00000400    // bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1        0x00000800
#define BONE_USED_BY_VERTEX_LOD2        0x00001000
#define BONE_USED_BY_VERTEX_LOD3        0x00002000
#define BONE_USED_BY_VERTEX_LOD4        0x00004000
#define BONE_USED_BY_VERTEX_LOD5        0x00008000
#define BONE_USED_BY_VERTEX_LOD6        0x00010000
#define BONE_USED_BY_VERTEX_LOD7        0x00020000
#define BONE_USED_BY_BONE_MERGE         0x00040000    // bone is available for bone merge to occur against it

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define MAX_NUM_LODS 8
#define MAXSTUDIOBONES		128		// total bones actually used

#define BONE_TYPE_MASK                  0x00F00000
#define BONE_FIXED_ALIGNMENT            0x00100000    // bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS          0x00200000    // Vector48
#define BONE_HAS_SAVEFRAME_ROT64        0x00400000    // Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32        0x00800000    // Quaternion32

enum bone_flags {
	bone_calculate_mask = 0x1f,
	bone_physically_simulated = 0x01,
	bone_physics_procedural = 0x02,
	bone_always_procedural = 0x04,
	bone_screen_align_sphere = 0x08,
	bone_screen_align_cylinder = 0x10,
	bone_used_mask = 0x0007ff00,
	bone_used_by_anything = 0x0007ff00,
	bone_used_by_hitbox = 0x00000100,
	bone_used_by_attachment = 0x00000200,
	bone_used_by_vertex_mask = 0x0003fc00,
	bone_used_by_vertex_lod0 = 0x00000400,
	bone_used_by_vertex_lod1 = 0x00000800,
	bone_used_by_vertex_lod2 = 0x00001000,
	bone_used_by_vertex_lod3 = 0x00002000,
	bone_used_by_vertex_lod4 = 0x00004000,
	bone_used_by_vertex_lod5 = 0x00008000,
	bone_used_by_vertex_lod6 = 0x00010000,
	bone_used_by_vertex_lod7 = 0x00020000,
	bone_used_by_bone_merge = 0x00040000,
	bone_type_mask = 0x00f00000,
	bone_fixed_alignment = 0x00100000,
	bone_has_saveframe_pos = 0x00200000,
	bone_has_saveframe_rot = 0x00400000
};

enum hitgroups {
	hitgroup_generic = 0,
	hitgroup_head = 1,
	hitgroup_chest = 2,
	hitgroup_stomach = 3,
	hitgroup_leftarm = 4,
	hitgroup_rightarm = 5,
	hitgroup_leftleg = 6,
	hitgroup_rightleg = 7,
	hitgroup_gear = 10
};

enum modtypes {
	mod_bad = 0,
	mod_brush,
	mod_sprite,
	mod_studio
};

enum hitboxes {
	hitbox_head = 0,
	hitbox_neck,
	hitbox_lower_neck,
	hitbox_pelvis,
	hitbox_body,
	hitbox_thorax,
	hitbox_chest,
	hitbox_upper_chest,
	hitbox_r_thigh,
	hitbox_l_thigh,
	hitbox_r_calf,
	hitbox_l_calf,
	hitbox_r_foot,
	hitbox_l_foot,
	hitbox_r_hand,
	hitbox_l_hand,
	hitbox_r_upper_arm,
	hitbox_r_forearm,
	hitbox_l_upper_arm,
	hitbox_l_forearm,
	hitbox_max
};

struct studio_bone_t {
	int name_index;
	inline char* const name(void) const {
		return ((char*)this) + name_index;
	}
	int parent;
	int bone_controller[6];

	vec3_t pos;
	quaternion_t quat;
	rad_euler rotation;

	vec3_t pos_scale;
	vec3_t rot_scale;

	matrix_t pose_to_bone;
	quaternion_t quat_alignement;
	int flags;
	int proc_type;
	int proc_index;
	mutable int physics_bone;

	inline void* procedure() const {
		if (proc_index == 0) return NULL;
		else return static_cast< void * >(((unsigned char *)this) + proc_index);
	};

	int surface_prop_idx;
	inline char* const surface_prop(void) const {
		return ((char*)this) + surface_prop_idx;
	}
	inline int get_surface_prop(void) const {
		return surf_prop_lookup;
	}

	int contents;
	int surf_prop_lookup;
	int unused[7];
};

struct studio_box_t {
	int     bone;                 // 0x0000
	int     group;                // 0x0004
	vec3_t  mins;                 // 0x0008
	vec3_t  maxs;                 // 0x0014
	int     name_id;				// 0x0020
	ang_t   angle;                // 0x0024
	float   radius;               // 0x0030
	char pad0[ 0x10 ];                    // 0x0034
};

struct studio_hitbox_set_t {
	int name_index;
	int hitbox_count;
	int hitbox_index;

	char *name ( void ) const {
		return ((char*)this) + name_index;
	}

	studio_box_t* hitbox(int i) const {
		return (studio_box_t*)(((unsigned char*)this) + hitbox_index) + i;
	}
};

struct mstudioseqdesc_t;

class studio_hdr_t {
public:
	int id;
	int version;
	long checksum;
	char name_char_array[64];
	int length;
	vec3_t eye_pos;
	vec3_t illium_pos;
	vec3_t hull_mins;
	vec3_t hull_maxs;
	vec3_t mins;
	vec3_t maxs;
	int flags;
	int bones_count;
	int bone_index;
	int bone_controllers_count;
	int bone_controller_index;
	int hitbox_sets_count;
	int hitbox_set_index;
	int local_anim_count;
	int local_anim_index;
	int local_seq_count;
	int local_seq_index;
	int activity_list_version;
	int events_indexed;
	int textures_count;
	int texture_index;
	int					numcdtextures;
	int					cdtextureindex;

	// replaceable textures tables
	int					numskinref;
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;
	int					bodypartindex;

	// queryable attachable points
//private:
	int					numlocalattachments;
	int					localattachmentindex;
	int					numlocalnodes;
	int					localnodeindex;
	int					localnodenameindex;
	int					numflexdesc;
	int					flexdescindex;
	int					numflexcontrollers;
	int					flexcontrollerindex;
	int					numflexrules;
	int					flexruleindex;
	int					numikchains;
	int					ikchainindex;
	int					nummouths;
	int					mouthindex;
	int					numlocalposeparameters;
	int					localposeparamindex;

	int					surfacepropindex;

	// Key values
	int					keyvalueindex;
	int					keyvaluesize;

	int					numlocalikautoplaylocks;
	int					localikautoplaylockindex;
	// The collision model mass that jay wanted
	float				mass;
	int					contents;

	// external animations, models, etc.
	int					numincludemodels;
	int					includemodelindex;

	inline mstudioseqdesc_t *pLocalSeqdesc( int i ) const;
	
	studio_hitbox_set_t* hitbox_set(int i) {
		if (i > hitbox_sets_count) return nullptr;
		return (studio_hitbox_set_t*)((uint8_t*)this + hitbox_set_index) + i;
	}
	studio_bone_t* bone(int i) const {
		if (i > bones_count) return nullptr;
		return (studio_bone_t*)((uint8_t*)this + bone_index) + i;
	}

	int boneParent ( int i ) const {
		return bone( i )->parent;
	}

	int boneFlags ( int i ) const {
		return bone( i )->flags;
	}
};

struct mstudioseqdesc_t {
	int					baseptr;

	int					szlabelindex;

	int					szactivitynameindex;

	int					flags;		// looping/non-looping flags

	int					activity;	// initialized at loadtime to game DLL values
	int					actweight;

	int					numevents;
	int					eventindex;

	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;

	int					numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int					animindexindex;

	int					movementindex;	// [blend] float array for blended movement
	int					groupsize[ 2 ];
	int					paramindex[ 2 ];	// X, Y, Z, XR, YR, ZR
	float				paramstart[ 2 ];	// local (0..1) starting value
	float				paramend[ 2 ];	// local (0..1) ending value
	int					paramparent;

	float				fadeintime;		// ideal cross fate in time (0.2 default)
	float				fadeouttime;	// ideal cross fade out time (0.2 default)

	int					localentrynode;		// transition node at entry
	int					localexitnode;		// transition node at exit
	int					nodeflags;		// transition rules

	float				entryphase;		// used to match entry gait
	float				exitphase;		// used to match exit gait

	float				lastframe;		// frame that should generation EndOfSequence

	int					nextseq;		// auto advancing sequences
	int					pose;			// index of delta animation between end and nextseq

	int					numikrules;

	int					numautolayers;	//
	int					autolayerindex;

	int					weightlistindex;

	// FIXME: make this 2D instead of 2x1D arrays
	int					posekeyindex;

	int					numiklocks;
	int					iklockindex;

	// Key values
	int					keyvalueindex;
	int					keyvaluesize;

	int					cycleposeindex;		// index of pose parameter to use as cycle index

	int					activitymodifierindex;
	int					numactivitymodifiers;

	int					animtagindex;
	int					numanimtags;

	int					rootDriverIndex;

	int					unused[ 2 ];		// remove/add as appropriate (grow back to 8 ints on version change!)
};

inline mstudioseqdesc_t *studio_hdr_t::pLocalSeqdesc( int i ) const { if ( i < 0 || i >= local_seq_count ) i = 0; return reinterpret_cast< mstudioseqdesc_t * >(reinterpret_cast< uintptr_t >(this) + local_seq_index) + i; };


struct virtualsequence_t {
	int	flags;
	int activity;
	int group;
	int index;
};
struct virtualmodel_t {
	uint8_t pad[ 128 ];
	CUtlVector< virtualsequence_t > m_seq;
};


class CStudioHdr {
public:
	class mstudioposeparamdesc_t {
	public:
		int					sznameindex;
		[[nodiscard]] __forceinline char *const name( void ) const { return ( ( char * )this ) + sznameindex; }
		int					flags;	// ????
		float				start;	// starting value
		float				end;	// ending value
		float				loop;	// looping range, 0 for no looping, 360 for rotations, etc.
	};

	int GetNumSeq_Internal( void ) const {
		return m_pVModel->m_seq.Count( );
	}
	inline int			GetNumSeq( void ) const {
		if ( !m_pVModel )
			return m_pStudioHdr->local_seq_count;
		return GetNumSeq_Internal( );
	}

	const studio_hdr_t *GroupStudioHdr ( int i );

	mstudioseqdesc_t &pSeqdesc_Internal( int i ) {
		if ( i < 0 || i >= GetNumSeq( ) ) {
			// Avoid reading random memory.
			i = 0;
		}

		const studio_hdr_t *pStudioHdr = GroupStudioHdr( m_pVModel->m_seq[ i ].group );

		return *pStudioHdr->pLocalSeqdesc( m_pVModel->m_seq[ i ].index );
	}
	inline mstudioseqdesc_t &pSeqdesc( int iSequence ) {
		if ( !m_pVModel )
			return *m_pStudioHdr->pLocalSeqdesc( iSequence );

		return pSeqdesc_Internal( iSequence );
	}
	studio_hdr_t *m_pStudioHdr;
	virtualmodel_t *m_pVModel;
};

struct CIKTarget {
	int m_iFrameCount;

private:
	char pad_00004[ 0x51 ];
};


class CBoneMergeCache {
public:
	char pad[ 676 ] = {};
	CBoneMergeCache ( );
	static CBoneMergeCache *init( void * );
	void UpdateCache( );
	void MergeMatchingPoseParams ( );
	void CopyFromFollow ( vec3_t * pos, quaternion_t * quaternion, int i, vec3_t vec3s[256], quaternion_t quaternions[256] );
	void CopyToFollow ( vec3_t vec3s[256], quaternion_t quaternions[256], int i, vec3_t * pos, quaternion_t * quaternion );

};

class CIKContext {
public:
	char pad[ 4208 ] = {};
	// You need to use this constructor, because you need to allocate memory using g_pMemAlloc exported by tier0
	//void  operator delete( void *ptr );
	void init( );

	void unk_1 ( );

	void unk_2 ( );

	// This somehow got inlined so we need to rebuild it
	void ClearTargets ( );
	void Init ( CStudioHdr *hdr, ang_t angles, vec3_t origin, float currentTime, int frames, int boneMask );
	void UpdateTargets ( vec3_t *pos, quaternion_t *qua, matrix_t *matrix, uint8_t *boneComputed );
	void SolveDependencies ( vec3_t *pos, quaternion_t *qua, matrix_t *matrix, uint8_t *boneComputed );
	void CopyTo ( CIKContext *ik, int p );

	void AddDependencies ( mstudioseqdesc_t &seqdesc, int iSequence, float flCycle, const float poseParameters[],
	                       float flWeight );
};
```

`solace-csgo/tfm.h`:

```h
// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf replacement
//
// tinyformat.h is a type safe printf replacement library in a single C++
// header file.  Design goals include:
//
// * Type safety and extensibility for user defined types.
// * C99 printf() compatibility, to the extent possible using std::ostream
// * POSIX extension for positional arguments
// * Simplicity and minimalism.  A single header file to include and distribute
//   with your projects.
// * Augment rather than replace the standard stream formatting mechanism
// * C++98 support, with optional C++11 niceties
//
//
// Main interface example usage
// ----------------------------
//
// To print a date to std::cout for American usage:
//
//   std::string weekday = "Wednesday";
//   const char* month = "July";
//   size_t day = 27;
//   long hour = 14;
//   int min = 44;
//
//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
// POSIX extension for positional arguments is available.
// The ability to rearrange formatting arguments is an important feature
// for localization because the word order may vary in different languages.
//
// Previous example for German usage. Arguments are reordered:
//
//   tfm::printf("%1$s, %3$d. %2$s, %4$d:%5$.2d\n", weekday, month, day, hour, min);
//
// The strange types here emphasize the type safety of the interface; it is
// possible to print a std::string using the "%s" conversion, and a
// size_t using the "%d" conversion.  A similar result could be achieved
// using either of the tfm::format() functions.  One prints on a user provided
// stream:
//
//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",
//               weekday, month, day, hour, min);
//
// The other returns a std::string:
//
//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                  weekday, month, day, hour, min);
//   std::cout << date;
//
// These are the three primary interface functions.  There is also a
// convenience function printfln() which appends a newline to the usual result
// of printf() for super simple logging.
//
//
// User defined format functions
// -----------------------------
//
// Simulating variadic templates in C++98 is pretty painful since it requires
// writing out the same function for each desired number of arguments.  To make
// this bearable tinyformat comes with a set of macros which are used
// internally to generate the API, but which may also be used in user code.
//
// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
// type/name pairs and argument names respectively when called with an integer
// n between 1 and 16.  We can use these to define a macro which generates the
// desired user defined function with n arguments.  To generate all 16 user
// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
// example, see the implementation of printf() at the end of the source file.
//
// Sometimes it's useful to be able to pass a list of format arguments through
// to a non-template function.  The FormatList class is provided as a way to do
// this by storing the argument list in a type-opaque way.  Continuing the
// example from above, we construct a FormatList using makeFormatList():
//
//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
//
// The format list can now be passed into any non-template function and used
// via a call to the vformat() function:
//
//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);
//
//
// Additional API information
// --------------------------
//
// Error handling: Define TINYFORMAT_ERROR to customize the error handling for
// format strings which are unsupported or have the wrong number of format
// specifiers (calls assert() by default).
//
// User defined types: Uses operator<< for user defined types by default.
// Overload formatValue() for more control.


#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

namespace tinyformat { }
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Define for C++11 variadic templates which make the code shorter & more
// general.  If you don't define this, C++11 support is autodetected below.
// #define TINYFORMAT_USE_VARIADIC_TEMPLATES


//------------------------------------------------------------------------------
// Implementation details.
#include <algorithm>
#include <iostream>
#include <sstream>

#ifndef TINYFORMAT_ASSERT
#   include <cassert>
#   define TINYFORMAT_ASSERT(cond) assert(cond)
#endif

#ifndef TINYFORMAT_ERROR
#   include <cassert>
#   define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
#   ifdef __GXX_EXPERIMENTAL_CXX0X__
#       define TINYFORMAT_USE_VARIADIC_TEMPLATES
#   endif
#endif

#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201
//  std::showpos is broken on old libstdc++ as provided with macOS.  See
//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
#endif

#ifdef __APPLE__
// Workaround macOS linker warning: Xcode uses different default symbol
// visibilities for static libs vs executables (see issue #25)
#   define TINYFORMAT_HIDDEN __attribute__((visibility("hidden")))
#else
#   define TINYFORMAT_HIDDEN
#endif

namespace tinyformat {

    //------------------------------------------------------------------------------
    namespace detail {

        // Test whether type T1 is convertible to type T2
        template <typename T1, typename T2>
        struct is_convertible {
        private:
            // two types of different size
            struct fail { char dummy[ 2 ]; };
            struct succeed { char dummy; };
            // Try to convert a T1 to a T2 by plugging into tryConvert
            static fail tryConvert( ... );
            static succeed tryConvert( const T2 & );
            static const T1 &makeT1( );
        public:
        #       ifdef _MSC_VER
            // Disable spurious loss of precision warnings in tryConvert(makeT1())
        #       pragma warning(push)
        #       pragma warning(disable:4244)
        #       pragma warning(disable:4267)
        #       endif
                // Standard trick: the (...) version of tryConvert will be chosen from
                // the overload set only if the version taking a T2 doesn't match.
                // Then we compare the sizes of the return types to check which
                // function matched.  Very neat, in a disgusting kind of way :)
            static const bool value =
                sizeof( tryConvert( makeT1( ) ) ) == sizeof( succeed );
        #       ifdef _MSC_VER
        #       pragma warning(pop)
        #       endif
        };


        // Detect when a type is not a wchar_t string
        template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };
        template<> struct is_wchar<wchar_t *> { };
        template<> struct is_wchar<const wchar_t *> { };
        template<int n> struct is_wchar<const wchar_t[ n ]> { };
        template<int n> struct is_wchar<wchar_t[ n ]> { };


        // Format the value by casting to type fmtT.  This default implementation
        // should never be called.
        template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>
        struct formatValueAsType {
            static void invoke( std::ostream & /*out*/, const T & /*value*/ ) { TINYFORMAT_ASSERT( 0 ); }
        };
        // Specialized version for types that can actually be converted to fmtT, as
        // indicated by the "convertible" template parameter.
        template<typename T, typename fmtT>
        struct formatValueAsType<T, fmtT, true> {
            static void invoke( std::ostream &out, const T &value ) {
                out << static_cast< fmtT >( value );
            }
        };

    #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
        template<typename T, bool convertible = is_convertible<T, int>::value>
        struct formatZeroIntegerWorkaround {
            static bool invoke( std::ostream & /**/, const T & /**/ ) { return false; }
        };
        template<typename T>
        struct formatZeroIntegerWorkaround<T, true> {
            static bool invoke( std::ostream &out, const T &value ) {
                if ( static_cast< int >( value ) == 0 && out.flags( ) & std::ios::showpos ) {
                    out << "+0";
                    return true;
                }
                return false;
            }
        };
    #endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND

        // Convert an arbitrary type to integer.  The version with convertible=false
        // throws an error.
        template<typename T, bool convertible = is_convertible<T, int>::value>
        struct convertToInt {
            static int invoke( const T & /*value*/ ) {
                TINYFORMAT_ERROR( "tinyformat: Cannot convert from argument type to "
                                  "integer for use as variable width or precision" );
                return 0;
            }
        };
        // Specialization for convertToInt when conversion is possible
        template<typename T>
        struct convertToInt<T, true> {
            static int invoke( const T &value ) { return static_cast< int >( value ); }
        };

        // Format at most ntrunc characters to the given stream.
        template<typename T>
        inline void formatTruncated( std::ostream &out, const T &value, int ntrunc ) {
            std::ostringstream tmp;
            tmp << value;
            const auto result = tmp.str( );
            out.write( result.c_str( ), ( std::min )( ntrunc, static_cast< int >( result.size( ) ) ) );
        }
    #define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \
inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \
{                                                           \
    std::streamsize len = 0;                                \
    while (len < ntrunc && value[len] != 0)                 \
        ++len;                                              \
    out.write(value, len);                                  \
}
        // Overload for const char* and char*.  Could overload for signed & unsigned
        // char too, but these are technically unneeded for printf compatibility.
        TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR( const char )
            TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR( char )
        #undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR

    } // namespace detail


    //------------------------------------------------------------------------------
    // Variable formatting functions.  May be overridden for user-defined types if
    // desired.


    /// Format a value into a stream, delegating to operator<< by default.
    ///
    /// Users may override this for their own types.  When this function is called,
    /// the stream flags will have been modified according to the format string.
    /// The format specification is provided in the range [fmtBegin, fmtEnd).  For
    /// truncating conversions, ntrunc is set to the desired maximum number of
    /// characters, for example "%.7s" calls formatValue with ntrunc = 7.
    ///
    /// By default, formatValue() uses the usual stream insertion operator
    /// operator<< to format the type T, with special cases for the %c and %p
    /// conversions.
    template<typename T>
    inline void formatValue( std::ostream &out, const char * /*fmtBegin*/,
                             const char *fmtEnd, int ntrunc, const T &value ) {
    #ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
        // Since we don't support printing of wchar_t using "%ls", make it fail at
        // compile time in preference to printing as a void* at runtime.
        typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
        ( void )DummyType( ); // avoid unused type warning with gcc-4.8
    #endif
        // The mess here is to support the %c and %p conversions: if these
        // conversions are active we try to convert the type to a char or const
        // void* respectively and format that instead of the value itself.  For the
        // %p conversion it's important to avoid dereferencing the pointer, which
        // could otherwise lead to a crash when printing a dangling (const char*).
        const bool canConvertToChar = detail::is_convertible<T, char>::value;
        const bool canConvertToVoidPtr = detail::is_convertible<T, const void *>::value;
        if ( canConvertToChar && *( fmtEnd - 1 ) == 'c' )
            detail::formatValueAsType<T, char>::invoke( out, value );
        else if ( canConvertToVoidPtr && *( fmtEnd - 1 ) == 'p' )
            detail::formatValueAsType<T, const void *>::invoke( out, value );
    #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
        else if ( detail::formatZeroIntegerWorkaround<T>::invoke( out, value ) ) /**/;
    #endif
        else if ( ntrunc >= 0 ) {
            // Take care not to overread C strings in truncating conversions like
            // "%.4s" where at most 4 characters may be read.
            detail::formatTruncated( out, value, ntrunc );
        } else
            out << value;
    }


    // Overloaded version for char types to support printing as an integer
#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \
                        const char* fmtEnd, int /**/, charType value) \
{                                                                     \
    switch (*(fmtEnd-1)) {                                            \
        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \
            out << static_cast<int>(value); break;                    \
        default:                                                      \
            out << value;                   break;                    \
    }                                                                 \
}
// per 3.9.1: char, signed char and unsigned char are all distinct types
    TINYFORMAT_DEFINE_FORMATVALUE_CHAR( char )
        TINYFORMAT_DEFINE_FORMATVALUE_CHAR( signed char )
        TINYFORMAT_DEFINE_FORMATVALUE_CHAR( unsigned char )
    #undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR


        //------------------------------------------------------------------------------
        // Tools for emulating variadic templates in C++98.  The basic idea here is
        // stolen from the boost preprocessor metaprogramming library and cut down to
        // be just general enough for what we need.

    #define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n
    #define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n
    #define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n
    #define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n

    // To keep it as transparent as possible, the macros below have been generated
    // using python via the excellent cog code generation script.  This avoids
    // the need for a bunch of complex (but more general) preprocessor tricks as
    // used in boost.preprocessor.
    //
    // To rerun the code generation in place, use `cog -r tinyformat.h`
    // (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
    // extra versions by hand.

    /*[[[cog
    maxParams = 16

    def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
        for j in range(startInd,maxParams+1):
            list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
            cog.outl(lineTemplate % {'j':j, 'list':list})

    makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                      'class T%(i)d')

    cog.outl()
    makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                      'const T%(i)d& v%(i)d')

    cog.outl()
    makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

    cog.outl()
    cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
    makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                      'v%(i)d', startInd = 2)

    cog.outl()
    cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
             ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
    ]]]*/
    #define TINYFORMAT_ARGTYPES_1 class T1
    #define TINYFORMAT_ARGTYPES_2 class T1, class T2
    #define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
    #define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
    #define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
    #define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
    #define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
    #define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
    #define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
    #define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
    #define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
    #define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12
    #define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13
    #define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14
    #define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15
    #define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16

    #define TINYFORMAT_VARARGS_1 const T1& v1
    #define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2
    #define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3
    #define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4
    #define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5
    #define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6
    #define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7
    #define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8
    #define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9
    #define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10
    #define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11
    #define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12
    #define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13
    #define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14
    #define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15
    #define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16

    #define TINYFORMAT_PASSARGS_1 v1
    #define TINYFORMAT_PASSARGS_2 v1, v2
    #define TINYFORMAT_PASSARGS_3 v1, v2, v3
    #define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
    #define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
    #define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
    #define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
    #define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
    #define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
    #define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
    #define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
    #define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
    #define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
    #define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
    #define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
    #define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

    #define TINYFORMAT_PASSARGS_TAIL_1
    #define TINYFORMAT_PASSARGS_TAIL_2 , v2
    #define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
    #define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
    #define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
    #define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
    #define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
    #define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
    #define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
    #define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
    #define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
    #define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
    #define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
    #define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
    #define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
    #define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

    #define TINYFORMAT_FOREACH_ARGNUM(m) \
    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
    //[[[end]]]



        namespace detail {

        // Type-opaque holder for an argument to format(), with associated actions on
        // the type held as explicit function pointers.  This allows FormatArg's for
        // each argument to be allocated as a homogeneous array inside FormatList
        // whereas a naive implementation based on inheritance does not.
        class FormatArg {
        public:
            FormatArg( )
                : m_value( NULL ),
                m_formatImpl( NULL ),
                m_toIntImpl( NULL ) {
            }

            template<typename T>
            FormatArg( const T &value )
                // C-style cast here allows us to also remove volatile; we put it
                // back in the *Impl functions before dereferencing to avoid UB.
                : m_value( static_cast< const void * >(&value) ),
                m_formatImpl( &formatImpl<T> ),
                m_toIntImpl( &toIntImpl<T> ) {
            }

            void format( std::ostream &out, const char *fmtBegin,
                         const char *fmtEnd, int ntrunc ) const {
                TINYFORMAT_ASSERT( m_value );
                TINYFORMAT_ASSERT( m_formatImpl );
                m_formatImpl( out, fmtBegin, fmtEnd, ntrunc, m_value );
            }

            int toInt( ) const {
                TINYFORMAT_ASSERT( m_value );
                TINYFORMAT_ASSERT( m_toIntImpl );
                return m_toIntImpl( m_value );
            }

        private:
            template<typename T>
            TINYFORMAT_HIDDEN static void formatImpl( std::ostream &out, const char *fmtBegin,
                                                      const char *fmtEnd, int ntrunc, const void *value ) {
                formatValue( out, fmtBegin, fmtEnd, ntrunc, *static_cast< const T * >( value ) );
            }

            template<typename T>
            TINYFORMAT_HIDDEN static int toIntImpl( const void *value ) {
                return convertToInt<T>::invoke( *static_cast< const T * >( value ) );
            }

            const void *m_value;
            void ( *m_formatImpl )( std::ostream &out, const char *fmtBegin,
                                    const char *fmtEnd, int ntrunc, const void *value );
            int ( *m_toIntImpl )( const void *value );
        };


        // Parse and return an integer from the string c, as atoi()
        // On return, c is set to one past the end of the integer.
        inline int parseIntAndAdvance( const char *&c ) {
	        auto i = 0;
            for ( ; *c >= '0' && *c <= '9'; ++c )
                i = 10 * i + ( *c - '0' );
            return i;
        }

        // Parse width or precision `n` from format string pointer `c`, and advance it
        // to the next character. If an indirection is requested with `*`, the argument
        // is read from `args[argIndex]` and `argIndex` is incremented (or read
        // from `args[n]` in positional mode). Returns true if one or more
        // characters were read.
        inline bool parseWidthOrPrecision( int &n, const char *&c, bool positionalMode,
                                           const detail::FormatArg *args,
                                           int &argIndex, int numArgs ) {
            if ( *c >= '0' && *c <= '9' ) {
                n = parseIntAndAdvance( c );
            } else if ( *c == '*' ) {
                ++c;
                n = 0;
                if ( positionalMode ) {
	                const auto pos = parseIntAndAdvance( c ) - 1;
                    if ( *c != '$' )
                        TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
                    if ( pos >= 0 && pos < numArgs )
                        n = args[ pos ].toInt( );
                    else
                        TINYFORMAT_ERROR( "tinyformat: Positional argument out of range" );
                    ++c;
                } else {
                    if ( argIndex < numArgs )
                        n = args[ argIndex++ ].toInt( );
                    else
                        TINYFORMAT_ERROR( "tinyformat: Not enough arguments to read variable width or precision" );
                }
            } else {
                return false;
            }
            return true;
        }

        // Print literal part of format string and return next format spec position.
        //
        // Skips over any occurrences of '%%', printing a literal '%' to the output.
        // The position of the first % character of the next nontrivial format spec is
        // returned, or the end of string.
        inline const char *printFormatStringLiteral( std::ostream &out, const char *fmt ) {
	        auto c = fmt;
            for ( ;; ++c ) {
                if ( *c == '\0' ) {
                    out.write( fmt, c - fmt );
                    return c;
                } else if ( *c == '%' ) {
                    out.write( fmt, c - fmt );
                    if ( *( c + 1 ) != '%' )
                        return c;
                    // for "%%", tack trailing % onto next literal section.
                    fmt = ++c;
                }
            }
        }


        // Parse a format string and set the stream state accordingly.
        //
        // The format mini-language recognized here is meant to be the one from C99,
        // with the form "%[flags][width][.precision][length]type" with POSIX
        // positional arguments extension.
        //
        // POSIX positional arguments extension:
        // Conversions can be applied to the nth argument after the format in
        // the argument list, rather than to the next unused argument. In this case,
        // the conversion specifier character % (see below) is replaced by the sequence
        // "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}],
        // giving the position of the argument in the argument list. This feature
        // provides for the definition of format strings that select arguments
        // in an order appropriate to specific languages.
        //
        // The format can contain either numbered argument conversion specifications
        // (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
        // (that is, % and * ), but not both. The only exception to this is that %%
        // can be mixed with the "%n$" form. The results of mixing numbered and
        // unnumbered argument specifications in a format string are undefined.
        // When numbered argument specifications are used, specifying the Nth argument
        // requires that all the leading arguments, from the first to the (N-1)th,
        // are specified in the format string.
        //
        // In format strings containing the "%n$" form of conversion specification,
        // numbered arguments in the argument list can be referenced from the format
        // string as many times as required.
        //
        // Formatting options which can't be natively represented using the ostream
        // state are returned in spacePadPositive (for space padded positive numbers)
        // and ntrunc (for truncating conversions).  argIndex is incremented if
        // necessary to pull out variable width and precision.  The function returns a
        // pointer to the character after the end of the current format spec.
        inline const char *streamStateFromFormat( std::ostream &out, bool &positionalMode,
                                                  bool &spacePadPositive,
                                                  int &ntrunc, const char *fmtStart,
                                                  const detail::FormatArg *args,
                                                  int &argIndex, int numArgs ) {
            TINYFORMAT_ASSERT( *fmtStart == '%' );
            // Reset stream state to defaults.
            out.width( 0 );
            out.precision( 6 );
            out.fill( ' ' );
            // Reset most flags; ignore irrelevant unitbuf & skipws.
            out.unsetf( std::ios::adjustfield | std::ios::basefield |
                        std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
                        std::ios::showpoint | std::ios::showpos | std::ios::uppercase );
            auto precisionSet = false;
            auto widthSet = false;
            auto widthExtra = 0;
            auto c = fmtStart + 1;

            // 1) Parse an argument index (if followed by '$') or a width possibly
            // preceded with '0' flag.
            if ( *c >= '0' && *c <= '9' ) {
                const auto tmpc = *c;
                const auto value = parseIntAndAdvance( c );
                if ( *c == '$' ) {
                    // value is an argument index
                    if ( value > 0 && value <= numArgs )
                        argIndex = value - 1;
                    else
                        TINYFORMAT_ERROR( "tinyformat: Positional argument out of range" );
                    ++c;
                    positionalMode = true;
                } else if ( positionalMode ) {
                    TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
                } else {
                    if ( tmpc == '0' ) {
                        // Use internal padding so that numeric values are
                        // formatted correctly, eg -00010 rather than 000-10
                        out.fill( '0' );
                        out.setf( std::ios::internal, std::ios::adjustfield );
                    }
                    if ( value != 0 ) {
                        // Nonzero value means that we parsed width.
                        widthSet = true;
                        out.width( value );
                    }
                }
            } else if ( positionalMode ) {
                TINYFORMAT_ERROR( "tinyformat: Non-positional argument used after a positional one" );
            }
            // 2) Parse flags and width if we did not do it in previous step.
            if ( !widthSet ) {
                // Parse flags
                for ( ;; ++c ) {
                    switch ( *c ) {
                    case '#':
                        out.setf( std::ios::showpoint | std::ios::showbase );
                        continue;
                    case '0':
                        // overridden by left alignment ('-' flag)
                        if ( !( out.flags( ) & std::ios::left ) ) {
                            // Use internal padding so that numeric values are
                            // formatted correctly, eg -00010 rather than 000-10
                            out.fill( '0' );
                            out.setf( std::ios::internal, std::ios::adjustfield );
                        }
                        continue;
                    case '-':
                        out.fill( ' ' );
                        out.setf( std::ios::left, std::ios::adjustfield );
                        continue;
                    case ' ':
                        // overridden by show positive sign, '+' flag.
                        if ( !( out.flags( ) & std::ios::showpos ) )
                            spacePadPositive = true;
                        continue;
                    case '+':
                        out.setf( std::ios::showpos );
                        spacePadPositive = false;
                        widthExtra = 1;
                        continue;
                    default:
                        break;
                    }
                    break;
                }
                // Parse width
                auto width = 0;
                widthSet = parseWidthOrPrecision( width, c, positionalMode,
                                                  args, argIndex, numArgs );
                if ( widthSet ) {
                    if ( width < 0 ) {
                        // negative widths correspond to '-' flag set
                        out.fill( ' ' );
                        out.setf( std::ios::left, std::ios::adjustfield );
                        width = -width;
                    }
                    out.width( width );
                }
            }
            // 3) Parse precision
            if ( *c == '.' ) {
                ++c;
                auto precision = 0;
                parseWidthOrPrecision( precision, c, positionalMode,
                                       args, argIndex, numArgs );
                // Presence of `.` indicates precision set, unless the inferred value
                // was negative in which case the default is used.
                precisionSet = precision >= 0;
                if ( precisionSet )
                    out.precision( precision );
            }
            // 4) Ignore any C99 length modifier
            while ( *c == 'l' || *c == 'h' || *c == 'L' ||
                    *c == 'j' || *c == 'z' || *c == 't' ) {
                ++c;
            }
            // 5) We're up to the conversion specifier character.
            // Set stream flags based on conversion specifier (thanks to the
            // boost::format class for forging the way here).
            auto intConversion = false;
            switch ( *c ) {
            case 'u': case 'd': case 'i':
                out.setf( std::ios::dec, std::ios::basefield );
                intConversion = true;
                break;
            case 'o':
                out.setf( std::ios::oct, std::ios::basefield );
                intConversion = true;
                break;
            case 'X':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'x': case 'p':
                out.setf( std::ios::hex, std::ios::basefield );
                intConversion = true;
                break;
            case 'E':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'e':
                out.setf( std::ios::scientific, std::ios::floatfield );
                out.setf( std::ios::dec, std::ios::basefield );
                break;
            case 'F':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'f':
                out.setf( std::ios::fixed, std::ios::floatfield );
                break;
            case 'A':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'a':
            #           ifdef _MSC_VER
                // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
                // by always setting maximum precision on MSVC to avoid precision
                // loss for doubles.
                out.precision( 13 );
            #           endif
                out.setf( std::ios::fixed | std::ios::scientific, std::ios::floatfield );
                break;
            case 'G':
                out.setf( std::ios::uppercase );
                // Falls through
            case 'g':
                out.setf( std::ios::dec, std::ios::basefield );
                // As in boost::format, let stream decide float format.
                out.flags( out.flags( ) & ~std::ios::floatfield );
                break;
            case 'c':
                // Handled as special case inside formatValue()
                break;
            case 's':
                if ( precisionSet )
                    ntrunc = static_cast< int >( out.precision( ) );
                // Make %s print Booleans as "true" and "false"
                out.setf( std::ios::boolalpha );
                break;
            case 'n':
                // Not supported - will cause problems!
                TINYFORMAT_ERROR( "tinyformat: %n conversion spec not supported" );
                break;
            case '\0':
                TINYFORMAT_ERROR( "tinyformat: Conversion spec incorrectly "
                                  "terminated by end of string" );
                return c;
            default:
                break;
            }
            if ( intConversion && precisionSet && !widthSet ) {
                // "precision" for integers gives the minimum number of digits (to be
                // padded with zeros on the left).  This isn't really supported by the
                // iostreams, but we can approximately simulate it with the width if
                // the width isn't otherwise used.
                out.width( out.precision( ) + widthExtra );
                out.setf( std::ios::internal, std::ios::adjustfield );
                out.fill( '0' );
            }
            return c + 1;
        }


        //------------------------------------------------------------------------------
        inline void formatImpl( std::ostream &out, const char *fmt,
                                const detail::FormatArg *args,
                                int numArgs ) {
            // Saved stream state
            const auto origWidth = out.width( );
            const auto origPrecision = out.precision( );
            const auto origFlags = out.flags( );
            const auto origFill = out.fill( );

            // "Positional mode" means all format specs should be of the form "%n$..."
            // with `n` an integer. We detect this in `streamStateFromFormat`.
            auto positionalMode = false;
            auto argIndex = 0;
            while ( true ) {
                fmt = printFormatStringLiteral( out, fmt );
                if ( *fmt == '\0' ) {
                    if ( !positionalMode && argIndex < numArgs ) {
                        TINYFORMAT_ERROR( "tinyformat: Not enough conversion specifiers in format string" );
                    }
                    break;
                }
                auto spacePadPositive = false;
                auto ntrunc = -1;
                const auto fmtEnd = streamStateFromFormat( out, positionalMode, spacePadPositive, ntrunc, fmt,
                                                           args, argIndex, numArgs );
                // NB: argIndex may be incremented by reading variable width/precision
                // in `streamStateFromFormat`, so do the bounds check here.
                if ( argIndex >= numArgs ) {
                    TINYFORMAT_ERROR( "tinyformat: Too many conversion specifiers in format string" );
                    return;
                }
                const auto &arg = args[ argIndex ];
                // Format the arg into the stream.
                if ( !spacePadPositive ) {
                    arg.format( out, fmt, fmtEnd, ntrunc );
                } else {
                    // The following is a special case with no direct correspondence
                    // between stream formatting and the printf() behaviour.  Simulate
                    // it crudely by formatting into a temporary string stream and
                    // munging the resulting string.
                    std::ostringstream tmpStream;
                    tmpStream.copyfmt( out );
                    tmpStream.setf( std::ios::showpos );
                    arg.format( tmpStream, fmt, fmtEnd, ntrunc );
                    auto result = tmpStream.str( ); // allocates... yuck.
                    for ( size_t i = 0, iend = result.size( ); i < iend; ++i ) {
                        if ( result[ i ] == '+' )
                            result[ i ] = ' ';
                    }
                    out << result;
                }
                if ( !positionalMode )
                    ++argIndex;
                fmt = fmtEnd;
            }

            // Restore stream state
            out.width( origWidth );
            out.precision( origPrecision );
            out.flags( origFlags );
            out.fill( origFill );
        }

    } // namespace detail


    /// List of template arguments format(), held in a type-opaque way.
    ///
    /// A const reference to FormatList (typedef'd as FormatListRef) may be
    /// conveniently used to pass arguments to non-template functions: All type
    /// information has been stripped from the arguments, leaving just enough of a
    /// common interface to perform formatting as required.
    class FormatList {
    public:
        FormatList( detail::FormatArg *args, int N )
            : m_args( args ), m_N( N ) {
        }

        friend void vformat( std::ostream &out, const char *fmt,
                             const FormatList &list );

    private:
        const detail::FormatArg *m_args;
        int m_N;
    };

    /// Reference to type-opaque format list for passing to vformat()
    typedef const FormatList &FormatListRef;


    namespace detail {

        // Format list subclass with fixed storage to avoid dynamic allocation
        template<int N>
        class FormatListN : public FormatList {
        public:
        #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
            template<typename... Args>
            FormatListN( const Args &... args )
                : FormatList( &m_formatterStore[ 0 ], N ),
                m_formatterStore{ FormatArg( args )... }
            { static_assert( sizeof...( args ) == N, "Number of args must be N" ); }
        #else // C++98 version
	        static void init( int ) { }
        #       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                \
                                                                        \
        template<TINYFORMAT_ARGTYPES(n)>                                \
        FormatListN(TINYFORMAT_VARARGS(n))                              \
            : FormatList(&m_formatterStore[0], n)                       \
        { TINYFORMAT_ASSERT(n == N); init(0, TINYFORMAT_PASSARGS(n)); } \
                                                                        \
        template<TINYFORMAT_ARGTYPES(n)>                                \
        void init(int i, TINYFORMAT_VARARGS(n))                         \
        {                                                               \
            m_formatterStore[i] = FormatArg(v1);                        \
            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));                      \
        }

            TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR )
            #       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
            #endif
                FormatListN( const FormatListN &other )
                : FormatList( &m_formatterStore[ 0 ], N ) {
                std::copy( &other.m_formatterStore[ 0 ], &other.m_formatterStore[ N ],
                           &m_formatterStore[ 0 ] );
            }

        private:
            FormatArg m_formatterStore[ N ];
        };

        // Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
        template<> class FormatListN<0> : public FormatList {
        public: FormatListN( ) : FormatList( 0, 0 ) { }
        };

    } // namespace detail


    //------------------------------------------------------------------------------
    // Primary API functions

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Make type-agnostic format list from list of template arguments.
///
/// The exact return type of this function is an implementation detail and
/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
///
///   FormatListRef formatList = makeFormatList( /*...*/ );
    template<typename... Args>
    detail::FormatListN<sizeof...( Args )> makeFormatList( const Args &... args ) {
        return detail::FormatListN<sizeof...( args )>( args... );
    }

#else // C++98 version

    inline detail::FormatListN<0> makeFormatList( ) {
        return detail::FormatListN<0>( );
    }
#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \
template<TINYFORMAT_ARGTYPES(n)>                              \
detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \
{                                                             \
    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \
}
    TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_MAKEFORMATLIST )
    #undef TINYFORMAT_MAKE_MAKEFORMATLIST

    #endif

        /// Format list of arguments to the stream according to the given format string.
        ///
        /// The name vformat() is chosen for the semantic similarity to vprintf(): the
        /// list of format arguments is held in a single function argument.
        inline void vformat( std::ostream &out, const char *fmt, FormatListRef list ) {
        detail::formatImpl( out, fmt, list.m_args, list.m_N );
    }


#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

    /// Format list of arguments to the stream according to given format string.
    template<typename... Args>
    void format( std::ostream &out, const char *fmt, const Args &... args ) {
        vformat( out, fmt, makeFormatList( args... ) );
    }

    /// Format list of arguments according to the given format string and return
    /// the result as a string.
    template<typename... Args>
    std::string format( const char *fmt, const Args &... args ) {
        std::ostringstream oss;
        format( oss, fmt, args... );
        return oss.str( );
    }

    /// Format list of arguments to std::cout, according to the given format string
    template<typename... Args>
    void printf( const char *fmt, const Args &... args ) {
        format( std::cout, fmt, args... );
    }

    template<typename... Args>
    void printfln( const char *fmt, const Args &... args ) {
        format( std::cout, fmt, args... );
        std::cout << '\n';
    }


#else // C++98 version

    inline void format( std::ostream &out, const char *fmt ) {
        vformat( out, fmt, makeFormatList( ) );
    }

    inline std::string format( const char *fmt ) {
        std::ostringstream oss;
        format( oss, fmt );
        return oss.str( );
    }

    inline void printf( const char *fmt ) {
        format( std::cout, fmt );
    }

    inline void printfln( const char *fmt ) {
        format( std::cout, fmt );
        std::cout << '\n';
    }

#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \
{                                                                         \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \
{                                                                         \
    std::ostringstream oss;                                               \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \
    return oss.str();                                                     \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
    std::cout << '\n';                                                    \
}

    TINYFORMAT_FOREACH_ARGNUM( TINYFORMAT_MAKE_FORMAT_FUNCS )
    #undef TINYFORMAT_MAKE_FORMAT_FUNCS

    #endif


} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED
```

`solace-csgo/thread_hander.cpp`:

```cpp
#include "aimbot.h"
#include "thread_handler.h"

static auto allocate_thread_id = reinterpret_cast< void(*) ( ) >(GetProcAddress( GetModuleHandleA( "tier0.dll" ), "AllocateThreadID" ));
static auto free_thread_id = reinterpret_cast< void(*) ( ) >(GetProcAddress( GetModuleHandleA( "tier0.dll" ), "FreeThreadID" ));

void ThreadHandler::ThreadLoop( ) {
	allocate_thread_id( );
	while ( true ) {
		std::function<void( )> job;
		{
			std::unique_lock<std::mutex> lock( g_thread_handler.queue_mutex2 );
			g_thread_handler.mutex_condition.wait( lock, [] {
				return !g_thread_handler.jobs.empty( ) || g_thread_handler.should_terminate;
				} );

			if ( g_thread_handler.should_terminate )
				break;

			job = g_thread_handler.jobs.front( );
			g_thread_handler.jobs.pop( );
		}
		job( );
	}
	free_thread_id( );
}

```

`solace-csgo/thread_handler.h`:

```h
#pragma once
#include <thread>
#include <vector>
#include <shared_mutex>
#include <condition_variable>
#include <algorithm>
#include <queue>


class ThreadHandler {
public:
	std::vector<std::thread> thread_pool;
	ThreadHandler( ) {
	}
	mutable std::mutex queue_mutex;                  // Prevents data races to the job queue
	mutable std::mutex queue_mutex2;                  // Prevents data races to the job queue

    std::queue<std::function<void()>> jobs = {};

	bool busy( ) {
		bool poolbusy = false;
		{
			std::unique_lock<std::mutex> lock( queue_mutex2 );
			poolbusy = !jobs.empty( );
		}
		return poolbusy;
	}


	static void ThreadLoop( );

	void QueueJob( const std::function<void( )>& job ) {
		{
			std::unique_lock<std::mutex> lock( queue_mutex2 );
			jobs.push( job );
		}
		mutex_condition.notify_one( );
	}
	bool should_terminate = false;
	void stop( ) {
		{
			std::unique_lock<std::mutex> lock( queue_mutex2 );
			should_terminate = true;
		}
		mutex_condition.notify_all( );
		for ( std::thread& active_thread : thread_pool ) {
			active_thread.join( );
		}
		thread_pool.clear( );
	}

	void start( ) {
		should_terminate = false;
		const uint32_t num_threads = std::thread::hardware_concurrency( ); // Max # of threads the system supports
		thread_pool.resize( num_threads );
		for ( uint32_t i = 0; i < num_threads; i++ ) {
			thread_pool.at( i ) = std::thread( ThreadLoop );
		}
	}
	std::condition_variable mutex_condition;
} inline g_thread_handler;

```

`solace-csgo/utils.h`:

```h
#pragma once
#include <algorithm>
#include <locale>
#include "vector"
#include "sstream"


#include "address.h"

#define CONCAT_TOKEN( x, y ) x##y
#define MACRO_CONCAT( x, y ) CONCAT_TOKEN( x, y )
#define PAD( size ) char MACRO_CONCAT( _pad, __COUNTER__ )[ size ];

#define BASE_TEMPLATE template < typename t = void* >

class util {
	class c_interface_reg {
	private:
		using create_t = void* (__cdecl*) ( );

	public:
		create_t m_create_fn;
		const char *m_name;
		c_interface_reg *m_next;
	};

public:
	BASE_TEMPLATE
	static t iter_interfaces ( c_interface_reg *register_list, const char *name ) {
		for ( auto *cur = register_list; cur; cur = cur->m_next ) {
			if ( strcmp( cur->m_name, name ) == 0 )
				return static_cast< t >(cur->m_create_fn( ));
		}
		return {};
	}

	BASE_TEMPLATE
	static t capture_interface ( const char *module, const char *name ) {
		static address interface_fn(
			reinterpret_cast< uintptr_t >(GetProcAddress( GetModuleHandleA( module ), "CreateInterface" )) );

		if ( !interface_fn.valid( ) ) { return nullptr; }
		if ( interface_fn.at< uint8_t >( 4 ) == 233 ) {
			auto jump_target = interface_fn.rel32( 5 );

			if ( jump_target.at< uint8_t >( 5 ) == 53 ) {
				return iter_interfaces< t >( **jump_target.as< c_interface_reg *** >( 6 ), name );
			}
		}
		else if ( interface_fn.at< uint8_t >( 2 ) == 53 ) {
			return iter_interfaces< t >( **interface_fn.as< c_interface_reg *** >( 3 ), name );
		}

		return nullptr;
	}
	BASE_TEMPLATE
	static t get_virtual_function( void *base, const std::uint16_t index ) {
		return ( *static_cast< t ** >( base ) )[ index ];
	}
	// container
	using patterns_t = std::vector< address >;
	using pattern_byte_t = std::pair< uint8_t, bool >;
	
	static std::uint8_t *find( const char *module_name, const char *signature, size_t len = -1 ) noexcept {
		auto *const module_handle = GetModuleHandleA( module_name );

		if ( !module_handle )
			return nullptr;

		auto pattern_to_byte = [ ]( const char *pattern ) {
			auto bytes = std::vector<int>{};
			const auto start = const_cast< char * >( pattern );
			const auto end = const_cast< char * >( pattern ) + std::strlen( pattern );

			for ( auto *current = start; current < end; ++current ) {
				if ( *current == '?' ) {
					++current;

					if ( *current == '?' )
						++current;

					bytes.push_back( -1 );
				} else {
					bytes.push_back( std::strtoul( current, &current, 16 ) );
				}
			}
			return bytes;
		};

		const auto dos_header = reinterpret_cast< PIMAGE_DOS_HEADER >( module_handle );
		const auto nt_headers =
			reinterpret_cast< PIMAGE_NT_HEADERS >( reinterpret_cast< std::uint8_t * >( module_handle ) + dos_header->e_lfanew );

		auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
		if ( len != -1 )
			size_of_image = len;
		auto pattern_bytes = pattern_to_byte( signature );
		const auto scan_bytes = reinterpret_cast< std::uint8_t * >( module_handle );

		const auto s = pattern_bytes.size( );
		const auto d = pattern_bytes.data( );

		for ( auto i = 0ul; i < size_of_image - s; ++i ) {
			auto found = true;

			for ( auto j = 0ul; j < s; ++j ) {
				if ( scan_bytes[ i + j ] != d[ j ] && d[ j ] != -1 ) {
					found = false;
					break;
				}
			}
			if ( found )
				return &scan_bytes[ i ];
		}

		throw std::runtime_error( std::string( "Wrong signature: " ) + signature );
	}
	
	static std::uint8_t *find( address start, size_t len, const char *pat ) noexcept {
		if ( !start )
			return nullptr;

		static auto pattern_to_byte = [ ]( const char *pattern ) {
			auto bytes = std::vector<int>{};
			const auto start = const_cast< char * >( pattern );
			const auto end = const_cast< char * >( pattern ) + std::strlen( pattern );

			for ( auto *current = start; current < end; ++current ) {
				if ( *current == '?' ) {
					++current;

					if ( *current == '?' )
						++current;

					bytes.push_back( -1 );
				} else {
					bytes.push_back( std::strtoul( current, &current, 16 ) );
				}
			}
			return bytes;
		};

		auto pattern_bytes = pattern_to_byte( pat );
		const auto scan_bytes = start.as< std::uint8_t * >();

		const auto s = pattern_bytes.size( );
		const auto d = pattern_bytes.data( );

		for ( auto i = 0ul; i < len - s; ++i ) {
			auto found = true;

			for ( auto j = 0ul; j < s; ++j ) {
				if ( scan_bytes[ i + j ] != d[ j ] && d[ j ] != -1 ) {
					found = false;
					break;
				}
			}
			if ( found )
				return &scan_bytes[ i ];
		}
	}
	static address find( address start, size_t len, const std::string &pat ) {
		uint8_t *scan_start, *scan_end;
		std::vector< pattern_byte_t > pattern{};
		std::stringstream			  stream{ pat };
		std::string				      w;

		if ( !start || !len || pat.empty( ) )
			return{};

		// split spaces and convert to hex.
		while ( stream >> w ) {
			// wildcard.
			if ( w[ 0 ] == '?' )
				pattern.push_back( { 0, true } );

			// valid hex digits.
			else if ( std::isxdigit( w[ 0 ] ) && std::isxdigit( w[ 1 ] ) )
				pattern.push_back( { static_cast< uint8_t >(std::strtoul( w.data( ), 0, 16 )), false } );
		}

		scan_start = start.as< uint8_t * >( );
		scan_end = scan_start + len;

		// find match.
		auto result = std::search( scan_start, scan_end, pattern.begin( ), pattern.end( ),
								   [ ]( const uint8_t b, const pattern_byte_t &p ) {
									   // byte matches or it's a wildcard.
									   return b == p.first || p.second;
								   } );

		// nothing found.
		if ( result == scan_end )
			return{};

		return ( uintptr_t )result;
	}
	static patterns_t FindAll( const char *module, const std::string &pat ) {
		patterns_t out{};
		address	   result;

		const auto module_handle = GetModuleHandleA( module );

		if ( !module_handle )
			return {};
		
		const auto dos_header = reinterpret_cast< PIMAGE_DOS_HEADER >( module_handle );
		const auto nt_headers =
			reinterpret_cast< PIMAGE_NT_HEADERS >( reinterpret_cast< std::uint8_t * >( module_handle ) + dos_header->e_lfanew );

		size_t size_of_image = nt_headers->OptionalHeader.SizeOfImage;
		address start{ module_handle };
		for ( ;; ) {
			// find result.
			result = find( start, size_of_image, pat );
			if ( !result )
				break;

			// if we arrived here we found something.
			out.push_back( result );

			// set new len.
			size_of_image = ( start + size_of_image ) - ( result + 1 );

			// new start point.
			start = result;
			start.add( 1 );
		}

		return out;
	}


	static address find( std::string &module, const std::string &pat ) {
		return find(module.c_str(), pat.c_str(  ) );
	}

	//static patterns_t FindAll( address start, const std::string &pat ) {
	//	patterns_t out{};
	//	address	   result;
	//	size_t len = std::strlen( pat.c_str( ) );
	//
	//	for ( ;; ) {
	//		// find result.
	//		result = find( start, pat.c_str(  ), len );
	//		if ( !result )
	//			break;
	//
	//		// if we arrived here we found something.
	//		out.push_back( result );
	//
	//		// set new len.
	//		len = ( start + len ) - ( result + 1 );
	//
	//		// new start m_point.
	//		start = result + 1;
	//	}
	//
	//	return out;
	//}
	//
	//static patterns_t FindAll( std::string &module, const std::string &pat ) {
	//	return FindAll( module.c_str( ), module.GetImageSize( ), pat );
	//}
};

// abusing macros, ik will revisit it later - l
#define VFUNC( function_name, index, type, ... ) \
	auto function_name { \
		return util::get_virtual_function< type >( this, index )( this, __VA_ARGS__ ); \
	};

#undef BASE_TEMPLATE

```

`solace-csgo/vec3.cpp`:

```cpp
#include "vec3.h"

#include <cmath>

#include "math_funcs.h"

void ang_t::vectors( vec3_t *forward, vec3_t *right, vec3_t *up ) const {
	float sp, sy, sr, cp, cy, cr;

	math::sin_cos( DEG2RAD( x ), &sp, &cp );
	math::sin_cos( DEG2RAD( y ), &sy, &cy );
	math::sin_cos( DEG2RAD( z ), &sr, &cr );

	if ( forward ) {
		forward->x = cp * cy;
		forward->y = cp * sy;
		forward->z = -sp;
	}

	if ( right ) {
		right->x = -1 * sr * sp * cy + -1 * cr * -sy;
		right->y = -1 * sr * sp * sy + -1 * cr * cy;
		right->z = -1 * sr * cp;
	}

	if ( up ) {
		up->x = cr * sp * cy + -sr * -sy;
		up->y = cr * sp * sy + -sr * cy;
		up->z = cr * cp;
	}
}

vec3_t ang_t::forward( ) const {
	vec3_t forward;

	const auto sy = sin( DEG2RAD( y ) );
	const auto sp = sin( DEG2RAD( x ) );
	const auto cy = cos( DEG2RAD( y ) );
	const auto cp = cos( DEG2RAD( x ) );

	forward.x = cp * cy;
	forward.y = cp * sy;
	forward.z = -sp;
	return forward;
}

vec3_t::vec3_t( void ) {
	x = y = z = 0.0f;
}

vec3_t::vec3_t( float _x, float _y, float _z ) {
	x = _x;
	y = _y;
	z = _z;
}

vec3_t::~vec3_t( void ) { }

matrix_t matrix_t::operator* ( matrix_t other ) const {
	matrix_t ret;
	math::ConcatTransforms( *this, other, &ret );
	return ret;
}
matrix_t matrix_t::operator* ( float other ) const {
	matrix_t ret;
	for ( int i = 0; i < 3; i++ ) {
		for ( int j = 0; j < 4; j++ ) {
			ret[i][j] = other * (*this)[ i ][ j ];
		}
	}
	return ret;
}

matrix_t matrix_t::operator+ ( matrix_t other ) const {
	matrix_t ret;
	for ( int i = 0; i < 3; i++ ) {
		for ( int j = 0; j < 4; j++ ) {
			ret[ i ][ j ] = (*this)[ i ][ j ] + other[ i ][ j ];
		}
	}
	return ret;
};

```

`solace-csgo/vec3.h`:

```h
#pragma once
#include <cmath>
#include <future>

inline float bits_to_float( std::uint32_t i ) {
	union convertor_t {
		float f; unsigned long ul;
	} tmp;

	tmp.ul = i;
	return tmp.f;
}

constexpr double M_PI = 3.14159265358979323846;
constexpr double M_PI_SQUARED = 9.869604401089358;

constexpr double M_PI_2 = M_PI * 2;
constexpr double M_PI_2_F = static_cast< float >( M_PI_2 );
constexpr float M_PI_F = static_cast< float >( M_PI );
constexpr float RAD2DEG( const float x ) {
	return static_cast< float >(x) * static_cast< float >(180.f / M_PI_F);
}
constexpr float DEG2RAD( const float x ) {
	return static_cast< float >(x) * static_cast< float >(M_PI_F / 180.f);
}

constexpr std::uint32_t FLOAT32_NAN_BITS = 0x7FC00000;
const float FLOAT32_NAN = bits_to_float( FLOAT32_NAN_BITS );
#define VEC_T_NAN FLOAT32_NAN
#define ASSERT( _exp ) ( (void ) 0 )
class vec3_t;
class ang_t {
public:
	float x, y, z;
	__forceinline ang_t( ) : x{0}, y{0}, z{0} {
	}
	ang_t( float x, float y, float z ) : x( x ), y( y ), z( z ) { }
	float &operator[]( int i ) { return reinterpret_cast< float * >(this)[ i ]; }
	float operator[]( int i ) const { return ( ( float * )this )[ i ]; }
	__forceinline bool operator==( const ang_t &v ) const {
		return v.x == x && v.y == y && v.z == z;
	}
	__forceinline bool operator!=( const ang_t &v ) const {
		return v.x != x || v.y != y || v.z != z;
	}
	ang_t &operator+=( const ang_t &v ) {
		x += v.x; y += v.y; z += v.z; return *this;
	}
	ang_t &operator-=( const ang_t &v ) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}
	ang_t &operator*=( float v ) {
		x *= v; y *= v; z *= v; return *this;
	}
	ang_t operator+( const ang_t &v ) const {
		return ang_t{ x + v.x, y + v.y, z + v.z };
	}
	ang_t operator-( const ang_t &v ) {
		return ang_t{ x - v.x, y - v.y, z - v.z };
	}
	ang_t operator-( ) const {
		return ang_t{ -x, -y, -z };
	}
	ang_t operator*( float fl ) const {
		return ang_t( x * fl, y * fl, z * fl );
	}
	ang_t operator*( const ang_t &v ) const {
		return ang_t( x * v.x, y * v.y, z * v.z );
	}
	ang_t &operator/=( float fl ) {
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	auto operator-( const ang_t &other ) const -> ang_t {
		auto buf = *this;

		buf.x -= other.x;
		buf.y -= other.y;
		buf.z -= other.z;

		return buf;
	}

	auto operator/( float other ) const {
		ang_t vec;
		vec.x = x / other;
		vec.y = y / other;
		vec.z = z / other;
		return vec;
	}
	
	[[nodiscard]] float delta( const ang_t target ) const {
		float ret = target.y - y;
		while ( ret > 180 )
			ret -= 360;
		while ( ret < -180 )
			ret += 360;
		ret += target.x - x;
		return ret;
	}

	ang_t rotate( const float x, const float y, const float z ) {
		this->x += x;
		this->y += y;
		this->z += z;
		return *this;
	}
	
	void vectors ( vec3_t *forward, vec3_t *right, vec3_t *up ) const;
	vec3_t forward ( ) const;
};

class quaternion_t {
public:
	float x = 0, y = 0, z = 0, w = 0;
	void init( float x, float y, float z, float w ) {
		this->x = ( x );
		this->y = ( y );
		this->z = ( z );
		this->w = ( w );
	}
	quaternion_t( ) {};
	quaternion_t( float x, float y, float z, float w ) : x( x ), y( y ), z( z ), w( w ) {}
	void operator=( quaternion_t& other ) 		{
		init( other.x, other.y, other.z, other.w );
	}
};

class vec3_t {
public:
	float x, y, z;
	vec3_t( );
	vec3_t( float, float, float );
	~vec3_t( );


	vec3_t &operator=( const vec3_t &vOther ) {
		init( vOther.x, vOther.y, vOther.z );
		return *this;
	}
	[[nodiscard]] __forceinline vec3_t cross( const vec3_t &v ) const {
		return {
			( y * v.z ) - ( z * v.y ),
			( z * v.x ) - ( x * v.z ),
			( x * v.y ) - ( y * v.x )
		};
	}


	vec3_t( const float *clr ) {
		x = clr[ 0 ];
		y = clr[ 1 ];
		z = clr[ 2 ];
	}
	
	void abs() {
		x = fabsf(x);
		y = fabsf(y);
		z = fabsf(z);
	}

	void init( float _x, float _y, float _z ) {
		x = _x; y = _y; z = _z;
	}
	void reset() {
		x = 0;
		y = 0;
		z = 0;
	}
	float &operator[]( int i ) { return reinterpret_cast< float * >(this)[ i ]; }
	float operator[]( int i ) const { return ( ( float * )this )[ i ]; }
	__forceinline bool operator==( const vec3_t &v ) const {
		return v.x == x && v.y == y && v.z == z;
	}
	__forceinline bool operator!=( const vec3_t &v ) const {
		return v.x != x || v.y != y || v.z != z;
	}
	vec3_t &operator+=( const vec3_t &v ) {
		x += v.x; y += v.y; z += v.z; return *this;
	}
	vec3_t &operator-=( const vec3_t &v ) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}
	vec3_t &operator*=( float v ) {
		x *= v; y *= v; z *= v; return *this;
	}
	vec3_t operator+( const vec3_t &v ) const {
		return vec3_t{ x + v.x, y + v.y, z + v.z };
	}
	vec3_t operator-( const vec3_t &v ) {
		return vec3_t{ x - v.x, y - v.y, z - v.z };
	}
	vec3_t operator-( ) const {
		return vec3_t{ -x, -y, -z };
	}
	vec3_t operator*( float fl ) const {
		return vec3_t( x * fl, y * fl, z * fl );
	}
	vec3_t operator*( const vec3_t &v ) const {
		return vec3_t( x * v.x, y * v.y, z * v.z );
	}
	vec3_t &operator/=( float fl ) {
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	auto operator-( const vec3_t &other ) const -> vec3_t {
		auto buf = *this;

		buf.x -= other.x;
		buf.y -= other.y;
		buf.z -= other.z;

		return buf;
	}

	auto operator/( float other ) const {
		vec3_t vec;
		vec.x = x / other;
		vec.y = y / other;
		vec.z = z / other;
		return vec;
	}
	auto operator<=( float other ) const {
		return ( fabsf( x ) <= other &&
			fabsf( y ) <= other &&
			fabsf( z ) <= other );
	}

	auto operator!=( vec3_t other ) const {
		return ( fabsf( x - other.x ) >= 0.f ||
			fabsf( y - other.y ) >= 0.f ||
			fabsf( z - other.z ) >= 0.f );
	}
	auto operator==( vec3_t other ) const {
		return ( fabsf( x - other.x ) <= 0.f &&
			fabsf( y - other.y ) <= 0.f &&
			fabsf( z - other.z ) <= 0.f );
	}

	__forceinline float dot( const vec3_t &b ) const {
		return( this->x * b.x + this->y * b.y + this->z * b.z );
	}

	[[nodiscard]] float length( void ) const {
		const auto sqsr = length_sqr( );

		if ( sqsr == 0 )
			return 0.f;

		return sqrt( sqsr );
	}
	[[nodiscard]] float length_2d_sqr() const {
		auto sqr = [](float n) {
			return static_cast<float>(n * n);
		};
		const auto sqsr = sqr(x) + sqr(y);

		return sqsr;
	}

	[[nodiscard]] float length_2d( ) const {
		float len = length_2d_sqr();
		if ( isnan( len ) || len == 0 )
			return 0.f;
		return sqrt( len );
	}

	[[nodiscard]] float length_sqr( ) const {
		auto sqr = [ ]( float n ) {
			return static_cast< float >( n * n );
		};

		return ( sqr( x ) + sqr( y ) + sqr( z ) );
	}


	float normalize( ) {
		const float ln = length( );
		if (isnan(ln) || ln == 0)
			return 0;
		x /= ln;
		y /= ln;
		z /= ln;
		return ln;
	};
	
	vec3_t normalized( ) const {
		float len = length();
		if ( isnan( len ) || len == 0 )
			return vec3_t(0,0,0 );
		return ( *this ) / len;
	}

	[[nodiscard]] ang_t look( vec3_t target ) const {
		target -= *this;
		ang_t angles;
		if ( target.y == 0.0f && target.x == 0.0f ) {
			angles.x = ( target.z > 0.0f ) ? 270.0f : 90.0f;
			angles.y = 0.0f;
		} else {
			angles.x = static_cast<float>(-atan2( -target.z, target.length_2d( ) ) * -180.f / M_PI);
			angles.y = static_cast< float >(atan2( target.y, target.x ) * 180.f / M_PI);

			//if ( angles.y > 90 )
			//	angles.y -= 180;
			//else if ( angles.y < 90 )
			//	angles.y += 180;
			//else if ( angles.y == 90 )
			//	angles.y = 0;
		}

		angles.z = 0.0f;
		return angles;
	}
};

class __declspec( align( 16 ) ) vec_aligned_t : public vec3_t {
public:
	vec_aligned_t &operator=( const vec3_t &vOther ) {
		init( vOther.x, vOther.y, vOther.z );
		return *this;
	}

	float w = 0;
};

#define VEC_T_NAN FLOAT32_NAN
#define ASSERT( _exp ) ( (void ) 0 )
struct matrix_t {
	matrix_t( ) { }
	matrix_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23 ) {
		mat_val[ 0 ][ 0 ] = m00;	mat_val[ 0 ][ 1 ] = m01; mat_val[ 0 ][ 2 ] = m02; mat_val[ 0 ][ 3 ] = m03;
		mat_val[ 1 ][ 0 ] = m10;	mat_val[ 1 ][ 1 ] = m11; mat_val[ 1 ][ 2 ] = m12; mat_val[ 1 ][ 3 ] = m13;
		mat_val[ 2 ][ 0 ] = m20;	mat_val[ 2 ][ 1 ] = m21; mat_val[ 2 ][ 2 ] = m22; mat_val[ 2 ][ 3 ] = m23;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void init( const vec3_t &x, const vec3_t &y, const vec3_t &z, const vec3_t &origin ) {
		mat_val[ 0 ][ 0 ] = x.x; mat_val[ 0 ][ 1 ] = y.x; mat_val[ 0 ][ 2 ] = z.x; mat_val[ 0 ][ 3 ] = origin.x;
		mat_val[ 1 ][ 0 ] = x.y; mat_val[ 1 ][ 1 ] = y.y; mat_val[ 1 ][ 2 ] = z.y; mat_val[ 1 ][ 3 ] = origin.y;
		mat_val[ 2 ][ 0 ] = x.z; mat_val[ 2 ][ 1 ] = y.z; mat_val[ 2 ][ 2 ] = z.z; mat_val[ 2 ][ 3 ] = origin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix_t( const vec3_t &x, const vec3_t &y, const vec3_t &z, const vec3_t &origin ) {
		init( x, y, z, origin );
	}

	inline void set_origin( vec3_t const &p ) {
		mat_val[ 0 ][ 3 ] = p.x;
		mat_val[ 1 ][ 3 ] = p.y;
		mat_val[ 2 ][ 3 ] = p.z;
	}

	inline vec3_t get_origin( ) {
		return {
		mat_val[ 0 ][ 3 ],
		mat_val[ 1 ][ 3 ],
		mat_val[ 2 ][ 3 ]
		};
	}

	inline void invalidate( void ) {
		for ( auto i = 0; i < 3; i++ ) {
			for ( auto j = 0; j < 4; j++ ) {
				mat_val[ i ][ j ] = VEC_T_NAN;
			}
		}
	}

	float *operator[]( int i ) { ASSERT( ( i >= 0 ) && ( i < 3 ) ); return mat_val[ i ]; }
	matrix_t operator* ( matrix_t other ) const;
	matrix_t operator* ( float other ) const;
	matrix_t operator+ ( matrix_t other ) const;
	const float *operator[]( int i ) const { ASSERT( ( i >= 0 ) && ( i < 3 ) ); return mat_val[ i ]; }
	float *base( ) { return &mat_val[ 0 ][ 0 ]; }
	const float *base( ) const { return &mat_val[ 0 ][ 0 ]; }

	float mat_val[ 3 ][ 4 ];
};
class bone_array_t : public matrix_t {
public:
	bool get_bone( vec3_t &out, int bone = 0 ) {
		if ( bone < 0 || bone >= 128 )
			return false;

		matrix_t *bone_matrix = &this[ bone ];

		if ( !bone_matrix )
			return false;

		out = { bone_matrix->mat_val[ 0 ][ 3 ], bone_matrix->mat_val[ 1 ][ 3 ], bone_matrix->mat_val[ 2 ][ 3 ] };

		return true;
	}
};
```

`solace-csgo/view_matrix.cpp`:

```cpp
#include "view_matrix.hpp"
#include "vec3.h"

view_matrix_t::view_matrix_t() {}

view_matrix_t::view_matrix_t(
	vec_t m00, vec_t m01, vec_t m02, vec_t m03,
	vec_t m10, vec_t m11, vec_t m12, vec_t m13,
	vec_t m20, vec_t m21, vec_t m22, vec_t m23,
	vec_t m30, vec_t m31, vec_t m32, vec_t m33) {
	init(
		m00, m01, m02, m03,
		m10, m11, m12, m13,
		m20, m21, m22, m23,
		m30, m31, m32, m33
	);
}

view_matrix_t::view_matrix_t(const matrix_t& matrix3x4) {
	init(matrix3x4);
}

//-----------------------------------------------------------------------------
// Creates a matrix where the X axis = forward
// the Y axis = left, and the Z axis = up
//-----------------------------------------------------------------------------
view_matrix_t::view_matrix_t(const vec3_t& _x, const vec3_t& _y, const vec3_t& _z) {
	init(
		_x.x, _y.x, _z.x, 0.0f,
		_x.y, _y.y, _z.y, 0.0f,
		_x.z, _y.z, _z.z, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}

void view_matrix_t::init(
	vec_t m00, vec_t m01, vec_t m02, vec_t m03,
	vec_t m10, vec_t m11, vec_t m12, vec_t m13,
	vec_t m20, vec_t m21, vec_t m22, vec_t m23,
	vec_t m30, vec_t m31, vec_t m32, vec_t m33
) {
	m[0][0] = m00;
	m[0][1] = m01;
	m[0][2] = m02;
	m[0][3] = m03;

	m[1][0] = m10;
	m[1][1] = m11;
	m[1][2] = m12;
	m[1][3] = m13;

	m[2][0] = m20;
	m[2][1] = m21;
	m[2][2] = m22;
	m[2][3] = m23;

	m[3][0] = m30;
	m[3][1] = m31;
	m[3][2] = m32;
	m[3][3] = m33;
}

//-----------------------------------------------------------------------------
// Initialize from a 3x4
//-----------------------------------------------------------------------------
void view_matrix_t::init(const matrix_t& m3x4) {
	memcpy(m, m3x4.base(), sizeof(matrix_t));

	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

//-----------------------------------------------------------------------------
// vec3_t3DMultiplyPosition treats src2 as if it's a m_point (adds the translation)
//-----------------------------------------------------------------------------
// NJS: src2 is passed in as a full vec3_t rather than a reference to prevent the need
// for 2 branches and a potential copy in the body.  (ie, handling the case when the src2
// reference is the same as the dst reference ).
void vector_3d_multiply_position(const view_matrix_t& src1, const vec3_t& src2, vec3_t& dst) {
	dst.x = src1[0][0] * src2.x + src1[0][1] * src2.y + src1[0][2] * src2.z + src1[0][3];
	dst.y = src1[1][0] * src2.x + src1[1][1] * src2.y + src1[1][2] * src2.z + src1[1][3];
	dst.z = src1[2][0] * src2.x + src1[2][1] * src2.y + src1[2][2] * src2.z + src1[2][3];
}

//-----------------------------------------------------------------------------
// Methods related to the basis vec3_ts of the matrix
//-----------------------------------------------------------------------------

vec3_t view_matrix_t::get_forward() const {
	return vec3_t(m[0][0], m[1][0], m[2][0]);
}

vec3_t view_matrix_t::get_left() const {
	return vec3_t(m[0][1], m[1][1], m[2][1]);
}

vec3_t view_matrix_t::get_up() const {
	return vec3_t(m[0][2], m[1][2], m[2][2]);
}

void view_matrix_t::set_forward(const vec3_t& forward) {
	m[0][0] = forward.x;
	m[1][0] = forward.y;
	m[2][0] = forward.z;
}

void view_matrix_t::set_left(const vec3_t& left) {
	m[0][1] = left.x;
	m[1][1] = left.y;
	m[2][1] = left.z;
}

void view_matrix_t::set_up(const vec3_t& up) {
	m[0][2] = up.x;
	m[1][2] = up.y;
	m[2][2] = up.z;
}

void view_matrix_t::get_basis_vector_3d(vec3_t& forward, vec3_t& left, vec3_t& up) const {
	forward = vec3_t(m[0][0], m[1][0], m[2][0]);
	left = vec3_t(m[0][1], m[1][1], m[2][1]);
	up = vec3_t(m[0][2], m[1][2], m[2][2]);
}

void view_matrix_t::set_basis_vector_3d(const vec3_t& forward, const vec3_t& left, const vec3_t& up) {
	set_forward(forward);
	set_left(left);
	set_up(up);
}

//-----------------------------------------------------------------------------
// Methods related to the translation component of the matrix
//-----------------------------------------------------------------------------

vec3_t view_matrix_t::get_translation() const {
	return vec3_t(m[0][3], m[1][3], m[2][3]);
}

vec3_t& view_matrix_t::get_translation(vec3_t& trans) const {
	trans.x = m[0][3];
	trans.y = m[1][3];
	trans.z = m[2][3];
	return trans;
}

void view_matrix_t::set_translation(const vec3_t& trans) {
	m[0][3] = trans.x;
	m[1][3] = trans.y;
	m[2][3] = trans.z;
}

//-----------------------------------------------------------------------------
// appply translation to this matrix in the input space
//-----------------------------------------------------------------------------
void view_matrix_t::pre_translate(const vec3_t& trans) {
	vec3_t tmp;
	vector_3d_multiply_position(*this, trans, tmp);
	m[0][3] = tmp.x;
	m[1][3] = tmp.y;
	m[2][3] = tmp.z;
}

//-----------------------------------------------------------------------------
// appply translation to this matrix in the output space
//-----------------------------------------------------------------------------
void view_matrix_t::post_translate(const vec3_t& trans) {
	m[0][3] += trans.x;
	m[1][3] += trans.y;
	m[2][3] += trans.z;
}

const matrix_t& view_matrix_t::as_matrix() const {
	return *((const matrix_t*)this);
}

matrix_t& view_matrix_t::as_matrix() {
	return *((matrix_t*)this);
}

void view_matrix_t::copy_from_matrix(const matrix_t& m3x4) {
	memcpy(m, m3x4.base(), sizeof(matrix_t));
	m[3][0] = m[3][1] = m[3][2] = 0;
	m[3][3] = 1;
}

void view_matrix_t::set_matrix(matrix_t& m3x4) const {
	memcpy(m3x4.base(), m, sizeof(matrix_t));
}

//-----------------------------------------------------------------------------
// Matrix math operations
//-----------------------------------------------------------------------------
const view_matrix_t& view_matrix_t::operator+=(const view_matrix_t& other) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] += other.m[i][j];
		}
	}
	return *this;
}

view_matrix_t& view_matrix_t::operator=(const view_matrix_t& other) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = other.m[i][j];
		}
	}
	return *this;
}

view_matrix_t view_matrix_t::operator+(const view_matrix_t& other) const {
	view_matrix_t ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = ((float*)m)[i] + ((float*)other.m)[i];
	}
	return ret;
}

view_matrix_t view_matrix_t::operator-(const view_matrix_t& other) const {
	view_matrix_t ret;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			ret.m[i][j] = m[i][j] - other.m[i][j];
		}
	}

	return ret;
}

view_matrix_t view_matrix_t::operator-() const {
	view_matrix_t ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = -((float*)m)[i];
	}
	return ret;
}

//-----------------------------------------------------------------------------
// vec3_t transformation
//-----------------------------------------------------------------------------

vec3_t view_matrix_t::operator*(const vec3_t& vec) const {
	vec3_t ret;
	ret.x = m[0][0] * vec.x + m[0][1] * vec.y + m[0][2] * vec.z + m[0][3];
	ret.y = m[1][0] * vec.x + m[1][1] * vec.y + m[1][2] * vec.z + m[1][3];
	ret.z = m[2][0] * vec.x + m[2][1] * vec.y + m[2][2] * vec.z + m[2][3];
	return ret;
}

vec3_t view_matrix_t::vector_3d_multiply(const vec3_t& vec) const {
	vec3_t result;
	vector_3d_multiply_position(*this, vec, result);
	return result;
}

vec3_t view_matrix_t::vector_3d_transpose(const vec3_t& vec) const {
	vec3_t tmp = vec;
	tmp.x -= m[0][3];
	tmp.y -= m[1][3];
	tmp.z -= m[2][3];

	return vec3_t(
		m[0][0] * tmp.x + m[1][0] * tmp.y + m[2][0] * tmp.z,
		m[0][1] * tmp.x + m[1][1] * tmp.y + m[2][1] * tmp.z,
		m[0][2] * tmp.x + m[1][2] * tmp.y + m[2][2] * tmp.z
	);
}

vec3_t view_matrix_t::vector_3d_multiply_upper(const vec3_t & vec) const {
	return vec3_t(
		m[0][0] * vec.x + m[0][1] * vec.y + m[0][2] * vec.z,
		m[1][0] * vec.x + m[1][1] * vec.y + m[1][2] * vec.z,
		m[2][0] * vec.x + m[2][1] * vec.y + m[2][2] * vec.z
	);
}

vec3_t view_matrix_t::vector_3d_transpose_rotation(const vec3_t & vec) const {
	return vec3_t(
		m[0][0] * vec.x + m[1][0] * vec.y + m[2][0] * vec.z,
		m[0][1] * vec.x + m[1][1] * vec.y + m[2][1] * vec.z,
		m[0][2] * vec.x + m[1][2] * vec.y + m[2][2] * vec.z
	);
}

void view_matrix_t::vector_3d_multiply(const vec3_t & in, vec3_t & out) const {
	vec_t rw;

	rw = 1.0f / (m[3][0] * in.x + m[3][1] * in.y + m[3][2] * in.z + m[3][3]);
	out.x = (m[0][0] * in.x + m[0][1] * in.y + m[0][2] * in.z + m[0][3]) * rw;
	out.y = (m[1][0] * in.x + m[1][1] * in.y + m[1][2] * in.z + m[1][3]) * rw;
	out.z = (m[2][0] * in.x + m[2][1] * in.y + m[2][2] * in.z + m[2][3]) * rw;
}

//-----------------------------------------------------------------------------
// Other random stuff
//-----------------------------------------------------------------------------
void view_matrix_t::identity() {
	m[0][0] = 1.0f; m[0][1] = 0.0f; m[0][2] = 0.0f; m[0][3] = 0.0f;
	m[1][0] = 0.0f; m[1][1] = 1.0f; m[1][2] = 0.0f; m[1][3] = 0.0f;
	m[2][0] = 0.0f; m[2][1] = 0.0f; m[2][2] = 1.0f; m[2][3] = 0.0f;
	m[3][0] = 0.0f; m[3][1] = 0.0f; m[3][2] = 0.0f; m[3][3] = 1.0f;
}

bool view_matrix_t::is_identity() const {
	return
		m[0][0] == 1.0f && m[0][1] == 0.0f && m[0][2] == 0.0f && m[0][3] == 0.0f &&
		m[1][0] == 0.0f && m[1][1] == 1.0f && m[1][2] == 0.0f && m[1][3] == 0.0f &&
		m[2][0] == 0.0f && m[2][1] == 0.0f && m[2][2] == 1.0f && m[2][3] == 0.0f &&
		m[3][0] == 0.0f && m[3][1] == 0.0f && m[3][2] == 0.0f && m[3][3] == 1.0f;
}

vec3_t view_matrix_t::apply_rotation(const vec3_t & vec) const {
	return vector_3d_multiply(vec);
}

```

`solace-csgo/view_matrix.hpp`:

```hpp
#pragma once
struct matrix_t;
class vec3_t;

typedef float vec_t;


class view_matrix_t {
public:

	view_matrix_t();
	view_matrix_t(
		vec_t m00, vec_t m01, vec_t m02, vec_t m03,
		vec_t m10, vec_t m11, vec_t m12, vec_t m13,
		vec_t m20, vec_t m21, vec_t m22, vec_t m23,
		vec_t m30, vec_t m31, vec_t m32, vec_t m33
	);

	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	view_matrix_t(const vec3_t& forward, const vec3_t& left, const vec3_t& up);

	// Construct from a 3x4 matrix
	view_matrix_t(const matrix_t& m3x4);

	// Set the values in the matrix.
	void		init(
		vec_t m00, vec_t m01, vec_t m02, vec_t m03,
		vec_t m10, vec_t m11, vec_t m12, vec_t m13,
		vec_t m20, vec_t m21, vec_t m22, vec_t m23,
		vec_t m30, vec_t m31, vec_t m32, vec_t m33
	);

	// Initialize from a 3x4
	void		init(const matrix_t& matrix3x4);

	// array access
	inline float* operator[](int i) {
		return m[i];
	}

	inline const float* operator[](int i) const {
		return m[i];
	}

	// Get a pointer to m[0][0]
	inline float* base() {
		return &m[0][0];
	}

	inline const float* base() const {
		return &m[0][0];
	}

	void		set_left(const vec3_t& left);
	void		set_up(const vec3_t& up);
	void		set_forward(const vec3_t& forward);

	void		get_basis_vector_3d(vec3_t& forward, vec3_t& left, vec3_t& up) const;
	void		set_basis_vector_3d(const vec3_t& forward, const vec3_t& left, const vec3_t& up);

	// Get/set the translation.
	vec3_t& 	get_translation(vec3_t& trans) const;
	void		set_translation(const vec3_t& trans);

	void		pre_translate(const vec3_t& tans);
	void		post_translate(const vec3_t& trans);

	matrix_t& 	as_matrix();
	const matrix_t& as_matrix() const;
	void		copy_from_matrix(const matrix_t& m3x4);
	void		set_matrix(matrix_t& m3x4) const;

	bool		operator==(const view_matrix_t& src) const;
	bool		operator!=(const view_matrix_t& src) const { return !(*this == src); }

	// Access the basis vec3_ts.
	vec3_t		get_left() const;
	vec3_t		get_up() const;
	vec3_t		get_forward() const;
	vec3_t		get_translation() const;

	// Matrix->vec3_t operations.
public:
	// Multiply by a 3D vec3_t (same as operator*).
	void		vector_3d_multiply(const vec3_t & in, vec3_t & out) const;

	// Applies the rotation (ignores translation in the matrix). (This just calls VMul3x3).
	vec3_t		apply_rotation(const vec3_t & vec) const;

	// Multiply by a vec3_t (divides by w, assumes input w is 1).
	vec3_t		operator*(const vec3_t & vec) const;

	// Multiply by the upper 3x3 part of the matrix (ie: only apply rotation).
	vec3_t		vector_3d_multiply(const vec3_t & vec) const;

	// Apply the inverse (transposed) rotation (only works on pure rotation matrix)
	vec3_t		vector_3d_transpose_rotation(const vec3_t & vec) const;

	// Multiply by the upper 3 rows.
	vec3_t		vector_3d_multiply_upper(const vec3_t & vec) const;

	// Apply the inverse (transposed) transformation (only works on pure rotation/translation)
	vec3_t		vector_3d_transpose(const vec3_t & vec) const;
	
public:

	view_matrix_t& operator=(const view_matrix_t & other);

	// Multiply two matrices (out = this * vm).
	void		MatrixMul(const view_matrix_t & vm, view_matrix_t & out) const;

	// Add two matrices.
	const view_matrix_t& operator+=(const view_matrix_t & other);

	// Just calls MatrixMul and returns the result.
	view_matrix_t		operator*(const view_matrix_t & other) const;

	// Add/Subtract two matrices.
	view_matrix_t		operator+(const view_matrix_t & other) const;
	view_matrix_t		operator-(const view_matrix_t & other) const;

	// Negation.
	view_matrix_t		operator-() const;

	// Matrix operations.
public:
	// Set to identity.
	void		identity();

	bool		is_identity() const;

	// Setup a matrix for origin and angles.
	void		setup_maitrx_orginal_angles(const vec3_t & origin, const vec3_t & angles);

	// Does a fast inverse, assuming the matrix only contains translation and rotation.
	void		inverse_tr(view_matrix_t & ret) const;

	// Usually used for debug checks. Returns true if the upper 3x3 contains
	// unit vec3_ts and they are all orthogonal.
	bool		is_rotation_matrix() const;

	// This calls the other InverseTR and returns the result.
	view_matrix_t		inverse_tr() const;

	// Get the scale of the matrix's basis vec3_ts.
	vec3_t			get_scale() const;

	// (Fast) multiply by a scaling matrix setup from vScale.
	view_matrix_t		scale(const vec3_t & scale);

	// Normalize the basis vec3_ts.
	view_matrix_t		normalize_basis_vector_3d() const;

	// Transpose.
	view_matrix_t		transpose() const;

	// Transpose upper-left 3x3.
	view_matrix_t		transpose_3x3() const;

public:
	// The matrix.
	vec_t		m[4][4];
};

```

`solace-csgo/view_setup.h`:

```h
#pragma once

struct view_setup_t {
	char _0x0000[ 16 ];
	__int32 x;
	__int32 x_old;
	__int32 y;
	__int32 y_old;
	__int32 width;
	__int32    width_old;
	__int32 height;
	__int32    height_old;
	char _0x0030[ 128 ];
	float fov;
	float fovViewmodel;
	vec3_t origin;
	vec3_t angles;
	float zNear;
	float zFar;
	float zNearViewmodel;
	float zFarViewmodel;
	float m_flAspectRatio;
	float m_flNearBlurDepth;
	float m_flNearFocusDepth;
	float m_flFarFocusDepth;
	float m_flFarBlurDepth;
	float m_flNearBlurRadius;
	float m_flFarBlurRadius;
	float m_nDoFQuality;
	__int32 m_nMotionBlurMode;
	char _0x0104[ 68 ];
	__int32 m_EdgeBlur;
};
```

`solace-csgo/vmt.h`:

```h
#pragma once
#include <cstdint>
#include <cstring>
#include <memory>

class c_hook {
private:
	uintptr_t                      m_base;
	void **m_old_vmt;
	std::unique_ptr< uintptr_t[ ] > m_new_vmt;
	size_t                       m_size;
	bool                         m_rtti;

private:
	__forceinline size_t count_methods( ) const {
		auto i{ 0u };

		while ( m_old_vmt[ i ] != nullptr )
			++i;

		return i;
	}

public:
	// default ctor.
	__forceinline c_hook( ) : m_base{}, m_old_vmt{}, m_new_vmt{}, m_size{}, m_rtti{} {}

	// ctor.
	__forceinline c_hook( uintptr_t base, bool rtti = true ) : m_base{}, m_old_vmt{}, m_new_vmt{}, m_size{}, m_rtti{} {
		init( base, rtti );
	}
	__forceinline c_hook( void* base, bool rtti = true ) : m_base{}, m_old_vmt{}, m_new_vmt{}, m_size{}, m_rtti{} {
		init( ( uintptr_t )base, rtti );
	}

	// dtor.
	__forceinline ~c_hook( ) {
		reset( );
	}

	// reset entire class.
	__forceinline void reset( ) {
		m_new_vmt.reset( );

		if ( m_base )
			*( uintptr_t * )m_base = ( uintptr_t )m_old_vmt;

		m_base = uintptr_t{};
		m_old_vmt = nullptr;
		m_size = 0;
		m_rtti = false;
	}

	// setup and replace vmt.
	__forceinline void init( uintptr_t base, const bool rtti = true ) {
		// save base class.
		m_base = base;

		// get ptr to old VMT.
		m_old_vmt = *reinterpret_cast< void *** >( base );
		if ( !m_old_vmt )
			return;

		// count number of methods in old VMT.
		m_size = count_methods( );
		if ( !m_size )
			return;

		// allocate new VMT.
		m_new_vmt = std::make_unique< uintptr_t[ ] >( rtti ? m_size + 1 : m_size );
		if ( !m_new_vmt )
			return;

		// get raw memory ptr.
		const auto vmt = reinterpret_cast< uintptr_t >( m_new_vmt.get( ) );

		if ( rtti ) {
			// copy VMT, starting from RTTI.
			std::memcpy( reinterpret_cast< uintptr_t * >( vmt ), m_old_vmt - 1, ( m_size + 1 ) * sizeof( uintptr_t ) );

			// VMTs are ( usually ) stored in the .data section we should be able to just overwrite it, so let's do that here.
			// also, since we've copied RTTI ptr then point the new table at index 1 ( index 0 contains RTTI ptr ).
			*reinterpret_cast< uintptr_t * >( base ) = ( vmt + sizeof( uintptr_t ) );

			// we've sucesfully copied the RTTI ptr.
			m_rtti = true;
		}

		else {
			// copy vmt.
			std::memcpy( reinterpret_cast< uintptr_t * >( vmt ), m_old_vmt, m_size * sizeof( uintptr_t ) );

			// since VMTs are ( usually ) stored in the .data section we should be able to just overwrite it, so let's do that here.
			*reinterpret_cast< uintptr_t * >( base ) = vmt;
		}
	}

	template< typename t = uintptr_t >
	__forceinline t add( void *function_ptr, size_t index ) {
		const auto vmt_index{ m_rtti ? index + 1 : index };

		// sanity check some stuff first.
		if ( !m_old_vmt || !m_new_vmt || vmt_index > m_size )
			return t{};

		// redirect.
		m_new_vmt[ vmt_index ] = reinterpret_cast< uintptr_t >( function_ptr );

		return reinterpret_cast< t >(m_old_vmt[index]);
	}

	__forceinline bool remove( size_t index ) const {
		const auto vmt_index{ m_rtti ? index + 1 : index };

		// sanity check some stuff first.
		if ( !m_old_vmt || !m_new_vmt || vmt_index > m_size )
			return false;

		// redirect.
		//m_new_vmt[vmt_index] = m_old_vmt[index];

		return true;
	}

	template< typename t = uintptr_t >
	__forceinline t get_original( size_t index ) {
		return  reinterpret_cast< t >(m_old_vmt[index]);
	}
};

```

`solace-csgo/weapon_info.h`:

```h
#pragma once
#include "utils.h"

enum CSWeaponType : int {
	WEAPONTYPE_UNKNOWN = -1,
	WEAPONTYPE_KNIFE,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_TASER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_HEALTHSHOT = 11
};

class weapon_info_t {
private:
	PAD( 0x4 );											// 0x0000

public:
	const char *m_weapon_name;						// 0x0004 -- actual weapon name, even for usp-s and revolver. ex: "weapon_revolver"
	PAD( 0xC );												// 0x0008
	int               m_max_clip1;							// 0x0014
	int				  m_max_clip2;							// 0x0018
	int				  m_default_clip1;						// 0x001C
	int		          m_default_clip2;						// 0x0020
	int               m_max_reserve;						// 0x0024
	PAD( 0x4 );												// 0x0028
	const char *m_world_model;						// 0x002C
	const char *m_view_model;							// 0x0030
	const char *m_world_dropped_model;				// 0x0034
	PAD( 0x48 );											// 0x0038
	const char *m_ammo_type;							// 0x0080
	uint8_t           pad_0084[ 4 ];						// 0x0084
	const char *m_sfui_name;							// 0x0088
	const char *m_deprecated_weapon_name;				// 0x008C -- shitty weapon name, shows "weapon_deagle" for revolver / etc.
	uint8_t           pad_0090[ 56 ];						// 0x0090
	CSWeaponType      m_weapon_type;						// 0x00C8
	int			      m_in_game_price;						// 0x00CC
	int               m_kill_award;							// 0x00D0
	const char *m_animation_prefix;					// 0x00D4
	float			  m_cycletime;							// 0x00D8
	float			  m_cycletime_alt;						// 0x00DC
	float			  m_time_to_idle;						// 0x00E0
	float			  m_idle_interval;						// 0x00E4
	bool			  m_is_full_auto;						// 0x00E5
	PAD( 0x3 );												// 0x00E8
	int               m_damage;								// 0x00EC
	float             m_armor_ratio;						// 0x00F0
	int               m_bullets;							// 0x00F4
	float             m_penetration;						// 0x00F8
	float             m_flinch_velocity_modifier_large;		// 0x00FC
	float             m_flinch_velocity_modifier_small;		// 0x0100
	float             m_range;								// 0x0104
	float             m_range_modifier;						// 0x0108
	float			  m_throw_velocity;						// 0x010C
	PAD( 0xC );												// 0x0118
	bool			  m_has_silencer;						// 0x0119
	PAD( 0x3 );												// 0x011C
	const char *m_silencer_model;						// 0x0120
	int				  m_crosshair_min_distance;				// 0x0124
	int				  m_crosshair_delta_distance;			// 0x0128
	float             m_max_player_speed;					// 0x012C
	float             m_max_player_speed_alt;				// 0x0130
	float			  m_spread;								// 0x0134
	float			  m_spread_alt;							// 0x0138
	float             m_inaccuracy_crouch;					// 0x013C
	float             m_inaccuracy_crouch_alt;				// 0x0140
	float             m_inaccuracy_stand;					// 0x0144
	float             m_inaccuracy_stand_alt;				// 0x0148
	float             m_inaccuracy_jump_initial;			// 0x014C
	float             m_inaccuracy_jump;					// 0x0150
	float             m_inaccuracy_jump_alt;				// 0x0154
	float             m_inaccuracy_land;					// 0x0158
	float             m_inaccuracy_land_alt;				// 0x015C
	float             m_inaccuracy_ladder;					// 0x0160
	float             m_inaccuracy_ladder_alt;				// 0x0164
	float             m_inaccuracy_fire;					// 0x0168
	float             m_inaccuracy_fire_alt;				// 0x016C
	float             m_inaccuracy_move;					// 0x0170
	float             m_inaccuracy_move_alt;				// 0x0174
	float             m_inaccuracy_reload;					// 0x0178
	int               m_recoil_seed;						// 0x017C
	float			  m_recoil_angle;						// 0x0180
	float             m_recoil_angle_alt;					// 0x0184
	float             m_recoil_angle_variance;				// 0x0188
	float             m_recoil_angle_variance_alt;			// 0x018C
	float             m_recoil_magnitude;					// 0x0190
	float             m_recoil_magnitude_alt;				// 0x0194
	float             m_recoil_magnitude_variance;			// 0x0198
	float             m_recoil_magnitude_variance_alt;		// 0x019C
	float             m_recovery_time_crouch;				// 0x01A0
	float             m_recovery_time_stand;				// 0x01A4
	float             m_recovery_time_crouch_final;			// 0x01A8
	float             m_recovery_time_stand_final;			// 0x01AC
	float             m_recovery_transition_start_bullet;	// 0x01B0
	float             m_recovery_transition_end_bullet;		// 0x01B4
	bool			  m_unzoom_after_shot;					// 0x01B5
	PAD( 0x3 );												// 0x01B8
	bool		      m_hide_view_model_zoomed;				// 0x01B9
	bool			  m_zoom_levels;						// 0x01BA
	PAD( 0x2 );												// 0x01BC
	int				  m_zoom_fov[ 2 ];						// 0x01C4
	float			  m_zoom_time[ 3 ];						// 0x01D0
	PAD( 0x8 );												// 0x01D8
	float             m_addon_scale;						// 0x01DC
	PAD( 0x8 );												// 0x01E4
	int				  m_tracer_frequency;					// 0x01E8
	int				  m_tracer_frequency_alt;				// 0x01EC
	PAD( 0x18 );											// 0x0200
	int				  m_health_per_shot;					// 0x0204
	PAD( 0x8 );												// 0x020C
	float			  m_inaccuracy_pitch_shift;				// 0x0210
	float			  m_inaccuracy_alt_sound_threshold;		// 0x0214
	float			  m_bot_audible_range;					// 0x0218
	PAD( 0x8 );												// 0x0220
	const char *m_wrong_team_msg;						// 0x0224
	bool			  m_has_burst_mode;						// 0x0225
	PAD( 0x3 );												// 0x0228
	bool			  m_is_revolver;						// 0x0229
	bool			  m_can_shoot_underwater;				// 0x022A
	PAD( 0x2 );
};

```

`solace-csgo/weapon_system.h`:

```h
#pragma once
#include "includes.h"
class weapon_info_t;

class i_weapon_system {
	virtual void unused0( ) = 0;
	virtual void unused1( ) = 0;
public:
	[[nodiscard]] virtual weapon_info_t *get_weapon_data( unsigned int idx ) const = 0;
};
```