Project Path: arc_gmh5225_woody_woodpacker_9ia58516

Source Tree:

```txt
arc_gmh5225_woody_woodpacker_9ia58516
├── Dockerfile
├── Makefile
├── README.md
├── asm
│   └── unpacker.asm
├── auteur
├── includes
│   ├── tools.h
│   └── woody_woodpacker.h
├── libsrcs
│   └── libft
├── ressources
│   ├── sample
│   ├── sample.c
│   └── woody
├── run.sh
├── srcs
│   ├── debug.c
│   ├── elf.c
│   ├── elf_modify.c
│   ├── elf_read.c
│   ├── elf_save.c
│   ├── elf_write.c
│   └── woody_woodpacker.c
├── subjects
│   ├── woody_woodpacker.en.pdf
│   └── woody_woodpacker.fr.pdf
└── tests
    ├── exec_all.sh
    └── loop_woody.sh

```

`Dockerfile`:

```
FROM amd64/ubuntu:bionic

CMD ["/bin/bash"]

RUN rm /etc/dpkg/dpkg.cfg.d/excludes

RUN apt update \
	&& apt install -y git vim man gcc clang make nasm gdb \
	&& git clone https://github.com/longld/peda.git /root/peda \
	&& echo "source /root/peda/peda.py" >> ~/.gdbinit \
	&& mkdir /root/woody_woodpacker

WORKDIR /root/woody_woodpacker

```

`Makefile`:

```
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vsteffen <marvin@42.fr>                    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2016/02/06 20:52:05 by vsteffen          #+#    #+#              #
#    Updated: 2018/03/20 18:17:27 by vsteffen         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

PROJECT	= woody_woodpacker
NAME	= woody_woodpacker

NEW_BIN	= woody

CC 	=	/usr/bin/clang
RM 	=	/bin/rm
MAKE 	=	/usr/bin/make
MKDIR 	=	/bin/mkdir -p
AR 	=	/usr/bin/ar
RANLIB 	=	/usr/bin/ranlib
GIT	=	/usr/bin/git
NASM	=	/usr/bin/nasm
OBJCOPY	=	/usr/bin/objcopy
HEXDUMP	=	/usr/bin/hexdump

OBJ = $(patsubst %.c, $(OPATH)/%.o, $(SRC))

CFLAGS = -Wall -Wextra -Werror -g #-fsanitize=address

ifeq ($(with-asm),y)
	WITH-ASM:= with-asm
endif

LIB	=	$(ROOT)/lib
LIBSRCS	=	$(ROOT)/libsrcs
LIBFT 	=	$(LIBSRCS)/libft

ROOT  	=	$(shell /bin/pwd)
OPATH 	=	$(ROOT)/objs
CPATH 	=	$(ROOT)/srcs
LPATH	=	$(LIBFT)/libft.a
HPATH 	=	-I $(ROOT)/includes -I $(LIBFT)/includes

SRC =	woody_woodpacker.c \
	debug.c \
	elf.c \
	elf_read.c \
	elf_write.c \
	elf_modify.c \
	elf_save.c

ASMPATH		= $(ROOT)/asm
ASM_SRC		= $(ASMPATH)/unpacker.asm
ASM_OBJ		= $(ASMPATH)/unpacker.o
ASM_BYTECODE	= $(ASMPATH)/bytecode

PRE_CHECK_SUB_LIBFT	:= $(LIBFT)/Makefile
PRE_CHECK_SUB		:= $(PRE_CHECK_SUB_LIBFT)

PRE_CHECK_LIB_LIBFT 	:= $(LIBFT)/libft.a
PRE_CHECK_LIB		:= $(PRE_CHECK_LIB_LIBFT) $(PRE_CHECK_LIB_LULZ)

COMPILE	= no

OS	:= $(shell uname -s)

ifeq ($(OS),Darwin)
	NPROCS:=$(shell sysctl -n hw.ncpu)
else
	NPROCS:=$(shell grep -c ^processor /proc/cpuinfo)
endif


define PRINT_RED
	printf "\033[31m$(1)\033[0m"
endef

define PRINT_GREEN
	printf "\033[32m$(1)\033[0m"
endef

define PRINT_YELLOW
	printf "\033[33m$(1)\033[0m"
endef

define PRINT_STATUS
	printf '['
	$(if $(filter $(2),SUCCESS),$(call PRINT_GREEN,$(1)))
	$(if $(filter $(2),FAIL),$(call PRINT_RED,$(1)))
	$(if $(filter $(2),WARN),$(call PRINT_YELLOW,$(1)))
	$(if $(filter $(2),INFO),printf $(1))
	$(if $(filter $(3),-n),printf $(1),echo ']')
endef

.PHONY: all clean fclean re lib-clean lib-update
.SILENT: $(PRE_CHECK_SUB) $(PRE_CHECK_LIB) $(NAME) $(OPATH) $(ASM_OBJ) $(OPATH)/%.o clean fclean re lib-clean lib-update

all: $(NAME)

$(PRE_CHECK_SUB):
	@echo $(PROJECT)": Init submodule $(dir $@) ... "
	@$(GIT) submodule update --init --recursive > /dev/null  # can't directly redirect stdout on /dev/null cause of sync wait on Linux
	@printf $(PROJECT)": $(dir $@) "
	@$(call PRINT_STATUS,INITIALIZED,SUCCESS)

$(PRE_CHECK_LIB): $(PRE_CHECK_SUB)
	echo $(PROJECT)": Compile $@ ... " ; \
	if [ $@ = $(PRE_CHECK_LIB_LIBFT) ] ; then \
		if [ $(OS) = "Darwin" ] ; then \
			$(MAKE) -C $(LIBFT) $(WITH-ASM) -j$(NPROCS) > /dev/null ; \
		else \
			$(MAKE) -C $(LIBFT) -j$(NPROCS) ; \
		fi; \
	else \
		echo "Other libraries here" ; \
	fi; \
	printf $(PROJECT)": $@ " ; \
	$(call PRINT_STATUS,COMPILED,SUCCESS) ;


$(ASM_OBJ):
	$(NASM) -f elf64 $(ASM_SRC) -o $(ASM_OBJ)
	$(OBJCOPY) -O binary -j .text $(ASM_OBJ) $(ASM_BYTECODE)

$(NAME): $(PRE_CHECK_LIB) $(ASM_OBJ) $(OPATH) $(OBJ)
	$(if $(filter $(COMPILE),yes),echo ']')
	printf $(PROJECT)": Building $@ ... "
	$(CC) -o $@ $(CFLAGS) $(OBJ) $(LPATH) $(HPATH) $(ASM_OBJ)
	$(call PRINT_STATUS,DONE,SUCCESS)

$(OPATH)/%.o: $(CPATH)/%.c | $(PRE_CHECK_LIB)
	$(if $(filter $(COMPILE),no),@printf $(PROJECT)': Files compiling [')
	$(eval COMPILE := yes)
	@$(CC) $(CFLAGS) -c $< -o $@ $(HPATH) -DBYTECODE=\"`$(HEXDUMP) -v -e '"\\\\x" 1/1 "%02X"' $(ASM_BYTECODE)`\"
	@$(call PRINT_GREEN,.)

$(OPATH):
	echo $(PROJECT)": Creation of objects directory"
	$(MKDIR) $@

clean:
	$(RM) -Rf $(OPATH)
	$(RM) -f $(ASM_OBJ)
	echo $(PROJECT)": Objects cleaned "
	printf $(PROJECT)": $@ rule "
	$(call PRINT_STATUS,DONE,SUCCESS)

fclean: clean
	$(RM) -f $(NAME)
	$(RM) -f $(NEW_BIN)
	$(RM) -f $(ASM_BYTECODE)
	echo $(PROJECT)": executable clean"
	printf $(PROJECT)": $@ rule "
	$(call PRINT_STATUS,DONE,SUCCESS)

re: fclean
	$(MAKE) -C $(ROOT) -j$(NPROCS) -s

lib-clean:
	echo $(PROJECT)": cleaning libraries ..."
	-$(MAKE) -C $(LIBFT) fclean -j$(NPROCS) > /dev/null
	printf $(PROJECT)": $@ rule "
	$(call PRINT_STATUS,DONE,SUCCESS)

lib-update:
	echo $(PROJECT)": Update submodules ... "
	$(GIT) submodule update --init --recursive --remote > /dev/null
	printf $(PROJECT)": submodules "
	$(call PRINT_STATUS,UPDATED,SUCCESS)

```

`README.md`:

```md
# woody_woodpacker
42 School project. From the subject (also available in french):

> The goal of this project is to code a program that will, firstly, encrypt a program give as parameter. Only 64 bits ELF files will be managed here.
>
> A new program called “woody” will be generated from this execution.  When this new program (woody) will be executed, it will have to be decrypted to be run. Its execution has to be at any point identical to the program given as parameter in the last step.

```

`asm/unpacker.asm`:

```asm
global xor_cipher

section .text

woody:
	pushfq
	push	rdi
	push	rsi
	push	rdx
	push	r8
	push	r9
	push	r10

xor_cipher_params:
	lea	rdi, [rel woody_str_end + 2]
	mov	rsi, 0xBBBBBBBBBBBBBBBB
	lea	rdx, [rel woody - 0x22222201]
	mov	rcx, 0xCCCCCCCCCCCCCCCC
	call	xor_cipher

print_woody:
	mov	rax, 1
	mov	rdi, 1
	lea	rsi, [rel woody_str]
	mov	rdx, woody_str_end - woody_str - 1
	syscall

exit:
	pop	r10
	pop	r9
	pop	r8
	pop	rdx
	pop	rsi
	pop	rdi
	popfq

	jmp 0xAAAAAAAE



; void xor_cipher(char *key, size_t key_size, void *text, size_t text_size)
xor_cipher:
	cmp	rsi, 0
	je	xor_cipher_end

	xor	r8, r8		; counter
	mov	r9, rdx		; address of .text
	mov	r10, rcx	; size of .text

loop:
	cmp	r8, r10
	je	xor_cipher_end

	xor	rdx, rdx	; clear dividend
	mov	rax, r8		; dividend
	mov	rcx, rsi	; divisor
	div	rcx, 		; rax = /, rdx = %

	lea	rax, [rel rdi + rdx]
	mov	dl, byte[rax]
	xor	byte[r9], dl

	inc	r8
	inc	r9
	jmp	loop

xor_cipher_end:
	ret



align 8

woody_str	db "....WOODY....", 0x0a, 0
woody_str_end	db 0x0

```

`auteur`:

```
vsteffen

```

`includes/tools.h`:

```h
#ifndef TOOLS_H
# define TOOLS_H


# define STR_IMPL_(x) #x
# define STR(x) STR_IMPL_(x)

# define ERROR_STR(x) __FILE__ ":" STR(__LINE__) ": " x
# define ERROR(x) perror(ERROR_STR(x))

# define COUNT_OF(ptr) (sizeof(ptr) / sizeof((ptr)[0]))

# define BSWAP16(x) \
	((__uint16_t) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))

# define BSWAP32(x) \
	((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >> 8) \
	| (((x) & 0x0000ff00u) << 8) | (((x) & 0x000000ffu) << 24))

# define BSWAP64(x)				\
	((((x) & 0xff00000000000000ull) >> 56)	\
	| (((x) & 0x00ff000000000000ull) >> 40)	\
	| (((x) & 0x0000ff0000000000ull) >> 24)	\
	| (((x) & 0x000000ff00000000ull) >> 8)	\
	| (((x) & 0x00000000ff000000ull) << 8)	\
	| (((x) & 0x0000000000ff0000ull) << 24)	\
	| (((x) & 0x000000000000ff00ull) << 40)	\
	| (((x) & 0x00000000000000ffull) << 56))


#endif

```

`includes/woody_woodpacker.h`:

```h
#ifndef WOODY_WOODPACKER_H
# define WOODY_WOODPACKER_H

# include "libft.h"
# include "tools.h"

# include <elf.h>

# include <sys/mman.h>
# include <fcntl.h>
# include <sys/stat.h>
# include <errno.h>
# include <sys/syscall.h>

# define USAGE "Usage: %s elf_file [key]\n"

# define KEY_DEFAULT_SIZE 64

# define NEW_BIN_FILENAME "woody"
# define BYTECODE_SIZE sizeof(BYTECODE)

# define PATTERN_ENTRY_OLD 		0xAAAAAAe9
# define PATTERN_ENTRY_OLD_SIZE_OPCODE	1

# define PATTERN_KEY_SIZE		0xBBBBBBBBBBBBBBBB
# define PATTERN_KEY_SIZE_OPCODE	0

# define PATTERN_TEXT_SIZE		0xCCCCCCCCCCCCCCCC
# define PATTERN_TEXT_SIZE_OPCODE	0

# define PATTERN_ENTRY_TEXT		0xDDDDDDDD
# define PATTERN_ENTRY_TEXT_SIZE_OPCODE	0

typedef enum {false, true} bool;

typedef struct	s_key {
	char	*raw;
	size_t	length;
}		t_key;

typedef struct	s_woody {
	char		*woody_name;
	struct s_key	key;
	int		bin_fd;
	struct stat	bin_st;
	void		*bin_map;
	Elf64_Ehdr	ehdr;		// Ehdr copy with good endian
	Elf64_Shdr	shstrtab;	// Shdr copy with good endian
	Elf64_Shdr	new_section;
	uint64_t	new_entry;
	uint64_t	shdr_last_offset_adjustment;
	uint64_t	new_section_and_padding_size;
	bool		reverse_endian;
}		t_woody;


void	exit_clean(struct s_woody *woody, int exit_status);

void	check_headers_offset(struct s_woody *woody);

const char	*get_phdr_type_str(uint32_t p_type);
const char	*get_phdr_flags_str(uint32_t flags, char buff[4]);
const char	*get_ehdr_type_str(uint16_t e_type);
const char	*get_shdr_type_str(uint32_t sh_type);
void		get_shstrtab(struct s_woody *woody);
uint16_t	get_index_segment_containing_section(struct s_woody *woody, Elf64_Shdr *section);
uint16_t	get_index_section_with_name(struct s_woody *woody, char *section_name);

void	read_elf_header(struct s_woody *woody);
void	read_program_header(struct s_woody *woody, uint16_t index, Elf64_Phdr *phdr);
void	read_section_header(struct s_woody *woody, uint16_t index, Elf64_Shdr *shdr);

void	write_uint16(struct s_woody *woody, uint16_t *addr, uint16_t value);
void	write_uint32(struct s_woody *woody, uint32_t *addr, uint32_t value);
void	write_uint64(struct s_woody *woody, uint64_t *addr, uint64_t value);

void	modify_ehdr(struct s_woody *woody);
void	modify_phdr_bss(struct s_woody *woody, Elf64_Phdr *phdr_bss, uint16_t index_phdr_bss);
void	modify_phdr_text(struct s_woody *woody, Elf64_Shdr *shdr_text);
void	modify_shdr_pushed_by_new_section(struct s_woody *woody, uint16_t index_shdr_last);
void	modify_shdr_last(struct s_woody *woody, Elf64_Shdr *shdr_last, uint16_t index_shdr_last);

void	insert_section_after_bss(struct s_woody *woody);

void	xor_cipher(char *key, size_t key_size, void *text, size_t text_size);

void	save_new_section(struct s_woody *woody, int new_bin_fd, Elf64_Shdr *shdr_bss);
void	save_new_shdr(struct s_woody *woody, int new_bin_fd, Elf64_Shdr *new_section);
void	save_new_elf_file(struct s_woody *woody, Elf64_Shdr *shdr_bss, uint16_t index_shdr_bss);

// DEBUG
void	debug_print_headers(struct s_woody *woody);
void	debug_print_program_header(struct s_woody *woody);
void	debug_print_section_header(struct s_woody *woody);


/*
##########################

\-----> Elf Header

#define EI_NIDENT 16

typedef struct {
	unsigned char e_ident[EI_NIDENT];
	uint16_t      e_type;
	uint16_t      e_machine;
	uint32_t      e_version;
	ElfN_Addr     e_entry;
	ElfN_Off      e_phoff;
	ElfN_Off      e_shoff;
	uint32_t      e_flags;
	uint16_t      e_ehsize;
	uint16_t      e_phentsize;
	uint16_t      e_phnum;
	uint16_t      e_shentsize;
	uint16_t      e_shnum;
	uint16_t      e_shstrndx;
} ElfN_Ehdr;

##########################

\-----> Elf Program Header

typedef struct {
	uint32_t   p_type;
	uint32_t   p_flags;
	Elf64_Off  p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	uint64_t   p_filesz;
	uint64_t   p_memsz;
	uint64_t   p_align;
} Elf64_Phdr;

##########################

\-----> Elf Section Header

typedef struct {
	uint32_t   sh_name;
	uint32_t   sh_type;
	uint64_t   sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off  sh_offset;
	uint64_t   sh_size;
	uint32_t   sh_link;
	uint32_t   sh_info;
	uint64_t   sh_addralign;
	uint64_t   sh_entsize;
} Elf64_Shdr;

##########################
*/

#endif

```

`ressources/sample.c`:

```c
#include <stdio.h>

int
main(void) {
	printf("Hello, World!\n");
	return (0x0);
}

```

`run.sh`:

```sh
#!/bin/bash

IMAGE_NAME="woody"
SCRIPT_PATH="$( cd "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"

if [[ "$(docker images -q woody 2> /dev/null)" == "" ]]; then
	docker build -t "$IMAGE_NAME" "$SCRIPT_PATH"
	if [ $? -ne 0 ]; then
		exit 1
	fi
fi

docker run -it --mount type=bind,source="$SCRIPT_PATH",target=/root/woody_woodpacker woody

```

`srcs/debug.c`:

```c
#include "woody_woodpacker.h"

const char	*get_phdr_type_str(uint32_t p_type) {
	switch (p_type) {
		case PT_NULL:		return "NULL";
		case PT_LOAD:		return "LOAD";
		case PT_DYNAMIC:	return "DYNAMIC";
		case PT_INTERP:		return "INTERP";
		case PT_NOTE:		return "NOTE";
		case PT_SHLIB:		return "SHLIB";
		case PT_PHDR:		return "PHDR";
		case PT_TLS:		return "TLS";
		case PT_GNU_EH_FRAME:	return "GNU_EH_FRAME";
		case PT_GNU_STACK:	return "GNU_STACK";
		case PT_GNU_RELRO:	return "GNU_RELRO";
		default:		return "UNKNOWN";
	}
}

const char	*get_phdr_flags_str(uint32_t flags, char buff[4]) {
	buff[0] = (flags & PF_R) ? 'R' : ' ';
	buff[1] = (flags & PF_W) ? 'W' : ' ';
	buff[2] = (flags & PF_X) ? 'A' : ' ';
	return buff;
}

const char	*get_ehdr_type_str(uint16_t e_type) {
	switch (e_type) {
		case ET_NONE:	return "NONE";
		case ET_REL:	return "REL";
		case ET_EXEC:	return "EXEC";
		case ET_DYN:	return "DYN";
		case ET_CORE:	return "CORE";
		default:	return "UNKNOWN";
	}
}

const char	*get_shdr_type_str(uint32_t sh_type) {
	switch (sh_type) {
		case SHT_NULL:		return "NULL";
		case SHT_PROGBITS:	return "PROGBITS";
		case SHT_SYMTAB:	return "SYMTAB";
		case SHT_STRTAB:	return "STRTAB";
		case SHT_RELA:		return "RELA";
		case SHT_HASH:		return "HASH";
		case SHT_DYNAMIC:	return "DYNAMIC";
		case SHT_NOTE:		return "NOTE";
		case SHT_NOBITS:	return "NOBITS";
		case SHT_REL:		return "REL";
		case SHT_SHLIB:		return "SHLIB";
		case SHT_DYNSYM:	return "DYNSYM";
		default:		return "UNKNOWN";
	}
}

void	debug_print_program_header(struct s_woody *woody) {
	Elf64_Phdr phdr;
	char  buff_flags_str[4];
	buff_flags_str[3] = 0;

	printf("There are %hu program headers, starting at offset %#lx:\n\n", woody->ehdr.e_phnum, woody->ehdr.e_phoff);
	printf("Program Headers:\n");
	printf("  Type           Offset             VirtAddr           PhysAddr\n");
	printf("                 FileSiz            MemSiz              Flags  Align\n");
	for (uint16_t i = 0; i < woody->ehdr.e_phnum; i++) {
		read_program_header(woody, i, &phdr);
		printf("  %-14s 0x%016lx 0x%016lx 0x%016lx\n", get_phdr_type_str(phdr.p_type), phdr.p_offset, phdr.p_vaddr, phdr.p_paddr);
		printf("                 0x%016lx 0x%016lx  %s    %#lx\n", phdr.p_filesz, phdr.p_memsz, get_phdr_flags_str(phdr.p_flags, buff_flags_str), phdr.p_align);
	}
}

void	debug_print_section_header(struct s_woody *woody) {
	Elf64_Shdr shdr;

	printf("There are %hu section headers, starting at offset %#lx:\n\n", woody->ehdr.e_shnum, woody->ehdr.e_shoff);
	printf("Section Headers:\n");
	printf("  [Nr] Name              Type             Address           Offset\n");
	printf("       Size              EntSize          Flags  Link  Info  Align\n");
	for (uint16_t i = 0; i < woody->ehdr.e_shnum; i++) {
		read_section_header(woody, i, &shdr);
		printf("  [%2hu] %-16s  %-16s %016lx  %08lx\n", i, woody->bin_map + woody->shstrtab.sh_offset + shdr.sh_name, get_shdr_type_str(shdr.sh_type), shdr.sh_addr, shdr.sh_offset);
		printf("       %016lx  %016lx   ?       %-5u %-5u %-lu\n", shdr.sh_size, shdr.sh_entsize, shdr.sh_link, shdr.sh_info, shdr.sh_addralign);
	}
}

void	debug_print_headers(struct s_woody *woody) {
	printf("Elf file type is %s\n", get_ehdr_type_str(woody->ehdr.e_type));
	printf("Entry point %#lx\n\n", woody->ehdr.e_entry);
	printf("e_shoff = %zu\n", woody->ehdr.e_shoff);
	printf("e_shstrndx = %hu\n", woody->ehdr.e_shstrndx);
	debug_print_program_header(woody);
	printf("\n\n\n");
	debug_print_section_header(woody);
}


```

`srcs/elf.c`:

```c
#include "woody_woodpacker.h"

void	check_headers_offset(struct s_woody *woody) {
	Elf64_Shdr	tmp_shdr;

	if (woody->ehdr.e_phoff + woody->ehdr.e_phentsize * woody->ehdr.e_phnum > (size_t)woody->bin_st.st_size \
		|| woody->ehdr.e_shoff + woody->ehdr.e_shentsize * woody->ehdr.e_shnum > (size_t)woody->bin_st.st_size)
	{
		dprintf(STDERR_FILENO, "%s: corrupted ELF file\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	for (uint16_t i = 0; i < woody->ehdr.e_shnum; i++) {
		read_section_header(woody, i, &tmp_shdr);
		if ((size_t)tmp_shdr.sh_offset + (tmp_shdr.sh_type == SHT_NOBITS ? 0 : (size_t)tmp_shdr.sh_size) > (size_t)woody->bin_st.st_size) {
			dprintf(STDERR_FILENO, "%s: corrupted ELF file (wrong section offset or size)\n", woody->woody_name);
			exit_clean(woody, EXIT_FAILURE);
		}
	}
}

void		get_shstrtab(struct s_woody *woody) {
	if (woody->ehdr.e_shstrndx == SHN_XINDEX) {
		Elf64_Shdr first_shdr;
		read_section_header(woody, 0, &first_shdr);
		read_section_header(woody, first_shdr.sh_link, &woody->shstrtab);
	}
	else
		read_section_header(woody, woody->ehdr.e_shstrndx, &woody->shstrtab);
}

uint16_t	get_index_section_with_name(struct s_woody *woody, char *section_name) {
	Elf64_Shdr	tmp;
	void		*end_of_str;
	size_t		offset_name;

	for (uint16_t i = 0; i < woody->ehdr.e_shnum; i++) {
		read_section_header(woody, i, &tmp);
		offset_name = woody->shstrtab.sh_offset + tmp.sh_name;
		if (offset_name > (size_t)woody->bin_st.st_size) {
			dprintf(STDERR_FILENO, "%s: corrupted ELF file (wrong shstrtab.sh_offset)\n", woody->woody_name);
			exit_clean(woody, EXIT_FAILURE);
		}
		end_of_str = ft_memchr(woody->bin_map + offset_name, 0, (size_t)woody->bin_st.st_size - offset_name);
		if (!end_of_str) {
			dprintf(STDERR_FILENO, "%s: corrupted ELF file (wrong sh_name offset)\n", woody->woody_name);
			exit_clean(woody, EXIT_FAILURE);
		}
		if (ft_strcmp(section_name, woody->bin_map + offset_name) == 0)
			return (i);
	}
	return (-1);
}

uint16_t	get_index_segment_containing_section(struct s_woody *woody, Elf64_Shdr *section) {
	Elf64_Phdr tmp;
	for (uint16_t i = 0; i < woody->ehdr.e_phnum; i++) {
		read_program_header(woody, i, &tmp);
		if (tmp.p_vaddr <= section->sh_addr && section->sh_addr <= tmp.p_vaddr + tmp.p_memsz)
			return (i);
	}
	return (-1);
}

void		fill_new_section(struct s_woody *woody, Elf64_Shdr *new_section, Elf64_Shdr *shdr_last) {
	new_section->sh_name = 0;
	new_section->sh_type = SHT_PROGBITS;
	new_section->sh_flags = SHF_EXECINSTR | SHF_ALLOC;
	new_section->sh_addr = shdr_last->sh_addr + shdr_last->sh_size; // Push bc shdr_last will be at least SHT_PROGBITS
	new_section->sh_offset = shdr_last->sh_offset + shdr_last->sh_size;
	new_section->sh_size = BYTECODE_SIZE + woody->key.length;
	new_section->sh_link = 0;
	new_section->sh_info = 0;
	new_section->sh_addralign = 1;
	new_section->sh_entsize = 0;
}

uint16_t	get_index_last_shdr_in_phdr_bss(struct s_woody *woody, uint16_t index_shdr_bss, Elf64_Phdr *phdr_bss) {
	uint64_t	phdr_bss_last_byte = phdr_bss->p_vaddr + phdr_bss->p_memsz;
	Elf64_Shdr	tmp;

	for (uint16_t i = index_shdr_bss; i < woody->ehdr.e_shnum; i++) {
		read_section_header(woody, i, &tmp);
		if (tmp.sh_addr + tmp.sh_size == phdr_bss_last_byte)
			return (i);
	}
	return (-1);
}

void		insert_section_after_bss(struct s_woody *woody) {
	Elf64_Shdr	shdr_last;
	Elf64_Shdr	shdr_bss;
	Elf64_Shdr	shdr_text;
	Elf64_Phdr	phdr_bss;
	uint16_t	index_shdr_bss;
	uint16_t	index_shdr_text;
	uint16_t	index_phdr_bss;
	uint16_t	index_shdr_last;

	index_shdr_bss = get_index_section_with_name(woody, ".bss");
	if (index_shdr_bss == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: .bss section not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	read_section_header(woody, index_shdr_bss, &shdr_bss);

	index_phdr_bss = get_index_segment_containing_section(woody, &shdr_bss);
	if (index_phdr_bss == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: .bss section not mapped (?)\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	read_program_header(woody, index_phdr_bss, &phdr_bss);

	index_shdr_last = get_index_last_shdr_in_phdr_bss(woody, index_shdr_bss, &phdr_bss);
	if (index_shdr_last == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: last section of phdr bss not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	read_section_header(woody, index_shdr_last, &shdr_last);

	if (shdr_last.sh_type == SHT_NOBITS)
		woody->new_section_and_padding_size = BYTECODE_SIZE + woody->key.length + shdr_last.sh_size;
	else
		woody->new_section_and_padding_size = BYTECODE_SIZE + woody->key.length;

	index_shdr_text = get_index_section_with_name(woody, ".text");
	if (index_shdr_text == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: .text section not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	read_section_header(woody, index_shdr_text, &shdr_text);
	// Check if old entrypoint + size .text are valid
	if (shdr_text.sh_offset + shdr_text.sh_size > (size_t)woody->bin_st.st_size) {
		dprintf(STDERR_FILENO, "%s: corrupted binary (wrong .text section size)\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	modify_shdr_last(woody, &shdr_last, index_shdr_last); // Must be done before fill_new_section

	fill_new_section(woody, &woody->new_section, &shdr_last);
	woody->new_entry = shdr_last.sh_addr + shdr_last.sh_size;

	modify_ehdr(woody);
	modify_phdr_bss(woody, &phdr_bss, index_phdr_bss);
	modify_phdr_text(woody, &shdr_text);
	modify_shdr_pushed_by_new_section(woody, index_shdr_last);

	xor_cipher(woody->key.raw, woody->key.length, woody->bin_map + shdr_text.sh_offset, shdr_text.sh_size);

	save_new_elf_file(woody, &shdr_last, index_shdr_last);
}

```

`srcs/elf_modify.c`:

```c
#include "woody_woodpacker.h"

void	modify_shdr_last(struct s_woody *woody, Elf64_Shdr *shdr_last, uint16_t index_shdr_last) {
	Elf64_Shdr shdr_prev_last;
	Elf64_Shdr *fptr_shdr_last;
	size_t shdr_last_offset;

	if (shdr_last->sh_type == SHT_NOBITS) {
		fptr_shdr_last = (Elf64_Shdr *)(woody->bin_map + woody->ehdr.e_shoff + woody->ehdr.e_shentsize * index_shdr_last);
		write_uint32(woody, &fptr_shdr_last->sh_type, SHT_PROGBITS);
		read_section_header(woody, index_shdr_last - 1, &shdr_prev_last);
		shdr_last_offset = shdr_prev_last.sh_offset + (shdr_last->sh_addr - shdr_prev_last.sh_addr);
		if (shdr_last_offset > shdr_last->sh_offset) {
			write_uint64(woody, &fptr_shdr_last->sh_offset, shdr_last_offset);
			woody->shdr_last_offset_adjustment = shdr_last_offset - shdr_last->sh_offset;
			shdr_last->sh_offset = shdr_last_offset;
		}
		else
			woody->shdr_last_offset_adjustment = 0;
	}
	else
		woody->shdr_last_offset_adjustment = 0;
}

void	modify_ehdr(struct s_woody *woody) {
	Elf64_Ehdr	*fptr_ehdr;

	fptr_ehdr = (Elf64_Ehdr *)woody->bin_map;
	write_uint16(woody, &fptr_ehdr->e_shnum, woody->ehdr.e_shnum + 1);
	write_uint64(woody, &fptr_ehdr->e_shoff, woody->ehdr.e_shoff + woody->new_section_and_padding_size + woody->shdr_last_offset_adjustment);
	write_uint16(woody, &fptr_ehdr->e_shstrndx, woody->ehdr.e_shstrndx + 1);
	write_uint64(woody, &fptr_ehdr->e_entry, woody->new_entry);
}

void	modify_phdr_bss(struct s_woody *woody, Elf64_Phdr *phdr_bss, uint16_t index_phdr_bss) {
	Elf64_Phdr	*fptr_phdr_bss;

	fptr_phdr_bss = (Elf64_Phdr *)(woody->bin_map + woody->ehdr.e_phoff + woody->ehdr.e_phentsize * index_phdr_bss);
	write_uint64(woody, &fptr_phdr_bss->p_filesz, phdr_bss->p_filesz + woody->new_section_and_padding_size + woody->shdr_last_offset_adjustment);
	write_uint64(woody, &fptr_phdr_bss->p_memsz, phdr_bss->p_memsz + BYTECODE_SIZE + woody->key.length);
	write_uint32(woody, &fptr_phdr_bss->p_flags, PF_R | PF_W | PF_X);
}

void	modify_phdr_text(struct s_woody *woody, Elf64_Shdr *shdr_text) {
	Elf64_Phdr	*fptr_phdr_text;
	uint16_t	index_phdr_text;

	index_phdr_text = get_index_segment_containing_section(woody, shdr_text);
	if (index_phdr_text == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: .bss section not mapped (?)\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	fptr_phdr_text = (Elf64_Phdr *)(woody->bin_map + woody->ehdr.e_phoff + woody->ehdr.e_phentsize * index_phdr_text);
	write_uint32(woody, &fptr_phdr_text->p_flags, PF_R | PF_W | PF_X);
}

void	modify_shdr_pushed_by_new_section(struct s_woody *woody, uint16_t index_shdr_last) {
	Elf64_Shdr tmp;
	Elf64_Shdr *fptr_shdr_tmp;

	for (uint16_t index = index_shdr_last + 1; index < woody->ehdr.e_shnum; index++) {
		read_section_header(woody, index, &tmp);
		if (tmp.sh_type == SHT_NOBITS)
			continue ;
		fptr_shdr_tmp = (Elf64_Shdr *)(woody->bin_map + woody->ehdr.e_shoff + woody->ehdr.e_shentsize * index);
		if (tmp.sh_type == SHT_SYMTAB) {
			write_uint32(woody, &fptr_shdr_tmp->sh_link, tmp.sh_link + 1);
		}
		write_uint64(woody, &fptr_shdr_tmp->sh_offset, tmp.sh_offset + woody->new_section_and_padding_size + woody->shdr_last_offset_adjustment);
	}
}

```

`srcs/elf_read.c`:

```c
#include "woody_woodpacker.h"

void	read_elf_header(struct s_woody *woody) {
	if ((size_t)woody->bin_st.st_size < sizeof(Elf64_Ehdr)) {
		dprintf(STDERR_FILENO, "%s: not an ELF file (file too small to contain ELF header)\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	woody->ehdr = *(Elf64_Ehdr *)woody->bin_map;

	if (*(uint32_t *)woody->ehdr.e_ident != *(uint32_t *)ELFMAG) {
		dprintf(STDERR_FILENO, "%s: not an ELF file (wrong magic number)\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	if (woody->ehdr.e_ident[EI_CLASS] != ELFCLASS64) {
		dprintf(STDERR_FILENO, "%s: ELF Class not supported\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	if (woody->ehdr.e_ident[EI_DATA] == ELFDATA2MSB) {
		#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			woody->reverse_endian = true;
		#else
			woody->reverse_endian = false;
		#endif
	}
	else if (woody->ehdr.e_ident[EI_DATA] == ELFDATA2LSB) {
		#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			woody->reverse_endian = true;
		#else
			woody->reverse_endian = false;
		#endif
	}
	else {
		woody->reverse_endian = false;
	}

	if (woody->ehdr.e_type != ET_EXEC && woody->ehdr.e_type != ET_DYN) {
		dprintf(STDERR_FILENO, "%s: wrong ELF type\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}

	if (woody->reverse_endian) {
		woody->ehdr.e_type 	=  BSWAP16(woody->ehdr.e_type);
		woody->ehdr.e_machine 	=  BSWAP16(woody->ehdr.e_machine);
		woody->ehdr.e_version 	=  BSWAP32(woody->ehdr.e_version);
		woody->ehdr.e_entry 	=  BSWAP64(woody->ehdr.e_entry);
		woody->ehdr.e_phoff 	=  BSWAP64(woody->ehdr.e_phoff);
		woody->ehdr.e_shoff 	=  BSWAP64(woody->ehdr.e_shoff);
		woody->ehdr.e_flags 	=  BSWAP32(woody->ehdr.e_flags);
		woody->ehdr.e_ehsize 	=  BSWAP16(woody->ehdr.e_ehsize);
		woody->ehdr.e_phentsize =  BSWAP16(woody->ehdr.e_phentsize);
		woody->ehdr.e_phnum 	=  BSWAP16(woody->ehdr.e_phnum);
		woody->ehdr.e_shentsize =  BSWAP16(woody->ehdr.e_shentsize);
		woody->ehdr.e_shnum 	=  BSWAP16(woody->ehdr.e_shnum);
		woody->ehdr.e_shstrndx 	=  BSWAP16(woody->ehdr.e_shstrndx);
	}
}

void	read_program_header(struct s_woody *woody, uint16_t index, Elf64_Phdr *phdr) {
	if (index >= woody->ehdr.e_phentsize) {
		dprintf(STDERR_FILENO, "%s: wrong index of phdr\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*phdr = *(Elf64_Phdr *)(woody->bin_map + woody->ehdr.e_phoff + woody->ehdr.e_phentsize * index);
	if (woody->reverse_endian) {
		phdr->p_type	= BSWAP32(phdr->p_type);
		phdr->p_flags	= BSWAP32(phdr->p_flags);
		phdr->p_offset	= BSWAP64(phdr->p_offset);
		phdr->p_vaddr	= BSWAP64(phdr->p_vaddr);
		phdr->p_paddr	= BSWAP64(phdr->p_paddr);
		phdr->p_filesz	= BSWAP64(phdr->p_filesz);
		phdr->p_memsz	= BSWAP64(phdr->p_memsz);
		phdr->p_align	= BSWAP64(phdr->p_align);
	}
}

void	read_section_header(struct s_woody *woody, uint16_t index, Elf64_Shdr *shdr) {
	if (index >= woody->ehdr.e_shentsize) {
		dprintf(STDERR_FILENO, "%s: wrong index of shdr\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*shdr = *(Elf64_Shdr *)(woody->bin_map + woody->ehdr.e_shoff + woody->ehdr.e_shentsize * index);
	if (woody->reverse_endian) {
		shdr->sh_name		= BSWAP32(shdr->sh_name);
		shdr->sh_type		= BSWAP32(shdr->sh_type);
		shdr->sh_flags		= BSWAP64(shdr->sh_flags);
		shdr->sh_addr		= BSWAP64(shdr->sh_addr);
		shdr->sh_offset		= BSWAP64(shdr->sh_offset);
		shdr->sh_size		= BSWAP64(shdr->sh_size);
		shdr->sh_link		= BSWAP32(shdr->sh_link);
		shdr->sh_info		= BSWAP32(shdr->sh_info);
		shdr->sh_addralign	= BSWAP64(shdr->sh_addralign);
		shdr->sh_entsize	= BSWAP64(shdr->sh_entsize);
	}
}

```

`srcs/elf_save.c`:

```c
#include "woody_woodpacker.h"

static void *find_pattern32(void *addr, size_t size, uint32_t pattern, uint8_t opcode_size) {
	for (size_t i = 0; i < size - sizeof(pattern); i++) {
		if (*(uint32_t *)(addr + i) == pattern)
			return (addr + i + opcode_size);
	}
	return (NULL);
}

static	void *find_pattern64(void *addr, size_t size, uint64_t pattern, uint8_t opcode_size) {
	for (size_t i = 0; i < size - sizeof(pattern); i++) {
		if (*(uint64_t *)(addr + i) == pattern)
			return (addr + i + opcode_size);
	}
	return (NULL);
}

void	save_new_section(struct s_woody *woody, int new_bin_fd, Elf64_Shdr *shdr_last) {
	static char bytecode[] = BYTECODE;

	// Padding for BSS section
	if (shdr_last->sh_type == SHT_NOBITS) {
		size_t size_to_write = shdr_last->sh_size + woody->shdr_last_offset_adjustment;
		char padding_zero[4096];
		ft_memset(padding_zero, 0, sizeof(padding_zero));
		while (true) {
			if (size_to_write / sizeof(padding_zero) < 1) {
				if (write(new_bin_fd, padding_zero, size_to_write) == -1) {
					ERROR("write");
					exit_clean(woody, EXIT_FAILURE);
				}
				break ;
			}
			if (write(new_bin_fd, padding_zero, sizeof(padding_zero)) == -1) {
				ERROR("write");
				exit_clean(woody, EXIT_FAILURE);
			}
			size_to_write -= sizeof(padding_zero);
		}
	}

	void *addr_pattern;
	// Write old entry
	addr_pattern = find_pattern32((void *)bytecode, BYTECODE_SIZE, PATTERN_ENTRY_OLD, PATTERN_ENTRY_OLD_SIZE_OPCODE);
	if (!addr_pattern) {
		dprintf(STDERR_FILENO, "%s: old entry pattern not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*(int32_t *)addr_pattern = woody->ehdr.e_entry - (woody->new_entry  + (size_t)(addr_pattern - (void *)bytecode) + sizeof(PATTERN_ENTRY_OLD));

	// Write key size
	addr_pattern = find_pattern64((void *)bytecode, BYTECODE_SIZE, PATTERN_KEY_SIZE, PATTERN_KEY_SIZE_OPCODE);
	if (!addr_pattern) {
		dprintf(STDERR_FILENO, "%s: key size pattern not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*(uint64_t *)addr_pattern = woody->key.length;


	// Write text section size
	Elf64_Shdr	shdr_text;
	uint16_t	index_shdr_text;
	index_shdr_text = get_index_section_with_name(woody, ".text");
	if (index_shdr_text == (uint16_t)-1) {
		dprintf(STDERR_FILENO, "%s: .text section not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	read_section_header(woody, index_shdr_text, &shdr_text);
	addr_pattern = find_pattern64((void *)bytecode, BYTECODE_SIZE, PATTERN_TEXT_SIZE, PATTERN_TEXT_SIZE_OPCODE);
	if (!addr_pattern) {
		dprintf(STDERR_FILENO, "%s: .text size pattern not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*(uint64_t *)addr_pattern = shdr_text.sh_size;

	// Write text entry
	addr_pattern = find_pattern32((void *)bytecode, BYTECODE_SIZE, PATTERN_ENTRY_TEXT, PATTERN_ENTRY_TEXT_SIZE_OPCODE);
	if (!addr_pattern) {
		dprintf(STDERR_FILENO, "%s: .text entry pattern not found\n", woody->woody_name);
		exit_clean(woody, EXIT_FAILURE);
	}
	*(int32_t *)addr_pattern = shdr_text.sh_addr - (woody->new_section.sh_addr + (size_t)(addr_pattern - (void *)bytecode) + sizeof(PATTERN_ENTRY_OLD));


	// Write instructions
	if (write(new_bin_fd, bytecode, BYTECODE_SIZE) == -1) {
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}

	// Write key
	if (write(new_bin_fd, woody->key.raw, woody->key.length) == -1) {
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}
}

void	save_new_shdr(struct s_woody *woody, int new_bin_fd, Elf64_Shdr *new_section) {
	write_uint32(woody, &new_section->sh_type, new_section->sh_type);
	write_uint64(woody, &new_section->sh_flags, new_section->sh_flags);
	write_uint64(woody, &new_section->sh_addr, new_section->sh_addr);
	write_uint64(woody, &new_section->sh_offset, new_section->sh_offset);
	write_uint64(woody, &new_section->sh_size, new_section->sh_size);
	write_uint64(woody, &new_section->sh_addralign, new_section->sh_addralign);

	if (write(new_bin_fd, new_section, sizeof(Elf64_Shdr)) == -1) {
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}
}

void	save_new_elf_file(struct s_woody *woody, Elf64_Shdr *shdr_last, uint16_t index_shdr_last) {
	int	new_bin_fd;
	size_t	written_map_bytes = 0;

	new_bin_fd = open(NEW_BIN_FILENAME, O_WRONLY | O_CREAT | O_TRUNC, woody->bin_st.st_mode);
	if (new_bin_fd == -1) {
		ERROR("open");
		exit_clean(woody, EXIT_FAILURE);
	}

	size_t size_to_write_before_decrypter = shdr_last->sh_offset - woody->shdr_last_offset_adjustment + (shdr_last->sh_type != SHT_NOBITS ? shdr_last->sh_size : 0);
	if (write(new_bin_fd, woody->bin_map, size_to_write_before_decrypter) == -1) { // FIRST PART
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}
	written_map_bytes += size_to_write_before_decrypter;
	save_new_section(woody, new_bin_fd, shdr_last); // Write new section + .bss padding
	size_t size_to_write_before_new_shdr = (woody->ehdr.e_shoff + woody->ehdr.e_shentsize * (index_shdr_last + 1)) - written_map_bytes;
	if (write(new_bin_fd, woody->bin_map + written_map_bytes, size_to_write_before_new_shdr) == -1) { // SECOND PART
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}
	written_map_bytes += size_to_write_before_new_shdr;
	save_new_shdr(woody, new_bin_fd, &woody->new_section); // Write new shdr
	if (write(new_bin_fd, woody->bin_map + written_map_bytes, woody->bin_st.st_size - written_map_bytes) == -1) { // THIRD PART
		ERROR("write");
		exit_clean(woody, EXIT_FAILURE);
	}
}


/*

+---------------+	<-------+
|      EHDR	|		|
+---------------+		|
|		|		|
|     PHDR_1 	|		|
|     PHDR_2 	|		|----	First part of bin_map
|     PHDR_N 	|		|
|		|		|
+---------------+		|
|		|		|
|    SECTION_1	|		|
|   SECTION_BSS	|	<-------+
|   NEW_SECTION	|	<-------+----	Write new section + .bss padding
|    SECTION_N	|		|
|		|		|
+---------------+		|----	Second part of bin_map
|		|		|
|     SHDR_1 	|		|
|    SHDR_BSS 	|		|
|    NEW_SHDR	|	<-------+----	Write new shdr
|     SHDR_N 	|		|
|		|		|----	Third part of bin_map
+---------------+	<-------+

*/

```

`srcs/elf_write.c`:

```c
#include "woody_woodpacker.h"

void	write_uint16(struct s_woody *woody, uint16_t *addr, uint16_t value) {
	if (woody->reverse_endian)
		*addr = BSWAP16(value);
	else
		*addr = value;
}

void	write_uint32(struct s_woody *woody, uint32_t *addr, uint32_t value) {
	if (woody->reverse_endian)
		*addr = BSWAP32(value);
	else
		*addr = value;
}

void	write_uint64(struct s_woody *woody, uint64_t *addr, uint64_t value) {
	if (woody->reverse_endian)
		*addr = BSWAP64(value);
	else
		*addr = value;
}

```

`srcs/woody_woodpacker.c`:

```c
#include "woody_woodpacker.h"

void	exit_clean(struct s_woody *woody, int exit_status) {
	close(woody->bin_fd);
	if (woody->key.raw != NULL)
		free(woody->key.raw);
	if (munmap(woody->bin_map, woody->bin_st.st_size) == -1)
		ERROR("munmap");
	exit(exit_status);
}

bool	map_file(char *elf_filename, struct s_woody *woody) {
	if ((woody->bin_fd = open(elf_filename, O_RDONLY)) == -1) {
		ERROR("open");
		return (false);
	}

	if (syscall(__NR_fstat, woody->bin_fd, &woody->bin_st) == -1) {
		ERROR("fstat");
		close(woody->bin_fd);
		return (false);
	}

	if ((woody->bin_map = mmap(NULL, woody->bin_st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, woody->bin_fd, 0)) == MAP_FAILED) {
		ERROR("mmap");
		close(woody->bin_fd);
		return (false);
	}
	return (true);
}

void	gen_random_key(struct s_woody *woody, struct s_key *key) {
	long key_length;

	if ((key_length = syscall(__NR_getrandom, key->raw, KEY_DEFAULT_SIZE, 0)) <= -1) {
		ERROR("getrandom");
		exit_clean(woody, EXIT_FAILURE);
	}
	key->length = (size_t)key_length;
	printf("Key value: ");
	for (ssize_t i = 0; i < key_length; i++) {
		printf("%02hhX", key->raw[i]);
	}
	printf("\n");
}

int	main(int ac, char **av)
{
	struct s_woody	woody;

	if (ac < 2 || ac > 3) {
		printf(USAGE, av[0]);
		return (EXIT_FAILURE);
	}

	woody.key.raw = NULL;
	woody.woody_name = av[0];

	if (!map_file(av[1], &woody))
		return (EXIT_FAILURE);
	read_elf_header(&woody);
	check_headers_offset(&woody);
	get_shstrtab(&woody);

	if (ac == 2) {
		woody.key.raw = malloc(KEY_DEFAULT_SIZE);
		gen_random_key(&woody, &woody.key);
	}
	else {
		woody.key.raw = ft_strdup(av[2]);
		woody.key.length = ft_strlen(av[2]);
	}

	insert_section_after_bss(&woody);
	// debug_print_headers(&woody);

	exit_clean(&woody, EXIT_SUCCESS);
}

```

`tests/exec_all.sh`:

```sh
#!/bin/bash

SCRIPT=`realpath $0`
SCRIPT_PATH=`dirname $SCRIPT`

LOG=$SCRIPT_PATH/exec_all.log
rm -rf $LOG
touch $LOG

TMP_DIR=$(mktemp -d)

cd $TMP

timeout_sec="$1"
if [ -z "$1" ] ; then
	timeout_sec="1"
fi

for entry in /bin/* /sbin/* /usr/bin/*
do
	# Removing programs which stop script
	if [[ "$entry" = "/bin/pidof" \
	|| "$entry" = "/usr/bin/yes" \
	|| "$entry" = "/sbin/killall5" ]] ; then
		continue
	fi
	printf "\n------------------> $entry\n"
	$SCRIPT_PATH/../woody_woodpacker $entry 2>&1 > /dev/null
	if [ $? -eq 0 ] ; then
		script -q -f -c "bash -c \"timeout --foreground --signal=SIGKILL $timeout_sec ./woody 0>&-\"" -a $LOG | grep -v 'Script done' | grep -v 'Script started'
	fi
done

rm -rf $TMP_DIR

exit 0

```

`tests/loop_woody.sh`:

```sh
#!/bin/bash

if [ ! $# -eq 2 ] ; then
	echo "Usage: $0 elf_binary number_of_iteration"
	exit 1
fi

if [ "$2" -lt 1 ] ; then
	echo "Wrong number of iteration"
	exit 1
fi

SCRIPT=`realpath $0`
SCRIPT_PATH=`dirname $SCRIPT`

cd $SCRIPT_PATH/..

TMP_WOODY=$(mktemp)
cp $1 $TMP_WOODY

i=1
while [ "$i" -le "$2" ]; do
	./woody_woodpacker $TMP_WOODY 2>&1 > /dev/null
	mv ./woody $TMP_WOODY
	i=$(($i + 1))
done

read -p "Execute woody ? [Y/n]" -n 1 -r
if [[ $REPLY =~ ^[Yy]$ || -z $REPLY ]] ; then
	$TMP_WOODY
fi

echo

mv $TMP_WOODY ./woody

exit 0

```