Project Path: arc_gmh5225_fastDbg_vf2cuh5k

Source Tree:

```txt
arc_gmh5225_fastDbg_vf2cuh5k
├── README.md
├── bp.go
├── build.sh
├── cmd.go
├── common.go
├── dbg.go
├── dbgInterface.go
├── disass.go
├── docs
│   └── commands.md
├── dump.go
├── ebpf
│   ├── ebpf.go
│   └── trace.ebpf.c
├── go.mod
├── go.sum
├── main.go
├── mem.go
├── ptrace.go
├── qemu
│   ├── cmd.go
│   ├── disass.go
│   ├── exprEval.go
│   ├── qemu.go
│   └── symResolve.go
├── regs.go
├── simd.go
├── sym.go
├── symResolver.go
├── ui.go
├── utils.go
└── wp.go

```

`README.md`:

```md
# fastDbg - super fast x64 elf debugger with golang -

Author: github.com/Yayoi-cs (tsune)

## Install

```bash
$ git clone https://github.com/Yayoi-cs/fastDbg.git
$ cd fastDbg
$ git clone https://github.com/capstone-engine/capstone.git
# Build capstone at first
$ go build
```

## Run

sudo is required for attaching

```bash
[~/GolandProjects/fastDbg]$./fastDbg 
      ___           ___           ___           ___           ___           ___           ___
     /\  \         /\  \         /\  \         /\  \         /\  \         /\  \         /\  \
    /::\  \       /::\  \       /::\  \        \:\  \       /::\  \       /::\  \       /::\  \
   /:/\:\  \     /:/\:\  \     /:/\ \  \        \:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \
  /::\~\:\  \   /::\~\:\  \   _\:\~\ \  \       /::\  \   /:/  \:\__\   /::\~\:\__\   /:/  \:\  \
 /:/\:\ \:\__\ /:/\:\ \:\__\ /\ \:\ \ \__\     /:/\:\__\ /:/__/ \:|__| /:/\:\ \:|__| /:/__/_\:\__\
 \/__\:\ \/__/ \/__\:\/:/  / \:\ \:\ \/__/    /:/  \/__/ \:\  \ /:/  / \:\~\:\/:/  / \:\  /\ \/__/
      \:\__\        \::/  /   \:\ \:\__\     /:/  /       \:\  /:/  /   \:\ \::/  /   \:\ \:\__\
       \/__/        /:/  /     \:\/:/  /     \/__/         \:\/:/  /     \:\/:/  /     \:\/:/  /
                   /:/  /       \::/  /                     \::/__/       \::/__/       \::/  /
                   \/__/         \/__/                       ~~            ~~            \/__/
Invalid arguments
Usage: ./fastDbg [OPTIONS] <file>

Options:
  -f string
        filename
  -p int
        process id
```

## Commands


```

`bp.go`:

```go
package main

import (
	"encoding/binary"
	"errors"
	"golang.org/x/sys/unix"
)

type TypeBp struct {
	pid      int
	addr     uintptr
	instr    []byte
	isEnable bool
}

var Bps []TypeBp

func (dbger *TypeDbg) NewBp(bpAddr uintptr, pid int) (*TypeBp, error) {
	bp := &TypeBp{
		pid:   pid,
		addr:  bpAddr,
		instr: make([]byte, 8),
	}
	if err := bp.enableBp(dbger); err != nil {
		return nil, err
	}
	Bps = append(Bps, *bp)
	Printf("breakpoint %d added at %x\n", len(Bps)-1, bpAddr)
	return bp, nil
}

func (dbger *TypeDbg) EnableBp(idx int) error {
	if len(Bps) <= idx {
		return errors.New("invalid index")
	}
	if Bps[idx].isEnable {
		return errors.New("already enabled")
	}
	err := Bps[idx].enableBp(dbger)
	if err != nil {
		return err
	}
	Printf("breakpoint %d enabled at %x\n", idx, Bps[idx].addr)
	return nil
}

func (dbger *TypeDbg) DisableBp(idx int) error {
	if len(Bps) <= idx {
		return errors.New("invalid index")
	}
	if !Bps[idx].isEnable {
		return errors.New("already disabled")
	}
	err := Bps[idx].disableBp(dbger)
	if err != nil {
		return err
	}
	Printf("breakpoint %d disabled at %x\n", idx, Bps[idx].addr)
	return nil
}

func (bp *TypeBp) enableBp(dbger *TypeDbg) error {
	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	var origInstr uint64
	var err error

	err = doSyscallErr(dbger.rpc, func() error {
		allZero := true
		for _, b := range bp.instr {
			if b != 0 {
				allZero = false
				break
			}
		}

		if allZero {
			_, err := unix.PtracePeekData(bp.pid, bp.addr, bp.instr)
			if err != nil {
				return err
			}
		}

		origInstr = binary.LittleEndian.Uint64(bp.instr)
		int3Instr := (origInstr & ^uint64(0xff)) | 0xcc
		int3InstrLittle := make([]byte, 8)
		binary.LittleEndian.PutUint64(int3InstrLittle, int3Instr)

		_, err := unix.PtracePokeData(bp.pid, bp.addr, int3InstrLittle)
		return err
	})

	if err != nil {
		if err == unix.ESRCH {
			return errors.New("process does not exist or exited")
		}
		return err
	}

	bp.isEnable = true
	return nil
}

func (bp *TypeBp) disableBp(dbger *TypeDbg) error {
	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	var err error

	err = doSyscallErr(dbger.rpc, func() error {
		_, err = unix.PtracePokeData(bp.pid, bp.addr, bp.instr)
		return err
	})

	if err != nil {
		if err == unix.ESRCH {
			return errors.New("process does not exist or exited")
		}
		return err
	}

	bp.isEnable = false
	return nil
}

```

`build.sh`:

```sh
clang -O2 -g -target bpf \
    -D__TARGET_ARCH_x86 \
    -I/usr/include/x86_64-linux-gnu \
    -c ebpf/trace.ebpf.c -o trace.ebpf.o
go build .
sudo setcap cap_sys_admin,cap_bpf,cap_perfmon,cap_net_admin+eip fastDbg

```

`cmd.go`:

```go
package main

import (
	"encoding/binary"
	"errors"
	"fastDbg/ebpf"
	"fmt"
	"golang.org/x/sys/unix"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
)

type cmdHandler struct {
	regex *regexp.Regexp
	fn    func(*TypeDbg, interface{}) error
}

var compiledCmds = []cmdHandler{
	{regexp.MustCompile(`^\s*(b|break|B|BREAK)\s+(l|list|L|LIST)\s*$`), (*TypeDbg).cmdBreakList},
	{regexp.MustCompile(`^\s*(b|break|B|BREAK)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdBreak},
	{regexp.MustCompile(`^\s*(b|break|B|BREAK)\s+(pie|PIE)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdBreakPie},
	{regexp.MustCompile(`^\s*(enable)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdEnable},
	{regexp.MustCompile(`^\s*(disable)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdDisable},
	{regexp.MustCompile(`^\s*(wp)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdWp},
	{regexp.MustCompile(`^\s*(wp d)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdWpDel},
	{regexp.MustCompile(`^\s*(disass)(\s+(0[xx][0-9a-fa-f]+|0[0-7]+|[1-9][0-9]*|0))?(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdDisass},
	{regexp.MustCompile(`^\s*(stackframe|stkf|STACKFRAME|STKF)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdStackFrame},
	{regexp.MustCompile(`^\s*(p|print|P|PRINT)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdPrint},
	{regexp.MustCompile(`^\s*(r|run|R|RUN)(?:\s+(.+))?$`), (*TypeDbg).cmdRun},
	{regexp.MustCompile(`^\s*(s|start|S|START)(?:\s+(.+))?$`), (*TypeDbg).cmdStart},
	{regexp.MustCompile(`^\s*(regs)(?:\s+(.+))?$`), (*TypeDbg).cmdRegs},
	{regexp.MustCompile(`^\s*(!)(.+)$`), (*TypeDbg).cmdCmd},
	{regexp.MustCompile(`^\s*(c|continue|cont|C|CONTINUE|CONT)\s*$`), (*TypeDbg).cmdContinue},
	{regexp.MustCompile(`^\s*(step|STEP)\s*$`), (*TypeDbg).cmdStep},
	{regexp.MustCompile(`^\s*(context|CONTEXT)\s*$`), (*TypeDbg).cmdContext},
	{regexp.MustCompile(`^\s*(color|COLOR)\s*$`), (*TypeDbg).cmdColor},
	{regexp.MustCompile(`^\s*(wp list)\s*$`), (*TypeDbg).cmdWpList},
	{regexp.MustCompile(`^\s*(stack|stk|STACK|STK)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdStack},
	{regexp.MustCompile(`^\s*(vmmap|VMMAP)(\s+\w+)*\s*$`), (*TypeDbg).cmdVmmap},
	{regexp.MustCompile(`^\s*(sym|symbol|SYM|SYMBOL)(\s+\w+)*\s*$`), (*TypeDbg).cmdSym},
	{regexp.MustCompile(`^\s*(got|GOT)\s*$`), (*TypeDbg).cmdGot},
	{regexp.MustCompile(`^\s*(bins|BINS)\s*$`), (*TypeDbg).cmdBins},
	{regexp.MustCompile(`^\s*(fs|fs_base)\s*$`), (*TypeDbg).cmdFs},
	{regexp.MustCompile(`^\s*(vis|visual-heap|VIS|VISUAL-HEAP)\s*$`), (*TypeDbg).cmdVisualHeap},
	{regexp.MustCompile(`^\s*(set32)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdSet32},
	{regexp.MustCompile(`^\s*(set16)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdSet16},
	{regexp.MustCompile(`^\s*(set8)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdSet8},
	{regexp.MustCompile(`^\s*(set)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdSet},
	{regexp.MustCompile(`^\s*(xor)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*TypeDbg).cmdXor},
	{regexp.MustCompile(`^\s*(tel|telescope)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdTelescope},
	{regexp.MustCompile(`^\s*(db|xxd)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdDumpByte},
	{regexp.MustCompile(`^\s*(dd|xxd\s+dword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdDumpDword},
	{regexp.MustCompile(`^\s*(dq|xxd\s+qword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdDumpQword},
	{regexp.MustCompile(`^\s*(bt|backtrace|BT|BACKTRACE)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*TypeDbg).cmdBacktrace},
	{regexp.MustCompile(`^\s*(simd|xmm|ymm|SIMD|XMM|YMM)\s*$`), (*TypeDbg).cmdSIMD},
}

func (dbger *TypeDbg) cmdExec(req string) error {
	for _, handler := range compiledCmds {
		if m := handler.regex.FindStringSubmatch(req); m != nil {
			return handler.fn(dbger, m)
		}
	}
	return errors.New("unknown command")
}

var tmpBps []uintptr
var tmpPieBps []uintptr

func (dbger *TypeDbg) cmdBreak(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	if !dbger.isStart {
		tmpBps = append(tmpBps, uintptr(addr))
		fmt.Printf("booked breakpoint %s%d%s @ %s0x%016x%s\n", ColorCyan, len(tmpBps), ColorReset, ColorCyan, addr, ColorReset)
		return nil
	}

	_, err = dbger.NewBp(uintptr(addr), dbger.pid)
	if err != nil {
		return err
	} else {
		fmt.Printf("new breakpoint at %s0x%016x%s\n", ColorCyan, addr, ColorReset)
		return nil
	}
}

func (dbger *TypeDbg) cmdBreakPie(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	offset, err := strconv.ParseUint(args[3], 0, 64)
	if err != nil {
		return err
	}

	if !dbger.isStart {
		// Store only the offset, not the absolute address
		tmpPieBps = append(tmpPieBps, uintptr(offset))
		fmt.Printf("booked PIE breakpoint %s%d%s @ offset %s0x%016x%s\n", ColorCyan, len(tmpPieBps), ColorReset, ColorCyan, offset, ColorReset)
		return nil
	}

	// When process is running, calculate absolute address
	absAddr := offset + libRoots[0].base
	_, err = dbger.NewBp(uintptr(absAddr), dbger.pid)
	if err != nil {
		return err
	} else {
		fmt.Printf("new breakpoint at %s0x%016x%s (PIE base + 0x%x)\n", ColorCyan, absAddr, ColorReset, offset)
		return nil
	}
}

func (dbger *TypeDbg) cmdEnable(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	off, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	err = dbger.EnableBp(int(off))
	return err
}

func (dbger *TypeDbg) cmdDisable(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	off, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	err = dbger.DisableBp(int(off))
	return err
}

func (dbger *TypeDbg) cmdBreakList(_ interface{}) error {
	if len(Bps) == 0 && len(tmpBps) == 0 && len(tmpPieBps) == 0 {
		fmt.Printf("No breakpoints set.\n")
		return nil
	}

	if len(tmpBps) > 0 || len(tmpPieBps) > 0 {
		hLine("booked breakpoints (will be set on start)")
		for i, addr := range tmpBps {
			fmt.Printf("[booked %d] %s0x%016x%s (absolute)\n", i, ColorCyan, addr, ColorReset)
		}
		for i, addr := range tmpPieBps {
			fmt.Printf("[booked %d] %s0x%016x%s (PIE relative)\n", i+len(tmpBps), ColorCyan, addr, ColorReset)
		}
	}

	if len(Bps) > 0 {
		if len(tmpBps) > 0 || len(tmpPieBps) > 0 {
			hLine("active breakpoints")
		}
		for i, bp := range Bps {
			status := "enabled"
			statusColor := ColorCyan
			if !bp.isEnable {
				status = "disabled"
				statusColor = ColorRed
			}

			disasm := ""
			if dbger.isStart && dbger.isProcessAlive() {
				disasmStr, err := dbger.DisassOne(bp.addr)
				if err == nil && disasmStr != nil {
					disasm = fmt.Sprintf(" -> %s", *disasmStr)
				}
			}

			symbol := ""
			if dbger.isStart {
				sym, offset, err := dbger.ResolveAddrToSymbol(uint64(bp.addr))
				if err == nil && sym != nil {
					if offset == 0 {
						symbol = fmt.Sprintf(" <%s>", sym.Name)
					} else {
						symbol = fmt.Sprintf(" <%s+%d>", sym.Name, offset)
					}
				}
			}

			fmt.Printf("[%d] %s0x%016x%s %s%s%s%s%s\n",
				i, ColorCyan, bp.addr, ColorReset,
				statusColor, status, ColorReset,
				symbol, disasm)
		}
	}

	return nil
}

func (dbger *TypeDbg) cmdPrint(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	val, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	fmt.Printf("HEX: %s0x%x%s DEC: %s%d%s OCT: %s%o%s BIN: %s%b%s\n", ColorCyan, val, ColorReset, ColorCyan, val, ColorReset, ColorCyan, val, ColorReset, ColorCyan, val, ColorReset)

	return err
}

func (dbger *TypeDbg) cmdRun(a interface{}) error {
	err := dbger.cmdStart(a)
	if err != nil {
		return err
	}

	err = dbger.Continue()
	if err != nil {
		return err
	}

	ws, err := dbger.wait()
	if err != nil {
		return err
	}
	if !ws.Exited() {
		cls()
		dbger.cmdContext(nil)
	}

	return nil
}

func (dbger *TypeDbg) cmdStart(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	var savedPieBps []uintptr
	if dbger.isStart && dbger.pid > 0 {
		if len(libRoots) > 0 && libRoots[0].base != 0 {
			for _, bp := range Bps {
				offset := uintptr(bp.addr) - uintptr(libRoots[0].base)
				savedPieBps = append(savedPieBps, offset)
			}
		}

		Printf("Killing previous process (PID:%d)...\n", dbger.pid)
		err := dbger.Kill()
		if err != nil {
			return fmt.Errorf("failed to kill previous process: %v", err)
		}

		tmpBps = []uintptr{}
	}

	Bps = []TypeBp{}

	tmpDbger, err := Run(dbger.path, args[2:]...)
	if err != nil {
		return err
	}
	mainDbger = *tmpDbger

	dbger.Reload()

	err = dbger.loadBase()
	if err != nil {
		return fmt.Errorf("failed to reload base: %v", err)
	}

	ebpf.NewTrace(dbger.pid)

	for _, addr := range tmpBps {
		_, err = dbger.NewBp(addr, dbger.pid)
		if err != nil {
			return err
		}
	}

	if len(libRoots) > 0 {
		for _, offset := range tmpPieBps {
			_, err = dbger.NewBp(uintptr(libRoots[0].base)+offset, dbger.pid)
			if err != nil {
				return err
			}
		}

		for _, offset := range savedPieBps {
			_, err = dbger.NewBp(uintptr(libRoots[0].base)+offset, dbger.pid)
			if err != nil {
				return err
			}
		}
	}

	if a != nil {
		cls()
		dbger.cmdContext(nil)
	}

	resolvedN = 0
	return nil
}

func (dbger *TypeDbg) cmdContinue(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}

	select {
	case <-interruptFlag:
	default:
	}

	err := dbger.Continue()
	if err != nil {
		return err
	}

	type waitResult struct {
		ws  unix.WaitStatus
		err error
	}
	waitCh := make(chan waitResult, 1)

	go func() {
		ws, err := dbger.wait()
		waitCh <- waitResult{ws, err}
	}()

	var ws unix.WaitStatus
	interrupted := false

	select {
	case result := <-waitCh:
		if result.err != nil {
			return result.err
		}
		ws = result.ws
		select {
		case <-interruptFlag:
			interrupted = true
		default:
		}
	case <-interruptFlag:
		interrupted = true
		result := <-waitCh
		if result.err != nil {
			return result.err
		}
		ws = result.ws
	}

	if ws.Exited() {
		return nil
	}

	cls()
	dbger.cmdContext(nil)

	if interrupted {
	}

	return nil
}

func (dbger *TypeDbg) cmdContext(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	dbger.Reload()
	if ebpf.MapFlag {
		dbger.loadBase()
		ebpf.MapFlag = false
	}

	hLine("registers")

	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	var regs *unix.PtraceRegs
	var err error

	regs, err = dbger.getRegs()
	if err != nil {
		return err
	}

	if regs == nil {
		return errors.New("nil registers")
	}

	rip, err := dbger.GetRip()
	if err != nil {
		return err
	}

	fmt.Printf("$rax   : %s0x%016x%s\n", dbger.addr2color(regs.Rax), regs.Rax, dbger.addr2some(regs.Rax))
	fmt.Printf("$rbx   : %s0x%016x%s\n", dbger.addr2color(regs.Rbx), regs.Rbx, dbger.addr2some(regs.Rbx))
	fmt.Printf("$rcx   : %s0x%016x%s\n", dbger.addr2color(regs.Rcx), regs.Rcx, dbger.addr2some(regs.Rcx))
	fmt.Printf("$rdx   : %s0x%016x%s\n", dbger.addr2color(regs.Rdx), regs.Rdx, dbger.addr2some(regs.Rdx))
	fmt.Printf("$rsp   : %s0x%016x%s\n", dbger.addr2color(regs.Rsp), regs.Rsp, dbger.addr2some(regs.Rsp))
	fmt.Printf("$rbp   : %s0x%016x%s\n", dbger.addr2color(regs.Rbp), regs.Rbp, dbger.addr2some(regs.Rbp))
	fmt.Printf("$rsi   : %s0x%016x%s\n", dbger.addr2color(regs.Rsi), regs.Rsi, dbger.addr2some(regs.Rsi))
	fmt.Printf("$rdi   : %s0x%016x%s\n", dbger.addr2color(regs.Rdi), regs.Rdi, dbger.addr2some(regs.Rdi))
	fmt.Printf("$rip   : %s0x%016x%s\n", dbger.addr2color(rip), rip, dbger.addr2some(rip))
	fmt.Printf("$r8    : %s0x%016x%s\n", dbger.addr2color(regs.R8), regs.R8, dbger.addr2some(regs.R8))
	fmt.Printf("$r9    : %s0x%016x%s\n", dbger.addr2color(regs.R9), regs.R9, dbger.addr2some(regs.R9))
	fmt.Printf("$r10   : %s0x%016x%s\n", dbger.addr2color(regs.R10), regs.R10, dbger.addr2some(regs.R10))
	fmt.Printf("$r11   : %s0x%016x%s\n", dbger.addr2color(regs.R11), regs.R11, dbger.addr2some(regs.R11))
	fmt.Printf("$r12   : %s0x%016x%s\n", dbger.addr2color(regs.R12), regs.R12, dbger.addr2some(regs.R12))
	fmt.Printf("$r13   : %s0x%016x%s\n", dbger.addr2color(regs.R13), regs.R13, dbger.addr2some(regs.R13))
	fmt.Printf("$r14   : %s0x%016x%s\n", dbger.addr2color(regs.R14), regs.R14, dbger.addr2some(regs.R14))
	fmt.Printf("$eflags: 0x%016x\n", regs.Eflags)
	fmt.Printf("$cs: %x $ss: %x $ds: %x $es: %x $fs: %x $gs: %x\n",
		regs.Cs, regs.Ss, regs.Ds, regs.Es, regs.Fs, regs.Gs)

	hLine("stack")
	if regs != nil && dbger.arch == 64 {
		data, err := dbger.GetMemory(64, uintptr(regs.Rsp))
		if err != nil {
			LogError("Error while getting stack memory: %v", err)
		} else {
			fmt.Printf("$rsp>")
			for i := 0; i < len(data); i += 8 {
				if i+8 <= len(data) {
					if i != 0 {
						fmt.Printf("     ")
					}
					address := binary.LittleEndian.Uint64(data[i : i+8])
					fmt.Printf("%s0x%016x%s: %s0x%016x%s%s\n", ColorReadWrite, regs.Rsp+uint64(i), ColorReset, dbger.addr2color(address),
						address, ColorReset, dbger.addr2some(address))
				}
			}
		}
	}

	hLine("disassembly")
	if regs != nil {
		dbger.disass(rip, 32)
	}

	hLine("back trace")
	btArgs := []string{"backtrace", "", ""}
	dbger.backtrace(btArgs, false)

	hLineRaw()
	return nil
}

func (dbger *TypeDbg) cmdStack(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	var sz uint64 = 8
	var err error
	if len(args[2]) != 0 {
		sz, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}
	rsp, err := dbger.GetRsp()
	if err != nil {
		return err
	}
	data, err := dbger.GetMemory(uint(sz*8), uintptr(rsp))
	if err != nil {
		LogError("Error while getting stack memory: %v", err)
	} else {
		for i := 0; i < len(data); i += 8 {
			if i+8 <= len(data) {
				fmt.Printf("%s0x%016x%s: %s0x%016x%s%s\n", ColorBlue, rsp+uint64(i), ColorReset, ColorCyan,
					binary.LittleEndian.Uint64(data[i:i+8]), ColorReset, dbger.addr2some(binary.LittleEndian.Uint64(data[i:i+8])))
			}
		}
	}

	return nil
}

func (dbger *TypeDbg) cmdVmmap(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}

	fmt.Println("[start]              [end]              | [size]     | [offset]    | [rwx]  [path]")
	if args[2] != "" {
		for _, p := range procMapsDetail {
			if strings.Contains(p.path, strings.TrimSpace(args[2])) {
				rwx := ""
				if p.r {
					rwx += "r"
				} else {
					rwx += " "
				}
				if p.w {
					rwx += "w"
				} else {
					rwx += " "
				}
				if p.x {
					rwx += "x"
				} else {
					rwx += " "
				}
				fmt.Printf("%s0x%016x ~ 0x%016x | 0x%08x | +0x%08x | %s : %s%s\n", dbger.addr2color(p.start), p.start, p.end, (int)(p.end-p.start), p.offset, rwx, p.path, ColorReset)
			}
		}
		return nil
	}

	for _, p := range procMapsDetail {
		rwx := ""
		if p.r {
			rwx += "r"
		} else {
			rwx += " "
		}
		if p.w {
			rwx += "w"
		} else {
			rwx += " "
		}
		if p.x {
			rwx += "x"
		} else {
			rwx += " "
		}
		fmt.Printf("%s0x%016x ~ 0x%016x | 0x%08x | +0x%08x | %s : %s%s\n", dbger.addr2color(p.start), p.start, p.end, (p.end - p.start), p.offset, rwx, p.path, ColorReset)
	}

	return nil
}

func (dbger *TypeDbg) cmdSym(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	return dbger.ListSymbols(args[2])
}

func (dbger *TypeDbg) cmdGot(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}

	pltEntries, gotEntries, err := dbger.AnalyzePLTGOTInfo()
	if err != nil {
		return fmt.Errorf("failed to analyze PLT/GOT: %v", err)
	}

	printf := func(format string, args ...interface{}) {
		fmt.Printf(format, args...)
	}

	printf("Name                        | PLT            | GOT            | GOT value     \n")
	hLine(".rela.plt")

	pltMap := make(map[string]PLTEntry)
	for _, plt := range pltEntries {
		pltMap[plt.OriginalName] = plt
	}

	gotMap := make(map[string]GOTEntry)
	for _, got := range gotEntries {
		if got.Name != "" && !strings.HasPrefix(got.Name, "GOT[") {
			gotMap[got.Name] = got
		}
	}

	processed := make(map[string]bool)

	for _, plt := range pltEntries {
		if processed[plt.OriginalName] {
			continue
		}
		processed[plt.OriginalName] = true

		pltAddr := fmt.Sprintf("0x%012x", plt.Address)
		gotAddr := "Not found"
		gotValue := "Not found"

		if got, exists := gotMap[plt.OriginalName]; exists {
			gotAddr = fmt.Sprintf("0x%012x", got.Address)

			data, err := dbger.GetMemory(8, uintptr(got.Address))
			if err == nil && len(data) >= 8 {
				value := binary.LittleEndian.Uint64(data)
				resolved := ""
				if value != 0 {
					if sym, _, err := dbger.ResolveAddrToSymbol(value); err == nil {
						resolved = fmt.Sprintf(" <%s>", sym.Name)
					}
				}
				gotValue = fmt.Sprintf("0x%012x%s", value, resolved)
			} else {
				gotValue = "0x000000000000"
			}
		} else {
			for _, got := range gotEntries {
				if strings.HasPrefix(got.Name, "GOT[") {
					data, err := dbger.GetMemory(8, uintptr(got.Address))
					if err == nil {
						value := binary.LittleEndian.Uint64(data)
						if value != 0 {
							if sym, _, err := dbger.ResolveAddrToSymbol(value); err == nil {
								if strings.Contains(sym.Name, plt.OriginalName) {
									gotAddr = fmt.Sprintf("0x%012x", got.Address)
									resolved := fmt.Sprintf(" <%s>", sym.Name)
									gotValue = fmt.Sprintf("0x%012x%s", value, resolved)
									break
								}
							}
						}
					}
				}
			}
		}

		printf("%-27s | %s | %s | %s\n", plt.OriginalName, pltAddr, gotAddr, gotValue)
	}

	hLine(".rela.dyn")

	for _, got := range gotEntries {
		if got.Name == "" || strings.HasPrefix(got.Name, "GOT[") {
			continue
		}

		if processed[got.Name] {
			continue
		}
		processed[got.Name] = true

		pltAddr := "  Not found   "
		if plt, exists := pltMap[got.Name]; exists {
			pltAddr = fmt.Sprintf("0x%012x", plt.Address)
		}

		gotAddr := fmt.Sprintf("0x%012x", got.Address)
		gotValue := "0x000000000000"

		data, err := dbger.GetMemory(8, uintptr(got.Address))
		if err == nil && len(data) >= 8 {
			value := binary.LittleEndian.Uint64(data)
			resolved := ""
			if value != 0 {
				if sym, _, err := dbger.ResolveAddrToSymbol(value); err == nil {
					resolved = fmt.Sprintf(" <%s>", sym.Name)
				}
			}
			gotValue = fmt.Sprintf("0x%012x%s", value, resolved)
		}

		printf("%-27s | %s | %s | %s\n", got.Name, pltAddr, gotAddr, gotValue)
	}

	return nil
}

func (dbger *TypeDbg) cmdCmd(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	handle := exec.Command("/bin/sh", "-c", args[2])
	output, err := handle.CombinedOutput()
	fmt.Println(string(output))
	return err
}

func (dbger *TypeDbg) cmdDisass(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	var addr uint64
	var err error
	if len(args[2]) == 0 {
		addr, err = dbger.GetRip()
		if err != nil {
			return err
		}
		dbger.disass2ret(addr)
		return nil
	} else {
		addr, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}
	var sz uint64 = 32
	if args[4] != "" {
		sz, err = strconv.ParseUint(args[5], 0, 32)
		if err != nil {
			return err
		}
	}

	dbger.disass(addr, uint(sz))

	return nil
}

func (dbger *TypeDbg) cmdRegs(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	if len(args[2]) != 0 {
		val, err := dbger.GetRegs(args[2])
		if err != nil {
			return err
		}
		Printf("%s = 0x%016x\n", args[2], val)

		return nil
	}
	var regs *unix.PtraceRegs
	var err error

	regs, err = dbger.getRegs()
	if err != nil {
		return err
	}

	if regs == nil {
		return errors.New("nil registers")
	}

	rip, err := dbger.GetRip()
	if err != nil {
		return err
	}

	fmt.Printf("$rax   : %s0x%016x%s\n", dbger.addr2color(regs.Rax), regs.Rax, dbger.addr2some(regs.Rax))
	fmt.Printf("$rbx   : %s0x%016x%s\n", dbger.addr2color(regs.Rbx), regs.Rbx, dbger.addr2some(regs.Rbx))
	fmt.Printf("$rcx   : %s0x%016x%s\n", dbger.addr2color(regs.Rcx), regs.Rcx, dbger.addr2some(regs.Rcx))
	fmt.Printf("$rdx   : %s0x%016x%s\n", dbger.addr2color(regs.Rdx), regs.Rdx, dbger.addr2some(regs.Rdx))
	fmt.Printf("$rsp   : %s0x%016x%s\n", dbger.addr2color(regs.Rsp), regs.Rsp, dbger.addr2some(regs.Rsp))
	fmt.Printf("$rbp   : %s0x%016x%s\n", dbger.addr2color(regs.Rbp), regs.Rbp, dbger.addr2some(regs.Rbp))
	fmt.Printf("$rsi   : %s0x%016x%s\n", dbger.addr2color(regs.Rsi), regs.Rsi, dbger.addr2some(regs.Rsi))
	fmt.Printf("$rdi   : %s0x%016x%s\n", dbger.addr2color(regs.Rdi), regs.Rdi, dbger.addr2some(regs.Rdi))
	fmt.Printf("$rip   : %s0x%016x%s\n", dbger.addr2color(rip), rip, dbger.addr2some(rip))
	fmt.Printf("$r8    : %s0x%016x%s\n", dbger.addr2color(regs.R8), regs.R8, dbger.addr2some(regs.R8))
	fmt.Printf("$r9    : %s0x%016x%s\n", dbger.addr2color(regs.R9), regs.R9, dbger.addr2some(regs.R9))
	fmt.Printf("$r10   : %s0x%016x%s\n", dbger.addr2color(regs.R10), regs.R10, dbger.addr2some(regs.R10))
	fmt.Printf("$r11   : %s0x%016x%s\n", dbger.addr2color(regs.R11), regs.R11, dbger.addr2some(regs.R11))
	fmt.Printf("$r12   : %s0x%016x%s\n", dbger.addr2color(regs.R12), regs.R12, dbger.addr2some(regs.R12))
	fmt.Printf("$r13   : %s0x%016x%s\n", dbger.addr2color(regs.R13), regs.R13, dbger.addr2some(regs.R13))
	fmt.Printf("$r14   : %s0x%016x%s\n", dbger.addr2color(regs.R14), regs.R14, dbger.addr2some(regs.R14))
	fmt.Printf("$eflags: 0x%016x\n", regs.Eflags)
	fmt.Printf("$cs: %x $ss: %x $ds: %x $es: %x $fs: %x $gs: %x\n",
		regs.Cs, regs.Ss, regs.Ds, regs.Es, regs.Fs, regs.Gs)

	return nil
}

func (dbger *TypeDbg) cmdStep(_ interface{}) error {
	err := dbger.Step()
	if err != nil {
		return err
	}
	if dbger.isStart {
		cls()
		dbger.cmdContext(nil)
	}

	return nil
}

func (dbger *TypeDbg) cmdColor(_ interface{}) error {
	fmt.Printf("%s[r  ]: readonly				%s\n", ColorRead, ColorReset)
	fmt.Printf("%s[ w ]: writeonly				%s\n", ColorWrite, ColorReset)
	fmt.Printf("%s[  x]: executable				%s\n", ColorExecutable, ColorReset)
	fmt.Printf("%s[rw ]: read/write				%s\n", ColorReadWrite, ColorReset)
	fmt.Printf("%s[r x]: read/executable			%s\n", ColorReadExecutable, ColorReset)
	fmt.Printf("%s[rwx]: read/write/executable	%s\n", ColorReadWriteExecutable, ColorReset)
	fmt.Printf("%s[---]: fault					%s\n", ColorDefault, ColorReset)
	return nil
}

func (dbger *TypeDbg) cmdBacktrace(a interface{}) error {
	return dbger.backtrace(a, true)
}

func (dbger *TypeDbg) backtrace(a interface{}, standalone bool) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}

	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	maxDepth := 20
	var err error

	if len(args) > 2 && len(args[2]) != 0 {
		depth, err := strconv.ParseUint(args[2], 0, 64)
		if err != nil {
			return fmt.Errorf("invalid depth: %v", err)
		}
		maxDepth = int(depth)
	}

	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}

	if regs == nil {
		return errors.New("nil registers")
	}

	rip, err := dbger.GetRip()
	if err != nil {
		return err
	}

	rbp := regs.Rbp

	frameNum := 0
	fmt.Printf("#%-2d %s0x%016x%s", frameNum, dbger.addr2color(rip), rip, ColorReset)

	sym, offset, err := dbger.ResolveAddrToSymbol(rip)
	if err == nil && sym != nil {
		if offset == 0 {
			fmt.Printf(" in %s()\n", sym.Name)
		} else {
			fmt.Printf(" in %s()+%d\n", sym.Name, offset)
		}
	} else {
		fmt.Printf("\n")
	}

	visited := make(map[uint64]bool)
	visited[rbp] = true

	for frameNum = 1; frameNum < maxDepth; frameNum++ {
		if rbp == 0 || rbp%8 != 0 {
			break
		}

		ripData, err := dbger.GetMemory(8, uintptr(rbp+8))
		if err != nil {
			break
		}

		if len(ripData) < 8 {
			break
		}

		savedRip := binary.LittleEndian.Uint64(ripData)

		if savedRip == 0 {
			break
		}

		fmt.Printf("#%-2d %s0x%016x%s", frameNum, dbger.addr2color(savedRip), savedRip, ColorReset)

		sym, offset, err := dbger.ResolveAddrToSymbol(savedRip)
		if err == nil && sym != nil {
			if offset == 0 {
				fmt.Printf(" in %s()\n", sym.Name)
			} else {
				fmt.Printf(" in %s()+%d\n", sym.Name, offset)
			}
		} else {
			fmt.Printf("\n")
		}

		rbpData, err := dbger.GetMemory(8, uintptr(rbp))
		if err != nil {
			break
		}

		if len(rbpData) < 8 {
			break
		}

		prevRbp := binary.LittleEndian.Uint64(rbpData)
		if visited[prevRbp] {
			break
		}
		if prevRbp <= rbp {
			break
		}

		visited[prevRbp] = true
		rbp = prevRbp
	}

	return nil
}

func (dbger *TypeDbg) cmdStackFrame(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}

	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	var sz uint64 = 8
	var err error
	if len(args[2]) != 0 {
		sz, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}

	if regs == nil {
		return errors.New("nil registers")
	}

	rsp := regs.Rsp
	rbp := regs.Rbp

	type FrameInfo struct {
		frameNum int
		rbpAddr  uint64
		ripAddr  uint64
		rbpValue uint64
		ripValue uint64
	}

	frames := []FrameInfo{}
	currentRbp := rbp
	visited := make(map[uint64]bool)

	for frameNum := 0; frameNum < 20; frameNum++ {
		if currentRbp == 0 || currentRbp%8 != 0 {
			break
		}

		if visited[currentRbp] {
			break
		}
		visited[currentRbp] = true

		frame := FrameInfo{
			frameNum: frameNum,
			rbpAddr:  currentRbp,
			ripAddr:  currentRbp + 8,
		}

		rbpData, err := dbger.GetMemory(8, uintptr(currentRbp))
		if err == nil && len(rbpData) >= 8 {
			frame.rbpValue = binary.LittleEndian.Uint64(rbpData)
		}

		ripData, err := dbger.GetMemory(8, uintptr(currentRbp+8))
		if err == nil && len(ripData) >= 8 {
			frame.ripValue = binary.LittleEndian.Uint64(ripData)
		}

		frames = append(frames, frame)

		if frame.rbpValue == 0 || frame.rbpValue <= currentRbp {
			break
		}
		currentRbp = frame.rbpValue
	}

	data, err := dbger.GetMemory(uint(sz*8), uintptr(rsp))
	if err != nil {
		return fmt.Errorf("error while getting stack memory: %v", err)
	}

	for i := 0; i < len(data); i += 8 {
		if i+8 > len(data) {
			break
		}

		addr := rsp + uint64(i)
		value := binary.LittleEndian.Uint64(data[i : i+8])

		annotation := ""
		for _, frame := range frames {
			if addr == frame.rbpAddr {
				annotation = fmt.Sprintf(" <- frame #%d rbp", frame.frameNum)
				break
			} else if addr == frame.ripAddr {
				annotation = fmt.Sprintf(" <- frame #%d ret", frame.frameNum)
				if sym, offset, err := dbger.ResolveAddrToSymbol(value); err == nil && sym != nil {
					if offset == 0 {
						annotation += fmt.Sprintf(" (%s)", sym.Name)
					} else {
						annotation += fmt.Sprintf(" (%s+%d)", sym.Name, offset)
					}
				}
				break
			}
		}

		fmt.Printf("%s0x%016x%s: %s0x%016x%s%s%s%s\n",
			ColorBlue, addr, ColorReset,
			dbger.addr2color(value), value, ColorReset,
			dbger.addr2some(value),
			ColorReadWriteExecutable, annotation)
	}

	return nil
}

func (dbger *TypeDbg) cmdSet(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	val, err := strconv.ParseUint(args[3], 0, 64)
	if err != nil {
		return err
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		dbger.SetRegs(args[2], val)
	}
	valBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(valBytes, val)
	return dbger.SetMemory(valBytes, uintptr(addr))
}

func (dbger *TypeDbg) cmdSet32(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	val, err := strconv.ParseUint(args[3], 0, 32)
	if err != nil {
		return err
	}
	valBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(valBytes, uint32(val))
	return dbger.SetMemory(valBytes, uintptr(addr))
}

func (dbger *TypeDbg) cmdSet16(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	val, err := strconv.ParseUint(args[3], 0, 16)
	if err != nil {
		return err
	}
	valBytes := make([]byte, 2)
	binary.LittleEndian.PutUint16(valBytes, uint16(val))
	return dbger.SetMemory(valBytes, uintptr(addr))
}

func (dbger *TypeDbg) cmdSet8(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	val, err := strconv.ParseUint(args[3], 0, 8)
	if err != nil {
		return err
	}
	valBytes := []byte{byte(val)}
	return dbger.SetMemory(valBytes, uintptr(addr))
}

func (dbger *TypeDbg) cmdXor(a interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	key, err := strconv.ParseUint(args[3], 0, 64)
	if err != nil {
		return err
	}
	memByte, err := dbger.GetMemory(8, uintptr(addr))
	if err != nil {
		return err
	}
	ord := binary.LittleEndian.Uint64(memByte)
	res := ord ^ key
	fmt.Printf("%s%x%s xor %s%x%s -> %s%x%s\n", ColorCyan, ord, ColorReset, ColorCyan, key, ColorReset, ColorCyan, res, ColorReset)
	resBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(resBytes, res)
	return dbger.SetMemory(resBytes, uintptr(addr))
}

func (dbger *TypeDbg) cmdFs(_ interface{}) error {
	if !dbger.isStart {
		return errors.New("debuggee has not started")
	}
	fsBase, err := dbger.GetFs_base()
	if err != nil {
		return err
	}
	fmt.Printf("fs_base = %s%x%s\n", ColorCyan, fsBase, ColorReset)

	data, err := dbger.GetMemory(8*0x10, uintptr(fsBase))
	if err != nil {
		return err
	}
	hLine("fs dump")
	for i := range 0xf {
		fmt.Printf(
			"%s0x%016x%s: %s%016x%s",
			ColorBlue,
			fsBase+uint64(i*0x8),
			ColorReset,
			ColorCyan,
			binary.LittleEndian.Uint64(data[i*0x8:i*0x8+8]),
			ColorReset)

		if i == 5 {
			fmt.Println(" <- canary")
		} else if i == 6 {
			fmt.Println(" <- mangling key")
		} else {
			fmt.Println("")
		}
	}
	return nil
}

func (dbger *TypeDbg) cmdWpList(_ interface{}) error {
	for i, s := range slotList {
		if s.flg {
			fmt.Printf("[%d] %s%016x%s READ/WRITE\n", i, ColorCyan, s.addr, ColorReset)
		} else {
			fmt.Printf("[%d] %sidle%s\n", i, ColorRed, ColorReset)
		}
	}

	return nil
}

func (dbger *TypeDbg) cmdWp(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	err = dbger.SetWatchpoint(addr, WP_SIZE_1, WP_READWRITE)

	if err == nil {
		fmt.Printf("New watchpoint %s%016x%s with WP_READWRITE\n", ColorCyan, addr, ColorReset)
		return nil
	}

	return err
}

func (dbger *TypeDbg) cmdWpDel(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	err = dbger.clearWatchpoint(addr)

	if err == nil {
		fmt.Printf("%swatchpoint removed: %016x%s\n", ColorRed, addr, ColorReset)
		return nil
	}

	return err
}

```

`common.go`:

```go
package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

type SymbolResolver interface {
	ResolveRegister(name string) (uint64, error)
	ResolveSymbol(name string) (uint64, error)
}

func EvaluateExpression(expr string, resolver SymbolResolver) (uint64, error) {
	resolved, err := resolveSymbolsInExpr(expr, resolver)
	if err != nil {
		return 0, err
	}
	return evalArithmetic(resolved)
}

func resolveSymbolsInExpr(expr string, resolver SymbolResolver) (string, error) {
	symPattern := regexp.MustCompile(`\$([a-zA-Z_][a-zA-Z0-9_@.]*)`)

	var resolveErr error
	result := symPattern.ReplaceAllStringFunc(expr, func(match string) string {
		symName := strings.TrimPrefix(match, "$")
		val, err := resolver.ResolveRegister(symName)
		if err == nil {
			return fmt.Sprintf("0x%x", val)
		}
		val, err = resolver.ResolveSymbol(symName)
		if err == nil {
			return fmt.Sprintf("0x%x", val)
		}

		resolveErr = fmt.Errorf("failed to resolve symbol: %s", symName)
		return match
	})

	return result, resolveErr
}

func evalArithmetic(expr string) (uint64, error) {
	expr = strings.TrimSpace(expr)
	if !strings.ContainsAny(expr, "+-*/()") {
		return parseNumber(expr)
	}
	tokens := tokenize(expr)
	if len(tokens) == 0 {
		return 0, fmt.Errorf("empty expression")
	}
	result, _, err := parseAddSub(tokens, 0)
	return result, err
}

type token struct {
	typ   string
	value string
}

func tokenize(expr string) []token {
	var tokens []token
	expr = strings.ReplaceAll(expr, " ", "")

	i := 0
	for i < len(expr) {
		ch := expr[i]

		switch ch {
		case '+', '-', '*', '/':
			tokens = append(tokens, token{"op", string(ch)})
			i++
		case '(':
			tokens = append(tokens, token{"lparen", "("})
			i++
		case ')':
			tokens = append(tokens, token{"rparen", ")"})
			i++
		default:
			start := i
			if ch == '0' && i+1 < len(expr) && (expr[i+1] == 'x' || expr[i+1] == 'X') {
				i += 2
				for i < len(expr) && isHexDigit(expr[i]) {
					i++
				}
			} else {
				for i < len(expr) && (isDigit(expr[i])) {
					i++
				}
			}
			if i > start {
				tokens = append(tokens, token{"number", expr[start:i]})
			} else {
				i++
			}
		}
	}

	return tokens
}

func isDigit(ch byte) bool {
	return ch >= '0' && ch <= '9'
}

func isHexDigit(ch byte) bool {
	return isDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')
}

func parseAddSub(tokens []token, pos int) (uint64, int, error) {
	left, pos, err := parseMulDiv(tokens, pos)
	if err != nil {
		return 0, pos, err
	}

	for pos < len(tokens) && tokens[pos].typ == "op" && (tokens[pos].value == "+" || tokens[pos].value == "-") {
		op := tokens[pos].value
		pos++

		right, newPos, err := parseMulDiv(tokens, pos)
		if err != nil {
			return 0, pos, err
		}
		pos = newPos

		if op == "+" {
			left = left + right
		} else {
			if right > left {
				return 0, pos, fmt.Errorf("subtraction would result in negative number")
			}
			left = left - right
		}
	}

	return left, pos, nil
}

func parseMulDiv(tokens []token, pos int) (uint64, int, error) {
	left, pos, err := parseFactor(tokens, pos)
	if err != nil {
		return 0, pos, err
	}

	for pos < len(tokens) && tokens[pos].typ == "op" && (tokens[pos].value == "*" || tokens[pos].value == "/") {
		op := tokens[pos].value
		pos++

		right, newPos, err := parseFactor(tokens, pos)
		if err != nil {
			return 0, pos, err
		}
		pos = newPos

		if op == "*" {
			left = left * right
		} else {
			if right == 0 {
				return 0, pos, fmt.Errorf("division by zero")
			}
			left = left / right
		}
	}

	return left, pos, nil
}

func parseFactor(tokens []token, pos int) (uint64, int, error) {
	if pos >= len(tokens) {
		return 0, pos, fmt.Errorf("unexpected end of expression")
	}

	tok := tokens[pos]

	if tok.typ == "number" {
		val, err := parseNumber(tok.value)
		return val, pos + 1, err
	}

	if tok.typ == "lparen" {
		val, newPos, err := parseAddSub(tokens, pos+1)
		if err != nil {
			return 0, newPos, err
		}
		pos = newPos

		if pos >= len(tokens) || tokens[pos].typ != "rparen" {
			return 0, pos, fmt.Errorf("missing closing parenthesis")
		}

		return val, pos + 1, nil
	}

	return 0, pos, fmt.Errorf("unexpected token: %s", tok.value)
}

func parseNumber(s string) (uint64, error) {
	s = strings.TrimSpace(s)
	if strings.HasPrefix(s, "0x") || strings.HasPrefix(s, "0X") {
		return strconv.ParseUint(s[2:], 16, 64)
	}
	if strings.HasPrefix(s, "0") && len(s) > 1 {
		return strconv.ParseUint(s, 8, 64)
	}
	return strconv.ParseUint(s, 10, 64)
}

func ResolveSymbolsInCommand(cmd string, resolver SymbolResolver) (string, error) {
	if !strings.Contains(cmd, "$") {
		return cmd, nil
	}

	exprPattern := regexp.MustCompile(`(\$[a-zA-Z_][a-zA-Z0-9_@.]*(?:\s*[+\-*/]\s*(?:0[xX][0-9a-fA-F]+|0[0-7]+|[0-9]+|\$[a-zA-Z_][a-zA-Z0-9_@.]*))*)`)

	var lastErr error
	result := exprPattern.ReplaceAllStringFunc(cmd, func(match string) string {
		val, err := EvaluateExpression(match, resolver)
		if err != nil {
			resolved, err2 := resolveSymbolsInExpr(match, resolver)
			if err2 != nil {
				lastErr = err2
				return match
			}
			return resolved
		}
		return fmt.Sprintf("0x%x", val)
	})

	return result, lastErr
}

```

`dbg.go`:

```go
package main

import (
	"bufio"
	"debug/elf"
	"errors"
	"fmt"
	"golang.org/x/sys/unix"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

var mainDbger TypeDbg = TypeDbg{
	pid:      0,
	path:     "",
	isAttach: false,
	rip:      0,
	isStart:  false,
	arch:     64,
	isBp:     false,
	rpc:      nil,
}

type TypeDbg struct {
	pid      int
	path     string
	isAttach bool
	rip      uint64
	isStart  bool
	arch     int
	isBp     bool
	rpc      *doSysRPC
}

var procMapsDetail []*proc

type proc struct {
	start  uint64
	end    uint64
	r      bool
	w      bool
	x      bool
	offset uint64
	path   string
}

func (dbger *TypeDbg) isProcessAlive() bool {
	if dbger.pid <= 0 {
		return false
	}
	_, err := os.Stat(fmt.Sprintf("/proc/%d", dbger.pid))
	return err == nil
}

func (dbger *TypeDbg) isStopped() bool {
	if !dbger.isProcessAlive() {
		return false
	}

	path := fmt.Sprintf("/proc/%d/stat", dbger.pid)
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}

	fields := strings.Fields(string(data))
	if len(fields) < 3 {
		return false
	}

	state := fields[2]
	return state == "t" || state == "T"
}

func (dbger *TypeDbg) isProcessTraced() bool {
	statusFile := fmt.Sprintf("/proc/%d/status", dbger.pid)
	data, err := os.ReadFile(statusFile)
	if err != nil {
		return false
	}

	return !strings.Contains(string(data), "TracerPid:\t0")
}

func (dbger *TypeDbg) getExecutablePath() (string, error) {
	exePath := fmt.Sprintf("/proc/%d/exe", dbger.pid)
	realPath, err := filepath.EvalSymlinks(exePath)
	if err != nil {
		return "", fmt.Errorf("failed to resolve executable path: %v", err)
	}

	absPath, err := filepath.Abs(realPath)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path: %v", err)
	}

	return absPath, nil
}

func (dbger *TypeDbg) loadBase() error {
	procMapsDetail = []*proc{}
	rgx := `^([0-9a-f]+)-([0-9a-f]+)\s+([rwxps-]+)\s+([0-9a-f]+)\s+([0-9a-f]+:[0-9a-f]+)\s+(\d+)(?:\s+(.*))?$`

	regex, err := regexp.Compile(rgx)
	if err != nil {
		return err
	}

	fileName := fmt.Sprintf("/proc/%d/maps", dbger.pid)
	file, err := os.Open(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		match := regex.FindStringSubmatch(scanner.Text())
		if len(match) < 7 {
			continue
		}
		startAddr, _ := strconv.ParseUint(match[1], 16, 64)
		endAddr, _ := strconv.ParseUint(match[2], 16, 64)
		offset, _ := strconv.ParseUint(match[4], 16, 64)
		pathname := ""
		if len(match) > 7 && match[7] != "" {
			pathname = strings.TrimSpace(match[7])
		}

		newMap := proc{
			start:  startAddr,
			end:    endAddr,
			r:      strings.Contains(match[3], "r"),
			w:      strings.Contains(match[3], "w"),
			x:      strings.Contains(match[3], "x"),
			offset: offset,
			path:   pathname,
		}
		procMapsDetail = append(procMapsDetail, &newMap)
	}

	return nil
}

func Run(bin string, args ...string) (*TypeDbg, error) {
	absPath := bin
	if strings.HasPrefix(bin, "~") {
		home, err := os.UserHomeDir()
		if err != nil {
			return nil, err
		}
		absPath = filepath.Join(home, bin[1:])
	} else if strings.HasPrefix(bin, "./") || !strings.HasPrefix(bin, "/") {
		cwd, err := os.Getwd()
		if err != nil {
			return nil, err
		}
		absPath = filepath.Join(cwd, bin)
	}

	absPath, err := filepath.Abs(absPath)
	if err != nil {
		return nil, err
	}

	f, err := elf.Open(absPath)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var arch int
	switch f.Class {
	case elf.ELFCLASS32:
		arch = 32
	case elf.ELFCLASS64:
		arch = 64
	default:
		return nil, errors.New("unknown ELF class")
	}

	dbger := &TypeDbg{
		pid:      -1,
		path:     absPath,
		isAttach: false,
		rip:      0,
		isStart:  true,
		arch:     arch,
		isBp:     false,
		rpc:      doSyscallWorker(),
	}

	doSyscallErr(dbger.rpc, func() error {
		cmd := exec.Command(absPath, args...)

		cmd.SysProcAttr = &unix.SysProcAttr{
			Ptrace: true,
		}

		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err = cmd.Start(); err != nil {
			return err
		}
		dbger.pid = cmd.Process.Pid
		Printf("%s started with PID:%d\n", absPath, dbger.pid)

		return nil
	})

	_, err = dbger.wait()
	if err != nil {
		return nil, err
	}

	dbger.rip, err = dbger.GetRip()
	if err != nil {
		return nil, err
	}

	err = dbger.loadBase()

	return dbger, nil
}

func Attach(pid int) (*TypeDbg, error) {
	dbger := &TypeDbg{
		pid:      pid,
		path:     "",
		isAttach: true,
		rip:      0,
		isStart:  true,
		arch:     64,
		rpc:      doSyscallWorker(),
	}

	if !dbger.isProcessAlive() {
		return nil, fmt.Errorf("process %d does not exist", pid)
	}

	if dbger.isProcessTraced() {
		return nil, fmt.Errorf("process %d is already being traced", pid)
	}

	exePath, err := dbger.getExecutablePath()
	if err != nil {
		return nil, fmt.Errorf("failed to get executable path: %v", err)
	}
	dbger.path = exePath
	Printf("Resolved executable: %s\n", exePath)

	f, err := elf.Open(exePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open ELF file: %v", err)
	}
	defer f.Close()

	switch f.Class {
	case elf.ELFCLASS32:
		dbger.arch = 32
	case elf.ELFCLASS64:
		dbger.arch = 64
	default:
		return nil, errors.New("unknown ELF class")
	}

	err = doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceAttach(pid)
	})
	if err != nil {
		return nil, dbger.formatPtraceError("attach", err)
	}

	Printf("attached to PID:%d\n", pid)

	_, err = dbger.wait()
	if err != nil {
		waitErr := err
		detachErr := doSyscallErr(dbger.rpc, func() error {
			return unix.PtraceDetach(pid)
		})
		if detachErr != nil {
			return nil, fmt.Errorf("wait failed: %v (detach also failed: %v)", waitErr, detachErr)
		}
		return nil, fmt.Errorf("wait failed: %v", waitErr)
	}

	dbger.rip, err = dbger.GetRip()
	if err != nil {
		return nil, err
	}

	err = dbger.loadBase()
	return dbger, nil
}

func (dbger *TypeDbg) Detach() error {
	if dbger.pid <= 0 {
		return errors.New("invalid PID")
	}

	wasStopped := dbger.isStopped()

	err := doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceDetach(dbger.pid)
	})
	if err != nil {
		return err
	}

	if wasStopped {
		unix.Kill(dbger.pid, unix.SIGCONT)
	}

	Printf("detached from PID:%d\n", dbger.pid)
	return nil
}

func (dbger *TypeDbg) interrupt() error {
	return doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceInterrupt(dbger.pid)
	})
}

func (dbger *TypeDbg) wait() (unix.WaitStatus, error) {
	var ws unix.WaitStatus
	var err error

	err = doSyscallErr(dbger.rpc, func() error {
		_, err = unix.Wait4(dbger.pid, &ws, 0, nil)
		return err
	})

	if err != nil {
		return 0, dbger.formatPtraceError("wait", err)
	}

	if ws.Exited() {
		Printf("PID:%d exited with status %d\n", dbger.pid, ws.ExitStatus())
		dbger.isStart = false
		return ws, nil
	}
	if ws.CoreDump() {
		Printf("Segmentation fault (SIGSEGV): %d\n", dbger.pid)
	}

	if ws.Stopped() {
		rip, err := dbger.GetRip()
		if err == nil {
			dbger.rip = rip
			dbger.checkBreakpoint(rip)
		}
	}

	return ws, nil
}

func (dbger *TypeDbg) checkBreakpoint(rip uint64) bool {
	checkAddr := rip - 1
	for i, b := range Bps {
		if b.addr == uintptr(checkAddr) && b.isEnable {
			Printf("stopped at breakpoint %d @ %x\n", i, checkAddr)
			return true
		}
	}
	return false
}

func (dbger *TypeDbg) stopWait() (unix.WaitStatus, error) {
	err := dbger.stop()
	if err != nil {
		return 0, err
	}
	return dbger.wait()
}

func (dbger *TypeDbg) Continue() error {
	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	rip, err := dbger.GetRip()
	if err != nil {
		return err
	}

	bp, ok := func(rip uint64) (*TypeBp, bool) {
		for _, b := range Bps {
			if b.addr == uintptr(rip) && b.isEnable {
				return &b, true
			}
		}
		return nil, false
	}(rip)

	if ok {
		if err := bp.disableBp(dbger); err != nil {
			return err
		}
		if err := dbger.SetRip(rip); err != nil {
			return err
		}
		err = doSyscallErr(dbger.rpc, func() error {
			return unix.PtraceSingleStep(dbger.pid)
		})
		if err != nil {
			return err
		}
		if _, err = dbger.wait(); err != nil {
			return err
		}

		err = bp.enableBp(dbger)
		if err != nil {
			return err
		}
	}

	return doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceCont(dbger.pid, 0)
	})
}

func (dbger *TypeDbg) stop() error {
	return doSyscallErr(dbger.rpc, func() error {
		return unix.Kill(dbger.pid, unix.SIGSTOP)
	})
}

func (dbger *TypeDbg) Step() error {
	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	rip, err := dbger.GetRip()
	if err != nil {
		return err
	}

	bp, ok := func(rip uint64) (*TypeBp, bool) {
		for _, b := range Bps {
			if b.addr == uintptr(rip) && b.isEnable {
				return &b, true
			}
		}
		return nil, false
	}(rip)

	if ok {
		if err := bp.disableBp(dbger); err != nil {
			return err
		}
		if err := dbger.SetRip(rip); err != nil {
			return err
		}
		err = doSyscallErr(dbger.rpc, func() error {
			return unix.PtraceSingleStep(dbger.pid)
		})
		if err != nil {
			return err
		}
		if _, err = dbger.wait(); err != nil {
			return err
		}

		err = bp.enableBp(dbger)
		if err != nil {
			return err
		}
	} else {
		return doSyscallErr(dbger.rpc, func() error {
			return unix.PtraceSingleStep(dbger.pid)
		})
		if _, err = dbger.wait(); err != nil {
			return err
		}
	}

	return nil
}

func (dbger *TypeDbg) formatPtraceError(operation string, err error) error {
	switch err {
	case unix.ESRCH:
		return fmt.Errorf("%s failed: process %d does not exist or exited", operation, dbger.pid)
	case unix.EPERM:
		return fmt.Errorf("%s failed: permission denied", operation)
	case unix.EBUSY:
		return fmt.Errorf("%s failed: process is busy", operation)
	default:
		return fmt.Errorf("%s failed: %v", operation, err)
	}
}

func (dbger *TypeDbg) GetProcMaps() []*proc {
	return procMapsDetail
}

func (dbger *TypeDbg) DisassOne(addr uintptr) (*string, error) {
	return dbger.disassOne(addr)
}

func (dbger *TypeDbg) IsActive() bool {
	return dbger.isStart && dbger.isProcessAlive()
}

func (dbger *TypeDbg) Kill() error {
	if dbger.pid <= 0 {
		return nil
	}

	// Kill the process if it's still alive
	if dbger.isProcessAlive() {
		err := doSyscallErr(dbger.rpc, func() error {
			return unix.Kill(dbger.pid, unix.SIGKILL)
		})
		if err != nil {
			return fmt.Errorf("failed to kill process: %v", err)
		}

		// Wait for process to exit
		doSyscallErr(dbger.rpc, func() error {
			unix.Wait4(dbger.pid, nil, 0, nil)
			return nil
		})
	}

	// Close the RPC goroutine
	if dbger.rpc != nil {
		dbger.rpc.closeSyscall()
		dbger.rpc = nil
	}

	dbger.isStart = false
	dbger.pid = 0

	return nil
}

```

`dbgInterface.go`:

```go
package main

type Debugger interface {
	GetMemory(size uint, addr uintptr) ([]byte, error)
	SetMemory(data []byte, addr uintptr) error
	GetRip() (uint64, error)
	SetRip(rip uint64) error
	Continue() error
	Step() error
	SetBreakpoint(addr uintptr) error
	RemoveBreakpoint(addr uintptr) error
	ResolveAddrToSymbol(addr uint64) (*Symbol, uint64, error)
	GetProcMaps() []*proc
	DisassOne(addr uintptr) (*string, error)
	IsActive() bool
}

```

`disass.go`:

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
	"unsafe"
)

/*

#cgo pkg-config: capstone
#include <capstone/capstone.h>

char* get_mnemonic(cs_insn* insn) { return insn->mnemonic; }
char* get_op_str(cs_insn* insn) { return insn->op_str; }
uint64_t get_address(cs_insn* insn) { return insn->address; }
uint16_t get_size(cs_insn* insn) { return insn->size; }
*/
import "C"

func (dbger *TypeDbg) disass(addr uint64, sz uint) {
	code, ok := func() ([]byte, bool) {
		for _, b := range Bps {
			if uint64(b.addr) == addr && b.isEnable {
				code, _ := dbger.GetMemory(sz, uintptr(addr))
				copy(code, b.instr)
				return code, true
			}
		}
		return nil, false
	}()

	var err error = nil
	if !ok {
		code, err = dbger.GetMemory(32, uintptr(addr))
	}

	if err != nil {
		Printf("Error reading memory at 0x%016x: %v\n", addr, err)
		return
	}

	var handle C.csh
	var insn *C.cs_insn
	ret := C.cs_open(C.CS_ARCH_X86, C.CS_MODE_64, &handle)
	if ret != C.CS_ERR_OK {
		Printf("Failed to open capstone engine: %d\n", ret)
		return
	}

	defer C.cs_close(&handle)

	count := C.cs_disasm(handle, (*C.uint8_t)(unsafe.Pointer(&code[0])), C.size_t(len(code)), C.uint64_t(addr), 0, &insn)
	if count == 0 {
		Printf("Failed to disassemble instruction at address 0x%016x\n", addr)
		return
	}

	defer C.cs_free(insn, count)

	instructions := (*[1000]C.cs_insn)(unsafe.Pointer(insn))[:count]
	for i := 0; i < int(count); i++ {
		inst := &instructions[i]
		mnemonic := C.get_mnemonic(inst)
		op_str := C.get_op_str(inst)

		if mnemonic == nil {
			Printf("0x%016x: <invalid mnemonic>\n", C.get_address(inst))
			continue
		}

		mnemonic_str := C.GoString(mnemonic)
		op_str_go := ""
		if op_str != nil {
			op_str_go = C.GoString(op_str)
		}

		if op_str_go != "" {
			v, err := strconv.ParseUint(op_str_go, 0, 64)
			if err != nil {
				fmt.Printf("%s0x%016x%s: %s%s %s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, op_str_go, ColorReset)
			} else {
				fmt.Printf("%s0x%016x%s: %s%s %s%s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, op_str_go, dbger.addr2some(v), ColorReset)
			}
		} else {
			fmt.Printf("%s0x%016x%s: %s%s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, ColorReset)
		}
	}
}

func (dbger *TypeDbg) disassOne(addr uintptr) (*string, error) {
	code, ok := func() ([]byte, bool) {
		for _, b := range Bps {
			if uint64(b.addr) == uint64(addr) && b.isEnable {
				code, err := dbger.GetMemory(8, addr)
				if err != nil {
					return nil, false
				}
				if len(b.instr) > 0 {
					copy(code, b.instr)
				}
				return code, true
			}
		}
		return nil, false
	}()

	var err error
	if !ok {
		code, err = dbger.GetMemory(8, addr)
		if err != nil {
			return nil, err
		}
	}

	var handle C.csh
	var insn *C.cs_insn

	ret := C.cs_open(C.CS_ARCH_X86, C.CS_MODE_64, &handle)
	if ret != C.CS_ERR_OK {
		return nil, fmt.Errorf("failed to open capstone engine: %d", ret)
	}

	defer C.cs_close(&handle)

	count := C.cs_disasm(handle, (*C.uint8_t)(unsafe.Pointer(&code[0])), C.size_t(len(code)), C.uint64_t(addr), 0, &insn)

	if count == 0 {
		return nil, fmt.Errorf("failed to disassemble instruction at address 0x%x", addr)
	}

	defer C.cs_free(insn, count)

	instructions := (*[1000]C.cs_insn)(unsafe.Pointer(insn))[:count]
	if len(instructions) == 0 {
		return nil, fmt.Errorf("no instructions disassembled")
	}

	inst := &instructions[0]
	mnemonic := C.get_mnemonic(inst)
	op_str := C.get_op_str(inst)

	if mnemonic == nil {
		return nil, fmt.Errorf("failed to get mnemonic")
	}

	ret_str := C.GoString(mnemonic)
	if op_str != nil {
		op_str_go := C.GoString(op_str)
		if op_str_go != "" {
			v, err := strconv.ParseUint(op_str_go, 0, 64)
			if err != nil {
				ret_str = fmt.Sprintf("%s %s", ret_str, op_str_go)
			} else {
				ret_str = fmt.Sprintf("%s %s%s", ret_str, op_str_go, dbger.addr2some(v))
			}
		}
	}

	return &ret_str, nil
}

func (dbger *TypeDbg) disass2ret(addr uint64) {
	currentAddr := addr

	for {
		code, ok := func() ([]byte, bool) {
			for _, b := range Bps {
				if uint64(b.addr) == currentAddr && b.isEnable {
					code, err := dbger.GetMemory(16, uintptr(currentAddr))
					if err != nil {
						return nil, false
					}
					if len(b.instr) > 0 {
						copy(code, b.instr)
					}
					return code, true
				}
			}
			return nil, false
		}()

		var err error
		if !ok {
			code, err = dbger.GetMemory(16, uintptr(currentAddr))
			if err != nil {
				Printf("Error reading memory at 0x%016x: %v\n", currentAddr, err)
				return
			}
		}

		var handle C.csh
		var insn *C.cs_insn
		ret := C.cs_open(C.CS_ARCH_X86, C.CS_MODE_64, &handle)
		if ret != C.CS_ERR_OK {
			Printf("Failed to open capstone engine: %d\n", ret)
			return
		}

		count := C.cs_disasm(handle, (*C.uint8_t)(unsafe.Pointer(&code[0])), C.size_t(len(code)), C.uint64_t(currentAddr), 1, &insn)
		if count == 0 {
			Printf("Failed to disassemble instruction at address 0x%016x\n", currentAddr)
			C.cs_close(&handle)
			return
		}

		instructions := (*[1000]C.cs_insn)(unsafe.Pointer(insn))[:count]
		inst := &instructions[0]

		mnemonic := C.get_mnemonic(inst)
		op_str := C.get_op_str(inst)

		if mnemonic == nil {
			Printf("0x%016x: <invalid mnemonic>\n", C.get_address(inst))
			C.cs_free(insn, count)
			C.cs_close(&handle)
			return
		}

		mnemonic_str := C.GoString(mnemonic)
		op_str_go := ""
		if op_str != nil {
			op_str_go = C.GoString(op_str)
		}

		if op_str_go != "" {
			v, err := strconv.ParseUint(op_str_go, 0, 64)
			if err != nil {
				fmt.Printf("%s0x%016x%s: %s%s %s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, op_str_go, ColorReset)
			} else {
				fmt.Printf("%s0x%016x%s: %s%s %s%s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, op_str_go, dbger.addr2some(v), ColorReset)
			}
		} else {
			fmt.Printf("%s0x%016x%s: %s%s%s\n", ColorBlue, C.get_address(inst), ColorReset, ColorPurple, mnemonic_str, ColorReset)
		}

		isRet := strings.HasPrefix(mnemonic_str, "ret")

		instSize := uint64(C.get_size(inst))

		C.cs_free(insn, count)
		C.cs_close(&handle)
		if isRet {
			break
		}

		currentAddr += instSize

		if instSize == 0 {
			Printf("Warning: instruction at 0x%016x has size 0, stopping disassembly\n", currentAddr-instSize)
			break
		}
	}
}

```

`docs/commands.md`:

```md
# FastDBG Commands

## break
`^\s*(b|break|B|BREAK)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## break pie
`^\s*(b|break|B|BREAK)\s+(pie|PIE)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## watch
`^\s*(watch)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(1|2|4|8))?(?:\s+(write|read|exec))?$`
## unwatch
`^\s*(unwatch|uwch)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## winfo
`^\s*(winfo|watchinfo)\s*$`
## enable_watch
`^\s*(enable_watch|ewch)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## disable_watch
`^\s*(disable_watch|dwch)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## enable
`^\s*(enable)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## disable
`^\s*(disable)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## disass
`^\s*(disass)(\s+(0[xx][0-9a-fa-f]+|0[0-7]+|[1-9][0-9]*|0))?(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## stackframe
`^\s*(stackframe|stkf|STACKFRAME|STKF)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## print
`^\s*(p|print|P|PRINT)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## run
`^\s*(r|run|R|RUN)(?:\s+(.+))?$`
## start
`^\s*(s|start|S|START)(?:\s+(.+))?$`
## regs
`^\s*(regs)(?:\s+(.+))?$`
## command
`^\s*(!)(.+)$`
## continue
`^\s*(c|continue|cont|C|CONTINUE|CONT)\s*$`
## step
`^\s*(step|STEP)\s*$`
## context
`^\s*(context|CONTEXT)\s*$`
## color
`^\s*(color|COLOR)\s*$`
## stack
`^\s*(stack|stk|STACK|STK)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## vmmap
`^\s*(vmmap|VMMAP)(\s+\w+)*\s*$`
## sym
`^\s*(sym|symbol|SYM|SYMBOL)(\s+\w+)*\s*$`
## got
`^\s*(got|GOT)\s*$`
## bins
`^\s*(bins|BINS)\s*$`
## fs_base
`^\s*(fs|fs_base)\s*$`
## visual-heap
`^\s*(vis|visual-heap|VIS|VISUAL-HEAP)\s*$`
## set32
`^\s*(set32)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## set16
`^\s*(set16)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## set8
`^\s*(set8)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## set
`^\s*(set)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## xor
`^\s*(xor)\s+(\S+)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`
## telescope
`^\s*(tel|telescope)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## xxd
`^\s*(db|xxd)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## xxd dword
`^\s*(dd|xxd\s+dword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## xxd qword
`^\s*(dq|xxd\s+qword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`
## backtrace
`^\s*(bt|backtrace|BT|BACKTRACE)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`

```

`dump.go`:

```go
package main

import (
	"encoding/binary"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"time"
	"unsafe"
)

func (dbger *TypeDbg) cmdDumpByte(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 64
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := dbger.GetMemory(uint(n), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%016x: ", addr+uint64(i))

		for j := 0; j < 16; j++ {
			if i+j < len(data) {
				fmt.Printf("%02x ", data[i+j])
			} else {
				fmt.Printf("   ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

func (dbger *TypeDbg) cmdDumpDword(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 16
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := dbger.GetMemory(uint(n*4), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%016x: ", addr+uint64(i))

		for j := 0; j < 16; j += 4 {
			if len(data)-(i+j) >= 4 {
				fmt.Printf("0x%08x ", binary.LittleEndian.Uint32(data[i+j:i+j+4]))
			} else {
				fmt.Printf("           ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

func (dbger *TypeDbg) cmdDumpQword(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 8
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := dbger.GetMemory(uint(n*8), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%016x: ", addr+uint64(i))

		for j := 0; j < 16; j += 8 {
			if len(data)-(i+j) >= 8 {
				fmt.Printf("0x%016x ", binary.LittleEndian.Uint64(data[i+j:i+j+8]))
			} else {
				fmt.Printf("                   ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

var maxDeps int = 0

func (dbger *TypeDbg) addr2some(addr uint64) string {
	var ret string
	sym, off, err := dbger.ResolveAddrToSymbol(addr)
	color := dbger.addr2color(addr)
	if err == nil {
		if off == 0 {
			ret += fmt.Sprintf("%s<%s>%s", color, sym.Name, ColorReset)
		} else {
			ret += fmt.Sprintf("%s<%s+0x%x>%s", color, sym.Name, off, ColorReset)
		}
	}
	if color == ColorExecutable || color == ColorReadWriteExecutable || color == ColorReadExecutable {
		instr, err := dbger.disassOne(uintptr(addr))
		if err == nil {
			ret += fmt.Sprintf("%s->%s%s%s", ColorReset, color, *instr, ColorReset)
		}
	} else {
		code, err := dbger.GetMemory(8, uintptr(addr))
		if err == nil {
			ok := func() bool {
				nonZero := false
				for _, c := range code {
					if c == 0 {
						continue
					}
					nonZero = true
					if c < 0x20 || c > 0x7e {
						return false
					}
				}

				return nonZero
			}()
			if ok {
				ret += fmt.Sprintf("%s->%s\"%s\"%s", ColorReset, color, string(code), ColorReset)
			} else {
				newAddr := binary.LittleEndian.Uint64(code)
				ret += fmt.Sprintf("%s->%s0x%016x%s", ColorReset, dbger.addr2color(newAddr), newAddr, ColorReset)
				if maxDeps < 4 {
					ret += dbger.addr2some(newAddr)
					maxDeps++
				}
			}
		}
	}
	maxDeps = 0
	return ret
}

const (
	ColorReadWriteExecutable = ColorYellow
	ColorReadExecutable      = ColorRed
	ColorReadWrite           = ColorCyan
	ColorExecutable          = ColorPurple
	ColorRead                = ColorBlue
	ColorWrite               = ColorGreen
	ColorDefault             = ColorReset
)

func (dbger *TypeDbg) addr2color(addr uint64) string {
	idx := sort.Search(len(procMapsDetail), func(i int) bool {
		return procMapsDetail[i].end > addr
	})
	if idx < len(procMapsDetail) &&
		addr >= procMapsDetail[idx].start &&
		addr < procMapsDetail[idx].end {
		p := procMapsDetail[idx]
		if p.r && p.w && p.x {
			return ColorReadWriteExecutable // rwx
		}
		if p.r && p.w && !p.x {
			return ColorReadWrite // rw
		}
		if p.x {
			return ColorExecutable // x (with or without r)
		}
		if p.r && !p.w && !p.x {
			return ColorRead // r only
		}
		if p.w && !p.r && !p.x {
			return ColorWrite // w only
		}
		return ColorDefault
	}
	return ColorDefault
}

func (dbger *TypeDbg) cmdTelescope(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 0x80
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	tempFile := fmt.Sprintf("/tmp/fastDbg_%d_%d", os.Getpid(), time.Now().Unix())
	file, err := os.Create(tempFile)
	if err != nil {
		return err
	}

	defer func() {
		file.Close()
		os.Remove(tempFile)
	}()

	code, err := dbger.GetMemory(uint(n*8), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(code); i += 8 {
		if i+8 <= len(code) {
			address := binary.LittleEndian.Uint64(code[i : i+8])
			var addrInfo string
			sym, off, err := dbger.ResolveAddrToSymbol(address)
			color := dbger.addr2color(address)
			if err == nil {
				if off == 0 {
					addrInfo = fmt.Sprintf("%s<%s>%s", color, sym.Name, ColorReset)
				} else {
					addrInfo = fmt.Sprintf("%s<%s+0x%x>%s", color, sym.Name, off, ColorReset)
				}
			}

			fmt.Fprintf(file, "%s0x%016x%s:+0x%03x(+0x%02x)|%s0x%016x%s%s\n",
				ColorBlue, addr+uint64(i), ColorReset, i, i/8, color,
				address, addrInfo, ColorReset)
		}
	}
	file.Close()

	cmd := exec.Command("less", "-SR", tempFile)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return err
	}

	return nil
}

const tcacheMaxBins = 64

type tcachePerThreadStruct struct {
	counts  [tcacheMaxBins]uint16
	entries [tcacheMaxBins]uint64
}

const (
	stateTrue = iota
	stateFalse
	stateUndefined
)

func (dbger *TypeDbg) cmdVisualHeap(_ interface{}) error {
	addr, sz, ok := func() (uint64, uint64, bool) {
		for _, p := range procMapsDetail {
			if strings.Contains(p.path, "heap") {
				return p.start, p.end - p.start, true
			}
		}
		return 0, 0, false
	}()
	if !ok {
		return errors.New("heap not found")
	}

	code, err := dbger.GetMemory(uint(sz), uintptr(addr))
	if err != nil {
		return err
	}

	tempFile := fmt.Sprintf("/tmp/fastDbg_%d_%d", os.Getpid(), time.Now().Unix())
	file, err := os.Create(tempFile)
	if err != nil {
		return err
	}

	defer func() {
		file.Close()
		os.Remove(tempFile)
	}()

	isSafeLinking := stateUndefined
	// tcache
	tmap := func() *map[uint64]string {
		ret := make(map[uint64]string)
		if len(code) > tcacheMaxBins*2+tcacheMaxBins*8+0x10 {
			tpts := (*tcachePerThreadStruct)(unsafe.Pointer(&code[0x10]))
			for i, e := range tpts.entries {
				if e == 0 {
					continue
				}
				ret[e] = fmt.Sprintf("tcache[sz=0x%x][1/%d]", 0x20+0x10*i, tpts.counts[i])
				var curr uint64 = e
				for j := range tpts.counts[i] - 1 {
					tmp := binary.LittleEndian.Uint64(code[curr-addr : curr-addr+8])
					if isSafeLinking == stateUndefined {
						if tmp%0x10 != 0 {
							isSafeLinking = stateTrue
						} else {
							isSafeLinking = stateFalse
						}
					}
					if isSafeLinking == stateTrue {
						curr = tmp ^ (curr >> 12)
					} else {
						curr = tmp
					}
					ret[curr] = fmt.Sprintf("tcache[sz=0x%x][%d/%d]", 0x20+0x10*i, 2+j, tpts.counts[i])
					if curr == 0 || curr-addr > uint64(len(code)) {
						break
					}
				}
			}
		}

		return &ret
	}()

	var c int = 0
	for i := uint64(0); i < uint64(len(code)); {
		chkSz := binary.LittleEndian.Uint64(code[i+8 : i+16])
		chkSz = chkSz & 0xfffffffffffffff8
		color := colorArray[c%len(colorArray)]
		var zeroFlag bool = false
		var zeroSz int = 0
		for j := uint64(0); j < chkSz; j += 0x10 {
			if i+j+0x10 < uint64(len(code)) {
				v1 := binary.LittleEndian.Uint64(code[i+j : i+j+8])
				v2 := binary.LittleEndian.Uint64(code[i+j+8 : i+j+8+8])
				if zeroFlag {
					zeroSz += 0x10
				}
				if v1 == 0 && v2 == 0 {
					if zeroFlag && j+0x10 == chkSz {
						fmt.Fprintf(file, "%s[repeat 0 for +0x%x times]%s\n", color, zeroSz, ColorReset)
					} else {
						zeroFlag = true
					}
				} else {
					if zeroFlag && zeroSz >= 0x10 {
						fmt.Fprintf(file, "%s[repeat 0 for +0x%x times]%s\n", color, zeroSz, ColorReset)
					}
					zeroSz = 0
					zeroFlag = false
				}
				if zeroSz < 0x10 {
					str, ok := (*tmap)[addr+i+j]
					fmt.Fprintf(file, "%s0x%016x|+0x%05x|+0x%05x: 0x%016x 0x%016x | ", color, addr+i+j, j, i+j, v1, v2)
					for k := range uint64(0x10) {
						b := code[i+j+k]
						if b >= 32 && b <= 126 {
							fmt.Fprintf(file, "%c", b)
						} else {
							fmt.Fprintf(file, ".")
						}
					}
					if ok {
						fmt.Fprintf(file, " | <- %s%s\n", str, ColorReset)
					} else {
						fmt.Fprintf(file, " |%s\n", ColorReset)
					}
				}
			}
		}
		i += chkSz
		c++
	}

	file.Close()

	cmd := exec.Command("less", "-SR", tempFile)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return err
	}

	return nil
}

func (dbger *TypeDbg) cmdBins(_ interface{}) error {
	hLine("tcache")
	addr, sz, ok := func() (uint64, uint64, bool) {
		for _, p := range procMapsDetail {
			if strings.Contains(p.path, "heap") {
				return p.start, p.end - p.start, true
			}
		}
		return 0, 0, false
	}()
	if !ok {
		return errors.New("heap not found")
	}

	code, err := dbger.GetMemory(uint(sz), uintptr(addr))
	if err != nil {
		return err
	}
	isSafeLinking := stateUndefined
	if len(code) > tcacheMaxBins*2+tcacheMaxBins*8+0x10 {
		tpts := (*tcachePerThreadStruct)(unsafe.Pointer(&code[0x10]))
		for i, e := range tpts.entries {
			if e == 0 {
				continue
			}
			fmt.Printf("tcache[sz=%s0x%x%s][n=%s%d%s]\n", ColorCyan, 0x20+0x10*i, ColorReset, ColorCyan, tpts.counts[i], ColorReset)
			fmt.Printf("%s0x%x%s -> ", ColorCyan, e, ColorReset)
			var curr uint64 = e
			for _ = range tpts.counts[i] - 1 {
				tmp := binary.LittleEndian.Uint64(code[curr-addr : curr-addr+8])
				if isSafeLinking == stateUndefined {
					if tmp%0x10 != 0 {
						isSafeLinking = stateTrue
					} else {
						isSafeLinking = stateFalse
					}
				}
				if isSafeLinking == stateTrue {
					curr = tmp ^ (curr >> 12)
				} else {
					curr = tmp
				}
				fmt.Printf("%s0x%x%s -> ", ColorCyan, curr, ColorReset)
				if curr == 0 || curr-addr > uint64(len(code)) {
					break
				}
			}
		}
	}

	return nil
}

```

`ebpf/ebpf.go`:

```go
package ebpf

/*
#cgo LDFLAGS: -lbpf -lelf -lz
#include <stdlib.h>
#include <string.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>

struct event {
    unsigned int pid;
    unsigned long long syscall;
};

void handleEvent(void *ctx, int cpu, void *data, unsigned int size);
void handleLost(void *ctx, int cpu, unsigned long long lost_cnt);
*/
import "C"

import (
	"fmt"
	"golang.org/x/sys/unix"
	"sync"
	"sync/atomic"
	"unsafe"
)

var MapFlag bool = false
var tracerRegistry sync.Map
var nextTracerID atomic.Int64

type Tracer struct {
	id    int64
	pid   int
	obj   *C.struct_bpf_object
	links []*C.struct_bpf_link
	pb    *C.struct_perf_buffer
	stop  chan struct{}
	wg    sync.WaitGroup
}

//export handleEvent
func handleEvent(ctx unsafe.Pointer, cpu C.int, data unsafe.Pointer, size C.uint) {
	tracerID := int64(uintptr(ctx))

	val, ok := tracerRegistry.Load(tracerID)
	if !ok {
		return
	}
	t := val.(*Tracer)

	event := (*C.struct_event)(data)

	if int(event.pid) == t.pid {
		syscallNum := uint64(event.syscall)
		if syscallNum == unix.SYS_MMAP || syscallNum == unix.SYS_BRK || syscallNum == unix.SYS_MUNMAP {
			MapFlag = true
		}
	}
}

//export handleLost
func handleLost(ctx unsafe.Pointer, cpu C.int, lostCnt C.ulonglong) {
	fmt.Printf("Lost %d events on CPU %d\n", lostCnt, cpu)
}

func NewTrace(pid int) (*Tracer, error) {
	t := &Tracer{
		id:   nextTracerID.Add(1),
		pid:  pid,
		stop: make(chan struct{}),
	}

	tracerRegistry.Store(t.id, t)

	objPath := C.CString("trace.ebpf.o")
	defer C.free(unsafe.Pointer(objPath))

	t.obj = C.bpf_object__open(objPath)
	if t.obj == nil {
		tracerRegistry.Delete(t.id)
		return nil, fmt.Errorf("failed to open BPF object")
	}

	if C.bpf_object__load(t.obj) != 0 {
		C.bpf_object__close(t.obj)
		tracerRegistry.Delete(t.id)
		return nil, fmt.Errorf("failed to load BPF object")
	}

	progMmapName := C.CString("trace_mmap")
	progBrkName := C.CString("trace_brk")
	defer C.free(unsafe.Pointer(progMmapName))
	defer C.free(unsafe.Pointer(progBrkName))

	progMmap := C.bpf_object__find_program_by_name(t.obj, progMmapName)
	progBrk := C.bpf_object__find_program_by_name(t.obj, progBrkName)

	if progMmap == nil || progBrk == nil {
		t.Close()
		return nil, fmt.Errorf("failed to find BPF programs")
	}

	linkMmap := C.bpf_program__attach(progMmap)
	if linkMmap == nil {
		t.Close()
		return nil, fmt.Errorf("failed to attach trace_mmap program")
	}
	t.links = append(t.links, linkMmap)

	linkBrk := C.bpf_program__attach(progBrk)
	if linkBrk == nil {
		t.Close()
		return nil, fmt.Errorf("failed to attach trace_brk program")
	}
	t.links = append(t.links, linkBrk)

	eventsMapName := C.CString("events")
	defer C.free(unsafe.Pointer(eventsMapName))

	eventsMap := C.bpf_object__find_map_by_name(t.obj, eventsMapName)
	if eventsMap == nil {
		t.Close()
		return nil, fmt.Errorf("failed to find events map")
	}
	mapFd := C.bpf_map__fd(eventsMap)

	ctx := unsafe.Pointer(uintptr(t.id))

	t.pb = C.perf_buffer__new(
		mapFd,
		8,
		C.perf_buffer_sample_fn(unsafe.Pointer(C.handleEvent)),
		C.perf_buffer_lost_fn(unsafe.Pointer(C.handleLost)),
		ctx,
		nil,
	)
	if t.pb == nil {
		t.Close()
		return nil, fmt.Errorf("failed to create perf buffer")
	}

	t.wg.Add(1)
	go t.pollLoop()

	return t, nil
}

func (t *Tracer) pollLoop() {
	defer t.wg.Done()

	for {
		select {
		case <-t.stop:
			return
		default:
			ret := C.perf_buffer__poll(t.pb, 100)
			if ret < 0 && ret != -4 {
				fmt.Printf("Error polling perf buffer: %d\n", ret)
			}
		}
	}
}

func (t *Tracer) Close() {
	close(t.stop)
	t.wg.Wait()
	tracerRegistry.Delete(t.id)

	if t.pb != nil {
		C.perf_buffer__free(t.pb)
	}

	for _, link := range t.links {
		if link != nil {
			C.bpf_link__destroy(link)
		}
	}

	if t.obj != nil {
		C.bpf_object__close(t.obj)
	}
}

func ResetFlag() {
	MapFlag = false
}

```

`ebpf/trace.ebpf.c`:

```c

#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(int));
    __uint(value_size, sizeof(int));
} events SEC(".maps");

struct event {
    __u32 pid;
    __u64 syscall; // 9=mmap, 12=brk
};

SEC("tracepoint/syscalls/sys_enter_mmap")
int trace_mmap(void *ctx) {
    struct event e = {
        .pid = bpf_get_current_pid_tgid() >> 32,
        .syscall = 9
    };
    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &e, sizeof(e));
    return 0;
}

SEC("tracepoint/syscalls/sys_enter_brk")
int trace_brk(void *ctx) {
    struct event e = {
        .pid = bpf_get_current_pid_tgid() >> 32,
        .syscall = 12
    };
    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &e, sizeof(e));
    return 0;
}

char LICENSE[] SEC("license") = "GPL";

```

`go.mod`:

```mod
module fastDbg

go 1.25rc2

require (
	github.com/chzyer/readline v1.5.1 // indirect
	github.com/common-nighthawk/go-figure v0.0.0-20210622060536-734e95fb86be // indirect
	github.com/manifoldco/promptui v0.9.0 // indirect
	golang.org/x/arch v0.20.0 // indirect
	golang.org/x/sys v0.35.0 // indirect
	golang.org/x/term v0.34.0 // indirect
)

```

`go.sum`:

```sum
github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
github.com/chzyer/logex v1.2.1/go.mod h1:JLbx6lG2kDbNRFnfkgvh4eRJRPX1QCoOIWomwysCBrQ=
github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e h1:fY5BOSpyZCqRo5OhCuC+XN+r/bBCmeuuJtjz+bCNIf8=
github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
github.com/chzyer/readline v1.5.1 h1:upd/6fQk4src78LMRzh5vItIt361/o4uq553V8B5sGI=
github.com/chzyer/readline v1.5.1/go.mod h1:Eh+b79XXUwfKfcPLepksvw2tcLE/Ct21YObkaSkeBlk=
github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
github.com/chzyer/test v1.0.0/go.mod h1:2JlltgoNkt4TW/z9V/IzDdFaMTM2JPIi26O1pF38GC8=
github.com/common-nighthawk/go-figure v0.0.0-20210622060536-734e95fb86be h1:J5BL2kskAlV9ckgEsNQXscjIaLiOYiZ75d4e94E6dcQ=
github.com/common-nighthawk/go-figure v0.0.0-20210622060536-734e95fb86be/go.mod h1:mk5IQ+Y0ZeO87b858TlA645sVcEcbiX6YqP98kt+7+w=
github.com/manifoldco/promptui v0.9.0 h1:3V4HzJk1TtXW1MTZMP7mdlwbBpIinw3HztaIlYthEiA=
github.com/manifoldco/promptui v0.9.0/go.mod h1:ka04sppxSGFAtxX0qhlYQjISsg9mR4GWtQEhdbn6Pgg=
golang.org/x/arch v0.20.0 h1:dx1zTU0MAE98U+TQ8BLl7XsJbgze2WnNKF/8tGp/Q6c=
golang.org/x/arch v0.20.0/go.mod h1:bdwinDaKcfZUGpH09BB7ZmOfhalA8lQdzl62l8gGWsk=
golang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20220310020820-b874c991c1a5/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.34.0 h1:O/2T7POpk0ZZ7MAzMeWFSg6S5IpWd/RXDlM9hgM3DR4=
golang.org/x/term v0.34.0/go.mod h1:5jC53AEywhIVebHgPVeg0mj8OD3VO9OzclacVrqpaAw=

```

`main.go`:

```go
package main

import (
	"fastDbg/qemu"
	"flag"
	"fmt"
	"github.com/common-nighthawk/go-figure"
	"os"
)

func main() {
	fn := flag.String("f", "", "filename for userland debugging")
	pid := flag.Int("p", 0, "process id for attaching")
	qemuMode := flag.Bool("qemu", false, "enable QEMU kernel debugging mode")
	qemuHost := flag.String("qemu-host", "localhost", "QEMU GDB server host")
	qemuPort := flag.Int("qemu-port", 12345, "QEMU GDB server port")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [OPTIONS]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\nUserland Debugging:\n")
		fmt.Fprintf(os.Stderr, "  -f <file>    Debug executable file\n")
		fmt.Fprintf(os.Stderr, "  -p <pid>     Attach to running process\n")
		fmt.Fprintf(os.Stderr, "\nKernel Debugging (QEMU):\n")
		fmt.Fprintf(os.Stderr, "  -qemu              Enable QEMU kernel debugging\n")
		fmt.Fprintf(os.Stderr, "  -qemu-host <host>  QEMU GDB server host (default: localhost)\n")
		fmt.Fprintf(os.Stderr, "  -qemu-port <port>  QEMU GDB server port (default: 12345)\n")
	}

	flag.Parse()

	fig := figure.NewFigure("fastDbg", "isometric1", true)
	fig.Print()

	if *qemuMode {
		qdbg, err := qemu.Connect(*qemuHost, *qemuPort)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to connect to QEMU: %v\n", err)
			os.Exit(1)
		}
		defer qdbg.Close()

		qdbg.Interactive()
		return
	}

	if (*fn == "" && *pid == 0) || (*fn != "" && *pid != 0) {
		fmt.Fprintf(os.Stderr, "Error: Must specify either -f <file> OR -p <pid> OR -qemu\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if *fn != "" {
		mainDbger.path = *fn
		mainDbger.Interactive(false)
	}

	if *pid != 0 {
		dbger, err := Attach(*pid)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error attaching pid %d: %s\n", *pid, err)
			os.Exit(1)
		}
		mainDbger = *dbger

		mainDbger.Interactive(true)
	}

	return
}

```

`mem.go`:

```go
package main

import (
	"golang.org/x/sys/unix"
)

func (dbger *TypeDbg) GetMemory(n uint, addr uintptr) ([]byte, error) {
	return doSyscall(dbger.rpc, func() ([]byte, error) {
		mem := make([]byte, n)
		count, err := unix.PtracePeekData(dbger.pid, addr, mem)
		if err != nil {
			return nil, err
		}
		if uint(count) != n {
			Printf("cannot read 0x%016x", uint64(addr)+uint64(count))
		}
		return mem, nil
	})
}

func (dbger *TypeDbg) SetMemory(data []byte, addr uintptr) error {
	_, err := doSyscall(dbger.rpc, func() (struct{}, error) {
		count, err := unix.PtracePokeData(dbger.pid, addr, data)
		if err != nil {
			return struct{}{}, err
		}
		if count != len(data) {
			Printf("cannot write 0x%016x", uint64(addr)+uint64(count))
		}
		return struct{}{}, nil
	})

	return err
}

```

`ptrace.go`:

```go
package main

import (
	"fmt"
	"runtime"
)

type anyResp struct {
	v   any
	err error
}

type anyReq struct {
	run  func() (any, error)
	resp chan anyResp
}

type doSysRPC struct {
	req  chan anyReq
	done chan struct{}
}

func doSyscallWorker() *doSysRPC {
	r := &doSysRPC{
		req:  make(chan anyReq),
		done: make(chan struct{}),
	}

	go func() {
		runtime.LockOSThread()
		defer runtime.UnlockOSThread()
		defer close(r.done)

		for q := range r.req {
			var out any
			var err error
			func() {
				defer func() {
					if x := recover(); x != nil {
						err = fmt.Errorf("%v", x)
					}
				}()
				out, err = q.run()
			}()
			q.resp <- anyResp{out, err}
			close(q.resp)
		}
	}()

	return r
}

func (r *doSysRPC) closeSyscall() {
	close(r.req)
	<-r.done
}

func doSyscall[T any](r *doSysRPC, fn func() (T, error)) (T, error) {
	resp := make(chan anyResp, 1)
	r.req <- anyReq{
		run:  func() (any, error) { v, err := fn(); return v, err },
		resp: resp,
	}
	r0 := <-resp
	if r0.err != nil {
		var zero T
		return zero, r0.err
	}
	return r0.v.(T), nil
}

func doSyscallErr(r *doSysRPC, fn func() error) error {
	_, err := doSyscall[struct{}](r, func() (struct{}, error) {
		if err := fn(); err != nil {
			return struct{}{}, err
		}
		return struct{}{}, nil
	})
	return err
}

```

`qemu/cmd.go`:

```go
package qemu

import (
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/chzyer/readline"
	"golang.org/x/term"
	"io"
	"os"
	"os/exec"
	"os/signal"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"
)

type cmdHandler struct {
	regex *regexp.Regexp
	fn    func(*QemuDbg, interface{}) error
}

var compiledCmds = []cmdHandler{
	{regexp.MustCompile(`^\s*(b|break|B|BREAK)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdBreak},
	{regexp.MustCompile(`^\s*(p|print|P|PRINT)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdPrint},
	{regexp.MustCompile(`^\s*(db|xxd)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdXxd},
	{regexp.MustCompile(`^\s*(dd|xxd\s+dword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdXxdDword},
	{regexp.MustCompile(`^\s*(dq|xxd\s+qword)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdXxdQword},
	{regexp.MustCompile(`^\s*(disass)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdDisass},
	{regexp.MustCompile(`^\s*(set)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdSet},
	{regexp.MustCompile(`^\s*(set32)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdSet32},
	{regexp.MustCompile(`^\s*(set16)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdSet16},
	{regexp.MustCompile(`^\s*(set8)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)$`), (*QemuDbg).cmdSet8},
	{regexp.MustCompile(`^\s*(tel|telescope)\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdTelescope},
	{regexp.MustCompile(`^\s*(stack|stk|STACK|STK)(\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdStack},
	{regexp.MustCompile(`^\s*(bt|backtrace|BT|BACKTRACE)(?:\s+(0[xX][0-9a-fA-F]+|0[0-7]+|[1-9][0-9]*|0))?$`), (*QemuDbg).cmdBacktrace},
	{regexp.MustCompile(`^\s*(regs|registers)$`), (*QemuDbg).cmdRegs},
	{regexp.MustCompile(`^\s*(c|continue|cont|C|CONTINUE|CONT)\s*$`), (*QemuDbg).cmdContinue},
	{regexp.MustCompile(`^\s*(step|STEP)\s*$`), (*QemuDbg).cmdStep},
	{regexp.MustCompile(`^\s*(context|CONTEXT)\s*$`), (*QemuDbg).cmdContext},
}

func (q *QemuDbg) CmdExec(req string) error {
	for _, handler := range compiledCmds {
		if m := handler.regex.FindStringSubmatch(req); m != nil {
			return handler.fn(q, m)
		}
	}
	return errors.New("unknown command")
}

const (
	ColorReset  = "\033[0m"
	ColorRed    = "\033[31m"
	ColorGreen  = "\033[32m"
	ColorYellow = "\033[33m"
	ColorBlue   = "\033[34m"
	ColorPurple = "\033[35m"
	ColorCyan   = "\033[36m"
	ColorWhite  = "\033[37m"
	ColorBold   = "\033[1m"
)

func LogError(msg string, a ...interface{}) {
	fmt.Printf("%s[ERROR]%s %s\n", ColorRed, ColorReset, fmt.Sprintf(msg, a...))
}

func Printf(msg string, a ...interface{}) {
	msg = strings.ReplaceAll(msg, "%d", "\033[36m%d\033[0m")
	msg = strings.ReplaceAll(msg, "0x%016x", "\033[36m0x%016x\033[0m")
	msg = strings.ReplaceAll(msg, "%016x", "\033[36m%016x\033[0m")
	msg = strings.ReplaceAll(msg, "%x", "\033[36m%x\033[0m")
	msg = strings.ReplaceAll(msg, "%s", "\033[32m%s\033[0m")
	fmt.Printf(msg, a...)
}

func cls() {
	fmt.Print("\033[2J")
	fmt.Print("\033[H")
}

func (q *QemuDbg) cmdBreak(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	err = q.SetBreakpoint(uintptr(addr))
	if err != nil {
		return err
	}

	fmt.Printf("Breakpoint set at %s0x%016x%s\n", ColorCyan, addr, ColorReset)
	return nil
}

func (q *QemuDbg) cmdPrint(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}
	val, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	fmt.Printf("HEX: %s0x%x%s DEC: %s%d%s OCT: %s%o%s BIN: %s%b%s\n",
		ColorCyan, val, ColorReset,
		ColorCyan, val, ColorReset,
		ColorCyan, val, ColorReset,
		ColorCyan, val, ColorReset)

	return nil
}

func (q *QemuDbg) cmdXxd(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 64
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := q.GetMemory(uint(n), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%s%016x%s: ", ColorBlue, addr+uint64(i), ColorReset)

		for j := 0; j < 16; j++ {
			if i+j < len(data) {
				fmt.Printf("%02x ", data[i+j])
			} else {
				fmt.Printf("   ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

func (q *QemuDbg) cmdXxdDword(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 16
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := q.GetMemory(uint(n*4), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%s%016x%s: ", ColorBlue, addr+uint64(i), ColorReset)

		for j := 0; j < 16; j += 4 {
			if len(data)-(i+j) >= 4 {
				fmt.Printf("%s0x%08x%s ", ColorCyan, binary.LittleEndian.Uint32(data[i+j:i+j+4]), ColorReset)
			} else {
				fmt.Printf("           ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

func (q *QemuDbg) cmdXxdQword(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 8
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := q.GetMemory(uint(n*8), uintptr(addr))
	if err != nil {
		return err
	}

	for i := 0; i < len(data); i += 16 {
		fmt.Printf("%s%016x%s: ", ColorBlue, addr+uint64(i), ColorReset)

		for j := 0; j < 16; j += 8 {
			if len(data)-(i+j) >= 8 {
				fmt.Printf("%s0x%016x%s ", ColorCyan, binary.LittleEndian.Uint64(data[i+j:i+j+8]), ColorReset)
			} else {
				fmt.Printf("                   ")
			}
		}

		fmt.Printf(" |")

		for j := 0; j < 16 && i+j < len(data); j++ {
			b := data[i+j]
			if b >= 32 && b <= 126 {
				fmt.Printf("%c", b)
			} else {
				fmt.Printf(".")
			}
		}

		fmt.Printf("|\n")
	}

	return nil
}

func (q *QemuDbg) cmdDisass(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var err error
	if len(args[2]) == 0 {
		addr, err = q.GetRip()
		if err != nil {
			return err
		}
	} else {
		addr, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	var sz uint64 = 32
	if args[4] != "" {
		sz, err = strconv.ParseUint(args[5], 0, 32)
		if err != nil {
			return err
		}
	}

	return q.disass(addr, uint(sz))
}

func (q *QemuDbg) cmdSet(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	val, err := strconv.ParseUint(args[3], 0, 64)
	if err != nil {
		return err
	}

	valBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(valBytes, val)

	err = q.SetMemory(valBytes, uintptr(addr))
	if err != nil {
		return err
	}

	fmt.Printf("Set %s0x%016x%s = %s0x%016x%s\n", ColorBlue, addr, ColorReset, ColorCyan, val, ColorReset)
	return nil
}

func (q *QemuDbg) cmdSet32(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	val, err := strconv.ParseUint(args[3], 0, 32)
	if err != nil {
		return err
	}

	valBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(valBytes, uint32(val))

	err = q.SetMemory(valBytes, uintptr(addr))
	if err != nil {
		return err
	}

	fmt.Printf("Set %s0x%016x%s = %s0x%08x%s\n", ColorBlue, addr, ColorReset, ColorCyan, val, ColorReset)
	return nil
}

func (q *QemuDbg) cmdSet16(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	val, err := strconv.ParseUint(args[3], 0, 16)
	if err != nil {
		return err
	}

	valBytes := make([]byte, 2)
	binary.LittleEndian.PutUint16(valBytes, uint16(val))

	err = q.SetMemory(valBytes, uintptr(addr))
	if err != nil {
		return err
	}

	fmt.Printf("Set %s0x%016x%s = %s0x%04x%s\n", ColorBlue, addr, ColorReset, ColorCyan, val, ColorReset)
	return nil
}

func (q *QemuDbg) cmdSet8(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}

	val, err := strconv.ParseUint(args[3], 0, 8)
	if err != nil {
		return err
	}

	valBytes := []byte{byte(val)}

	err = q.SetMemory(valBytes, uintptr(addr))
	if err != nil {
		return err
	}

	fmt.Printf("Set %s0x%016x%s = %s0x%02x%s\n", ColorBlue, addr, ColorReset, ColorCyan, val, ColorReset)
	return nil
}

func (q *QemuDbg) cmdRegs(a interface{}) error {
	regs, err := q.GetRegs()
	if err != nil {
		return err
	}

	fmt.Printf("$rax   : %s0x%016x%s\n", ColorCyan, regs.Rax, ColorReset)
	fmt.Printf("$rbx   : %s0x%016x%s\n", ColorCyan, regs.Rbx, ColorReset)
	fmt.Printf("$rcx   : %s0x%016x%s\n", ColorCyan, regs.Rcx, ColorReset)
	fmt.Printf("$rdx   : %s0x%016x%s\n", ColorCyan, regs.Rdx, ColorReset)
	fmt.Printf("$rsp   : %s0x%016x%s\n", ColorCyan, regs.Rsp, ColorReset)
	fmt.Printf("$rbp   : %s0x%016x%s\n", ColorCyan, regs.Rbp, ColorReset)
	fmt.Printf("$rsi   : %s0x%016x%s\n", ColorCyan, regs.Rsi, ColorReset)
	fmt.Printf("$rdi   : %s0x%016x%s\n", ColorCyan, regs.Rdi, ColorReset)
	fmt.Printf("$rip   : %s0x%016x%s\n", ColorCyan, regs.Rip, ColorReset)
	fmt.Printf("$r8    : %s0x%016x%s\n", ColorCyan, regs.R8, ColorReset)
	fmt.Printf("$r9    : %s0x%016x%s\n", ColorCyan, regs.R9, ColorReset)
	fmt.Printf("$r10   : %s0x%016x%s\n", ColorCyan, regs.R10, ColorReset)
	fmt.Printf("$r11   : %s0x%016x%s\n", ColorCyan, regs.R11, ColorReset)
	fmt.Printf("$r12   : %s0x%016x%s\n", ColorCyan, regs.R12, ColorReset)
	fmt.Printf("$r13   : %s0x%016x%s\n", ColorCyan, regs.R13, ColorReset)
	fmt.Printf("$r14   : %s0x%016x%s\n", ColorCyan, regs.R14, ColorReset)
	fmt.Printf("$r15   : %s0x%016x%s\n", ColorCyan, regs.R15, ColorReset)
	fmt.Printf("$eflags: %s0x%016x%s\n", ColorCyan, regs.Eflags, ColorReset)
	fmt.Printf("$cs: %x $ss: %x $ds: %x $es: %x $fs: %x $gs: %x\n",
		regs.Cs, regs.Ss, regs.Ds, regs.Es, regs.Fs, regs.Gs)

	return nil
}

func (q *QemuDbg) cmdContinue(a interface{}) error {
	fmt.Println("Continuing...")
	return q.Continue()
}

func (q *QemuDbg) cmdStep(a interface{}) error {
	err := q.Step()
	if err != nil {
		return err
	}
	cls()
	return q.cmdContext(nil)
}

func (q *QemuDbg) cmdTelescope(a interface{}) error {
	args, ok := a.([]string)
	if !ok || len(args) < 3 {
		return errors.New("invalid arguments")
	}

	var addr uint64
	var n uint64 = 0x80
	addr, err := strconv.ParseUint(args[2], 0, 64)
	if err != nil {
		return err
	}
	if len(args) > 3 && args[3] != "" {
		n, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	data, err := q.GetMemory(uint(n*8), uintptr(addr))
	if err != nil {
		return err
	}

	tempFile := fmt.Sprintf("/tmp/fastDbg_qemu_%d_%d", os.Getpid(), time.Now().Unix())
	file, err := os.Create(tempFile)
	if err != nil {
		return err
	}

	defer func() {
		file.Close()
		os.Remove(tempFile)
	}()

	for i := 0; i < len(data); i += 8 {
		if i+8 <= len(data) {
			address := binary.LittleEndian.Uint64(data[i : i+8])
			fmt.Fprintf(file, "%s0x%016x%s:+0x%03x(+0x%02x)| %s0x%016x%s\n",
				ColorBlue, addr+uint64(i), ColorReset,
				i, i/8,
				ColorCyan, address, ColorReset)
		}
	}
	file.Close()

	cmd := exec.Command("less", "-SR", tempFile)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return err
	}

	return nil
}

func (q *QemuDbg) cmdStack(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	var sz uint64 = 16
	var err error
	if len(args[2]) != 0 {
		sz, err = strconv.ParseUint(args[3], 0, 64)
		if err != nil {
			return err
		}
	}

	regs, err := q.GetRegs()
	if err != nil {
		return err
	}

	rsp := regs.Rsp
	data, err := q.GetMemory(uint(sz*8), uintptr(rsp))
	if err != nil {
		return fmt.Errorf("error while getting stack memory: %v", err)
	}

	for i := 0; i < len(data); i += 8 {
		if i+8 <= len(data) {
			fmt.Printf("%s0x%016x%s: %s0x%016x%s\n",
				ColorBlue, rsp+uint64(i), ColorReset,
				ColorCyan, binary.LittleEndian.Uint64(data[i:i+8]), ColorReset)
		}
	}

	return nil
}

func (q *QemuDbg) cmdBacktrace(a interface{}) error {
	args, ok := a.([]string)
	if !ok {
		return errors.New("invalid arguments")
	}

	maxDepth := 20
	var err error
	if len(args) > 2 && len(args[2]) != 0 {
		depth, err := strconv.ParseUint(args[2], 0, 64)
		if err != nil {
			return fmt.Errorf("invalid depth: %v", err)
		}
		maxDepth = int(depth)
	}

	regs, err := q.GetRegs()
	if err != nil {
		return err
	}

	rip := regs.Rip
	rbp := regs.Rbp

	frameNum := 0
	fmt.Printf("#%-2d %s0x%016x%s\n", frameNum, ColorCyan, rip, ColorReset)

	visited := make(map[uint64]bool)
	visited[rbp] = true

	for frameNum = 1; frameNum < maxDepth; frameNum++ {
		if rbp == 0 || rbp%8 != 0 {
			break
		}

		ripData, err := q.GetMemory(8, uintptr(rbp+8))
		if err != nil {
			break
		}

		if len(ripData) < 8 {
			break
		}

		savedRip := binary.LittleEndian.Uint64(ripData)
		if savedRip == 0 {
			break
		}

		fmt.Printf("#%-2d %s0x%016x%s\n", frameNum, ColorCyan, savedRip, ColorReset)

		rbpData, err := q.GetMemory(8, uintptr(rbp))
		if err != nil {
			break
		}

		if len(rbpData) < 8 {
			break
		}

		prevRbp := binary.LittleEndian.Uint64(rbpData)
		if visited[prevRbp] {
			break
		}
		if prevRbp <= rbp {
			break
		}

		visited[prevRbp] = true
		rbp = prevRbp
	}

	return nil
}

func (q *QemuDbg) cmdContext(a interface{}) error {
	hLine("registers")

	if err := q.cmdRegs(nil); err != nil {
		return err
	}

	hLine("disassembly")
	regs, err := q.GetRegs()
	if err != nil {
		return err
	}

	q.disass(regs.Rip, 32)

	hLine("stack")
	data, err := q.GetMemory(64, uintptr(regs.Rsp))
	if err == nil {
		for i := 0; i < len(data); i += 8 {
			if i+8 <= len(data) {
				address := binary.LittleEndian.Uint64(data[i : i+8])
				fmt.Printf("%s0x%016x%s: %s0x%016x%s\n",
					ColorBlue, regs.Rsp+uint64(i), ColorReset,
					ColorCyan, address, ColorReset)
			}
		}
	}

	hLineRaw()
	return nil
}

func hLine(msg string) {
	if term.IsTerminal(int(os.Stdout.Fd())) {
		w, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err == nil && w > 0 {
			fmt.Printf(strings.Repeat("-", (w-len(msg)-2)/2) + "[" + msg + "]" + strings.Repeat("-", (w-len(msg)-2)/2) + "\n")
			return
		}
	}
	fmt.Printf("[" + msg + "]\n")
}

func hLineRaw() {
	if term.IsTerminal(int(os.Stdout.Fd())) {
		w, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err == nil && w > 0 {
			fmt.Println(strings.Repeat("-", w))
			return
		}
	}
	fmt.Println(strings.Repeat("-", 80))
}

func (q *QemuDbg) resolveSymbols(cmd string) (string, error) {
	resolver := NewQemuSymbolResolver(q)
	return ResolveSymbolsInCommand(cmd, resolver)
}

func (q *QemuDbg) Interactive() {
	// Set up signal handler for Ctrl+C
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT)
	defer signal.Stop(sigChan)

	// Handle SIGINT in background - interrupt running QEMU target
	go func() {
		for range sigChan {
			Printf("\n^C - Interrupting QEMU target...\n")
			if err := q.Interrupt(); err != nil {
				LogError("Failed to interrupt QEMU target: %v", err)
			}
		}
	}()

	prev := ""

	rl, err := readline.NewEx(&readline.Config{
		Prompt:            "[fastDbg-QEMU]$ ",
		HistoryFile:       "/tmp/fastdbg_qemu_history.txt",
		InterruptPrompt:   "^C",
		EOFPrompt:         "exit",
		HistorySearchFold: true,
		FuncFilterInputRune: func(r rune) (rune, bool) {
			switch r {
			case readline.CharCtrlZ:
				return r, false
			}
			return r, true
		},
	})
	if err != nil {
		panic(err)
	}
	defer rl.Close()

	if err := q.cmdContext(nil); err != nil {
		LogError("Failed to get initial context: %v", err)
	}

	for {
		regs, err := q.GetRegs()
		if err == nil {
			rl.SetPrompt(fmt.Sprintf("[%sfastDbg%s:%s0x%x%s]$ ", ColorCyan, ColorReset, ColorCyan, regs.Rip, ColorReset))
		} else {
			rl.SetPrompt("[fastDbg]$ ")
		}

		req, err := rl.Readline()
		if err != nil {
			if err == readline.ErrInterrupt {
				if err := q.Interrupt(); err != nil {
					LogError("Failed to interrupt QEMU target: %v", err)
				} else {
					if err := q.cmdContext(nil); err != nil {
						LogError("Failed to get context: %v", err)
					}
				}
				continue
			}
			if err == io.EOF {
				break
			}
			continue
		}

		if req == "" {
			if prev == "" {
				continue
			}
			req = prev
		}

		if req == "q" || req == "exit" || req == "quit" {
			break
		}

		prev = req

		resolvedReq := req
		if strings.Contains(req, "$") {
			resolvedReq, _ = q.resolveSymbols(req)
		}

		err = q.CmdExec(resolvedReq)
		if err != nil {
			LogError(err.Error())
		}
	}
}

```

`qemu/disass.go`:

```go
package qemu

import (
	"fmt"
	"unsafe"
)

/*

#cgo pkg-config: capstone
#include <capstone/capstone.h>

static inline char* qemu_get_mnemonic(cs_insn* insn) { return insn->mnemonic; }
static inline char* qemu_get_op_str(cs_insn* insn) { return insn->op_str; }
static inline uint64_t qemu_get_address(cs_insn* insn) { return insn->address; }
static inline uint16_t qemu_get_size(cs_insn* insn) { return insn->size; }
*/
import "C"

func (q *QemuDbg) disass(addr uint64, sz uint) error {
	code, err := q.GetMemory(sz, uintptr(addr))
	if err != nil {
		fmt.Printf("Error reading memory at 0x%016x: %v\n", addr, err)
		return err
	}

	var handle C.csh
	var insn *C.cs_insn
	ret := C.cs_open(C.CS_ARCH_X86, C.CS_MODE_64, &handle)
	if ret != C.CS_ERR_OK {
		return fmt.Errorf("capstone open failed")
	}

	defer C.cs_close(&handle)

	count := C.cs_disasm(handle, (*C.uint8_t)(unsafe.Pointer(&code[0])), C.size_t(len(code)), C.uint64_t(addr), 0, &insn)
	if count == 0 {
		return fmt.Errorf("disassembly failed")
	}

	defer C.cs_free(insn, count)

	instructions := (*[1000]C.cs_insn)(unsafe.Pointer(insn))[:count]
	for i := 0; i < int(count); i++ {
		inst := &instructions[i]
		mnemonic := C.qemu_get_mnemonic(inst)
		op_str := C.qemu_get_op_str(inst)

		if mnemonic == nil {
			fmt.Printf("0x%016x: <invalid mnemonic>\n", C.qemu_get_address(inst))
			continue
		}

		mnemonic_str := C.GoString(mnemonic)
		op_str_go := ""
		if op_str != nil {
			op_str_go = C.GoString(op_str)
		}

		if op_str_go != "" {
			fmt.Printf("%s0x%016x%s: %s%s %s%s\n",
				ColorBlue, C.qemu_get_address(inst), ColorReset,
				ColorPurple, mnemonic_str, op_str_go, ColorReset)
		} else {
			fmt.Printf("%s0x%016x%s: %s%s%s\n",
				ColorBlue, C.qemu_get_address(inst), ColorReset,
				ColorPurple, mnemonic_str, ColorReset)
		}
	}

	return nil
}

```

`qemu/exprEval.go`:

```go
package qemu

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

type SymbolResolver interface {
	ResolveRegister(name string) (uint64, error)
	ResolveSymbol(name string) (uint64, error)
}

func EvaluateExpression(expr string, resolver SymbolResolver) (uint64, error) {
	resolved, err := resolveSymbolsInExpr(expr, resolver)
	if err != nil {
		return 0, err
	}
	return evalArithmetic(resolved)
}

func resolveSymbolsInExpr(expr string, resolver SymbolResolver) (string, error) {
	symPattern := regexp.MustCompile(`\$([a-zA-Z_][a-zA-Z0-9_@.]*)`)

	var resolveErr error
	result := symPattern.ReplaceAllStringFunc(expr, func(match string) string {
		symName := strings.TrimPrefix(match, "$")
		val, err := resolver.ResolveRegister(symName)
		if err == nil {
			return fmt.Sprintf("0x%x", val)
		}
		val, err = resolver.ResolveSymbol(symName)
		if err == nil {
			return fmt.Sprintf("0x%x", val)
		}

		resolveErr = fmt.Errorf("failed to resolve symbol: %s", symName)
		return match
	})

	return result, resolveErr
}

func evalArithmetic(expr string) (uint64, error) {
	expr = strings.TrimSpace(expr)
	if !strings.ContainsAny(expr, "+-*/()") {
		return parseNumber(expr)
	}
	tokens := tokenize(expr)
	if len(tokens) == 0 {
		return 0, fmt.Errorf("empty expression")
	}
	result, _, err := parseAddSub(tokens, 0)
	return result, err
}

type token struct {
	typ   string
	value string
}

func tokenize(expr string) []token {
	var tokens []token
	expr = strings.ReplaceAll(expr, " ", "")

	i := 0
	for i < len(expr) {
		ch := expr[i]

		switch ch {
		case '+', '-', '*', '/':
			tokens = append(tokens, token{"op", string(ch)})
			i++
		case '(':
			tokens = append(tokens, token{"lparen", "("})
			i++
		case ')':
			tokens = append(tokens, token{"rparen", ")"})
			i++
		default:
			start := i
			if ch == '0' && i+1 < len(expr) && (expr[i+1] == 'x' || expr[i+1] == 'X') {
				i += 2
				for i < len(expr) && isHexDigit(expr[i]) {
					i++
				}
			} else {
				for i < len(expr) && (isDigit(expr[i])) {
					i++
				}
			}
			if i > start {
				tokens = append(tokens, token{"number", expr[start:i]})
			} else {
				i++
			}
		}
	}

	return tokens
}

func isDigit(ch byte) bool {
	return ch >= '0' && ch <= '9'
}

func isHexDigit(ch byte) bool {
	return isDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')
}

func parseAddSub(tokens []token, pos int) (uint64, int, error) {
	left, pos, err := parseMulDiv(tokens, pos)
	if err != nil {
		return 0, pos, err
	}

	for pos < len(tokens) && tokens[pos].typ == "op" && (tokens[pos].value == "+" || tokens[pos].value == "-") {
		op := tokens[pos].value
		pos++

		right, newPos, err := parseMulDiv(tokens, pos)
		if err != nil {
			return 0, pos, err
		}
		pos = newPos

		if op == "+" {
			left = left + right
		} else {
			if right > left {
				return 0, pos, fmt.Errorf("subtraction would result in negative number")
			}
			left = left - right
		}
	}

	return left, pos, nil
}

func parseMulDiv(tokens []token, pos int) (uint64, int, error) {
	left, pos, err := parseFactor(tokens, pos)
	if err != nil {
		return 0, pos, err
	}

	for pos < len(tokens) && tokens[pos].typ == "op" && (tokens[pos].value == "*" || tokens[pos].value == "/") {
		op := tokens[pos].value
		pos++

		right, newPos, err := parseFactor(tokens, pos)
		if err != nil {
			return 0, pos, err
		}
		pos = newPos

		if op == "*" {
			left = left * right
		} else {
			if right == 0 {
				return 0, pos, fmt.Errorf("division by zero")
			}
			left = left / right
		}
	}

	return left, pos, nil
}

func parseFactor(tokens []token, pos int) (uint64, int, error) {
	if pos >= len(tokens) {
		return 0, pos, fmt.Errorf("unexpected end of expression")
	}

	tok := tokens[pos]

	if tok.typ == "number" {
		val, err := parseNumber(tok.value)
		return val, pos + 1, err
	}

	if tok.typ == "lparen" {
		val, newPos, err := parseAddSub(tokens, pos+1)
		if err != nil {
			return 0, newPos, err
		}
		pos = newPos

		if pos >= len(tokens) || tokens[pos].typ != "rparen" {
			return 0, pos, fmt.Errorf("missing closing parenthesis")
		}

		return val, pos + 1, nil
	}

	return 0, pos, fmt.Errorf("unexpected token: %s", tok.value)
}

func parseNumber(s string) (uint64, error) {
	s = strings.TrimSpace(s)
	if strings.HasPrefix(s, "0x") || strings.HasPrefix(s, "0X") {
		return strconv.ParseUint(s[2:], 16, 64)
	}
	if strings.HasPrefix(s, "0") && len(s) > 1 {
		return strconv.ParseUint(s, 8, 64)
	}
	return strconv.ParseUint(s, 10, 64)
}

func ResolveSymbolsInCommand(cmd string, resolver SymbolResolver) (string, error) {
	if !strings.Contains(cmd, "$") {
		return cmd, nil
	}

	exprPattern := regexp.MustCompile(`(\$[a-zA-Z_][a-zA-Z0-9_@.]*(?:\s*[+\-*/]\s*(?:0[xX][0-9a-fA-F]+|0[0-7]+|[0-9]+|\$[a-zA-Z_][a-zA-Z0-9_@.]*))*)`)

	var lastErr error
	result := exprPattern.ReplaceAllStringFunc(cmd, func(match string) string {
		val, err := EvaluateExpression(match, resolver)
		if err != nil {
			resolved, err2 := resolveSymbolsInExpr(match, resolver)
			if err2 != nil {
				lastErr = err2
				return match
			}
			return resolved
		}
		return fmt.Sprintf("0x%x", val)
	})

	return result, lastErr
}

```

`qemu/qemu.go`:

```go
package qemu

import (
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"
)

type QemuDbg struct {
	conn    net.Conn
	host    string
	port    int
	arch    int
	isStart bool
}

func Connect(host string, port int) (*QemuDbg, error) {
	addr := fmt.Sprintf("%s:%d", host, port)
	conn, err := net.Dial("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to %s: %v", addr, err)
	}

	dbg := &QemuDbg{
		conn:    conn,
		host:    host,
		port:    port,
		arch:    64,
		isStart: true,
	}
	_, err = conn.Write([]byte("+"))
	if err != nil {
		conn.Close()
		return nil, err
	}

	fmt.Printf("Connected to QEMU GDB stub at %s\n", addr)
	return dbg, nil
}

func (q *QemuDbg) Close() error {
	if q.conn != nil {
		q.sendPacket("D")
		return q.conn.Close()
	}
	return nil
}

func (q *QemuDbg) sendPacket(data string) error {
	checksum := byte(0)
	for i := 0; i < len(data); i++ {
		checksum += data[i]
	}
	packet := fmt.Sprintf("$%s#%02x", data, checksum)

	for retry := 0; retry < 3; retry++ {
		_, err := q.conn.Write([]byte(packet))
		if err != nil {
			return err
		}

		q.conn.SetReadDeadline(time.Now().Add(2 * time.Second))
		ackBuf := make([]byte, 1)
		n, err := q.conn.Read(ackBuf)
		q.conn.SetReadDeadline(time.Time{})

		if err != nil {
			if retry < 2 {
				continue
			}
			return fmt.Errorf("failed to read ack: %v", err)
		}

		if n > 0 && ackBuf[0] == '+' {
			return nil
		} else if n > 0 && ackBuf[0] == '-' {
			continue
		}
		return nil
	}

	return fmt.Errorf("failed to send packet after 3 retries")
}

func (q *QemuDbg) recvPacket() (string, error) {
	q.conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	defer q.conn.SetReadDeadline(time.Time{})

	buf := make([]byte, 8192)
	n, err := q.conn.Read(buf)
	if err != nil {
		return "", err
	}

	response := string(buf[:n])

	response = strings.TrimPrefix(response, "+")
	response = strings.TrimPrefix(response, "-")
	if strings.Contains(response, "$") && strings.Contains(response, "#") {
		startIdx := strings.Index(response, "$")
		endIdx := strings.Index(response, "#")
		if startIdx >= 0 && endIdx > startIdx && endIdx+2 < len(response) {
			data := response[startIdx+1 : endIdx]
			checksumStr := response[endIdx+1 : endIdx+3]
			expectedChecksum := byte(0)
			for i := 0; i < len(data); i++ {
				expectedChecksum += data[i]
			}
			var receivedChecksum byte
			fmt.Sscanf(checksumStr, "%02x", &receivedChecksum)

			if expectedChecksum == receivedChecksum {
				_, _ = q.conn.Write([]byte("+"))
				return data, nil
			} else {
				_, _ = q.conn.Write([]byte("-"))
				return "", fmt.Errorf("checksum mismatch")
			}
		}
	}

	response = strings.TrimSpace(response)
	if response != "" {
		_, _ = q.conn.Write([]byte("+"))
	}

	return response, nil
}

func (q *QemuDbg) readResponse(cmd string) (string, error) {
	if err := q.sendPacket(cmd); err != nil {
		return "", err
	}
	return q.recvPacket()
}

func (q *QemuDbg) GetMemory(size uint, addr uintptr) ([]byte, error) {
	cmd := fmt.Sprintf("m%x,%x", addr, size)
	resp, err := q.readResponse(cmd)
	if err != nil {
		return nil, err
	}

	if resp == "E00" || resp == "" {
		return nil, errors.New("failed to read memory")
	}

	data, err := hex.DecodeString(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to decode memory: %v", err)
	}

	return data, nil
}

func (q *QemuDbg) SetMemory(data []byte, addr uintptr) error {
	hexData := hex.EncodeToString(data)
	cmd := fmt.Sprintf("M%x,%x:%s", addr, len(data), hexData)
	resp, err := q.readResponse(cmd)
	if err != nil {
		return err
	}

	if resp != "OK" {
		return fmt.Errorf("failed to write memory: %s", resp)
	}

	return nil
}

func (q *QemuDbg) Continue() error {
	return q.sendPacket("c")
}

func (q *QemuDbg) Interrupt() error {
	// Send Ctrl+C (0x03) to interrupt the running target
	// This is the GDB remote protocol way to interrupt execution
	_, err := q.conn.Write([]byte{0x03})
	if err != nil {
		return fmt.Errorf("failed to send interrupt: %v", err)
	}

	// Read the stop response
	_, err = q.recvPacket()
	if err != nil {
		return fmt.Errorf("failed to receive interrupt response: %v", err)
	}

	return nil
}

func (q *QemuDbg) Step() error {
	if err := q.sendPacket("s"); err != nil {
		return err
	}
	_, err := q.recvPacket()
	return err
}

type Regs struct {
	Rax    uint64
	Rbx    uint64
	Rcx    uint64
	Rdx    uint64
	Rsi    uint64
	Rdi    uint64
	Rbp    uint64
	Rsp    uint64
	R8     uint64
	R9     uint64
	R10    uint64
	R11    uint64
	R12    uint64
	R13    uint64
	R14    uint64
	R15    uint64
	Rip    uint64
	Eflags uint64
	Cs     uint32
	Ss     uint32
	Ds     uint32
	Es     uint32
	Fs     uint32
	Gs     uint32
}

func (q *QemuDbg) GetRegs() (*Regs, error) {
	resp, err := q.readResponse("g")
	if err != nil {
		return nil, err
	}

	resp = strings.TrimSpace(resp)

	data, err := hex.DecodeString(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to decode registers: %v (response: %s)", err, resp[:min(len(resp), 50)])
	}

	if len(data) < 8*17 {
		return nil, fmt.Errorf("insufficient register data: got %d bytes, need at least %d", len(data), 8*17)
	}

	regs := &Regs{}
	regs.Rax = binary.LittleEndian.Uint64(data[0:8])
	regs.Rbx = binary.LittleEndian.Uint64(data[8:16])
	regs.Rcx = binary.LittleEndian.Uint64(data[16:24])
	regs.Rdx = binary.LittleEndian.Uint64(data[24:32])
	regs.Rsi = binary.LittleEndian.Uint64(data[32:40])
	regs.Rdi = binary.LittleEndian.Uint64(data[40:48])
	regs.Rbp = binary.LittleEndian.Uint64(data[48:56])
	regs.Rsp = binary.LittleEndian.Uint64(data[56:64])
	regs.R8 = binary.LittleEndian.Uint64(data[64:72])
	regs.R9 = binary.LittleEndian.Uint64(data[72:80])
	regs.R10 = binary.LittleEndian.Uint64(data[80:88])
	regs.R11 = binary.LittleEndian.Uint64(data[88:96])
	regs.R12 = binary.LittleEndian.Uint64(data[96:104])
	regs.R13 = binary.LittleEndian.Uint64(data[104:112])
	regs.R14 = binary.LittleEndian.Uint64(data[112:120])
	regs.R15 = binary.LittleEndian.Uint64(data[120:128])
	regs.Rip = binary.LittleEndian.Uint64(data[128:136])
	regs.Eflags = binary.LittleEndian.Uint64(data[136:144])

	if len(data) >= 168 {
		regs.Cs = binary.LittleEndian.Uint32(data[144:148])
		regs.Ss = binary.LittleEndian.Uint32(data[148:152])
		regs.Ds = binary.LittleEndian.Uint32(data[152:156])
		regs.Es = binary.LittleEndian.Uint32(data[156:160])
		regs.Fs = binary.LittleEndian.Uint32(data[160:164])
		regs.Gs = binary.LittleEndian.Uint32(data[164:168])
	}

	return regs, nil
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func (q *QemuDbg) SetReg(regNum int, value uint64) error {
	buf := make([]byte, 8)
	binary.LittleEndian.PutUint64(buf, value)
	hexValue := hex.EncodeToString(buf)

	cmd := fmt.Sprintf("P%x=%s", regNum, hexValue)
	resp, err := q.readResponse(cmd)
	if err != nil {
		return err
	}

	if resp != "OK" {
		return fmt.Errorf("failed to set register: %s", resp)
	}

	return nil
}

func (q *QemuDbg) SetBreakpoint(addr uintptr) error {
	cmd := fmt.Sprintf("Z0,%x,1", addr)
	resp, err := q.readResponse(cmd)
	if err != nil {
		return err
	}

	if resp != "OK" && resp != "" {
		return fmt.Errorf("failed to set breakpoint: %s", resp)
	}

	return nil
}

func (q *QemuDbg) RemoveBreakpoint(addr uintptr) error {
	cmd := fmt.Sprintf("z0,%x,1", addr)
	resp, err := q.readResponse(cmd)
	if err != nil {
		return err
	}

	if resp != "OK" && resp != "" {
		return fmt.Errorf("failed to remove breakpoint: %s", resp)
	}

	return nil
}

func (q *QemuDbg) GetRip() (uint64, error) {
	regs, err := q.GetRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rip, nil
}

func (q *QemuDbg) SetRip(rip uint64) error {
	return q.SetReg(16, rip)
}

func parseAddr(s string) (uint64, error) {
	return strconv.ParseUint(s, 0, 64)
}

func RunQemuDebugger(host string, port int) error {
	dbg, err := Connect(host, port)
	if err != nil {
		return fmt.Errorf("failed to connect to QEMU: %v", err)
	}
	defer dbg.Close()

	dbg.Interactive()
	return nil
}

func (q *QemuDbg) DisassOne(addr uintptr) (*string, error) {
	code, err := q.GetMemory(16, addr)
	if err != nil {
		return nil, err
	}

	result := fmt.Sprintf("%02x %02x %02x %02x", code[0], code[1], code[2], code[3])
	return &result, nil
}

func (q *QemuDbg) GetProcMaps() []interface{} {
	return []interface{}{}
}

func (q *QemuDbg) IsActive() bool {
	return q.conn != nil && q.isStart
}

func (q *QemuDbg) ResolveAddrToSymbol(addr uint64) (interface{}, uint64, error) {
	return nil, 0, fmt.Errorf("symbol resolution not available for QEMU remote debugging")
}

```

`qemu/symResolve.go`:

```go
package qemu

import (
	"fmt"
	"strings"
)

type QemuSymbolResolver struct {
	dbg *QemuDbg
}

func NewQemuSymbolResolver(dbg *QemuDbg) *QemuSymbolResolver {
	return &QemuSymbolResolver{dbg: dbg}
}

func (r *QemuSymbolResolver) ResolveRegister(name string) (uint64, error) {
	regs, err := r.dbg.GetRegs()
	if err != nil {
		return 0, fmt.Errorf("failed to get registers: %v", err)
	}

	switch strings.ToLower(name) {
	case "rax":
		return regs.Rax, nil
	case "rbx":
		return regs.Rbx, nil
	case "rcx":
		return regs.Rcx, nil
	case "rdx":
		return regs.Rdx, nil
	case "rsi":
		return regs.Rsi, nil
	case "rdi":
		return regs.Rdi, nil
	case "rbp":
		return regs.Rbp, nil
	case "rsp":
		return regs.Rsp, nil
	case "r8":
		return regs.R8, nil
	case "r9":
		return regs.R9, nil
	case "r10":
		return regs.R10, nil
	case "r11":
		return regs.R11, nil
	case "r12":
		return regs.R12, nil
	case "r13":
		return regs.R13, nil
	case "r14":
		return regs.R14, nil
	case "r15":
		return regs.R15, nil
	case "rip":
		return regs.Rip, nil
	case "eflags":
		return regs.Eflags, nil
	case "cs":
		return uint64(regs.Cs), nil
	case "ss":
		return uint64(regs.Ss), nil
	case "ds":
		return uint64(regs.Ds), nil
	case "es":
		return uint64(regs.Es), nil
	case "fs":
		return uint64(regs.Fs), nil
	case "gs":
		return uint64(regs.Gs), nil
	default:
		return 0, fmt.Errorf("unknown register: %s", name)
	}
}

func (r *QemuSymbolResolver) ResolveSymbol(name string) (uint64, error) {
	return 0, fmt.Errorf("symbol resolution not available for QEMU remote debugging")
}

```

`regs.go`:

```go
package main

import (
	"errors"
	"golang.org/x/sys/unix"
	"strings"
)

func (dbger *TypeDbg) GetRegs(reqName string) (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}

	regName := strings.ToUpper(reqName)

	switch regName {
	case "R15":
		return regs.R15, nil
	case "R14":
		return regs.R14, nil
	case "R13":
		return regs.R13, nil
	case "R12":
		return regs.R12, nil
	case "RBP":
		return regs.Rbp, nil
	case "RBX":
		return regs.Rbx, nil
	case "R11":
		return regs.R11, nil
	case "R10":
		return regs.R10, nil
	case "R9":
		return regs.R9, nil
	case "R8":
		return regs.R8, nil
	case "RAX":
		return regs.Rax, nil
	case "RCX":
		return regs.Rcx, nil
	case "RDX":
		return regs.Rdx, nil
	case "RSI":
		return regs.Rsi, nil
	case "RDI":
		return regs.Rdi, nil
	case "ORIG_RAX":
		return regs.Orig_rax, nil
	case "RIP":
		for _, b := range Bps {
			if uint64(b.addr) == regs.Rip-1 {
				return regs.Rip - 1, nil
			}
		}
		return regs.Rip, nil
	case "CS":
		return regs.Cs, nil
	case "EFLAGS":
		return regs.Eflags, nil
	case "RSP":
		return regs.Rsp, nil
	case "SS":
		return regs.Ss, nil
	case "FS_BASE":
		return regs.Fs_base, nil
	case "GS_BASE":
		return regs.Gs_base, nil
	case "DS":
		return regs.Ds, nil
	case "ES":
		return regs.Es, nil
	case "FS":
		return regs.Fs, nil
	case "GS":
		return regs.Gs, nil
	default:
		return 0, errors.New("invalid register")
	}
}

func (dbger *TypeDbg) getRegs() (*unix.PtraceRegs, error) {
	if !dbger.isProcessAlive() {
		return nil, errors.New("process is not alive")
	}

	regs := &unix.PtraceRegs{}
	err := doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceGetRegs(dbger.pid, regs)
	})
	if err != nil {
		return nil, err
	}

	return regs, nil
}

func (dbger *TypeDbg) SetRegs(regName string, val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}

	regName = strings.ToUpper(regName)

	switch regName {
	case "R15":
		regs.R15 = val
	case "R14":
		regs.R14 = val
	case "R13":
		regs.R13 = val
	case "R12":
		regs.R12 = val
	case "RBP":
		regs.Rbp = val
	case "RBX":
		regs.Rbx = val
	case "R11":
		regs.R11 = val
	case "R10":
		regs.R10 = val
	case "R9":
		regs.R9 = val
	case "R8":
		regs.R8 = val
	case "RAX":
		regs.Rax = val
	case "RCX":
		regs.Rcx = val
	case "RDX":
		regs.Rdx = val
	case "RSI":
		regs.Rsi = val
	case "RDI":
		regs.Rdi = val
	case "ORIG_RAX":
		regs.Orig_rax = val
	case "RIP":
		regs.Rip = val
	case "CS":
		regs.Cs = val
	case "EFLAGS":
		regs.Eflags = val
	case "RSP":
		regs.Rsp = val
	case "SS":
		regs.Ss = val
	case "FS_BASE":
		regs.Fs_base = val
	case "GS_BASE":
		regs.Gs_base = val
	case "DS":
		regs.Ds = val
	case "ES":
		regs.Es = val
	case "FS":
		regs.Fs = val
	case "GS":
		regs.Gs = val
	default:
		return errors.New("invalid register")
	}
	err = dbger.setRegs(regs)

	return err
}

func (dbger *TypeDbg) setRegs(regs *unix.PtraceRegs) error {
	if !dbger.isProcessAlive() {
		return errors.New("process is not alive")
	}

	err := doSyscallErr(dbger.rpc, func() error {
		return unix.PtraceSetRegs(dbger.pid, regs)
	})
	if err != nil {
		return errors.New("PtraceSetRegs failed: " + err.Error())
	}

	return nil
}

func (dbger *TypeDbg) GetR15() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R15, nil
}

func (dbger *TypeDbg) GetR14() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R14, nil
}

func (dbger *TypeDbg) GetR13() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R13, nil
}

func (dbger *TypeDbg) GetR12() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R12, nil
}

func (dbger *TypeDbg) GetRbp() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rbp, nil
}

func (dbger *TypeDbg) GetRbx() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rbx, nil
}

func (dbger *TypeDbg) GetR11() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R11, nil
}

func (dbger *TypeDbg) GetR10() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R10, nil
}

func (dbger *TypeDbg) GetR9() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R9, nil
}

func (dbger *TypeDbg) GetR8() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.R8, nil
}

func (dbger *TypeDbg) GetRax() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rax, nil
}

func (dbger *TypeDbg) GetRcx() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rcx, nil
}

func (dbger *TypeDbg) GetRdx() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rdx, nil
}

func (dbger *TypeDbg) GetRsi() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rsi, nil
}

func (dbger *TypeDbg) GetRdi() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rdi, nil
}

func (dbger *TypeDbg) GetOrig_rax() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Orig_rax, nil
}

func (dbger *TypeDbg) GetRip() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	for _, b := range Bps {
		if uint64(b.addr) == regs.Rip-1 {
			return regs.Rip - 1, nil
		}
	}
	return regs.Rip, nil
}

func (dbger *TypeDbg) GetCs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Cs, nil
}

func (dbger *TypeDbg) GetEflags() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Eflags, nil
}

func (dbger *TypeDbg) GetRsp() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Rsp, nil
}

func (dbger *TypeDbg) GetSs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Ss, nil
}

func (dbger *TypeDbg) GetFs_base() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Fs_base, nil
}

func (dbger *TypeDbg) GetGs_base() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Gs_base, nil
}

func (dbger *TypeDbg) GetDs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Ds, nil
}

func (dbger *TypeDbg) GetEs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Es, nil
}

func (dbger *TypeDbg) GetFs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Fs, nil
}

func (dbger *TypeDbg) GetGs() (uint64, error) {
	regs, err := dbger.getRegs()
	if err != nil {
		return 0, err
	}
	return regs.Gs, nil
}

func (dbger *TypeDbg) SetR15(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R15 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR14(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R14 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR13(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R13 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR12(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R12 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRbp(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rbp = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRbx(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rbx = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR11(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R11 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR10(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R10 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR9(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R9 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetR8(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.R8 = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRax(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rax = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRcx(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rcx = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRdx(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rdx = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRsi(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rsi = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRdi(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rdi = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetOrig_rax(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Orig_rax = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRip(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rip = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetCs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Cs = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetEflags(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Eflags = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetRsp(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Rsp = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetSs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Ss = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetFs_base(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Fs_base = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetGs_base(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Gs_base = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetDs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Ds = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetEs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Es = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetFs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Fs = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

func (dbger *TypeDbg) SetGs(val uint64) error {
	regs, err := dbger.getRegs()
	if err != nil {
		return err
	}
	regs.Gs = val
	err = dbger.setRegs(regs)
	if err != nil {
		return err
	}
	return nil
}

```

`simd.go`:

```go
package main

/*
#include <stdint.h>
#include <string.h>

struct xsave_header {
    uint64_t xstate_bv;
    uint64_t xcomp_bv;
    uint64_t reserved[6];
};

struct i387_fxsave_struct {
    uint16_t cwd;
    uint16_t swd;
    uint16_t twd;
    uint16_t fop;
    uint64_t rip;
    uint64_t rdp;
    uint32_t mxcsr;
    uint32_t mxcsr_mask;
    uint32_t st_space[32];
    uint32_t xmm_space[64];
    uint32_t padding[24];
};

struct xsave_struct {
    struct i387_fxsave_struct i387;
    struct xsave_header header;
};
*/
import "C"

import (
	"encoding/binary"
	"fmt"
	"golang.org/x/sys/unix"
	"math"
	"unsafe"
)

const (
	NT_X86_XSTATE = 0x202
)

const (
	XSTATE_FP        = 0x1
	XSTATE_SSE       = 0x2
	XSTATE_YMM       = 0x4
	XSTATE_BNDREGS   = 0x8
	XSTATE_BNDCSR    = 0x10
	XSTATE_OPMASK    = 0x20
	XSTATE_ZMM_Hi256 = 0x40
	XSTATE_Hi16_ZMM  = 0x80
)

func (dbger *TypeDbg) getExtendedRegs() ([]byte, error) {
	buf := make([]byte, 4096)

	iov := unix.Iovec{
		Base: &buf[0],
		Len:  uint64(len(buf)),
	}

	err := doSyscallErr(dbger.rpc, func() error {
		_, _, errno := unix.Syscall6(
			unix.SYS_PTRACE,
			unix.PTRACE_GETREGSET,
			uintptr(dbger.pid),
			uintptr(NT_X86_XSTATE),
			uintptr(unsafe.Pointer(&iov)),
			0, 0,
		)
		if errno != 0 {
			return errno
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	return buf[:iov.Len], nil
}

func printXMMRegister(name string, data []byte) {
	if len(data) != 16 {
		return
	}

	fmt.Printf("%-6s: ", name)
	for i := 15; i >= 0; i-- {
		fmt.Printf("%02x", data[i])
		if i == 8 {
			fmt.Print(" ")
		}
	}

	fmt.Print(" | ")

	f64_0 := math.Float64frombits(binary.LittleEndian.Uint64(data[0:8]))
	f64_1 := math.Float64frombits(binary.LittleEndian.Uint64(data[8:16]))
	fmt.Printf("f64:[%.6f %.6f]", f64_0, f64_1)

	fmt.Println()
}

func printYMMRegister(name string, lowData, highData []byte) {
	if len(lowData) != 16 || len(highData) != 16 {
		return
	}

	fmt.Printf("%-6s: ", name)

	for i := 15; i >= 0; i-- {
		fmt.Printf("%02x", highData[i])
	}
	fmt.Print(" ")

	for i := 15; i >= 0; i-- {
		fmt.Printf("%02x", lowData[i])
	}

	fmt.Println()
}

func (dbger *TypeDbg) cmdSIMD(a interface{}) error {
	if !dbger.isStart {
		return fmt.Errorf("debuggee has not started")
	}

	if !dbger.isProcessAlive() {
		return fmt.Errorf("process is not alive")
	}

	extRegs, err := dbger.getExtendedRegs()
	if err != nil {
		return fmt.Errorf("failed to get extended registers: %v", err)
	}

	if len(extRegs) < 512 {
		return fmt.Errorf("invalid XSAVE buffer size: %d bytes", len(extRegs))
	}
	xsave := (*C.struct_xsave_struct)(unsafe.Pointer(&extRegs[0]))
	xstateBv := uint64(xsave.header.xstate_bv)
	mxcsr := uint32(xsave.i387.mxcsr)
	fmt.Printf("MXCSR: %s0x%08x%s", ColorCyan, mxcsr, ColorReset)
	fmt.Printf(" [")
	if mxcsr&0x1 != 0 {
		fmt.Print("IE ")
	}
	if mxcsr&0x2 != 0 {
		fmt.Print("DE ")
	}
	if mxcsr&0x4 != 0 {
		fmt.Print("ZE ")
	}
	if mxcsr&0x8 != 0 {
		fmt.Print("OE ")
	}
	if mxcsr&0x10 != 0 {
		fmt.Print("UE ")
	}
	if mxcsr&0x20 != 0 {
		fmt.Print("PE ")
	}
	fmt.Printf("] RC:%d FTZ:%d DAZ:%d\n",
		(mxcsr>>13)&0x3, (mxcsr>>15)&0x1, (mxcsr>>6)&0x1)

	fmt.Printf("XSTATE_BV: %s0x%016x%s ", ColorCyan, xstateBv, ColorReset)
	fmt.Printf("[")
	if xstateBv&XSTATE_FP != 0 {
		fmt.Print("x87 ")
	}
	if xstateBv&XSTATE_SSE != 0 {
		fmt.Print("SSE ")
	}
	if xstateBv&XSTATE_YMM != 0 {
		fmt.Print("AVX ")
	}
	if xstateBv&XSTATE_OPMASK != 0 {
		fmt.Print("AVX512_OPMASK ")
	}
	if xstateBv&XSTATE_ZMM_Hi256 != 0 {
		fmt.Print("AVX512_ZMM_Hi256 ")
	}
	if xstateBv&XSTATE_Hi16_ZMM != 0 {
		fmt.Print("AVX512_Hi16_ZMM ")
	}
	fmt.Printf("]\n\n")

	hLine("XMM Registers (SSE - 128 bit)")
	for i := 0; i < 16; i++ {
		xmmData := make([]byte, 16)
		for j := 0; j < 16; j++ {
			xmmData[j] = *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&xsave.i387.xmm_space[0])) + uintptr(i*16+j)))
		}
		printXMMRegister(fmt.Sprintf("XMM%d", i), xmmData)
	}

	if xstateBv&XSTATE_YMM != 0 {
		fmt.Println()
		hLine("YMM Registers (AVX - 256 bit)")

		ymmhOffset := 576

		if len(extRegs) >= ymmhOffset+256 {
			for i := 0; i < 16; i++ {
				xmmData := make([]byte, 16)
				for j := 0; j < 16; j++ {
					xmmData[j] = *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&xsave.i387.xmm_space[0])) + uintptr(i*16+j)))
				}

				ymmhData := make([]byte, 16)
				for j := 0; j < 16; j++ {
					ymmhData[j] = extRegs[ymmhOffset+i*16+j]
				}

				printYMMRegister(fmt.Sprintf("YMM%d", i), xmmData, ymmhData)
			}
		}
	}

	fmt.Println()
	hLine("x87 FPU Registers")
	fmt.Printf("FCW: %s0x%04x%s  FSW: %s0x%04x%s  FTW: %s0x%04x%s  FOP: %s0x%04x%s\n",
		ColorCyan, xsave.i387.cwd, ColorReset,
		ColorCyan, xsave.i387.swd, ColorReset,
		ColorCyan, xsave.i387.twd, ColorReset,
		ColorCyan, xsave.i387.fop, ColorReset)
	fmt.Printf("FIP: %s0x%016x%s  FDP: %s0x%016x%s\n",
		ColorCyan, xsave.i387.rip, ColorReset,
		ColorCyan, xsave.i387.rdp, ColorReset)

	fmt.Println()
	for i := 0; i < 8; i++ {
		stData := make([]byte, 16)
		for j := 0; j < 16; j++ {
			stData[j] = *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&xsave.i387.st_space[0])) + uintptr(i*16+j)))
		}

		fmt.Printf("ST(%d)  : ", i)
		for j := 15; j >= 0; j-- {
			fmt.Printf("%02x", stData[j])
			if j == 8 {
				fmt.Print(" ")
			}
		}
		fmt.Println()
	}

	return nil
}

```

`sym.go`:

```go
package main

import (
	"bufio"
	"debug/elf"
	"encoding/binary"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
)

type LibraryRange struct {
	libIndex int
	start    uint64
	end      uint64
}

type rootStruct struct {
	name string
	base uint64
	end  uint64
	root *symTree
}

type symTree struct {
	str *string
	p   map[uint8]*symTree
}

type PLTEntry struct {
	Address      uint64
	Name         string
	OriginalName string
	Offset       uint64
	AddEnd       int64
	IsSynthetic  bool
}

type GOTEntry struct {
	Address uint64
	Name    string
	Value   uint64
}

type ELFSymbol struct {
	NameOffset uint32
	Info       uint8
	Other      uint8
	Section    elf.SectionIndex
	Value      uint64
	Size       uint64
}

type Relocation struct {
	Offset      uint64
	Info        uint64
	SymbolIndex uint32
	Type        uint32
	Addend      int64
}

var libRoots []rootStruct
var libraryRanges []LibraryRange

func addTreeToLib(libIndex int, ptr uint64, name *string) {
	if libIndex >= len(libRoots) {
		return
	}

	symTmp := libRoots[libIndex].root
	if symTmp == nil {
		libRoots[libIndex].root = &symTree{p: make(map[uint8]*symTree)}
		symTmp = libRoots[libIndex].root
	}

	for i := 64 - 8; i > 0; i -= 8 {
		key := uint8((ptr >> i) & 0xff)
		v, ok := symTmp.p[key]
		if !ok {
			newNode := symTree{p: make(map[uint8]*symTree)}
			symTmp.p[key] = &newNode
			symTmp = &newNode
		} else {
			symTmp = v
		}
	}

	lastKey := uint8(ptr & 0xff)
	if symTmp.p[lastKey] == nil {
		symTmp.p[lastKey] = &symTree{p: make(map[uint8]*symTree)}
	}
	symTmp.p[lastKey].str = name
}

func addr2NameFromLibExact(libIndex int, ptr uint64) (*string, error) {
	if libIndex >= len(libRoots) || libRoots[libIndex].root == nil {
		return nil, errors.New("library not found")
	}

	symTmp := libRoots[libIndex].root

	for i := 64 - 8; i > 0; i -= 8 {
		key := uint8((ptr >> i) & 0xff)
		v, ok := symTmp.p[key]
		if !ok {
			return nil, errors.New("symbol not found")
		}
		symTmp = v
	}

	lastKey := uint8(ptr & 0xff)
	finalNode, ok := symTmp.p[lastKey]
	if !ok || finalNode == nil || finalNode.str == nil {
		return nil, errors.New("symbol not found")
	}

	return finalNode.str, nil
}

func findNearestSymbolInLib(libIndex int, relativeAddr uint64) (*string, uint64) {
	if libIndex >= len(libRoots) || symTable == nil {
		return nil, 0
	}

	var bestSymbol *string
	var bestOffset uint64 = ^uint64(0)

	for _, sym := range symTable.symbols {
		if sym.LibIndex != libIndex {
			continue
		}

		if sym.Addr <= relativeAddr {
			offset := relativeAddr - sym.Addr
			if sym.Size > 0 && offset >= sym.Size {
				continue
			}
			if offset < bestOffset {
				bestOffset = offset
				bestSymbol = &sym.Name
			}
		}
	}

	if bestSymbol != nil {
		return bestSymbol, bestOffset
	}
	return nil, 0
}

func findLibraryForAddress(addr uint64) int {
	idx := sort.Search(len(libraryRanges), func(i int) bool {
		return libraryRanges[i].end > addr
	})

	for i := idx; i < len(libraryRanges); i++ {
		r := &libraryRanges[i]
		if addr >= r.start && addr < r.end {
			return r.libIndex
		}
	}

	for i := range libRoots {
		if libRoots[i].base > 0 {
			if addr >= libRoots[i].base && (libRoots[i].end == 0 || addr < libRoots[i].end) {
				return i
			}
		} else if i == 0 {
			return 0
		}
	}
	return -1
}

func addr2Name(addr uint64) (*string, uint64, error) {
	libIndex := findLibraryForAddress(addr)
	if libIndex < 0 {
		return nil, 0, errors.New("address not found in any library")
	}

	relativeAddr := addr
	if libRoots[libIndex].base > 0 {
		if addr >= libRoots[libIndex].base {
			relativeAddr = addr - libRoots[libIndex].base
		} else {
			return nil, 0, errors.New("address out of library range")
		}
	}

	if namePtr, err := addr2NameFromLibExact(libIndex, relativeAddr); err == nil && namePtr != nil {
		return namePtr, 0, nil
	}

	bestSymbol, bestOffset := findNearestSymbolInLib(libIndex, relativeAddr)
	if bestSymbol != nil {
		return bestSymbol, bestOffset, nil
	}

	return nil, 0, errors.New("symbol not found")
}

type Symbol struct {
	Name     string
	Addr     uint64
	Size     uint64
	Type     elf.SymType
	Bind     elf.SymBind
	Section  uint16
	LibIndex int
}

type SymbolTable struct {
	symbols      []Symbol
	addrToSymbol map[uint64]*Symbol
	nameToSymbol map[string]*Symbol
	addrNameMap  map[string]int
	rangeMap     map[uint64]*Symbol
	rangeDirty   bool
	sortedAddrs  []uint64
}

var symTable *SymbolTable

func NewSymbolTable() *SymbolTable {
	return &SymbolTable{
		symbols:      make([]Symbol, 0),
		addrToSymbol: make(map[uint64]*Symbol),
		nameToSymbol: make(map[string]*Symbol),
		addrNameMap:  make(map[string]int),
		rangeMap:     make(map[uint64]*Symbol),
		rangeDirty:   false,
		sortedAddrs:  nil,
	}
}

func (st *SymbolTable) AddSymbol(sym Symbol) {
	key := fmt.Sprintf("%x_%s_%d", sym.Addr, sym.Name, sym.LibIndex)

	actualAddr := sym.Addr
	if sym.LibIndex < len(libRoots) {
		actualAddr += libRoots[sym.LibIndex].base
	}

	if existingIdx, exists := st.addrNameMap[key]; exists {
		existing := &st.symbols[existingIdx]

		if sym.Size > existing.Size ||
			(sym.Size == existing.Size && sym.Bind == elf.STB_GLOBAL && existing.Bind == elf.STB_WEAK) {
			oldActualAddr := existing.Addr
			if existing.LibIndex < len(libRoots) {
				oldActualAddr += libRoots[existing.LibIndex].base
			}
			delete(st.rangeMap, oldActualAddr)
			delete(st.addrToSymbol, oldActualAddr)

			st.symbols[existingIdx] = sym
			st.addrToSymbol[actualAddr] = &st.symbols[existingIdx]
			st.nameToSymbol[sym.Name] = &st.symbols[existingIdx]
			st.rangeMap[actualAddr] = &st.symbols[existingIdx]
			st.rangeDirty = true

			addTreeToLib(sym.LibIndex, sym.Addr, &st.symbols[existingIdx].Name)
		}
		return
	}

	st.symbols = append(st.symbols, sym)
	newIdx := len(st.symbols) - 1

	st.addrToSymbol[actualAddr] = &st.symbols[newIdx]
	st.nameToSymbol[sym.Name] = &st.symbols[newIdx]
	st.addrNameMap[key] = newIdx
	st.rangeMap[actualAddr] = &st.symbols[newIdx]
	st.rangeDirty = true

	addTreeToLib(sym.LibIndex, sym.Addr, &st.symbols[newIdx].Name)
}

func (st *SymbolTable) getSortedAddresses() []uint64 {
	if !st.rangeDirty && st.sortedAddrs != nil {
		return st.sortedAddrs
	}

	st.sortedAddrs = st.sortedAddrs[:0]

	if cap(st.sortedAddrs) < len(st.rangeMap) {
		st.sortedAddrs = make([]uint64, 0, len(st.rangeMap))
	}

	for addr := range st.rangeMap {
		st.sortedAddrs = append(st.sortedAddrs, addr)
	}

	sort.Slice(st.sortedAddrs, func(i, j int) bool {
		return st.sortedAddrs[i] < st.sortedAddrs[j]
	})

	st.rangeDirty = false
	return st.sortedAddrs
}

func (dbger *TypeDbg) ldd() ([]string, error) {
	var lib []string
	out, err := exec.Command("ldd", dbger.path).Output()
	if err != nil {
		return nil, err
	}
	for i, f := range strings.Fields(string(out)) {
		if strings.HasPrefix(f, "(") {
			tmp := strings.Fields(string(out))[i-1]
			if strings.Contains(tmp, "/") {
				resolved, err := filepath.EvalSymlinks(tmp)
				if err != nil {
					tmp, _ = filepath.Abs(tmp)
				} else {
					tmp, _ = filepath.Abs(resolved)
				}
				lib = append(lib, tmp)
			}
		}
	}
	return lib, nil
}

func (dbger *TypeDbg) isPIE() (bool, error) {
	file, err := elf.Open(dbger.path)
	if err != nil {
		return false, err
	}
	defer file.Close()

	return file.Type == elf.ET_DYN, nil
}

func (dbger *TypeDbg) getBaseAddress(pid int, libPath string) (uint64, error) {
	mapsPath := fmt.Sprintf("/proc/%d/maps", pid)
	file, err := os.Open(mapsPath)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, libPath) {
			fields := strings.Fields(line)
			if len(fields) > 0 {
				addrRange := strings.Split(fields[0], "-")
				if len(addrRange) == 2 {
					baseAddr, err := strconv.ParseUint(addrRange[0], 16, 64)
					if err == nil {
						return baseAddr, nil
					}
				}
			}
		}
	}
	return 0, errors.New("base address not found")
}

func calculateLibraryEnd(libIndex int) uint64 {
	if libIndex >= len(libRoots) || symTable == nil {
		return 0
	}

	maxAddr := libRoots[libIndex].base
	for _, sym := range symTable.symbols {
		if sym.LibIndex != libIndex {
			continue
		}
		actualAddr := sym.Addr + libRoots[libIndex].base
		endAddr := actualAddr + sym.Size
		if endAddr > maxAddr {
			maxAddr = endAddr
		}
	}

	if maxAddr-libRoots[libIndex].base < 65536 {
		maxAddr = libRoots[libIndex].base + 65536
	}

	return maxAddr
}

func buildLibraryRanges() {
	libraryRanges = libraryRanges[:0]

	for i := range libRoots {
		end := calculateLibraryEnd(i)
		libRoots[i].end = end

		libraryRanges = append(libraryRanges, LibraryRange{
			libIndex: i,
			start:    libRoots[i].base,
			end:      end,
		})
	}

	sort.Slice(libraryRanges, func(i, j int) bool {
		return libraryRanges[i].start < libraryRanges[j].start
	})
}

func getByteOrder(file *elf.File) binary.ByteOrder {
	if file.Data == elf.ELFDATA2LSB {
		return binary.LittleEndian
	}
	return binary.BigEndian
}

func parseSymbol(data []byte, file *elf.File) ELFSymbol {
	var symbol ELFSymbol
	byteOrder := getByteOrder(file)

	if file.Class == elf.ELFCLASS64 {
		symbol.NameOffset = byteOrder.Uint32(data[0:4])
		symbol.Info = data[4]
		symbol.Other = data[5]
		symbol.Section = elf.SectionIndex(byteOrder.Uint16(data[6:8]))
		symbol.Value = byteOrder.Uint64(data[8:16])
		symbol.Size = byteOrder.Uint64(data[16:24])
	} else {
		symbol.NameOffset = byteOrder.Uint32(data[0:4])
		symbol.Value = uint64(byteOrder.Uint32(data[4:8]))
		symbol.Size = uint64(byteOrder.Uint32(data[8:12]))
		symbol.Info = data[12]
		symbol.Other = data[13]
		symbol.Section = elf.SectionIndex(byteOrder.Uint16(data[14:16]))
	}

	return symbol
}

func getSymbolName(nameOffset uint32, dynStrings []byte) string {
	if nameOffset >= uint32(len(dynStrings)) {
		return ""
	}

	end := nameOffset
	for end < uint32(len(dynStrings)) && dynStrings[end] != 0 {
		end++
	}

	return string(dynStrings[nameOffset:end])
}

func parseRelocations(section *elf.Section, file *elf.File) ([]Relocation, error) {
	data, err := section.Data()
	if err != nil {
		return nil, err
	}

	var relocations []Relocation
	var entrySize int

	if section.Type == elf.SHT_RELA {
		if file.Class == elf.ELFCLASS64 {
			entrySize = 24
		} else {
			entrySize = 12
		}
	} else if section.Type == elf.SHT_REL {
		if file.Class == elf.ELFCLASS64 {
			entrySize = 16
		} else {
			entrySize = 8
		}
	}

	entryCount := len(data) / entrySize
	byteOrder := getByteOrder(file)

	for i := 0; i < entryCount; i++ {
		entryData := data[i*entrySize : (i+1)*entrySize]
		var reloc Relocation

		if file.Class == elf.ELFCLASS64 {
			reloc.Offset = byteOrder.Uint64(entryData[0:8])
			reloc.Info = byteOrder.Uint64(entryData[8:16])
			reloc.SymbolIndex = uint32(reloc.Info >> 32)
			reloc.Type = uint32(reloc.Info & 0xffffffff)

			if section.Type == elf.SHT_RELA && len(entryData) >= 24 {
				reloc.Addend = int64(byteOrder.Uint64(entryData[16:24]))
			}
		} else {
			reloc.Offset = uint64(byteOrder.Uint32(entryData[0:4]))
			reloc.Info = uint64(byteOrder.Uint32(entryData[4:8]))
			reloc.SymbolIndex = uint32(reloc.Info >> 8)
			reloc.Type = uint32(reloc.Info & 0xff)

			if section.Type == elf.SHT_RELA && len(entryData) >= 12 {
				reloc.Addend = int64(int32(byteOrder.Uint32(entryData[8:12])))
			}
		}

		relocations = append(relocations, reloc)
	}

	return relocations, nil
}

func getPLTEntrySize(machine elf.Machine) int {
	switch machine {
	case elf.EM_X86_64:
		return 16
	case elf.EM_386:
		return 16
	case elf.EM_AARCH64:
		return 16
	case elf.EM_ARM:
		return 12
	default:
		return 16
	}
}

func loadDynamicSymbols(file *elf.File) ([]ELFSymbol, []byte, error) {
	dynsymSection := file.Section(".dynsym")
	if dynsymSection == nil {
		return nil, nil, fmt.Errorf(".dynsym section not found")
	}

	dynstrSection := file.Section(".dynstr")
	if dynstrSection == nil {
		return nil, nil, fmt.Errorf(".dynstr section not found")
	}

	dynstrData, err := dynstrSection.Data()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read .dynstr: %w", err)
	}

	dynsymData, err := dynsymSection.Data()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read .dynsym: %w", err)
	}

	var symbolSize int
	if file.Class == elf.ELFCLASS64 {
		symbolSize = 24
	} else {
		symbolSize = 16
	}

	symbolCount := len(dynsymData) / symbolSize
	dynSymbols := make([]ELFSymbol, symbolCount)

	for i := 0; i < symbolCount; i++ {
		symbolData := dynsymData[i*symbolSize : (i+1)*symbolSize]
		symbol := parseSymbol(symbolData, file)
		dynSymbols[i] = symbol
	}

	return dynSymbols, dynstrData, nil
}

func (dbger *TypeDbg) analyzePLTGOT(filename string) error {
	file, err := elf.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	dynSymbols, dynStrings, err := loadDynamicSymbols(file)
	if err != nil {
		return err
	}

	relPltSection := file.Section(".rela.plt")
	if relPltSection == nil {
		relPltSection = file.Section(".rel.plt")
	}

	if relPltSection != nil {
		relocations, err := parseRelocations(relPltSection, file)
		if err == nil {
			pltEntrySize := getPLTEntrySize(file.Machine)

			pltSecSection := file.Section(".plt.sec")
			if pltSecSection != nil {
				for i, reloc := range relocations {
					if reloc.SymbolIndex >= uint32(len(dynSymbols)) {
						continue
					}

					pltEntryAddr := pltSecSection.Addr + uint64(i*pltEntrySize)

					symbol := dynSymbols[reloc.SymbolIndex]
					symbolName := getSymbolName(symbol.NameOffset, dynStrings)
					if symbolName == "" {
						continue
					}

					pltName := symbolName + "@plt"
					if reloc.Addend != 0 {
						pltName += fmt.Sprintf("+0x%x", reloc.Addend)
					}

					pltSym := Symbol{
						Name:     pltName,
						Addr:     pltEntryAddr - libRoots[0].base,
						Size:     uint64(pltEntrySize),
						Type:     elf.STT_FUNC,
						Bind:     elf.STB_GLOBAL,
						Section:  0,
						LibIndex: 0,
					}
					symTable.AddSymbol(pltSym)
				}
			}

			pltSection := file.Section(".plt")
			if pltSection != nil {
				for i, reloc := range relocations {
					if reloc.SymbolIndex >= uint32(len(dynSymbols)) {
						continue
					}

					pltEntryAddr := pltSection.Addr + uint64((i+1)*pltEntrySize)

					symbol := dynSymbols[reloc.SymbolIndex]
					symbolName := getSymbolName(symbol.NameOffset, dynStrings)
					if symbolName == "" {
						continue
					}

					var pltName string
					if pltSecSection != nil {
						pltName = symbolName + "@plt.stub"
					} else {
						pltName = symbolName + "@plt"
						if reloc.Addend != 0 {
							pltName += fmt.Sprintf("+0x%x", reloc.Addend)
						}
					}

					pltSym := Symbol{
						Name:     pltName,
						Addr:     pltEntryAddr - libRoots[0].base,
						Size:     uint64(pltEntrySize),
						Type:     elf.STT_FUNC,
						Bind:     elf.STB_GLOBAL,
						Section:  0,
						LibIndex: 0,
					}
					symTable.AddSymbol(pltSym)
				}
			}
		}
	}

	gotSection := file.Section(".got.plt")
	if gotSection == nil {
		gotSection = file.Section(".got")
	}

	if gotSection != nil {
		gotData, err := gotSection.Data()
		if err == nil {
			var entrySize int
			if file.Class == elf.ELFCLASS64 {
				entrySize = 8
			} else {
				entrySize = 4
			}

			entryCount := len(gotData) / entrySize
			for i := 0; i < entryCount; i++ {
				gotAddr := gotSection.Addr + uint64(i*entrySize)
				gotName := fmt.Sprintf("GOT[%d]", i)

				gotSym := Symbol{
					Name:     gotName,
					Addr:     gotAddr - libRoots[0].base,
					Size:     uint64(entrySize),
					Type:     elf.STT_OBJECT,
					Bind:     elf.STB_GLOBAL,
					Section:  0,
					LibIndex: 0,
				}
				symTable.AddSymbol(gotSym)
			}
		}
	}

	return nil
}

func (dbger *TypeDbg) LoadSymbolsFromELF() error {
	if dbger.path == "" {
		return errors.New("invalid filename")
	}

	symTable = NewSymbolTable()
	libRoots = make([]rootStruct, 0)

	isPie, err := dbger.isPIE()
	if err != nil {
		return err
	}

	mainRoot := rootStruct{
		name: dbger.path,
		base: 0,
		end:  0,
		root: &symTree{p: make(map[uint8]*symTree)},
	}

	if isPie {
		mainRoot.base = 0
	}

	libRoots = append(libRoots, mainRoot)

	if err := dbger.loadSymbolsFromFile(dbger.path, 0); err != nil {
		return fmt.Errorf("failed to load main symbols: %v", err)
	}

	if err := dbger.analyzePLTGOT(dbger.path); err != nil {
		Printf("Warning: failed to analyze PLT/GOT: %v\n", err)
	}

	libs, err := dbger.ldd()
	var wg sync.WaitGroup
	wg.Add(len(libs))
	if err != nil {
		Printf("Warning: failed to get shared libraries: %v\n", err)
	} else {
		for _, lib := range libs {
			func() {
				defer wg.Done()
				libRoot := rootStruct{
					name: lib,
					base: 0,
					end:  0,
					root: &symTree{p: make(map[uint8]*symTree)},
				}
				libRoots = append(libRoots, libRoot)

				libIndex := len(libRoots) - 1
				if err := dbger.loadSymbolsFromFile(lib, libIndex); err != nil {
					Printf("Warning: failed to load symbols from %s: %v\n", lib, err)
				}
			}()
		}
	}
	wg.Wait()

	Printf("Loaded %d symbols from %d libraries\n", len(symTable.symbols), len(libRoots))
	go symTable.getSortedAddresses()

	return nil
}

func (dbger *TypeDbg) loadSymbolsFromFile(filename string, libIndex int) error {
	file, err := elf.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := dbger.loadSymbolSection(file, ".symtab", ".strtab", libIndex); err != nil {
		// Printf("failed to load static symbols from %s: %v\n", filename, err)
	}

	if err := dbger.loadSymbolSection(file, ".dynsym", ".dynstr", libIndex); err != nil {
		// Printf("failed to load dynamic symbols from %s: %v\n", filename, err)
	}

	return nil
}

func (dbger *TypeDbg) loadSymbolSection(file *elf.File, symSecName, strSecName string, libIndex int) error {
	var symSection *elf.Section
	for _, section := range file.Sections {
		if section.Name == symSecName {
			symSection = section
			break
		}
	}
	if symSection == nil {
		return fmt.Errorf("symbol section %s not found", symSecName)
	}

	var strSection *elf.Section
	for _, section := range file.Sections {
		if section.Name == strSecName {
			strSection = section
			break
		}
	}
	if strSection == nil {
		return fmt.Errorf("string section %s not found", strSecName)
	}

	_, err := strSection.Data()
	if err != nil {
		return fmt.Errorf("failed to read string table: %v", err)
	}

	var symbols []elf.Symbol
	if symSecName == ".symtab" {
		symbols, err = file.Symbols()
	} else {
		symbols, err = file.DynamicSymbols()
	}
	if err != nil {
		return fmt.Errorf("failed to read symbols: %v", err)
	}

	for _, sym := range symbols {
		if sym.Name == "" {
			continue
		}

		symType := elf.SymType(sym.Info & 0xf)
		isImportantSymbol := strings.Contains(sym.Name, "_start") ||
			strings.Contains(sym.Name, "_end") ||
			strings.Contains(sym.Name, "main") ||
			strings.Contains(sym.Name, "__") ||
			symType == elf.STT_FUNC ||
			symType == elf.STT_OBJECT ||
			sym.Info>>4 == uint8(elf.STB_GLOBAL)

		if sym.Value == 0 && !isImportantSymbol {
			continue
		}

		if symType == elf.STT_FILE || symType == elf.STT_SECTION {
			continue
		}

		symbol := Symbol{
			Name:     sym.Name,
			Addr:     sym.Value,
			Size:     sym.Size,
			Type:     symType,
			Bind:     elf.SymBind(sym.Info >> 4),
			Section:  uint16(sym.Section),
			LibIndex: libIndex,
		}

		symTable.AddSymbol(symbol)
	}

	return nil
}

var resolvedN int = 0

func (dbger *TypeDbg) Reload() error {
	if len(libRoots) == 0 {
		return errors.New("no libraries loaded")
	} else if len(libRoots) == resolvedN {
		return nil
	}
	resolvedN = 0

	isPie, err := dbger.isPIE()
	if err != nil {
		return err
	}

	if isPie {
		baseAddr, err := dbger.getBaseAddress(dbger.pid, libRoots[0].name)
		if err == nil {
			libRoots[0].base = baseAddr
			resolvedN++
		}
	}

	for i := 1; i < len(libRoots); i++ {
		baseAddr, err := dbger.getBaseAddress(dbger.pid, libRoots[i].name)
		if err == nil {
			libRoots[i].base = baseAddr
			resolvedN++
		}
	}

	if symTable != nil {
		newRangeMap := make(map[uint64]*Symbol)
		newAddrToSymbol := make(map[uint64]*Symbol)

		for _, sym := range symTable.symbols {
			actualAddr := sym.Addr
			if sym.LibIndex < len(libRoots) {
				actualAddr += libRoots[sym.LibIndex].base
			}
			newRangeMap[actualAddr] = &sym
			newAddrToSymbol[actualAddr] = &sym
		}

		symTable.rangeMap = newRangeMap
		symTable.addrToSymbol = newAddrToSymbol
		symTable.rangeDirty = true
		symTable.sortedAddrs = nil
	}

	buildLibraryRanges()

	return nil
}

func (dbger *TypeDbg) ResolveAddrToSymbol(addr uint64) (*Symbol, uint64, error) {
	if symTable == nil {
		return nil, 0, errors.New("symbols not loaded")
	}

	namePtr, offset, err := addr2Name(addr)
	if err != nil {
		return nil, 0, err
	}

	if sym, exists := symTable.nameToSymbol[*namePtr]; exists {
		return sym, offset, nil
	}

	return nil, 0, errors.New("symbol structure not found")
}

func (dbger *TypeDbg) ResolveSymbolToAddr(name string) (*Symbol, error) {
	if symTable == nil {
		return nil, errors.New("symbols not loaded")
	}

	if sym, exists := symTable.nameToSymbol[name]; exists {
		return sym, nil
	}

	var matches []*Symbol
	for symName, sym := range symTable.nameToSymbol {
		if strings.Contains(strings.ToLower(symName), strings.ToLower(name)) {
			matches = append(matches, sym)
		}
	}

	if len(matches) == 0 {
		return nil, fmt.Errorf("symbol '%s' not found", name)
	}

	if len(matches) == 1 {
		return matches[0], nil
	}

	Printf("Multiple symbols found for '%s':\n", name)
	for i, sym := range matches {
		actualAddr := sym.Addr
		if sym.LibIndex < len(libRoots) {
			actualAddr += libRoots[sym.LibIndex].base
		}
		libName := "unknown"
		if sym.LibIndex < len(libRoots) {
			libName = libRoots[sym.LibIndex].name
		}
		Printf("  %d: %s @ 0x%x (%s)\n", i, sym.Name, actualAddr, libName)
	}

	return matches[0], nil
}

func (dbger *TypeDbg) ListSymbols(filter string) error {
	if symTable == nil {
		return errors.New("symbols not loaded")
	}

	sortedAddrs := symTable.getSortedAddresses()

	if filter == "" {
		tempFile := fmt.Sprintf("/tmp/fastDbg_%d_%d", os.Getpid(), time.Now().Unix())
		file, err := os.Create(tempFile)
		if err != nil {
			return err
		}

		defer func() {
			file.Close()
			os.Remove(tempFile)
		}()

		fmt.Fprintf(file, "%-18s %-8s %-8s %-30s %s\n", "ADDRESS", "TYPE", "BIND", "LIBRARY", "NAME")
		fmt.Fprintf(file, "%s\n", strings.Repeat("-", 120))

		count := 0
		for _, actualAddr := range sortedAddrs {
			sym := symTable.rangeMap[actualAddr]
			libName := "unknown"
			if sym.LibIndex < len(libRoots) {
				libName = libRoots[sym.LibIndex].name
			}
			typeStr := symbolTypeString(sym.Type)
			bindStr := symbolBindString(sym.Bind)
			fmt.Fprintf(file, "0x%016x  %-8s %-8s %-30s %s\n", actualAddr, typeStr, bindStr, libName, sym.Name)
			count++
		}
		file.Close()

		cmd := exec.Command("less", "-SR", tempFile)
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			return err
		}

	} else {
		count := 0

		Printf("%-18s %-8s %-8s %-30s %s\n", "ADDRESS", "TYPE", "BIND", "LIBRARY", "NAME")
		Printf("%s\n", strings.Repeat("-", 120))

		for _, actualAddr := range sortedAddrs {
			sym := symTable.rangeMap[actualAddr]
			if !strings.Contains(strings.ToLower(sym.Name), strings.ToLower(filter)) {
				continue
			}

			libName := "unknown"
			if sym.LibIndex < len(libRoots) {
				libName = libRoots[sym.LibIndex].name
			}
			typeStr := symbolTypeString(sym.Type)
			bindStr := symbolBindString(sym.Bind)
			Printf("0x%016x  %-8s %-8s %-30s %s\n", actualAddr, typeStr, bindStr, libName, sym.Name)
			count++
		}

		if count == 0 {
			Printf("No symbols found matching '%s'\n", filter)
		}
	}

	return nil
}

func (dbger *TypeDbg) GetSymbolInfo(name string) error {
	sym, err := dbger.ResolveSymbolToAddr(name)
	if err != nil {
		return err
	}

	actualAddr := sym.Addr
	if sym.LibIndex < len(libRoots) {
		actualAddr += libRoots[sym.LibIndex].base
	}

	libName := "unknown"
	if sym.LibIndex < len(libRoots) {
		libName = libRoots[sym.LibIndex].name
	}

	Printf("Symbol: %s\n", sym.Name)
	Printf("Address: 0x%016x\n", actualAddr)
	Printf("Relative Address: 0x%016x\n", sym.Addr)
	Printf("Size: %d bytes\n", sym.Size)
	Printf("Type: %s\n", symbolTypeString(sym.Type))
	Printf("Bind: %s\n", symbolBindString(sym.Bind))
	Printf("Section: %d\n", sym.Section)
	Printf("Library: %s\n", libName)
	if sym.LibIndex < len(libRoots) {
		Printf("Base Address: 0x%016x\n", libRoots[sym.LibIndex].base)
	}

	return nil
}

func symbolTypeString(t elf.SymType) string {
	switch t {
	case elf.STT_NOTYPE:
		return "NOTYPE"
	case elf.STT_OBJECT:
		return "OBJECT"
	case elf.STT_FUNC:
		return "FUNC"
	case elf.STT_SECTION:
		return "SECTION"
	case elf.STT_FILE:
		return "FILE"
	case elf.STT_COMMON:
		return "COMMON"
	case elf.STT_TLS:
		return "TLS"
	default:
		return "UNKNOWN"
	}
}

func symbolBindString(b elf.SymBind) string {
	switch b {
	case elf.STB_LOCAL:
		return "LOCAL"
	case elf.STB_GLOBAL:
		return "GLOBAL"
	case elf.STB_WEAK:
		return "WEAK"
	default:
		return "UNKNOWN"
	}
}

func (dbger *TypeDbg) resolveSyms(addr uint64) {
	sym, offset, err := dbger.ResolveAddrToSymbol(addr)
	if err != nil {
		Printf("0x%016x: <no symbol>\n", addr)
		return
	}

	libName := ""
	if sym.LibIndex < len(libRoots) {
		fullPath := libRoots[sym.LibIndex].name
		if idx := strings.LastIndex(fullPath, "/"); idx >= 0 {
			libName = fmt.Sprintf(" [%s]", fullPath[idx+1:])
		} else {
			libName = fmt.Sprintf(" [%s]", fullPath)
		}
	}

	if offset == 0 {
		Printf("0x%016x: %s%s\n", addr, sym.Name, libName)
	} else {
		Printf("0x%016x: %s+0x%x%s\n", addr, sym.Name, offset, libName)
	}
}

func (dbger *TypeDbg) AnalyzePLTGOTInfo() ([]PLTEntry, []GOTEntry, error) {
	if dbger.path == "" {
		return nil, nil, errors.New("invalid filename")
	}

	file, err := elf.Open(dbger.path)
	if err != nil {
		return nil, nil, err
	}
	defer file.Close()

	dynSymbols, dynStrings, err := loadDynamicSymbols(file)
	if err != nil {
		return nil, nil, err
	}

	var pltEntries []PLTEntry
	var gotEntries []GOTEntry

	pltSection := file.Section(".plt.sec")
	if pltSection == nil {
		pltSection = file.Section(".plt")
	}

	if pltSection != nil {
		relPltSection := file.Section(".rela.plt")
		if relPltSection == nil {
			relPltSection = file.Section(".rel.plt")
		}

		if relPltSection != nil {
			relocations, err := parseRelocations(relPltSection, file)
			if err == nil {
				pltEntrySize := getPLTEntrySize(file.Machine)
				isModernPLT := (pltSection.Name == ".plt.sec")

				for i, reloc := range relocations {
					if reloc.SymbolIndex >= uint32(len(dynSymbols)) {
						continue
					}

					var pltEntryAddr uint64
					if isModernPLT {
						pltEntryAddr = pltSection.Addr + uint64(i*pltEntrySize)
					} else {
						pltEntryAddr = pltSection.Addr + uint64((i+1)*pltEntrySize)
					}

					symbol := dynSymbols[reloc.SymbolIndex]
					symbolName := getSymbolName(symbol.NameOffset, dynStrings)
					if symbolName == "" {
						continue
					}

					pltName := symbolName + "@plt"
					if reloc.Addend != 0 {
						pltName += fmt.Sprintf("+0x%x", reloc.Addend)
					}

					entry := PLTEntry{
						Address:      pltEntryAddr + libRoots[0].base,
						Name:         pltName,
						OriginalName: symbolName,
						Offset:       pltEntryAddr - pltSection.Addr,
						AddEnd:       reloc.Addend,
						IsSynthetic:  true,
					}
					pltEntries = append(pltEntries, entry)
				}
			}
		}
	}

	gotSection := file.Section(".got.plt")
	if gotSection == nil {
		gotSection = file.Section(".got")
	}

	if gotSection != nil {
		gotData, err := gotSection.Data()
		if err == nil {
			var entrySize int
			if file.Class == elf.ELFCLASS64 {
				entrySize = 8
			} else {
				entrySize = 4
			}

			entryCount := len(gotData) / entrySize
			byteOrder := getByteOrder(file)

			for i := 0; i < entryCount; i++ {
				entryData := gotData[i*entrySize : (i+1)*entrySize]
				var value uint64

				if entrySize == 8 {
					value = byteOrder.Uint64(entryData)
				} else {
					value = uint64(byteOrder.Uint32(entryData))
				}

				entry := GOTEntry{
					Address: gotSection.Addr + uint64(i*entrySize) + libRoots[0].base,
					Name:    fmt.Sprintf("GOT[%d]", i),
					Value:   value,
				}
				gotEntries = append(gotEntries, entry)
			}
		}
	}

	relPltSection := file.Section(".rela.plt")
	if relPltSection == nil {
		relPltSection = file.Section(".rel.plt")
	}

	if relPltSection != nil {
		pltRelocations, err := parseRelocations(relPltSection, file)
		if err == nil {
			for _, reloc := range pltRelocations {
				if reloc.SymbolIndex >= uint32(len(dynSymbols)) {
					continue
				}

				symbol := dynSymbols[reloc.SymbolIndex]
				symbolName := getSymbolName(symbol.NameOffset, dynStrings)
				if symbolName == "" {
					continue
				}

				for i := range gotEntries {
					if gotEntries[i].Address-libRoots[0].base == reloc.Offset {
						gotEntries[i].Name = symbolName
						break
					}
				}
			}
		}
	}

	relDynSection := file.Section(".rela.dyn")
	if relDynSection == nil {
		relDynSection = file.Section(".rel.dyn")
	}

	if relDynSection != nil {
		dynRelocations, err := parseRelocations(relDynSection, file)
		if err == nil {
			for _, reloc := range dynRelocations {
				if reloc.SymbolIndex >= uint32(len(dynSymbols)) {
					continue
				}

				symbol := dynSymbols[reloc.SymbolIndex]
				symbolName := getSymbolName(symbol.NameOffset, dynStrings)
				if symbolName == "" {
					continue
				}

				for i := range gotEntries {
					if gotEntries[i].Address-libRoots[0].base == reloc.Offset {
						gotEntries[i].Name = symbolName
						break
					}
				}
			}
		}
	}

	return pltEntries, gotEntries, nil
}

```

`symResolver.go`:

```go
package main

import (
	"strings"
)

type NativeSymbolResolver struct {
	dbg *TypeDbg
}

func NewNativeSymbolResolver(dbg *TypeDbg) *NativeSymbolResolver {
	return &NativeSymbolResolver{dbg: dbg}
}

func (r *NativeSymbolResolver) ResolveRegister(name string) (uint64, error) {
	return r.dbg.GetRegs(name)
}

func (r *NativeSymbolResolver) ResolveSymbol(name string) (uint64, error) {
	sym, err := r.dbg.ResolveSymbolToAddr(name)
	if err != nil {
		return 0, err
	}

	actualAddr := sym.Addr
	if sym.LibIndex < len(libRoots) {
		actualAddr += libRoots[sym.LibIndex].base
	}

	return actualAddr, nil
}

func (dbger *TypeDbg) resolveSymbolsNew(cmd string) (string, error) {
	if !strings.Contains(cmd, "$") {
		return cmd, nil
	}

	resolver := NewNativeSymbolResolver(dbger)
	return ResolveSymbolsInCommand(cmd, resolver)
}

```

`ui.go`:

```go
package main

import (
	"fastDbg/ebpf"
	"fmt"
	"github.com/chzyer/readline"
	"io"
	"os"
	"os/signal"
	"strings"
	"syscall"
)

func (dbger *TypeDbg) resolveSymbols(cmd string) (string, error) {
	return dbger.resolveSymbolsNew(cmd)
}

var interruptFlag = make(chan struct{}, 1)

func (dbger *TypeDbg) Interactive(doContext bool) {
	if err := dbger.LoadSymbolsFromELF(); err != nil {
		LogError("Failed to load symbols: %v", err)
	}

	if dbger.isStart && dbger.isProcessAlive() {
		if err := dbger.Reload(); err != nil {
			LogError("Failed to reload symbols: %v", err)
		}
	}

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT)
	defer signal.Stop(sigChan)

	go func() {
		for range sigChan {
			if dbger.isStart && dbger.isProcessAlive() && !dbger.isStopped() {
				if err := syscall.Kill(dbger.pid, syscall.SIGSTOP); err != nil {
					LogError("Failed to send SIGSTOP to process: %v", err)
					continue
				}
				select {
				case interruptFlag <- struct{}{}:
				default:
				}
			}
		}
	}()

	prev := ""

	rl, err := readline.NewEx(&readline.Config{
		Prompt:                 "[fastDbg]$ ",
		HistoryFile:            "/tmp/fastdbg_history.txt",
		InterruptPrompt:        "",
		EOFPrompt:              "exit",
		HistorySearchFold:      true,
		FuncFilterInputRune:    filterInput,
		DisableAutoSaveHistory: false,
	})
	if err != nil {
		panic(err)
	}
	defer rl.Close()

	if doContext {
		dbger.cmdContext(nil)
	}

	for {
		if ebpf.MapFlag {
			dbger.loadBase()
			ebpf.MapFlag = false
		}
		if !dbger.isStart {
			rl.SetPrompt("[fastDbg]$ ")
		} else {
			rl.SetPrompt(fmt.Sprintf("[%sfastDbg%s:%s0x%x%s]$ ", ColorCyan, ColorReset, ColorCyan, dbger.rip, ColorReset))
		}

		req, err := rl.Readline()
		if err != nil {
			if err == readline.ErrInterrupt {
				if dbger.isStart && dbger.isProcessAlive() {
					if !dbger.isStopped() {
						if err := dbger.interrupt(); err != nil {
							LogError("Failed to interrupt process: %v", err)
						} else {
							if _, waitErr := dbger.wait(); waitErr != nil {
								LogError("Failed to wait after interrupt: %v", waitErr)
							} else {
								if rip, ripErr := dbger.GetRip(); ripErr == nil {
									dbger.rip = rip
								}
								dbger.cmdContext(nil)
							}
						}
					}
				}
				continue
			}
			if err == io.EOF {
				break
			}
			continue
		}

		if req == "" {
			if prev == "" {
				continue
			}
			req = prev
		}

		if req == "q" || req == "exit" {
			break
		}

		prev = req

		resolvedReq := req
		if strings.Contains(req, "$") {
			var resolveErr error
			resolvedReq, resolveErr = dbger.resolveSymbols(req)
			if resolveErr != nil {
				LogError("Failed to resolve symbols in command: %v", resolveErr)
				LogError("Attempting to execute command anyway...")
			}
		}

		err = dbger.cmdExec(resolvedReq)

		if err != nil {
			LogError(err.Error())
		}
	}
}

func filterInput(r rune) (rune, bool) {
	switch r {
	case readline.CharCtrlZ:
		return r, false
	}
	return r, true
}

```

`utils.go`:

```go
package main

import (
	"fmt"
	"golang.org/x/term"
	"os"
	"runtime"
	"strings"
)

const (
	ColorReset  = "\033[0m"
	ColorRed    = "\033[31m"
	ColorGreen  = "\033[32m"
	ColorYellow = "\033[33m"
	ColorBlue   = "\033[34m"
	ColorPurple = "\033[35m"
	ColorCyan   = "\033[36m"
	ColorWhite  = "\033[37m"
	ColorBold   = "\033[1m"
)

var colorArray []string = []string{
	ColorRed,
	ColorGreen,
	ColorYellow,
	ColorBlue,
	ColorPurple,
	ColorCyan,
}

func LogError(msg string, a ...interface{}) {
	// Get caller information
	pc, _, _, ok := runtime.Caller(1)
	callerName := "unknown"
	if ok {
		fn := runtime.FuncForPC(pc)
		if fn != nil {
			callerName = fn.Name()
			// Extract just the function name (remove package path)
			if idx := strings.LastIndex(callerName, "/"); idx != -1 {
				callerName = callerName[idx+1:]
			}
		}
	}
	fmt.Printf("%s[ERROR]%s [%s] %s\n", ColorRed, ColorReset, callerName, fmt.Sprintf(msg, a...))
}

func Printf(msg string, a ...interface{}) {
	msg = strings.ReplaceAll(msg, "%d", "\033[36m%d\033[0m")
	msg = strings.ReplaceAll(msg, "0x%016x", "\033[36m0x%016x\033[0m")
	msg = strings.ReplaceAll(msg, "%016x", "\033[36m%016x\033[0m")
	msg = strings.ReplaceAll(msg, "%x", "\033[36m%x\033[0m")
	msg = strings.ReplaceAll(msg, "%s", "\033[32m%s\033[0m")

	fmt.Printf(msg, a...)
}

func hLine(msg string) {
	if term.IsTerminal(int(os.Stdout.Fd())) {
		w, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err == nil && w > 0 {
			fmt.Printf(strings.Repeat("-", (w-len(msg)-2)/2) + "[" + msg + "]" + strings.Repeat("-", (w-len(msg)-2)/2) + "\n")
			return
		}
	}
	fmt.Printf("[" + msg + "]")
}

func hLineRaw() {
	if term.IsTerminal(int(os.Stdout.Fd())) {
		w, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err == nil && w > 0 {
			fmt.Println(strings.Repeat("-", w))
			return
		}
	}
}

func cls() {
	fmt.Print("\033[2J")
	fmt.Print("\033[H")
}

```

`wp.go`:

```go
package main

import (
	"encoding/binary"
	"fmt"
	"golang.org/x/sys/unix"
)

/*
#include <sys/user.h>
#include <stddef.h>

unsigned long get_dr0_offset() {
    return offsetof(struct user, u_debugreg[0]);
}
unsigned long get_dr7_offset() {
    return offsetof(struct user, u_debugreg[7]);
}
*/
import "C"

const (
	WP_EXEC      = 0b00
	WP_WRITE     = 0b01
	WP_IO        = 0b10
	WP_READWRITE = 0b11
)

const (
	WP_SIZE_1 = 0b00 // 1 byte
	WP_SIZE_2 = 0b01 // 2 bytes
	WP_SIZE_8 = 0b10 // 8 bytes
	WP_SIZE_4 = 0b11 // 4 bytes
)

type wpStruct struct {
	flg  bool
	addr uint64
}

var slotList [4]wpStruct

func findEmpty() uint64 {
	for i, s := range slotList {
		if s.flg == false {
			return uint64(i)
		}
	}
	return uint64(0xdeadbeaf)
}

func (dbger *TypeDbg) SetWatchpoint(wpAddr uint64, wpSize uint64, wpCondition uint64) error {

	dr0off := uintptr(C.get_dr0_offset())
	dr7off := uintptr(C.get_dr7_offset())

	slot := findEmpty()
	if slot == uint64(0xdeadbeaf) {
		return fmt.Errorf("reached to maximum number of watch point")
	}

	buf := make([]byte, 8)
	err := doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePeekUser(dbger.pid, dr7off, buf)
		return err
	})
	if err != nil {
		return fmt.Errorf("PtracePeekUser failed")
	}

	dr7 := binary.LittleEndian.Uint64(buf)
	drOffset := dr0off + uintptr(slot*8)
	putBuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(putBuf, wpAddr)
	err = doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePokeUser(dbger.pid, drOffset, putBuf)
		return err
	})
	if err != nil {
		return fmt.Errorf("PtracePokeUser failed")
	}
	var enableBit uint64 = 1 << (slot * 2)
	enableBit |= (1 << 8)
	var cShift uint64 = 16 + (slot * 4)
	var cBits uint64 = wpCondition << cShift
	var sShift uint64 = 18 + (slot * 4)
	var sizeBits uint64 = wpSize << sShift

	clearMask := ^(uint64(0xF<<cShift) | uint64(3<<(slot*2)))
	newDR7 := (dr7 & clearMask) | enableBit | cBits | sizeBits

	drBuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(drBuf, newDR7)
	err = doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePokeUser(dbger.pid, dr0off, drBuf)
		return err
	})
	if err != nil {
		return err
	}

	slotList[slot] = wpStruct{
		flg:  true,
		addr: wpAddr,
	}

	return nil
}

func (dbger *TypeDbg) clearWatchpoint(slot uint64) error {
	if slot > uint64(len(slotList)) {
		for i, s := range slotList {
			if s.addr == slot {
				slot = uint64(i)
				break
			}
		}
	}

	dr0off := uintptr(C.get_dr0_offset())
	dr7off := uintptr(C.get_dr7_offset())

	dr0Off := dr0off + uintptr(slot*8)
	putBuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(putBuf, 0)
	err := doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePokeUser(dbger.pid, dr0Off, putBuf)
		return err
	})
	if err != nil {
		return fmt.Errorf("PtracePokeUser failed")
	}
	buf := make([]byte, 8)
	err = doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePeekUser(dbger.pid, dr7off, buf)
		return err
	})
	if err != nil {
		return fmt.Errorf("PtracePeekUser failed")
	}

	dr7 := binary.LittleEndian.Uint64(buf)

	clearMask := ^uint64(3 << (slot * 2))
	newDR7 := dr7 & clearMask

	drBuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(drBuf, newDR7)
	err = doSyscallErr(dbger.rpc, func() error {
		_, err := unix.PtracePokeUser(dbger.pid, dr7off, drBuf)
		return err
	})

	return err
}

```