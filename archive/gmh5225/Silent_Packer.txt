Project Path: arc_gmh5225_Silent_Packer_dn3g5r3t

Source Tree:

```txt
arc_gmh5225_Silent_Packer_dn3g5r3t
├── CMakeLists.txt
├── LICENSE.TXT
├── METHODS.md
├── README.md
├── TODO.md
├── bin
│   └── Silent_Packer
├── includes
│   ├── ELF
│   │   ├── elf_allocation.h
│   │   ├── elf_code_cave.h
│   │   ├── elf_deallocation.h
│   │   ├── elf_encryption.h
│   │   ├── elf_functions.h
│   │   ├── elf_packing.h
│   │   ├── elf_packing_method.h
│   │   ├── elf_section_insertion.h
│   │   ├── elf_silvio_infection.h
│   │   └── elf_writing.h
│   ├── PE
│   │   ├── pe_allocation.h
│   │   ├── pe_code_cave.h
│   │   ├── pe_deallocation.h
│   │   ├── pe_encryption.h
│   │   ├── pe_functions.h
│   │   ├── pe_packing.h
│   │   ├── pe_packing_method.h
│   │   ├── pe_section_insertion.h
│   │   ├── pe_struct.h
│   │   └── pe_writing.h
│   ├── STUB
│   │   ├── all_elf_loaders.h
│   │   ├── all_elf_loaders_infos.h
│   │   ├── all_loaders.h
│   │   ├── all_pe_loaders.h
│   │   ├── all_pe_loaders_infos.h
│   │   ├── amd64_aes_128_ecb_linux_elf_loader.h
│   │   ├── amd64_aes_128_ecb_win_pe_loader.h
│   │   ├── amd64_xor_linux_elf_loader.h
│   │   ├── amd64_xor_win_pe_loader.h
│   │   ├── i386_aes_128_ecb_linux_elf_loader.h
│   │   ├── i386_aes_128_ecb_win_pe_loader.h
│   │   ├── i386_xor_linux_elf_loader.h
│   │   └── i386_xor_win_pe_loader.h
│   ├── argtable3.h
│   ├── common
│   │   ├── aes_128_ecb_encryption.h
│   │   ├── cipher_functions.h
│   │   ├── file_functions.h
│   │   ├── loader_functions.h
│   │   └── packer_config.h
│   ├── main.h
│   └── packing_method.h
├── lib
│   └── src
│       └── argtable3.c
├── resources
│   ├── ELF_Section_Insertion.png
│   ├── ELF_Silvio_text_infection.png
│   ├── PE_Code_cave.png
│   ├── PE_structure.png
│   ├── elf_structure.svg
│   └── linking_execution_view.jpg
└── src
    ├── ELF
    │   ├── elf_allocation.c
    │   ├── elf_code_cave.c
    │   ├── elf_deallocation.c
    │   ├── elf_encryption.c
    │   ├── elf_functions.c
    │   ├── elf_packing.c
    │   ├── elf_packing_method.c
    │   ├── elf_section_insertion.c
    │   ├── elf_silvio_infection.c
    │   └── elf_writing.c
    ├── PE
    │   ├── pe_allocation.c
    │   ├── pe_code_cave.c
    │   ├── pe_deallocation.c
    │   ├── pe_encryption.c
    │   ├── pe_functions.c
    │   ├── pe_packing.c
    │   ├── pe_packing_method.c
    │   ├── pe_section_insertion.c
    │   └── pe_writing.c
    ├── STUB
    │   ├── amd64_aes_128_ecb_linux_elf_loader.asm
    │   ├── amd64_aes_128_ecb_win_pe_loader.asm
    │   ├── amd64_xor_linux_elf_loader.asm
    │   ├── amd64_xor_win_pe_loader.asm
    │   ├── i386_aes_128_ecb_linux_elf_loader.asm
    │   ├── i386_aes_128_ecb_win_pe_loader.asm
    │   ├── i386_xor_linux_elf_loader.asm
    │   └── i386_xor_win_pe_loader.asm
    ├── common
    │   ├── aes_128_ecb_encryption.asm
    │   ├── cipher_functions.c
    │   ├── file_functions.c
    │   ├── loader_functions.c
    │   └── packer_config.c
    ├── main.c
    └── utilities
        └── Silent_Log

```

`CMakeLists.txt`:

```txt
### Basic cmake setup ###

cmake_minimum_required(VERSION 3.2.1)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/staticlibs)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/staticlibs)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

set(CMAKE_C_FLAGS "-Wall")
set(CMAKE_C_FLAGS "-Wextra")

project(Silent_Packer)

# https://cliutils.gitlab.io/modern-cmake/chapters/projects/submodule.html
### Git Submodule management ###
find_package(Git REQUIRED)
if(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
    option(GIT_SUBMODULE "Check submodules during build" ON)
    if(GIT_SUBMODULE)
        message(STATUS "Submodule update")
        execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                RESULT_VARIABLE GIT_SUBMOD_RESULT)
        if(NOT GIT_SUBMOD_RESULT EQUAL "0")
            message(FATAL_ERROR "git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules")
        endif()
    endif()
endif()

if(NOT EXISTS "${PROJECT_SOURCE_DIR}/src/utilities/Silent_Log/log.c")
    message(FATAL_ERROR "The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.")
endif()


### NASM management ###
enable_language(ASM_NASM)
if(CMAKE_ASM_NASM_COMPILER_LOADED)
    set(CAN_USE_ASSEMBLER TRUE)

    # https://stackoverflow.com/questions/49131996/compile-asm-and-c-with-asm-for-debugging
    set(CMAKE_ASM_NASM_OBJECT_FORMAT elf64)
    set(CMAKE_ASM_NASM_COMPILE_OBJECT "<CMAKE_ASM_NASM_COMPILER> <INCLUDES> \
    <FLAGS> -f ${CMAKE_ASM_NASM_OBJECT_FORMAT} -o <OBJECT> <SOURCE>")
    set_source_files_properties(src/common/aes_128_ecb_encryption.asm PROPERTIES COMPILE_FLAGS "-g -Fdwarf")

    file(GLOB_RECURSE ENGINE_ASM_FILES "src/engine/*.asm")
    set(ENGINE_SOURCES ${ENGINE_SOURCES} ${ENGINE_ASM_FILES})
endif(CMAKE_ASM_NASM_COMPILER_LOADED)



### Includes ###
include_directories(includes)
include_directories(includes/ELF)
include_directories(includes/PE)
include_directories(includes/STUB)
include_directories(includes/common)
include_directories(src/utilities/Silent_Log)

### Sources ###
set(SOURCES src/main.c)

set(UTILITIES_SOURCES src/utilities/Silent_Log/log.c)
set(SOURCES ${SOURCES} ${UTILITIES_SOURCES})

set(ELF_SOURCES src/ELF/elf_allocation.c src/ELF/elf_functions.c src/ELF/elf_packing.c src/ELF/elf_encryption.c src/ELF/elf_section_insertion.c src/ELF/elf_writing.c src/ELF/elf_silvio_infection.c src/ELF/elf_code_cave.c src/ELF/elf_deallocation.c)
set(PE_SOURCES src/PE/pe_allocation.c src/PE/pe_functions.c src/PE/pe_writing.c src/PE/pe_packing.c src/PE/pe_code_cave.c src/PE/pe_packing_method.c src/PE/pe_encryption.c src/PE/pe_section_insertion.c src/PE/pe_deallocation.c)

set(COMMON_SOURCES ${ELF_SOURCES} ${PE_SOURCES} src/common/file_functions.c src/common/cipher_functions.c src/ELF/elf_packing_method.c src/common/loader_functions.c src/common/packer_config.c)

set(ASSEMBLY_SOURCES src/common/aes_128_ecb_encryption.asm)

set(SOURCES ${SOURCES} ${COMMON_SOURCES} ${ASSEMBLY_SOURCES})

add_executable(Silent_Packer ${SOURCES})
install(TARGETS Silent_Packer DESTINATION bin)

### Libs ###

### Static common libs ###
set(ARGTABLE_SOURCES lib/src/argtable3.c)
add_library(argtable3 STATIC ${ARGTABLE_SOURCES})

target_link_libraries(Silent_Packer argtable3 pthread m)

```

`LICENSE.TXT`:

```TXT
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

```

`METHODS.md`:

```md
This is a very basic explanation of the different file format structures and how does the different encryption methods used by Silent_Packer work.

# ELF

> In computing, the **Executable and Linkable Format** (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps.

## ELF Structure

![ELF Structure](resources/elf_structure.svg)

## ELF Code cave

**TODO**

## ELF Section Insertion

![ELF Section Insertion](resources/ELF_Section_Insertion.png)

## ELF Silvio Text Infection

![ELF Silvio Text Infection](resources/ELF_Silvio_text_infection.png)

# PE

> The **Portable Executable** (PE) format is a file format for executables, object code, DLLs and others used in 32-bit and 64-bit versions of Windows operating systems. The PE format is a data structure that encapsulates the information necessary for the Windows OS loader to manage the wrapped executable code.

## PE Structure

![PE Structure](resources/PE_structure.png)

## PE Code Cave

![PE Code Cave](resources/PE_Code_cave.png)

## PE Section Insertion

**TODO**
```

`README.md`:

```md
# Silent_Packer

Silent_Packer is an ELF / PE packer written in pure C.

This program can be used to obfuscate a binary. This packer supports PIE binaries.

My code is surely not perfect, do not hesitate to make pull requests or to contact me for any problems / code enhancement suggestion at [silentvoid13@protonmail.com](mailto:silentvoid13@protonmail.com).

## License

Silent_Packer is licensed under the GNU AGPLv3 license. Refer to [LICENSE](https://github.com/SilentVoid13/Silent_Packer/blob/master/LICENSE.txt) for more informations.

## What is a packer ?

> Binary packers alter the original binary data, and restore it (more or less) before execution.

Silent_Packer is a very basic and common packer, encrypting the code section from the binary (`.text`) and decrypting it before executing it. This technique can be used to obfuscate the binary code to bypass antiviruses or to make reverse engineering harder. Packers can also be used to compress a binary to reduce its size.

You can find a more detailed stackoverflow post [here](https://reverseengineering.stackexchange.com/questions/1779/what-are-the-different-types-of-packers).

## File formats

Silent_Packer currently support the following file formats :

- ELF64
- ELF32
- PE32+
- PE32

I will maybe add the MACH-O file format later. You can suggest me a file format that you want me to add.

## Cipher methods

Silent_Packer currently support the following cipher methods :

- XOR
- AES-128-ECB

Support for some more secure AES modes should arrive soon (AES-128-CBC, AES-256, ...)

You can suggest me a cipher method that you want me to add.

## Encryption methods

Silent_Packer currently support the following encryption methods :

- Section Insertion
- Code Cave
- Silvio Text Infection (only for ELF files)

For a basic explanation on how does these methods work, see the [METHODS](https://github.com/SilentVoid13/Silent_Packer/blob/master/METHODS.md) file.

## Usage

```bash
Usage: Silent_Packer [-hVvd] [-f file] [-c <xor, aes128_ecb>] [-m <section_insertion, code_cave, silvio_infection>] [-o file]
  -h, --help                Display this help and exit
  -V, --version             Display version info and exit
  -v, --verbose             Verbose output
  -d, --debug               Debug mode
  -f, --file=file           File to pack
  -c, --cipher=<xor, aes128_ecb> Cipher method to use
  -m, --method=<section_insertion, code_cave, silvio_infection> Method to pack the binary
  -o, --output=file         Output file
```

## Building

You can either get the compiled version from the latest [release](https://github.com/SilentVoid13/Silent_Packer/releases), from the [bin](https://github.com/SilentVoid13/Silent_Packer/tree/master/bin) directory, or compile it yourself.

This project relies on [Silent_Log](https://github.com/SilentVoid13/Silent_Log) for logging messages.

To build it yourself you will need `cmake`, `gcc` and `nasm`.

No windows version is available at the moment.

**On Linux**

```bash
mkdir build && cd build
cmake ..
make
make install
```

The compiled binary will be available in the **bin** directory.

## Known_bugs

Feel free to report any bugs, so that I can fix them.

The packer has some recurrent bugs with PE files, especially with big binaries with a lot of dynamic libs. The section insertion method has a weird behavior sometimes (adding some null bytes at the beginning of the section making the offsets wrong).

## Contributing

Feel free to contribute. See the [TODO](https://github.com/SilentVoid13/Silent_Packer/blob/master/TODO.md) list.

## Disclaimer

I am not responsible for what you do with the information and code provided. This is intended for professional or educational purposes only.
```

`TODO.md`:

```md

# Packer
- [x] Make README file
- [ ] Add dynamic library support
- [x] Add PIE support
    - Probably my nasm loader that needs to be changed
- [ ] Add new ciphers
    - [x] AES
- [x] Add PE Support
- [ ] Clean code
- [ ] Add mprotect in loader
- [x] Add functions prototypes
- [x] Add file recognition (ELF or PE)
- [x] Add file arch recognition (x32 or x64) 
- [x] Free malloc variables
- [x] Add submodule warning in makefile
- [ ] Add possibility to add a custom stub (no encryption just executing stub before jumping to main)
- [ ] Add more packing methods
- [ ] Change stub message

## ELF

### 32 bit
- [x] Add 32 bit support

### Section insertion
- [x] Add section name to the section string table
- [x] Fix string table errors

### Silvio infection
- [ ] Add possibility to add a big payload and add multiple PAGE_SIZE padding

### Code cave
- [x] Add code_cave support

### Heap allocated variables
- [x] file_data mmap - munmap

s_elf struct :

- [x] t_elf (elf_allocation)
- [x] elf_header (elf_allocation)
- [x] prog_header (elf_allocation)
- [x] section_header (elf_allocation)
- [x] section_data  (elf_allocation)
- [x] section_data\[i\] (elf_allocation)

- [x] loader (loader_functions)

## PE

### 32 bit
- [x] Add 32 bit support
    - Need to test it

### Code cave
- [ ] Clean code

### Section insertion
- [x] Add section insertion packing method
- [ ] Fix section insertion not working for every binary
    - Don't know why, but it's adding some null bytes at the beginning of the section making the offsets wrong when decrypting the .text

### Heap allocated variables

- [x] t_pe64 (pe_allocation)
- [x] dos_header (pe_allocation)
- [x] dos_stub (pe_allocation)
- [x] pe_header (pe_allocation)
- [x] section_header (pe_allocation)
- [x] section_data (pe_allocation)
- [x] section_data\[i\] (pe_allocation)

- [x] loader (loader_functions)

## AES

- [x] Add AES-128-ECB support for PE32, PE32+, ELF32
- [ ] Add AES-128-CBC
- [ ] Add AES-256

```

`includes/ELF/elf_allocation.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_ALLOCATION_H
#define SILENT_PACKER_ELF_ALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <elf.h>
#include <linux/elf-em.h>

// http://man7.org/linux/man-pages/man5/elf.5.html

typedef struct s_elf {
    enum{ELF32, ELF64} s_type;
} t_elf;

typedef struct s_elf64
{
    t_elf type_header;
    Elf64_Ehdr	*elf_header;
    Elf64_Phdr	*prog_header;
    Elf64_Shdr	*section_header;
    // Array of bytes for each section
    char **section_data;
} t_elf64;

typedef struct s_elf32 {
    t_elf type_header;
    Elf32_Ehdr	*elf_header;
    Elf32_Phdr	*prog_header;
    Elf32_Shdr	*section_header;
    // Array of bytes for each section
    char **section_data;
} t_elf32;

int allocate_elf_elf_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_program_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_sections_header(t_elf *elf, void *file_data, size_t file_data_size);
int allocate_elf_sections_data(t_elf *elf, void *file_data, size_t file_data_size);

int allocate_elf(t_elf **elf, void *file_data, size_t file_data_size);


#endif //SILENT_PACKER_ELF_ALLOCATION_H

```

`includes/ELF/elf_code_cave.h`:

```h
//
// Created by silentvoid on 3/7/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CODE_CAVE_H
#define SILENT_PACKER_CODE_CAVE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int find_elf_code_cave_index(t_elf *elf);
int set_new_elf_cave_segment_values(t_elf *elf, int segment_index);
int elf_cave_insert_loader(t_elf *elf, int section_index, int old_section_size);

int elf_code_cave_injection(t_elf *elf);

#endif //SILENT_PACKER_CODE_CAVE_H

```

`includes/ELF/elf_deallocation.h`:

```h
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_DEALLOCATION_H
#define SILENT_PACKER_ELF_DEALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

void deallocate_elf_elf_header(t_elf *elf);
void deallocate_elf_program_header(t_elf *elf);
void deallocate_elf_sections_header(t_elf *elf);
void deallocate_elf_sections_data(t_elf *elf);
void deallocate_elf_sections_data_data(t_elf *elf);
void deallocate_elf_struct(t_elf *elf);
void deallocate_elf(t_elf *elf);

#endif //SILENT_PACKER_ELF_DEALLOCATION_H

```

`includes/ELF/elf_encryption.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ENCRYPT_ELF_H
#define SILENT_PACKER_ENCRYPT_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int encrypt_elf(t_elf *elf);

#endif //SILENT_PACKER_ENCRYPT_ELF_H

```

`includes/ELF/elf_functions.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ELF_FUNCTIONS_H
#define SILENT_PACKER_ELF_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int set_new_elf_entry_to_section(t_elf *elf, int section_index);
int set_new_elf_entry_to_addr32(t_elf *elf, int32_t entry_address, int section_index, int section_size);
int set_new_elf_entry_to_addr64(t_elf *elf, int64_t entry_address, int section_index, int section_size);

int find_last_elf_segment_of_type(t_elf *elf, unsigned int p_type);
int find_last_elf_section_from_segment(t_elf *elf, int segment_index);
int find_elf_text_segment(t_elf *elf);
int find_elf_segment_index_of_section(t_elf *elf, int section_index);
char * find_elf_section_name(t_elf *elf, int index);
int find_elf_section_index(t_elf *elf, char *section_name);

void add_elf_segment_permission(t_elf *elf, int segment_index, int permission);

#endif //SILENT_PACKER_ELF_FUNCTIONS_H

```

`includes/ELF/elf_packing.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACK_ELF_H
#define SILENT_PACKER_PACK_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mhash.h>

int pack_elf(char *file, char *file_data, size_t file_data_size, char *output);

#endif //SILENT_PACKER_PACK_ELF_H

```

`includes/ELF/elf_packing_method.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_ELF_H
#define SILENT_PACKER_PACKING_METHOD_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

#include "packing_method.h"

int elf_pack_using_method(t_elf *elf);

#endif //SILENT_PACKER_PACKING_METHOD_ELF_H

```

`includes/ELF/elf_section_insertion.h`:

```h
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_SECTION_INSERTION_H
#define SILENT_PACKER_SECTION_INSERTION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "elf_allocation.h"

int set_new_elf_section_string_table(t_elf *elf);
int set_new_elf_section_symtab_sh_link_value(t_elf *elf);
int elf_section_create_new_section(t_elf *elf, int last_pt_load_index, int last_loadable_section_index);
void print_link_fields(t_elf *elf);
int set_new_elf_section_pt_loader_permissions(t_elf *elf);

int elf_insert_section(t_elf *elf);

#endif //SILENT_PACKER_SECTION_INSERTION_H

```

`includes/ELF/elf_silvio_infection.h`:

```h
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_SILVIO_INFECTION_H
#define SILENT_PACKER_SILVIO_INFECTION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ELF/elf_allocation.h"

#define PAGE_SIZE64 0x2000
#define PAGE_SIZE32 4096

int set_new_elf_silvio_segment_values(t_elf *elf, int text_segment_index);
int set_new_elf_silvio_section_values(t_elf *elf, int last_section_index);
int elf_silvio_insert_loader(t_elf *elf, int section_index, int old_section_size);

int elf_silvio_infect(t_elf *elf);

#endif //SILENT_PACKER_SILVIO_INFECTION_H

```

`includes/ELF/elf_writing.h`:

```h
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_WRITE_ELF_H
#define SILENT_PACKER_WRITE_ELF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "ELF/elf_allocation.h"

int write_elf(t_elf *elf, char *filename);

#endif //SILENT_PACKER_WRITE_ELF_H

```

`includes/PE/pe_allocation.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_ALLOCATION_H
#define SILENT_PACKER_PE_ALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_struct.h"

typedef struct s_pe {
    enum{PE32, PE64} s_type;
} t_pe;

typedef struct s_pe32 {
    t_pe type_header;
    IMAGE_DOS_HEADER *dos_header;
    char *dos_stub;
    IMAGE_NT_HEADERS32 *pe_header;
    IMAGE_SECTION_HEADER *section_header;
    char **section_data;
} t_pe32;

typedef struct s_pe64 {
    t_pe type_header;
    IMAGE_DOS_HEADER *dos_header;
    char *dos_stub;
    IMAGE_NT_HEADERS64 *pe_header;
    IMAGE_SECTION_HEADER *section_header;
    char **section_data;
} t_pe64;

/*
 * Can be a solution too
typedef struct s_pe {
    enum{PE32, PE64} s_type;

    union {
        t_pe64 pe64;
        t_pe32 pe32;
    };
} t_pe;
*/

int allocate_pe_dos_header(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_dos_stub(t_pe *pe, void *file_data);
int allocate_pe_pe_header(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_sections_headers(t_pe *pe, void *file_data, size_t file_data_size);
int allocate_pe_sections_data(t_pe *pe, void *file_data, size_t file_data_size);
void print_pe_info(t_pe *pe);

int allocate_pe(t_pe **pe, void *file_data, size_t file_data_size, int arch);

#endif //SILENT_PACKER_PE_ALLOCATION_H

```

`includes/PE/pe_code_cave.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CODE_CAVE_H
#define SILENT_PACKER_CODE_CAVE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int find_pe_code_cave_index(t_pe *pe);
int set_new_pe_cave_section_values(t_pe *pe, int section_index);
int pe_cave_insert_loader(t_pe *pe, int section_index, int old_section_size);

int pe_code_cave_injection(t_pe *pe);

#endif //SILENT_PACKER_CODE_CAVE_H

```

`includes/PE/pe_deallocation.h`:

```h
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_DEALLOCATION_H
#define SILENT_PACKER_PE_DEALLOCATION_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

void deallocate_pe_dos_header(t_pe *pe);
void deallocate_pe_dos_stub(t_pe *pe);
void deallocate_pe_pe_header(t_pe *pe);
void deallocate_pe_sections_headers(t_pe *pe);
void deallocate_pe_sections_data(t_pe *pe);
void deallocate_pe_sections_data_data(t_pe *pe);
void deallocate_pe_struct(t_pe *pe);
void deallocate_pe(t_pe *pe);

#endif //SILENT_PACKER_PE_DEALLOCATION_H

```

`includes/PE/pe_encryption.h`:

```h
//
// Created by silentvoid on 3/19/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ENCRYPT_PE_H
#define SILENT_PACKER_ENCRYPT_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int encrypt_pe(t_pe *pe);

#endif //SILENT_PACKER_ENCRYPT_PE_H

```

`includes/PE/pe_functions.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_FUNCTIONS_H
#define SILENT_PACKER_PE_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"

int set_new_pe_entry_to_section(t_pe *pe, int section_index);
int set_new_pe_entry_to_addr(t_pe *pe, uint32_t entry_addr, int section_index, int section_size);

int find_pe_text_section(t_pe *pe);
void add_pe_section_permission(t_pe *pe, int segment_index, int permission);
void print_pe_section_info(t_pe *pe, int section_index);

#endif //SILENT_PACKER_PE_FUNCTIONS_H

```

`includes/PE/pe_packing.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACK_PE_H
#define SILENT_PACKER_PACK_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int pack_pe(char *file, char *file_data, size_t file_data_size, char *output);

#endif //SILENT_PACKER_PACK_PE_H

```

`includes/PE/pe_packing_method.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_PE_H
#define SILENT_PACKER_PACKING_METHOD_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pe_allocation.h"
#include "packing_method.h"

int pe_pack_using_method(t_pe *pe);

#endif //SILENT_PACKER_PACKING_METHOD_PE_H

```

`includes/PE/pe_section_insertion.h`:

```h
//
// Created by silentvoid on 3/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_SECTION_INSERTION_H
#define SILENT_PACKER_PE_SECTION_INSERTION_H

#include "pe_allocation.h"

int add_new_pe_section_header(t_pe *pe);
int add_new_pe_section_data(t_pe *pe);
int set_new_pe_header_values(t_pe *pe);
void print_new_section_header_info(IMAGE_SECTION_HEADER *section_header);

int pe_insert_section(t_pe *pe);

#endif //SILENT_PACKER_PE_SECTION_INSERTION_H

```

`includes/PE/pe_struct.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PE_STRUCT_H
#define SILENT_PACKER_PE_STRUCT_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_SHORT_NAME 8

#define DOSMAG 0x5a4d

#define STR_DOSMAG "MZ"
#define SSTR_DOSMAG 2

#define PEMAG 0x00004550

#define DOS_STUB_SIZE 64

#define PE32MAG 0x10b
#define PE64MAG 0x20b

#define IMAGE_FILE_RELOCS_STRIPPED 0x0001 /**< No relocation info. */
#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008
#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010
#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020
#define IMAGE_FILE_16BIT_MACHINE 0x0040
#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080
#define IMAGE_FILE_32BIT_MACHINE 0x0100
#define IMAGE_FILE_DEBUG_STRIPPED 0x0200
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800
#define IMAGE_FILE_SYSTEM0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000

/* These are the settings of the Machine field. */
#define IMAGE_FILE_MACHINE_UNKNOWN 0x0 /**< COFF header's Machine field for
                                         unknown machine. */
#define IMAGE_FILE_MACHINE_I386 0x014c /**< COFF header's Machine field for
                                         I386 machines. */
#define IMAGE_FILE_MACHINE_ARM 0x01c0 /**< COFF header's Machine field for ARM
                                        machines. */
#define IMAGE_FILE_MACHINE_AMD64 0x8664 /**< COFF header's Machine field for
                                          AMD machines. */

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

#define IMAGE_DOS_SIGNATURE 0x5A4D /**< DOS header signature. Equals to 'MZ'. */
#define IMAGE_NT_SIGNATURE 0x00004550 /**< PE header signature. Equals to 'PE\0\0'. */
#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10B /**< OPTIONAL header 32bits signature. */
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20B /**< OPTIONAL header 64bits signature. */

#define IMAGE_SIZEOF_SHORT_NAME 8 /**< Max length for the section header's name field. */

#define IMAGE_SCN_CNT_CODE 0x00000020 /**< The section contains executable code. */
#define IMAGE_SCN_MEM_EXECUTE 0x20000000 /**< The section can be executed as code. */
#define IMAGE_SCN_MEM_READ 0x40000000 /**< The section can be read. */
#define IMAGE_SCN_MEM_WRITE 0x80000000 /**< The section can be written. */

/* PE classes */
#define PECLASSNONE 0 /**< Unknown class. */
#define PECLASS32 1 /**< 32-bit objects. */
#define PECLASS64 2 /**< 64-bit objects. */

typedef struct _IMAGE_DOS_HEADER {
    uint16_t e_magic; /**< DOS header signature. Must be equal to 'MZ' */
    uint16_t e_cblp; /**< Bytes on last page of file */
    uint16_t e_cp; /**< Pages in file */
    uint16_t e_crlc; /**< Relocations */
    uint16_t e_cparhdr; /**< Size of header in paragraphs */
    uint16_t e_minalloc; /**< Minimum extra paragraphs needed */
    uint16_t e_maxalloc; /**< Maximum extra paragraphs needed */
    uint16_t e_ss; /**< Initial (relative) SS value */
    uint16_t e_sp; /**< Initial SP value */
    uint16_t e_csum; /**< Checksum */
    uint16_t e_ip; /**< Initial IP value */
    uint16_t e_cs; /**< Initial (relative) CS value */
    uint16_t e_lfarlc; /**< File address of relocation table */
    uint16_t e_ovno; /**< Overlay number */
    uint16_t e_res[4]; /**< Reserved words */
    uint16_t e_oemid; /**< OEM identifier (for e_oeminfo) */
    uint16_t e_oeminfo; /**< OEM information; e_oemid specific */
    uint16_t e_res2[10]; /**< Reserved words */
    uint32_t e_lfanew; /**< Offset to extended header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    uint16_t  Machine;
    uint16_t  NumberOfSections;
    uint32_t TimeDateStamp;
    uint32_t PointerToSymbolTable;
    uint32_t NumberOfSymbols;
    uint16_t  SizeOfOptionalHeader;
    uint16_t  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    uint32_t VirtualAddress;
    uint32_t Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER32 {
    uint16_t Magic; /**< OPTIONAL header signature. Equals to
                      #IMAGE_NT_OPTIONAL_HDR32_MAGIC for 32bits EXE files. */
    uint8_t MajorLinkerVersion; /**< The version of the linker that produced the file. */
    uint8_t MinorLinkerVersion; /**< The version of the linker that produced the file. */
    uint32_t SizeOfCode; /**< The combined and rounded-up size of all the code
                           sections (most of the time, '.text' section). */
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUnitializedData;
    uint32_t AddressOfEntryPoint; /**< The address where the loader will begin
                                    the execution. */
    uint32_t BaseOfCode; /**< Relative virtual address where the code sections
                           begin. */
    uint32_t BaseOfData; /**< Relative virtual address where the data sections
                           begin. */
    uint32_t ImageBase; /**< Assumed location where the file will be
                          memory-mapped. */
    uint32_t SectionAlignment; /**< Alignment value for a section. */
    uint32_t FileAlignment; /**< Alignment value for the file's raw data. */
    uint16_t MajorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MinorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MajorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MinorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MajorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint16_t MinorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint32_t Win32VersionValue; /**< Reserved. */
    uint32_t SizeOfImage; /**< Total size starting from the image base to the
                            end of the last section. The end of the last
                            section is rounded up to the nearest multiple of
                            the #SectionAlignment value. */
    uint32_t SizeOfHeaders; /**< Size of the PE headers and the section table.
                              The raw section data starts immediately after all
                              the header components. */
    uint32_t CheckSum; /**< CRC checksum. Usualy ignored and set to 0. */
    uint16_t Subsystem; /**< Type of subsystem used for its user interface. */
    uint16_t DllCharacteristics; /**< Set of flags indicating under which
                                   circumstances a DLL's initialization
                                   function will be called. Appears to always
                                   be set to 0. */
    uint32_t SizeOfStackReserve; /**< The amount of virtual memory to reserve
                                   for the initial thread's stack. */
    uint32_t SizeOfStackCommit; /**< The amount of memory initially committed
                                  for the initial thread's stack. */
    uint32_t SizeOfHeapReserve; /**< The amount of virtual memory to reserve
                                  for the initial process heap. */
    uint32_t SizeOfHeapCommit; /**< The amount of memory initially committed in
                                 the process heap. */
    uint32_t LoaderFlags; /**< Debugging related field. */
    uint32_t NumberOfRvaAndSizes; /**< The number of entries in the
                                    #DataDirectory array. Always set to 16 by
                                    the tools. */
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /**< Array of #IMAGE_DATA_DIRECTORY structures. See WINNT.H. */
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    uint16_t Magic; /**< OPTIONAL header signature. Equals to
                      #IMAGE_NT_OPTIONAL_HDR64_MAGIC for 64bits EXE files. */
    uint8_t MajorLinkerVersion; /**< The version of the linker that produced the file. */
    uint8_t MinorLinkerVersion; /**< The version of the linker that produced the file. */
    uint32_t SizeOfCode; /**< The combined and rounded-up size of all the code
                           sections (most of the time, '.text' section). */
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint; /**< The address where the loader will begin
                                    the execution. */
    uint32_t BaseOfCode; /**< Relative virtual address where the code sections
                           begin. */
    uint64_t ImageBase; /**< Assumed location where the file will be
                          memory-mapped. */
    uint32_t SectionAlignment; /**< Alignment value for a section. */
    uint32_t FileAlignment; /**< Alignment value for the file's raw data. */
    uint16_t MajorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MinorOperatingSystemVersion; /**< The minimum version of the
                                            operating system required to use
                                            the executable. */
    uint16_t MajorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MinorImageVersion; /**< User-definable field to allow different
                                  version of an EXE file. */
    uint16_t MajorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint16_t MinorSubsystemVersion; /**< The minimum subsystem version required
                                      to run the EXE file. Typical value 3.10
                                      (meaning Windows NT 3.1). */
    uint32_t Win32VersionValue; /**< Reserved. */
    uint32_t SizeOfImage; /**< Total size starting from the image base to the
                            end of the last section. The end of the last
                            section is rounded up to the nearest multiple of
                            the #SectionAlignment value. */
    uint32_t SizeOfHeaders; /**< Size of the PE headers and the section table.
                              The raw section data starts immediately after all
                              the header components. */
    uint32_t CheckSum; /**< CRC checksum. Usualy ignored and set to 0. */
    uint16_t Subsystem; /**< Type of subsystem used for its user interface. */
    uint16_t DllCharacteristics; /**< Set of flags indicating under which
                                   circumstances a DLL's initialization
                                   function will be called. Appears to always
                                   be set to 0. */
    uint64_t SizeOfStackReserve; /**< The amount of virtual memory to reserve
                                   for the initial thread's stack. */
    uint64_t SizeOfStackCommit; /**< The amount of memory initially committed
                                  for the initial thread's stack. */
    uint64_t SizeOfHeapReserve; /**< The amount of memory initially committed
                                  in the process heap. */
    uint64_t SizeOfHeapCommit; /**< The amount of memory initially committed in
                                 the process heap. */
    uint32_t LoaderFlags; /**< Debugging related field. */
    uint32_t NumberOfRvaAndSizes; /**< The number of entries in the
                                    #DataDirectory array. Always set to 16 by
                                    the tools. */
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /**< Array of #IMAGE_DATA_DIRECTORY structures. See WINNT.H. */
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS32 {
    uint32_t Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32;

typedef struct _IMAGE_NT_HEADERS64 {
    uint32_t Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
    uint8_t Name[IMAGE_SIZEOF_SHORT_NAME]; /**< 8-bytes ANSI name of the
                                             section. If the length of the
                                             string is greater than 8, it is
                                             truncated without appending a NULL
                                             terminating byte. */
    union {
        uint32_t PhysicalAddress;
        uint32_t VirtualSize;
    } Misc; /**< Size of the code or the data before beeing rounded up to the
              nearest file alignment multiple. */
    uint32_t VirtualAddress; /**< Relative virtual address to where the loader
                               should map the section. */
    uint32_t SizeOfRawData; /**< Size of the section after beeing rounded up to
                              the nearest file alignment multiple. */
    uint32_t PointerToRawData; /**< File based offset to the raw data. */
    uint32_t PointerToRelocations; /**< Set to 0 for EXE files. */
    uint32_t PointerToLinenumbers; /**< File based offset to the line number
                                     table. */
    uint16_t NumberOfRelocations; /**< Irrelevant for EXE files. */
    uint16_t NumberOfLinenumbers; /**< Number of line numbers in the line
                                    number table for the section. */
    uint32_t Characteristics; /**< Set of flags describing the section.
                                (Readable, Writeable, Executable, etc.) */
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#endif //SILENT_PACKER_PE_STRUCT_H

```

`includes/PE/pe_writing.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_WRITE_PE_H
#define SILENT_PACKER_WRITE_PE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "pe_allocation.h"

int write_pe(t_pe *pe, char *filename);

#endif //SILENT_PACKER_WRITE_PE_H

```

`includes/STUB/all_elf_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_ELF_LOADERS_H
#define SILENT_PACKER_ALL_ELF_LOADERS_H

#include "i386_xor_linux_elf_loader.h"
#include "amd64_xor_linux_elf_loader.h"

#include "amd64_aes_128_ecb_linux_elf_loader.h"
#include "i386_aes_128_ecb_linux_elf_loader.h"

#endif //SILENT_PACKER_ALL_ELF_LOADERS_H

```

`includes/STUB/all_elf_loaders_infos.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H
#define SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H

#define NO_PAYLOAD
#include "all_elf_loaders.h"

#endif //SILENT_PACKER_ALL_ELF_LOADERS_INFOS_H

```

`includes/STUB/all_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_LOADERS_H
#define SILENT_PACKER_ALL_LOADERS_H

#include "all_elf_loaders.h"

#include "all_pe_loaders.h"

#endif //SILENT_PACKER_ALL_LOADERS_H

```

`includes/STUB/all_pe_loaders.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_PE_LOADERS_H
#define SILENT_PACKER_ALL_PE_LOADERS_H

#include "amd64_xor_win_pe_loader.h"
#include "i386_xor_win_pe_loader.h"

#include "amd64_aes_128_ecb_win_pe_loader.h"
#include "i386_aes_128_ecb_win_pe_loader.h"

#endif //SILENT_PACKER_ALL_PE_LOADERS_H

```

`includes/STUB/all_pe_loaders_infos.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_ALL_PE_LOADERS_INFOS_H
#define SILENT_PACKER_ALL_PE_LOADERS_INFOS_H

#define NO_PAYLOAD
#include "all_pe_loaders.h"

#endif //SILENT_PACKER_ALL_PE_LOADERS_INFOS_H

```

`includes/STUB/amd64_aes_128_ecb_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H
#define SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H

#define AMD64_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE 40
#define AMD64_AES_128_ECB_LINUX_ELF_LOADER_SIZE 480

#ifndef NO_PAYLOAD
unsigned char amd64_aes_128_ecb_linux_elf_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc7, 0x48,
0x8d, 0x35, 0x3c, 0x00, 0x00, 0x00, 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x4c, 0x8d, 0x25,
0xdc, 0xff, 0xff, 0xff, 0x4c, 0x2b, 0x25, 0xad, 0x01, 0x00, 0x00, 0xeb, 0x35, 0x66, 0x0f, 0x70,
0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04,
0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef,
0xca, 0xc3, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d,
0x0a, 0x00, 0xf3, 0x0f, 0x6f, 0x0d, 0x4e, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x05, 0x57, 0x01, 0x00,
0x00, 0x4c, 0x01, 0xe0, 0x48, 0x8b, 0x15, 0x55, 0x01, 0x00, 0x00, 0xf3, 0x0f, 0x6f, 0xc1, 0x66,
0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8, 0xa3, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x94, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x3a,
0xdf, 0xd1, 0x04, 0xe8, 0x85, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf1, 0x66, 0x0f, 0x3a, 0xdf,
0xd1, 0x08, 0xe8, 0x76, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x10, 0xe8, 0x67, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x20, 0xe8, 0x57, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xc9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x40, 0xe8, 0x47, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xd1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x80, 0xe8, 0x37, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xd9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x1b, 0xe8, 0x27, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
0x36, 0xe8, 0x17, 0xff, 0xff, 0xff, 0xf3, 0x44, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x38, 0xdb, 0xe4,
0x66, 0x0f, 0x38, 0xdb, 0xed, 0x66, 0x0f, 0x38, 0xdb, 0xf6, 0x66, 0x0f, 0x38, 0xdb, 0xff, 0x66,
0x45, 0x0f, 0x38, 0xdb, 0xc0, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xc9, 0x66, 0x45, 0x0f, 0x38, 0xdb,
0xd2, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xdb, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xe4, 0x4d, 0x31, 0xc0,
0x48, 0x83, 0xea, 0x10, 0xf3, 0x46, 0x0f, 0x6f, 0x3c, 0x00, 0x66, 0x45, 0x0f, 0xef, 0xfd, 0x66,
0x45, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfb, 0x66, 0x45, 0x0f, 0x38, 0xde,
0xfa, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf9, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf8, 0x66, 0x44, 0x0f,
0x38, 0xde, 0xff, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfe, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfd, 0x66,
0x44, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x44, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x46, 0x0f, 0x7f, 0x3c,
0x00, 0x49, 0x83, 0xc0, 0x10, 0x4c, 0x39, 0xc2, 0x7e, 0x02, 0xeb, 0xa8, 0x59, 0x5a, 0x5c, 0x5e,
0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_AES_128_ECB_LINUX_ELF_LOADER_H

```

`includes/STUB/amd64_aes_128_ecb_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H
#define SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H

#define AMD64_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE 40
#define AMD64_AES_128_ECB_WIN_PE_LOADER_SIZE 458

#ifndef NO_PAYLOAD
unsigned char amd64_aes_128_ecb_win_pe_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x4c, 0x8d, 0x25, 0xf2, 0xff, 0xff, 0xff, 0x4c, 0x2b,
        0x25, 0xad, 0x01, 0x00, 0x00, 0xeb, 0x35, 0x66, 0x0f, 0x70, 0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9,
        0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1,
        0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef, 0xca, 0xc3, 0x5b, 0x55, 0x6e, 0x70,
        0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xf3, 0x0f, 0x6f, 0x0d,
        0x4e, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x05, 0x57, 0x01, 0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48, 0x8b,
        0x15, 0x55, 0x01, 0x00, 0x00, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8,
        0xa3, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x94,
        0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x85, 0xff,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xf1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x08, 0xe8, 0x76, 0xff, 0xff,
        0xff, 0xf3, 0x0f, 0x6f, 0xf9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x10, 0xe8, 0x67, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0x57, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xc9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0x47, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xd1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x80, 0xe8, 0x37, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xd9, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x1b, 0xe8, 0x27, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x17, 0xff, 0xff, 0xff,
        0xf3, 0x44, 0x0f, 0x6f, 0xe9, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x66, 0x0f, 0x38, 0xdb, 0xed, 0x66,
        0x0f, 0x38, 0xdb, 0xf6, 0x66, 0x0f, 0x38, 0xdb, 0xff, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xc0, 0x66,
        0x45, 0x0f, 0x38, 0xdb, 0xc9, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xd2, 0x66, 0x45, 0x0f, 0x38, 0xdb,
        0xdb, 0x66, 0x45, 0x0f, 0x38, 0xdb, 0xe4, 0x4d, 0x31, 0xc0, 0x48, 0x83, 0xea, 0x10, 0xf3, 0x46,
        0x0f, 0x6f, 0x3c, 0x00, 0x66, 0x45, 0x0f, 0xef, 0xfd, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfc, 0x66,
        0x45, 0x0f, 0x38, 0xde, 0xfb, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xfa, 0x66, 0x45, 0x0f, 0x38, 0xde,
        0xf9, 0x66, 0x45, 0x0f, 0x38, 0xde, 0xf8, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xff, 0x66, 0x44, 0x0f,
        0x38, 0xde, 0xfe, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfd, 0x66, 0x44, 0x0f, 0x38, 0xde, 0xfc, 0x66,
        0x44, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x46, 0x0f, 0x7f, 0x3c, 0x00, 0x49, 0x83, 0xc0, 0x10, 0x4c,
        0x39, 0xc2, 0x7e, 0x02, 0xeb, 0xa8, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff,
        0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
        0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
        0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_AES_128_ECB_WIN_PE_LOADER_H

```

`includes/STUB/amd64_xor_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H
#define SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H

#define AMD64_XOR_LINUX_ELF_LOADER_INFOS_SIZE 32
#define AMD64_XOR_LINUX_ELF_LOADER_SIZE 146

#ifndef NO_PAYLOAD
unsigned char amd64_xor_linux_elf_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc7, 0x48,
0x8d, 0x35, 0x17, 0x00, 0x00, 0x00, 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x4c, 0x8d, 0x25,
0xdc, 0xff, 0xff, 0xff, 0x4c, 0x2b, 0x25, 0x5f, 0x00, 0x00, 0x00, 0xeb, 0x10, 0x5b, 0x55, 0x6e,
0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0x48, 0x8b, 0x05,
0x36, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x0d, 0x37, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x15, 0x20, 0x00,
0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48, 0x01, 0xc1, 0x30, 0x10, 0x48, 0xc1, 0xca, 0x08, 0x48, 0xff,
0xc0, 0x48, 0x39, 0xc8, 0x75, 0xf2, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff,
0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_XOR_LINUX_ELF_LOADER_H

```

`includes/STUB/amd64_xor_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H
#define SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H

#define AMD64_XOR_WIN_PE_LOADER_INFOS_SIZE 32
#define AMD64_XOR_WIN_PE_LOADER_SIZE 124

#ifndef NO_PAYLOAD
unsigned char amd64_xor_win_pe_loader_stub[] = {
        0x9c, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x4c, 0x8d, 0x25, 0xf2, 0xff, 0xff, 0xff, 0x4c, 0x2b,
        0x25, 0x5f, 0x00, 0x00, 0x00, 0xeb, 0x10, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e,
        0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0x48, 0x8b, 0x05, 0x36, 0x00, 0x00, 0x00, 0x48, 0x8b,
        0x0d, 0x37, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x15, 0x20, 0x00, 0x00, 0x00, 0x4c, 0x01, 0xe0, 0x48,
        0x01, 0xc1, 0x30, 0x10, 0x48, 0xc1, 0xca, 0x08, 0x48, 0xff, 0xc0, 0x48, 0x39, 0xc8, 0x75, 0xf2,
        0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0x9d, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc,
        0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_AMD64_XOR_WIN_PE_LOADER_H

```

`includes/STUB/i386_aes_128_ecb_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H
#define SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H

#define I386_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE 28
#define I386_AES_128_ECB_LINUX_ELF_LOADER_SIZE 658

#ifndef NO_PAYLOAD
unsigned char i386_aes_128_ecb_linux_elf_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x54, 0x00, 0x00, 0x00, 0x83, 0xea, 0xfe, 0x89,
0xd1, 0xba, 0x10, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x04, 0x00, 0x00, 0x00,
0xcd, 0x80, 0xe8, 0x39, 0x00, 0x00, 0x00, 0x83, 0xea, 0x65, 0x89, 0xd3, 0xe8, 0x2f, 0x00, 0x00,
0x00, 0x81, 0xea, 0xd7, 0xfd, 0xff, 0xff, 0x2b, 0x1a, 0xeb, 0x3c, 0x66, 0x0f, 0x70, 0xd2, 0xff,
0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f,
0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0x66, 0x0f, 0xef, 0xca, 0xc3,
0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e,
0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0xe4, 0xff, 0xff, 0xff, 0x81, 0xea, 0xdf, 0xfd,
0xff, 0xff, 0x8b, 0x02, 0x01, 0xd8, 0xe8, 0xd5, 0xff, 0xff, 0xff, 0x81, 0xea, 0xef, 0xfd, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0x0a, 0xe8, 0xc6, 0xff, 0xff, 0xff, 0x81, 0xea, 0xdb, 0xfd, 0xff, 0xff,
0x8b, 0x12, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x01, 0xe8, 0x8a, 0xff, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x6e, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x52, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38,
0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x08,
0xe8, 0x36, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec,
0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x10, 0xe8, 0x1a, 0xff, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0xfe, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f,
0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0xe2, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38,
0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x80,
0xe8, 0xc6, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec,
0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x1b, 0xe8, 0xaa, 0xfe, 0xff,
0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f,
0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x8e, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f,
0xe1, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x31, 0xc9, 0x83, 0xea, 0x10, 0xf3, 0x0f,
0x6f, 0xc8, 0xf3, 0x0f, 0x6f, 0x3c, 0x08, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66,
0x0f, 0xef, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc,
0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f,
0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83,
0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66,
0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde,
0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f,
0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24,
0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x0f, 0x38, 0xdf, 0xf8, 0xf3, 0x0f, 0x7f,
0x3c, 0x08, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x83, 0xc1, 0x10, 0x39, 0xca, 0x7e, 0x05, 0xe9,
0x5a, 0xff, 0xff, 0xff, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0x5b, 0x59, 0x5a, 0x5c, 0x5e, 0x5f,
0x58, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd, 0xee, 0xee,
0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_I386_AES_128_ECB_LINUX_ELF_LOADER_H

```

`includes/STUB/i386_aes_128_ecb_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H
#define SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H

#define I386_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE 28
#define I386_AES_128_ECB_WIN_PE_LOADER_SIZE 631

#ifndef NO_PAYLOAD
unsigned char i386_aes_128_ecb_win_pe_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x39, 0x00, 0x00, 0x00, 0x83, 0xea, 0x4a, 0x89,
        0xd3, 0xe8, 0x2f, 0x00, 0x00, 0x00, 0x81, 0xea, 0xd7, 0xfd, 0xff, 0xff, 0x2b, 0x1a, 0xeb, 0x3c,
        0x66, 0x0f, 0x70, 0xd2, 0xff, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1,
        0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb, 0xc5, 0xe1, 0x73, 0xf9, 0x04, 0x66, 0x0f, 0xef, 0xcb,
        0x66, 0x0f, 0xef, 0xca, 0xc3, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0x5b, 0x55, 0x6e, 0x70,
        0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0xe4, 0xff, 0xff,
        0xff, 0x81, 0xea, 0xdf, 0xfd, 0xff, 0xff, 0x8b, 0x02, 0x01, 0xd8, 0xe8, 0xd5, 0xff, 0xff, 0xff,
        0x81, 0xea, 0xef, 0xfd, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0x0a, 0xe8, 0xc6, 0xff, 0xff, 0xff, 0x81,
        0xea, 0xdb, 0xfd, 0xff, 0xff, 0x8b, 0x12, 0xf3, 0x0f, 0x6f, 0xc1, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x01, 0xe8, 0x8a, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x02, 0xe8, 0x6e, 0xff,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f,
        0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x04, 0xe8, 0x52, 0xff, 0xff, 0xff, 0xf3, 0x0f,
        0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66,
        0x0f, 0x3a, 0xdf, 0xd1, 0x08, 0xe8, 0x36, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
        0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x10, 0xe8, 0x1a, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x20, 0xe8, 0xfe, 0xfe,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f,
        0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x40, 0xe8, 0xe2, 0xfe, 0xff, 0xff, 0xf3, 0x0f,
        0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66,
        0x0f, 0x3a, 0xdf, 0xd1, 0x80, 0xe8, 0xc6, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f,
        0x38, 0xdb, 0xe4, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1,
        0x1b, 0xe8, 0xaa, 0xfe, 0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x66, 0x0f, 0x38, 0xdb, 0xe4, 0x83,
        0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x66, 0x0f, 0x3a, 0xdf, 0xd1, 0x36, 0xe8, 0x8e, 0xfe,
        0xff, 0xff, 0xf3, 0x0f, 0x6f, 0xe1, 0x83, 0xec, 0x10, 0xf3, 0x0f, 0x7f, 0x24, 0x24, 0x31, 0xc9,
        0x83, 0xea, 0x10, 0xf3, 0x0f, 0x6f, 0xc8, 0xf3, 0x0f, 0x6f, 0x3c, 0x08, 0xf3, 0x0f, 0x6f, 0x24,
        0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0xef, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10,
        0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38,
        0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3,
        0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24,
        0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4,
        0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f,
        0x38, 0xde, 0xfc, 0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc,
        0xf3, 0x0f, 0x6f, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x66, 0x0f, 0x38, 0xde, 0xfc, 0x66, 0x0f, 0x38,
        0xdf, 0xf8, 0xf3, 0x0f, 0x7f, 0x3c, 0x08, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x83, 0xc1, 0x10,
        0x39, 0xca, 0x7e, 0x05, 0xe9, 0x5a, 0xff, 0xff, 0xff, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0x5b,
        0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd,
        0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xee
};
#endif //NO_PAYLOAD

#endif //SILENT_PACKER_I386_AES_128_ECB_WIN_PE_LOADER_H

```

`includes/STUB/i386_xor_linux_elf_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_XOR_LINUX_LOADER_H
#define SILENT_PACKER_I386_XOR_LINUX_LOADER_H

#define I386_XOR_LINUX_ELF_LOADER_INFOS_SIZE 16
#define I386_XOR_LINUX_ELF_LOADER_SIZE 151

#ifndef NO_PAYLOAD
unsigned char i386_xor_linux_elf_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x3c, 0x00, 0x00, 0x00, 0x83, 0xea, 0x15, 0x89,
0xd1, 0xba, 0x10, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x04, 0x00, 0x00, 0x00,
0xcd, 0x80, 0xe8, 0x21, 0x00, 0x00, 0x00, 0x83, 0xea, 0x4d, 0x89, 0xd3, 0xe8, 0x17, 0x00, 0x00,
0x00, 0x83, 0xea, 0xba, 0x2b, 0x1a, 0xeb, 0x17, 0x5b, 0x55, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x69,
0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc3, 0xe8,
0xf4, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc2, 0x8b, 0x02, 0xe8, 0xea, 0xff, 0xff, 0xff, 0x83, 0xea,
0xbe, 0x8b, 0x0a, 0xe8, 0xe0, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc6, 0x8b, 0x12, 0x01, 0xd8, 0x01,
0xc1, 0x30, 0x10, 0xc1, 0xca, 0x04, 0x40, 0x39, 0xc8, 0x75, 0xf6, 0x5b, 0x59, 0x5a, 0x5c, 0x5e,
0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0x0f, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb, 0xbb, 0xcc,
0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_I386_XOR_LINUX_LOADER_H
```

`includes/STUB/i386_xor_win_pe_loader.h`:

```h
//
// Created by silentvoid on 4/2/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H
#define SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H

#define I386_XOR_WIN_PE_LOADER_INFOS_SIZE 16
#define I386_XOR_WIN_PE_LOADER_SIZE 124

#ifndef NO_PAYLOAD
unsigned char i386_xor_win_pe_loader_stub[] = {
        0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x53, 0xe8, 0x21, 0x00, 0x00, 0x00, 0x83, 0xea, 0x32, 0x89,
        0xd3, 0xe8, 0x17, 0x00, 0x00, 0x00, 0x83, 0xea, 0xba, 0x2b, 0x1a, 0xeb, 0x17, 0x5b, 0x55, 0x6e,
        0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x2e, 0x2e, 0x5d, 0x0a, 0x00, 0xe8, 0x00, 0x00,
        0x00, 0x00, 0x5a, 0xc3, 0xe8, 0xf4, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc2, 0x8b, 0x02, 0xe8, 0xea,
        0xff, 0xff, 0xff, 0x83, 0xea, 0xbe, 0x8b, 0x0a, 0xe8, 0xe0, 0xff, 0xff, 0xff, 0x83, 0xea, 0xc6,
        0x8b, 0x12, 0x01, 0xd8, 0x01, 0xc1, 0x30, 0x10, 0xc1, 0xca, 0x04, 0x40, 0x39, 0xc8, 0x75, 0xf6,
        0x5b, 0x59, 0x5a, 0x5c, 0x5e, 0x5f, 0x58, 0xe9, 0xfb, 0xff, 0xff, 0x0f, 0xaa, 0xaa, 0xaa, 0xaa,
        0xbb, 0xbb, 0xbb, 0xbb, 0xcc, 0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xdd
};
#endif // NO_PAYLOAD

#endif //SILENT_PACKER_I386_XOR_WIN_PE_LOADER_H

```

`includes/argtable3.h`:

```h
/*******************************************************************************
 * argtable3: Declares the main interfaces of the library
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#ifndef ARGTABLE3
#define ARGTABLE3

// CUSTOM HEADER
void display_argtable_help(char *progname, void **argtable);
//


#include <stdio.h> /* FILE */
#include <time.h>  /* struct tm */

#ifdef __cplusplus
extern "C" {
#endif

#define ARG_REX_ICASE 1
#define ARG_DSTR_SIZE 200
#define ARG_CMD_NAME_LEN 100
#define ARG_CMD_DESCRIPTION_LEN 256

#ifndef ARG_REPLACE_GETOPT
#define ARG_REPLACE_GETOPT 1 /* use the embedded getopt as the system getopt(3) */
#endif                       /* ARG_REPLACE_GETOPT */

/* bit masks for arg_hdr.flag */
enum { ARG_TERMINATOR = 0x1, ARG_HASVALUE = 0x2, ARG_HASOPTVALUE = 0x4 };

#if defined(_WIN32)
  #if defined(argtable3_EXPORTS)
    #define ARG_EXTERN __declspec(dllexport)
  #elif defined(argtable3_IMPORTS)
    #define ARG_EXTERN __declspec(dllimport)
  #else
    #define ARG_EXTERN
  #endif
#else
  #define ARG_EXTERN
#endif

typedef struct _internal_arg_dstr* arg_dstr_t;
typedef void* arg_cmd_itr_t;

typedef void(arg_resetfn)(void* parent);
typedef int(arg_scanfn)(void* parent, const char* argval);
typedef int(arg_checkfn)(void* parent);
typedef void(arg_errorfn)(void* parent, arg_dstr_t ds, int error, const char* argval, const char* progname);
typedef void(arg_dstr_freefn)(char* buf);
typedef int(arg_cmdfn)(int argc, char* argv[], arg_dstr_t res);
typedef int(arg_comparefn)(const void* k1, const void* k2);

/*
 * The arg_hdr struct defines properties that are common to all arg_xxx structs.
 * The argtable library requires each arg_xxx struct to have an arg_hdr
 * struct as its first data member.
 * The argtable library functions then use this data to identify the
 * properties of the command line option, such as its option tags,
 * datatype string, and glossary strings, and so on.
 * Moreover, the arg_hdr struct contains pointers to custom functions that
 * are provided by each arg_xxx struct which perform the tasks of parsing
 * that particular arg_xxx arguments, performing post-parse checks, and
 * reporting errors.
 * These functions are private to the individual arg_xxx source code
 * and are the pointer to them are initiliased by that arg_xxx struct's
 * constructor function. The user could alter them after construction
 * if desired, but the original intention is for them to be set by the
 * constructor and left unaltered.
 */
struct arg_hdr {
    char flag;             /* Modifier flags: ARG_TERMINATOR, ARG_HASVALUE. */
    const char* shortopts; /* String defining the short options */
    const char* longopts;  /* String defiing the long options */
    const char* datatype;  /* Description of the argument data type */
    const char* glossary;  /* Description of the option as shown by arg_print_glossary function */
    int mincount;          /* Minimum number of occurences of this option accepted */
    int maxcount;          /* Maximum number of occurences if this option accepted */
    void* parent;          /* Pointer to parent arg_xxx struct */
    arg_resetfn* resetfn;  /* Pointer to parent arg_xxx reset function */
    arg_scanfn* scanfn;    /* Pointer to parent arg_xxx scan function */
    arg_checkfn* checkfn;  /* Pointer to parent arg_xxx check function */
    arg_errorfn* errorfn;  /* Pointer to parent arg_xxx error function */
    void* priv;            /* Pointer to private header data for use by arg_xxx functions */
};

struct arg_rem {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
};

struct arg_lit {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    int count;          /* Number of matching command line args */
};

struct arg_int {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    int count;          /* Number of matching command line args */
    int* ival;          /* Array of parsed argument values */
};

struct arg_dbl {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    int count;          /* Number of matching command line args */
    double* dval;       /* Array of parsed argument values */
};

struct arg_str {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    int count;          /* Number of matching command line args */
    const char** sval;  /* Array of parsed argument values */
};

struct arg_rex {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    int count;          /* Number of matching command line args */
    const char** sval;  /* Array of parsed argument values */
};

struct arg_file {
    struct arg_hdr hdr;     /* The mandatory argtable header struct */
    int count;              /* Number of matching command line args*/
    const char** filename;  /* Array of parsed filenames  (eg: /home/foo.bar) */
    const char** basename;  /* Array of parsed basenames  (eg: foo.bar) */
    const char** extension; /* Array of parsed extensions (eg: .bar) */
};

struct arg_date {
    struct arg_hdr hdr; /* The mandatory argtable header struct */
    const char* format; /* strptime format string used to parse the date */
    int count;          /* Number of matching command line args */
    struct tm* tmval;   /* Array of parsed time values */
};

enum { ARG_ELIMIT = 1, ARG_EMALLOC, ARG_ENOMATCH, ARG_ELONGOPT, ARG_EMISSARG };
struct arg_end {
    struct arg_hdr hdr;  /* The mandatory argtable header struct */
    int count;           /* Number of errors encountered */
    int* error;          /* Array of error codes */
    void** parent;       /* Array of pointers to offending arg_xxx struct */
    const char** argval; /* Array of pointers to offending argv[] string */
};

typedef struct arg_cmd_info {
    char name[ARG_CMD_NAME_LEN];
    char description[ARG_CMD_DESCRIPTION_LEN];
    arg_cmdfn* proc;
} arg_cmd_info_t;

/**** arg_xxx constructor functions *********************************/

ARG_EXTERN struct arg_rem* arg_rem(const char* datatype, const char* glossary);

ARG_EXTERN struct arg_lit* arg_lit0(const char* shortopts, const char* longopts, const char* glossary);
ARG_EXTERN struct arg_lit* arg_lit1(const char* shortopts, const char* longopts, const char* glossary);
ARG_EXTERN struct arg_lit* arg_litn(const char* shortopts, const char* longopts, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_key* arg_key0(const char* keyword, int flags, const char* glossary);
ARG_EXTERN struct arg_key* arg_key1(const char* keyword, int flags, const char* glossary);
ARG_EXTERN struct arg_key* arg_keyn(const char* keyword, int flags, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_int* arg_int0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_int* arg_int1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_int* arg_intn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_dbl* arg_dbl0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_dbl* arg_dbl1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_dbl* arg_dbln(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_str* arg_str0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_str* arg_str1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_str* arg_strn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_rex* arg_rex0(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary);
ARG_EXTERN struct arg_rex* arg_rex1(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary);
ARG_EXTERN struct arg_rex* arg_rexn(const char* shortopts,
                         const char* longopts,
                         const char* pattern,
                         const char* datatype,
                         int mincount,
                         int maxcount,
                         int flags,
                         const char* glossary);

ARG_EXTERN struct arg_file* arg_file0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_file* arg_file1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_file* arg_filen(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_date* arg_date0(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_date* arg_date1(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary);
ARG_EXTERN struct arg_date* arg_daten(const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char* glossary);

ARG_EXTERN struct arg_end* arg_end(int maxerrors);

#define ARG_DSTR_STATIC ((arg_dstr_freefn*)0)
#define ARG_DSTR_VOLATILE ((arg_dstr_freefn*)1)
#define ARG_DSTR_DYNAMIC ((arg_dstr_freefn*)3)

/**** other functions *******************************************/
ARG_EXTERN int arg_nullcheck(void** argtable);
ARG_EXTERN int arg_parse(int argc, char** argv, void** argtable);
ARG_EXTERN void arg_print_option(FILE* fp, const char* shortopts, const char* longopts, const char* datatype, const char* suffix);
ARG_EXTERN void arg_print_syntax(FILE* fp, void** argtable, const char* suffix);
ARG_EXTERN void arg_print_syntaxv(FILE* fp, void** argtable, const char* suffix);
ARG_EXTERN void arg_print_glossary(FILE* fp, void** argtable, const char* format);
ARG_EXTERN void arg_print_glossary_gnu(FILE* fp, void** argtable);
ARG_EXTERN void arg_print_errors(FILE* fp, struct arg_end* end, const char* progname);
ARG_EXTERN void arg_print_option_ds(arg_dstr_t ds, const char* shortopts, const char* longopts, const char* datatype, const char* suffix);
ARG_EXTERN void arg_print_syntax_ds(arg_dstr_t ds, void** argtable, const char* suffix);
ARG_EXTERN void arg_print_syntaxv_ds(arg_dstr_t ds, void** argtable, const char* suffix);
ARG_EXTERN void arg_print_glossary_ds(arg_dstr_t ds, void** argtable, const char* format);
ARG_EXTERN void arg_print_glossary_gnu_ds(arg_dstr_t ds, void** argtable);
ARG_EXTERN void arg_print_errors_ds(arg_dstr_t ds, struct arg_end* end, const char* progname);
ARG_EXTERN void arg_freetable(void** argtable, size_t n);

ARG_EXTERN arg_dstr_t arg_dstr_create();
ARG_EXTERN void arg_dstr_destroy(arg_dstr_t ds);
ARG_EXTERN void arg_dstr_reset(arg_dstr_t ds);
ARG_EXTERN void arg_dstr_free(arg_dstr_t ds);
ARG_EXTERN void arg_dstr_set(arg_dstr_t ds, char* str, arg_dstr_freefn* free_proc);
ARG_EXTERN void arg_dstr_cat(arg_dstr_t ds, char* str);
ARG_EXTERN void arg_dstr_catf(arg_dstr_t ds, const char* fmt, ...);
ARG_EXTERN char* arg_dstr_cstr(arg_dstr_t ds);

ARG_EXTERN void arg_cmd_init(void);
ARG_EXTERN void arg_cmd_uninit(void);
ARG_EXTERN void arg_cmd_register(const char* name, arg_cmdfn* proc, const char* description);
ARG_EXTERN void arg_cmd_unregister(const char* name);
ARG_EXTERN int arg_cmd_dispatch(const char* name, int argc, char* argv[], arg_dstr_t res);
ARG_EXTERN unsigned int arg_cmd_count(void);
ARG_EXTERN arg_cmd_info_t* arg_cmd_info(const char* name);
ARG_EXTERN arg_cmd_itr_t arg_cmd_itr_create(void);
ARG_EXTERN void arg_cmd_itr_destroy(arg_cmd_itr_t itr);
ARG_EXTERN int arg_cmd_itr_advance(arg_cmd_itr_t itr);
ARG_EXTERN char* arg_cmd_itr_key(arg_cmd_itr_t itr);
ARG_EXTERN arg_cmd_info_t* arg_cmd_itr_value(arg_cmd_itr_t itr);
ARG_EXTERN int arg_cmd_itr_search(arg_cmd_itr_t itr, void* k);
ARG_EXTERN void arg_mgsort(void* data, int size, int esize, int i, int k, arg_comparefn* comparefn);
ARG_EXTERN void arg_make_get_help_msg(arg_dstr_t res);
ARG_EXTERN void arg_make_help_msg(arg_dstr_t ds, char* cmd_name, void** argtable);
ARG_EXTERN void arg_make_syntax_err_msg(arg_dstr_t ds, void** argtable, struct arg_end* end);
ARG_EXTERN int arg_make_syntax_err_help_msg(arg_dstr_t ds, char* name, int help, int nerrors, void** argtable, struct arg_end* end, int* exitcode);
ARG_EXTERN void arg_set_module_name(const char* name);
ARG_EXTERN void arg_set_module_version(int major, int minor, int patch, const char* tag);

/**** deprecated functions, for back-compatibility only ********/
ARG_EXTERN void arg_free(void** argtable);

#ifdef __cplusplus
}
#endif
#endif

```

`includes/common/aes_128_ecb_encryption.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_AES_128_ECB_ENCRYPTION_H
#define SILENT_PACKER_AES_128_ECB_ENCRYPTION_H

void aes_128_ecb_encrypt(char *data, size_t data_size, unsigned char *key, size_t key_size);

#endif //SILENT_PACKER_AES_128_ECB_ENCRYPTION_H

```

`includes/common/cipher_functions.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_CIPHER_FUNCTIONS_H
#define SILENT_PACKER_CIPHER_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <time.h>

extern uint32_t text_data_size32;
extern uint32_t text_entry_point32;
extern uint32_t cipher_key32;

extern uint64_t text_data_size64;
extern uint64_t text_entry_point64;
extern uint64_t cipher_key64;

extern unsigned char cipher_key128[17];

uint32_t generate_random_key32();
uint64_t generate_random_key64();
void generate_random_key128();

uint32_t rotate_right32(uint32_t value);
uint64_t rotate_right64(uint64_t value);

int xor_encrypt32(char *data, size_t data_size, uint32_t key);
int xor_encrypt64(char *data, size_t data_size, uint64_t key);

#endif //SILENT_PACKER_CIPHER_FUNCTIONS_H

```

`includes/common/file_functions.h`:

```h
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_FILE_FUNCTIONS_H
#define SILENT_PACKER_FILE_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mhash.h>

#define ELF_FILE        1
#define PE_FILE         2
#define UNKNOWN_FILE    (-1)

#define x32_ARCH        32
#define x64_ARCH        64
#define UNKNOWN_ARCH    (-1)

int allocate_file(char *file, void **file_data, size_t *file_data_size);
int write_to_file(int fd, void *data, size_t data_size);
int dump_to_file(char *filename, char *data, size_t data_size);
void add_zero_padding(int fd, size_t end_offset);
int check_magic_bytes(char *file_data, size_t file_data_size);
int get_elf_arch(const char *file_data, size_t file_data_size);
int get_pe_arch(const char *file_data, size_t file_data_size);

#endif //SILENT_PACKER_FILE_FUNCTIONS_H

```

`includes/common/loader_functions.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_LOADER_FUNCTIONS_H
#define SILENT_PACKER_LOADER_FUNCTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define CIPHER_KEY_OFFSET32_AES     28
#define CIPHER_KEY_OFFSET32         16
#define TEXT_ENTRY_POINT_OFFSET32   12
#define TEXT_DATA_SIZE_OFFSET32     8
#define LOADER_OFFSET_OFFSET32      4

#define CIPHER_KEY_OFFSET64_AES     40
#define CIPHER_KEY_OFFSET64         32
#define TEXT_ENTRY_POINT_OFFSET64   24
#define TEXT_DATA_SIZE_OFFSET64     16
#define LOADER_OFFSET_OFFSET64      8


extern uint32_t text_data_size32;
extern uint32_t text_entry_point32;
extern uint32_t cipher_key32;
extern uint32_t loader_offset32;

extern uint64_t text_data_size64;
extern uint64_t text_entry_point64;
extern uint64_t cipher_key64;
extern uint64_t loader_offset64;

char * patch_loader();

#endif //SILENT_PACKER_LOADER_FUNCTIONS_H

```

`includes/common/packer_config.h`:

```h
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKER_CONFIG_H
#define SILENT_PACKER_PACKER_CONFIG_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX_CIPHER_LENGTH 20
#define MAX_PACKING_METHOD_LENGTH 40

struct s_packer_config {
    int arch;
    char cipher[MAX_CIPHER_LENGTH];
    char packing_method[MAX_PACKING_METHOD_LENGTH];
    size_t cipher_key_offset;
    size_t loader_size;
    size_t loader_infos_size;
    unsigned char *loader_stub;
    int debug_mode;
};

extern struct s_packer_config packer_config;

int fill_packer_config(char *packing_method, char *cipher, int arch, int file_type, int debug_mode);

#endif //SILENT_PACKER_PACKER_CONFIG_H

```

`includes/main.h`:

```h
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_MAIN_H
#define SILENT_PACKER_MAIN_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void display_argtable_help(char *progname, void **argtable);

#endif //SILENT_PACKER_MAIN_H

```

`includes/packing_method.h`:

```h
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#ifndef SILENT_PACKER_PACKING_METHOD_H
#define SILENT_PACKER_PACKING_METHOD_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SECTION_INSERTION_METHOD 1
#define SILVIO_INFECTION_METHOD 2
#define CODE_CAVE_METHOD 3

struct method_config {
    int method_type;
    int concerned_section;
};

extern struct method_config method_config;

#endif //SILENT_PACKER_PACKING_METHOD_H

```

`lib/src/argtable3.c`:

```c
/*******************************************************************************
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#define ARG_AMALGAMATION

/*******************************************************************************
 * argtable3_private: Declares private types, constants, and interfaces
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 2013-2019 Tom G. Huang
 * <tomghuang@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#ifndef ARG_UTILS_H
#define ARG_UTILS_H

#include <stdlib.h>

#define ARG_ENABLE_TRACE 0
#define ARG_ENABLE_LOG 1

#ifdef __cplusplus
extern "C" {
#endif

enum { ARG_ERR_MINCOUNT = 1, ARG_ERR_MAXCOUNT, ARG_ERR_BADINT, ARG_ERR_OVERFLOW, ARG_ERR_BADDOUBLE, ARG_ERR_BADDATE, ARG_ERR_REGNOMATCH };

typedef void(arg_panicfn)(const char* fmt, ...);

#if defined(_MSC_VER)
#define ARG_TRACE(x)                                               \
    __pragma(warning(push)) __pragma(warning(disable : 4127)) do { \
        if (ARG_ENABLE_TRACE)                                      \
            dbg_printf x;                                          \
    }                                                              \
    while (0)                                                      \
    __pragma(warning(pop))

#define ARG_LOG(x)                                                 \
    __pragma(warning(push)) __pragma(warning(disable : 4127)) do { \
        if (ARG_ENABLE_LOG)                                        \
            dbg_printf x;                                          \
    }                                                              \
    while (0)                                                      \
    __pragma(warning(pop))
#else
#define ARG_TRACE(x)          \
    do {                      \
        if (ARG_ENABLE_TRACE) \
            dbg_printf x;     \
    } while (0)

#define ARG_LOG(x)          \
    do {                    \
        if (ARG_ENABLE_LOG) \
            dbg_printf x;   \
    } while (0)
#endif

extern void dbg_printf(const char* fmt, ...);
extern void arg_set_panic(arg_panicfn* proc);
extern void* xmalloc(size_t size);
extern void* xcalloc(size_t count, size_t size);
extern void* xrealloc(void* ptr, size_t size);
extern void xfree(void* ptr);

struct arg_hashtable_entry {
    void *k, *v;
    unsigned int h;
    struct arg_hashtable_entry* next;
};

typedef struct arg_hashtable {
    unsigned int tablelength;
    struct arg_hashtable_entry** table;
    unsigned int entrycount;
    unsigned int loadlimit;
    unsigned int primeindex;
    unsigned int (*hashfn)(void* k);
    int (*eqfn)(void* k1, void* k2);
} arg_hashtable_t;

/**
 * @brief Create a hash table.
 *
 * @param   minsize   minimum initial size of hash table
 * @param   hashfn    function for hashing keys
 * @param   eqfn      function for determining key equality
 * @return            newly created hash table or NULL on failure
 */
arg_hashtable_t* arg_hashtable_create(unsigned int minsize, unsigned int (*hashfn)(void*), int (*eqfn)(void*, void*));

/**
 * @brief This function will cause the table to expand if the insertion would take
 * the ratio of entries to table size over the maximum load factor.
 *
 * This function does not check for repeated insertions with a duplicate key.
 * The value returned when using a duplicate key is undefined -- when
 * the hash table changes size, the order of retrieval of duplicate key
 * entries is reversed.
 * If in doubt, remove before insert.
 *
 * @param   h   the hash table to insert into
 * @param   k   the key - hash table claims ownership and will free on removal
 * @param   v   the value - does not claim ownership
 * @return      non-zero for successful insertion
 */
void arg_hashtable_insert(arg_hashtable_t* h, void* k, void* v);

#define ARG_DEFINE_HASHTABLE_INSERT(fnname, keytype, valuetype) \
    int fnname(arg_hashtable_t* h, keytype* k, valuetype* v) { return arg_hashtable_insert(h, k, v); }

/**
 * @brief Search the specified key in the hash table.
 *
 * @param   h   the hash table to search
 * @param   k   the key to search for  - does not claim ownership
 * @return      the value associated with the key, or NULL if none found
 */
void* arg_hashtable_search(arg_hashtable_t* h, void* k);

#define ARG_DEFINE_HASHTABLE_SEARCH(fnname, keytype, valuetype) \
    valuetype* fnname(arg_hashtable_t* h, keytype* k) { return (valuetype*)(arg_hashtable_search(h, k)); }

/**
 * @brief Remove the specified key from the hash table.
 *
 * @param   h   the hash table to remove the item from
 * @param   k   the key to search for  - does not claim ownership
 */
void arg_hashtable_remove(arg_hashtable_t* h, void* k);

#define ARG_DEFINE_HASHTABLE_REMOVE(fnname, keytype, valuetype) \
    valuetype* fnname(arg_hashtable_t* h, keytype* k) { return (valuetype*)(arg_hashtable_remove(h, k)); }

/**
 * @brief Return the number of keys in the hash table.
 *
 * @param   h   the hash table
 * @return      the number of items stored in the hash table
 */
unsigned int arg_hashtable_count(arg_hashtable_t* h);

/**
 * @brief Change the value associated with the key.
 *
 * function to change the value associated with a key, where there already
 * exists a value bound to the key in the hash table.
 * Source due to Holger Schemel.
 *
 * @name        hashtable_change
 * @param   h   the hash table
 * @param       key
 * @param       value
 */
int arg_hashtable_change(arg_hashtable_t* h, void* k, void* v);

/**
 * @brief Free the hash table and the memory allocated for each key-value pair.
 *
 * @param   h            the hash table
 * @param   free_values  whether to call 'free' on the remaining values
 */
void arg_hashtable_destroy(arg_hashtable_t* h, int free_values);

typedef struct arg_hashtable_itr {
    arg_hashtable_t* h;
    struct arg_hashtable_entry* e;
    struct arg_hashtable_entry* parent;
    unsigned int index;
} arg_hashtable_itr_t;

arg_hashtable_itr_t* arg_hashtable_itr_create(arg_hashtable_t* h);

void arg_hashtable_itr_destroy(arg_hashtable_itr_t* itr);

/**
 * @brief Return the value of the (key,value) pair at the current position.
 */
extern void* arg_hashtable_itr_key(arg_hashtable_itr_t* i);

/**
 * @brief Return the value of the (key,value) pair at the current position.
 */
extern void* arg_hashtable_itr_value(arg_hashtable_itr_t* i);

/**
 * @brief Advance the iterator to the next element. Returns zero if advanced to end of table.
 */
int arg_hashtable_itr_advance(arg_hashtable_itr_t* itr);

/**
 * @brief Remove current element and advance the iterator to the next element.
 */
int arg_hashtable_itr_remove(arg_hashtable_itr_t* itr);

/**
 * @brief Search and overwrite the supplied iterator, to point to the entry matching the supplied key.
 *
 * @return  Zero if not found.
 */
int arg_hashtable_itr_search(arg_hashtable_itr_t* itr, arg_hashtable_t* h, void* k);

#define ARG_DEFINE_HASHTABLE_ITERATOR_SEARCH(fnname, keytype) \
    int fnname(arg_hashtable_itr_t* i, arg_hashtable_t* h, keytype* k) { return (arg_hashtable_iterator_search(i, h, k)); }

#ifdef __cplusplus
}
#endif

#endif
/*******************************************************************************
 * arg_utils: Implements memory, panic, and other utility functions
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 2013-2019 Tom G. Huang
 * <tomghuang@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void panic(const char* fmt, ...);
static arg_panicfn* s_panic = panic;

void dbg_printf(const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
}

static void panic(const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);

    char* s;

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996)
#endif
    s = getenv("EF_DUMPCORE");
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

    if (s != NULL && *s != '\0') {
        abort();
    } else {
        exit(EXIT_FAILURE);
    }
}

void arg_set_panic(arg_panicfn* proc) {
    s_panic = proc;
}

void* xmalloc(size_t size) {
    void* ret = malloc(size);
    if (!ret) {
        s_panic("Out of memory!\n");
    }
    return ret;
}

void* xcalloc(size_t count, size_t size) {
    size_t allocated_count = count && size ? count : 1;
    size_t allocated_size = count && size ? size : 1;
    void* ret = calloc(allocated_count, allocated_size);
    if (!ret) {
        s_panic("Out of memory!\n");
    }
    return ret;
}

void* xrealloc(void* ptr, size_t size) {
    size_t allocated_size = size ? size : 1;
    void* ret = realloc(ptr, allocated_size);
    if (!ret) {
        s_panic("Out of memory!\n");
    }
    return ret;
}

void xfree(void* ptr) {
    free(ptr);
}

static void merge(void* data, int esize, int i, int j, int k, arg_comparefn* comparefn) {
    char* a = (char*)data;
    char* m;
    int ipos, jpos, mpos;

    /* Initialize the counters used in merging. */
    ipos = i;
    jpos = j + 1;
    mpos = 0;

    /* Allocate storage for the merged elements. */
    m = (char*)xmalloc(esize * ((k - i) + 1));

    /* Continue while either division has elements to merge. */
    while (ipos <= j || jpos <= k) {
        if (ipos > j) {
            /* The left division has no more elements to merge. */
            while (jpos <= k) {
                memcpy(&m[mpos * esize], &a[jpos * esize], esize);
                jpos++;
                mpos++;
            }

            continue;
        } else if (jpos > k) {
            /* The right division has no more elements to merge. */
            while (ipos <= j) {
                memcpy(&m[mpos * esize], &a[ipos * esize], esize);
                ipos++;
                mpos++;
            }

            continue;
        }

        /* Append the next ordered element to the merged elements. */
        if (comparefn(&a[ipos * esize], &a[jpos * esize]) < 0) {
            memcpy(&m[mpos * esize], &a[ipos * esize], esize);
            ipos++;
            mpos++;
        } else {
            memcpy(&m[mpos * esize], &a[jpos * esize], esize);
            jpos++;
            mpos++;
        }
    }

    /* Prepare to pass back the merged data. */
    memcpy(&a[i * esize], m, esize * ((k - i) + 1));
    xfree(m);
}

void arg_mgsort(void* data, int size, int esize, int i, int k, arg_comparefn* comparefn) {
    int j;

    /* Stop the recursion when no more divisions can be made. */
    if (i < k) {
        /* Determine where to divide the elements. */
        j = (int)(((i + k - 1)) / 2);

        /* Recursively sort the two divisions. */
        arg_mgsort(data, size, esize, i, j, comparefn);
        arg_mgsort(data, size, esize, j + 1, k, comparefn);
        merge(data, esize, i, j, k, comparefn);
    }
}/*******************************************************************************
 * arg_hashtable: Implements the hash table utilities
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 2013-2019 Tom G. Huang
 * <tomghuang@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * This hash table module is adapted from the C hash table implementation by
 * Christopher Clark. Here is the copyright notice from the library:
 *
 * Copyright (c) 2002, Christopher Clark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * * Neither the name of the original author; nor the names of any contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Credit for primes table: Aaron Krowne
 * http://br.endernet.org/~akrowne/
 * http://planetmath.org/encyclopedia/GoodHashTablePrimes.html
 */
static const unsigned int primes[] = {53,       97,       193,      389,       769,       1543,      3079,      6151,      12289,
                                      24593,    49157,    98317,    196613,    393241,    786433,    1572869,   3145739,   6291469,
                                      12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741};
const unsigned int prime_table_length = sizeof(primes) / sizeof(primes[0]);
const float max_load_factor = (float)0.65;

static unsigned int enhanced_hash(arg_hashtable_t* h, void* k) {
    /*
     * Aim to protect against poor hash functions by adding logic here.
     * The logic is taken from Java 1.4 hash table source.
     */
    unsigned int i = h->hashfn(k);
    i += ~(i << 9);
    i ^= ((i >> 14) | (i << 18)); /* >>> */
    i += (i << 4);
    i ^= ((i >> 10) | (i << 22)); /* >>> */
    return i;
}

static unsigned int index_for(unsigned int tablelength, unsigned int hashvalue) {
    return (hashvalue % tablelength);
};

arg_hashtable_t* arg_hashtable_create(unsigned int minsize, unsigned int (*hashfn)(void*), int (*eqfn)(void*, void*)) {
    arg_hashtable_t* h;
    unsigned int pindex;
    unsigned int size = primes[0];

    /* Check requested hash table isn't too large */
    if (minsize > (1u << 30))
        return NULL;

    /*
     * Enforce size as prime. The reason is to avoid clustering of values
     * into a small number of buckets (yes, distribution). A more even
     *  distributed hash table will perform more consistently.
     */
    for (pindex = 0; pindex < prime_table_length; pindex++) {
        if (primes[pindex] > minsize) {
            size = primes[pindex];
            break;
        }
    }

    h = (arg_hashtable_t*)xmalloc(sizeof(arg_hashtable_t));
    h->table = (struct arg_hashtable_entry**)xmalloc(sizeof(struct arg_hashtable_entry*) * size);
    memset(h->table, 0, size * sizeof(struct arg_hashtable_entry*));
    h->tablelength = size;
    h->primeindex = pindex;
    h->entrycount = 0;
    h->hashfn = hashfn;
    h->eqfn = eqfn;
    h->loadlimit = (unsigned int)ceil(size * max_load_factor);
    return h;
}

static int arg_hashtable_expand(arg_hashtable_t* h) {
    /* Double the size of the table to accommodate more entries */
    struct arg_hashtable_entry** newtable;
    struct arg_hashtable_entry* e;
    unsigned int newsize;
    unsigned int i;
    unsigned int index;

    /* Check we're not hitting max capacity */
    if (h->primeindex == (prime_table_length - 1))
        return 0;
    newsize = primes[++(h->primeindex)];

    newtable = (struct arg_hashtable_entry**)xmalloc(sizeof(struct arg_hashtable_entry*) * newsize);
    memset(newtable, 0, newsize * sizeof(struct arg_hashtable_entry*));
    /*
     * This algorithm is not 'stable': it reverses the list
     * when it transfers entries between the tables
     */
    for (i = 0; i < h->tablelength; i++) {
        while (NULL != (e = h->table[i])) {
            h->table[i] = e->next;
            index = index_for(newsize, e->h);
            e->next = newtable[index];
            newtable[index] = e;
        }
    }

    xfree(h->table);
    h->table = newtable;
    h->tablelength = newsize;
    h->loadlimit = (unsigned int)ceil(newsize * max_load_factor);
    return -1;
}

unsigned int arg_hashtable_count(arg_hashtable_t* h) {
    return h->entrycount;
}

void arg_hashtable_insert(arg_hashtable_t* h, void* k, void* v) {
    /* This method allows duplicate keys - but they shouldn't be used */
    unsigned int index;
    struct arg_hashtable_entry* e;
    if ((h->entrycount + 1) > h->loadlimit) {
        /*
         * Ignore the return value. If expand fails, we should
         * still try cramming just this value into the existing table
         * -- we may not have memory for a larger table, but one more
         * element may be ok. Next time we insert, we'll try expanding again.
         */
        arg_hashtable_expand(h);
    }
    e = (struct arg_hashtable_entry*)xmalloc(sizeof(struct arg_hashtable_entry));
    e->h = enhanced_hash(h, k);
    index = index_for(h->tablelength, e->h);
    e->k = k;
    e->v = v;
    e->next = h->table[index];
    h->table[index] = e;
    h->entrycount++;
}

void* arg_hashtable_search(arg_hashtable_t* h, void* k) {
    struct arg_hashtable_entry* e;
    unsigned int hashvalue;
    unsigned int index;

    hashvalue = enhanced_hash(h, k);
    index = index_for(h->tablelength, hashvalue);
    e = h->table[index];
    while (e != NULL) {
        /* Check hash value to short circuit heavier comparison */
        if ((hashvalue == e->h) && (h->eqfn(k, e->k)))
            return e->v;
        e = e->next;
    }
    return NULL;
}

void arg_hashtable_remove(arg_hashtable_t* h, void* k) {
    /*
     * TODO: consider compacting the table when the load factor drops enough,
     *       or provide a 'compact' method.
     */

    struct arg_hashtable_entry* e;
    struct arg_hashtable_entry** pE;
    unsigned int hashvalue;
    unsigned int index;

    hashvalue = enhanced_hash(h, k);
    index = index_for(h->tablelength, hashvalue);
    pE = &(h->table[index]);
    e = *pE;
    while (NULL != e) {
        /* Check hash value to short circuit heavier comparison */
        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {
            *pE = e->next;
            h->entrycount--;
            xfree(e->k);
            xfree(e->v);
            xfree(e);
            return;
        }
        pE = &(e->next);
        e = e->next;
    }
}

void arg_hashtable_destroy(arg_hashtable_t* h, int free_values) {
    unsigned int i;
    struct arg_hashtable_entry *e, *f;
    struct arg_hashtable_entry** table = h->table;
    if (free_values) {
        for (i = 0; i < h->tablelength; i++) {
            e = table[i];
            while (NULL != e) {
                f = e;
                e = e->next;
                xfree(f->k);
                xfree(f->v);
                xfree(f);
            }
        }
    } else {
        for (i = 0; i < h->tablelength; i++) {
            e = table[i];
            while (NULL != e) {
                f = e;
                e = e->next;
                xfree(f->k);
                xfree(f);
            }
        }
    }
    xfree(h->table);
    xfree(h);
}

arg_hashtable_itr_t* arg_hashtable_itr_create(arg_hashtable_t* h) {
    unsigned int i;
    unsigned int tablelength;

    arg_hashtable_itr_t* itr = (arg_hashtable_itr_t*)xmalloc(sizeof(arg_hashtable_itr_t));
    itr->h = h;
    itr->e = NULL;
    itr->parent = NULL;
    tablelength = h->tablelength;
    itr->index = tablelength;
    if (0 == h->entrycount)
        return itr;

    for (i = 0; i < tablelength; i++) {
        if (h->table[i] != NULL) {
            itr->e = h->table[i];
            itr->index = i;
            break;
        }
    }
    return itr;
}

void arg_hashtable_itr_destroy(arg_hashtable_itr_t* itr) {
    xfree(itr);
}

void* arg_hashtable_itr_key(arg_hashtable_itr_t* i) {
    return i->e->k;
}

void* arg_hashtable_itr_value(arg_hashtable_itr_t* i) {
    return i->e->v;
}

int arg_hashtable_itr_advance(arg_hashtable_itr_t* itr) {
    unsigned int j;
    unsigned int tablelength;
    struct arg_hashtable_entry** table;
    struct arg_hashtable_entry* next;

    if (itr->e == NULL)
        return 0; /* stupidity check */

    next = itr->e->next;
    if (NULL != next) {
        itr->parent = itr->e;
        itr->e = next;
        return -1;
    }

    tablelength = itr->h->tablelength;
    itr->parent = NULL;
    if (tablelength <= (j = ++(itr->index))) {
        itr->e = NULL;
        return 0;
    }

    table = itr->h->table;
    while (NULL == (next = table[j])) {
        if (++j >= tablelength) {
            itr->index = tablelength;
            itr->e = NULL;
            return 0;
        }
    }

    itr->index = j;
    itr->e = next;
    return -1;
}

int arg_hashtable_itr_remove(arg_hashtable_itr_t* itr) {
    struct arg_hashtable_entry* remember_e;
    struct arg_hashtable_entry* remember_parent;
    int ret;

    /* Do the removal */
    if ((itr->parent) == NULL) {
        /* element is head of a chain */
        itr->h->table[itr->index] = itr->e->next;
    } else {
        /* element is mid-chain */
        itr->parent->next = itr->e->next;
    }
    /* itr->e is now outside the hashtable */
    remember_e = itr->e;
    itr->h->entrycount--;
    xfree(remember_e->k);
    xfree(remember_e->v);

    /* Advance the iterator, correcting the parent */
    remember_parent = itr->parent;
    ret = arg_hashtable_itr_advance(itr);
    if (itr->parent == remember_e) {
        itr->parent = remember_parent;
    }
    xfree(remember_e);
    return ret;
}

int arg_hashtable_itr_search(arg_hashtable_itr_t* itr, arg_hashtable_t* h, void* k) {
    struct arg_hashtable_entry* e;
    struct arg_hashtable_entry* parent;
    unsigned int hashvalue;
    unsigned int index;

    hashvalue = enhanced_hash(h, k);
    index = index_for(h->tablelength, hashvalue);

    e = h->table[index];
    parent = NULL;
    while (e != NULL) {
        /* Check hash value to short circuit heavier comparison */
        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {
            itr->index = index;
            itr->e = e;
            itr->parent = parent;
            itr->h = h;
            return -1;
        }
        parent = e;
        e = e->next;
    }
    return 0;
}

int arg_hashtable_change(arg_hashtable_t* h, void* k, void* v) {
    struct arg_hashtable_entry* e;
    unsigned int hashvalue;
    unsigned int index;

    hashvalue = enhanced_hash(h, k);
    index = index_for(h->tablelength, hashvalue);
    e = h->table[index];
    while (e != NULL) {
        /* Check hash value to short circuit heavier comparison */
        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {
            xfree(e->v);
            e->v = v;
            return -1;
        }
        e = e->next;
    }
    return 0;
}
/*******************************************************************************
 * arg_dstr: Implements the dynamic string utilities
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 2013-2019 Tom G. Huang
 * <tomghuang@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996)
#endif

#define START_VSNBUFF 16

/*
 * This dynamic string module is adapted from TclResult.c in the Tcl library.
 * Here is the copyright notice from the library:
 *
 * This software is copyrighted by the Regents of the University of
 * California, Sun Microsystems, Inc., Scriptics Corporation, ActiveState
 * Corporation and other parties.  The following terms apply to all files
 * associated with the software unless explicitly disclaimed in
 * individual files.
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 *
 * GOVERNMENT USE: If you are acquiring this software on behalf of the
 * U.S. government, the Government shall have only "Restricted Rights"
 * in the software and related documentation as defined in the Federal
 * Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
 * are acquiring the software on behalf of the Department of Defense, the
 * software shall be classified as "Commercial Computer Software" and the
 * Government shall have only "Restricted Rights" as defined in Clause
 * 252.227-7014 (b) (3) of DFARs.  Notwithstanding the foregoing, the
 * authors grant the U.S. Government and others acting in its behalf
 * permission to use and distribute the software in accordance with the
 * terms specified in this license.
 */

typedef struct _internal_arg_dstr {
    char* data;
    arg_dstr_freefn* free_proc;
    char sbuf[ARG_DSTR_SIZE + 1];
    char* append_data;
    int append_data_size;
    int append_used;
} _internal_arg_dstr_t;

static void setup_append_buf(arg_dstr_t res, int newSpace);

arg_dstr_t arg_dstr_create() {
    _internal_arg_dstr_t* h = (_internal_arg_dstr_t*)xmalloc(sizeof(_internal_arg_dstr_t));
    memset(h, 0, sizeof(_internal_arg_dstr_t));
    h->sbuf[0] = 0;
    h->data = h->sbuf;
    h->free_proc = ARG_DSTR_STATIC;
    return h;
}

void arg_dstr_destroy(arg_dstr_t ds) {
    if (ds == NULL)
        return;

    arg_dstr_reset(ds);
    xfree(ds);
    return;
}

void arg_dstr_set(arg_dstr_t ds, char* str, arg_dstr_freefn* free_proc) {
    int length;
    register arg_dstr_freefn* old_free_proc = ds->free_proc;
    char* old_result = ds->data;

    if (str == NULL) {
        ds->sbuf[0] = 0;
        ds->data = ds->sbuf;
        ds->free_proc = ARG_DSTR_STATIC;
    } else if (free_proc == ARG_DSTR_VOLATILE) {
        length = (int)strlen(str);
        if (length > ARG_DSTR_SIZE) {
            ds->data = (char*)xmalloc((unsigned)length + 1);
            ds->free_proc = ARG_DSTR_DYNAMIC;
        } else {
            ds->data = ds->sbuf;
            ds->free_proc = ARG_DSTR_STATIC;
        }
        strcpy(ds->data, str);
    } else {
        ds->data = str;
        ds->free_proc = free_proc;
    }

    /*
     * If the old result was dynamically-allocated, free it up. Do it here,
     * rather than at the beginning, in case the new result value was part of
     * the old result value.
     */

    if ((old_free_proc != 0) && (old_result != ds->data)) {
        if (old_free_proc == ARG_DSTR_DYNAMIC) {
            xfree(old_result);
        } else {
            (*old_free_proc)(old_result);
        }
    }

    if ((ds->append_data != NULL) && (ds->append_data_size > 0)) {
        xfree(ds->append_data);
        ds->append_data = NULL;
        ds->append_data_size = 0;
    }
}

char* arg_dstr_cstr(arg_dstr_t ds) /* Interpreter whose result to return. */
{
    return ds->data;
}

void arg_dstr_cat(arg_dstr_t ds, char* str) {
    setup_append_buf(ds, (int)strlen(str) + 1);
    strncat(ds->data, str, strlen(str));
}

/*
 * The logic of the `arg_dstr_catf` function is adapted from the `bformat`
 * function in The Better String Library by Paul Hsieh. Here is the copyright
 * notice from the library:
 *
 * Copyright (c) 2014, Paul Hsieh
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of bstrlib nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
void arg_dstr_catf(arg_dstr_t ds, const char* fmt, ...) {
    va_list arglist;
    char* buff;
    int n, r;
    size_t slen;

    if (fmt == NULL)
        return;

    /* Since the length is not determinable beforehand, a search is
       performed using the truncating "vsnprintf" call (to avoid buffer
       overflows) on increasing potential sizes for the output result. */

    if ((n = (int)(2 * strlen(fmt))) < START_VSNBUFF)
        n = START_VSNBUFF;

    buff = (char*)xmalloc(n + 2);
    memset(buff, 0, n + 2);

    for (;;) {
        va_start(arglist, fmt);
        r = vsnprintf(buff, n + 1, fmt, arglist);
        va_end(arglist);

        slen = strlen(buff);
        if (slen < (size_t)n)
            break;

        if (r > n)
            n = r;
        else
            n += n;

        xfree(buff);
        buff = (char*)xmalloc(n + 2);
        memset(buff, 0, n + 2);
    }

    arg_dstr_cat(ds, buff);
    xfree(buff);
}

static void setup_append_buf(arg_dstr_t ds, int new_space) {
    int total_space;

    /*
     * Make the append buffer larger, if that's necessary, then copy the
     * data into the append buffer and make the append buffer the official
     * data.
     */
    if (ds->data != ds->append_data) {
        /*
         * If the buffer is too big, then free it up so we go back to a
         * smaller buffer. This avoids tying up memory forever after a large
         * operation.
         */
        if (ds->append_data_size > 500) {
            xfree(ds->append_data);
            ds->append_data = NULL;
            ds->append_data_size = 0;
        }
        ds->append_used = (int)strlen(ds->data);
    } else if (ds->data[ds->append_used] != 0) {
        /*
         * Most likely someone has modified a result created by
         * arg_dstr_cat et al. so that it has a different size. Just
         * recompute the size.
         */
        ds->append_used = (int)strlen(ds->data);
    }

    total_space = new_space + ds->append_used;
    if (total_space >= ds->append_data_size) {
        char* newbuf;

        if (total_space < 100) {
            total_space = 200;
        } else {
            total_space *= 2;
        }
        newbuf = (char*)xmalloc((unsigned)total_space);
        strcpy(newbuf, ds->data);
        if (ds->append_data != NULL) {
            xfree(ds->append_data);
        }
        ds->append_data = newbuf;
        ds->append_data_size = total_space;
    } else if (ds->data != ds->append_data) {
        strcpy(ds->append_data, ds->data);
    }

    arg_dstr_free(ds);
    ds->data = ds->append_data;
}

void arg_dstr_free(arg_dstr_t ds) {
    if (ds->free_proc != NULL) {
        if (ds->free_proc == ARG_DSTR_DYNAMIC) {
            xfree(ds->data);
        } else {
            (*ds->free_proc)(ds->data);
        }
        ds->free_proc = NULL;
    }
}

void arg_dstr_reset(arg_dstr_t ds) {
    arg_dstr_free(ds);
    if ((ds->append_data != NULL) && (ds->append_data_size > 0)) {
        xfree(ds->append_data);
        ds->append_data = NULL;
        ds->append_data_size = 0;
    }

    ds->data = ds->sbuf;
    ds->sbuf[0] = 0;
}

#if defined(_MSC_VER)
#pragma warning(pop)
#endif
/*	$Id: getopt.h,v 1.1 2009/10/16 19:50:28 rodney Exp rodney $ */
/*	$OpenBSD: getopt.h,v 1.1 2002/12/03 20:24:29 millert Exp $	*/
/*	$NetBSD: getopt.h,v 1.4 2000/07/07 10:43:54 ad Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if ARG_REPLACE_GETOPT == 1

#ifndef _GETOPT_H_
#define _GETOPT_H_

/*
 * GNU-like getopt_long() and 4.4BSD getsubopt()/optreset extensions
 */
#define no_argument 0
#define required_argument 1
#define optional_argument 2

struct option {
    /* name of long option */
    const char* name;
    /*
     * one of no_argument, required_argument, and optional_argument:
     * whether option takes an argument
     */
    int has_arg;
    /* if not NULL, set *flag to val when option found */
    int* flag;
    /* if flag not NULL, value to set *flag to; else return value */
    int val;
};

#ifdef __cplusplus
extern "C" {
#endif

int getopt_long(int, char* const*, const char*, const struct option*, int*);
int getopt_long_only(int, char* const*, const char*, const struct option*, int*);
#ifndef _GETOPT_DEFINED
#define _GETOPT_DEFINED
int getopt(int, char* const*, const char*);
int getsubopt(char**, char* const*, char**);

extern char* optarg; /* getopt(3) external variables */
extern int opterr;
extern int optind;
extern int optopt;
extern int optreset;
extern char* suboptarg; /* getsubopt(3) external variable */
#endif                  /* _GETOPT_DEFINED */

#ifdef __cplusplus
}
#endif
#endif /* !_GETOPT_H_ */

#else
#include <getopt.h>
#endif /* ARG_REPLACE_GETOPT */
/*	$Id: getopt_long.c,v 1.1 2009/10/16 19:50:28 rodney Exp rodney $	*/
/*	$OpenBSD: getopt_long.c,v 1.23 2007/10/31 12:34:57 chl Exp $	*/
/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "getopt.h"
#endif

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#if ARG_REPLACE_GETOPT == 1
int opterr = 1;   /* if error message should be printed */
int optind = 1;   /* index into parent argv vector */
int optopt = '?'; /* character checked for validity */
int optreset;     /* reset getopt */
char* optarg;     /* argument associated with option */
#endif            /* ARG_REPLACE_GETOPT */

#define PRINT_ERROR ((opterr) && (*options != ':'))

#define FLAG_PERMUTE 0x01  /* permute non-options to the end of argv */
#define FLAG_ALLARGS 0x02  /* treat non-options as args to option "-1" */
#define FLAG_LONGONLY 0x04 /* operate as getopt_long_only */

/* return values */
#define BADCH (int)'?'
#define BADARG ((*options == ':') ? (int)':' : (int)'?')
#define INORDER (int)1

#define EMSG ""

#if ARG_REPLACE_GETOPT == 1
static int getopt_internal(int, char* const*, const char*, const struct option*, int*, int);
#endif /* ARG_REPLACE_GETOPT */
static int parse_long_options(char* const*, const char*, const struct option*, int*, int);
static int gcd(int, int);
static void permute_args(int, int, int, char* const*);

static char* place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptchar[] = "unknown option -- %c";
static const char illoptstring[] = "unknown option -- %s";

#ifdef _WIN32

/* Windows needs warnx().  We change the definition though:
 *  1. (another) global is defined, opterrmsg, which holds the error message
 *  2. errors are always printed out on stderr w/o the program name
 * Note that opterrmsg always gets set no matter what opterr is set to.  The
 * error message will not be printed if opterr is 0 as usual.
 */

#include <stdarg.h>
#include <stdio.h>

#define MAX_OPTERRMSG_SIZE 128

extern char opterrmsg[MAX_OPTERRMSG_SIZE];
char opterrmsg[MAX_OPTERRMSG_SIZE]; /* buffer for the last error message */

static void warnx(const char* fmt, ...) {
    va_list ap;
    va_start(ap, fmt);

    // Make sure opterrmsg is always zero-terminated despite the _vsnprintf()
    // implementation specifics and manually suppress the warning.
    memset(opterrmsg, 0, sizeof(opterrmsg));
    if (fmt != NULL)
#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
        _vsnprintf_s(opterrmsg, sizeof(opterrmsg), sizeof(opterrmsg) - 1, fmt, ap);
#else
        _vsnprintf(opterrmsg, sizeof(opterrmsg) - 1, fmt, ap);
#endif

    va_end(ap);

#pragma warning(suppress : 6053)
    fprintf(stderr, "%s\n", opterrmsg);
}

#else
#include <err.h>
#endif /*_WIN32*/

/*
 * Compute the greatest common divisor of a and b.
 */
static int gcd(int a, int b) {
    int c;

    c = a % b;
    while (c != 0) {
        a = b;
        b = c;
        c = a % b;
    }

    return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void permute_args(int panonopt_start, int panonopt_end, int opt_end, char* const* nargv) {
    int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
    char* swap;

    /*
     * compute lengths of blocks and number and size of cycles
     */
    nnonopts = panonopt_end - panonopt_start;
    nopts = opt_end - panonopt_end;
    ncycle = gcd(nnonopts, nopts);
    cyclelen = (opt_end - panonopt_start) / ncycle;

    for (i = 0; i < ncycle; i++) {
        cstart = panonopt_end + i;
        pos = cstart;
        for (j = 0; j < cyclelen; j++) {
            if (pos >= panonopt_end)
                pos -= nnonopts;
            else
                pos += nopts;
            swap = nargv[pos];
            /* LINTED const cast */
            ((char**)nargv)[pos] = nargv[cstart];
            /* LINTED const cast */
            ((char**)nargv)[cstart] = swap;
        }
    }
}

/*
 * parse_long_options --
 *	Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int parse_long_options(char* const* nargv, const char* options, const struct option* long_options, int* idx, int short_too) {
    char *current_argv, *has_equal;
    size_t current_argv_len;
    int i, match;

    current_argv = place;
    match = -1;

    optind++;

    if ((has_equal = strchr(current_argv, '=')) != NULL) {
        /* argument found (--option=arg) */
        current_argv_len = has_equal - current_argv;
        has_equal++;
    } else
        current_argv_len = strlen(current_argv);

    for (i = 0; long_options[i].name; i++) {
        /* find matching long option */
        if (strncmp(current_argv, long_options[i].name, current_argv_len))
            continue;

        if (strlen(long_options[i].name) == current_argv_len) {
            /* exact match */
            match = i;
            break;
        }
        /*
         * If this is a known short option, don't allow
         * a partial match of a single character.
         */
        if (short_too && current_argv_len == 1)
            continue;

        if (match == -1) /* partial match */
            match = i;
        else {
            /* ambiguous abbreviation */
            if (PRINT_ERROR)
                warnx(ambig, (int)current_argv_len, current_argv);
            optopt = 0;
            return (BADCH);
        }
    }
    if (match != -1) { /* option found */
        if (long_options[match].has_arg == no_argument && has_equal) {
            if (PRINT_ERROR)
                warnx(noarg, (int)current_argv_len, current_argv);
            /*
             * XXX: GNU sets optopt to val regardless of flag
             */
            if (long_options[match].flag == NULL)
                optopt = long_options[match].val;
            else
                optopt = 0;
            return (BADARG);
        }
        if (long_options[match].has_arg == required_argument || long_options[match].has_arg == optional_argument) {
            if (has_equal)
                optarg = has_equal;
            else if (long_options[match].has_arg == required_argument) {
                /*
                 * optional argument doesn't use next nargv
                 */
                optarg = nargv[optind++];
            }
        }
        if ((long_options[match].has_arg == required_argument) && (optarg == NULL)) {
            /*
             * Missing argument; leading ':' indicates no error
             * should be generated.
             */
            if (PRINT_ERROR)
                warnx(recargstring, current_argv);
            /*
             * XXX: GNU sets optopt to val regardless of flag
             */
            if (long_options[match].flag == NULL)
                optopt = long_options[match].val;
            else
                optopt = 0;
            --optind;
            return (BADARG);
        }
    } else { /* unknown option */
        if (short_too) {
            --optind;
            return (-1);
        }
        if (PRINT_ERROR)
            warnx(illoptstring, current_argv);
        optopt = 0;
        return (BADCH);
    }
    if (idx)
        *idx = match;
    if (long_options[match].flag) {
        *long_options[match].flag = long_options[match].val;
        return (0);
    } else
        return (long_options[match].val);
}

#if ARG_REPLACE_GETOPT == 1
/*
 * getopt_internal --
 *	Parse argc/argv argument vector.  Called by user level routines.
 */
static int getopt_internal(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx, int flags) {
    char* oli; /* option letter list index */
    int optchar, short_too;
    static int posixly_correct = -1;

    if (options == NULL)
        return (-1);

    /*
     * Disable GNU extensions if POSIXLY_CORRECT is set or options
     * string begins with a '+'.
     */
    if (posixly_correct == -1)
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996)
#endif
        posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
#if defined(_MSC_VER)
#pragma warning(pop)
#endif
    if (posixly_correct || *options == '+')
        flags &= ~FLAG_PERMUTE;
    else if (*options == '-')
        flags |= FLAG_ALLARGS;
    if (*options == '+' || *options == '-')
        options++;

    /*
     * XXX Some GNU programs (like cvs) set optind to 0 instead of
     * XXX using optreset.  Work around this braindamage.
     */
    if (optind == 0)
        optind = optreset = 1;

    optarg = NULL;
    if (optreset)
        nonopt_start = nonopt_end = -1;
start:
    if (optreset || !*place) { /* update scanning pointer */
        optreset = 0;
        if (optind >= nargc) { /* end of argument vector */
            place = EMSG;
            if (nonopt_end != -1) {
                /* do permutation, if we have to */
                permute_args(nonopt_start, nonopt_end, optind, nargv);
                optind -= nonopt_end - nonopt_start;
            } else if (nonopt_start != -1) {
                /*
                 * If we skipped non-options, set optind
                 * to the first of them.
                 */
                optind = nonopt_start;
            }
            nonopt_start = nonopt_end = -1;
            return (-1);
        }
        if (*(place = nargv[optind]) != '-' || (place[1] == '\0' && strchr(options, '-') == NULL)) {
            place = EMSG; /* found non-option */
            if (flags & FLAG_ALLARGS) {
                /*
                 * GNU extension:
                 * return non-option as argument to option 1
                 */
                optarg = nargv[optind++];
                return (INORDER);
            }
            if (!(flags & FLAG_PERMUTE)) {
                /*
                 * If no permutation wanted, stop parsing
                 * at first non-option.
                 */
                return (-1);
            }
            /* do permutation */
            if (nonopt_start == -1)
                nonopt_start = optind;
            else if (nonopt_end != -1) {
                permute_args(nonopt_start, nonopt_end, optind, nargv);
                nonopt_start = optind - (nonopt_end - nonopt_start);
                nonopt_end = -1;
            }
            optind++;
            /* process next argument */
            goto start;
        }
        if (nonopt_start != -1 && nonopt_end == -1)
            nonopt_end = optind;

        /*
         * If we have "-" do nothing, if "--" we are done.
         */
        if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
            optind++;
            place = EMSG;
            /*
             * We found an option (--), so if we skipped
             * non-options, we have to permute.
             */
            if (nonopt_end != -1) {
                permute_args(nonopt_start, nonopt_end, optind, nargv);
                optind -= nonopt_end - nonopt_start;
            }
            nonopt_start = nonopt_end = -1;
            return (-1);
        }
    }

    /*
     * Check long options if:
     *  1) we were passed some
     *  2) the arg is not just "-"
     *  3) either the arg starts with -- we are getopt_long_only()
     */
    if (long_options != NULL && place != nargv[optind] && (*place == '-' || (flags & FLAG_LONGONLY))) {
        short_too = 0;
        if (*place == '-')
            place++; /* --foo long option */
        else if (*place != ':' && strchr(options, *place) != NULL)
            short_too = 1; /* could be short option too */

        optchar = parse_long_options(nargv, options, long_options, idx, short_too);
        if (optchar != -1) {
            place = EMSG;
            return (optchar);
        }
    }

    if ((optchar = (int)*place++) == (int)':' || (optchar == (int)'-' && *place != '\0') || (oli = strchr(options, optchar)) == NULL) {
        /*
         * If the user specified "-" and  '-' isn't listed in
         * options, return -1 (non-option) as per POSIX.
         * Otherwise, it is an unknown option character (or ':').
         */
        if (optchar == (int)'-' && *place == '\0')
            return (-1);
        if (!*place)
            ++optind;
        if (PRINT_ERROR)
            warnx(illoptchar, optchar);
        optopt = optchar;
        return (BADCH);
    }
    if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
        /* -W long-option */
        if (*place) /* no space */
            /* NOTHING */;
        else if (++optind >= nargc) { /* no arg */
            place = EMSG;
            if (PRINT_ERROR)
                warnx(recargchar, optchar);
            optopt = optchar;
            return (BADARG);
        } else /* white space */
            place = nargv[optind];
        optchar = parse_long_options(nargv, options, long_options, idx, 0);
        place = EMSG;
        return (optchar);
    }
    if (*++oli != ':') { /* doesn't take argument */
        if (!*place)
            ++optind;
    } else { /* takes (optional) argument */
        optarg = NULL;
        if (*place) /* no white space */
            optarg = place;
        else if (oli[1] != ':') {    /* arg not optional */
            if (++optind >= nargc) { /* no arg */
                place = EMSG;
                if (PRINT_ERROR)
                    warnx(recargchar, optchar);
                optopt = optchar;
                return (BADARG);
            } else
                optarg = nargv[optind];
        }
        place = EMSG;
        ++optind;
    }
    /* dump back option letter */
    return (optchar);
}

/*
 * getopt --
 *	Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int getopt(int nargc, char* const* nargv, const char* options) {
    /*
     * We don't pass FLAG_PERMUTE to getopt_internal() since
     * the BSD getopt(3) (unlike GNU) has never done this.
     *
     * Furthermore, since many privileged programs call getopt()
     * before dropping privileges it makes sense to keep things
     * as simple (and bug-free) as possible.
     */
    return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}
#endif /* ARG_REPLACE_GETOPT */

/*
 * getopt_long --
 *	Parse argc/argv argument vector.
 */
int getopt_long(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx) {
    return (getopt_internal(nargc, nargv, options, long_options, idx, FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *	Parse argc/argv argument vector.
 */
int getopt_long_only(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx) {
    return (getopt_internal(nargc, nargv, options, long_options, idx, FLAG_PERMUTE | FLAG_LONGONLY));
}
/*******************************************************************************
 * arg_date: Implements the date command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>
#include <string.h>

char* arg_strptime(const char* buf, const char* fmt, struct tm* tm);

static void arg_date_resetfn(struct arg_date* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static int arg_date_scanfn(struct arg_date* parent, const char* argval) {
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount) {
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* no argument value was given, leave parent->tmval[] unaltered but still count it */
        parent->count++;
    } else {
        const char* pend;
        struct tm tm = parent->tmval[parent->count];

        /* parse the given argument value, store result in parent->tmval[] */
        pend = arg_strptime(argval, parent->format, &tm);
        if (pend && pend[0] == '\0')
            parent->tmval[parent->count++] = tm;
        else
            errorcode = ARG_ERR_BADDATE;
    }

    ARG_TRACE(("%s:scanfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static int arg_date_checkfn(struct arg_date* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;

    ARG_TRACE(("%s:checkfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static void arg_date_errorfn(struct arg_date* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        case ARG_ERR_BADDATE: {
            struct tm tm;
            char buff[200];

            arg_dstr_catf(ds, "illegal timestamp format \"%s\"\n", argval);
            memset(&tm, 0, sizeof(tm));
            arg_strptime("1999-12-31 23:59:59", "%F %H:%M:%S", &tm);
            strftime(buff, sizeof(buff), parent->format, &tm);
            arg_dstr_catf(ds, "correct format is \"%s\"\n", buff);
            break;
        }
    }
}

struct arg_date* arg_date0(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary) {
    return arg_daten(shortopts, longopts, format, datatype, 0, 1, glossary);
}

struct arg_date* arg_date1(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary) {
    return arg_daten(shortopts, longopts, format, datatype, 1, 1, glossary);
}

struct arg_date*
arg_daten(const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char* glossary) {
    size_t nbytes;
    struct arg_date* result;

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    /* default time format is the national date format for the locale */
    if (!format)
        format = "%x";

    nbytes = sizeof(struct arg_date)         /* storage for struct arg_date */
             + maxcount * sizeof(struct tm); /* storage for tmval[maxcount] array */

    /* allocate storage for the arg_date struct + tmval[] array.    */
    /* we use calloc because we want the tmval[] array zero filled. */
    result = (struct arg_date*)xcalloc(1, nbytes);

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : format;
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_date_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_date_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_date_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_date_errorfn;

    /* store the tmval[maxcount] array immediately after the arg_date struct */
    result->tmval = (struct tm*)(result + 1);

    /* init the remaining arg_date member variables */
    result->count = 0;
    result->format = format;

    ARG_TRACE(("arg_daten() returns %p\n", result));
    return result;
}

/*-
 * Copyright (c) 1997, 1998, 2005, 2008 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code was contributed to The NetBSD Foundation by Klaus Klein.
 * Heavily optimised by David Laight
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <string.h>
#include <time.h>

/*
 * We do not implement alternate representations. However, we always
 * check whether a given modifier is allowed for a certain conversion.
 */
#define ALT_E 0x01
#define ALT_O 0x02
#define LEGAL_ALT(x)           \
    {                          \
        if (alt_format & ~(x)) \
            return (0);        \
    }
#define TM_YEAR_BASE (1900)

static int conv_num(const char**, int*, int, int);

static const char* day[7] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

static const char* abday[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

static const char* mon[12] = {"January", "February", "March",     "April",   "May",      "June",
                              "July",    "August",   "September", "October", "November", "December"};

static const char* abmon[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

static const char* am_pm[2] = {"AM", "PM"};

static int arg_strcasecmp(const char* s1, const char* s2) {
    const unsigned char* us1 = (const unsigned char*)s1;
    const unsigned char* us2 = (const unsigned char*)s2;
    while (tolower(*us1) == tolower(*us2++))
        if (*us1++ == '\0')
            return 0;

    return tolower(*us1) - tolower(*--us2);
}

static int arg_strncasecmp(const char* s1, const char* s2, size_t n) {
    if (n != 0) {
        const unsigned char* us1 = (const unsigned char*)s1;
        const unsigned char* us2 = (const unsigned char*)s2;
        do {
            if (tolower(*us1) != tolower(*us2++))
                return tolower(*us1) - tolower(*--us2);

            if (*us1++ == '\0')
                break;
        } while (--n != 0);
    }

    return 0;
}

char* arg_strptime(const char* buf, const char* fmt, struct tm* tm) {
    char c;
    const char* bp;
    size_t len = 0;
    int alt_format, i, split_year = 0;

    bp = buf;

    while ((c = *fmt) != '\0') {
        /* Clear `alternate' modifier prior to new conversion. */
        alt_format = 0;

        /* Eat up white-space. */
        if (isspace(c)) {
            while (isspace(*bp))
                bp++;

            fmt++;
            continue;
        }

        if ((c = *fmt++) != '%')
            goto literal;

    again:
        switch (c = *fmt++) {
            case '%': /* "%%" is converted to "%". */
            literal:
                if (c != *bp++)
                    return (0);
                break;

            /*
             * "Alternative" modifiers. Just set the appropriate flag
             * and start over again.
             */
            case 'E': /* "%E?" alternative conversion modifier. */
                LEGAL_ALT(0);
                alt_format |= ALT_E;
                goto again;

            case 'O': /* "%O?" alternative conversion modifier. */
                LEGAL_ALT(0);
                alt_format |= ALT_O;
                goto again;

            /*
             * "Complex" conversion rules, implemented through recursion.
             */
            case 'c': /* Date and time, using the locale's format. */
                LEGAL_ALT(ALT_E);
                bp = arg_strptime(bp, "%x %X", tm);
                if (!bp)
                    return (0);
                break;

            case 'D': /* The date as "%m/%d/%y". */
                LEGAL_ALT(0);
                bp = arg_strptime(bp, "%m/%d/%y", tm);
                if (!bp)
                    return (0);
                break;

            case 'R': /* The time as "%H:%M". */
                LEGAL_ALT(0);
                bp = arg_strptime(bp, "%H:%M", tm);
                if (!bp)
                    return (0);
                break;

            case 'r': /* The time in 12-hour clock representation. */
                LEGAL_ALT(0);
                bp = arg_strptime(bp, "%I:%M:%S %p", tm);
                if (!bp)
                    return (0);
                break;

            case 'T': /* The time as "%H:%M:%S". */
                LEGAL_ALT(0);
                bp = arg_strptime(bp, "%H:%M:%S", tm);
                if (!bp)
                    return (0);
                break;

            case 'X': /* The time, using the locale's format. */
                LEGAL_ALT(ALT_E);
                bp = arg_strptime(bp, "%H:%M:%S", tm);
                if (!bp)
                    return (0);
                break;

            case 'x': /* The date, using the locale's format. */
                LEGAL_ALT(ALT_E);
                bp = arg_strptime(bp, "%m/%d/%y", tm);
                if (!bp)
                    return (0);
                break;

            /*
             * "Elementary" conversion rules.
             */
            case 'A': /* The day of week, using the locale's form. */
            case 'a':
                LEGAL_ALT(0);
                for (i = 0; i < 7; i++) {
                    /* Full name. */
                    len = strlen(day[i]);
                    if (arg_strncasecmp(day[i], bp, len) == 0)
                        break;

                    /* Abbreviated name. */
                    len = strlen(abday[i]);
                    if (arg_strncasecmp(abday[i], bp, len) == 0)
                        break;
                }

                /* Nothing matched. */
                if (i == 7)
                    return (0);

                tm->tm_wday = i;
                bp += len;
                break;

            case 'B': /* The month, using the locale's form. */
            case 'b':
            case 'h':
                LEGAL_ALT(0);
                for (i = 0; i < 12; i++) {
                    /* Full name. */
                    len = strlen(mon[i]);
                    if (arg_strncasecmp(mon[i], bp, len) == 0)
                        break;

                    /* Abbreviated name. */
                    len = strlen(abmon[i]);
                    if (arg_strncasecmp(abmon[i], bp, len) == 0)
                        break;
                }

                /* Nothing matched. */
                if (i == 12)
                    return (0);

                tm->tm_mon = i;
                bp += len;
                break;

            case 'C': /* The century number. */
                LEGAL_ALT(ALT_E);
                if (!(conv_num(&bp, &i, 0, 99)))
                    return (0);

                if (split_year) {
                    tm->tm_year = (tm->tm_year % 100) + (i * 100);
                } else {
                    tm->tm_year = i * 100;
                    split_year = 1;
                }
                break;

            case 'd': /* The day of month. */
            case 'e':
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_mday, 1, 31)))
                    return (0);
                break;

            case 'k': /* The hour (24-hour clock representation). */
                LEGAL_ALT(0);
            /* FALLTHROUGH */
            case 'H':
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_hour, 0, 23)))
                    return (0);
                break;

            case 'l': /* The hour (12-hour clock representation). */
                LEGAL_ALT(0);
            /* FALLTHROUGH */
            case 'I':
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_hour, 1, 12)))
                    return (0);
                if (tm->tm_hour == 12)
                    tm->tm_hour = 0;
                break;

            case 'j': /* The day of year. */
                LEGAL_ALT(0);
                if (!(conv_num(&bp, &i, 1, 366)))
                    return (0);
                tm->tm_yday = i - 1;
                break;

            case 'M': /* The minute. */
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_min, 0, 59)))
                    return (0);
                break;

            case 'm': /* The month. */
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &i, 1, 12)))
                    return (0);
                tm->tm_mon = i - 1;
                break;

            case 'p': /* The locale's equivalent of AM/PM. */
                LEGAL_ALT(0);
                /* AM? */
                if (arg_strcasecmp(am_pm[0], bp) == 0) {
                    if (tm->tm_hour > 11)
                        return (0);

                    bp += strlen(am_pm[0]);
                    break;
                }
                /* PM? */
                else if (arg_strcasecmp(am_pm[1], bp) == 0) {
                    if (tm->tm_hour > 11)
                        return (0);

                    tm->tm_hour += 12;
                    bp += strlen(am_pm[1]);
                    break;
                }

                /* Nothing matched. */
                return (0);

            case 'S': /* The seconds. */
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_sec, 0, 61)))
                    return (0);
                break;

            case 'U': /* The week of year, beginning on sunday. */
            case 'W': /* The week of year, beginning on monday. */
                LEGAL_ALT(ALT_O);
                /*
                 * XXX This is bogus, as we can not assume any valid
                 * information present in the tm structure at this
                 * point to calculate a real value, so just check the
                 * range for now.
                 */
                if (!(conv_num(&bp, &i, 0, 53)))
                    return (0);
                break;

            case 'w': /* The day of week, beginning on sunday. */
                LEGAL_ALT(ALT_O);
                if (!(conv_num(&bp, &tm->tm_wday, 0, 6)))
                    return (0);
                break;

            case 'Y': /* The year. */
                LEGAL_ALT(ALT_E);
                if (!(conv_num(&bp, &i, 0, 9999)))
                    return (0);

                tm->tm_year = i - TM_YEAR_BASE;
                break;

            case 'y': /* The year within 100 years of the epoch. */
                LEGAL_ALT(ALT_E | ALT_O);
                if (!(conv_num(&bp, &i, 0, 99)))
                    return (0);

                if (split_year) {
                    tm->tm_year = ((tm->tm_year / 100) * 100) + i;
                    break;
                }
                split_year = 1;
                if (i <= 68)
                    tm->tm_year = i + 2000 - TM_YEAR_BASE;
                else
                    tm->tm_year = i + 1900 - TM_YEAR_BASE;
                break;

            /*
             * Miscellaneous conversions.
             */
            case 'n': /* Any kind of white-space. */
            case 't':
                LEGAL_ALT(0);
                while (isspace(*bp))
                    bp++;
                break;

            default: /* Unknown/unsupported conversion. */
                return (0);
        }
    }

    /* LINTED functional specification */
    return ((char*)bp);
}

static int conv_num(const char** buf, int* dest, int llim, int ulim) {
    int result = 0;

    /* The limit also determines the number of valid digits. */
    int rulim = ulim;

    if (**buf < '0' || **buf > '9')
        return (0);

    do {
        result *= 10;
        result += *(*buf)++ - '0';
        rulim /= 10;
    } while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');

    if (result < llim || result > ulim)
        return (0);

    *dest = result;
    return (1);
}
/*******************************************************************************
 * arg_dbl: Implements the double command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>

static void arg_dbl_resetfn(struct arg_dbl* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static int arg_dbl_scanfn(struct arg_dbl* parent, const char* argval) {
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount) {
        /* maximum number of arguments exceeded */
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* a valid argument with no argument value was given. */
        /* This happens when an optional argument value was invoked. */
        /* leave parent argument value unaltered but still count the argument. */
        parent->count++;
    } else {
        double val;
        char* end;

        /* extract double from argval into val */
        val = strtod(argval, &end);

        /* if success then store result in parent->dval[] array otherwise return error*/
        if (*end == 0)
            parent->dval[parent->count++] = val;
        else
            errorcode = ARG_ERR_BADDOUBLE;
    }

    ARG_TRACE(("%s:scanfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static int arg_dbl_checkfn(struct arg_dbl* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;

    ARG_TRACE(("%s:checkfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static void arg_dbl_errorfn(struct arg_dbl* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        case ARG_ERR_BADDOUBLE:
            arg_dstr_catf(ds, "invalid argument \"%s\" to option ", argval);
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;
    }
}

struct arg_dbl* arg_dbl0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_dbln(shortopts, longopts, datatype, 0, 1, glossary);
}

struct arg_dbl* arg_dbl1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_dbln(shortopts, longopts, datatype, 1, 1, glossary);
}

struct arg_dbl* arg_dbln(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {
    size_t nbytes;
    struct arg_dbl* result;

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_dbl)             /* storage for struct arg_dbl */
             + (maxcount + 1) * sizeof(double); /* storage for dval[maxcount] array plus one extra for padding to memory boundary */

    result = (struct arg_dbl*)xmalloc(nbytes);

    size_t addr;
    size_t rem;

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : "<double>";
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_dbl_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_dbl_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_dbl_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_dbl_errorfn;

    /* Store the dval[maxcount] array on the first double boundary that
     * immediately follows the arg_dbl struct. We do the memory alignment
     * purely for SPARC and Motorola systems. They require floats and
     * doubles to be aligned on natural boundaries.
     */
    addr = (size_t)(result + 1);
    rem = addr % sizeof(double);
    result->dval = (double*)(addr + sizeof(double) - rem);
    ARG_TRACE(("addr=%p, dval=%p, sizeof(double)=%d rem=%d\n", addr, result->dval, (int)sizeof(double), (int)rem));

    result->count = 0;

    ARG_TRACE(("arg_dbln() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_end: Implements the error handling utilities
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>

static void arg_end_resetfn(struct arg_end* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static void arg_end_errorfn(void* parent, arg_dstr_t ds, int error, const char* argval, const char* progname) {
    /* suppress unreferenced formal parameter warning */
    (void)parent;

    progname = progname ? progname : "";
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (error) {
        case ARG_ELIMIT:
            arg_dstr_cat(ds, "too many errors to display");
            break;
        case ARG_EMALLOC:
            arg_dstr_cat(ds, "insufficient memory");
            break;
        case ARG_ENOMATCH:
            arg_dstr_catf(ds, "unexpected argument \"%s\"", argval);
            break;
        case ARG_EMISSARG:
            arg_dstr_catf(ds, "option \"%s\" requires an argument", argval);
            break;
        case ARG_ELONGOPT:
            arg_dstr_catf(ds, "invalid option \"%s\"", argval);
            break;
        default:
            arg_dstr_catf(ds, "invalid option \"-%c\"", error);
            break;
    }

    arg_dstr_cat(ds, "\n");
}

struct arg_end* arg_end(int maxcount) {
    size_t nbytes;
    struct arg_end* result;

    nbytes = sizeof(struct arg_end) + maxcount * sizeof(int) /* storage for int error[maxcount] array*/
             + maxcount * sizeof(void*)                      /* storage for void* parent[maxcount] array */
             + maxcount * sizeof(char*);                     /* storage for char* argval[maxcount] array */

    result = (struct arg_end*)xmalloc(nbytes);

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_TERMINATOR;
    result->hdr.shortopts = NULL;
    result->hdr.longopts = NULL;
    result->hdr.datatype = NULL;
    result->hdr.glossary = NULL;
    result->hdr.mincount = 1;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_end_resetfn;
    result->hdr.scanfn = NULL;
    result->hdr.checkfn = NULL;
    result->hdr.errorfn = (arg_errorfn*)arg_end_errorfn;

    /* store error[maxcount] array immediately after struct arg_end */
    result->error = (int*)(result + 1);

    /* store parent[maxcount] array immediately after error[] array */
    result->parent = (void**)(result->error + maxcount);

    /* store argval[maxcount] array immediately after parent[] array */
    result->argval = (const char**)(result->parent + maxcount);

    ARG_TRACE(("arg_end(%d) returns %p\n", maxcount, result));
    return result;
}

void arg_print_errors_ds(arg_dstr_t ds, struct arg_end* end, const char* progname) {
    int i;
    ARG_TRACE(("arg_errors()\n"));
    for (i = 0; i < end->count; i++) {
        struct arg_hdr* errorparent = (struct arg_hdr*)(end->parent[i]);
        if (errorparent->errorfn)
            errorparent->errorfn(end->parent[i], ds, end->error[i], end->argval[i], progname);
    }
}

void arg_print_errors(FILE* fp, struct arg_end* end, const char* progname) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_errors_ds(ds, end, progname);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}/*******************************************************************************
 * arg_file: Implements the file command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>
#include <string.h>

#ifdef WIN32
#define FILESEPARATOR1 '\\'
#define FILESEPARATOR2 '/'
#else
#define FILESEPARATOR1 '/'
#define FILESEPARATOR2 '/'
#endif

static void arg_file_resetfn(struct arg_file* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

/* Returns ptr to the base filename within *filename */
static const char* arg_basename(const char* filename) {
    const char *result = NULL, *result1, *result2;

    /* Find the last occurrence of eother file separator character. */
    /* Two alternative file separator chars are supported as legal  */
    /* file separators but not both together in the same filename.  */
    result1 = (filename ? strrchr(filename, FILESEPARATOR1) : NULL);
    result2 = (filename ? strrchr(filename, FILESEPARATOR2) : NULL);

    if (result2)
        result = result2 + 1; /* using FILESEPARATOR2 (the alternative file separator) */

    if (result1)
        result = result1 + 1; /* using FILESEPARATOR1 (the preferred file separator) */

    if (!result)
        result = filename; /* neither file separator was found so basename is the whole filename */

    /* special cases of "." and ".." are not considered basenames */
    if (result && (strcmp(".", result) == 0 || strcmp("..", result) == 0))
        result = filename + strlen(filename);

    return result;
}

/* Returns ptr to the file extension within *basename */
static const char* arg_extension(const char* basename) {
    /* find the last occurrence of '.' in basename */
    const char* result = (basename ? strrchr(basename, '.') : NULL);

    /* if no '.' was found then return pointer to end of basename */
    if (basename && !result)
        result = basename + strlen(basename);

    /* special case: basenames with a single leading dot (eg ".foo") are not considered as true extensions */
    if (basename && result == basename)
        result = basename + strlen(basename);

    /* special case: empty extensions (eg "foo.","foo..") are not considered as true extensions */
    if (basename && result && result[1] == '\0')
        result = basename + strlen(basename);

    return result;
}

static int arg_file_scanfn(struct arg_file* parent, const char* argval) {
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount) {
        /* maximum number of arguments exceeded */
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* a valid argument with no argument value was given. */
        /* This happens when an optional argument value was invoked. */
        /* leave parent arguiment value unaltered but still count the argument. */
        parent->count++;
    } else {
        parent->filename[parent->count] = argval;
        parent->basename[parent->count] = arg_basename(argval);
        parent->extension[parent->count] =
                arg_extension(parent->basename[parent->count]); /* only seek extensions within the basename (not the file path)*/
        parent->count++;
    }

    ARG_TRACE(("%s4:scanfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static int arg_file_checkfn(struct arg_file* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;

    ARG_TRACE(("%s:checkfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static void arg_file_errorfn(struct arg_file* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        default:
            arg_dstr_catf(ds, "unknown error at \"%s\"\n", argval);
    }
}

struct arg_file* arg_file0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_filen(shortopts, longopts, datatype, 0, 1, glossary);
}

struct arg_file* arg_file1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_filen(shortopts, longopts, datatype, 1, 1, glossary);
}

struct arg_file* arg_filen(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {
    size_t nbytes;
    struct arg_file* result;

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_file)     /* storage for struct arg_file */
             + sizeof(char*) * maxcount  /* storage for filename[maxcount] array */
             + sizeof(char*) * maxcount  /* storage for basename[maxcount] array */
             + sizeof(char*) * maxcount; /* storage for extension[maxcount] array */

    result = (struct arg_file*)xmalloc(nbytes);

    int i;

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.glossary = glossary;
    result->hdr.datatype = datatype ? datatype : "<file>";
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_file_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_file_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_file_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_file_errorfn;

    /* store the filename,basename,extension arrays immediately after the arg_file struct */
    result->filename = (const char**)(result + 1);
    result->basename = result->filename + maxcount;
    result->extension = result->basename + maxcount;
    result->count = 0;

    /* foolproof the string pointers by initialising them with empty strings */
    for (i = 0; i < maxcount; i++) {
        result->filename[i] = "";
        result->basename[i] = "";
        result->extension[i] = "";
    }

    ARG_TRACE(("arg_filen() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_int: Implements the int command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <ctype.h>
#include <limits.h>
#include <stdlib.h>

static void arg_int_resetfn(struct arg_int* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

/* strtol0x() is like strtol() except that the numeric string is    */
/* expected to be prefixed by "0X" where X is a user supplied char. */
/* The string may optionally be prefixed by white space and + or -  */
/* as in +0X123 or -0X123.                                          */
/* Once the prefix has been scanned, the remainder of the numeric   */
/* string is converted using strtol() with the given base.          */
/* eg: to parse hex str="-0X12324", specify X='X' and base=16.      */
/* eg: to parse oct str="+0o12324", specify X='O' and base=8.       */
/* eg: to parse bin str="-0B01010", specify X='B' and base=2.       */
/* Failure of conversion is indicated by result where *endptr==str. */
static long int strtol0X(const char* str, const char** endptr, char X, int base) {
    long int val;          /* stores result */
    int s = 1;             /* sign is +1 or -1 */
    const char* ptr = str; /* ptr to current position in str */

    /* skip leading whitespace */
    while (isspace(*ptr))
        ptr++;
    /* printf("1) %s\n",ptr); */

    /* scan optional sign character */
    switch (*ptr) {
        case '+':
            ptr++;
            s = 1;
            break;
        case '-':
            ptr++;
            s = -1;
            break;
        default:
            s = 1;
            break;
    }
    /* printf("2) %s\n",ptr); */

    /* '0X' prefix */
    if ((*ptr++) != '0') {
        /* printf("failed to detect '0'\n"); */
        *endptr = str;
        return 0;
    }
    /* printf("3) %s\n",ptr); */
    if (toupper(*ptr++) != toupper(X)) {
        /* printf("failed to detect '%c'\n",X); */
        *endptr = str;
        return 0;
    }
    /* printf("4) %s\n",ptr); */

    /* attempt conversion on remainder of string using strtol() */
    val = strtol(ptr, (char**)endptr, base);
    if (*endptr == ptr) {
        /* conversion failed */
        *endptr = str;
        return 0;
    }

    /* success */
    return s * val;
}

/* Returns 1 if str matches suffix (case insensitive).    */
/* Str may contain trailing whitespace, but nothing else. */
static int detectsuffix(const char* str, const char* suffix) {
    /* scan pairwise through strings until mismatch detected */
    while (toupper(*str) == toupper(*suffix)) {
        /* printf("'%c' '%c'\n", *str, *suffix); */

        /* return 1 (success) if match persists until the string terminator */
        if (*str == '\0')
            return 1;

        /* next chars */
        str++;
        suffix++;
    }
    /* printf("'%c' '%c' mismatch\n", *str, *suffix); */

    /* return 0 (fail) if the matching did not consume the entire suffix */
    if (*suffix != 0)
        return 0; /* failed to consume entire suffix */

    /* skip any remaining whitespace in str */
    while (isspace(*str))
        str++;

    /* return 1 (success) if we have reached end of str else return 0 (fail) */
    return (*str == '\0') ? 1 : 0;
}

static int arg_int_scanfn(struct arg_int* parent, const char* argval) {
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount) {
        /* maximum number of arguments exceeded */
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* a valid argument with no argument value was given. */
        /* This happens when an optional argument value was invoked. */
        /* leave parent arguiment value unaltered but still count the argument. */
        parent->count++;
    } else {
        long int val;
        const char* end;

        /* attempt to extract hex integer (eg: +0x123) from argval into val conversion */
        val = strtol0X(argval, &end, 'X', 16);
        if (end == argval) {
            /* hex failed, attempt octal conversion (eg +0o123) */
            val = strtol0X(argval, &end, 'O', 8);
            if (end == argval) {
                /* octal failed, attempt binary conversion (eg +0B101) */
                val = strtol0X(argval, &end, 'B', 2);
                if (end == argval) {
                    /* binary failed, attempt decimal conversion with no prefix (eg 1234) */
                    val = strtol(argval, (char**)&end, 10);
                    if (end == argval) {
                        /* all supported number formats failed */
                        return ARG_ERR_BADINT;
                    }
                }
            }
        }

        /* Safety check for integer overflow. WARNING: this check    */
        /* achieves nothing on machines where size(int)==size(long). */
        if (val > INT_MAX || val < INT_MIN)
            errorcode = ARG_ERR_OVERFLOW;

        /* Detect any suffixes (KB,MB,GB) and multiply argument value appropriately. */
        /* We need to be mindful of integer overflows when using such big numbers.   */
        if (detectsuffix(end, "KB")) /* kilobytes */
        {
            if (val > (INT_MAX / 1024) || val < (INT_MIN / 1024))
                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */
            else
                val *= 1024;                /* 1KB = 1024 */
        } else if (detectsuffix(end, "MB")) /* megabytes */
        {
            if (val > (INT_MAX / 1048576) || val < (INT_MIN / 1048576))
                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */
            else
                val *= 1048576;             /* 1MB = 1024*1024 */
        } else if (detectsuffix(end, "GB")) /* gigabytes */
        {
            if (val > (INT_MAX / 1073741824) || val < (INT_MIN / 1073741824))
                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */
            else
                val *= 1073741824; /* 1GB = 1024*1024*1024 */
        } else if (!detectsuffix(end, ""))
            errorcode = ARG_ERR_BADINT; /* invalid suffix detected */

        /* if success then store result in parent->ival[] array */
        if (errorcode == 0)
            parent->ival[parent->count++] = (int)val;
    }

    /* printf("%s:scanfn(%p,%p) returns %d\n",__FILE__,parent,argval,errorcode); */
    return errorcode;
}

static int arg_int_checkfn(struct arg_int* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;
    /*printf("%s:checkfn(%p) returns %d\n",__FILE__,parent,errorcode);*/
    return errorcode;
}

static void arg_int_errorfn(struct arg_int* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        case ARG_ERR_BADINT:
            arg_dstr_catf(ds, "invalid argument \"%s\" to option ", argval);
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_OVERFLOW:
            arg_dstr_cat(ds, "integer overflow at option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, " ");
            arg_dstr_catf(ds, "(%s is too large)\n", argval);
            break;
    }
}

struct arg_int* arg_int0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_intn(shortopts, longopts, datatype, 0, 1, glossary);
}

struct arg_int* arg_int1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_intn(shortopts, longopts, datatype, 1, 1, glossary);
}

struct arg_int* arg_intn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {
    size_t nbytes;
    struct arg_int* result;

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_int)    /* storage for struct arg_int */
             + maxcount * sizeof(int); /* storage for ival[maxcount] array */

    result = (struct arg_int*)xmalloc(nbytes);

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : "<int>";
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_int_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_int_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_int_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_int_errorfn;

    /* store the ival[maxcount] array immediately after the arg_int struct */
    result->ival = (int*)(result + 1);
    result->count = 0;

    ARG_TRACE(("arg_intn() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_lit: Implements the literature command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>

static void arg_lit_resetfn(struct arg_lit* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static int arg_lit_scanfn(struct arg_lit* parent, const char* argval) {
    int errorcode = 0;
    if (parent->count < parent->hdr.maxcount)
        parent->count++;
    else
        errorcode = ARG_ERR_MAXCOUNT;

    ARG_TRACE(("%s:scanfn(%p,%s) returns %d\n", __FILE__, parent, argval, errorcode));
    return errorcode;
}

static int arg_lit_checkfn(struct arg_lit* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;
    ARG_TRACE(("%s:checkfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static void arg_lit_errorfn(struct arg_lit* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_catf(ds, "%s: missing option ", progname);
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            arg_dstr_cat(ds, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_catf(ds, "%s: extraneous option ", progname);
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;
    }

    ARG_TRACE(("%s:errorfn(%p, %p, %d, %s, %s)\n", __FILE__, parent, ds, errorcode, argval, progname));
}

struct arg_lit* arg_lit0(const char* shortopts, const char* longopts, const char* glossary) {
    return arg_litn(shortopts, longopts, 0, 1, glossary);
}

struct arg_lit* arg_lit1(const char* shortopts, const char* longopts, const char* glossary) {
    return arg_litn(shortopts, longopts, 1, 1, glossary);
}

struct arg_lit* arg_litn(const char* shortopts, const char* longopts, int mincount, int maxcount, const char* glossary) {
    struct arg_lit* result;

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    result = (struct arg_lit*)xmalloc(sizeof(struct arg_lit));

    /* init the arg_hdr struct */
    result->hdr.flag = 0;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = NULL;
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_lit_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_lit_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_lit_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_lit_errorfn;

    /* init local variables */
    result->count = 0;

    ARG_TRACE(("arg_litn() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_rem: Implements the rem command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>

struct arg_rem* arg_rem(const char* datatype, const char* glossary) {
    struct arg_rem* result = (struct arg_rem*)xmalloc(sizeof(struct arg_rem));

    result->hdr.flag = 0;
    result->hdr.shortopts = NULL;
    result->hdr.longopts = NULL;
    result->hdr.datatype = datatype;
    result->hdr.glossary = glossary;
    result->hdr.mincount = 1;
    result->hdr.maxcount = 1;
    result->hdr.parent = result;
    result->hdr.resetfn = NULL;
    result->hdr.scanfn = NULL;
    result->hdr.checkfn = NULL;
    result->hdr.errorfn = NULL;

    ARG_TRACE(("arg_rem() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_rex: Implements the regex command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>
#include <string.h>

#ifndef _TREX_H_
#define _TREX_H_

/*
 * This module uses the T-Rex regular expression library to implement the regex
 * logic. Here is the copyright notice of the library:
 *
 * Copyright (C) 2003-2006 Alberto Demichelis
 *
 * This software is provided 'as-is', without any express
 * or implied warranty. In no event will the authors be held
 * liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for
 * any purpose, including commercial applications, and to alter
 * it and redistribute it freely, subject to the following restrictions:
 *
 *   1. The origin of this software must not be misrepresented;
 *      you must not claim that you wrote the original software.
 *      If you use this software in a product, an acknowledgment
 *      in the product documentation would be appreciated but
 *      is not required.
 *
 *   2. Altered source versions must be plainly marked as such,
 *      and must not be misrepresented as being the original software.
 *
 *   3. This notice may not be removed or altered from any
 *      source distribution.
 */

#ifdef __cplusplus
extern "C" {
#endif

#define TRexChar char
#define MAX_CHAR 0xFF
#define _TREXC(c) (c)
#define trex_strlen strlen
#define trex_printf printf

#ifndef TREX_API
#define TREX_API extern
#endif

#define TRex_True 1
#define TRex_False 0

#define TREX_ICASE ARG_REX_ICASE

typedef unsigned int TRexBool;
typedef struct TRex TRex;

typedef struct {
    const TRexChar* begin;
    int len;
} TRexMatch;

TREX_API TRex* trex_compile(const TRexChar* pattern, const TRexChar** error, int flags);
TREX_API void trex_free(TRex* exp);
TREX_API TRexBool trex_match(TRex* exp, const TRexChar* text);
TREX_API TRexBool trex_search(TRex* exp, const TRexChar* text, const TRexChar** out_begin, const TRexChar** out_end);
TREX_API TRexBool
trex_searchrange(TRex* exp, const TRexChar* text_begin, const TRexChar* text_end, const TRexChar** out_begin, const TRexChar** out_end);
TREX_API int trex_getsubexpcount(TRex* exp);
TREX_API TRexBool trex_getsubexp(TRex* exp, int n, TRexMatch* subexp);

#ifdef __cplusplus
}
#endif

#endif

struct privhdr {
    const char* pattern;
    int flags;
};

static void arg_rex_resetfn(struct arg_rex* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static int arg_rex_scanfn(struct arg_rex* parent, const char* argval) {
    int errorcode = 0;
    const TRexChar* error = NULL;
    TRex* rex = NULL;
    TRexBool is_match = TRex_False;

    if (parent->count == parent->hdr.maxcount) {
        /* maximum number of arguments exceeded */
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* a valid argument with no argument value was given. */
        /* This happens when an optional argument value was invoked. */
        /* leave parent argument value unaltered but still count the argument. */
        parent->count++;
    } else {
        struct privhdr* priv = (struct privhdr*)parent->hdr.priv;

        /* test the current argument value for a match with the regular expression */
        /* if a match is detected, record the argument value in the arg_rex struct */

        rex = trex_compile(priv->pattern, &error, priv->flags);
        is_match = trex_match(rex, argval);
        if (!is_match)
            errorcode = ARG_ERR_REGNOMATCH;
        else
            parent->sval[parent->count++] = argval;

        trex_free(rex);
    }

    ARG_TRACE(("%s:scanfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static int arg_rex_checkfn(struct arg_rex* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;
    // struct privhdr *priv = (struct privhdr*)parent->hdr.priv;

    /* free the regex "program" we constructed in resetfn */
    // regfree(&(priv->regex));

    /*printf("%s:checkfn(%p) returns %d\n",__FILE__,parent,errorcode);*/
    return errorcode;
}

static void arg_rex_errorfn(struct arg_rex* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        case ARG_ERR_REGNOMATCH:
            arg_dstr_cat(ds, "illegal value  ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;

        default: {
            // char errbuff[256];
            // regerror(errorcode, NULL, errbuff, sizeof(errbuff));
            // printf("%s\n", errbuff);
        } break;
    }
}

struct arg_rex* arg_rex0(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary) {
    return arg_rexn(shortopts, longopts, pattern, datatype, 0, 1, flags, glossary);
}

struct arg_rex* arg_rex1(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary) {
    return arg_rexn(shortopts, longopts, pattern, datatype, 1, 1, flags, glossary);
}

struct arg_rex* arg_rexn(const char* shortopts,
                         const char* longopts,
                         const char* pattern,
                         const char* datatype,
                         int mincount,
                         int maxcount,
                         int flags,
                         const char* glossary) {
    size_t nbytes;
    struct arg_rex* result;
    struct privhdr* priv;
    int i;
    const TRexChar* error = NULL;
    TRex* rex = NULL;

    if (!pattern) {
        printf("argtable: ERROR - illegal regular expression pattern \"(NULL)\"\n");
        printf("argtable: Bad argument table.\n");
        return NULL;
    }

    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_rex)      /* storage for struct arg_rex */
             + sizeof(struct privhdr)    /* storage for private arg_rex data */
             + maxcount * sizeof(char*); /* storage for sval[maxcount] array */

    /* init the arg_hdr struct */
    result = (struct arg_rex*)xmalloc(nbytes);
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : pattern;
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_rex_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_rex_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_rex_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_rex_errorfn;

    /* store the arg_rex_priv struct immediately after the arg_rex struct */
    result->hdr.priv = result + 1;
    priv = (struct privhdr*)(result->hdr.priv);
    priv->pattern = pattern;
    priv->flags = flags;

    /* store the sval[maxcount] array immediately after the arg_rex_priv struct */
    result->sval = (const char**)(priv + 1);
    result->count = 0;

    /* foolproof the string pointers by initializing them to reference empty strings */
    for (i = 0; i < maxcount; i++)
        result->sval[i] = "";

    /* here we construct and destroy a regex representation of the regular
     * expression for no other reason than to force any regex errors to be
     * trapped now rather than later. If we don't, then errors may go undetected
     * until an argument is actually parsed.
     */

    rex = trex_compile(priv->pattern, &error, priv->flags);
    if (rex == NULL) {
        ARG_LOG(("argtable: %s \"%s\"\n", error ? error : _TREXC("undefined"), priv->pattern));
        ARG_LOG(("argtable: Bad argument table.\n"));
    }

    trex_free(rex);

    ARG_TRACE(("arg_rexn() returns %p\n", result));
    return result;
}

/* see copyright notice in trex.h */
#include <ctype.h>
#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#ifdef _UINCODE
#define scisprint iswprint
#define scstrlen wcslen
#define scprintf wprintf
#define _SC(x) L(x)
#else
#define scisprint isprint
#define scstrlen strlen
#define scprintf printf
#define _SC(x) (x)
#endif

#ifdef _DEBUG
#include <stdio.h>

static const TRexChar* g_nnames[] = {_SC("NONE"),    _SC("OP_GREEDY"), _SC("OP_OR"),     _SC("OP_EXPR"),   _SC("OP_NOCAPEXPR"),
                                     _SC("OP_DOT"),  _SC("OP_CLASS"),  _SC("OP_CCLASS"), _SC("OP_NCLASS"), _SC("OP_RANGE"),
                                     _SC("OP_CHAR"), _SC("OP_EOL"),    _SC("OP_BOL"),    _SC("OP_WB")};

#endif
#define OP_GREEDY (MAX_CHAR + 1)  // * + ? {n}
#define OP_OR (MAX_CHAR + 2)
#define OP_EXPR (MAX_CHAR + 3)       // parentesis ()
#define OP_NOCAPEXPR (MAX_CHAR + 4)  // parentesis (?:)
#define OP_DOT (MAX_CHAR + 5)
#define OP_CLASS (MAX_CHAR + 6)
#define OP_CCLASS (MAX_CHAR + 7)
#define OP_NCLASS (MAX_CHAR + 8)  // negates class the [^
#define OP_RANGE (MAX_CHAR + 9)
#define OP_CHAR (MAX_CHAR + 10)
#define OP_EOL (MAX_CHAR + 11)
#define OP_BOL (MAX_CHAR + 12)
#define OP_WB (MAX_CHAR + 13)

#define TREX_SYMBOL_ANY_CHAR ('.')
#define TREX_SYMBOL_GREEDY_ONE_OR_MORE ('+')
#define TREX_SYMBOL_GREEDY_ZERO_OR_MORE ('*')
#define TREX_SYMBOL_GREEDY_ZERO_OR_ONE ('?')
#define TREX_SYMBOL_BRANCH ('|')
#define TREX_SYMBOL_END_OF_STRING ('$')
#define TREX_SYMBOL_BEGINNING_OF_STRING ('^')
#define TREX_SYMBOL_ESCAPE_CHAR ('\\')

typedef int TRexNodeType;

typedef struct tagTRexNode {
    TRexNodeType type;
    int left;
    int right;
    int next;
} TRexNode;

struct TRex {
    const TRexChar* _eol;
    const TRexChar* _bol;
    const TRexChar* _p;
    int _first;
    int _op;
    TRexNode* _nodes;
    int _nallocated;
    int _nsize;
    int _nsubexpr;
    TRexMatch* _matches;
    int _currsubexp;
    void* _jmpbuf;
    const TRexChar** _error;
    int _flags;
};

static int trex_list(TRex* exp);

static int trex_newnode(TRex* exp, TRexNodeType type) {
    TRexNode n;
    int newid;
    n.type = type;
    n.next = n.right = n.left = -1;
    if (type == OP_EXPR)
        n.right = exp->_nsubexpr++;
    if (exp->_nallocated < (exp->_nsize + 1)) {
        exp->_nallocated *= 2;
        exp->_nodes = (TRexNode*)xrealloc(exp->_nodes, exp->_nallocated * sizeof(TRexNode));
    }
    exp->_nodes[exp->_nsize++] = n;
    newid = exp->_nsize - 1;
    return (int)newid;
}

static void trex_error(TRex* exp, const TRexChar* error) {
    if (exp->_error)
        *exp->_error = error;
    longjmp(*((jmp_buf*)exp->_jmpbuf), -1);
}

static void trex_expect(TRex* exp, int n) {
    if ((*exp->_p) != n)
        trex_error(exp, _SC("expected paren"));
    exp->_p++;
}

static TRexChar trex_escapechar(TRex* exp) {
    if (*exp->_p == TREX_SYMBOL_ESCAPE_CHAR) {
        exp->_p++;
        switch (*exp->_p) {
            case 'v':
                exp->_p++;
                return '\v';
            case 'n':
                exp->_p++;
                return '\n';
            case 't':
                exp->_p++;
                return '\t';
            case 'r':
                exp->_p++;
                return '\r';
            case 'f':
                exp->_p++;
                return '\f';
            default:
                return (*exp->_p++);
        }
    } else if (!scisprint(*exp->_p))
        trex_error(exp, _SC("letter expected"));
    return (*exp->_p++);
}

static int trex_charclass(TRex* exp, int classid) {
    int n = trex_newnode(exp, OP_CCLASS);
    exp->_nodes[n].left = classid;
    return n;
}

static int trex_charnode(TRex* exp, TRexBool isclass) {
    TRexChar t;
    if (*exp->_p == TREX_SYMBOL_ESCAPE_CHAR) {
        exp->_p++;
        switch (*exp->_p) {
            case 'n':
                exp->_p++;
                return trex_newnode(exp, '\n');
            case 't':
                exp->_p++;
                return trex_newnode(exp, '\t');
            case 'r':
                exp->_p++;
                return trex_newnode(exp, '\r');
            case 'f':
                exp->_p++;
                return trex_newnode(exp, '\f');
            case 'v':
                exp->_p++;
                return trex_newnode(exp, '\v');
            case 'a':
            case 'A':
            case 'w':
            case 'W':
            case 's':
            case 'S':
            case 'd':
            case 'D':
            case 'x':
            case 'X':
            case 'c':
            case 'C':
            case 'p':
            case 'P':
            case 'l':
            case 'u': {
                t = *exp->_p;
                exp->_p++;
                return trex_charclass(exp, t);
            }
            case 'b':
            case 'B':
                if (!isclass) {
                    int node = trex_newnode(exp, OP_WB);
                    exp->_nodes[node].left = *exp->_p;
                    exp->_p++;
                    return node;
                }
                /* fall through */
            default:
                t = *exp->_p;
                exp->_p++;
                return trex_newnode(exp, t);
        }
    } else if (!scisprint(*exp->_p)) {
        trex_error(exp, _SC("letter expected"));
    }
    t = *exp->_p;
    exp->_p++;
    return trex_newnode(exp, t);
}
static int trex_class(TRex* exp) {
    int ret = -1;
    int first = -1, chain;
    if (*exp->_p == TREX_SYMBOL_BEGINNING_OF_STRING) {
        ret = trex_newnode(exp, OP_NCLASS);
        exp->_p++;
    } else
        ret = trex_newnode(exp, OP_CLASS);

    if (*exp->_p == ']')
        trex_error(exp, _SC("empty class"));
    chain = ret;
    while (*exp->_p != ']' && exp->_p != exp->_eol) {
        if (*exp->_p == '-' && first != -1) {
            int r, t;
            if (*exp->_p++ == ']')
                trex_error(exp, _SC("unfinished range"));
            r = trex_newnode(exp, OP_RANGE);
            if (first > *exp->_p)
                trex_error(exp, _SC("invalid range"));
            if (exp->_nodes[first].type == OP_CCLASS)
                trex_error(exp, _SC("cannot use character classes in ranges"));
            exp->_nodes[r].left = exp->_nodes[first].type;
            t = trex_escapechar(exp);
            exp->_nodes[r].right = t;
            exp->_nodes[chain].next = r;
            chain = r;
            first = -1;
        } else {
            if (first != -1) {
                int c = first;
                exp->_nodes[chain].next = c;
                chain = c;
                first = trex_charnode(exp, TRex_True);
            } else {
                first = trex_charnode(exp, TRex_True);
            }
        }
    }
    if (first != -1) {
        int c = first;
        exp->_nodes[chain].next = c;
        chain = c;
        first = -1;
    }
    /* hack? */
    exp->_nodes[ret].left = exp->_nodes[ret].next;
    exp->_nodes[ret].next = -1;
    return ret;
}

static int trex_parsenumber(TRex* exp) {
    int ret = *exp->_p - '0';
    int positions = 10;
    exp->_p++;
    while (isdigit(*exp->_p)) {
        ret = ret * 10 + (*exp->_p++ - '0');
        if (positions == 1000000000)
            trex_error(exp, _SC("overflow in numeric constant"));
        positions *= 10;
    };
    return ret;
}

static int trex_element(TRex* exp) {
    int ret = -1;
    switch (*exp->_p) {
        case '(': {
            int expr, newn;
            exp->_p++;

            if (*exp->_p == '?') {
                exp->_p++;
                trex_expect(exp, ':');
                expr = trex_newnode(exp, OP_NOCAPEXPR);
            } else
                expr = trex_newnode(exp, OP_EXPR);
            newn = trex_list(exp);
            exp->_nodes[expr].left = newn;
            ret = expr;
            trex_expect(exp, ')');
        } break;
        case '[':
            exp->_p++;
            ret = trex_class(exp);
            trex_expect(exp, ']');
            break;
        case TREX_SYMBOL_END_OF_STRING:
            exp->_p++;
            ret = trex_newnode(exp, OP_EOL);
            break;
        case TREX_SYMBOL_ANY_CHAR:
            exp->_p++;
            ret = trex_newnode(exp, OP_DOT);
            break;
        default:
            ret = trex_charnode(exp, TRex_False);
            break;
    }

    {
        TRexBool isgreedy = TRex_False;
        unsigned short p0 = 0, p1 = 0;
        switch (*exp->_p) {
            case TREX_SYMBOL_GREEDY_ZERO_OR_MORE:
                p0 = 0;
                p1 = 0xFFFF;
                exp->_p++;
                isgreedy = TRex_True;
                break;
            case TREX_SYMBOL_GREEDY_ONE_OR_MORE:
                p0 = 1;
                p1 = 0xFFFF;
                exp->_p++;
                isgreedy = TRex_True;
                break;
            case TREX_SYMBOL_GREEDY_ZERO_OR_ONE:
                p0 = 0;
                p1 = 1;
                exp->_p++;
                isgreedy = TRex_True;
                break;
            case '{':
                exp->_p++;
                if (!isdigit(*exp->_p))
                    trex_error(exp, _SC("number expected"));
                p0 = (unsigned short)trex_parsenumber(exp);
                /*******************************/
                switch (*exp->_p) {
                    case '}':
                        p1 = p0;
                        exp->_p++;
                        break;
                    case ',':
                        exp->_p++;
                        p1 = 0xFFFF;
                        if (isdigit(*exp->_p)) {
                            p1 = (unsigned short)trex_parsenumber(exp);
                        }
                        trex_expect(exp, '}');
                        break;
                    default:
                        trex_error(exp, _SC(", or } expected"));
                }
                /*******************************/
                isgreedy = TRex_True;
                break;
        }
        if (isgreedy) {
            int nnode = trex_newnode(exp, OP_GREEDY);
            exp->_nodes[nnode].left = ret;
            exp->_nodes[nnode].right = ((p0) << 16) | p1;
            ret = nnode;
        }
    }
    if ((*exp->_p != TREX_SYMBOL_BRANCH) && (*exp->_p != ')') && (*exp->_p != TREX_SYMBOL_GREEDY_ZERO_OR_MORE) &&
        (*exp->_p != TREX_SYMBOL_GREEDY_ONE_OR_MORE) && (*exp->_p != '\0')) {
        int nnode = trex_element(exp);
        exp->_nodes[ret].next = nnode;
    }

    return ret;
}

static int trex_list(TRex* exp) {
    int ret = -1, e;
    if (*exp->_p == TREX_SYMBOL_BEGINNING_OF_STRING) {
        exp->_p++;
        ret = trex_newnode(exp, OP_BOL);
    }
    e = trex_element(exp);
    if (ret != -1) {
        exp->_nodes[ret].next = e;
    } else
        ret = e;

    if (*exp->_p == TREX_SYMBOL_BRANCH) {
        int temp, tright;
        exp->_p++;
        temp = trex_newnode(exp, OP_OR);
        exp->_nodes[temp].left = ret;
        tright = trex_list(exp);
        exp->_nodes[temp].right = tright;
        ret = temp;
    }
    return ret;
}

static TRexBool trex_matchcclass(int cclass, TRexChar c) {
    switch (cclass) {
        case 'a':
            return isalpha(c) ? TRex_True : TRex_False;
        case 'A':
            return !isalpha(c) ? TRex_True : TRex_False;
        case 'w':
            return (isalnum(c) || c == '_') ? TRex_True : TRex_False;
        case 'W':
            return (!isalnum(c) && c != '_') ? TRex_True : TRex_False;
        case 's':
            return isspace(c) ? TRex_True : TRex_False;
        case 'S':
            return !isspace(c) ? TRex_True : TRex_False;
        case 'd':
            return isdigit(c) ? TRex_True : TRex_False;
        case 'D':
            return !isdigit(c) ? TRex_True : TRex_False;
        case 'x':
            return isxdigit(c) ? TRex_True : TRex_False;
        case 'X':
            return !isxdigit(c) ? TRex_True : TRex_False;
        case 'c':
            return iscntrl(c) ? TRex_True : TRex_False;
        case 'C':
            return !iscntrl(c) ? TRex_True : TRex_False;
        case 'p':
            return ispunct(c) ? TRex_True : TRex_False;
        case 'P':
            return !ispunct(c) ? TRex_True : TRex_False;
        case 'l':
            return islower(c) ? TRex_True : TRex_False;
        case 'u':
            return isupper(c) ? TRex_True : TRex_False;
    }
    return TRex_False; /*cannot happen*/
}

static TRexBool trex_matchclass(TRex* exp, TRexNode* node, TRexChar c) {
    do {
        switch (node->type) {
            case OP_RANGE:
                if (exp->_flags & TREX_ICASE) {
                    if (c >= toupper(node->left) && c <= toupper(node->right))
                        return TRex_True;
                    if (c >= tolower(node->left) && c <= tolower(node->right))
                        return TRex_True;
                } else {
                    if (c >= node->left && c <= node->right)
                        return TRex_True;
                }
                break;
            case OP_CCLASS:
                if (trex_matchcclass(node->left, c))
                    return TRex_True;
                break;
            default:
                if (exp->_flags & TREX_ICASE) {
                    if (c == tolower(node->type) || c == toupper(node->type))
                        return TRex_True;
                } else {
                    if (c == node->type)
                        return TRex_True;
                }
        }
    } while ((node->next != -1) && ((node = &exp->_nodes[node->next]) != NULL));
    return TRex_False;
}

static const TRexChar* trex_matchnode(TRex* exp, TRexNode* node, const TRexChar* str, TRexNode* next) {
    TRexNodeType type = node->type;
    switch (type) {
        case OP_GREEDY: {
            // TRexNode *greedystop = (node->next != -1) ? &exp->_nodes[node->next] : NULL;
            TRexNode* greedystop = NULL;
            int p0 = (node->right >> 16) & 0x0000FFFF, p1 = node->right & 0x0000FFFF, nmaches = 0;
            const TRexChar *s = str, *good = str;

            if (node->next != -1) {
                greedystop = &exp->_nodes[node->next];
            } else {
                greedystop = next;
            }

            while ((nmaches == 0xFFFF || nmaches < p1)) {
                const TRexChar* stop;
                if ((s = trex_matchnode(exp, &exp->_nodes[node->left], s, greedystop)) == NULL)
                    break;
                nmaches++;
                good = s;
                if (greedystop) {
                    // checks that 0 matches satisfy the expression(if so skips)
                    // if not would always stop(for instance if is a '?')
                    if (greedystop->type != OP_GREEDY || (greedystop->type == OP_GREEDY && ((greedystop->right >> 16) & 0x0000FFFF) != 0)) {
                        TRexNode* gnext = NULL;
                        if (greedystop->next != -1) {
                            gnext = &exp->_nodes[greedystop->next];
                        } else if (next && next->next != -1) {
                            gnext = &exp->_nodes[next->next];
                        }
                        stop = trex_matchnode(exp, greedystop, s, gnext);
                        if (stop) {
                            // if satisfied stop it
                            if (p0 == p1 && p0 == nmaches)
                                break;
                            else if (nmaches >= p0 && p1 == 0xFFFF)
                                break;
                            else if (nmaches >= p0 && nmaches <= p1)
                                break;
                        }
                    }
                }

                if (s >= exp->_eol)
                    break;
            }
            if (p0 == p1 && p0 == nmaches)
                return good;
            else if (nmaches >= p0 && p1 == 0xFFFF)
                return good;
            else if (nmaches >= p0 && nmaches <= p1)
                return good;
            return NULL;
        }
        case OP_OR: {
            const TRexChar* asd = str;
            TRexNode* temp = &exp->_nodes[node->left];
            while ((asd = trex_matchnode(exp, temp, asd, NULL)) != NULL) {
                if (temp->next != -1)
                    temp = &exp->_nodes[temp->next];
                else
                    return asd;
            }
            asd = str;
            temp = &exp->_nodes[node->right];
            while ((asd = trex_matchnode(exp, temp, asd, NULL)) != NULL) {
                if (temp->next != -1)
                    temp = &exp->_nodes[temp->next];
                else
                    return asd;
            }
            return NULL;
            break;
        }
        case OP_EXPR:
        case OP_NOCAPEXPR: {
            TRexNode* n = &exp->_nodes[node->left];
            const TRexChar* cur = str;
            int capture = -1;
            if (node->type != OP_NOCAPEXPR && node->right == exp->_currsubexp) {
                capture = exp->_currsubexp;
                exp->_matches[capture].begin = cur;
                exp->_currsubexp++;
            }

            do {
                TRexNode* subnext = NULL;
                if (n->next != -1) {
                    subnext = &exp->_nodes[n->next];
                } else {
                    subnext = next;
                }
                if ((cur = trex_matchnode(exp, n, cur, subnext)) == NULL) {
                    if (capture != -1) {
                        exp->_matches[capture].begin = 0;
                        exp->_matches[capture].len = 0;
                    }
                    return NULL;
                }
            } while ((n->next != -1) && ((n = &exp->_nodes[n->next]) != NULL));

            if (capture != -1)
                exp->_matches[capture].len = (int)(cur - exp->_matches[capture].begin);
            return cur;
        }
        case OP_WB:
            if ((str == exp->_bol && !isspace(*str)) || (str == exp->_eol && !isspace(*(str - 1))) || (!isspace(*str) && isspace(*(str + 1))) ||
                (isspace(*str) && !isspace(*(str + 1)))) {
                return (node->left == 'b') ? str : NULL;
            }
            return (node->left == 'b') ? NULL : str;
        case OP_BOL:
            if (str == exp->_bol)
                return str;
            return NULL;
        case OP_EOL:
            if (str == exp->_eol)
                return str;
            return NULL;
        case OP_DOT: {
            str++;
        }
            return str;
        case OP_NCLASS:
        case OP_CLASS:
            if (trex_matchclass(exp, &exp->_nodes[node->left], *str) ? (type == OP_CLASS ? TRex_True : TRex_False)
                                                                     : (type == OP_NCLASS ? TRex_True : TRex_False)) {
                str++;
                return str;
            }
            return NULL;
        case OP_CCLASS:
            if (trex_matchcclass(node->left, *str)) {
                str++;
                return str;
            }
            return NULL;
        default: /* char */
            if (exp->_flags & TREX_ICASE) {
                if (*str != tolower(node->type) && *str != toupper(node->type))
                    return NULL;
            } else {
                if (*str != node->type)
                    return NULL;
            }
            str++;
            return str;
    }
}

/* public api */
TRex* trex_compile(const TRexChar* pattern, const TRexChar** error, int flags) {
    TRex* exp = (TRex*)xmalloc(sizeof(TRex));
    exp->_eol = exp->_bol = NULL;
    exp->_p = pattern;
    exp->_nallocated = (int)scstrlen(pattern) * sizeof(TRexChar);
    exp->_nodes = (TRexNode*)xmalloc(exp->_nallocated * sizeof(TRexNode));
    exp->_nsize = 0;
    exp->_matches = 0;
    exp->_nsubexpr = 0;
    exp->_first = trex_newnode(exp, OP_EXPR);
    exp->_error = error;
    exp->_jmpbuf = xmalloc(sizeof(jmp_buf));
    exp->_flags = flags;
    if (setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {
        int res = trex_list(exp);
        exp->_nodes[exp->_first].left = res;
        if (*exp->_p != '\0')
            trex_error(exp, _SC("unexpected character"));
#ifdef _DEBUG
        {
            int nsize, i;
            TRexNode* t;
            nsize = exp->_nsize;
            t = &exp->_nodes[0];
            scprintf(_SC("\n"));
            for (i = 0; i < nsize; i++) {
                if (exp->_nodes[i].type > MAX_CHAR)
                    scprintf(_SC("[%02d] %10s "), i, g_nnames[exp->_nodes[i].type - MAX_CHAR]);
                else
                    scprintf(_SC("[%02d] %10c "), i, exp->_nodes[i].type);
                scprintf(_SC("left %02d right %02d next %02d\n"), exp->_nodes[i].left, exp->_nodes[i].right, exp->_nodes[i].next);
            }
            scprintf(_SC("\n"));
        }
#endif
        exp->_matches = (TRexMatch*)xmalloc(exp->_nsubexpr * sizeof(TRexMatch));
        memset(exp->_matches, 0, exp->_nsubexpr * sizeof(TRexMatch));
    } else {
        trex_free(exp);
        return NULL;
    }
    return exp;
}

void trex_free(TRex* exp) {
    if (exp) {
        xfree(exp->_nodes);
        xfree(exp->_jmpbuf);
        xfree(exp->_matches);
        xfree(exp);
    }
}

TRexBool trex_match(TRex* exp, const TRexChar* text) {
    const TRexChar* res = NULL;
    exp->_bol = text;
    exp->_eol = text + scstrlen(text);
    exp->_currsubexp = 0;
    res = trex_matchnode(exp, exp->_nodes, text, NULL);
    if (res == NULL || res != exp->_eol)
        return TRex_False;
    return TRex_True;
}

TRexBool trex_searchrange(TRex* exp, const TRexChar* text_begin, const TRexChar* text_end, const TRexChar** out_begin, const TRexChar** out_end) {
    const TRexChar* cur = NULL;
    int node = exp->_first;
    if (text_begin >= text_end)
        return TRex_False;
    exp->_bol = text_begin;
    exp->_eol = text_end;
    do {
        cur = text_begin;
        while (node != -1) {
            exp->_currsubexp = 0;
            cur = trex_matchnode(exp, &exp->_nodes[node], cur, NULL);
            if (!cur)
                break;
            node = exp->_nodes[node].next;
        }
        text_begin++;
    } while (cur == NULL && text_begin != text_end);

    if (cur == NULL)
        return TRex_False;

    --text_begin;

    if (out_begin)
        *out_begin = text_begin;
    if (out_end)
        *out_end = cur;
    return TRex_True;
}

TRexBool trex_search(TRex* exp, const TRexChar* text, const TRexChar** out_begin, const TRexChar** out_end) {
    return trex_searchrange(exp, text, text + scstrlen(text), out_begin, out_end);
}

int trex_getsubexpcount(TRex* exp) {
    return exp->_nsubexpr;
}

TRexBool trex_getsubexp(TRex* exp, int n, TRexMatch* subexp) {
    if (n < 0 || n >= exp->_nsubexpr)
        return TRex_False;
    *subexp = exp->_matches[n];
    return TRex_True;
}
/*******************************************************************************
 * arg_str: Implements the str command-line option
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <stdlib.h>

static void arg_str_resetfn(struct arg_str* parent) {
    ARG_TRACE(("%s:resetfn(%p)\n", __FILE__, parent));
    parent->count = 0;
}

static int arg_str_scanfn(struct arg_str* parent, const char* argval) {
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount) {
        /* maximum number of arguments exceeded */
        errorcode = ARG_ERR_MAXCOUNT;
    } else if (!argval) {
        /* a valid argument with no argument value was given. */
        /* This happens when an optional argument value was invoked. */
        /* leave parent argument value unaltered but still count the argument. */
        parent->count++;
    } else {
        parent->sval[parent->count++] = argval;
    }

    ARG_TRACE(("%s:scanfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static int arg_str_checkfn(struct arg_str* parent) {
    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;

    ARG_TRACE(("%s:checkfn(%p) returns %d\n", __FILE__, parent, errorcode));
    return errorcode;
}

static void arg_str_errorfn(struct arg_str* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {
    const char* shortopts = parent->hdr.shortopts;
    const char* longopts = parent->hdr.longopts;
    const char* datatype = parent->hdr.datatype;

    /* make argval NULL safe */
    argval = argval ? argval : "";

    arg_dstr_catf(ds, "%s: ", progname);
    switch (errorcode) {
        case ARG_ERR_MINCOUNT:
            arg_dstr_cat(ds, "missing option ");
            arg_print_option_ds(ds, shortopts, longopts, datatype, "\n");
            break;

        case ARG_ERR_MAXCOUNT:
            arg_dstr_cat(ds, "excess option ");
            arg_print_option_ds(ds, shortopts, longopts, argval, "\n");
            break;
    }
}

struct arg_str* arg_str0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_strn(shortopts, longopts, datatype, 0, 1, glossary);
}

struct arg_str* arg_str1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {
    return arg_strn(shortopts, longopts, datatype, 1, 1, glossary);
}

struct arg_str* arg_strn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {
    size_t nbytes;
    struct arg_str* result;

    /* should not allow this stupid error */
    /* we should return an error code warning this logic error */
    /* foolproof things by ensuring maxcount is not less than mincount */
    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_str)      /* storage for struct arg_str */
             + maxcount * sizeof(char*); /* storage for sval[maxcount] array */

    result = (struct arg_str*)xmalloc(nbytes);

    int i;

    /* init the arg_hdr struct */
    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : "<string>";
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn*)arg_str_resetfn;
    result->hdr.scanfn = (arg_scanfn*)arg_str_scanfn;
    result->hdr.checkfn = (arg_checkfn*)arg_str_checkfn;
    result->hdr.errorfn = (arg_errorfn*)arg_str_errorfn;

    /* store the sval[maxcount] array immediately after the arg_str struct */
    result->sval = (const char**)(result + 1);
    result->count = 0;

    /* foolproof the string pointers by initializing them to reference empty strings */
    for (i = 0; i < maxcount; i++)
        result->sval[i] = "";

    ARG_TRACE(("arg_strn() returns %p\n", result));
    return result;
}
/*******************************************************************************
 * arg_cmd: Provides the sub-command mechanism
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 2013-2019 Tom G. Huang
 * <tomghuang@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#endif

#include <assert.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MODULE_VERSION_SIZE 128

static arg_hashtable_t* s_hashtable = NULL;
static char* s_module_name = NULL;
static int s_mod_ver_major = 0;
static int s_mod_ver_minor = 0;
static int s_mod_ver_patch = 0;
static char* s_mod_ver_tag = NULL;
static char* s_mod_ver = NULL;

void arg_set_module_name(const char* name) {
    xfree(s_module_name);
    size_t slen = strlen(name);
    s_module_name = (char*)xmalloc(slen + 1);
    memset(s_module_name, 0, slen + 1);

#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
    strncpy_s(s_module_name, slen + 1, name, slen);
#else
    strncpy(s_module_name, name, slen);
#endif
}

void arg_set_module_version(int major, int minor, int patch, const char* tag) {
    s_mod_ver_major = major;
    s_mod_ver_minor = minor;
    s_mod_ver_patch = patch;

    xfree(s_mod_ver_tag);
    size_t slen_tag = strlen(tag);
    s_mod_ver_tag = (char*)xmalloc(slen_tag + 1);
    memset(s_mod_ver_tag, 0, slen_tag + 1);

#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
    strncpy_s(s_mod_ver_tag, slen_tag + 1, tag, slen_tag);
#else
    strncpy(s_mod_ver_tag, tag, slen_tag);
#endif

    arg_dstr_t ds = arg_dstr_create();
    arg_dstr_catf(ds, "%d.", s_mod_ver_major);
    arg_dstr_catf(ds, "%d.", s_mod_ver_minor);
    arg_dstr_catf(ds, "%d.", s_mod_ver_patch);
    arg_dstr_cat(ds, s_mod_ver_tag);

    xfree(s_mod_ver);
    size_t slen_ds = strlen(arg_dstr_cstr(ds));
    s_mod_ver = (char*)xmalloc(slen_ds + 1);
    memset(s_mod_ver, 0, slen_ds + 1);

#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
    strncpy_s(s_mod_ver, slen_ds + 1, arg_dstr_cstr(ds), slen_ds);
#else
    strncpy(s_mod_ver, arg_dstr_cstr(ds), slen_ds);
#endif

    arg_dstr_destroy(ds);
}

static unsigned int hash_key(void* key) {
    char* str = (char*)key;
    int c;
    unsigned int hash = 5381;

    while ((c = *str++) != 0)
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

static int equal_keys(void* key1, void* key2) {
    char* k1 = (char*)key1;
    char* k2 = (char*)key2;
    return (0 == strcmp(k1, k2));
}

void arg_cmd_init(void) {
    s_hashtable = arg_hashtable_create(32, hash_key, equal_keys);
}

void arg_cmd_uninit(void) {
    arg_hashtable_destroy(s_hashtable, 1);
}

void arg_cmd_register(const char* name, arg_cmdfn* proc, const char* description) {
    assert(strlen(name) < ARG_CMD_NAME_LEN);
    assert(strlen(description) < ARG_CMD_DESCRIPTION_LEN);

    /* Check if the command already exists. */
    /* If the command exists, replace the existing command. */
    /* If the command doesn't exist, insert the command. */
    arg_cmd_info_t* cmd_info = (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, (void*)name);
    if (cmd_info) {
        arg_hashtable_remove(s_hashtable, (void*)name);
        cmd_info = NULL;
    }

    cmd_info = (arg_cmd_info_t*)xmalloc(sizeof(arg_cmd_info_t));
    memset(cmd_info, 0, sizeof(arg_cmd_info_t));

#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
    strncpy_s(cmd_info->name, ARG_CMD_NAME_LEN, name, strlen(name));
    strncpy_s(cmd_info->description, ARG_CMD_DESCRIPTION_LEN, description, strlen(description));
#else
    strncpy(cmd_info->name, name, strlen(name));
    strncpy(cmd_info->description, description, strlen(description));
#endif

    cmd_info->proc = proc;

    size_t slen_name = strlen(name);
    void* k = xmalloc(slen_name + 1);
    memset(k, 0, slen_name + 1);

#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
    strncpy_s((char*)k, slen_name + 1, name, slen_name);
#else
    strncpy((char*)k, name, slen_name);
#endif

    arg_hashtable_insert(s_hashtable, k, cmd_info);
}

void arg_cmd_unregister(const char* name) {
    arg_hashtable_remove(s_hashtable, (void*)name);
}

int arg_cmd_dispatch(const char* name, int argc, char* argv[], arg_dstr_t res) {
    arg_cmd_info_t* cmd_info = arg_cmd_info(name);

    assert(cmd_info != NULL);
    assert(cmd_info->proc != NULL);

    return cmd_info->proc(argc, argv, res);
}

arg_cmd_info_t* arg_cmd_info(const char* name) {
    return (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, (void*)name);
}

unsigned int arg_cmd_count(void) {
    return arg_hashtable_count(s_hashtable);
}

arg_cmd_itr_t arg_cmd_itr_create(void) {
    return (arg_cmd_itr_t)arg_hashtable_itr_create(s_hashtable);
}

int arg_cmd_itr_advance(arg_cmd_itr_t itr) {
    return arg_hashtable_itr_advance((arg_hashtable_itr_t*)itr);
}

char* arg_cmd_itr_key(arg_cmd_itr_t itr) {
    return (char*)arg_hashtable_itr_key((arg_hashtable_itr_t*)itr);
}

arg_cmd_info_t* arg_cmd_itr_value(arg_cmd_itr_t itr) {
    return (arg_cmd_info_t*)arg_hashtable_itr_value((arg_hashtable_itr_t*)itr);
}

void arg_cmd_itr_remove(arg_cmd_itr_t itr) {
    arg_hashtable_itr_remove((arg_hashtable_itr_t*)itr);
}

void arg_cmd_itr_destroy(arg_cmd_itr_t itr) {
    arg_hashtable_itr_destroy((arg_hashtable_itr_t*)itr);
}

int arg_cmd_itr_search(arg_cmd_itr_t itr, void* k) {
    return arg_hashtable_itr_search((arg_hashtable_itr_t*)itr, s_hashtable, k);
}

static const char* module_name() {
    if (s_module_name == NULL || strlen(s_module_name) == 0)
        return "<name>";

    return s_module_name;
}

static const char* module_version() {
    if (s_mod_ver == NULL || strlen(s_mod_ver) == 0)
        return "0.0.0.0";

    return s_mod_ver;
}

void arg_make_get_help_msg(arg_dstr_t res) {
    arg_dstr_catf(res, "%s v%s\n", module_name(), module_version());
    arg_dstr_catf(res, "Please type '%s help' to get more information.\n", module_name());
}

void arg_make_help_msg(arg_dstr_t ds, char* cmd_name, void** argtable) {
    arg_cmd_info_t* cmd_info = (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, cmd_name);
    if (cmd_info) {
        arg_dstr_catf(ds, "%s: %s\n", cmd_name, cmd_info->description);
    }

    arg_dstr_cat(ds, "Usage:\n");
    arg_dstr_catf(ds, "  %s", module_name());

    arg_print_syntaxv_ds(ds, argtable, "\n \nAvailable options:\n");
    arg_print_glossary_ds(ds, argtable, "  %-23s %s\n");

    arg_dstr_cat(ds, "\n");
}

void arg_make_syntax_err_msg(arg_dstr_t ds, void** argtable, struct arg_end* end) {
    arg_print_errors_ds(ds, end, module_name());
    arg_dstr_cat(ds, "Usage: \n");
    arg_dstr_catf(ds, "  %s", module_name());
    arg_print_syntaxv_ds(ds, argtable, "\n");
    arg_dstr_cat(ds, "\n");
}

int arg_make_syntax_err_help_msg(arg_dstr_t ds, char* name, int help, int nerrors, void** argtable, struct arg_end* end, int* exitcode) {
    // help handling
    // note: '-h|--help' takes precedence over error reporting
    if (help > 0) {
        arg_make_help_msg(ds, name, argtable);
        *exitcode = EXIT_SUCCESS;
        return 1;
    }

    // syntax error handling
    if (nerrors > 0) {
        arg_make_syntax_err_msg(ds, argtable, end);
        *exitcode = EXIT_FAILURE;
        return 1;
    }

    return 0;
}
/*******************************************************************************
 * argtable3: Implements the main interfaces of the library
 *
 * This file is part of the argtable3 library.
 *
 * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann
 * <sheitmann@users.sourceforge.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of STEWART HEITMANN nor the  names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "argtable3.h"

#ifndef ARG_AMALGAMATION
#include "argtable3_private.h"
#include "getopt.h"
#endif

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#endif

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

static void arg_register_error(struct arg_end* end, void* parent, int error, const char* argval) {
    /* printf("arg_register_error(%p,%p,%d,%s)\n",end,parent,error,argval); */
    if (end->count < end->hdr.maxcount) {
        end->error[end->count] = error;
        end->parent[end->count] = parent;
        end->argval[end->count] = argval;
        end->count++;
    } else {
        end->error[end->hdr.maxcount - 1] = ARG_ELIMIT;
        end->parent[end->hdr.maxcount - 1] = end;
        end->argval[end->hdr.maxcount - 1] = NULL;
    }
}

/*
 * Return index of first table entry with a matching short option
 * or -1 if no match was found.
 */
static int find_shortoption(struct arg_hdr** table, char shortopt) {
    int tabindex;
    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        if (table[tabindex]->shortopts && strchr(table[tabindex]->shortopts, shortopt))
            return tabindex;
    }
    return -1;
}

struct longoptions {
    int getoptval;
    int noptions;
    struct option* options;
};

#if 0
static
void dump_longoptions(struct longoptions * longoptions)
{
    int i;
    printf("getoptval = %d\n", longoptions->getoptval);
    printf("noptions  = %d\n", longoptions->noptions);
    for (i = 0; i < longoptions->noptions; i++)
    {
        printf("options[%d].name    = \"%s\"\n",
               i,
               longoptions->options[i].name);
        printf("options[%d].has_arg = %d\n", i, longoptions->options[i].has_arg);
        printf("options[%d].flag    = %p\n", i, longoptions->options[i].flag);
        printf("options[%d].val     = %d\n", i, longoptions->options[i].val);
    }
}
#endif

static struct longoptions* alloc_longoptions(struct arg_hdr** table) {
    struct longoptions* result;
    size_t nbytes;
    int noptions = 1;
    size_t longoptlen = 0;
    int tabindex;

    /*
     * Determine the total number of option structs required
     * by counting the number of comma separated long options
     * in all table entries and return the count in noptions.
     * note: noptions starts at 1 not 0 because we getoptlong
     * requires a NULL option entry to terminate the option array.
     * While we are at it, count the number of chars required
     * to store private copies of all the longoption strings
     * and return that count in logoptlen.
     */
    tabindex = 0;
    do {
        const char* longopts = table[tabindex]->longopts;
        longoptlen += (longopts ? strlen(longopts) : 0) + 1;
        while (longopts) {
            noptions++;
            longopts = strchr(longopts + 1, ',');
        }
    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));
    /*printf("%d long options consuming %d chars in total\n",noptions,longoptlen);*/

    /* allocate storage for return data structure as: */
    /* (struct longoptions) + (struct options)[noptions] + char[longoptlen] */
    nbytes = sizeof(struct longoptions) + sizeof(struct option) * noptions + longoptlen;
    result = (struct longoptions*)xmalloc(nbytes);

    int option_index = 0;
    char* store;

    result->getoptval = 0;
    result->noptions = noptions;
    result->options = (struct option*)(result + 1);
    store = (char*)(result->options + noptions);

    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        const char* longopts = table[tabindex]->longopts;

        while (longopts && *longopts) {
            char* storestart = store;

            /* copy progressive longopt strings into the store */
            while (*longopts != 0 && *longopts != ',')
                *store++ = *longopts++;
            *store++ = 0;
            if (*longopts == ',')
                longopts++;
            /*fprintf(stderr,"storestart=\"%s\"\n",storestart);*/

            result->options[option_index].name = storestart;
            result->options[option_index].flag = &(result->getoptval);
            result->options[option_index].val = tabindex;
            if (table[tabindex]->flag & ARG_HASOPTVALUE)
                result->options[option_index].has_arg = 2;
            else if (table[tabindex]->flag & ARG_HASVALUE)
                result->options[option_index].has_arg = 1;
            else
                result->options[option_index].has_arg = 0;

            option_index++;
        }
    }
    /* terminate the options array with a zero-filled entry */
    result->options[option_index].name = 0;
    result->options[option_index].has_arg = 0;
    result->options[option_index].flag = 0;
    result->options[option_index].val = 0;

    /*dump_longoptions(result);*/
    return result;
}

static char* alloc_shortoptions(struct arg_hdr** table) {
    char* result;
    size_t len = 2;
    int tabindex;

    /* determine the total number of option chars required */
    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        struct arg_hdr* hdr = table[tabindex];
        len += 3 * (hdr->shortopts ? strlen(hdr->shortopts) : 0);
    }

    result = xmalloc(len);

    char* res = result;

    /* add a leading ':' so getopt return codes distinguish    */
    /* unrecognised option and options missing argument values */
    *res++ = ':';

    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        struct arg_hdr* hdr = table[tabindex];
        const char* shortopts = hdr->shortopts;
        while (shortopts && *shortopts) {
            *res++ = *shortopts++;
            if (hdr->flag & ARG_HASVALUE)
                *res++ = ':';
            if (hdr->flag & ARG_HASOPTVALUE)
                *res++ = ':';
        }
    }
    /* null terminate the string */
    *res = 0;

    /*printf("alloc_shortoptions() returns \"%s\"\n",(result?result:"NULL"));*/
    return result;
}

/* return index of the table terminator entry */
static int arg_endindex(struct arg_hdr** table) {
    int tabindex = 0;
    while (!(table[tabindex]->flag & ARG_TERMINATOR))
        tabindex++;
    return tabindex;
}

static void arg_parse_tagged(int argc, char** argv, struct arg_hdr** table, struct arg_end* endtable) {
    struct longoptions* longoptions;
    char* shortoptions;
    int copt;

    /*printf("arg_parse_tagged(%d,%p,%p,%p)\n",argc,argv,table,endtable);*/

    /* allocate short and long option arrays for the given opttable[].   */
    /* if the allocs fail then put an error msg in the last table entry. */
    longoptions = alloc_longoptions(table);
    shortoptions = alloc_shortoptions(table);

    /*dump_longoptions(longoptions);*/

    /* reset getopts internal option-index to zero, and disable error reporting */
    optind = 0;
    opterr = 0;

    /* fetch and process args using getopt_long */
    while ((copt = getopt_long(argc, argv, shortoptions, longoptions->options, NULL)) != -1) {
        /*
           printf("optarg='%s'\n",optarg);
           printf("optind=%d\n",optind);
           printf("copt=%c\n",(char)copt);
           printf("optopt=%c (%d)\n",optopt, (int)(optopt));
         */
        switch (copt) {
            case 0: {
                int tabindex = longoptions->getoptval;
                void* parent = table[tabindex]->parent;
                /*printf("long option detected from argtable[%d]\n", tabindex);*/
                if (optarg && optarg[0] == 0 && (table[tabindex]->flag & ARG_HASVALUE)) {
                    /* printf(": long option %s requires an argument\n",argv[optind-1]); */
                    arg_register_error(endtable, endtable, ARG_EMISSARG, argv[optind - 1]);
                    /* continue to scan the (empty) argument value to enforce argument count checking */
                }
                if (table[tabindex]->scanfn) {
                    int errorcode = table[tabindex]->scanfn(parent, optarg);
                    if (errorcode != 0)
                        arg_register_error(endtable, parent, errorcode, optarg);
                }
            } break;

            case '?':
                /*
                 * getopt_long() found an unrecognised short option.
                 * if it was a short option its value is in optopt
                 * if it was a long option then optopt=0
                 */
                switch (optopt) {
                    case 0:
                        /*printf("?0 unrecognised long option %s\n",argv[optind-1]);*/
                        arg_register_error(endtable, endtable, ARG_ELONGOPT, argv[optind - 1]);
                        break;
                    default:
                        /*printf("?* unrecognised short option '%c'\n",optopt);*/
                        arg_register_error(endtable, endtable, optopt, NULL);
                        break;
                }
                break;

            case ':':
                /*
                 * getopt_long() found an option with its argument missing.
                 */
                /*printf(": option %s requires an argument\n",argv[optind-1]); */
                arg_register_error(endtable, endtable, ARG_EMISSARG, argv[optind - 1]);
                break;

            default: {
                /* getopt_long() found a valid short option */
                int tabindex = find_shortoption(table, (char)copt);
                /*printf("short option detected from argtable[%d]\n", tabindex);*/
                if (tabindex == -1) {
                    /* should never get here - but handle it just in case */
                    /*printf("unrecognised short option %d\n",copt);*/
                    arg_register_error(endtable, endtable, copt, NULL);
                } else {
                    if (table[tabindex]->scanfn) {
                        void* parent = table[tabindex]->parent;
                        int errorcode = table[tabindex]->scanfn(parent, optarg);
                        if (errorcode != 0)
                            arg_register_error(endtable, parent, errorcode, optarg);
                    }
                }
                break;
            }
        }
    }

    xfree(shortoptions);
    xfree(longoptions);
}

static void arg_parse_untagged(int argc, char** argv, struct arg_hdr** table, struct arg_end* endtable) {
    int tabindex = 0;
    int errorlast = 0;
    const char* optarglast = NULL;
    void* parentlast = NULL;

    /*printf("arg_parse_untagged(%d,%p,%p,%p)\n",argc,argv,table,endtable);*/
    while (!(table[tabindex]->flag & ARG_TERMINATOR)) {
        void* parent;
        int errorcode;

        /* if we have exhausted our argv[optind] entries then we have finished */
        if (optind >= argc) {
            /*printf("arg_parse_untagged(): argv[] exhausted\n");*/
            return;
        }

        /* skip table entries with non-null long or short options (they are not untagged entries) */
        if (table[tabindex]->longopts || table[tabindex]->shortopts) {
            /*printf("arg_parse_untagged(): skipping argtable[%d] (tagged argument)\n",tabindex);*/
            tabindex++;
            continue;
        }

        /* skip table entries with NULL scanfn */
        if (!(table[tabindex]->scanfn)) {
            /*printf("arg_parse_untagged(): skipping argtable[%d] (NULL scanfn)\n",tabindex);*/
            tabindex++;
            continue;
        }

        /* attempt to scan the current argv[optind] with the current     */
        /* table[tabindex] entry. If it succeeds then keep it, otherwise */
        /* try again with the next table[] entry.                        */
        parent = table[tabindex]->parent;
        errorcode = table[tabindex]->scanfn(parent, argv[optind]);
        if (errorcode == 0) {
            /* success, move onto next argv[optind] but stay with same table[tabindex] */
            /*printf("arg_parse_untagged(): argtable[%d] successfully matched\n",tabindex);*/
            optind++;

            /* clear the last tentative error */
            errorlast = 0;
        } else {
            /* failure, try same argv[optind] with next table[tabindex] entry */
            /*printf("arg_parse_untagged(): argtable[%d] failed match\n",tabindex);*/
            tabindex++;

            /* remember this as a tentative error we may wish to reinstate later */
            errorlast = errorcode;
            optarglast = argv[optind];
            parentlast = parent;
        }
    }

    /* if a tenative error still remains at this point then register it as a proper error */
    if (errorlast) {
        arg_register_error(endtable, parentlast, errorlast, optarglast);
        optind++;
    }

    /* only get here when not all argv[] entries were consumed */
    /* register an error for each unused argv[] entry */
    while (optind < argc) {
        /*printf("arg_parse_untagged(): argv[%d]=\"%s\" not consumed\n",optind,argv[optind]);*/
        arg_register_error(endtable, endtable, ARG_ENOMATCH, argv[optind++]);
    }

    return;
}

static void arg_parse_check(struct arg_hdr** table, struct arg_end* endtable) {
    int tabindex = 0;
    /* printf("arg_parse_check()\n"); */
    do {
        if (table[tabindex]->checkfn) {
            void* parent = table[tabindex]->parent;
            int errorcode = table[tabindex]->checkfn(parent);
            if (errorcode != 0)
                arg_register_error(endtable, parent, errorcode, NULL);
        }
    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));
}

static void arg_reset(void** argtable) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int tabindex = 0;
    /*printf("arg_reset(%p)\n",argtable);*/
    do {
        if (table[tabindex]->resetfn)
            table[tabindex]->resetfn(table[tabindex]->parent);
    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));
}

int arg_parse(int argc, char** argv, void** argtable) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    struct arg_end* endtable;
    int endindex;
    char** argvcopy = NULL;

    /*printf("arg_parse(%d,%p,%p)\n",argc,argv,argtable);*/

    /* reset any argtable data from previous invocations */
    arg_reset(argtable);

    /* locate the first end-of-table marker within the array */
    endindex = arg_endindex(table);
    endtable = (struct arg_end*)table[endindex];

    /* Special case of argc==0.  This can occur on Texas Instruments DSP. */
    /* Failure to trap this case results in an unwanted NULL result from  */
    /* the malloc for argvcopy (next code block).                         */
    if (argc == 0) {
        /* We must still perform post-parse checks despite the absence of command line arguments */
        arg_parse_check(table, endtable);

        /* Now we are finished */
        return endtable->count;
    }

    argvcopy = (char**)xmalloc(sizeof(char*) * (argc + 1));

    int i;

    /*
        Fill in the local copy of argv[]. We need a local copy
        because getopt rearranges argv[] which adversely affects
        susbsequent parsing attempts.
        */
    for (i = 0; i < argc; i++)
        argvcopy[i] = argv[i];

    argvcopy[argc] = NULL;

    /* parse the command line (local copy) for tagged options */
    arg_parse_tagged(argc, argvcopy, table, endtable);

    /* parse the command line (local copy) for untagged options */
    arg_parse_untagged(argc, argvcopy, table, endtable);

    /* if no errors so far then perform post-parse checks otherwise dont bother */
    if (endtable->count == 0)
        arg_parse_check(table, endtable);

    /* release the local copt of argv[] */
    xfree(argvcopy);

    return endtable->count;
}

/*
 * Concatenate contents of src[] string onto *pdest[] string.
 * The *pdest pointer is altered to point to the end of the
 * target string and *pndest is decremented by the same number
 * of chars.
 * Does not append more than *pndest chars into *pdest[]
 * so as to prevent buffer overruns.
 * Its something like strncat() but more efficient for repeated
 * calls on the same destination string.
 * Example of use:
 *   char dest[30] = "good"
 *   size_t ndest = sizeof(dest);
 *   char *pdest = dest;
 *   arg_char(&pdest,"bye ",&ndest);
 *   arg_char(&pdest,"cruel ",&ndest);
 *   arg_char(&pdest,"world!",&ndest);
 * Results in:
 *   dest[] == "goodbye cruel world!"
 *   ndest  == 10
 */
static void arg_cat(char** pdest, const char* src, size_t* pndest) {
    char* dest = *pdest;
    char* end = dest + *pndest;

    /*locate null terminator of dest string */
    while (dest < end && *dest != 0)
        dest++;

    /* concat src string to dest string */
    while (dest < end && *src != 0)
        *dest++ = *src++;

    /* null terminate dest string */
    *dest = 0;

    /* update *pdest and *pndest */
    *pndest = end - dest;
    *pdest = dest;
}

static void arg_cat_option(char* dest, size_t ndest, const char* shortopts, const char* longopts, const char* datatype, int optvalue) {
    if (shortopts) {
        char option[3];

        /* note: option array[] is initialiazed dynamically here to satisfy   */
        /* a deficiency in the watcom compiler wrt static array initializers. */
        option[0] = '-';
        option[1] = shortopts[0];
        option[2] = 0;

        arg_cat(&dest, option, &ndest);
        if (datatype) {
            arg_cat(&dest, " ", &ndest);
            if (optvalue) {
                arg_cat(&dest, "[", &ndest);
                arg_cat(&dest, datatype, &ndest);
                arg_cat(&dest, "]", &ndest);
            } else
                arg_cat(&dest, datatype, &ndest);
        }
    } else if (longopts) {
        size_t ncspn;

        /* add "--" tag prefix */
        arg_cat(&dest, "--", &ndest);

        /* add comma separated option tag */
        ncspn = strcspn(longopts, ",");
#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
        strncat_s(dest, ndest, longopts, (ncspn < ndest) ? ncspn : ndest);
#else
        strncat(dest, longopts, (ncspn < ndest) ? ncspn : ndest);
#endif

        if (datatype) {
            arg_cat(&dest, "=", &ndest);
            if (optvalue) {
                arg_cat(&dest, "[", &ndest);
                arg_cat(&dest, datatype, &ndest);
                arg_cat(&dest, "]", &ndest);
            } else
                arg_cat(&dest, datatype, &ndest);
        }
    } else if (datatype) {
        if (optvalue) {
            arg_cat(&dest, "[", &ndest);
            arg_cat(&dest, datatype, &ndest);
            arg_cat(&dest, "]", &ndest);
        } else
            arg_cat(&dest, datatype, &ndest);
    }
}

static void
arg_cat_optionv(char* dest, size_t ndest, const char* shortopts, const char* longopts, const char* datatype, int optvalue, const char* separator) {
    separator = separator ? separator : "";

    if (shortopts) {
        const char* c = shortopts;
        while (*c) {
            /* "-a|-b|-c" */
            char shortopt[3];

            /* note: shortopt array[] is initialiazed dynamically here to satisfy */
            /* a deficiency in the watcom compiler wrt static array initializers. */
            shortopt[0] = '-';
            shortopt[1] = *c;
            shortopt[2] = 0;

            arg_cat(&dest, shortopt, &ndest);
            if (*++c)
                arg_cat(&dest, separator, &ndest);
        }
    }

    /* put separator between long opts and short opts */
    if (shortopts && longopts)
        arg_cat(&dest, separator, &ndest);

    if (longopts) {
        const char* c = longopts;
        while (*c) {
            size_t ncspn;

            /* add "--" tag prefix */
            arg_cat(&dest, "--", &ndest);

            /* add comma separated option tag */
            ncspn = strcspn(c, ",");
#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
            strncat_s(dest, ndest, c, (ncspn < ndest) ? ncspn : ndest);
#else
            strncat(dest, c, (ncspn < ndest) ? ncspn : ndest);
#endif
            c += ncspn;

            /* add given separator in place of comma */
            if (*c == ',') {
                arg_cat(&dest, separator, &ndest);
                c++;
            }
        }
    }

    if (datatype) {
        if (longopts)
            arg_cat(&dest, "=", &ndest);
        else if (shortopts)
            arg_cat(&dest, " ", &ndest);

        if (optvalue) {
            arg_cat(&dest, "[", &ndest);
            arg_cat(&dest, datatype, &ndest);
            arg_cat(&dest, "]", &ndest);
        } else
            arg_cat(&dest, datatype, &ndest);
    }
}

void arg_print_option_ds(arg_dstr_t ds, const char* shortopts, const char* longopts, const char* datatype, const char* suffix) {
    char syntax[200] = "";
    suffix = suffix ? suffix : "";

    /* there is no way of passing the proper optvalue for optional argument values here, so we must ignore it */
    arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, 0, "|");

    arg_dstr_cat(ds, syntax);
    arg_dstr_cat(ds, (char*)suffix);
}

/* this function should be deprecated because it doesn't consider optional argument values (ARG_HASOPTVALUE) */
void arg_print_option(FILE* fp, const char* shortopts, const char* longopts, const char* datatype, const char* suffix) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_option_ds(ds, shortopts, longopts, datatype, suffix);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}

/*
 * Print a GNU style [OPTION] string in which all short options that
 * do not take argument values are presented in abbreviated form, as
 * in: -xvfsd, or -xvf[sd], or [-xvsfd]
 */
static void arg_print_gnuswitch_ds(arg_dstr_t ds, struct arg_hdr** table) {
    int tabindex;
    char* format1 = " -%c";
    char* format2 = " [-%c";
    char* suffix = "";

    /* print all mandatory switches that are without argument values */
    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        /* skip optional options */
        if (table[tabindex]->mincount < 1)
            continue;

        /* skip non-short options */
        if (table[tabindex]->shortopts == NULL)
            continue;

        /* skip options that take argument values */
        if (table[tabindex]->flag & ARG_HASVALUE)
            continue;

        /* print the short option (only the first short option char, ignore multiple choices)*/
        arg_dstr_catf(ds, format1, table[tabindex]->shortopts[0]);
        format1 = "%c";
        format2 = "[%c";
    }

    /* print all optional switches that are without argument values */
    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        /* skip mandatory args */
        if (table[tabindex]->mincount > 0)
            continue;

        /* skip args without short options */
        if (table[tabindex]->shortopts == NULL)
            continue;

        /* skip args with values */
        if (table[tabindex]->flag & ARG_HASVALUE)
            continue;

        /* print first short option */
        arg_dstr_catf(ds, format2, table[tabindex]->shortopts[0]);
        format2 = "%c";
        suffix = "]";
    }

    arg_dstr_catf(ds, "%s", suffix);
}

void arg_print_syntax_ds(arg_dstr_t ds, void** argtable, const char* suffix) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int i, tabindex;

    /* print GNU style [OPTION] string */
    arg_print_gnuswitch_ds(ds, table);

    /* print remaining options in abbreviated style */
    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        char syntax[200] = "";
        const char *shortopts, *longopts, *datatype;

        /* skip short options without arg values (they were printed by arg_print_gnu_switch) */
        if (table[tabindex]->shortopts && !(table[tabindex]->flag & ARG_HASVALUE))
            continue;

        shortopts = table[tabindex]->shortopts;
        longopts = table[tabindex]->longopts;
        datatype = table[tabindex]->datatype;
        arg_cat_option(syntax, sizeof(syntax), shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE);

        if (strlen(syntax) > 0) {
            /* print mandatory instances of this option */
            for (i = 0; i < table[tabindex]->mincount; i++) {
                arg_dstr_cat(ds, " ");
                arg_dstr_cat(ds, syntax);
            }

            /* print optional instances enclosed in "[..]" */
            switch (table[tabindex]->maxcount - table[tabindex]->mincount) {
                case 0:
                    break;
                case 1:
                    arg_dstr_cat(ds, " [");
                    arg_dstr_cat(ds, syntax);
                    arg_dstr_cat(ds, "]");
                    break;
                case 2:
                    arg_dstr_cat(ds, " [");
                    arg_dstr_cat(ds, syntax);
                    arg_dstr_cat(ds, "]");
                    arg_dstr_cat(ds, " [");
                    arg_dstr_cat(ds, syntax);
                    arg_dstr_cat(ds, "]");
                    break;
                default:
                    arg_dstr_cat(ds, " [");
                    arg_dstr_cat(ds, syntax);
                    arg_dstr_cat(ds, "]...");
                    break;
            }
        }
    }

    if (suffix) {
        arg_dstr_cat(ds, (char*)suffix);
    }
}

void arg_print_syntax(FILE* fp, void** argtable, const char* suffix) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_syntax_ds(ds, argtable, suffix);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}

void arg_print_syntaxv_ds(arg_dstr_t ds, void** argtable, const char* suffix) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int i, tabindex;

    /* print remaining options in abbreviated style */
    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        char syntax[200] = "";
        const char *shortopts, *longopts, *datatype;

        shortopts = table[tabindex]->shortopts;
        longopts = table[tabindex]->longopts;
        datatype = table[tabindex]->datatype;
        arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, "|");

        /* print mandatory options */
        for (i = 0; i < table[tabindex]->mincount; i++) {
            arg_dstr_cat(ds, " ");
            arg_dstr_cat(ds, syntax);
        }

        /* print optional args enclosed in "[..]" */
        switch (table[tabindex]->maxcount - table[tabindex]->mincount) {
            case 0:
                break;
            case 1:
                arg_dstr_cat(ds, " [");
                arg_dstr_cat(ds, syntax);
                arg_dstr_cat(ds, "]");
                break;
            case 2:
                arg_dstr_cat(ds, " [");
                arg_dstr_cat(ds, syntax);
                arg_dstr_cat(ds, "]");
                arg_dstr_cat(ds, " [");
                arg_dstr_cat(ds, syntax);
                arg_dstr_cat(ds, "]");
                break;
            default:
                arg_dstr_cat(ds, " [");
                arg_dstr_cat(ds, syntax);
                arg_dstr_cat(ds, "]...");
                break;
        }
    }

    if (suffix) {
        arg_dstr_cat(ds, (char*)suffix);
    }
}

void arg_print_syntaxv(FILE* fp, void** argtable, const char* suffix) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_syntaxv_ds(ds, argtable, suffix);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}

void arg_print_glossary_ds(arg_dstr_t ds, void** argtable, const char* format) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int tabindex;

    format = format ? format : "  %-20s %s\n";
    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        if (table[tabindex]->glossary) {
            char syntax[200] = "";
            const char* shortopts = table[tabindex]->shortopts;
            const char* longopts = table[tabindex]->longopts;
            const char* datatype = table[tabindex]->datatype;
            const char* glossary = table[tabindex]->glossary;
            arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, ", ");
            arg_dstr_catf(ds, format, syntax, glossary);
        }
    }
}

void arg_print_glossary(FILE* fp, void** argtable, const char* format) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_glossary_ds(ds, argtable, format);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}

/**
 * Print a piece of text formatted, which means in a column with a
 * left and a right margin. The lines are wrapped at whitspaces next
 * to right margin. The function does not indent the first line, but
 * only the following ones.
 *
 * Example:
 * arg_print_formatted( fp, 0, 5, "Some text that doesn't fit." )
 * will result in the following output:
 *
 * Some
 * text
 * that
 * doesn'
 * t fit.
 *
 * Too long lines will be wrapped in the middle of a word.
 *
 * arg_print_formatted( fp, 2, 7, "Some text that doesn't fit." )
 * will result in the following output:
 *
 * Some
 *   text
 *   that
 *   doesn'
 *   t fit.
 *
 * As you see, the first line is not indented. This enables output of
 * lines, which start in a line where output already happened.
 *
 * Author: Uli Fouquet
 */
static void arg_print_formatted_ds(arg_dstr_t ds, const unsigned lmargin, const unsigned rmargin, const char* text) {
    assert(strlen(text) < UINT_MAX);

    const unsigned int textlen = (unsigned int)strlen(text);
    unsigned int line_start = 0;
    unsigned int line_end = textlen + 1;
    const unsigned int colwidth = (rmargin - lmargin) + 1;

    /* Someone doesn't like us... */
    if (line_end < line_start) {
        arg_dstr_catf(ds, "%s\n", text);
    }

    while (line_end - 1 > line_start) {
        /* Eat leading white spaces. This is essential because while
           wrapping lines, there will often be a whitespace at beginning
           of line */
        while (isspace(*(text + line_start))) {
            line_start++;
        }

        if ((line_end - line_start) > colwidth) {
            line_end = line_start + colwidth;
        }

        /* Find last whitespace, that fits into line */
        while ((line_end > line_start) && (line_end - line_start > colwidth) && !isspace(*(text + line_end))) {
            line_end--;
        }

        /* Do not print trailing whitespace. If this text
           has got only one line, line_end now points to the
           last char due to initialization. */
        line_end--;

        /* Output line of text */
        while (line_start < line_end) {
            char c = *(text + line_start);
            arg_dstr_cat(ds, &c);
            line_start++;
        }
        arg_dstr_cat(ds, "\n");

        /* Initialize another line */
        if (line_end + 1 < textlen) {
            unsigned i;

            for (i = 0; i < lmargin; i++) {
                arg_dstr_cat(ds, " ");
            }

            line_end = textlen;
        }

        /* If we have to print another line, get also the last char. */
        line_end++;

    } /* lines of text */
}

/**
 * Prints the glossary in strict GNU format.
 * Differences to arg_print_glossary() are:
 *   - wraps lines after 80 chars
 *   - indents lines without shortops
 *   - does not accept formatstrings
 *
 * Contributed by Uli Fouquet
 */
void arg_print_glossary_gnu_ds(arg_dstr_t ds, void** argtable) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int tabindex;

    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {
        if (table[tabindex]->glossary) {
            char syntax[200] = "";
            const char* shortopts = table[tabindex]->shortopts;
            const char* longopts = table[tabindex]->longopts;
            const char* datatype = table[tabindex]->datatype;
            const char* glossary = table[tabindex]->glossary;

            if (!shortopts && longopts) {
                /* Indent trailing line by 4 spaces... */
                memset(syntax, ' ', 4);
                *(syntax + 4) = '\0';
            }

            arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, ", ");

            /* If syntax fits not into column, print glossary in new line... */
            if (strlen(syntax) > 25) {
                arg_dstr_catf(ds, "  %-25s %s\n", syntax, "");
                *syntax = '\0';
            }

            arg_dstr_catf(ds, "  %-25s ", syntax);
            arg_print_formatted_ds(ds, 28, 79, glossary);
        }
    } /* for each table entry */

    arg_dstr_cat(ds, "\n");
}

void arg_print_glossary_gnu(FILE* fp, void** argtable) {
    arg_dstr_t ds = arg_dstr_create();
    arg_print_glossary_gnu_ds(ds, argtable);
    fputs(arg_dstr_cstr(ds), fp);
    arg_dstr_destroy(ds);
}

/**
 * Checks the argtable[] array for NULL entries and returns 1
 * if any are found, zero otherwise.
 */
int arg_nullcheck(void** argtable) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int tabindex;
    /*printf("arg_nullcheck(%p)\n",argtable);*/

    if (!table)
        return 1;

    tabindex = 0;
    do {
        /*printf("argtable[%d]=%p\n",tabindex,argtable[tabindex]);*/
        if (!table[tabindex])
            return 1;
    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));

    return 0;
}

/*
 * arg_free() is deprecated in favour of arg_freetable() due to a flaw in its design.
 * The flaw results in memory leak in the (very rare) case that an intermediate
 * entry in the argtable array failed its memory allocation while others following
 * that entry were still allocated ok. Those subsequent allocations will not be
 * deallocated by arg_free().
 * Despite the unlikeliness of the problem occurring, and the even unlikelier event
 * that it has any deliterious effect, it is fixed regardless by replacing arg_free()
 * with the newer arg_freetable() function.
 * We still keep arg_free() for backwards compatibility.
 */
void arg_free(void** argtable) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    int tabindex = 0;
    int flag;
    /*printf("arg_free(%p)\n",argtable);*/
    do {
        /*
           if we encounter a NULL entry then somewhat incorrectly we presume
           we have come to the end of the array. It isnt strictly true because
           an intermediate entry could be NULL with other non-NULL entries to follow.
           The subsequent argtable entries would then not be freed as they should.
         */
        if (table[tabindex] == NULL)
            break;

        flag = table[tabindex]->flag;
        xfree(table[tabindex]);
        table[tabindex++] = NULL;

    } while (!(flag & ARG_TERMINATOR));
}

/* frees each non-NULL element of argtable[], where n is the size of the number of entries in the array */
void arg_freetable(void** argtable, size_t n) {
    struct arg_hdr** table = (struct arg_hdr**)argtable;
    size_t tabindex = 0;
    /*printf("arg_freetable(%p)\n",argtable);*/
    for (tabindex = 0; tabindex < n; tabindex++) {
        if (table[tabindex] == NULL)
            continue;

        xfree(table[tabindex]);
        table[tabindex] = NULL;
    };
}

#ifdef _WIN32
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    return TRUE;
    UNREFERENCED_PARAMETER(hinstDLL);
    UNREFERENCED_PARAMETER(lpvReserved);
}
#endif

```

`resources/elf_structure.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   version="1.0"
   width="739.51001"
   height="820"
   id="svg2"
   sodipodi:docname="Elf-layout--en.svg"
   inkscape:version="0.92.2 (5c3e80d, 2017-08-06)">
  <metadata
     id="metadata4562">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1600"
     inkscape:window-height="837"
     id="namedview4560"
     showgrid="false"
     inkscape:zoom="0.8"
     inkscape:cx="155.38"
     inkscape:cy="410"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg2" />
  <defs
     id="defs4">
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Lend"
       style="overflow:visible">
      <path
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.97309,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z"
         transform="matrix(-1.1,0,0,-1.1,-1.1,0)"
         id="path4726"
         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow1Mend"
       style="overflow:visible">
      <path
         d="M 0,0 L 5,-5 L -12.5,0 L 5,5 L 0,0 z"
         transform="matrix(-0.4,0,0,-0.4,-4,0)"
         id="path4738"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Mend"
       style="overflow:visible">
      <path
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.97309,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z"
         transform="scale(-0.6,-0.6)"
         id="path4720"
         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="TriangleOutL"
       style="overflow:visible">
      <path
         d="M 5.77,0 L -2.88,5 L -2.88,-5 L 5.77,0 z"
         transform="scale(0.8,0.8)"
         id="path4649"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
    <linearGradient
       id="linearGradient3133">
      <stop
         id="stop3135"
         style="stop-color:#0000ff;stop-opacity:1"
         offset="0" />
      <stop
         id="stop3137"
         style="stop-color:#0000ff;stop-opacity:0"
         offset="1" />
    </linearGradient>
  </defs>
  <g
     transform="translate(-12.939504,-98.096169)"
     id="layer1">
    <g
       transform="translate(0,18)"
       id="g2640">
      <g
         id="g5175">
        <path
           d="M 613.625,724.53125 C 612.5981,724.53125 611.76562,725.36372 611.76562,726.39062 C 611.76562,727.41753 612.5981,728.25 613.625,728.25 C 622.90001,728.23499 630.70258,730.13353 636.03125,733.65625 C 641.35992,737.17897 644.3526,742.14212 644.34375,749.0625 C 644.32605,762.90325 631.26999,784.90482 596.375,813.5 C 595.79567,813.89505 595.48945,814.58364 595.58412,815.27842 C 595.6788,815.9732 596.15811,816.55476 596.82201,816.78039 C 597.48592,817.00603 598.22033,816.83696 598.71875,816.34375 C 633.97316,787.45405 648.0107,765.16483 648.03125,749.09375 C 648.04152,741.05821 644.28029,734.65235 638.09375,730.5625 C 631.90721,726.47265 623.40389,724.51543 613.625,724.53125 z"
           id="path3581"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 596.55809,726.41912 L 622.13811,711.57772 L 622.18601,741.17768 L 596.55809,726.41912 z"
           id="path5181"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5167">
        <path
           d="M 615.53125,537.40625 C 614.84881,537.41915 614.22891,537.80672 613.91846,538.4146 C 613.60802,539.02248 613.65747,539.7519 614.04712,540.31231 C 614.43677,540.87272 615.10332,541.17308 615.78125,541.09375 C 624.30518,540.5271 641.5447,547.01808 658.4375,560.09375 C 675.3303,573.16942 692.0983,592.67701 700.9375,617.71875 C 709.7767,642.76049 710.77667,673.3453 696.03125,708.90625 C 681.28583,744.4672 650.73563,785.00468 596.375,829.59375 C 595.58109,830.24096 595.46217,831.40922 596.10937,832.20313 C 596.75658,832.99703 597.92484,833.11596 598.71875,832.46875 C 653.4037,787.61366 684.38073,746.62431 699.4375,710.3125 C 714.49427,674.00069 713.56383,642.35519 704.4375,616.5 C 695.31117,590.64481 678.08354,570.59726 660.71875,557.15625 C 643.35396,543.71524 626.08129,536.7049 615.53125,537.40625 z"
           id="path3583"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 598.60784,540.39306 L 623.17375,523.9273 L 625.13716,553.46211 L 598.60784,540.39306 z"
           id="path5173"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5159">
        <path
           d="M 615.5,404.59375 C 614.4731,404.61964 613.66161,405.4731 613.6875,406.5 C 613.71339,407.5269 614.56685,408.33839 615.59375,408.3125 C 631.60747,408.78571 657.29883,423.17914 681.5625,448.0625 C 705.82617,472.94586 728.83428,508.15304 740.59375,549.8125 C 764.11269,633.13141 743.02185,742.29203 596.4375,847.625 C 595.85893,847.99334 595.53159,848.65152 595.58697,849.33515 C 595.64236,850.01878 596.07138,850.61568 596.7017,850.88608 C 597.33203,851.15647 598.06021,851.05599 598.59375,850.625 C 746.02889,744.68067 768.06415,633.50935 744.15625,548.8125 C 732.2023,506.46408 708.88382,470.76376 684.21875,445.46875 C 659.55368,420.17374 633.72034,405.12662 615.6875,404.59375 C 615.62504,404.59058 615.56246,404.59058 615.5,404.59375 L 615.5,404.59375 z"
           id="path3585"
           style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-opacity:1" />
        <path
           d="M 598.56551,405.95282 L 624.59549,391.91555 L 623.72119,421.50263 L 598.56551,405.95282 z"
           id="path5165"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
    </g>
    <g
       transform="translate(0,18)"
       id="g2592">
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="98.596169"
         id="rect2160"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="203.99149"
         id="rect3149"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.62759"
         height="100.60824"
         x="162.03151"
         y="777.1507"
         id="rect3151"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.36804"
         height="159.70755"
         x="162.16129"
         y="309.5166"
         id="rect3153"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.25955236px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.51022"
         height="125.64294"
         x="162.09019"
         y="474.19971"
         id="rect3155"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.11736131px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <rect
         width="434.57434"
         height="111.62189"
         x="162.05814"
         y="660.71509"
         id="rect3157"
         style="font-size:36px;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.0532496px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <text
         x="378.45837"
         y="638.71503"
         id="text5129"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="378.45837"
           y="638.71503"
           id="tspan5131">...</tspan></text>
      <text
         x="376.1044"
         y="727.50885"
         id="text5133"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.1044"
           y="727.50885"
           id="tspan5135">.data</tspan></text>
      <text
         x="376.1044"
         y="548.00397"
         id="text5137"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.1044"
           y="548.00397"
           id="tspan5139">.rodata</tspan></text>
      <text
         x="374.76651"
         y="402.67029"
         id="text5141"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="374.76651"
           y="402.67029"
           id="tspan5143">.text</tspan></text>
      <text
         x="390.97278"
         y="259.24197"
         id="text5145"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="390.97278"
           y="259.24197"
           id="tspan5147">Program header table</tspan></text>
      <text
         x="374.47354"
         y="159.88318"
         id="text5149"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="374.47354"
           y="159.88318"
           id="tspan5151">ELF header</tspan></text>
      <text
         x="376.16299"
         y="842.33545"
         id="text5153"
         xml:space="preserve"
         style="font-size:36px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;writing-mode:lr-tb;text-anchor:middle;font-family:Bitstream Vera Sans"><tspan
           x="376.16299"
           y="842.33545"
           id="tspan5155">Section header table</tspan></text>
    </g>
    <g
       transform="translate(0,9.9513409)"
       id="g2628"
       style="font-size:40px">
      <g
         id="g5191">
        <path
           d="M 158.59375,240.46875 C 158.17657,240.49346 157.78005,240.65868 157.46875,240.9375 C 12.232118,366.00238 -1.236628,475.64394 22.09375,553.75 C 45.424128,631.85606 105.21875,678.4375 105.21875,678.4375 C 106.02992,679.06745 107.19818,678.92054 107.82813,678.10938 C 108.45807,677.29821 108.31117,676.12995 107.5,675.5 C 107.5,675.5 48.605655,629.51813 25.65625,552.6875 C 2.7068448,475.85687 15.391155,368.19356 159.90625,243.75 C 160.53574,243.2394 160.7596,242.37851 160.45857,241.62595 C 160.15754,240.87338 159.40173,240.40437 158.59375,240.46875 L 158.59375,240.46875 z"
           id="path4760"
           style="font-size:40px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 119.83906,687.47222 L 90.54692,683.40096 L 108.74694,660.05745 L 119.83906,687.47222 z"
           id="path5197"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
      <g
         id="g5183">
        <path
           d="M 160.1875,264.53125 C 159.83976,264.58497 159.51454,264.73674 159.25,264.96875 C 73.516681,335.57267 56.303827,382.38545 61.25,412.0625 C 66.196173,441.73955 93.28125,453.21875 93.28125,453.21875 C 93.895652,453.50878 94.619589,453.43873 95.166989,453.03629 C 95.714388,452.63384 95.997179,451.96375 95.903612,451.29081 C 95.810045,450.61787 95.355176,450.05034 94.71875,449.8125 C 94.71875,449.8125 69.517857,439.1384 64.90625,411.46875 C 60.294643,383.7991 76.293073,338.06012 161.59375,267.8125 C 162.24704,267.29362 162.47225,266.40171 162.14361,265.63488 C 161.81497,264.86806 161.01379,264.41603 160.1875,264.53125 z"
           id="path4764"
           style="font-size:40px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3.70000005;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:3.70000005;stroke-dasharray:none;stroke-opacity:1" />
        <path
           d="M 109.73853,458.16544 L 80.39141,461.81941 L 91.924754,434.55878 L 109.73853,458.16544 z"
           id="path5189"
           style="fill-rule:evenodd;stroke:#000000;stroke-width:0.8pt;marker-start:none" />
      </g>
    </g>
  </g>
  <text
     xml:space="preserve"
     style="font-style:normal;font-weight:normal;font-size:40px;line-height:1;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none"
     x="143.91016"
     y="292"
     id="text9601"><tspan
       sodipodi:role="line"
       x="143.91016"
       y="292"
       id="tspan9633"
       style="font-size:46.66666667px;line-height:100%">⎧</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="340"
       id="tspan9677"
       style="font-size:46.66666667px;line-height:100%">⎪</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="388"
       id="tspan9679"
       style="font-size:46.66666667px;line-height:100%">⎨</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="436"
       id="tspan9681"
       style="font-size:46.66666667px;line-height:100%">⎪</tspan><tspan
       sodipodi:role="line"
       x="143.91016"
       y="484"
       id="tspan9683"
       style="font-size:46.66666667px;line-height:100%">⎩</tspan></text>
  <text
     xml:space="preserve"
     style="font-style:normal;font-weight:normal;font-size:40px;line-height:1;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none"
     x="144.75"
     y="559.87891"
     id="text9601-2"><tspan
       sodipodi:role="line"
       x="144.75"
       y="559.87891"
       id="tspan9677-4"
       style="font-size:46.66666794px;line-height:100%">⎧</tspan><tspan
       sodipodi:role="line"
       x="144.75"
       y="606.54559"
       id="tspan9681-9"
       style="font-size:46.66666794px;line-height:100%">⎨</tspan><tspan
       sodipodi:role="line"
       x="144.75"
       y="653.21222"
       id="tspan9683-5"
       style="font-size:46.66666794px;line-height:100%">⎩</tspan></text>
</svg>

```

`src/ELF/elf_allocation.c`:

```c
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_allocation.h"
#include "elf_deallocation.h"
#include "file_functions.h"
#include "packer_config.h"

#include "log.h"

int allocate_elf_elf_header(t_elf *elf, void *file_data, size_t file_data_size) {
    // http://www.openvirtualization.org/documentation/structElf64__Ehdr.html

    if(elf->s_type == ELF32) {
        if (file_data_size < sizeof(Elf32_Ehdr)) {
            log_error("Total file size is less than ELF Header size");
            return -1;
        }

        ((t_elf32 *)elf)->elf_header = malloc(sizeof(Elf32_Ehdr));
        if (((t_elf32 *)elf)->elf_header == NULL) {
            deallocate_elf_elf_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf32 *)elf)->elf_header, file_data, sizeof(Elf32_Ehdr));

        // https://code.woboq.org/userspace/glibc/elf/elf.h.html
        // "\177ELF"
        if (strncmp((char *) ((t_elf32 *)elf)->elf_header->e_ident, ELFMAG, SELFMAG) != 0) {
            deallocate_elf_elf_header(elf);
            log_error("Magic bytes does not match ELF bytes");
            return -1;
        }

        if (((t_elf32 *)elf)->elf_header->e_machine != EM_386) {
            deallocate_elf_elf_header(elf);
            log_error("File is not a x32 executable");
            return -1;
        }
    }
    else {
        if (file_data_size < sizeof(Elf64_Ehdr)) {
            log_error("Total file size is less than ELF Header size");
            return -1;
        }

        ((t_elf64 *)elf)->elf_header = malloc(sizeof(Elf64_Ehdr));
        if (((t_elf64 *)elf)->elf_header == NULL) {
            deallocate_elf_elf_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf64 *)elf)->elf_header, file_data, sizeof(Elf64_Ehdr));

        // https://code.woboq.org/userspace/glibc/elf/elf.h.html
        // "\177ELF"
        if (strncmp((char *) ((t_elf64 *)elf)->elf_header->e_ident, ELFMAG, SELFMAG) != 0) {
            deallocate_elf_elf_header(elf);
            log_error("Magic bytes does not match ELF bytes");
            return -1;
        }

        if (((t_elf64 *)elf)->elf_header->e_machine != EM_X86_64) {
            deallocate_elf_elf_header(elf);
            log_error("File is not a x64 executable");
            return -1;
        }
    }

    return 1;
}

int allocate_elf_program_header(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        size_t elf_program_header_size = sizeof(Elf32_Phdr) * ((t_elf32 *)elf)->elf_header->e_phnum;
        if (file_data_size < sizeof(Elf32_Ehdr) + elf_program_header_size) {
            log_error("Total file size is inferior to ELF Header + Program Header size");
            return -1;
        }

        ((t_elf32 *)elf)->prog_header = malloc(elf_program_header_size);
        if (((t_elf32 *)elf)->prog_header == NULL) {
            deallocate_elf_program_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf32 *)elf)->prog_header, file_data + ((t_elf32 *)elf)->elf_header->e_phoff, elf_program_header_size);
    }
    else {
        size_t elf_program_header_size = sizeof(Elf64_Phdr) * ((t_elf64 *)elf)->elf_header->e_phnum;
        if (file_data_size < sizeof(Elf64_Ehdr) + elf_program_header_size) {
            log_error("Total file size is inferior to ELF Header + Program Header size");
            return -1;
        }

        ((t_elf64 *)elf)->prog_header = malloc(elf_program_header_size);
        if (((t_elf64 *)elf)->prog_header == NULL) {
            deallocate_elf_program_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_elf64 *)elf)->prog_header, file_data + ((t_elf64 *)elf)->elf_header->e_phoff, elf_program_header_size);
    }

    return 1;
}

int allocate_elf_sections_header(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        size_t elf_sections_header_size = sizeof(Elf32_Shdr) * ((t_elf32 *)elf)->elf_header->e_shnum;

        ((t_elf32 *)elf)->section_header = malloc(elf_sections_header_size);
        if (((t_elf32 *)elf)->section_header == NULL) {
            deallocate_elf_sections_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf32 *)elf)->section_header, 0, elf_sections_header_size);

        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (file_data_size < ((t_elf32 *)elf)->elf_header->e_shoff + (i * sizeof(Elf32_Shdr))) {
                deallocate_elf_sections_header(elf);
                log_error("Total file size is inferior to ELF section header size");
                return -1;
            }
            memcpy(&(((t_elf32 *)elf)->section_header[i]), file_data + ((t_elf32 *)elf)->elf_header->e_shoff + (i * sizeof(Elf32_Shdr)),
                   sizeof(Elf32_Shdr));
        }
    }
    else {
        size_t elf_sections_header_size = sizeof(Elf64_Shdr) * ((t_elf64 *)elf)->elf_header->e_shnum;

        ((t_elf64 *)elf)->section_header = malloc(elf_sections_header_size);
        if (((t_elf64 *)elf)->section_header == NULL) {
            deallocate_elf_sections_header(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf64 *)elf)->section_header, 0, elf_sections_header_size);

        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (file_data_size < ((t_elf64 *)elf)->elf_header->e_shoff + (i * sizeof(Elf64_Shdr))) {
                deallocate_elf_sections_header(elf);
                log_error("Total file size is inferior to ELF section header size");
                return -1;
            }
            memcpy(&(((t_elf64 *)elf)->section_header[i]), file_data + ((t_elf64 *)elf)->elf_header->e_shoff + (i * sizeof(Elf64_Shdr)),
                   sizeof(Elf64_Shdr));
        }
    }

    return 1;
}

int allocate_elf_sections_data(t_elf *elf, void *file_data, size_t file_data_size) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->section_data = malloc(sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum);
        if (((t_elf32 *)elf)->section_data == NULL) {
            deallocate_elf_sections_data(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf32 *)elf)->section_data, 0, sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum);

        // TODO: Free all the malloc section_data_data up to i
        size_t elf_section_data_size;
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            // Section that occupies no space in file
            if (((t_elf32 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                ((t_elf32 *)elf)->section_data[i] = NULL;
            } else {
                if (file_data_size < ((t_elf32 *)elf)->section_header[i].sh_offset) {
                    log_error("Total file size is less than section data offset");
                    return -1;
                }

                elf_section_data_size = ((t_elf32 *)elf)->section_header[i].sh_size;

                ((t_elf32 *)elf)->section_data[i] = malloc(elf_section_data_size);
                if (((t_elf32 *)elf)->section_data[i] == NULL) {
                    free(((t_elf32 *)elf)->section_data[i]);
                    log_error("malloc() failure");
                    return -1;
                }
                memset(((t_elf32 *)elf)->section_data[i], 0, elf_section_data_size);
                memcpy(((t_elf32 *)elf)->section_data[i], file_data + ((t_elf32 *)elf)->section_header[i].sh_offset, elf_section_data_size);
            }
        }
    }
    else {
        ((t_elf64 *)elf)->section_data = malloc(sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum);
        if (((t_elf64 *)elf)->section_data == NULL) {
            deallocate_elf_sections_data(elf);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_elf64 *)elf)->section_data, 0, sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum);

        size_t elf_section_data_size;
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            // Section that occupies no space in file
            if (((t_elf64 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                ((t_elf64 *)elf)->section_data[i] = NULL;
            } else {
                if (file_data_size < ((t_elf64 *)elf)->section_header[i].sh_offset) {
                    log_error("Total file size is less than section data offset");
                    return -1;
                }

                elf_section_data_size = ((t_elf64 *)elf)->section_header[i].sh_size;

                ((t_elf64 *)elf)->section_data[i] = malloc(elf_section_data_size);
                if (((t_elf64 *)elf)->section_data[i] == NULL) {
                    free(((t_elf64 *)elf)->section_data[i]);
                    log_error("malloc() failure");
                    return -1;
                }
                memset(((t_elf64 *)elf)->section_data[i], 0, elf_section_data_size);
                memcpy(((t_elf64 *)elf)->section_data[i], file_data + ((t_elf64 *)elf)->section_header[i].sh_offset, elf_section_data_size);
            }
        }
    }

    return 1;
}

int allocate_elf(t_elf **elf, void *file_data, size_t file_data_size) {
    size_t t_elf_size;

    if(packer_config.arch == x32_ARCH)
        t_elf_size = sizeof(t_elf32);
    else
        t_elf_size = sizeof(t_elf64);

    *elf = malloc(t_elf_size);
    if(*elf == NULL) {
        deallocate_elf_struct(*elf);
        log_error("malloc() failure");
        return -1;
    }
    memset(*elf, 0, t_elf_size);

    t_elf type_pe;
    if(packer_config.arch == 32) {
        type_pe.s_type = ELF32;
        ((t_elf32 *)(*elf))->type_header = type_pe;
    }
    else {
        type_pe.s_type = ELF64;
        ((t_elf64 *)(*elf))->type_header = type_pe;
    }

    log_verbose("Allocating ELF Header ...");

    if(allocate_elf_elf_header(*elf, file_data, file_data_size) == -1) {
        log_error("Error during ELF Header allocation");
        return -1;
    }

    log_verbose("Allocating Program Header ...");

    if(allocate_elf_program_header(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        log_error("Error during Program Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Headers ...");

    if(allocate_elf_sections_header(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        deallocate_elf_program_header(*elf);
        log_error("Error during Section Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Data ...");

    if(allocate_elf_sections_data(*elf, file_data, file_data_size) == -1) {
        deallocate_elf_elf_header(*elf);
        deallocate_elf_program_header(*elf);
        deallocate_elf_sections_header(*elf);
        log_error("Error during Section Data allocation");
        return -1;
    }

    return 1;
}

```

`src/ELF/elf_code_cave.c`:

```c
//
// Created by silentvoid on 3/7/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_code_cave.h"
#include "elf_functions.h"
#include "elf_allocation.h"
#include "elf_packing_method.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

int find_elf_code_cave_index(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf32 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                continue;
            }
            unsigned int code_cave_size;

            // TODO: Maybe change that since it's relying on the fact that the section header is located after the section data (may not always be the case)
            if (i == ((t_elf32 *)elf)->elf_header->e_shnum - 1) {
                code_cave_size =
                        ((t_elf32 *)elf)->elf_header->e_shoff - (((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size);
            } else {
                code_cave_size = ((t_elf32 *)elf)->section_header[i + 1].sh_offset -
                                 (((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size);
            }

            if (code_cave_size > packer_config.loader_size) {
                int segment_index = find_elf_segment_index_of_section(elf, i);
                if (((t_elf32 *)elf)->prog_header[segment_index].p_type == PT_LOAD) {
                    log_verbose("Code Cave size : %d", code_cave_size);
                    return i;
                }
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf64 *)elf)->section_header[i].sh_type == SHT_NOBITS) {
                continue;
            }
            unsigned int code_cave_size;

            // TODO: Maybe change that since it's relying on the fact that the section header is located after the section data (may not always be the case)
            if (i == ((t_elf64 *)elf)->elf_header->e_shnum - 1) {
                code_cave_size =
                        ((t_elf64 *)elf)->elf_header->e_shoff - (((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size);
            } else {
                code_cave_size = ((t_elf64 *)elf)->section_header[i + 1].sh_offset -
                                 (((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size);
            }

            if (code_cave_size > packer_config.loader_size) {
                int segment_index = find_elf_segment_index_of_section(elf, i);
                if (((t_elf64 *)elf)->prog_header[segment_index].p_type == PT_LOAD) {
                    log_verbose("Code Cave size : %d", code_cave_size);
                    return i;
                }
            }
        }
    }

    return -1;
}

int set_new_elf_cave_segment_values(t_elf *elf, int segment_index) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->prog_header[segment_index].p_memsz += packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_filesz += packer_config.loader_size;
    }
    else {
        ((t_elf64 *)elf)->prog_header[segment_index].p_memsz += packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_filesz += packer_config.loader_size;
    }

    add_elf_segment_permission(elf, segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)
    add_elf_segment_permission(elf, segment_index, PF_X); // NOLINT(hicpp-signed-bitwise)

    int text_segment_index = find_elf_text_segment(elf);
    if(text_segment_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }
    add_elf_segment_permission(elf, text_segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)

    return 1;
}

int elf_cave_insert_loader(t_elf *elf, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;

    if(elf->s_type == ELF32) {
        new_section_data = realloc(((t_elf32 *)elf)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf32 *)elf)->section_data[section_index] = new_section_data;
        // For ASM
        loader_offset32 = ((t_elf32 *)elf)->section_header[section_index].sh_addr + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        new_section_data = realloc(((t_elf64 *)elf)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf64 *)elf)->section_data[section_index] = new_section_data;
        // For ASM
        loader_offset64 = ((t_elf64 *)elf)->section_header[section_index].sh_addr + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int elf_code_cave_injection(t_elf *elf) {

    log_verbose("Finding the code cave ...");

    int section_cave_index = find_elf_code_cave_index(elf);
    if(section_cave_index == -1) {
        log_error("Couldn't find any code cave in this ELF");
        return -1;
    }
    method_config.concerned_section = section_cave_index;

    int segment_index = find_elf_segment_index_of_section(elf, section_cave_index);
    if(segment_index == -1) {
        log_error("Couldn't find segment index");
        return -1;
    }

    log_verbose("Setting new segment values ...");

    if(set_new_elf_cave_segment_values(elf, segment_index) == -1) {
        log_error("Error during segment values modification");
        return -1;
    }

    log_verbose("Inserting the loader inside the code cave ...");

    int old_section_size;
    if(elf->s_type == ELF32)
        old_section_size = ((t_elf32 *)elf)->section_header[section_cave_index].sh_size;
    else
        old_section_size = ((t_elf64 *)elf)->section_header[section_cave_index].sh_size;

    if(elf_cave_insert_loader(elf, section_cave_index, old_section_size) == -1) {
        log_error("Error during Loader insertion");
        return -1;
    }

    log_verbose("Setting new ELF entry point ...");

    if(elf->s_type == ELF32) {
        Elf32_Addr loader_addr;
        loader_addr = ((t_elf32 *) elf)->section_header[section_cave_index].sh_addr + old_section_size;
        set_new_elf_entry_to_addr32(elf, loader_addr, section_cave_index, old_section_size);
    }
    else {
        Elf64_Addr loader_addr;
        loader_addr = ((t_elf64 *) elf)->section_header[section_cave_index].sh_addr + old_section_size;
        set_new_elf_entry_to_addr64(elf, loader_addr, section_cave_index, old_section_size);
    }

    return 1;
}

```

`src/ELF/elf_deallocation.c`:

```c
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_deallocation.h"
#include "elf_allocation.h"

void deallocate_elf_elf_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->elf_header);
    }
    else {
        free(((t_elf64 *)elf)->elf_header);
    }
}

void deallocate_elf_program_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->prog_header);
    }
    else {
        free(((t_elf64 *)elf)->prog_header);
    }
}

void deallocate_elf_sections_header(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->section_header);
    }
    else {
        free(((t_elf64 *)elf)->section_header);
    }
}


void deallocate_elf_sections_data_data(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            free(((t_elf32 *)elf)->section_data[i]);
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            free(((t_elf64 *)elf)->section_data[i]);
        }
    }
}

void deallocate_elf_sections_data(t_elf *elf) {
    if(elf->s_type == ELF32) {
        free(((t_elf32 *)elf)->section_data);
    }
    else {
        free(((t_elf64 *)elf)->section_data);
    }
}

void deallocate_elf_struct(t_elf *elf) {
    free(elf);
}

void deallocate_elf(t_elf *elf) {
    deallocate_elf_elf_header(elf);
    deallocate_elf_program_header(elf);
    deallocate_elf_sections_header(elf);
    deallocate_elf_sections_data_data(elf);
    deallocate_elf_sections_data(elf);
    deallocate_elf_struct(elf);
}


```

`src/ELF/elf_encryption.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_encryption.h"
#include "cipher_functions.h"
#include "elf_allocation.h"
#include "elf_functions.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "file_functions.h"
#include "aes_128_ecb_encryption.h"

#include "log.h"

int encrypt_elf(t_elf *elf) {
    int text_section_index = find_elf_section_index(elf, ".text");
    if(text_section_index == -1) {
        log_error("Couldn't find .text section in the ELF binary");
        return -1;
    }

    log_verbose("Got .text section index : %d", text_section_index);

    char *text_data;
    if(elf->s_type == ELF32) {
        text_data = ((t_elf32 *)elf)->section_data[text_section_index];

        // Setting global variables
        text_data_size32 = ((t_elf32 *)elf)->section_header[text_section_index].sh_size;
        text_entry_point32 = ((t_elf32 *)elf)->section_header[text_section_index].sh_addr;

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text32.dmp", text_data, text_data_size32);
        }

        log_verbose("Generating random key ...");

        if(strcmp(packer_config.cipher, "xor") == 0) {
            cipher_key32 = generate_random_key32();
            uint32_t temp_key = cipher_key32;
            log_info("Random key : %x", cipher_key32);
            xor_encrypt32(text_data, text_data_size32, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size32, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text32_encrypted.dmp", text_data, text_data_size32);
        }
    }
    else {
        text_data = ((t_elf64 *)elf)->section_data[text_section_index];

        // Setting global variables
        text_data_size64 = ((t_elf64 *)elf)->section_header[text_section_index].sh_size;
        text_entry_point64 = ((t_elf64 *)elf)->section_header[text_section_index].sh_addr;

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text64.dmp", text_data, text_data_size64);
        }

        log_verbose("Generating random key ...");

        if(strcmp(packer_config.cipher, "xor") == 0) {
            cipher_key64 = generate_random_key64();
            uint64_t temp_key = cipher_key64;
            log_info("Random key : %lx", cipher_key64);
            xor_encrypt64(text_data, text_data_size64, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size64, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text64_encrypted.dmp", text_data, text_data_size64);
        }
    }

    return 1;
}

```

`src/ELF/elf_functions.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_functions.h"
#include "elf_allocation.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

int set_new_elf_entry_to_section(t_elf *elf, int section_index) {
    if(elf->s_type == ELF32) {
        Elf32_Addr last_entry = ((t_elf32 *)elf)->elf_header->e_entry;
        ((t_elf32 *)elf)->elf_header->e_entry = ((t_elf32 *)elf)->section_header[section_index].sh_addr;
        int32_t jump = last_entry - (((t_elf32 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_elf32 *)elf)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        Elf64_Addr last_entry = ((t_elf64 *)elf)->elf_header->e_entry;
        ((t_elf64 *)elf)->elf_header->e_entry = ((t_elf64 *)elf)->section_header[section_index].sh_addr;
        int32_t jump = last_entry - (((t_elf64 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_elf64 *)elf)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int set_new_elf_entry_to_addr32(t_elf *elf, int32_t entry_address, int section_index, int section_size) {
    Elf32_Addr last_entry = ((t_elf32 *)elf)->elf_header->e_entry;
    ((t_elf32 *)elf)->elf_header->e_entry = entry_address;
    int32_t jump = last_entry - (((t_elf32 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

    memcpy(((t_elf32 *)elf)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);

    return 1;
}

int set_new_elf_entry_to_addr64(t_elf *elf, int64_t entry_address, int section_index, int section_size) {
    Elf64_Addr last_entry = ((t_elf64 *)elf)->elf_header->e_entry;
    ((t_elf64 *)elf)->elf_header->e_entry = entry_address;
    int32_t jump = last_entry - (((t_elf64 *)elf)->elf_header->e_entry + packer_config.loader_size - packer_config.loader_infos_size);

    memcpy(((t_elf64 *)elf)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);

    return 1;
}

int find_last_elf_segment_of_type(t_elf *elf, unsigned int p_type) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == p_type) {
                index = i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == p_type) {
                index = i;
            }
        }
    }

    return index;
}

// Find last section from specified segment index
int find_last_elf_section_from_segment(t_elf *elf, int segment_index) {
    int index = -1;

    if(elf->s_type == ELF32) {
        Elf32_Phdr *program_header = ((t_elf32 *)elf)->prog_header + segment_index;
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            Elf32_Shdr *section_header = ((t_elf32 *)elf)->section_header + i;

            if (section_header->sh_addr >= program_header->p_vaddr
                && section_header->sh_addr < program_header->p_vaddr + program_header->p_memsz
                    ) {
                index = i;
            }
        }
    }
    else {
        Elf64_Phdr *program_header = ((t_elf64 *)elf)->prog_header + segment_index;
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            Elf64_Shdr *section_header = ((t_elf64 *)elf)->section_header + i;

            if (section_header->sh_addr >= program_header->p_vaddr
                && section_header->sh_addr < program_header->p_vaddr + program_header->p_memsz
                    ) {
                index = i;
            }
        }
    }

    return index;
}

// Find the text segment based on the fact that the elf entry point is located at the start of the .text section
int find_elf_text_segment(t_elf *elf) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == PT_LOAD
                && ((t_elf32 *)elf)->elf_header->e_entry < (((t_elf32 *)elf)->prog_header[i].p_vaddr + ((t_elf32 *)elf)->prog_header[i].p_filesz)
                && ((t_elf32 *)elf)->elf_header->e_entry > ((t_elf32 *)elf)->prog_header[i].p_vaddr) {
                index = i;
                break;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == PT_LOAD
                && ((t_elf64 *)elf)->elf_header->e_entry < (((t_elf64 *)elf)->prog_header[i].p_vaddr + ((t_elf64 *)elf)->prog_header[i].p_filesz)
                && ((t_elf64 *)elf)->elf_header->e_entry > ((t_elf64 *)elf)->prog_header[i].p_vaddr) {
                index = i;
                break;
            }
        }
    }

    return index;
}

int find_elf_segment_index_of_section(t_elf *elf, int section_index) {
    int index = -1;

    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_offset <= ((t_elf32 *)elf)->section_header[section_index].sh_offset) {
                index = i;
            } else {
                if (index == -1)
                    index = 0;
                break;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_offset <= ((t_elf64 *)elf)->section_header[section_index].sh_offset) {
                index = i;
            } else {
                if (index == -1)
                    index = 0;
                break;
            }
        }
    }

    return index;
}

char* find_elf_section_name(t_elf *elf, int index) {
    // sh_name contains the index into the section string table of the section name string
    if(elf->s_type == ELF32) {
        int section_string_table_index = ((t_elf32 *)elf)->elf_header->e_shstrndx;
        return ((char *) (((t_elf32 *)elf)->section_data[section_string_table_index] + ((t_elf32 *)elf)->section_header[index].sh_name));
    }
    else {
        int section_string_table_index = ((t_elf64 *)elf)->elf_header->e_shstrndx;
        return ((char *) (((t_elf64 *)elf)->section_data[section_string_table_index] + ((t_elf64 *)elf)->section_header[index].sh_name));
    }
}

int find_elf_section_index(t_elf *elf, char *section_name) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            char *s_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, s_name) == 0) {
                return i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            char *s_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, s_name) == 0) {
                return i;
            }
        }
    }

    return -1;
}

void add_elf_segment_permission(t_elf *elf, int segment_index, int permission) {
    if(elf->s_type == ELF32)
        ((t_elf32 *)elf)->prog_header[segment_index].p_flags |= permission; // NOLINT(hicpp-signed-bitwise)
    else
        ((t_elf64 *)elf)->prog_header[segment_index].p_flags |= permission; // NOLINT(hicpp-signed-bitwise)
}

```

`src/ELF/elf_packing.c`:

```c
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_packing.h"
#include "elf_allocation.h"
#include "elf_deallocation.h"
#include "file_functions.h"
#include "elf_encryption.h"
#include "elf_writing.h"
#include "elf_packing_method.h"
#include "packer_config.h"

#include "log.h"

/*
 * Basic ELF structure
 *
 * -----------
 * ELF Header
 * -----------
 * Program header table
 * -----------
 * [section_data]
 * .text
 * .rodata
 * .shstrtab (string table section names)
 * [...]
 * -----------
 * Section header table containing multiple section headers
 * .text header
 * -----------
 *
*/

int pack_elf(char *file, char *file_data, size_t file_data_size, char *output) {
    log_verbose("Detected arch : x%d", packer_config.arch);
    log_info("Allocating ELF in memory ...");

    t_elf *elf = NULL;
    if(allocate_elf(&elf, file_data, file_data_size) == -1) {
        munmap(file_data, file_data_size);
        log_error("Error during ELF allocation");
        return -1;
    }

    // De-allocate mapped file as we don't need it anymore
    munmap(file_data, file_data_size);

    log_info("Encrypting .text section ...");
    if(encrypt_elf(elf) == -1) {
        deallocate_elf(elf);
        log_error("Error during ELF encryption");
        return -1;
    }

    log_info("Packing using specified method ...");
    if(elf_pack_using_method(elf) == -1) {
        deallocate_elf(elf);
        log_error("Error during ELF packing");
        return -1;
    }

    char *filename;
    if(output != NULL)
        filename = output;
    else
        filename = "packed.elf";

    log_info("Writing Packed ELF to file ...");
    if(write_elf(elf, filename) == -1) {
        deallocate_elf(elf);
        log_error("Error during new ELF writing");
        return -1;
    }

    log_success("File %s packed into %s !", file, filename);
    deallocate_elf(elf);

    return 1;
}

```

`src/ELF/elf_packing_method.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_packing_method.h"
#include "elf_allocation.h"
#include "packer_config.h"
#include "elf_packing.h"
#include "elf_section_insertion.h"
#include "elf_silvio_infection.h"
#include "elf_code_cave.h"

#include "log.h"

struct method_config method_config;

int elf_pack_using_method(t_elf *elf) {
    if(strcmp(packer_config.packing_method, "section_insertion") == 0) {
        method_config.method_type = SECTION_INSERTION_METHOD;
        if (elf_insert_section(elf) == -1) {
            log_error("Error during Section insertion");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "code_cave") == 0) {
        method_config.method_type = CODE_CAVE_METHOD;
        if(elf_code_cave_injection(elf) == -1) {
            log_error("Error during Code Cave Injection");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "silvio_infection") == 0) {
        method_config.method_type = SILVIO_INFECTION_METHOD;
        if(elf_silvio_infect(elf) == -1) {
            log_error("Error during Silvio infection");
            return -1;
        }
    }

    return 1;
}
```

`src/ELF/elf_section_insertion.c`:

```c
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_section_insertion.h"
#include "elf_packing_method.h"
#include "elf_functions.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "file_functions.h"
#include "all_elf_loaders_infos.h"

#include "log.h"


Elf64_Shdr new_section64 = {
        .sh_name = 0,
        .sh_type = SHT_PROGBITS,
        .sh_flags = SHF_EXECINSTR | SHF_ALLOC, // NOLINT(hicpp-signed-bitwise)
        .sh_addr = 0,
        .sh_offset = 0,
        .sh_size = 0,
        .sh_link = 0,
        .sh_info = 0,
        .sh_addralign = 16,
        .sh_entsize = 0,
};

Elf32_Shdr new_section32 = {
        .sh_name = 0,
        .sh_type = SHT_PROGBITS,
        .sh_flags = SHF_EXECINSTR | SHF_ALLOC, // NOLINT(hicpp-signed-bitwise)
        .sh_addr = 0,
        .sh_offset = 0,
        .sh_size = 0,
        .sh_link = 0,
        .sh_info = 0,
        .sh_addralign = 16,
        .sh_entsize = 0,
};

int set_new_elf_section_string_table(t_elf *elf) {
    char *new_string_table;

    char *section_name = ".dec";
    size_t section_name_length = strlen(section_name);

    if(elf->s_type == ELF32) {
        int section_string_table_index = ((t_elf32 *)elf)->elf_header->e_shstrndx;

        int old_size = ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size;

        size_t new_string_table_size = ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size + section_name_length + 1;
        new_string_table = realloc(((t_elf32 *)elf)->section_data[section_string_table_index], new_string_table_size);
        if (new_string_table == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        memcpy(new_string_table + old_size, section_name,section_name_length+1);

        // We set it to the end of the old section_string_table
        new_section32.sh_name = old_size;

        ((t_elf32 *)elf)->section_data[section_string_table_index] = new_string_table;
        ((t_elf32 *)elf)->section_header[section_string_table_index].sh_size = new_string_table_size;
    }
    else {
        int section_string_table_index = ((t_elf64 *)elf)->elf_header->e_shstrndx;

        int old_size = ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size;

        size_t new_string_table_size = ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size + section_name_length + 1;
        new_string_table = realloc(((t_elf64 *)elf)->section_data[section_string_table_index], new_string_table_size);
        if (new_string_table == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        memcpy(new_string_table + old_size, section_name,section_name_length+1);

        // We set it to the end of the old section_string_table
        new_section64.sh_name = old_size;

        ((t_elf64 *)elf)->section_data[section_string_table_index] = new_string_table;
        ((t_elf64 *)elf)->section_header[section_string_table_index].sh_size = new_string_table_size;
    }

    return 1;
}

int set_new_elf_section_symtab_sh_link_value(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            char *section_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, ".symtab") == 0) {
                ((t_elf32 *)elf)->section_header[i].sh_link += 1;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            char *section_name = find_elf_section_name(elf, i);
            if (strcmp(section_name, ".symtab") == 0) {
                ((t_elf64 *)elf)->section_header[i].sh_link += 1;
            }
        }
    }

    return 1;
}

/* Map example
     *
     * --------
     * loadable1
     * --------
     * loadable2
     * --------
     * loadable3 --> last_loadable_section_index
     * --------
     * non_loadable1
     * --------
     * non_loadable2
     * --------
     * new_created_empty_section
     * --------
     *
     * We change it to this :
     *
     * --------
     * loadable1
     * --------
     * loadable2
     * --------
     * loadable3 --> last_loadable_section_index
     * --------
     * new_section_loadable4
     * --------
     * non_loadable1
     * --------
     * non_loadable2
     * --------
     *
*/
int elf_section_create_new_section(t_elf *elf, int last_pt_load_index, int last_loadable_section_index) {
    char **new_section_data;
    char *loader;

    if(elf->s_type == ELF32) {
        Elf32_Shdr *new_section_headers;
        ((t_elf32 *)elf)->elf_header->e_shnum += 1;

        // We realloc to add the new section header
        size_t new_section_headers_size = sizeof(Elf32_Shdr) * ((t_elf32 *)elf)->elf_header->e_shnum;
        new_section_headers = realloc(((t_elf32 *)elf)->section_header, new_section_headers_size);
        if (new_section_headers == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        // We realloc to add the new section data
        size_t new_section_data_size = sizeof(char *) * ((t_elf32 *)elf)->elf_header->e_shnum;
        new_section_data = realloc(((t_elf32 *)elf)->section_data, new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        // Re-map to new memory location
        ((t_elf32 *)elf)->section_header = new_section_headers;
        ((t_elf32 *)elf)->section_data = new_section_data;

        // Set new section values
        // sh_offset and sh_addr == end of last loadable segment since we know we will add it there
        new_section32.sh_offset =
                ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_offset + ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_memsz;
        new_section32.sh_addr =
                ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_vaddr + ((t_elf32 *)elf)->prog_header[last_pt_load_index].p_memsz;

        new_section32.sh_size = packer_config.loader_size;

        // For ASM
        loader_offset32 = new_section32.sh_addr;

        loader = patch_loader(x32_ARCH, ELF32, packer_config.cipher);
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }

        // -1 because e_shnum starts at 1 / -1 because we created an empty section which doesn't count
        size_t remaining_after_section_headers_data_size =
                sizeof(Elf32_Shdr) * (((t_elf32 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);
        size_t remaining_after_section_headers_count =
                sizeof(char *) * (((t_elf32 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);

        // We move all sections after the last loadable section to + 1
        memmove(new_section_headers + last_loadable_section_index + 2,
                new_section_headers + last_loadable_section_index + 1, remaining_after_section_headers_data_size);
        // Shift all char * pointer after the last loadable section to + 1
        memmove(new_section_data + last_loadable_section_index + 2, new_section_data + last_loadable_section_index + 1,
                remaining_after_section_headers_count);

        // Since we append a new section
        last_loadable_section_index += 1;

        // If the section header string table is after our inserted section, we add + 1 to e_shstrndx to correct its index
        if (((t_elf32 *)elf)->elf_header->e_shstrndx >= last_loadable_section_index) {
            ((t_elf32 *)elf)->elf_header->e_shstrndx += 1;
        }

        // We set a new proper section name
        if (set_new_elf_section_string_table(elf) == -1) {
            free(loader);
            log_error("Error setting new string table");
            return -1;
        }

        // Inserting our new loadable section after the last loadable section
        memcpy(new_section_headers + last_loadable_section_index, &new_section32, sizeof(Elf32_Shdr));
        char *new_section_d = malloc(new_section32.sh_size);
        if(new_section_d == NULL) {
            free(loader);
            free(new_section_d);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(new_section_d, loader, packer_config.loader_size);
        ((t_elf32 *)elf)->section_data[last_loadable_section_index] = new_section_d;
    }
    else {
        Elf64_Shdr *new_section_headers;
        ((t_elf64 *)elf)->elf_header->e_shnum += 1;

        size_t new_section_headers_size = sizeof(Elf64_Shdr) * ((t_elf64 *)elf)->elf_header->e_shnum;
        new_section_headers = realloc(((t_elf64 *)elf)->section_header, new_section_headers_size);
        if (new_section_headers == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        size_t new_section_data_size = sizeof(char *) * ((t_elf64 *)elf)->elf_header->e_shnum;
        new_section_data = realloc(((t_elf64 *)elf)->section_data, new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }

        ((t_elf64 *)elf)->section_header = new_section_headers;
        ((t_elf64 *)elf)->section_data = new_section_data;

        new_section64.sh_offset =
                ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_offset + ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_memsz;
        new_section64.sh_addr =
                ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_vaddr + ((t_elf64 *)elf)->prog_header[last_pt_load_index].p_memsz;

        new_section64.sh_size = packer_config.loader_size;

        // For ASM
        loader_offset64 = new_section64.sh_addr;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }

        size_t remaining_after_section_headers_data_size =
                sizeof(Elf64_Shdr) * (((t_elf64 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);
        size_t remaining_after_section_headers_count =
                sizeof(char *) * (((t_elf64 *)elf)->elf_header->e_shnum - last_loadable_section_index - 1 - 1);

        memmove(new_section_headers + last_loadable_section_index + 2,
                new_section_headers + last_loadable_section_index + 1, remaining_after_section_headers_data_size);
        memmove(new_section_data + last_loadable_section_index + 2, new_section_data + last_loadable_section_index + 1,
                remaining_after_section_headers_count);

        last_loadable_section_index += 1;

        if (((t_elf64 *)elf)->elf_header->e_shstrndx >= last_loadable_section_index) {
            ((t_elf64 *)elf)->elf_header->e_shstrndx += 1;
        }

        // We set a new proper section name
        if (set_new_elf_section_string_table(elf) == -1) {
            free(loader);
            log_error("Error setting new string table");
            return -1;
        }

        memcpy(new_section_headers + last_loadable_section_index, &new_section64, sizeof(Elf64_Shdr));
        char *new_section_d = malloc(new_section64.sh_size);
        if(new_section_d == NULL) {
            free(loader);
            free(new_section_d);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(new_section_d, loader, packer_config.loader_size);
        ((t_elf64 *)elf)->section_data[last_loadable_section_index] = new_section_d;
    }
    free(loader);

    // Fixing sh_link symbol_table index value
    // https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcoblj/index.html#chapter6-47976
    if (set_new_elf_section_symtab_sh_link_value(elf) == -1) {
        log_error("Error modifying symtab sh_link value");
        return -1;
    }

    return 1;
}

int elf_section_set_new_segment_values(t_elf *elf, int segment_index) {
    if(elf->s_type == ELF32) {
        // Set new segment size with our new section included
        size_t new_segment_size = ((t_elf32 *)elf)->prog_header[segment_index].p_memsz + packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_memsz = new_segment_size;
        ((t_elf32 *)elf)->prog_header[segment_index].p_filesz = new_segment_size;
    }
    else {
        size_t new_segment_size = ((t_elf64 *)elf)->prog_header[segment_index].p_memsz + packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_memsz = new_segment_size;
        ((t_elf64 *)elf)->prog_header[segment_index].p_filesz = new_segment_size;
    }

    // Set all pt_loader permissions on RWX (pretty ugly)
    set_new_elf_section_pt_loader_permissions(elf);

    return 1;
}

int elf_section_set_new_section_values(t_elf *elf, int section_index) {
    if(elf->s_type == ELF32) {
        // We shift each section offset to make it correct since we moved sections to leave space for our inserted section
        for (int i = section_index; i < ((t_elf32 *)elf)->elf_header->e_shnum - 1; i++) {
            ((t_elf32 *)elf)->section_header[i + 1].sh_offset = ((t_elf32 *)elf)->section_header[i].sh_offset + ((t_elf32 *)elf)->section_header[i].sh_size;
        }

        // We change the offset of the start of the section header to be correct
        // We set it at the end of the last section data == start of section headers (c.f elf structure)
        int section_count = ((t_elf32 *)elf)->elf_header->e_shnum;
        ((t_elf32 *)elf)->elf_header->e_shoff = ((t_elf32 *)elf)->section_header[section_count - 1].sh_offset + ((t_elf32 *)elf)->section_header[section_count - 1].sh_size;
    }
    else {
        for (int i = section_index; i < ((t_elf64 *)elf)->elf_header->e_shnum - 1; i++) {
            ((t_elf64 *)elf)->section_header[i + 1].sh_offset = ((t_elf64 *)elf)->section_header[i].sh_offset + ((t_elf64 *)elf)->section_header[i].sh_size;
        }

        int section_count = ((t_elf64 *)elf)->elf_header->e_shnum;
        ((t_elf64 *)elf)->elf_header->e_shoff = ((t_elf64 *)elf)->section_header[section_count - 1].sh_offset + ((t_elf64 *)elf)->section_header[section_count - 1].sh_size;
    }

    return 1;
}

void print_link_fields(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            printf("section_name : %s\n", find_elf_section_name(elf, i));
            printf("sh_type : %d\n", ((t_elf32 *)elf)->section_header[i].sh_type);
            printf("sh_link : %d\n", ((t_elf32 *)elf)->section_header[i].sh_link);
            printf("\n");
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            printf("section_name : %s\n", find_elf_section_name(elf, i));
            printf("sh_type : %d\n", ((t_elf64 *)elf)->section_header[i].sh_type);
            printf("sh_link : %d\n", ((t_elf64 *)elf)->section_header[i].sh_link);
            printf("\n");
        }
    }
}

int set_new_elf_section_pt_loader_permissions(t_elf *elf) {
    if(elf->s_type == ELF32) {
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf32 *)elf)->prog_header[i].p_type == PT_LOAD) {
                ((t_elf32 *)elf)->prog_header[i].p_flags = PF_X | PF_W | PF_R; // NOLINT(hicpp-signed-bitwise)
            }
        }
    }
    else {
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            if (((t_elf64 *)elf)->prog_header[i].p_type == PT_LOAD) {
                ((t_elf64 *)elf)->prog_header[i].p_flags = PF_X | PF_W | PF_R; // NOLINT(hicpp-signed-bitwise)
            }
        }
    }

    return 1;
}

int elf_insert_section(t_elf *elf) {
    int last_pt_load_index = find_last_elf_segment_of_type(elf, PT_LOAD);
    if(last_pt_load_index == -1) {
        log_error("Couldn't find PT_LOAD segment");
        return -1;
    }

    int last_loadable_section_index = find_last_elf_section_from_segment(elf, last_pt_load_index);
    if(last_loadable_section_index == -1) {
        log_error("Couldn't find the last Section index");
        return -1;
    }

    log_verbose("Creating new section ...");

    if(elf_section_create_new_section(elf, last_pt_load_index, last_loadable_section_index) == -1) {
        log_error("Error during new Section creation");
        return -1;
    }

    // Since we appended a new section
    last_loadable_section_index += 1;
    method_config.concerned_section = last_loadable_section_index;

    log_verbose("Setting new segment values ...");

    if(elf_section_set_new_segment_values(elf, last_pt_load_index) == -1) {
        log_error("Couldn't set new segment values");
        return -1;
    }

    log_verbose("Setting new section values ...");

    if(elf_section_set_new_section_values(elf, last_loadable_section_index) == -1) {
        log_error("Couldn't set new section values");
        return -1;
    }

    log_verbose("Setting new ELF entry point ...");

    // Add our new section as the new elf entry point
    set_new_elf_entry_to_section(elf, last_loadable_section_index);

    return 1;
}
```

`src/ELF/elf_silvio_infection.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_silvio_infection.h"
#include "elf_functions.h"
#include "elf_allocation.h"
#include "loader_functions.h"
#include "elf_packing_method.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"

Elf32_Addr loader_addr32;
Elf64_Addr loader_addr64;

int set_new_elf_silvio_segment_values(t_elf *elf, int text_segment_index) {
    if(elf->s_type == ELF32) {
        loader_addr32 = ((t_elf32 *)elf)->prog_header[text_segment_index].p_vaddr + ((t_elf32 *)elf)->prog_header[text_segment_index].p_filesz;

        ((t_elf32 *)elf)->prog_header[text_segment_index].p_filesz += packer_config.loader_size;
        ((t_elf32 *)elf)->prog_header[text_segment_index].p_memsz += packer_config.loader_size;

        for (int i = text_segment_index + 1; i < ((t_elf32 *)elf)->elf_header->e_phnum; i++) {
            ((t_elf32 *)elf)->prog_header[i].p_offset += PAGE_SIZE32;
        }
    }
    else {
        loader_addr64 = ((t_elf64 *)elf)->prog_header[text_segment_index].p_vaddr + ((t_elf64 *)elf)->prog_header[text_segment_index].p_filesz;

        ((t_elf64 *)elf)->prog_header[text_segment_index].p_filesz += packer_config.loader_size;
        ((t_elf64 *)elf)->prog_header[text_segment_index].p_memsz += packer_config.loader_size;

        for (int i = text_segment_index + 1; i < ((t_elf64 *)elf)->elf_header->e_phnum; i++) {
            ((t_elf64 *)elf)->prog_header[i].p_offset += PAGE_SIZE64;
        }
    }

    return 1;
}

int set_new_elf_silvio_section_values(t_elf *elf, int last_section_index) {
    if(elf->s_type == ELF32) {
        ((t_elf32 *)elf)->elf_header->e_shoff += PAGE_SIZE32;

        ((t_elf32 *)elf)->section_header[last_section_index].sh_size += packer_config.loader_size;

        for (int i = last_section_index + 1; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            ((t_elf32 *)elf)->section_header[i].sh_offset += PAGE_SIZE32;
        }
    }
    else {
        ((t_elf64 *)elf)->elf_header->e_shoff += PAGE_SIZE64;

        ((t_elf64 *)elf)->section_header[last_section_index].sh_size += packer_config.loader_size;

        for (int i = last_section_index + 1; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            ((t_elf64 *)elf)->section_header[i].sh_offset += PAGE_SIZE64;
        }
    }

    return 1;
}

int elf_silvio_insert_loader(t_elf *elf, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;
    if(elf->s_type == ELF32) {
        size_t new_section_data_size = ((t_elf32 *)elf)->section_header[section_index].sh_size;
        new_section_data = realloc(((t_elf32 *)elf)->section_data[section_index], new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf32 *)elf)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset32 = loader_addr32;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        size_t new_section_data_size = ((t_elf64 *)elf)->section_header[section_index].sh_size;
        new_section_data = realloc(((t_elf64 *)elf)->section_data[section_index], new_section_data_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_elf64 *)elf)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset64 = loader_addr64;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;

        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int elf_silvio_infect(t_elf *elf) {
    int text_segment_index = find_elf_text_segment(elf);
    if(text_segment_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }

    int last_section_index = find_last_elf_section_from_segment(elf, text_segment_index);
    if(last_section_index == -1) {
        log_error("Couldn't find last section from .text segment");
        return -1;
    }
    method_config.concerned_section = last_section_index;


    int old_section_size;
    if(elf->s_type == ELF32)
        old_section_size = ((t_elf32 *)elf)->section_header[last_section_index].sh_size;
    else
        old_section_size = ((t_elf64 *)elf)->section_header[last_section_index].sh_size;


    log_verbose("Setting new section values ...");

    set_new_elf_silvio_section_values(elf, last_section_index);

    log_verbose("Setting new segment values ...");

    set_new_elf_silvio_segment_values(elf, text_segment_index);

    log_verbose("Inserting the loader ...");

    if(elf_silvio_insert_loader(elf, last_section_index, old_section_size) == -1) {
        log_error("Loader insertion failed");
        return -1;
    }

    // Add write permission to be able to decrypt it
    add_elf_segment_permission(elf, text_segment_index, PF_W); // NOLINT(hicpp-signed-bitwise)

    log_verbose("Setting new ELF entry point ...");

    if(elf->s_type == ELF32) {
        set_new_elf_entry_to_addr32(elf, loader_addr32, last_section_index, old_section_size);
    }
    else {
        set_new_elf_entry_to_addr64(elf, loader_addr64, last_section_index, old_section_size);
    }

    return 1;
}
```

`src/ELF/elf_writing.c`:

```c
//
// Created by silentvoid on 2/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "elf_writing.h"
#include "elf_allocation.h"
#include "file_functions.h"
#include "elf_packing_method.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_elf_loaders_infos.h"

#include "log.h"



int write_elf(t_elf *elf, char *filename) {
    int fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0755); // NOLINT(hicpp-signed-bitwise)
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    if(elf->s_type == ELF32) {
        log_verbose("Writing ELF header ...");
        write_to_file(fd, ((t_elf32 *)elf)->elf_header, sizeof(Elf32_Ehdr));
        add_zero_padding(fd, ((t_elf32 *)elf)->elf_header->e_phoff);

        log_verbose("Writing Program header ...");
        write_to_file(fd, ((t_elf32 *)elf)->prog_header, sizeof(Elf32_Phdr) * ((t_elf32 *)elf)->elf_header->e_phnum);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf32 *)elf)->section_header[i].sh_type != SHT_NOBITS) {
                add_zero_padding(fd, ((t_elf32 *)elf)->section_header[i].sh_offset);

                // If we find the section with the code cave
                if (method_config.method_type == CODE_CAVE_METHOD && i == method_config.concerned_section) {
                    write_to_file(fd, ((t_elf32 *)elf)->section_data[i], ((t_elf32 *)elf)->section_header[i].sh_size + packer_config.loader_size);
                } else {
                    write_to_file(fd, ((t_elf32 *)elf)->section_data[i], ((t_elf32 *)elf)->section_header[i].sh_size);
                }
            }
        }
        add_zero_padding(fd, ((t_elf32 *)elf)->elf_header->e_shoff);

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_elf32 *)elf)->elf_header->e_shnum; i++) {
            write_to_file(fd, &(((t_elf32 *)elf)->section_header[i]), sizeof(Elf32_Shdr));
        }
    }
    else {
        log_verbose("Writing ELF header ...");
        write_to_file(fd, ((t_elf64 *)elf)->elf_header, sizeof(Elf64_Ehdr));
        add_zero_padding(fd, ((t_elf64 *)elf)->elf_header->e_phoff);

        log_verbose("Writing Program header ...");
        write_to_file(fd, ((t_elf64 *)elf)->prog_header, sizeof(Elf64_Phdr) * ((t_elf64 *)elf)->elf_header->e_phnum);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            if (((t_elf64 *)elf)->section_header[i].sh_type != SHT_NOBITS) {
                add_zero_padding(fd, ((t_elf64 *)elf)->section_header[i].sh_offset);

                // If we find the section with the code cave
                if (method_config.method_type == CODE_CAVE_METHOD && i == method_config.concerned_section) {
                    write_to_file(fd, ((t_elf64 *)elf)->section_data[i], ((t_elf64 *)elf)->section_header[i].sh_size + packer_config.loader_size);
                } else {
                    write_to_file(fd, ((t_elf64 *)elf)->section_data[i], ((t_elf64 *)elf)->section_header[i].sh_size);
                }
            }
        }
        add_zero_padding(fd, ((t_elf64 *)elf)->elf_header->e_shoff);

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_elf64 *)elf)->elf_header->e_shnum; i++) {
            write_to_file(fd, &(((t_elf64 *) elf)->section_header[i]), sizeof(Elf64_Shdr));
        }
    }

    close(fd);

    return 1;
}
```

`src/PE/pe_allocation.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_allocation.h"
#include "pe_deallocation.h"
#include "file_functions.h"

#include "log.h"

int allocate_pe_dos_header(t_pe *pe, void *file_data, size_t file_data_size) {
    if(file_data_size < sizeof(IMAGE_DOS_HEADER)) {
        log_error("Total file size is less than DOS Header size");
        return -1;
    }

    // PE32 and PE32+ have the same DOS Header

    ((t_pe32 *)pe)->dos_header = malloc(sizeof(IMAGE_DOS_HEADER));
    if (((t_pe32 *)pe)->dos_header == NULL) {
        deallocate_pe_dos_header(pe);
        log_error("malloc() failure");
        return -1;
    }
    memcpy(((t_pe32 *)pe)->dos_header, file_data, sizeof(IMAGE_DOS_HEADER));

    // 0x5a4d
    if (((t_pe32 *)pe)->dos_header->e_magic != DOSMAG) {
        deallocate_pe_dos_header(pe);
        log_error("Magic bytes do not match PE file");
        return -1;
    }

    // TODO : check architecture like in ELF

    return 1;
}

int allocate_pe_dos_stub(t_pe *pe, void *file_data) {
    size_t dos_stub_size = ((t_pe32 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER);

    // PE32 and PE32+ have the same DOS Stub

    ((t_pe32 *)pe)->dos_stub = malloc(dos_stub_size);
    if(((t_pe32 *)pe)->dos_stub == NULL) {
        deallocate_pe_dos_stub(pe);
        log_error("malloc() failure");
        return -1;
    }
    memcpy(((t_pe32 *)pe)->dos_stub, file_data + sizeof(IMAGE_DOS_HEADER), dos_stub_size);

    return 1;
}

int allocate_pe_pe_header(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        if (file_data_size < sizeof(IMAGE_NT_HEADERS32)) {
            log_error("Total file size is less than PE Header size");
            return -1;
        }

        ((t_pe32 *)pe)->pe_header = malloc(sizeof(IMAGE_NT_HEADERS32));
        if (((t_pe32 *)pe)->pe_header == NULL) {
            deallocate_pe_pe_header(pe);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_pe32 *)pe)->pe_header, file_data + ((t_pe32 *)pe)->dos_header->e_lfanew, sizeof(IMAGE_NT_HEADERS32));

        if ((((t_pe32 *)pe)->pe_header->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) { // NOLINT(hicpp-signed-bitwise)
            deallocate_pe_pe_header(pe);
            log_error("The file is not an executable");
            return -1;
        }

        if (((t_pe32 *)pe)->pe_header->FileHeader.SizeOfOptionalHeader == 0) {
            deallocate_pe_pe_header(pe);
            log_error("The file is an OBJ file");
            return -1;
        }

        if (((t_pe32 *)pe)->pe_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            deallocate_pe_pe_header(pe);
            log_error("File is not an executable image");
            return -1;
        }
    }
    else {
        if (file_data_size < sizeof(IMAGE_NT_HEADERS64)) {
            log_error("Total file size is less than PE Header size");
            return -1;
        }

        ((t_pe64 *)pe)->pe_header = malloc(sizeof(IMAGE_NT_HEADERS64));
        if (((t_pe64 *)pe)->pe_header == NULL) {
            deallocate_pe_pe_header(pe);
            log_error("malloc() failure");
            return -1;
        }
        memcpy(((t_pe64 *)pe)->pe_header, file_data + ((t_pe64 *)pe)->dos_header->e_lfanew, sizeof(IMAGE_NT_HEADERS64));

        if ((((t_pe64 *)pe)->pe_header->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) { // NOLINT(hicpp-signed-bitwise)
            deallocate_pe_pe_header(pe);
            log_error("The file is not an executable");
            return -1;
        }

        if (((t_pe64 *)pe)->pe_header->FileHeader.SizeOfOptionalHeader == 0) {
            deallocate_pe_pe_header(pe);
            log_error("The file is an OBJ file");
            return -1;
        }

        if (((t_pe64 *)pe)->pe_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            deallocate_pe_pe_header(pe);
            log_error("File is not an executable image");
            return -1;
        }
    }

    return 1;
}

int allocate_pe_sections_headers(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        size_t pe_sections_header_size = sizeof(IMAGE_SECTION_HEADER) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe32 *)pe)->section_header = malloc(pe_sections_header_size);
        if (((t_pe32 *)pe)->section_header == NULL) {
            deallocate_pe_sections_headers(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe32 *)pe)->section_header, 0, pe_sections_header_size);

        // TODO: Check for IMAGE_SCN_CNT_UNINITIALIZED_DATA type like in elf_allocation
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size <
                ((t_pe32 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS32) + (i * sizeof(IMAGE_SECTION_HEADER))) {
                deallocate_pe_sections_headers(pe);
                log_error("Total file size is inferior to PE section header size");
                return -1;
            }
            memcpy(&(((t_pe32 *)pe)->section_header[i]), file_data + ((t_pe32 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS32) +
                                             (i * sizeof(IMAGE_SECTION_HEADER)), sizeof(IMAGE_SECTION_HEADER));
        }
    }
    else {
        size_t pe_sections_header_size = sizeof(IMAGE_SECTION_HEADER) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe64 *)pe)->section_header = malloc(pe_sections_header_size);
        if (((t_pe64 *)pe)->section_header == NULL) {
            deallocate_pe_sections_headers(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe64 *)pe)->section_header, 0, pe_sections_header_size);

        // TODO: Check for IMAGE_SCN_CNT_UNINITIALIZED_DATA type like in elf_allocation
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size <
                ((t_pe64 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64) + (i * sizeof(IMAGE_SECTION_HEADER))) {
                deallocate_pe_sections_headers(pe);
                log_error("Total file size is inferior to PE section header size");
                return -1;
            }
            memcpy(&(((t_pe64 *)pe)->section_header[i]), file_data + ((t_pe64 *)pe)->dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64) +
                                                         (i * sizeof(IMAGE_SECTION_HEADER)), sizeof(IMAGE_SECTION_HEADER));
        }
    }

    return 1;
}

int allocate_pe_sections_data(t_pe *pe, void *file_data, size_t file_data_size) {
    if(pe->s_type == PE32) {
        size_t section_data_size = sizeof(char *) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe32 *)pe)->section_data = malloc(section_data_size);
        if (((t_pe32 *)pe)->section_data == NULL) {
            deallocate_pe_sections_data(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe32 *)pe)->section_data, 0, section_data_size);

        // TODO: Free all the malloc section_data_data up to i
        size_t pe_section_data_size;
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size < ((t_pe32 *)pe)->section_header[i].PointerToRawData) {
                log_error("Total file size is less than section data offset");
                return -1;
            }
            pe_section_data_size = ((t_pe32 *)pe)->section_header[i].SizeOfRawData;

            ((t_pe32 *)pe)->section_data[i] = malloc(pe_section_data_size);
            if (((t_pe32 *)pe)->section_data[i] == NULL) {
                free(((t_pe32 *)pe)->section_data[i]);
                log_error("malloc() error");
                return -1;
            }
            memset(((t_pe32 *)pe)->section_data[i], 0, pe_section_data_size);
            memcpy(((t_pe32 *)pe)->section_data[i], file_data + ((t_pe32 *)pe)->section_header[i].PointerToRawData, pe_section_data_size);
        }
    }
    else {
        size_t section_data_size = sizeof(char *) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;

        ((t_pe64 *)pe)->section_data = malloc(section_data_size);
        if (((t_pe64 *)pe)->section_data == NULL) {
            deallocate_pe_sections_data(pe);
            log_error("malloc() failure");
            return -1;
        }
        memset(((t_pe64 *)pe)->section_data, 0, section_data_size);

        size_t pe_section_data_size;
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (file_data_size < ((t_pe64 *)pe)->section_header[i].PointerToRawData) {
                log_error("Total file size is less than section data offset");
                return -1;
            }
            pe_section_data_size = ((t_pe64 *)pe)->section_header[i].SizeOfRawData;

            ((t_pe64 *)pe)->section_data[i] = malloc(pe_section_data_size);
            if (((t_pe64 *)pe)->section_data[i] == NULL) {
                free(((t_pe64 *)pe)->section_data[i]);
                log_error("malloc() error");
                return -1;
            }
            memset(((t_pe64 *)pe)->section_data[i], 0, pe_section_data_size);
            memcpy(((t_pe64 *)pe)->section_data[i], file_data + ((t_pe64 *)pe)->section_header[i].PointerToRawData, pe_section_data_size);
        }
    }

    return 1;
}

void print_pe_info(t_pe *pe) {
    if(pe->s_type == PE32) {
        printf("e_lfanew : %d\n", ((t_pe32 *)pe)->dos_header->e_lfanew);
        printf("section_header size : %ld\n",
               sizeof(IMAGE_SECTION_HEADER) * ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections);

        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            printf("section_offset: %d\n", ((t_pe32 *)pe)->section_header[i].PointerToRawData);
            printf("section_size : %d\n", ((t_pe32 *)pe)->section_header[i].SizeOfRawData);
            if (i != ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections - 1) {
                printf("next_section_offset : %d\n", ((t_pe32 *)pe)->section_header[i + 1].PointerToRawData);
            }
            printf("\n");
        }
    }
    else {
        printf("e_lfanew : %d\n", ((t_pe64 *)pe)->dos_header->e_lfanew);
        printf("section_header size : %ld\n",
               sizeof(IMAGE_SECTION_HEADER) * ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections);

        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            printf("section_offset: %d\n", ((t_pe64 *)pe)->section_header[i].PointerToRawData);
            printf("section_size : %d\n", ((t_pe64 *)pe)->section_header[i].SizeOfRawData);
            if (i != ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections - 1) {
                printf("next_section_offset : %d\n", ((t_pe64 *)pe)->section_header[i + 1].PointerToRawData);
            }
            printf("\n");
        }
    }
}

int allocate_pe(t_pe **pe, void *file_data, size_t file_data_size, int arch) {
    size_t t_pe_size;
    if(arch == x32_ARCH) {
        t_pe_size = sizeof(t_pe32);
    }
    else {
        t_pe_size = sizeof(t_pe64);
    }

    *pe = malloc(t_pe_size);
    if(*pe == NULL) {
        deallocate_pe_struct(*pe);
        log_error("malloc() failure");
        return -1;
    }
    memset(*pe, 0, t_pe_size);

    t_pe type_pe;
    if(arch == 32) {
        type_pe.s_type = PE32;
        ((t_pe32 *)(*pe))->type_header = type_pe;
    }
    else {
        type_pe.s_type = PE64;
        ((t_pe32 *)(*pe))->type_header = type_pe;
    }

    log_verbose("Allocating DOS Header ...");
    if(allocate_pe_dos_header(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_struct(*pe);
        log_error("Error during DOS Header allocation");
        return -1;
    }

    log_verbose("Allocating DOS Stub ...");
    if(allocate_pe_dos_stub(*pe, file_data) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during DOS Stub allocation");
        return -1;
    }

    log_verbose("Allocating PE Header ...");
    if(allocate_pe_pe_header(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during PE Header allocation");
        return -1;
    }

    log_verbose("Allocating Sections Headers ...");
    if(allocate_pe_sections_headers(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_pe_header(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during Section Headers allocation");
        return -1;
    }

    log_verbose("Allocating Sections Data ...");
    if(allocate_pe_sections_data(*pe, file_data, file_data_size) == -1) {
        deallocate_pe_dos_header(*pe);
        deallocate_pe_dos_stub(*pe);
        deallocate_pe_pe_header(*pe);
        deallocate_pe_sections_headers(*pe);
        deallocate_pe_struct(*pe);
        log_error("Error during Section Data allocation");
        return -1;
    }

    //print_pe_info(*pe);

    return 1;
}
```

`src/PE/pe_code_cave.c`:

```c
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_code_cave.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

int find_pe_code_cave_index(t_pe *pe) {
    size_t code_cave_size;

    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections - 1; i++) {
            if (((t_pe32 *)pe)->section_header[i].SizeOfRawData > ((t_pe32 *)pe)->section_header[i].Misc.VirtualSize) {
                code_cave_size = ((t_pe32 *)pe)->section_header[i].SizeOfRawData - ((t_pe32 *)pe)->section_header[i].Misc.VirtualSize;

                //print_pe_section_info(pe, i);

                if (code_cave_size > packer_config.loader_size) {
                    return i;
                }
            }
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections - 1; i++) {
            if (((t_pe64 *)pe)->section_header[i].SizeOfRawData > ((t_pe64 *)pe)->section_header[i].Misc.VirtualSize) {
                code_cave_size = ((t_pe64 *)pe)->section_header[i].SizeOfRawData - ((t_pe64 *)pe)->section_header[i].Misc.VirtualSize;

                //print_pe_section_info(pe, i);

                if (code_cave_size > packer_config.loader_size) {
                    return i;
                }
            }
        }
    }

    return -1;
}

int set_new_pe_cave_section_values(t_pe *pe, int section_index) {
    if(pe->s_type == PE32)
        ((t_pe32 *)pe)->section_header[section_index].Misc.VirtualSize += packer_config.loader_size;
    else
        ((t_pe64 *)pe)->section_header[section_index].Misc.VirtualSize += packer_config.loader_size;

    // TODO: Change this to use mprotect in the loader

    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text segment");
        return -1;
    }
    add_pe_section_permission(pe, text_section_index, IMAGE_SCN_MEM_WRITE); // NOLINT(hicpp-signed-bitwise)

    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_WRITE); // NOLINT(hicpp-signed-bitwise)
    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_READ); // NOLINT(hicpp-signed-bitwise)
    add_pe_section_permission(pe, section_index, IMAGE_SCN_MEM_EXECUTE); // NOLINT(hicpp-signed-bitwise)

    return 1;
}

int pe_cave_insert_loader(t_pe *pe, int section_index, int old_section_size) {
    char *new_section_data;
    char *loader;

    if(pe->s_type == PE32) {
        new_section_data = realloc(((t_pe32 *)pe)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe32 *)pe)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset32 = ((t_pe32 *)pe)->section_header[section_index].VirtualAddress + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    else {
        new_section_data = realloc(((t_pe64 *)pe)->section_data[section_index], old_section_size + packer_config.loader_size);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe64 *)pe)->section_data[section_index] = new_section_data;

        // For ASM
        loader_offset64 = ((t_pe64 *)pe)->section_header[section_index].VirtualAddress + old_section_size;

        loader = patch_loader();
        if(loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        memcpy(new_section_data + old_section_size, loader, packer_config.loader_size);
    }
    free(loader);

    return 1;
}

int pe_code_cave_injection(t_pe *pe) {

    log_verbose("Finding a code cave ...");

    int section_cave_index = find_pe_code_cave_index(pe);
    if(section_cave_index == -1) {
        log_error("Couldn't find any code cave in this PE file");
        return -1;
    }

    log_verbose("Setting new section values ...");


    int old_section_size;
    if(pe->s_type == PE32)
        old_section_size = ((t_pe32 *)pe)->section_header[section_cave_index].Misc.VirtualSize;
    else
        old_section_size = ((t_pe64 *)pe)->section_header[section_cave_index].Misc.VirtualSize;

    if(set_new_pe_cave_section_values(pe, section_cave_index) == -1) {
        log_error("Error during section values modification");
        return -1;
    }

    log_verbose("Inserting the loader inside the code cave ...");

    if(pe_cave_insert_loader(pe, section_cave_index, old_section_size) == -1) {
        log_error("Error during Loader insertion");
        return -1;
    }

    log_verbose("Setting new PE entry point ...");

    uint32_t loader_addr;
    if(pe->s_type == PE32)
        loader_addr = ((t_pe32 *)pe)->section_header[section_cave_index].VirtualAddress + old_section_size;
    else
        loader_addr = ((t_pe64 *)pe)->section_header[section_cave_index].VirtualAddress + old_section_size;

    set_new_pe_entry_to_addr(pe, loader_addr, section_cave_index, old_section_size);

    return 1;
}
```

`src/PE/pe_deallocation.c`:

```c
//
// Created by silentvoid on 4/12/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_deallocation.h"
#include "pe_allocation.h"

void deallocate_pe_dos_header(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->dos_header);
    }
    else {
        free(((t_pe64 *)pe)->dos_header);
    }
}
void deallocate_pe_dos_stub(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->dos_stub);
    }
    else {
        free(((t_pe64 *)pe)->dos_stub);
    }
}

void deallocate_pe_pe_header(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->pe_header);
    }
    else {
        free(((t_pe64 *)pe)->pe_header);
    }
}

void deallocate_pe_sections_headers(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->section_header);
    }
    else {
        free(((t_pe64 *)pe)->section_header);
    }
}

void deallocate_pe_sections_data(t_pe *pe) {
    if(pe->s_type == PE32) {
        free(((t_pe32 *)pe)->section_data);
    }
    else {
        free(((t_pe64 *)pe)->section_data);
    }
}

void deallocate_pe_sections_data_data(t_pe *pe) {
    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            free(((t_pe32 *)pe)->section_data[i]);
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            free(((t_pe64 *)pe)->section_data[i]);
        }
    }
}

void deallocate_pe_struct(t_pe *pe) {
    free(pe);
}

void deallocate_pe(t_pe *pe) {
    deallocate_pe_dos_header(pe);
    deallocate_pe_dos_stub(pe);
    deallocate_pe_pe_header(pe);
    deallocate_pe_sections_headers(pe);
    deallocate_pe_sections_data(pe);
    deallocate_pe_sections_data_data(pe);
    deallocate_pe_struct(pe);
}

```

`src/PE/pe_encryption.c`:

```c
//
// Created by silentvoid on 3/19/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_encryption.h"
#include "pe_struct.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "aes_128_ecb_encryption.h"

#include "log.h"

int encrypt_pe(t_pe *pe) {
    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text section");
        return -1;
    }

    log_verbose("Got .text section index : %d", text_section_index);

    char *text_data;

    if(pe->s_type == PE32) {
        // Setting global variables
        text_entry_point32 = ((t_pe32 *)pe)->section_header[text_section_index].VirtualAddress;
        text_data_size32 = ((t_pe32 *)pe)->section_header[text_section_index].Misc.VirtualSize;

        text_data = ((t_pe32 *)pe)->section_data[text_section_index];

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text32.dmp", text_data, text_data_size32);
        }

        log_verbose("Generating random key ...");
        cipher_key32 = generate_random_key32();
        uint64_t temp_key = cipher_key32;
        log_info("Random key : %d", cipher_key32);

        if(strcmp(packer_config.cipher, "xor") == 0) {
            xor_encrypt32(text_data, text_data_size32, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size32, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text32_encrypted.dmp", text_data, text_data_size32);
        }
    }
    else {
        // Setting global variables
        text_entry_point64 = ((t_pe64 *)pe)->section_header[text_section_index].VirtualAddress;
        text_data_size64 = ((t_pe64 *)pe)->section_header[text_section_index].Misc.VirtualSize;

        text_data = ((t_pe64 *)pe)->section_data[text_section_index];

        if(packer_config.debug_mode) {
            log_debug("Dumping .text ...");
            dump_to_file("text64.dmp", text_data, text_data_size64);
        }

        log_verbose("Generating random key ...");
        cipher_key64 = generate_random_key64();
        uint64_t temp_key = cipher_key64;
        log_info("Random key : %d", cipher_key64);

        if(strcmp(packer_config.cipher, "xor") == 0) {
            xor_encrypt64(text_data, text_data_size64, temp_key);
        }
        else if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            generate_random_key128();

            log_info("Random key : ");
            for(int i = 0; i < 16; i++)
                printf("%02x", cipher_key128[i]);
            puts("");

            aes_128_ecb_encrypt(text_data, text_data_size64, cipher_key128, 16);
        }

        if(packer_config.debug_mode) {
            log_debug("Dumping encrypted .text ...");
            dump_to_file("text64_encrypted.dmp", text_data, text_data_size64);
        }
    }

    return 1;
}

```

`src/PE/pe_functions.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_functions.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "loader_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

int set_new_pe_entry_to_addr(t_pe *pe, uint32_t entry_addr, int section_index, int section_size)  {
    if(pe->s_type == PE32) {
        uint32_t last_entry = ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = entry_addr;
        int32_t jump = last_entry - (((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe32 *)pe)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        uint32_t last_entry = ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = entry_addr;
        int32_t jump = last_entry - (((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe64 *)pe)->section_data[section_index] + section_size + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int set_new_pe_entry_to_section(t_pe *pe, int section_index) {
    if(pe->s_type == PE32) {
        uint32_t last_entry = ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = ((t_pe32 *)pe)->section_header[section_index].VirtualAddress;
        int32_t jump = last_entry - (((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe32 *)pe)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }
    else {
        uint32_t last_entry = ((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint = ((t_pe64 *)pe)->section_header[section_index].VirtualAddress;
        int32_t jump = last_entry - (((t_pe64 *)pe)->pe_header->OptionalHeader.AddressOfEntryPoint + packer_config.loader_size - packer_config.loader_infos_size);

        memcpy(((t_pe64 *)pe)->section_data[section_index] + packer_config.loader_size - (packer_config.loader_infos_size + 4), &jump, 4);
    }

    return 1;
}

int find_pe_text_section(t_pe *pe) {
    int index = -1;
    if(pe->s_type == PE32) {
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (((t_pe32 *)pe)->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) { // NOLINT(hicpp-signed-bitwise)
                index = i;
            }
        }
    }
    else {
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            if (((t_pe64 *)pe)->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) { // NOLINT(hicpp-signed-bitwise)
                index = i;
            }
        }
    }
    return index;
}

void add_pe_section_permission(t_pe *pe, int segment_index, int permission) {
    if(pe->s_type == PE32) {
        ((t_pe32 *)pe)->section_header[segment_index].Characteristics |= permission; // NOLINT(hicpp-signed-bitwise)
    }
    else {
        ((t_pe64 *)pe)->section_header[segment_index].Characteristics |= permission; // NOLINT(hicpp-signed-bitwise)
    }
}

void print_pe_section_info(t_pe *pe, int section_index) {
    puts("");

    if(pe->s_type == PE32) {
        printf("Section name : %s\n", ((t_pe32 *)pe)->section_header[section_index].Name);
        printf("VirtualSize : %d\n", ((t_pe32 *)pe)->section_header[section_index].Misc.VirtualSize);
        printf("SizeofRawData : %d\n", ((t_pe32 *)pe)->section_header[section_index].SizeOfRawData);
        printf("PointerToRawData : %x\n", ((t_pe32 *)pe)->section_header[section_index].PointerToRawData);
        printf("VirtualAddress : %x\n", ((t_pe32 *)pe)->section_header[section_index].VirtualAddress);
    }
    else {
        printf("Section name : %s\n", ((t_pe64 *)pe)->section_header[section_index].Name);
        printf("VirtualSize : %d\n", ((t_pe64 *)pe)->section_header[section_index].Misc.VirtualSize);
        printf("SizeofRawData : %d\n", ((t_pe64 *)pe)->section_header[section_index].SizeOfRawData);
        printf("PointerToRawData : %x\n", ((t_pe64 *)pe)->section_header[section_index].PointerToRawData);
        printf("VirtualAddress : %x\n", ((t_pe64 *)pe)->section_header[section_index].VirtualAddress);
    }
}

```

`src/PE/pe_packing.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_packing.h"
#include "pe_allocation.h"
#include "pe_deallocation.h"
#include "file_functions.h"
#include "packer_config.h"
#include "pe_writing.h"
#include "pe_packing_method.h"
#include "pe_encryption.h"

#include "log.h"

int pack_pe(char *file, char *file_data, size_t file_data_size, char *output) {
    log_verbose("Detected arch : x%d", packer_config.arch);
    log_info("Allocating PE in memory ...");

    t_pe *pe = NULL;
    if (allocate_pe(&pe, file_data, file_data_size, packer_config.arch) == -1) {
        munmap(file_data, file_data_size);
        log_error("Error during PE allocation");
        return -1;
    }

    // De-allocate mapped file as we don't need it anymore
    munmap(file_data, file_data_size);

    log_info("Encrypting .text section ...");
    if(encrypt_pe(pe) == -1) {
        deallocate_pe(pe);
        log_error("Error during PE encryption");
        return -1;
    }

    log_info("Packing using specified method ...");
    if(pe_pack_using_method(pe) == -1) {
        deallocate_pe(pe);
        log_error("Error during PE packing");
        return -1;
    }

    char *filename;
    if(output != NULL)
        filename = output;
    else
        filename = "packed.exe";

    log_info("Writing Packed PE to file ...");
    if(write_pe(pe, filename) == -1) {
        deallocate_pe(pe);
        log_error("Error during new PE writing");
        return -1;
    }

    log_success("File %s packed into %s !", file, filename);
    deallocate_pe(pe);

    return 1;
}


```

`src/PE/pe_packing_method.c`:

```c
//
// Created by silentvoid on 2/28/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_packing_method.h"
#include "pe_allocation.h"
#include "packer_config.h"
#include "pe_code_cave.h"
#include "pe_section_insertion.h"

#include "log.h"

struct method_config method_config;

int pe_pack_using_method(t_pe *pe) {
    if(strcmp(packer_config.packing_method, "section_insertion") == 0) {
        method_config.method_type = SECTION_INSERTION_METHOD;
        if (pe_insert_section(pe) == -1) {
            log_error("Error during Section insertion");
            return -1;
        }
    }
    else if(strcmp(packer_config.packing_method, "code_cave") == 0) {
        method_config.method_type = CODE_CAVE_METHOD;
        if(pe_code_cave_injection(pe) == -1) {
            log_error("Error during Code Cave Injection");
            return -1;
        }
    }

    return 1;
}
```

`src/PE/pe_section_insertion.c`:

```c
#pragma clang diagnostic push
#pragma ide diagnostic ignored "hicpp-signed-bitwise"
//
// Created by silentvoid on 3/26/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_section_insertion.h"
#include "pe_struct.h"
#include "pe_allocation.h"
#include "pe_functions.h"
#include "loader_functions.h"
#include "file_functions.h"
#include "packer_config.h"
#include "all_pe_loaders_infos.h"

#include "log.h"

void print_new_section_header_info(IMAGE_SECTION_HEADER *section_header) {
    printf("VirtualAddress : %d\n", section_header->VirtualAddress);
    printf("VirtualSize : %d\n", section_header->Misc.VirtualSize);
    printf("SizeOfRawData : %d\n", section_header->SizeOfRawData);
}

int add_new_pe_section_header(t_pe *pe) {
    int sections_count;
    if(pe->s_type == PE32) {
        sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        size_t new_section_header_size = sections_count * sizeof(IMAGE_SECTION_HEADER) + sizeof(IMAGE_SECTION_HEADER);
        IMAGE_SECTION_HEADER *new_section_header = realloc(((t_pe32 *)pe)->section_header, new_section_header_size);
        if (new_section_header == NULL) {
            log_error("realloc() failure\n");
            return -1;
        }
        ((t_pe32 *)pe)->section_header = new_section_header;
    }
    else {
        sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        size_t new_section_header_size = sections_count * sizeof(IMAGE_SECTION_HEADER) + sizeof(IMAGE_SECTION_HEADER);
        IMAGE_SECTION_HEADER *new_section_header = realloc(((t_pe64 *)pe)->section_header, new_section_header_size);
        if (new_section_header == NULL) {
            log_error("realloc() failure\n");
            return -1;
        }
        ((t_pe64 *)pe)->section_header = new_section_header;
    }

    IMAGE_SECTION_HEADER new_header;
    memset(&new_header, 0, sizeof(IMAGE_SECTION_HEADER));

    char *section_name = ".dec";
    memset(new_header.Name, 0, sizeof(new_header.Name));
    memcpy(new_header.Name, section_name, strlen(section_name));

    if(pe->s_type == PE32) {
        new_header.VirtualAddress = ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfImage;
        new_header.PointerToRawData =   ((t_pe32 *)pe)->section_header[sections_count - 1].PointerToRawData +
                                        ((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData;

        new_header.Misc.VirtualSize = packer_config.loader_size;
        // TO SEE
        size_t raw_data_size = 0;
        while(raw_data_size < packer_config.loader_size) {
            raw_data_size += ((t_pe32 *)pe)->pe_header->OptionalHeader.FileAlignment;
        }
        new_header.SizeOfRawData = raw_data_size;

        new_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; // NOLINT(hicpp-signed-bitwise)

        //print_new_section_header_info(&new_header);

        memcpy(&(((t_pe32 *)pe)->section_header[sections_count]), &new_header, sizeof(IMAGE_SECTION_HEADER));
    }
    else {
        new_header.VirtualAddress = ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfImage;
        new_header.PointerToRawData =   ((t_pe64 *)pe)->section_header[sections_count - 1].PointerToRawData +
                                        ((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData;

        new_header.Misc.VirtualSize = packer_config.loader_size;

        // TO SEE
        size_t raw_data_size = 0;
        while(raw_data_size < packer_config.loader_size) {
            raw_data_size += ((t_pe64 *)pe)->pe_header->OptionalHeader.FileAlignment;
        }
        new_header.SizeOfRawData = raw_data_size;

        new_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; // NOLINT(hicpp-signed-bitwise)

        //print_new_section_header_info(&new_header);

        memcpy(&(((t_pe64 *)pe)->section_header[sections_count]), &new_header, sizeof(IMAGE_SECTION_HEADER));
    }

    return 1;
}

int set_new_pe_header_values(t_pe *pe) {
    if(pe->s_type == PE32) {
        int old_sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections += 1;

        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfCode += ((t_pe32 *)pe)->section_header[old_sections_count - 1].SizeOfRawData;
        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfHeaders += sizeof(IMAGE_SECTION_HEADER);
        ((t_pe32 *)pe)->pe_header->OptionalHeader.SizeOfImage += packer_config.loader_size;
    }
    else {
        int old_sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections += 1;

        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfCode += ((t_pe64 *)pe)->section_header[old_sections_count - 1].SizeOfRawData;
        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfHeaders += sizeof(IMAGE_SECTION_HEADER);
        ((t_pe64 *)pe)->pe_header->OptionalHeader.SizeOfImage += packer_config.loader_size;
    }

    return 1;
}

int add_new_pe_section_data(t_pe *pe) {
    char *loader;

    if(pe->s_type == PE32) {
        int sections_count = ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections;
        char **new_section_data = realloc(((t_pe32 *)pe)->section_data, sizeof(char *) * sections_count);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe32 *)pe)->section_data = new_section_data;

        // For ASM
        loader_offset32 = ((t_pe32 *)pe)->section_header[sections_count - 1].VirtualAddress;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        char *new_section = malloc(((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        if(new_section == NULL) {
            free(loader);
            free(new_section);
            log_error("malloc() failure");
            return -1;
        }
        memset(new_section, 0, ((t_pe32 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        memcpy(new_section, loader, packer_config.loader_size);
        ((t_pe32 *)pe)->section_data[sections_count - 1] = new_section;
    }
    else {
        int sections_count = ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections;
        char **new_section_data = realloc(((t_pe64 *)pe)->section_data, sizeof(char *) * sections_count);
        if (new_section_data == NULL) {
            log_error("realloc() failure");
            return -1;
        }
        ((t_pe64 *)pe)->section_data = new_section_data;

        // For ASM
        loader_offset64 = ((t_pe64 *)pe)->section_header[sections_count - 1].VirtualAddress;

        loader = patch_loader();
        if (loader == NULL) {
            free(loader);
            log_error("Error during loader patching");
            return -1;
        }
        char *new_section = malloc(((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        if(new_section == NULL) {
            free(loader);
            free(new_section);
            log_error("malloc() failure");
            return -1;
        }
        memset(new_section, 0, ((t_pe64 *)pe)->section_header[sections_count - 1].SizeOfRawData);
        memcpy(new_section, loader, packer_config.loader_size);
        ((t_pe64 *)pe)->section_data[sections_count - 1] = new_section;
    }
    free(loader);

    return 1;
}

int pe_insert_section(t_pe *pe) {
    int text_section_index = find_pe_text_section(pe);
    if(text_section_index == -1) {
        log_error("Couldn't find .text section");
        return -1;
    }
    add_pe_section_permission(pe, text_section_index, IMAGE_SCN_MEM_WRITE);

    log_verbose("Creating new section ...");

    if(add_new_pe_section_header(pe) == -1) {
        log_error("Error during new Section Header insertion");
        return -1;
    }

    log_verbose("Setting new sections headers values ...");

    if(set_new_pe_header_values(pe) == -1) {
        log_error("Couldn't set new PE Header values");
        return -1;
    }

    log_verbose("Inserting the section data ...");

    if(add_new_pe_section_data(pe) == -1) {
        log_error("Error during new Section Data insertion");
        return -1;
    }

    log_verbose("Setting new PE entry point ...");

    if(pe->s_type == PE32)
        set_new_pe_entry_to_section(pe, ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections-1);
    else
        set_new_pe_entry_to_section(pe, ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections-1);

    return 1;
}
#pragma clang diagnostic pop
```

`src/PE/pe_writing.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "pe_writing.h"
#include "pe_allocation.h"
#include "file_functions.h"

#include "log.h"

int write_pe(t_pe *pe, char *filename) {
    int fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0755); // NOLINT(hicpp-signed-bitwise)
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    if(pe->s_type == PE32) {
        log_verbose("Writing DOS header ...");
        write_to_file(fd, ((t_pe32 *)pe)->dos_header, sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing DOS Stub ...");
        write_to_file(fd, ((t_pe32 *)pe)->dos_stub, ((t_pe32 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing PE header ...");
        write_to_file(fd, ((t_pe32 *)pe)->pe_header, sizeof(IMAGE_NT_HEADERS32));

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, &(((t_pe32 *)pe)->section_header[i]), sizeof(IMAGE_SECTION_HEADER));
        }
        add_zero_padding(fd, ((t_pe32 *)pe)->section_header[0].PointerToRawData);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_pe32 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, ((t_pe32 *)pe)->section_data[i], ((t_pe32 *)pe)->section_header[i].SizeOfRawData);
        }
    }
    else {
        log_verbose("Writing DOS header ...");
        write_to_file(fd, ((t_pe64 *)pe)->dos_header, sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing DOS Stub ...");
        write_to_file(fd, ((t_pe64 *)pe)->dos_stub, ((t_pe64 *)pe)->dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER));

        log_verbose("Writing PE header ...");
        write_to_file(fd, ((t_pe64 *)pe)->pe_header, sizeof(IMAGE_NT_HEADERS64));

        log_verbose("Writing Sections headers ...");
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, &(((t_pe64 *)pe)->section_header[i]), sizeof(IMAGE_SECTION_HEADER));
        }
        add_zero_padding(fd, ((t_pe64 *)pe)->section_header[0].PointerToRawData);

        log_verbose("Writing Sections data ...");
        for (int i = 0; i < ((t_pe64 *)pe)->pe_header->FileHeader.NumberOfSections; i++) {
            write_to_file(fd, ((t_pe64 *)pe)->section_data[i], ((t_pe64 *)pe)->section_header[i].SizeOfRawData);
        }
    }

    close(fd);

    return 1;
}

```

`src/STUB/amd64_aes_128_ecb_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

aes_128_ecb_decrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; sys_write
    mov rax, 1
	mov	rdi, rax
	lea	rsi, [rel msg]
	mov	rdx, msg_len
	syscall

    ; We save pie offset
    lea r12, [rel aes_128_ecb_decrypt]
    sub r12, [rel info_offset]

    jmp start_unpacking

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    movdqu xmm1, [rel info_key]

    ; Load .text address in rax
    mov rax, [rel info_addr]
    add rax, r12

    ; For later
    mov rdx, [rel info_size]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    ;  Getting ready to use with the Equivalent Inverse Cipher
    ; 9 times - Not on the last one
    aesimc xmm4, xmm4
    aesimc xmm5, xmm5
    aesimc xmm6, xmm6
    aesimc xmm7, xmm7
    aesimc xmm8, xmm8
    aesimc xmm9, xmm9
    aesimc xmm10, xmm10
    aesimc xmm11, xmm11
    aesimc xmm12, xmm12

	xor r8, r8

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rdx, 16
aes_loop:
    ; Load .text encrypted section block in xmm15
    movdqu xmm15, [rax + r8]

    pxor xmm15, xmm13 ; First xor
    aesdec xmm15, xmm12 ; Round 1
    aesdec xmm15, xmm11 ; Round 2
    aesdec xmm15, xmm10 ; Round 3
    aesdec xmm15, xmm9 ; Round 4
    aesdec xmm15, xmm8 ; Round 5
    aesdec xmm15, xmm7 ; Round 6
    aesdec xmm15, xmm6 ; Round 7
    aesdec xmm15, xmm5 ; Round 8
    aesdec xmm15, xmm4 ; Round 9
    aesdeclast xmm15, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rax + r8], xmm15

    add r8, 16
    cmp rdx, r8
    jle clean
    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_key1:      dq  0xbbbbbbbbbbbbbbbb
info_addr:	    dq	0xcccccccccccccccc
info_size:	    dq  0xdddddddddddddddd
info_offset:    dq  0xeeeeeeeeeeeeeeee


```

`src/STUB/amd64_aes_128_ecb_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

aes_128_ecb_decrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall on windows seems like a pain
    ;mov rax, 1
	;mov	rdi, rax
	;lea	rsi, [rel msg]
	;mov	rdx, msg_len
	;syscall

    ; We save pie offset
    lea r12, [rel aes_128_ecb_decrypt]
    sub r12, [rel info_offset]

    jmp start_unpacking

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    movdqu xmm1, [rel info_key]

    ; Load .text address in rax
    mov rax, [rel info_addr]
    add rax, r12

    ; For later
    mov rdx, [rel info_size]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    ;  Getting ready to use with the Equivalent Inverse Cipher
    ; 9 times - Not on the last one
    aesimc xmm4, xmm4
    aesimc xmm5, xmm5
    aesimc xmm6, xmm6
    aesimc xmm7, xmm7
    aesimc xmm8, xmm8
    aesimc xmm9, xmm9
    aesimc xmm10, xmm10
    aesimc xmm11, xmm11
    aesimc xmm12, xmm12

	xor r8, r8

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rdx, 16
aes_loop:
    ; Load .text encrypted section block in xmm15
    movdqu xmm15, [rax + r8]

    pxor xmm15, xmm13 ; First xor
    aesdec xmm15, xmm12 ; Round 1
    aesdec xmm15, xmm11 ; Round 2
    aesdec xmm15, xmm10 ; Round 3
    aesdec xmm15, xmm9 ; Round 4
    aesdec xmm15, xmm8 ; Round 5
    aesdec xmm15, xmm7 ; Round 6
    aesdec xmm15, xmm6 ; Round 7
    aesdec xmm15, xmm5 ; Round 8
    aesdec xmm15, xmm4 ; Round 9
    aesdeclast xmm15, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rax + r8], xmm15

    add r8, 16
    cmp rdx, r8
    jle clean
    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_key1:      dq  0xbbbbbbbbbbbbbbbb
info_addr:	    dq	0xcccccccccccccccc
info_size:	    dq  0xdddddddddddddddd
info_offset:    dq  0xeeeeeeeeeeeeeeee


```

`src/STUB/amd64_xor_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall : rax
    ; parameter order : rdi, rsi, rdx, r10, r8, r9
    ; sys_write
    mov rax, 1
	mov	rdi, rax
	lea	rsi, [rel msg]
	mov	rdx, msg_len
	syscall

    ; We save pie offset
    lea r12, [rel loader_entry_point]
    sub r12, [rel info_offset]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
	mov	rax, [rel info_addr]
	mov	rcx, [rel info_size]
	mov	rdx, [rel info_key]

    ; We add PIE offset
	add rax, r12
	add	rcx, rax

.loop:
	xor	byte [rax], dl
	ror	rdx, 8
	inc	rax
	cmp	rax, rcx
	jnz	.loop

	popx rax, rdi, rsi, rsp, rdx, rcx
	popfq
	jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_addr:	    dq	0xbbbbbbbbbbbbbbbb
info_size:	    dq  0xcccccccccccccccc
info_offset:    dq  0xdddddddddddddddd

```

`src/STUB/amd64_xor_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; syscall on windows seems like a pain
    ;mov rax, 1
	;mov	rdi, rax
	;lea	rsi, [rel msg]
	;mov	rdx, msg_len
	;syscall

    ; We save pie offset
    lea r12, [rel loader_entry_point]
    sub r12, [rel info_offset]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
	mov	rax, [rel info_addr]
	mov	rcx, [rel info_size]
	mov	rdx, [rel info_key]

    ; We add PIE offset
	add rax, r12
	add	rcx, rax

.loop:
	xor	byte [rax], dl
	ror	rdx, 8
	inc	rax
	cmp	rax, rcx
	jnz	.loop

	popx rax, rdi, rsi, rsp, rdx, rcx
	popfq
	jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dq	0xaaaaaaaaaaaaaaaa
info_addr:	    dq	0xbbbbbbbbbbbbbbbb
info_size:	    dq  0xcccccccccccccccc
info_offset:    dq  0xdddddddddddddddd

```

`src/STUB/i386_aes_128_ecb_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 32]

aes_128_ecb_decrypt:
	pushx eax, edi, esi, esp, edx, ecx, ebx

	; sys_write
    call get_my_loc
    sub edx, next_i - msg
    mov ecx, edx
    mov edx, msg_len
    mov ebx, 1
    mov eax, 4
    int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - aes_128_ecb_decrypt
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

    jmp start_unpacking

; Uses xmm1, xmm2 and xmm3
key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	; We add PIE offset
    add eax, ebx
    call get_my_loc
	sub edx, next_i - info_key
    movdqu xmm1, [edx]
    call get_my_loc
	sub edx, next_i - info_size
	mov	edx, [edx]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; We don't have enough xmm registers in x86 to store every round keys, so we push them to the stack

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x2, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x4, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x8, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x10, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x20, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x40, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x80, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x1b, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x36, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4

	xor ecx, ecx

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub edx, 16
aes_loop:
    movdqu xmm1, xmm0

    ; Load .text encrypted section block in xmm15
    movdqu xmm7, [eax + ecx]

    movdqu  xmm4, oword [esp]
    add     esp, 16
    pxor xmm7, xmm4 ; First xor
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 1
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 2
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 3
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 4
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 5
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 6
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 7
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 8
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 9
    aesdeclast xmm7, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [eax + ecx], xmm7

    ; Restore the stack for another loop
    sub esp, 160

    add ecx, 16
    cmp edx, ecx
    jle clean
    jmp aes_loop

clean:
    ; Reset the stack
    add esp, 160
	popx eax, edi, esi, esp, edx, ecx, ebx
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dd	0xaaaaaaaa
info_key1:	    dd	0xaaaaaaaa
info_key2:	    dd	0xaaaaaaaa
info_key3:	    dd	0xaaaaaaaa
info_addr:	    dd	0xcccccccc
info_size:	    dd  0xdddddddd
info_offset:    dd  0xeeeeeeee


```

`src/STUB/i386_aes_128_ecb_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 32]

aes_128_ecb_decrypt:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall on windows seems like a pain
    ;call get_my_loc
    ;sub edx, next_i - msg
	;mov ecx, edx
	;mov edx, msg_len
	;mov ebx, 1
    ;mov eax, 4
    ;int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - aes_128_ecb_decrypt
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

    jmp start_unpacking

; Uses xmm1, xmm2 and xmm3
key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	; We add PIE offset
    add eax, ebx
    call get_my_loc
	sub edx, next_i - info_key
    movdqu xmm1, [edx]
    call get_my_loc
	sub edx, next_i - info_size
	mov	edx, [edx]

    ; Move the key in xmm0 to backup
    movdqu xmm0, xmm1

    ; We don't have enough xmm registers in x86 to store every round keys, so we push them to the stack

    ; Generating round keys

    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x2, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x4, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x8, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x10, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x20, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x40, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x80, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x1b, xmm4
    aesimc xmm4, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4
    aes_128_keygenassist 0x36, xmm4
    sub esp, 16
    movdqu oword [esp], xmm4

	xor ecx, ecx

; Because we can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub edx, 16
aes_loop:
    movdqu xmm1, xmm0

    ; Load .text encrypted section block in xmm15
    movdqu xmm7, [eax + ecx]

    movdqu  xmm4, oword [esp]
    add     esp, 16
    pxor xmm7, xmm4 ; First xor
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 1
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 2
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 3
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 4
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 5
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 6
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 7
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 8
    movdqu  xmm4, oword [esp]
    add     esp, 16
    aesdec xmm7, xmm4 ; Round 9
    aesdeclast xmm7, xmm0 ; Round 10

    ; Load the encrypted .text section block
    movdqu [eax + ecx], xmm7

    ; Restore the stack for another loop
    sub esp, 160

    add ecx, 16
    cmp edx, ecx
    jle clean
    jmp aes_loop

clean:
    ; Reset the stack
    add esp, 160
	popx eax, edi, esi, esp, edx, ecx, ebx
    jmp	0xFFFFFFFF

; random values here, to be patched
info_start:
info_key:	    dd	0xaaaaaaaa
info_key1:	    dd	0xaaaaaaaa
info_key2:	    dd	0xaaaaaaaa
info_key3:	    dd	0xaaaaaaaa
info_addr:	    dd	0xcccccccc
info_size:	    dd  0xdddddddd
info_offset:    dd  0xeeeeeeee


```

`src/STUB/i386_xor_linux_elf_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point32:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall : eax
    ; parameters order : ebx, ecx, edx, esi, edi, ebp
    ; sys_write
    call get_my_loc
    sub edx, next_i - msg
	mov ecx, edx
	mov edx, msg_len
	mov ebx, 1
    mov eax, 4
    int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - loader_entry_point32
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	call get_my_loc
	sub edx, next_i - info_size
	mov	ecx, [edx]
	call get_my_loc
	sub edx, next_i - info_key
	mov	edx, [edx]

    ; We add PIE offset
	add eax, ebx
	add	ecx, eax

.loop:
	xor	byte [eax], dl
	ror	edx, 4
	inc	eax
	cmp	eax, ecx
	jnz	.loop

	popx eax, edi, esi, esp, edx, ecx, ebx

	jmp	0xFFFFFFF

; Random values here, to be patched
info_key:	    dd	0xaaaaaaaa
info_addr:	    dd	0xbbbbbbbb
info_size:	    dd  0xcccccccc
info_offset:    dd  0xdddddddd

```

`src/STUB/i386_xor_win_pe_loader.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

section .text

loader_entry_point32:
	pushx eax, edi, esi, esp, edx, ecx, ebx

    ; syscall on windows seems like a pain
    ;call get_my_loc
    ;sub edx, next_i - msg
	;mov ecx, edx
	;mov edx, msg_len
	;mov ebx, 1
    ;mov eax, 4
    ;int 0x80

    ; We save pie offset
    call get_my_loc
    sub edx, next_i - loader_entry_point32
    mov ebx, edx
    call get_my_loc
    sub edx, next_i - info_offset
    sub ebx, [edx]

	jmp	start_unpacking

msg	db	"[Unpacking...]", 10, 0
msg_len	equ	$ - msg

get_my_loc:
    call next_i

next_i:
    pop edx
    ret

start_unpacking:
    call get_my_loc
    sub edx, next_i - info_addr
	mov	eax, [edx]
	call get_my_loc
	sub edx, next_i - info_size
	mov	ecx, [edx]
	call get_my_loc
	sub edx, next_i - info_key
	mov	edx, [edx]

    ; We add PIE offset
	add eax, ebx
	add	ecx, eax

.loop:
	xor	byte [eax], dl
	ror	edx, 4
	inc	eax
	cmp	eax, ecx
	jnz	.loop

	popx eax, edi, esi, esp, edx, ecx, ebx

	jmp	0xFFFFFFF

; Random values here, to be patched
info_key:	    dd	0xaaaaaaaa
info_addr:	    dd	0xbbbbbbbb
info_size:	    dd  0xcccccccc
info_offset:    dd  0xdddddddd

```

`src/common/aes_128_ecb_encryption.asm`:

```asm
%macro pushx 1-*
 %rep %0
   push %1
   %rotate 1
 %endrep
%endmacro

%macro popx 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro aes_128_keygenassist 1-2
    aeskeygenassist xmm2, xmm1, %1
    call key_expansion_128
    movdqu %2, xmm1
%endmacro

[BITS 64]

global aes_128_ecb_encrypt:function

key_expansion_128:
    pshufd xmm2, xmm2, 0xff
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    vpslldq xmm3, xmm1, 0x4
    pxor xmm1, xmm3
    pxor xmm1, xmm2
    ret

; Used for padding
; PKCS PADDING
;aes_pkcs_padding:
;    sub r9, rsi
;    mov rcx, 16
;    sub rcx, r9
;
;    ; push
;    sub rsp, 16
;    movdqu oword [rsp], xmm15
;.aes_pkcs_pad_loop:
;    mov [rsp+rcx], r9b
;    inc rcx
;    cmp rcx, 16
;    jnz .aes_pkcs_pad_loop
;
;    ; pop
;    movdqu  xmm15, oword [rsp]
;    add     rsp, 16
;
;    jmp after_padding


; void aes_128_ecb_encrypt(char *data, size_t data_size, char *key, size_t key_size)
;                           rdi             rsi         rdx             r10
aes_128_ecb_encrypt:
	pushfq
	pushx rax, rdi, rsi, rsp, rdx, rcx

    ; TODO
	; cmp r10, 128
    ; cmp data_size, ?

    ; 128 bit key
    movdqu xmm1, [rdx]

    ; Move the key in xmm0
    movdqu xmm0, xmm1

    ; Generating round keys
    ; 10 times
    aes_128_keygenassist 0x1, xmm4
    aes_128_keygenassist 0x2, xmm5
    aes_128_keygenassist 0x4, xmm6
    aes_128_keygenassist 0x8, xmm7
    aes_128_keygenassist 0x10, xmm8
    aes_128_keygenassist 0x20, xmm9
    aes_128_keygenassist 0x40, xmm10
    aes_128_keygenassist 0x80, xmm11
    aes_128_keygenassist 0x1b, xmm12
    aes_128_keygenassist 0x36, xmm13

    xor r8, r8

; We can't fully encrypt the .text data when it's not a 16bytes multiple - TOFIX
    sub rsi, 16
aes_loop:
    ; Load .text plaintext section block in xmm15
    movdqu xmm15, [rdi + r8]

; Used for padding
;
;    mov r9, r8
;    add r9, 16
;    cmp r9, rsi
;    jg aes_pkcs_padding
;after_padding:

    ; Whitening step - Round 0
    pxor xmm15, xmm0 ; First xor

    aesenc xmm15, xmm4 ; Round 1
    aesenc xmm15, xmm5 ; Round 2
    aesenc xmm15, xmm6 ; Round 3
    aesenc xmm15, xmm7 ; Round 4
    aesenc xmm15, xmm8 ; Round 5
    aesenc xmm15, xmm9 ; Round 6
    aesenc xmm15, xmm10 ; Round 7
    aesenc xmm15, xmm11 ; Round 8
    aesenc xmm15, xmm12 ; Round 9
    aesenclast xmm15, xmm13 ; Round 10

    ; Load the encrypted .text section block
    movdqu [rdi + r8], xmm15

    add r8, 16
    cmp rsi, r8
    jle clean
    jmp aes_loop

; Used for padding
;    mov r9, r8
;    add r9, 16
;    cmp r9, rsi
;    jg padded_block
;    ; Load the encrypted .text section block
;    movdqu [rdi + r8], xmm15
;    jmp end_aes_loop
;padded_block:
;    mov rcx, rsi
;    sub rcx, r8
;    ; push
;    sub rsp, 16
;    movdqu oword [rsp], xmm15
;padded_block_loop:
;    mov rdx, [rdi+r8]
;    add rsp, 1
;    mov [rdx+rcx], spl
;    inc rcx
;    cmp rcx,16
;    jnz padded_block_loop
;    add rsp, 16
;end_aes_loop:
;    add r8, 16
;    jmp aes_loop

clean:
    popx rax, rdi, rsi, rsp, rdx, rcx
    popfq
    ret


```

`src/common/cipher_functions.c`:

```c
#pragma clang diagnostic push
#pragma ide diagnostic ignored "hicpp-signed-bitwise"
//
// Created by silentvoid on 2/25/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "cipher_functions.h"

#include "log.h"

uint32_t generate_random_key32() {
    // Note: rand() is not a really good pRNG generator but that should be ok in our case
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)
    uint32_t key = rand(); // NOLINT(cert-msc30-c,cert-msc50-cpp)
    return key;
}

uint64_t generate_random_key64() {
    // Note: rand() is not a really good pRNG generator but that should be ok in our case
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)
    uint64_t key = rand(); // NOLINT(cert-msc30-c,cert-msc50-cpp)
    return key;
}

void generate_random_key128() {
    srand(time(NULL)); // NOLINT(cert-msc32-c,cert-msc51-cpp)

    uint32_t first = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t second = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t third = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)
    uint32_t fourth = rand();// NOLINT(cert-msc30-c,cert-msc50-cpp)

    memcpy(cipher_key128, &first, sizeof(uint32_t));
    memcpy(cipher_key128+4, &second, sizeof(uint32_t));
    memcpy(cipher_key128+8, &third, sizeof(uint32_t));
    memcpy(cipher_key128+12, &fourth, sizeof(uint32_t));

    //uint32_t test = 0x41414141;
    //memcpy(key, &test, sizeof(uint32_t));
    //memcpy(key+4, &test, sizeof(uint32_t));
    //memcpy(key+8, &test, sizeof(uint32_t));
    //memcpy(key+12, &test, sizeof(uint32_t));
}

uint32_t rotate_right32(uint32_t value) {
    // https://www.geeksforgeeks.org/rotate-bits-of-an-integer/
    // https://blog.regehr.org/archives/1063
    uint32_t n_rotations = sizeof(uint32_t);
    uint32_t int_bits = sizeof(uint32_t) * 8;
    return (value >> n_rotations) | (value << (int_bits - n_rotations));
}

uint64_t rotate_right64(uint64_t value) {
    // https://www.geeksforgeeks.org/rotate-bits-of-an-integer/
    // https://blog.regehr.org/archives/1063
    uint64_t n_rotations = sizeof(uint64_t);
    uint64_t int_bits = sizeof(uint64_t) * 8;
    return (value >> n_rotations) | (value << (int_bits - n_rotations));
}


int xor_encrypt32(char *data, size_t data_size, uint32_t key) {
    for(int i = 0; i < (int)data_size; i++) {
        data[i] = (char)(data[i] ^ key);
        key = rotate_right32(key);
    }

    return 1;
}

int xor_encrypt64(char *data, size_t data_size, uint64_t key) {
    for(int i = 0; i < (int)data_size; i++) {
        data[i] = (char)(data[i] ^ key);
        key = rotate_right64(key);
    }

    return 1;
}

#pragma clang diagnostic pop
```

`src/common/file_functions.c`:

```c
//
// Created by silentvoid on 3/16/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_struct.h"

#include "log.h"

// To keep track of the bytes written for the padding
size_t offset = 0;

/*
 * Mapping file in memory using mmap
 *
 */
int allocate_file(char *file, void **file_data, size_t *file_data_size) {
    int fd = open(file, O_RDONLY);
    if(fd < 0) {
        log_error("open() failure");
        return -1;
    }

    int size = lseek(fd, 0, SEEK_END);
    if(size < 0) {
        close(fd);
        log_error("lseek() failure");
        return -1;
    }
    *file_data_size = size;

    *file_data = mmap(NULL, *file_data_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0); // NOLINT(hicpp-signed-bitwise)
    if(*file_data == MAP_FAILED) {
        close(fd);
        log_error("mmap() failure");
        return -1;
    }
    close(fd);

    return 1;
}

int write_to_file(int fd, void *data, size_t data_size) {
    size_t n_bytes;
    if((n_bytes = write(fd, data, data_size)) != data_size) {
        log_error("write() failure");
        return -1;
    }
    offset += n_bytes;

    return 1;
}

int dump_to_file(char *filename, char *data, size_t data_size) {
    FILE *dump;
    dump = fopen(filename, "w");
    if(dump == NULL) {
        log_error("Error dumping file");
        return -1;
    }
    fwrite(data, data_size, 1, dump);
    fclose(dump);

    return 1;
}

void add_zero_padding(int fd, size_t end_offset) {
    char c = 0;
    while(offset < end_offset) {
        write_to_file(fd, &c, sizeof(c));
    }
}

int check_magic_bytes(char *file_data, size_t file_data_size) {
    // TODO: Random value - See for a coherent value
    if(file_data_size < 50) {
        log_error("Invalid file size");
        return UNKNOWN_FILE;
    }

    if(strncmp(file_data, ELFMAG, SELFMAG) == 0) {
        return ELF_FILE;
    }
    else if(strncmp(file_data, STR_DOSMAG, SSTR_DOSMAG) == 0) {
        return PE_FILE;
    }
    else {
        return UNKNOWN_FILE;
    }
}

int get_elf_arch(const char *file_data, size_t file_data_size) {
    // TODO: Maybe improve this
    if(file_data_size < sizeof(Elf32_Ehdr)) {
        log_error("Invalid file size");
        return UNKNOWN_ARCH;
    }

    if(file_data[EI_CLASS] == ELFCLASS32) {
        return x32_ARCH;
    }
    else if(file_data[EI_CLASS] == ELFCLASS64) {
        return x64_ARCH;
    }
    else {
        return UNKNOWN_ARCH;
    }
}

int get_pe_arch(const char *file_data, size_t file_data_size) {
    // TODO: Maybe improve this
    if(file_data_size < sizeof(IMAGE_DOS_HEADER) + DOS_STUB_SIZE + sizeof(IMAGE_NT_HEADERS32)) {
        log_error("Invalid file size");
        return UNKNOWN_ARCH;
    }

    size_t machine_type_offset = sizeof(IMAGE_DOS_HEADER) + DOS_STUB_SIZE + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER);
    uint16_t arch_value = *((uint16_t *)(file_data+machine_type_offset));

    if(arch_value == PE32MAG) {
        return x32_ARCH;
    }
    else if(arch_value == PE64MAG) {
        return x64_ARCH;
    }
    else {
        return UNKNOWN_ARCH;
    }
}
```

`src/common/loader_functions.c`:

```c
//
// Created by silentvoid on 3/18/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "loader_functions.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_allocation.h"
#include "packer_config.h"

#include "log.h"

uint64_t text_data_size64;
uint64_t text_entry_point64;
uint64_t cipher_key64;
uint64_t loader_offset64;

uint32_t text_data_size32;
uint32_t text_entry_point32;
uint32_t cipher_key32;
uint32_t loader_offset32;

unsigned char cipher_key128[17];

// Set globals variables for nasm code
char * patch_loader() {
    char *loader;

    if(packer_config.arch == x32_ARCH) {
        loader = malloc(packer_config.loader_size);
        if(loader == NULL) {
            log_error("malloc() failure");
            return NULL;
        }
        memset(loader, 0x0, packer_config.loader_size);

        // Copy the loader asm entry point
        memcpy(loader, packer_config.loader_stub, packer_config.loader_size);

        if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET32_AES, cipher_key128, 16);
        }
        else {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET32, &cipher_key32, sizeof(uint32_t));
        }
        memcpy(loader + packer_config.loader_size - TEXT_ENTRY_POINT_OFFSET32, &text_entry_point32, sizeof(uint32_t));
        memcpy(loader + packer_config.loader_size - TEXT_DATA_SIZE_OFFSET32, &text_data_size32, sizeof(uint32_t));
        memcpy(loader + packer_config.loader_size - LOADER_OFFSET_OFFSET32, &loader_offset32, sizeof(uint32_t));
    }
    else {
        loader = malloc(packer_config.loader_size);
        if(loader == NULL) {
            log_error("malloc() failure");
            return NULL;
        }
        memset(loader, 0x0, packer_config.loader_size);

        // Copy the loader asm entry point
        memcpy(loader, packer_config.loader_stub, packer_config.loader_size);

        if(strcmp(packer_config.cipher, "aes128_ecb") == 0) {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET64_AES, cipher_key128, 16);
        }
        else {
            memcpy(loader + packer_config.loader_size - CIPHER_KEY_OFFSET64, &cipher_key64, sizeof(uint64_t));
        }
        memcpy(loader + packer_config.loader_size - TEXT_ENTRY_POINT_OFFSET64, &text_entry_point64, sizeof(uint64_t));
        memcpy(loader + packer_config.loader_size - TEXT_DATA_SIZE_OFFSET64, &text_data_size64, sizeof(uint64_t));
        memcpy(loader + packer_config.loader_size - LOADER_OFFSET_OFFSET64, &loader_offset64, sizeof(uint64_t));
    }

    if(packer_config.debug_mode) {
        log_debug("Dumping loader ...");
        dump_to_file("loader.dmp", loader, packer_config.loader_size);
    }

    return loader;
}

```

`src/common/packer_config.c`:

```c
//
// Created by silentvoid on 4/10/20.
// Copyright (c) 2020 SilentVoid. All rights reserved.
//

#include "packer_config.h"
#include "all_loaders.h"
#include "cipher_functions.h"
#include "file_functions.h"
#include "elf_allocation.h"
#include "pe_allocation.h"

#include "log.h"

struct s_packer_config packer_config;

int fill_packer_config(char *packing_method, char *cipher, int arch, int file_type, int debug_mode) {
    strncpy(packer_config.packing_method, packing_method, MAX_PACKING_METHOD_LENGTH);
    strncpy(packer_config.cipher, cipher, MAX_CIPHER_LENGTH);
    packer_config.arch = arch;
    packer_config.debug_mode = debug_mode;

    if(arch == x32_ARCH) {
        if (file_type == ELF_FILE) {
            if (strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = I386_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_AES_128_ECB_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(i386_aes_128_ecb_linux_elf_loader_stub[0]);
            } else if (strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = I386_XOR_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_XOR_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(i386_xor_linux_elf_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        } else if (file_type == PE_FILE) {
            if (strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = I386_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_AES_128_ECB_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(i386_aes_128_ecb_win_pe_loader_stub[0]);
            } else if (strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = I386_XOR_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = I386_XOR_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(i386_xor_win_pe_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        } else {
            log_error("Unknown file type");
            return -1;
        }
        return 1;
    }
    else if(arch == x64_ARCH) {
        if(file_type == ELF_FILE) {
            if(strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = AMD64_AES_128_ECB_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_AES_128_ECB_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_aes_128_ecb_linux_elf_loader_stub[0]);
            }
            else if(strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = AMD64_XOR_LINUX_ELF_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_XOR_LINUX_ELF_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_xor_linux_elf_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        }
        else if(file_type == PE_FILE) {
            if(strcmp(cipher, "aes128_ecb") == 0) {
                packer_config.loader_infos_size = AMD64_AES_128_ECB_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_AES_128_ECB_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = amd64_aes_128_ecb_win_pe_loader_stub;
            }
            else if(strcmp(cipher, "xor") == 0) {
                packer_config.loader_infos_size = AMD64_XOR_WIN_PE_LOADER_INFOS_SIZE;
                packer_config.loader_size = AMD64_XOR_WIN_PE_LOADER_SIZE;
                packer_config.loader_stub = &(amd64_xor_win_pe_loader_stub[0]);
            }
            else {
                log_error("Unknown cipher");
                return -1;
            }
        }
        else {
            log_error("Unknown file type");
            return -1;
        }
    }

    return 1;
}


```

`src/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>

#include "main.h"
#include "elf_packing.h"
#include "pe_packing.h"
#include "file_functions.h"
#include "packer_config.h"

#include "argtable3.h"
#include "log.h"

struct arg_lit *verb, *help, *version, *debug;
struct arg_str *cipher, *packing_method;
struct arg_file *output, *file;
struct arg_end *end;

void display_argtable_help(char *progname, void **argtable) {
    printf("Usage: %s", progname);
    arg_print_syntax(stdout, argtable, "\n");
    arg_print_glossary(stdout, argtable, "  %-25s %s\n");
    exit(0);
}

int main(int argc, char** argv) {
        void *argtable[] = {
                help     = arg_litn("h", "help", 0, 1, "Display this help and exit"),
                version  = arg_litn("V", "version", 0, 1, "Display version info and exit"),
                verb     = arg_litn("v", "verbose", 0, 1, "Verbose output"),
                debug    = arg_litn("d", "debug", 0, 1, "Debug mode"),
                file     = arg_filen("f", "file", "file", 0, 1, "File to pack"),
                cipher   = arg_strn("c", "cipher", "<xor, aes128_ecb>", 0, 1, "Cipher method to use"),
                packing_method = arg_strn("m", "method", "<section_insertion, code_cave, silvio_infection>", 0, 1, "Method to pack the binary"),
                output   = arg_filen("o", "output", "file", 0, 1, "Output file"),
                end      = arg_end(20),
        };

        char *progname = "Silent_Packer";
        char *progversion = "0.1";
        char *progdate = "2020";
        char *author_name = "SilentVoid";

        output->filename[0] = NULL;
        file->filename[0] = NULL;
        cipher->sval[0] = NULL;
        packing_method->sval[0] = NULL;

        int nerrors;
        nerrors = arg_parse(argc, argv, argtable);

        verbose = verb->count;

        if(help->count > 0) {
            display_argtable_help(progname, argtable);
        }

        if(version->count > 0) {
                printf("%s %s\n", progname, progversion);
                printf("Copyright (C) %s %s\n", progdate, author_name);
                exit(0);
        }

        if(nerrors > 0) {
                arg_print_errors(stdout, end, progname);
                printf("Try '%s --help' for more informations.\n", progname);
                exit(1);
        }

        if(file->count > 0 && cipher->count > 0 && packing_method->count > 0) {
            if(
                    (strcmp(cipher->sval[0], "xor") != 0) &&
                    (strcmp(cipher->sval[0], "aes128_ecb") != 0)
            ) {
                log_error("Wrong cipher method");
                display_argtable_help(progname, argtable);
            }

            if(
                    (strcmp(packing_method->sval[0], "silvio_infection") != 0) &&
                    (strcmp(packing_method->sval[0], "code_cave") != 0) &&
                    (strcmp(packing_method->sval[0], "section_insertion") != 0)
            ) {
                log_error("Wrong packing method");
                display_argtable_help(progname, argtable);
            }

            void *file_data;
            size_t file_data_size;

            log_info("Allocating file in memory ...");
            if(allocate_file((char *) file->filename[0], &file_data, &file_data_size) == -1) {
                log_error("Error during file allocation");
                return -1;
            }

            int file_type = check_magic_bytes(file_data, file_data_size);
            if(file_type == ELF_FILE) {
                int arch = get_elf_arch(file_data, file_data_size);
                if(arch == UNKNOWN_ARCH) {
                    munmap(file_data, file_data_size);
                    log_error("Couldn't detect the architecture of the file");
                    return -1;
                }

                if(fill_packer_config((char *) packing_method->sval[0], (char *) cipher->sval[0], arch, file_type, debug->count) == -1) {
                    munmap(file_data, file_data_size);
                    log_error("Error during packer configuration");
                    return -1;
                }

                int p_status = pack_elf((char *) file->filename[0], file_data, file_data_size, (char *) output->filename[0]);
                if(p_status == -1) {
                    log_error("An error occured during the ELF packing");
                }
            }
            else if(file_type == PE_FILE) {
                int arch = get_pe_arch(file_data, file_data_size);
                if(arch == UNKNOWN_ARCH) {
                    munmap(file_data, file_data_size);
                    log_error("Couldn't detect the architecture of the file");
                    return -1;
                }

                if(strcmp(packing_method->sval[0], "silvio_infection") == 0) {
                    munmap(file_data, file_data_size);
                    log_error("Silvio infection is not available for PE files");
                    return -1;
                }

                if(fill_packer_config((char *) packing_method->sval[0], (char *) cipher->sval[0], arch, file_type, debug->count) == -1) {
                    munmap(file_data, file_data_size);
                    log_error("Error during packer configuration");
                    return -1;
                }

                int p_status = pack_pe((char *) file->filename[0], file_data, file_data_size, (char *) output->filename[0]);
                if(p_status == -1) {
                    log_error("An error occured during the PE packing");
                }
             }
            else {
                log_error("Invalid file type");
            }
        }
        else {
            display_argtable_help(progname, argtable);
        }

        arg_freetable(argtable, sizeof(argtable) / sizeof(argtable[0]));
        return 0;
}

```