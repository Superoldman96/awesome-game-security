Project Path: arc_gmh5225_Zodiak_2gxbwdvl

Source Tree:

```txt
arc_gmh5225_Zodiak_2gxbwdvl
├── README.md
├── USAGE.md
├── fix.reg
└── src
    ├── Driver
    │   ├── Driver.vcxproj
    │   ├── Driver.vcxproj.filters
    │   ├── Driver.vcxproj.user
    │   ├── data.c
    │   ├── data.h
    │   ├── export.c
    │   ├── export.h
    │   ├── game.c
    │   ├── game.h
    │   ├── gdi.c
    │   ├── gdi.h
    │   ├── general.h
    │   ├── main.c
    │   ├── memory.c
    │   ├── memory.h
    │   ├── mouse.asm
    │   ├── mouse.c
    │   ├── mouse.h
    │   ├── pch.h
    │   ├── spoof.c
    │   ├── spoof.h
    │   ├── struct.h
    │   ├── utils.c
    │   └── utils.h
    └── Zodiak.sln

```

`README.md`:

```md
<p align="center"><img src="https://i.imgur.com/7YOOfqF.png" align="center" alt="Zodiak" width="250" align="center"></p>

# Zodiak
**Zodiak** is a full kernel driver cheat for CS 1.6. The cheat is designed to leave zero traces in the system to avoid detection, so there are no config files or anything else that could leave a trace.

The ESP is implemented by exporting GDI functions, allowing it to work in CS 1.6. The aimbot is created by exploiting the MouHID driver and callling own `MouseClassServiceCallback`.

In the end, it’s similar to ekknod's EC cheat but adapted for CS 1.6, because it uses the same techniques. I hope ekknod won’t mind :3

## General
- Written in C and assembly
- Automatic offsets detection
- Thread context spoofing
- Operates in a single thread

## Features
- **Aimbot** (calling "own" MouseClassServiceCallback)
- **ESP** (GDI kernel drawing without hooks)

## Usage
Since this cheat is a kernel driver, you'll need to load it. I recommend using [kdmapper](https://github.com/TheCruZ/kdmapper) as it very easy to use. If you prefer, you can also load it just in test mode.
Check out [USAGE.md](USAGE.md) for detailed instruction.

### Default Keybinds
- **F6**: Toggle Aimbot
- **F7**: Toggle ESP
- **F8**: Toggle "Only Enemies" Mode
- **Arrow Right/Left**: Adjust FOV
- **Arrow Up/Down**: Adjust Smooth


## Credits
- [Ekknod](https://github.com/ekknod) for the simple and effective GDI implementation, mouse callback trick, and overall for all his publicly available projects, especially the EC project, which I believe has one of the best structures I've seen in external cheats.
- [Unmaewei](https://github.com/unmaewei) for his Full Kernel Driver Cheat. I borrowed some general driver operations from there.

```

`USAGE.md`:

```md
## Usage Instructions

### 1. Download and Compile
You can either download and compile the project yourself or use the pre-compiled binaries provided. This will give you a `.sys` file, which is the driver you need to load.

### 2. Loading the Driver
To load the driver, you can use any compatible driver mapper. I recommend using [kdmapper](https://github.com/TheCruZ/kdmapper). Alternatively, you can load the driver in **Test Mode**.

### 3. Configuring the Game
To ensure the cheat works correctly, go to your Steam game properties and select **"Steam Legacy - Pre-25th Anniversary Build"** under the game version.

---

## Limitations
- Only works with the Steam version of the game.
- Supports only resolutions without black bars. (use -stretchaspect or -nofbo)
- Esp typically will work only in windowed fullscreen mode. But, for some it can work in fullscreen after disabling fullscreen optimization. Futhermore, if you have a two or more monitors esp will probably also work in fullscreen when second screen is turned on.

---

## Default Keybinds
- **F6**: Toggle Aimbot
- **F7**: Toggle ESP
- **F8**: Toggle "Only Enemies" Mode
- **Arrow Right/Left**: Adjust FOV
- **Arrow Up/Down**: Adjust Smooth

---

## FAQ

**Q: Which versions of Windows does the cheat support?**  
A: The cheat supports Windows 10 and 11. All versions before windows 10 are not supported.

**Q: Which version of CS 1.6 does the cheat support?**  
A: The cheat is developed specifically for the Steam version labeled **"Steam Legacy - Pre-25th Anniversary Build."**

**Q: The old ESP boxes aren’t clearing, how do I fix this?**  
A: In the project directory, there is a file named `fix.reg`. Running this file will resolve the issue if it occurs.

**Q: Why is the "Only Enemies" mode not working on some servers for some players?**  
A: The "Only Enemies" mode only works with default player models. If a player is using a custom model, the mode may not function correctly.

**Q: The ESP isn’t working for me in fullscreen mode, how can I fix this?**  
A: Cheat is not made to work in fullscreen, but sometimes it can work. Try navigating to the properties of the `hl.exe` file and disabling fullscreen optimizations. If that not work, only thing is if you have a two or more monitors, esp could work for you in fullscreen when second screen is turned on.

```

`fix.reg`:

```reg
Windows Registry Editor Version 5.00
 
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Dwm]
"OverlayTestMode"=dword:00000005
```

`src/Driver/Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{36751642-2D56-4D61-B9D8-8E5CECE086BA}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Driver</RootNamespace>
    <ProjectName>Zodiak</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>ZodiakEntry</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="data.c" />
    <ClCompile Include="export.c" />
    <ClCompile Include="game.c" />
    <ClCompile Include="gdi.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="memory.c" />
    <ClCompile Include="mouse.c" />
    <ClCompile Include="spoof.c" />
    <ClCompile Include="utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="data.h" />
    <ClInclude Include="export.h" />
    <ClInclude Include="game.h" />
    <ClInclude Include="gdi.h" />
    <ClInclude Include="general.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="mouse.h" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="spoof.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="mouse.asm">
      <ObjectFileName>$(IntDir)\mouse_asm.obj</ObjectFileName>
      <FileType>Document</FileType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`src/Driver/Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="utils.c" />
    <ClCompile Include="data.c" />
    <ClCompile Include="memory.c" />
    <ClCompile Include="mouse.c" />
    <ClCompile Include="gdi.c" />
    <ClCompile Include="game.c" />
    <ClCompile Include="spoof.c" />
    <ClCompile Include="export.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="data.h" />
    <ClInclude Include="general.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="mouse.h" />
    <ClInclude Include="gdi.h" />
    <ClInclude Include="game.h" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="spoof.h" />
    <ClInclude Include="export.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="mouse.asm" />
  </ItemGroup>
</Project>
```

`src/Driver/Driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TestCertificate>CN="WDKTestCert Z,133688085189440989" | 4F64988DBD333D985BBE80D740598D11FA6685E8</TestCertificate>
  </PropertyGroup>
</Project>
```

`src/Driver/data.c`:

```c
#include "data.h"

/* Def values */
bool bEsp = true;
bool bAimbot = true;
bool bOnlyEnemies = false;

void DataInitialize() 
{
	/* Getting hw.dll base address */
	if (!get_hw_base())
	{
		DebugPrint("hw.dll not found");
		return;
	}
	DebugPrint("hw.dll -> 0x%08X", hw_dll);

	/* Getting client.dll base address */
	if (!get_client_base())
	{
		DebugPrint("client.dll not found");
		return;
	}
	DebugPrint("client.dll -> 0x%08X", client_dll);

	/* Getting screen size */
	SpoofContext();
	GetScreenResolution(&screen_size); // for this function we need spoof context first
	RestoreContext();

	DataLoop();
}

void DataLoop()
{
	while (true)
	{
		/* Clearing entity list */
		clear_entity_list();

		/* Reading view matrix */
		if (!read_view_matrix()) 
		{
			return; // used as a check to see if the game is running
		}

		/* Spoofing our process context to the win32 context */
		SpoofContext();

		for (int i = 0; i < MAX_ENTITIES; ++i)
		{
			/* Dead Check */
			if (entity_dead(i))
			{
				continue;
			}
			
			/* Only Enemies Mode */
			if (bOnlyEnemies) 
			{
				if (entity_teammate(i))
				{
					continue;
				}
			}

			/* Making entity screen transformation */
			BOX box;
			if (!entity_screen(i, &box))
			{
				continue;
			}

			/* Drawing esp box */
			if (bEsp) 
			{
				DrawRect((LONG)box.x, (LONG)box.y, (LONG)box.w, (LONG)box.h, (unsigned char)box_color.r, (unsigned char)box_color.g, (unsigned char)box_color.b);
			}
		}

		/* Handle Key Inputs */
		HandleKeyInputs();

		/* Bringing back original context */
		RestoreContext();

		/* Make sleep do decrease cpu usage */
		NtSleep(1);
	}
}

```

`src/Driver/data.h`:

```h
#pragma once
#pragma warning(disable: 6011) // dereferencing null pointer bla bla bla
#include "pch.h"

extern bool bEsp;
extern bool bAimbot;
extern bool bOnlyEnemies;

void DataInitialize();
void DataLoop();
```

`src/Driver/export.c`:

```c
#include "export.h"

bool exports_init()
{
	QWORD win32kbase = GetModuleEntry(L"win32kbase.sys");
	if (!win32kbase)
	{
		return false;
	}

	QWORD win32kfull = GetModuleEntry(L"win32kfull.sys");
	if (!win32kfull)
	{
		return false;
	}

	NtGdiGetDeviceCaps = (GetDeviceCaps_t)GetProcAddressQ(win32kbase, "NtGdiGetDeviceCaps");
	if (!NtGdiGetDeviceCaps)
	{
		return false;
	}

	NtUserGetAsyncKeyState = (GetAsyncKeyState_t)GetProcAddressQ(win32kbase, "NtUserGetAsyncKeyState");
	if (!NtUserGetAsyncKeyState)
	{
		return false;
	}

	NtUserGetForegroundWindow = (GetForegroundWindow_t)GetProcAddressQ(win32kfull, "NtUserGetForegroundWindow");
	if (!NtUserGetForegroundWindow)
	{
		return false;
	}

	NtUserGetDC = (GetDC_t)GetProcAddressQ(win32kbase, "NtUserGetDC");
	if (!NtUserGetDC)
	{
		return false;
	}

	NtUserGetDCEx = (GetDCEx_t)GetProcAddressQ(win32kfull, "NtUserGetDCEx");
	if (!NtUserGetDCEx)
	{
		return false;
	}

	NtGdiPatBlt = (PatBlt_t)GetProcAddressQ(win32kfull, "NtGdiPatBlt");
	if (!NtGdiPatBlt)
	{
		return false;
	}

	NtGdiSelectBrush = (SelectBrush_t)GetProcAddressQ(win32kbase, "GreSelectBrush");
	if (!NtGdiSelectBrush)
	{
		return false;
	}

	NtUserReleaseDC = (ReleaseDC_t)GetProcAddressQ(win32kbase, "NtUserReleaseDC");
	if (!NtUserReleaseDC)
	{
		return false;
	}

	NtGdiCreateSolidBrush = (CreateSolidBrush_t)GetProcAddressQ(win32kfull, "NtGdiCreateSolidBrush");
	if (!NtGdiCreateSolidBrush)
	{
		return false;
	}

	NtGdiDeleteObjectApp = (DeleteObjectApp_t)GetProcAddressQ(win32kbase, "NtGdiDeleteObjectApp");
	if (!NtGdiDeleteObjectApp)
	{
		return false;
	}

	NtGdiExtTextOutW = (ExtTextOutW_t)GetProcAddressQ(win32kfull, "NtGdiExtTextOutW");
	if (!NtGdiExtTextOutW)
	{
		return false;
	}

	NtGdiHfontCreate = (HfontCreate_t)GetProcAddressQ(win32kfull, "hfontCreate");
	if (!NtGdiHfontCreate)
	{
		return false;
	}

	NtGdiSelectFont = (SelectFont_t)GetProcAddressQ(win32kfull, "NtGdiSelectFont");
	if (!NtGdiSelectFont)
	{
		return false;
	}

	return 1;
}
```

`src/Driver/export.h`:

```h
#pragma once
#include "pch.h"

/* Gdi stuff */
typedef HDC(*GetDC_t)(HWND hwnd);//verified
typedef HDC(*GetDCEx_t)(HWND hwnd, HANDLE region, ULONG flags);//verified
typedef BOOL(*PatBlt_t)(HDC hdcDest, INT x, INT y, INT cx, INT cy, DWORD dwRop);//verified
typedef HBRUSH(*SelectBrush_t)(HDC hdc, HBRUSH hbrush); //verified
typedef int (*ReleaseDC_t)(HDC hdc); //verified
typedef HBRUSH(*CreateSolidBrush_t)(COLORREF cr, HBRUSH hbr); //verified
typedef BOOL(*DeleteObjectApp_t)(HANDLE hobj); //verified
typedef BOOL(*ExtTextOutW_t)(IN HDC hDC, //verified
	IN INT 	XStart,
	IN INT 	YStart,
	IN UINT 	fuOptions,
	IN OPTIONAL LPRECT 	UnsafeRect,
	IN LPWSTR 	UnsafeString,
	IN INT 	Count,
	IN OPTIONAL LPINT 	UnsafeDx,
	IN DWORD 	dwCodePage
	);
typedef HFONT(*HfontCreate_t)(IN PENUMLOGFONTEXDVW pelfw, IN ULONG cjElfw, IN DWORD lft, IN FLONG fl, IN PVOID pvCliData); //verified
typedef HFONT(*SelectFont_t)(_In_ HDC 	hdc, //verified
	_In_ HFONT 	hfont
	);
typedef int (*GetDeviceCaps_t)(HDC a1, int a2);

/* Windows Functions */
typedef int (*GetAsyncKeyState_t)(INT a);
typedef HWND(*GetForegroundWindow_t)();

/* 
	Remember that to use these functions need to be in the win32 context ! 
*/

/* Windows Functions */
GetAsyncKeyState_t NtUserGetAsyncKeyState;
GetForegroundWindow_t NtUserGetForegroundWindow;

/* GDI Exports */
GetDC_t NtUserGetDC;
GetDCEx_t NtUserGetDCEx;
SelectBrush_t NtGdiSelectBrush;
PatBlt_t NtGdiPatBlt;
ReleaseDC_t NtUserReleaseDC;
CreateSolidBrush_t NtGdiCreateSolidBrush;
DeleteObjectApp_t NtGdiDeleteObjectApp;
ExtTextOutW_t NtGdiExtTextOutW;
HfontCreate_t NtGdiHfontCreate;
SelectFont_t NtGdiSelectFont;
GetDeviceCaps_t NtGdiGetDeviceCaps;

bool exports_init();
```

`src/Driver/game.c`:

```c
#include "game.h"

bool get_hw_base() 
{
	hw_dll = GetModuleBase32(gPid, L"\\hw.dll");

	if (hw_dll == 0)
	{
		return false;
	}
	return true;
}

bool get_client_base() 
{
	client_dll = GetModuleBase32(gPid, L"\\client.dll");

	if (client_dll == 0)
	{
		return false;
	}
	return true;
}

bool read_view_matrix()
{
	if (!read(hw_dll + dwViewMatrix, &view_matrix, sizeof(view_matrix_t)))
	{
		return false; // used as a check to see if the game is running
	}
	return true;
}

void clear_entity_list()
{
	memset(entity_list, 0, sizeof(entity_list));
}

bool entity_dead(int i)
{
	/*
		Making dead check by entity state
		If player is alive and in draw distance state always increment, we are checking old state and compering with new one
		Why not using 0x178 offset for dead check?
		Its because when player is not in draw distance, it will continuing drawing the last position
	*/
	float state = get_entity_state(i);

	if (!state) 
	{
		return true;
	}

	if (!state_list[i])
	{
		state_list[i] = state;
		return true;
	}

	if (state == state_list[i])
	{
		return true;
	}

	state_list[i] = state;

	return false;
}

bool entity_screen(int i, BOX* box)
{
	Vector3 origin = get_entity_origin(i);

	if (origin.x == 0.0f || origin.y == 0.0f || origin.z == 0.0f) {
		return false;
	}

	Vector3 origin_bottom = origin;
	Vector3 origin_top = origin;
	Vector3 origin_head = origin;

	origin_bottom.z -= ESP_BOX_BOTTOM;
	origin_top.z += ESP_BOX_TOP;
	origin_head.z += AIMBOT_HEAD; // should point on the head

	Vector2 screen_bottom, screen_top, screen_head;

	if (!w2s(screen_size, origin_bottom, &screen_bottom, view_matrix) ||
		!w2s(screen_size, origin_top, &screen_top, view_matrix) ||
		!w2s(screen_size, origin_head, &screen_head, view_matrix)) 
	{
		return false;
	}

	int height = (int)(screen_bottom.y - screen_top.y);
	int width = (int)(height / 2.4f);
	screen_top.x -= width / 2;

	if (screen_top.x <= 0.0f || screen_top.y <= 0.0f ||
		screen_bottom.x <= 0.0f || screen_bottom.y <= 0.0f) 
	{
		return false;
	}

	box->h = height;
	box->w = width;
	box->x = screen_top.x;
	box->y = screen_top.y;

	entity_list[i] = screen_head;

	return true;
}

int get_player_team() 
{
	int team;
	read(client_dll + dwLocalTeam, &team, sizeof(int));

	return team;
}

bool entity_teammate(int i) 
{
	int team = get_player_team();
	char* model = get_entity_model(i);

	/* CT */
	if (team == 2) {
		if (strstr(model, "gign") != NULL ||
			strstr(model, "gsg9") != NULL ||
			strstr(model, "urban") != NULL ||
			strstr(model, "sas") != NULL)
		{
			return true;
		}
	}

	/* T */
	else if (team == 1) {
		if (strstr(model, "terror") != NULL ||
			strstr(model, "leet") != NULL ||
			strstr(model, "arctic") != NULL ||
			strstr(model, "guerilla") != NULL)
		{
			return true;
		}
	}

	return false;
}

Vector2 get_closest_entity()
{
	Vector2 closest_enemy = { 0 };
	double closestDist = 999999.f;

	Vector2 center = { screen_size.x / 2, screen_size.y / 2 };

	int fovHalf = aimbot_fov / 2;

	int lowerX = (int)center.x - fovHalf;
	int upperX = (int)center.x + fovHalf;
	int lowerY = (int)center.y - fovHalf;
	int upperY = (int)center.y + fovHalf;

	for (int i = 0; i < MAX_ENTITIES; ++i)
	{
		if (entity_list[i].x || entity_list[i].y) 
		{
			if (entity_list[i].x > lowerX && entity_list[i].x < upperX && entity_list[i].y > lowerY && entity_list[i].y < upperY)
			{
				double dist = distance((int)entity_list[i].x, (int)entity_list[i].y, (int)center.x, (int)center.y);
				if (dist < closestDist)
				{
					closestDist = dist;
					closest_enemy = entity_list[i];
				}
			}
		}
	}

	return closest_enemy;
}

char* get_entity_model(int i) 
{
	static char model[10];
	read(hw_dll + dwEntityList + (i * m_entitySize) + m_entityModel, &model, sizeof(model));

	return model;
}

float get_entity_state(int i)
{
	float state;
	read(hw_dll + dwEntityList + (i * m_entitySize) + m_stateValue, &state, sizeof(float));

	return state;
}

Vector3 get_entity_origin(int i)
{
	Vector3 origin;
	read(hw_dll + dwEntityList + (i * m_entitySize) + m_entityOrigin, &origin, sizeof(Vector3));

	return origin;
}

void HandleKeyInputs()
{
	/* Aimbot */
	if (bAimbot)
	{
		if (NtUserGetAsyncKeyState(AIMBOT_KEY))
		{
			Vector2 closest_enemy = get_closest_entity();

			if (closest_enemy.x != 0 && closest_enemy.y != 0)
			{
				aim(closest_enemy, screen_size, aimbot_smooth);
			}
		}
	}


	{
		static count = 0;
		/* Aimbot on/off */
		if (NtUserGetAsyncKeyState(AIMBOT_TOGGLE_KEY)) // F6
		{
			count++;
			if (count == 1)
			{
				bAimbot = !bAimbot;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Esp on/off */
		if (NtUserGetAsyncKeyState(ESP_TOGGLE_KEY)) // F7
		{
			count++;
			if (count == 1)
			{
				bEsp = !bEsp;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Only Enemies on/off */
		if (NtUserGetAsyncKeyState(ONLY_ENEMIES_KEY)) // F8
		{
			count++;
			if (count == 1)
			{
				bOnlyEnemies = !bOnlyEnemies;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Smooth Increase */
		if (NtUserGetAsyncKeyState(SMOOTH_UP_KEY)) // VK_UP
		{
			count++;
			if (count == 1)
			{
				aimbot_smooth += 0.1f;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Smooth Decrease  */
		if (NtUserGetAsyncKeyState(SMOOTH_DOWN_KEY)) // VK_DOWN
		{
			count++;
			if (aimbot_smooth > 1.0 && count == 1)
			{
				aimbot_smooth -= 0.1f;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Fov Increase */
		if (NtUserGetAsyncKeyState(FOV_UP_KEY)) // VK_UP
		{
			count++;
			if (count == 1) 
			{
				aimbot_fov += 10;
			}
		}
		else
		{
			count = 0;
		}
	}

	{
		static count = 0;
		/* Fov Decrease  */
		if (NtUserGetAsyncKeyState(FOV_DOWN_KEY)) // VK_DOWN
		{
			count++;
			if (aimbot_fov > 1 && count == 1)
			{
				aimbot_fov -= 10;
			}
		}
		else
		{
			count = 0;
		}
	}
}

/* Converted w2s that I have used in cs2 cheat */
bool w2s(Vector2 screen, Vector3 position, Vector2* out, view_matrix_t matrix)
{
	/*
		Issue with CS 1.6 that view matrix in game is stored in columns, when in newer CS2 is stored with rows
		cs2    -> [0][0]  [0][1]  [0][2]  [0][3]  // First row
		cs 1.6 -> [0][0]  [1][0]  [2][0]  [3][0]  // First column
	*/
	out->x = matrix[0][0] * position.x + matrix[1][0] * position.y + matrix[2][0] * position.z + matrix[3][0];
	out->y = matrix[0][1] * position.x + matrix[1][1] * position.y + matrix[2][1] * position.z + matrix[3][1];
	float w = matrix[0][3] * position.x + matrix[1][3] * position.y + matrix[2][3] * position.z + matrix[3][3];

	if (w < 0.01f) 
	{
		return false;
	}

	float inv_w = 1.0f / w;
	out->x *= inv_w;
	out->y *= inv_w;

	out->x = (out->x + 1.0f) * 0.5f * screen.x;
	out->y = (1.0f - out->y) * 0.5f * screen.y;

	return true;
}

void aim(Vector2 position, Vector2 screen, float SmoothAmount)
{
	int TargetX = 0, TargetY = 0;

	if (position.x != 0.0f)
	{
		if (position.x > screen.x / 2)
		{
			TargetX = -(int)((screen.x / 2 - position.x) / SmoothAmount);
			if (TargetX + screen.x / 2 > screen.x) TargetX = 0;
		}

		if (position.x < screen.x / 2)
		{
			TargetX = (int)((position.x - screen.x / 2) / SmoothAmount);
			if (TargetX + screen.x / 2 < 0) TargetX = 0;
		}
	}

	if (position.y != 0.0f)
	{
		if (position.y > screen.y / 2)
		{
			TargetY = -(int)((screen.y / 2 - position.y) / SmoothAmount);
			if (TargetY + screen.y / 2 > screen.y) TargetY = 0;
		}

		if (position.y < screen.y / 2)
		{
			TargetY = (int)((position.y - screen.y / 2) / SmoothAmount);
			if (TargetY + screen.y / 2 < 0) TargetY = 0;
		}
	}

	if (TargetX != 0 || TargetY != 0) 
	{
		mouse_move((LONG)(TargetX), (LONG)(TargetY), 0);
	}
}

double distance(int x1, int y1, int x2, int y2)
{
	int dx = x2 - x1;
	int dy = y2 - y1;
	return sqrt(dx * dx + dy * dy);
}

```

`src/Driver/game.h`:

```h
#pragma once
#include "pch.h"

/* 
	Attempt to create something like an sdk for cs 1.6
	but it turned out more like a wrapper
*/

uint32_t hw_dll;
uint32_t client_dll;
view_matrix_t view_matrix;
Vector2 screen_size;
int player_team;

float state_list[MAX_ENTITIES];
Vector2 entity_list[MAX_ENTITIES];

/* Third party functions */
bool w2s(Vector2 screen, Vector3 position, Vector2* out, view_matrix_t matrix);
void aim(Vector2 position, Vector2 screen, float SmoothAmount);
double distance(int x1, int y1, int x2, int y2);

void HandleKeyInputs();

bool get_hw_base();
bool get_client_base();

bool read_view_matrix();

void clear_entity_list();

bool entity_dead(int i);
bool entity_teammate(int i);
bool entity_screen(int i, BOX* box);

Vector2 get_closest_entity();

int get_player_team();

float get_entity_state(int i);
char* get_entity_model(int i);
Vector3 get_entity_origin(int i);
```

`src/Driver/gdi.c`:

```c
#include "gdi.h"

bool FrameRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr, int thickness)
{
	HBRUSH oldbrush;
	RECT r = *lprc;

	if ((r.right <= r.left) || (r.bottom <= r.top)) return false;

	oldbrush = NtGdiSelectBrush(hDC, hbr);

	NtGdiPatBlt(hDC, r.left, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.right - thickness, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.top, r.right - r.left, thickness, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.bottom - thickness, r.right - r.left, thickness, PATCOPY);

	if (oldbrush)
		NtGdiSelectBrush(hDC, oldbrush);
	return TRUE;
}

bool FillRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr)
{
	BOOL Ret;
	HBRUSH prevhbr = NULL;


	prevhbr = NtGdiSelectBrush(hDC, hbr);
	Ret = NtGdiPatBlt(hDC, lprc->left, lprc->top, lprc->right - lprc->left,
		lprc->bottom - lprc->top, PATCOPY);

	/* Select old brush */
	if (prevhbr)
		NtGdiSelectBrush(hDC, prevhbr);

	return Ret;
}


void DrawRect(
	LONG x, LONG y, LONG w, LONG h,
	unsigned char r, unsigned char g, unsigned char b)
{
	HDC hdc = NtUserGetDCEx(0x0, 0, 1);
	if (!hdc)
		return;

	HBRUSH brush = NtGdiCreateSolidBrush(RGB(r, g, b), NULL);
	if (!brush)
	{
		NtUserReleaseDC(hdc);
		return;
	}

	RECT rect = { x, y, x + w, y + h };
	FrameRect(hdc, &rect, brush, 1); // with 1 looks better especially when there is many enemies, imo ofc 
	NtUserReleaseDC(hdc);
	NtGdiDeleteObjectApp(brush);
}

void DrawFillRect(VOID* hwnd, LONG x, LONG y, LONG w, LONG h, unsigned char r, unsigned char g, unsigned char b)
{
	if (NtUserGetForegroundWindow() != (HWND)hwnd)
	{
		return;
	}

	// HDC hdc = NtUserGetDC((HWND)hwnd);
	HDC hdc = NtUserGetDCEx(0x0, 0, 1);
	UNREFERENCED_PARAMETER(hwnd);
	if (!hdc)
		return;

	HBRUSH brush = NtGdiCreateSolidBrush(RGB(r, g, b), NULL);
	if (!brush)
		return;

	RECT rect = { x, y, x + w, y + h };
	FillRect(hdc, &rect, brush);
	NtUserReleaseDC(hdc);
	NtGdiDeleteObjectApp(brush);
}

bool GetScreenResolution(Vector2* screen_out) 
{
	HDC hdc = NtUserGetDC(NULL); // Get the device context for the entire screen
	int x = NtGdiGetDeviceCaps(hdc, HORZRES);
	int y = NtGdiGetDeviceCaps(hdc, VERTRES);
	NtUserReleaseDC(hdc);
	if (!x || !y) 
	{
		return false;
	}

	screen_out->x = (float)x;
	screen_out->y = (float)y;
	return true;
}
```

`src/Driver/gdi.h`:

```h
#pragma once
#include "pch.h"

/* 
	Remember that to use these functions we need to be in the win32 context ! 
*/
bool GetScreenResolution(Vector2* screen_out);
bool FrameRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr, int thickness);
bool FillRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr);
void DrawRect(LONG x, LONG y, LONG w, LONG h, unsigned char r, unsigned char g, unsigned char b);
void DrawFillRect(VOID* hwnd, LONG x, LONG y, LONG w, LONG h, unsigned char r, unsigned char g, unsigned char b);
```

`src/Driver/general.h`:

```h
#pragma once
#include "pch.h"

/* Offsets */
#define dwViewMatrix          0xEC9780
#define dwEntityList          0x12043CC
#define dwLocalTeam           0x100DF4
#define m_entityOrigin        0x184
#define m_stateValue          0x17C
#define m_entityModel         0x12C
#define m_entitySize          0x250

/* Settings */
#define MAX_ENTITIES          64
#define AIMBOT_KEY            0x1		// VK_LBUTTON

// change these if aimbot points below or higher than player head
// or want to make bigger esp box or something
#define AIMBOT_HEAD           20.f      // Head position (relatively of the player origin)
#define ESP_BOX_BOTTOM        30.f      // Box bottom position (relatively of the player origin) 
#define ESP_BOX_TOP           25.f      // Box top position (relatively of the player origin)

#define ESP_TOGGLE_KEY        0x76		// F7
#define AIMBOT_TOGGLE_KEY     0x75		// F6

#define SMOOTH_UP_KEY         0x26		// VK_UP
#define SMOOTH_DOWN_KEY       0x28		// VK_DOWN
#define FOV_UP_KEY            0x27		// VK_RIGHT
#define FOV_DOWN_KEY          0x25		// VK_LEFT

#define ONLY_ENEMIES_KEY      0x77		// F8

static RGB box_color = { 255.0f, 0.0f, 0.0f };

static float aimbot_smooth = 3.f;
static int aimbot_fov = 100;


/* Global variables */
static CHAR* gProcessName = "hl.exe";;
PEPROCESS gProcess;
ULONG64 gPid;

/* Others */
#define DBG 1
#if DBG
#define DebugPrint(x,...) DbgPrint("[zodiak] " x, __VA_ARGS__)
#else
#define DebugPrint(x,...)
#endif

// sb: There is no useless things in programming !
// this big foot nygga:
#define __FLTUSED__
__declspec(selectany) int _fltused = 1;
// virgin nerd in the corner: "fltused is important flag for compiler to allow support float !!!" 
```

`src/Driver/main.c`:

```c
#include "pch.h"

HANDLE dataHandle;

void MainThread() 
{
	while (true) 
	{
		/* Waiting for hl.exe */
		while (FindProcessByName(gProcessName, &gProcess) == STATUS_NOT_FOUND)
		{
			DebugPrint("waiting for -> %s", gProcessName);
			NtSleep(2500);
		}

		if (!gProcess) 
		{
			DebugPrint("gProcess -> not found");
			return;
		}
		DebugPrint("gProcess -> %p\n", gProcess);

		/* Getting the game PID */
		gPid = (ULONG64)PsGetProcessId(gProcess);

		if (!gPid) 
		{
			DebugPrint("gPid -> not found");
			return;
		}
		DebugPrint("gPid -> %i", (int)gPid);

		/* Pass execution to the data function */
		DataInitialize();
	}
}

NTSTATUS ZodiakEntry(PDRIVER_OBJECT driver_obj, PUNICODE_STRING registery_path) 
{
	UNREFERENCED_PARAMETER(driver_obj);
	UNREFERENCED_PARAMETER(registery_path);

	/* Microsoft compiler is sometimes retarded, thats why we have to do this non sense */
	/* It would otherwise generate wrapper functions around, and it would cause system BSOD */
	_KeAcquireSpinLockAtDpcLevel = (QWORD)KeAcquireSpinLockAtDpcLevel;
	_KeReleaseSpinLockFromDpcLevel = (QWORD)KeReleaseSpinLockFromDpcLevel;
	_IofCompleteRequest = (QWORD)IofCompleteRequest;
	_IoReleaseRemoveLockEx = (QWORD)IoReleaseRemoveLockEx;

	NTSTATUS status;

	/* Getting Windows Build Number */
	ULONG BuildNumber;
	PsGetVersion(NULL, NULL, &BuildNumber, NULL);
	DebugPrint("Windows Build: %u\n", BuildNumber);

	/* Setting offsets by build number */
    if (!SetOffsetsByBuildNumber(BuildNumber)) 
    {
        DebugPrint("Unsupported build number -> %lu\n", BuildNumber);
        return STATUS_NOT_SUPPORTED;
    }

	SpoofContext();
	/* Exporting Functions */
	if (!exports_init()) 
	{
		DebugPrint("Exports initialization failed");
		return STATUS_UNSUCCESSFUL;
	}
	RestoreContext();

	/* Starting Main Thread */
	status = PsCreateSystemThread(
		&dataHandle,
		THREAD_ALL_ACCESS,              
		NULL,                           
		NULL,                           
		NULL,                          
		(PKSTART_ROUTINE)MainThread,    
		NULL                            
	);
		
	if (!NT_SUCCESS(status)) 
	{
		DebugPrint("PsCreateSystemThread failed");
	}

	return status;
}

```

`src/Driver/memory.c`:

```c
#include "memory.h"

NTSTATUS copy_memory(void* src_process_id, void* src_address, void* dest_process_id, void* dest_address, uintptr_t size)
{
    if (src_process_id == (void*)4ULL)
    {
        RtlCopyMemory(dest_address, src_address, size);
        return STATUS_SUCCESS;
    }
    else
    {
        void* SrcProc = 0;
        void* DstProc = 0;
        uintptr_t size_out = 0;
        NTSTATUS status = 0;

        status = PsLookupProcessByProcessId(src_process_id, &(PEPROCESS)SrcProc);
        if (!NT_SUCCESS(status))
        {
            return status;
        }

        status = PsLookupProcessByProcessId(dest_process_id, &(PEPROCESS)DstProc);
        if (!NT_SUCCESS(status))
        {
            return status;
        }

        status = MmCopyVirtualMemory(SrcProc, src_address, DstProc, dest_address, size, 1, &size_out);

        // Dereference SrcProc and DstProc to prevent memory leaks
        ObDereferenceObject(SrcProc);
        ObDereferenceObject(DstProc);

        return status;
    }
}

NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
    SIZE_T Bytes;
    if (NT_SUCCESS(MmCopyVirtualMemory(Process, SourceAddress, PsGetCurrentProcess(),
        TargetAddress, Size, KernelMode, &Bytes)))
        return STATUS_SUCCESS;
    else
        return STATUS_ACCESS_DENIED;
}

NTSTATUS KeWriteVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
    SIZE_T Bytes;
    if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process,
        TargetAddress, Size, KernelMode, &Bytes)))
        return STATUS_SUCCESS;
    else
        return STATUS_ACCESS_DENIED;
}

NTSTATUS ReadEx(HANDLE ProcessId, PVOID Address, PVOID Buffer, SIZE_T Size)
{
    PEPROCESS Process;
    NTSTATUS Status;

    if (!NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &Process))) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    Status = KeReadVirtualMemory(Process, Address, Buffer, Size);

    if (NT_SUCCESS(Status)) 
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return Status;
    }
}

NTSTATUS WriteEx(HANDLE ProcessId, PVOID Address, PVOID Buffer, SIZE_T Size)
{
    PEPROCESS Process;
    NTSTATUS Status;

    if (!NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &Process))) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    Status = KeWriteVirtualMemory(Process, Address, Buffer, Size);

    if (NT_SUCCESS(Status)) 
    {
        return STATUS_SUCCESS;
    }
    else 
    {
        return Status;
    }
}
```

`src/Driver/memory.h`:

```h
#pragma once
#include "pch.h"

#define MM_COPY_MEMORY_VIRTUAL              0x2

NTSTATUS copy_memory(void* src_process_id, void* src_address, void* dest_process_id, void* dest_address, uintptr_t size);

NTSTATUS ReadEx(HANDLE ProcessId, PVOID Address, PVOID Buffer, SIZE_T Size);
NTSTATUS WriteEx(HANDLE ProcessId, PVOID Address, PVOID Buffer, SIZE_T Size);

inline bool read(uintptr_t Address, PVOID Buffer, SIZE_T Size)
{
    return NT_SUCCESS(ReadEx((HANDLE)gPid, (PVOID)Address, Buffer, Size));
}

inline bool write(uintptr_t Address, PVOID Buffer, SIZE_T Size)
{
    return NT_SUCCESS(WriteEx((HANDLE)gPid, (PVOID)Address, Buffer, Size));
}
```

`src/Driver/mouse.asm`:

```asm
EXTERNDEF _KeAcquireSpinLockAtDpcLevel:PROC
EXTERNDEF _KeReleaseSpinLockFromDpcLevel:PROC
EXTERNDEF _IofCompleteRequest:PROC
EXTERNDEF _IoReleaseRemoveLockEx:PROC
EXTERNDEF memmove:PROC

.data
WPP_RECORDER_INITIALIZED dq 0;
WPP_GLOBAL_Control dq 0;
.code

WPP_RECORDER_SF proc
	ret
WPP_RECORDER_SF endp

MouseClassReadCopyData proc
	mov    r11,rsp
	mov    QWORD PTR [r11+8h],rbx
	mov    QWORD PTR [r11+10h],rbp
	mov    QWORD PTR [r11+18h],rsi
	push   rdi
	push   r12
	push   r13
	push   r14
	push   r15
	sub    rsp,50h
	inc    DWORD PTR [rcx+0a8h]
	mov    rsi,rdx
	mov    eax,DWORD PTR [rcx+54h]
	mov    rdi,rcx
	mov    r13,QWORD PTR [rdx+0b8h]
	lea    ebp,[rax+rax*2]
	mov    ebx,DWORD PTR [r13+8h]
	shl    ebp,3h
	mov    edx,DWORD PTR [rdi+88h]
	cmp    ebp,ebx
	cmovae ebp,ebx
	sub    edx,DWORD PTR [rdi+78h]
	add    edx,DWORD PTR [rdi+68h]
	mov    r12d,ebp
	cmp    ebp,edx
	cmovae r12d,edx
	mov    r14,QWORD PTR [rsi+18h]
	mov    rdx,QWORD PTR [rdi+78h]
	mov    rcx,r14
	mov    r8d,r12d
	mov    r15d,r12d
	call   memmove
	add    r14,r15
	mov    ebx,ebp
	sub    ebx,r12d
	je     J1A5
	mov    rdx,QWORD PTR [rdi+68h]
	mov    r8,rbx
	mov    rcx,r14
	call   memmove
	mov    rcx,QWORD PTR [rdi+68h]
	add    rcx,rbx
	mov    QWORD PTR [rdi+78h],rcx
	jmp    J1B0
J1A5:
	add    QWORD PTR [rdi+78h],r15
J1B0:
	mov    ebx,ebp
	mov    rax,0aaaaaaaaaaaaaaabh
	mul    rbx
	shr    rdx,4h
	sub    DWORD PTR [rdi+54h],edx
	jne    J1FF
	mov    BYTE PTR [rdi+42h],1h
J1FF:
	mov    QWORD PTR [rsi+38h],rbx
	lea    r11,[rsp+50h]
	mov    rbx,QWORD PTR [r11+30h]
	xor    eax,eax
	mov    rsi,QWORD PTR [r11+40h]
	mov    DWORD PTR [r13+8h],ebp
	mov    rbp,QWORD PTR [r11+38h]
	mov    rsp,r11
	pop    r15
	pop    r14
	pop    r13
	pop    r12
	pop    rdi
	ret
MouseClassReadCopyData endp




MouseClassDequeueRead proc
	xor    edx,edx
	lea    r8,[rcx+98h]
J9:
	mov    rcx,QWORD PTR [r8]
	cmp    rcx,r8
	je     J47
	cmp    QWORD PTR [rcx+8h],r8
	jne    J4C
	mov    rax,QWORD PTR [rcx]
	cmp    QWORD PTR [rax+8h],rcx
	jne    J4C
	mov    QWORD PTR [r8],rax
	lea    rdx,[rcx-0a8h]
	mov    QWORD PTR [rax+8h],r8
	xor    eax,eax
	xchg   QWORD PTR [rdx+68h],rax
	test   rax,rax
	jne    J42
	mov    QWORD PTR [rcx+8h],rcx
	xor    edx,edx
	mov    QWORD PTR [rcx],rcx
J42:
	test   rdx,rdx
	je     J9
J47:
	mov    rax,rdx
	ret
	int    3
J4C:
	mov    ecx,3h
	int    29h
MouseClassDequeueRead endp


MouseClassServiceCallback proc
	mov    rax,rsp
	mov    QWORD PTR [rax+8h],rbx
	mov    QWORD PTR [rax+10h],rsi
	mov    QWORD PTR [rax+18h],rdi
	mov    QWORD PTR [rax+20h],r9
	push   rbp
	push   r12
	push   r13
	push   r14
	push   r15
	mov    rbp,rsp
	sub    rsp,70h
	mov    r13,r9
	mov    rbx,r8
	mov    r14,rdx
	mov    r15,rcx



	
	lea    rax, WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED, rax
	jne    J61
	mov    rcx,QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J61
	mov    rcx,QWORD PTR [rcx+40h]
	lea    r9d,[rsi+32h]
	lea    r8d,[rsi+3h]
	mov    dl,5h
	call   WPP_RECORDER_SF

J61:


	mov    rdi,QWORD PTR [r15+40h]
	sub    ebx,r14d
	mov    r12d,esi
	mov    DWORD PTR [r13+0h],esi
	lea    rcx,[rdi+90h]
	call   QWORD PTR _KeAcquireSpinLockAtDpcLevel
	nop    DWORD PTR [rax+rax*1+0h]
	lea    rax,[rbp-10h]
	mov    rcx,rdi
	mov    QWORD PTR [rbp-8h],rax
	lea    rax,[rbp-10h]
	mov    QWORD PTR [rbp-10h],rax
	call   MouseClassDequeueRead
	mov    rsi,rax
	xor    r9d,r9d
	mov    rax,0aaaaaaaaaaaaaaabh
	test   rsi,rsi
	je     J1aa
	mov    r13,QWORD PTR [rsi+0b8h]
	mov    r12d,ebx
	mov    r8d,DWORD PTR [r13+8h]
	cmp    ebx,r8d
	cmovae r12d,r8d
	mul    r12
	mov    rax,QWORD PTR [rbp+48h]
	shr    rdx,4h
	add    DWORD PTR [rax],edx
	lea    rax, WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J11d
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],r9w
	je     J11d
	mov    rax,QWORD PTR [rsi+18h]
	mov    rcx,QWORD PTR [rcx+40h]
	mov    QWORD PTR [rsp+50h],rax
	mov    QWORD PTR [rsp+48h],r14
	mov    DWORD PTR [rsp+40h],r8d
	mov    DWORD PTR [rsp+38h],ebx
	mov    QWORD PTR [rsp+30h],rsi
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF

J11d:

	mov    rax,0fffff78000000014h
	mov    rax,QWORD PTR [rax]
	lea    rdx,WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rdx
	jne    J15e
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	mov    DWORD PTR [rsp+40h],r12d
	mov    QWORD PTR [rsp+38h],rax
	mov    QWORD PTR [rsp+30h],rsi
	mov    rcx,QWORD PTR [rcx+40h]
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF

J15e:

	mov    rcx,QWORD PTR [rsi+18h]
	mov    r8,r12
	mov    rdx,r14
	call   memmove
	mov    QWORD PTR [rsi+38h],r12
	lea    rcx,[rbp-10h]
	xor    r8d,r8d
	mov    DWORD PTR [rsi+30h],r8d
	add    rsi,0a8h
	mov    DWORD PTR [r13+8h],r12d
	mov    rax,QWORD PTR [rbp-8h]
	cmp    QWORD PTR [rax],rcx
	jne    J495
	mov    r13,QWORD PTR [rbp+48h]
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rsi],rcx
	mov    QWORD PTR [rsi+8h],rax
	mov    QWORD PTR [rax],rsi
	mov    QWORD PTR [rbp-8h],rsi

J1aa:

	mov    eax,r12d
	add    r14,rax
	sub    ebx,r12d
	lea    r12,WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J1e4
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J1e4
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+30h],ebx
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF

J1e4:

	test   ebx,ebx
	je     J41d
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J22f
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J22f
	mov    eax,DWORD PTR [rdi+54h]
	mov    r9d,36h
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+38h],ebx
	lea    edx,[rax+rax*2]
	mov    eax,DWORD PTR [rdi+88h]
	shl    edx,3h
	sub    eax,edx
	mov    DWORD PTR [rsp+30h],eax
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF

J22f:

	mov    ecx,DWORD PTR [rdi+88h]
	cmp    ecx,ebx
	mov    r12d,ecx
	cmovae r12d,ebx
	sub    ecx,DWORD PTR [rdi+70h]
	mov    ebx,DWORD PTR [rdi+68h]
	add    ebx,ecx
	lea    rax,WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J287
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J287
	mov    rcx,QWORD PTR [rcx+40h]
	mov    r9d,38h
	mov    DWORD PTR [rsp+38h],ebx
	mov    DWORD PTR [rsp+30h],r12d
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF
	lea    rax,WPP_RECORDER_INITIALIZED

J287:

	cmp    r12d,ebx
	mov    esi,r12d
	cmovae esi,ebx
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J2cc
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	xor    eax,eax
	cmp    WORD PTR [rcx+48h],ax
	je     J2cc
	mov    rcx,QWORD PTR [rcx+40h]
	lea    r9d,[rax+39h]
	mov    rax,QWORD PTR [rdi+70h]
	mov    QWORD PTR [rsp+40h],rax
	mov    QWORD PTR [rsp+38h],r14
	mov    DWORD PTR [rsp+30h],esi
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF

J2cc:

	mov    rcx,QWORD PTR [rdi+70h]
	mov    rdx,r14
	mov    r8d,esi
	mov    ebx,esi
	call   memmove
	add    QWORD PTR [rdi+70h],rbx
	add    r14,rbx
	mov    rdx,QWORD PTR [rdi+68h]
	mov    eax,DWORD PTR [rdi+88h]
	mov    rcx,QWORD PTR [rdi+70h]
	add    rax,rdx
	cmp    rcx,rax
	jb     J301
	mov    QWORD PTR [rdi+70h],rdx
	mov    rcx,rdx

J301:

	mov    ebx,r12d
	sub    ebx,esi
	je     J362
	lea    rdx,WPP_RECORDER_INITIALIZED
	mov    rax,rcx
	cmp    WPP_RECORDER_INITIALIZED,rdx
	jne    J350
	mov    rdx, QWORD PTR WPP_GLOBAL_Control
	xor    r8d,r8d
	cmp    WORD PTR [rdx+48h],r8w
	je     J350
	mov    QWORD PTR [rsp+40h],rcx
	lea    r9d,[r8+03ah]
	mov    rcx,QWORD PTR [rdx+40h]
	mov    QWORD PTR [rsp+38h],r14
	mov    DWORD PTR [rsp+30h],ebx
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF
	mov    rax,QWORD PTR [rdi+70h]

J350:

	mov    r8,rbx
	mov    rdx,r14
	mov    rcx,rax
	call   memmove
	add    QWORD PTR [rdi+70h],rbx

J362:

	mov    ecx,r12d
	mov    rax,0aaaaaaaaaaaaaaabh
	mul    rcx
	shr    rdx,4h
	add    DWORD PTR [rdi+54h],edx
	mov    ecx,DWORD PTR [r13+0h]
	add    ecx,edx
	mov    eax,ecx
	mov    DWORD PTR [r13+0h],ecx
	lea    r12,WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J41d
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J41d
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+48h],eax
	mov    rax,QWORD PTR [rdi+78h]
	mov    QWORD PTR [rsp+40h],rax
	mov    rax,QWORD PTR [rdi+70h]
	mov    QWORD PTR [rsp+38h],rax
	mov    eax,DWORD PTR [rdi+54h]
	mov    DWORD PTR [rsp+30h],eax
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SF
	jmp    J41d

J3d5:

	mov    rcx,rdi
	call   MouseClassDequeueRead
	mov    rbx,rax
	test   rax,rax
	je     J422
	mov    rdx,rax
	mov    rcx,rdi
	call   MouseClassReadCopyData
	mov    DWORD PTR [rbx+30h],eax
	lea    rcx,[rbp-10h]
	mov    rdx,QWORD PTR [rbp-8h]
	lea    rax,[rbx+0a8h]
	cmp    QWORD PTR [rdx],rcx
	jne    J495
	mov    QWORD PTR [rax+8h],rdx
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rax],rcx
	mov    QWORD PTR [rdx],rax
	mov    QWORD PTR [rbp-8h],rax

J41d:

	cmp    DWORD PTR [rdi+54h],esi


	ja     J3d5

J422:

	lea    rcx,[rdi+90h]
	call   QWORD PTR _KeReleaseSpinLockFromDpcLevel
	nop    DWORD PTR [rax+rax*1+0h]

J435:

	mov    rbx,QWORD PTR [rbp-10h]
	lea    rax,[rbp-10h]
	cmp    rbx,rax
	je     J49c
	lea    rax,[rbp-10h]
	cmp    QWORD PTR [rbx+8h],rax
	jne    J495
	mov    rax,QWORD PTR [rbx]
	cmp    QWORD PTR [rax+8h],rbx
	jne    J495
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rbp-10h],rax
	mov    QWORD PTR [rax+8h],rcx
	mov    dl,6h
	lea    rcx,[rbx-0a8h]
	call   QWORD PTR _IofCompleteRequest
	nop    DWORD PTR [rax+rax*1+0h]
	lea    rcx,[rdi+20h]
	mov    r8d,20h
	lea    rdx,[rbx-0a8h]
	call   QWORD PTR _IoReleaseRemoveLockEx
	nop    DWORD PTR [rax+rax*1+0h]
	jmp    J435

J495:

	mov    ecx,3h
	int    29h

J49C:

	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J4c7
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J4c7
	mov    rcx,QWORD PTR [rcx+40h]
	mov    r9d,3ch
	mov    dl,5h
	lea    r8d,[r9-39h]
	call   WPP_RECORDER_SF

J4c7:

	lea    r11,[rsp+70h]
	mov    rbx,QWORD PTR [r11+30h]
	mov    rsi,QWORD PTR [r11+38h]
	mov    rdi,QWORD PTR [r11+40h]
	mov    rsp,r11
	pop    r15
	pop    r14
	pop    r13
	pop    r12
	pop    rbp
	ret
MouseClassServiceCallback endp

end

```

`src/Driver/mouse.c`:

```c
#include "mouse.h"

#define KeMRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

#pragma warning(disable : 4201)
typedef struct _MOUSE_INPUT_DATA {
	USHORT UnitId;
	USHORT Flags;
	union {
		ULONG Buttons;
		struct {
			USHORT ButtonFlags;
			USHORT ButtonData;
		};
	};
	ULONG  RawButtons;
	LONG   LastX;
	LONG   LastY;
	ULONG  ExtraInformation;
} MOUSE_INPUT_DATA, * PMOUSE_INPUT_DATA;

typedef VOID
(*MouseClassServiceCallbackFn)(
	PDEVICE_OBJECT DeviceObject,
	PMOUSE_INPUT_DATA InputDataStart,
	PMOUSE_INPUT_DATA InputDataEnd,
	PULONG InputDataConsumed
	);

typedef struct _MOUSE_OBJECT
{
	PDEVICE_OBJECT              mouse_device;
	MouseClassServiceCallbackFn service_callback;
	BOOL                        use_mouse;
} MOUSE_OBJECT, * PMOUSE_OBJECT;


MOUSE_OBJECT gMouseObject;

NTSYSCALLAPI POBJECT_TYPE* IoDriverObjectType;

VOID MouseClassServiceCallback(
	PDEVICE_OBJECT DeviceObject,
	PMOUSE_INPUT_DATA InputDataStart,
	PMOUSE_INPUT_DATA InputDataEnd,
	PULONG InputDataConsumed
);

void mouse_move(long x, long y, unsigned short button_flags)
{
	KIRQL irql;
	ULONG input_data;
	MOUSE_INPUT_DATA mid = { 0 };
	mid.LastX = x;
	mid.LastY = y;
	mid.ButtonFlags = button_flags;
	if (!mouse_open())
	{
		return;
	}
	mid.UnitId = 1;
	KeMRaiseIrql(DISPATCH_LEVEL, &irql);
	MouseClassServiceCallback(gMouseObject.mouse_device, &mid, (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
	KeLowerIrql(irql);
}


BOOL mouse_open(void)
{
	// https://github.com/nbqofficial/norsefire

	if (gMouseObject.use_mouse == 0) {

		UNICODE_STRING class_string;
		RtlInitUnicodeString(&class_string, L"\\Driver\\MouClass");


		PDRIVER_OBJECT class_driver_object = NULL;
		NTSTATUS status = ObReferenceObjectByName(&class_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&class_driver_object);
		if (!NT_SUCCESS(status)) {
			gMouseObject.use_mouse = 0;
			return 0;
		}

		UNICODE_STRING hid_string;
		RtlInitUnicodeString(&hid_string, L"\\Driver\\MouHID");


		PDRIVER_OBJECT hid_driver_object = NULL;

		status = ObReferenceObjectByName(&hid_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&hid_driver_object);
		if (!NT_SUCCESS(status))
		{
			if (class_driver_object) {
				ObfDereferenceObject(class_driver_object);
			}
			gMouseObject.use_mouse = 0;
			return 0;
		}

		PVOID class_driver_base = NULL;


		PDEVICE_OBJECT hid_device_object = hid_driver_object->DeviceObject;
		while (hid_device_object && !gMouseObject.service_callback)
		{
			PDEVICE_OBJECT class_device_object = class_driver_object->DeviceObject;
			while (class_device_object && !gMouseObject.service_callback)
			{
				if (!class_device_object->NextDevice && !gMouseObject.mouse_device)
				{
					gMouseObject.mouse_device = class_device_object;
				}

				PULONG_PTR device_extension = (PULONG_PTR)hid_device_object->DeviceExtension;
				ULONG_PTR device_ext_size = ((ULONG_PTR)hid_device_object->DeviceObjectExtension - (ULONG_PTR)hid_device_object->DeviceExtension) / 4;
				class_driver_base = class_driver_object->DriverStart;
				for (ULONG_PTR i = 0; i < device_ext_size; i++)
				{
					if (device_extension[i] == (ULONG_PTR)class_device_object && device_extension[i + 1] > (ULONG_PTR)class_driver_object)
					{
						gMouseObject.service_callback = (MouseClassServiceCallbackFn)(device_extension[i + 1]);

						break;
					}
				}
				class_device_object = class_device_object->NextDevice;
			}
			hid_device_object = hid_device_object->AttachedDevice;
		}

		if (!gMouseObject.mouse_device)
		{
			PDEVICE_OBJECT target_device_object = class_driver_object->DeviceObject;
			while (target_device_object)
			{
				if (!target_device_object->NextDevice)
				{
					gMouseObject.mouse_device = target_device_object;
					break;
				}
				target_device_object = target_device_object->NextDevice;
			}
		}

		ObfDereferenceObject(class_driver_object);
		ObfDereferenceObject(hid_driver_object);

		if (gMouseObject.mouse_device && gMouseObject.service_callback) {
			gMouseObject.use_mouse = 1;
		}

	}

	return gMouseObject.mouse_device && gMouseObject.service_callback;
}
```

`src/Driver/mouse.h`:

```h
#pragma once
#include "pch.h"

QWORD _KeAcquireSpinLockAtDpcLevel;
QWORD _KeReleaseSpinLockFromDpcLevel;
QWORD _IofCompleteRequest;
QWORD _IoReleaseRemoveLockEx;

BOOL mouse_open(void);
void mouse_move(long x, long y, unsigned short button_flags);
```

`src/Driver/pch.h`:

```h
#pragma once
#include <Ntifs.h>
#include <WinDef.h>
#include <wingdi.h>
#include <ntddk.h>
#include <stdbool.h>
#include <ntddk.h>

#include "struct.h"
#include "general.h"
#include "memory.h"
#include "export.h"
#include "gdi.h"
#include "mouse.h"
#include "utils.h"
#include "spoof.h"
#include "game.h"
#include "data.h"

//       |\      _,,,---,,_
// Zzz   /,`.-'`'    -.  ;-;;,_
//      |,4-  ) )-,_. ,\ (  `'-'
//     '---''(_/--'  `-\_)

```

`src/Driver/spoof.c`:

```c
#include "spoof.h"

void SpoofContext() 
{
	currentProcess = IoGetCurrentProcess();
	currentThread = KeGetCurrentThread();
	memcpy(&currentCid, (PVOID)((char*)currentThread + cidOffset), sizeof(CLIENT_ID));

	/* Spoofing our process context to the win32 context */
	PVOID targetWin32Thread = 0;
	PETHREAD targetThread = GetWin32Thread(&targetWin32Thread);
	if (!targetWin32Thread || !targetThread)
	{
		DebugPrint("failed to find win32thread");
		return;
	}
	PEPROCESS targetProcess = PsGetThreadProcess(targetThread);

	CLIENT_ID targetCid = { 0 };
	memcpy(&targetCid, (PVOID)((char*)targetThread + cidOffset), sizeof(CLIENT_ID));

	KeStackAttachProcess(targetProcess, &apc);
	SpoofWin32Thread(targetWin32Thread, targetProcess, targetCid);
}

void RestoreContext() 
{
	SpoofWin32Thread(currentWin32Thread, currentProcess, currentCid);
	KeUnstackDetachProcess(&apc);
}

PETHREAD GetWin32Thread(PVOID* win32Thread)
{
	int currentThreadId = 1;
	NTSTATUS status = 0;
	do
	{
		PETHREAD currentEthread = 0;
		status = PsLookupThreadByThreadId((HANDLE)currentThreadId, &currentEthread);

		if (!NT_SUCCESS(status) || !currentEthread)
		{
			currentThreadId++;
			continue;
		}

		if (PsIsThreadTerminating(currentEthread))
		{
			currentThreadId++;
			continue;
		}

		PVOID Win32Thread;
		memcpy(&Win32Thread, (PVOID)((UINT64)currentEthread + win32ThreadOffset), sizeof(PVOID));

		if (Win32Thread)
		{
			PEPROCESS threadOwner = PsGetThreadProcess(currentEthread);
			char procName[15];
			memcpy(&procName, (PVOID)((UINT64)threadOwner + imageFileNameOffset), sizeof(procName));
			if (!strcmp(procName, "dwm.exe")) // explorer.exe causing bsod
			{
				*win32Thread = Win32Thread;
				return currentEthread;
			}
		}
		currentThreadId++;
	} while (0x3000 > currentThreadId);

	return 0;
}

void SpoofWin32Thread(PVOID newWin32Value, PEPROCESS newProcess, CLIENT_ID newClientId)
{
	PVOID win32ThreadPtr = (PVOID)((char*)currentThread + win32ThreadOffset);
	memcpy(win32ThreadPtr, &newWin32Value, sizeof(PVOID));

	PVOID processPtr = (PVOID)((char*)currentThread + processOffset);
	memcpy(processPtr, &newProcess, sizeof(PEPROCESS));

	PVOID clientIdPtr = (PVOID)((char*)currentThread + cidOffset);
	memcpy(clientIdPtr, &newClientId, sizeof(CLIENT_ID));
}

bool SetOffsetsByBuildNumber(ULONG buildNumber)
{
    /* Set offsets based on the build number */

    if (buildNumber >= 22621) // Windows 11 22H2
    {
        processOffset = 0x450;
        win32ThreadOffset = 0x1c8;
        cidOffset = 0x7a0;
        imageFileNameOffset = 0x5a8;
        return true;
    }
    else if (buildNumber >= 22000) // Windows 11 21H2
    {
        processOffset = 0x448;
        win32ThreadOffset = 0x1c8;
        cidOffset = 0x7a0;
        imageFileNameOffset = 0x5a8;
        return true;
    }
    else if (buildNumber >= 19041) // Windows 10 2004, 20H2, 21H1, 21H2
    {
        processOffset = 0x220;
        win32ThreadOffset = 0x1c8;
        cidOffset = 0x478;
        imageFileNameOffset = 0x5a8;
        return true;
    }
    else if (buildNumber >= 18362) // Windows 10 1903, 1909
    {
        processOffset = 0x218;
        win32ThreadOffset = 0x1b8;
        cidOffset = 0x470;
        imageFileNameOffset = 0x598;
        return true;
    }
    else if (buildNumber >= 17763) // Windows 10 1809
    { 
        processOffset = 0x218;
        win32ThreadOffset = 0x1b8;
        cidOffset = 0x478;
        imageFileNameOffset = 0x5a8;
        return true;
    }
    else if (buildNumber >= 17134) // Windows 10 1803
    { 
        processOffset = 0x210;
        win32ThreadOffset = 0x1b0;
        cidOffset = 0x460;
        imageFileNameOffset = 0x588;
        return true;
    }
    else if (buildNumber >= 16299) // Windows 10 1709
    { 
        processOffset = 0x208;
        win32ThreadOffset = 0x1a8;
        cidOffset = 0x450;
        imageFileNameOffset = 0x578;
        return true;
    }
    else if (buildNumber >= 15063) // Windows 10 1703
    { 
        processOffset = 0x200;
        win32ThreadOffset = 0x1a0;
        cidOffset = 0x448;
        imageFileNameOffset = 0x570;
        return true;
    }
    else if (buildNumber >= 14393) // Windows 10 1607
    { 
        processOffset = 0x198;
        win32ThreadOffset = 0x190;
        cidOffset = 0x440;
        imageFileNameOffset = 0x568;
        return true;
    }
    else if (buildNumber >= 10586) // Windows 10 1511
    { 
        processOffset = 0x190;
        win32ThreadOffset = 0x188;
        cidOffset = 0x438;
        imageFileNameOffset = 0x560;
        return true;
    }
    else if (buildNumber >= 10240) // Windows 10 1507
    { 
        processOffset = 0x188;
        win32ThreadOffset = 0x180;
        cidOffset = 0x430;
        imageFileNameOffset = 0x558;
        return true;
    }
    else 
    {
        return false;
    }
}
```

`src/Driver/spoof.h`:

```h
#pragma once
#include "pch.h"

/* Offsets */
ULONG processOffset; //_KTHREAD->_KPROCESS* Process;
ULONG win32ThreadOffset; //_KTHREAD->VOID* volatile Win32Thread
ULONG cidOffset; //_ETHREAD->_CLIENT_ID Cid;  
ULONG imageFileNameOffset; //_PEPROCESS->UCHAR ImageFileName[15];   

KAPC_STATE apc;
PVOID currentWin32Thread;
PEPROCESS currentProcess;
PETHREAD currentThread;
CLIENT_ID currentCid;

void SpoofContext();
void RestoreContext();

/* Function that change offsets based on windows build number */
bool SetOffsetsByBuildNumber(ULONG buildNumber);

/* Local functions */
static PETHREAD GetWin32Thread(PVOID* win32Thread);
static void SpoofWin32Thread(PVOID newWin32Value, PEPROCESS newProcess, CLIENT_ID newClientId);


```

`src/Driver/struct.h`:

```h
#pragma once
#include "pch.h"

/* Local Structs/Types */
typedef ULONG_PTR QWORD;
typedef unsigned int uint32_t;
typedef float view_matrix_t[4][4];

typedef struct
{
    float x;
    float y;
    float z;
} Vector3;

typedef struct
{
    float x;
    float y;
} Vector2;

typedef struct
{
    float r;
    float g;
    float b;
} RGB;

typedef struct
{
    float x;
    float y;
    int w;
    int h;
} BOX;

/* Exported functions */
NTKERNELAPI
NTSTATUS
NTAPI
MmCopyVirtualMemory(
    _In_ PEPROCESS SourceProcess,
    _In_reads_bytes_(BufferSize) PVOID SourceAddress,
    _In_ PEPROCESS TargetProcess,
    _Out_writes_bytes_(BufferSize) PVOID TargetAddress,
    _In_ SIZE_T BufferSize,
    _In_ KPROCESSOR_MODE PreviousMode,
    _Out_ PSIZE_T ReturnSize
);

NTKERNELAPI
PPEB
NTAPI
PsGetProcessPeb(
    PEPROCESS Process
);

NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(
    _In_ PEPROCESS Process
);

NTSYSCALLAPI
NTSTATUS
ObReferenceObjectByName(
    __in PUNICODE_STRING ObjectName,
    __in ULONG Attributes,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PVOID ParseContext,
    __out PVOID* Object
);


/* Windows structs */
typedef struct _PEB_LDR_DATA {
    ULONG Length;
    UCHAR Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    UCHAR ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB {
    UCHAR Reserved1[2];
    UCHAR BeingDebugged;
    UCHAR Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID Reserved4[3];
    ULONG AtlThunkSListPtr32;
    PVOID Reserved5;
    ULONG Reserved6;
    ULONG Reserved7;
    PVOID Reserved8;
    PVOID Reserved9;
    PVOID Reserved10;
    PVOID Reserved11;
    PVOID Reserved12;
    PVOID Reserved13;
    PVOID Reserved14;
    PVOID Reserved15;
    PVOID Reserved16;
    PVOID Reserved17;
    PVOID Reserved18;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[2];
    PVOID DllBase;
    PVOID Reserved3[2];
    UNICODE_STRING FullDllName;
    BYTE Reserved4[8];
    PVOID Reserved5[3];
#pragma warning(push)
#pragma warning(disable: 4201) // we'll always use the Microsoft compiler
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    } DUMMYUNIONNAME;
#pragma warning(pop)
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _KLDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    VOID* ExceptionTable;
    UINT32 ExceptionTableSize;
    VOID* GpValue;
    VOID* NonPagedDebugInfo;
    VOID* ImageBase;
    VOID* EntryPoint;
    UINT32 SizeOfImage;
    UNICODE_STRING FullImageName;
    UNICODE_STRING BaseImageName;
} _LDR_DATA_TABLE_ENTRY, * _PLDR_DATA_TABLE_ENTRY;


/* 32 bit */
typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    UCHAR Initialized;
    ULONG SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB32
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    ULONG Mutant;
    ULONG ImageBaseAddress;
    ULONG Ldr;
    ULONG ProcessParameters;
    ULONG SubSystemData;
    ULONG ProcessHeap;
    ULONG FastPebLock;
    ULONG AtlThunkSListPtr;
    ULONG IFEOKey;
    ULONG CrossProcessFlags;
    ULONG UserSharedInfoPtr;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    ULONG ApiSetMap;
} PEB32, * PPEB32;
```

`src/Driver/utils.c`:

```c
#include "utils.h"

__declspec(dllimport) LIST_ENTRY* PsLoadedModuleList;

NTSTATUS FindProcessByName(CHAR* process_name, PEPROCESS* process)
{
	PEPROCESS sys_process = PsInitialSystemProcess;
	PEPROCESS cur_entry = sys_process;

	CHAR image_name[15];

	do
	{
		RtlCopyMemory((PVOID)(&image_name), (PVOID)((uintptr_t)cur_entry + 0x5a8) /*EPROCESS->ImageFileName*/, sizeof(image_name));

		if (strstr(image_name, process_name))
		{
			DWORD active_threads;
			RtlCopyMemory((PVOID)&active_threads, (PVOID)((uintptr_t)cur_entry + 0x5f0) /*EPROCESS->ActiveThreads*/, sizeof(active_threads));
			if (active_threads)
			{
				ObReferenceObject(cur_entry);
				*process = cur_entry;
				return STATUS_SUCCESS;
			}
		}

		PLIST_ENTRY list = (PLIST_ENTRY)((uintptr_t)(cur_entry)+0x448) /*EPROCESS->ActiveProcessLinks*/;
		cur_entry = (PEPROCESS)((uintptr_t)list->Flink - 0x448);

	} while (cur_entry != sys_process);

	return STATUS_NOT_FOUND;
}


uintptr_t GetModuleBase64(uintptr_t pid, wchar_t* module_name)
{
	void* ProcessPtr = 0;

	// Find process by ID
	if (PsLookupProcessByProcessId((HANDLE)pid, &(PEPROCESS)ProcessPtr) < 0 || ProcessPtr == 0)
	{
		return 0;
	}

	PPEB pPeb = (PPEB)PsGetProcessPeb(ProcessPtr); // Return Base Address
	if (!pPeb)
	{
		ObDereferenceObject(ProcessPtr); // Clean up process object
		return 0;
	}

	KAPC_STATE state;
	KeStackAttachProcess(ProcessPtr, &state);

    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;
	if (!pLdr)
	{
		KeUnstackDetachProcess(&state);
		ObDereferenceObject(ProcessPtr); // Clean up process object
		return 0;
	}

	// Assuming module_name is a wchar_t* (null-terminated wide string)
	uintptr_t address = 0;

	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InMemoryOrderModuleList.Flink;
		list != &pLdr->InMemoryOrderModuleList; list = (PLIST_ENTRY)list->Flink)
	{
		PLDR_DATA_TABLE_ENTRY pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

		// Output the FullDllName using DbgPrint
		//DbgPrint("Checking module: %wZ\n", &pEntry->FullDllName);

		// Check if module_name is a substring of pEntry->FullDllName.Buffer
		if (wcsstr(pEntry->FullDllName.Buffer, module_name) != NULL)
		{
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			address = baseAddr;
			break;  // Exit loop once the module is found
		}
	}

	KeUnstackDetachProcess(&state);
	ObDereferenceObject(ProcessPtr); // Clean up process object

	return address;
}

uint32_t GetModuleBase32(uintptr_t pid, wchar_t* module_name)
{
	void* ProcessPtr = 0;

	// Find process by ID
	if (PsLookupProcessByProcessId((HANDLE)pid, &(PEPROCESS)ProcessPtr) < 0 || ProcessPtr == 0)
	{
		return 0;
	}

	PPEB32 pPeb = (PPEB32)PsGetProcessWow64Process(ProcessPtr);
	if (!pPeb)
	{
		ObDereferenceObject(ProcessPtr); // Clean up process object
		return 0;
	}

	KAPC_STATE state;
	KeStackAttachProcess(ProcessPtr, &state);

	PPEB_LDR_DATA32 pLdr = (PPEB_LDR_DATA32)pPeb->Ldr;
	if (!pLdr)
	{
		KeUnstackDetachProcess(&state);
		ObDereferenceObject(ProcessPtr); // Clean up process object
		return 0;
	}

	// Assuming module_name is a wchar_t* (null-terminated wide string)
	uint32_t address = 0;

	for (PLIST_ENTRY32 list = (PLIST_ENTRY32)pLdr->InMemoryOrderModuleList.Flink;
		list != &pLdr->InMemoryOrderModuleList; list = (PLIST_ENTRY32)list->Flink)
	{
		PLDR_DATA_TABLE_ENTRY32 pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY32, InMemoryOrderLinks);

		// Output the FullDllName using DbgPrint
		//DbgPrint("Checking module: %wZ\n", (const wchar_t*)&pEntry->FullDllName);

		// Check if module_name is a substring of pEntry->FullDllName.Buffer
		if (wcsstr((const wchar_t*)pEntry->FullDllName.Buffer, module_name) != NULL)
		{
			ULONG32 baseAddr = (ULONG32)pEntry->DllBase;
			address = baseAddr;
			break;  // Exit loop once the module is found
		}
	}

	KeUnstackDetachProcess(&state);
	ObDereferenceObject(ProcessPtr); // Clean up process object

	return address;
}

QWORD GetModuleEntry(PCWSTR module_name)
{
	for (PLIST_ENTRY pListEntry = PsLoadedModuleList->Flink; pListEntry != PsLoadedModuleList; pListEntry = pListEntry->Flink)
	{
		_PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, _LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (pEntry->ImageBase == 0)
			continue;

		if (pEntry->BaseImageName.Buffer && !wcscmp(pEntry->BaseImageName.Buffer, module_name))
		{
			return (QWORD)pEntry->ImageBase;
		}

	}
	return 0;
}

QWORD GetProcAddressQ(QWORD base, PCSTR export_name)
{
	QWORD a0;
	DWORD a1[4];


	a0 = base + *(USHORT*)(base + 0x3C);
	a0 = base + *(DWORD*)(a0 + 0x88);
	a1[0] = *(DWORD*)(a0 + 0x18);
	a1[1] = *(DWORD*)(a0 + 0x1C);
	a1[2] = *(DWORD*)(a0 + 0x20);
	a1[3] = *(DWORD*)(a0 + 0x24);
	while (a1[0]--) {

		a0 = base + *(DWORD*)(base + a1[2] + (a1[0] * 4));
		if (strcmp((PCSTR)a0, export_name) == 0) {

			return (base + *(DWORD*)(base + a1[1] + (*(USHORT*)(base + a1[3] + (a1[0] * 2)) * 4)));
		}
	}
	return 0;
}

/* very clean func, thx ekknod :3 */
void NtSleep(DWORD milliseconds)
{
	QWORD ms = milliseconds;
	ms = (ms * 1000) * 10;
	ms = ms * -1;
#ifdef _KERNEL_MODE
	KeDelayExecutionThread(KernelMode, 0, (PLARGE_INTEGER)&ms);
#else
	NtDelayExecution(0, (PLARGE_INTEGER)&ms);
#endif
}

```

`src/Driver/utils.h`:

```h
#pragma once
#include "pch.h"

NTSTATUS FindProcessByName(CHAR* process_name, PEPROCESS* process);

uintptr_t GetModuleBase64(uintptr_t pid, wchar_t* module_name);
uint32_t GetModuleBase32(uintptr_t pid, wchar_t* module_name);

QWORD GetModuleEntry(PCWSTR module_name);
QWORD GetProcAddressQ(QWORD base, PCSTR export_name);

void NtSleep(DWORD milliseconds);
```

`src/Zodiak.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34330.188
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Zodiak", "Driver\Driver.vcxproj", "{36751642-2D56-4D61-B9D8-8E5CECE086BA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x64.ActiveCfg = Release|x64
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x64.Build.0 = Release|x64
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x64.Deploy.0 = Release|x64
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x86.ActiveCfg = Release|x64
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x86.Build.0 = Release|x64
		{36751642-2D56-4D61-B9D8-8E5CECE086BA}.Release|x86.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3B454971-542A-4F94-B38D-2FB7C5BA781F}
	EndGlobalSection
EndGlobal

```