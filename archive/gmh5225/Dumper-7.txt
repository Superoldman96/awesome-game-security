Project Path: arc_gmh5225_Dumper-7_95auapq3

Source Tree:

```txt
arc_gmh5225_Dumper-7_95auapq3
├── Dumper
│   ├── Dumper.vcxproj
│   ├── Dumper.vcxproj.filters
│   ├── Enums.h
│   ├── FileWriter.cpp
│   ├── FileWriter.h
│   ├── Generator.cpp
│   ├── Generator.h
│   ├── NameArray.cpp
│   ├── NameArray.h
│   ├── ObjectArray.cpp
│   ├── ObjectArray.h
│   ├── OffsetFinder.h
│   ├── Offsets.cpp
│   ├── Offsets.h
│   ├── Package.cpp
│   ├── Package.h
│   ├── Settings.h
│   ├── Types.cpp
│   ├── Types.h
│   ├── UnrealObjects.cpp
│   ├── UnrealObjects.h
│   ├── UnrealTypes.cpp
│   ├── UnrealTypes.h
│   ├── Utils.h
│   └── main.cpp
├── Dumper-7.sln
└── README.md

```

`Dumper-7.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Dumper-7", "Dumper\Dumper.vcxproj", "{CF452592-4ABF-4A97-96C3-606A96BF2A62}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SDKTest", "SDKTest\SDKTest.vcxproj", "{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Debug|x64.ActiveCfg = Debug|x64
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Debug|x64.Build.0 = Debug|x64
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Debug|x86.ActiveCfg = Debug|Win32
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Debug|x86.Build.0 = Debug|Win32
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Release|x64.ActiveCfg = Release|x64
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Release|x64.Build.0 = Release|x64
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Release|x86.ActiveCfg = Release|Win32
		{CF452592-4ABF-4A97-96C3-606A96BF2A62}.Release|x86.Build.0 = Release|Win32
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Debug|x64.ActiveCfg = Debug|x64
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Debug|x64.Build.0 = Debug|x64
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Debug|x86.ActiveCfg = Debug|Win32
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Debug|x86.Build.0 = Debug|Win32
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Release|x64.ActiveCfg = Release|x64
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Release|x64.Build.0 = Release|x64
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Release|x86.ActiveCfg = Release|Win32
		{AB16E7C7-AF0E-4FAC-9161-EAE7D1AE86FD}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A2FDE019-8DEB-4D39-9D64-FF23C4593743}
	EndGlobalSection
EndGlobal

```

`Dumper/Dumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{cf452592-4abf-4a97-96c3-606a96bf2a62}</ProjectGuid>
    <RootNamespace>Dumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Dumper-7</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FileWriter.cpp" />
    <ClCompile Include="Generator.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="ObjectArray.cpp" />
    <ClCompile Include="Offsets.cpp" />
    <ClCompile Include="Package.cpp" />
    <ClCompile Include="Types.cpp" />
    <ClCompile Include="NameArray.cpp" />
    <ClCompile Include="UnrealObjects.cpp" />
    <ClCompile Include="UnrealTypes.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Enums.h" />
    <ClInclude Include="FileWriter.h" />
    <ClInclude Include="Generator.h" />
    <ClInclude Include="ObjectArray.h" />
    <ClInclude Include="OffsetFinder.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Package.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="Types.h" />
    <ClInclude Include="NameArray.h" />
    <ClInclude Include="UnrealObjects.h" />
    <ClInclude Include="UnrealTypes.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Dumper/Dumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="ObjectArray.cpp">
      <Filter>Engine\Private</Filter>
    </ClCompile>
    <ClCompile Include="Offsets.cpp">
      <Filter>Engine\Private</Filter>
    </ClCompile>
    <ClCompile Include="UnrealObjects.cpp">
      <Filter>Engine\Private</Filter>
    </ClCompile>
    <ClCompile Include="Generator.cpp">
      <Filter>Generator\Private</Filter>
    </ClCompile>
    <ClCompile Include="Types.cpp">
      <Filter>Generator\Private</Filter>
    </ClCompile>
    <ClCompile Include="FileWriter.cpp">
      <Filter>Generator\Private</Filter>
    </ClCompile>
    <ClCompile Include="Package.cpp">
      <Filter>Generator\Private</Filter>
    </ClCompile>
    <ClCompile Include="NameArray.cpp">
      <Filter>Engine\Private</Filter>
    </ClCompile>
    <ClCompile Include="UnrealTypes.cpp">
      <Filter>Engine\Private</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Engine">
      <UniqueIdentifier>{0b2e1251-929c-4f5b-bd97-9f43d1e3d1a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Private">
      <UniqueIdentifier>{c14865ec-9225-40d7-ab6c-b7f7011841e2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Public">
      <UniqueIdentifier>{b5a6970c-66b5-4546-8bc3-8bc17d28045a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{da88a5f5-413a-4b03-9503-d846f46c9162}</UniqueIdentifier>
    </Filter>
    <Filter Include="Generator">
      <UniqueIdentifier>{a6bcdd0a-a630-4efa-bd57-2592e3c779cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Generator\Private">
      <UniqueIdentifier>{08d7d513-d8c3-4514-8b6e-c7843ff07ded}</UniqueIdentifier>
    </Filter>
    <Filter Include="Generator\Public">
      <UniqueIdentifier>{6e2d36b6-6458-4b6a-9568-d2ac002e81c7}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ObjectArray.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="UnrealTypes.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="Enums.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="UnrealObjects.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="OffsetFinder.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
    <ClInclude Include="Generator.h">
      <Filter>Generator\Public</Filter>
    </ClInclude>
    <ClInclude Include="Types.h">
      <Filter>Generator\Public</Filter>
    </ClInclude>
    <ClInclude Include="Package.h">
      <Filter>Generator\Public</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Generator</Filter>
    </ClInclude>
    <ClInclude Include="FileWriter.h">
      <Filter>Generator\Public</Filter>
    </ClInclude>
    <ClInclude Include="NameArray.h">
      <Filter>Engine\Public</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Dumper/Enums.h`:

```h
#pragma once

#include <cstdint>
#include <type_traits>
#include <sstream>
#include <vector>

typedef __int8 int8;
typedef __int16 int16;
typedef __int32 int32;
typedef __int64 int64;

typedef unsigned __int8 uint8;
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
typedef unsigned __int64 uint64;

#define ENUM_OPERATORS(EEnumClass)																																		\
																																										\
inline constexpr EEnumClass operator|(EEnumClass Left, EEnumClass Right)																								\
{																																										\
	return (EEnumClass)((std::underlying_type<EEnumClass>::type)(Left) | (std::underlying_type<EEnumClass>::type)(Right));												\
}																																										\
																																										\
inline bool operator&(EEnumClass Left, EEnumClass Right)																												\
{																																										\
	return (((std::underlying_type<EEnumClass>::type)(Left) & (std::underlying_type<EEnumClass>::type)(Right)) == (std::underlying_type<EEnumClass>::type)(Right));		\
}																																										
																																																																																		
enum class EPropertyFlags : uint64
{
	None							= 0x0000000000000000,

	Edit							= 0x0000000000000001,
	ConstParm						= 0x0000000000000002,
	BlueprintVisible				= 0x0000000000000004,
	ExportObject					= 0x0000000000000008,
	BlueprintReadOnly				= 0x0000000000000010,
	Net								= 0x0000000000000020,
	EditFixedSize					= 0x0000000000000040,
	Parm							= 0x0000000000000080,
	OutParm							= 0x0000000000000100,
	ZeroConstructor					= 0x0000000000000200,
	ReturnParm						= 0x0000000000000400,
	DisableEditOnTemplate 			= 0x0000000000000800,

	Transient						= 0x0000000000002000,
	Config							= 0x0000000000004000,

	DisableEditOnInstance			= 0x0000000000010000,
	EditConst						= 0x0000000000020000,
	GlobalConfig					= 0x0000000000040000,
	InstancedReference				= 0x0000000000080000,	

	DuplicateTransient				= 0x0000000000200000,	
	SubobjectReference				= 0x0000000000400000,	

	SaveGame						= 0x0000000001000000,
	NoClear							= 0x0000000002000000,

	ReferenceParm					= 0x0000000008000000,
	BlueprintAssignable				= 0x0000000010000000,
	Deprecated						= 0x0000000020000000,
	IsPlainOldData					= 0x0000000040000000,
	RepSkip							= 0x0000000080000000,
	RepNotify						= 0x0000000100000000, 
	Interp							= 0x0000000200000000,
	NonTransactional				= 0x0000000400000000,
	EditorOnly						= 0x0000000800000000,
	NoDestructor					= 0x0000001000000000,

	AutoWeak						= 0x0000004000000000,
	ContainsInstancedReference		= 0x0000008000000000,	
	AssetRegistrySearchable			= 0x0000010000000000,
	SimpleDisplay					= 0x0000020000000000,
	AdvancedDisplay					= 0x0000040000000000,
	Protected						= 0x0000080000000000,
	BlueprintCallable				= 0x0000100000000000,
	BlueprintAuthorityOnly			= 0x0000200000000000,
	TextExportTransient				= 0x0000400000000000,
	NonPIEDuplicateTransient		= 0x0000800000000000,
	ExposeOnSpawn					= 0x0001000000000000,
	PersistentInstance				= 0x0002000000000000,
	UObjectWrapper					= 0x0004000000000000, 
	HasGetValueTypeHash				= 0x0008000000000000, 
	NativeAccessSpecifierPublic		= 0x0010000000000000,	
	NativeAccessSpecifierProtected	= 0x0020000000000000,
	NativeAccessSpecifierPrivate	= 0x0040000000000000,	
	SkipSerialization				= 0x0080000000000000, 
};

enum class EFunctionFlags : uint32
{
	None					= 0x00000000,

	Final					= 0x00000001,
	RequiredAPI				= 0x00000002,
	BlueprintAuthorityOnly	= 0x00000004, 
	BlueprintCosmetic		= 0x00000008, 
	Net						= 0x00000040,  
	NetReliable				= 0x00000080, 
	NetRequest				= 0x00000100,	
	Exec					= 0x00000200,	
	Native					= 0x00000400,	
	Event					= 0x00000800,   
	NetResponse				= 0x00001000,  
	Static					= 0x00002000,   
	NetMulticast			= 0x00004000,	
	UbergraphFunction		= 0x00008000,  
	MulticastDelegate		= 0x00010000,
	Public					= 0x00020000,	
	Private					= 0x00040000,	
	Protected				= 0x00080000,
	Delegate				= 0x00100000,	
	NetServer				= 0x00200000,	
	HasOutParms				= 0x00400000,	
	HasDefaults				= 0x00800000,
	NetClient				= 0x01000000,
	DLLImport				= 0x02000000,
	BlueprintCallable		= 0x04000000,
	BlueprintEvent			= 0x08000000,
	BlueprintPure			= 0x10000000,	
	EditorOnly				= 0x20000000,	
	Const					= 0x40000000,
	NetValidate				= 0x80000000,

	AllFlags = 0xFFFFFFFF,
};

enum class EObjectFlags
{
	NoFlags							= 0x00000000,

	Public							= 0x00000001,
	Standalone						= 0x00000002,
	MarkAsNative					= 0x00000004,
	Transactional					= 0x00000008,
	ClassDefaultObject				= 0x00000010,
	ArchetypeObject					= 0x00000020,
	Transient						= 0x00000040,

	MarkAsRootSet					= 0x00000080,
	TagGarbageTemp					= 0x00000100,

	NeedInitialization				= 0x00000200,
	NeedLoad						= 0x00000400,
	KeepForCooker					= 0x00000800,
	NeedPostLoad					= 0x00001000,
	NeedPostLoadSubobjects			= 0x00002000,
	NewerVersionExists				= 0x00004000,
	BeginDestroyed					= 0x00008000,
	FinishDestroyed					= 0x00010000,

	BeingRegenerated				= 0x00020000,
	DefaultSubObject				= 0x00040000,
	WasLoaded						= 0x00080000,
	TextExportTransient				= 0x00100000,
	LoadCompleted					= 0x00200000,
	InheritableComponentTemplate	= 0x00400000,
	DuplicateTransient				= 0x00800000,
	StrongRefOnFrame				= 0x01000000,
	NonPIEDuplicateTransient		= 0x02000000,
	Dynamic							= 0x04000000,
	WillBeLoaded					= 0x08000000, 
};

enum class EFieldClassID : uint64
{
	Int8					= 1llu << 1,
	Byte					= 1llu << 6,
	Int						= 1llu << 7,
	Float					= 1llu << 8,
	UInt64					= 1llu << 9,
	Class					= 1llu << 10,
	UInt32					= 1llu << 11,
	Interface				= 1llu << 12,
	Name					= 1llu << 13,
	String					= 1llu << 14,
	Object					= 1llu << 16,
	Bool					= 1llu << 17,
	UInt16					= 1llu << 18,
	Struct					= 1llu << 20,
	Array					= 1llu << 21,
	Int64					= 1llu << 22,
	Delegate				= 1llu << 23,
	SoftObject				= 1llu << 27,
	LazyObject				= 1llu << 28,
	WeakObject				= 1llu << 29,
	Text					= 1llu << 30,
	Int16					= 1llu << 31,
	Double					= 1llu << 32,
	SoftClass				= 1llu << 33,
	Map						= 1llu << 46,
	Set						= 1llu << 47,
	Enum					= 1llu << 48,
	MulticastInlineDelegate = 1llu << 50,
	MulticastSparseDelegate = 1llu << 51,
	ObjectPointer			= 1llu << 53
};

enum class EClassCastFlags : uint64
{
	None								= 0x0000000000000000,

	Field								= 0x0000000000000001,
	Int8Property						= 0x0000000000000002,
	Enum								= 0x0000000000000004,
	Struct								= 0x0000000000000008,
	ScriptStruct						= 0x0000000000000010,
	Class								= 0x0000000000000020,
	ByteProperty						= 0x0000000000000040,
	IntProperty							= 0x0000000000000080,
	FloatProperty						= 0x0000000000000100,
	UInt64Property						= 0x0000000000000200,
	ClassProperty						= 0x0000000000000400,
	UInt32Property						= 0x0000000000000800,
	InterfaceProperty					= 0x0000000000001000,
	NameProperty						= 0x0000000000002000,
	StrProperty							= 0x0000000000004000,
	Property							= 0x0000000000008000,
	ObjectProperty						= 0x0000000000010000,
	BoolProperty						= 0x0000000000020000,
	UInt16Property						= 0x0000000000040000,
	Function							= 0x0000000000080000,
	StructProperty						= 0x0000000000100000,
	ArrayProperty						= 0x0000000000200000,
	Int64Property						= 0x0000000000400000,
	DelegateProperty					= 0x0000000000800000,
	NumericProperty						= 0x0000000001000000,
	MulticastDelegateProperty			= 0x0000000002000000,
	ObjectPropertyBase					= 0x0000000004000000,
	WeakObjectProperty					= 0x0000000008000000,
	LazyObjectProperty					= 0x0000000010000000,
	SoftObjectProperty					= 0x0000000020000000,
	TextProperty						= 0x0000000040000000,
	Int16Property						= 0x0000000080000000,
	DoubleProperty						= 0x0000000100000000,
	SoftClassProperty					= 0x0000000200000000,
	Package								= 0x0000000400000000,
	Level								= 0x0000000800000000,
	Actor								= 0x0000001000000000,
	PlayerController					= 0x0000002000000000,
	Pawn								= 0x0000004000000000,
	SceneComponent						= 0x0000008000000000,
	PrimitiveComponent					= 0x0000010000000000,
	SkinnedMeshComponent				= 0x0000020000000000,
	SkeletalMeshComponent				= 0x0000040000000000,
	Blueprint							= 0x0000080000000000,
	DelegateFunction					= 0x0000100000000000,
	StaticMeshComponent					= 0x0000200000000000,
	MapProperty							= 0x0000400000000000,
	SetProperty							= 0x0000800000000000,
	EnumProperty						= 0x0001000000000000,
	SparseDelegateFunction				= 0x0002000000000000,
	MulticastInlineDelegateProperty		= 0x0004000000000000,
	MulticastSparseDelegateProperty		= 0x0008000000000000,
	FieldPathProperty					= 0x0010000000000000,
	ObjectPtrProperty					= 0x0020000000000000,
	ClassPtrProperty					= 0x0040000000000000,
	LargeWorldCoordinatesRealProperty	= 0x0080000000000000,
};

enum class EClassFlags
{
	CLASS_None					= 0x00000000u,
	Abstract					= 0x00000001u,
	DefaultConfig				= 0x00000002u,
	Config						= 0x00000004u,
	Transient					= 0x00000008u,
	Parsed						= 0x00000010u,
	MatchedSerializers			= 0x00000020u,
	ProjectUserConfig			= 0x00000040u,
	Native						= 0x00000080u,
	NoExport					= 0x00000100u,
	NotPlaceable				= 0x00000200u,
	PerObjectConfig				= 0x00000400u,
	ReplicationDataIsSetUp		= 0x00000800u,
	EditInlineNew				= 0x00001000u,
	CollapseCategories			= 0x00002000u,
	Interface					= 0x00004000u,
	CustomConstructor			= 0x00008000u,
	Const						= 0x00010000u,
	LayoutChanging				= 0x00020000u,
	CompiledFromBlueprint		= 0x00040000u,
	MinimalAPI					= 0x00080000u,
	RequiredAPI					= 0x00100000u,
	DefaultToInstanced			= 0x00200000u,
	TokenStreamAssembled		= 0x00400000u,
	HasInstancedReference		= 0x00800000u,
	Hidden						= 0x01000000u,
	Deprecated					= 0x02000000u,
	HideDropDown				= 0x04000000u,
	GlobalUserConfig			= 0x08000000u,
	Intrinsic					= 0x10000000u,
	Constructed					= 0x20000000u,
	ConfigDoNotCheckDefaults	= 0x40000000u,
	NewerVersionExists			= 0x80000000u,
};

enum class EMappingsTypeFlags : uint8
{
	ByteProperty,
	BoolProperty,
	IntProperty,
	FloatProperty,
	ObjectProperty,
	NameProperty,
	DelegateProperty,
	DoubleProperty,
	ArrayProperty,
	StructProperty,
	StrProperty,
	TextProperty,
	InterfaceProperty,
	MulticastDelegateProperty,
	WeakObjectProperty, //
	LazyObjectProperty, // When deserialized, these 3 properties will be SoftObjects
	AssetObjectProperty, //
	SoftObjectProperty,
	UInt64Property,
	UInt32Property,
	UInt16Property,
	Int64Property,
	Int16Property,
	Int8Property,
	MapProperty,
	SetProperty,
	EnumProperty,
	FieldPathProperty,

	Unknown = 0xFF
};

ENUM_OPERATORS(EObjectFlags);
ENUM_OPERATORS(EFunctionFlags);
ENUM_OPERATORS(EPropertyFlags);
ENUM_OPERATORS(EClassCastFlags);
ENUM_OPERATORS(EClassFlags);
ENUM_OPERATORS(EMappingsTypeFlags);
ENUM_OPERATORS(EFieldClassID);

static std::string StringifyFunctionFlags(EFunctionFlags FunctionFlags)
{
	std::vector<const char*> Buffer;

	if (FunctionFlags & EFunctionFlags::Final) { Buffer.push_back("Final"); }
	if (FunctionFlags & EFunctionFlags::RequiredAPI) { Buffer.push_back("RequiredAPI"); }
	if (FunctionFlags & EFunctionFlags::BlueprintAuthorityOnly) { Buffer.push_back("BlueprintAuthorityOnly"); }
	if (FunctionFlags & EFunctionFlags::BlueprintCosmetic) { Buffer.push_back("BlueprintCosmetic"); }
	if (FunctionFlags & EFunctionFlags::Net) { Buffer.push_back("Net"); }
	if (FunctionFlags & EFunctionFlags::NetReliable) { Buffer.push_back("NetReliable"); }
	if (FunctionFlags & EFunctionFlags::NetRequest) { Buffer.push_back("NetRequest"); }
	if (FunctionFlags & EFunctionFlags::Exec) { Buffer.push_back("Exec"); }
	if (FunctionFlags & EFunctionFlags::Native) { Buffer.push_back("Native"); }
	if (FunctionFlags & EFunctionFlags::Event) { Buffer.push_back("Event"); }
	if (FunctionFlags & EFunctionFlags::NetResponse) { Buffer.push_back("NetResponse"); }
	if (FunctionFlags & EFunctionFlags::Static) { Buffer.push_back("Static"); }
	if (FunctionFlags & EFunctionFlags::NetMulticast) { Buffer.push_back("NetMulticast"); }
	if (FunctionFlags & EFunctionFlags::UbergraphFunction) { Buffer.push_back("UbergraphFunction"); }
	if (FunctionFlags & EFunctionFlags::MulticastDelegate) { Buffer.push_back("MulticastDelegate"); }
	if (FunctionFlags & EFunctionFlags::Public) { Buffer.push_back("Public"); }
	if (FunctionFlags & EFunctionFlags::Private) { Buffer.push_back("Private"); }
	if (FunctionFlags & EFunctionFlags::Protected) { Buffer.push_back("Protected"); }
	if (FunctionFlags & EFunctionFlags::Delegate) { Buffer.push_back("Delegate"); }
	if (FunctionFlags & EFunctionFlags::NetServer) { Buffer.push_back("NetServer"); }
	if (FunctionFlags & EFunctionFlags::HasOutParms) { Buffer.push_back("HasOutParams"); }
	if (FunctionFlags & EFunctionFlags::HasDefaults) { Buffer.push_back("HasDefaults"); }
	if (FunctionFlags & EFunctionFlags::NetClient) { Buffer.push_back("NetClient"); }
	if (FunctionFlags & EFunctionFlags::DLLImport) { Buffer.push_back("DLLImport"); }
	if (FunctionFlags & EFunctionFlags::BlueprintCallable) { Buffer.push_back("BlueprintCallable"); }
	if (FunctionFlags & EFunctionFlags::BlueprintEvent) { Buffer.push_back("BlueprintEvent"); }
	if (FunctionFlags & EFunctionFlags::BlueprintPure) { Buffer.push_back("BlueprintPure"); }
	if (FunctionFlags & EFunctionFlags::EditorOnly) { Buffer.push_back("EditorOnly"); }
	if (FunctionFlags & EFunctionFlags::Const) { Buffer.push_back("Const"); }
	if (FunctionFlags & EFunctionFlags::NetValidate) { Buffer.push_back("NetValidate"); }

	switch (Buffer.size())
	{
	case 0:
		return std::string("None");
		break;
	case 1:
		return std::string(Buffer[0]);
		break;
	default:
		std::ostringstream os;
		std::copy(Buffer.begin(), Buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
		os << *Buffer.rbegin();
		return os.str();
	}
}

static std::string StringifyPropertyFlags(EPropertyFlags PropertyFlags)
{
	std::vector<const char*> Buffer;

	if (PropertyFlags & EPropertyFlags::Edit) { Buffer.push_back("Edit"); }
	if (PropertyFlags & EPropertyFlags::ConstParm) { Buffer.push_back("ConstParm"); }
	if (PropertyFlags & EPropertyFlags::BlueprintVisible) { Buffer.push_back("BlueprintVisible"); }
	if (PropertyFlags & EPropertyFlags::ExportObject) { Buffer.push_back("ExportObject"); }
	if (PropertyFlags & EPropertyFlags::BlueprintReadOnly) { Buffer.push_back("BlueprintReadOnly"); }
	if (PropertyFlags & EPropertyFlags::Net) { Buffer.push_back("Net"); }
	if (PropertyFlags & EPropertyFlags::EditFixedSize) { Buffer.push_back("EditFixedSize"); }
	if (PropertyFlags & EPropertyFlags::Parm) { Buffer.push_back("Parm"); }
	if (PropertyFlags & EPropertyFlags::OutParm) { Buffer.push_back("OutParm"); }
	if (PropertyFlags & EPropertyFlags::ZeroConstructor) { Buffer.push_back("ZeroConstructor"); }
	if (PropertyFlags & EPropertyFlags::ReturnParm) { Buffer.push_back("ReturnParm"); }
	if (PropertyFlags & EPropertyFlags::DisableEditOnTemplate) { Buffer.push_back("DisableEditOnTemplate"); }
	if (PropertyFlags & EPropertyFlags::Transient) { Buffer.push_back("Transient"); }
	if (PropertyFlags & EPropertyFlags::Config) { Buffer.push_back("Config"); }
	if (PropertyFlags & EPropertyFlags::DisableEditOnInstance) { Buffer.push_back("DisableEditOnInstance"); }
	if (PropertyFlags & EPropertyFlags::EditConst) { Buffer.push_back("EditConst"); }
	if (PropertyFlags & EPropertyFlags::GlobalConfig) { Buffer.push_back("GlobalConfig"); }
	if (PropertyFlags & EPropertyFlags::InstancedReference) { Buffer.push_back("InstancedReference"); }
	if (PropertyFlags & EPropertyFlags::DuplicateTransient) { Buffer.push_back("DuplicateTransient"); }
	if (PropertyFlags & EPropertyFlags::SubobjectReference) { Buffer.push_back("SubobjectReference"); }
	if (PropertyFlags & EPropertyFlags::SaveGame) { Buffer.push_back("SaveGame"); }
	if (PropertyFlags & EPropertyFlags::NoClear) { Buffer.push_back("NoClear"); }
	if (PropertyFlags & EPropertyFlags::ReferenceParm) { Buffer.push_back("ReferenceParm"); }
	if (PropertyFlags & EPropertyFlags::BlueprintAssignable) { Buffer.push_back("BlueprintAssignable"); }
	if (PropertyFlags & EPropertyFlags::Deprecated) { Buffer.push_back("Deprecated"); }
	if (PropertyFlags & EPropertyFlags::IsPlainOldData) { Buffer.push_back("IsPlainOldData"); }
	if (PropertyFlags & EPropertyFlags::RepSkip) { Buffer.push_back("RepSkip"); }
	if (PropertyFlags & EPropertyFlags::RepNotify) { Buffer.push_back("RepNotify"); }
	if (PropertyFlags & EPropertyFlags::Interp) { Buffer.push_back("Interp"); }
	if (PropertyFlags & EPropertyFlags::NonTransactional) { Buffer.push_back("NonTransactional"); }
	if (PropertyFlags & EPropertyFlags::EditorOnly) { Buffer.push_back("EditorOnly"); }
	if (PropertyFlags & EPropertyFlags::NoDestructor) { Buffer.push_back("NoDestructor"); }
	if (PropertyFlags & EPropertyFlags::AutoWeak) { Buffer.push_back("AutoWeak"); }
	if (PropertyFlags & EPropertyFlags::ContainsInstancedReference) { Buffer.push_back("ContainsInstancedReference"); }
	if (PropertyFlags & EPropertyFlags::AssetRegistrySearchable) { Buffer.push_back("AssetRegistrySearchable"); }
	if (PropertyFlags & EPropertyFlags::SimpleDisplay) { Buffer.push_back("SimpleDisplay"); }
	if (PropertyFlags & EPropertyFlags::AdvancedDisplay) { Buffer.push_back("AdvancedDisplay"); }
	if (PropertyFlags & EPropertyFlags::Protected) { Buffer.push_back("Protected"); }
	if (PropertyFlags & EPropertyFlags::BlueprintCallable) { Buffer.push_back("BlueprintCallable"); }
	if (PropertyFlags & EPropertyFlags::BlueprintAuthorityOnly) { Buffer.push_back("BlueprintAuthorityOnly"); }
	if (PropertyFlags & EPropertyFlags::TextExportTransient) { Buffer.push_back("TextExportTransient"); }
	if (PropertyFlags & EPropertyFlags::NonPIEDuplicateTransient) { Buffer.push_back("NonPIEDuplicateTransient"); }
	if (PropertyFlags & EPropertyFlags::ExposeOnSpawn) { Buffer.push_back("ExposeOnSpawn"); }
	if (PropertyFlags & EPropertyFlags::PersistentInstance) { Buffer.push_back("PersistentInstance"); }
	if (PropertyFlags & EPropertyFlags::UObjectWrapper) { Buffer.push_back("UObjectWrapper"); }
	if (PropertyFlags & EPropertyFlags::HasGetValueTypeHash) { Buffer.push_back("HasGetValueTypeHash"); }
	if (PropertyFlags & EPropertyFlags::NativeAccessSpecifierPublic) { Buffer.push_back("NativeAccessSpecifierPublic"); }
	if (PropertyFlags & EPropertyFlags::NativeAccessSpecifierProtected) { Buffer.push_back("NativeAccessSpecifierProtected"); }
	if (PropertyFlags & EPropertyFlags::NativeAccessSpecifierPrivate) { Buffer.push_back("NativeAccessSpecifierPrivate"); }

	switch (Buffer.size())
	{
	case 0:
		return std::string("None");
		break;
	case 1:
		return std::string(Buffer[0]);
		break;
	default:
		std::ostringstream os;
		std::copy(Buffer.begin(), Buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
		os << *Buffer.rbegin();
		return os.str();
	}
}

static std::string StringifyObjectFlags(EObjectFlags ObjFlags)
{
	std::vector<const char*> Buffer;

	if (ObjFlags & EObjectFlags::Public) { Buffer.push_back("Public"); }
	if (ObjFlags & EObjectFlags::Standalone) { Buffer.push_back("Standalone"); }
	if (ObjFlags & EObjectFlags::MarkAsNative) { Buffer.push_back("MarkAsNative"); }
	if (ObjFlags & EObjectFlags::Transactional) { Buffer.push_back("Transactional"); }
	if (ObjFlags & EObjectFlags::ClassDefaultObject) { Buffer.push_back("ClassDefaultObject"); }
	if (ObjFlags & EObjectFlags::ArchetypeObject) { Buffer.push_back("ArchetypeObject"); }
	if (ObjFlags & EObjectFlags::Transient) { Buffer.push_back("Transient"); }
	if (ObjFlags & EObjectFlags::MarkAsRootSet) { Buffer.push_back("MarkAsRootSet"); }
	if (ObjFlags & EObjectFlags::TagGarbageTemp) { Buffer.push_back("TagGarbageTemp"); }
	if (ObjFlags & EObjectFlags::NeedInitialization) { Buffer.push_back("NeedInitialization"); }
	if (ObjFlags & EObjectFlags::NeedLoad) { Buffer.push_back("NeedLoad"); }
	if (ObjFlags & EObjectFlags::KeepForCooker) { Buffer.push_back("KeepForCooker"); }
	if (ObjFlags & EObjectFlags::NeedPostLoad) { Buffer.push_back("NeedPostLoad"); }
	if (ObjFlags & EObjectFlags::NeedPostLoadSubobjects) { Buffer.push_back("NeedPostLoadSubobjects"); }
	if (ObjFlags & EObjectFlags::NewerVersionExists) { Buffer.push_back("NewerVersionExists"); }
	if (ObjFlags & EObjectFlags::BeginDestroyed) { Buffer.push_back("BeginDestroyed"); }
	if (ObjFlags & EObjectFlags::FinishDestroyed) { Buffer.push_back("FinishDestroyed"); }
	if (ObjFlags & EObjectFlags::BeingRegenerated) { Buffer.push_back("BeingRegenerated"); }
	if (ObjFlags & EObjectFlags::DefaultSubObject) { Buffer.push_back("DefaultSubObject"); }
	if (ObjFlags & EObjectFlags::WasLoaded) { Buffer.push_back("WasLoaded"); }
	if (ObjFlags & EObjectFlags::TextExportTransient) { Buffer.push_back("TextExportTransient"); }
	if (ObjFlags & EObjectFlags::LoadCompleted) { Buffer.push_back("LoadCompleted"); }
	if (ObjFlags & EObjectFlags::InheritableComponentTemplate) { Buffer.push_back("InheritableComponentTemplate"); }
	if (ObjFlags & EObjectFlags::DuplicateTransient) { Buffer.push_back("DuplicateTransient"); }
	if (ObjFlags & EObjectFlags::StrongRefOnFrame) { Buffer.push_back("StrongRefOnFrame"); }
	if (ObjFlags & EObjectFlags::NonPIEDuplicateTransient) { Buffer.push_back("NonPIEDuplicateTransient"); }
	if (ObjFlags & EObjectFlags::Dynamic) { Buffer.push_back("Dynamic"); }
	if (ObjFlags & EObjectFlags::WillBeLoaded) { Buffer.push_back("WillBeLoaded"); }

	switch (Buffer.size())
	{
	case 0:
		return std::string("None");
		break;
	case 1:
		return std::string(Buffer[0]);
		break;
	default:
		std::ostringstream os;
		std::copy(Buffer.begin(), Buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
		os << *Buffer.rbegin();
		return os.str();
	}
}

static std::string StringifyClassCastFlags(EClassCastFlags CastFlags)
{
	std::vector<const char*> Buffer;

	if (CastFlags & EClassCastFlags::Field) { Buffer.push_back("Field"); }
	if (CastFlags & EClassCastFlags::Int8Property) { Buffer.push_back("Int8Property"); }
	if (CastFlags & EClassCastFlags::Enum) { Buffer.push_back("Enum"); }
	if (CastFlags & EClassCastFlags::Struct) { Buffer.push_back("Struct"); }
	if (CastFlags & EClassCastFlags::ScriptStruct) { Buffer.push_back("ScriptStruct"); }
	if (CastFlags & EClassCastFlags::Class) { Buffer.push_back("Class"); }
	if (CastFlags & EClassCastFlags::ByteProperty) { Buffer.push_back("ByteProperty"); }
	if (CastFlags & EClassCastFlags::IntProperty) { Buffer.push_back("IntProperty"); }
	if (CastFlags & EClassCastFlags::FloatProperty) { Buffer.push_back("FloatProperty"); }
	if (CastFlags & EClassCastFlags::UInt64Property) { Buffer.push_back("UInt64Property"); }
	if (CastFlags & EClassCastFlags::ClassProperty) { Buffer.push_back("ClassProperty"); }
	if (CastFlags & EClassCastFlags::UInt32Property) { Buffer.push_back("UInt32Property"); }
	if (CastFlags & EClassCastFlags::InterfaceProperty) { Buffer.push_back("InterfaceProperty"); }
	if (CastFlags & EClassCastFlags::NameProperty) { Buffer.push_back("NameProperty"); }
	if (CastFlags & EClassCastFlags::StrProperty) { Buffer.push_back("StrProperty"); }
	if (CastFlags & EClassCastFlags::Property) { Buffer.push_back("Property"); }
	if (CastFlags & EClassCastFlags::ObjectProperty) { Buffer.push_back("ObjectProperty"); }
	if (CastFlags & EClassCastFlags::BoolProperty) { Buffer.push_back("BoolProperty"); }
	if (CastFlags & EClassCastFlags::UInt16Property) { Buffer.push_back("UInt16Property"); }
	if (CastFlags & EClassCastFlags::Function) { Buffer.push_back("Function"); }
	if (CastFlags & EClassCastFlags::StructProperty) { Buffer.push_back("StructProperty"); }
	if (CastFlags & EClassCastFlags::ArrayProperty) { Buffer.push_back("ArrayProperty"); }
	if (CastFlags & EClassCastFlags::Int64Property) { Buffer.push_back("Int64Property"); }
	if (CastFlags & EClassCastFlags::DelegateProperty) { Buffer.push_back("DelegateProperty"); }
	if (CastFlags & EClassCastFlags::NumericProperty) { Buffer.push_back("NumericProperty"); }
	if (CastFlags & EClassCastFlags::MulticastDelegateProperty) { Buffer.push_back("MulticastDelegateProperty"); }
	if (CastFlags & EClassCastFlags::ObjectPropertyBase) { Buffer.push_back("ObjectPropertyBase"); }
	if (CastFlags & EClassCastFlags::WeakObjectProperty) { Buffer.push_back("WeakObjectProperty"); }
	if (CastFlags & EClassCastFlags::LazyObjectProperty) { Buffer.push_back("LazyObjectProperty"); }
	if (CastFlags & EClassCastFlags::SoftObjectProperty) { Buffer.push_back("SoftObjectProperty"); }
	if (CastFlags & EClassCastFlags::TextProperty) { Buffer.push_back("TextProperty"); }
	if (CastFlags & EClassCastFlags::Int16Property) { Buffer.push_back("Int16Property"); }
	if (CastFlags & EClassCastFlags::DoubleProperty) { Buffer.push_back("DoubleProperty"); }
	if (CastFlags & EClassCastFlags::SoftClassProperty) { Buffer.push_back("SoftClassProperty"); }
	if (CastFlags & EClassCastFlags::Package) { Buffer.push_back("Package"); }
	if (CastFlags & EClassCastFlags::Level) { Buffer.push_back("Level"); }
	if (CastFlags & EClassCastFlags::Actor) { Buffer.push_back("Actor"); }
	if (CastFlags & EClassCastFlags::PlayerController) { Buffer.push_back("PlayerController"); }
	if (CastFlags & EClassCastFlags::Pawn) { Buffer.push_back("Pawn"); }
	if (CastFlags & EClassCastFlags::SceneComponent) { Buffer.push_back("SceneComponent"); }
	if (CastFlags & EClassCastFlags::PrimitiveComponent) { Buffer.push_back("PrimitiveComponent"); }
	if (CastFlags & EClassCastFlags::SkinnedMeshComponent) { Buffer.push_back("SkinnedMeshComponent"); }
	if (CastFlags & EClassCastFlags::SkeletalMeshComponent) { Buffer.push_back("SkeletalMeshComponent"); }
	if (CastFlags & EClassCastFlags::Blueprint) { Buffer.push_back("Blueprint"); }
	if (CastFlags & EClassCastFlags::DelegateFunction) { Buffer.push_back("DelegateFunction"); }
	if (CastFlags & EClassCastFlags::StaticMeshComponent) { Buffer.push_back("StaticMeshComponent"); }
	if (CastFlags & EClassCastFlags::MapProperty) { Buffer.push_back("MapProperty"); }
	if (CastFlags & EClassCastFlags::SetProperty) { Buffer.push_back("SetProperty"); }
	if (CastFlags & EClassCastFlags::EnumProperty) { Buffer.push_back("EnumProperty"); }
	if (CastFlags & EClassCastFlags::SparseDelegateFunction) { Buffer.push_back("SparseDelegateFunction"); }
	if (CastFlags & EClassCastFlags::MulticastInlineDelegateProperty) { Buffer.push_back("MulticastInlineDelegateProperty"); }
	if (CastFlags & EClassCastFlags::MulticastSparseDelegateProperty) { Buffer.push_back("MulticastSparseDelegateProperty"); }
	if (CastFlags & EClassCastFlags::FieldPathProperty) { Buffer.push_back("MarkAsFieldPathPropertyRootSet"); }
	if (CastFlags & EClassCastFlags::ObjectPtrProperty) { Buffer.push_back("ObjectPtrProperty"); }
	if (CastFlags & EClassCastFlags::ClassPtrProperty) { Buffer.push_back("ClassPtrProperty"); }
	if (CastFlags & EClassCastFlags::LargeWorldCoordinatesRealProperty) { Buffer.push_back("LargeWorldCoordinatesRealProperty"); }

	switch (Buffer.size())
	{
	case 0:
		return std::string("None");
		break;
	case 1:
		return std::string(Buffer[0]);
		break;
	default:
		std::ostringstream os;
		std::copy(Buffer.begin(), Buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
		os << *Buffer.rbegin();
		return os.str();
	}
}

static EMappingsTypeFlags EPropertyFlagsToMappingFlags(EClassCastFlags Flags)
{
	
	if (Flags & EClassCastFlags::ObjectProperty 
	|| Flags & EClassCastFlags::ClassProperty 
	|| Flags & EClassCastFlags::ObjectPtrProperty
	|| Flags & EClassCastFlags::ClassPtrProperty)
	{
		return EMappingsTypeFlags::ObjectProperty;
	}
	else if (Flags & EClassCastFlags::StructProperty)
	{
		return EMappingsTypeFlags::StructProperty;
	}
	else if (Flags & EClassCastFlags::Int8Property)
	{
		return EMappingsTypeFlags::Int8Property;
	}
	else if (Flags & EClassCastFlags::Int16Property)
	{
		return EMappingsTypeFlags::Int16Property;
	}
	else if (Flags & EClassCastFlags::IntProperty)
	{
		return EMappingsTypeFlags::IntProperty;
	}
	else if (Flags & EClassCastFlags::Int64Property)
	{
		return EMappingsTypeFlags::Int64Property;
	}
	else if (Flags & EClassCastFlags::UInt16Property)
	{
		return EMappingsTypeFlags::UInt16Property;
	}
	else if (Flags & EClassCastFlags::UInt32Property)
	{
		return EMappingsTypeFlags::UInt32Property;
	}
	else if (Flags & EClassCastFlags::UInt64Property)
	{
		return EMappingsTypeFlags::UInt64Property;
	}
	else if (Flags & EClassCastFlags::ArrayProperty)
	{
		return EMappingsTypeFlags::ArrayProperty;
	}
	else if (Flags & EClassCastFlags::FloatProperty)
	{
		return EMappingsTypeFlags::FloatProperty;
	}
	else if (Flags & EClassCastFlags::DoubleProperty)
	{
		return EMappingsTypeFlags::DoubleProperty;
	}
	else if (Flags & EClassCastFlags::BoolProperty)
	{
		return EMappingsTypeFlags::BoolProperty;
	}
	else if (Flags & EClassCastFlags::StrProperty)
	{
		return EMappingsTypeFlags::StrProperty;
	}
	else if (Flags & EClassCastFlags::NameProperty)
	{
		return EMappingsTypeFlags::NameProperty;
	}
	else if (Flags & EClassCastFlags::TextProperty)
	{
		return EMappingsTypeFlags::TextProperty;
	}
	else if (Flags & EClassCastFlags::EnumProperty)
	{
		return EMappingsTypeFlags::EnumProperty;
	}
	else if (Flags & EClassCastFlags::InterfaceProperty)
	{
		return EMappingsTypeFlags::InterfaceProperty;
	}
	else if (Flags & EClassCastFlags::MapProperty)
	{
		return EMappingsTypeFlags::MapProperty;
	}
	else if (Flags & EClassCastFlags::ByteProperty)
	{
		return EMappingsTypeFlags::ByteProperty;
	}
	else if (Flags & EClassCastFlags::MulticastDelegateProperty
	|| Flags & EClassCastFlags::MulticastInlineDelegateProperty
	|| Flags & EClassCastFlags::MulticastSparseDelegateProperty)
	{
		return EMappingsTypeFlags::MulticastDelegateProperty;
	}
	else if (Flags & EClassCastFlags::DelegateProperty)
	{
		return EMappingsTypeFlags::DelegateProperty;
	}
	else if (Flags & EClassCastFlags::SoftObjectProperty
	|| Flags & EClassCastFlags::SoftClassProperty)
	{
		return EMappingsTypeFlags::SoftObjectProperty;
	}
	else if (Flags & EClassCastFlags::WeakObjectProperty)
	{
		return EMappingsTypeFlags::WeakObjectProperty;
	}
	else if (Flags & EClassCastFlags::LazyObjectProperty)
	{
		return EMappingsTypeFlags::LazyObjectProperty;
	}
	else if (Flags & EClassCastFlags::SetProperty)
	{
		return EMappingsTypeFlags::SetProperty;
	}
	else if (Flags & EClassCastFlags::FieldPathProperty)
	{
		return EMappingsTypeFlags::FieldPathProperty;
	}

	return EMappingsTypeFlags::Unknown;
}
```

`Dumper/FileWriter.cpp`:

```cpp
#include "FileWriter.h"
#include "Settings.h"

FileWriter::FileWriter(const fs::path& FilePath)
{
	FileStream.open(FilePath);
	SetFileHeader();
}

FileWriter::FileWriter(const fs::path& FilePath, const std::string& FileName, FileType Type)
{
	CurrentFileType = Type;
	CurrentFile = FileName;
	SetFileType(Type);
	FileStream.open(FilePath / CurrentFile);
	if (!FileStream.is_open()) std::cout << "Couldn't open \"" << CurrentFile << "\"" << std::endl;
	SetFileHeader();
}

FileWriter::FileWriter(const std::string& FileName)
{
	CurrentFile = FileName;
	Open(CurrentFile);
	SetFileHeader();
}

FileWriter::FileWriter(const std::string& FileName, FileType Type)
{
	CurrentFile = FileName;
	CurrentFileType = Type;
	SetFileType(Type);
	Open(CurrentFile);
	SetFileHeader();
}

FileWriter::~FileWriter()
{
	Close();
}

void FileWriter::Open(std::string FileName)
{
	Close();
	CurrentFile = Settings::FilePrefix != nullptr ? Settings::FilePrefix + FileName : FileName;
	FileStream.open(CurrentFile);
}

void FileWriter::Open(std::string FileName, FileType Type)
{
	Close();
	CurrentFile = Settings::FilePrefix != nullptr ? Settings::FilePrefix + FileName : FileName;
	SetFileType(Type);
	Open(CurrentFile);
}

void FileWriter::Close()
{
	SetFileEnding();
	FileStream.flush();
	FileStream.close();
}

void FileWriter::Write(const std::string& Text)
{
	FileStream << Text;
}
void FileWriter::Write(std::string&& Text)
{
	FileStream << std::move(Text);
}

void FileWriter::WriteIncludes(Types::Includes& Includes)
{
	Write(Includes.GetGeneratedBody());
}

void FileWriter::WriteParamStruct(Types::Struct& Struct)
{
	if (Struct.IsEmpty())
		return;

	if (!bWroteParametersBefore)
	{
		bWroteParametersBefore = true;

		Write(
			R"(//---------------------------------------------------------------------------------------------------------------------
// PARAMETERS
//---------------------------------------------------------------------------------------------------------------------

)");
	}
	Write(Struct.GetGeneratedBody());
}

void FileWriter::WriteStruct(Types::Struct& Struct)
{
	Write(Struct.GetGeneratedBody());
}

void FileWriter::WriteStructs(std::vector<Types::Struct>& Structs)
{
	Write(
		R"(//---------------------------------------------------------------------------------------------------------------------
// STRUCTS
//---------------------------------------------------------------------------------------------------------------------

)");

	for (Types::Struct& Struct : Structs)
	{
		WriteStruct(Struct);
	}
}

void FileWriter::WriteEnum(Types::Enum& Enum)
{
	Write(Enum.GetGeneratedBody());
}

void FileWriter::WriteEnums(std::vector<Types::Enum>& Enums)
{
	Write(
		R"(//---------------------------------------------------------------------------------------------------------------------
// ENUMS
//---------------------------------------------------------------------------------------------------------------------

)");

	for (Types::Enum& Enum : Enums)
	{
		WriteEnum(Enum);
	}

	Write("\n");
}

void FileWriter::WriteFunction(Types::Function& Function)
{
	if (!bWroteFunctionsBefore)
	{
		bWroteFunctionsBefore = true;

		Write(
			R"(//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------

)");
	}

	Write(Function.GetGeneratedBody());
}

void FileWriter::WriteFunctions(std::vector<Types::Function>& Functions)
{
	for (Types::Function& Function : Functions)
	{
		WriteFunction(Function);
	}
}

void FileWriter::WriteClass(Types::Class& Class)
{
	Write(Class.GetGeneratedBody());
}

void FileWriter::WriteClasses(std::vector<Types::Class>& Classes)
{
	Write(
		R"(//---------------------------------------------------------------------------------------------------------------------
// CLASSES
//---------------------------------------------------------------------------------------------------------------------

)");
	for (Types::Class& Class : Classes)
	{
		WriteClass(Class);
	}
}

void FileWriter::SetFileType(FileType& Type)
{
	switch (Type)
	{
	case FileWriter::FileType::Parameter:
		CurrentFile += "_parameters.hpp";
		break;
	case FileWriter::FileType::Function:
		CurrentFile += "_functions.cpp";
		break;
	case FileWriter::FileType::Struct:
		CurrentFile += "_structs.hpp";
		break;
	case FileWriter::FileType::Class:
		CurrentFile += "_classes.hpp";
		break;
	case FileWriter::FileType::Source:
		CurrentFile += ".cpp";
		break;
	case FileWriter::FileType::Header:
		CurrentFile += ".hpp";
		break;
	default:
		CurrentFile += ".hpp";
		break;
	}
}

void FileWriter::SetFileHeader()
{
	FileStream << R"(#pragma once

// Dumped with Dumper-7!


)";

	if (CurrentFileType == FileType::Function || CurrentFileType == FileType::Parameter || CurrentFileType == FileType::Source)
		FileStream << "#include \"../SDK.hpp\"\n\n";

	if (Settings::SDKNamespaceName)
		FileStream << std::format("namespace {}\n{{\n", Settings::SDKNamespaceName);

	if (CurrentFileType == FileType::Parameter && Settings::ParamNamespaceName)
		FileStream << std::format("namespace {}\n{{\n", Settings::ParamNamespaceName);
}

void FileWriter::SetFileEnding()
{
	if (Settings::SDKNamespaceName)
		FileStream << "}\n";

	if (CurrentFileType == FileType::Parameter && Settings::ParamNamespaceName)
		FileStream << "}\n";

	FileStream << R"(

)";
}


std::ofstream& FileWriter::DebugGetStream()
{
	return FileStream;
}

```

`Dumper/FileWriter.h`:

```h
#pragma once

#include <filesystem>
#include "Types.h"
#include "Settings.h"

namespace fs = std::filesystem;

class FileWriter
{
	friend class Generator;

public:
	enum class FileType
	{
		Parameter,
		Function,
		Struct,
		Class,
		Source,
		Header
	};

private:
	std::ofstream FileStream;
	FileType CurrentFileType;
	std::string CurrentFile;
	bool bWroteFunctionsBefore;
	bool bWroteParametersBefore;

public:
	FileWriter(const fs::path& FilePath);
	FileWriter(const fs::path& FilePath, const std::string& FileName, FileType Type);
	FileWriter(const std::string& FileName);
	FileWriter(const std::string& FileName, FileType Type);
	~FileWriter();

	void Open(std::string FileName);
	void Open(std::string FileName, FileType Type);
	void Close();
	void Write(const std::string& Text);
	void Write(std::string&& Text);
	void WriteIncludes(Types::Includes& Includes);
	void WriteParamStruct(Types::Struct& Struct);
	void WriteStruct(Types::Struct& Struct);
	void WriteStructs(std::vector<Types::Struct>& Structs);
	void WriteEnum(Types::Enum& Enum);
	void WriteEnums(std::vector<Types::Enum>& Enums);
	void WriteFunction(Types::Function& Function);
	void WriteFunctions(std::vector<Types::Function>& Functions);
	void WriteClass(Types::Class& Class);
	void WriteClasses(std::vector<Types::Class>& Classes);
	void SetFileType(FileType& Type);
	void SetFileHeader();
	void SetFileEnding();

	std::ofstream& DebugGetStream();
};

template<class StreamType>
class MappingFileWriter
{
private:
	StreamType Stream;

public:
	MappingFileWriter() = default;

	MappingFileWriter(fs::path FilePath)
		: Stream(FilePath, std::ios::binary)
	{
	}

	template<typename T>
	inline void Write(T Data)
	{
		Stream.write(reinterpret_cast<const char*>(&Data), sizeof(Data));
	}

	inline void WriteStr(const std::string& Data)
	{
		Stream << Data;
	}

	inline uint32 GetSize()
	{
		Stream.flush();

		// yes, I pasted this from shade
		auto Pos = Stream.tellp();
		Stream.seekp(0, SEEK_END);
		auto Ret = Stream.tellp();
		Stream.seekp(Pos, SEEK_SET);

		return Ret;
	}

	inline auto Rdbuf()
	{
		return Stream.rdbuf();
	}

	template<class T>
	inline void CopyFromOtherBuffer(MappingFileWriter<T>& Other)
	{
		Stream.flush();

		Stream << Other.Rdbuf();
	}

	~MappingFileWriter()
	{
		Stream.flush();
	}
};

```

`Dumper/Generator.cpp`:

```cpp
#include "Generator.h"
#include "NameArray.h"

#include <future>

Generator::FunctionsMap Generator::PredefinedFunctions;
Generator::MemberMap Generator::PredefinedMembers;

std::mutex Generator::PackageMutex;
std::vector<std::future<void>> Generator::Futures;


void Generator::Init()
{
	/* manual override */
	//ObjectArray::Init(/*GObjects*/, /*ChunkSize*/, /*bIsChunked*/);
	//FName::Init(/*FName::AppendString*/);
	//Off::InSDK::InitPE(/*PEIndex*/);

	/* Back4Blood*/
	//InitObjectArrayDecryption([](void* ObjPtr) -> uint8* { return reinterpret_cast<uint8*>(uint64(ObjPtr) ^ 0x8375); });

	/* Multiversus [Unsupported, weird GObjects-struct]*/
	//InitObjectArrayDecryption([](void* ObjPtr) -> uint8* { return reinterpret_cast<uint8*>(uint64(ObjPtr) ^ 0x1B5DEAFD6B4068C); });

	ObjectArray::Init();
	FName::Init();
	Off::Init();
	Off::InSDK::InitPE(); //Must be last, relies on offsets initialized in Off::Init()

	InitPredefinedMembers();
	InitPredefinedFunctions();
}

void Generator::GenerateMappings()
{
	fs::path DumperFolder;
	fs::path GenFolder;

	try
	{
		DumperFolder = Settings::SDKGenerationPath;
		GenFolder = DumperFolder / (Settings::GameVersion + '-' + Settings::GameName + "_MAPPINGS");

		if (!fs::exists(DumperFolder))
		{
			fs::create_directories(DumperFolder);
		}

		if (fs::exists(GenFolder))
		{
			fs::path Old = GenFolder.generic_string() + "_OLD";

			fs::remove_all(Old);

			fs::rename(GenFolder, Old);
		}

		fs::create_directory(GenFolder);
	}
	catch (const std::filesystem::filesystem_error& fe)
	{
		std::cout << "Could not create required folders! Info: \n";
		std::cout << fe.what() << std::endl;
		return;
	}


	struct EnumInfo
	{
		std::vector<int32> MemberNames;
		int32 EnumNameIdx;

		EnumInfo(std::vector<int32>&& Names, int32 Idx)
			: MemberNames(std::move(Names)), EnumNameIdx(Idx)
		{
		}
	};

	struct StructInfo
	{
		int32 NameIdx;
		int32 SuperNameIdx;

		UEStruct SelfStruct;

		StructInfo(int32 Name, int32 SuperName, UEStruct Self)
			: NameIdx(Name), SuperNameIdx(SuperName), SelfStruct(Self)
		{
		}
	};

	MappingFileWriter<std::ofstream> MappingsStream(GenFolder / (Settings::GameVersion + ".usmap"));
	MappingFileWriter<std::stringstream> Buffer;

	std::unordered_map<int32, int32> NameIdxPairs;
	std::vector<EnumInfo> Enums;
	std::vector<StructInfo> Structs;

	int NameIndex = 0;

	auto WriteNameToBuffer = [&Buffer](FName Name)
	{
		std::string StrName = Name.ToString();

		StrName = StrName.substr(StrName.find_last_of(':') + 1);

		if (StrName.length() > 0xFF)
		{
			Buffer.Write<uint8>(0xFF);
			Buffer.WriteStr(StrName.substr(0, 0xFF));
		}
		else
		{
			Buffer.Write<uint8>(StrName.length());
			Buffer.WriteStr(StrName);
		}
	};

	for (auto Obj : ObjectArray())
	{
		if (Obj.IsA(EClassCastFlags::Struct))
		{
			UEStruct AsStruct = Obj.Cast<UEStruct>();

			auto [StructNameIt, bInsertedStructName] = NameIdxPairs.insert({ Obj.GetFName().GetCompIdx(), NameIndex });

			if (bInsertedStructName)
			{
				WriteNameToBuffer(Obj.GetFName());
				NameIndex++;
			}

			int32 SuperIdx = AsStruct.GetSuper() ? NameIdxPairs[AsStruct.GetSuper().GetFName().GetCompIdx()] : 0xFFFFFFFF;
			Structs.emplace_back(StructNameIt->second, SuperIdx, AsStruct);

			for (UEProperty Prop : Obj.Cast<UEStruct>().GetProperties())
			{
				auto [It, bInsertedPropName] = NameIdxPairs.insert({ Prop.GetFName().GetCompIdx(), NameIndex });

				if (bInsertedPropName)
				{
					WriteNameToBuffer(Prop.GetFName());
					NameIndex++;
				}
			}
		}
		else if (Obj.IsA(EClassCastFlags::Enum))
		{
			auto [EnumNameIt, bInsertedEnumname] = NameIdxPairs.insert({ Obj.GetFName().GetCompIdx(), NameIndex });

			if (bInsertedEnumname)
			{
				WriteNameToBuffer(Obj.GetFName());
				NameIndex++;
			}

			std::vector<int32> MemberNames;

			for (auto& [Name, Value] : Obj.Cast<UEEnum>().GetNameValuePairs())
			{
				auto [MemberNameIt, bInsertedMemberName] = NameIdxPairs.insert({ Name.GetCompIdx(), NameIndex });

				if (bInsertedMemberName)
				{
					WriteNameToBuffer(Name);
					NameIndex++;
				}

				MemberNames.push_back(MemberNameIt->second); //Index
			}

			Enums.emplace_back(std::move(MemberNames), EnumNameIt->second);
		}
	}

	auto WriteProperty = [&NameIdxPairs, &Buffer](UEProperty Property, auto&& WriteProperty) -> void
	{
		if (Property.IsA(EClassCastFlags::ByteProperty) && Property.Cast<UEByteProperty>().GetEnum()) 
			Buffer.Write<uint8>((uint8)EMappingsTypeFlags::EnumProperty);
		
		Buffer.Write<uint8>((uint8)Property.GetMappingType());

		if (Property.IsA(EClassCastFlags::EnumProperty))
		{
			UEEnumProperty EnumProperty = Property.Cast<UEEnumProperty>();

			WriteProperty(EnumProperty.GetUnderlayingProperty(), WriteProperty);

			auto Enum = EnumProperty.GetEnum();
			Buffer.Write<int32>(NameIdxPairs[Enum ? Enum.GetFName().GetCompIdx() : 0]);
		}
		else if (Property.IsA(EClassCastFlags::ByteProperty) && Property.Cast<UEByteProperty>().GetEnum())
		{
			Buffer.Write<int32>(NameIdxPairs[Property.Cast<UEByteProperty>().GetEnum().GetFName().GetCompIdx()]);
		}
		else if (Property.IsA(EClassCastFlags::StructProperty))
		{
			Buffer.Write<int32>(NameIdxPairs[Property.Cast<UEStructProperty>().GetUnderlayingStruct().GetFName().GetCompIdx()]);
		}
		else if (Property.IsA(EClassCastFlags::ArrayProperty))
		{
			WriteProperty(Property.Cast<UEArrayProperty>().GetInnerProperty(), WriteProperty);
		}
		else if (Property.IsA(EClassCastFlags::SetProperty))
		{
			WriteProperty(Property.Cast<UESetProperty>().GetElementProperty(), WriteProperty);
		}
		else if (Property.IsA(EClassCastFlags::MapProperty))
		{
			WriteProperty(Property.Cast<UEMapProperty>().GetKeyProperty(), WriteProperty);
			WriteProperty(Property.Cast<UEMapProperty>().GetValueProperty(), WriteProperty);
		}
	};

	Buffer.Write<uint32>(Enums.size());
	for (auto& Enum : Enums)
	{
		Buffer.Write<int32>(Enum.EnumNameIdx);
		Buffer.Write<uint8>(Enum.MemberNames.size());

		for (int32 NameIdx : Enum.MemberNames)
		{
			Buffer.Write<int32>(NameIdx);
		}
	}

	Buffer.Write<uint32>(Structs.size());
	for (auto& Struct : Structs)
	{
		Buffer.Write<int32>(Struct.NameIdx);
		Buffer.Write<int32>(Struct.SuperNameIdx);

		uint16 PropertyCount = 0;
		uint16 SerializableCount = 0;

		auto Properties = Struct.SelfStruct.GetProperties();

		for (auto Property : Properties)
		{
			PropertyCount += Property.GetArrayDim();
			SerializableCount++;
		}

		Buffer.Write<uint16>(PropertyCount);
		Buffer.Write<uint16>(SerializableCount);

		SerializableCount = 0; // recycling for indices

		for (auto Property : Properties)
		{
			Buffer.Write<uint16>(SerializableCount); // Index
			Buffer.Write<uint8>(Property.GetArrayDim());
			Buffer.Write<int32>(NameIdxPairs[Property.GetFName().GetCompIdx()]);

			WriteProperty(Property, WriteProperty);

			SerializableCount++;
		}
	}

	uint32 DataSize = Buffer.GetSize() + 0xF;

	// HEADER
	MappingsStream.Write<uint16>(0x30C4); //MAGIC
	MappingsStream.Write<uint8>(0); // EUsmapVersion::Initial
	//only when versioning >= 1
	//MappingsStream.Write<int32>(false); // EUsmapVersion::PackageVersioning yes, someone decided int == bool in CUE4 Parser

	//Versioning info here

	MappingsStream.Write<uint8>(0); //CompressionMethode::None
	MappingsStream.Write<uint32>(DataSize); // CompressedSize
	MappingsStream.Write<uint32>(DataSize); // DecompressedSize
	
	MappingsStream.Write<uint32>(NameIndex); // NameCount
	
	//move data to other stream
	MappingsStream.CopyFromOtherBuffer(Buffer);
}

void Generator::GenerateIDAMappings()
{
	fs::path DumperFolder;
	fs::path GenFolder;

	try
	{
		DumperFolder = Settings::SDKGenerationPath;
		GenFolder = DumperFolder / (Settings::GameVersion + '-' + Settings::GameName + "_IDA_MAPPINGS");

		if (!fs::exists(DumperFolder))
		{
			fs::create_directories(DumperFolder);
		}

		if (fs::exists(GenFolder))
		{
			fs::path Old = GenFolder.generic_string() + "_OLD";

			fs::remove_all(Old);

			fs::rename(GenFolder, Old);
		}

		fs::create_directory(GenFolder);
	}
	catch (const std::filesystem::filesystem_error& fe)
	{
		std::cout << "Could not create required folders! Info: \n";
		std::cout << fe.what() << std::endl;
		return;
	}

	/*
	uint32 Offset;
	uint16 NameLen;
	char*  Name[NmaeLen];
	*/
	std::ofstream IDAMappingsStream(GenFolder / (Settings::GameVersion + ".idmap"), std::ios::binary);

	for (UEObject Obj : ObjectArray())
	{
		if (Obj.HasAnyFlags(EObjectFlags::ClassDefaultObject))
		{
			UEClass Super = Obj.GetClass().GetSuper().Cast<UEClass>();

			if (Super && Obj.GetVft() == Super.GetDefaultObject().GetVft())
				continue;
			
			std::string Name = Obj.GetClass().GetCppName() + "_VFT";

			uint32 Offset = static_cast<uint32>(GetOffset(Obj.GetVft()));
			uint16 NameLen = static_cast<uint16>(Name.length());

			IDAMappingsStream.write(reinterpret_cast<const char*>(&Offset), sizeof(Offset));
			IDAMappingsStream.write(reinterpret_cast<const char*>(&NameLen), sizeof(NameLen));
			IDAMappingsStream.write(Name.c_str(), NameLen);
		}
		else if (Obj.IsA(EClassCastFlags::Class))
		{
			static auto MangleFunctionName = [](std::string&& ClassName, std::string&& FuncName) -> std::string
			{
				return "_ZN" + std::to_string(ClassName.length()) + ClassName + std::to_string(FuncName.length() + 4) + "exec" + FuncName + "Ev";
			};

			for (UEField F = Obj.Cast<UEClass>().GetChild(); F; F = F.GetNext())
			{
				if (!F.IsA(EClassCastFlags::Function))
					continue;

				std::string MangledName = MangleFunctionName(Obj.Cast<UEClass>().GetCppName(), F.Cast<UEFunction>().GetValidName());

				uint32 Offset = static_cast<uint32>(GetOffset(F.Cast<UEFunction>().GetExecFunction()));
				uint16 NameLen = static_cast<uint16>(MangledName.length());

				IDAMappingsStream.write(reinterpret_cast<const char*>(&Offset), sizeof(Offset));
				IDAMappingsStream.write(reinterpret_cast<const char*>(&NameLen), sizeof(NameLen));
				IDAMappingsStream.write(MangledName.c_str(), NameLen);
			}
		}
	}

	IDAMappingsStream.close();
}

void Generator::HandlePackageGeneration(const fs::path* const SDKFolder, int32 PackageIndex, std::vector<int32>* MemberIndices)
{
	UEObject Object = ObjectArray::GetByIndex(PackageIndex);

	if (!Object)
		return;

	Package Pack(Object);

	PackageMutex.lock();
	Package::AddPackage(PackageIndex);
	Pack.GatherDependencies(*MemberIndices);
	PackageMutex.unlock();

	Pack.Process(*MemberIndices);

	if (!Pack.IsEmpty())
	{
		std::string PackageName = Object.GetName();
		std::string FileName = Settings::FilePrefix ? Settings::FilePrefix + PackageName : PackageName;

		if (fs::exists(*SDKFolder / (FileName + "_classes.hpp")))
			FileName += "_1";

		FileWriter ClassFile(*SDKFolder, FileName, FileWriter::FileType::Class);
		ClassFile.WriteClasses(Pack.AllClasses);
		ClassFile.Close();

		FileWriter StructsFile(*SDKFolder, FileName, FileWriter::FileType::Struct);
		StructsFile.WriteEnums(Pack.AllEnums);
		StructsFile.WriteStructs(Pack.AllStructs);
		ClassFile.Close();

		FileWriter FunctionFile(*SDKFolder, FileName, FileWriter::FileType::Function);
		FileWriter ParameterFile(*SDKFolder, FileName, FileWriter::FileType::Parameter);

		if (PackageName == "CoreUObject")
			FunctionFile.Write("\t//Initialize GObjects using InitGObjects()\n\tTUObjectArray* UObject::GObjects = nullptr;\n\n");

		for (auto& [ClassName, PackageFunctionsPairs] : Generator::PredefinedFunctions)
		{
			if (PackageFunctionsPairs.first != PackageName)
				continue;

			for (auto& PredefFunc : PackageFunctionsPairs.second)
			{
				if (!PredefFunc.DeclarationCPP.empty())
				{
					FunctionFile.Write(PredefFunc.DeclarationCPP);
					FunctionFile.Write(PredefFunc.Body);
					FunctionFile.Write("\n");
				}
			}
		}

		for (auto& Function : Pack.AllFunctions)
		{
			FunctionFile.WriteFunction(Function);
			ParameterFile.WriteParamStruct(Function.GetParamStruct());
		}
	}
	else
	{
		PackageMutex.lock();
		Package::PackageSorterClasses.RemoveDependant(PackageIndex);
		Package::PackageSorterStructs.RemoveDependant(PackageIndex);
		PackageMutex.unlock();
	}
}

void Generator::GenerateSDK()
{
	std::unordered_map<int32_t, std::vector<int32_t>> ObjectPackages;

	ObjectArray::GetAllPackages(ObjectPackages);

	fs::path DumperFolder;
	fs::path GenFolder;
	fs::path SDKFolder;

	try
	{
		DumperFolder = Settings::SDKGenerationPath;
		GenFolder = DumperFolder / (Settings::GameVersion + '-' + Settings::GameName);
		SDKFolder = GenFolder / "SDK";

		if (!fs::exists(DumperFolder))
		{
			fs::create_directories(DumperFolder);
		}

		if (fs::exists(GenFolder))
		{
			fs::path Old = GenFolder.generic_string() + "_OLD";

			fs::remove_all(Old);

			fs::rename(GenFolder, Old);
		}

		fs::create_directory(GenFolder);
		fs::create_directory(SDKFolder);
	}
	catch (const std::filesystem::filesystem_error& fe)
	{
		std::cout << "Could not create required folders! Info: \n"; 
		std::cout << fe.what() << std::endl;
		return;
	}

	ObjectArray::DumpObjects();

	Package::InitAssertionStream(GenFolder);


	// Determine main-package of the game
	int32 IndexOfBiggestPackage = 0;
	int32 SizeOfBiggestPackage = 0;

	for (const auto& [PackageIdx, DependencyVector] : ObjectPackages)
	{
		if (DependencyVector.size() > SizeOfBiggestPackage)
		{
			SizeOfBiggestPackage = DependencyVector.size();
			IndexOfBiggestPackage = PackageIdx;
		}
	}

	_setmaxstdio(0x800); // set number of files which can be open simultaneously

	Futures.reserve(ObjectPackages.size());

	for (auto& [PackageIndex, MemberIndices] : ObjectPackages)
	{
		Futures.push_back(std::async(std::launch::async, HandlePackageGeneration, &SDKFolder, PackageIndex, &MemberIndices));
	}

	for (auto& Future : Futures)
	{
		Future.wait();
	}

	Futures.clear();

	Package::CloseAssertionStream();

	GenerateSDKHeader(GenFolder, IndexOfBiggestPackage);
	GenerateFixupFile(GenFolder);
	GenerateBasicFile(SDKFolder);

	std::cout << "\n\n[=] Done [=]\n\n";
}

void Generator::GenerateSDKHeader(const fs::path& SdkPath, int32 BiggestPackageIdx)
{
	std::ofstream HeaderStream(SdkPath / "SDK.hpp");

	HeaderStream << "#pragma once\n\n";
	HeaderStream << "// Made with <3 by me [Encryqed] && you [Fischsalat] + him [TempAccountNull]\n\n";

	HeaderStream << std::format("// {}\n", Settings::GameName);
	HeaderStream << std::format("// {}\n\n", Settings::GameVersion);
	HeaderStream << std::format("// Main-package: {}\n\n", ObjectArray::GetByIndex(BiggestPackageIdx).GetValidName());

	HeaderStream << "#include <string>\n";
	HeaderStream << "#include <Windows.h>\n";
	HeaderStream << "#include <iostream>\n";
	HeaderStream << "#include <type_traits>\n\n";

	HeaderStream << "typedef __int8 int8;\n";
	HeaderStream << "typedef __int16 int16;\n";
	HeaderStream << "typedef __int32 int32;\n";
	HeaderStream << "typedef __int64 int64;\n\n";

	HeaderStream << "typedef unsigned __int8 uint8;\n";
	HeaderStream << "typedef unsigned __int16 uint16;\n";
	HeaderStream << "typedef unsigned __int32 uint32;\n";
	HeaderStream << "typedef unsigned __int64 uint64;\n";

	HeaderStream << std::format(
		R"(
namespace Offsets
{{
	constexpr int32 GObjects          = 0x{:08X};
	constexpr int32 AppendString      = 0x{:08X};
	constexpr int32 GNames            = 0x{:08X};
	constexpr int32 ProcessEvent      = 0x{:08X};
	constexpr int32 ProcessEventIdx   = 0x{:08X};
}}
)", Off::InSDK::GObjects, Off::InSDK::AppendNameToString, Off::InSDK::GNames, Off::InSDK::PEOffset, Off::InSDK::PEIndex);

	if (Settings::XORString)
		HeaderStream << std::format("#define {}(str) str\n", Settings::XORString);

	HeaderStream << "\n#include \"PropertyFixup.hpp\"\n";
	HeaderStream << "\n#include \"SDK/" << (Settings::FilePrefix ? Settings::FilePrefix : "") << "Basic.hpp\"\n";

	if (Settings::bIncludeOnlyRelevantPackages)
	{
		std::string IncludesString;

		Package::PackageSorterStructs.GetIncludesForPackage(BiggestPackageIdx, EIncludeFileType::Struct, IncludesString, false);
		HeaderStream << IncludesString;

		IncludesString.clear();

		Package::PackageSorterClasses.GetIncludesForPackage(BiggestPackageIdx, EIncludeFileType::Class, IncludesString, false, &Package::PackageSorterStructs, EIncludeFileType::Struct);
		HeaderStream << IncludesString;
		
		IncludesString.clear();
		
		Package::PackageSorterParams.GetIncludesForPackage(BiggestPackageIdx, EIncludeFileType::Params, IncludesString, false);
		HeaderStream << IncludesString;
	}

	for (auto& Pack : Package::PackageSorterStructs.AllDependencies)
	{
		std::string IncludesString;
		Package::PackageSorterStructs.GetIncludesForPackage(Pack.first, EIncludeFileType::Struct, IncludesString, Settings::bIncludeOnlyRelevantPackages);

		HeaderStream << IncludesString;
	}

	for (auto& Pack : Package::PackageSorterClasses.AllDependencies)
	{
		std::string IncludesString;
		Package::PackageSorterClasses.GetIncludesForPackage(Pack.first, EIncludeFileType::Class, IncludesString, Settings::bIncludeOnlyRelevantPackages, &Package::PackageSorterStructs, EIncludeFileType::Struct);
	
		HeaderStream << IncludesString;
	}
	
	for (auto& Pack : Package::PackageSorterParams.AllDependencies)
	{
		std::string IncludesString;
		Package::PackageSorterParams.GetIncludesForPackage(Pack.first, EIncludeFileType::Params, IncludesString, Settings::bIncludeOnlyRelevantPackages);
	
		HeaderStream << IncludesString;
	}

	if constexpr (Settings::Debug::bGenerateAssertionsForPredefinedMembers)
	{
		HeaderStream << "\n\n";

		for (auto& Predef : Generator::PredefinedMembers)
		{
			HeaderStream << "\n";

			for (auto& Member : Predef.second)
			{
				if (Member.Size == 0)
					continue;

				std::string Name = Member.Name;

				const int ArrayInfo = Member.Name.find_first_of("[");
				if (ArrayInfo != -1)
					Name = Member.Name.substr(0, ArrayInfo);

				HeaderStream << std::format("static_assert(offsetof({3}::{0}, {1}) == 0x{2:X}, \"{0}::{1} has a wrong offset!\");\n", Predef.first, Name, Member.Offset, Settings::SDKNamespaceName ? Settings::SDKNamespaceName : "");
			}
		}
	}

	HeaderStream.close();
}

void Generator::GenerateFixupFile(const fs::path& SdkPath)
{
	std::ofstream FixupStream(SdkPath / "PropertyFixup.hpp");

	FixupStream << "#pragma once\n\n";

	FixupStream << "// Definitions for missing Properties\n\n";

	for (auto& Property : UEProperty::UnknownProperties)
	{
		FixupStream << std::format("class {}\n{{\n\tunsigned __int8 Pad[0x{:X}];\n}};\n\n", Property.first, Property.second);
	}
}

void Generator::InitPredefinedMembers()
{
	auto PrefixPropertyName = [](std::string&& Name) -> std::string
	{
		return (Settings::Internal::bUseFProperty ? 'F' : 'U') + std::move(Name);
	};
	
	PredefinedMembers["UObject"] =
	{
		{ "static class TUObjectArray*", "GObjects", 0x00, 0x00},
		{ "void*", "Vft", Off::UObject::Vft, 0x08 },
		{ "int32 ", "Flags", Off::UObject::Flags, 0x04 },
		{ "int32", "Index", Off::UObject::Index, 0x04 },
		{ "class UClass*", "Class", Off::UObject::Class, 0x08 },
		{ "class FName", "Name", Off::UObject::Name, Off::InSDK::FNameSize },
		{ "class UObject*", "Outer", Off::UObject::Outer, 0x08 }
	};

	PredefinedMembers["UField"] =
	{
		{ "class UField*", "Next", Off::UField::Next, 0x08 }
	};

	PredefinedMembers["UEnum"] =
	{
		{ "class TArray<class TPair<class FName, int64>>", "Names", Off::UEnum::Names, 0x10 }
	};

	PredefinedMembers["UStruct"] =
	{
		{ "class UStruct*", "Super", Off::UStruct::SuperStruct, 0x08 },
		{ "class UField*", "Children", Off::UStruct::Children, 0x08 },
		{ "int32", "Size", Off::UStruct::Size, 0x04 }
	};

	if (Settings::Internal::bUseFProperty)
		PredefinedMembers["UStruct"].insert({ "class FField* ", "ChildProperties", Off::UStruct::ChildProperties, 0x08 });

	PredefinedMembers["UFunction"] =
	{
		{ "using FNativeFuncPtr = void (*)(void* Context, void* TheStack, void* Result)", "", 0x0, 0x0 },
		{ "uint32", "FunctionFlags", Off::UFunction::FunctionFlags, 0x08 },
		{ "FNativeFuncPtr", "ExecFunction", Off::UFunction::ExecFunction, 0x08 }
	};

	PredefinedMembers["UClass"] =
	{
		{ "enum class EClassCastFlags", "CastFlags", Off::UClass::CastFlags, 0x08 },
		{ "class UObject*", "DefaultObject", Off::UClass::ClassDefaultObject, 0x08 }
	};


	PredefinedMembers[PrefixPropertyName("Property")] =
	{
		{ "int32", "ElementSize", Off::UProperty::ElementSize, 0x04 },
		{ "uint64", "PropertyFlags", Off::UProperty::PropertyFlags, 0x08 },
		{ "int32", "Offset", Off::UProperty::Offset_Internal, 0x04 }
	};

	PredefinedMembers[PrefixPropertyName("ByteProperty")] =
	{
		{ "class UEnum*", "Enum", Off::UByteProperty::Enum, 0x08 }
	};

	PredefinedMembers[PrefixPropertyName("BoolProperty")] =
	{
		{ "uint8", "FieldSize", Off::UBoolProperty::Base, 0x01 },
		{ "uint8", "ByteOffset", Off::UBoolProperty::Base + 0x1, 0x01 },
		{ "uint8", "ByteMask", Off::UBoolProperty::Base + 0x2, 0x01 },
		{ "uint8", "FieldMask", Off::UBoolProperty::Base + 0x3, 0x01 }
	};

	PredefinedMembers[PrefixPropertyName("ObjectPropertyBase")] =
	{
		{ "class UClass*", "PropertyClass", Off::UObjectProperty::PropertyClass, 0x08 }
	};

	PredefinedMembers[PrefixPropertyName("ClassProperty")] =
	{
		{ "class UClass*", "MetaClass", Off::UClassProperty::MetaClass, 0x08 }
	};

	PredefinedMembers[PrefixPropertyName("StructProperty")] =
	{
		{ "class UStruct*", "Struct", Off::UStructProperty::Struct, 0x08 }
	};

	std::string PrefixedPropertyPtr = std::format("class {}*", PrefixPropertyName("Property"));

	PredefinedMembers[PrefixPropertyName("ArrayProperty")] =
	{
		{ PrefixedPropertyPtr, "InnerProperty", Off::UArrayProperty::Inner, 0x08}
	};

	PredefinedMembers[PrefixPropertyName("MapProperty")] =
	{
		{ PrefixedPropertyPtr, "KeyProperty", Off::UMapProperty::Base, 0x08 },
		{ PrefixedPropertyPtr, "ValueProperty", Off::UMapProperty::Base + 0x08, 0x08 }
	};

	PredefinedMembers[PrefixPropertyName("SetProperty")] =
	{
		{ PrefixedPropertyPtr, "ElementProperty", Off::USetProperty::ElementProp, 0x08 }
	};

	PredefinedMembers[PrefixPropertyName("EnumProperty")] =
	{
		{ PrefixedPropertyPtr, "UnderlayingProperty", Off::UEnumProperty::Base, 0x08 },
		{ "class UEnum*", "Enum", Off::UEnumProperty::Base + 0x08, 0x08 }
	};

	if (!Settings::Internal::bUseFProperty)
		return;

	int FFieldVariantSize = (!Settings::Internal::bUseMaskForFieldOwner ? 0x10 : 0x8);
	std::string UObjectIdentifierType = (Settings::Internal::bUseMaskForFieldOwner ? "static constexpr uint64" : "bool");
	std::string UObjectIdentifierName = (Settings::Internal::bUseMaskForFieldOwner ? "UObjectMask = 0x1" : "bIsUObject");

	PredefinedMembers["FFieldClass"] =
	{
		{ "FName", "Name", Off::FFieldClass::Name, Off::InSDK::FNameSize },
		{ "uint64", "Id", Off::FFieldClass::Id, 0x8 },
		{ "uint64", "CastFlags", Off::FFieldClass::CastFlags, 0x8 },
		{ "EClassFlags", "ClassFlags", Off::FFieldClass::ClassFlags, 0x4 },
		{ "FFieldClass*", "SuperClass", Off::FFieldClass::SuperClass, 0x8 },
	};

	PredefinedMembers["FFieldVariant"] =
	{
		{ "union { class FField* Field; class UObject* Object; }", "Container", 0x0, 0x8 },
		{ UObjectIdentifierType, UObjectIdentifierName, Settings::Internal::bUseMaskForFieldOwner ? 0x0 : 0x8, !Settings::Internal::bUseMaskForFieldOwner }
	};

	if (!Settings::Internal::bUseMaskForFieldOwner)
		PredefinedMembers["FFieldVariant"].insert({ "uint8", "Pad[0x7]", 0x9, 0x7 });


	PredefinedMembers["FField"] =
	{
		{ "void*", "Vft", Off::FField::Vft, 0x8 },
		{ "FFieldClass*", "Class", Off::FField::Class, 0x8 },
		{ "FFieldVariant", "Owner", Off::FField::Owner, FFieldVariantSize },
		{ "FField*", "Next", Off::FField::Next, 0x8 },
		{ "FName", "Name", Off::FField::Name, Off::InSDK::FNameSize },
		{ "int32", "Flags", Off::FField::Flags, 0x4 }
	};
}

void Generator::InitPredefinedFunctions()
{
	PredefinedFunctions["UObject"] =
	{
		"CoreUObject",
		{
			{
				"\tbool HasTypeFlag(EClassCastFlags TypeFlag) const;",
				"\tbool UObject::HasTypeFlag(EClassCastFlags TypeFlag) const",
R"(
	{
		return TypeFlag != EClassCastFlags::None ? Class->CastFlags & TypeFlag : true;
	}
)"
			},
			{
				"\tbool IsDefaultObject() const", "",
R"(
	{
		return (Flags & 0x10) == 0x10;
	}
)"
			},
			{
				"\tstd::string GetName() const;",
				"\tstd::string UObject::GetName() const",
R"(
	{
		return this ? Name.ToString() : "None";
	}
)"
			},
			{
				"\tstd::string GetFullName() const;",
				"\tstd::string UObject::GetFullName() const",
R"(
	{
		if (Class)
		{
			std::string Temp;

			for (UObject* NextOuter = Outer; NextOuter; NextOuter = NextOuter->Outer)
			{
				Temp = NextOuter->GetName() + "." + Temp;
			}

			std::string Name = Class->GetName();
			Name += " ";
			Name += Temp;
			Name += GetName();

			return Name;
		}

		return "None";
	}
)"
			},
			{
				"\ttemplate<typename UEType = UObject>\n\tstatic UEType* FindObject(const std::string& FullName, EClassCastFlags RequiredType = EClassCastFlags::None)", "",
R"(
	{
		for (int i = 0; i < GObjects->Num(); ++i)
		{
			UObject* Object = GObjects->GetByIndex(i);
	
			if (!Object)
				continue;
			
			if (Object->HasTypeFlag(RequiredType) && Object->GetFullName() == FullName)
			{
				return static_cast<UEType*>(Object);
			}
		}

		return nullptr;
	}
)"
			},
			{
				"\ttemplate<typename UEType = UObject>\n\tstatic UEType* FindObjectFast(const std::string& Name, EClassCastFlags RequiredType = EClassCastFlags::None)", "",
R"(
	{
		for (int i = 0; i < GObjects->Num(); ++i)
		{
			UObject* Object = GObjects->GetByIndex(i);
	
			if (!Object)
				continue;
			
			if (Object->HasTypeFlag(RequiredType) && Object->GetName() == Name)
			{
				return static_cast<UEType*>(Object);
			}
		}

		return nullptr;
	}
)"
			},
			{
				"\tstatic class UClass* FindClass(const std::string& ClassFullName)", "",
R"(
	{
		return FindObject<class UClass>(ClassFullName, EClassCastFlags::Class);
	}
)"
			},
			{
				"\tstatic class UClass* FindClassFast(const std::string& ClassName)", "",
R"(
	{
		return FindObjectFast<class UClass>(ClassName, EClassCastFlags::Class);
	}
)"
			},
			{
				"\tbool IsA(class UClass* Clss) const;",
				"\tbool UObject::IsA(class UClass* Clss) const",
R"(
	{
		for (UStruct* Super = Class; Super; Super = Super->Super)
		{
			if (Super == Clss)
			{
				return true;
			}
		}

		return false;
	}
)"
			},
			{
				"\tinline void ProcessEvent(class UFunction* Function, void* Parms) const", "",
R"(
	{
		return GetVFunction<void(*)(const UObject*, class UFunction*, void*)>(this, Offsets::ProcessEventIdx)(this, Function, Parms);
	}
)"
			}
		}
	};

	PredefinedFunctions["UClass"] =
	{
		"CoreUObject",
		{
			{
				"\tclass UFunction* GetFunction(const std::string& ClassName, const std::string& FuncName);",
				"\tclass UFunction* UClass::GetFunction(const std::string& ClassName, const std::string& FuncName)",
R"(
	{
		for(UStruct* Clss = this; Clss; Clss = Clss->Super)
		{
			if (Clss->GetName() == ClassName)
			{
				for (UField* Field = Clss->Children; Field; Field = Field->Next)
				{
					if(Field->HasTypeFlag(EClassCastFlags::Function) && Field->GetName() == FuncName)
					{
						return static_cast<class UFunction*>(Field);
					}	
				}
			}
		}
		return nullptr;
	}
)"
			}
		}
	};

	PredefinedFunctions["FGuid"] =
	{
		"CoreUObject",
		{
			{
				"\tinline bool operator==(const FGuid& Other) const",
				"",
R"(
	{
		return A == Other.A && B == Other.B && C == Other.C && D == Other.D;
	})"
			},
			{
				"\tinline bool operator!=(const FGuid& Other) const",
				"",
R"(
	{
		return A != Other.A || B != Other.B || C != Other.C || D != Other.D;
	}
)"
			}
		}
	};

	PredefinedFunctions["FVector"] =
	{
		"CoreUObject",
		{
{ "\tinline FVector()", "", R"(
		: X(0.0), Y(0.0), Z(0.0)
	{
	})"
			},
{ "\tinline FVector(decltype(X) Value)", "", R"(
		: X(Value), Y(Value), Z(Value)
	{
	})"
			},
{ "\tinline FVector(decltype(X) x, decltype(Y) y, decltype(Z) z)", "", R"(
		: X(x), Y(y), Z(z)
	{
	})"
			},
{ "\tinline bool operator==(const FVector& Other) const", "", R"(
	{
		return X == Other.X && Y == Other.Y && Z == Other.Z;
	})"
			},
{ "\tinline bool operator!=(const FVector& Other) const", "", R"(
	{
		return X != Other.X || Y != Other.Y || Z != Other.Z;
	})"
			},
{ "\tFVector operator+(const FVector& Other) const;", "\tFVector FVector::operator+(const FVector& Other) const", R"(
	{
		return { X + Other.X, Y + Other.Y, Z + Other.Z };
	}
)"
			},
{ "\tFVector operator-(const FVector& Other) const;", "\tFVector FVector::operator-(const FVector& Other) const", R"(
	{
		return { X - Other.X, Y - Other.Y, Z - Other.Z };
	}
)"
			},
{ "\tFVector operator*(decltype(X) Scalar) const;", "\tFVector FVector::operator*(decltype(X) Scalar) const", R"(
	{
		return { X * Scalar, Y * Scalar, Z * Scalar };
	}
)"
			},
{ "\tFVector operator/(decltype(X) Scalar) const;", "\tFVector FVector::operator/(decltype(X) Scalar) const", R"(
	{
		if (Scalar == 0.0f)
			return FVector();

		return { X / Scalar, Y / Scalar, Z / Scalar };
	}
)"
			}
		}
	};

	PredefinedFunctions["FVector4"] =
	{
		"CoreUObject",
		{
{ "\tinline FVector4()", "", R"(
		: X(0.0), Y(0.0), Z(0.0), W(0.0)
	{
	})"
			},
{ "\tinline FVector4(decltype(X) Value)", "", R"(
		: X(Value), Y(Value), Z(Value), W(Value)
	{
	})"
			},
{ "\tinline FVector4(decltype(X) x, decltype(Y) y, decltype(Z) z, decltype(W) w)", "", R"(
		: X(x), Y(y), Z(z), W(w)
	{
	})"
			},
{ "\tinline bool operator==(const FVector4& Other) const", "", R"(
	{
		return X == Other.X && Y == Other.Y && Z == Other.Z && W == Other.W;
	})"
			},
{ "\tinline bool operator!=(const FVector4& Other) const", "", R"(
	{
		return X != Other.X || Y != Other.Y || Z != Other.Z || W != Other.W;
	})"
			},
{ "\tFVector4 operator+(const FVector4& Other) const;", "\tFVector4 FVector4::operator+(const FVector4& Other) const", R"(
	{
		return { X + Other.X, Y + Other.Y, Z + Other.Z, W + Other.W };
	}
)"
			},
{ "\tFVector4 operator-(const FVector4& Other) const;", "\tFVector4 FVector4::operator-(const FVector4& Other) const", R"(
	{
		return { X - Other.X, Y - Other.Y, Z - Other.Z, W - Other.W };
	}
)"
			},
{ "\tFVector4 operator*(decltype(X) Scalar) const;", "\tFVector4 FVector4::operator*(decltype(X) Scalar) const", R"(
	{
		return { X * Scalar, Y * Scalar, Z * Scalar, W * Scalar };
	}
)"
			},
{ "\tFVector4 operator/(decltype(X) Scalar) const;", "\tFVector4 FVector4::operator/(decltype(X) Scalar) const", R"(
	{
		if (Scalar == 0.0f)
			return FVector4();

		return { X / Scalar, Y / Scalar, Z / Scalar, W / Scalar };
	}
)"
			}
		}
	};

	PredefinedFunctions["FVector2D"] =
	{
		"CoreUObject",
		{
{ "\tinline FVector2D()", "", R"(
		: X(0.0), Y(0.0)
	{
	})"
			},
{ "\tinline FVector2D(decltype(X) Value)", "", R"(
		: X(Value), Y(Value)
	{
	})"
			},
{ "\tinline FVector2D(decltype(X) x, decltype(Y) y)", "", R"(
		: X(x), Y(y)
	{
	})"
			},
{ "\tinline bool operator==(const FVector2D& Other) const", "", R"(
	{
		return X == Other.X && Y == Other.Y;
	})"
			},
{ "\tinline bool operator!=(const FVector2D& Other) const", "", R"(
	{
		return X != Other.X || Y != Other.Y;
	})"
			},
{ "\tFVector2D operator+(const FVector2D& Other) const;", "\tFVector2D FVector2D::operator+(const FVector2D& Other) const", R"(
	{
		return { X + Other.X, Y + Other.Y };
	}
)"
			},
{ "\tFVector2D operator-(const FVector2D& Other) const;", "\tFVector2D FVector2D::operator-(const FVector2D& Other) const", R"(
	{
		return { X - Other.X, Y - Other.Y };
	}
)"
			},
{ "\tFVector2D operator*(decltype(X) Scalar) const;", "\tFVector2D FVector2D::operator*(decltype(X) Scalar) const", R"(
	{
		return { X * Scalar, Y * Scalar };
	}
)"
			},
{ "\tFVector2D operator/(decltype(X) Scalar) const;", "\tFVector2D FVector2D::operator/(decltype(X) Scalar) const", R"(
	{
		if (Scalar == 0.0f)
			return FVector2D();

		return { X / Scalar, Y / Scalar };
	}
)"
			}
		}
	};

	PredefinedFunctions["FRotator"] =
	{
		"CoreUObject",
		{
{ "\tinline FRotator()", "", R"(
		: Pitch(0.0), Yaw(0.0), Roll(0.0)
	{
	})"
			},
{ "\tinline FRotator(decltype(Pitch) Value)", "", R"(
		: Pitch(Value), Yaw(Value), Roll(Value)
	{
	})"
			},
{ "\tinline FRotator(decltype(Pitch) pitch, decltype(Yaw) yaw, decltype(Roll) roll)", "", R"(
		: Pitch(pitch), Yaw(yaw), Roll(roll)
	{
	})"
			},
{ "\tinline bool operator==(const FRotator& Other) const", "", R"(
	{
		return Pitch == Other.Pitch && Yaw == Other.Yaw && Roll == Other.Roll;
	})"
			},
{ "\tinline bool operator!=(const FRotator& Other) const", "", R"(
	{
		return Pitch != Other.Pitch || Yaw != Other.Yaw || Roll != Other.Roll;
	})"
			},
{ "\tFRotator operator+(const FRotator& Other) const;", "\tFRotator FRotator::operator+(const FRotator& Other) const", R"(
	{
		return { Pitch + Other.Pitch, Yaw + Other.Yaw, Roll + Other.Roll };
	}
)"
			},
{ "\tFRotator operator-(const FRotator& Other) const;", "\tFRotator FRotator::operator-(const FRotator& Other) const", R"(
	{
		return { Pitch - Other.Pitch, Yaw - Other.Yaw, Roll - Other.Roll };
	}
)"
			},
{ "\tFRotator operator*(decltype(Pitch) Scalar) const;", "\tFRotator FRotator::operator*(decltype(Pitch) Scalar) const", R"(
	{
		return { Pitch * Scalar, Yaw * Scalar, Roll * Scalar };
	}
)"
			},
{ "\tFRotator operator/(decltype(Pitch) Scalar) const;", "\tFRotator FRotator::operator/(decltype(Pitch) Scalar) const", R"(
	{
		if (Scalar == 0.0f)
			return FRotator();

		return { Pitch / Scalar, Yaw / Scalar, Roll / Scalar };
	}
)"
			}
		}
	};

	PredefinedFunctions["FQuat"] =
	{
		"CoreUObject",
		{
{ "\tinline FQuat()", "", R"(
		: X(0.0), Y(0.0), Z(0.0), W(0.0)
	{
	})"
			},
{ "\tinline FQuat(decltype(X) Value)", "", R"(
		: X(Value), Y(Value), Z(Value), W(Value)
	{
	})"
			},
{ "\tinline FQuat(decltype(X) x, decltype(Y) y, decltype(Z) z, decltype(W) w)", "", R"(
		: X(x), Y(y), Z(z), W(w)
	{
	})"
			},
{ "\tinline bool operator==(const FQuat& Other) const", "", R"(
	{
		return X == Other.X && Y == Other.Y && Z == Other.Z && W == Other.W;
	})"
			},
{ "\tinline bool operator!=(const FQuat& Other) const", "", R"(
	{
		return X != Other.X || Y != Other.Y || Z != Other.Z || W != Other.W;
	})"
			},
{ "\tFQuat operator+(const FQuat& Other) const;", "\tFQuat FQuat::operator+(const FQuat& Other) const", R"(
	{
		return { X + Other.X, Y + Other.Y, Z + Other.Z, W + Other.W };
	}
)"
			},
{ "\tFQuat operator-(const FQuat& Other) const;", "\tFQuat FQuat::operator-(const FQuat& Other) const", R"(
	{
		return { X - Other.X, Y - Other.Y, Z - Other.Z, W - Other.W };
	}
)"
			},
{ "\tFQuat operator*(decltype(X) Scalar) const;", "\tFQuat FQuat::operator*(decltype(X) Scalar) const", R"(
	{
		return { X * Scalar, Y * Scalar, Z * Scalar, W * Scalar };
	}
)"
			},
{ "\tFQuat operator/(decltype(X) Scalar) const;", "\tFQuat FQuat::operator/(decltype(X) Scalar) const", R"(
	{
		if (Scalar == 0.0f)
			return FQuat();

		return { X / Scalar, Y / Scalar, Z / Scalar, W / Scalar };
	}
)"
			}
		}
	};

	PredefinedFunctions["UEngine"] =
	{
		"Engine",
		{
			{
				"\tstatic class UEngine* GetEngine();",
				"\tclass UEngine* UEngine::GetEngine()",
R"(
	{
		static UEngine* GEngine = nullptr;

		if (!GEngine)
		{
			for (int i = 0; i < UObject::GObjects->Num(); i++)
			{
				UObject* Obj = UObject::GObjects->GetByIndex(i);

				if (!Obj)
					continue;

				if (Obj->IsA(UEngine::StaticClass()) && !Obj->IsDefaultObject())
				{
					GEngine = static_cast<UEngine*>(Obj);
					break;
				}
			}
		}

		return GEngine; 
	}
)"
			}
		}
	};

	PredefinedFunctions["UGameEngine"] =
	{
		"Engine",
		{
			{
				"\tstatic class UGameEngine* GetEngine();",
				"\tclass UGameEngine* UGameEngine::GetEngine()",
R"(
	{
		static class UGameEngine* GameEngine = nullptr;

		if (!GameEngine)
		{
			GameEngine = static_cast<class UGameEngine*>(UEngine::GetEngine());

			if (!GameEngine->IsA(UGameEngine::StaticClass()))
				GameEngine = nullptr;
		}

		return GameEngine; 
	}
)"
			}
		}
	};
		
	PredefinedFunctions["UWorld"] =
	{
		"Engine",
		{
			{
				"\tstatic class UWorld* GetWorld();",
				"\tclass UWorld* UWorld::GetWorld()",
R"(
	{
		if (UEngine* Engine = UEngine::GetEngine())
		{
			if (!Engine->GameViewport)
				return nullptr;

			return Engine->GameViewport->World;
		}

		return nullptr;
	}
)"
			}
		}
	};
}


struct MemberBuilder
{
private:
	int32 CurrentSize = 0x0;
	std::string Members;

public:
	const char* Indent = "\t";

private:
	inline void AddPadding(int32 Size)
	{
		static int32 PaddingIdx = 0x0;

		CurrentSize += Size;
		Members += std::format("{}uint8 Pad_{:X}[0x{:X}];\n", Indent, PaddingIdx++, Size);
	}

public:
	inline void Add(std::string&& MemberTypeAndName, int32 Offset, int32 Size, bool bSkip = false)
	{
		if (bSkip)
			return;

		if (Offset > CurrentSize)
			AddPadding(Offset - CurrentSize);

		CurrentSize += Size;

		Members += MemberTypeAndName;
	}

	inline std::string GetMembers(int32 RequiredSize = 0)
	{
		if (RequiredSize > CurrentSize)
			AddPadding(RequiredSize - CurrentSize);

		return Members;
	}
};

void Generator::GenerateBasicFile(const fs::path& SdkPath)
{
	FileWriter BasicHeader(SdkPath, Settings::FilePrefix ? Settings::FilePrefix + std::string("Basic") : "Basic", FileWriter::FileType::Header);
	FileWriter BasicSource(SdkPath, Settings::FilePrefix ? Settings::FilePrefix + std::string("Basic") : "Basic", FileWriter::FileType::Source);

	BasicHeader.Write(
		R"(
void InitGObjects();
)");

	BasicSource.Write(
		R"(
void InitGObjects()
{
	UObject::GObjects = reinterpret_cast<TUObjectArray*>(uintptr_t(GetModuleHandle(0)) + Offsets::GObjects);
}		
)");

	BasicHeader.Write(
		R"(
template<typename Fn>
inline Fn GetVFunction(const void* Instance, std::size_t Index)
{
	auto Vtable = *reinterpret_cast<const void***>(const_cast<void*>(Instance));
	return reinterpret_cast<Fn>(Vtable[Index]);
}
)");

	constexpr const char* DefaultDecryption = R"([](void* ObjPtr) -> uint8*
	{
		return reinterpret_cast<uint8*>(ObjPtr);
	})";

	std::string DecryptionStrToUse = ObjectArray::DecryptionLambdaStr.empty() ? DefaultDecryption : std::move(ObjectArray::DecryptionLambdaStr);

	MemberBuilder FUObjectItemMemberBuilder;
	FUObjectItemMemberBuilder.Add("\tclass UObject* Object;\n", Off::InSDK::FUObjectItemInitialOffset, sizeof(void*));

	BasicHeader.Write(std::format(R"(
struct FUObjectItem
{{
{}
}};
)", FUObjectItemMemberBuilder.GetMembers(Off::InSDK::FUObjectItemSize)));

	if (Off::InSDK::ChunkSize <= 0)
	{
		BasicHeader.Write(
			std::format(R"(
class TUObjectArray
{{
public:
	static inline auto DecryptPtr = {};

public:
	FUObjectItem* Objects;
	int32 MaxElements;
	int32 NumElements;

public:
	// Call InitGObjects() before using these functions
	inline int Num() const
	{{
		return NumElements;
	}}

	inline FUObjectItem* GetDecrytedObjPtr() const
	{{
		return reinterpret_cast<FUObjectItem*>(DecryptPtr(Objects));
	}}

	inline class UObject* GetByIndex(const int32 Index) const
	{{
		if (Index < 0 || Index > NumElements)
			return nullptr;

		return GetDecrytedObjPtr()[Index].Object;
	}}
}};
)", DecryptionStrToUse));
	}
	else
	{
		constexpr const char* MemmberString = R"(
	FUObjectItem** Objects;
	uint8 Pad_0[0x08];
	int32 MaxElements;
	int32 NumElements;
	int32 MaxChunks;
	int32 NumChunks;
)";

		constexpr const char* MemberStringWeirdLayout = R"(
	uint8 Pad_0[0x10];
	int32 MaxElements;
	int32 NumElements;
	int32 MaxChunks;
	int32 NumChunks;
	FUObjectItem** Objects;
)";

		BasicHeader.Write(
			std::format(R"(
class TUObjectArray
{{
public:
	enum
	{{
		ElementsPerChunk = 0x{:X},
	}};

public:
	static inline auto DecryptPtr = {};
	{}

public:
	// Call InitGObjects() before using these functions
	inline int32 Num() const
	{{
		return NumElements;
	}}

	inline FUObjectItem** GetDecrytedObjPtr() const
	{{
		return reinterpret_cast<FUObjectItem**>(DecryptPtr(Objects));
	}}

	inline class UObject* GetByIndex(const int32 Index) const
	{{
		if (Index < 0 || Index > NumElements)
			return nullptr;

		const int32 ChunkIndex = Index / ElementsPerChunk;
		const int32 InChunkIdx = Index % ElementsPerChunk;

		return GetDecrytedObjPtr()[ChunkIndex][InChunkIdx].Object;
	}}
}};
)", Off::InSDK::ChunkSize, DecryptionStrToUse, Off::FUObjectArray::Ptr == 0 ? MemmberString : MemberStringWeirdLayout));
	}

	BasicHeader.Write(
		R"(
template<class T>
class TArray
{
protected:
	T* Data;
	int32 NumElements;
	int32 MaxElements;

public:

	inline TArray()
		:NumElements(0), MaxElements(0), Data(nullptr)
	{
	}

	inline TArray(int32 Size)
		:NumElements(0), MaxElements(Size), Data(reinterpret_cast<T*>(malloc(sizeof(T) * Size)))
	{
	}

	inline T& operator[](uint32 Index)
	{
		return Data[Index];
	}
	inline const T& operator[](uint32 Index) const
	{
		return Data[Index];
	}

	inline int32 Num()
	{
		return NumElements;
	}

	inline int32 Max()
	{
		return MaxElements;
	}

	inline int32 GetSlack()
	{
		return MaxElements - NumElements;
	}

	inline bool IsValid()
	{
		return Data != nullptr;
	}

	inline bool IsValidIndex(int32 Index)
	{
		return Index >= 0 && Index < NumElements;
	}

	inline void ResetNum()
	{
		NumElements = 0;
	}
};
)");

	BasicHeader.Write(
		R"(
class FString : public TArray<wchar_t>
{
public:
	inline FString() = default;

	using TArray::TArray;

	inline FString(const wchar_t* WChar)
	{
		MaxElements = NumElements = *WChar ? std::wcslen(WChar) + 1 : 0;

		if (NumElements)
		{
			Data = const_cast<wchar_t*>(WChar);
		}
	}

	inline FString operator=(const wchar_t*&& Other)
	{
		return FString(Other);
	}

	inline std::wstring ToWString()
	{
		if (IsValid())
		{
			return Data;
		}

		return L"";
	}

	inline std::string ToString()
	{
		if (IsValid())
		{
			std::wstring WData(Data);
			return std::string(WData.begin(), WData.end());
		}

		return "";
	}
};
)");


	if (Off::InSDK::AppendNameToString == 0x0 && !Settings::Internal::bUseNamePool)
	{
		MemberBuilder NameEntryMembers;
		NameEntryMembers.Add("\tint32 NameIndex;\n", Off::FNameEntry::NameArray::IndexOffset, sizeof(int32));
		NameEntryMembers.Add(
R"(
	union
	{
		char    AnsiName[1024];
		wchar_t WideName[1024];
	};
)", Off::FNameEntry::NameArray::StringOffset, 0x0);

		BasicHeader.Write(std::format(R"(
class FNameEntry
{{
public:
	static constexpr uint32 NameWideMask = 0x1;
	static constexpr uint32 NameIndexShiftCount = 0x1;

public:
{}

public:
	inline bool IsWide() const
	{{
		return (NameIndex & NameWideMask);
	}}

	inline std::string GetString() const
	{{
		if (IsWide())
		{{
			std::wstring WideString(WideName);
			return std::string(WideString.begin(), WideString.end());
		}}

		return AnsiName;
	}}
}};
)", NameEntryMembers.GetMembers()));

		BasicHeader.Write(std::format(R"(
class TNameEntryArray
{{
public:
	
	static constexpr uint32 ChunkTableSize = {};
	static constexpr uint32 NumElementsPerChunk = 0x4000;

public:
	FNameEntry** Chunks[ChunkTableSize];
	int32 NumElements;
	int32 NumChunks;

public:
	inline bool IsValidIndex(int32 Index, int32 ChunkIdx, int32 InChunkIdx) const
	{{
		return return Index >= 0 && Index < NumElements;
	}}

	inline FNameEntry* GetEntryByIndex(int32 Index) const
	{{
		const int32 ChunkIdx = Index / NumElementsPerChunk;
		const int32 InChunk  = Index % NumElementsPerChunk;

		if (!IsValidIndex(Index, ChunkIdx, InChunk))
			return nullptr;

		return Chunks[ChunkIdx][InChunk];
	}}	
}};
)", Off::NameArray::NumElements / 8));
	}
	else if (Off::InSDK::AppendNameToString == 0x0 && Settings::Internal::bUseNamePool)
	{
		const int32 FNameEntryHeaderSize = Off::FNameEntry::NamePool::StringOffset - Off::FNameEntry::NamePool::HeaderOffset;

		MemberBuilder NumberedDataBuilder;
		NumberedDataBuilder.Indent = "\t\t";
		NumberedDataBuilder.Add("\t\tuint8 Pad[0x2]\n", -1, sizeof(uint8[0x2]), !Settings::Internal::bUseCasePreservingName);
		NumberedDataBuilder.Add("\t\tuint32 Id;\n", -1, sizeof(uint32));
		NumberedDataBuilder.Add("\t\tuint32 Number;", -1, sizeof(uint32));

		MemberBuilder NameEntryHeaderMembers;
		NameEntryHeaderMembers.Add("\tuint16 bIsWide : 1;\n", 0, 0);
		NameEntryHeaderMembers.Add("\tuint16 Len : 15;", 0, 0, !Settings::Internal::bUseCasePreservingName);
		NameEntryHeaderMembers.Add("\tuint16 LowercaseProbeHash : 5;\n", 0, 0, Settings::Internal::bUseCasePreservingName);
		NameEntryHeaderMembers.Add("\tuint16 Len : 10;", 0, 0, Settings::Internal::bUseCasePreservingName);

		MemberBuilder NameEntryMembers;
		NameEntryMembers.Add("\tFNameEntryHeader Header;\n", Off::FNameEntry::NamePool::HeaderOffset, sizeof(uint16));
		NameEntryMembers.Add(
			R"(
	union
	{
		char    AnsiName[1024];
		wchar_t WideName[1024];
		FNumberedData NumberedName;
	};
)", Off::FNameEntry::NameArray::StringOffset, 0x0);

		BasicHeader.Write(std::format(R"(
class FNameEntryHeader
{{
public:
{}
}};
)", NameEntryHeaderMembers.GetMembers()));

		BasicHeader.Write(std::format(R"(
class FNameEntry
{{
public:
	struct FNumberedData
	{{
{}
	}};

public:
{}

public:
	inline bool IsWide() const
	{{
		return Header.bIsWide;
	}}

	inline std::string GetString() const
	{{
		if (IsWide())
		{{
			std::wstring WideString(WideName, Header.Len);
			return std::string(WideString.begin(), WideString.end());
		}}

		return std::string(AnsiName, Header.Len);
	}}

}};
)", NumberedDataBuilder.GetMembers(), NameEntryMembers.GetMembers()));


		MemberBuilder NamePoolMembers;
		NamePoolMembers.Add("\tuint32 CurrentBlock;\n", Off::NameArray::MaxChunkIndex, sizeof(uint32));
		NamePoolMembers.Add("\tuint32 CurrentByteCursor;\n", Off::NameArray::ByteCursor, sizeof(uint32));
		NamePoolMembers.Add("\tuint8* Blocks[8192];\n", Off::NameArray::ChunksStart, sizeof(uint8**));

		BasicHeader.Write(std::format(R"(
class FNamePool
{{
public:
	static constexpr uint32 FNameBlockOffsetBits = {};
	static constexpr uint32 FNameBlockOffsets = 1 << FNameBlockOffsetBits;

	static constexpr uint32 FNameEntryStride = {};

public:
	// Members of FNamePool with padding
{}

public:
	inline bool IsValidIndex(int32 Index, int32 ChunkIdx, int32 InChunkIdx) const
	{{
		return ChunkIdx <= CurrentBlock && !(ChunkIdx == CurrentBlock && InChunkIdx > CurrentByteCursor);
	}}

	inline FNameEntry* GetEntryByIndex(int32 Index) const
	{{
		const int32 ChunkIdx = Index >> FNameBlockOffsetBits;
		const int32 InChunk = (Index & (FNameBlockOffsets - 1));

		if (!IsValidIndex(Index, ChunkIdx, InChunk))
			return nullptr;

		return reinterpret_cast<FNameEntry*>(Blocks[ChunkIdx] + (InChunk * FNameEntryStride));
	}}
}};
)", Off::InSDK::FNamePoolBlockOffsetBits, Off::InSDK::FNameEntryStride, NamePoolMembers.GetMembers()));
	}


	std::string FNameMemberStr = "int32 ComparisonIndex;\n";

	constexpr const char* DisplayIdx = "\tint32 DisplayIndex;\n";
	constexpr const char* Number =     "\tint32 Number;\n";
	constexpr const char* Pad =        "\tint32 Pad;\n";

	FNameMemberStr += Off::FName::Number == 4 ? Number : Settings::Internal::bUseCasePreservingName ? DisplayIdx : "";
	FNameMemberStr += Off::FName::Number == 8 ? Number : Settings::Internal::bUseCasePreservingName ? DisplayIdx : "";
	

	std::string GetDisplayIndexString = std::format(R"(inline int32 GetDisplayIndex() const
	{{
		return {};
	}})", Settings::Internal::bUseCasePreservingName ? "DisplayIndex" : "ComparisonIndex");

	constexpr const char* GetRawStringWithAppendString =
 R"(inline std::string GetRawString() const
	{
		thread_local FString TempString(1024);
		static void(*AppendString)(const FName*, FString&) = nullptr;

		if (!AppendString)
			AppendString = reinterpret_cast<void(*)(const FName*, FString&)>(uintptr_t(GetModuleHandle(0)) + Offsets::AppendString);

		AppendString(this, TempString);

		std::string OutputString = TempString.ToString();
		TempString.ResetNum();

		return OutputString;
	})";

	constexpr const char* GetRawStringWithNameArray =
 R"(inline std::string GetRawString() const
	{
		if (!GNames)
			InitGNames();

		std::string RetStr = FName::GNames->GetEntryByIndex(GetDisplayIndex())->GetString();

		if (Number > 0)
			RetStr += ("_" + std::to_string(Number - 1));

		return RetStr;
	})";

	constexpr const char* GetRawStringWithNameArrayWithOutlineNumber =
 R"(inline std::string GetRawString() const
	{
		if (!GNames)
			InitGNames();

		const FNameEntry* Entry = FName::GNames->GetEntryByIndex(GetDisplayIndex());

		if (Entry->Header.Length == 0)
		{{
			if (Entry->Number > 0)
				return FName::GNames->GetEntryByIndex(Entry->NumberedName.Id)->GetString() + "_" + std::to_string(Entry->Number - 1);

			return FName::GNames->GetEntryByIndex(Entry->NumberedName.Id)->GetString();
		}}

		return Entry.GetString();
	})";

	BasicHeader.Write(
		std::format(R"(
class FName
{{
public:
	// GNames - either of type TNameEntryArray [<4.23] or FNamePool [>=4.23]
	static inline {}* GNames = nullptr;

	// Members of FName - depending on configuration [WITH_CASE_PRESERVING_NAME | FNAME_OUTLINE_NUMBER]
	{}

	// GetDisplayIndex - returns the Id of the string depending on the configuration [default: ComparisonIndex, WITH_CASE_PRESERVING_NAME: DisplayIndex]
	{}

	// GetRawString - returns an unedited string as the engine uses it
	{}

	static inline void InitGNames()
	{{
		GNames = {}(uint64(GetModuleHandle(0)) + Offsets::GNames);
	}}

	// ToString - returns an edited string as it's used by most SDKs ["/Script/CoreUObject" -> "CoreUObject"]
	inline std::string ToString() const
	{{
		std::string OutputString = GetRawString();

		size_t pos = OutputString.rfind('/');

		if (pos == std::string::npos)
			return OutputString;

		return OutputString.substr(pos + 1);
	}}

	inline bool operator==(const FName& Other) const
	{{
		return ComparisonIndex == Other.ComparisonIndex{};
	}}

	inline bool operator!=(const FName& Other) const
	{{
		return ComparisonIndex != Other.ComparisonIndex{};
	}}
}};
)", Off::InSDK::AppendNameToString == 0 ? Settings::Internal::bUseNamePool ? "FNamePool" : "TNameEntryArray" : "void"
  , FNameMemberStr
  , GetDisplayIndexString
  , Off::InSDK::AppendNameToString == 0 ? Settings::Internal::bUseUoutlineNumberName ? GetRawStringWithNameArrayWithOutlineNumber : GetRawStringWithNameArray : GetRawStringWithAppendString
  , Off::InSDK::AppendNameToString == 0 ? Settings::Internal::bUseNamePool ? "reinterpret_cast<FNamePool*>" : "*reinterpret_cast<TNameEntryArray**>" : "reinterpret_cast<void*>"
  , !Settings::Internal::bUseUoutlineNumberName ? " && Number == Other.Number" : ""
  , !Settings::Internal::bUseUoutlineNumberName ? " || Number != Other.Number" : ""));

	BasicHeader.Write(
		R"(
template<typename ClassType>
class TSubclassOf
{
	class UClass* ClassPtr;

public:
	TSubclassOf() = default;

	inline TSubclassOf(UClass* Class)
		: ClassPtr(Class)
	{
	}

	inline UClass* Get()
	{
		return ClassPtr;
	}

	inline operator UClass*() const
	{
		return ClassPtr;
	}

	template<typename Target, typename = std::enable_if<std::is_base_of_v<Target, ClassType>, bool>::type>
	inline operator TSubclassOf<Target>() const
	{
		return ClassPtr;
	}

	inline UClass* operator->()
	{
		return ClassPtr;
	}

	inline TSubclassOf& operator=(UClass* Class)
	{
		ClassPtr = Class;

		return *this;
	}

	inline bool operator==(const TSubclassOf& Other) const
	{
		return ClassPtr == Other.ClassPtr;
	}

	inline bool operator!=(const TSubclassOf& Other) const
	{
		return ClassPtr != Other.ClassPtr;
	}

	inline bool operator==(UClass* Other) const
	{
		return ClassPtr == Other;
	}

	inline bool operator!=(UClass* Other) const
	{
		return ClassPtr != Other;
	}
};
)");

	BasicHeader.Write(
		R"(
template<typename ValueType, typename KeyType>
class TPair
{
public:
	ValueType First;
	KeyType Second;
};
)");

	BasicHeader.Write(
		R"(
class FTextData 
{
public:
	uint8 Pad[0x28];
	wchar_t* Name;
	int32 Length;
};
)");

	BasicHeader.Write(
		R"(
class FText 
{
public:
	FTextData* Data;
	uint8 Pad[0x10];

	wchar_t* Get() const 
	{
		if (Data) 
			return Data->Name;

		return nullptr;
	}

	std::string ToString()
	{
		if (Data)
		{
			std::wstring Temp(Data->Name);
			return std::string(Temp.begin(), Temp.end());
		}

		return "";
	}
};
)");

	BasicHeader.Write(
		R"(
template<typename ElementType>
class TSet
{
	uint8 WaitTillIImplementIt[0x50];
};
)");

	BasicHeader.Write(
		R"(
template<typename KeyType, typename ValueType>
class TMap
{
	uint8 WaitTillIImplementIt[0x50];
};
)");

	BasicHeader.Write(
		R"(
class FWeakObjectPtr
{
protected:
	int32		ObjectIndex;
	int32		ObjectSerialNumber;

public:
	class UObject* Get() const;

	class UObject* operator->() const;

	bool operator==(const FWeakObjectPtr& Other) const;
	bool operator!=(const FWeakObjectPtr& Other) const;

	bool operator==(const class UObject* Other) const;
	bool operator!=(const class UObject* Other) const;
};
)");

	BasicHeader.Write(
		R"(
template<typename UEType>
class TWeakObjectPtr : FWeakObjectPtr
{
public:

	UEType* Get() const
	{
		return static_cast<UEType*>(FWeakObjectPtr::Get());
	}

	UEType* operator->() const
	{
		return static_cast<UEType*>(FWeakObjectPtr::Get());
	}
};
)");

	BasicHeader.Write(
		R"(

struct FUniqueObjectGuid
{
	uint32 A;
	uint32 B;
	uint32 C;
	uint32 D;
};
)");

	BasicHeader.Write(
		R"(
template<typename TObjectID>
class TPersistentObjectPtr
{
public:
	FWeakObjectPtr WeakPtr;
	int32 TagAtLastTest;
	TObjectID ObjectID;

	class UObject* Get() const
	{
		return WeakPtr.Get();
	}
	class UObject* operator->() const
	{
		return WeakPtr.Get();
	}
};
)");

	BasicHeader.Write(
		R"(
template<typename UEType>
class TLazyObjectPtr : public TPersistentObjectPtr<FUniqueObjectGuid>
{
public:

	UEType* Get() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}

	UEType* operator->() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}
};
)");
	
	UEStruct SoftObjectPath = ObjectArray::FindObjectFast<UEStruct>("SoftObjectPath", EClassCastFlags::Struct);

	if (SoftObjectPath)
	{
		BasicHeader.Write("namespace SoftObjPathWrapper\n{\n");

		if (UEStructProperty AssetPath = SoftObjectPath.FindMember("AssetPath", EClassCastFlags::StructProperty).Cast<UEStructProperty>())
		{
			Types::Struct AssetPathStruct = Package::StaticGenerateStruct(AssetPath.GetUnderlayingStruct());
			BasicHeader.WriteStruct(AssetPathStruct);
		}

		Types::Struct SoftObjectPathStruct = Package::StaticGenerateStruct(SoftObjectPath);
		BasicHeader.WriteStruct(SoftObjectPathStruct);

		BasicHeader.Write("}\n");

		BasicHeader.Write(
			R"(
class FSoftObjectPtr : public TPersistentObjectPtr<SoftObjPathWrapper::FSoftObjectPath>
{
public:
	FString GetSubPathString();
	std::string GetSubPathStringStr();

	template<class SoftObjectPath = FSoftObjectPath>
	SoftObjectPath& GetObjectPath();
};
)");


		BasicHeader.Write(
			R"(
template<typename UEType>
class TSoftObjectPtr : public FSoftObjectPtr
{
public:

	UEType* Get() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}

	UEType* operator->() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}
};
)");

		BasicHeader.Write(
			R"(
template<typename UEType>
class TSoftClassPtr : public FSoftObjectPtr
{
public:

	UEType* Get() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}

	UEType* operator->() const
	{
		return static_cast<UEType*>(TPersistentObjectPtr::Get());
	}
};
)");

		BasicSource.Write(
			R"(
FString FSoftObjectPtr::GetSubPathString()
{
	return ObjectID.SubPathString;
}

std::string FSoftObjectPtr::GetSubPathStringStr()
{
	return ObjectID.SubPathString.ToString();
}

template<class SoftObjectPath>
SoftObjectPath& FSoftObjectPtr::GetObjectPath()
{
	static_assert(std::is_same_v<SoftObjectPath, FSoftObjectPath>, "Only use this with FSoftObjectPath. This function is only templated as a workaround to C++ type-checks.");

	return reinterpret_cast<FSoftObjectPath&>(ObjectID);
}

void Dummy() { FSoftObjectPtr().GetObjectPath(); }

)");
	}


	BasicSource.Write(
		R"(
class UObject* FWeakObjectPtr::Get() const
{
	return UObject::GObjects->GetByIndex(ObjectIndex);
}

class UObject* FWeakObjectPtr::operator->() const
{
	return UObject::GObjects->GetByIndex(ObjectIndex);
}

bool FWeakObjectPtr::operator==(const FWeakObjectPtr& Other) const
{
	return ObjectIndex == Other.ObjectIndex;
}
bool FWeakObjectPtr::operator!=(const FWeakObjectPtr& Other) const
{
	return ObjectIndex != Other.ObjectIndex;
}

bool FWeakObjectPtr::operator==(const class UObject* Other) const
{
	return ObjectIndex == Other->Index;
}
bool FWeakObjectPtr::operator!=(const class UObject* Other) const
{
	return ObjectIndex != Other->Index;
}
)");

	BasicHeader.Write(
		R"(

enum class EClassCastFlags : uint64_t
{
	None = 0x0000000000000000,

	Field							= 0x0000000000000001,
	Int8Property					= 0x0000000000000002,
	Enum							= 0x0000000000000004,
	Struct							= 0x0000000000000008,
	ScriptStruct					= 0x0000000000000010,
	Class							= 0x0000000000000020,
	ByteProperty					= 0x0000000000000040,
	IntProperty						= 0x0000000000000080,
	FloatProperty					= 0x0000000000000100,
	UInt64Property					= 0x0000000000000200,
	ClassProperty					= 0x0000000000000400,
	UInt32Property					= 0x0000000000000800,
	InterfaceProperty				= 0x0000000000001000,
	NameProperty					= 0x0000000000002000,
	StrProperty						= 0x0000000000004000,
	Property						= 0x0000000000008000,
	ObjectProperty					= 0x0000000000010000,
	BoolProperty					= 0x0000000000020000,
	UInt16Property					= 0x0000000000040000,
	Function						= 0x0000000000080000,
	StructProperty					= 0x0000000000100000,
	ArrayProperty					= 0x0000000000200000,
	Int64Property					= 0x0000000000400000,
	DelegateProperty				= 0x0000000000800000,
	NumericProperty					= 0x0000000001000000,
	MulticastDelegateProperty		= 0x0000000002000000,
	ObjectPropertyBase				= 0x0000000004000000,
	WeakObjectProperty				= 0x0000000008000000,
	LazyObjectProperty				= 0x0000000010000000,
	SoftObjectProperty				= 0x0000000020000000,
	TextProperty					= 0x0000000040000000,
	Int16Property					= 0x0000000080000000,
	DoubleProperty					= 0x0000000100000000,
	SoftClassProperty				= 0x0000000200000000,
	Package							= 0x0000000400000000,
	Level							= 0x0000000800000000,
	Actor							= 0x0000001000000000,
	PlayerController				= 0x0000002000000000,
	Pawn							= 0x0000004000000000,
	SceneComponent					= 0x0000008000000000,
	PrimitiveComponent				= 0x0000010000000000,
	SkinnedMeshComponent			= 0x0000020000000000,
	SkeletalMeshComponent			= 0x0000040000000000,
	Blueprint						= 0x0000080000000000,
	DelegateFunction				= 0x0000100000000000,
	StaticMeshComponent				= 0x0000200000000000,
	MapProperty						= 0x0000400000000000,
	SetProperty						= 0x0000800000000000,
	EnumProperty					= 0x0001000000000000,
};
)");

	BasicHeader.Write(
		R"(
inline constexpr EClassCastFlags operator|(EClassCastFlags Left, EClassCastFlags Right)
{				
	using CastFlagsType = std::underlying_type<EClassCastFlags>::type;
	return static_cast<EClassCastFlags>(static_cast<CastFlagsType>(Left) | static_cast<CastFlagsType>(Right));
}

inline bool operator&(EClassCastFlags Left, EClassCastFlags Right)
{
	using CastFlagsType = std::underlying_type<EClassCastFlags>::type;
	return (static_cast<CastFlagsType>(Left) & static_cast<CastFlagsType>(Right)) == static_cast<CastFlagsType>(Right);
}
)");


	BasicHeader.Write(
		R"(

enum class EClassFlags : int32
{
	CLASS_None					= 0x00000000u,
	Abstract					= 0x00000001u,
	DefaultConfig				= 0x00000002u,
	Config						= 0x00000004u,
	Transient					= 0x00000008u,
	Parsed						= 0x00000010u,
	MatchedSerializers			= 0x00000020u,
	ProjectUserConfig			= 0x00000040u,
	Native						= 0x00000080u,
	NoExport					= 0x00000100u,
	NotPlaceable				= 0x00000200u,
	PerObjectConfig				= 0x00000400u,
	ReplicationDataIsSetUp		= 0x00000800u,
	EditInlineNew				= 0x00001000u,
	CollapseCategories			= 0x00002000u,
	Interface					= 0x00004000u,
	CustomConstructor			= 0x00008000u,
	Const						= 0x00010000u,
	LayoutChanging				= 0x00020000u,
	CompiledFromBlueprint		= 0x00040000u,
	MinimalAPI					= 0x00080000u,
	RequiredAPI					= 0x00100000u,
	DefaultToInstanced			= 0x00200000u,
	TokenStreamAssembled		= 0x00400000u,
	HasInstancedReference		= 0x00800000u,
	Hidden						= 0x01000000u,
	Deprecated					= 0x02000000u,
	HideDropDown				= 0x04000000u,
	GlobalUserConfig			= 0x08000000u,
	Intrinsic					= 0x10000000u,
	Constructed					= 0x20000000u,
	ConfigDoNotCheckDefaults	= 0x40000000u,
	NewerVersionExists			= 0x80000000u,
};
)");

	BasicHeader.Write(
		R"(
inline constexpr EClassFlags operator|(EClassFlags Left, EClassFlags Right)
{
	using ClassFlagsType = std::underlying_type<EClassFlags>::type;
	return static_cast<EClassFlags>(static_cast<ClassFlagsType>(Left) | static_cast<ClassFlagsType>(Right));
}

inline bool operator&(EClassFlags Left, EClassFlags Right)
{
	using ClassFlagsType = std::underlying_type<EClassFlags>::type;
	return ((static_cast<ClassFlagsType>(Left) & static_cast<ClassFlagsType>(Right)) == static_cast<ClassFlagsType>(Right));
}
)");

	BasicHeader.Write(
		R"(
class FScriptInterface
{
public:
	UObject* ObjectPointer = nullptr;
	void* InterfacePointer = nullptr;

	inline UObject* GetObjectRef()
	{
		return ObjectPointer;
	}
};

template<class InterfaceType>
class TScriptInterface : public FScriptInterface
{
public:
};


)");

	if (!Settings::Internal::bUseFProperty)
		return;

	// const std::string& SuperName, Types::Struct& Struct, int32 StructSize, int32 SuperSize

	struct FPropertyPredef
	{
		const char* ClassName;
		const char* SuperName;
	};

	std::unordered_map<std::string, int32> ClassSizePairs;

	constexpr std::array<FPropertyPredef, 0xD> FPropertyClassSuperPairs =
	{{
		{ "FFieldClass", "" },
		{ "FFieldVariant", "" },
		{ "FField", "" },
		{ "FProperty", "FField" },
		{ "FByteProperty", "FProperty" },
		{ "FBoolProperty", "FProperty" },
		{ "FObjectPropertyBase", "FProperty" },
		{ "FClassProperty", "FObjectPropertyBase" },
		{ "FStructProperty", "FProperty" },
		{ "FArrayProperty", "FProperty" },
		{ "FMapProperty", "FProperty" },
		{ "FSetProperty", "FProperty" },
		{ "FEnumProperty", "FProperty" }
	}};


	ClassSizePairs.reserve(FPropertyClassSuperPairs.size());
	for (auto& [ClassName, SuperName] : FPropertyClassSuperPairs)
	{
		int32 SuperSize = 0;

		if (SuperName && strcmp(SuperName, "") != 0)
			SuperSize = ClassSizePairs[SuperName];

		Types::Struct NewStruct(ClassName, true, SuperName);
		ClassSizePairs[ClassName] = Package::GeneratePredefinedMembers(ClassName, NewStruct, 0, SuperSize); // fix supersize

		BasicHeader.Write(NewStruct.GetGeneratedBody());
	}


	//-TUObjectArray
	//-TArray
	//-FString
	//-FName [AppendString()]
	//-TSubclassOf<Type>
	// TSet<Type>
	// TMap<Type>
	//-FText
}

//class FWeakObjectPtr
//{
//protected:
//	int32		ObjectIndex;
//	int32		ObjectSerialNumber;
//
//public:
//	class UObject* Get() const;
//
//	class UObject* operator->() const;
//
//	bool operator==(const FWeakObjectPtr& Other) const;
//	bool operator!=(const FWeakObjectPtr& Other) const;
//
//	bool operator==(const class UObject* Other) const;
//	bool operator!=(const class UObject* Other) const;
//};
//
//template<typename UEType>
//struct TWeakObjectPtr : FWeakObjectPtr
//{
//public:
//	class UEType* Get() const;
//
//	class UEType* operator->() const;
//};
//
//class UObject* FWeakObjectPtr::Get() const
//{
//	return UObject::GObjects->GetByIndex(ObjectIndex);
//}
//
//class UObject* FWeakObjectPtr::operator->() const
//{
//	return UObject::GObjects->GetByIndex(ObjectIndex);
//}
//
//bool FWeakObjectPtr::operator==(const FWeakObjectPtr& Other) const
//{
//	return ObjectIndex == Other.ObjectIndex;
//}
//bool FWeakObjectPtr::operator!=(const FWeakObjectPtr& Other) const
//{
//	return ObjectIndex != Other.ObjectIndex;
//}
//
//bool FWeakObjectPtr::operator==(const class UObject* Other) const
//{
//	return ObjectIndex == Obj->Index;
//}
//bool FWeakObjectPtr::operator!=(const class UObject* Other) const
//{
//	return ObjectIndex != Obj->Index;
//}
//
//
//class UEType* TWeakObjectPtr<UEType>::Get() const
//{
//	return UObject::GObjects->GetByIndex(ObjectIndex);
//}
//
//class UEType* TWeakObjectPtr<UEType>::operator->() const
//{
//	return UObject::GObjects->GetByIndex(ObjectIndex);
//}


//class TUObjectArray
//{
//	struct FUObjectItem
//	{
//		class UObject* Object;
//		uint8 Pad[0x10];
//	};
//
//	FUObjectItem* Objects;
//	int32_t MaxElements;
//	int32_t NumElements;
//
//public:
//	inline int Num() const
//	{
//		return NumElements;
//	}
//
//	inline class UObject* GetByIndex(const int32 Index) const
//	{
//		if (Index < 0 || Index > NumElements)
//			return nullptr;
//
//		return Objects[Index].Object;
//	}
//};
//
//class TUObjectArray
//{
//	enum
//	{
//		ElementsPerChunk = 0x{:X},
//	};
//
//	struct FUObjectItem
//	{
//		class UObject* Object;
//		uint8 Pad[0x10];
//	};
//
//	FUObjectItem** Objects;
//	uint8_t Pad_0[0x08];
//	int32_t MaxElements;
//	int32_t NumElements;
//	int32_t MaxChunks;
//	int32_t NumChunks;
//
//	inline int Num() const
//	{
//		return NumElements;
//	}
//
//	inline class UObject* GetByIndex(const int32 Index) const
//	{
//		if (Index < 0 || Index > NumElements)
//			return nullptr;
//
//		const int32 ChunkIndex = Index / ElementsPerChunk;
//		const int32 InChunkIdx = Index % ElementsPerChunk;
//
//		return Objects[ChunkIndex][InChunkIdx].Object;
//	}
//};

struct FText
{
	FString TextData;
	uint8 IdkTheRest[0x8];
};

template<typename ClassType>
class TSubclassOf
{
	class UClass* ClassPtr;

public:
	inline UClass* Get()
	{
		return ClassPtr;
	}
	inline UClass* operator->()
	{
		return ClassPtr;
	}
	inline TSubclassOf& operator=(UClass* Class)
	{
		ClassPtr = Class;

		return *this;
	}

	inline bool operator==(const TSubclassOf& Other) const
	{
		return ClassPtr == Other.ClassPtr;
	}
	inline bool operator!=(const TSubclassOf& Other) const
	{
		return ClassPtr != Other.ClassPtr;
	}
	inline bool operator==(UClass* Other) const
	{
		return ClassPtr == Other;
	}
	inline bool operator!=(UClass* Other) const
	{
		return ClassPtr != Other;
	}
};


//template<class T>
//class TArray
//{
//protected:
//	T* Data;
//	int32 NumElements;
//	int32 MaxElements;
//
//public:
//
//	TArray() = default;
//
//	inline TArray(int32 Size)
//		:NumElements(0), MaxElements(Size), Data(reinterpret_cast<T*>(malloc(sizeof(T) * Size)))
//	{
//	}
//
//	inline T& operator[](uint32 Index)
//	{
//		return Data[Index];
//	}
//	inline const T& operator[](uint32 Index) const
//	{
//		return Data[Index];
//	}
//
//	inline int32 Num()
//	{
//		return NumElements;
//	}
//
//	inline int32 Max()
//	{
//		return MaxElements;
//	}
//
//	inline int32 GetSlack()
//	{
//		return MaxElements - NumElements;
//	}
//
//	inline bool IsValid()
//	{
//		return Data != nullptr;
//	}
//
//	inline bool IsValidIndex(int32 Index)
//	{
//		return Index >= 0 && Index < NumElements;
//	}
//
//	inline bool IsValidIndex(uint32 Index)
//	{
//		return Index < NumElements;
//	}
//
//	inline void ResetNum()
//	{
//		NumElements = 0;
//	}
//};

//class FString : public TArray<wchar_t>
//{
//public:
//	inline FString() = default;
//
//	using TArray::TArray;
//
//	inline FString(const wchar_t* WChar)
//	{
//		MaxElements = NumElements = *WChar ? std::wcslen(WChar) + 1 : 0;
//
//		if (NumElements)
//		{
//			Data = const_cast<wchar_t*>(WChar);
//		}
//	}
//
//	inline FString operator=(const wchar_t*&& Other)
//	{
//		return FString(Other);
//	}
//
//	inline std::wstring ToWString()
//	{
//		if (IsValid())
//		{
//			return Data;
//		}
//
//		return L"";
//	}
//
//	inline std::string ToString()
//	{
//		if (IsValid())
//		{
//			std::wstring WData(Data);
//			return std::string(WData.begin(), WData.end());
//		}
//
//		return "";
//	}
//};

//class FName
//{
//public:
//	int32 ComparisonIndex;
//	int32 Number;
//
//	inline std::string ToString()
//	{
//		static FString TempString(1024);
//		static auto AppendString = reinterpret_cast<void(*)(FName*, FString&)>(uintptr_t(GetModuleHandle(0)) + OFFSET));
//
//		AppendString(this, TempString);
//
//		std::string OutputString = TempString.ToString();
//		TempString.ResetNum();
//
//		size_t pos = OutputString.rfind('/');
//
//		if (pos == std::string::npos)
//			return OutputString;
//
//		return OutputString.substr(pos + 1);
//	}
//
//	inline bool operator==(const FName& Other)
//	{
//		return ComparisonIndex == Other.ComparisonIndex;
//	}
//
//	inline bool operator!=(const FName& Other)
//	{
//		return ComparisonIndex != Other.ComparisonIndex;
//	}
//};

```

`Dumper/Generator.h`:

```h
#pragma once

#include <unordered_set>
#include <filesystem>
#include <chrono>
#include <future>
#include <set>
#include "FileWriter.h"
#include "Settings.h"
#include "Package.h"

namespace fs = std::filesystem;

using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::duration;
using std::chrono::milliseconds;

class Generator
{
	friend class Package;
	friend class Types::Class;
	friend class Types::Struct;
	friend class FileWriter;

private:
	struct PredefinedFunction
	{
		std::string DeclarationH;
		std::string DeclarationCPP;
		std::string Body;
	};

	struct PredefinedMember
	{
		std::string Type;
		std::string Name;
		int32 Offset;
		int32 Size;

		inline bool operator<(const PredefinedMember& Other) const { return  Offset != Other.Offset ? Offset < Other.Offset : Size < Other.Size; }
	};

	using FunctionsMap = std::unordered_map<std::string, std::pair<std::string, std::vector<PredefinedFunction>>>;
	using MemberMap = std::unordered_map<std::string, std::set<PredefinedMember>> ;

	static FunctionsMap PredefinedFunctions; // Types.cpp
	static MemberMap PredefinedMembers; // Package.cpp

	static std::mutex PackageMutex;
	static std::vector<std::future<void>> Futures;

public:
	static void Init();

private:
	static void InitPredefinedMembers();
	static void InitPredefinedFunctions();

private:
	static void HandlePackageGeneration(const fs::path* const SDKFolder, int32 PackageIndex, std::vector<int32>* MemberIndices);

public:
	static void GenerateMappings();
	static void GenerateIDAMappings();
	static void GenerateSDK();

private:
	static void GenerateSDKHeader(const fs::path& SdkPath, int32 BiggestPackageIdx);
	static void GenerateFixupFile(const fs::path& SdkPath);
	static void GenerateBasicFile(const fs::path& SdkPath);
};

```

`Dumper/NameArray.cpp`:

```cpp
#include "NameArray.h"

/* DEBUG */
#include "ObjectArray.h"

uint8* NameArray::GNames = nullptr;

FNameEntry::FNameEntry(void* Ptr)
	: Address((uint8*)Ptr)
{
}

std::string FNameEntry::GetString()
{
	if (!Address)
		return "";

	return GetStr(Address);
}

void* FNameEntry::GetAddress()
{
	return Address;
}

void FNameEntry::Init(uint8_t* FirstChunkPtr, int64 NameEntryStringOffset)
{
	if (Settings::Internal::bUseNamePool)
	{
		constexpr int64 NoneStrLen = 0x4;
		constexpr int64 BytePropertyStrLen = 0xC;

		Off::FNameEntry::NamePool::StringOffset = NameEntryStringOffset;
		Off::FNameEntry::NamePool::HeaderOffset = NameEntryStringOffset == 6 ? 4 : 0;

		uint16 BytePropertyHeader = *reinterpret_cast<uint16*>(*reinterpret_cast<uint8**>(FirstChunkPtr) + NameEntryStringOffset + NoneStrLen);

		while (BytePropertyHeader != BytePropertyStrLen)
		{			
			FNameEntryLengthShiftCount++;
			BytePropertyHeader >>= 1;
		}

		GetStr = [](uint8* NameEntry) -> std::string
		{
			const uint16 HeaderWithoutNumber = *reinterpret_cast<uint16*>(NameEntry + Off::FNameEntry::NamePool::HeaderOffset);
			const int32 NameLen = HeaderWithoutNumber >> FNameEntry::FNameEntryLengthShiftCount;

			if (NameLen == 0)
			{
				const int32 EntryIdOffset = Off::FNameEntry::NamePool::StringOffset + ((Off::FNameEntry::NamePool::StringOffset == 6) * 2);

				const int32 NextEntryIndex = *reinterpret_cast<int32*>(NameEntry + EntryIdOffset);
				const int32 Number = *reinterpret_cast<int32*>(NameEntry + EntryIdOffset + sizeof(int32));

				if (Number > 0)
					return NameArray::GetNameEntry(NextEntryIndex).GetString() + "_" + std::to_string(Number - 1);

				return NameArray::GetNameEntry(NextEntryIndex).GetString();
			}

			if (HeaderWithoutNumber & NameWideMask)
			{
				std::wstring WString(reinterpret_cast<const wchar_t*>(NameEntry + Off::FNameEntry::NamePool::StringOffset), NameLen);
				return std::string(WString.begin(), WString.end());
			}

			return std::string(reinterpret_cast<const char*>(NameEntry + Off::FNameEntry::NamePool::StringOffset), NameLen);
		};
	}
	else
	{
		uint8_t* FNameEntryNone = (uint8_t*)NameArray::GetNameEntry(0x0).GetAddress();
		uint8_t* FNameEntryIdxThree = (uint8_t*)NameArray::GetNameEntry(0x3).GetAddress();
		uint8_t* FNameEntryIdxEight = (uint8_t*)NameArray::GetNameEntry(0x8).GetAddress();

		for (int i = 0; i < 0x20; i++)
		{
			if (*reinterpret_cast<uint32*>(FNameEntryNone + i) == 0x656e6f4e /*"None" in little-endian*/)
			{
				Off::FNameEntry::NameArray::StringOffset = i;
				break;
			}
		}

		for (int i = 0; i < 0x20; i++)
		{
			// lowest bit is bIsWide mask, shift right by 1 to get the index
			if ((*reinterpret_cast<uint32*>(FNameEntryIdxThree + i) >> 1) == 0x3 &&
				(*reinterpret_cast<uint32*>(FNameEntryIdxEight + i) >> 1) == 0x8)
			{
				Off::FNameEntry::NameArray::IndexOffset = i;
				break;
			}
		}

		GetStr = [](uint8* NameEntry) -> std::string
		{
			const int32 NameIdx = *reinterpret_cast<int32*>(NameEntry + Off::FNameEntry::NameArray::IndexOffset);
			const void* NameString = reinterpret_cast<void*>(NameEntry + Off::FNameEntry::NameArray::StringOffset);

			if (NameIdx & NameWideMask)
			{
				std::wstring WString(reinterpret_cast<const wchar_t*>(NameString));
				return std::string(WString.begin(), WString.end());
			}

			return reinterpret_cast<const char*>(NameString);
		};
	}
}

bool NameArray::InitializeNameArray(uint8_t* NameArray)
{
	int32 ValidPtrCount = 0x0;
	int32 ZeroQWordCount = 0x0;

	int32 PerChunk = 0x0;

	if (!NameArray || IsBadReadPtr(NameArray))
		return false;

	for (int i = 0; i < 0x800; i += 0x8)
	{
		uint8_t* SomePtr = *reinterpret_cast<uint8_t**>(NameArray + i);

		if (SomePtr == 0)
		{
			ZeroQWordCount++;
		}
		else if (ZeroQWordCount == 0x0 && SomePtr != nullptr)
		{
			ValidPtrCount++;
		}
		else if (ZeroQWordCount > 0 && SomePtr != 0)
		{
			int32 NumElements = *reinterpret_cast<int32_t*>(NameArray + i);
			int32 NumChunks = *reinterpret_cast<int32_t*>(NameArray + i + 4);

			if (NumChunks == ValidPtrCount)
			{
				Off::NameArray::NumElements = i;
				Off::NameArray::MaxChunkIndex = i + 4;

				ByIndex = [](void* NamesArray, int32 ComparisonIndex, int32 NamePoolBlockOffsetBits) -> void*
				{
					const int32 ChunkIdx = ComparisonIndex / 0x4000;
					const int32 InChunk = ComparisonIndex % 0x4000;

					if (ComparisonIndex > NameArray::GetNumElements())
						return nullptr;

					return reinterpret_cast<void***>(NamesArray)[ChunkIdx][InChunk];
				};

				return true;
			}
		}
	}

	return false;
}

bool NameArray::InitializeNamePool(uint8_t* NamePool)
{
	Off::NameArray::MaxChunkIndex = 0x0;
	Off::NameArray::ByteCursor = 0x4;

	Off::NameArray::ChunksStart = 0x10;

	for (int i = 0x0; i < 0x20; i += 4)
	{
		const int32 PossibleMaxChunkIdx = *reinterpret_cast<int32*>(NamePool + i);

		if (PossibleMaxChunkIdx <= 0 || PossibleMaxChunkIdx > 0x10000)
			continue;

		int32 NotNullptrCount = 0x0;
		bool bFoundFirstPtr = false;

		for (int j = 0x0; j < 0x10000; j += 8)
		{
			const int32 ChunkOffset = i + 8 + j + (i % 8);

			if ((*reinterpret_cast<uint8_t**>(NamePool + ChunkOffset)) != nullptr)
			{
				NotNullptrCount++;

				if (!bFoundFirstPtr)
				{
					bFoundFirstPtr = true;
					Off::NameArray::ChunksStart = i + 8 + j + (i % 8);
				}
			}
		}

		if (PossibleMaxChunkIdx == (NotNullptrCount - 1))
		{
			Off::NameArray::MaxChunkIndex = i;
			Off::NameArray::ByteCursor = i + 4;
			break;
		}
	}

	constexpr uint64 CoreUObjAsUint64 = 0x726F432F74706972; // little endian "ript/Cor" ["/Script/CoreUObject"]
	constexpr uint32 NoneAsUint32 = 0x656E6F4E; // little endian "None"

	constexpr int64 CoreUObjectStringLength = sizeof("/S");

	uint8_t** ChunkPtr = reinterpret_cast<uint8_t**>(NamePool + Off::NameArray::ChunksStart);

	// "/Script/CoreUObject"
	uint8_t* CoreUObjectFNameEntry = nullptr;
	int64 FNameEntryHeaderSize = 0x0;

	for (int i = 0; i < 0x1000; i++)
	{
		if (*reinterpret_cast<uint32*>(*ChunkPtr + i) == NoneAsUint32)
		{
			FNameEntryHeaderSize = i;
		}
		else if (*reinterpret_cast<uint64*>(*ChunkPtr + i) == CoreUObjAsUint64)
		{
			CoreUObjectFNameEntry = *ChunkPtr + static_cast<uint64>(i) + (CoreUObjectStringLength + FNameEntryHeaderSize);
			break;
		}
	}

	NameEntryStride = FNameEntryHeaderSize == 2 ? 2 : 4;
	Off::InSDK::FNameEntryStride = NameEntryStride;

	ByIndex = [](void* NamesArray, int32 ComparisonIndex, int32 NamePoolBlockOffsetBits) -> void*
	{
		const int32 ChunkIdx = ComparisonIndex >> NamePoolBlockOffsetBits;
		const int32 InChunkOffset = (ComparisonIndex & ((1 << NamePoolBlockOffsetBits) - 1)) * NameEntryStride;

		const bool bIsBeyondLastChunk = ChunkIdx == NameArray::GetNumChunks() && InChunkOffset > NameArray::GetByteCursor();

		if (ChunkIdx < 0 || ChunkIdx > GetNumChunks() || bIsBeyondLastChunk)
			return nullptr;

		uint8_t* ChunkPtr = reinterpret_cast<uint8_t*>(NamesArray) + 0x10;

		return reinterpret_cast<uint8_t**>(ChunkPtr)[ChunkIdx] + InChunkOffset;
	};

	Settings::Internal::bUseNamePool = true;
	FNameEntry::Init(reinterpret_cast<uint8*>(ChunkPtr), FNameEntryHeaderSize);

	return true;
}

void NameArray::Init()
{
	uintptr_t ImageBase = GetImageBase();

	std::cout << "Searching for GNames...\n\n";

	struct Signature
	{
		const char* Pattern;
		int Relative;
	};

	std::array<Signature, 3> Signatures = { {
		{ "48 89 3D ? ? ? ? 8B 87 ? ? ? ? 05 ? ? ? ? 99 81 E2 ? ? ? ?", 3 }, // TNameEntryArray
		{ "48 8D 0D ? ? ? ? E8 ? ? ? ? 4C 8B C0 C6 05", 3 }, // FNamePool
		{ "48 8D 05 ? ? ? ? 48 83 C4 ? 5F C3 48 89 5C 24", 3 } // FNamePool Back4Blood
	}};

	uint8_t** GNamesAddress = nullptr;

	for (auto Sig : Signatures)
	{
		if (GNamesAddress = reinterpret_cast<uint8_t**>(FindPattern(Sig.Pattern, Sig.Relative, true)))
			break;
	}

	if (!GNamesAddress)
	{
		std::cout << "\nGNames couldn't be found\n\n" << std::endl;
		exit(1);
	}

	Off::InSDK::GNames = uintptr_t(GNamesAddress) - ImageBase;

	if (NameArray::InitializeNameArray(*GNamesAddress))
	{
		GNames = *GNamesAddress;
		Settings::Internal::bUseNamePool = false;
		FNameEntry::Init();
		std::cout << "Found NameArray at offset: 0x" << std::hex << (reinterpret_cast<uintptr_t>(GNamesAddress) - ImageBase) << "\n" << std::endl;
		return;
	}
	else if (NameArray::InitializeNamePool(reinterpret_cast<uint8_t*>(GNamesAddress)))
	{
		GNames = reinterpret_cast<uint8_t*>(GNamesAddress);
		Settings::Internal::bUseNamePool = true;
		std::cout << "Found NamePool at offset: 0x" << std::hex << (reinterpret_cast<uintptr_t>(GNamesAddress) - ImageBase) << "\n" << std::endl;
		/* FNameEntry::Init() was moved into NameArray::InitializeNamePool to avoid duplicated logic */
		return;
	}

	std::cout << "\nGNames couldn't be found!\n\n\n";
}

void NameArray::PostInit()
{
	if (GNames && Settings::Internal::bUseNamePool)
	{
		// Reverse-order iteration because newer objects are more likely to have a chunk-index equal to NumChunks - 1
		
		NameArray::FNameBlockOffsetBits = 0xE;

		int i = ObjectArray::Num();
		while (i >= 0)
		{
			const int32 CurrentBlock = NameArray::GetNumChunks();

			UEObject Obj = ObjectArray::GetByIndex(i);

			if (!Obj)
			{
				i--;
				continue;
			}

			const int32 ObjNameChunkIdx = Obj.GetFName().GetCompIdx() >> NameArray::FNameBlockOffsetBits;

			if (ObjNameChunkIdx == CurrentBlock)
				break;

			if (ObjNameChunkIdx > CurrentBlock)
			{
				NameArray::FNameBlockOffsetBits++;
				i = ObjectArray::Num();
			}

			i--;
		}
		Off::InSDK::FNamePoolBlockOffsetBits = NameArray::FNameBlockOffsetBits;

		std::cout << "\nNameArray::FNameBlockOffsetBits: 0x" << std::hex << NameArray::FNameBlockOffsetBits << "\n" << std::endl;
	}
}

int32 NameArray::GetNumChunks()
{
	return *reinterpret_cast<int32*>(GNames + Off::NameArray::MaxChunkIndex);
}

int32 NameArray::GetNumElements()
{
	return !Settings::Internal::bUseNamePool ? *reinterpret_cast<int32*>(GNames + Off::NameArray::NumElements) : 0;
}

int32 NameArray::GetByteCursor()
{
	return Settings::Internal::bUseNamePool ? *reinterpret_cast<int32*>(GNames + Off::NameArray::ByteCursor) : 0;
}

FNameEntry NameArray::GetNameEntry(void* Name)
{
	return ByIndex(GNames, FName(Name).GetCompIdx(), FNameBlockOffsetBits);
}

FNameEntry NameArray::GetNameEntry(int32 Idx)
{
	return ByIndex(GNames, Idx, FNameBlockOffsetBits);
}


```

`Dumper/NameArray.h`:

```h
#pragma once
#include "UnrealTypes.h"

class FNameEntry
{
private:
	friend class NameArray;

private:
	static constexpr int32 NameWideMask = 0x1;

private:
	static inline int32 FNameEntryLengthShiftCount = 0x0;

	static inline std::string(*GetStr)(uint8* NameEntry) = nullptr;

private:
	uint8* Address;

public:
	FNameEntry() = default;

	FNameEntry(void* Ptr);

public:
	std::string GetString();
	void* GetAddress();

private:
	//Optional to avoid code duplication for FNamePool
	static void Init(uint8_t* FirstChunkPtr = nullptr, int64 NameEntryStringOffset = 0x0);
};

class NameArray
{
private:
	static inline uint32 FNameBlockOffsetBits = 0x10;

private:
	static uint8* GNames;

	static inline int64 NameEntryStride = 0x0;

	static inline void* (*ByIndex)(void* NamesArray, int32 ComparisonIndex, int32 NamePoolBlockOffsetBits) = nullptr;

private:
	static bool InitializeNameArray(uint8_t* NameArray);
	static bool InitializeNamePool(uint8_t* NamePool);

public:
	static void Init();
	static void PostInit();

	static void Init(int32 GNamesOffset, bool bIsNamePool);
	
public:
	static int32 GetNumChunks();

	static int32 GetNumElements();
	static int32 GetByteCursor();

	static FNameEntry GetNameEntry(void* Name);
	static FNameEntry GetNameEntry(int32 Idx);
};

```

`Dumper/ObjectArray.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <format>
#include <filesystem>
#include "ObjectArray.h"
#include "Offsets.h"
#include "Utils.h"

namespace fs = std::filesystem;

/* Scuffed stuff up here */
struct FChunkedFixedUObjectArray
{
	void** ObjectsAbove;
	uint8_t Pad_0[0x08];
	int32_t MaxElements;
	int32_t NumElements;
	int32_t MaxChunks;
	int32_t NumChunks;
	void** ObjectsBelow;

	inline int32 IsValid(int32& OutObjectsPtrOffset)
	{
		void** ObjectsAboveButDecrypted = (void**)ObjectArray::DecryptPtr(ObjectsAbove);
		void** ObjectsBelowButDecrypted = (void**)ObjectArray::DecryptPtr(ObjectsBelow);

		if (NumChunks > 0x14 || NumChunks < 0x1)
			return false;

		if (MaxChunks > 0x22F || MaxChunks < 0x9)
			return false;

		if (NumElements > MaxElements || NumChunks > MaxChunks)
			return false;

		if (((NumElements / 0x10000) + 1) != NumChunks || (MaxElements / 0x10000) != MaxChunks)
			return false;

		const bool bAreObjectsAboveValid = (ObjectsAboveButDecrypted && !IsBadReadPtr(ObjectsAboveButDecrypted));
		const bool bAreObjectsBewlowValid = (ObjectsBelowButDecrypted && !IsBadReadPtr(ObjectsBelowButDecrypted));

		if (!bAreObjectsAboveValid && !bAreObjectsBewlowValid)
			return false;

		for (int i = 0; i < NumChunks; i++)
		{
#pragma warning(disable:6011)
			const bool bIsCurrentIndexValidAbove = bAreObjectsAboveValid ? !IsBadReadPtr(ObjectsAboveButDecrypted[i]) : false;
			const bool bIsCurrentIndexValidBelow = bAreObjectsBewlowValid ? !IsBadReadPtr(ObjectsBelowButDecrypted[i]) : false;
#pragma pop

			if (!bIsCurrentIndexValidAbove && !bIsCurrentIndexValidBelow)
				return false;
		}

		OutObjectsPtrOffset = 0x00;

		if (!bAreObjectsAboveValid && bAreObjectsBewlowValid)
			OutObjectsPtrOffset = 0x20;

		return true;
	}
};

struct FFixedUObjectArray
{
	struct FUObjectItem
	{
		void* Object;
		uint8_t Pad[0x10];
	};

	FUObjectItem* Objects;
	int32_t Max;
	int32_t Num;

	inline bool IsValid()
	{
		FUObjectItem* ObjectsButDecrypted = (FUObjectItem*)ObjectArray::DecryptPtr(Objects);

		if (Num > Max)
			return false;

		if (Max > 0x400000)
			return false;

		if (Num < 0x1000)
			return false;

		if (IsBadReadPtr(ObjectsButDecrypted))
			return false;

		if (IsBadReadPtr(ObjectsButDecrypted[5].Object))
			return false;

		if (*(int32_t*)(uintptr_t(ObjectsButDecrypted[5].Object) + 0xC) != 5)
			return false;

		return true;
	}
};



uint8* ObjectArray::GObjects = nullptr;
uint32 ObjectArray::NumElementsPerChunk = 0x10000;
uint32 ObjectArray::SizeOfFUObjectItem = 0x18;
uint32 ObjectArray::FUObjectItemInitialOffset = 0x0;
std::string ObjectArray::DecryptionLambdaStr = "";

void ObjectArray::InitializeFUObjectItem(uint8_t* FirstItemPtr)
{
	for (int i = 0x0; i < 0x10; i += 4)
	{
		if (!IsBadReadPtr(*reinterpret_cast<uint8_t**>(FirstItemPtr + i)))
		{
			FUObjectItemInitialOffset = i;
			break;
		}
	}

	for (int i = FUObjectItemInitialOffset + 0x8; i <= 0x38; i += 4)
	{
		void* SecondObject = *reinterpret_cast<uint8**>(FirstItemPtr + i);
		void* ThirdObject  = *reinterpret_cast<uint8**>(FirstItemPtr + (i * 2) - FUObjectItemInitialOffset);
		if (!IsBadReadPtr(SecondObject) && !IsBadReadPtr(*(void**)SecondObject) && !IsBadReadPtr(ThirdObject) && !IsBadReadPtr(*(void**)ThirdObject))
		{
			SizeOfFUObjectItem = i - FUObjectItemInitialOffset;
			break;
		}
	}

	Off::InSDK::FUObjectItemInitialOffset = FUObjectItemInitialOffset;
	Off::InSDK::FUObjectItemSize = SizeOfFUObjectItem;
}

void ObjectArray::InitDecryption(uint8_t* (*DecryptionFunction)(void* ObjPtr), const char* DecryptionLambdaAsStr)
{
	DecryptPtr = DecryptionFunction;
	DecryptionLambdaStr = DecryptionLambdaAsStr;
}

void ObjectArray::InitializeChunkSize(uint8_t* ChunksPtr)
{
	int IndexOffset = 0x0;
	uint8* ObjAtIdx374 = (uint8*)ByIndex(ChunksPtr, 0x374, SizeOfFUObjectItem, FUObjectItemInitialOffset, 0x10000);
	uint8* ObjAtIdx106 = (uint8*)ByIndex(ChunksPtr, 0x106, SizeOfFUObjectItem, FUObjectItemInitialOffset, 0x10000);

	for (int i = 0x8; i < 0x20; i++)
	{
		if (*reinterpret_cast<int32*>(ObjAtIdx374 + i) == 0x374 && *reinterpret_cast<int32*>(ObjAtIdx106 + i) == 0x106)
		{
			IndexOffset = i;
			break;
		}
	}

	int IndexToCheck = 0x10400;
	while (ObjectArray::Num() > IndexToCheck)
	{
		if (void* Obj = ByIndex(ChunksPtr, IndexToCheck, SizeOfFUObjectItem, FUObjectItemInitialOffset, 0x10000))
		{
			const bool bIsTrue = *reinterpret_cast<int32*>((uint8*)Obj + IndexOffset) != IndexToCheck;
			NumElementsPerChunk = bIsTrue ? 0x10400 : 0x10000;
			break;
		}
		IndexToCheck += 0x10400;
	}

	Off::InSDK::ChunkSize = NumElementsPerChunk;
}

/* We don't speak about this function... */
void ObjectArray::Init(bool bScanAllMemory)
{
	if (!bScanAllMemory)
		std::cout << "\nDumper-7 by me, you & him\n\n\n";

	uintptr_t ImageBase = GetImageBase();
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)(ImageBase);
	PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)(ImageBase + DosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER Sections = IMAGE_FIRST_SECTION(NtHeader);

	uint8_t* SearchBase = (uint8_t*)ImageBase;
 	DWORD SearchRange = NtHeader->OptionalHeader.SizeOfImage;

	if (!bScanAllMemory)
	{
		for (int i = 0; i < NtHeader->FileHeader.NumberOfSections; i++)
		{
			IMAGE_SECTION_HEADER& CurrentSection = Sections[i];

			if (std::string((char*)CurrentSection.Name) == ".data")
			{
				SearchBase = (uint8_t*)(CurrentSection.VirtualAddress + ImageBase);
				SearchRange = CurrentSection.Misc.VirtualSize;
			}
		}
	}

	if (!bScanAllMemory)
		std::cout << "Searching for GObjects...\n\n";


	for (int i = 0; i < SearchRange; i += 0x4)
	{

		auto FixedArray = reinterpret_cast<FFixedUObjectArray*>(SearchBase + i);
		auto ChunkedArray = reinterpret_cast<FChunkedFixedUObjectArray*>(SearchBase + i);

		if (FixedArray->IsValid())
		{
			GObjects = reinterpret_cast<uint8_t*>(SearchBase + i);
			Off::FUObjectArray::Num = 0xC;
			NumElementsPerChunk = -1;

			Off::InSDK::GObjects = uintptr_t(SearchBase + i) - ImageBase;

			std::cout << "Found FFixedUObjectArray GObjects at offset 0x" << std::hex << Off::InSDK::GObjects << std::dec << "\n\n";

			ByIndex = [](void* ObjectsArray, int32 Index, uint32 FUObjectItemSize, uint32 FUObjectItemOffset, uint32 PerChunk) -> void*
			{
				if (Index < 0 || Index > Num())
					return nullptr;

				uint8_t* ChunkPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(ObjectsArray));

				return *reinterpret_cast<void**>(ChunkPtr + FUObjectItemOffset + (Index * FUObjectItemSize));
			};

			uint8_t* ChunksPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(GObjects + Off::FUObjectArray::Ptr));

			ObjectArray::InitializeFUObjectItem(*reinterpret_cast<uint8_t**>(ChunksPtr));

			return;
		}
		else if (ChunkedArray->IsValid(Off::FUObjectArray::Ptr))
		{
			GObjects = reinterpret_cast<uint8_t*>(SearchBase + i);
			NumElementsPerChunk = 0x10000;
			SizeOfFUObjectItem = 0x18;
			Off::FUObjectArray::Num = 0x14;
			FUObjectItemInitialOffset = 0x0;

			Off::InSDK::GObjects = uintptr_t(SearchBase + i) - ImageBase;

			std::cout << "Found FChunkedFixedUObjectArray GObjects at offset 0x" << std::hex << Off::InSDK::GObjects << std::dec << "\n\n";

			ByIndex = [](void* ObjectsArray, int32 Index, uint32 FUObjectItemSize, uint32 FUObjectItemOffset, uint32 PerChunk) -> void*
			{
				if (Index < 0 || Index > Num())
					return nullptr;

				const int32 ChunkIndex = Index / PerChunk;
				const int32 InChunkIdx = Index % PerChunk;

				uint8_t* ChunkPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(ObjectsArray));

				uint8_t* Chunk = reinterpret_cast<uint8_t**>(ChunkPtr)[ChunkIndex];
				uint8_t* ItemPtr = reinterpret_cast<uint8_t*>(Chunk) + (InChunkIdx * FUObjectItemSize);

				return *reinterpret_cast<void**>(ItemPtr + FUObjectItemOffset);
			};
			
			uint8_t* ChunksPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(GObjects + Off::FUObjectArray::Ptr));

			ObjectArray::InitializeFUObjectItem(*reinterpret_cast<uint8_t**>(ChunksPtr));

			ObjectArray::InitializeChunkSize(GObjects + Off::FUObjectArray::Ptr);

			return;
		}
	}

	if (!bScanAllMemory)
	{
		ObjectArray::Init(true);
		return;
	}

	if (!bScanAllMemory)
		std::cout << "\nGObjects couldn't be found!\n\n\n";
}

void ObjectArray::Init(int32 GObjectsOffset, int32 ElementsPerChunk, bool bIsChunked)
{
	GObjects = reinterpret_cast<uint8_t*>(GetImageBase() + GObjectsOffset);

	Off::InSDK::GObjects = GObjectsOffset;

	std::cout << "GObjects: 0x" << (void*)GObjects << "\n" << std::endl;

	if (!bIsChunked)
	{
		Off::FUObjectArray::Num = 0xC;

		ByIndex = [](void* ObjectsArray, int32 Index, uint32 FUObjectItemSize, uint32 FUObjectItemOffset, uint32 PerChunk) -> void*
		{
			if (Index < 0 || Index > Num())
				return nullptr;

			uint8_t* ItemPtr = *reinterpret_cast<uint8_t**>(ObjectsArray) + (Index * FUObjectItemSize);

			return *reinterpret_cast<void**>(ItemPtr + FUObjectItemOffset);
		};

		uint8_t* ChunksPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(GObjects));

		ObjectArray::InitializeFUObjectItem(*reinterpret_cast<uint8_t**>(ChunksPtr));
	}
	else
	{
		Off::FUObjectArray::Num = 0x14;

		ByIndex = [](void* ObjectsArray, int32 Index, uint32 FUObjectItemSize, uint32 FUObjectItemOffset, uint32 PerChunk) -> void*
		{
			if (Index < 0 || Index > Num())
				return nullptr;

			const int32 ChunkIndex = Index / PerChunk;
			const int32 InChunkIdx = Index % PerChunk;

			uint8_t* Chunk = (*reinterpret_cast<uint8_t***>(ObjectsArray))[ChunkIndex];
			uint8_t* ItemPtr = reinterpret_cast<uint8_t*>(Chunk) + (InChunkIdx * FUObjectItemSize);

			return *reinterpret_cast<void**>(ItemPtr + FUObjectItemOffset);
		};

		uint8_t* ChunksPtr = DecryptPtr(*reinterpret_cast<uint8_t**>(GObjects));

		ObjectArray::InitializeFUObjectItem(*reinterpret_cast<uint8_t**>(ChunksPtr));
	}

	NumElementsPerChunk = ElementsPerChunk;
	Off::InSDK::ChunkSize = ElementsPerChunk;
}

void ObjectArray::DumpObjects()
{
	fs::path Path(Settings::SDKGenerationPath);

	if (!Settings::GameVersion.empty() && !Settings::GameName.empty())
		Path /= (Settings::GameVersion + '-' + Settings::GameName);

	std::ofstream DumpStream(Path / "GObjects-Dump.txt");

	DumpStream << "Object dump by Dumper-7\n\n";
	DumpStream << (!Settings::GameVersion.empty() && !Settings::GameName.empty() ? (Settings::GameVersion + '-' + Settings::GameName) + "\n\n" : "");
	DumpStream << "Count: " << Num() << "\n\n\n";

	for (auto Object : ObjectArray())
	{
		DumpStream << std::format("[{:08X}] {{{}}} {}\n", Object.GetIndex(), Object.GetAddress(), Object.GetFullName());
	}

	DumpStream.close();
}


void ObjectArray::GetAllPackages(std::unordered_map<int32_t, std::vector<int32_t>>& OutPackagesWithMembers/*, std::unordered_map<int32_t, bool>& PackagesToInclude*/)
{
	UEStruct::StructSizes.reserve(0x600);

	for (UEObject Object : ObjectArray())
	{
		if (!Object || Object.HasAnyFlags(EObjectFlags::ClassDefaultObject))
			continue;

		if (Object.IsA(EClassCastFlags::Struct))
		{
			OutPackagesWithMembers[Object.GetOutermost().GetIndex()].push_back(Object.GetIndex());

			UEStruct ObjAsStruct = Object.Cast<UEStruct>();
			UEStruct Super = ObjAsStruct.GetSuper();

			int32 LowestOffset = 0xFFFFFF;
	
			for (UEProperty Property : ObjAsStruct.GetProperties())
			{
				if (!Property.IsTypeSupported())
					UEProperty::UnknownProperties.insert({ Property.GetCppType(), Property.GetSize() });

				if (Property.Cast<UEProperty>().GetOffset() < LowestOffset)
				{
					LowestOffset = Property.Cast<UEProperty>().GetOffset();
				}

				if (Property.IsA(EClassCastFlags::EnumProperty))
				{
					UEEnum Enum = Property.Cast<UEEnumProperty>().GetEnum();
				
					if (Property.Cast<UEEnumProperty>().GetSize() != 0x1 && Enum)
						UEEnum::BigEnums[Enum.GetIndex()] = Property.Cast<UEEnumProperty>().GetUnderlayingProperty().GetCppType();
				}
			}

			if (!Super || Object.IsA(EClassCastFlags::Function))
				continue;

			if (LowestOffset != 0xFFFFFF)
			{
				for (UEStruct S = Super; S; S = S.GetSuper())
				{
					auto It = UEStruct::StructSizes.find(S.GetIndex());

					if (It != UEStruct::StructSizes.end())
					{
						if (It->second > LowestOffset)
							It->second = LowestOffset;
					}
					else
					{
						UEStruct::StructSizes[S.GetIndex()] = (LowestOffset < S.GetStructSize() ? LowestOffset : S.GetStructSize());
					}

					if (S.HasMembers())
						break;
				}
			}
		}
		else if (Object.IsA(EClassCastFlags::Enum))
		{
			OutPackagesWithMembers[Object.GetOutermost().GetIndex()].push_back(Object.GetIndex());
		}
	}
}

int32 ObjectArray::Num()
{
	return *reinterpret_cast<int32*>(GObjects + Off::FUObjectArray::Num);
}

template<typename UEType>
static UEType ObjectArray::GetByIndex(int32 Index)
{
	return UEType(ByIndex(GObjects + Off::FUObjectArray::Ptr, Index, SizeOfFUObjectItem, FUObjectItemInitialOffset, NumElementsPerChunk));
}

template<typename UEType>
UEType ObjectArray::FindObject(std::string FullName, EClassCastFlags RequiredType)
{
	for (UEObject Object : ObjectArray())
	{
		if (Object.IsA(RequiredType) && Object.GetFullName() == FullName)
		{
			return Object.Cast<UEType>();
		}
	}

	return UEType();
}

template<typename UEType>
UEType ObjectArray::FindObjectFast(std::string Name, EClassCastFlags RequiredType)
{
	auto ObjArray = ObjectArray();

	for (UEObject Object : ObjArray)
	{
		if (Object.IsA(RequiredType) && Object.GetName() == Name)
		{
			return Object.Cast<UEType>();
		}
	}

	return UEType();
}

template<typename UEType>
static UEType ObjectArray::FindObjectFastInOuter(std::string Name, std::string Outer)
{
	auto ObjArray = ObjectArray();

	for (UEObject Object : ObjArray)
	{
		if (Object.GetName() == Name && Object.GetOuter().GetName() == Outer)
		{
			return Object.Cast<UEType>();
		}
	}

	return UEType();
}

UEClass ObjectArray::FindClass(std::string FullName)
{
	return FindObject<UEClass>(FullName, EClassCastFlags::Class);
}

UEClass ObjectArray::FindClassFast(std::string Name)
{
	return FindObjectFast<UEClass>(Name, EClassCastFlags::Class);
}

ObjectArray::ObjectsIterator ObjectArray::begin()
{
	return ObjectsIterator(*this);
}
ObjectArray::ObjectsIterator ObjectArray::end()
{
	return ObjectsIterator(*this, Num());
}


ObjectArray::ObjectsIterator::ObjectsIterator(ObjectArray& Array, int32 StartIndex)
	: IteratedArray(Array), CurrentIndex(StartIndex), CurrentObject(ObjectArray::GetByIndex(StartIndex))
{
}

UEObject ObjectArray::ObjectsIterator::operator*()
{
	return CurrentObject;
}

ObjectArray::ObjectsIterator& ObjectArray::ObjectsIterator::operator++()
{
	CurrentObject = ObjectArray::GetByIndex(++CurrentIndex);

	while (!CurrentObject && CurrentIndex < ObjectArray::Num() - 1)
	{
		CurrentObject = ObjectArray::GetByIndex(++CurrentIndex);
	}

	return *this;
}

bool ObjectArray::ObjectsIterator::operator!=(const ObjectsIterator& Other)
{
	return CurrentIndex != Other.CurrentIndex;
}

int32 ObjectArray::ObjectsIterator::GetIndex() const
{
	return CurrentIndex;
}

/*
* The compiler won't generate functions for a specific template type unless it's used in the .cpp file corresponding to the
* header it was declatred in.
*
* See https://stackoverflow.com/questions/456713/why-do-i-get-unresolved-external-symbol-errors-when-using-templates
*/
void TemplateTypeCreationForObjectArray(void)
{
	ObjectArray::FindObject<UEObject>("");
	ObjectArray::FindObject<UEField>("");
	ObjectArray::FindObject<UEEnum>("");
	ObjectArray::FindObject<UEStruct>("");
	ObjectArray::FindObject<UEClass>("");
	ObjectArray::FindObject<UEFunction>("");
	ObjectArray::FindObject<UEProperty>("");
	ObjectArray::FindObject<UEByteProperty>("");
	ObjectArray::FindObject<UEBoolProperty>("");
	ObjectArray::FindObject<UEObjectProperty>("");
	ObjectArray::FindObject<UEClassProperty>("");
	ObjectArray::FindObject<UEStructProperty>("");
	ObjectArray::FindObject<UEArrayProperty>("");
	ObjectArray::FindObject<UEMapProperty>("");
	ObjectArray::FindObject<UESetProperty>("");
	ObjectArray::FindObject<UEEnumProperty>("");

	ObjectArray::FindObjectFast<UEObject>("");
	ObjectArray::FindObjectFast<UEField>("");
	ObjectArray::FindObjectFast<UEEnum>("");
	ObjectArray::FindObjectFast<UEStruct>("");
	ObjectArray::FindObjectFast<UEClass>("");
	ObjectArray::FindObjectFast<UEFunction>("");
	ObjectArray::FindObjectFast<UEProperty>("");
	ObjectArray::FindObjectFast<UEByteProperty>("");
	ObjectArray::FindObjectFast<UEBoolProperty>("");
	ObjectArray::FindObjectFast<UEObjectProperty>("");
	ObjectArray::FindObjectFast<UEClassProperty>("");
	ObjectArray::FindObjectFast<UEStructProperty>("");
	ObjectArray::FindObjectFast<UEArrayProperty>("");
	ObjectArray::FindObjectFast<UEMapProperty>("");
	ObjectArray::FindObjectFast<UESetProperty>("");
	ObjectArray::FindObjectFast<UEEnumProperty>("");

	ObjectArray::FindObjectFastInOuter<UEObject>("", "");
	ObjectArray::FindObjectFastInOuter<UEField>("", "");
	ObjectArray::FindObjectFastInOuter<UEEnum>("", "");
	ObjectArray::FindObjectFastInOuter<UEStruct>("", "");
	ObjectArray::FindObjectFastInOuter<UEClass>("", "");
	ObjectArray::FindObjectFastInOuter<UEFunction>("", "");
	ObjectArray::FindObjectFastInOuter<UEProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEByteProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEBoolProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEObjectProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEClassProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEStructProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEArrayProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEMapProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UESetProperty>("", "");
	ObjectArray::FindObjectFastInOuter<UEEnumProperty>("", "");

	ObjectArray::GetByIndex<UEObject>(-1);
	ObjectArray::GetByIndex<UEField>(-1);
	ObjectArray::GetByIndex<UEEnum>(-1);
	ObjectArray::GetByIndex<UEStruct>(-1);
	ObjectArray::GetByIndex<UEClass>(-1);
	ObjectArray::GetByIndex<UEFunction>(-1);
	ObjectArray::GetByIndex<UEProperty>(-1);
	ObjectArray::GetByIndex<UEByteProperty>(-1);
	ObjectArray::GetByIndex<UEBoolProperty>(-1);
	ObjectArray::GetByIndex<UEObjectProperty>(-1);
	ObjectArray::GetByIndex<UEClassProperty>(-1);
	ObjectArray::GetByIndex<UEStructProperty>(-1);
	ObjectArray::GetByIndex<UEArrayProperty>(-1);
	ObjectArray::GetByIndex<UEMapProperty>(-1);
	ObjectArray::GetByIndex<UESetProperty>(-1);
	ObjectArray::GetByIndex<UEEnumProperty>(-1);
}

```

`Dumper/ObjectArray.h`:

```h
#pragma once
#include <string>
#include <vector>
#include "UnrealObjects.h"

class ObjectArray
{
private:
	friend struct FChunkedFixedUObjectArray;
	friend struct FFixedUObjectArray;
	friend class ObjectArrayValidator;

private:
	static uint8* GObjects;
	static uint32 NumElementsPerChunk;
	static uint32 SizeOfFUObjectItem;
	static uint32 FUObjectItemInitialOffset;

public:
	static std::string DecryptionLambdaStr;

private:
	static inline void*(*ByIndex)(void* ObjectsArray, int32 Index, uint32 FUObjectItemSize, uint32 FUObjectItemOffset, uint32 PerChunk) = nullptr;

	static inline uint8_t* (*DecryptPtr)(void* ObjPtr) = [](void* Ptr) -> uint8* { return (uint8*)Ptr; };

private:
	static void InitializeFUObjectItem(uint8_t* FirstItemPtr);
	static void InitializeChunkSize(uint8_t* GObjects);

public:
	static void InitDecryption(uint8_t* (*DecryptionFunction)(void* ObjPtr), const char* DecryptionLambdaAsStr);

	static void Init(bool bScanAllMemory = false);

	static void Init(int32 GObjectsOffset, int32 NumElementsPerChunk, bool bIsChunked);

	static void DumpObjects();

	static void GetAllPackages(std::unordered_map<int32_t, std::vector<int32_t>>& OutPackagesWithMembers);

	static int32 Num();

	template<typename UEType = UEObject>
	static UEType GetByIndex(int32 Index);

	template<typename UEType = UEObject>
	static UEType FindObject(std::string FullName, EClassCastFlags RequiredType = EClassCastFlags::None);

	template<typename UEType = UEObject>
	static UEType FindObjectFast(std::string Name, EClassCastFlags RequiredType = EClassCastFlags::None);

	template<typename UEType = UEObject>
	static UEType FindObjectFastInOuter(std::string Name, std::string Outer);

	static UEClass FindClass(std::string FullName);

	static UEClass FindClassFast(std::string Name);

	class ObjectsIterator
	{
		ObjectArray& IteratedArray;
		UEObject CurrentObject;
		int32 CurrentIndex;

	public:
		ObjectsIterator(ObjectArray& Array, int32 StartIndex = 0);

		UEObject operator*();
		ObjectsIterator& operator++();
		bool operator!=(const ObjectsIterator& Other);

		int32 GetIndex() const;
	};

	ObjectsIterator begin();
	ObjectsIterator end();

	static inline void* DEBUGGetGObjects()
	{
		return GObjects;
	}
};


#define InitObjectArrayDecryption(DecryptionLambda) ObjectArray::InitDecryption(DecryptionLambda, #DecryptionLambda)
```

`Dumper/OffsetFinder.h`:

```h
#pragma once

#include <vector>
#include "ObjectArray.h"

namespace OffsetFinder
{
	template<int Alignement = 4, typename T>
	inline int32_t FindOffset(std::vector<std::pair<void*, T>>& ObjectValuePair, int MinOffset = 0x28, int MaxOffset = 0x1A0)
	{
		int32_t HighestFoundOffset = MinOffset;

		for (int i = 0; i < ObjectValuePair.size(); i++)
		{
			uint8_t* BytePtr = (uint8_t*)(ObjectValuePair[i].first);

			for (int j = HighestFoundOffset; j < MaxOffset; j += Alignement)
			{
				if ((*(T*)(BytePtr + j)) == ObjectValuePair[i].second && j >= HighestFoundOffset)
				{
					if (j > HighestFoundOffset)
					{
						HighestFoundOffset = j;
						i = 0;
					}
					j = MaxOffset;
				}
			}
		}
		return HighestFoundOffset;
	}

	template<bool bCheckForVft = true>
	inline int32_t GetValidPointerOffset(uint8_t* ObjA, uint8_t* ObjB, int32_t StartingOffset, int32_t MaxOffset)
	{
		if (IsBadReadPtr(ObjA) || IsBadReadPtr(ObjB))
			return -1;

		for (int j = StartingOffset; j <= MaxOffset; j += 0x8)
		{
			const bool bIsAValid = !IsBadReadPtr(*reinterpret_cast<void**>(ObjA + j)) && (bCheckForVft ? !IsBadReadPtr(**reinterpret_cast<void***>(ObjA + j)) : true);
			const bool bIsBValid = !IsBadReadPtr(*reinterpret_cast<void**>(ObjB + j)) && (bCheckForVft ? !IsBadReadPtr(**reinterpret_cast<void***>(ObjB + j)) : true);

			if (bIsAValid && bIsBValid)
				return j;
		}

		return -1;
	};

	/* UObject */
	inline void InitUObjectOffsets()
	{
		uint8_t* ObjA = (uint8_t*)ObjectArray::GetByIndex(0x55).GetAddress();
		uint8_t* ObjB = (uint8_t*)ObjectArray::GetByIndex(0x123).GetAddress();

		auto GetIndexOffset = [&ObjA, &ObjB]() -> int32_t
		{
			std::vector<std::pair<void*, int32_t>> Infos;

			Infos.emplace_back(ObjectArray::GetByIndex(0x055).GetAddress(), 0x055);
			Infos.emplace_back(ObjectArray::GetByIndex(0x123).GetAddress(), 0x123);

			return FindOffset<4>(Infos, 0x0);
		};

		Off::UObject::Vft = 0x00;
		Off::UObject::Flags = sizeof(void*);
		Off::UObject::Index = GetIndexOffset();
		Off::UObject::Class = GetValidPointerOffset(ObjA, ObjB, Off::UObject::Index + sizeof(int), 0x40);
		Off::UObject::Name = Off::UObject::Class + sizeof(void*);
		Off::UObject::Outer = GetValidPointerOffset(ObjA, ObjB, Off::UObject::Name + 0x8, 0x40);

		// loop a few times in case we accidentally choose a UPackage (which doesn't have an Outer) to find Outer
		while (Off::UObject::Outer == -1)
		{
			ObjA = (uint8*)ObjectArray::GetByIndex(rand() % 0x400).GetAddress();
			ObjB = (uint8*)ObjectArray::GetByIndex(rand() % 0x400).GetAddress();

			Off::UObject::Outer = GetValidPointerOffset(ObjA, ObjB, Off::UObject::Name + 0x8, 0x40);
		}
	}

	inline void FixupHardcodedOffsets()
	{
		if (Settings::Internal::bUseCasePreservingName)
		{
			Off::FField::Flags += 0x8;

			Off::FFieldClass::Id += 0x08;
			Off::FFieldClass::CastFlags += 0x08;
			Off::FFieldClass::ClassFlags += 0x08;
			Off::FFieldClass::SuperClass += 0x08;
		}

		if (Settings::Internal::bUseFProperty)
		{
			/*
			* On versions below 5.1.1: class FFieldVariant { void*, bool } -> extends to { void*, bool, uint8[0x7] }
			* ON versions since 5.1.1: class FFieldVariant { void* }
			* 
			* Check: 
			* if FFieldVariant contains a bool, the memory at the bools offset will not be a valid pointer
			* if FFieldVariant doesn't contain a bool, the memory at the bools offset will be the next member of FField, the Next ptr [valid]
			*/

			void* PossibleNextPtrOrBool0 = *(void**)((uint8*)ObjectArray::FindClassFast("Actor").GetChildProperties().GetAddress() + 0x18);
			void* PossibleNextPtrOrBool1 = *(void**)((uint8*)ObjectArray::FindClassFast("ActorComponent").GetChildProperties().GetAddress() + 0x18);
			void* PossibleNextPtrOrBool2 = *(void**)((uint8*)ObjectArray::FindClassFast("Pawn").GetChildProperties().GetAddress() + 0x18);

			auto IsValidPtr = [](void* a) -> bool
			{
				return !IsBadReadPtr(a) && (uintptr_t(a) & 0x1) == 0; // realistically, there wont be any pointers to unaligned memory
			};

			if (IsValidPtr(PossibleNextPtrOrBool0) && IsValidPtr(PossibleNextPtrOrBool1) && IsValidPtr(PossibleNextPtrOrBool2))
			{
				std::cout << "Applaying fix to hardcoded offsets \n" << std::endl;

				Settings::Internal::bUseMaskForFieldOwner = true;

				Off::FField::Next -= 0x08;
				Off::FField::Name -= 0x08;
				Off::FField::Flags -= 0x08;
			}
		}
	}

	inline void InitFNameSettings()
	{
		UEObject FirstObject = ObjectArray::GetByIndex(0);
		
		const uint8* NameAddress = static_cast<const uint8*>(FirstObject.GetFName().GetAddress());

		const int32 FNameFirstInt /* ComparisonIndex */ =  *reinterpret_cast<const int32*>(NameAddress);
		const int32 FNameSecondInt /* [Number/DisplayIndex] */ = *reinterpret_cast<const int32*>(NameAddress + 0x4);

		const int32 FNameSize = Off::UObject::Outer - Off::UObject::Name;

		Off::FName::CompIdx = 0x0;
		Off::FName::Number = 0x4; // defaults for check

		 // FNames for which FName::Number == [1...4]
		auto GetNumNamesWithNumberOneToFour = []() -> int32
		{
			int32 NamesWithNumberOneToFour = 0x0;

			for (UEObject Obj : ObjectArray())
			{
				const int32 Number = Obj.GetFName().GetNumber();

				if (Number > 0x0 && Number < 0x5)
					NamesWithNumberOneToFour++;
			}

			return NamesWithNumberOneToFour;
		};

		Off::FName::CompIdx = 0x0;

		if (FNameSize == 0x8 && FNameFirstInt == FNameSecondInt) /* WITH_CASE_PRESERVING_NAME + FNAME_OUTLINE_NUMBER*/
		{
			Settings::Internal::bUseCasePreservingName = true;
			Settings::Internal::bUseUoutlineNumberName = true;

			Off::FName::Number = -0x1;
			Off::InSDK::FNameSize = 0x8;
		}
		else if (FNameSize == 0x10) /* WITH_CASE_PRESERVING_NAME */
		{
			Settings::Internal::bUseCasePreservingName = true;

			Off::FName::Number = FNameFirstInt == FNameSecondInt ? 0x8 : 0x4;

			Off::InSDK::FNameSize = 0xC;
		}
		else if (GetNumNamesWithNumberOneToFour() < 0x3A) /* FNAME_OUTLINE_NUMBER*/
		{
			Settings::Internal::bUseUoutlineNumberName = true;

			Off::FName::Number = -0x1;

			Off::InSDK::FNameSize = 0x4;
		}
		else /* Default */
		{
			Off::FName::Number = 0x4;

			Off::InSDK::FNameSize = 0x8;
		}
	}

	/* UField */
	inline int32_t FindUFieldNextOffset()
	{
		uint8_t* KismetSystemLibraryChild = reinterpret_cast<uint8_t*>(ObjectArray::FindObjectFast<UEStruct>("KismetSystemLibrary").GetChild().GetAddress());
		uint8_t* KismetStringLibraryChild = reinterpret_cast<uint8_t*>(ObjectArray::FindObjectFast<UEStruct>("KismetStringLibrary").GetChild().GetAddress());
		
		return GetValidPointerOffset(KismetSystemLibraryChild, KismetStringLibraryChild, Off::UObject::Outer + 0x08, 0x48);
	}

	/* FField */
	inline int32_t FindFFieldNextOffset()
	{
		uint8_t* GuidChildren = reinterpret_cast<uint8_t*>(ObjectArray::FindObjectFast<UEStruct>("Guid").GetChildProperties().GetAddress());
		uint8_t* VectorChildren = reinterpret_cast<uint8_t*>(ObjectArray::FindObjectFast<UEStruct>("Vector").GetChildProperties().GetAddress());

		return GetValidPointerOffset(GuidChildren, VectorChildren, Off::FField::Owner + 0x8, 0x48);
	}

	inline int32_t FindFFieldNameOffset()
	{
		UEFField GuidChild = ObjectArray::FindObjectFast<UEStruct>("Guid").GetChildProperties();
		UEFField VectorChild = ObjectArray::FindObjectFast<UEStruct>("Vector").GetChildProperties();

		std::string GuidChildName = GuidChild.GetName();
		std::string VectorChildName = VectorChild.GetName();

		if ((GuidChildName == "A" || GuidChildName == "D") && (VectorChildName == "X" || VectorChildName == "Z"))
			return Off::FField::Name;

		for (Off::FField::Name = Off::FField::Owner; Off::FField::Name < 0x40; Off::FField::Name += 4)
		{
			GuidChildName = GuidChild.GetName();
			VectorChildName = VectorChild.GetName();
			
			if ((GuidChildName == "A" || GuidChildName == "D") && (VectorChildName == "X" || VectorChildName == "Z"))
				return Off::FField::Name;
		}
	}

	/* UEnum */
	inline int32_t FindEnumNamesOffset()
	{
		std::vector<std::pair<void*, int32_t>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("ENetRole").GetAddress(), 0x5 });			
		Infos.push_back({ ObjectArray::FindObjectFast("ETraceTypeQuery").GetAddress(), 0x22 }); 

		int Ret = FindOffset(Infos) - 0x8;

		struct Name08Byte { uint8 Pad[0x08]; };
		struct Name16Byte { uint8 Pad[0x10]; };

		uint8* ArrayAddress = static_cast<uint8*>(Infos[0].first) + Ret;

		if (Settings::Internal::bUseCasePreservingName)
		{
			TArray<TPair<Name16Byte, int64>>& ArrayOfNameValuePairs = *reinterpret_cast<TArray<TPair<Name16Byte, int64>>*>(ArrayAddress);

			if (ArrayOfNameValuePairs[1].Second != 1)
				Settings::Internal::bIsEnumNameOnly = true;

			
		}
		else
		{
			if (reinterpret_cast<TArray<TPair<Name08Byte, int64>>*>(static_cast<uint8*>(Infos[0].first) + Ret)->operator[](1).Second != 1)
				Settings::Internal::bIsEnumNameOnly = true;
		}

		return Ret;
	}

	/* UStruct */
	inline int32_t FindSuperOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("Struct").GetAddress(), ObjectArray::FindObjectFast("Field").GetAddress() });
		Infos.push_back({ ObjectArray::FindObjectFast("Class").GetAddress(), ObjectArray::FindObjectFast("Struct").GetAddress() });
		
		// Thanks to the ue4 dev who decided UStruct should be spelled Ustruct
		if (Infos[0].first == nullptr)
			Infos[0].first = Infos[1].second = ObjectArray::FindObjectFast("struct").GetAddress();

		return FindOffset(Infos);
	}

	inline int32_t FindChildOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("PlayerController").GetAddress(), ObjectArray::FindObjectFastInOuter("WasInputKeyJustReleased", "PlayerController").GetAddress() });
		Infos.push_back({ ObjectArray::FindObjectFast("Controller").GetAddress(), ObjectArray::FindObjectFastInOuter("UnPossess", "Controller").GetAddress() });

		if (FindOffset(Infos) == 0x28)
		{
			Infos.clear();

			Infos.push_back({ ObjectArray::FindObjectFast("Vector").GetAddress(), ObjectArray::FindObjectFastInOuter("X", "Vector").GetAddress() });
			Infos.push_back({ ObjectArray::FindObjectFast("Vector4").GetAddress(), ObjectArray::FindObjectFastInOuter("X", "Vector4").GetAddress() });
			Infos.push_back({ ObjectArray::FindObjectFast("Vector2D").GetAddress(), ObjectArray::FindObjectFastInOuter("X", "Vector2D").GetAddress() });
			Infos.push_back({ ObjectArray::FindObjectFast("Guid").GetAddress(), ObjectArray::FindObjectFastInOuter("A","Guid").GetAddress() });

			return FindOffset(Infos);
		}

		Settings::Internal::bUseFProperty = true;

		return FindOffset(Infos);
	}

	inline int32_t FindChildPropertiesOffset()
	{
		uint8* ObjA = (uint8*)ObjectArray::FindObjectFast("Color").GetAddress();
		uint8* ObjB = (uint8*)ObjectArray::FindObjectFast("Guid").GetAddress();

		return GetValidPointerOffset(ObjA, ObjB, Off::UStruct::Children + 0x08, 0x80);
	}

	inline int32_t FindStructSizeOffset()
	{
		std::vector<std::pair<void*, int32_t>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("Color").GetAddress(), 0x04 });
		Infos.push_back({ ObjectArray::FindObjectFast("Guid").GetAddress(), 0x10 });

		return FindOffset(Infos);
	}

	/* UFunction */
	inline int32_t FindFunctionFlagsOffset()
	{
		std::vector<std::pair<void*, EFunctionFlags>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("WasInputKeyJustPressed").GetAddress(), EFunctionFlags::Final | EFunctionFlags::Native | EFunctionFlags::Public | EFunctionFlags::BlueprintCallable | EFunctionFlags::BlueprintPure | EFunctionFlags::Const });
		Infos.push_back({ ObjectArray::FindObjectFast("ToggleSpeaking").GetAddress(), EFunctionFlags::Exec | EFunctionFlags::Native | EFunctionFlags::Public });
		Infos.push_back({ ObjectArray::FindObjectFast("SwitchLevel").GetAddress(), EFunctionFlags::Exec | EFunctionFlags::Native | EFunctionFlags::Public });

		int32 Ret = FindOffset(Infos);

		if (Ret == 0x28)
		{
			for (auto& [_, Flags] : Infos)
				Flags = Flags | EFunctionFlags::RequiredAPI;
		}

		return FindOffset(Infos);
	}

	inline int32_t FindFunctionNativeFuncOffset()
	{
		std::vector<std::pair<void*, EFunctionFlags>> Infos;

		uintptr_t WasInputKeyJustPressed = reinterpret_cast<uintptr_t>(ObjectArray::FindObjectFast("WasInputKeyJustPressed").GetAddress());
		uintptr_t ToggleSpeaking = reinterpret_cast<uintptr_t>(ObjectArray::FindObjectFast("ToggleSpeaking").GetAddress());
		uintptr_t SwitchLevel = reinterpret_cast<uintptr_t>(ObjectArray::FindObjectFast("SwitchLevel").GetAddress());

		for (int i = 0x40; i < 0x140; i += 8)
		{
			if (IsInProcessRange(*reinterpret_cast<uintptr_t*>(WasInputKeyJustPressed + i)) && IsInProcessRange(*reinterpret_cast<uintptr_t*>(ToggleSpeaking + i)) && IsInProcessRange(*reinterpret_cast<uintptr_t*>(SwitchLevel + i)))
				return i;
		}

		return 0x0;
	}

	inline int32_t FindNumParamsOffset()
	{
		std::vector<std::pair<void*, uint8_t>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("SwitchLevel").GetAddress(), 0x1 });
		Infos.push_back({ ObjectArray::FindObjectFast("SetViewTargetWithBlend").GetAddress(), 0x5 });
		Infos.push_back({ ObjectArray::FindObjectFast("SetHapticsByValue").GetAddress(), 0x3 });
		Infos.push_back({ ObjectArray::FindObjectFast("SphereTraceSingleForObjects").GetAddress(), 0xE });

		return FindOffset<1>(Infos);
	}

	inline int32_t FindParamSizeOffset()
	{
		std::vector<std::pair<void*, uint16_t>> Infos;

		// TODO (encryqed) : Fix it anyways somehow, for some reason its one byte off? Idk why i just add a byte manually
		Infos.push_back({ ObjectArray::FindObjectFast("SwitchLevel").GetAddress(), 0x10 });
		Infos.push_back({ ObjectArray::FindObjectFast("SetViewTargetWithBlend").GetAddress(), 0x15 });
		Infos.push_back({ ObjectArray::FindObjectFast("SetHapticsByValue").GetAddress(), 0x9 });
		Infos.push_back({ ObjectArray::FindObjectFast("SphereTraceSingleForObjects").GetAddress(), 0x109 });

		int ParamSizeOffset = FindOffset<1>(Infos);

		if (Settings::Internal::bUseFProperty)
		{
			return ParamSizeOffset + 0x1;
		}

		return ParamSizeOffset;
	}

	/* UClass */
	inline int32_t FindCastFlagsOffset()
	{
		std::vector<std::pair<void*, EClassCastFlags>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("Actor").GetAddress(), EClassCastFlags::Actor });
		Infos.push_back({ ObjectArray::FindObjectFast("Class").GetAddress(), EClassCastFlags::Field | EClassCastFlags::Struct | EClassCastFlags::Class });
		
		return FindOffset(Infos);
	}

	inline int32_t FindDefaultObjectOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		Infos.push_back({ ObjectArray::FindObjectFast("Object").GetAddress(), ObjectArray::FindObjectFast("Default__Object").GetAddress() });
		Infos.push_back({ ObjectArray::FindObjectFast("Field").GetAddress(), ObjectArray::FindObjectFast("Default__Field").GetAddress() });

		return FindOffset(Infos);
	}

	/* UProperty */
	inline int32_t FindElementSizeOffset()
	{
		std::vector<std::pair<void*, int32_t>> Infos;

		UEStruct Guid = ObjectArray::FindObjectFast("Guid", EClassCastFlags::Struct).Cast<UEStruct>();

		Infos.push_back({ Guid.FindMember("A").GetAddress(), 0x04 });
		Infos.push_back({ Guid.FindMember("B").GetAddress(), 0x04 });
		Infos.push_back({ Guid.FindMember("C").GetAddress(), 0x04 });

		return FindOffset(Infos);
	}

	inline int32_t FindArrayDimOffset()
	{
		std::vector<std::pair<void*, int32_t>> Infos;

		UEStruct Guid = ObjectArray::FindObjectFast("Guid", EClassCastFlags::Struct).Cast<UEStruct>();

		Infos.push_back({ Guid.FindMember("A").GetAddress(), 0x01 });
		Infos.push_back({ Guid.FindMember("B").GetAddress(), 0x01 });
		Infos.push_back({ Guid.FindMember("C").GetAddress(), 0x01 });

		const int32_t MinOffset = Off::UProperty::ElementSize - 0x10;
		const int32_t MaxOffset = Off::UProperty::ElementSize + 0x10;

		return FindOffset(Infos, MinOffset, MaxOffset);
	}

	inline int32_t FindPropertyFlagsOffset()
	{
		std::vector<std::pair<void*, EPropertyFlags>> Infos;

		Infos.push_back({ ObjectArray::FindClassFast("Actor").FindMember("bActorEnableCollision").GetAddress(), EPropertyFlags::NoDestructor | EPropertyFlags::HasGetValueTypeHash | EPropertyFlags::NativeAccessSpecifierPrivate });
		Infos.push_back({ ObjectArray::FindClassFast("PlayerController").FindMember("HiddenActors").GetAddress(), EPropertyFlags::ZeroConstructor | EPropertyFlags::NativeAccessSpecifierPublic });

		int FlagsOffset = FindOffset(Infos);

		// Same flags without AccessSpecifier or Hashing flags
		if (FlagsOffset == 0x28)
		{
			Infos[1].second = EPropertyFlags::ZeroConstructor;
			Infos[0].second = EPropertyFlags::NoDestructor;

			FlagsOffset = FindOffset(Infos);
		}

		return FlagsOffset;
	}

	inline int32_t FindOffsetInternalOffset()
	{
		std::vector<std::pair<void*, int32_t>> Infos;

		UEStruct Color = ObjectArray::FindObjectFast("Color", EClassCastFlags::Struct).Cast<UEStruct>();

		Infos.push_back({ Color.FindMember("B").GetAddress(), 0x00 });
		Infos.push_back({ Color.FindMember("G").GetAddress(), 0x01 });
		Infos.push_back({ Color.FindMember("R").GetAddress(), 0x02 });

		return FindOffset(Infos);
	}

	/* UByteProperty */
	inline int32_t FindEnumOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		void* ENetRoleObject = ObjectArray::FindObjectFast("ENetRole").GetAddress();
		UEStruct Actor = ObjectArray::FindClassFast("Actor");

		Infos.push_back({Actor.FindMember("RemoteRole").GetAddress(), ENetRoleObject });
		Infos.push_back({Actor.FindMember("Role").GetAddress(), ENetRoleObject });

		return FindOffset(Infos);
	}

	/* UBoolProperty */
	inline int32_t FindBoolPropertyBaseOffset()
	{
		std::vector<std::pair<void*, uint8_t>> Infos;

		Infos.push_back({ ObjectArray::FindClassFast("Engine").FindMember("bIsOverridingSelectedColor").GetAddress(), 0xFF });
		Infos.push_back({ ObjectArray::FindClassFast("PlayerController").FindMember("bAutoManageActiveCameraTarget").GetAddress(), 0xFF });

		return (FindOffset<1>(Infos, Off::UProperty::Offset_Internal) - 0x3);
	}

	/* UObjectPropertyBase */
	inline int32_t FindPropertyClassOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		// TODO (encryqed) : Gonna fix it later 
		Infos.push_back({ ObjectArray::FindObjectFast("AuthorityGameMode").GetAddress(), ObjectArray::FindObjectFast("GameModeBase").GetAddress() });
		Infos.push_back({ ObjectArray::FindObjectFast("NetworkManager").GetAddress(), ObjectArray::FindObjectFast("GameNetworkManager").GetAddress() });
	
		return FindOffset(Infos);
	}

	/* UClassProperty */
	inline int32_t FindMetaClassOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		UEStruct GameModeBase = ObjectArray::FindObjectFast("GameModeBase", EClassCastFlags::Class).Cast<UEStruct>();

		Infos.push_back({ GameModeBase.FindMember("GameSessionClass").GetAddress(), ObjectArray::FindObjectFast("GameSession").GetAddress() });
		Infos.push_back({ GameModeBase.FindMember( "GameStateClass").GetAddress(), ObjectArray::FindObjectFast("GameStateBase").GetAddress() });

		return FindOffset(Infos);
	}
	
	/* UStructProperty */
	inline int32_t FindStructTypeOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		UEStruct Transform = ObjectArray::FindObjectFast("Transform", EClassCastFlags::Struct).Cast<UEStruct>();

		void* VectorStruct = ObjectArray::FindObjectFast("Vector").GetAddress();
		Infos.push_back({ Transform.FindMember("Scale3D").GetAddress(), VectorStruct });
		Infos.push_back({ Transform.FindMember("Translation").GetAddress(), VectorStruct });

		return FindOffset(Infos);
	}

	/* UArrayProperty */
	inline int32_t FindInnerTypeOffset(const int32 PropertySize)
	{
		if (!Settings::Internal::bUseFProperty)
			return PropertySize;

		if (UEProperty Property = ObjectArray::FindClassFast("GameViewportClient").FindMember("DebugProperties", EClassCastFlags::ArrayProperty))
		{
			void* AddressToCheck = *reinterpret_cast<void**>(reinterpret_cast<uint8*>(Property.GetAddress()) + PropertySize);

			if (IsBadReadPtr(AddressToCheck))
				return PropertySize + 0x8;
		}

		return PropertySize;
	}

	/* USetProperty */
	inline int32_t FindSetPropertyBaseOffset(const int32 PropertySize)
	{
		if (!Settings::Internal::bUseFProperty)
			return PropertySize;

		if (auto Object = ObjectArray::FindObjectFast<UEStruct>("LevelCollection", EClassCastFlags::Struct).FindMember("Levels", EClassCastFlags::SetProperty))
		{
			void* AddressToCheck = *(void**)((uint8*)Object.GetAddress() + PropertySize);

			if (IsBadReadPtr(AddressToCheck))
				return PropertySize + 0x8;
		}

		return PropertySize;
	}

	/* UMapProperty */
	inline int32_t FindMapPropertyBaseOffset(const int32 PropertySize)
	{
		if (!Settings::Internal::bUseFProperty)
			return PropertySize;

		if (auto Object = ObjectArray::FindClassFast("UserDefinedEnum").FindMember("DisplayNameMap", EClassCastFlags::MapProperty))
		{
			void* AddressToCheck = *(void**)((uint8*)Object.GetAddress() + PropertySize);

			if (IsBadReadPtr(AddressToCheck))
				return PropertySize + 0x8;
		}

		return PropertySize;
	}

	/* UEnumProperty */
	inline int32_t FindEnumPropertyBaseOffset()
	{
		std::vector<std::pair<void*, void*>> Infos;

		// TODO (encryqed) : Gonna fix it later 
		Infos.push_back({ ObjectArray::FindObjectFast("RuntimeGeneration").GetAddress(), ObjectArray::FindObjectFastInOuter("UnderlyingType", "RuntimeGeneration").GetAddress()});
		Infos.push_back({ ObjectArray::FindObjectFast("AutoPossessAI").GetAddress(), ObjectArray::FindObjectFastInOuter("UnderlyingType", "AutoPossessAI").GetAddress()});

		return FindOffset(Infos);
	}
}

```

`Dumper/Offsets.cpp`:

```cpp
#include "Offsets.h"
#include "ObjectArray.h"
#include "OffsetFinder.h"

#include "NameArray.h"

void Off::InSDK::InitPE()
{
	void** Vft = *(void***)ObjectArray::GetByIndex(0).GetAddress();

	auto Resolve32BitRelativeJump = [](void* FunctionPtr) -> uint8_t*
	{
		uint8_t* Address = reinterpret_cast<uint8_t*>(FunctionPtr);
		if (*Address == 0xE9)
		{
			uint8_t* Ret = ((Address + 5) + *reinterpret_cast<int32_t*>(Address + 1));

			if (IsInProcessRange(uintptr_t(Ret)))
				return Ret;
		}

		return reinterpret_cast<uint8_t*>(FunctionPtr);
	};

	for (int i = 0; i < 0x150; i++)
	{
		if (!Vft[i] || !IsInProcessRange(reinterpret_cast<uintptr_t>(Vft[i])))
			break;

		if (FindPatternInRange({ 0xF7, -0x1, Off::UFunction::FunctionFlags, 0x0, 0x0, 0x0, 0x0, 0x04, 0x0, 0x0 }, Resolve32BitRelativeJump(Vft[i]), 0x400)
		&&  FindPatternInRange({ 0xF7, -0x1, Off::UFunction::FunctionFlags, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0 }, Resolve32BitRelativeJump(Vft[i]), 0x400))
		{
			Off::InSDK::PEIndex = i;
			Off::InSDK::PEOffset = GetOffset(Vft[i]);

			std::cout << "PE-Offset: 0x" << std::hex << Off::InSDK::PEOffset << "\n";
			std::cout << "PE-Index: 0x" << std::hex << i << "\n\n";
			return;
		}
	}

	void* PeAddr = (void*)FindByWStringInAllSections(L"Accessed None").FindNextFunctionStart();

	for (int i = 0; i < 0x150; i++)
	{
		if (!PeAddr)
			break;

		if (Resolve32BitRelativeJump(Vft[i]) == PeAddr)
		{
			Off::InSDK::PEIndex = i;
			Off::InSDK::PEOffset = GetOffset(PeAddr);

			std::cout << "PE-Offset: 0x" << std::hex << Off::InSDK::PEOffset << "\n";
			std::cout << "PE-Index: 0x" << std::hex << i << "\n\n";
			return;
		}
	}

	// If PE wasn't found by string ref, use a sig (or two)
}

void Off::InSDK::InitPE(int32 Index)
{
	Off::InSDK::PEIndex = Index;

	void** VFT = *reinterpret_cast<void***>(ObjectArray::GetByIndex(0).GetAddress());

	uintptr_t Imagebase = GetImageBase();

	Off::InSDK::PEOffset = uintptr_t(VFT[Off::InSDK::PEIndex]) - Imagebase;

	std::cout << "VFT-Offset: 0x" << std::hex << uintptr_t(VFT) - Imagebase << std::endl;
}

void Off::Init()
{
	OffsetFinder::InitUObjectOffsets();

	OffsetFinder::InitFNameSettings();

	::NameArray::PostInit();

	Off::UStruct::Children = OffsetFinder::FindChildOffset();
	std::cout << "Off::UStruct::Children: " << Off::UStruct::Children << "\n";

	Off::UField::Next = OffsetFinder::FindUFieldNextOffset();
	std::cout << "Off::UField::Next: " << Off::UField::Next << "\n";

	Off::UStruct::SuperStruct = OffsetFinder::FindSuperOffset();
	std::cout << "Off::UStruct::SuperStruct: " << Off::UStruct::SuperStruct << "\n";

	Off::UStruct::Size = OffsetFinder::FindStructSizeOffset();
	std::cout << "Off::UStruct::Size: " << Off::UStruct::Size << "\n";

	Off::UClass::CastFlags = OffsetFinder::FindCastFlagsOffset();
	std::cout << "Off::UClass::CastFlags: " << Off::UClass::CastFlags << "\n";

	if (Settings::Internal::bUseFProperty)
	{
		std::cout << "Game uses FProperty system\n\n";

		Off::UStruct::ChildProperties = OffsetFinder::FindChildPropertiesOffset();
		std::cout << "Off::UStruct::ChildProperties: " << Off::UStruct::ChildProperties << "\n";

		OffsetFinder::FixupHardcodedOffsets(); // must be called after FindChildPropertiesOffset 

		Off::FField::Next = OffsetFinder::FindFFieldNextOffset();
		std::cout << "Off::FField::Next: " << Off::FField::Next << "\n";
		
		Off::FField::Name = OffsetFinder::FindFFieldNameOffset();
		std::cout << "Off::FField::Name: " << Off::FField::Name << "\n";
	}

	Off::UClass::ClassDefaultObject = OffsetFinder::FindDefaultObjectOffset();
	std::cout << "Off::UClass::ClassDefaultObject: " << Off::UClass::ClassDefaultObject << "\n";

	Off::UEnum::Names = OffsetFinder::FindEnumNamesOffset();
	std::cout << "Off::UEnum::Names: " << Off::UEnum::Names << "\n";

	Off::UFunction::FunctionFlags = OffsetFinder::FindFunctionFlagsOffset();
	std::cout << "Off::UFunction::FunctionFlags: " << Off::UFunction::FunctionFlags << "\n\n";

	Off::UFunction::ExecFunction = OffsetFinder::FindFunctionNativeFuncOffset();
	std::cout << "Off::UFunction::ExecFunction: " << Off::UFunction::ExecFunction << "\n\n";

	Off::UProperty::ElementSize = OffsetFinder::FindElementSizeOffset();
	std::cout << "Off::UProperty::ElementSize: " << Off::UProperty::ElementSize << "\n";

	Off::UProperty::ArrayDim = OffsetFinder::FindArrayDimOffset();
	std::cout << "Off::UProperty::ArrayDim: " << Off::UProperty::ArrayDim << "\n";

	Off::UProperty::Offset_Internal = OffsetFinder::FindOffsetInternalOffset();
	std::cout << "Off::UProperty::Offset_Internal: " << Off::UProperty::Offset_Internal << "\n";

	Off::UProperty::PropertyFlags = OffsetFinder::FindPropertyFlagsOffset();
	std::cout << "Off::UProperty::PropertyFlags: " << Off::UProperty::PropertyFlags << "\n";

	const int32 PropertySize = OffsetFinder::FindBoolPropertyBaseOffset();
	std::cout << "UPropertySize: " << PropertySize << "\n\n";

	Off::UArrayProperty::Inner = OffsetFinder::FindInnerTypeOffset(PropertySize);
	std::cout << "Off::UArrayProperty::Inner: " << Off::UArrayProperty::Inner << "\n";
	
	Off::USetProperty::ElementProp = OffsetFinder::FindSetPropertyBaseOffset(PropertySize);
	std::cout << "Off::USetProperty::ElementProp: " << Off::USetProperty::ElementProp << "\n";
	
	Off::UMapProperty::Base = OffsetFinder::FindMapPropertyBaseOffset(PropertySize);
	std::cout << "Off::UMapProperty::Base: " << Off::UMapProperty::Base << "\n\n";

	Off::UByteProperty::Enum = PropertySize;
	Off::UBoolProperty::Base = PropertySize;
	Off::UObjectProperty::PropertyClass = PropertySize;
	Off::UStructProperty::Struct = PropertySize;
	Off::UEnumProperty::Base = PropertySize;

	Off::UClassProperty::MetaClass = PropertySize + 0x8; //0x8 inheritance from UObjectProperty
}

```

`Dumper/Offsets.h`:

```h
#pragma once
#include "Enums.h"
#include "Settings.h"

namespace Off
{
	void Init();

	//Offsets not to be used during generation but inside of the generated SDK
	namespace InSDK
	{
		void InitPE();
		void InitPE(int32 Index);

		inline int32 PEIndex;
		inline int32 PEOffset;

		inline int32 GObjects;
		inline int32 ChunkSize;
		inline int32 FUObjectItemSize;
		inline int32 FUObjectItemInitialOffset;

		inline int32 AppendNameToString;
		inline int32 FNameSize;

		inline int32 GNames = 0x0;
		inline int32 FNamePoolBlockOffsetBits = 0x0;
		inline int32 FNameEntryStride = 0x0;
	}

	namespace FUObjectArray
	{
		inline int32 Ptr;
		inline int32 Num;
	}

	namespace NameArray
	{
		inline int32 ChunksStart;
		inline int32 MaxChunkIndex;
		inline int32 NumElements;
		inline int32 ByteCursor;
	}

	namespace FField
	{
		// Fixed for CasePreserving FNames by OffsetFinder::FixupHardcodedOffsets();
		inline int32 Vft = 0x00;
		inline int32 Class = 0x08;
		inline int32 Owner = 0x10;
		inline int32 Next = 0x20;
		inline int32 Name = 0x28;
		inline int32 Flags = 0x30;
	}

	namespace FFieldClass
	{
		// Fixed for CasePreserving FNames by OffsetFinder::FixupHardcodedOffsets();
		// Fixed for OutlineNumber FNames by OffsetFinder::FixFNameSize();
		inline int32 Name = 0x00;
		inline int32 Id = 0x08;
		inline int32 CastFlags = 0x10;
		inline int32 ClassFlags = 0x18;
		inline int32 SuperClass = 0x20;
	}

	namespace FName
	{
		// These values initialized by OffsetFinder::InitUObjectOffsets()
		inline int32 CompIdx = 0x0;
		inline int32 Number = 0x4;
	}

	namespace FNameEntry
	{
		// These values are initialized by FNameEntry::Init()
		namespace NameArray
		{
			inline int32 StringOffset;
			inline int32 IndexOffset;
		}

		// These values are initialized by FNameEntry::Init()
		namespace NamePool
		{
			inline int32 HeaderOffset;
			inline int32 StringOffset;
		}
	}

	namespace UObject
	{
		inline int32 Vft;
		inline int32 Flags;
		inline int32 Index;
		inline int32 Class;
		inline int32 Name;
		inline int32 Outer;
	}

	namespace UField
	{
		inline int32 Next;
	}
	namespace UEnum
	{
		inline int32 Names;
	}

	namespace UStruct
	{
		inline int32 SuperStruct;
		inline int32 Children;
		inline int32 ChildProperties;
		inline int32 Size;
	}

	namespace UFunction
	{
		inline int32 FunctionFlags;
		inline int32 ExecFunction;
	}

	namespace UClass
	{
		inline int32 CastFlags;
		inline int32 ClassDefaultObject;
	}

	namespace UProperty
	{
		inline int32 ArrayDim;
		inline int32 ElementSize;
		inline int32 PropertyFlags;
		inline int32 Offset_Internal;
	}

	namespace UByteProperty
	{
		inline int32 Enum;
	}

	namespace UBoolProperty
	{
		struct UBoolPropertyBase
		{
			uint8 FieldSize;
			uint8 ByteOffset;
			uint8 ByteMask;
			uint8 FieldMask;
		};

		inline int32 Base;
	}

	namespace UObjectProperty
	{
		inline int32 PropertyClass;
	}

	namespace UClassProperty
	{
		inline int32 MetaClass;
	}

	namespace UStructProperty
	{
		inline int32 Struct;
	}

	namespace UArrayProperty
	{
		inline int32 Inner;
	}

	namespace UMapProperty
	{
		struct UMapPropertyBase
		{
			class UProperty* KeyProperty;
			class UProperty* ValueProperty;
		};

		inline int32 Base;
	}

	namespace USetProperty
	{
		inline int32 ElementProp;
	}

	namespace UEnumProperty
	{
		struct UEnumPropertyBase
		{
			class UProperty* UnderlayingProperty;
			class UEnum* Enum;
		};

		inline int32 Base;
	}
}
```

`Dumper/Package.cpp`:

```cpp
#include <algorithm>

#include "Package.h"
#include "Settings.h"
#include "Generator.h"

std::ofstream Package::DebugAssertionStream;
PackageDependencyManager Package::PackageSorterClasses; // "PackageName_classes.hpp"
PackageDependencyManager Package::PackageSorterStructs; // "PackageName_structs.hpp"
PackageDependencyManager Package::PackageSorterParams; // "PackageName_parameters.hpp"

void PackageDependencyManager::GenerateClassSorted(class Package& Pack, int32 ClassIdx)
{
	auto& [bIsIncluded, Dependencies] = AllDependencies[ClassIdx];

	if (!bIsIncluded)
	{
		bIsIncluded = true;

		for (auto& Dependency : Dependencies)
		{
			GenerateClassSorted(Pack, Dependency);
		}

		Pack.GenerateClass(ObjectArray::GetByIndex<UEClass>(ClassIdx));
	}
}

void PackageDependencyManager::GenerateStructSorted(class Package& Pack, const int32 StructIdx)
{
	auto& [bIsIncluded, Dependencies] = AllDependencies[StructIdx];

	if (!bIsIncluded)
	{
		bIsIncluded = true;

		for (auto& Dependency : Dependencies)
		{
			GenerateStructSorted(Pack, Dependency);
		}

		Pack.GenerateStruct(ObjectArray::GetByIndex<UEStruct>(StructIdx));
	}
}

void PackageDependencyManager::GetIncludesForPackage(
	const int32 Index, 
	EIncludeFileType FileType, 
	std::string& OutRef, 
	bool bCommentOut, 
	PackageDependencyManager* AdditionalDependencies,
	EIncludeFileType AdditionalDepFileType
)
{
	auto& [bIsIncluded, Dependencies] = AllDependencies[Index];

	if (!bIsIncluded)
	{
		bIsIncluded = true;

		if (AdditionalDependencies)
			AdditionalDependencies->GetIncludesForPackage(Index, AdditionalDepFileType, OutRef, bCommentOut);
		
		for (auto& Dependency : Dependencies)
		{
			GetIncludesForPackage(Dependency, FileType, OutRef, bCommentOut, AdditionalDependencies, AdditionalDepFileType);
		}

		std::string PackageName = ObjectArray::GetByIndex(Index).GetName();

		switch (FileType)
		{
		case EIncludeFileType::Struct:	
			OutRef += std::format("\n{}#include \"SDK/{}{}_structs.hpp\"", (bCommentOut ? "//" : ""), (Settings::FilePrefix ? Settings::FilePrefix : ""), PackageName);
			break;
		case EIncludeFileType::Class:
			OutRef += std::format("\n{}#include \"SDK/{}{}_classes.hpp\"", (bCommentOut ? "//" : ""), (Settings::FilePrefix ? Settings::FilePrefix : ""), PackageName);
			break;
		case EIncludeFileType::Params:
			OutRef += std::format("\n{}#include \"SDK/{}{}_parameters.hpp\"", (bCommentOut ? "//" : ""), (Settings::FilePrefix ? Settings::FilePrefix : ""), PackageName);
			break;
		default:
			break;
		}
	}
}

void PackageDependencyManager::GetPropertyDependency(UEProperty Prop, std::unordered_set<int32>& Store)
{
	if (Prop.IsA(EClassCastFlags::StructProperty))
	{
		Store.insert(Prop.Cast<UEStructProperty>().GetUnderlayingStruct().GetIndex());
	}
	else if (Prop.IsA(EClassCastFlags::EnumProperty))
	{
		if (auto Enum = Prop.Cast<UEEnumProperty>().GetEnum())
			Store.insert(Enum.GetIndex());
	}
	else if (Prop.IsA(EClassCastFlags::ByteProperty))
	{
		if (UEObject Enum = Prop.Cast<UEByteProperty>().GetEnum())
		{
			Store.insert(Enum.GetIndex());
		}
	}
	else if (Prop.IsA(EClassCastFlags::ArrayProperty))
	{
		GetPropertyDependency(Prop.Cast<UEArrayProperty>().GetInnerProperty(), Store);
	}
	else if (Prop.IsA(EClassCastFlags::SetProperty))
	{
		GetPropertyDependency(Prop.Cast<UESetProperty>().GetElementProperty(), Store);
	}
	else if (Prop.IsA(EClassCastFlags::MapProperty))
	{
		GetPropertyDependency(Prop.Cast<UEMapProperty>().GetKeyProperty(), Store);
		GetPropertyDependency(Prop.Cast<UEMapProperty>().GetValueProperty(), Store);
	}
}

void PackageDependencyManager::GetFunctionDependency(UEFunction Func, std::unordered_set<int32>& Store)
{
	for (UEProperty Property : Func.GetProperties())
	{
		PackageDependencyManager::GetPropertyDependency(Property, Store);
	}
}

void Package::InitAssertionStream(const fs::path& GenPath)
{
	if constexpr (Settings::Debug::bGenerateAssertionFile)
	{
		DebugAssertionStream.open(GenPath / "Assertions.h");

		DebugAssertionStream << "#pragma once\n#include\"SDK.hpp\"\n\nusing namespace SDK;\n\n";
	}
}

void Package::CloseAssertionStream()
{
	if constexpr (Settings::Debug::bGenerateAssertionFile)
	{
		DebugAssertionStream.flush();
		DebugAssertionStream.close();
	}
}

int32 Package::GeneratePredefinedMembers(const std::string& ClassName, Types::Struct& Struct, int32 StructSize, int32 SuperSize)
{
	int PrevPropertyEnd = SuperSize;
	int PrevPropertySize = -1;

	auto Predef = Generator::PredefinedMembers.find(ClassName);
	if (Predef != Generator::PredefinedMembers.end())
	{
		Struct.SetCustomAlignment(0x1);

		bool bIsFirstMember = true;
		for (auto& Member : Predef->second)
		{
			if (Member.Offset > PrevPropertyEnd && PrevPropertySize != 0)
			{
				Struct.AddMember(GenerateBytePadding(PrevPropertyEnd, Member.Offset - PrevPropertyEnd, "Fixing Size After Last (Predefined) Property  [ Dumper-7 ]"));
			}

			Struct.AddMember(Types::Member(Member.Type, Member.Name, std::format("(0x{:02X}[0x{:02X}]) NOT AUTO-GENERATED PROPERTY", Member.Offset, Member.Size)));

			PrevPropertySize = Member.Size;
			PrevPropertyEnd = Member.Size > 0 ? Member.Offset + Member.Size : PrevPropertyEnd;
		}

		StructSize = max(StructSize, PrevPropertyEnd);

		if (StructSize > PrevPropertyEnd)
		{
			Struct.AddMember(GenerateBytePadding(PrevPropertyEnd, StructSize - PrevPropertyEnd, "Fixing Size Of Struct [ Dumper-7 ]"));
		}

		return StructSize;
	}

	return 0;
}

Types::Member Package::GenerateBytePadding(const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	static uint32 PadNum = 0;

	return Types::Member("uint8", std::format("Pad_{:X}[0x{:X}]", PadNum++, PadSize), Reason);
}

Types::Member Package::GenerateBitPadding(const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	static uint32 BitPadNum = 0;

	return Types::Member("uint8", std::format("BitPad_{:X} : {:X}", BitPadNum++, PadSize), std::move(Reason));
}

void Package::GatherDependencies(const std::vector<int32_t>& PackageMembers)
{
	for (int32_t Index : PackageMembers)
	{
		UEObject Object = ObjectArray::GetByIndex(Index);

		if (!Object)
			continue;

		std::unordered_set<int32> ObjectsToCheck;
		const bool bIsClass = Object.IsA(EClassCastFlags::Class);

		if (Object.IsA(EClassCastFlags::Struct) && !Object.IsA(EClassCastFlags::Function))
		{
			UEStruct Struct = Object.Cast<UEStruct>();

			if (UEStruct Super = Struct.GetSuper())
				ObjectsToCheck.insert(Super.GetIndex());

			for (UEProperty Property : Struct.GetProperties())
			{
				PackageDependencyManager::GetPropertyDependency(Property, ObjectsToCheck);
			}

			for (UEField Field = Struct.GetChild(); Field; Field = Field.GetNext())
			{
				if (Field.IsA(EClassCastFlags::Function))
				{
					PackageDependencyManager::GetFunctionDependency(UEFunction(Field.GetAddress()), ObjectsToCheck);
				}
			}
			for (auto& Idx : ObjectsToCheck)
			{
				UEObject Obj = ObjectArray::GetByIndex(Idx);
			
				UEObject Outermost = Obj.GetOutermost();

				const bool bDependencyIsClass = Obj.IsA(EClassCastFlags::Class);
				const bool bDependencyIsStruct = Obj.IsA(EClassCastFlags::Struct) && !bDependencyIsClass;

				if (PackageObject != Outermost)
				{
					auto& PackageSorter = bDependencyIsClass ? Package::PackageSorterClasses : Package::PackageSorterStructs;

					PackageSorter.AddDependency(PackageObject.GetIndex(), Outermost.GetIndex());
					Package::PackageSorterParams.AddDependency(PackageObject.GetIndex(), Outermost.GetIndex());

					continue;
				}
			
				if (bIsClass && bDependencyIsClass)
				{
					ClassSorter.AddDependency(Object.GetIndex(), Idx);
				}
				else if (!bIsClass && bDependencyIsStruct)
				{
					StructSorter.AddDependency(Object.GetIndex(), Idx);
				}
			}
		}
	}
}

void Package::AddPackage(int32 Idx)
{
	Package::PackageSorterClasses.AddPackage(Idx);
	Package::PackageSorterStructs.AddPackage(Idx);
}

void Package::Process(const std::vector<int32_t>& PackageMembers)
{
	//AddPackage(PackageObject.GetIndex());

	//GatherDependencies(PackageMembers);

	for (int32_t Index : PackageMembers)
	{
		UEObject Object = ObjectArray::GetByIndex(Index);

		if (!Object)
			continue;

		if (Object.IsA(EClassCastFlags::Enum))
		{
			GenerateEnum(Object.Cast<UEEnum>());
		}
		else if (Object.IsA(EClassCastFlags::Class))
		{
			ClassSorter.GenerateClassSorted(*this, Index);
		}
		else if (Object.IsA(EClassCastFlags::Struct) && !Object.IsA(EClassCastFlags::Function))
		{
			StructSorter.GenerateStructSorted(*this, Index);
		}
	}
}

void Package::StaticGenerateMembers(const std::vector<UEProperty>& MemberVector, UEStruct& Super, Types::Struct& Struct, int32 StructSize, int32 SuperSize)
{
	const bool bIsSuperFunction = Super.IsA(EClassCastFlags::Function);

	bool bLastPropertyWasBitField = false;

	int PrevPropertyEnd = SuperSize;
	int PrevBoolPropertyEnd = 0;
	int PrevBoolPropertyBit = 1;

	std::string SuperName = Super.GetCppName();

	if (MemberVector.size() == 0 && GeneratePredefinedMembers(SuperName, Struct, StructSize, SuperSize) != 0)
		return; // generated struct based on override, return now
		

	if constexpr (Settings::Debug::bGenerateAssertionFile)
	{
		if constexpr (!Settings::Debug::bLimitAssertionsToEngienPackage)
		{
			if (Super.GetOutermost() == EnginePackage)
			{
				if (!Super.IsA(EClassCastFlags::Function) && !MemberVector.empty())
				{
					Package::DebugAssertionStream << "\n//" << SuperName << "\n";
					Package::DebugAssertionStream << std::format("static_assert(sizeof({}) == 0x{:04X}, \"Class {} has wrong size!\");\n", SuperName, StructSize, SuperName);
				}
			}
		}
	}

	for (auto& Property : MemberVector)
	{
		std::string CppType = Property.GetCppType();
		std::string Name = Property.GetArrayDim() > 1 ? std::format("{}[0x{:X}]", Property.GetValidName(), Property.GetArrayDim()) : Property.GetValidName();

		const int Offset = Property.GetOffset();
		const int Size = (!Property.IsA(EClassCastFlags::StructProperty) ? Property.GetSize() : Property.Cast<UEStructProperty>().GetUnderlayingStruct().GetStructSize()) * Property.GetArrayDim();

		std::string Comment = std::format("0x{:X}(0x{:X})({})", Offset, Size, Property.StringifyFlags());

		if (Offset >= PrevPropertyEnd)
		{
			if (bLastPropertyWasBitField && PrevBoolPropertyBit != 9)
			{
				Struct.AddMember(GenerateBitPadding(Offset, 9 - PrevBoolPropertyBit, "Fixing Bit-Field Size  [ Dumper-7 ]"));
			}
			if (Offset > PrevPropertyEnd)
			{
				Struct.AddMember(GenerateBytePadding(PrevPropertyEnd, Offset - PrevPropertyEnd, "Fixing Size After Last Property  [ Dumper-7 ]"));
			}
		}

		if (Property.IsA(EClassCastFlags::BoolProperty) && !Property.Cast<UEBoolProperty>().IsNativeBool())
		{
			Name += " : 1";

			const uint8 BitIndex = Property.Cast<UEBoolProperty>().GetBitIndex();

			Comment = std::format("Mask: 0x{:X}, PropSize: 0x{:X}{}", Property.Cast<UEBoolProperty>().GetFieldMask(), Size, Comment);

			if (PrevBoolPropertyEnd < Offset)
				PrevBoolPropertyBit = 1;

			if (PrevBoolPropertyBit < BitIndex)
			{
				Struct.AddMember(GenerateBitPadding(Offset, BitIndex - PrevBoolPropertyBit, "Fixing Bit-Field Size  [ Dumper-7 ]"));
			}

			PrevBoolPropertyBit = BitIndex + 1;
			PrevBoolPropertyEnd = Offset;

			bLastPropertyWasBitField = true;
		}
		else
		{
			bLastPropertyWasBitField = false;
		}

		Types::Member Member(CppType, Name, Comment);

		PrevPropertyEnd = Offset + Size;

		Struct.AddMember(Member);

		if constexpr (Settings::Debug::bGenerateAssertionFile)
		{
			bool bWriteAssertion = true;

			if constexpr (Settings::Debug::bLimitAssertionsToEngienPackage)
				bWriteAssertion = Super.GetOutermost() == EnginePackage;

			if (bWriteAssertion)
			{
				if (!Super.IsA(EClassCastFlags::Function) && PrevBoolPropertyEnd != Offset)
				{
					size_t SpacePos = Name.find(' ');
					size_t BracePos = Name.find('[');

					Name = Name.substr(0, SpacePos != std::string::npos ? SpacePos : BracePos != std::string::npos ? BracePos : Name.length());

					Package::DebugAssertionStream << std::format("static_assert(offsetof({}, {}) == 0x{:04X}, \"Wrong offset on {}::{}!\");\n", SuperName, Name, Offset, SuperName, Name);
				}
			}
		}
	}

	if (StructSize > PrevPropertyEnd)
	{
		Struct.AddMember(GenerateBytePadding(PrevPropertyEnd, StructSize - PrevPropertyEnd, "Fixing Size Of Struct [ Dumper-7 ]"));
	}
}

Types::Function Package::StaticGenerateFunction(UEFunction& Function, UEStruct& Super)
{
	static int NumUnnamedFunctions = 0;

	std::string ReturnType = "void";
	std::vector<Types::Parameter> Params;
	std::string FuncBody;

	std::string FunctionName = Function.GetValidName();

	if (FunctionName.empty())
		FunctionName = std::format("UnknownFunction_{:04X}", NumUnnamedFunctions++);

	std::vector<std::pair<std::string, bool>> OutPtrParamNames;

	bool bHasRetType = false;
	bool bHasParams = false;

	for (UEProperty Param : Function.GetProperties())
	{
		bHasParams = true;

		bool bIsRef = false;
		bool bIsOut = false;
		bool bIsMoveType = Param.IsA(EClassCastFlags::StructProperty) || Param.IsA(EClassCastFlags::ArrayProperty) || Param.IsA(EClassCastFlags::StrProperty);
		bool bIsRet = Param.HasPropertyFlags(EPropertyFlags::ReturnParm);

		std::string Type = Param.GetCppType();

		if (!bIsRet && Param.HasPropertyFlags(EPropertyFlags::ReferenceParm))
		{
			Type += "&";
			bIsRef = true;
			bIsOut = true;
		}

		if (!bIsRet && !bIsRef && Param.HasPropertyFlags(EPropertyFlags::OutParm))
		{
			Type += "*";
			bIsOut = true;
			OutPtrParamNames.push_back({ Param.GetValidName(), bIsMoveType });
		}

		if (!bIsRet && !bIsOut && !bIsRef && bIsMoveType)
		{
			Type += "&";

			Type = "const " + Type;
		}

		if (bIsRet)
		{
			ReturnType = Type;
			bHasRetType = true;
		}
		else
		{
			Params.push_back(Types::Parameter(Type, Param.GetValidName(), bIsOut && !bIsRef));
		}
	}

	Types::Function Func(ReturnType, FunctionName, Super.GetCppName(), Params);

	Func.AddComment(Function.GetFullName());
	Func.AddComment("(" + Function.StringifyFlags() + ")");
	Func.AddComment("Parameters:");

	for (UEProperty Param : Function.GetProperties())
	{
		Func.AddComment(std::format("{:{}}{:{}}({})", Param.GetCppType(), 35, Param.GetValidName(), 65, Param.StringifyFlags()));
	}

	FuncBody += "\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n";

	if (Settings::XORString)
	{
		FuncBody += std::format("\t\tFunc = Class->GetFunction({0}(\"{1}\"), {0}(\"{2}\"));\n\n", Settings::XORString, Super.GetName(), Function.GetName());
	}
	else
	{
		FuncBody += std::format("\t\tFunc = Class->GetFunction(\"{}\", \"{}\");\n\n", Super.GetName(), Function.GetName());
	}

	if (bHasParams)
		FuncBody += std::format("\t{}{} Parms{{}};\n", (Settings::ParamNamespaceName ? Settings::ParamNamespaceName + std::string("::") : ""), Function.GetParamStructName());

	for (auto& Param : Func.GetParameters())
	{
		if (!Param.IsParamOutPtr())
			FuncBody += std::format("\n\tParms.{0} = {0};", Param.GetName());
	}

	if (Function.HasFlags(EFunctionFlags::Native))
		FuncBody += "\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;";

	FuncBody += bHasParams ? "\n\n\tUObject::ProcessEvent(Func, &Parms);\n" : "\n\n\tUObject::ProcessEvent(Func, nullptr);\n";

	if (Function.HasFlags(EFunctionFlags::Native))
		FuncBody += "\n\n\tFunc->FunctionFlags = Flgs;\n";


	for (auto& [Name, bMove] : OutPtrParamNames)
	{
		FuncBody += std::format("\n\tif ({0} != nullptr)\n\t\t*{0} = {1}Parms.{0}{2};\n", Name, bMove ? "std::move(" : "", bMove ? ")" : "");
	}

	if (bHasRetType)
		FuncBody += "\n\treturn Parms.ReturnValue;\n";

	Func.AddBody(FuncBody);

	if (bHasParams)
		Func.SetParamStruct(StaticGenerateStruct(Function, true));

	return Func;
}

Types::Struct Package::StaticGenerateStruct(UEStruct Struct, bool bIsFunction)
{
	std::string StructName = !bIsFunction ? Struct.GetCppName() : Struct.Cast<UEFunction>().GetParamStructName();

	Types::Struct RetStruct(StructName);

	int Size = Struct.GetStructSize();
	int SuperSize = 0;

	auto It = UEStruct::StructSizes.find(Struct.GetIndex());

	if (It != UEStruct::StructSizes.end())
		Size = It->second;

	if (!bIsFunction)
	{
		if (UEStruct Super = Struct.GetSuper())
		{
			RetStruct = Types::Struct(StructName, false, Super.GetCppName());
			SuperSize = Super.GetStructSize();

			UEObject SuperPackage = Super.GetOutermost();

			auto It = UEStruct::StructSizes.find(Super.GetIndex());

			if (It != UEStruct::StructSizes.end())
				SuperSize = It->second;
		}
	}

	RetStruct.AddComment(std::format("0x{:X} (0x{:X} - 0x{:X})", Size - SuperSize, Size, SuperSize));
	RetStruct.AddComment(Struct.GetFullName());

	std::vector<UEProperty> Properties = Struct.GetProperties();

	static int NumProps = 0;
	static int NumFuncs = 0;

	std::sort(Properties.begin(), Properties.end(), [](UEProperty Left, UEProperty Right) -> bool
		{
			if (Left.IsA(EClassCastFlags::BoolProperty) && Right.IsA(EClassCastFlags::BoolProperty))
			{
				if (Left.GetOffset() == Right.GetOffset())
				{
					return Left.Cast<UEBoolProperty>().GetFieldMask() < Right.Cast<UEBoolProperty>().GetFieldMask();
				}
			}

			return Left.GetOffset() < Right.GetOffset();
		});

	StaticGenerateMembers(Properties, Struct, RetStruct, Size, SuperSize);

	return RetStruct;
}

Types::Class Package::StaticGenerateClass(UEClass Class, std::vector<Types::Function>& PackageFunctions)
{
	std::string ClassName = Class.GetCppName();
	std::string RawName = Class.GetName();
	std::string FullName = Class.GetFullName();

	Types::Class RetClass(ClassName, RawName);

	int Size = Class.GetStructSize();
	int SuperSize = 0;

	auto It = UEStruct::StructSizes.find(Class.GetIndex());

	if (It != UEStruct::StructSizes.end())
		Size = It->second;

	if (UEStruct Super = Class.GetSuper())
	{
		RetClass = Types::Class(ClassName, RawName, Super.GetCppName());
		SuperSize = Super.GetStructSize();

		auto It = UEStruct::StructSizes.find(Super.GetIndex());

		if (It != UEStruct::StructSizes.end())
			SuperSize = It->second;
	}

	RetClass.AddComment(std::format("0x{:X} (0x{:X} - 0x{:X})", Size - SuperSize, Size, SuperSize));
	RetClass.AddComment(FullName);

		
	Types::Function StaticClass("class UClass*", "StaticClass", Class.GetCppName(), {}, true);

	StaticClass.AddComment(Class.GetFullName());
	StaticClass.AddComment("(" + Class.StringifyCastFlags() + ")");


	StaticClass.AddBody(
		std::format(
			R"(	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast({});

	return Clss;)", Settings::XORString ? std::format("{}(\"{}\")", Settings::XORString, RawName) : std::format("\"{}\"", RawName)));


	Types::Function GetDefault("class " + ClassName + "*", "GetDefaultObj", ClassName, {}, true, true);

	GetDefault.AddComment(Class.GetDefaultObject().GetFullName());
	GetDefault.AddComment("(" + Class.GetDefaultObject().StringifyObjFlags() + ")");

	GetDefault.AddBody(
		std::format(
			R"(	static class {0}* Default = nullptr;

	if (!Default)
		Default = static_cast<{0}*>({0}::StaticClass()->DefaultObject);

	return Default;)", ClassName));

	RetClass.AddFunction(StaticClass);
	RetClass.AddFunction(GetDefault);
	PackageFunctions.push_back(StaticClass);
	PackageFunctions.push_back(GetDefault);

	for (UEField Child = Class.GetChild(); Child; Child = Child.GetNext())
	{
		if (Child.IsA(EClassCastFlags::Function))
		{
			Types::Function Func = StaticGenerateFunction(Child.Cast<UEFunction&>(), Class);

			RetClass.AddFunction(Func);
			PackageFunctions.push_back(Func);
		}
	}

	std::vector<UEProperty> Properties = Class.GetProperties();

	std::sort(Properties.begin(), Properties.end(), [](UEProperty Left, UEProperty Right) -> bool
		{
			if (Left.IsA(EClassCastFlags::BoolProperty) && Right.IsA(EClassCastFlags::BoolProperty))
			{
				if (Left.GetOffset() == Right.GetOffset())
				{
					return Left.Cast<UEBoolProperty>().GetFieldMask() < Right.Cast<UEBoolProperty>().GetFieldMask();
				}
			}

			return Left.GetOffset() < Right.GetOffset();
		});

	UEObject PackageObj = Class.GetOutermost();
	StaticGenerateMembers(Properties, Class, RetClass, Size, SuperSize);

	return RetClass;
}

Types::Enum Package::StaticGenerateEnum(UEEnum Enum)
{
	std::string EnumName = Enum.GetEnumTypeAsStr();

	std::vector<TPair<FName, int64>> NameValue = Enum.GetNameValuePairs();

	Types::Enum Enm(EnumName, "uint8");

	if (UEEnum::BigEnums.find(Enum.GetIndex()) != UEEnum::BigEnums.end())
		Enm = Types::Enum(EnumName, UEEnum::BigEnums[Enum.GetIndex()]);

	for (int i = 0; i < NameValue.size(); i++)
	{
		std::string TooFullOfAName = NameValue[i].First.ToString();

		Enm.AddMember(MakeNameValid(TooFullOfAName.substr(TooFullOfAName.find_last_of("::") + 1)), NameValue[i].Second);
	}

	if (EnumName.find("PixelFormat") != -1)
		Enm.FixWindowsConstant("PF_MAX");

	if (EnumName.find("ERaMaterialName") != -1)
		Enm.FixWindowsConstant("TRANSPARENT");

	return Enm;
}

void Package::GenerateFunction(UEFunction& Function, UEStruct& Super)
{
	AllFunctions.push_back(StaticGenerateFunction(Function, Super));
}

void Package::GenerateStruct(UEStruct Struct, bool bIsFunction)
{
	AllStructs.push_back(StaticGenerateStruct(Struct, bIsFunction));
}

void Package::GenerateClass(UEClass Class)
{
	Types::Class RetClass = StaticGenerateClass(Class, AllFunctions);

	

	AllClasses.push_back(RetClass);
}

void Package::GenerateEnum(UEEnum Enum)
{
	AllEnums.push_back(StaticGenerateEnum(Enum));
}

```

`Dumper/Package.h`:

```h
#pragma once

#include <unordered_set>
#include <filesystem>

#include "Types.h"
#include "ObjectArray.h"

namespace fs = std::filesystem;

enum class EIncludeFileType
{
	Struct,
	Class,
	Params,

	None
};

struct PackageDependencyManager
{
	friend class Package;

	//int32 = PackageIdx
	//pair<bool, set<int32>> = pair<bIsIncluded, set<DependencyIndices>>
	std::unordered_map<int32, std::pair<bool, std::unordered_set<int32>>> AllDependencies;

	PackageDependencyManager() = default;

	PackageDependencyManager(int32 PackageIdx)
	{
		if (AllDependencies.find(PackageIdx) == AllDependencies.end())
			AllDependencies[PackageIdx] = { { false }, { } };
	}

	void RemoveDependant(const int32 PackageIndex)
	{
		AllDependencies.erase(PackageIndex);
	}

	inline void AddPackage(const int32 PackageIdx)
	{
		if (AllDependencies.find(PackageIdx) == AllDependencies.end())
		{
			AllDependencies[PackageIdx] = { { false }, { } };
		}
	}

	inline void AddDependency(const int32 DepandantIdx, const int32 DependencyIndex)
	{
		AllDependencies[DepandantIdx].second.insert(DependencyIndex);
	}

	/* Only use this when sorting struct dependencies */
	void GenerateStructSorted(class Package& Pack, const int32 StructIdx);

	/* Only use this when sorting class dependencies */
	void GenerateClassSorted(class Package& Pack, const int32 ClassIdx);

	/* Only use this when sorting package dependencies */
	void GetIncludesForPackage(
		const int32 Index, 
		EIncludeFileType FileType, 
		std::string& OutRef, 
		bool bCommentOut = false, 
		PackageDependencyManager* AdditionalDependencies = nullptr,
		EIncludeFileType AdditionalDepFileType = EIncludeFileType::None
	);

	static void GetPropertyDependency(UEProperty Prop, std::unordered_set<int32>& Store);
	static void GetFunctionDependency(UEFunction Func, std::unordered_set<int32>& Store);
};

class Package
{
private:
	friend PackageDependencyManager;

public:
	static std::ofstream DebugAssertionStream;
	static PackageDependencyManager PackageSorterClasses; // "PackageName_classes.hpp"
	static PackageDependencyManager PackageSorterStructs; // "PackageName_structs.hpp"
	static PackageDependencyManager PackageSorterParams; // "PackageName_parameters.hpp"

private:
	inline static UEObject EnginePackage = nullptr;

private:
	PackageDependencyManager StructSorter;
	PackageDependencyManager ClassSorter;

private:
	UEObject PackageObject;

public:
	std::vector<Types::Enum> AllEnums;
	std::vector<Types::Struct> AllStructs;
	std::vector<Types::Class> AllClasses;
	std::vector<Types::Function> AllFunctions;

	Package(UEObject _Object)
		: PackageObject(_Object)
	{
		if constexpr (Settings::Debug::bGenerateAssertionFile && Settings::Debug::bLimitAssertionsToEngienPackage)
		{
			if (!EnginePackage)
				EnginePackage = ObjectArray::FindObjectFast("Engine", EClassCastFlags::Package);
		}
	}

	static void AddPackage(int32 Idx);
	static void InitAssertionStream(const fs::path& GenPath);
	static void CloseAssertionStream();
	static int32 GeneratePredefinedMembers(const std::string& ClassName, Types::Struct& Struct, int32 StructSize, int32 SuperSize);

	static Types::Member GenerateBytePadding(int32 Offset, int32 PadSize, std::string&& Reason);
	static Types::Member GenerateBitPadding(int32 Offset, int32 PadSize, std::string&& Reason);

	void GatherDependencies(const std::vector<int32_t>& PackageMembers);

	void Process(const std::vector<int32_t>& PackageMembers);

	static void StaticGenerateMembers(const std::vector<UEProperty>& MemberVector, UEStruct& Super, Types::Struct& Struct, int32 StructSize, int32 SuperSize);
	static Types::Function StaticGenerateFunction(UEFunction& Function, UEStruct& Super);
	static Types::Struct StaticGenerateStruct(UEStruct Struct, bool bIsFunction = false);
	static Types::Class StaticGenerateClass(UEClass Class, std::vector<Types::Function>& PackageFunctions);
	static Types::Enum StaticGenerateEnum(UEEnum Enum);

	void GenerateFunction(UEFunction& Function, UEStruct& Super);
	void GenerateStruct(UEStruct Struct, bool bIsFunction = false);
	void GenerateClass(UEClass Class);
	void GenerateEnum(UEEnum Enum);

	inline bool IsEmpty()
	{
		return AllEnums.empty() && AllClasses.empty() && AllStructs.empty() && AllFunctions.empty();
	}

	inline UEObject DebugGetObject()
	{
		return PackageObject;
	}
};

```

`Dumper/Settings.h`:

```h
#pragma once


namespace Settings
{
	//Auto generated if no override is provided
	inline std::string GameName = "";
	inline std::string GameVersion = "";


	inline constexpr const char* SDKGenerationPath = "C:/Dumper-7";


	//includes only packages required for the games main package (the package with the most structs/classes/enums)
	inline constexpr const bool bIncludeOnlyRelevantPackages = false;


	//No prefix for files -> FilePrefix = nullptr
	inline constexpr const char* FilePrefix = nullptr;

	//No seperate namespace for SDK -> SDKNamespaceName = nullptr
	inline constexpr const char* SDKNamespaceName = "SDK";

	//No seperate namespace for Params -> ParamNamespaceName = nullptr
	inline constexpr const char* ParamNamespaceName = "Params";

	//Do not XOR strings -> XORString = nullptr
	inline constexpr const char* XORString = nullptr;


	namespace Debug
	{
		inline constexpr bool bGenerateAssertionFile = false;
		inline constexpr bool bLimitAssertionsToEngienPackage = true;

		// Recommended
		inline constexpr bool bGenerateAssertionsForPredefinedMembers = true;
	}

	// Dont touch this
	namespace Internal
	{
		// UEEnum::Names
		inline bool bIsEnumNameOnly = false;

		inline bool bUseFProperty = false;

		inline bool bUseNamePool = false;

		inline bool bUseCasePreservingName = false;
		inline bool bUseUoutlineNumberName = false;

		inline bool bUseMaskForFieldOwner = false;

		inline std::string MainGamePackageName;
	}
}

```

`Dumper/Types.cpp`:

```cpp
#include "Types.h"
#include "Enums.h"
#include "Generator.h"

Types::Struct::Struct(std::string Name, bool bIsClass, std::string Super)
{
	StructMembers.reserve(50);

	CppName = Name;
	CustomAlignSize = 0;

	Declaration = (Super.empty() ? std::format("{} {}\n", (bIsClass ? "class" : "struct"), Name) : std::format("{} {} : public {}\n", (bIsClass ? "class" : "struct"), Name, Super));

	InnerBody = "{\npublic:\n";
}

void Types::Struct::AddComment(std::string Comment)
{
	Comments += "// " + Comment + "\n";
}

void Types::Struct::AddMember(Member& NewMember)
{
	StructMembers.push_back(NewMember);
}

void Types::Struct::AddMember(Member&& NewMember)
{
	StructMembers.emplace_back(std::move(NewMember));
}

void Types::Struct::AddMembers(std::vector<Member>& NewMembers)
{
	for (Member NewMember : NewMembers)
	{
		StructMembers.push_back(NewMember);
	}
}

std::string Types::Struct::GetGeneratedBody()
{
	if (CppName.empty())
		return "";

	for (Member StructMember : StructMembers)
	{
		InnerBody += StructMember.GetGeneratedBody();
	}

	if (Generator::PredefinedFunctions.find(CppName) != Generator::PredefinedFunctions.end())
	{
		for (auto& PredefFunc : Generator::PredefinedFunctions[CppName].second)
		{
			InnerBody += "\n" + PredefFunc.DeclarationH;
	
			if (PredefFunc.DeclarationCPP == "")
				InnerBody += PredefFunc.Body;
	
			InnerBody += "\n";
		}
	}

	std::string PackingStart = "";
	std::string PackingEnd = "";

	if (CustomAlignSize > 0)
	{
		PackingStart = std::format(R"(
#ifdef _MSC_VER
	#pragma pack(push, 0x{:X})
#endif
)", CustomAlignSize);

		PackingEnd = R"(
#ifdef _MSC_VER
	#pragma pack(pop)
#endif
)";
	}

	return PackingStart + Comments + Declaration + InnerBody + "};" + PackingEnd + "\n\n";
}

void Types::Class::AddFunction(Function& NewFunction)
{
	ClassFunctions.push_back(NewFunction);
}

void Types::Class::AddFunction(Function&& NewFunction)
{
	ClassFunctions.emplace_back(std::move(NewFunction));
}

std::string Types::Class::GetGeneratedBody()
{
	for (Member ClassMember : StructMembers)
	{
		InnerBody += ClassMember.GetGeneratedBody();
	}

	InnerBody += "\n";

	if (Generator::PredefinedFunctions.find(CppName) != Generator::PredefinedFunctions.end())
	{
		for (auto& PredefFunc : Generator::PredefinedFunctions[CppName].second)
		{
			InnerBody += "\n" + PredefFunc.DeclarationH;

			if (PredefFunc.DeclarationCPP == "")
				InnerBody += PredefFunc.Body;
			
			InnerBody += "\n";
		}
	}

	for (Function ClassFunction : ClassFunctions)
	{
		InnerBody += std::format("\t{}\n", ClassFunction.GetDeclaration());
	}

	return Comments + Declaration + InnerBody + "};\n\n";
}

Types::Includes::Includes(std::vector<std::pair<std::string, bool>> HeaderFiles)
{
	this->HeaderFiles = HeaderFiles;

	for (auto Pair : HeaderFiles)
	{
		if (Pair.second)
		{
			Declaration += std::format("#include <{}>\n", Pair.first);
		}
		else
		{
			Declaration += std::format("#include \"{}\"\n", Pair.first);
		}
	}
}

std::string Types::Includes::GetGeneratedBody()
{
	return Declaration + "\n";
}

Types::Member::Member(std::string Type, std::string Name, std::string Comment)
{
	this->Type = Type + (Name.empty() ? "" : " ");
	this->Name = Name;
	this->Comment = Comment != "" ? ("// " + Comment) : "";
}

void Types::Member::AddComment(std::string Comment)
{
	this->Comment = "// " + Comment;
}

std::string Types::Member::GetGeneratedBody()
{
	return std::format("\t{:{}}{:{}} {}\n", Type, 45, Name + ";", 50, Comment);
}

Types::Function::Function(std::string Type, std::string Name, std::string SuperName, std::vector<Parameter> Parameters, bool bIsStatic, bool bAddNewLine)
{
	this->Parameters = Parameters;

	std::string ParamStr = GetParametersAsString();

	DeclarationH = std::format("{}{} {}({});{}", (bIsStatic ? "static " : ""), Type, Name, ParamStr, (bAddNewLine ? "\n" : ""));
	DeclarationCPP = std::format("{} {}::{}({})", Type, SuperName, Name, ParamStr);

	Body = "{";
}

std::vector<Types::Parameter>& Types::Function::GetParameters()
{
	return Parameters;
}

std::string Types::Function::GetParametersAsString()
{
	if (Parameters.empty())
	{
		return std::string();
	}

	std::string Output;

	for (Parameter Param : Parameters)
	{
		Output += Param.GetGeneratedBody();
	}

	Output.resize(Output.size() - 2);

	return Output;
}

std::string Types::Function::GetDeclaration()
{
	 return DeclarationH;
}

void Types::Function::AddBody(std::string Body)
{
	this->Body = std::format("{{\n{}\n}}", Body);
}

void Types::Function::SetParamStruct(Types::Struct&& Params)
{
	ParamStruct = Params;
}

Types::Struct& Types::Function::GetParamStruct()
{
	return ParamStruct;
}

void Types::Function::AddComment(std::string& Comment)
{
	Comments += std::format("// {}\n", Comment);
}

void Types::Function::AddComment(std::string&& Comment)
{
	Comments += std::format("// {}\n", Comment);
}

std::string Types::Function::GetGeneratedBody()
{
	return std::format("\n{}\n{}\n{}\n\n", Comments, DeclarationCPP, Body);
}

Types::Parameter::Parameter(std::string Type, std::string Name, bool bIsOutPtr)
{
	this->bIsOutPtr = bIsOutPtr;
	this->Type = Type;
	this->Name = Name;
}

std::string Types::Parameter::GetName()
{
	return Name;
}

std::string Types::Parameter::GetGeneratedBody()
{
	return std::format("{} {}, ", Type, Name);
}

bool Types::Parameter::IsParamOutPtr()
{
	return bIsOutPtr;
}

Types::Enum::Enum(std::string Name)
{
	Declaration = std::format("{}\n", Name);
}

Types::Enum::Enum(std::string Name, std::string Type)
{
	Declaration = std::format("{} : {}\n", Name, Type);
}

void Types::Enum::AddComment(std::string&& Comment)
{
	Declaration = std::format("// {}\n{}", std::move(Comment), Declaration);
}

void Types::Enum::AddMember(std::string&& Name, int64 Value)
{
	EnumMembers.emplace_back(std::move(Name), Value);
}

void Types::Enum::FixWindowsConstant(std::string&& ConstantName)
{
	for (auto& EnumMember : EnumMembers)
	{
		if (EnumMember.first == ConstantName)
		{
			EnumMember.first += "_";
		}
	}
}

std::string Types::Enum::GetGeneratedBody()
{
	std::string Body = Declaration + "{\n";

	for (const auto& EnumMember : EnumMembers)
	{
		Body += std::format("\t{:{}} = {},\n", EnumMember.first, 30, EnumMember.second);
	}

	return Body + "};\n\n";
}

```

`Dumper/Types.h`:

```h
#pragma once
#include <iostream>
#include <format>
#include <fstream>
#include <vector>
#include <sstream>
#include "Enums.h"

namespace Types
{
	class Includes
	{
	private:
		std::string Declaration;
		std::vector<std::pair<std::string, bool>> HeaderFiles;

	public:
		Includes(std::vector<std::pair<std::string, bool>> HeaderFiles);

		std::string GetGeneratedBody();
	};

	class Enum
	{
	private:
		std::string Declaration;
		std::vector<std::pair<std::string, int64>> EnumMembers;

	public:
		Enum() = default;
		Enum(std::string Name);
		Enum(std::string Name, std::string Type);

		void AddComment(std::string&& Comment);
		void AddMember(std::string&& Name, int64 Value);
		void FixWindowsConstant(std::string&& ConstantName);

		std::string GetGeneratedBody();
	};

	class Member
	{
	private:
		std::string Type;
		std::string Name;
		std::string Comment = "";

	public:
		Member(std::string Type, std::string Name, std::string Comment = "");

		void AddComment(std::string Comment);

		std::string GetGeneratedBody();
	};

	class Parameter
	{
	private:
		bool bIsOutPtr;
		std::string Type;
		std::string Name;

	public:
		Parameter(std::string Type, std::string Name, bool bIsOutPtr = false);

		std::string GetName();
		std::string GetGeneratedBody();

		bool IsParamOutPtr();
	};


	class Struct
	{
	protected:
		std::string CppName;
		std::string Declaration;
		std::string InnerBody;
		std::string Comments;
		std::vector<Member> StructMembers;
		int32 CustomAlignSize;

	public:
		Struct() = default;
		Struct(std::string Name, bool bIsClass = false, std::string Super = "");

		void AddComment(std::string Comment);
		void AddMember(Member& NewMember);
		void AddMember(Member&& NewMember);
		void AddMembers(std::vector<Member>& NewMembers);

		void SetCustomAlignment(int32 AlignOverride)
		{
			CustomAlignSize = AlignOverride;
		}

		std::string GetGeneratedBody();

		inline bool IsEmpty()
		{
			return CppName.empty() && Declaration.empty();
		}
	};


	class Function
	{
	private:
		Struct ParamStruct;

		std::string Body;
		std::string DeclarationH;
		std::string DeclarationCPP;
		std::vector<Parameter> Parameters;
		std::string Comments;

	public:
		Function(std::string Type, std::string Name, std::string SuperName, std::vector<Parameter> Parameters = {}, bool bIsStatic = false, bool bAddNewLine = false);

		std::vector<Parameter>& GetParameters();
		std::string GetParametersAsString();

		void AddBody(std::string Body);
		void SetParamStruct(Struct&& Params);

		std::string GetDeclaration();

		std::string GetGeneratedBody();
		Struct& GetParamStruct();

		void AddComment(std::string& Comment);
		void AddComment(std::string&& Comment);
	};

	class Class : public Struct
	{
	private:
		std::vector<Function> ClassFunctions;
		std::string RawName; //For StaticClass()

	public:
		using Struct::Struct;

		Class(std::string CppName, std::string Name, std::string Super = "")
			: Struct(CppName, true, Super), RawName(Name)
		{
		}

	public:
		void AddFunction(Function& NewFunction);
		void AddFunction(Function&& NewFunction);

	public:
		std::string GetGeneratedBody();
	};
}

```

`Dumper/UnrealObjects.cpp`:

```cpp
#include <format>

#include "UnrealObjects.h"
#include "Offsets.h"
#include "ObjectArray.h"

std::unordered_map<int32, std::string> UEEnum::BigEnums;
std::unordered_map<std::string, uint32> UEProperty::UnknownProperties;
std::unordered_map<int32, uint32> UEStruct::StructSizes;


void* UEFFieldClass::GetAddress()
{
	return Class;
}

UEFFieldClass::operator bool() const
{
	return Class != nullptr;
}

EFieldClassID UEFFieldClass::GetId() const
{
	return *reinterpret_cast<EFieldClassID*>(Class + Off::FFieldClass::Id);
}

EClassCastFlags UEFFieldClass::GetCastFlags() const
{
	return *reinterpret_cast<EClassCastFlags*>(Class + Off::FFieldClass::CastFlags);
}

EClassFlags UEFFieldClass::GetClassFlags() const
{
	return *reinterpret_cast<EClassFlags*>(Class + Off::FFieldClass::ClassFlags);
}

UEFFieldClass UEFFieldClass::GetSuper() const
{
	return UEFFieldClass(*reinterpret_cast<void**>(Class + Off::FFieldClass::SuperClass));
}

FName UEFFieldClass::GetFName() const
{
	return FName(Class + Off::FFieldClass::Name); //Not the real FName, but a wrapper which holds the address of a FName
}

bool UEFFieldClass::IsType(EClassCastFlags Flags) const
{
	return (Flags != EClassCastFlags::None ? (GetCastFlags() & Flags) : true);
}

std::string UEFFieldClass::GetName() const
{
	return Class ? GetFName().ToString() : "None";
}

std::string UEFFieldClass::GetValidName() const
{
	return Class ? GetFName().ToValidString() : "None";
}

std::string UEFFieldClass::GetCppName() const
{
	// This is evile dark magic code which shouldn't exist
	return "F" + GetValidName();
}

void* UEFField::GetAddress()
{
	return Field;
}

EObjectFlags UEFField::GetFlags() const
{
	return *reinterpret_cast<EObjectFlags*>(Field + Off::FField::Flags);
}

class UEObject UEFField::GetOwnerAsUObject() const
{
	if (IsOwnerUObject())
	{
		if (Settings::Internal::bUseMaskForFieldOwner)
			return (void*)(*reinterpret_cast<uintptr_t*>(Field + Off::FField::Owner) & ~0x1ull);

		return *reinterpret_cast<void**>(Field + Off::FField::Owner);
	}

	return nullptr;
}

class UEFField UEFField::GetOwnerAsFField() const
{
	if (!IsOwnerUObject())
		return *reinterpret_cast<void**>(Field + Off::FField::Owner);

	return nullptr;
}

class UEObject UEFField::GetOwnerUObject() const
{
	UEFField Field = *this;

	while (!Field.IsOwnerUObject() && Field.GetOwnerAsFField())
	{
		Field = Field.GetOwnerAsFField();
	}

	return Field.GetOwnerAsUObject();
}

class UEObject UEFField::GetOutermost() const
{
	UEObject OwnerUObject = GetOwnerUObject();
	return OwnerUObject.GetOutermost();
}

UEFFieldClass UEFField::GetClass() const
{
	return UEFFieldClass(*reinterpret_cast<void**>(Field + Off::FField::Class));
}

FName UEFField::GetFName() const
{
	return FName(Field + Off::FField::Name); //Not the real FName, but a wrapper which holds the address of a FName
}

UEFField UEFField::GetNext() const
{
	return UEFField(*reinterpret_cast<void**>(Field + Off::FField::Next));
}

template<typename UEType>
UEType UEFField::Cast() const
{
	return UEType(Field);
}

bool UEFField::IsOwnerUObject() const
{
	if (Settings::Internal::bUseMaskForFieldOwner)
	{
		return *reinterpret_cast<uintptr_t*>(Field + Off::FField::Owner) & 0x1;
	}

	return *reinterpret_cast<bool*>(Field + Off::FField::Owner + 0x8);
}

bool UEFField::IsA(EClassCastFlags Flags) const
{
	return (Flags != EClassCastFlags::None ? GetClass().IsType(Flags) : true);
}

std::string UEFField::GetName() const
{
	return Field ? GetFName().ToString() : "None";
}

std::string UEFField::GetValidName() const
{
	return Field ? GetFName().ToValidString() : "None";
}

std::string UEFField::GetCppName() const
{
	static UEClass ActorClass = ObjectArray::FindClassFast("Actor");
	static UEClass InterfaceClass = ObjectArray::FindClassFast("Interface");

	std::string Temp = GetValidName();

	if (IsA(EClassCastFlags::Class))
	{
		if (Cast<UEClass>().HasType(ActorClass)) 
		{
			return 'A' + Temp;
		}
		else if (Cast<UEClass>().HasType(InterfaceClass)) 
		{
			return 'I' + Temp;
		}

		return 'U' + Temp;
	}

	return 'F' + Temp;
}

UEFField::operator bool() const
{
	return Field != nullptr && reinterpret_cast<void*>(Field + Off::FField::Class) != nullptr;
}

bool UEFField::operator==(const UEFField& Other) const
{
	return Field == Other.Field;
}

bool UEFField::operator!=(const UEFField& Other) const
{
	return Field != Other.Field;
}

void(*UEObject::PE)(void*, void*, void*) = nullptr;

void* UEObject::GetAddress()
{
	return Object;
}

void* UEObject::GetVft() const
{
	return *reinterpret_cast<void**>(Object);
}

EObjectFlags UEObject::GetFlags() const
{
	return *reinterpret_cast<EObjectFlags*>(Object + Off::UObject::Flags);
}

int32 UEObject::GetIndex() const
{
	return *reinterpret_cast<int32*>(Object + Off::UObject::Index);
}

UEClass UEObject::GetClass() const
{
	return UEClass(*reinterpret_cast<void**>(Object + Off::UObject::Class));
}

FName UEObject::GetFName() const
{
	return FName(Object + Off::UObject::Name); //Not the real FName, but a wrapper which holds the address of a FName
}

UEObject UEObject::GetOuter() const
{
	return UEObject(*reinterpret_cast<void**>(Object + Off::UObject::Outer));
}

bool UEObject::HasAnyFlags(EObjectFlags Flags) const
{
	return GetFlags() & Flags;
}

template<typename UEType>
UEType UEObject::Cast()
{
	return UEType(Object);
}

template<typename UEType>
const UEType UEObject::Cast() const
{
	return UEType(Object);
}

bool UEObject::IsA(EClassCastFlags TypeFlags) const
{
	return (TypeFlags != EClassCastFlags::None ? GetClass().IsType(TypeFlags) : true);
}

UEObject UEObject::GetOutermost() const
{
	UEObject Outermost;

	for (UEObject Outer = *this; Outer; Outer = Outer.GetOuter())
	{
		Outermost = Outer;
	}
	return Outermost;
}

std::string UEObject::StringifyObjFlags() const
{
	return StringifyObjectFlags(GetFlags());
}

std::string UEObject::GetName() const
{
	return Object ? GetFName().ToString() : "None";
}

std::string UEObject::GetValidName() const
{
	return Object ? GetFName().ToValidString() : "None";
}

std::string UEObject::GetCppName() const
{
	static UEClass ActorClass = ObjectArray::FindClassFast("Actor");
	static UEClass InterfaceClass = ObjectArray::FindClassFast("Interface");

	std::string Temp = GetValidName();

	if (IsA(EClassCastFlags::Class))
	{
		if (Cast<UEClass>().HasType(ActorClass))
		{
			return 'A' + Temp;
		}
		else if (Cast<UEClass>().HasType(InterfaceClass))
		{
			return 'I' + Temp;
		}

		return 'U' + Temp;
	}

	return 'F' + Temp;
}

std::string UEObject::GetFullName() const
{
	if (*this)
	{
		std::string Temp;

		for (UEObject Outer = GetOuter(); Outer; Outer = Outer.GetOuter())
		{
			Temp = Outer.GetName() + "." + Temp;
		}

		std::string Name = GetClass().GetName();
		Name += " ";
		Name += Temp;
		Name += GetName();

		return Name;
	}

	return "None";
}

UEObject::operator bool() const
{
	// if an object is 0x10000F000 it passes the nullptr check
	return Object != nullptr && reinterpret_cast<void*>(Object + Off::UObject::Class) != nullptr;
}

UEObject::operator uint8*()
{
	return Object;
}

bool UEObject::operator==(const UEObject& Other) const
{
	return Object == Other.Object;
}

bool UEObject::operator!=(const UEObject& Other) const
{
	return Object != Other.Object;
}

void UEObject::ProcessEvent(UEFunction Func, void* Params)
{
	void** VFT = *reinterpret_cast<void***>(GetAddress());

	void(*Prd)(void*, void*, void*) = decltype(Prd)(VFT[Off::InSDK::PEIndex]);

	Prd(Object, Func.GetAddress(), Params);
}

UEField UEField::GetNext() const
{
	return UEField(*reinterpret_cast<void**>(Object + Off::UField::Next));
}

bool UEField::IsNextValid() const
{
	return (bool)GetNext();
}

std::vector<TPair<FName, int64>> UEEnum::GetNameValuePairs() const
{
	struct Name08Byte { uint8 Pad[0x08]; };
	struct Name16Byte { uint8 Pad[0x10]; };

	std::vector<TPair<FName, int64>> Ret;

	if (!Settings::Internal::bIsEnumNameOnly)
	{
		if (Settings::Internal::bUseCasePreservingName)
		{
			auto& Names = *reinterpret_cast<TArray<TPair<Name16Byte, int64>>*>(Object + Off::UEnum::Names);

			for (int i = 0; i < Names.Num(); i++)
			{
				Ret.push_back({ FName(&Names[i].First), Names[i].Second });
			}
		}
		else
		{
			auto& Names = *reinterpret_cast<TArray<TPair<Name08Byte, int64>>*>(Object + Off::UEnum::Names);

			for (int i = 0; i < Names.Num(); i++)
			{
				Ret.push_back({ FName(&Names[i].First), Names[i].Second });
			}
		}
	}
	else
	{
		auto& NameOnly = *reinterpret_cast<TArray<FName>*>(Object + Off::UEnum::Names);

		if (Settings::Internal::bUseCasePreservingName)
		{
			auto& Names = *reinterpret_cast<TArray<Name16Byte>*>(Object + Off::UEnum::Names);

			for (int i = 0; i < Names.Num(); i++)
			{
				Ret.push_back({ FName(&Names[i]), i });
			}
		}
		else
		{
			auto& Names = *reinterpret_cast<TArray<Name08Byte>*>(Object + Off::UEnum::Names);

			for (int i = 0; i < Names.Num(); i++)
			{
				Ret.push_back({ FName(&Names[i]), i });
			}
		}
	}

	return Ret;
}

std::string UEEnum::GetSingleName(int32 Index) const
{
	return GetNameValuePairs()[Index].First.ToString();
}

std::string UEEnum::GetEnumTypeAsStr() const
{
	std::string Temp = GetName();

	return "enum class " + (Temp[0] == 'E' ? Temp : 'E' + Temp);
}


UEStruct UEStruct::GetSuper() const
{
	return UEStruct(*reinterpret_cast<void**>(Object + Off::UStruct::SuperStruct));
}

UEField UEStruct::GetChild() const
{
	return UEField(*reinterpret_cast<void**>(Object + Off::UStruct::Children));
}

UEFField UEStruct::GetChildProperties() const
{
	return UEFField(*reinterpret_cast<void**>(Object + Off::UStruct::ChildProperties));
}

int32 UEStruct::GetStructSize() const
{
	return *reinterpret_cast<int32*>(Object + Off::UStruct::Size);
}

std::vector<UEProperty> UEStruct::GetProperties() const
{
	std::vector<UEProperty> Properties;

	if (Settings::Internal::bUseFProperty)
	{
		for (UEFField Field = GetChildProperties(); Field; Field = Field.GetNext())
		{
			if (Field.IsA(EClassCastFlags::Property))
			{
				Properties.push_back(Field.Cast<UEProperty>());
			}
		}

		return Properties;
	}

	for (UEField Field = GetChild(); Field; Field = Field.GetNext())
	{
		if (Field.IsA(EClassCastFlags::Property))
		{
			Properties.push_back(Field.Cast<UEProperty>());
		}
	}

	return Properties;
}

UEProperty UEStruct::FindMember(const std::string& MemberName, EClassCastFlags TypeFlags) const
{
	if (!Object)
		return nullptr;

	if (Settings::Internal::bUseFProperty)
	{
		for (UEFField Field = GetChildProperties(); Field; Field = Field.GetNext())
		{
			if (Field.IsA(TypeFlags) && Field.GetName() == MemberName)
			{
				return Field.Cast<UEProperty>();
			}
		}
	}

	for (UEField Field = GetChild(); Field; Field = Field.GetNext())
	{
		if (Field.IsA(TypeFlags) && Field.GetName() == MemberName)
		{
			return Field.Cast<UEProperty>();
		}
	}

	return nullptr;
}

bool UEStruct::HasMembers() const
{
	if (!Object)
		return false;

	if (Settings::Internal::bUseFProperty)
	{
		for (UEFField Field = GetChildProperties(); Field; Field = Field.GetNext())
		{
			if (Field.IsA(EClassCastFlags::Property))
			{
				return true;
			}
		}
	}
	else
	{
		for (UEField F = GetChild(); F; F = F.GetNext())
		{
			if (F.IsA(EClassCastFlags::Property))
			{
				return true;
			}
		}
	}

	return false;
}

EClassCastFlags UEClass::GetCastFlags() const
{
	return *reinterpret_cast<EClassCastFlags*>(Object + Off::UClass::CastFlags);
}

std::string UEClass::StringifyCastFlags() const
{
	return StringifyClassCastFlags(GetCastFlags());
}

bool UEClass::IsType(EClassCastFlags TypeFlag) const
{
	return (TypeFlag != EClassCastFlags::None ? (GetCastFlags() & TypeFlag) : true);
}

bool UEClass::HasType(UEClass TypeClass) const
{
	if (TypeClass == nullptr)
		return false;

	for (UEStruct S = *this; S; S = S.GetSuper())
	{
		if (S == TypeClass)
			return true;
	}

	return false;
}

UEObject UEClass::GetDefaultObject() const
{
	return UEObject(*reinterpret_cast<void**>(Object + Off::UClass::ClassDefaultObject));
}

UEFunction UEClass::GetFunction(const std::string& ClassName, const std::string& FuncName) const
{
	for (UEStruct Struct = *this; Struct; Struct = Struct.GetSuper())
	{
		if (Struct.GetName() == ClassName)
		{
			for (UEField Field = Struct.GetChild(); Field; Field = Field.GetNext())
			{
				if (Field.IsA(EClassCastFlags::Function) && Field.GetName() == FuncName)
				{
					return Field.Cast<UEFunction>();
				}	
			}
		}
	}

	return nullptr;
}

EFunctionFlags UEFunction::GetFunctionFlags() const
{
	return *reinterpret_cast<EFunctionFlags*>(Object + Off::UFunction::FunctionFlags);
}

bool UEFunction::HasFlags(EFunctionFlags FuncFlags) const
{
	return GetFunctionFlags() & FuncFlags;
}

void* UEFunction::GetExecFunction() const
{
	return *reinterpret_cast<void**>(Object + Off::UFunction::ExecFunction);
}

std::string UEFunction::StringifyFlags()  const
{
	return StringifyFunctionFlags(GetFunctionFlags());
}

std::string UEFunction::GetParamStructName() const
{
	return GetOuter().GetCppName() + "_" + GetValidName() + "_Params";
}

void* UEProperty::GetAddress()
{
	return Base;
}

std::pair<UEClass, UEFFieldClass> UEProperty::GetClass() const
{
	if (Settings::Internal::bUseFProperty)
	{
		return { UEClass(0), UEFField(Base).GetClass() };
	}

	return { UEObject(Base).GetClass(), UEFFieldClass(0) };
}

UEProperty::operator bool() const
{
	return Base != nullptr && ((Base + Off::UObject::Class) != nullptr || (Base + Off::FField::Class) != nullptr);
}

template<typename UEType>
UEType UEProperty::Cast()
{
	return UEType(Base);
}

template<typename UEType>
const UEType UEProperty::Cast() const
{
	return UEType(Base);
}

bool UEProperty::IsA(EClassCastFlags TypeFlags) const
{
	if (GetClass().first)
		return GetClass().first.IsType(TypeFlags);
	
	return GetClass().second.IsType(TypeFlags);
}

bool UEProperty::IsTypeSupported() const
{
	EClassCastFlags PropTypeFlags = (GetClass().first ? GetClass().first.GetCastFlags() : GetClass().second.GetCastFlags());

	return static_cast<std::underlying_type_t<EClassCastFlags>>(PropTypeFlags) & static_cast<std::underlying_type_t<EClassCastFlags>>(GetSupportedProperties());
}

FName UEProperty::GetFName() const
{
	if (Settings::Internal::bUseFProperty)
	{
		return FName(Base + Off::FField::Name); //Not the real FName, but a wrapper which holds the address of a FName
	}

	return FName(Base + Off::UObject::Name); //Not the real FName, but a wrapper which holds the address of a FName
}

int32 UEProperty::GetArrayDim() const
{
	return *reinterpret_cast<int32*>(Base + Off::UProperty::ArrayDim);
}

int32 UEProperty::GetSize() const
{
	return *reinterpret_cast<int32*>(Base + Off::UProperty::ElementSize);
}

int32 UEProperty::GetOffset() const
{
	return *reinterpret_cast<int32*>(Base + Off::UProperty::Offset_Internal);
}

EPropertyFlags UEProperty::GetPropertyFlags() const
{
	return *reinterpret_cast<EPropertyFlags*>(Base + Off::UProperty::PropertyFlags);
}

EMappingsTypeFlags UEProperty::GetMappingType() const
{
	EClassCastFlags Flags = GetClass().first ? GetClass().first.GetCastFlags() : GetClass().second.GetCastFlags();

	return EPropertyFlagsToMappingFlags(Flags);
}

bool UEProperty::HasPropertyFlags(EPropertyFlags PropertyFlag) const
{
	return GetPropertyFlags() & PropertyFlag;
}

UEObject UEProperty::GetOutermost() const
{
	return Settings::Internal::bUseFProperty ? UEFField(Base).GetOutermost() : UEObject(Base).GetOutermost();
}

std::string UEProperty::GetName() const
{
	return Base ? GetFName().ToString() : "None";
}

std::string UEProperty::GetValidName() const
{
	return Base ? GetFName().ToValidString() : "None";
}

std::string UEProperty::GetCppType() const
{
	EClassCastFlags TypeFlags = (GetClass().first ? GetClass().first.GetCastFlags() : GetClass().second.GetCastFlags());

	if (TypeFlags & EClassCastFlags::ByteProperty)
	{
		return Cast<UEByteProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::UInt16Property)
	{
		return "uint16";
	}
	else if (TypeFlags &  EClassCastFlags::UInt32Property)
	{
		return "uint32";
	}
	else if (TypeFlags &  EClassCastFlags::UInt64Property)
	{
		return "uint64";
	}
	else if (TypeFlags & EClassCastFlags::Int8Property)
	{
		return "int8";
	}
	else if (TypeFlags &  EClassCastFlags::Int16Property)
	{
		return "int16";
	}
	else if (TypeFlags &  EClassCastFlags::IntProperty)
	{
		return "int32";
	}
	else if (TypeFlags &  EClassCastFlags::Int64Property)
	{
		return "int64";
	}
	else if (TypeFlags &  EClassCastFlags::FloatProperty)
	{
		return "float";
	}
	else if (TypeFlags &  EClassCastFlags::DoubleProperty)
	{
		return "double";
	}
	else if (TypeFlags &  EClassCastFlags::ClassProperty)
	{
		return Cast<UEClassProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::NameProperty)
	{
		return "class FName";
	}
	else if (TypeFlags &  EClassCastFlags::StrProperty)
	{
		return "class FString";
	}
	else if (TypeFlags & EClassCastFlags::TextProperty)
	{
		return "class FText";
	}
	else if (TypeFlags &  EClassCastFlags::BoolProperty)
	{
		return Cast<UEBoolProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::StructProperty)
	{
		return Cast<UEStructProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::ArrayProperty)
	{
		return Cast<UEArrayProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::WeakObjectProperty)
	{
		return Cast<UEWeakObjectProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::LazyObjectProperty)
	{
		return Cast<UELazyObjectProperty>().GetCppType();
	}
	else if (TypeFlags & EClassCastFlags::SoftClassProperty)
	{
		return Cast<UESoftClassProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::SoftObjectProperty)
	{
		return Cast<UESoftObjectProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::ObjectProperty)
	{
		return Cast<UEObjectProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::MapProperty)
	{
		return Cast<UEMapProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::SetProperty)
	{
		return Cast<UESetProperty>().GetCppType();
	}
	else if (TypeFlags &  EClassCastFlags::EnumProperty)
	{
		return Cast<UEEnumProperty>().GetCppType();
	}
	else if (TypeFlags & EClassCastFlags::InterfaceProperty) 
	{
		return Cast<UEInterfaceProperty>().GetCppType();
	}
	else
	{
		return (GetClass().first ? GetClass().first.GetCppName() : GetClass().second.GetCppName()) + "_";;
	}
}

std::string UEProperty::StringifyFlags() const
{
	return StringifyPropertyFlags(GetPropertyFlags());
}

UEEnum UEByteProperty::GetEnum() const
{
	return UEEnum(*reinterpret_cast<void**>(Base + Off::UByteProperty::Enum));
}

std::string UEByteProperty::GetCppType() const
{
	if (UEEnum Enum = GetEnum())
	{
		return Enum.GetEnumTypeAsStr();
	}

	return "uint8";
}

uint8 UEBoolProperty::GetFieldMask() const
{
	return reinterpret_cast<Off::UBoolProperty::UBoolPropertyBase*>(Base + Off::UBoolProperty::Base)->FieldMask;
}

uint8 UEBoolProperty::GetBitIndex() const
{
	uint8 FieldMask = GetFieldMask();
	
	if (FieldMask != 0xFF)
	{
		if (FieldMask == 0x01) { return 1; }
		if (FieldMask == 0x02) { return 2; }
		if (FieldMask == 0x04) { return 3; }
		if (FieldMask == 0x08) { return 4; }
		if (FieldMask == 0x10) { return 5; }
		if (FieldMask == 0x20) { return 6; }
		if (FieldMask == 0x40) { return 7; }
		if (FieldMask == 0x80) { return 8; }
	}

	return 0xFF;
}

bool UEBoolProperty::IsNativeBool() const
{
	return reinterpret_cast<Off::UBoolProperty::UBoolPropertyBase*>(Base + Off::UBoolProperty::Base)->FieldMask == 0xFF;
}

std::string UEBoolProperty::GetCppType() const
{
	return IsNativeBool() ? "bool" : "uint8";
}

UEClass UEObjectProperty::GetPropertyClass() const
{
	return UEClass(*reinterpret_cast<void**>(Base + Off::UObjectProperty::PropertyClass));
}

std::string UEObjectProperty::GetCppType() const
{
	return std::format("class {}*", GetPropertyClass() ? GetPropertyClass().GetCppName() : "UObject");
}

UEClass UEClassProperty::GetMetaClass() const
{
	return UEClass(*reinterpret_cast<void**>(Base + Off::UClassProperty::MetaClass));
}

std::string UEClassProperty::GetCppType() const
{
	return HasPropertyFlags(EPropertyFlags::UObjectWrapper) ? std::format("TSubclassOf<class {}>", GetMetaClass().GetCppName()) : "class UClass*";
}

std::string UEWeakObjectProperty::GetCppType() const
{
	return std::format("TWeakObjectPtr<class {}>", GetPropertyClass() ? GetPropertyClass().GetCppName() : "UObject");
}

std::string UELazyObjectProperty::GetCppType() const
{
	return std::format("TLazyObjectPtr<class {}>", GetPropertyClass() ? GetPropertyClass().GetCppName() : "UObject");
}

std::string UESoftObjectProperty::GetCppType() const
{
	return std::format("TSoftObjectPtr<class {}>", GetPropertyClass() ? GetPropertyClass().GetCppName() : "UObject");
}

std::string UESoftClassProperty::GetCppType() const
{
	return std::format("TSoftClassPtr<class {}>", GetMetaClass() ? GetMetaClass().GetCppName() : GetPropertyClass().GetCppName());
}

std::string UEInterfaceProperty::GetCppType() const
{
	return std::format("TScriptInterface<class {}>", GetPropertyClass().GetCppName());
}

UEStruct UEStructProperty::GetUnderlayingStruct() const
{
	return UEStruct(*reinterpret_cast<void**>(Base + Off::UStructProperty::Struct));
}

std::string UEStructProperty::GetCppType() const
{
	return std::format("struct {}", GetUnderlayingStruct().GetCppName());
}

UEProperty UEArrayProperty::GetInnerProperty() const
{
	return UEProperty(*reinterpret_cast<void**>(Base + Off::UArrayProperty::Inner));
}

std::string UEArrayProperty::GetCppType() const
{
	return std::format("TArray<{}>", GetInnerProperty().GetCppType());
}

UEProperty UEMapProperty::GetKeyProperty() const
{
	return UEProperty(reinterpret_cast<Off::UMapProperty::UMapPropertyBase*>(Base + Off::UMapProperty::Base)->KeyProperty);
}

UEProperty UEMapProperty::GetValueProperty() const
{
	return UEProperty(reinterpret_cast<Off::UMapProperty::UMapPropertyBase*>(Base + Off::UMapProperty::Base)->ValueProperty);
}

std::string UEMapProperty::GetCppType() const
{
	return std::format("TMap<{}, {}>", GetKeyProperty().GetCppType(), GetValueProperty().GetCppType());
}

UEProperty UESetProperty::GetElementProperty() const
{
	return UEProperty(*reinterpret_cast<void**>(Base + Off::USetProperty::ElementProp));
}

std::string UESetProperty::GetCppType() const
{
	return std::format("TSet<{}>", GetElementProperty().GetCppType());
}

UEProperty UEEnumProperty::GetUnderlayingProperty() const
{
	return UEProperty(reinterpret_cast<Off::UEnumProperty::UEnumPropertyBase*>(Base + Off::UEnumProperty::Base)->UnderlayingProperty);
}

UEEnum UEEnumProperty::GetEnum() const
{
	return UEEnum(reinterpret_cast<Off::UEnumProperty::UEnumPropertyBase*>(Base + Off::UEnumProperty::Base)->Enum);
}

std::string UEEnumProperty::GetCppType() const
{
	if (GetEnum())
		return GetEnum().GetEnumTypeAsStr();

	return GetUnderlayingProperty().GetCppType();
}

/*
* The compiler won't generate functions for a specific template type unless it's used in the .cpp file corresponding to the
* header it was declatred in.
*
* See https://stackoverflow.com/questions/456713/why-do-i-get-unresolved-external-symbol-errors-when-using-templates
*/
void TemplateTypeCreationForUnrealObjects(void)
{
	UEObject Dummy(nullptr);
	UEFField FDummy(nullptr);
	UEProperty PDummy(nullptr);

	const UEObject CDummy(nullptr);
	const UEFField CFDummy(nullptr);
	const UEProperty CPDummy(nullptr);

	FDummy.Cast<UEFField>();
	FDummy.Cast<UEProperty>();
	FDummy.Cast<UEByteProperty>();
	FDummy.Cast<UEBoolProperty>();
	FDummy.Cast<UEObjectProperty>();
	FDummy.Cast<UEClassProperty>();
	FDummy.Cast<UEStructProperty>();
	FDummy.Cast<UEArrayProperty>();
	FDummy.Cast<UEMapProperty>();
	FDummy.Cast<UESetProperty>();
	FDummy.Cast<UEEnumProperty>();
	FDummy.Cast<UEInterfaceProperty>();

	FDummy.Cast<UEFField&>();
	FDummy.Cast<UEProperty&>();
	FDummy.Cast<UEByteProperty&>();
	FDummy.Cast<UEBoolProperty&>();
	FDummy.Cast<UEObjectProperty&>();
	FDummy.Cast<UEClassProperty&>();
	FDummy.Cast<UEStructProperty&>();
	FDummy.Cast<UEArrayProperty&>();
	FDummy.Cast<UEMapProperty&>();
	FDummy.Cast<UESetProperty&>();
	FDummy.Cast<UEEnumProperty&>();
	FDummy.Cast<UEInterfaceProperty&>();

	PDummy.Cast<UEFField>();
	PDummy.Cast<UEProperty>();
	PDummy.Cast<UEByteProperty>();
	PDummy.Cast<UEBoolProperty>();
	PDummy.Cast<UEObjectProperty>();
	PDummy.Cast<UEClassProperty>();
	PDummy.Cast<UEStructProperty>();
	PDummy.Cast<UEArrayProperty>();
	PDummy.Cast<UEMapProperty>();
	PDummy.Cast<UESetProperty>();
	PDummy.Cast<UEEnumProperty>();
	PDummy.Cast<UEInterfaceProperty>();

	PDummy.Cast<UEFField&>();
	PDummy.Cast<UEProperty&>();
	PDummy.Cast<UEByteProperty&>();
	PDummy.Cast<UEBoolProperty&>();
	PDummy.Cast<UEObjectProperty&>();
	PDummy.Cast<UEClassProperty&>();
	PDummy.Cast<UEStructProperty&>();
	PDummy.Cast<UEArrayProperty&>();
	PDummy.Cast<UEMapProperty&>();
	PDummy.Cast<UESetProperty&>();
	PDummy.Cast<UEEnumProperty&>();
	PDummy.Cast<UEInterfaceProperty&>();

	Dummy.Cast<UEFField>();

	Dummy.Cast<UEObject>();
	Dummy.Cast<UEField>();
	Dummy.Cast<UEEnum>();
	Dummy.Cast<UEStruct>();
	Dummy.Cast<UEClass>();
	Dummy.Cast<UEFunction>();
	Dummy.Cast<UEProperty>();
	Dummy.Cast<UEByteProperty>();
	Dummy.Cast<UEBoolProperty>();
	Dummy.Cast<UEObjectProperty>();
	Dummy.Cast<UEClassProperty>();
	Dummy.Cast<UEStructProperty>();
	Dummy.Cast<UEArrayProperty>();
	Dummy.Cast<UEMapProperty>();
	Dummy.Cast<UESetProperty>();
	Dummy.Cast<UEEnumProperty>();
	Dummy.Cast<UEInterfaceProperty>();

	Dummy.Cast<UEObject&>();
	Dummy.Cast<UEField&>();
	Dummy.Cast<UEEnum&>();
	Dummy.Cast<UEStruct&>();
	Dummy.Cast<UEClass&>();
	Dummy.Cast<UEFunction&>();
	Dummy.Cast<UEProperty&>();
	Dummy.Cast<UEByteProperty&>();
	Dummy.Cast<UEBoolProperty&>();
	Dummy.Cast<UEObjectProperty&>();
	Dummy.Cast<UEClassProperty&>();
	Dummy.Cast<UEStructProperty&>();
	Dummy.Cast<UEArrayProperty&>();
	Dummy.Cast<UEMapProperty&>();
	Dummy.Cast<UESetProperty&>();
	Dummy.Cast<UEEnumProperty&>();
	Dummy.Cast<UEInterfaceProperty&>();


	CPDummy.Cast<UEObject>();
	CPDummy.Cast<UEField>();
	CPDummy.Cast<UEProperty>();

	CPDummy.Cast<UEField&>();
	CPDummy.Cast<UEProperty&>();

	CFDummy.Cast<UEFField>();
	CFDummy.Cast<UEProperty>();
	CFDummy.Cast<UEByteProperty>();
	CFDummy.Cast<UEBoolProperty>();
	CFDummy.Cast<UEObjectProperty>();
	CFDummy.Cast<UEClassProperty>();
	CFDummy.Cast<UEStructProperty>();
	CFDummy.Cast<UEArrayProperty>();
	CFDummy.Cast<UEMapProperty>();
	CFDummy.Cast<UESetProperty>();
	CFDummy.Cast<UEEnumProperty>();
	CFDummy.Cast<UEInterfaceProperty>();

	CFDummy.Cast<UEFField&>();
	CFDummy.Cast<UEProperty&>();
	CFDummy.Cast<UEByteProperty&>();
	CFDummy.Cast<UEBoolProperty&>();
	CFDummy.Cast<UEObjectProperty&>();
	CFDummy.Cast<UEClassProperty&>();
	CFDummy.Cast<UEStructProperty&>();
	CFDummy.Cast<UEArrayProperty&>();
	CFDummy.Cast<UEMapProperty&>();
	CFDummy.Cast<UESetProperty&>();
	CFDummy.Cast<UEEnumProperty&>();
	CFDummy.Cast<UEInterfaceProperty&>();

	CDummy.Cast<UEFField>();

	CDummy.Cast<UEObject>();
	CDummy.Cast<UEField>();
	CDummy.Cast<UEEnum>();
	CDummy.Cast<UEStruct>();
	CDummy.Cast<UEClass>();
	CDummy.Cast<UEFunction>();
	CDummy.Cast<UEProperty>();
	CDummy.Cast<UEByteProperty>();
	CDummy.Cast<UEBoolProperty>();
	CDummy.Cast<UEObjectProperty>();
	CDummy.Cast<UEClassProperty>();
	CDummy.Cast<UEStructProperty>();
	CDummy.Cast<UEArrayProperty>();
	CDummy.Cast<UEMapProperty>();
	CDummy.Cast<UESetProperty>();
	CDummy.Cast<UEEnumProperty>();
	CDummy.Cast<UEInterfaceProperty>();

	CDummy.Cast<UEObject&>();
	CDummy.Cast<UEField&>();
	CDummy.Cast<UEEnum&>();
	CDummy.Cast<UEStruct&>();
	CDummy.Cast<UEClass&>();
	CDummy.Cast<UEFunction&>();
	CDummy.Cast<UEProperty&>();
	CDummy.Cast<UEByteProperty&>();
	CDummy.Cast<UEBoolProperty&>();
	CDummy.Cast<UEObjectProperty&>();
	CDummy.Cast<UEClassProperty&>();
	CDummy.Cast<UEStructProperty&>();
	CDummy.Cast<UEArrayProperty&>();
	CDummy.Cast<UEMapProperty&>();
	CDummy.Cast<UESetProperty&>();
	CDummy.Cast<UEEnumProperty&>();
	CDummy.Cast<UEInterfaceProperty&>();
}

```

`Dumper/UnrealObjects.h`:

```h
#pragma once

#include <vector>
#include <unordered_map>
#include "Enums.h"
#include "UnrealTypes.h"

class UEClass;
class UEFField;
class UEObject;
class UEProperty;

class UEFFieldClass
{
protected:
	uint8* Class;

public:

	UEFFieldClass() = default;

	UEFFieldClass(void* NewFieldClass)
		: Class(reinterpret_cast<uint8*>(NewFieldClass))
	{
	}

	UEFFieldClass(const UEFFieldClass& OldFieldClass)
		: Class(reinterpret_cast<uint8*>(OldFieldClass.Class))
	{
	}

	void* GetAddress();

	operator bool() const;

	EFieldClassID GetId() const;

	EClassCastFlags GetCastFlags() const;
	EClassFlags GetClassFlags() const;
	UEFFieldClass GetSuper() const;
	FName GetFName() const;

	bool IsType(EClassCastFlags Flags) const;

	std::string GetName() const;
	std::string GetValidName() const;
	std::string GetCppName() const;
};

class UEFField
{
protected:
	uint8* Field;

public:

	UEFField() = default;

	UEFField(void* NewField)
		: Field(reinterpret_cast<uint8*>(NewField))
	{
	}

	UEFField(const UEFField& OldField)
		: Field(reinterpret_cast<uint8*>(OldField.Field))
	{
	}

	void* GetAddress();

	EObjectFlags GetFlags() const;
	class UEObject GetOwnerAsUObject() const;
	class UEFField GetOwnerAsFField() const;
	class UEObject GetOwnerUObject() const;
	class UEObject GetOutermost() const;
	UEFFieldClass GetClass() const;
	FName GetFName() const;
	UEFField GetNext() const;

	template<typename UEType>
	UEType Cast() const;

	bool IsOwnerUObject() const;
	bool IsA(EClassCastFlags Flags) const;

	std::string GetName() const;
	std::string GetValidName() const;
	std::string GetCppName() const;

	explicit operator bool() const;
	bool operator==(const UEFField& Other) const;
	bool operator!=(const UEFField& Other) const;
};

class UEObject
{
private:
	static void(*PE)(void*, void*, void*);

protected:
	uint8* Object;

public:

	UEObject() = default;

	UEObject(void* NewObject)
		: Object(reinterpret_cast<uint8*>(NewObject))
	{
	}

	UEObject(const UEObject& OldObject)
		: Object(reinterpret_cast<uint8*>(OldObject.Object))
	{
	}

	void* GetAddress();

	void* GetVft() const;
	EObjectFlags GetFlags() const;
	int32 GetIndex() const;
	UEClass GetClass() const;
	FName GetFName() const;
	UEObject GetOuter() const;

	bool HasAnyFlags(EObjectFlags Flags) const;

	template<typename UEType>
	UEType Cast();

	template<typename UEType>
	const UEType Cast() const;

	bool IsA(EClassCastFlags TypeFlags) const;

	UEObject GetOutermost() const;

	std::string StringifyObjFlags() const;

	std::string GetName() const;
	std::string GetValidName() const;
	std::string GetCppName() const;
	std::string GetFullName() const;

	explicit operator bool() const;
	explicit operator uint8*();
	bool operator==(const UEObject& Other) const;
	bool operator!=(const UEObject& Other) const;

	void ProcessEvent(class UEFunction Func, void* Params);
};

class UEField : public UEObject
{
	using UEObject::UEObject;

public:
	UEField GetNext() const;
	bool IsNextValid() const;
};

class UEEnum : public UEField
{
	using UEField::UEField;

public:
	static std::unordered_map<int32, std::string> BigEnums; //ObjectArray::GetAllPackages()

	std::vector<TPair<FName, int64>> GetNameValuePairs() const;
	std::string GetSingleName(int32 Index) const;
	std::string GetEnumTypeAsStr() const;
};

class UEStruct : public UEField
{
	using UEField::UEField;

public:
	static std::unordered_map<int32 /*StructIdx*/, uint32 /*RealSize*/> StructSizes;

public:
	UEStruct GetSuper() const;
	UEField GetChild() const;
	UEFField GetChildProperties() const;
	int32 GetStructSize() const;

	std::vector<UEProperty> GetProperties() const;

	UEProperty FindMember(const std::string& MemberName, EClassCastFlags TypeFlags = EClassCastFlags::None) const;

	bool HasMembers() const;
};

class UEFunction : public UEStruct
{
	using UEStruct::UEStruct;

public:
	EFunctionFlags GetFunctionFlags() const;
	bool HasFlags(EFunctionFlags Flags) const;

	void* GetExecFunction() const;

	std::string StringifyFlags() const;
	std::string GetParamStructName() const;
};

class UEClass : public UEStruct
{
	using UEStruct::UEStruct;

public:
	EClassCastFlags GetCastFlags() const;
	std::string StringifyCastFlags() const;
	bool IsType(EClassCastFlags TypeFlag) const;
	bool HasType(UEClass TypeClass) const;
	UEObject GetDefaultObject() const;

	UEFunction GetFunction(const std::string& ClassName, const std::string& FuncName) const;
};

class UEProperty
{
protected:
	uint8* Base;

public:
	static std::unordered_map<std::string /* Property Name */, uint32 /* Property Size */> UnknownProperties;

	UEProperty() = default;

	UEProperty(void* NewProperty)
		: Base(reinterpret_cast<uint8*>(NewProperty))
	{
	}

	UEProperty(const UEProperty& OldProperty)
		: Base(reinterpret_cast<uint8*>(OldProperty.Base))
	{
	}

public:
	void* GetAddress();

	std::pair<UEClass, UEFFieldClass> GetClass() const;

	operator bool() const;

	template<typename UEType>
	UEType Cast();

	template<typename UEType>
	const UEType Cast() const;

	bool IsA(EClassCastFlags TypeFlags) const;

	bool IsTypeSupported() const;

	FName GetFName() const;
	int32 GetArrayDim() const;
	int32 GetSize() const;
	int32 GetOffset() const;
	EPropertyFlags GetPropertyFlags() const;
	EMappingsTypeFlags GetMappingType() const;
	bool HasPropertyFlags(EPropertyFlags PropertyFlag) const;

	UEObject GetOutermost() const;

	std::string GetName() const;
	std::string GetValidName() const;

	std::string GetCppType() const;

	std::string StringifyFlags() const;

public:
	static consteval EClassCastFlags GetSupportedProperties()
	{
		return EClassCastFlags::ByteProperty | EClassCastFlags::UInt16Property | EClassCastFlags::UInt32Property | EClassCastFlags::UInt64Property
			| EClassCastFlags::Int8Property | EClassCastFlags::Int16Property | EClassCastFlags::IntProperty | EClassCastFlags::Int64Property
			| EClassCastFlags::FloatProperty | EClassCastFlags::DoubleProperty | EClassCastFlags::ClassProperty | EClassCastFlags::NameProperty
			| EClassCastFlags::StrProperty | EClassCastFlags::TextProperty | EClassCastFlags::BoolProperty | EClassCastFlags::StructProperty
			| EClassCastFlags::ArrayProperty | EClassCastFlags::WeakObjectProperty | EClassCastFlags::LazyObjectProperty | EClassCastFlags::SoftClassProperty
			| EClassCastFlags::SoftObjectProperty | EClassCastFlags::ObjectProperty | EClassCastFlags::MapProperty | EClassCastFlags::SetProperty
			| EClassCastFlags::EnumProperty | EClassCastFlags::InterfaceProperty;
	}
};

class UEByteProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEEnum GetEnum() const;

	std::string GetCppType() const;
};

class UEBoolProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	uint8 GetFieldMask() const;
	uint8 GetBitIndex() const;
	bool IsNativeBool() const;

	std::string GetCppType() const;
};

class UEObjectProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEClass GetPropertyClass() const;

	std::string GetCppType() const;
};

class UEClassProperty : public UEObjectProperty
{
	using UEObjectProperty::UEObjectProperty;

public:
	UEClass GetMetaClass() const;

	std::string GetCppType() const;
};

class UEWeakObjectProperty : public UEObjectProperty
{
	using UEObjectProperty::UEObjectProperty;

public:
	std::string GetCppType() const;
};

class UELazyObjectProperty : public UEObjectProperty
{
	using UEObjectProperty::UEObjectProperty;

public:
	std::string GetCppType() const;
};

class UESoftObjectProperty : public UEObjectProperty
{
	using UEObjectProperty::UEObjectProperty;

public:
	std::string GetCppType() const;
};

class UESoftClassProperty : public UEClassProperty
{
	using UEClassProperty::UEClassProperty;

public:
	std::string GetCppType() const;
};

class UEInterfaceProperty : public UEObjectProperty
{
	using UEObjectProperty::UEObjectProperty;

public:
	std::string GetCppType() const;
};

class UEStructProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEStruct GetUnderlayingStruct() const;

	std::string GetCppType() const;
};

class UEArrayProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEProperty GetInnerProperty() const;

	std::string GetCppType() const;
};

class UEMapProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEProperty GetKeyProperty() const;
	UEProperty GetValueProperty() const;

	std::string GetCppType() const;
};

class UESetProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEProperty GetElementProperty() const;

	std::string GetCppType() const;
};

class UEEnumProperty : public UEProperty
{
	using UEProperty::UEProperty;

public:
	UEProperty GetUnderlayingProperty() const;
	UEEnum GetEnum() const;

	std::string GetCppType() const;
};

```

`Dumper/UnrealTypes.cpp`:

```cpp
#include "UnrealTypes.h"
#include "NameArray.h"

void(*FName::AppendString)(void*, FString&) = nullptr;

std::string MakeNameValid(std::string&& Name)
{
	static constexpr const char* Numbers[10] =
	{
		"Zero",
		"One",
		"Two",
		"Three",
		"Four",
		"Five",
		"Six",
		"Seven",
		"Eight",
		"Nine"
	};

	if (Name == "bool")
		return "Bool";

	if (Name == "TRUE")
		return "TURR";

	if (Name == "FALSE")
		return "FLASE";

	if (Name == "NULL")
		return "NULLL";

	if (Name[0] <= '9' && Name[0] >= '0')
	{
		Name.replace(0, 1, Numbers[Name[0] - '0']);
	}
	else if ((Name[0] <= 'z' && Name[0] >= 'a') && Name[0] != 'b')
	{
		Name[0] -= 0x20;
	}

	for (int i = 0; i < Name.length(); i++)
	{
		switch (Name[i])
		{
		case '+':
			Name.replace(i, 1, "Plus");
			continue;
		case '-':
			Name.replace(i, 1, "Minus");
			continue;
		case '*':
			Name.replace(i, 1, "Star");
			continue;
		case '/':
			Name.replace(i, 1, "Slash");
			continue;
		default:
			break;
		}

		char c = Name[i];

		if (c != '_' && !((c <= 'z' && c >= 'a') || (c <= 'Z' && c >= 'A') || (c <= '9' && c >= '0')))
		{
			Name[i] = '_';
		}
	}

	return Name;
}

//std::string MakeNameValid(std::string&& Name)
//{
//	
//
//	for (int i = 0; i < Name.length(); i++)
//	{
//		char c = Name[i];
//
//		if (c != '_' && !((c <= 'z' && c >= 'a') || (c <= 'Z' && c >= 'A') || (c <= '9' && c >= '0')))
//		{
//			Name[i] = '_';
//		}
//	}
//
//	return Name;
//}

FName::FName(void* Ptr)
	: Address((uint8*)Ptr)
{
}

void FName::Init()
{
	constexpr std::array<const char*, 5> PossibleSigs = 
	{ 
		"48 8D ? ? 48 8D ? ? E8",
		"48 8D ? ? ? 48 8D ? ? E8",
		"48 8D ? ? 49 8B ? E8",
		"48 8D ? ? ? 49 8B ? E8",
		"48 8D ? ? 48 8B ? E8"
	};

	MemAddress StringRef = FindByStringInAllSections("ForwardShadingQuality_");

	int i = 0;
	while (!AppendString && i < PossibleSigs.size())
	{
		AppendString = reinterpret_cast<void(*)(void*, FString&)>(StringRef.RelativePattern(PossibleSigs[i], 0x80, -1 /* auto */));
		i++;
	}

	Off::InSDK::AppendNameToString = AppendString ? GetOffset(AppendString) : 0x0;

	if (!AppendString)
	{
		NameArray::Init();

		ToStr = [](void* Name) -> std::string
		{
			if (!Settings::Internal::bUseUoutlineNumberName)
			{
				const int32 Number = FName(Name).GetNumber();

				if (Number > 0)
					return NameArray::GetNameEntry(Name).GetString() + "_" + std::to_string(Number - 1);
			}

			return NameArray::GetNameEntry(Name).GetString();
		};

		return;
	}


	std::cout << "Found FName::AppendString at Offset 0x" << std::hex << Off::InSDK::AppendNameToString << "\n\n";

	ToStr = [](void* Name) -> std::string
	{
		thread_local FFreableString TempString(1024);

		AppendString(Name, TempString);

		std::string OutputString = TempString.ToString();
		TempString.ResetNum();

		return OutputString;
	};
}

void FName::Init(int32 AppendStringOffset)
{
	AppendString = reinterpret_cast<void(*)(void*, FString&)>(GetImageBase() + AppendStringOffset);

	Off::InSDK::AppendNameToString = AppendStringOffset;

	ToStr = [](void* Name) -> std::string
	{
		thread_local FFreableString TempString(1024);

		AppendString(Name, TempString);

		std::string OutputString = TempString.ToString();
		TempString.ResetNum();

		return OutputString;
	};

	std::cout << "Found FName::AppendString at Offset 0x" << std::hex << Off::InSDK::AppendNameToString << "\n\n";
}

std::string FName::ToString()
{
	std::string OutputString = ToStr(Address);

	size_t pos = OutputString.rfind('/');

	if (pos == std::string::npos)
		return OutputString;

	return OutputString.substr(pos + 1);
}

std::string FName::ToValidString()
{
	return MakeNameValid(ToString());
}

int32 FName::GetCompIdx()
{
	return *reinterpret_cast<int32*>(Address + Off::FName::CompIdx);
}
int32 FName::GetNumber()
{
	return *reinterpret_cast<int32*>(Address + Off::FName::Number);
}

bool FName::operator==(FName Other)
{
	return GetCompIdx() == Other.GetCompIdx();
}

bool FName::operator!=(FName Other)
{
	return GetCompIdx() != Other.GetCompIdx();
}

std::string FName::CompIdxToString(int CmpIdx)
{
	if (!Settings::Internal::bUseCasePreservingName)
	{
		struct FakeFName
		{
			int CompIdx;
			uint8 Pad[0x4];
		} Name(CmpIdx);

		return FName(&Name).ToString();
	}
	else
	{
		struct FakeFName
		{
			int CompIdx;
			uint8 Pad[0xC];
		} Name(CmpIdx);

		return FName(&Name).ToString();
	}
}

void* FName::DEBUGGetAppendString()
{
	return (void*)(AppendString);
}
```

`Dumper/UnrealTypes.h`:

```h
#pragma once

#include <array>
#include <string>
#include <iostream>
#include <Windows.h>
#include "Enums.h"
#include "Utils.h"
#include "Offsets.h"

extern std::string MakeNameValid(std::string&& Name);

template<typename ValueType, typename KeyType>
class alignas(4) TPair
{
public:
	ValueType First;
	KeyType Second;
};

template<class T>
class TArray
{
	friend class FString;

protected:
	T* Data;
	int32 NumElements;
	int32 MaxElements;

public:

	TArray() = default;

	inline TArray(int32 Num)
		:NumElements(0), MaxElements(Num), Data((T*)malloc(sizeof(T)* Num))
	{
	}

	inline T& operator[](uint32 Index)
	{
		return Data[Index];
	}
	inline const T& operator[](uint32 Index) const
	{
		return Data[Index];
	}

	inline int32 Num()
	{
		return this->NumElements;
	}

	inline int32 Max()
	{
		return this->MaxElements;
	}

	inline int32 GetSlack()
	{
		return MaxElements - NumElements;
	}

	inline bool IsValid()
	{
		return this->Data != nullptr;
	}

	inline bool IsValidIndex(int32 Index)
	{
		return Index >= 0 && Index < this->NumElements;
	}

	inline bool IsValidIndex(uint32 Index)
	{
		return Index < this->NumElements;
	}

	inline void ResetNum()
	{
		NumElements = 0;
	}

protected:
	inline void FreeArray()
	{
		NumElements = 0;
		MaxElements = 0;
		if (Data) free(Data);
		Data = nullptr;
	}
};

class FString : public TArray<wchar_t>
{
public:
	using TArray::TArray;

	inline FString(const wchar_t* WChar)
	{
		MaxElements = NumElements = *WChar ? std::wcslen(WChar) + 1 : 0;

		if (NumElements)
		{
			Data = const_cast<wchar_t*>(WChar);
		}
	}

	inline FString operator=(const wchar_t*&& Other)
	{
		return FString(Other);
	}

	inline std::wstring ToWString()
	{
		if (IsValid())
		{
			return Data;
		}

		return L"";
	}

	inline std::string ToString()
	{
		if (IsValid())
		{
			std::wstring WData(Data);
			return std::string(WData.begin(), WData.end());
		}

		return "";
	}
};

class FFreableString : public FString
{
public:
	using FString::FString;

	~FFreableString()
	{
		FreeArray();
	}
};


class FName
{
private:
	static void(*AppendString)(void*, FString&);

	inline static std::string(*ToStr)(void* Name) = nullptr;

private:
	uint8* Address;

public:
	FName() = default;

	FName(void* Ptr);

public:
	static void Init();

	static void Init(int32 AppendStringOffset);

public:
	inline const void* GetAddress() const { return Address; }

	std::string ToString();
	std::string ToValidString();

	int32 GetCompIdx();
	int32 GetNumber();

	bool operator==(FName Other);

	bool operator!=(FName Other);

	static std::string CompIdxToString(int CmpIdx);

	static void* DEBUGGetAppendString();
};

```

`Dumper/Utils.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <vector>
#include <string>
#include <fstream>

struct CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
};

struct TEB
{
	NT_TIB NtTib;
	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	struct PEB* ProcessEnvironmentBlock;
};

struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};

struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
};

struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};

struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
}; 

inline _TEB* _NtCurrentTeb()
{
	return (struct _TEB*)__readgsqword(((LONG)__builtin_offsetof(NT_TIB, Self)));
}

inline uintptr_t GetModuleSize()
{
	PEB* ProcessEnvironmentBlock = ((PEB*)((TEB*)((TEB*)_NtCurrentTeb())->ProcessEnvironmentBlock));
	PEB_LDR_DATA* Ldr = ProcessEnvironmentBlock->Ldr;

	int i = 0;

	LIST_ENTRY** Start = (LIST_ENTRY**)&Ldr->InMemoryOrderModuleList;
	for (LIST_ENTRY* P = *Start; P; P = P->Flink)
	{
		LDR_DATA_TABLE_ENTRY* A = (LDR_DATA_TABLE_ENTRY*)P;

		if (!A || i++ == 0x20)
			break;

		std::cout << "DllBase: " << A->DllBase << std::endl;
		std::cout << "EntryPoint: " << A->EntryPoint << std::endl;
		std::cout << "Size: " << std::hex << A->SizeOfImage << std::endl;

		std::wstring DllName(A->FullDllName.Buffer, A->FullDllName.Length >> 1);
		std::string DDLName = std::string(DllName.begin(), DllName.end());

		std::cout << DDLName << "\n" << std::endl;
	}

	return 0;
}

inline uintptr_t GetImageBase()
{
	PEB* ProcessEnvironmentBlock = ((PEB*)((TEB*)((TEB*)_NtCurrentTeb())->ProcessEnvironmentBlock));
	return (uintptr_t)ProcessEnvironmentBlock->ImageBaseAddress;
}

inline uintptr_t GetOffset(void* Addr)
{
	static uintptr_t ImageBase = 0x0;

	if (ImageBase == 0x0)
		ImageBase = GetImageBase();

	uintptr_t AddrAsInt = reinterpret_cast<uintptr_t>(Addr);

	return AddrAsInt > ImageBase ? (AddrAsInt - ImageBase) : 0x0;
}

inline bool IsInProcessRange(uintptr_t Address)
{
	uintptr_t ImageBase = GetImageBase();
	PIMAGE_NT_HEADERS NtHeader = reinterpret_cast<PIMAGE_NT_HEADERS>(ImageBase + reinterpret_cast<PIMAGE_DOS_HEADER>(ImageBase)->e_lfanew);

	return Address > ImageBase && Address < (NtHeader->OptionalHeader.SizeOfImage + ImageBase);
}

static bool IsBadReadPtr(void* p)
{
	MEMORY_BASIC_INFORMATION mbi;

	if (VirtualQuery(p, &mbi, sizeof(mbi)))
	{
		constexpr DWORD mask = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
		bool b = !(mbi.Protect & mask);
		if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS))
			b = true;

		return b;
	}

	return true;
};

static inline void* FindPatternInRange(std::vector<int>&& Signature, uint8_t* Start, uintptr_t Range, bool bRelative = false, uint32_t Offset = 0, int SkipCount = 0)
{
	const auto PatternLength = Signature.size();
	const auto PatternBytes = Signature.data();

	for (int i = 0; i < (Range - PatternLength); i++)
	{
		bool bFound = true;
		int CurrentSkips = 0;

		for (auto j = 0ul; j < PatternLength; ++j)
		{
			if (Start[i + j] != PatternBytes[j] && PatternBytes[j] != -1)
			{
				bFound = false;
				break;
			}
		}
		if (bFound)
		{
			if (CurrentSkips != SkipCount)
			{
				CurrentSkips++;
				continue;
			}

			uintptr_t Address = uintptr_t(Start + i);
			if (bRelative)
			{
				if (Offset == -1)
					Offset = PatternLength;

				Address = ((Address + Offset + 4) + *(int32_t*)(Address + Offset));
			}
			return (void*)Address;
		}
	}

	return nullptr;
}

static inline void* FindPatternInRange(const char* Signature, uint8_t* Start, uintptr_t Range, bool bRelative = false, uint32_t Offset = 0)
{
	static auto patternToByte = [](const char* pattern) -> std::vector<int>
	{
		auto Bytes = std::vector<int>{};
		const auto Start = const_cast<char*>(pattern);
		const auto End = const_cast<char*>(pattern) + strlen(pattern);

		for (auto Current = Start; Current < End; ++Current)
		{
			if (*Current == '?')
			{
				++Current;
				if (*Current == '?') ++Current;
				Bytes.push_back(-1);
			}
			else { Bytes.push_back(strtoul(Current, &Current, 16)); }
		}
		return Bytes;
	};

	return FindPatternInRange(patternToByte(Signature), Start, Range, bRelative, Offset);
}

static inline void* FindPattern(const char* Signature, uint32_t Offset = 0, bool bSearchAllSegments = false)
{
	uint8_t* ImageBase = (uint8_t*)GetImageBase();

	const auto DosHeader = (PIMAGE_DOS_HEADER)ImageBase;
	const auto NtHeaders = (PIMAGE_NT_HEADERS)(ImageBase + DosHeader->e_lfanew);

	const auto SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;

	if (!bSearchAllSegments)
	{
		PIMAGE_SECTION_HEADER Sections = IMAGE_FIRST_SECTION(NtHeaders);

		uint8_t* TextSection = nullptr;
		DWORD TextSize = 0;

		for (int i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++)
		{
			IMAGE_SECTION_HEADER& CurrentSection = Sections[i];

			std::string SectionName = (const char*)CurrentSection.Name;

			if (SectionName == ".text" && !TextSection)
			{
				TextSection = (ImageBase + CurrentSection.VirtualAddress);
				TextSize = CurrentSection.Misc.VirtualSize;
			}
		}

		return FindPatternInRange(Signature, TextSection, TextSize, Offset != 0x0, Offset);
	}

	return FindPatternInRange(Signature, ImageBase, SizeOfImage, Offset != 0x0, Offset);
}

struct MemAddress
{
public:
	uint8_t* Address;

private:
	//pasted
	static std::vector<int32_t> PatternToBytes(const char* pattern)
	{
		auto bytes = std::vector<int>{};
		const auto start = const_cast<char*>(pattern);
		const auto end = const_cast<char*>(pattern) + strlen(pattern);

		for (auto current = start; current < end; ++current)
		{
			if (*current == '?')
			{
				++current;
				if (*current == '?')
					++current;
				bytes.push_back(-1);
			}
			else { bytes.push_back(strtoul(current, &current, 16)); }
		}
		return bytes;
	}

	static bool IsFunctionRet(uint8_t* Address)
	{
		int Align = 0x10 - (uintptr_t(Address) % 0x10);
		//if (Opcode == RET && (OpcodeBefore is a POP opcode || OpcodeTwoBefore is a different POP Opcode)
		return Address[0] == 0xC3 && Address[Align] == 0x40 && ((Address[-1] >= 0x58 && Address[-1] <= 0x5F) || (Address[-2] == 0x41 && (Address[-1] >= 0x58 && Address[-1] <= 0x5F)));
	}

public:
	inline MemAddress(void* Addr)
		: Address((uint8_t*)Addr)
	{
	}
	inline MemAddress(uintptr_t Addr)
		: Address((uint8_t*)Addr)
	{
	}
	operator bool()
	{
		return Address != nullptr;
	}
	explicit operator void*()
	{
		return Address;
	}
	explicit operator uintptr_t()
	{
		return uintptr_t(Address);
	}

	inline MemAddress operator+(int Value) const
	{
		return Address + Value;
	}

	template<typename T = void>
	inline T* Get()
	{
		return Address;
	}

	MemAddress FindFunctionEnd()
	{
		if (!Address)
			return MemAddress(nullptr);

		int Align = 0x10 - (uintptr_t(Address) % 0x10);

		for (int i = 0; i < 0xFFFF; i++)
		{
			if (IsFunctionRet(Address + i))
			{
				return MemAddress(Address + i);
			}
			if ((uintptr_t(Address + i) % 0x10 == 0) && (Address[i] == 0x40 && (Address[i + 1] >= 0x50 && Address[i + 1] <= 0x57) && (Address[i + 2] >= 0x50 && Address[i + 2] <= 0x57)))
			{
				return MemAddress(Address + i);
			}
		}

		return  MemAddress(nullptr);
	}

	inline void* RelativePattern(const char* Pattern, int32_t Range, int32_t Relative = 0)
	{
		if (!Address)
			return nullptr;

		return FindPatternInRange(Pattern, Address, Range, Relative != 0, Relative);
	}

	// every occurence of E8 counts as a call, use for max 1-5 calls only
	/* Negative index for search up, positive for search down  | goes beyond function-boundaries */
	inline void* GetCalledFunction(int32_t FunctionIndex)
	{
		if (!Address || FunctionIndex == 0)
			return nullptr;

		int32_t NumCalls = 0;

		for (int i = 0; i < (FunctionIndex > 0 ? 0xFFF : -0xFFF); (FunctionIndex > 0 ? i += 0x50 : i -= 0x50))
		{
			for (int j = 0; j < 0x50; j++)
			{
				//opcode: call
				if (Address[i + j] == 0xE8)
				{
					uint8_t* CallAddr = Address + i + j;

					void* Func = CallAddr + *reinterpret_cast<int32*>(CallAddr + 1) + 5; /*Addr + Offset + 5*/

					if ((uint64_t(Func) % 0x4) != 0x0)
						continue;
						
					if (++NumCalls == FunctionIndex)
					{
						return Func;
					}
				}
			}
		}

		return nullptr;
	}

	inline MemAddress FindNextFunctionStart()
	{
		if (!Address)
			return MemAddress(nullptr);

		uintptr_t FuncEnd = (uintptr_t)FindFunctionEnd();

		return FuncEnd % 0x10 != 0 ? FuncEnd + (0x10 - (FuncEnd % 0x10)) : FuncEnd;
	}
};

template<typename Type = const char*>
inline MemAddress FindByString(Type RefStr)
{
	uintptr_t ImageBase = GetImageBase();
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)(ImageBase);
	PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)(ImageBase + DosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER Sections = IMAGE_FIRST_SECTION(NtHeader);

	uint8_t* DataSection = nullptr;
	uint8_t* TextSection = nullptr;
	DWORD DataSize = 0;
	DWORD TextSize = 0;

	uint8_t* StringAddress = nullptr;

	for (int i = 0; i < NtHeader->FileHeader.NumberOfSections; i++)
	{
		IMAGE_SECTION_HEADER& CurrentSection = Sections[i];

		std::string SectionName = (const char*)CurrentSection.Name;

		//std::cout << "Section: " << SectionName << " at 0x" << (void*)(CurrentSection.VirtualAddress + ImageBase) << "\n";

		if (SectionName == ".rdata" && !DataSection)
		{
			DataSection = (uint8_t*)(CurrentSection.VirtualAddress + ImageBase);
			DataSize = CurrentSection.Misc.VirtualSize;
		}
		else if (SectionName == ".text" && !TextSection)
		{
			TextSection = (uint8_t*)(CurrentSection.VirtualAddress + ImageBase);
			TextSize = CurrentSection.Misc.VirtualSize;
		}
	}

	for (int i = 0; i < DataSize; i++)
	{
		if constexpr (std::is_same<Type, const char*>())
		{
			if (strcmp((const char*)RefStr, (const char*)(DataSection + i)) == 0)
			{
				//std::cout << "FoundStr ref: " << (const char*)(DataSection + i) << "\n";

				StringAddress = DataSection + i;
			}
		}
		else
		{
			if (wcscmp((const wchar_t*)RefStr, (const wchar_t*)(DataSection + i)) == 0)
			{
				//std::wcout << L"FoundStr wref: " << (const wchar_t*)(DataSection + i) << L"\n";

				StringAddress = DataSection + i;
			}
		}
	}

	for (int i = 0; i < TextSize; i++)
	{
		// opcode: lea
		if ((TextSection[i] == uint8_t(0x4C) || TextSection[i] == uint8_t(0x48)) && TextSection[i + 1] == uint8_t(0x8D))
		{
			const uint8_t* StrPtr = *(int32_t*)(TextSection + i + 3) + 7 + TextSection + i;

			if (StrPtr == StringAddress)
			{
				//std::cout << "Found Address: 0x" << (void*)(TextSection + i) << "\n";

				return { TextSection + i };
			}
		}
	}

	return nullptr;
}

inline MemAddress FindByWString(const wchar_t* RefStr)
{
	return FindByString<const wchar_t*>(RefStr);
}

/* Slower than FindByString */
template<typename Type = const char*>
inline MemAddress FindByStringInAllSections(Type RefStr, void* StartAddress = nullptr)
{
	uintptr_t ImageBase = GetImageBase();
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)(ImageBase);
	PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)(ImageBase + DosHeader->e_lfanew);

	const DWORD SizeOfImage = NtHeader->OptionalHeader.SizeOfImage;

	uint8_t* SearchStart = StartAddress ? reinterpret_cast<uint8_t*>(StartAddress) : reinterpret_cast<uint8_t*>(ImageBase);
	DWORD SearchRange = SizeOfImage;

	for (int i = 0; i < SearchRange; i++)
	{
		// opcode: lea
		if ((SearchStart[i] == uint8_t(0x4C) || SearchStart[i] == uint8_t(0x48)) && SearchStart[i + 1] == uint8_t(0x8D))
		{
			const uint8_t* StrPtr = *(int32_t*)(SearchStart + i + 3) + 7 + SearchStart + i;

			if (!IsInProcessRange((uintptr_t)StrPtr))
				continue;

			if constexpr (std::is_same<Type, const char*>())
			{
				if (strcmp((const char*)RefStr, (const char*)StrPtr) == 0)
				{
					//std::cout << "FoundStr ref: " << (const char*)(SearchStart + i) << "\n";

					return { SearchStart + i };
				}
			}
			else
			{
				auto a = std::wstring((const wchar_t*)StrPtr);

				if (wcscmp((const wchar_t*)RefStr, (const wchar_t*)StrPtr) == 0) 
				{
					//std::wcout << L"FoundStr wref: " << (const wchar_t*)(SearchStart + i) << L"\n";

					return { SearchStart + i };
				}
			}
		}
	}

	return nullptr;
}

/* Slower than FindByWString */
inline MemAddress FindByWStringInAllSections(const wchar_t* RefStr)
{
	return FindByStringInAllSections<const wchar_t*>(RefStr);
}




```

`Dumper/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <chrono>
#include <fstream>
#include "Generator.h"

enum class EFortToastType : uint8
{
        Default                        = 0,
        Subdued                        = 1,
        Impactful                      = 2,
        EFortToastType_MAX             = 3,
};

DWORD MainThread(HMODULE Module)
{
	AllocConsole();
	FILE* Dummy;
	freopen_s(&Dummy, "CONOUT$", "w", stdout);
	freopen_s(&Dummy, "CONIN$", "r", stdin);

	auto t_1 = high_resolution_clock::now();

	std::cout << "Started Generation [Dumper-7]!\n";
  
	Generator::Init();

	if (Settings::GameName.empty() && Settings::GameVersion.empty())
	{
		// Only Possible in Main()
		FString Name;
		FString Version;
		UEClass Kismet = ObjectArray::FindClassFast("KismetSystemLibrary");
		UEFunction GetGameName = Kismet.GetFunction("KismetSystemLibrary", "GetGameName");
		UEFunction GetEngineVersion = Kismet.GetFunction("KismetSystemLibrary", "GetEngineVersion");

		Kismet.ProcessEvent(GetGameName, &Name);
		Kismet.ProcessEvent(GetEngineVersion, &Version);

		Settings::GameName = Name.ToString();
		Settings::GameVersion = Version.ToString();
	}

	std::cout << "GameName: " << Settings::GameName << "\n";
	std::cout << "GameVersion: " << Settings::GameVersion << "\n\n";

	Generator::GenerateSDK();
	Generator::GenerateMappings();
	Generator::GenerateIDAMappings();

	auto t_C = high_resolution_clock::now();
	
	auto ms_int_ = duration_cast<milliseconds>(t_C - t_1);
	duration<double, std::milli> ms_double_ = t_C - t_1;
	
	std::cout << "\n\nGenerating SDK took (" << ms_double_.count() << "ms)\n\n\n";

	while (true)
	{
		if (GetAsyncKeyState(VK_F6) & 1)
		{
			fclose(stdout);
			if (Dummy) fclose(Dummy);
			FreeConsole();

			FreeLibraryAndExitThread(Module, 0);
		}

		Sleep(100);
	}

	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID lpReserved)
{
	switch (reason)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MainThread, hModule, 0, 0);
		break;
	}

	return TRUE;
}
```

`README.md`:

```md

# Dumper 7

SDK Generator for all Unreal Engine games. Supported versions are all of UE4 and UE5.

## How to use

- Compile the dll in x64-Release
- Inject the dll into your target game
- The SDK is generated into the path specified by `Settings::SDKGenerationPath`
## Overriding Offsets

- ### Only override any offsets if the generator doesn't find them by itself
- All overrides are made in **Generator::Init()** inside of **Generator.cpp**

- GObjects
  ```cpp
  ObjectArray::Init(/*GObjectsOffset*/, /*ChunkSize*/, /*bIsChunked*/);
  ```
  ```cpp
  /* Make sure only to use types which exist in the sdk (eg. uint8, uint64) */
  InitObjectArrayDecryption([](void* ObjPtr) -> uint8* { return reinterpret_cast<uint8*>(uint64(ObjPtr) ^ 0x8375); });
  ```
- FName::AppendString
  ```cpp
  FName::Init(/*FName::AppendStringOffset*/);
  ```
- ProcessEvent
  ```cpp
  Off::InSDK::InitPE(/*PEIndex*/);
  ```
## Notes

- Be aware, that the calls to ProcessEvent in `Main.cpp` may crash on debug configuration
- In the SDK, initialize `UObject::GObjects` by calling the function `SDK::InitGObjects()`
- In the SDK, functions from classes as `UKismetSystemLibrary` or `UGameplayStatics` may only be called on their default-objects
## Issues

If you have any issues using the Dumper, please create an Issue on this repository\
and explain the problem **in detail**.
## TODO

- Fix mapping-file generation
- Fix cyclic dependencies of packages

```