Project Path: arc_gmh5225_BakaWare4_ub7gbplc

Source Tree:

```txt
arc_gmh5225_BakaWare4_ub7gbplc
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── cheat
│   ├── CMakeLists.txt
│   ├── include
│   │   └── imconfig_bw.h
│   └── src
│       ├── base
│       │   ├── base.h
│       │   ├── debug.h
│       │   ├── logger.cpp
│       │   ├── logger.h
│       │   ├── math.cpp
│       │   ├── math.h
│       │   ├── types
│       │   │   ├── angle.h
│       │   │   ├── bounding_box.h
│       │   │   ├── color.h
│       │   │   ├── dimension.h
│       │   │   ├── matrix.h
│       │   │   ├── pattern.h
│       │   │   └── vector.h
│       │   └── winapi.h
│       ├── core
│       │   ├── cheat.cpp
│       │   ├── cheat.h
│       │   ├── config.cpp
│       │   ├── config.h
│       │   ├── features
│       │   │   ├── esp.cpp
│       │   │   ├── features.h
│       │   │   └── misc.cpp
│       │   ├── hooks
│       │   │   ├── client_dll.cpp
│       │   │   ├── client_mode.cpp
│       │   │   ├── d3d11.cpp
│       │   │   └── wnd_proc.cpp
│       │   ├── hooks.cpp
│       │   ├── hooks.h
│       │   ├── input.cpp
│       │   ├── input.h
│       │   └── main.cpp
│       ├── crypt
│       │   ├── fnv1a.h
│       │   └── xorstr.h
│       ├── memory
│       │   ├── address.h
│       │   ├── dll.cpp
│       │   ├── dll.h
│       │   ├── hook_mgr.h
│       │   ├── interfaces.cpp
│       │   ├── interfaces.h
│       │   ├── memory.h
│       │   ├── netvars.cpp
│       │   └── netvars.h
│       ├── render
│       │   ├── menu.cpp
│       │   ├── menu.h
│       │   ├── render.cpp
│       │   └── render.h
│       └── valve
│           ├── cs
│           │   ├── cs.h
│           │   ├── entity.cpp
│           │   └── entity.h
│           └── se
│               ├── client.h
│               ├── engine.h
│               ├── inputsystem.h
│               ├── schema.h
│               ├── se.h
│               └── util.h
├── cspell.json
├── injector
│   ├── CMakeLists.txt
│   ├── LICENSE
│   └── src
│       ├── CapcomLoader.h
│       ├── CapcomResource.h
│       ├── DriverLoader.h
│       ├── Error.h
│       ├── KernelHelper.h
│       ├── KernelRoutines.h
│       ├── LICENSE
│       ├── LockedMemory.h
│       ├── MemoryController.h
│       ├── NtDefines.h
│       ├── PerfectInjector.cpp
│       └── SimpleMapper.h
├── vcpkg
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)
project(BakaWare4 VERSION 4.0.0)

if (MSVC)
    # multi core parallel building
    include(ProcessorCount)
    ProcessorCount(PROCESSOR_COUNT)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP${PROCESSOR_COUNT}")
    set(CMAKE_VS_MSBUILD_COMMAND "${CMAKE_VS_MSBUILD_COMMAND} /p:CL_MPCount=${PROCESSOR_COUNT} /m")
endif ()

add_subdirectory(cheat)
add_subdirectory(injector)
```

`CMakePresets.json`:

```json
{
  "version": 6,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 23,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "x64-windows",
      "binaryDir": "${sourceDir}/build",
      "generator": "Visual Studio 17 2022",
      "architecture": {
        "value": "x64",
        "strategy": "set"
      },
      "toolchainFile": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
      "environment": {
        "VCPKG_ROOT": "./vcpkg",
        "VCPKG_DEFAULT_TRIPLET": "x64-windows"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "Debug",
      "configurePreset": "x64-windows",
      "configuration": "Debug"
    },
    {
      "name": "Release",
      "configurePreset": "x64-windows",
      "configuration": "Release"
    }
  ]
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2023 nezu.cc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# BakaWare4

Counter-Strike 2 cheat

## Features

- ESP
  - Box
  - Name
  - Health
  - Skeleton
- Misc
  - bunnyhop

**THIS CHEAT IS STILL WIP, MORE TO COME SOON:tm:**

## Technical "rules"

for those that care

- No modifying any read only memory sections
- No hooks on globally exported interfaces
- No SEH/VEH (except for the one that is required to disable DEP when mapped using perfect injector)
- No TLS
- No persistent threads
- Must load and function correctly when mapped above 0x7FFFFFFEFFFF ;)

NOTE: the above only applies to release builds, anything is fair game  
in debug builds since they are only designed to be loaded in `-insecure`

## Building

This project uses [CMake](https://cmake.org/) to generate build files and [Visual Studio 17 2022](https://visualstudio.microsoft.com/) to compile it.

When cloning the repository, make sure to clone it with the `--recursive` flag to also clone the vcpkg submodule.

### Example
From the `Developer PowerShell for VS 2022` while in the project directory run:

```powershell
# list configure presets
cmake --list-presets
# configure the project using the "x64-windows" preset
# NOTE: this will also install the dependencies using vcpkg
cmake --preset=x64-windows
# list build presets
cmake --build --list-presets
# build the project using the "Release" preset
cmake --build --preset=Release
```

Or just open it in your favorite IDE (that supports CMake and CMakePresets) and build it from there.

### Dependencies

- [Dear ImGui](https://github.com/ocornut/imgui) (included using vcpkg)
- [nlohmann JSON](https://github.com/nlohmann/json) (included using vcpkg)
- [ThePerfectInjector](https://github.com/can1357/ThePerfectInjector) (included directly in the source tree)

## Contributing

Fell free to improve it and make a pull request but there is no
guarantee that I will like/agree with it and merge it.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details

## Q&A

- Q: Is this cheat undetected?  
A: Idk, you tell me. **I'm not responsible for any bans you get!**

- Q: What version of the game does it work on?  
A: It's designed to work on the latest steam version, I do not support cracked/older versions.  
**THIS CHEAT REQUIRES THE STEAM OVERLAY TO BE ON FOR RENDERING**  
**THE VULKAN RENDERER IS NOT SUPPORTED YET**

- Q: What is this?  
A: This is a forth instalment in my counter-strike cheat making adventure.

- Q: Why that name?  
A: Idk, I'm bad at naming things and it was a long time ago when this name was chosen.

- Q: What is the injector included?  
A: It's (ThePerfectInjector)[https://github.com/can1357/ThePerfectInjector]. It maps kernel space memory into
usermode by manipulating page tables. Windows will actively refuse to interact with memory addresses above
0x7FFFFFFEFFFF through their APIs making it basically invisible to external usermode scanners. These pages
are still perfectly valid though and the CPU will happily execute them. That's not to say it's fully undetectable.
We register a VEH to nerf DEP that will sometimes get mad at us and think that the RWX page is in fact not executable.
We just catch the exception and tell it to just continue execution. Another detection vector are of course the hooks,
and while we try to stay stealthy with them, they still need to exist. Anything running directly inside cs can read
our memory just fine, this injector only hides us from windows's virtual memory APIs.

- Q: Why not just use X?  
A: Nothing out there is perfect, and neither is this. This is a cheat designed to be perfect for **ME**.  
If you find it useful that's great. Releasing it because why not, I'm not going to sell it anyway.

- Q: What is the base?  
A: This cheat was heavily inspired by (lstrsrt/csgo_internal_base)[https://github.com/lstrsrt/csgo_internal_base] but
ported to CS2 and with some slight changes. Over time the layout will probably drift further and further away from it though.
```

`cheat/CMakeLists.txt`:

```txt
add_definitions(-DBAKAWARE_VERSION="${PROJECT_VERSION}")
add_definitions(-DIMGUI_USER_CONFIG=<imconfig_bw.h>)

find_package(imgui CONFIG REQUIRED)
find_package(nlohmann_json CONFIG REQUIRED)

file(GLOB_RECURSE SOURCES "src/*.cpp" )
add_library(BakaWare4 SHARED ${SOURCES})

target_include_directories(BakaWare4 PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(BakaWare4 PRIVATE nlohmann_json::nlohmann_json imgui::imgui)

target_compile_features(BakaWare4 PUBLIC c_std_17 cxx_std_20)
target_compile_options(BakaWare4 PUBLIC /Zc:threadSafeInit- /sdl- /GS- /guard:cf-)
```

`cheat/include/imconfig_bw.h`:

```h
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/rebased branch with your modifications to it)
// B) or '#define IMGUI_USER_CONFIG "my_imgui_config.h"' in your project and then add directives in your own file without touching this template.
//-----------------------------------------------------------------------------
// You need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include the imgui*.cpp
// files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------


//---- Define assertion handler. Defaults to calling assert().
// If your macro uses multiple statements, make sure is enclosed in a 'do { .. } while (0)' block so it can be used as a single statement.
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows
// Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
// for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
//#define IMGUI_DISABLE_OBSOLETE_KEYIO                      // 1.87: disable legacy io.KeyMap[]+io.KeysDown[] in favor io.AddKeyEvent(). This will be folded into IMGUI_DISABLE_OBSOLETE_FUNCTIONS in a few versions.

//---- Disable all of Dear ImGui or don't implement standard windows/tools.
// It is very strongly recommended to NOT disable the demo windows and debug tool during development. They are extremely useful in day to day work. Please read comments in imgui_demo.cpp.
//#define IMGUI_DISABLE                                     // Disable everything: all headers and source files will be empty.
//#define IMGUI_DISABLE_DEMO_WINDOWS                        // Disable demo windows: ShowDemoWindow()/ShowStyleEditor() will be empty.
//#define IMGUI_DISABLE_DEBUG_TOOLS                         // Disable metrics/debugger and other debug tools: ShowMetricsWindow(), ShowDebugLogWindow() and ShowStackToolWindow() will be empty (this was called IMGUI_DISABLE_METRICS_WINDOW before 1.88).

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc. (user32.lib/.a, kernel32.lib/.a)
//#define IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS          // [Win32] [Default with Visual Studio] Implement default IME handler (require imm32.lib/.a, auto-link for Visual Studio, -limm32 on command-line for MinGW)
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] [Default with non-Visual Studio compilers] Don't implement default IME handler (won't require imm32.lib/.a)
#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, ime).
//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).
//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)
//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.
#define IMGUI_DISABLE_FILE_FUNCTIONS                      // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle at all (replace them with dummies)
//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().
//#define IMGUI_DISABLE_SSE                                 // Disable use of SSE intrinsics even if available

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Use 32-bit for ImWchar (default is 16-bit) to support unicode planes 1-16. (e.g. point beyond 0xFFFF like emoticons, dingbats, symbols, shapes, ancient languages, etc...)
//#define IMGUI_USE_WCHAR32

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of Dear ImGui sources files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_STB_SPRINTF_FILENAME    "my_folder/stb_sprintf.h"    // only used if enabled
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Use stb_sprintf.h for a faster implementation of vsnprintf instead of the one from libc (unless IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS is defined)
// Compatibility checks of arguments and formats done by clang and GCC will be disabled in order to support the extra formats provided by stb_sprintf.h.
//#define IMGUI_USE_STB_SPRINTF

//---- Use FreeType to build and rasterize the font atlas (instead of stb_truetype which is embedded by default in Dear ImGui)
// Requires FreeType headers to be available in the include path. Requires program to be compiled with 'misc/freetype/imgui_freetype.cpp' (in this repository) + the FreeType library (not provided).
// On Windows you may use vcpkg with 'vcpkg install freetype --triplet=x64-windows' + 'vcpkg integrate install'.
//#define IMGUI_ENABLE_FREETYPE

//---- Use stb_truetype to build and rasterize the font atlas (default)
// The only purpose of this define is if you want force compilation of the stb_truetype backend ALONG with the FreeType backend.
//#define IMGUI_ENABLE_STB_TRUETYPE

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                     \
        constexpr ImVec2(const MyVec2& f) : x(f.x), y(f.y) {}                   \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                     \
        constexpr ImVec4(const MyVec4& f) : x(f.x), y(f.y), z(f.z), w(f.w) {}   \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/
//---- ...Or use Dear ImGui's own very basic math operators.
#define IMGUI_DEFINE_MATH_OPERATORS

//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.
// Your renderer backend will need to support it (most example renderer backends support both 16/32-bit indices).
// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.
// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.
//#define ImDrawIdx unsigned int

//---- Override ImDrawCallback signature (will need to modify renderer backends accordingly)
//struct ImDrawList;
//struct ImDrawCmd;
//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);
//#define ImDrawCallback MyImDrawCallback

//---- Debug Tools: Macro to break in Debugger
// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)
//#define IM_DEBUG_BREAK  IM_ASSERT(0)
//#define IM_DEBUG_BREAK  __debugbreak()

//---- Debug Tools: Enable slower asserts
//#define IMGUI_DEBUG_PARANOID

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/

#ifndef IMCONFIG_H
#define IMCONFIG_H


#endif /* IMCONFIG_H */

```

`cheat/src/base/base.h`:

```h
#pragma once

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-value"
#pragma clang diagnostic ignored "-Wpragma-once-outside-header"
#pragma clang diagnostic ignored "-Wreorder-ctor"
#endif

#define NOMINMAX

#include <chrono>
using namespace std::chrono_literals;
#include <cstddef>
#include <cstdint>
#include <thread>

#include "logger.h"
#include "types/angle.h"
// #include "types/bitfield.h"
#include "types/color.h"
#include "types/dimension.h"
#include "types/matrix.h"
#include "types/pattern.h"
#include "types/vector.h"
#include "types/bounding_box.h"
#include "../crypt/xorstr.h"
```

`cheat/src/base/debug.h`:

```h
#pragma once

#include <cassert>
#include "logger.h"

#ifdef NDEBUG
[[noreturn]]
#endif
static void dbg_fail(std::string_view fn, std::string_view msg = "") noexcept
{
#ifdef _DEBUG
    if (msg.empty())
        LOG_ERROR(XOR("An error occurred in {}!"), fn);
    else
        LOG_ERROR(XOR("{} ({})"), msg, fn);
    assert(false);
#else
    std::abort();
#endif
}

#ifdef __clang__
#define FUNCTION_NAME __PRETTY_FUNCTION__
#else
#define FUNCTION_NAME __FUNCTION__
#endif
#define ASSERT(expr) do { if (!(expr)) dbg_fail(XOR(FUNCTION_NAME)); } while (false)
#define ASSERT_MSG(expr, msg) do { if (!(expr)) dbg_fail(XOR(FUNCTION_NAME), msg); } while (false)

```

`cheat/src/base/logger.cpp`:

```cpp
#include "logger.h"
#include "../memory/dll.h"

void logger::valve_logger::initialize(const char* channel_name, logging_severity severity, clr4 color) noexcept {
    using function_t = logging_channel_id(__stdcall*)(const char*, void*, int, logging_severity, clr4);
    static function_t fn = dlls::tier0.get_export("LoggingSystem_RegisterLoggingChannel"_hash).cast<function_t>();
    ASSERT(fn);
    channel_id = fn(channel_name, nullptr, 0, severity, color);
}

bool logger::valve_logger::is_channel_enabled(logging_severity severity) noexcept {
    using function_t = bool(__stdcall*)(logging_channel_id, logging_severity);
    static function_t fn = dlls::tier0.get_export("LoggingSystem_IsChannelEnabled"_hash).cast<function_t>();
    ASSERT(fn);
    return fn(channel_id, severity);
}

void logger::valve_logger::log(logging_severity severity, const char *message) noexcept {
    using function_t = void(__stdcall*)(logging_channel_id, logging_severity, const char*, ...);
    static function_t fn = dlls::tier0.get_export("LoggingSystem_LogDirect"_hash).cast<function_t>();
    ASSERT(fn);
    fn(channel_id, severity, message);
}
```

`cheat/src/base/logger.h`:

```h
#pragma once

#include <chrono>
namespace ch = std::chrono;
#include <format>
#include <fstream>
#include <iostream>
#include <string_view>

#include "winapi.h"
#include "types/color.h"
#include "../crypt/xorstr.h"

// #define EXTERNAL_CONSOLE 

// #ifdef EXTERNAL_CONSOLE
#define LOG_INFO(fmt, ...) logger::add<logger::level::info>(fmt, __VA_ARGS__)
#define LOG_ERROR(fmt, ...) logger::add<logger::level::error>(fmt, __VA_ARGS__)
// #else
// #define LOG_INFO
// #define LOG_ERROR
// #endif

namespace logger {

    inline HANDLE console{ };

    enum class level {
        info,
        error,
    };

    namespace valve_logger {
        typedef int logging_channel_id;
        enum class logging_severity {
            LS_MESSAGE = 0,
            LS_WARNING = 1,
            LS_ASSERT = 2,
            LS_ERROR = 3,
            LS_HIGHEST_SEVERITY = 4,
        };

        inline logging_channel_id channel_id;

        void initialize(const char* channel_name, logging_severity severity = logging_severity::LS_HIGHEST_SEVERITY, clr4 color = clr4(0x00, 0x77, 0xFF, 0xFF)) noexcept;

        void log(logging_severity severity, const char* message) noexcept;

        bool is_channel_enabled(logging_severity severity) noexcept;
    };

    // Use the LOG macros instead of accessing these directly

    template<level lvl, class... va_args>
    void add(std::string_view fmt, va_args&&... args) noexcept
    {
        std::string str;
        if constexpr (sizeof...(args) > 0)
            str = std::vformat(fmt, std::make_format_args(std::forward<decltype(args)>(args)...));
        else
            str = fmt;

        str += '\n';
    #ifdef EXTERNAL_CONSOLE
        std::cout << "[ ";
        switch (lvl) {
        case level::info:
            SetConsoleTextAttribute(console, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
            std::cout << '*';
            break;
        case level::error:
            SetConsoleTextAttribute(console, FOREGROUND_RED);
            std::cout << '!';
            break;
        }

        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        const auto time = ch::system_clock::to_time_t(ch::system_clock::now());
        std::tm tm{ };
        localtime_s(&tm, &time);
        std::cout << " ] " << std::put_time(&tm, "[%T] ");

        std::cout << fmt;
    #else
        switch (lvl) {
        case level::info:
            valve_logger::log(valve_logger::logging_severity::LS_MESSAGE, str.data());
            break;
        case level::error:
            valve_logger::log(valve_logger::logging_severity::LS_ERROR, str.data());
            break;
        }
    #endif
    }

    inline void initialize(std::string_view console_title) noexcept
    {
    #ifdef EXTERNAL_CONSOLE
        AllocConsole();
        AttachConsole(ATTACH_PARENT_PROCESS);
        SetConsoleTitleA(console_title.data());

        freopen_s(reinterpret_cast<FILE**>(stdout), XOR("CONOUT$"), XOR("w"), stdout);
        console = GetStdHandle(STD_OUTPUT_HANDLE);
    #else
        valve_logger::initialize(console_title.data());
    #endif
        LOG_INFO(XOR("Logger initialized."));
    }

    inline void end() noexcept
    {
    #ifdef EXTERNAL_CONSOLE
        fclose(stdout);
        FreeConsole();
    #endif
    }

}

```

`cheat/src/base/math.cpp`:

```cpp
#include "math.h"

#include "../memory/dll.h"
#include "../core/cheat.h"

bool math::world_to_screen(const vec3 &world, vec2 &screen) noexcept {
    SIG(function_ptr, dlls::client, "E8 ? ? ? ? F3 0F 10 45 ? 8B D0")
    auto function = function_ptr.absolute<bool(__thiscall*)(const vec3&, vec3&)>();
    vec3 screen_ret;
    if (function(world, screen_ret))
        return false;
    
    screen.x = (1.0f + screen_ret.x) * (cheat::screen_size.x * 0.5f);
    screen.y = (1.0f - screen_ret.y) * (cheat::screen_size.y * 0.5f);
    return true;
}

```

`cheat/src/base/math.h`:

```h
#pragma once
#include "base.h"

namespace math {
    bool world_to_screen(const vec3& world, vec2& screen) noexcept;
}
```

`cheat/src/base/types/angle.h`:

```h
#pragma once

#include <limits>

struct angle {
    float x{ }, y{ }, z{ };

    constexpr angle() noexcept = default;
    constexpr angle(float x, float y, float z) noexcept
        : x(x), y(y), z(z) { }

    bool operator==(const angle& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) <= std::numeric_limits<float>::epsilon() &&
            std::abs(y - rhs.y) <= std::numeric_limits<float>::epsilon() &&
            std::abs(z - rhs.z) <= std::numeric_limits<float>::epsilon());
    }

    bool operator!=(const angle& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) > std::numeric_limits<float>::epsilon() ||
            std::abs(y - rhs.y) > std::numeric_limits<float>::epsilon() ||
            std::abs(z - rhs.z) > std::numeric_limits<float>::epsilon());
    }

    constexpr angle operator+(const angle& rhs) const noexcept
    {
        return angle(x + rhs.x, y + rhs.y, z + rhs.z);
    }

    constexpr angle operator-(const angle& rhs) const noexcept
    {
        return angle(x - rhs.x, y - rhs.y, z - rhs.z);
    }

    constexpr angle operator*(const angle& rhs) const noexcept
    {
        return angle(x * rhs.x, y * rhs.y, z * rhs.z);
    }

    constexpr angle operator/(const angle& rhs) const noexcept
    {
        return angle(x / rhs.x, y / rhs.y, z / rhs.z);
    }

    constexpr angle operator+(const float rhs) const noexcept
    {
        return angle(x + rhs, y + rhs, z + rhs);
    }

    constexpr angle operator-(const float rhs) const noexcept
    {
        return angle(x - rhs, y - rhs, z - rhs);
    }

    constexpr angle operator*(const float rhs) const noexcept
    {
        return angle(x * rhs, y * rhs, z * rhs);
    }

    constexpr angle operator/(const float rhs) const noexcept
    {
        return angle(x / rhs, y / rhs, z / rhs);
    }

    constexpr angle& operator=(const angle& rhs) noexcept
    {
        x = rhs.x;
        y = rhs.y;
        z = rhs.z;
        return *this;
    }

    constexpr angle& operator+=(const angle& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

    constexpr angle& operator-=(const angle& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

    constexpr angle& operator*=(const angle& rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        z *= rhs.z;
        return *this;
    }

    constexpr angle& operator/=(const angle& rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        z /= rhs.z;
        return *this;
    }

    constexpr angle& operator+=(const float rhs) noexcept
    {
        x += rhs;
        y += rhs;
        z += rhs;
        return *this;
    }

    constexpr angle& operator-=(const float rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        z -= rhs;
        return *this;
    }

    constexpr angle& operator*=(const float rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        z *= rhs;
        return *this;
    }

    constexpr angle& operator/=(const float rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        z /= rhs;
        return *this;
    }

    constexpr void clamp() noexcept
    {
        x = std::clamp(x, -89.0f, 89.0f);
        y = std::clamp(y, -180.0f, 180.0f);
        z = 0.0f;
    }

    constexpr auto length_sqr() const noexcept
    {
        return (x * x + y * y + z * z);
    }

    constexpr auto length2d_sqr() const noexcept
    {
        return (x * x + y * y);
    }

    auto length() const noexcept
    {
        return sqrtf(length_sqr());
    }

    auto length2d() const noexcept
    {
        return sqrtf(length2d_sqr());
    }

    void normalize() noexcept
    {
        x = std::isfinite(x) ? std::remainder(x, 360.0f) : 0.0f;
        y = std::isfinite(y) ? std::remainder(y, 360.0f) : 0.0f;
        z = 0.0f;
    }
};

#include <format>

template<>
struct std::formatter<angle> : std::formatter<std::string> {
    auto format(angle a, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}]", a.x, a.y, a.z), ctx);
    }
};

```

`cheat/src/base/types/bounding_box.h`:

```h
#pragma once

struct bbox {
    float x{ }, y{ }, w{ }, h{ };

    float center_x() const noexcept { return x + ((w - x) * 0.5f); }
    float center_y() const noexcept { return y + ((h - y) * 0.5f); }

};

```

`cheat/src/base/types/color.h`:

```h
#pragma once

struct clr3;

struct clr4 {
    union {
        struct {
            uint8_t r, g, b, a;
        };
        uint32_t rgba{ };
    };

    constexpr clr4() noexcept = default;

    template<std::integral ix, std::integral ax>
    constexpr clr4(ix r, ix g, ix b, ax a) noexcept
        : r(r), g(g), b(b), a(a) { }

    template<std::floating_point fp>
    constexpr clr4(fp r, fp g, fp b, fp a) noexcept
        : r(static_cast<uint8_t>(r * 255)), g(static_cast<uint8_t>(g * 255)),
          b(static_cast<uint8_t>(b * 255)), a(static_cast<uint8_t>(a * 255)) { }

    float r_base() const noexcept { return r / 255.f; }
    float g_base() const noexcept { return g / 255.f; }
    float b_base() const noexcept { return b / 255.f; }
    float a_base() const noexcept { return a / 255.f; }

    static clr4 white(uint8_t a = 255) noexcept { return clr4(255, 255, 255, a); }
    static clr4 black(uint8_t a = 255) noexcept { return clr4(0, 0, 0, a); }
    static clr4 red(uint8_t a = 255) noexcept { return clr4(255, 0, 0, a); }
    static clr4 green(uint8_t a = 255) noexcept { return clr4(0, 255, 0, a); }
    static clr4 blue(uint8_t a = 255) noexcept { return clr4(0, 0, 255, a); }
    static clr4 cyan (uint8_t a = 255) noexcept { return clr4(0, 255, 255, a); }
    static clr4 magenta (uint8_t a = 255) noexcept { return clr4(255, 0, 255, a); }
    static clr4 yellow (uint8_t a = 255) noexcept { return clr4(255, 255, 0, a); }

    static clr4 lerp(const clr4& a, const clr4& b, float t) noexcept {
        return clr4(
            std::lerp(a.r_base(), b.r_base(), t),
            std::lerp(a.g_base(), b.g_base(), t),
            std::lerp(a.b_base(), b.b_base(), t),
            std::lerp(a.a_base(), b.a_base(), t)
        );
    }
};

static_assert(sizeof(clr4) == 4);

struct clr3 {
    uint8_t r{ }, g{ }, b{ };

    constexpr clr3() noexcept = default;
    constexpr clr3(uint8_t r, uint8_t g, uint8_t b) noexcept
        : r(r), g(g), b(b) { }

    auto to_clr4(uint8_t alpha = 255) const noexcept
    {
        return clr4(r, g, b, alpha);
    }
};

```

`cheat/src/base/types/dimension.h`:

```h
#pragma once

struct d2 {
    int x{ }, y{ };

    constexpr d2() noexcept = default;
    constexpr d2(int x, int y) noexcept
        : x(x), y(y) { }

    constexpr bool operator==(d2 rhs) const noexcept
    {
        return x == rhs.x && y == rhs.y;
    }

    constexpr bool operator!=(d2 rhs) const noexcept
    {
        return x != rhs.x || y != rhs.y;
    }

    constexpr d2 operator+(d2 rhs) const noexcept
    {
        return d2(x + rhs.x, y + rhs.y);
    }

    constexpr d2 operator-(d2 rhs) const noexcept
    {
        return d2(x - rhs.x, y - rhs.y);
    }

    constexpr d2 operator*(d2 rhs) const noexcept
    {
        return d2(x * rhs.x, y * rhs.y);
    }

    constexpr d2 operator/(d2 rhs) const noexcept
    {
        return d2(x / rhs.x, y / rhs.y);
    }

    constexpr d2 operator+(const int rhs) const noexcept
    {
        return d2(x + rhs, y + rhs);
    }

    constexpr d2 operator-(const int rhs) const noexcept
    {
        return d2(x - rhs, y - rhs);
    }

    constexpr d2 operator*(const int rhs) const noexcept
    {
        return d2(x * rhs, y * rhs);
    }

    constexpr d2 operator/(const int rhs) const noexcept
    {
        return d2(x / rhs, y / rhs);
    }

    constexpr d2& operator+=(d2 rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }

    constexpr d2& operator-=(d2 rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }

    constexpr d2& operator*=(d2 rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        return *this;
    }

    constexpr d2& operator/=(d2 rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        return *this;
    }

    constexpr d2& operator+=(int rhs) noexcept
    {
        x += rhs;
        y += rhs;
        return *this;
    }

    constexpr d2& operator-=(int rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        return *this;
    }

    constexpr d2& operator*=(int rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        return *this;
    }

    constexpr d2& operator/=(int rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        return *this;
    }
};

```

`cheat/src/base/types/matrix.h`:

```h
#pragma once

using mat3x3 = float[3][3];

struct mat3x4 {
    float data[3][4]{ };

    float* operator[](int i) noexcept
    {
        return data[i];
    }

    const float* operator[](int i) const noexcept
    {
        return data[i];
    }
};

struct mat4x4 {
    float data[4][4]{ };

    float* operator[](int i) noexcept
    {
        return data[i];
    }

    const float* operator[](int i) const noexcept
    {
        return data[i];
    }
};

```

`cheat/src/base/types/pattern.h`:

```h
#pragma once

#include <array>

template<size_t len>
struct string_literal {
    size_t length = len - 1;
    std::array<char, len - 1> value{ };

    consteval string_literal(const char(&str)[len])
    {
        for (size_t i{ }; i < len - 1; i++)
            value[i] = str[i];
    }
};

static consteval bool is_hex_char(char c)
{
    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F');
}

static consteval int hex_char_to_int(char c)
{
    return (c > '9') ? (c & ~0x20) - 'A' + 10 : (c - '0');
}

static consteval int make_hex_digits(char a, char b)
{
    return 16 * hex_char_to_int(a) + hex_char_to_int(b);
}

template<string_literal str>
struct pattern {
    struct length_t {
        static consteval auto get()
        {
            size_t ret{ };
            bool was_digit{ };

            for (size_t i{ }; i < str.length; i++) {
                if (is_hex_char(str.value[i])) {
                    if (!was_digit)
                        ret++;
                    was_digit = true;
                } else if (str.value[i] == '?') {
                    ret++;
                    was_digit = false;
                } else if (str.value[i] == ' ')
                    was_digit = false;

            }
            return ret;
        }
    };

    static consteval auto value()
    {
        constexpr auto len = length_t::get();
        static_assert(len > 0);
        std::array<int, len> ret{ };

        for (size_t i{ }, j{ }; i < str.length; i++) {
            if (str.value[i] == ' ')
                continue;
            if (is_hex_char(str.value[i])) {
                i++;
                if (j < len) {
                    if (is_hex_char(str.value[i]))
                        ret[j++] = make_hex_digits(str.value[i - 1], str.value[i]);
                }
            } else if (str.value[i] == '?')
                ret[j++] = -1;
        }
        return ret;
    }
};

#define PATTERN(str) pattern<str>::value()

```

`cheat/src/base/types/vector.h`:

```h
#pragma once
#include <imgui.h>

struct vec2 {
    float x{ }, y{ };

    constexpr vec2() noexcept = default;
    constexpr vec2(float x, float y) noexcept
        : x(x), y(y) { }
    constexpr vec2(ImVec2 v) noexcept
        : x(v.x), y(v.y) { }
};

struct vec3 {
    float x{ }, y{ }, z{ };

    constexpr vec3() noexcept = default;
    constexpr vec3(float x, float y, float z) noexcept
        : x(x), y(y), z(z) { }

    bool operator==(const vec3& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) <= std::numeric_limits<float>::epsilon() &&
            std::abs(y - rhs.y) <= std::numeric_limits<float>::epsilon() &&
            std::abs(z - rhs.z) <= std::numeric_limits<float>::epsilon());
    }

    bool operator!=(const vec3& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) > std::numeric_limits<float>::epsilon() ||
            std::abs(y - rhs.y) > std::numeric_limits<float>::epsilon() ||
            std::abs(z - rhs.z) > std::numeric_limits<float>::epsilon());
    }

    constexpr vec3 operator+(const vec3& rhs) const noexcept
    {
        return vec3(x + rhs.x, y + rhs.y, z + rhs.z);
    }

    constexpr vec3 operator-(const vec3& rhs) const noexcept
    {
        return vec3(x - rhs.x, y - rhs.y, z - rhs.z);
    }

    constexpr vec3 operator*(const vec3& rhs) const noexcept
    {
        return vec3(x * rhs.x, y * rhs.y, z * rhs.z);
    }

    constexpr vec3 operator/(const vec3& rhs) const noexcept
    {
        return vec3(x / rhs.x, y / rhs.y, z / rhs.z);
    }

    constexpr vec3 operator+(const float rhs) const noexcept
    {
        return vec3(x + rhs, y + rhs, z + rhs);
    }

    constexpr vec3 operator-(const float rhs) const noexcept
    {
        return vec3(x - rhs, y - rhs, z - rhs);
    }

    constexpr vec3 operator*(const float rhs) const noexcept
    {
        return vec3(x * rhs, y * rhs, z * rhs);
    }

    constexpr vec3 operator/(const float rhs) const noexcept
    {
        return vec3(x / rhs, y / rhs, z / rhs);
    }

    constexpr vec3& operator=(const vec3& rhs) noexcept
    {
        x = rhs.x;
        y = rhs.y;
        z = rhs.z;
        return *this;
    }

    constexpr vec3& operator+=(const vec3& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

    constexpr vec3& operator-=(const vec3& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

    constexpr vec3& operator*=(const vec3& rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        z *= rhs.z;
        return *this;
    }

    constexpr vec3& operator/=(const vec3& rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        z /= rhs.z;
        return *this;
    }

    constexpr vec3& operator+=(const float rhs) noexcept
    {
        x += rhs;
        y += rhs;
        z += rhs;
        return *this;
    }

    constexpr vec3& operator-=(const float rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        z -= rhs;
        return *this;
    }

    constexpr vec3& operator*=(const float rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        z *= rhs;
        return *this;
    }

    constexpr vec3& operator/=(const float rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        z /= rhs;
        return *this;
    }

    constexpr void inverse() noexcept
    {
        x = -x;
        y = -y;
        z = -z;
    }

    constexpr void clear() noexcept
    {
        x = { };
        y = { };
        z = { };
    }

    float length_sqr() const noexcept
    {
        return dot_product(*this);
    }

    float length() const noexcept
    {
        return sqrtf(length_sqr());
    }

    float length2d_sqr() const noexcept
    {
        return (x * x + y * y);
    }

    float length2d() const noexcept
    {
        return sqrtf(length2d_sqr());
    }

    float distance_to(const vec3& other) const noexcept
    {
        return (*this - other).length();
    }

    float dot_product(const vec3& v) const noexcept
    {
        return (x * v.x + y * v.y + z * v.z);
    }

    vec3 cross_product(const vec3& v) const noexcept
    {
        return vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);
    }

    vec3 transform(const mat3x4& mat) noexcept
    {
        return vec3(dot_product({ mat[0][0], mat[0][1], mat[0][2] }) + mat[0][3],
          dot_product({ mat[1][0], mat[1][1], mat[1][2] }) + mat[1][3],
          dot_product({ mat[2][0], mat[2][1], mat[2][2] }) + mat[2][3]);
    }

    void normalize() noexcept
    {
        *this /= length();
    }

    auto to_vec2() const noexcept
    {
        return vec2(x, y);
    }
};

struct vec4 {
    float x{ }, y{ }, z{ }, w{ };
};

#include <format>

template<>
struct std::formatter<vec2> : std::formatter<std::string> {
    auto format(vec2 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}]", v.x, v.y), ctx);
    }
};

template<>
struct std::formatter<vec3> : std::formatter<std::string> {
    auto format(vec3 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}]", v.x, v.y, v.z), ctx);
    }
};

template<>
struct std::formatter<vec4> : std::formatter<std::string> {
    auto format(vec4 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}, {}]", v.x, v.y, v.z, v.w), ctx);
    }
};

```

`cheat/src/base/winapi.h`:

```h
#pragma once

#include "base.h"
#include <filesystem>
namespace fs = std::filesystem;
#include <string_view>
#include <Windows.h>
#include <TlHelp32.h>

struct dll;

namespace win {

    // Only usable for handles closed via CloseHandle()!
    struct scoped_handle {
        HANDLE handle{ };

        scoped_handle(HANDLE handle) noexcept
            : handle(handle) { }
        ~scoped_handle()
        {
            if (handle)
                CloseHandle(handle);
        }

        operator bool() noexcept
        {
            return handle != nullptr && handle != INVALID_HANDLE_VALUE;
        }

        operator HANDLE() noexcept
        {
            return handle;
        }
    };

}

```

`cheat/src/core/cheat.cpp`:

```cpp
#include "cheat.h"
#include "../render/menu.h"
#include "../valve/cs/cs.h"

LONG CALLBACK veh_handler(EXCEPTION_POINTERS* ExceptionInfo) {
	auto exception_code = ExceptionInfo->ExceptionRecord->ExceptionCode;
	auto exception_info0 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
	auto exception_info1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[1];

    if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
        // DEP Violation
        if (exception_info0 == 8) {
            // ignore DEP violation above 0x7FFFFFFEFFFF
            if (exception_info1 >= 0x7FFFFFFEFFFF)
                return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

	return EXCEPTION_CONTINUE_SEARCH;
}

void cheat::initialize(uintptr_t base) noexcept {
    dlls::initialize();
    logger::initialize(XOR("BakaWare"));
    dlls::add_to_trusted_list(base);
    memory::erase_pe_headers(base);
    interfaces::initialize();
    cheat::update_global_vars();
    render::initialize();
    input::initialize(menu::is_open);
    hooks::initialize();
    // cfg::initialize();

    // bypass DEP if mapped above 0x7FFFFFFEFFFF
    if (base >= 0x7FFFFFFEFFFF) {
        PVOID handle = AddVectoredExceptionHandler(FALSE, veh_handler);
        LOG_INFO(XOR("BEP bypass handler at: {}"), handle);
    }

    LOG_ERROR(XOR("BakaWare initialized. Base: {} Last full build: {} {}"), (void*)base, __DATE__, __TIME__);
}

DWORD cheat::end(LPVOID instance) noexcept {
    input::unlock_cursor(false);
    hooks::end();
    logger::end();

    // FreeLibraryAndExitThread(static_cast<HMODULE>(instance), EXIT_SUCCESS);
    return EXIT_SUCCESS;
}

void cheat::update_global_vars() noexcept {
    SIG(globals_ptr, dlls::client, "48 89 15 ? ? ? ? 48 8D 05 ? ? ? ? 48 85")
    auto global_vars = globals_ptr.absolute<se::global_vars**>(0x3);
    if (cheat::global_vars != *global_vars) {
        cheat::global_vars = *global_vars;
        LOG_INFO(XOR("Global vars updated: {}"), (void*)cheat::global_vars);
    }
}

void cheat::local_player::update() noexcept {
    controller = cs::get_local_player_controller();
    if (!controller) {
        pawn = nullptr;
        return;
    }
    pawn = controller->m_hPawn().get_as<cs::player_pawn>();
}

void cheat::local_player::reset() noexcept {
    controller = nullptr;
    pawn = nullptr;
}

```

`cheat/src/core/cheat.h`:

```h
#pragma once

#include "../memory/interfaces.h"
#include "../memory/hook_mgr.h"
#include "../render/render.h"
#include "input.h"
#include "config.h"

namespace cheat {

    struct local_player {
        cs::player_controller* controller;
        cs::player_pawn* pawn;

        auto operator->() noexcept { return pawn; }
        operator bool() noexcept { return pawn; }
        operator cs::player_pawn*() noexcept { return pawn; }


        void update() noexcept;
        void reset() noexcept;

        inline bool valid() noexcept { 
            return pawn && pawn->m_lifeState() == cs::life_state::LIFE_ALIVE;
        }

        inline bool void_move_type() noexcept {
            if (!pawn)
                return false;
            const auto move_type = pawn->m_MoveType();
            return move_type != cs::move_type::MOVETYPE_NOCLIP
                && move_type != cs::move_type::MOVETYPE_LADDER;
        }
    };

    inline local_player local{ };
    inline bool should_unhook{ };
    inline d2 screen_size{ };
    inline se::global_vars* global_vars{ };

    void initialize(uintptr_t base) noexcept;
    DWORD end(LPVOID instance) noexcept;
    void update_global_vars() noexcept;

}

```

`cheat/src/core/config.cpp`:

```cpp
#include "config.h"
#include "../base/base.h"

using json = nlohmann::json;

void config::load(std::wstring_view file) noexcept {}

void config::save(std::wstring_view file) noexcept {
    json j = cfg;
    LOG_INFO(XOR("config: {}"), j.dump(2));
}

```

`cheat/src/core/config.h`:

```h
#pragma once

#include <nlohmann/json.hpp>

namespace config {

class esp;

class player_visuals {
public:
    bool enabled{ true };
    bool teammates{ false };
    bool health{ true };
    bool box{ true };
    bool name{ true };
    // bool weapon{ true };
    bool skeleton{ true };
    // bool ammo{ true };

    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(
        player_visuals, enabled, box, name, health, skeleton
    )
};

class esp_config {
public:
    player_visuals players{ };
    // visuals weapons{ };
    // visuals grenades{ };

    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(
        esp_config, players
    )
};

class misc_config {
public:
    bool reoil_crosshair { true };
    bool bunny_hop { true };

    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(
        misc_config, reoil_crosshair, bunny_hop
    )
};

class conf {
public:
    esp_config esp{ };
    misc_config misc{ };

    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(
        conf, esp, misc
    )
};

void load(std::wstring_view file) noexcept;
void save(std::wstring_view file) noexcept;

}

inline config::conf cfg{ };
```

`cheat/src/core/features/esp.cpp`:

```cpp
#include "features.h"

void render_box(render::renderer* r, const bbox& bb, const clr4& clr) {
    r->rect(
        bb.x, bb.y, 
        bb.w, bb.h, 
        clr4::black(128),
        3
    );
    r->rect(
        bb.x, bb.y, 
        bb.w, bb.h, 
        clr
    );
}

void render_health(render::renderer* r, const bbox& bb, const uint32_t heath) {
    // TODO: hp color config
    const clr4 top_clr = clr4::green(220);
    const clr4 bot_clr = clr4::red(220);

    const float hp = heath / 100.f;
    const clr4 hp_clr = clr4::lerp(bot_clr, top_clr, hp);
    const float hp_h = std::floor(std::lerp(bb.h, bb.y, hp));

    r->rect_filled(
        bb.x - 6, bb.y - 1, 
        bb.x - 2, bb.h + 1, 
        clr4::black(128)
    );
    r->rect_filled_multi_color(
        bb.x - 5, hp_h, 
        bb.x - 3, bb.h, 
        hp_clr, hp_clr,
        bot_clr, bot_clr
    );
}

void render_name(render::renderer* r, const bbox& bb, const char* name, const clr4& clr) {
    if (!name || !strlen(name))
        return;

    const auto name_size = r->calc_text_size(name).x;
    r->text(
        bb.center_x() - (name_size / 2),
        bb.y - 16,
        clr,
        name
    );
}

bool render_skeleton(render::renderer* r, cs::base_entity* controller, const clr4& clr, bool render, bbox& bb, float padding = 0.f) {
    auto game_scene_node = controller->m_pGameSceneNode();
    if (!game_scene_node)
        return false;

    auto skeleton = game_scene_node->get_skeleton_instance();
    if (!skeleton)
        return false;

    // do this first so we don't have to check every bone if the origin is offscreen
    auto& origin = game_scene_node->m_vecAbsOrigin();
    auto origin2 = origin + vec3(0, 0, 32);
    vec2 origin_scr, origin2_scr;
    if (!math::world_to_screen(origin, origin_scr) || !math::world_to_screen(origin2, origin2_scr))
        return false;

    skeleton->calc_world_space_bones(cs::bone_flags::FLAG_HITBOX);

    auto& model_state = skeleton->m_modelState();
    cs::model* model = model_state.m_hModel();
    const auto num_bones = model->num_bones();
    auto bones = model_state.get_bone_data();

    std::vector<vec2> bone_scrs;
    bone_scrs.reserve(num_bones * 2);

    for (uint32_t i = 0; i < num_bones; i++) {
        if (!(model->bone_flags(i) & cs::bone_flags::FLAG_HITBOX)) {
            continue;
        }

        auto parent_index = model->bone_parent(i);
        if (parent_index == -1)
            continue;

        vec2 start_scr, end_scr;
        if (!math::world_to_screen(bones[i].pos, start_scr) || !math::world_to_screen(bones[parent_index].pos, end_scr))
            continue;

        bone_scrs.push_back(start_scr);
        bone_scrs.push_back(end_scr);

        if (render) {
            r->line(
                start_scr.x, start_scr.y,
                end_scr.x, end_scr.y,
                clr, 1
            );
        }
    }

    bb.x = bb.y = std::numeric_limits<float>::max();
    bb.w = bb.h = -std::numeric_limits<float>::max();

    if (bone_scrs.empty())
        return false;

    for (const auto& pos : bone_scrs) {
        bb.x = std::min(bb.x, pos.x);
        bb.y = std::min(bb.y, pos.y);
        bb.w = std::max(bb.w, pos.x);
        bb.h = std::max(bb.h, pos.y);
    }

    bb.x = std::floor(bb.x);
    bb.y = std::floor(bb.y);
    bb.w = std::floor(bb.w);
    bb.h = std::floor(bb.h);

    const float scale = std::abs(origin_scr.y - origin2_scr.y) / 32.f;
    bb.x -= std::floor(scale * padding);
    bb.y -= std::floor(scale * padding);
    bb.w += std::floor(scale * padding);
    bb.h += std::floor(scale * padding);

    return true;
}

void features::esp::render(render::renderer* r) noexcept {
    // FIXME: other types of esp
    if (cfg.esp.players.enabled == false)
        return;

    if (!interfaces::engine->is_valid())
        return;

    for (uint32_t i = 1; i < cheat::global_vars->max_clients; i++) {
        auto controller = interfaces::entity_list->get_base_entity<cs::player_controller*>(i);
        if (!controller || controller->m_bIsLocalPlayerController() || !controller->m_bPawnIsAlive())
            continue;
        
        auto player = controller->m_hPawn().get_as<cs::player_pawn>();
        if (!player)
            continue;
        
        if (cheat::local && !cheat::local->is_enemy(player) && !cfg.esp.players.teammates)
            continue;

        bbox bb;
        if (!render_skeleton(r, player, clr4::white(220), cfg.esp.players.skeleton, bb, 8)) // TODO: skeleton color config
            continue;

        if (cfg.esp.players.box)
            render_box(r, bb, clr4::white(220)); // TODO: box color config

        if (cfg.esp.players.health)
            render_health(r, bb, std::min(controller->m_iPawnHealth(), 100u));

        if (cfg.esp.players.name) {
            std::string name(controller->m_sSanitizedPlayerName());
            if (controller->has_flag(cs::flags::fl_fakeclient))
                name.insert(0, "BOT ");
            render_name(r, bb, name.c_str(), clr4::white(220)); // TODO: text color config
        }
    }
}
```

`cheat/src/core/features/features.h`:

```h
#pragma once

#include "../../base/base.h"
#include "../../base/math.h"
#include "../../memory/memory.h"
#include "../../memory/interfaces.h"
#include "../../render/render.h"
#include "../../core/cheat.h"

namespace features {

    namespace esp {
        void render(render::renderer* r) noexcept;
    }

    namespace misc {
        void render(render::renderer* r) noexcept;
        void run(se::user_cmd* cmd) noexcept;
    }

    inline void render(render::renderer* r) noexcept {
        esp::render(r);
        misc::render(r);
    }

    inline void run(se::user_cmd* cmd) noexcept {
        misc::run(cmd);
    }

}

```

`cheat/src/core/features/misc.cpp`:

```cpp
#include "features.h"

void render_recoil_crosshair(render::renderer* r) noexcept {
    // FIXME: local player
}

void run_bunny_hop(se::user_cmd* cmd) noexcept {
    if (!cheat::local.valid() || !cheat::local.void_move_type())
        return;
    
    if (!cheat::local->has_flag(cs::flags::fl_onground))
        cmd->buttons &= ~se::buttons::in_jump;
}

void features::misc::render(render::renderer* r) noexcept {
    if (!interfaces::engine->is_valid())
        return;

    if (cfg.misc.reoil_crosshair)
        render_recoil_crosshair(r);
}

void features::misc::run(se::user_cmd *cmd) noexcept {
    if (cfg.misc.bunny_hop)
        run_bunny_hop(cmd);
}

```

`cheat/src/core/hooks.cpp`:

```cpp
#include "hooks.h"
#include "../memory/interfaces.h"
#include "../memory/hook_mgr.h"
#include "../core/hooks.h"
#include "../render/render.h"

void hooks::initialize() noexcept
{
    if (render::game_window)
        original_wnd_proc = reinterpret_cast<WNDPROC>(SetWindowLongPtr(render::game_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wnd_proc)));
    else
        LOG_ERROR(XOR("Failed to hook window proc, game window HWND missing!"));

    // hook_func = dlls::cs2.find(PATTERN("48 8B C4 48 89 58 08 48 89 70 10 57")).cast<decltype(hook_func)>();
    // unhook_func = dlls::cs2.find(PATTERN("48 85 C9 0F 84 94")).cast<decltype(unhook_func)>();

    auto present_ptr = dlls::game_overlay_renderer64.find(PATTERN("48 FF 25 ? ? ? ? 48 89 5C 24 30")).absolute<void**>(0x3);
    auto resize_buffers_ptr = dlls::game_overlay_renderer64.find(PATTERN("48 83 C4 30 41 5F 41 5E 5F 48 FF 25")).absolute<void**>(0xC);

    SET_PTR_HOOK(present_ptr, present);
    SET_PTR_HOOK(resize_buffers_ptr, resize_buffers);

    SET_VT_HOOK(interfaces::csgo_input, mouse_input_enabled, 10);
    SET_VT_HOOK(interfaces::csgo_input, create_move, 5);
    SET_VT_HOOK(interfaces::client_mode, level_init, 23);
    SET_VT_HOOK(interfaces::client_mode, level_shutdown, 24);

    LOG_INFO(XOR("Hooks initialized."));
}

void hooks::end() noexcept {
    for (auto a : interfaces::hooked_tables)
        static_cast<interface_holder<void*>*>(a)->restore();

    // for (auto& a : hooked_fns)
    //     unhook_func(a.second);

    for (auto& a : hooked_ptrs)
        *a.first = a.second;

    if (original_wnd_proc && render::game_window)
        SetWindowLongPtr(render::game_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(original_wnd_proc));
}

```

`cheat/src/core/hooks.h`:

```h
#pragma once

#include "../base/base.h"
#include <Windows.h>
#include <d3d11.h>

// #include "../valve/cs/cs.h"
#include "../valve/se/se.h"

#define DECLARE_HOOK(name, ret, base, ... /* args */) namespace name { \
using ty = ret(__thiscall*)(base* ecx, __VA_ARGS__); \
inline ty original; \
ret WINAPI fn(base* ecx, __VA_ARGS__); \
}

#define DECLARE_PROXY(name, prop_name) namespace name { \
inline cs::recv_proxy_fn original{ }; \
void proxy(cs::recv_proxy_data* data, void*, void*); \
}

namespace hooks {

    inline WNDPROC original_wnd_proc{ };

    extern LRESULT CALLBACK wnd_proc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam);
    DECLARE_HOOK(present, HRESULT, IDXGISwapChain, UINT, UINT);
    DECLARE_HOOK(resize_buffers, HRESULT, IDXGISwapChain, UINT, UINT, UINT, DXGI_FORMAT, UINT);
    DECLARE_HOOK(mouse_input_enabled, bool, se::csgo_input);
    DECLARE_HOOK(create_move, bool, se::csgo_input, uint32_t, uint8_t);
    DECLARE_HOOK(level_init, void, se::client_mode, const char*);
    DECLARE_HOOK(level_shutdown, void, se::client_mode);
    

    // DECLARE_HOOK(level_init_post_entity, void, se::client_dll)
    // DECLARE_HOOK(level_shutdown, void, se::client_dll)
    // DECLARE_HOOK(create_move_proxy, void, se::client_dll, int, float, bool)
    // DECLARE_HOOK(frame_stage_notify, void, se::client_dll, cs::frame_stage)
    // DECLARE_HOOK(override_view, void, se::client_mode, cs::view_setup*)
    // DECLARE_HOOK(get_viewmodel_fov, float, se::client_mode)
    // DECLARE_HOOK(on_add_entity, void, se::entity_list, cs::handle_entity*, cs::base_handle)
    // DECLARE_HOOK(on_remove_entity, void, se::entity_list, cs::handle_entity*, cs::base_handle)
    // DECLARE_HOOK(fire_event_intern, bool, se::event_manager, cs::game_event*, bool, bool)
    // DECLARE_HOOK(draw_model, void, se::studio_render, cs::draw_model_results*,
    //     const cs::draw_model_info&, mat3x4*, float*, float*, const vec3&, int)
    // DECLARE_HOOK(lock_cursor, void, se::surface)
    // DECLARE_HOOK(paint, void, se::vgui, cs::paint_mode)

    // DECLARE_PROXY(spotted, "CBaseEntity->m_bSpotted")

}

#undef DECLARE_HOOK
#undef DECLARE_PROXY

```

`cheat/src/core/hooks/client_dll.cpp`:

```cpp
#include "../hooks.h"
#include "../../core/input.h"
#include "../../core/cheat.h"
#include "../../core/features/features.h"

bool __fastcall hooks::mouse_input_enabled::fn(se::csgo_input* rcx) {
    if (input::cursor_unlocked)
        return false;

    return original(rcx);
}

bool __fastcall hooks::create_move::fn(se::csgo_input* cs_input, uint32_t split_screen_index, uint8_t a3) {
    bool ret = original(cs_input, split_screen_index, a3);

    cheat::local.update();

    auto user_cmd = cs_input->get_user_cmd(split_screen_index);
    if (!user_cmd)
        return ret;

    features::run(user_cmd);

    return ret;
}
```

`cheat/src/core/hooks/client_mode.cpp`:

```cpp
#include "../hooks.h"
#include "../../core/cheat.h"

void __stdcall hooks::level_init::fn(se::client_mode* rcx, const char* newmap) {
    cheat::update_global_vars();
    original(rcx, newmap);
}

void __stdcall hooks::level_shutdown::fn(se::client_mode* rcx) {
    cheat::local.reset();
    original(rcx);
}
```

`cheat/src/core/hooks/d3d11.cpp`:

```cpp
#include "../hooks.h"
#include "../../render/render.h"
#include "../../core/cheat.h"

HRESULT WINAPI hooks::present::fn(IDXGISwapChain *swap_chain, UINT SyncInterval, UINT Flags) {
    if (cheat::should_unhook)
        return original(swap_chain, SyncInterval, Flags);
    
    if (!render::render_target_view)
        render::set_swap_chain(swap_chain);

    render::render();

    return original(swap_chain, SyncInterval, Flags);
}

HRESULT WINAPI hooks::resize_buffers::fn(IDXGISwapChain *swap_chain, UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags) {
    if (!cheat::should_unhook)
        render::cleanup_render_target();

    return original(swap_chain, BufferCount, Width, Height, NewFormat, SwapChainFlags);
}

```

`cheat/src/core/hooks/wnd_proc.cpp`:

```cpp
#include "../hooks.h"
#include "../cheat.h"
#include "../../core/input.h"
#include "../../render/menu.h"

LRESULT CALLBACK hooks::wnd_proc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam) {
    input::process(msg, wparam, lparam);

    if (input::is_key_active({ VK_INSERT, input::key_type::toggle })) {
        menu::toggle();
    }

    if (render::input(wnd, msg, wparam, lparam))
        return 1;

    return CallWindowProcA(original_wnd_proc, wnd, msg, wparam, lparam);
}

```

`cheat/src/core/input.cpp`:

```cpp
#include "input.h"
#include "../memory/interfaces.h"
#include "cheat.h"
#include <windowsx.h>

void input::initialize(bool unlock) noexcept
{
    input_context = interfaces::input_stack_system->find_input_context(XOR("Mouse Control"));
    if (!input_context) {
        LOG_ERROR(XOR("Failed to find \"Mouse Control\" input context."));
        return;
    }

    last_mouse_enabled = input_context->enabled;
    LOG_INFO(XOR("Input initialized. last_mouse_enabled = {}"), last_mouse_enabled);

    if (unlock)
        unlock_cursor(true);
}

void input::unlock_cursor(bool unlock) noexcept
{
    if (!input_context) {
        LOG_ERROR(XOR("Failed to {} cursor, missing input context."), (unlock ? XOR("unlock") : XOR("lock")));
        cursor_unlocked = unlock;
        return;
    }

    // we already are in the desired state
    if (unlock == cursor_unlocked)
        return;

    if (cursor_unlocked = unlock) {
        // save game state
        last_mouse_enabled = input_context->enabled;
        if (!last_mouse_enabled) {
            interfaces::input_stack_system->set_mouse_capture(input_context, true);
            interfaces::csgo_input->set_cursor_pos(cheat::screen_size.x / 2, cheat::screen_size.y / 2);
        }
    } else {
        // restore game state when unlocking
        interfaces::input_stack_system->set_mouse_capture(input_context, last_mouse_enabled);
    }
}

bool input::is_key_active(keybind key) noexcept
{
    switch (key.type) {
    case key_type::always:
        return true;
    case key_type::hold:
        return key_states[key.code] == key_state::down ||
               key_states[key.code] == key_state::toggled;
    case key_type::release:
        return key_states[key.code] == key_state::up;
    case key_type::toggle:
        if (key_states[key.code] == key_state::toggled) {
            key_states[key.code] = key_state::up;
            return true;
        }
        return false;
    case key_type::off:
    default:
        return false;
    }
}

bool input::is_hovering_item(d2 item_pos, d2 item_size) noexcept
{
    return (mouse_pos.x >= item_pos.x && mouse_pos.y >= item_pos.y &&
        mouse_pos.x <= item_pos.x + item_size.x && mouse_pos.y <= item_pos.y + item_size.y);
}

void input::process(UINT msg, WPARAM wparam, LPARAM lparam) noexcept
{
    uint64_t key{ };
    key_state state{ };
    static key_state last_state{ };

    switch (msg) {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        key = wparam;
        state = key_state::down;
        break;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        key = wparam;
        state = key_state::up;
        break;
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
        key = VK_LBUTTON;
        state = msg == WM_LBUTTONUP ? key_state::up : key_state::down;
        break;
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
        key = VK_RBUTTON;
        state = msg == WM_RBUTTONUP ? key_state::up : key_state::down;
        break;
    case WM_MOUSEMOVE:
        mouse_pos = { GET_X_LPARAM(lparam), GET_Y_LPARAM(lparam) };
        break;
    default:
        return;
    }

    // ignore invalid keys
    if (key >= 0xFF)
        return;

    // TODO: this is retarded, rework needed to handle edge cases.
    if (key_states[key] == key_state::up && state == key_state::down) {
        if (last_state == key_state::down)
            key_states[key] = key_state::down;
        else
            key_states[key] = key_state::toggled;
    }
    else
    	key_states[key] = state;

    last_state = state;
}

```

`cheat/src/core/input.h`:

```h
#pragma once

#include "../base/base.h"
#include "../valve/se/inputsystem.h"
#include <array>
#include <Windows.h>
#ifdef small
#undef small
#endif

#include "../base/types/dimension.h"

namespace input {

    enum class key_state {
        up,
        down,
        toggled
    };

    enum class key_type {
        off,
        always,
        hold,
        toggle,
        release
    };

    struct keybind {
        uint64_t code{ };
        key_type type{ };

        constexpr keybind() noexcept = default;
        constexpr keybind(uint64_t code, key_type type) noexcept
            : code(code), type(type) { }
    };

    inline se::input_context* input_context{ };
    inline std::array<key_state, 255u> key_states{ };
    inline d2 mouse_pos{ };
    inline bool last_mouse_enabled{ };
    inline bool cursor_unlocked{ };

    void initialize(bool unlock = false) noexcept;
    void unlock_cursor(bool enable) noexcept;
    bool is_key_active(keybind key) noexcept;
    bool is_hovering_item(d2 item_pos, d2 item_size) noexcept;
    void process(UINT msg, WPARAM wparam, LPARAM lparam) noexcept;

}

using input::keybind;

```

`cheat/src/core/main.cpp`:

```cpp
#include "cheat.h"

static DWORD WINAPI on_attach(LPVOID instance) noexcept
{
    cheat::initialize(reinterpret_cast<uintptr_t>(instance));

#ifdef _DEBUG
    while (!cheat::should_unhook)
        std::this_thread::sleep_for(100ms);

    cheat::end(instance);
#endif
    return TRUE;
}


BOOL APIENTRY DllMain(HMODULE instance, DWORD call_reason, LPVOID)
{
    if (call_reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(instance);
#ifdef _DEBUG
        if (const auto thread = CreateThread(nullptr, 0, on_attach, instance, 0, nullptr))
            CloseHandle(thread);
#else
        on_attach(instance);
#endif
    }

    return TRUE;
}

```

`cheat/src/crypt/fnv1a.h`:

```h
#pragma once

using hash_t = uint_fast32_t;

template<class ty>
concept string_like = requires(ty t) {
    t.data();
    t.substr();
};

inline namespace crypt {

    namespace fnv1a {

        constexpr hash_t basis = 0x811c9dc5;
        constexpr hash_t prime = 0x1000193;

        template<std::integral ch = char>
        constexpr hash_t hash(const ch* str) noexcept
        {
            const auto len = [str]() {
                size_t i{ };
                while (str[i])
                    i++;
                return i;
            }();

            auto hashed = basis;
            for (size_t i{ }; i < len; i++) {
                hashed ^= str[i];
                hashed *= prime;
            }
            return hashed;
        }

        template<string_like st = std::string_view>
        inline hash_t hash(const st& str) noexcept
        {
            return hash(str.data());
        }

        namespace literals {

            constexpr auto operator""_hash(const char* str, size_t len) noexcept
            {
                return hash(str);
            }

            constexpr auto operator""_hash(const wchar_t* str, size_t len) noexcept
            {
                return hash(str);
            }

        }

    }

}

using namespace fnv1a::literals;

```

`cheat/src/crypt/xorstr.h`:

```h
/*
 * Copyright 2017 - 2021 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#include <arm_neon.h>
#elif defined(_M_X64) || defined(__amd64__) || defined(_M_IX86) || defined(__i386__)
#include <immintrin.h>
#else
#error Unsupported platform
#endif

#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#ifndef _DEBUG
#define xorstr(str) ::jm::xor_string([]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define XOR(str) xorstr(str).crypt_get()
#else
#define xorstr(str) str
#define XOR(str) str
#endif

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

namespace jm {

    namespace detail {

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for(char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part  = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<std::size_t N, class CharT>
        XORSTR_FORCEINLINE constexpr std::uint64_t
        load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
        {
            using cast_type = typename std::make_unsigned<CharT>::type;
            constexpr auto value_size = sizeof(CharT);
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for(std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
                value ^=
                    (std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
                     << ((i % idx_offset) * 8 * value_size));

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm("" : "=r"(value) : "0"(value) :);
            return value;
#else
            volatile std::uint64_t reg = value;
            return reg;
#endif
        }

    } // namespace detail

    template<class CharT, std::size_t Size, class Keys, class Indices>
    class xor_string;

    template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
    class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
        constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);    
#else
        constexpr static inline std::uint64_t alignment = 16;
#endif

        alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

    public:
        using value_type    = CharT;
        using size_type     = std::size_t;
        using pointer       = CharT*;
        using const_pointer = const CharT*;

        template<class L>
        XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
            : _storage{ ::jm::detail::load_from_reg((std::integral_constant<std::uint64_t, detail::load_xored_str8<Size>(Keys, Indices, l())>::value))... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return Size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
            // everything is inlined by hand because a certain compiler with a certain linker is _very_ slow
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ ::jm::detail::load_from_reg(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)::jm::detail::load_from_reg((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ ::jm::detail::load_from_reg(Keys)... };
#endif

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#if defined(__clang__)
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : __builtin_neon_vst1q_v(
                                    reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                                    veorq_u64(__builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2, 51),
                                              __builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(keys) + Indices * 2, 51)),
                                    51)), ...);
#else // GCC, MSVC
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : vst1q_u64(
                        reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                        veorq_u64(vld1q_u64(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2),
                                  vld1q_u64(reinterpret_cast<const uint64_t*>(keys) + Indices * 2)))), ...);
#endif
#elif !defined(JM_XORSTR_DISABLE_AVX_INTRINSICS)
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast<pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            // crypt() is inlined by hand because a certain compiler with a certain linker is _very_ slow
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ ::jm::detail::load_from_reg(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)::jm::detail::load_from_reg((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ ::jm::detail::load_from_reg(Keys)... };
#endif

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#if defined(__clang__)
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : __builtin_neon_vst1q_v(
                                    reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                                    veorq_u64(__builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2, 51),
                                              __builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(keys) + Indices * 2, 51)),
                                    51)), ...);
#else // GCC, MSVC
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : vst1q_u64(
                        reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                        veorq_u64(vld1q_u64(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2),
                                  vld1q_u64(reinterpret_cast<const uint64_t*>(keys) + Indices * 2)))), ...);
#endif
#elif !defined(JM_XORSTR_DISABLE_AVX_INTRINSICS)
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif

            return (pointer)(_storage);
        }
    };

    template<class L, std::size_t Size, std::size_t... Indices>
    xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) -> xor_string<
                std::remove_const_t<std::remove_reference_t<decltype(l()[0])>>,
                Size,
                std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
                std::index_sequence<Indices...>>;

} // namespace jm

#endif // include guard

```

`cheat/src/memory/address.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include "../base/debug.h"

struct address {
    uintptr_t value{ };

    address() = default;
    address(uintptr_t value) noexcept
        : value(value) { }
    address(uintptr_t* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(uint8_t* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(void* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(std::nullptr_t value) noexcept
        : value(0) { }

    operator bool() const noexcept { return value != 0; }
    operator void*() noexcept { return reinterpret_cast<void*>(value); }

    template<class ty>
    constexpr ty cast() noexcept
    {
        ASSERT(value != 0);
        return reinterpret_cast<ty>(value);
    }

    constexpr address& offset(ptrdiff_t offset) noexcept
    {
        value += offset;
        return *this;
    }

    template<class ty>
    ty& dereference() noexcept
    {
        ASSERT(value != 0);
        return *reinterpret_cast<ty*>(value);
    }

    template<class ty>
    ty absolute(ptrdiff_t rel_offset = 0x1, ptrdiff_t abs_offset = 0x0) noexcept
    {
        ASSERT(value != 0);
        const auto jmp = value + rel_offset;
        const auto target = *reinterpret_cast<int32_t*>(jmp);
        if (target)
            // Base address + offset + size of next instruction + target address.
            return reinterpret_cast<ty>(jmp + abs_offset + sizeof(int32_t) + target);
        return ty();
    }
};

```

`cheat/src/memory/dll.cpp`:

```cpp
#include "dll.h"

address dll::get_export(hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return address();

    const auto optional_hdr = &nt_hdrs->OptionalHeader;
    const auto dir_addr = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(
        base + optional_hdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    const auto functions = reinterpret_cast<uint32_t*>(base + dir_addr->AddressOfFunctions);
    const auto names = reinterpret_cast<uint32_t*>(base + dir_addr->AddressOfNames);
    const auto ordinals = reinterpret_cast<uint16_t*>(base + dir_addr->AddressOfNameOrdinals);

    for (DWORD i{ }; i < dir_addr->NumberOfFunctions; i++) {
        const auto name = reinterpret_cast<const char*>(base + names[i]);
        if (fnv1a::hash(name) == hash)
            return address(base + functions[ordinals[i]]);
    }

    return address();
}

address dll::get_import(const dll& from, hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return address();

    const auto optional_hdr = &nt_hdrs->OptionalHeader;
    auto import_desc = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
        base + optional_hdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    while (import_desc->Name) {
        auto cur_dll = reinterpret_cast<char*>(base) + import_desc->Name;
        if (!from.name.compare(cur_dll)) {
            auto thunk_data = reinterpret_cast<IMAGE_THUNK_DATA*>(base + import_desc->OriginalFirstThunk);
            for (int i = 0; thunk_data->u1.Function; i++, thunk_data++) {
                char* cur_fn = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(base + thunk_data->u1.AddressOfData)->Name;
                if (fnv1a::hash(cur_fn) == hash) {
                    auto table = reinterpret_cast<uintptr_t*>(base + import_desc->FirstThunk);
                    return address(table[i]);
                }
            }
            return address();
        }
        import_desc++;
    }

    return address();
}

IMAGE_SECTION_HEADER* dll::get_section(hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return nullptr;

    auto section = IMAGE_FIRST_SECTION(nt_hdrs);
    if (!section)
        return nullptr;

    for (WORD i{ }; i <= nt_hdrs->FileHeader.NumberOfSections; i++, section++) {
        const auto name = reinterpret_cast<const char*>(section->Name);
        if (fnv1a::hash(name) == hash)
            return section;
    }

    return nullptr;
}

bool dll::is_within_section(address addr, hash_t section_hash) const noexcept
{
    auto section = get_section(section_hash);
    if (!section)
        return false;

    return is_within_section(addr, section);
}

bool dll::is_within_section(address addr, IMAGE_SECTION_HEADER* section) const noexcept
{
    if (!section)
        return false;

    const auto start = base + section->VirtualAddress;
    const auto end = start + section->SizeOfRawData;

    return addr.value >= start && addr.value < end;
}

void dlls::add_to_trusted_list(uintptr_t base) noexcept
{
    SIG(data_ptr, dlls::client, "48 8B 05 ? ? ? ? 49 8B F8 8B F2")
    auto data = *data_ptr.absolute<return_address_data**>(3);

    auto dos = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
    if (dos->e_magic != IMAGE_DOS_SIGNATURE) {
        LOG_ERROR(XOR("add_to_trusted_list: invalid DOS header"));
        return;
    }

    auto nt = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos->e_lfanew);
    if (nt->Signature != IMAGE_NT_SIGNATURE) {
        LOG_ERROR(XOR("add_to_trusted_list: invalid NT header"));
        return;
    }

    const auto index = data->whitelist.size / 2;
    if (index >= std::size(data->whitelist.modules)) {
        LOG_ERROR(XOR("add_to_trusted_list: whitelist is full"));
        return;
    }

    auto& module_data = data->whitelist.modules[index];
    module_data.start = base + nt->OptionalHeader.BaseOfCode;
    // yes, this will go past the end of the image, this is how valve does it as well /shrug
    module_data.end = module_data.start + nt->OptionalHeader.SizeOfImage;
    data->whitelist.size += 2;

    LOG_INFO(XOR("add_to_trusted_list: added {}-{} idx: {} to whitelist"), (void*)module_data.start, (void*)module_data.end, index);
}
```

`cheat/src/memory/dll.h`:

```h
#pragma once
#include "../base/base.h"

#include <unordered_map>
#include <Windows.h>
#include <winternl.h>

#include "../crypt/fnv1a.h"
#include "memory.h"

struct dll;
namespace dlls { inline std::vector<dll*> list; }

struct dll {
    std::string name{ };
    uintptr_t base{ };
    size_t size{ };
    address create_interface{ }; // Only relevant to game DLLs

    explicit dll(std::string_view name) noexcept
        : name(name)
    {
        dlls::list.push_back(this);
    }

    template<size_t len> requires(len > 0)
    address find(std::array<int, len>&& pattern) const noexcept
    {
        auto bytes = reinterpret_cast<uint8_t*>(base);
        for (size_t i{ }; i < size - len; i++) {
            for (size_t j{ }; j < len; j++) {
                if (bytes[i + j] != pattern[j] && pattern[j] != -1)
                    break;
                if (j + 1 == len)
                    return address(&bytes[i]);
            }
        }

        LOG_ERROR(XOR("{}: did not find pattern {}"), name, [&]()
        {
            /* Slow, but this only runs when something goes wrong. */
            std::stringstream ss{ };
            for (auto byte : pattern) {
                if (byte == -1)
                    ss << '?';
                else
                    ss << std::uppercase << std::hex << std::setfill('0') << std::setw(2) << byte;
                ss << ' ';
            }
            return ss.str();
        }());
        return address();
    }

    inline IMAGE_NT_HEADERS* get_nt_headers() const noexcept
    {
        auto dos = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
        if (dos->e_magic != IMAGE_DOS_SIGNATURE)
            return nullptr;

        auto nt = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos->e_lfanew);
        if (nt->Signature != IMAGE_NT_SIGNATURE)
            return nullptr;

        return nt;
    }

    address get_import(const dll& from, hash_t hash) const noexcept;
    address get_export(hash_t hash) const noexcept;
    IMAGE_SECTION_HEADER* get_section(hash_t hash) const noexcept;
    bool is_within_section(address addr, hash_t section_hash) const noexcept;
    bool is_within_section(address addr, IMAGE_SECTION_HEADER* section) const noexcept;

};

struct return_address_data {
    struct whitelist {
        struct module {
            uintptr_t start;
            uintptr_t end;
        } modules[80];
        int size;
    } whitelist;
    struct blacklist {
        uintptr_t addresses[32];
        int size;
    } blacklist;
};

static_assert(sizeof(return_address_data) == 0x610);

namespace dlls {

    inline dll cs2{ XOR("cs2.exe") };
    inline dll tier0{ XOR("tier0.dll") };
    inline dll sdl2{ XOR("SDL2.dll") };
    inline dll game_overlay_renderer64{ XOR("gameoverlayrenderer64.dll") };
    inline dll render_system_dx11{ XOR("rendersystemdx11.dll") };
    inline dll client{ XOR("client.dll") };
    inline dll engine2{ XOR("engine2.dll") };
    inline dll schemasystem{ XOR("schemasystem.dll") };
    inline dll input_system{ XOR("inputsystem.dll") };

    inline void initialize() noexcept
    {
        struct LDR_DATA_TABLE_ENTRY {
            LIST_ENTRY InLoadOrderLinks;
            LIST_ENTRY InMemoryOrderLinks;
            LIST_ENTRY InInitializationOrderLinks;
            PVOID DllBase;
            PVOID EntryPoint;
            ULONG SizeOfImage;
            UNICODE_STRING FullDllName;
            UNICODE_STRING BaseDllName;
        };

        std::unordered_map<hash_t, LDR_DATA_TABLE_ENTRY*> loaded{ };

        const auto peb = reinterpret_cast<const PEB*>(__readgsqword(0x60));
        auto cur = CONTAINING_RECORD(peb->Ldr->InMemoryOrderModuleList.Flink,
                                     LDR_DATA_TABLE_ENTRY,
                                     InMemoryOrderLinks);

        while (cur->BaseDllName.Length) {
            loaded.insert_or_assign(fnv1a::hash(cur->BaseDllName.Buffer), cur);
            cur = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(cur->InLoadOrderLinks.Flink);
        }

        for (auto entry : list) {
            const auto res = loaded.find(fnv1a::hash(entry->name));
            ASSERT_MSG(res != loaded.cend(), XOR("DLL not loaded yet?"));
            const auto dll = res->second;
            entry->base = reinterpret_cast<uintptr_t>(dll->DllBase);
            entry->size = dll->SizeOfImage;
        }
    }

    void add_to_trusted_list(uintptr_t base) noexcept;

};

```

`cheat/src/memory/hook_mgr.h`:

```h
#pragma once

#include <map>
#include "memory.h"
#include "../base/debug.h"

#define SET_SIG_HOOK(dll, sig, name) set(dll, PATTERN(sig), reinterpret_cast<void*>(name::fn), reinterpret_cast<void**>(&name::original))
#define SET_VT_HOOK(inter, name, index) set(inter, index, name::fn, name::original)
#define SET_PTR_HOOK(ptr, name) set(ptr, name::fn, name::original)

namespace hooks {

    //inline std::add_pointer_t<void* (void*, void*, bool)> hook_func{ };
    //inline std::add_pointer_t<void(void*)> unhook_func{ };

    //inline std::map<void*, void*> hooked_fns{ }; /* Only contains signature hooks */
    inline std::map<void**, void*> hooked_ptrs{ }; /* Only contains pointer hooks */

    void initialize() noexcept;
    void end() noexcept;

    template<class ty, class fn>
    void set(interface_holder<ty*>& vmt, int index, void* hook, fn& original) noexcept
    {
        ASSERT_MSG(vmt.replacement_vmt, XOR("Trying to set hook with replace_vmt = false!"));
        vmt.replacement_vmt[index + 1] = reinterpret_cast<uintptr_t>(hook);
        original = reinterpret_cast<fn>(vmt.real_vmt[index]);
    };

    template<class fn>
    void set(void** ptr, void* hook, fn& original) noexcept
    {
        hooked_ptrs[ptr] = *ptr;
        original = reinterpret_cast<fn>(*ptr);
        *ptr = hook;
    }

    // template<size_t len>
    // void set(dll& dll, std::array<int, len>&& sig, void* hook, void** original) noexcept
    // {
    //     auto target = dll.find<len>(std::move(sig));
    //     ASSERT(target);
    //     ASSERT(dll.is_within_section(target, ".text"_hash));
    //     hooked_fns[hook] = target;
    //     *original = hook_func(target, hook, false);
    //     if (!*original)
    //         LOG_ERROR(XOR("Error while hooking function!")); /* Not fatal, but we should warn about it */
    // };

}

```

`cheat/src/memory/interfaces.cpp`:

```cpp
#include "interfaces.h"
#include "dll.h"

static void collect_interfaces(dll& dll) noexcept;
template<class ty>
static void get_cached_interface(interface_holder<ty*>& ptr, std::string_view version_string) noexcept;

void interfaces::initialize() noexcept
{
    collect_interfaces(dlls::client);
    collect_interfaces(dlls::engine2);
    collect_interfaces(dlls::schemasystem);
    collect_interfaces(dlls::input_system);

    get_cached_interface(client, XOR("Source2Client002"));
    get_cached_interface(engine, XOR("Source2EngineToClient001"));
    get_cached_interface(game_resource, XOR("GameResourceServiceClientV001"));
    get_cached_interface(schema_system, XOR("SchemaSystem_001"));
    get_cached_interface(input_stack_system, XOR("InputStackSystemVersion001"));

    entity_list.initialize(game_resource->get_entity_list());
    csgo_input.initialize<true>(*dlls::client.find(PATTERN("48 8B 0D ? ? ? ? 48 8B 01 FF 50 ? 8B DF")).absolute<se::csgo_input**>(3));
    client_mode.initialize<true>(dlls::client.find(PATTERN("48 8D 0D ? ? ? ? 48 69 C0 ? ? ? ? 48 03 C1 C3 CC CC")).absolute<se::client_mode*>(3));

    LOG_INFO(XOR("Interfaces initialized."));
}

namespace se {

struct interface_reg {
    std::add_pointer_t<void*()> create_fn{ };
    const char* name{ };
    interface_reg* next{ };
};

}

static auto get_interface_regs(dll& dll) noexcept
{
    if (!dll.create_interface) {
        dll.create_interface = dll.get_export("CreateInterface"_hash);
        ASSERT(dll.create_interface);
    }

    // Follow jmp instruction inside function to get to CreateInterfaceInternal(), where the global interface list is moved into ESI.
    const auto reg_list = *dll.create_interface.absolute<se::interface_reg**>(0x3);
    ASSERT(reg_list);
    return reg_list;
}

static void collect_interfaces(dll& dll) noexcept
{
    for (auto cur = get_interface_regs(dll); cur; cur = cur->next) {
        LOG_INFO(XOR("{}: found interface: {}"), dll.name, cur->name);
        interfaces::list.push_back(std::make_pair(cur->name, cur->create_fn()));
    }
}

template<class ty>
static void get_cached_interface(interface_holder<ty*>& ptr, std::string_view version_string) noexcept
{
    for (const auto& [name, iface] : interfaces::list) {
        if (name.starts_with(version_string.data())) {
            ptr.template initialize<false>(static_cast<ty*>(iface));
            return;
        }
    }
}

```

`cheat/src/memory/interfaces.h`:

```h
#pragma once

#include "../valve/se/se.h"
#include "memory.h"

namespace interfaces {

    inline std::vector<void*> hooked_tables{ };
    inline std::vector<std::pair<std::string, void*>> list{ };

}

template<class ptr> requires std::is_pointer_v<ptr>
struct interface_holder {
    ptr instance{ };
    uintptr_t* real_vmt{ };
    std::unique_ptr<uintptr_t[]> replacement_vmt{ };

    constexpr ptr operator->() const noexcept { return instance; }
    constexpr void operator=(ptr rhs) noexcept { instance = rhs; }
    constexpr operator bool() const noexcept { return instance; }
    constexpr operator ptr() noexcept { return instance; }

    // Pass false to replace_vmt if you don't hook anything from the table or if get_vmt_length() is crashing
    template<bool replace_vmt = false>
    inline void initialize(ptr vptr) noexcept
    {
        ASSERT(vptr);
        constexpr int dynamic_cast_info_len = 1;

        instance = vptr;

        if constexpr (replace_vmt) {
            real_vmt = *reinterpret_cast<uintptr_t**>(instance);

            const auto len = memory::get_vmt_length(real_vmt) + dynamic_cast_info_len;
            replacement_vmt = std::make_unique<uintptr_t[]>(len);
            std::ranges::copy(real_vmt - dynamic_cast_info_len, real_vmt + len - dynamic_cast_info_len, replacement_vmt.get());

            *reinterpret_cast<uintptr_t**>(instance) = replacement_vmt.get() + dynamic_cast_info_len;

            interfaces::hooked_tables.push_back(this);
        }
    }

    inline void restore() noexcept
    {
        *reinterpret_cast<uintptr_t**>(instance) = real_vmt;
    }
};

namespace interfaces {

inline interface_holder<se::client_dll*>            client{ };
inline interface_holder<se::engine_client*>         engine{ };
inline interface_holder<se::game_resource_service*> game_resource{ };
inline interface_holder<se::entity_list*>           entity_list{ };
inline interface_holder<se::csgo_input*>            csgo_input{ };
inline interface_holder<se::schema_system*>         schema_system{ };
inline interface_holder<se::input_stack_system*>    input_stack_system{ };
inline interface_holder<se::client_mode*>           client_mode{ };

void initialize() noexcept;

}

```

`cheat/src/memory/memory.h`:

```h
#pragma once

#define CONCAT_IMPL(x, y) x##y
#define CONCAT(x, y) CONCAT_IMPL(x, y)
#define PAD(size) private: [[maybe_unused]] std::byte CONCAT(pad, __COUNTER__)[size]{ }; public:

#include <intrin.h>

#include "address.h"
#include "dll.h"
#include "netvars.h"

template<size_t len> requires(len > 0)
class signature {
private:
    std::mutex mtx { };
    bool found { };
    address addr { };
    dll &mod;
    std::array<int, len> pattern { };

    inline void find() noexcept {
        std::scoped_lock lock(mtx);
        if (found)
            return;

        addr = mod.find(std::move(pattern));
        found = true;
    }

public:
    signature(dll &mod, std::array<int, len> pattern) noexcept : mod(mod), pattern(pattern) { }

    inline address get() noexcept {
        if (!found)
            find();
        return addr;
    }
};

#define SIG(name, dll, sig) \
    static signature CONCAT(name, _static)(dll, PATTERN(sig)); \
    auto name = CONCAT(name, _static).get();

namespace memory {

    template<class ty, int i, class... va_args>
    ty call_virtual(void* base, va_args... args) noexcept
    {
        return (*static_cast<ty(__thiscall***)(void*, va_args...)>(base))[i](base, args...);
    }

    template<class ty = address>
    ty get_virtual(void* base, int index) noexcept
    {
        return (*static_cast<ty**>(base))[index];
    }

    inline address get_frame_address() noexcept
    {
        return address(reinterpret_cast<uintptr_t>(_AddressOfReturnAddress()) - sizeof(uintptr_t));
    }

    inline bool is_address_valid(address addr) noexcept
    {
        if (!addr)
            return false;

        MEMORY_BASIC_INFORMATION info{ };
        if (!VirtualQuery(addr, &info, sizeof(info)))
            return false;

        return info.State & MEM_COMMIT && !(info.Protect & PAGE_NOACCESS);
    }

    inline size_t get_vmt_length(uintptr_t* vptr) noexcept
    {
        size_t length{ };
        MEMORY_BASIC_INFORMATION info{ };

        while (VirtualQuery(reinterpret_cast<LPCVOID>(vptr[length]), &info, sizeof(info)) &&
               info.State & MEM_COMMIT &&
               info.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
            ++length;

        return length;
    }

    inline void erase_pe_headers(uintptr_t base) noexcept
    {
    #ifndef _DEBUG
        HMODULE mod;
        if (GetModuleHandleExA(
            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
            reinterpret_cast<LPCSTR>(base),
            &mod
        ) != 0) {
            LOG_ERROR(XOR("erase_pe_header: module is not manually mapped, ignoring"));
            return;
        }

        MEMORY_BASIC_INFORMATION info{ };
        if (!VirtualQuery(reinterpret_cast<LPCVOID>(base), &info, sizeof(info))) {
            LOG_ERROR(XOR("erase_pe_header: VirtualQuery failed"));
            return;
        }

        if ((info.Protect & (PAGE_READWRITE | PAGE_EXECUTE_READWRITE)) == 0) {
            LOG_ERROR(XOR("erase_pe_header: pe headers are not writable, ignoring"));
            return;
        }

        auto dos = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
        if (dos->e_magic != IMAGE_DOS_SIGNATURE) {
            LOG_ERROR(XOR("erase_pe_header: invalid DOS header"));
            return;
        }

        auto nt = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos->e_lfanew);
        if (nt->Signature != IMAGE_NT_SIGNATURE) {
            LOG_ERROR(XOR("erase_pe_header: invalid NT header"));
            return;
        }

        std::memset(reinterpret_cast<void*>(base), 0, nt->OptionalHeader.SizeOfHeaders);
    #endif
    }

}

#define VIRTUAL_FUNCTION(name, ret, idx, args, ... /* params */) \
inline ret name(__VA_ARGS__) noexcept \
{ \
    return memory::call_virtual<ret, idx>args; \
}

// Parameters and arguments are reversed, only way I could get this macro to work properly.
#define VIRTUAL_FUNCTION_SIG(name, ret, dll, sig, args, ... /* params */) \
inline ret name(__VA_ARGS__) noexcept \
{ \
    SIG(addr, dll, sig) \
    auto fn = addr.cast<ret(__thiscall*)(void*, __VA_ARGS__)>(); \
    return fn args; \
}

#define VIRTUAL_FUNCTION_SIG_ABSOLUTE(name, ret, dll, sig, offset, args, ... /* params */) \
inline ret name(__VA_ARGS__) noexcept \
{ \
    SIG(addr, dll, sig) \
    auto fn = addr.absolute<ret(__thiscall*)(void*, __VA_ARGS__)>(offset); \
    return fn args; \
}


```

`cheat/src/memory/netvars.cpp`:

```cpp
#include "netvars.h"
#include "interfaces.h"

using NetvarKeyValueMap_t = std::unordered_map<uint32_t, int16_t>;
using NetvarTableMap_t = std::unordered_map<uint32_t, NetvarKeyValueMap_t>;

static bool init_netvars_for_class(NetvarTableMap_t& table_map, const char* class_name, uint32_t class_key) noexcept {
    auto type = interfaces::schema_system->find_type_scope_for_module(XOR("client.dll"));
    if (!type) {
        LOG_ERROR(XOR("init_netvars_for_class: type scope not found for module client.dll"));
        return false;
    }

    auto class_info = type->find_declared_class(class_name);
    if (!class_info) {
        table_map.emplace(class_key, NetvarKeyValueMap_t{});
        LOG_ERROR(XOR("init_netvars_for_class: class {} not found"), class_name);
        return false;
    }

    auto size = class_info->size();
    auto field_data = class_info->get_field_data();

    auto& kv_Map = table_map[class_key];
    kv_Map.reserve(size);

    for (auto i = 0; i < size; i++) {
        auto& field = field_data[i];
        kv_Map.emplace(fnv1a::hash(field.name), field.offset);
    }

    return true;
}

uintptr_t netvars::get_offset(const char *class_name, uint32_t class_key, const char *member_name, uint32_t member_key) noexcept {
    static NetvarTableMap_t table_map;
    const auto& table_map_it = table_map.find(class_key);
    if (table_map_it == table_map.cend()) {
        init_netvars_for_class(table_map, class_name, class_key);
        return get_offset(class_name, class_key, member_name, member_key);
    }

    const auto& kv_map = table_map_it->second;
    const auto& kv_map_it = kv_map.find(member_key);
    if (kv_map_it == kv_map.cend()) {
        LOG_ERROR(XOR("netvars::get_offset: member {} not found in class {}"), member_name, class_name);
        return 0;
    }

    LOG_INFO(XOR("resolved netvar offset {}::{} -> {}"), class_name, member_name, kv_map_it->second);

    return kv_map_it->second;
}

```

`cheat/src/memory/netvars.h`:

```h
#pragma once

#include "../base/base.h"
#include "../crypt/fnv1a.h"
#include "../crypt/xorstr.h"

namespace netvars {

uintptr_t get_offset(const char* className, uint32_t classKey, const char* memberName, uint32_t memberKey) noexcept;

}

#define NETVAR_OFFSET(var_name, datatable, prop_name, extra_offset, type) \
    std::add_lvalue_reference_t<type> var_name() {                        \
                                                                          \
        static const auto offset = netvars::get_offset(                   \
            XOR(datatable), datatable##_hash, XOR(prop_name), prop_name##_hash);    \
                                                                          \
        return *reinterpret_cast<std::add_pointer_t<type>>(               \
            (uintptr_t)(this) + offset + extra_offset);                   \
    }

#define NETVAR(var_name, datatable, prop_name, type) \
    NETVAR_OFFSET(var_name, datatable, prop_name, 0, type)
```

`cheat/src/render/menu.cpp`:

```cpp
#include "menu.h"
#include "../core/cheat.h"
#include <imgui.h>
#include <imgui_internal.h>
#include "../core/config.h"

#define ADD_VERSION(str) (str " " BAKAWARE_VERSION)

void menu::render() noexcept {
    if (!is_open)
        return;

#ifdef _DEBUG
    ImGui::ShowDemoWindow();

    if (ImGui::Button(XOR("Unhook")))
        cheat::should_unhook = true;
    
    ImGui::Text(XOR("Global vars: %p"), cheat::global_vars);
    ImGui::Text(XOR("Local controller: %p"), cheat::local.controller);
    ImGui::Text(XOR("Local player pawn: %p"), cheat::local.pawn);
    ImGui::Text(XOR("last_mouse_enabled: %d"), input::last_mouse_enabled ? 1 : 0);
#endif

    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
	ImGui::SetNextWindowSize(ImVec2(800, 600));
    if (ImGui::Begin(XOR(ADD_VERSION("BakaWare")), 0, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize)) {
        {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
            ImGui::Columns(2, 0, true);
            ImGui::SetColumnWidth(-1, 150);
            ImGui::GetCurrentWindow()->DC.CurrentColumns->Flags |= ImGuiColumnsFlags_NoResize;
            const ImVec2 size(ImGui::GetContentRegionAvail().x, 50);
            for (int i = 0; i < tabs.size(); i++) {
                auto& tab = tabs[i];
                if (tab->render_button(size, i == selected_tab))
                    selected_tab = i;
            }
            ImGui::PopStyleVar();

            // TODO: configs

            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
			ImGui::NextColumn();
			ImGui::PopStyleVar();
        }
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8, 8));
        if (ImGui::BeginChild(XOR("##settings"), ImVec2(), true)) {
			tabs[selected_tab]->render();
		}
		ImGui::EndChild();
		ImGui::PopStyleVar();
		ImGui::Columns();
    }
    ImGui::End();
	ImGui::PopStyleVar();

}

bool menu::menu_tab::render_button(const ImVec2 size, bool selected, bool vertical) noexcept {
    ImGuiID id = ImGui::GetID((label + "_back").c_str());
	ImGuiStyle style = ImGui::GetStyle();
	const ImVec2 label_size = ImGui::CalcTextSize(label.c_str(), NULL, true);
    const auto pos = ImGui::GetCurrentWindow()->DC.CursorPos;
	const ImRect rect(pos, pos + size);
	ImGui::ItemSize(size, style.FramePadding.y);
	if (!ImGui::ItemAdd(rect, id))
        return false;
    bool hovered;
	bool pressed = ImGui::ButtonBehavior(rect, id, &hovered, 0);
    if (pressed) ImGui::MarkItemEdited(id);
    float delta = ImGui::GetIO().DeltaTime;
	float size_var = vertical ? size.y : size.x;
	if (hovered || selected) {
		if (btn_mode == 100) {
			btn_mode = 0;
			btn_speed = 15;
		}
		if (btn_mode != 2) {
			btn_speed += delta * 50;
			btn_width += btn_speed * delta * 100;
		}
		if (btn_width > size_var) {
			btn_width = size_var;
			btn_speed *= btn_mode == 0 ? -.3f : 0;
			btn_mode++;
		}
	} else {
		if (btn_mode != 100) btn_speed = 0;
		btn_mode = 100;
		btn_speed -= delta * 50;
		btn_width += btn_speed * delta * 100;
		if (btn_width < 0) {
			btn_speed = 0;
			btn_width = 0;
		}
	}
    const ImRect rect2(pos, pos + (vertical ? ImVec2(size.x, btn_width) : ImVec2(btn_width, size.y)));
	ImGui::RenderNavHighlight(rect, id);
	ImGui::RenderFrame(rect2.Min, rect2.Max, ImGui::GetColorU32(selected ? ImGuiCol_ButtonActive : ImGuiCol_Button), false, style.FrameRounding);
	ImGui::RenderTextClipped(rect.Min + style.FramePadding, rect.Max - style.FramePadding, label.c_str(), NULL, &label_size, style.ButtonTextAlign, &rect);

	return pressed;
}

void menu::menu_tab_visuals::render() noexcept {
    ImGui::Checkbox(XOR("Enabled"), &cfg.esp.players.enabled);
    ImGui::Checkbox(XOR("Teammates"), &cfg.esp.players.teammates);
    ImGui::Checkbox(XOR("Box"), &cfg.esp.players.box);
    ImGui::Checkbox(XOR("Name"), &cfg.esp.players.name);
    ImGui::Checkbox(XOR("Health"), &cfg.esp.players.health);
    ImGui::Checkbox(XOR("Skeleton"), &cfg.esp.players.skeleton);
}

void menu::menu_tab_misc::render() noexcept {
    ImGui::Checkbox(XOR("Bunny hop"), &cfg.misc.bunny_hop);
}

```

`cheat/src/render/menu.h`:

```h
#pragma once
#include "../base/base.h"
#include "../core/input.h"

namespace menu {
    inline bool is_open{ true };
    inline int selected_tab { 0 };

    inline void toggle() { 
        is_open = !is_open;
        input::unlock_cursor(is_open);
    };
    void render() noexcept;

    class menu_tab {
    private:
        std::string label;
        float btn_width{ 0.f };
        float btn_speed{ 0.f };
        unsigned int btn_mode{ 0 };
    public:
        menu_tab(std::string label) noexcept : label(label) { };
        bool render_button(const ImVec2 size, bool selected = false, bool vertical = false) noexcept;
        virtual void render() noexcept = 0;
    };

    class menu_tab_visuals : public menu_tab {
    public:
        menu_tab_visuals() noexcept : menu_tab(XOR("Visuals")) { };
        void render() noexcept override;
    };

    class menu_tab_misc : public menu_tab {
    public:
        menu_tab_misc() noexcept : menu_tab(XOR("Misc")) { };
        void render() noexcept override;
    };

    inline std::vector<menu_tab*> tabs {
        new menu_tab_visuals(),
        new menu_tab_misc()
    };
}

```

`cheat/src/render/render.cpp`:

```cpp
#include "render.h"
#include "../base/base.h"
#include "../memory/memory.h"
#include "../core/cheat.h"
#include "menu.h"
#include "../core/features/features.h"
#include <imgui_impl_dx11.h>
#include <imgui_impl_win32.h>

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

void render::initialize() noexcept {
    auto swap_chain_ptr = **dlls::render_system_dx11.find(PATTERN("66 0F 7F 05 ? ? ? ? 66 0F 7F 0D ? ? ? ? 48 89 35")).absolute<CSwapChainDx11***>(0x4);

    if (!set_swap_chain(swap_chain_ptr->pSwapChain))
        return;

    ImGui::CreateContext();
    ImGui_ImplWin32_Init(game_window);
    ImGui_ImplDX11_Init(device, context);

    ImVec4* colors = ImGui::GetStyle().Colors;
	colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.03f, 0.03f, 0.03f, 1.00f);
	colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 1.00f, 0.50f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.29f, 0.29f, 0.29f, 0.50f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.15f, 0.15f, 0.15f, 0.54f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.54f, 0.54f, 0.54f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.54f, 0.54f, 0.54f, 0.40f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.00f, 0.41f, 1.00f, 1.00f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.46f, 0.51f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.00f, 0.00f, 0.62f, 1.00f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.53f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.00f, 0.26f, 0.65f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.00f, 0.26f, 0.65f, 1.00f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_Button] = ImVec4(0.00f, 0.26f, 0.65f, 1.00f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.00f, 0.26f, 0.65f, 1.00f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.00f, 0.37f, 0.94f, 1.00f);
	colors[ImGuiCol_Separator] = ImVec4(0.00f, 0.00f, 1.00f, 0.50f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.00f, 0.00f, 1.00f, 0.50f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.00f, 0.00f, 1.00f, 0.50f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.00f, 0.00f, 0.44f, 0.49f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.00f, 0.00f, 1.00f, 0.49f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.00f, 0.00f, 1.00f, 0.49f);
	colors[ImGuiCol_Tab] = ImVec4(0.30f, 0.30f, 0.30f, 1.00f);
	colors[ImGuiCol_TabHovered] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TabActive] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TabUnfocused] = ImVec4(0.30f, 0.30f, 0.30f, 1.00f);
	colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.00f, 0.73f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.00f, 1.00f, 0.00f, 1.00f);
    colors[ImGuiCol_TableHeaderBg] = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
    colors[ImGuiCol_TableBorderStrong] = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);
    colors[ImGuiCol_TableBorderLight] = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);
    colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.00f, 0.73f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.00f, 1.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.41f, 1.00f, 0.00f, 0.70f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	ImGuiStyle& style = ImGui::GetStyle();
	style.ChildRounding = .0f;
	style.FrameRounding = .0f;
	style.GrabRounding = .0f;
	style.PopupRounding = .0f;
	style.ScrollbarRounding = .0f;
	style.TabRounding = .0f;
	style.WindowRounding = .0f;
	style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
	style.GrabMinSize = 20.f;

    LOG_INFO(XOR("Render initialized."));
}

bool render::set_swap_chain(IDXGISwapChain* swap_chain) noexcept {
    render::swap_chain = swap_chain;

    DXGI_SWAP_CHAIN_DESC swapChainDesc;
    if (FAILED(swap_chain->GetDesc(&swapChainDesc))) {
        LOG_ERROR(XOR("Failed to get swap chain description."));
        return false;
    }
    game_window = swapChainDesc.OutputWindow;

    if (FAILED(swap_chain->GetDevice(__uuidof(ID3D11Device), reinterpret_cast<PVOID*>(&device)))) {
        LOG_ERROR(XOR("Failed to get device from swap chain."));
        return false;
    }

    device->GetImmediateContext(&context);

    ID3D11Texture2D* back_buffer;
    if (FAILED(swap_chain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<PVOID*>(&back_buffer)))) {
        LOG_ERROR(XOR("Failed to get buffer from swap chain."));
        return false;
    }

    D3D11_RENDER_TARGET_VIEW_DESC desc;
    desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DMS;

    if (FAILED(device->CreateRenderTargetView(back_buffer, &desc, &render_target_view))) {
        back_buffer->Release();
        LOG_ERROR(XOR("Failed to create render target view."));
        return false;
    }
    back_buffer->Release();

    interfaces::engine->get_screen_size(&cheat::screen_size.x, &cheat::screen_size.y);

    return true;
}

void render::cleanup_render_target() noexcept {
    if (render_target_view) {
        render_target_view->Release();
        render_target_view = nullptr;
    }
}

void render::render() noexcept {
    if (!render_target_view)
        return;

    ImGui_ImplDX11_NewFrame();
    ImGui_ImplWin32_NewFrame();
    {
        std::scoped_lock lock(input_mutex);
        ImGui::NewFrame();
    }

    auto r = render::renderer(ImGui::GetBackgroundDrawList());

    features::render(&r);

    menu::render();

    ImGui::Render();
    context->OMSetRenderTargets(1, &render_target_view, nullptr);
    ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
}

bool render::input(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam) noexcept {
    {
        std::scoped_lock lock(input_mutex);
        ImGui_ImplWin32_WndProcHandler(wnd, msg, wparam, lparam);
    }
    if (!menu::is_open)
        return false;
    
    switch (msg) {
        case WM_MOUSEMOVE:
        case WM_NCMOUSEMOVE:
        case WM_MOUSELEAVE:
        case WM_NCMOUSELEAVE:
        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
        case WM_XBUTTONDOWN:
        case WM_XBUTTONDBLCLK:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        case WM_XBUTTONUP:
        case WM_MOUSEWHEEL:
        case WM_MOUSEHWHEEL:
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
        case WM_SETFOCUS:
        case WM_KILLFOCUS:
        case WM_CHAR:
        case WM_DEVICECHANGE:
            return true;
        default:
            return false;
    }
}

void render::end() noexcept {
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    cleanup_render_target();
}

```

`cheat/src/render/render.h`:

```h
#pragma once

#include <d3d11.h>
#include <imgui.h>
#include "../memory/memory.h"

namespace render {

class CSwapChainDx11 {
public:
	PAD(0x178)
	IDXGISwapChain* pSwapChain;
};

inline HWND                    game_window{ };
inline IDXGISwapChain*         swap_chain{ };
inline ID3D11Device*           device{ };
inline ID3D11RenderTargetView* render_target_view{ };
inline ID3D11DeviceContext*    context{ };
inline std::recursive_mutex    input_mutex{ };

void initialize() noexcept;
bool set_swap_chain(IDXGISwapChain* swap_chain) noexcept;
void cleanup_render_target() noexcept;
void render() noexcept;
bool input(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam) noexcept;
void end() noexcept;

class renderer {
public:
    renderer(ImDrawList* draw_list) noexcept : draw_list(draw_list) {}

    void rect(float x1, float y1, float x2, float y2, clr4 color, float t = 1.0f, float r = 0.0f) {
        draw_list->AddRect(ImVec2(x1, y1), ImVec2(x2, y2), color.rgba, r, ImDrawFlags_RoundCornersAll, t);
    }

    void rect_filled(float x1, float y1, float x2, float y2, clr4 color, float r = 0.0f) {
        draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), color.rgba, r, ImDrawFlags_RoundCornersAll);
    }

    void rect_filled_multi_color(float x1, float y1, float x2, float y2, clr4 upr_left, clr4 upr_right, clr4 btm_right, clr4 btm_left) {
        draw_list->AddRectFilledMultiColor(ImVec2(x1, y1), ImVec2(x2, y2), upr_left.rgba, upr_right.rgba, btm_right.rgba, btm_left.rgba);
    }

    vec2 calc_text_size(const char* text) {
        return ImGui::CalcTextSize(text);
    }

    void text(float x, float y, clr4 color, const char* text, bool outline = true) {
        draw_list->AddText(ImVec2(x + 1, y + 1), clr4::black(color.a).rgba, text);
        draw_list->AddText(ImVec2(x, y), color.rgba, text);
    }

    void line(float x1, float y1, float x2, float y2, clr4 color, float t = 1.0f) {
        draw_list->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), color.rgba, t);
    }

private:
    ImDrawList* draw_list;
};

}

```

`cheat/src/valve/cs/cs.h`:

```h
#pragma once

#include "../../base/base.h"

#include "entity.h"
```

`cheat/src/valve/cs/entity.cpp`:

```cpp
#include "entity.h"

#include "../../memory/interfaces.h"
#include "../../base/math.h"

#include <limits>
#include "../../core/input.h"

cs::base_entity *cs::handle::get() noexcept {
    return interfaces::entity_list->get_base_entity(get_entry_index());
}

bool cs::base_entity::is_player_controller() {
    return false;
}

bool cs::base_entity::get_bounding_box(bbox &out) {
    collision_property* pCollision = m_pCollision();
    if (!pCollision)
        return false;

    game_scene_node* pGameSceneNode = m_pGameSceneNode();
    if (!pGameSceneNode)
        return false;

    const vec3& origin = pGameSceneNode->m_vecAbsOrigin();
    const vec3 min = pCollision->m_vecMins() + origin;
    const vec3 max = pCollision->m_vecMaxs() + origin;

    out.x = out.y = std::numeric_limits<float>::max();
    out.w = out.h = -std::numeric_limits<float>::max();

    for (size_t i = 0; i < 8; ++i) {
        const vec3 point {
            i & 1 ? max.x : min.x, 
            i & 2 ? max.y : min.y, 
            i & 4 ? max.z : min.z
        };
        vec2 screen;
        if (!math::world_to_screen(point, screen))
            return false;

        out.x = std::floor(std::min(out.x, screen.x));
        out.y = std::floor(std::min(out.y, screen.y));
        out.w = std::floor(std::max(out.w, screen.x));
        out.h = std::floor(std::max(out.h, screen.y));
    }

    return true;
}

```

`cheat/src/valve/cs/entity.h`:

```h
#pragma once

#include "../../memory/memory.h"
#include "../se/util.h"

#define ENT_ENTRY_MASK 0x7fff

namespace cs {

enum class life_state : uint8_t {
	LIFE_ALIVE = 0x0,
	LIFE_DYING = 0x1,
	LIFE_DEAD = 0x2,
	LIFE_RESPAWNABLE = 0x3,
	LIFE_RESPAWNING = 0x4,
};

enum class move_type : uint8_t {
	MOVETYPE_NONE = 0x0,
	MOVETYPE_OBSOLETE = 0x1,
	MOVETYPE_WALK = 0x2,
	MOVETYPE_STEP = 0x3,
	MOVETYPE_FLY = 0x4,
	MOVETYPE_FLYGRAVITY = 0x5,
	MOVETYPE_PHYSICIST = 0x6,
	MOVETYPE_PUSH = 0x7,
	MOVETYPE_NOCLIP = 0x8,
	MOVETYPE_OBSERVER = 0x9,
	MOVETYPE_LADDER = 0xa,
	MOVETYPE_CUSTOM = 0xb,
	MOVETYPE_LAST = 0xc,
	MOVETYPE_MAX_BITS = 0x5,
};

enum flags : uint32_t {
    fl_onground = (1 << 0),
    fl_ducking = (1 << 1),
    fl_waterjump = (1 << 2),
    fl_ontrain = (1 << 3),
    fl_inrain = (1 << 4),
    fl_frozen = (1 << 5),
    fl_atcontrols = (1 << 6),
    fl_client = (1 << 7),
    fl_fakeclient = (1 << 8),
    fl_inwater = (1 << 9),
    fl_fly = (1 << 10),
    fl_swim = (1 << 11),
    fl_conveyor = (1 << 12),
    fl_npc = (1 << 13),
    fl_godmode = (1 << 14),
    fl_notarget = (1 << 15),
    fl_aimtarget = (1 << 16),
    fl_partialground = (1 << 17),
    fl_staticprop = (1 << 18),
    fl_graphed = (1 << 19),
    fl_grenade = (1 << 20),
    fl_stepmovement = (1 << 21),
    fl_donttouch = (1 << 22),
    fl_basevelocity = (1 << 23),
    fl_worldbrush = (1 << 24),
    fl_object = (1 << 25),
    fl_killme = (1 << 26),
    fl_onfire = (1 << 27),
    fl_dissolving = (1 << 28),
    fl_transragdoll = (1 << 29),
    fl_unblockable_by_player = (1 << 30)
};

enum bone_flags : uint32_t {
	FLAG_NO_BONE_FLAGS = 0x0,
	FLAG_BONEFLEXDRIVER = 0x4,
	FLAG_CLOTH = 0x8,
	FLAG_PHYSICS = 0x10,
	FLAG_ATTACHMENT = 0x20,
	FLAG_ANIMATION = 0x40,
	FLAG_MESH = 0x80,
	FLAG_HITBOX = 0x100,
	FLAG_BONE_USED_BY_VERTEX_LOD0 = 0x400,
	FLAG_BONE_USED_BY_VERTEX_LOD1 = 0x800,
	FLAG_BONE_USED_BY_VERTEX_LOD2 = 0x1000,
	FLAG_BONE_USED_BY_VERTEX_LOD3 = 0x2000,
	FLAG_BONE_USED_BY_VERTEX_LOD4 = 0x4000,
	FLAG_BONE_USED_BY_VERTEX_LOD5 = 0x8000,
	FLAG_BONE_USED_BY_VERTEX_LOD6 = 0x10000,
	FLAG_BONE_USED_BY_VERTEX_LOD7 = 0x20000,
	FLAG_BONE_MERGE_READ = 0x40000,
	FLAG_BONE_MERGE_WRITE = 0x80000,
	FLAG_ALL_BONE_FLAGS = 0xfffff,
	BLEND_PREALIGNED = 0x100000,
	FLAG_RIGIDLENGTH = 0x200000,
	FLAG_PROCEDURAL = 0x400000,
};

class base_entity;

class handle {
public:
    base_entity* get() noexcept;

    inline int get_entry_index() noexcept { return m_Index & ENT_ENTRY_MASK; }
    template <typename T>
    inline T* get_as() {
        return (T*)(get());
    }

    uintptr_t m_Index;
};

struct alignas(16) bone_data {
    vec3 pos;
    float scale;
    vec4 rot;
};

static_assert(sizeof(bone_data) == 0x20);

class model {
public:
    VIRTUAL_FUNCTION_SIG_ABSOLUTE(num_bones, uint32_t, dlls::client, "E8 ? ? ? ? 85 C0 7E 21", 1, (this))
    VIRTUAL_FUNCTION_SIG(bone_flags, uint32_t, dlls::client, "85 D2 78 16 3B 91", (this, index), uint32_t index)
    VIRTUAL_FUNCTION_SIG(bone_name, const char*, dlls::client, "85 D2 78 25 3B 91", (this, index), uint32_t index)
    VIRTUAL_FUNCTION_SIG(bone_parent, int32_t, dlls::client, "85 D2 78 17 3B 91 70", (this, index), uint32_t index)
};

class model_state {
public:
    NETVAR(m_hModel, "CModelState", "m_hModel", se::strong_handle<model>);

    bone_data* get_bone_data() noexcept {
        return address(this).offset(0x80).dereference<bone_data*>();
    }
};

class skeleton_instance {
public:
    NETVAR(m_modelState, "CSkeletonInstance", "m_modelState", model_state);

    VIRTUAL_FUNCTION_SIG_ABSOLUTE(get_bone, void, dlls::client, "E8 ? ? ? ? EB 19 48 8B CF", 1, (this, data, index), bone_data& data, int index)
    VIRTUAL_FUNCTION_SIG(calc_world_space_bones, void, dlls::client, "40 55 56 57 41 54 41 55 41 56 41 57 48 81 EC F0", (this, bone_mask), bone_flags bone_mask)
};

class game_scene_node {
public:
    NETVAR(m_vecAbsOrigin, "CGameSceneNode", "m_vecAbsOrigin", vec3);

    VIRTUAL_FUNCTION(get_skeleton_instance, skeleton_instance*, 8, (this))
};

class collision_property {
public:
    NETVAR(m_vecMins, "CCollisionProperty", "m_vecMins", vec3);
    NETVAR(m_vecMaxs, "CCollisionProperty", "m_vecMaxs", vec3);
};

class player_weapon_services {
   public:
    // NETVAR(m_hActiveWeapon, "CPlayer_WeaponServices", "m_hActiveWeapon",
    //              CHandle);
    // NETVAR(m_hMyWeapons, "CPlayer_WeaponServices", "m_hMyWeapons",
    //               CNetworkUtlVectorBase<CHandle>);
};

class entity_instance {
public:
    // FIXME: m_pEntity
};

class base_entity : public entity_instance {
public:
    bool is_player_controller();
    bool get_bounding_box(bbox& out);
    
    inline bool has_flag(flags flag) noexcept { return m_fFlags() & flag; }

    NETVAR(m_pGameSceneNode, "C_BaseEntity", "m_pGameSceneNode", game_scene_node*);
    NETVAR(m_pCollision, "C_BaseEntity", "m_pCollision", collision_property*);
    NETVAR(m_iTeamNum, "C_BaseEntity", "m_iTeamNum", uint8_t);
    NETVAR(m_lifeState, "C_BaseEntity", "m_lifeState", life_state);
    NETVAR(m_MoveType, "C_BaseEntity", "m_MoveType", move_type);
    NETVAR(m_fFlags, "C_BaseEntity", "m_fFlags", flags);
};

class base_player_controller : public base_entity {
public:
    NETVAR(m_steamID, "CBasePlayerController", "m_steamID", uint64_t);
    NETVAR(m_hPawn, "CBasePlayerController", "m_hPawn", handle);
    NETVAR(m_bIsLocalPlayerController, "CBasePlayerController", "m_bIsLocalPlayerController", bool);
};

class player_controller : public base_player_controller {
public:
    NETVAR(m_sSanitizedPlayerName, "CCSPlayerController", "m_sSanitizedPlayerName", const char*);
    NETVAR(m_iPawnHealth, "CCSPlayerController", "m_iPawnHealth", uint32_t);
    NETVAR(m_bPawnIsAlive, "CCSPlayerController", "m_bPawnIsAlive", bool);
};

class base_player_pawn : public base_entity {
public:
    NETVAR(m_hController, "C_BasePlayerPawn", "m_hController", handle);
    NETVAR(m_pWeaponServices, "C_BasePlayerPawn", "m_pWeaponServices", player_weapon_services*);
};

class player_pawn_base : public base_player_pawn {
public:
    NETVAR(m_iHealth, "C_CSPlayerPawnBase", "m_aimPunchCache", se::util_vector<angle>);
};

class player_pawn : public player_pawn_base {
public:
    VIRTUAL_FUNCTION_SIG(is_enemy, bool, dlls::client, "40 57 48 83 EC 40 48 8B F9 48 85", (this, other_player), player_pawn* other_player)
};

inline cs::player_controller* get_local_player_controller(int32_t split_screen_slot = 0) noexcept {
    SIG(sig, dlls::client, "E8 ? ? ? ? 49 89 47 08")
    auto fn = sig.absolute<player_controller*(__stdcall*)(int32_t)>();
    return fn(split_screen_slot);
}

}
```

`cheat/src/valve/se/client.h`:

```h
#pragma once

#include "../../memory/memory.h"
#include "../cs/entity.h"

#define MAX_SPLITSCREEN_PLAYERS 1

namespace se {

enum buttons : uint32_t {
    in_attack = 1,
    in_jump = 2,
    in_duck = 4,
    in_attack2 = 2048,
    in_moveforward = 8,
    in_moveback = 16,
    in_moveleft = 512,
    in_moveright = 1024
};

struct entity_list;

struct client_dll {
  public:
};

struct game_resource_service {
    entity_list* get_entity_list() {
        return address(this).offset(0x58).dereference<entity_list*>();
    }
};

struct entity_list {
    template <class ty = cs::base_entity *>
    VIRTUAL_FUNCTION_SIG_ABSOLUTE(get_base_entity, ty, dlls::client, "8B D3 E8 ? ? ? ? 48 8B F8 48 85 C0 74 76", 3, (this, index), int index)
    VIRTUAL_FUNCTION_SIG_ABSOLUTE(get_max_entities, int, dlls::client, "33 DB E8 ? ? ? ? 8B 08", 3, (this, max), int* max)
    
};

struct cmd_qangle {
    char pad1[0x18];
    vec3 angles;
};

static_assert(sizeof(cmd_qangle) == 0x24);

struct user_cmd_base {
    PAD(0x40)
    cmd_qangle* view;
    PAD(0x8)
    float forwardmove;
    float sidemove;

    // TODO: maybe more here
};

struct user_cmd {
    PAD(0x30)
    user_cmd_base* base;
    PAD(0x18)
    uint32_t buttons;
    PAD(0x1C)
};

static_assert(sizeof(user_cmd) == 0x70);

struct per_user_input {
    user_cmd cmds[150];
    PAD(0x30)
    int sequence_number;
    PAD(0x18C)
};

static_assert(sizeof(per_user_input) == sizeof(user_cmd) * (150 + 4)); // 0x4360

struct csgo_input {
    VIRTUAL_FUNCTION_SIG(set_cursor_pos, void, dlls::client, "44 89 44 24 18 89 54 24 10 48 83", (this, x, y), uint32_t x, uint32_t y)

    user_cmd* get_user_cmd(int split_screen_index) {
        if (split_screen_index >= MAX_SPLITSCREEN_PLAYERS) {
            return nullptr;
        }
        auto input = &per_user[split_screen_index];
        return &input->cmds[input->sequence_number % std::size(input->cmds)];
    }
private:
    PAD(0x10);
    per_user_input per_user[MAX_SPLITSCREEN_PLAYERS];
};

struct client_mode {

};

struct global_vars {
public:
    float realtime;
    std::int32_t frame_count;
    PAD(0x8)
    std::uint32_t max_clients;
    float interval_per_tick;
    PAD(0x12)
    float curtime;
    float curtime2;
    PAD(0xC)
    std::int32_t tick_count;
    float interval_per_tick2;
    void* current_netchan;
    PAD(0x130)
    char* current_map;
    char* current_mapname;
};

}
```

`cheat/src/valve/se/engine.h`:

```h
#pragma once

namespace se {

struct engine_client {

    VIRTUAL_FUNCTION(is_in_game, bool, 30, (this));
    VIRTUAL_FUNCTION(is_connected, bool, 31, (this));
    VIRTUAL_FUNCTION(get_screen_size, void, 48, (this, width, height), int* width, int* height);
    VIRTUAL_FUNCTION(get_level_name, const char*, 51, (this));
    VIRTUAL_FUNCTION(get_level_name_short, const char*, 52, (this));

    inline bool is_valid() noexcept {
        return is_in_game() && is_connected();
    }
};

}
```

`cheat/src/valve/se/inputsystem.h`:

```h
#pragma once

#include "../../memory/memory.h"

namespace se {

struct plat_window;

struct input_context {
    const char* name;
    PAD(0x9C)
    bool enabled;
};

struct input_stack_system {
    VIRTUAL_FUNCTION(set_mouse_capture, void, 16, (this, context, state), input_context* context, bool state);

    input_context* find_input_context(const char* name) {
        for (int i = 0; i < context_count; i++) {
            if (strcmp(contexts[i]->name, name) == 0)
                return contexts[i];
        }
        return nullptr;
    }
private:
    PAD(0x28)
    int context_count;
    input_context** contexts;
};

}

```

`cheat/src/valve/se/schema.h`:

```h
#pragma once

#include "../../memory/memory.h"

namespace se {

struct type_scope;
struct schema_class_info_data;
struct schema_class_field_data;

struct schema_system {
    VIRTUAL_FUNCTION(find_type_scope_for_module, type_scope*, 13, (this, module), const char* module)
};

struct type_scope {
    VIRTUAL_FUNCTION(find_declared_class, schema_class_info_data*, 2, (this, name), const char* name)
};

struct schema_class_info_data {
    short size() {
        return *address(this).offset(0x1C).cast<short*>();
    }

    schema_class_field_data* get_field_data() {
        return *address(this).offset(0x28).cast<schema_class_field_data**>();
    }
};

struct schema_class_field_data {
    const char* name;
    PAD(0x8);
    short offset;
    PAD(0xE);
};

}
```

`cheat/src/valve/se/se.h`:

```h
#pragma once

#include "../../base/base.h"

#include "client.h"
#include "engine.h"
#include "schema.h"
#include "inputsystem.h"
#include "util.h"
```

`cheat/src/valve/se/util.h`:

```h
#pragma once

#include "../../base/base.h"

namespace se {

template <class T>
class util_vector {
public:
    size_t size;
    T* data;
};

struct resource_binding {
    void* data;
    // uint32_t last_bind_frame;
    // uint32_t flags;
    // interlocked_int ref_count;
};

template <class T>
class strong_handle {
public:
    operator T*() noexcept {
        ASSERT(binding);
        return (T*)binding->data;
    }
    T* operator->() noexcept {
        ASSERT(binding);
        return (T*)binding->data;
    }
private:
    const resource_binding *binding;
};

}
```

`cspell.json`:

```json
{
    "version": "0.2",
    "ignorePaths": [
        "injector/src"
    ],
    "dictionaryDefinitions": [],
    "dictionaries": [],
    "words": [
        "aimtarget",
        "atcontrols",
        "basevelocity",
        "BONEFLEXDRIVER",
        "CONOUT",
        "donttouch",
        "fakeclient",
        "FLYGRAVITY",
        "forwardmove",
        "gameoverlayrenderer",
        "godmode",
        "inrain",
        "inwater",
        "killme",
        "Maxs",
        "moveback",
        "moveforward",
        "moveright",
        "MOVETYPE",
        "NOCLIP",
        "notarget",
        "onfire",
        "onground",
        "ontrain",
        "partialground",
        "PREALIGNED",
        "rendersystemdx",
        "RESPAWNABLE",
        "RESPAWNING",
        "RIGIDLENGTH",
        "scrs",
        "sidemove",
        "staticprop",
        "stepmovement",
        "transragdoll",
        "unblockable",
        "veorq",
        "waterjump",
        "worldbrush",
        "xored",
        "XORSTR"
    ],
    "ignoreWords": [],
    "import": []
}

```

`injector/CMakeLists.txt`:

```txt

add_executable(PerfectInjector "src/PerfectInjector.cpp")

target_compile_features(PerfectInjector PUBLIC c_std_17 cxx_std_20)
set_target_properties(PerfectInjector PROPERTIES LINK_FLAGS "/MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\"")
```

`injector/LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2018, Can Bölük
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`injector/src/CapcomLoader.h`:

```h
#pragma once
#include <filesystem>
#include <iostream>
#include <fstream>

#include "CapcomResource.h"
#include "DriverLoader.h"
#include "LockedMemory.h"

#define IOCTL_RunPayload64 0xAA013044

#pragma pack(push, 1)
struct CapcomContext
{
	using FnCapcomCb = void( __stdcall*)( PVOID );
	using FnCapcomCbNoCtx = void(__stdcall*)();

	uint64_t BufferPointer;
	uint8_t MovabsRaxData[ 0x2 ] = { 0x48, 0xB8 };		// mov rax, data
	uint64_t DataSource;								// -
	uint8_t MovRdxRax[ 0x3 ] = { 0x48, 0x89, 0xC1 };	// mov rcx, rax
	uint8_t MovabsRax[ 0x2 ] = { 0x48, 0xB8 };			// mov rax, destination
	uint64_t Destination;								// -
	uint8_t JmpRax[ 0x2 ] = { 0xFF, 0xE0 };				// jmp rax

	HANDLE CapcomDevice;
	std::wstring CapcomDriverName;

	CapcomContext( std::wstring DriverName, HANDLE Device )
	{
		this->CapcomDriverName = DriverName;
		this->CapcomDevice = Device;
	}

	void ExecuteInKernel( FnCapcomCb Destination, PVOID Ctx = 0 )
	{
		this->Destination = ( uint64_t ) Destination;

		// STOP OPTIMIZING MY FUCKING VARIABLES AWAY DUMB CUNT
		if ( __rdtsc() == 0 )
			Destination( 0 );

		DWORD Status = 0x0;
		DWORD BytesReturned = 0x0;
		this->DataSource = ( uint64_t ) Ctx;
		this->BufferPointer = ( uint64_t ) ( &this->BufferPointer + 1 );

		DeviceIoControl
		(
			CapcomDevice,
			IOCTL_RunPayload64,
			&this->BufferPointer,
			sizeof( uint64_t ),
			&Status,
			sizeof( Status ),
			&BytesReturned,
			0
		);
	}

	void ExecuteInKernel( FnCapcomCbNoCtx Fn, PVOID Ctx = 0 )
	{
		this->ExecuteInKernel( ( FnCapcomCb )( Fn ), Ctx );
	}
};
#pragma pack(pop)

static void Cl_AssertDecrypted()
{
	if ( CAPCOM_DRIVER[ 0 ] != 0x4D )
	{
		for ( BYTE& b : CAPCOM_DRIVER )
			b ^= CAPCOM_DRIVER_XOR_KEY;
	}
}

static std::wstring Cl_GetDriverPath()
{
	wchar_t SystemDirectory[ 2048 ];
	GetSystemDirectoryW( SystemDirectory, 2048 );

	std::wstring DriverPath = SystemDirectory;
	DriverPath += L"\\drivers\\";

	return DriverPath;
}

static NTSTATUS Cl_RemoveSimilarDrivers( BYTE* Driver )
{
	namespace fs = std::filesystem;

	std::wstring DriverPath = Cl_GetDriverPath();

	NTSTATUS Status = STATUS_SUCCESS;

	for ( auto& File : fs::directory_iterator( DriverPath ) )
	{
		std::wstring Path = File.path();
		if ( Path.find( L".sys" ) != -1 )
		{
			std::ifstream FileStr( File.path(), std::ios::binary );
			char Data[ 1024 ];
			FileStr.read( Data, 1024 );
			FileStr.close();

			if ( !memcmp( Driver, Data, 1024 ) )
			{
				bool Deleted = DeleteFileW( Path.c_str() );

				printf( "[+] DeleteFile (%ls) : %x\n", Path.c_str(), Deleted );

				if ( !Deleted )
				{
					size_t StrEnd = Path.find( L".sys" );
					size_t StrStart = Path.rfind( L"\\", StrEnd );
					std::wstring DriverName = Path.substr( StrStart + 1, StrEnd - StrStart - 1 ).c_str();
					Dl_UnloadDriver( DriverName.c_str() );

					Deleted = DeleteFileW( Path.c_str() );
					printf( "[+] DeleteFile2 (%ls) : %x\n", Path.c_str(), Deleted );
				}

				Status |= !Deleted;
			}
		}
	}

	return Status;
}

static BOOL Cl_FreeContext( CapcomContext* Ctx )
{
	Cl_AssertDecrypted();
	CloseHandle( Ctx->CapcomDevice );
	if ( Dl_UnloadDriver( Ctx->CapcomDriverName.c_str() ) )
		return FALSE;
	if ( Cl_RemoveSimilarDrivers( CAPCOM_DRIVER ) )
		return FALSE;
	VirtualFree( Ctx, 0, MEM_FREE );
	return TRUE;
}

static CapcomContext* Cl_InitContext()
{
	Cl_AssertDecrypted();

	CapcomContext* AllocatedContext = ( CapcomContext* ) ( VirtualAlloc( 0, sizeof( CapcomContext ), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) );

	std::wstring CapcomDriverName = L"";

	srand( (DWORD)__rdtsc() );
	
	for ( int i = 0; i < 12; i++ )
		CapcomDriverName += wchar_t( L'A' + rand() % 20 );

	std::wstring DriverPath = Cl_GetDriverPath() + CapcomDriverName + L".sys";
	
	if ( Cl_RemoveSimilarDrivers( CAPCOM_DRIVER ) )
	{
		printf( "[+] Failed to remove similar drivers!\n" );
		VirtualFree( AllocatedContext, 0, MEM_FREE );
		return 0;
	}

	std::ofstream file( DriverPath, std::ios::binary );
	
	if ( !file.good() )
	{
		printf( "[+] Failed to create file!\n" );
		VirtualFree( AllocatedContext, 0, MEM_FREE );
		return 0;
	}

	file.write( ( char* ) CAPCOM_DRIVER, sizeof( CAPCOM_DRIVER ) );
	file.close();

	if ( Dl_LoadDriver( CapcomDriverName.c_str() ) )
	{
		printf( "[+] Failed to load driver!\n" );
		while ( 1 );
		Cl_RemoveSimilarDrivers( CAPCOM_DRIVER );
		VirtualFree( AllocatedContext, 0, MEM_FREE );
		return 0;
	}

	HANDLE Device = Dl_OpenDevice( "Htsysm72FB" );

	if ( !Device )
	{
		printf( "[+] Failed to open device!\n" );
		Dl_UnloadDriver( CapcomDriverName.c_str() );
		Cl_RemoveSimilarDrivers( CAPCOM_DRIVER );
		VirtualFree( AllocatedContext, 0, MEM_FREE );
		return 0;
	}

	new ( AllocatedContext ) CapcomContext( CapcomDriverName, Device );
	return AllocatedContext;
}

```

`injector/src/CapcomResource.h`:

```h
#pragma once
static unsigned char CAPCOM_DRIVER[] = 
{
	0xaf, 0xb8, 0x72, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe6, 0xe2, 0xe2, 0xe2, 0x1d, 0x1d, 0xe2, 0xe2, 0x5a, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x22, 0xe2, 0xe2, 0xe2, 0xec, 0xfd, 0x58, 0xec, 0xe2, 0x56, 0xeb, 0x2f, 0xc3, 0x5a, 0xe3, 0xae, 0x2f, 0xc3, 0xb6, 0x8a,
	0x8b, 0x91, 0xc2, 0x92, 0x90, 0x8d, 0x85, 0x90, 0x83, 0x8f, 0xc2, 0x81, 0x83, 0x8c, 0x8c, 0x8d, 0x96, 0xc2, 0x80, 0x87, 0xc2, 0x90, 0x97, 0x8c, 0xc2, 0x8b, 0x8c, 0xc2, 0xa6, 0xad, 0xb1, 0xc2, 0x8f, 0x8d, 0x86, 0x87, 0xcc, 0xef, 0xef, 0xe8,
	0xc6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf, 0x16, 0xf6, 0x3f, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x99, 0x6c, 0x4c, 0x77, 0x98, 0x6c, 0x3d, 0xea, 0xe3, 0x6c, 0x48, 0x77, 0x98, 0x6c,
	0x3d, 0xea, 0xf6, 0x6c, 0x4a, 0x77, 0x98, 0x6c, 0x3d, 0xea, 0xe0, 0x6c, 0x4a, 0x77, 0x98, 0x6c, 0xb0, 0x8b, 0x81, 0x8a, 0x4b, 0x77, 0x98, 0x6c, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xb2, 0xa7, 0xe2, 0xe2, 0x86, 0x64, 0xe7, 0xe2,
	0xf7, 0xf6, 0x2f, 0xb5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x12, 0xe2, 0xc0, 0xe2, 0xe9, 0xe0, 0xea, 0xe2, 0x62, 0xe4, 0xe2, 0xe2, 0x62, 0xe0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xee, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xf9, 0x8, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2, 0xca, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2, 0xaa, 0xe2, 0xe2, 0xe2,
	0xe2, 0xee, 0xe2, 0xe2, 0xb2, 0xff, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe1, 0xe2, 0xe2, 0xfe, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xcc, 0x96, 0x87, 0x9a, 0x96, 0xe2, 0xe2, 0xe2, 0x2, 0xe6, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe7, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc2, 0xe2, 0xe2, 0x8a, 0xcc, 0x86, 0x83, 0x96, 0x83, 0xe2, 0xe2, 0xe2, 0x22, 0xe2, 0xe2, 0xe2, 0xe2, 0xea, 0xe2, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xea, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0x2a, 0xcc, 0x92, 0x86, 0x83, 0x96, 0x83, 0xe2, 0xe2, 0xaa, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xaa, 0xcc, 0x8b, 0x8c, 0x84, 0x8d, 0xe2, 0xe2, 0xe2, 0x42, 0xe2, 0xe2, 0xe2, 0x62, 0xeb, 0xe2, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0x62, 0xeb, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0x2a, 0xab, 0xac, 0xab, 0xb6, 0xe2, 0xe2, 0xe2, 0xe2, 0xf6, 0xe3, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2, 0x62, 0xe3, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc2, 0xe2, 0xe2, 0x0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x18, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf0, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc8, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xbe, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x96, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x1, 0xdf, 0x79, 0xb3,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe0, 0xe2, 0xe2, 0xe2, 0xac, 0xe2, 0xe2, 0xe2, 0xbe, 0xe1, 0xe2, 0xe2, 0xbe, 0xe1, 0xe2, 0xe2, 0xb0, 0xb1, 0xa6, 0xb1, 0xd3, 0x8b, 0xd8, 0x33, 0x6a, 0x66, 0x6c, 0xad, 0x61, 0x51, 0x9d, 0x5e, 0x2f, 0xcc, 0x3b, 0xfe,
	0xf5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0xb5, 0xaa, 0x61, 0xe, 0xa2, 0xae, 0x69, 0x23, 0xaa, 0x6f, 0xee, 0xc6, 0xaa, 0xc9, 0x28, 0xed, 0x55, 0xe0, 0x84,
	0x6b, 0xe6, 0xf3, 0xaa, 0x61, 0x20, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x12, 0xd1, 0x1d, 0xaa, 0x6f, 0xf6, 0xc6, 0x84, 0xa3, 0x5b, 0xb7, 0xb7, 0x84, 0xdb, 0xde, 0xc6, 0x96, 0x90, 0xed, 0x55, 0xe8, 0x84, 0xa3, 0x23, 0x3, 0xe0, 0xa6, 0x69, 0x33,
	0x84, 0xa6, 0xe1, 0x2d, 0xa3, 0x23, 0x8, 0xe4, 0xa3, 0x6f, 0xa0, 0x1d, 0x61, 0x1a, 0xe0, 0x95, 0xb4, 0xa3, 0xd0, 0x2b, 0x84, 0xd1, 0x22, 0xa2, 0xc8, 0x2d, 0xa3, 0xc8, 0x28, 0x84, 0x61, 0x3, 0xdd, 0x84, 0x61, 0x1b, 0xe8, 0x91, 0xe7, 0x6f,
	0xa3, 0xd2, 0x9, 0xeb, 0x84, 0x61, 0x1b, 0xc6, 0x91, 0xeb, 0x6f, 0xa3, 0xd5, 0x84, 0x61, 0x1b, 0xc6, 0x90, 0xeb, 0x84, 0x61, 0x1b, 0xdc, 0x91, 0xe1, 0x6f, 0xa3, 0xdf, 0x84, 0x61, 0x1b, 0xdc, 0xa3, 0x58, 0xcc, 0xe2, 0xe2, 0xe2, 0x84, 0xa3,
	0xed, 0xa6, 0x20, 0x84, 0x67, 0x22, 0x96, 0xed, 0x84, 0x6b, 0xe0, 0xaa, 0x61, 0x20, 0xe0, 0x1d, 0x25, 0x84, 0x61, 0xd8, 0xe2, 0x97, 0x6c, 0xd1, 0x22, 0xab, 0x69, 0x1a, 0xaa, 0x6f, 0xf6, 0xc6, 0xaa, 0x6f, 0xaa, 0x1d, 0x84, 0x10, 0x4d, 0xd1,
	0x2b, 0xed, 0x55, 0xe6, 0xe8, 0xaa, 0x61, 0x23, 0xe0, 0x84, 0x67, 0x22, 0x84, 0x6b, 0xa6, 0xed, 0x1e, 0x97, 0xc, 0xab, 0x69, 0x22, 0xaa, 0x61, 0x26, 0xa2, 0xbd, 0x21, 0xaa, 0xb1, 0xaa, 0x61, 0xe, 0xd2, 0xaa, 0x69, 0xbb, 0xea, 0xa7, 0xd1,
	0x22, 0xae, 0x6f, 0xff, 0x92, 0xe1, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0x23, 0xe0, 0xe2, 0xe2, 0xa3, 0xed, 0x55, 0xe6, 0xe2, 0x84, 0xa1, 0x6b, 0xe6, 0xfa, 0xab, 0x61, 0x22, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x4, 0xaa, 0x6f, 0xf7, 0x2d, 0xe6, 0xe2,
	0xe2, 0xab, 0x69, 0x29, 0xa, 0x11, 0x1c, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0xa3, 0x1c, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0xf7, 0xcc, 0x1c, 0x1d, 0x1d, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0xb7,
	0x1c, 0x1d, 0x1d, 0xaa, 0x61, 0x26, 0xd2, 0xb9, 0x21, 0x2e, 0x2e, 0x2e, 0xaa, 0xb1, 0xaa, 0x61, 0xe, 0xc2, 0xaa, 0x69, 0x60, 0x5a, 0xe2, 0xe2, 0xe2, 0xd1, 0x2b, 0xaa, 0x69, 0x38, 0x6b, 0xa8, 0xd2, 0xaa, 0x6b, 0xa8, 0xda, 0xda, 0xea, 0x96,
	0xee, 0x62, 0xda, 0xe0, 0x96, 0xe5, 0x25, 0xa0, 0xd2, 0xe0, 0xe2, 0xe2, 0x22, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0x1a, 0x1f, 0x1d, 0x1d, 0x69, 0xa1, 0xd2, 0xaa, 0x61, 0x26, 0xc2, 0xb9, 0x21, 0x2e, 0x2e, 0x2e, 0xaa, 0x6b, 0xae, 0xc6,
	0xea, 0xaa, 0x61, 0xe, 0xaa, 0xaa, 0x69, 0xa6, 0xc6, 0xb2, 0xaa, 0x69, 0xae, 0xc6, 0xb2, 0xaa, 0xdb, 0xaa, 0x1a, 0x96, 0xe6, 0xd1, 0x22, 0x9, 0xab, 0xaa, 0x69, 0xa6, 0xc6, 0xb2, 0xaa, 0x6b, 0xa6, 0xc6, 0xca, 0xaa, 0x69, 0xe7, 0x24, 0x1f,
	0x1d, 0x1d, 0xaa, 0x6b, 0xa6, 0xc6, 0xd2, 0xaa, 0x25, 0xa6, 0xc6, 0xc2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0xc3, 0xe0, 0xe2, 0xe2, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0x32, 0xaa, 0x69, 0xae, 0xc6, 0xd2, 0x1d, 0xb6, 0xc6, 0xca, 0xaa,
	0x6f, 0xe7, 0xc0, 0xe0, 0xe2, 0xe2, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0x32, 0x5a, 0xe3, 0xe2, 0xe2, 0xe2, 0xaa, 0x61, 0x26, 0xaa, 0x21, 0x2e, 0xaa, 0xb1, 0xb4, 0xb5, 0xaa, 0x61, 0xe, 0xc2, 0xaa, 0x69, 0x60, 0x5a, 0xe2, 0xe2, 0xe2, 0xaa,
	0x69, 0x98, 0xfa, 0xd1, 0x2b, 0x6b, 0xa8, 0xd2, 0xaa, 0x6b, 0xa8, 0xda, 0x62, 0xda, 0xec, 0xa6, 0x69, 0xaa, 0xf2, 0xa6, 0x69, 0xa2, 0xea, 0xaa, 0x69, 0x38, 0x69, 0xb2, 0xfa, 0x96, 0xeb, 0x25, 0xa1, 0xd2, 0xe0, 0xe2, 0xe2, 0x22, 0x9, 0xbc,
	0xa3, 0x59, 0xa6, 0xc2, 0xe3, 0x48, 0x69, 0x23, 0x69, 0x13, 0xa3, 0xd9, 0x31, 0xa3, 0x58, 0xa6, 0xd2, 0xe3, 0x48, 0x96, 0xed, 0xa3, 0xd9, 0x30, 0x97, 0xf3, 0x5a, 0xea, 0xe2, 0xe2, 0xe2, 0x6f, 0x92, 0x1e, 0x9, 0xe5, 0x5c, 0xe6, 0xe2, 0xe2,
	0xe2, 0x69, 0x24, 0xa6, 0xd9, 0x2a, 0x97, 0xc5, 0xa6, 0xd9, 0x24, 0x97, 0xc0, 0xa3, 0xd9, 0x31, 0x96, 0xe8, 0xa3, 0xd9, 0x30, 0x97, 0xec, 0xaa, 0x69, 0xed, 0x9, 0xe0, 0x69, 0xed, 0xa, 0xf3, 0x1d, 0x1d, 0x1d, 0x69, 0x2a, 0x69, 0x24, 0x6b,
	0xed, 0xaa, 0x6b, 0xa1, 0xda, 0x9, 0xe5, 0x25, 0xa1, 0xd2, 0xef, 0xe2, 0xe2, 0x22, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0x3d, 0x1e, 0x1d, 0x1d, 0x69, 0xa1, 0xd2, 0xaa, 0x61, 0x26, 0xc2, 0xbd, 0xbc, 0xb9, 0x21, 0xaa, 0xb1, 0xb5, 0xaa,
	0x61, 0xe, 0x8a, 0xaa, 0x69, 0x3b, 0xaa, 0x6f, 0xdf, 0x51, 0x1b, 0x1d, 0x1d, 0xae, 0x6f, 0xff, 0xce, 0xe0, 0xe2, 0xe2, 0xd1, 0x2b, 0xed, 0x55, 0x66, 0xdb, 0x96, 0xe5, 0xe2, 0xe2, 0x84, 0xa0, 0x6b, 0xe6, 0xfb, 0xaa, 0x61, 0x23, 0xe0, 0x84,
	0x67, 0x22, 0x97, 0x8, 0xaa, 0x6f, 0xf7, 0xef, 0xe1, 0xe2, 0xe2, 0xab, 0x69, 0x29, 0xa, 0xd3, 0x1f, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xa2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0x9d, 0x1e, 0x1d, 0x1d, 0xae, 0x6f, 0x7e, 0xc6, 0x72, 0xe2, 0xe2,
	0xe2, 0xae, 0x6f, 0xa6, 0xc6, 0xa2, 0xae, 0x6b, 0xbe, 0xc6, 0xd2, 0xa3, 0x5b, 0xe3, 0x48, 0xe2, 0xe2, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x24, 0xa6, 0xc6, 0xca, 0xe2, 0x25, 0xa6, 0xc6, 0xc2, 0xe2, 0xe2, 0xe2, 0xe2, 0x1d, 0xf7, 0x8d, 0x1e, 0x1d,
	0x1d, 0x67, 0x22, 0xed, 0x6a, 0x6d, 0xe2, 0xe2, 0xe2, 0xd1, 0x2b, 0xae, 0x6f, 0xff, 0x94, 0xe3, 0xe2, 0xe2, 0xed, 0x55, 0x66, 0xdb, 0xba, 0xe5, 0xe2, 0xe2, 0x84, 0xa0, 0x6b, 0xe6, 0xfb, 0xaa, 0x61, 0x23, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x8,
	0xaa, 0x6f, 0xf7, 0x7b, 0xe0, 0xe2, 0xe2, 0xab, 0x69, 0x29, 0xa, 0x5f, 0x1e, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xb2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0xe9, 0x1e, 0x1d, 0x1d, 0xaa, 0x6f, 0xb6, 0xc6, 0xa2, 0xaa, 0x6f, 0xae, 0xc6, 0xb2, 0x1d,
	0xf7, 0xf1, 0x1e, 0x1d, 0x1d, 0x67, 0x22, 0x69, 0x1a, 0x9b, 0xf2, 0xaa, 0x69, 0x6e, 0xc6, 0x72, 0xe2, 0xe2, 0xe2, 0x1d, 0xf7, 0xed, 0x1e, 0x1d, 0x1d, 0x9, 0xc9, 0xaa, 0x6f, 0xe7, 0x58, 0x1f, 0x1d, 0x1d, 0xaa, 0x6b, 0x61, 0x62, 0xe2, 0xe2,
	0xe2, 0xaa, 0x6b, 0xa1, 0x92, 0xaa, 0x6f, 0xe7, 0xb6, 0x1c, 0x1d, 0x1d, 0xaa, 0x6b, 0x61, 0x2, 0xe2, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0xd0, 0x1f, 0x1d, 0x1d, 0xaa, 0x6b, 0xa1, 0x8a, 0x69, 0x25, 0xaa, 0x61, 0x26, 0x8a, 0xbd, 0xb9, 0x21, 0x2e,
	0xbe, 0xe2, 0xa6, 0xe2, 0x8d, 0xe2, 0x91, 0xe2, 0xa6, 0xe2, 0x87, 0xe2, 0x94, 0xe2, 0x8b, 0xe2, 0x81, 0xe2, 0x87, 0xe2, 0x91, 0xe2, 0xbe, 0xe2, 0xe2, 0xe2, 0x2e, 0x2e, 0xbe, 0xe2, 0xa6, 0xe2, 0x87, 0xe2, 0x94, 0xe2, 0x8b, 0xe2, 0x81, 0xe2,
	0x87, 0xe2, 0xbe, 0xe2, 0xe2, 0xe2, 0x2e, 0x2e, 0x18, 0xed, 0xc2, 0x2, 0xaa, 0x6b, 0xe3, 0xaa, 0xc7, 0x1d, 0x1d, 0xd, 0x1d, 0xed, 0xc0, 0x2, 0x21, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0x69, 0xe3, 0xed, 0xc0, 0x2, 0x19, 0x21,
	0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0x90, 0xe0, 0x92, 0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0xb0, 0xe0, 0xd2, 0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0xd0, 0xe0, 0xd2, 0xe3, 0xeb, 0xe3, 0xe2, 0xeb, 0x60, 0xe2, 0xe2, 0xe3, 0xea, 0xe6, 0xe2, 0xea, 0xd0, 0xe6, 0x92,
	0xe1, 0x82, 0xe0, 0xd2, 0xe3, 0xe5, 0xe1, 0xe2, 0xe5, 0x20, 0xe1, 0x92, 0xe0, 0xd2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x4e, 0xe1, 0xe2, 0xe2, 0x9e, 0xe6, 0xe2, 0xe2, 0x4a, 0xe5, 0xe2, 0xe2, 0x9e, 0xe6, 0xe2, 0xe2,
	0x3, 0xe6, 0xe2, 0xe2, 0x52, 0xe5, 0xe2, 0xe2, 0x6, 0xe6, 0xe2, 0xe2, 0xc3, 0xe7, 0xe2, 0xe2, 0x5a, 0xe5, 0xe2, 0xe2, 0xc6, 0xe7, 0xe2, 0xe2, 0x6d, 0xe7, 0xe2, 0xe2, 0x22, 0xe5, 0xe2, 0xe2, 0x72, 0xe7, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2,
	0x2a, 0xe5, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2, 0xb5, 0xe5, 0xe2, 0xe2, 0x36, 0xe5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x65, 0xe2, 0x8, 0xe2, 0x1f, 0xe2, 0x78, 0xe2,
	0xa9, 0xe2, 0x91, 0xe2, 0xb6, 0xe2, 0x46, 0xe2, 0xbe, 0xe2, 0x6d, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbb, 0xe2, 0x95, 0xe2, 0x53, 0xe2, 0x15, 0xe2, 0x6a, 0xe2, 0x91, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbb, 0xe2, 0x54, 0xe2, 0x1c, 0xe2, 0x15, 0xe2, 0x2b, 0xe2, 0x50, 0xe2, 0x3f, 0xe2, 0x72, 0xe2, 0x21, 0xe2, 0x39, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x4a, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x64, 0xe9, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x18, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf0, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc8, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xbe, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x96, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbd, 0xe3, 0xab, 0x8d, 0xa6, 0x87, 0x8e, 0x87,
	0x96, 0x87, 0xa6, 0x87, 0x94, 0x8b, 0x81, 0x87, 0xe2, 0xe2, 0x83, 0xe3, 0xab, 0x8d, 0xa6, 0x87, 0x8e, 0x87, 0x96, 0x87, 0xb1, 0x9b, 0x8f, 0x80, 0x8d, 0x8e, 0x8b, 0x81, 0xae, 0x8b, 0x8c, 0x89, 0xe2, 0xe2, 0xdc, 0xe6, 0xb0, 0x96, 0x8e, 0xab,
	0x8c, 0x8b, 0x96, 0xb7, 0x8c, 0x8b, 0x81, 0x8d, 0x86, 0x87, 0xb1, 0x96, 0x90, 0x8b, 0x8c, 0x85, 0xe2, 0xe2, 0x14, 0xe3, 0xab, 0x8d, 0x84, 0xa1, 0x8d, 0x8f, 0x92, 0x8e, 0x87, 0x96, 0x87, 0xb0, 0x87, 0x93, 0x97, 0x87, 0x91, 0x96, 0xe2, 0xe2,
	0x20, 0xe0, 0xaf, 0x8f, 0xa5, 0x87, 0x96, 0xb1, 0x9b, 0x91, 0x96, 0x87, 0x8f, 0xb0, 0x8d, 0x97, 0x96, 0x8b, 0x8c, 0x87, 0xa3, 0x86, 0x86, 0x90, 0x87, 0x91, 0x91, 0xe2, 0xb7, 0xe3, 0xab, 0x8d, 0xa1, 0x90, 0x87, 0x83, 0x96, 0x87, 0xb1, 0x9b,
	0x8f, 0x80, 0x8d, 0x8e, 0x8b, 0x81, 0xae, 0x8b, 0x8c, 0x89, 0xe2, 0xe2, 0xae, 0xe3, 0xab, 0x8d, 0xa1, 0x90, 0x87, 0x83, 0x96, 0x87, 0xa6, 0x87, 0x94, 0x8b, 0x81, 0x87, 0xe2, 0xe2, 0x8c, 0x96, 0x8d, 0x91, 0x89, 0x90, 0x8c, 0x8e, 0xcc, 0x87,
	0x9a, 0x87, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xb2, 0xff, 0xe2, 0xe2, 0xe2, 0xe0, 0xe0, 0xe2,
	0xd2, 0x60, 0xff, 0xa2, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe5, 0xe0, 0x42, 0x60, 0xff, 0xd3, 0xd2, 0x60, 0xff, 0xcf, 0xe0, 0xe3, 0xe3, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0xd2,
	0xae, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe6, 0x42, 0xdc, 0xd2, 0xde, 0xd2, 0xf5, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xed, 0xd2, 0xeb, 0xe1, 0xe3, 0xe2, 0x42, 0xe6, 0x40, 0xe0,
	0x62, 0xe2, 0xd2, 0xc3, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0xe6, 0xf6, 0xff, 0xfe, 0x4d, 0x25, 0xde, 0x75, 0x24, 0x5e, 0x30, 0xd1, 0xfd, 0x65, 0x95, 0x3b, 0xed, 0x3e, 0x47, 0x93, 0xc7, 0x41, 0x42, 0x60, 0xfa,
	0x69, 0xd2, 0x60, 0xe1, 0xc, 0xd2, 0x60, 0xe1, 0xb5, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0x9c, 0x71, 0x9, 0x19, 0x9e, 0x24, 0xac, 0xbb, 0x8, 0xa9, 0x78, 0x95, 0x36, 0xe4, 0x1e, 0xd9, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64,
	0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0x63, 0x69, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb8, 0xa3, 0xd3, 0xf7, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xee, 0xb5, 0x87, 0x91, 0x96, 0x87, 0x90,
	0x8c, 0xc2, 0xa1, 0x83, 0x92, 0x87, 0xd3, 0xf6, 0xd2, 0xf0, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe9, 0xa6, 0x97, 0x90, 0x80, 0x83, 0x8c, 0x94, 0x8b, 0x8e, 0x8e, 0x87, 0xd3, 0xed, 0xd2, 0xef, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xe4, 0xb6,
	0x8a, 0x83, 0x95, 0x96, 0x87, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf6, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff,
	0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf4, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0x91, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd0, 0xd3, 0xd0, 0xd0, 0xd3, 0xd2,
	0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd2, 0xd3, 0xd0, 0xd1, 0xd2, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0xbc, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9,
	0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b,
	0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xd2, 0x60, 0xe3,
	0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x53, 0x4e, 0x51, 0xab, 0xb6, 0xa9, 0x75, 0xfe, 0xf0, 0xe8,
	0x3a, 0xc7, 0x9b, 0x73, 0xc0, 0xb5, 0xc8, 0x8d, 0x3e, 0x5a, 0xc4, 0x26, 0xa1, 0x91, 0x89, 0x20, 0x5d, 0xcc, 0xb2, 0xb8, 0x19, 0xf6, 0x20, 0x94, 0x6c, 0xa1, 0xe3, 0xc7, 0xa1, 0x56, 0x43, 0x0, 0xa7, 0x16, 0xa, 0x55, 0x99, 0x21, 0x96, 0x2e,
	0xc0, 0x35, 0x56, 0x76, 0xe2, 0xe0, 0x15, 0xaf, 0xf, 0x5d, 0x56, 0x55, 0xa6, 0xc6, 0x89, 0x2f, 0xbd, 0xa7, 0xd9, 0x33, 0xa6, 0x2c, 0xa1, 0xf0, 0x91, 0xf5, 0x60, 0x69, 0x8b, 0x56, 0xc9, 0x29, 0x7b, 0xfc, 0x4e, 0x90, 0xf9, 0xc4, 0xaf, 0x93,
	0xfd, 0x53, 0xd3, 0x3f, 0x19, 0xb3, 0x83, 0xe0, 0xb1, 0x44, 0x48, 0x17, 0xab, 0xce, 0xe7, 0x9a, 0xa7, 0x47, 0xcd, 0x6b, 0x2c, 0x5, 0x7b, 0x5, 0x1c, 0x6e, 0x0, 0xb5, 0xdd, 0xdf, 0x24, 0x70, 0x3e, 0xa8, 0x1a, 0x99, 0xd1, 0x6, 0x9b, 0xe8,
	0x19, 0x12, 0x97, 0x6a, 0xa3, 0x7e, 0x1d, 0x27, 0xe1, 0xb3, 0x7b, 0x48, 0x35, 0x8e, 0x7d, 0x71, 0x8b, 0x65, 0x87, 0xcb, 0x61, 0x67, 0x20, 0x82, 0xf6, 0x26, 0x2a, 0x2b, 0xd9, 0xf6, 0x38, 0x22, 0x63, 0x12, 0xfd, 0xef, 0x96, 0x3c, 0x70, 0xc0,
	0x49, 0x28, 0x15, 0x19, 0x96, 0x9e, 0xc5, 0x4, 0x15, 0xa8, 0xf9, 0x9d, 0x45, 0x21, 0x7c, 0xcf, 0x4c, 0x68, 0x8, 0x44, 0x4, 0x48, 0xc5, 0xf4, 0x9f, 0x83, 0x15, 0x7a, 0x93, 0xf3, 0x5e, 0x0, 0xb2, 0x43, 0xa9, 0x7, 0xbf, 0x18, 0x7, 0xec,
	0x45, 0xce, 0x7d, 0x48, 0x87, 0xc2, 0x31, 0x3a, 0x74, 0xa, 0x2a, 0x9e, 0x47, 0xac, 0xaa, 0xa6, 0x1d, 0xfb, 0x0, 0xa6, 0xe5, 0x70, 0xe9, 0x35, 0x8a, 0x66, 0x62, 0xbf, 0x88, 0x9a, 0x86, 0xa7, 0x2f, 0x82, 0xa4, 0x9c, 0xb6, 0x23, 0xf1, 0x9e,
	0x27, 0x9b, 0x13, 0x2b, 0x23, 0x93, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x63, 0x18, 0xd2, 0x63, 0x15, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0xbd, 0x78, 0x17, 0x8c, 0xbe, 0x2e, 0x2e, 0x96, 0x78, 0x36, 0x3f, 0x9f,
	0xd, 0xdd, 0x39, 0xe, 0xae, 0x62, 0xcc, 0x3f, 0xd2, 0xd0, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0xc4, 0xd2, 0xc6, 0xd2, 0xc0, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf4, 0x8a, 0x96,
	0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x8d, 0x81, 0x91, 0x92, 0xcc, 0x96, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xf0, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xea, 0xd2, 0xe4, 0xe3, 0xe3, 0x1d, 0xe0, 0xe3, 0xe2,
	0xd2, 0xdd, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xda, 0xd2, 0xd4, 0xd2, 0xd6, 0x42, 0xd0, 0x42, 0xd2, 0x64, 0xcc, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x81, 0x90, 0x8e, 0xcc, 0x96, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xcc, 0x81, 0x8d, 0x8f,
	0xcd, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xb6, 0x8b, 0x8f, 0x87, 0x91, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xa1, 0xa3, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4,
	0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xea, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3, 0xe4, 0xd2, 0xca, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc3, 0xd2, 0xfd, 0x46, 0xff, 0xd2, 0xf9, 0xd3, 0xfb, 0xd2,
	0xf5, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf2, 0xb6, 0x8b, 0x8f, 0x87, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0xcf, 0xd0, 0xd2, 0xd6, 0xda, 0xcf, 0xd3, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1,
	0x63, 0x63, 0xe2, 0xe1, 0xeb, 0x79, 0x6d, 0x9b, 0xd, 0x9d, 0xbb, 0xd2, 0x48, 0xd, 0x8a, 0x57, 0x18, 0x1, 0xeb, 0xff, 0x59, 0xad, 0x60, 0xe4, 0xbf, 0xd5, 0xbd, 0x44, 0xb0, 0x7d, 0xf4, 0x6f, 0x8, 0xfe, 0x70, 0xeb, 0xa6, 0x8c, 0x17, 0x8f,
	0x9, 0xba, 0x9e, 0xd2, 0xa, 0x1b, 0x8b, 0x6f, 0xc1, 0x91, 0xe9, 0xf0, 0x8d, 0xa5, 0x4b, 0x4c, 0xdb, 0xf3, 0x1a, 0xc8, 0x53, 0x79, 0x52, 0xf8, 0x21, 0x6c, 0x9, 0xbb, 0x74, 0xe2, 0x4f, 0x2c, 0xee, 0xaf, 0x50, 0x32, 0xd3, 0x44, 0xea, 0xbe,
	0xc8, 0x98, 0x1e, 0x0, 0x98, 0xff, 0xb5, 0xae, 0x4a, 0x87, 0xfa, 0xb, 0x9b, 0xa2, 0x80, 0xc7, 0x74, 0x8c, 0x25, 0x25, 0xd5, 0x88, 0x61, 0xc3, 0xea, 0x6c, 0xa3, 0x8, 0x3f, 0x3b, 0xb5, 0xdd, 0xff, 0x95, 0xab, 0x65, 0xc8, 0xf4, 0xe4, 0xbc,
	0x44, 0xda, 0x88, 0xc0, 0xf0, 0x41, 0xb3, 0xfb, 0x61, 0x9c, 0x54, 0xd2, 0x60, 0xe6, 0x41, 0xd2, 0x60, 0xe1, 0x69, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0xec, 0x2d, 0x16, 0xda, 0x2a, 0x1c, 0x5d, 0xd7, 0x8c, 0xe6, 0x3a, 0x88, 0x7a, 0xf9,
	0xf8, 0xb2, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0xbc, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6,
	0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd0, 0xd3,
	0xd2, 0xd3, 0xda, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd2, 0xd3, 0xd0, 0xd0, 0xdb, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x80, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1,
	0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd6, 0xd2, 0xd0, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1,
	0xf1, 0xc9, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x87, 0x90,
	0xc2, 0xcf, 0xc2, 0xa5, 0xd6, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x40, 0x81,
	0xe9, 0xdb, 0xa6, 0x5a, 0x59, 0xc1, 0x45, 0xa6, 0xab, 0x59, 0xec, 0x1d, 0x43, 0x12, 0x83, 0xe8, 0xb1, 0x71, 0x52, 0x7a, 0x39, 0x4f, 0xce, 0xed, 0xa8, 0x27, 0x8c, 0x1d, 0x64, 0xde, 0xb1, 0xb7, 0xed, 0xf7, 0x2c, 0xe6, 0xdd, 0xc9, 0x1f, 0x4b,
	0x74, 0x74, 0x3b, 0x5c, 0x83, 0x9b, 0xe9, 0xb9, 0x2b, 0xae, 0x64, 0x94, 0x7, 0x2, 0xa1, 0xa9, 0xc0, 0x77, 0xc, 0x20, 0xc9, 0xa1, 0x23, 0x7d, 0x3a, 0x8a, 0x56, 0x6c, 0xa2, 0xad, 0xc, 0x67, 0xda, 0x5b, 0xf3, 0x27, 0xc1, 0x10, 0x86, 0xba,
	0x12, 0xf7, 0xd0, 0x8d, 0xac, 0xb5, 0x43, 0x4c, 0x6a, 0x46, 0xe0, 0x35, 0xc8, 0xfc, 0x2f, 0xa9, 0x3, 0x3f, 0x81, 0x37, 0xf5, 0x6b, 0xd0, 0xb9, 0x52, 0xbc, 0x7b, 0xb8, 0x4a, 0x7f, 0xca, 0xb2, 0xec, 0xf5, 0xc, 0x74, 0x39, 0x83, 0xd9, 0xa7,
	0xb3, 0xff, 0x2d, 0xf0, 0xb4, 0xe9, 0x70, 0xa5, 0x1e, 0x49, 0x4c, 0x14, 0x84, 0xdf, 0xa5, 0x4e, 0x92, 0x90, 0x5, 0x70, 0x5, 0xbd, 0x2f, 0xf2, 0x5b, 0x26, 0x61, 0x86, 0x76, 0xfb, 0x5f, 0xc7, 0x62, 0x3, 0xa, 0x30, 0xc0, 0x47, 0x32, 0x58,
	0xe0, 0x98, 0x43, 0x95, 0x71, 0xb9, 0x87, 0x21, 0xc, 0xf5, 0x96, 0x5e, 0xa3, 0x64, 0xc8, 0x3e, 0xea, 0xae, 0x6e, 0x70, 0x6e, 0x73, 0xcf, 0x7c, 0x95, 0xa6, 0xfd, 0x8a, 0x34, 0x4a, 0x96, 0x95, 0x39, 0xec, 0xb9, 0xd0, 0x69, 0xb4, 0x69, 0xd1,
	0x5f, 0x3b, 0x81, 0x2a, 0xab, 0x7f, 0xd8, 0x27, 0x27, 0x8, 0xd1, 0xe9, 0x30, 0x13, 0x41, 0xf9, 0x16, 0x69, 0x5c, 0x3b, 0x51, 0xb5, 0x69, 0xd9, 0x3c, 0xe6, 0x45, 0x98, 0xc0, 0x50, 0xc6, 0x4c, 0xcc, 0x25, 0x92, 0x27, 0x5c, 0xac, 0x61, 0xc4,
	0xea, 0x19, 0xe9, 0x5f, 0x4b, 0xad, 0x7b, 0xea, 0x3, 0xf2, 0xca, 0x90, 0x48, 0x2f, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0xb5, 0xd2, 0x60, 0xe3, 0xb1, 0xd2, 0xee, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xe0, 0xd2,
	0xe2, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe3, 0xe3, 0x1d, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xea, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe5,
	0x62, 0xd2, 0x91, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0x85, 0xd2, 0x87, 0xd2, 0xc8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xfc, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x96, 0x91,
	0xcf, 0x8d, 0x81, 0x91, 0x92, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xd5, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe0, 0x64, 0xc9, 0x8a, 0x96, 0x96, 0x92, 0xd8,
	0xcd, 0xcd, 0x96, 0x91, 0xcf, 0x83, 0x8b, 0x83, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x96, 0x91, 0x91, 0xcf, 0x81, 0x83, 0xcf, 0x85, 0xd0, 0xcc, 0x81, 0x87, 0x90, 0xd2, 0xde,
	0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xd7, 0xd2, 0xd1, 0xd2, 0xd3, 0x42, 0xcd, 0x42, 0xcf, 0x64, 0xc9, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x96, 0x91, 0xcf, 0x81, 0x90, 0x8e, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x96, 0x91, 0x91, 0xcf, 0x81, 0x83, 0xcf, 0x85, 0xd0, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xca, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc3, 0xd2, 0xfd, 0x46, 0xff, 0xd2, 0xf9, 0xd3, 0xfb, 0xd2, 0xf5, 0xe4,
	0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf2, 0xb6, 0x8b, 0x8f, 0x87, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0xcf, 0xd0, 0xd2, 0xd6, 0xda, 0xcf, 0xd0, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0xa4, 0x24, 0x8b, 0x41, 0xec, 0xa8, 0xf6,
	0xfc, 0x37, 0xae, 0x38, 0xb0, 0x81, 0xf5, 0xdd, 0xbc, 0xd4, 0x5e, 0xef, 0x4, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0xbd, 0x78, 0x17, 0x8c, 0xbe, 0x2e, 0x2e, 0x96, 0x78, 0x36, 0x3f, 0x9f, 0xd, 0xdd,
	0x39, 0xe, 0xae, 0x62, 0xcc, 0x3f, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0x9a, 0xd9, 0x56, 0x73, 0xc8, 0xe2, 0xae, 0x12, 0x6d, 0x80, 0xd2, 0xd5, 0x9a, 0x41,
	0x66, 0xc5, 0xe5, 0x8d, 0xfa, 0x50, 0x3c, 0xc7, 0x3e, 0x42, 0x36, 0x76, 0xe1, 0x48, 0x64, 0xac, 0xc7, 0x7d, 0x78, 0xa2, 0xe1, 0xfe, 0x3f, 0x2c, 0x1, 0x9b, 0x29, 0xc3, 0x8a, 0xe4, 0x38, 0x54, 0xd0, 0x56, 0x8f, 0x5d, 0x16, 0xce, 0xc4, 0x81,
	0xd1, 0x6, 0xab, 0x86, 0x8f, 0xef, 0x4, 0x21, 0x85, 0xec, 0x15, 0xe7, 0x46, 0xd7, 0x8e, 0x9e, 0x6b, 0xf4, 0x24, 0xb, 0x50, 0x3d, 0x50, 0xb, 0x3f, 0xc2, 0x24, 0x93, 0xed, 0x2f, 0x77, 0x96, 0x3e, 0x54, 0xbe, 0x3c, 0x5f, 0xd5, 0xfd, 0xa1,
	0x9a, 0x4, 0x9a, 0x57, 0x2f, 0xca, 0xe6, 0xc2, 0x41, 0x48, 0x13, 0xa9, 0x26, 0x6a, 0xcb, 0x73, 0xec, 0x62, 0x33, 0xf3, 0x1e, 0x3f, 0xbe, 0x94, 0x8c, 0xad, 0xbc, 0xec, 0xa7, 0xa4, 0xa3, 0x8c, 0xef, 0x52, 0x8, 0xda, 0x78, 0x53, 0xd8, 0x38,
	0xeb, 0x93, 0xf2, 0x1e, 0xfe, 0x9b, 0x56, 0x62, 0x99, 0x4e, 0x8b, 0x16, 0x1f, 0x7e, 0x54, 0xee, 0xf4, 0xc9, 0x13, 0x9d, 0xb9, 0xeb, 0xdf, 0x79, 0xb9, 0x0, 0xf4, 0x28, 0xf1, 0x63, 0x8f, 0xe2, 0xcc, 0xda, 0xef, 0x4a, 0xcb, 0x6d, 0xce, 0x3,
	0x50, 0x16, 0xb8, 0x4b, 0xe3, 0x4d, 0xf7, 0x7e, 0xce, 0xcd, 0xab, 0xf9, 0x39, 0xc0, 0x59, 0x21, 0x1c, 0x9a, 0x76, 0xb3, 0x21, 0x64, 0x53, 0x60, 0x6a, 0xbf, 0x12, 0xdf, 0x56, 0xb3, 0x43, 0x9b, 0xd1, 0xc9, 0xcc, 0x99, 0x5b, 0x3e, 0xc2, 0xeb,
	0xf1, 0x93, 0x9, 0x88, 0xfb, 0xb9, 0x2d, 0xa, 0x47, 0xd2, 0xb5, 0xce, 0x6b, 0xab, 0xdd, 0x5b, 0x2d, 0x9d, 0x2b, 0x5d, 0xdc, 0xc0, 0x8a, 0x81, 0xb1, 0x78, 0x5f, 0x8b, 0x96, 0x4e, 0x27, 0xff, 0xde, 0x9d, 0x70, 0x2, 0x21, 0x5e, 0xfe, 0x3a,
	0xe6, 0x97, 0xd2, 0x60, 0xe6, 0x11, 0xd2, 0x60, 0xe1, 0x39, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0x9c, 0xbb, 0xa2, 0x6f, 0xde, 0x7b, 0x27, 0xf3, 0x4a, 0xb1, 0x19, 0xcd, 0x91, 0x22, 0xdf, 0x26, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa,
	0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2,
	0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7,
	0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd4, 0xd2, 0xd7, 0xd2, 0xd0, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd3, 0xd5, 0xd2, 0xd7,
	0xd2, 0xd0, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x63, 0x68, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xa8, 0xb2, 0xd3, 0xec, 0xd2, 0xee, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xe7, 0xad, 0x91, 0x83, 0x89,
	0x83, 0xd3, 0xf2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe5, 0xa1, 0x8a, 0x97, 0x8d, 0xcf, 0x89, 0x97, 0xd3, 0xfa, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf6, 0xed, 0xa1, 0xa3, 0xb2, 0xa1, 0xad, 0xaf, 0xc2, 0xa1, 0x8d, 0xcc,
	0xce, 0xae, 0x96, 0x86, 0xcc, 0xd3, 0xc7, 0xd2, 0xc1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf6, 0xfe, 0xb0, 0xc4, 0xa6, 0xc2, 0xa3, 0x91, 0x91, 0x87, 0x96, 0xc2, 0xaf, 0x83, 0x8c, 0x83, 0x85, 0x87, 0x8f, 0x87, 0x8c, 0x96, 0xc2, 0xb1, 0x87, 0x81,
	0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfa, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf6, 0xed, 0xa1, 0xa3, 0xb2, 0xa1, 0xad, 0xaf, 0xc2, 0xa1, 0x8d, 0xcc, 0xce, 0xae, 0x96, 0x86, 0xcc, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64,
	0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x30, 0xc7, 0x78, 0xcf, 0x4a, 0x81, 0x33, 0xfa, 0x2b, 0x85, 0xa5, 0x96, 0xd1, 0xeb, 0x83, 0x5d, 0xc2,
	0x63, 0x1a, 0x8, 0xf9, 0x40, 0x9a, 0xca, 0xfa, 0x5f, 0xb3, 0x63, 0x62, 0xf3, 0xf8, 0xd4, 0x36, 0x56, 0x3d, 0xbe, 0xb5, 0xb7, 0x4c, 0x2a, 0x24, 0x32, 0x7a, 0x53, 0x78, 0x3d, 0x40, 0xa3, 0x1d, 0x89, 0xa, 0xd8, 0x8, 0x4, 0x11, 0x3c, 0xae,
	0xc7, 0xfb, 0x4b, 0x9b, 0x88, 0x5e, 0xa1, 0x5, 0xac, 0x88, 0x86, 0xde, 0x4f, 0x30, 0x8, 0x7, 0xc0, 0x7c, 0x28, 0xb9, 0xa0, 0xa1, 0xad, 0x23, 0x79, 0x2, 0xfc, 0x3a, 0x44, 0x54, 0x21, 0x1c, 0x94, 0x9f, 0xf8, 0x80, 0x54, 0x7d, 0xc, 0xc,
	0x1c, 0x8c, 0x6, 0x7c, 0xe8, 0xa7, 0x2a, 0x95, 0x27, 0xf5, 0x22, 0x37, 0xac, 0x20, 0x4, 0xe5, 0xa2, 0xd6, 0x51, 0xd5, 0x96, 0x68, 0x12, 0xa6, 0x29, 0x6b, 0xfc, 0xac, 0xcc, 0xbe, 0x3e, 0x3d, 0xba, 0x6a, 0x9, 0xf6, 0xdf, 0xda, 0xd6, 0x4d,
	0x88, 0x43, 0x33, 0xd7, 0xca, 0x50, 0xf2, 0x57, 0xc0, 0x7, 0xa4, 0x49, 0xe9, 0x5f, 0x12, 0x45, 0xc1, 0x29, 0xde, 0xda, 0x86, 0xd0, 0x52, 0x25, 0xdc, 0xa4, 0xc4, 0xf3, 0x65, 0x4d, 0xa0, 0xe0, 0xf6, 0xb4, 0x2, 0x92, 0xd9, 0xb8, 0xcc, 0xb0,
	0x84, 0xde, 0xbc, 0x6, 0x68, 0xa3, 0x51, 0x84, 0xbb, 0x29, 0x91, 0x39, 0x72, 0x67, 0xce, 0xf, 0x16, 0x69, 0x70, 0xed, 0xc2, 0x8e, 0x86, 0x6e, 0x1a, 0x18, 0xad, 0xf7, 0x9, 0x79, 0x6, 0xc8, 0xe8, 0x82, 0xba, 0x53, 0xbf, 0xa3, 0x43, 0x46,
	0x7b, 0x25, 0xe5, 0x34, 0x13, 0x57, 0xf0, 0xa3, 0x25, 0x6d, 0x76, 0xd1, 0xf6, 0xc3, 0xc9, 0xc0, 0x8, 0x16, 0x41, 0x28, 0x6f, 0x54, 0x1a, 0xee, 0x7, 0x7a, 0xf9, 0x2d, 0x96, 0x32, 0xac, 0x38, 0x1e, 0x27, 0x6c, 0xc5, 0x47, 0x62, 0x1d, 0xe0,
	0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0xbf, 0xd2, 0x60, 0xe3, 0xbb, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe6, 0xe0, 0xd2, 0xe2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe5, 0x62, 0xd2,
	0xc9, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xc6, 0xd2, 0xc0, 0xd2, 0xc2, 0x42, 0xfc, 0x42, 0xfe, 0x64, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x91, 0x94,
	0xcc, 0x81, 0x90, 0x8e, 0xd2, 0x83, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6, 0xb8, 0xd2, 0xba, 0xd2, 0xb4, 0xe4, 0xe4, 0x85, 0x63, 0xee, 0xe3, 0xe6, 0xe3, 0xd2, 0xae, 0xd2, 0xc1, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe3, 0xf4,
	0xf5, 0x8a, 0x96, 0x96, 0x92, 0x91, 0xd8, 0xcd, 0xcd, 0x86, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x81, 0x92, 0x91, 0xd2, 0xc7, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe0, 0xd2, 0xfb, 0xee, 0xf5,
	0x8a, 0x96, 0x96, 0x92, 0x91, 0xd8, 0xcd, 0xcd, 0x86, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x90, 0x92, 0x83, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7,
	0xe7, 0xe5, 0xe1, 0xe1, 0xd2, 0xb5, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0xa9, 0xd2, 0xab, 0xd2, 0xfd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf1, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd,
	0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x86, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xc4, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe0, 0x64, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f,
	0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x91, 0x94, 0xcc, 0x81, 0x90, 0x96, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x74, 0xd9, 0xb1, 0x12, 0x9b, 0xd1, 0x75, 0x4d, 0x9f, 0x61, 0xd, 0xcc, 0xc9, 0x2e,
	0x28, 0x55, 0x64, 0xfc, 0x90, 0x84, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x97, 0x74, 0xa, 0x69, 0x73, 0xd9, 0xdc, 0xb7, 0xa9, 0x9, 0xa7, 0x11, 0x45, 0x75, 0x76, 0xf7, 0x7d, 0x4, 0x46, 0xf, 0xd2, 0xef, 0xe4,
	0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0x89, 0xcb, 0x24, 0xeb, 0x7, 0x41, 0x5e, 0xaf, 0xcc, 0xd9, 0xbb, 0x40, 0xc9, 0xa0, 0x2d, 0x3e, 0x16, 0xeb, 0xf2, 0xa9, 0x4, 0x2e, 0x95,
	0x85, 0x80, 0xae, 0xad, 0x74, 0x37, 0x67, 0xd, 0x60, 0xa1, 0xb7, 0xaf, 0x0, 0xb3, 0xd5, 0xb6, 0x64, 0x9d, 0x86, 0x5, 0x1f, 0x31, 0x79, 0xe2, 0x77, 0x8b, 0xe1, 0xc, 0x5, 0x4e, 0x82, 0x65, 0x86, 0xf9, 0x60, 0x3a, 0x36, 0x77, 0xaa, 0xc2,
	0xc9, 0x61, 0xab, 0xea, 0xbf, 0x70, 0x7a, 0x2a, 0x0, 0xab, 0x6d, 0xc2, 0x76, 0xfb, 0xe8, 0x46, 0x8e, 0x3f, 0x42, 0xb3, 0xef, 0x71, 0x9f, 0xa8, 0x55, 0xd9, 0x46, 0x8b, 0xc0, 0x74, 0x90, 0xa2, 0x9a, 0xc0, 0x56, 0x9e, 0xad, 0xf1, 0xf0, 0xa5,
	0xb8, 0xf6, 0x4f, 0x29, 0xcb, 0xf8, 0xf2, 0xfd, 0xe1, 0x82, 0x4e, 0x3e, 0x18, 0x86, 0x44, 0x48, 0x2b, 0xf6, 0x99, 0xe1, 0xad, 0x2c, 0x45, 0x80, 0x20, 0x44, 0x68, 0xf2, 0xda, 0x67, 0xc2, 0x6b, 0xc0, 0xa4, 0xfb, 0x72, 0xd, 0xe9, 0x11, 0x4,
	0xe0, 0x58, 0x76, 0xc0, 0xb5, 0x51, 0x84, 0xe6, 0xd, 0xaa, 0xd0, 0x25, 0xf7, 0x37, 0xd0, 0xe9, 0x7b, 0x37, 0x1f, 0xb9, 0x45, 0x45, 0x83, 0xca, 0xf, 0x8f, 0xe9, 0x45, 0x2d, 0x72, 0x26, 0xd4, 0xcc, 0x0, 0x4b, 0x86, 0xc0, 0x18, 0xa8, 0x8b,
	0x37, 0x4d, 0xe5, 0xe9, 0x49, 0x16, 0x4f, 0x9a, 0x88, 0x3d, 0x46, 0xd8, 0xc3, 0x33, 0x4c, 0x71, 0x1c, 0x3d, 0x2c, 0x13, 0xd9, 0x9c, 0xcd, 0xb4, 0x55, 0x24, 0xfb, 0x15, 0x36, 0xe9, 0x28, 0x1a, 0x97, 0x8c, 0xeb, 0x9b, 0x98, 0x7b, 0xca, 0x38,
	0x4b, 0xe8, 0xba, 0xce, 0x6c, 0x93, 0x62, 0x2f, 0x54, 0xcd, 0xa5, 0x22, 0x65, 0xde, 0x25, 0xea, 0x11, 0x1, 0x74, 0x60, 0xe8, 0x9d, 0x3c, 0x1b, 0xcb, 0xfb, 0xed, 0xa, 0x8f, 0x8, 0xe9, 0xc7, 0x84, 0xd2, 0x60, 0xe7, 0xbb, 0xd2, 0x60, 0xe6,
	0xa3, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0xdf, 0x9a, 0x35, 0x1b, 0x94, 0xab, 0x82, 0x50, 0x83, 0x9f, 0x16, 0x12, 0xfc, 0x28, 0x64, 0xc8, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xd2,
	0x63, 0x28, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf5, 0xd2, 0xf7, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xec, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc,
	0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd8, 0xd2, 0xda, 0xe4, 0xe1, 0xb7,
	0xe6, 0xe9, 0xf1, 0xd3, 0xca, 0x81, 0xcb, 0xc2, 0xd0, 0xd2, 0xd2, 0xd4, 0xc2, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xc2, 0xcf, 0xc2, 0xa4, 0x8d, 0x90, 0xc2, 0x83, 0x97, 0x96, 0x8a, 0x8d, 0x90,
	0x8b, 0x98, 0x87, 0x86, 0xc2, 0x97, 0x91, 0x87, 0xc2, 0x8d, 0x8c, 0x8e, 0x9b, 0xd3, 0xa7, 0xd2, 0xa1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xde, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1,
	0xc2, 0xb2, 0x97, 0x80, 0x8e, 0x8b, 0x81, 0xc2, 0xb2, 0x90, 0x8b, 0x8f, 0x83, 0x90, 0x9b, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xa3, 0x97, 0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x96, 0x9b, 0xc2,
	0xcf, 0xc2, 0xa5, 0xd7, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd1, 0xd3, 0xd0, 0xd3, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd1, 0xd3, 0xd0, 0xd2, 0xdb, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x9d, 0xd3, 0xe9,
	0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b,
	0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4,
	0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7, 0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b,
	0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x75, 0x61,
	0xfc, 0xe2, 0xf4, 0x4d, 0xce, 0x53, 0x30, 0xea, 0x26, 0x35, 0x8a, 0x71, 0xb3, 0x82, 0xfc, 0x93, 0x14, 0x0, 0xa5, 0x56, 0x39, 0xba, 0xaf, 0xc1, 0x80, 0x88, 0x56, 0x5d, 0xb8, 0xf9, 0xb3, 0x15, 0x41, 0xef, 0xfa, 0x95, 0x8a, 0x59, 0x3a, 0xd4,
	0x49, 0xcd, 0xc3, 0xb2, 0x38, 0x7c, 0x11, 0x5, 0xbd, 0xc5, 0xac, 0xe9, 0x20, 0x75, 0x2a, 0xeb, 0x92, 0x71, 0x4b, 0x38, 0xbe, 0xef, 0xac, 0x46, 0xef, 0x73, 0x42, 0x56, 0xe, 0xf6, 0x2c, 0x73, 0x90, 0xb6, 0xcc, 0x2c, 0x41, 0x39, 0xa6, 0xb,
	0xb0, 0xf9, 0xdd, 0xa3, 0xde, 0x28, 0xa8, 0x6, 0x48, 0x22, 0xa, 0xdb, 0x49, 0xb1, 0x2e, 0xc3, 0x32, 0x2e, 0x2d, 0x9d, 0x79, 0x4, 0x20, 0x2e, 0xba, 0x88, 0x60, 0xf7, 0xc, 0xdf, 0xd4, 0x2d, 0xfe, 0x27, 0x75, 0xe5, 0xc6, 0x6c, 0x13, 0x99,
	0x5c, 0xd3, 0xcf, 0xdf, 0x8c, 0x3e, 0x57, 0x7b, 0xa0, 0x7d, 0xa9, 0x83, 0x77, 0xbd, 0xfe, 0x92, 0xc, 0xf5, 0x9f, 0x39, 0x69, 0x7, 0x83, 0x6b, 0x9a, 0x25, 0x8a, 0xf9, 0x4d, 0xf3, 0x9a, 0xf8, 0x7a, 0x4c, 0x26, 0xb7, 0xa5, 0xb1, 0x3b, 0x51,
	0xd0, 0x34, 0x43, 0xec, 0xa4, 0xa2, 0x27, 0x75, 0x70, 0x68, 0x33, 0xb1, 0x45, 0x7b, 0xb9, 0x67, 0xd7, 0xb5, 0x31, 0x8, 0x71, 0x80, 0x83, 0xc2, 0xe8, 0x25, 0xd2, 0x95, 0xc6, 0xf3, 0xaf, 0x80, 0x61, 0x54, 0x58, 0x99, 0x8a, 0x60, 0xd3, 0xc,
	0x87, 0x28, 0x3d, 0x1b, 0x37, 0x6f, 0x50, 0xd7, 0x3e, 0x6e, 0xc9, 0x8d, 0x88, 0x90, 0xbe, 0x82, 0x66, 0x7e, 0x10, 0xee, 0x76, 0xbc, 0x22, 0xb4, 0xb0, 0xe2, 0xaa, 0x2e, 0x31, 0x1a, 0x47, 0x9f, 0x3c, 0xcd, 0x35, 0xf1, 0x6, 0xda, 0x4a, 0x66,
	0x37, 0xa4, 0x5a, 0xf1, 0x64, 0x20, 0xf9, 0x7f, 0x8, 0xb8, 0xda, 0x3f, 0x79, 0x39, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0x61, 0xd2, 0x60, 0xe3, 0x9d, 0xd2, 0xcd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6,
	0xc1, 0xd2, 0xc3, 0xd2, 0xfd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf1, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0xd0, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xf0, 0xe4, 0xe1,
	0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xea, 0xd2, 0xe4, 0xe3, 0xe3, 0x1d, 0xe0, 0xe3, 0xe2, 0xd2, 0x8e, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6, 0x87, 0xd2, 0x81, 0xd2, 0x83, 0xe4, 0xe9, 0x82, 0x64, 0xaa, 0xe3, 0x64, 0x1a, 0xa7, 0xe3, 0xe5,
	0xf5, 0xe1, 0xd2, 0xb0, 0xd2, 0xc4, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe3, 0xf4, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x95, 0x95, 0x95, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x97, 0x96, 0x8a, 0xcc, 0x81, 0x8d, 0x8f,
	0xcd, 0x81, 0x92, 0x91, 0xd2, 0xca, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe0, 0xd2, 0xfe, 0xf8, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x95, 0x95, 0x95, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x97, 0x96, 0x8a, 0xcc, 0x81,
	0x8d, 0x8f, 0xcd, 0x90, 0x92, 0x83, 0xd2, 0xd2, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xcb, 0xd2, 0xc5, 0xd2, 0xc7, 0x42, 0xc1, 0x42, 0xc3, 0x64, 0xfd, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0xd3, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80,
	0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x92, 0x81, 0x83, 0xd1, 0xcf, 0x85, 0xd7, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xf4, 0xd2, 0xf6, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xe0, 0xe4, 0xea, 0xc9,
	0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xe1, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3, 0xe4, 0xd2, 0xcb, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc0, 0xd2, 0xc2, 0x46, 0xfc, 0xd2, 0xfe, 0xd3, 0xf8,
	0xd2, 0xfa, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf3, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xb2, 0xa9, 0xab, 0xcf, 0xd3, 0xcf, 0xd7, 0xd4, 0xd5, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x74, 0xd9, 0xb1,
	0x12, 0x9b, 0xd1, 0x75, 0x4d, 0x9f, 0x61, 0xd, 0xcc, 0xc9, 0x2e, 0x28, 0x55, 0x64, 0xfc, 0x90, 0x84, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x9d, 0x31, 0x87, 0x45, 0x20, 0x3f, 0xe, 0x59, 0x12, 0xd2,
	0xeb, 0x11, 0xa1, 0xdb, 0x18, 0xe0, 0x4d, 0xd1, 0xd3, 0xd1, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0xf1, 0x67, 0xf8, 0xfc, 0x8b, 0x4b, 0xd5, 0x15, 0x42, 0x5f,
	0x46, 0x4d, 0x9c, 0xff, 0x83, 0xb1, 0x1c, 0x7f, 0x6e, 0xbc, 0xee, 0x44, 0x97, 0xfc, 0x9a, 0xf5, 0xc1, 0x3f, 0x1f, 0xe, 0xf8, 0xe1, 0xb7, 0xdb, 0x19, 0x93, 0x77, 0x25, 0x87, 0xb8, 0x45, 0x6c, 0xd2, 0x30, 0xa6, 0xb8, 0x83, 0x39, 0x92, 0x8d,
	0x38, 0xc3, 0xe7, 0x20, 0xcc, 0x91, 0x58, 0xab, 0x13, 0x33, 0x71, 0x1c, 0xbf, 0x2b, 0x2f, 0xbc, 0xe1, 0x2, 0x6b, 0x7c, 0xdd, 0x96, 0xfc, 0x35, 0x15, 0xda, 0x69, 0x4b, 0x34, 0x2d, 0x59, 0xd7, 0xcd, 0xd1, 0xba, 0x4a, 0x70, 0xb4, 0x33, 0x2a,
	0xaf, 0xd9, 0x60, 0x4, 0x9b, 0x66, 0xf4, 0x1e, 0xca, 0x52, 0x53, 0xa5, 0x11, 0xff, 0x40, 0xdc, 0xc, 0x65, 0x3b, 0x44, 0x9d, 0x46, 0xb4, 0x47, 0xdd, 0x4f, 0x66, 0xcc, 0xcb, 0x3c, 0x9e, 0x5e, 0x4a, 0x48, 0x41, 0xdf, 0xe6, 0xe3, 0x8, 0x58,
	0x71, 0x40, 0xec, 0xb2, 0xc0, 0xcb, 0xf5, 0xae, 0x65, 0x6, 0xd8, 0xf3, 0xbd, 0x34, 0x46, 0xc7, 0x6b, 0x79, 0xe7, 0x89, 0xcd, 0x56, 0x2b, 0xe3, 0xae, 0xc5, 0x99, 0xe9, 0x4e, 0xfb, 0xe7, 0xc0, 0x42, 0x82, 0xf7, 0xdd, 0x38, 0x2b, 0x19, 0xaf,
	0xae, 0x6d, 0x19, 0x90, 0x85, 0x95, 0x1f, 0xc5, 0x76, 0x25, 0x58, 0xd7, 0xec, 0x6a, 0xab, 0x1c, 0x6f, 0x1f, 0xca, 0x4d, 0xa8, 0xf0, 0x5f, 0xef, 0x51, 0x75, 0xe7, 0x3c, 0xa6, 0xee, 0xf7, 0x18, 0xd4, 0xc9, 0xe1, 0x3e, 0x23, 0xb2, 0xe3, 0x13,
	0x43, 0xf3, 0xbf, 0xf6, 0x7, 0x0, 0x5f, 0xc5, 0xa9, 0xb6, 0x5c, 0xc9, 0x66, 0xbc, 0xed, 0x44, 0x21, 0x96, 0xe7, 0xe8, 0xd, 0x75, 0x21, 0x6b, 0xc0, 0x53, 0xfd, 0x95, 0x11, 0x5f, 0x2f, 0xa1, 0x36, 0x13, 0xae, 0x4b, 0xdd, 0x57, 0x69, 0x66,
	0x4d, 0x86, 0x10, 0x32, 0xf6, 0xc3, 0xd2, 0x60, 0xe7, 0x78, 0xd2, 0x60, 0xe1, 0x60, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xe8, 0x83, 0xfb, 0x71, 0x6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xfe, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15,
	0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf1, 0xd2, 0xf3, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xe8, 0xb5, 0x83, 0x91, 0x8a, 0x8b, 0x8c, 0x85, 0x96,
	0x8d, 0x8c, 0xd3, 0xf2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe5, 0xb0, 0x87, 0x86, 0x8f, 0x8d, 0x8c, 0x86, 0xd3, 0xfc, 0xd2, 0xfe, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf7, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96,
	0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xcb, 0xd2, 0xc5, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc2, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb4, 0x87,
	0x90, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xb0, 0x8d, 0x8d, 0x96, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd3, 0xd2, 0xd0, 0xd0, 0xd0, 0xd3, 0xdb, 0xd0, 0xd7, 0xd3, 0xd5, 0xb8, 0xf5, 0xef, 0xd0, 0xd3, 0xd2, 0xd0, 0xd0, 0xd0,
	0xd3, 0xdb, 0xd1, 0xd7, 0xd3, 0xd5, 0xb8, 0xd2, 0x63, 0x28, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf5, 0xd2, 0xf7, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xec, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b,
	0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90,
	0x89, 0xd3, 0xd8, 0xd2, 0xda, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xd3, 0xca, 0x81, 0xcb, 0xc2, 0xd0, 0xd2, 0xd2, 0xd4, 0xc2, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xc2, 0xcf, 0xc2, 0xa4, 0x8d,
	0x90, 0xc2, 0x83, 0x97, 0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x98, 0x87, 0x86, 0xc2, 0x97, 0x91, 0x87, 0xc2, 0x8d, 0x8c, 0x8e, 0x9b, 0xd3, 0xa7, 0xd2, 0xa1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xde, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c,
	0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb2, 0x97, 0x80, 0x8e, 0x8b, 0x81, 0xc2, 0xb2, 0x90, 0x8b, 0x8f, 0x83, 0x90, 0x9b, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xa3, 0x97,
	0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x96, 0x9b, 0xc2, 0xcf, 0xc2, 0xa5, 0xd7, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8,
	0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x4d, 0xc6, 0xea, 0xea, 0xcb, 0x98, 0xd7, 0x7c, 0x82, 0xee, 0x48, 0x5, 0xa9, 0xd9, 0xac, 0x3e, 0x9e, 0x5e, 0xde, 0xa7, 0xfe, 0x59, 0xc9, 0x2, 0x1c, 0xcb, 0xe0, 0x1b, 0xb5, 0xea, 0x41, 0x86, 0x67, 0xf7, 0xc5,
	0x17, 0x13, 0x4f, 0x2a, 0xd3, 0x6b, 0xbf, 0xc0, 0xa, 0xc8, 0x48, 0x44, 0xa0, 0x51, 0x6d, 0x1a, 0x5b, 0xb7, 0x55, 0x53, 0x55, 0xa9, 0x51, 0x1c, 0x6d, 0x9c, 0xe5, 0xb5, 0xe, 0xd, 0xa1, 0x39, 0x84, 0x80, 0xf7, 0x83, 0x2d, 0x82, 0xef, 0x46,
	0x3a, 0x3c, 0x1a, 0x2, 0x21, 0x80, 0xea, 0xdf, 0xb6, 0xf1, 0x9, 0xab, 0x28, 0xbb, 0xb6, 0x67, 0xc4, 0x7, 0xc9, 0x6d, 0xf9, 0x7d, 0x9, 0x17, 0x43, 0x73, 0x20, 0xd1, 0xab, 0x3a, 0xa1, 0x81, 0x88, 0xb0, 0xa9, 0x30, 0x6d, 0xa, 0x92, 0xb3,
	0xaf, 0x33, 0x6b, 0x8b, 0x99, 0x25, 0x92, 0x14, 0x51, 0x3e, 0xf0, 0x96, 0x39, 0x99, 0xbf, 0xa9, 0xb4, 0x31, 0x74, 0x5d, 0xf7, 0x95, 0x43, 0x52, 0x16, 0x40, 0xc7, 0x10, 0x4d, 0xfe, 0x70, 0x85, 0xfa, 0x7, 0x16, 0xe4, 0xe6, 0xd, 0x72, 0x5b,
	0x6, 0xe2, 0x6, 0x3f, 0xd8, 0x57, 0xfb, 0x1d, 0xe0, 0x58, 0x16, 0xde, 0xc, 0x2, 0x69, 0x9, 0xd5, 0x69, 0xe, 0x16, 0x35, 0x4e, 0x10, 0x14, 0x12, 0xdf, 0x4d, 0x3f, 0x97, 0x73, 0xd1, 0xfb, 0xff, 0xfe, 0xa2, 0x29, 0x96, 0xc6, 0xfb, 0xc3,
	0x71, 0x3b, 0xf6, 0x1c, 0x4e, 0xc8, 0xb0, 0x25, 0x6d, 0x37, 0xe6, 0xab, 0x6, 0x6f, 0x81, 0xa5, 0x6a, 0xde, 0x8b, 0x61, 0x29, 0x1c, 0xa5, 0x5f, 0xc9, 0x9c, 0xad, 0x27, 0x77, 0x4c, 0xec, 0x7f, 0x36, 0x33, 0xa1, 0x22, 0x85, 0x91, 0x1, 0xf6,
	0xea, 0x9c, 0x7, 0xdd, 0x7d, 0x91, 0x5a, 0xd1, 0xe8, 0x2d, 0xbf, 0xdd, 0xd6, 0x65, 0x74, 0x68, 0xc, 0xb1, 0xa, 0xc7, 0xf7, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x63, 0x29, 0xd2, 0x63, 0x2a, 0xd2, 0xf3, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6,
	0xe8, 0xd2, 0xea, 0xd2, 0xe4, 0xe4, 0xe6, 0xb7, 0xff, 0xc2, 0xe2, 0xd2, 0xed, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xe7, 0xd2, 0xe1, 0xe3, 0xe3, 0x1d, 0xd2, 0xe9, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3,
	0x64, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x9d, 0x31, 0x87, 0x45, 0x20, 0x3f, 0xe, 0x59, 0x12, 0xd2, 0xeb, 0x11, 0xa1, 0xdb, 0x18, 0xe0, 0x4d, 0xd1, 0xd3, 0xd1, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6,
	0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x80, 0x19, 0xe8, 0xc3, 0xb9, 0x9d, 0xa1, 0x8c, 0xf3, 0x38, 0xeb, 0xb6, 0xb2, 0x89, 0x17, 0x30, 0x74, 0x93, 0x13, 0x7c, 0xd2, 0xb7, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xac, 0xd2, 0xae, 0xd2, 0xa8, 0x42, 0xaa,
	0x42, 0xa4, 0x64, 0xa6, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x81, 0x90, 0x8e, 0xcc, 0x8f, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x92, 0x89, 0x8b, 0xcd, 0x81, 0x90, 0x8e, 0xcd, 0x92, 0x90, 0x8d,
	0x86, 0x97, 0x81, 0x96, 0x91, 0xcd, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xa1, 0x8d, 0x86, 0x87, 0xb4, 0x87, 0x90, 0x8b, 0x84, 0xb0, 0x8d, 0x8d, 0x96, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64,
	0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1, 0x60, 0xe0, 0xe3, 0xe2, 0x63, 0xc8, 0x60, 0xf4, 0x6e, 0xd6, 0x85, 0xc9, 0x7, 0xe1, 0x9, 0xd6, 0x99, 0x6e, 0x40, 0x41, 0xb2, 0x68, 0x16, 0xb7, 0x64, 0x13, 0xfc, 0x6e, 0x6c, 0x4c, 0x9f, 0xc,
	0xe1, 0xfb, 0x2c, 0x90, 0x77, 0xfa, 0xaa, 0x4f, 0x80, 0xf3, 0x1f, 0xc2, 0x1f, 0xdd, 0xa5, 0xe4, 0xe3, 0xb8, 0x0, 0x2, 0x8d, 0x6e, 0xf7, 0xce, 0xac, 0xde, 0x88, 0xb2, 0x8e, 0xe9, 0xd4, 0x41, 0x2d, 0x98, 0xef, 0x7e, 0xa0, 0x5e, 0xbe, 0x1a,
	0xfb, 0x37, 0x82, 0x1, 0x8b, 0x4, 0x0, 0xc1, 0xa3, 0x85, 0x6e, 0x8a, 0x61, 0x94, 0xc9, 0x6d, 0x71, 0x41, 0xc8, 0x57, 0x9d, 0x5c, 0xbb, 0x19, 0x4b, 0x2b, 0x50, 0xc4, 0x6d, 0x28, 0x40, 0x11, 0x60, 0xf9, 0x7a, 0xdc, 0x73, 0x77, 0xc5, 0x75,
	0x64, 0x83, 0xc, 0xb9, 0xbf, 0xe5, 0x89, 0x2f, 0x64, 0x4a, 0x0, 0x87, 0x62, 0x4a, 0x0, 0xf7, 0x0, 0x50, 0x5c, 0xc1, 0xe7, 0x88, 0x58, 0xee, 0x11, 0xa5, 0x71, 0xaf, 0x4e, 0x46, 0x6e, 0xe5, 0x9b, 0xdb, 0x22, 0x83, 0xf0, 0xd8, 0xe7, 0xef,
	0x6b, 0x41, 0xe, 0x7d, 0xb5, 0x6b, 0x66, 0x19, 0xe, 0x28, 0x9e, 0xa5, 0x84, 0xf6, 0x73, 0x3a, 0x54, 0xed, 0xfb, 0xbf, 0x4, 0x5a, 0xa8, 0x4e, 0x5e, 0xa5, 0x2a, 0x93, 0xa1, 0x74, 0x4, 0xd0, 0xc2, 0x47, 0x3e, 0x95, 0x64, 0x1f, 0xde, 0x1,
	0x69, 0x93, 0x39, 0x99, 0x79, 0xe1, 0x1e, 0x55, 0xff, 0xd0, 0x86, 0x9, 0xf4, 0xb0, 0x42, 0xa1, 0x41, 0x18, 0xcc, 0x4f, 0xbb, 0x70, 0xac, 0x9e, 0x25, 0x10, 0xd1, 0xa0, 0xaa, 0xda, 0xb3, 0xd8, 0x9e, 0xda, 0x25, 0xf9, 0xc6, 0xc0, 0xca, 0xa2,
	0xfc, 0xf8, 0xa4, 0xfd, 0xf5, 0x39, 0xfa, 0x15, 0x12, 0xc5, 0xd7, 0x8e, 0x5a, 0x81, 0x3b, 0x2f, 0x5b, 0x86, 0xbf, 0xc9, 0x47, 0xbc, 0xd, 0x24, 0xcb, 0x56, 0x10, 0x25, 0x1a, 0xc3, 0x2e, 0xe6, 0x58, 0xb5, 0x1f, 0xe3, 0x54, 0x49, 0x24, 0x85,
	0x1b, 0x5, 0x31, 0x7b, 0x9d, 0x16, 0x17, 0xc0, 0x18, 0x90, 0x17, 0x1f, 0x1d, 0xd8, 0xfe, 0xa0, 0xd8, 0x43, 0x1b, 0x62, 0xfa, 0x47, 0xc, 0x6f, 0xfe, 0x36, 0x84, 0x7c, 0xa7, 0xe3, 0x1c, 0x48, 0xc, 0x1d, 0x19, 0xf5, 0x6d, 0xd2, 0x15, 0x13,
	0x2f, 0xcb, 0x27, 0x7f, 0xe, 0x57, 0x37, 0xab, 0xe2, 0xdf, 0x67, 0x5a, 0x29, 0x59, 0x71, 0xd8, 0xc5, 0x88, 0xab, 0x22, 0xd2, 0x4c, 0x84, 0x2b, 0x15, 0xc1, 0xca, 0xd0, 0x94, 0x1b, 0x46, 0x61, 0xb4, 0x2a, 0xaa, 0x2c, 0xb8, 0x74, 0x48, 0x42,
	0x2e, 0xee, 0x26, 0x9d, 0x56, 0x6c, 0x75, 0x4d, 0x8f, 0x1, 0xb6, 0xc5, 0x21, 0x7d, 0x64, 0x22, 0x34, 0x6, 0x91, 0xea, 0x75, 0xe7, 0x39, 0x32, 0xb6, 0x80, 0xbc, 0xe1, 0xaa, 0x20, 0x37, 0x7d, 0x9d, 0x45, 0x84, 0x6e, 0x32, 0x7f, 0x52, 0xad,
	0x36, 0x31, 0x7a, 0xbd, 0xa9, 0x98, 0x2b, 0x9d, 0x50, 0xcb, 0xb0, 0x32, 0xf0, 0x62, 0x25, 0xed, 0xb6, 0x54, 0xfc, 0x85, 0x2f, 0x24, 0x42, 0x8e, 0xf3, 0xe1, 0x66, 0x31, 0xaa, 0x97, 0x5, 0xc8, 0x1c, 0x52, 0xd9, 0x8c, 0xe8, 0xd8, 0x44, 0x89,
	0x94, 0x7b, 0xe7, 0x41, 0x13, 0x95, 0x8a, 0x83, 0xd1, 0xf6, 0xa5, 0xe4, 0x1e, 0xb1, 0x9d, 0xb0, 0x5f, 0x70, 0xf6, 0xbe, 0xa8, 0xc6, 0x88, 0x85, 0x6e, 0x4d, 0x6f, 0x72, 0x48, 0x32, 0x14, 0x9b, 0xc3, 0xf9, 0x71, 0xc4, 0x9e, 0x21, 0x2c, 0xfc,
	0x5f, 0x6a, 0xda, 0x70, 0x4c, 0xa7, 0x24, 0xfb, 0x88, 0xab, 0xb2, 0x51, 0xe7, 0x1a, 0x4c, 0xbb, 0xd5, 0x68, 0x88, 0xc7, 0xe1, 0x76, 0x53, 0xbb, 0x63, 0xb2, 0xa, 0x58, 0x61, 0x62, 0x55, 0xc1, 0xd7, 0x16, 0x94, 0x5b, 0x85, 0xff, 0xbb, 0xfa,
	0x4f, 0xc2, 0x6f, 0x76, 0xd3, 0x60, 0xe6, 0xde, 0xd2, 0x60, 0xe6, 0xda, 0xe0, 0xe3, 0xe3, 0xd2, 0x63, 0x71, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7,
	0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c,
	0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83,
	0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7, 0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xe0, 0xf2, 0x9c, 0xbb, 0xa2, 0x6f, 0xde, 0x7b, 0x27, 0xf3, 0x4a, 0xb1, 0x19,
	0xcd, 0x91, 0x22, 0xdf, 0x26, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0x42, 0x92, 0xd2, 0xf2, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xee, 0xd3, 0xe0, 0xd2, 0xe2, 0xd2, 0xfb, 0xe4, 0xeb,
	0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe1, 0xd3, 0xee, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe6, 0xd2, 0xfe, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe9, 0xd3, 0xec, 0xd2,
	0xee, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xf7, 0xd2, 0xc1, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe6, 0xd3, 0xf4, 0xe6, 0xf6, 0x55, 0xf, 0x63, 0x9c, 0x40, 0xd4, 0xc8, 0xe7, 0xf1, 0xff,
	0x6e, 0xdb, 0x9, 0x3a, 0xc4, 0xac, 0x5b, 0x4e, 0x0, 0xdc, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe6, 0x60, 0xe3, 0xe2, 0xd7, 0x3b, 0x2b, 0x53, 0xb5, 0xcf, 0x59, 0xf4, 0x5a, 0xc2, 0x3,
	0x2f, 0xcd, 0xa, 0x51, 0xa6, 0xff, 0x15, 0x8b, 0x3d, 0xa6, 0x5b, 0x90, 0x43, 0xd5, 0x44, 0x28, 0x14, 0xff, 0x8a, 0xc0, 0x38, 0x17, 0x1f, 0xfb, 0xf2, 0x98, 0x83, 0x48, 0x6b, 0x6b, 0xbe, 0xe0, 0x3e, 0x1f, 0xde, 0xa6, 0xac, 0x31, 0x44, 0x10,
	0xe0, 0xaa, 0x2b, 0xbc, 0xe6, 0x6b, 0xcb, 0xe2, 0xdf, 0xbe, 0xde, 0x50, 0xa2, 0x78, 0x55, 0x96, 0xf5, 0xb4, 0xc7, 0x93, 0x84, 0x82, 0x4e, 0xcc, 0xd8, 0xd9, 0xd0, 0x3f, 0xd5, 0x5e, 0xa5, 0x9e, 0xda, 0x73, 0xb4, 0x98, 0x5e, 0x23, 0x4a, 0x2a,
	0xde, 0x7c, 0xbb, 0x85, 0xb9, 0x72, 0xe3, 0x8d, 0x20, 0x76, 0xb0, 0x44, 0xa, 0x50, 0xa7, 0x65, 0xf, 0xde, 0x74, 0x2, 0x98, 0xd, 0x77, 0x4b, 0x52, 0xf9, 0x45, 0x17, 0xbc, 0xaa, 0xf5, 0xb0, 0xc8, 0x39, 0x90, 0xcd, 0xbb, 0xe5, 0x10, 0x32,
	0x4, 0x47, 0x77, 0xe0, 0x5b, 0x83, 0xa8, 0x7f, 0xa6, 0x38, 0xe8, 0x2f, 0x10, 0x41, 0x1f, 0xbc, 0xd6, 0xc1, 0x3b, 0x5c, 0x1a, 0xc6, 0xce, 0xeb, 0xa9, 0x5e, 0xad, 0xfa, 0xa5, 0x3e, 0xc5, 0x42, 0x4d, 0xab, 0xf7, 0x20, 0x5a, 0xff, 0xe0, 0x9b,
	0xf9, 0xb9, 0xa6, 0xb3, 0x62, 0x9, 0x83, 0xc4, 0x28, 0xba, 0x6e, 0x4, 0x2c, 0xb4, 0x94, 0xc3, 0xb4, 0xd7, 0xd8, 0x37, 0x75, 0x7, 0x3a, 0xdb, 0x1f, 0xf, 0x58, 0x1b, 0x3b, 0x32, 0x98, 0xb2, 0x89, 0x3d, 0xed, 0x8b, 0x43, 0x8d, 0x30, 0xa,
	0x4b, 0xfe, 0xf4, 0x84, 0xa2, 0xbc, 0x5d, 0xf9, 0xc8, 0xf5, 0x9, 0x2f, 0xe5, 0xc3, 0x77, 0x8e, 0x1e, 0x6c, 0x8d, 0x36, 0x5f, 0x79, 0x68, 0xba, 0xac, 0xac, 0xa9, 0x5d, 0x5, 0xb4, 0xec, 0x8e, 0x95, 0x5d, 0xe4, 0x14, 0x60, 0x6e, 0x7, 0xa2,
	0x2d, 0xef, 0x5b, 0xbf, 0x7d, 0x43, 0x60, 0xe0, 0xe9, 0xd2, 0x60, 0xe0, 0xe5, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe4, 0xd3, 0x60, 0xe3, 0x1a, 0xd2, 0x60, 0xe3, 0x16, 0xe0, 0xe3, 0xe3, 0xd2, 0x90, 0xd2, 0xbc, 0xd3,
	0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96,
	0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90,
	0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xe0, 0xf2, 0xec, 0x2d, 0x16, 0xda, 0x2a, 0x1c, 0x5d, 0xd7, 0x8c, 0xe6, 0x3a, 0x88, 0x7a, 0xf9, 0xf8, 0xb2, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8,
	0xe7, 0xe2, 0x42, 0xbf, 0xd2, 0xfa, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe1, 0xd3, 0xe9, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe5, 0xe3, 0xd2, 0xfe, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef,
	0xe3, 0xeb, 0xe7, 0xd3, 0xed, 0xf5, 0xef, 0xd3, 0xd4, 0xd2, 0xdb, 0xd2, 0xd4, 0xd2, 0xd7, 0xd2, 0xd1, 0xd0, 0xd3, 0xb8, 0xd2, 0xc1, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe6, 0xd3, 0xf4, 0xe6, 0xf6, 0xaf, 0x33, 0x5f,
	0x6e, 0xb, 0xb0, 0xec, 0x50, 0x74, 0xec, 0x83, 0x77, 0x2c, 0x80, 0xd, 0xc4, 0x2b, 0x31, 0xf6, 0x1f, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe6, 0x60, 0xe3, 0xe2, 0xaa, 0xc4, 0xd9, 0x6,
	0x39, 0x9a, 0x9e, 0x4f, 0x75, 0x93, 0xbe, 0x7e, 0xf6, 0xf2, 0x11, 0x5c, 0xbc, 0xff, 0xf9, 0x5d, 0x9f, 0xb9, 0x17, 0xd7, 0x85, 0xc4, 0x67, 0x85, 0x39, 0xaa, 0x1e, 0x45, 0x59, 0x3c, 0xd9, 0xc3, 0x70, 0x69, 0xd7, 0xd, 0x40, 0x85, 0x81, 0x91,
	0x96, 0x18, 0x1d, 0x93, 0x59, 0x53, 0xfb, 0x31, 0x2d, 0x81, 0x35, 0x63, 0x66, 0x7f, 0xa4, 0xde, 0x52, 0xd, 0x76, 0x86, 0xc3, 0x69, 0xe9, 0x3c, 0x85, 0xa9, 0xac, 0x6d, 0xa9, 0x0, 0x18, 0xec, 0xc8, 0xb5, 0xcd, 0x3e, 0x69, 0x30, 0x5d, 0xde,
	0x9b, 0x25, 0x4e, 0x69, 0x5a, 0x9a, 0xb0, 0x29, 0x29, 0xa0, 0x46, 0xbe, 0xc7, 0xf3, 0x12, 0x90, 0x0, 0x53, 0x2a, 0x74, 0x63, 0x89, 0x1d, 0x8d, 0xcd, 0x81, 0x5d, 0xde, 0xae, 0x2a, 0xae, 0x50, 0x42, 0xb7, 0x4c, 0x5, 0x7a, 0xb0, 0x94, 0xf,
	0x1d, 0x66, 0xc9, 0xe0, 0xc4, 0x66, 0xb7, 0x35, 0x8c, 0x68, 0x88, 0xe3, 0xfa, 0x38, 0x6, 0x9b, 0x25, 0x25, 0x5a, 0xdd, 0x98, 0xd0, 0x15, 0x8b, 0x8e, 0x4, 0xe2, 0xbc, 0x70, 0x62, 0xae, 0xa2, 0xed, 0x8f, 0x71, 0x58, 0x2b, 0xc1, 0xca, 0x33,
	0x92, 0x70, 0xf3, 0x7d, 0xbd, 0x55, 0xf6, 0xc0, 0x3e, 0x6, 0xf7, 0x80, 0x58, 0x5, 0x91, 0x9c, 0xa2, 0xd6, 0x5e, 0x46, 0x59, 0xab, 0x9c, 0x8d, 0x3e, 0x46, 0xcc, 0xc1, 0xa3, 0xa5, 0x2, 0xa, 0xf8, 0x82, 0x3a, 0xd2, 0x6e, 0xaf, 0x5c, 0x7f,
	0xa1, 0xd0, 0x59, 0x44, 0x83, 0xf3, 0x44, 0x38, 0xaf, 0xc1, 0x11, 0x4b, 0x37, 0xf8, 0xc7, 0x64, 0x4e, 0x25, 0x7, 0x52, 0x9b, 0x23, 0x1d, 0xd5, 0x2c, 0xbb, 0x7f, 0xe0, 0xaa, 0x3a, 0xe, 0x9, 0x75, 0x3e, 0xfb, 0x40, 0xb9, 0x3e, 0x30, 0xe6,
	0x29, 0x93, 0x5f, 0xbc, 0x6c, 0xe2, 0x79, 0x87, 0x97, 0x95, 0x8c, 0x6a, 0xe2, 0xe2, 0xe2, 0xe2,
};
static const unsigned char CAPCOM_DRIVER_XOR_KEY = 0xe2;
```

`injector/src/DriverLoader.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include <Shlwapi.h>
#include <iostream>
#include "NtDefines.h"
#pragma comment(lib, "Shlwapi.lib")

static NTSTATUS Dl_RemoveDriverFromRegistry( const wchar_t* DriverName )
{
	NTSTATUS Status = STATUS_SUCCESS;

	std::wstring RegistryPath = std::wstring( L"System\\CurrentControlSet\\Services\\" ) + DriverName;

	Status = RegDeleteKeyW( HKEY_LOCAL_MACHINE,
							RegistryPath.c_str() );
	if ( !Status || Status == ERROR_FILE_NOT_FOUND )
		return STATUS_SUCCESS;

	Status = SHDeleteKeyW( HKEY_LOCAL_MACHINE,
						   RegistryPath.c_str() );
	if ( !Status || Status == ERROR_FILE_NOT_FOUND )
		return STATUS_SUCCESS;

	Status = RegDeleteKeyW( HKEY_LOCAL_MACHINE,
							RegistryPath.c_str() );
	if ( !Status || Status == ERROR_FILE_NOT_FOUND )
		return STATUS_SUCCESS;

	return Status;
}

static NTSTATUS Dl_TryOpenServiceKey( const wchar_t* DriverName )
{
	std::wstring RegistryPath = std::wstring( L"System\\CurrentControlSet\\Services\\" ) + DriverName;
	HKEY Key;
	NTSTATUS Result = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
									 RegistryPath.c_str(),
									 0,
									 KEY_ALL_ACCESS,
									 &Key );
	RegCloseKey( Key );
	return Result;
}

static NTSTATUS Dl_AddServiceToRegistery( const wchar_t* DriverName )
{
	NTSTATUS Status = STATUS_SUCCESS;

	std::wstring RegistryPath = std::wstring( L"System\\CurrentControlSet\\Services\\" ) + DriverName;

	Dl_RemoveDriverFromRegistry( DriverName );

	HKEY Key;
	Status = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
							  RegistryPath.c_str(),
							  0,
							  NULL,
							  0,
							  KEY_ALL_ACCESS,
							  NULL,
							  &Key,
							  0 );

	if ( Status )
		return Status;

	const auto RegWriteString = [ = ] ( const wchar_t* Name, const std::wstring& Data ) -> NTSTATUS
	{
		return RegSetValueExW( Key,
							   Name,
							   0,
							   REG_EXPAND_SZ,
							   ( PBYTE ) Data.c_str(),
							   (DWORD)Data.size() * sizeof( wchar_t ) );
	};
	const auto RegWriteDWORD = [ = ] ( const wchar_t* Name, DWORD Data ) -> NTSTATUS
	{
		return RegSetValueExW( Key,
							   Name,
							   0,
							   REG_DWORD,
							   ( PBYTE ) &Data,
							   sizeof( DWORD ) );
	};

	Status |= RegWriteString( L"ImagePath", std::wstring( L"\\SystemRoot\\System32\\drivers\\" ) + DriverName + L".sys" );
	Status |= RegWriteDWORD( L"Type", 1 );
	Status |= RegWriteDWORD( L"ErrorControl", 1 );
	Status |= RegWriteDWORD( L"Start", 3 );

	if ( Status )
	{
		RegCloseKey( Key );
		Dl_RemoveDriverFromRegistry( DriverName );
		return Status;
	}


	RegCloseKey( Key );
	return STATUS_SUCCESS;
}

static NTSTATUS Dl_UnloadDriver( const wchar_t* DriverName )
{
	if ( !AcquirePrivilege( SeLoadDriverPrivilege, AdjustCurrentProcess ) )
		return 1;

	if ( Dl_TryOpenServiceKey( DriverName ) == 2 )
		Dl_AddServiceToRegistery( DriverName );
	std::wstring SourceRegistry = std::wstring( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) + DriverName;

	UNICODE_STRING SourceRegistryUnicode = { 0 };
	SourceRegistryUnicode.Buffer = ( wchar_t* ) SourceRegistry.c_str();
	SourceRegistryUnicode.Length = (USHORT)( SourceRegistry.size() ) * 2;
	SourceRegistryUnicode.MaximumLength = (USHORT)( SourceRegistry.size() + 1 ) * 2;

	NTSTATUS Status = NtUnloadDriver( &SourceRegistryUnicode );

	printf( "[+] NtUnloadDriver(%ls) returned %08x\n", SourceRegistry.c_str(), Status );

	Dl_RemoveDriverFromRegistry( DriverName );

	return Status;
}


static NTSTATUS Dl_LoadDriver( const wchar_t* DriverName )
{
	if ( !AcquirePrivilege( SeLoadDriverPrivilege, AdjustCurrentProcess ) )
		return 1;

	if ( Dl_AddServiceToRegistery( DriverName ) )
		return 2;

	std::wstring SourceRegistry = std::wstring( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) + DriverName;

	UNICODE_STRING SourceRegistryUnicode = { 0 };
	SourceRegistryUnicode.Buffer = ( wchar_t* ) SourceRegistry.c_str();
	SourceRegistryUnicode.Length = (USHORT)( SourceRegistry.size() ) * 2;
	SourceRegistryUnicode.MaximumLength = (USHORT)( SourceRegistry.size() + 1 ) * 2;

	NTSTATUS Status = NtLoadDriver( &SourceRegistryUnicode );

	printf( "[+] NtLoadDriver(%ls) returned %08x\n", SourceRegistry.c_str(), Status );

	if ( Status )
	{
		Dl_UnloadDriver( DriverName );
		Dl_RemoveDriverFromRegistry( DriverName );
	}

	return Status;
}

static HANDLE Dl_OpenDevice( std::string DriverName )
{
	char CompleteDeviceName[ 128 ];
	sprintf_s( CompleteDeviceName, "\\\\.\\%s", DriverName.data() );

	HANDLE DeviceHandle = CreateFileA
	(
		CompleteDeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if ( DeviceHandle == INVALID_HANDLE_VALUE )
		DeviceHandle = 0;

	printf( "[+] CreateFileA(%s) returned %08llx\n", CompleteDeviceName, (uintptr_t)DeviceHandle );

	return DeviceHandle;
}
```

`injector/src/Error.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>

#undef ERROR
#define ERROR( msg ) \
{SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 12 ); \
printf( "\n[[[[[[        " msg "        ]]]]]]\n\n" ); \
system( "pause" ); \
exit( 0 );}


#define assert( cond ) if( !(cond) ) ERROR( "Assert Failed: " #cond  )
```

`injector/src/KernelHelper.h`:

```h
#pragma once
#include <intrin.h>
#include <iostream>
#include "KernelRoutines.h"
#include "LockedMemory.h"
#include "CapcomLoader.h"

// Not thread safe!
using fnPassiveCall = uint64_t( *)( ... );

NON_PAGED_DATA static fnFreeCall Khk_ExAllocatePool = 0;
NON_PAGED_DATA static fnPassiveCall Khk_PassiveCallStub = 0;

static const uint32_t Kh_PassiveCallStubCallStoreOffset = 0x34;
static const uint32_t Kh_PassiveCallStubSmepEnabledOffset = 0xB;

NON_PAGED_DATA static UCHAR Kh_PassiveCallStubData[] =
{
	0x0F, 0x20, 0xE0,                                // mov    rax,cr4               ; -
	0x48, 0x0F, 0xBA, 0xE8, 0x14,                    // bts    rax,0x14              ; | will be nop'd if no SMEP support
	0x0F, 0x22, 0xE0,                                // mov    cr4,rax               ; -
	0xFB,                                            // sti
	0x48, 0x8D, 0x05, 0x07, 0x00, 0x00, 0x00,        // lea    rax,[rip+0x7]         ; continue
	0x8F, 0x40, 0x12,                                // pop    QWORD PTR [rax+0x12]  ; ret_store
	0x50,                                            // push rax
	0xFF, 0x60, 0x1A,                                // jmp    QWORD PTR [rax+0x1a]  ; call_store
	0xFA,                                            // cli
	0x0F, 0x20, 0xE1,                                // mov    rcx,cr4
	0x48, 0x0F, 0xBA, 0xF1, 0x14,                    // btr    rcx,0x14
	0x0F, 0x22, 0xE1,                                // mov    cr4,rcx
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,              // jmp    QWORD PTR [rip+0x0]   ; ret_store

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ret_store:  dq 0
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // call_store: dq 0
};


// This function is the only _TRICKY_ part of this project.
// ExAllocatePool does not require interrupts to be enabled WHEN the size is small and we are depending on that.
NON_PAGED_CODE static void Khk_AllocatePassiveStub()
{
	PVOID Out = ( PVOID ) Khk_ExAllocatePool( 0ull, sizeof( Kh_PassiveCallStubData ) );
	Np_memcpy( Out, Kh_PassiveCallStubData, sizeof( Kh_PassiveCallStubData ) );
	Khk_PassiveCallStub = ( fnPassiveCall ) Out;
}

template<typename ...Params>
NON_PAGED_CODE static uint64_t Khk_CallPassive( PVOID Ptr, Params &&... params )
{
	*( PVOID* ) ( ( ( PUCHAR ) Khk_PassiveCallStub ) + Kh_PassiveCallStubCallStoreOffset ) = Ptr;
	return Khk_PassiveCallStub( std::forward<Params>( params ) ... );
}

static void Khu_Init( CapcomContext* CpCtx, KernelContext* KrCtx )
{
	if ( Khk_PassiveCallStub )
		return;

	int CpuInfo[ 4 ];
	__cpuid( CpuInfo, 0x7 );
	
	if ( !( CpuInfo[ 1 ] & ( 1 << 7 ) ) ) // EBX : 1 << 7 = SMEP
	{
		printf( "[+] No SMEP support!\n" );
		memset( Kh_PassiveCallStubData, 0x90, Kh_PassiveCallStubSmepEnabledOffset );
	}

	Khk_ExAllocatePool = KrCtx->GetProcAddress<fnFreeCall>( "ExAllocatePool" );
	CpCtx->ExecuteInKernel( Khk_AllocatePassiveStub );
}
```

`injector/src/KernelRoutines.h`:

```h
#pragma once
#include <Windows.h>
#include <inttypes.h>
#include <iostream>
#include <vector>
#include "NtDefines.h"

struct KernelContext
{
	HMODULE NtLib;
	uint64_t NtBase;

	template<typename T = fnFreeCall>
	T GetProcAddress( const char* Proc )
	{
		FARPROC LocProc = ::GetProcAddress( this->NtLib, Proc );

		if ( !LocProc )
			return ( T ) ( nullptr );

		uintptr_t Delta = ( uintptr_t ) ( LocProc ) - ( uintptr_t ) ( this->NtLib );

		return ( T ) ( this->NtBase + Delta );
	}
};

static KernelContext* Kr_InitContext()
{
	KernelContext* Kc = new KernelContext;

	std::vector<BYTE> Buffer( 1024 * 1024 );

	ULONG ReqSize = 0;

	do
	{
		if ( !NtQuerySystemInformation( SystemModuleInformation, Buffer.data(), Buffer.size(), &ReqSize ) )
			break;

		Buffer.resize( ReqSize * 2 );
	}
	while ( ReqSize > Buffer.size() );

	SYSTEM_MODULE_INFORMATION* ModuleInfo = ( SYSTEM_MODULE_INFORMATION* ) Buffer.data();

	char* KernelFileName = ( char* ) ModuleInfo->Module[ 0 ].FullPathName + ModuleInfo->Module[ 0 ].OffsetToFileName;

	Kc->NtBase = (uint64_t) ModuleInfo->Module[ 0 ].ImageBase;
	Kc->NtLib = LoadLibraryA( KernelFileName );

	if ( !Kc->NtBase || !Kc->NtLib )
	{
		delete Kc;
		printf( "[+] Failed to get kernel module information!\n" );
		return 0;
	}

	printf( "[+] Kernel: %s @ %16llx\n", KernelFileName, Kc->NtBase );

	return Kc;
}

static void Kr_FreeContext( KernelContext* Ctx )
{
	delete Ctx;
}
```

`injector/src/LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2018, Can Bölük
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`injector/src/LockedMemory.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include "NtDefines.h"

#pragma section(".LDATA", read, write)
#pragma section(".LTEXT", read, execute)

#pragma data_seg(".LDATA$1")
#pragma data_seg(".LDATA$2")
#pragma data_seg(".LDATA$3")
#pragma data_seg()

#pragma code_seg(".LTEXT$1")
#pragma code_seg(".LTEXT$2")
#pragma code_seg(".LTEXT$3")
#pragma code_seg()

__declspec( allocate( ".LDATA$1" ) ) static char Np_DataStart = 0x0;
__declspec( allocate( ".LDATA$3" ) ) static char Np_DataEnd = 0x0;

__declspec( allocate( ".LTEXT$1" ) ) static char Np_TextStart = 0x0;
__declspec( allocate( ".LTEXT$3" ) ) static char Np_TextEnd = 0x0;


#define NON_PAGED_DATA  __declspec( allocate( ".LDATA$2" ) )
#define NON_PAGED_CODE __declspec( code_seg( ".LTEXT$2" ) ) __declspec(noinline)
#define NON_PAGED_LAMBDA(...)  []( __VA_ARGS__ ) NON_PAGED_CODE

// Mini non-paged crt
#define Np_memcpy(dst, src, size) __movsb( ( BYTE* ) dst, ( const BYTE* ) src, size )
#define Np_memset(dst, val, size) __stosb( ( BYTE* ) dst, val, size)
#define Np_ZeroMemory(dst, size) __stosb( ( BYTE* ) dst, 0, size)

#pragma comment(linker,"/MERGE:.LDATA=.data")
#pragma comment(linker,"/MERGE:.LTEXT=.text")

// Routines to lock the pages
static BOOL Np_TryIncreaseWorkingSetSize( SIZE_T Size )
{
	SIZE_T Min, Max;
	if ( !GetProcessWorkingSetSize( NtCurrentProcess(), &Min, &Max ) )
		return FALSE;
	if ( !SetProcessWorkingSetSize( NtCurrentProcess(), Min + Size, Max + Size ) )
		return FALSE;
	printf( "[+] Increasing working set (%llu KB, %llu KB) -> (%llu KB, %llu KB)!\n", Min / 1024u, Max / 1024u, ( Min + Size ) / 1024u, ( Max + Size ) / 1024u );
	return TRUE;
}

static BOOL Np_TryLockPage( PVOID Page )
{
	if ( !Np_TryIncreaseWorkingSetSize( 0x1000 ) )
		return FALSE;
	if ( VirtualLock( Page, 0x1000 ) )
		return TRUE;
	if ( !Np_TryIncreaseWorkingSetSize( 0x2000 ) )
		return FALSE;
	return VirtualLock( Page, 0x1000 );
}

static BOOL Np_LockRange( PVOID From, PVOID To )
{
	PBYTE FromPageAligned = ( PBYTE ) ( ( uintptr_t ) ( From ) & ( ~0xFFF ) );
	PBYTE ToPageAligned = ( PBYTE ) ( ( uintptr_t ) ( To ) & ( ~0xFFF ) );

	for ( PBYTE Current = FromPageAligned; Current <= ToPageAligned; Current += 0x1000 )
	{
		if ( !Np_TryLockPage( Current ) )
		{
			printf( "[+] Failed locking %16llx!\n", (uintptr_t)Current );
			return FALSE;
		}
		else
		{
			printf( "[+] Locked %16llx successfully!\n", (uintptr_t)From );
		}
	}
	return TRUE;
}

static BOOL Np_LockSections()
{
	printf( "[+] .LDATA: %16llx -> %16llx!\n", (uintptr_t)&Np_DataStart, (uintptr_t)&Np_DataEnd );
	printf( "[+] .LTEXT: %16llx -> %16llx!\n", (uintptr_t)&Np_TextStart, (uintptr_t)&Np_TextEnd );

	return
		Np_LockRange( &Np_DataStart, &Np_DataEnd ) &&
		Np_LockRange( &Np_TextStart, &Np_TextEnd );
}
```

`injector/src/MemoryController.h`:

```h
#pragma once
#include <iostream>
#include <intrin.h>
#include <inttypes.h>
#include <functional>
#include "Error.h"
#include "LockedMemory.h"
#include "KernelRoutines.h"
#include "CapcomLoader.h"
#include "KernelHelper.h"

#define PFN_TO_PAGE(pfn) ( pfn << 12 )
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_CASE_INSENSITIVE                0x00000040L

#pragma pack(push, 1)
typedef union CR3_
{
	uint64_t value;
	struct
	{
		uint64_t ignored_1 : 3;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t ignored_2 : 7;
		uint64_t pml4_p : 40;
		uint64_t reserved : 12;
	};
} PTE_CR3;

typedef union VIRT_ADDR_
{
	uint64_t value;
	void *pointer;
	struct
	{
		uint64_t offset : 12;
		uint64_t pt_index : 9;
		uint64_t pd_index : 9;
		uint64_t pdpt_index : 9;
		uint64_t pml4_index : 9;
		uint64_t reserved : 16;
	};
} VIRT_ADDR;

typedef uint64_t PHYS_ADDR;

typedef union PML4E_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t ignored_1 : 1;
		uint64_t reserved_1 : 1;
		uint64_t ignored_2 : 4;
		uint64_t pdpt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PML4E;

typedef union PDPTE_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pd_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDPTE;

typedef union PDE_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDE;

typedef union PTE_
{
	uint64_t value;
	VIRT_ADDR vaddr;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t pat : 1;
		uint64_t global : 1;
		uint64_t ignored_1 : 3;
		uint64_t page_frame : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PTE;
#pragma pack(pop)

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG           Length;
	HANDLE          RootDirectory;
	PVOID		     ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef struct _PHYSICAL_MEMORY_RANGE
{
	PHYSICAL_ADDRESS BaseAddress;
	LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

struct MemoryController
{
	template<typename T>
	T& ReadPhysicalUnsafe( uint64_t Pa )
	{
		return *( T* ) ( PhysicalMemoryBegin + Pa );
	}

	PUCHAR PhysicalMemoryBegin;
	SIZE_T PhysicalMemorySize;

	uint64_t TargetDirectoryBase;

	uint64_t CurrentDirectoryBase;
	uint64_t CurrentEProcess;

	uint64_t UniqueProcessIdOffset;
	uint64_t DirectoryTableBaseOffset;
	uint64_t ActiveProcessLinksOffset;

	NTSTATUS CreationStatus;

	uint64_t FindEProcess( uint64_t Pid )
	{
		uint64_t EProcess = this->CurrentEProcess;

		do
		{
			if ( this->ReadVirtual<uint64_t>( ( PUCHAR ) EProcess + this->UniqueProcessIdOffset ) == Pid )
				return EProcess;

			LIST_ENTRY Le = this->ReadVirtual<LIST_ENTRY>( ( PUCHAR ) EProcess + this->ActiveProcessLinksOffset );
			EProcess = ( uint64_t ) Le.Flink - this->ActiveProcessLinksOffset;
		}
		while ( EProcess != this->CurrentEProcess );

		return 0;
	}

	void AttachTo( uint64_t EProcess )
	{
		this->TargetDirectoryBase = this->ReadVirtual<uint64_t>( ( PUCHAR ) EProcess + this->DirectoryTableBaseOffset );
	}

	void Detach()
	{
		this->TargetDirectoryBase = this->CurrentDirectoryBase;
	}

	


	struct PageTableInfo
	{
		PML4E* Pml4e;
		PDPTE* Pdpte;
		PDE* Pde;
		PTE* Pte;
	};

	PageTableInfo QueryPageTableInfo( PVOID Va )
	{
		PageTableInfo Pi = { 0,0,0,0 };

		VIRT_ADDR Addr = { ( uint64_t ) Va };
		PTE_CR3 Cr3 = { TargetDirectoryBase };

		{
			uint64_t a = PFN_TO_PAGE( Cr3.pml4_p ) + sizeof( PML4E ) * Addr.pml4_index;
			if ( a > this->PhysicalMemorySize )
				return Pi;
			PML4E& e = ReadPhysicalUnsafe<PML4E>( a );
			if ( !e.present )
				return Pi;
			Pi.Pml4e = &e;
		}
		{
			uint64_t a = PFN_TO_PAGE( Pi.Pml4e->pdpt_p ) + sizeof( PDPTE ) * Addr.pdpt_index;
			if ( a > this->PhysicalMemorySize )
				return Pi;
			PDPTE& e = ReadPhysicalUnsafe<PDPTE>( a );
			if ( !e.present )
				return Pi;
			Pi.Pdpte = &e;
		}
		{
			uint64_t a = PFN_TO_PAGE( Pi.Pdpte->pd_p ) + sizeof( PDE ) * Addr.pd_index;
			if ( a > this->PhysicalMemorySize )
				return Pi;
			PDE& e = ReadPhysicalUnsafe<PDE>( a );
			if ( !e.present )
				return Pi;
			Pi.Pde = &e;
			if ( Pi.Pde->page_size )
				return Pi;
		}
		{
			uint64_t a = PFN_TO_PAGE( Pi.Pde->pt_p ) + sizeof( PTE ) * Addr.pt_index;
			if ( a > this->PhysicalMemorySize )
				return Pi;
			PTE& e = ReadPhysicalUnsafe<PTE>( a );
			if ( !e.present )
				return Pi;
			Pi.Pte = &e;
		}
		return Pi;
	}

	uint64_t VirtToPhys( PVOID Va )
	{
		auto Info = QueryPageTableInfo( Va );

		if ( !Info.Pde )
			return 0;

		uint64_t Pa = 0;

		if ( Info.Pde->page_size )
		{
			Pa = PFN_TO_PAGE( Info.Pde->pt_p );
			Pa += ( uint64_t ) Va & ( 0x200000 - 1 );
		}
		else
		{
			if ( !Info.Pte )
				return 0;
			Pa = PFN_TO_PAGE( Info.Pte->page_frame );
			Pa += ( uint64_t ) Va & ( 0x1000 - 1 );
		}
		return Pa;
	}

	void IterPhysRegion( PVOID StartVa, SIZE_T Size, std::function<void( PVOID Va, uint64_t, SIZE_T )> Fn )
	{
		PUCHAR It = ( PUCHAR ) StartVa;
		PUCHAR End = It + Size;

		while ( It < End )
		{
			SIZE_T Size = ( PUCHAR ) ( ( ( uint64_t ) It + 0x1000 ) & ( ~0xFFF ) ) - It;

			if ( ( It + Size ) > End )
				Size = End - It;

			uint64_t Pa = VirtToPhys( It );

			Fn( It, Pa, Size );

			It += Size;
		}
	}

	void AttachIfCanRead( uint64_t EProcess, PVOID Adr )
	{
		this->AttachTo( EProcess );
		if ( !this->VirtToPhys( Adr ) )
			this->Detach();
	}

	SIZE_T ReadVirtual( PVOID Src, PVOID Dst, SIZE_T Size )
	{
		PUCHAR It = ( PUCHAR ) Dst;
		SIZE_T BytesRead = 0;

		this->IterPhysRegion( Src, Size, [ & ] ( PVOID Va, uint64_t Pa, SIZE_T Sz )
		{
			if ( Pa )
			{
				BytesRead += Sz;
				memcpy( It, PhysicalMemoryBegin + Pa, Sz );
				It += Sz;
			}
		} );

		return BytesRead;
	}

	SIZE_T WriteVirtual( PVOID Src, PVOID Dst, SIZE_T Size )
	{
		PUCHAR It = ( PUCHAR ) Src;
		SIZE_T BytesRead = 0;

		this->IterPhysRegion( Dst, Size, [ & ] ( PVOID Va, uint64_t Pa, SIZE_T Sz )
		{
			if ( Pa )
			{
				BytesRead += Sz;
				memcpy( PhysicalMemoryBegin + Pa, It, Sz );
				It += Sz;
			}
		} );

		return BytesRead;
	}

	template<typename T>
	T ReadVirtual( PVOID From )
	{
		char Buffer[ sizeof( T ) ];
		this->ReadVirtual( From, Buffer, sizeof( T ) );
		return *( T* ) ( Buffer );
	}

	template<typename T>
	void WriteVirtual( PVOID To, const T& Data )
	{
		this->WriteVirtual( ( PVOID ) &Data, To, sizeof( T ) );
	}
};

static MemoryController Mc_InitContext( CapcomContext** CpCtxReuse = 0, KernelContext** KrCtxReuse = 0 )
{
	assert( Np_LockSections() );

	KernelContext* KrCtx = Kr_InitContext();
	CapcomContext* CpCtx = Cl_InitContext();

	assert( CpCtx );
	assert( KrCtx );

	Khu_Init( CpCtx, KrCtx );
	printf( "[+] Mapping physical memory to user-mode!\n" );


	NON_PAGED_DATA static MemoryController Controller = { 0 };

	NON_PAGED_DATA static auto k_ZwOpenSection = KrCtx->GetProcAddress<>( "ZwOpenSection" );
	NON_PAGED_DATA static auto k_ZwMapViewOfSection = KrCtx->GetProcAddress<>( "ZwMapViewOfSection" );
	NON_PAGED_DATA static auto k_ZwClose = KrCtx->GetProcAddress<>( "ZwClose" );
	NON_PAGED_DATA static auto k_PsGetCurrentProcess = KrCtx->GetProcAddress<>( "PsGetCurrentProcess" );
	NON_PAGED_DATA static auto k_PsGetCurrentProcessId = KrCtx->GetProcAddress<>( "PsGetCurrentProcessId" );
	NON_PAGED_DATA static auto k_PsGetProcessId = KrCtx->GetProcAddress<>( "PsGetProcessId" );
	NON_PAGED_DATA static auto k_MmGetPhysicalMemoryRanges = KrCtx->GetProcAddress<PPHYSICAL_MEMORY_RANGE( *)( )>( "MmGetPhysicalMemoryRanges" );

	NON_PAGED_DATA static wchar_t PhysicalMemoryName[] = L"\\Device\\PhysicalMemory";
	NON_PAGED_DATA static OBJECT_ATTRIBUTES PhysicalMemoryAttributes;
	NON_PAGED_DATA static UNICODE_STRING PhysicalMemoryNameUnicode;

	PhysicalMemoryNameUnicode.Buffer = PhysicalMemoryName;
	PhysicalMemoryNameUnicode.Length = sizeof( PhysicalMemoryName ) - 2;
	PhysicalMemoryNameUnicode.MaximumLength = sizeof( PhysicalMemoryName );

	PhysicalMemoryAttributes.Length = sizeof( PhysicalMemoryAttributes );
	PhysicalMemoryAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
	PhysicalMemoryAttributes.ObjectName = &PhysicalMemoryNameUnicode;
	PhysicalMemoryAttributes.RootDirectory = 0;
	PhysicalMemoryAttributes.SecurityDescriptor = 0;
	PhysicalMemoryAttributes.SecurityQualityOfService = 0;

	CpCtx->ExecuteInKernel( NON_PAGED_LAMBDA()
	{
		auto Range = k_MmGetPhysicalMemoryRanges();

		while ( Range->NumberOfBytes.QuadPart )
		{
			Controller.PhysicalMemorySize = max( Controller.PhysicalMemorySize, (ULONGLONG)(Range->BaseAddress.QuadPart + Range->NumberOfBytes.QuadPart) );
			Range++;
		}

		HANDLE PhysicalMemoryHandle = 0;
		Controller.CreationStatus = (NTSTATUS)Khk_CallPassive( k_ZwOpenSection, &PhysicalMemoryHandle, uint64_t( SECTION_ALL_ACCESS ), &PhysicalMemoryAttributes );

		if ( !Controller.CreationStatus )
		{
			Controller.CreationStatus = (NTSTATUS)Khk_CallPassive
			(
				k_ZwMapViewOfSection,
				PhysicalMemoryHandle,
				NtCurrentProcess(),
				&Controller.PhysicalMemoryBegin,
				0ull,
				0ull,
				0ull,
				&Controller.PhysicalMemorySize,
				1ull,
				0,
				PAGE_READWRITE
			);

			if ( !Controller.CreationStatus )
			{
				Controller.CurrentEProcess = k_PsGetCurrentProcess();
				Controller.CurrentDirectoryBase = __readcr3();

				uint64_t Pid = k_PsGetProcessId( Controller.CurrentEProcess );

				uint32_t PidOffset = *( uint32_t* ) ( ( PUCHAR ) k_PsGetProcessId + 3 );
				if ( PidOffset < 0x600 && *( uint64_t* ) ( Controller.CurrentEProcess + PidOffset ) == Pid )
				{
					Controller.UniqueProcessIdOffset = PidOffset;
					Controller.ActiveProcessLinksOffset = Controller.UniqueProcessIdOffset + 0x8;
				}

				for ( int i = 0; i < 0x600; i += 0x8 )
				{
					uint64_t* Ptr = (uint64_t*)(Controller.CurrentEProcess + i);
					if ( !Controller.UniqueProcessIdOffset && (Ptr[ 0 ] & 0xFFFFFFFF) == Pid && ( Ptr[ 1 ] > 0xffff800000000000 ) && ( Ptr[ 2 ] > 0xffff800000000000 ) && ( ( Ptr[ 1 ] & 0xF ) == ( Ptr[ 2 ] & 0xF ) ) )
					{
						Controller.UniqueProcessIdOffset = i;
						Controller.ActiveProcessLinksOffset = Controller.UniqueProcessIdOffset + 0x8;
					}
					else if ( !Controller.DirectoryTableBaseOffset && Ptr[ 0 ] == __readcr3() )
					{
						Controller.DirectoryTableBaseOffset = i;
					}
				}
			}

			k_ZwClose( PhysicalMemoryHandle );
		}
	} );

	if ( !Controller.UniqueProcessIdOffset )
		Controller.CreationStatus = 1;
	if ( !Controller.DirectoryTableBaseOffset )
		Controller.CreationStatus = 2;

	printf( "[+] PhysicalMemoryBegin: %16llx\n", (uintptr_t)Controller.PhysicalMemoryBegin );
	printf( "[+] PhysicalMemorySize:  %16llx\n", Controller.PhysicalMemorySize );

	printf( "[+] CurrentProcessCr3:   %16llx\n", Controller.CurrentDirectoryBase );
	printf( "[+] CurrentEProcess:     %16llx\n", Controller.CurrentEProcess );

	printf( "[+] DirectoryTableBase@  %16llx\n", Controller.DirectoryTableBaseOffset );
	printf( "[+] UniqueProcessId@     %16llx\n", Controller.UniqueProcessIdOffset );
	printf( "[+] ActiveProcessLinks@  %16llx\n", Controller.ActiveProcessLinksOffset );

	printf( "[+] Status:              %16lx\n", Controller.CreationStatus );

	Controller.TargetDirectoryBase = Controller.CurrentDirectoryBase;

	if ( !CpCtxReuse )
		Cl_FreeContext( CpCtx );
	else
		*CpCtxReuse = CpCtx;

	if ( !KrCtxReuse )
		Kr_FreeContext( KrCtx );
	else
		*KrCtxReuse = KrCtx;

	return Controller;
}
```

`injector/src/NtDefines.h`:

```h
#pragma once
#include <Windows.h>
#pragma pack(push, 8)
typedef struct _SYSTEM_MODULE_ENTRY
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[ 256 ];
} SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;

#pragma warning(disable : 4200)
typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[ 0 ];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;

#define NtCurrentProcess() ( HANDLE(-1) )
#define SeLoadDriverPrivilege 10ull
#define SystemModuleInformation 0xBull
#define AdjustCurrentProcess 0ull
#define STATUS_SUCCESS 0
#pragma pack(pop)

using fnFreeCall = uint64_t( __fastcall* )( ... );

template<typename ...Params>
static NTSTATUS __NtRoutine( const char* Name, Params &&... params )
{
	auto fn = ( fnFreeCall ) GetProcAddress( GetModuleHandleA( "ntdll.dll" ), Name );
	return (NTSTATUS)fn( std::forward<Params>( params ) ... );
}

#define NtQuerySystemInformation(...) __NtRoutine("NtQuerySystemInformation", __VA_ARGS__)
#define RtlAdjustPrivilege(...) __NtRoutine("RtlAdjustPrivilege", __VA_ARGS__)
#define NtUnloadDriver(...) __NtRoutine("NtUnloadDriver", __VA_ARGS__)
#define NtLoadDriver(...) __NtRoutine("NtLoadDriver", __VA_ARGS__)

static BOOL AcquirePrivilege( DWORD Privilage, DWORD Proc )
{
	BOOLEAN Enabled = 0;
	return !RtlAdjustPrivilege( Privilage, 1ull, Proc, &Enabled ) || Enabled;
}
```

`injector/src/PerfectInjector.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <tlhelp32.h>
#include <Psapi.h>
#include <map>
#include "Error.h"
#include "MemoryController.h"
#include "SimpleMapper.h"
#include "LockedMemory.h"
#pragma comment(lib, "psapi.lib")

PVOID AllocateKernelMemory( CapcomContext* CpCtx, KernelContext* KrCtx, SIZE_T Size )
{
	NON_PAGED_DATA static auto k_ExAllocatePool = KrCtx->GetProcAddress<fnFreeCall>( "ExAllocatePool" );
	NON_PAGED_DATA static uint64_t MemOut;

	CpCtx->ExecuteInKernel( NON_PAGED_LAMBDA( PVOID Pv )
	{
		MemOut = Khk_CallPassive( k_ExAllocatePool, 0ull, Pv );
	}, ( PVOID ) Size );

	return ( PVOID ) MemOut;
}

BOOL ExposeKernelMemoryToProcess( MemoryController& Mc, PVOID Memory, SIZE_T Size, uint64_t EProcess )
{
	Mc.AttachTo( EProcess );

	BOOL Success = FALSE;

	Mc.IterPhysRegion( Memory, Size, [ & ] ( PVOID Va, uint64_t Pa, SIZE_T Sz )
	{
		auto Info = Mc.QueryPageTableInfo( Va );

		Info.Pml4e->user = TRUE;
		Info.Pdpte->user = TRUE;
		Info.Pde->user = TRUE;

		if ( !Info.Pde || ( Info.Pte && ( !Info.Pte->present ) ) )
		{
			Success = FALSE;
		}
		else
		{
			if ( Info.Pte )
				Info.Pte->user = TRUE;
		}
	} );

	Mc.Detach();

	return Success;
}

PUCHAR FindKernelPadSinglePage( PUCHAR Start, SIZE_T Size )
{
	PUCHAR It = Start;

	MEMORY_BASIC_INFORMATION Mbi;

	PUCHAR StreakStart = 0;
	int Streak = 0;

	do
	{
		if ( ( 0x1000 - ( uint64_t( It ) & 0xFFF ) ) < Size )
		{
			It++;
			continue;
		}

		if ( *It == 0 )
		{
			if ( !Streak )
				StreakStart = It;
			Streak++;
		}
		else
		{
			Streak = 0;
			StreakStart = 0;
		}

		if ( Streak >= Size )
			return StreakStart;

		VirtualQuery( It, &Mbi, sizeof( Mbi ) );

		It++;
	}
	while ( ( Mbi.Protect == PAGE_EXECUTE_READWRITE || Mbi.Protect == PAGE_EXECUTE_READ || Mbi.Protect == PAGE_EXECUTE_WRITECOPY ) );
	return 0;
}

uint32_t FindProcess( const std::string& Name )
{
	PROCESSENTRY32 ProcessEntry;
	ProcessEntry.dwSize = sizeof( PROCESSENTRY32 );
	HANDLE ProcessSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );
	if ( Process32First( ProcessSnapshot, &ProcessEntry ) )
	{
		do
		{
			if ( !_stricmp( ProcessEntry.szExeFile, Name.data() ) )
			{
				CloseHandle( ProcessSnapshot );
				return ProcessEntry.th32ProcessID;
			}
		}
		while ( Process32Next( ProcessSnapshot, &ProcessEntry ) );
	}
	CloseHandle( ProcessSnapshot );
	return 0;
}


static const char* ConHdr = "=================================================\n"
                            "|             The Perfect Injector              |\n"
	                        "| This software is distributed free of charge.  |\n"
	                        "| If you bought this you have been scammed.     |\n"
	                        "| https://github.com/can1357/ThePerfectInjector |\n"
	                        "=================================================\n\n";

int main( int argc, char**argv )
{
	std::string ProcessName = argc > 1 ? argv[ 1 ] : "";
	std::string DllPath = argc > 2 ? argv[ 2 ] : "";

	// noloadlib, waitkey

	std::map<std::string, bool> Flags;

	if ( argc > 3 )
	{
		for ( int i = 3; i < argc; i++ )
		{
			std::string Str = argv[ i ];
			for ( auto& c : Str )
				c = tolower( c );
			Flags[ Str ] = true;
		}
	}

	SetConsoleTitleA( "The Perfect Injector" );
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 0xF );
	printf( ConHdr );
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 0x8 );

	if ( !ProcessName.size() )
	{
		printf( "Enter the target process name: " );
		std::cin >> std::ws;
		getline( std::cin, ProcessName );
	}
	if ( !DllPath.size() )
	{
		printf( "Enter the path to the module: " );
		std::cin >> std::ws;
		getline( std::cin, DllPath );
	}

	printf( "\n" );
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 13 );


	printf( "Flags:         " );

	for ( int i = 3; i < argc; i++ )
		printf( "'%s' ", argv[ i ] );
	printf( "\n" );

	printf( "Dll Path:      '%s'\n", DllPath.data() );
	printf( "Process Name:  '%s'\n", ProcessName.data() );
	printf( "\n" );

	// Initialize physical memory controller
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 12 );
	KernelContext* KrCtx;
	CapcomContext* CpCtx;
	MemoryController Controller = Mc_InitContext( &CpCtx, &KrCtx );

	if ( Controller.CreationStatus )
		ERROR( "Controller Raised A Creation Status" );

	// Hook a very commonly used function
	PUCHAR _TlsGetValue = ( PUCHAR ) GetProcAddress( GetModuleHandleA( "KERNEL32" ), "TlsGetValue" ); // Not &TlsGetValue to avoid __imp intermodule calls

																									  // kernel32._TlsGetValue - EB 1E                 - jmp kernel32._TlsGetValue+
																									  // KERNEL32._TlsGetValue - E9 CBD70100           - jmp KERNEL32.UTUnRegister+160
	assert( *_TlsGetValue == 0xE9 || *_TlsGetValue == 0xEB );
	PUCHAR Target = ( *_TlsGetValue == 0xEB ) ? ( _TlsGetValue + 2 + *( int8_t* ) ( _TlsGetValue + 1 ) ) : ( _TlsGetValue + 5 + *( int32_t* ) ( _TlsGetValue + 1 ) );

	// Map module to kernel and create a hook stub
	std::vector<std::pair<PVOID, SIZE_T>> UsedRegions;

	TlsLockedHookController* TlsHookController = Mp_MapDllAndCreateHookEntry( DllPath, _TlsGetValue, Target, !Flags[ "noloadlib" ], [ & ] ( SIZE_T Size )
	{
		//return VirtualAlloc( 0, Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );
		PVOID Memory = AllocateKernelMemory( CpCtx, KrCtx, Size );
		ExposeKernelMemoryToProcess( Controller, Memory, Size, Controller.CurrentEProcess );
		ZeroMemory( Memory, Size );
		UsedRegions.push_back( { Memory, Size } );
		return Memory;
	} );

	// Unload driver
	Cl_FreeContext( CpCtx );
	Kr_FreeContext( KrCtx );

	printf( "\n" );
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 10 );

	if ( Flags[ "waitkey" ] )
	{
		printf( "Waiting for F2 key...\n" );
		while ( !( GetAsyncKeyState( VK_F2 ) & 0x8000 ) ) Sleep( 10 );
	}

	printf( "Waiting for %s...\n", ProcessName.data() );

	uint32_t Pid = 0;
	while ( !Pid )
	{
		Pid = FindProcess( ProcessName );
		Sleep( 10 );
	}

	printf( "Found %s. Pid 0x%04x!\n", ProcessName.data(), Pid );

	printf( "\n" );
	SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ), 11 );


	uint64_t EProcess = Controller.FindEProcess( Pid );
	printf( "[-] EProcess:                               %16llx\n", EProcess );

	if ( !EProcess )
		ERROR( "EProcess Not Valid" );

	// Expose region to process
	for ( auto Region : UsedRegions )
	{
		printf( "[-] Exposing %16llx (%08llx bytes) to pid:%6x\n", (uintptr_t)Region.first, Region.second, Pid );
		ExposeKernelMemoryToProcess( Controller, Region.first, Region.second, EProcess );
	}

	std::vector<BYTE> PidBasedHook =
	{
		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,        // mov rax, gs:[0x30]
		0x8B, 0x40, 0x40,                                            // mov eax,[rax+0x40] ; pid
		0x3D, 0xDD, 0xCC, 0xAB, 0x0A,                                // cmp eax, 0xAABCCDD
		0x0F, 0x85, 0x00, 0x00, 0x00, 0x00,                          // jne 0xAABBCC
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,  // mov rax, 0xAABBCCDDEEAA
		0xFF, 0xE0                                                   // jmp rax
	};

	PUCHAR PadSpace = FindKernelPadSinglePage( _TlsGetValue, PidBasedHook.size() );

	if ( !PadSpace )
		ERROR( "Couldn't Find Appropriate Padding" );

	printf( "[-] Hooking TlsGetValue @                   %16llx\n", (uintptr_t)_TlsGetValue );
	printf( "[-] TlsGetValue Redirection Target:         %16llx\n", (uintptr_t)Target );
	printf( "[-] Stub located at:                        %16llx\n", (uintptr_t)PadSpace );
	printf( "[-] Image located at:                       %16llx\n", (uintptr_t)TlsHookController );

	*( uint32_t* ) ( &PidBasedHook[ 0xD ] ) = (uint32_t)Pid; // Pid
	*( int32_t* ) ( &PidBasedHook[ 0x13 ] ) = (int32_t)( Target - ( PadSpace + 0x17 ) ); // Jmp
	*( PUCHAR* ) ( &PidBasedHook[ 0x19 ] ) = &TlsHookController->EntryBytes; // Hook target

																			 // Backup and complete hook
	BYTE Jmp[ 5 ];
	Jmp[ 0 ] = 0xE9;
	*( int32_t* ) ( Jmp + 1 ) = (int32_t)( PadSpace - ( _TlsGetValue + 5 ) );

	std::vector<BYTE> Backup1( PidBasedHook.size(), 0 );
	std::vector<BYTE> Backup2( 5, 0 );

	TlsHookController->NumThreadsWaiting = 0;
	TlsHookController->IsFree = FALSE;

	Controller.Detach();


	auto AssertCoW = [ & ] ( PVOID Page )
	{
		VirtualLock( Page, 0x1 );

		PSAPI_WORKING_SET_EX_INFORMATION Ws;
		Ws.VirtualAddress = Page;
		QueryWorkingSetEx( HANDLE( -1 ), &Ws, sizeof( Ws ) );

		if ( !Ws.VirtualAttributes.Shared )
			ERROR( "Page Not CoW" );

		VirtualUnlock( Page, 0x1 );
	};

	// check maching memory checks AND is CoW check 

	printf( "[-] Writing stub to padding...\n" );
	AssertCoW( PadSpace );
	Controller.AttachIfCanRead( EProcess, PadSpace );
	Controller.ReadVirtual( PadSpace, Backup1.data(), PidBasedHook.size() );
	Controller.WriteVirtual( PidBasedHook.data(), PadSpace, PidBasedHook.size() );

	printf( "[-] Writing the hook to TlsGetValue...\n" );
	AssertCoW( _TlsGetValue );
	Controller.AttachIfCanRead( EProcess, _TlsGetValue );
	Controller.ReadVirtual( _TlsGetValue, Backup2.data(), 5 );
	Controller.WriteVirtual( Jmp, _TlsGetValue, 5 );

	printf( "[-] Hooked! Waiting for threads to spin...\n" );

	// Wait for threads to lock
	uint64_t TStart = GetTickCount64();
	while ( !Controller.ReadVirtual<BYTE>( &TlsHookController->NumThreadsWaiting ) && !( GetAsyncKeyState( VK_F1 ) & 0x8000 ) && ( ( GetTickCount64() - TStart ) < 5000 ) )
		Sleep( 1 );
	printf( "[-] Threads spinning:                       %16x\n", TlsHookController->NumThreadsWaiting );

	// Restore Backup

	Controller.AttachIfCanRead( EProcess, _TlsGetValue );
	Controller.WriteVirtual( Backup2.data(), _TlsGetValue, 5 );
	
	
	if ( TlsHookController->NumThreadsWaiting )
		printf( "[-] Unhooked and started thread hijacking!\n" );
	else
		printf( "[-] ERROR: Wait timed out...\n" );

	TlsHookController->IsFree = TRUE;
	Sleep( 2000 );

	Controller.AttachIfCanRead( EProcess, PadSpace );
	Controller.WriteVirtual( Backup1.data(), PadSpace, PidBasedHook.size() );

	// return system( "pause" );
    return 0;
}

```

`injector/src/SimpleMapper.h`:

```h
#pragma once
#include <Windows.h>
#include <fstream>
#include <vector>
#include <functional>

#pragma pack(push, 1)
struct TlsLockedHookController
{
	BYTE IsFree;
	BYTE NumThreadsWaiting;
	BYTE EntryBytes;
};
#pragma pack(pop)

static std::vector<BYTE> Mp_ReadFile( const std::string& Path )
{
	std::ifstream Stream( Path, std::ios::binary | std::ios::ate );
	std::ifstream::pos_type Pos = Stream.tellg();

	if ( Pos == ( std::ifstream::pos_type ) - 1 )
		return {};

	std::vector<BYTE> Data( Pos );
	Stream.seekg( 0, std::ios::beg );
	Stream.read( ( char* ) &Data[ 0 ], Pos );

	return Data;
}

static void * Mp_RvaToPointer( BYTE* Image, DWORD Va )
{
	PIMAGE_DOS_HEADER DosHeader = ( PIMAGE_DOS_HEADER ) Image;
	PIMAGE_NT_HEADERS FileHeader = ( PIMAGE_NT_HEADERS ) ( ( uint64_t ) DosHeader + DosHeader->e_lfanew );

	PIMAGE_SECTION_HEADER SectionHeader = ( PIMAGE_SECTION_HEADER )
		( ( ( ULONG_PTR ) &FileHeader->OptionalHeader ) + FileHeader->FileHeader.SizeOfOptionalHeader );

	for ( int i = 0; i < FileHeader->FileHeader.NumberOfSections; i++ )
	{
		char * Name = ( char* ) SectionHeader[ i ].Name;
		DWORD RawData = SectionHeader[ i ].PointerToRawData;
		DWORD VirtualAddress = SectionHeader[ i ].VirtualAddress;
		DWORD RawSize = SectionHeader[ i ].SizeOfRawData;
		DWORD VirtualSize = SectionHeader[ i ].Misc.VirtualSize;

		if ( Va >= VirtualAddress &&
			 Va < ( VirtualAddress + VirtualSize ) )
		{
			return Image + Va - VirtualAddress + RawData;
		}
	}
	return Image + Va;
}

static void Mp_PushBytes( std::vector<BYTE>& Target, const std::vector<BYTE>& Bytes )
{
	size_t i = Target.size();
	Target.resize( i + Bytes.size() );
	memcpy( &Target[ i ], &Bytes[ 0 ], Bytes.size() );
}

static std::vector<BYTE> Mp_CreateImportShell( BYTE* Image, PVOID MappedAdr, bool LoadLib )
{
	// no handle, no access to modules /shrug
	// could prob read EProcess->Peb but cba sorry

	std::vector<BYTE> Out =
	{ 
		0x48, 0x83, 0xEC, 0x38,                                       // sub    rsp,0x38
		0x4C, 0x8D, 0x3D, 0xDD, 0xCC, 0xBB, 0x00,                     // lea r15, [rip+0xBBCCDD]
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA ; GetModuleHandleA // LoadLibraryA?
		0x49, 0x89, 0xC5,                                             // mov r13, rax
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA ; GetProcAddress
		0x49, 0x89, 0xC4                                              // mov r11, rax
	};

	*( FARPROC* ) &Out[ 0xD ] = LoadLib ? GetProcAddress( GetModuleHandleA( "KERNEL32" ), "LoadLibraryA" ) : GetProcAddress( GetModuleHandleA( "KERNEL32" ), "GetModuleHandleA" ); // avoding __imp's
	*( FARPROC* ) &Out[ 0x1A ] = GetProcAddress( GetModuleHandleA( "KERNEL32" ), "GetProcAddress" );   // avoding __imp's

	std::vector<BYTE> DataContainer = {};

	PIMAGE_DOS_HEADER DosHeader = ( PIMAGE_DOS_HEADER ) Image;
	PIMAGE_NT_HEADERS FileHeader = ( PIMAGE_NT_HEADERS ) ( ( uint64_t ) DosHeader + DosHeader->e_lfanew );
	PIMAGE_OPTIONAL_HEADER OptionalHeader = &FileHeader->OptionalHeader;

	PIMAGE_IMPORT_DESCRIPTOR  ImportDescriptor = ( PIMAGE_IMPORT_DESCRIPTOR ) Mp_RvaToPointer
	(
		Image,
		FileHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].VirtualAddress
	);

	while ( ImportDescriptor && ImportDescriptor->Name && FileHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].Size )
	{
		PCHAR ModuleName = ( PCHAR ) Mp_RvaToPointer( Image, ImportDescriptor->Name );

		IMAGE_THUNK_DATA * Thunk = NULL;
		IMAGE_THUNK_DATA * Func = NULL;

		size_t ModuleNameOffset = DataContainer.size();

		do
			DataContainer.push_back( *ModuleName );
		while ( *ModuleName++ );

		std::vector<BYTE> ModulePusher =
		{ 
			0x49, 0x8D, 0x8F, 0xBB, 0xAA, 0x00, 0x00,  // lea    rcx,[r15+0xaabb]
			0x41, 0xFF, 0xD5,                          // call   r13
			0x48, 0x89, 0xC6                           // mov    rsi,rax
		};

		*( uint32_t* ) ( &ModulePusher[ 3 ] ) = (uint32_t)ModuleNameOffset;

		Mp_PushBytes( Out, ModulePusher );

		if ( ImportDescriptor->OriginalFirstThunk )
		{
			Thunk = ( IMAGE_THUNK_DATA* ) Mp_RvaToPointer( Image, ImportDescriptor->OriginalFirstThunk);
			Func = ( IMAGE_THUNK_DATA* ) ( ( PUCHAR ) MappedAdr + ImportDescriptor->FirstThunk );
		}
		else
		{
			Thunk = ( IMAGE_THUNK_DATA* ) Mp_RvaToPointer( Image, ImportDescriptor->FirstThunk);
			Func = ( IMAGE_THUNK_DATA* ) ( ( PUCHAR ) MappedAdr + ImportDescriptor->FirstThunk );
		}

		for ( ; Thunk->u1.AddressOfData; Thunk++, Func++ )
		{
			assert( !( Thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64 ) );

			FARPROC FunctionAddress = NULL;
			IMAGE_IMPORT_BY_NAME* ImageImportByName = ( IMAGE_IMPORT_BY_NAME* )
				Mp_RvaToPointer( Image, *( DWORD* ) Thunk );
			PCHAR ImportName = ( PCHAR ) ImageImportByName->Name;
			ULONGLONG* Target = &Func->u1.Function;

			size_t ImportNameOffset = DataContainer.size();

			if ( !_strcmpi( ImportName, "AddVectoredExceptionHandler" ) )
				printf( "\n[+] WARNING: Vectored Exception Handling IS NOT SUPPORTED!\n\n" );

			do
				DataContainer.push_back( *ImportName );
			while ( *ImportName++ );

			size_t OffsetOffset = DataContainer.size();
			DataContainer.resize( DataContainer.size() + 8 );
			*( uint64_t* ) ( &DataContainer[ OffsetOffset ] ) = ( uint64_t ) Target;

			std::vector<BYTE> ImportFixer =
			{ 
				0x48, 0x89, 0xF1,                          // mov    rcx,rsi
				0x49, 0x8D, 0x97, 0xBB, 0xAA, 0x00, 0x00,  // lea    rdx,[r9+0xaabb]
				0x41, 0xFF, 0xD4,                          // call   r12
				0x49, 0x8B, 0x9F, 0xBB, 0xAA, 0x00, 0x00,  // mov    rbx,QWORD PTR [r9+0xaabb]
				0x48, 0x89, 0x03                           // mov    QWORD PTR [rbx],rax
			};

			*( uint32_t* ) ( &ImportFixer[ 6 ] ) = (uint32_t)ImportNameOffset;
			*( uint32_t* ) ( &ImportFixer[ 16 ] ) = (uint32_t)OffsetOffset;

			Mp_PushBytes( Out, ImportFixer );

		}
		ImportDescriptor++;
	}

	Mp_PushBytes( Out, { 0x48, 0x83, 0xC4, 0x38 } ); // add rsp, 0x38
	size_t JmpSize = Out.size();
	Mp_PushBytes( Out, { 0xE9, 0x00, 0x00, 0x00, 0x00 } ); // jmp 0xAABBCCDD
	*( uint32_t* ) ( &Out[ 7 ] ) = (uint32_t)Out.size() - 0xB;
	Mp_PushBytes( Out, DataContainer );
	*( int32_t* ) ( &Out[ JmpSize + 1 ] ) = (int32_t)DataContainer.size();
	return Out;
}

static void Mp_RelocateImage( BYTE* Image, BYTE* Target )
{
	PIMAGE_DOS_HEADER DosHeader = ( PIMAGE_DOS_HEADER ) Image;
	PIMAGE_NT_HEADERS FileHeader = ( PIMAGE_NT_HEADERS ) ( ( uint64_t ) DosHeader + DosHeader->e_lfanew );
	PIMAGE_SECTION_HEADER SectionHeader = ( PIMAGE_SECTION_HEADER )
		( ( ( ULONG_PTR ) &FileHeader->OptionalHeader ) + FileHeader->FileHeader.SizeOfOptionalHeader );

	// Copy sections
	memcpy( Target, Image, 0x1000 ); // Pe Header

	for ( int i = 0; i < FileHeader->FileHeader.NumberOfSections; i++ )
	{
		char * Name = ( char* ) SectionHeader[ i ].Name;
		uint64_t RawData = SectionHeader[ i ].PointerToRawData;
		uint64_t VirtualAddress = SectionHeader[ i ].VirtualAddress;
		uint64_t RawSize = SectionHeader[ i ].SizeOfRawData;
		uint64_t VirtSize = SectionHeader[ i ].Misc.VirtualSize;
		ZeroMemory( Target + VirtualAddress, VirtSize );
		memcpy( Target + VirtualAddress, Image + RawData, RawSize );

		if ( !_strcmpi( Name, ".pdata" ) )
			printf( "\n[+] WARNING: Structured Exception Handling IS NOT SUPPORTED!\n\n" );
		if ( !_strcmpi( Name, ".tls" ) )
			printf( "\n[+] WARNING: Thread-local Storage IS NOT SUPPORTED!\n\n" );
	}

	// Reloc sections
	if ( FileHeader->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC &&
		 FileHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].VirtualAddress != 0 )
	{

		PIMAGE_BASE_RELOCATION Reloc = ( PIMAGE_BASE_RELOCATION ) ( Target + FileHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].VirtualAddress );
		DWORD RelocSize = FileHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].Size;
		uint64_t Delta = (uint64_t)Target - FileHeader->OptionalHeader.ImageBase;
		DWORD c = 0;
		while ( c < RelocSize )
		{
			size_t p = sizeof( IMAGE_BASE_RELOCATION );
			LPWORD Chains = ( LPWORD ) ( ( PUCHAR ) Reloc + p );
			while ( p < Reloc->SizeOfBlock )
			{
				uint64_t Base = ( uint64_t ) ( Target + Reloc->VirtualAddress );
				switch ( *Chains >> 12 )
				{
					case IMAGE_REL_BASED_HIGHLOW:
						*( uint32_t* ) ( Base + ( *Chains & 0xFFF ) ) += ( uint32_t ) Delta;
						break;
	 				case IMAGE_REL_BASED_DIR64:
						*( uint64_t* ) ( Base + ( *Chains & 0xFFF ) ) += Delta;
						break;
				}
				Chains++;
				p += sizeof( WORD );
			}
			c += Reloc->SizeOfBlock;
			Reloc = ( PIMAGE_BASE_RELOCATION ) ( ( PBYTE ) Reloc + Reloc->SizeOfBlock );
		}
	}

}

static TlsLockedHookController* Mp_MapDllAndCreateHookEntry( const std::string& Path, PVOID ValCheck, PVOID HookOut, bool LoadLib, const std::function<PVOID( SIZE_T )>& MemoryAllocator )
{
	auto File = Mp_ReadFile( Path );

	assert( File.size() );

	PIMAGE_DOS_HEADER DosHeader = ( PIMAGE_DOS_HEADER ) File.data();

	assert( DosHeader->e_magic == IMAGE_DOS_SIGNATURE );

	PIMAGE_NT_HEADERS FileHeader = ( PIMAGE_NT_HEADERS ) ( ( uint64_t ) DosHeader + DosHeader->e_lfanew );

	assert( FileHeader->Signature == IMAGE_NT_SIGNATURE );

	PIMAGE_OPTIONAL_HEADER OptionalHeader = &FileHeader->OptionalHeader;

	assert( OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC );
	assert( FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64 );

	std::vector<BYTE> Prologue =
	{ 
		0x00, 0x00, // data
		0xF0, 0xFE, 0x05, 0xF8, 0xFF, 0xFF, 0xFF,                     // lock inc byte ptr [rip-n]
		                                                              // wait_lock:
		0x80, 0x3D, 0xF0, 0xFF, 0xFF, 0xFF, 0x00,                     // cmp byte ptr [rip-m], 0x0
		0xF3, 0x90,                                                   // pause
		0x74, 0xF5,                                                   // je wait_lock

		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA
		                                                              // data_sync_lock:
		0x0F, 0x0D, 0x08,                                             // prefetchw [rax]
		0x81, 0x38, 0xDD, 0xCC, 0xBB, 0xAA,                           // cmp dword ptr[rax], 0xAABBCCDD
		0xF3, 0x90,                                                   // pause
		0x75, 0xF3,                                                   // jne data_sync_lock

		0xF0, 0xFE, 0x0D, 0xCF, 0xFF, 0xFF, 0xFF,                     // lock dec byte ptr [rip-n]
		0x75, 0x41,                                                   // jnz continue_exec                         
		0x53,                                                         // push stuff
		0x51, 
		0x52, 
		0x56, 
		0x57, 
		0x55, 
		0x41, 0x50, 
		0x41, 0x51, 
		0x41, 0x52, 
		0x41, 0x53, 
		0x41, 0x54, 
		0x41, 0x55, 
		0x41, 0x56, 
		0x41, 0x57, 
		0x9C, 
		0x48, 0x89, 0xE5,                                             // mov rbp, rsp
		0x48, 0x83, 0xEC, 0x20,                                       // sub rsp, 0x20
		0x48, 0x83, 0xE4, 0xF0,                                       // and rsp, 0xFFFFFFFFFFFFFFF0
		0xE8, 0x26, 0x00, 0x00, 0x00,                                 // call stub
		0x48, 0x89, 0xEC,                                             // mov rsp, rbp
		0x9D,                                                         // pop stuff
		0x41, 0x5F, 
		0x41, 0x5E,
		0x41, 0x5D, 
		0x41, 0x5C, 
		0x41, 0x5B, 
		0x41, 0x5A, 
		0x41, 0x59, 
		0x41, 0x58, 
		0x5D, 
		0x5F, 
		0x5E, 
		0x5A, 
		0x59, 
		0x5B, 
		0x48, 0xB8, 0xAA, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00,  // mov rax, 0xAABBCCDDEEFFAA
		0xFF, 0xE0                                                   // jmp rax
		                                                             // stub:
	};

	*( PVOID* ) &Prologue[ 0x77 ] = HookOut;
	*( PVOID* ) &Prologue[ 0x16 ] = ValCheck;
	*( DWORD* ) &Prologue[ 0x23 ] = *( DWORD* ) ValCheck;

	std::vector<BYTE> JmpEntryPont =
	{ 
		0x48, 0xB8, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00, 0x00, 0x00,   // mov rax, 0xAABBCCDD
		0x48, 0x89, 0xC1,                                             // mov rcx, rax
		0x48, 0xC7, 0xC2, 0x01, 0x00, 0x00, 0x00,                     // mov rdx, 1
		0x4D, 0x31, 0xC0,                                             // xor r8, r8
		0x48, 0x05, 0xCD, 0xBB, 0xAA, 0x00,                           // add rax, 0xAABBCD
		0xFF, 0xE0                                                    // jmp rax
	};

	printf( "[+] Creating import shellcode...\n" );
	size_t ShellSize = Mp_CreateImportShell( File.data(), nullptr, LoadLib ).size() + JmpEntryPont.size() + Prologue.size();

	BYTE* Memory = ( BYTE* ) MemoryAllocator( OptionalHeader->SizeOfImage + ShellSize + 0xFFF );

	uint64_t ImageMemory = ( ( uint64_t ) Memory + ShellSize + 0xFFF )&( ~0xFFF );

	*( uint64_t* ) ( &JmpEntryPont[ 0x02 ] ) = ImageMemory;
	*( uint32_t* ) ( &JmpEntryPont[ 0x19 ] ) = FileHeader->OptionalHeader.AddressOfEntryPoint;

	auto Shell = Mp_CreateImportShell( File.data(), PVOID( ImageMemory ), LoadLib );
	Mp_PushBytes( Shell, JmpEntryPont );
	Mp_PushBytes( Prologue, Shell );
	Shell = Prologue;

	printf( "[+] Relocating image...\n" );
	Mp_RelocateImage( File.data(), PBYTE( ImageMemory ) );
	memcpy( Memory, Shell.data(), Shell.size() );

	printf( "[+] Image mapping done!\n" );
	return ( TlsLockedHookController * ) Memory;
}

```

`vcpkg.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json",
  "name": "bakaware",
  "dependencies": [
    "nlohmann-json",
    {
      "name": "imgui",
      "features": [
        "dx11-binding",
        "win32-binding"
      ]
    }
  ]
}
```