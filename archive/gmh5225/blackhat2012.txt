Project Path: arc_gmh5225_blackhat2012_z252she5

Source Tree:

```txt
arc_gmh5225_blackhat2012_z252she5
├── ASMsrc
│   ├── README.md
│   ├── anti-vm_in_instruction.ASM
│   ├── anti_disassembly_yason.ASM
│   ├── api_hash.ASM
│   ├── api_hash_stealth.ASM
│   ├── call_trick.ASM
│   ├── code_transposition.ASM
│   ├── ep_not_exec.ASM
│   ├── fakecode.ASM
│   ├── fakejump.ASM
│   ├── fakemath.ASM
│   ├── garbage_bytes.ASM
│   ├── hardware_bp.ASM
│   ├── heapflags.ASM
│   ├── instr_substitution.ASM
│   ├── instruction_counting.ASM
│   ├── middle_instruction.ASM
│   ├── nop_sequence.ASM
│   ├── ntglobal.ASM
│   ├── peb.ASM
│   ├── program_control_flow.ASM
│   ├── pushret.ASM
│   ├── rdtsc.ASM
│   ├── register_reassignment.ASM
│   ├── softice.ASM
│   ├── software_bp.ASM
│   └── ss_register.ASM
├── Csrc
│   ├── README.md
│   ├── VMDetection
│   │   ├── VMDetection
│   │   │   ├── ReadMe.txt
│   │   │   ├── VMDetection.cpp
│   │   │   ├── VMDetection.vcxproj
│   │   │   ├── VMDetection.vcxproj.filters
│   │   │   └── VMDetection.vcxproj.user
│   │   ├── VMDetection.sln
│   │   └── VMDetection.suo
│   └── fcall_examples
│       ├── fcall_examples
│       │   ├── ReadMe.txt
│       │   ├── defs.h
│       │   ├── defs2.h
│       │   ├── fcall_examples.cpp
│       │   ├── fcall_examples.vcxproj
│       │   ├── fcall_examples.vcxproj.filters
│       │   ├── fcall_examples.vcxproj.user
│       │   └── ntDefs.h
│       ├── fcall_examples.sln
│       ├── fcall_examples.suo
│       └── ipch
│           └── fcall_examples-e4364cbf
│               └── fcall_examples-cedde00c.ipch
├── README.md
├── blackhat2012-paper.pdf
└── blackhat2012-presentation.pdf

```

`ASMsrc/README.md`:

```md
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>README ASM source</title>
</head>
<body>
<pre>
Qualys Vulnerabliity & Malware Research Labs (VMRL)

Blackhat 2012 Presentation Samples

TiTle:	A Scientific (but non academic) study of how malware employs anti-debugging,
		anti-disassembly and anti-virtualization technologies
		
Authors: Rodrigo Rubira Branco - rbranco *NOSPAM* qualys.com
		 Gabriel Negreira Barbosa - gbarbosa *NOSPAM* qualys.com
		 Pedro Drimel Neto - pdrimel *NOSPAM* qualys.com
		 
Those are the anti-debugging techniques implemented in ASM. To compile use
flat assembly which is available at http://flatassembler.net/

</pre>
</body>
</html>

```

`ASMsrc/anti-vm_in_instruction.ASM`:

```ASM
; Created for Hackers 2 Hackers Conference (H2HC) 2012 - 9th Edition
; Training: Windows Malware Reverse Engineering
;
; Authors:
; Rodrigo Rubira Branco
; Gabriel Negreira Barbosa
;
; VMWare IN Anti-VM Technique
;
; Based on:
; Tom Liston, and Ed Skoudis - On the Cutting Edge: Thwarting Virtual Machine Detection - http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf

include 'win32ax.inc'

.code

  start:
	push	.vmware_not_detected
	push	dword [fs:0x0]
	mov	[fs:0x0],esp

	mov	eax,0x564D5868 ; 'VMXh'
	mov	ebx,0x0
	mov	ecx,0xA
	mov	edx,0x5658 ; 'VX'

	in	eax,dx

	cmp	ebx,0x564D5868 ; 'VMXh'
	je	.vmware_detected
	jmp	.vmware_not_detected



	.vmware_detected:
		invoke	MessageBox,HWND_DESKTOP,"VMWare Detected!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0

	.vmware_not_detected:
		invoke	MessageBox,HWND_DESKTOP,"VMWare NOT Detected!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0

  .end start

```

`ASMsrc/anti_disassembly_yason.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test branch to garbage byte (5.2)
; reference: "The Art of Unpacking" by Mark Vincent Yason
;

include 'win32ax.inc'

.code
	start:
		push	.jmp_real_01
		stc
		jnc	.jmp_fake_01
		retn

		.jmp_fake_01:
			db	0xff

		.jmp_real_01:
			mov	eax, [fs:0x18]
			push	.jmp_real_02
			clc
			jc	.jmp_fake_02
			retn

		.jmp_fake_02:
			db 0xff

		.jmp_real_02:
			mov	eax, [eax+0x30]
			movzx	eax, byte [eax+0x02]
			test	eax, eax
			jnz	.debugger_found
			jmp	.exit

		.debugger_found:
			invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
			invoke	ExitProcess, 0
		.exit:
			invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK
			invoke	ExitProcess,0

	.end start
```

`ASMsrc/api_hash.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created only to test PEB-> Ldr Address Resolving detection (4.3)
; it is by no means a fully functional program to be used in order to import windows APIs
; reference: Harmony Security - Blog - Retrieving Kernel32's Base Address
; http://blog.harmonysecurity.com/2009/06/retrieving-kernel32s-base-address.html

include 'win32ax.inc'

.code

  start:
	pusha
	mov	eax,[fs:0x30]	; PEB
	mov	eax,[eax+0xc]	; Ldr
	mov	eax,[eax+0xc]	; InLoadOrderModuleList.Flink
	mov	eax,[eax]	; InLoadOrderModuleList.Flink
	mov	eax,[eax]	; InLoadOrderModuleList.Flink
	mov	eax,[eax+0x18]	; BaseAddress

	mov	ebx,eax

	add	eax,[eax+0x3c]	; DOS_HEADER.e_lfanew
	mov	eax,[eax+0x78]	; OptionalHeader.ExportDir.VirtualAddress
	add	eax,ebx

	lea	esi,[eax+0x1c]	 ; AddressOfFunctions

	invoke	ExitProcess,0

  .end start
```

`ASMsrc/api_hash_stealth.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created only to test stealth import of windows API (4.4)
; it is by no means a fully functional program to be used in order to import windows APIs
; This program was created to test ntglobal access (3.1)
; reference: Alexey Lyashko - Stealth Import of Windows API
; http://syprog.blogspot.com.br/2011/10/stealth-import-of-windows-api.html

include 'win32ax.inc'

.data
	mz db "MZ"
	pe db "PE"

.code

  start:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop

	mov	eax,[fs:0]
	;mov     ebx,0FFFFFFFFh

	.search_default_handler:
		cmp	dword [eax], 0xFFFFFFFF
		jz	.found_default_handler
		mov	eax, [eax]
		jmp	.search_default_handler

	.found_default_handler:
	       mov	eax, [eax+4]
	       and	eax, 0xFFFF0000

	.look_for_mz:
		cmp	word [eax], 'MZ'
		jz     .got_mz
		sub    eax, 0x10000
		jmp    .look_for_mz

	.got_mz:
		mov	bx, [eax+0x3C]
		movzx	ebx,bx
		add	eax,ebx
		mov	bx, 'PE'
		movzx	ebx, bx
		cmp    [eax], ebx
		jz     .found_pe
		jmp    .not_found_pe

	.found_pe:
		add	eax, 0x78
		invoke	MessageBox,HWND_DESKTOP,"PE signature found!",invoke GetCommandLine,MB_OK
		pop	esi
		pop	edi
		pop	edx
		pop	ecx
		pop	ebx
		pop	eax
		invoke	ExitProcess,NULL

	.not_found_pe:
		invoke	MessageBox,HWND_DESKTOP,"PE signature not found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start
```

`ASMsrc/call_trick.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop
	call	.function
	db	0x6a
	.correct_return:
		pop eax
		invoke	MessageBox,HWND_DESKTOP,"This is where should return",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0
	.function:
		push	DWORD .correct_return
		ret
  .end start

```

`ASMsrc/code_transposition.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop

	; before obfuscation
	; xor    eax,eax
	; inc    eax
	; push   ebx
	; jmp    .continuation
	; .continuation:
	;          invoke  MessageBox,HWND_DESKTOP,"Destination!",invoke GetCommandLine,MB_OK


	; after obfuscation
	jmp	.first

	.second:
		push	ebx
		jmp	.continuation

	.first:
		xor	eax,eax
		inc	eax
		jmp	.second

	.continuation:
		  invoke  MessageBox,HWND_DESKTOP,"Destination!",invoke GetCommandLine,MB_OK


	invoke	ExitProcess,0
  .end start

```

`ASMsrc/ep_not_exec.ASM`:

```ASM
; EP not exec

include 'win32ax.inc'

.code

  start:
	invoke	MessageBox,HWND_DESKTOP,"Hello EP not exec!",invoke GetCommandLine,MB_OK
	invoke	ExitProcess,0

  .end start
```

`ASMsrc/fakecode.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop

	;jmp     .destination
	;push    0x12345678
	;inc     eax
	;mov     esp,eax
	;invoke  MessageBox,HWND_DESKTOP,"This does not execute!",invoke GetCommandLine,MB_OK
	;.destination:
	;        invoke  MessageBox,HWND_DESKTOP,"This gets executed!",invoke GetCommandLine,MB_OK

	;xor     eax,eax
	;jnz     .fake_code
	;jmp     .destination
	;.fake_code:
	;        push    0x12345678
	;        inc     eax
	;        mov     esp,eax
	;        invoke  MessageBox,HWND_DESKTOP,"This does not execute!",invoke GetCommandLine,MB_OK
	;.destination:
	;        invoke  MessageBox,HWND_DESKTOP,"This gets executed!",invoke GetCommandLine,MB_OK

	push	.destination
	ret
	push	0x12345678
	inc	eax
	mov	esp,eax
	invoke	MessageBox,HWND_DESKTOP,"This does not execute!",invoke GetCommandLine,MB_OK
	.destination:
		invoke	MessageBox,HWND_DESKTOP,"This gets executed!",invoke GetCommandLine,MB_OK




	invoke	ExitProcess,0
  .end start

```

`ASMsrc/fakejump.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop
	;xor     eax,eax
	;jz      .destination

	;stc
	;jc      .destination

	clc
	jnc	.destination

	;xor     eax,eax
	;jnz     .destination2

	.destination:
		invoke	MessageBox,HWND_DESKTOP,"Destination",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0
	;.destination2:
	;        invoke  ExitProcess,0

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/fakemath.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test push followed by pop and xor/or (4.1)
; reference: Laspe Raber, Jason Raber - BlackHat 2008
;            Deobfuscator: An Automated Approach to the Identification and Removal of Code Obfuscation


include 'win32ax.inc'

.code

  start:
	xor	eax,eax
	xor	ebx,ebx
	xor	ecx,ecx
	xor	edx,edx
	push	0x4040
	pop	eax
	xor	eax, 0x5050

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/garbage_bytes.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop

	;jmp     .destination
	;db      0x6a ; garbage byte technique
	;.destination:
	;        pop eax

	mov	eax,eax
	jz	.destination
	db	0x6a
	.destination:
		pop eax

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/hardware_bp.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test hardware breakpoint detection (3.13)
; reference: "Anti-Unpacker Tricks" by Peter Ferrie


include 'win32ax.inc'

.code

  start:
	push	.exception_handler
	push	dword [fs:0]
	mov	[fs:0],esp

	xor	eax,eax
	mov	dword [eax], 0
	pop	dword [fs:0]
	add	esp,4
	test	eax,eax
	jnz	.being_debugged
	jmp	.exit


	.exception_handler:
	mov	eax,[esp+0xc]
	cmp	dword [eax+0x04],0
	jne	.being_debugged
	cmp	dword [eax+0x08],0
	jne	.being_debugged
	cmp	dword [eax+0x0C],0
	jne	.being_debugged
	cmp	dword [eax+0x10],0
	jne	.being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Hardwae BP Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Hardware BP Not Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`ASMsrc/heapflags.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test heap flags access (3.4)
; reference: "Anti-Unpacker Tricks" by Peter Ferrie

include 'win32ax.inc' ;

.code

  start:
	mov	eax,[fs:0x30]
	mov	eax,[eax+0x18]
	mov	eax,[eax+0xc]
	dec	eax
	dec	eax
	jne	.being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/instr_substitution.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop
	;push    .destination
	;ret

	;mov     dword[esp],.destination
	;ret

	push	.destination
	push	ebp
	mov	ebp,esp
	leave
	ret

	.destination:
		  invoke  MessageBox,HWND_DESKTOP,"Destination!",invoke GetCommandLine,MB_OK


	invoke	ExitProcess,0
  .end start

```

`ASMsrc/instruction_counting.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test detection of instruction counting implemented by tElock  (3.29)
; references:
; "Anti-Unpacker Tricks" by Peter Ferrie
; "The Ultimate Anti-Debugging Reference" by Peter Ferrie

include 'win32ax.inc'

.code

  start:
	xor	eax,eax
	push	.exception
	push	dword [fs:eax]
	mov	[fs:eax], esp
	int3	; force an exception
	.labelone:
		nop
		nop
		nop
		nop
	cmp	al, 4  ; when no hardware breakpoint is set 0x4 is returned in EAX
	jne	.being_debugged
	jmp	.exit

	.exception:
		push	edi
		mov	eax, [esp+8]	; ExceptionRecord
		mov	edi, [esp+0x10] ; ContextRecord

		push	0x55; local-enable DR0, DR1, DR2, DR3 - how does it actually happen? didnt understand this 0x55
		pop	ecx
		inc	dword [ecx*2+edi+0x0e]; EIP (which is defined in ContextRecord) - why does not use AA instead of 55*2
					      ; Debugging I did not see EIP being incremented... bug?
					      ; that's EIP in CONTEXT, skip one NOP at each time

		mov	eax, [eax]; ExceptionCode
		sub	eax, 0x80000003
		jne	.test_singlestep ; if code is not EXCEPTION_BREAKPOINT (usual) jumps to .test_singlestep
		mov	eax, .labelone	 ; EAX has offset of .labelone
		scasd
		stosd	; dr0
		inc	eax
		stosd	; dr1
		inc	eax
		stosd	; dr2
		inc	eax
		stosd	; dr3
		mov	ch,1
		xchg	ecx, eax
		scasd
		stosd	; dr7 ?
		xor	eax,eax
		pop	edi
		ret

	.test_singlestep:
		dec	eax;
		jne	.being_debugged ; if ExceptionCode is equal SINGLE_STEP 0x80000002 then debugger detected
					; otherwise return
		inc	dword [ecx*2+edi+6]; EAX increment EAX in the CONTEXT, used to hold the count of single-step instructions!
		pop	edi
		ret

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger NOT Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`ASMsrc/middle_instruction.ASM`:

```ASM
; Created for Hackers 2 Hackers Conference (H2HC) 2012 - 9th Edition
; Training: Windows Malware Reverse Engineering
;
; Authors:
; Rodrigo Rubira Branco
; Gabriel Negreira Barbosa
;
; Jump to the middle of an instruction
;
; Based on:
; Nick Harbour - Advanced Software Armoring and Polymorphic Kung-Fu

include 'win32ax.inc'

.code

  start:
	; Useles pushes. They are here only to pop later.
	; The idea of such pops is to make it clear, in the debugger, the destination of the "jmp 5" inside the mov instruction
	push 0x1
	push 0x2
	push 0x3

	mov ax,0x05eb
	xor eax,eax

	; jump to "jmp 5" (0xeb 0xe5)
	; last bytes of mov instruction is 0xeb 0xe5
	; such "jmp 5" redirects the flow to the "; rest of the code"
	jz $-4

	db 0xe8 ; garbage byte

	; rest of the code

	; pops described in the pushes comment
	pop eax
	pop eax
	pop eax

	invoke	MessageBox,HWND_DESKTOP,"Hooray!",invoke GetCommandLine,MB_OK
	invoke	ExitProcess, 0
  .end start

```

`ASMsrc/nop_sequence.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test NOP sequence detection (4.2)
; reference: Mihai Christodorescu, Somesh Jha - Proceedings of the 12th USENIX Security

include 'win32ax.inc'

.code

  start:
	xor	eax, eax
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	mov	eax,0x10101010
	nop
	nop
	nop
	invoke	ExitProcess,0

  .end start

```

`ASMsrc/ntglobal.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test ntglobal access (3.1)
; reference: "Anti-Unpacker Tricks" by Peter Ferrie
;

include 'win32ax.inc'

.code

  start:
	xor	eax,eax
	xor	ebx,ebx

	mov	eax,[fs:0x30]
	mov	bl,[eax+68h]
	cmp	bl,70h
	je	.being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/peb.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test PEB Being Debuged access (3.2)
; reference: "Anti-Unpacker Tricks" by Peter Ferrie

include 'win32ax.inc'

.code

  start:
	push	dword [fs:0x30]
	pop	eax
	push	dword [eax+0x2]
	pop	ebx
	cmp	bl, 0
	jne	.being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0
  .end start

```

`ASMsrc/program_control_flow.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop

	push	.destination
	jmp	dword [esp]
	db	0x6a
	.destination:
		pop eax

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/pushret.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test push-ret anti-disassembly technique (5.1)

include 'win32ax.inc'

.code

  start:
	pop	eax
	pop	ebx
	pop	ecx
	push	.continue
	ret
	db	0xab
	db	0xbc
	db	0xcd
	db	0xff
	db	0xaa
	db	0x1
	db	0x2
	db	0xff
	db	0xef
	db	0xe9
	db	0xab
	db	0xe8
	db	0xa9

	.continue:
		xor	eax,eax
		mov	ecx,1
		nop
		xchg	eax,ecx
		push	edx
		pop	edx
		invoke	ExitProcess,0
  .end start

```

`ASMsrc/rdtsc.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test RDTSC instruction timing (3.25)
; references:
; "Anti-Unpacker Tricks" by Peter Ferrie
; "The Ultimate Anti-Debugging Reference" by Peter Ferrie
; "Windows Anti-Debug Reference" by Nicolas Falliere:
; http://www.symantec.com/connect/articles/windows-anti-debug-reference

include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	rdtsc	; rdpmc or rdmsr (64 bits)
	xor	ecx,ecx
	add	ecx,eax
	rdtsc	; rdpmc or rdmsr (64 bits)
	sub	eax,ecx
	cmp	eax,0xFFF
	jnb    .being_debugged
	jmp    .exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`ASMsrc/register_reassignment.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop

	; before obfuscation
	; xor    eax,eax
	; inc    ebx

	; after obfuscation
	xor	ebx,ebx
	inc	eax

	invoke	ExitProcess,0
  .end start

```

`ASMsrc/softice.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
; This program was created to test softice anti-debugging detection (3.21)
; reference: "Anti-Unpacker Tricks" by Peter Ferrie


include 'win32ax.inc'

.code

  start:
	xor	eax, eax
	push	dword [fs:0]
	mov	[fs:0],esp
	int1
	.exception:
		mov	eax,[esp+0x4]
		cmp	dword[eax], 0x80000004
		je	.being_debugged
		jmp	.exit
	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`ASMsrc/software_bp.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test detection of software breakpoint (3.26)
; reference: "The Art Of Unpacking" by Mark Vincent Yason

include 'win32ax.inc'

.code

  start:
	nop
	xor	eax,eax
	xor	ebx,ebx
	xor	ecx,ecx
	xor	edx,edx

	.protectedcode:
		nop
		nop
		nop
		xor	eax,eax
		nop
		nop
		nop
		nop
	cld
	mov	edi,.protectedcode
	mov	ecx,0x09
	mov	al,0xCC
	repne	scasb
	jz	.being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Software Breakpoint Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Software Breakpoint NOT Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`ASMsrc/ss_register.ASM`:

```ASM
; Qualys Vulnerabliity & Malware Research Labs (VMRL)
; Blackhat 2012 Presentation Samples
; TiTle:   A Scientific (but non academic) study of how malware employs anti-debugging,
;          anti-disassembly and anti-virtualization technologies
; Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
;          Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
;          Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>
;
;
; This program was created to test SS register use to detect debugger (single-step) (3.22)
; references:
; "Anti-Unpacker Tricks" by Peter Ferrie
; "The Ultimate Anti-Debugging Reference" by Peter Ferrie
; "Windows Anti-Debug Reference" by Nicolas Falliere:
; http://www.symantec.com/connect/articles/windows-anti-debug-reference

include 'win32ax.inc'

.code

  start:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	push	ss
	pop	ss
	pushfd
	test   byte [esp+1], 1
	jnz    .being_debugged
	jmp	.exit

	.being_debugged:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Found - Single step detected!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess, 0
	.exit:
		invoke	MessageBox,HWND_DESKTOP,"Debugger Not Found!",invoke GetCommandLine,MB_OK
		invoke	ExitProcess,0

  .end start

```

`Csrc/README.md`:

```md
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>README C source</title>
</head>
<body>
<pre>
Qualys Vulnerabliity & Malware Research Labs (VMRL)

Blackhat 2012 Presentation Samples

TiTle: 	A Scientific (but non academic) study of how malware employs anti-debugging,
		anti-disassembly and anti-virtualization technologies

Authors: Rodrigo Rubira Branco  - rbranco *NOSPAM* qualys.com
		 Gabriel Negreira Barbosa - gbarbosa *NOSPAM* qualys.com
		 Pedro Drimel Neto - pdrimel *NOSPAM* qualys.com

The files on this directory were compiled on Visual Studio 2010

Directories:
fcall_examples - Those are anti-debugging techinques that were implemented in C/C++
VMDetection - anti-VM techniques

</pre>
</body>
</html>


```

`Csrc/VMDetection/VMDetection.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VMDetection", "VMDetection\VMDetection.vcxproj", "{DC7096E1-91C2-471F-8DED-1F70E4B09551}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DC7096E1-91C2-471F-8DED-1F70E4B09551}.Debug|Win32.ActiveCfg = Debug|Win32
		{DC7096E1-91C2-471F-8DED-1F70E4B09551}.Debug|Win32.Build.0 = Debug|Win32
		{DC7096E1-91C2-471F-8DED-1F70E4B09551}.Release|Win32.ActiveCfg = Release|Win32
		{DC7096E1-91C2-471F-8DED-1F70E4B09551}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Csrc/VMDetection/VMDetection/ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : VMDetection Project Overview
========================================================================

AppWizard has created this VMDetection application for you.

This file contains a summary of what you will find in each of the files that
make up your VMDetection application.


VMDetection.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

VMDetection.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

VMDetection.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named VMDetection.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`Csrc/VMDetection/VMDetection/VMDetection.cpp`:

```cpp
/* Qualys Vulnerabliity & Malware Research Labs (VMRL)
Blackhat 2012 Presentation Samples
TiTle: 	A Scientific (but non academic) study of how malware employs anti-debugging,
		anti-disassembly and anti-virtualization technologies
Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
		 Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
		 Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>

This program basically implements virtual machine detection techniques described
on sections 5.1, 5.2 and 5.3. The code is based on the following sources:

http://www.trapkit.de/research/vmm/scoopyng/
http://www.offensivecomputing.net/dc14/vmdetect.cpp
http://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual		 
*/

#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <conio.h>
#include <excpt.h>

// 5.1
// Reference:
// ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void sidt() {
	unsigned char	idtr[6];
	unsigned long	idt	= 0;

	_asm sidt idtr
	idt = *((unsigned long *)&idtr[2]);

	if 	((idt >> 24) == 0xff)
		printf("VM detected\n");
	else
		printf("VM not detected\n");
		
}

// 5.1
// Reference:
// ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void sldt() {
	unsigned char   ldtr[5] = "\xef\xbe\xad\xde";
	unsigned long   ldt			= 0;

	_asm sldt ldtr
	ldt = *((unsigned long *)&ldtr[0]);

	if (ldt == 0xdead0000)
		printf("VM not detected\n");
	else
		printf("VM detected\n");
}

// 5.1
// Reference:
// ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void sgdt() {
	unsigned char   gdtr[6];
	unsigned long   gdt	= 0;

	_asm sgdt gdtr
	gdt = *((unsigned long *)&gdtr[2]);

	if ((gdt >> 24) == 0xff)
		printf("VM detected\n");
	else
		printf("VM not detected\n");
}

// 5.1
// Reference:
// ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void str() {
	unsigned char	mem[4] = {0, 0, 0, 0};

	__asm str mem;

	if ((mem[0] == 0x00) && (mem[1] == 0x40))
		printf ("VM detected\n");
	else
		printf ("VM not detected\n");
}

// 5.1
// Reference
// http://www.offensivecomputing.net/ Written by Danny Quist, Offensive Computing
void smsw() {
    unsigned int reax = 0;

    __asm
    {
        mov eax, 0xCCCCCCCC;
        smsw eax;
        mov DWORD PTR [reax], eax;
    }

	if ( (( (reax >> 24) & 0xFF ) == 0xcc) && (( (reax >> 16) & 0xFF ) == 0xcc))
        printf("VM detected\n");
	else
		printf("VM not detected\n");
}

// 5.2
// Reference: ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void vmware_get_memory() {
	unsigned int	a	= 0;

	__try {
		__asm {
			push eax
			push ebx
			push ecx
			push edx
			
			mov eax, 'VMXh'
			mov ecx, 14h
			mov dx, 'VX'
			in eax, dx
			mov a, eax 

			pop edx
			pop ecx
			pop ebx
			pop eax
		}
	} __except (EXCEPTION_EXECUTE_HANDLER) {}

	if (a > 0)
		printf("VMWare detected\n");
	else
		printf("VMWare not detected\n");
}

// 5.2
// Reference: ScoopyNG - The VMware detection tool - Version v1.0 - Tobias Klein, 2008 - www.trapkit.de
void vmware_get_version() {
	unsigned int	a, b;

	__try {
		__asm {
			push eax			
			push ebx
			push ecx
			push edx
			
			mov eax, 'VMXh'
			mov ecx, 0Ah
			mov dx, 'VX'			
			in eax, dx
			mov a, ebx 
			mov b, ecx

			pop edx
			pop ecx
			pop ebx
			pop eax
		}
	} __except (EXCEPTION_EXECUTE_HANDLER) {}

	if (a == 'VMXh')
		printf("VM detected\n");
	else
		printf("VM not detected\n");
}

// 5.3
// Reference:
// http://www.codeproject.com/system/VmDetect.asp
DWORD __forceinline IsInsideVPC_exceptionFilter(_EXCEPTION_POINTERS *ep)
{
  PCONTEXT ctx = ep->ContextRecord;

  ctx->Ebx = -1; // Not running VPC
  ctx->Eip += 4; // skip past the "call VPC" opcodes
  return EXCEPTION_CONTINUE_EXECUTION;
  // we can safely resume execution since we skipped faulty instruction
}

// From Elias Bachaalany's Codeproject.com post:
// http://www.codeproject.com/system/VmDetect.asp
BOOL virtualpc_detect()
{
  bool rc = false;

  __try {
	  __asm {
		  	push eax			
			push ebx
			push ecx
			push edx

			mov ebx,0h
			mov eax, 01h
			
			__emit 0Fh
			__emit 3Fh
			__emit 07h
			__emit 0Bh

			test ebx, ebx
			setz [rc]
    
			pop edx
			pop ecx
			pop ebx
			pop eax
	  }
  }
  __except(IsInsideVPC_exceptionFilter(GetExceptionInformation())) {
	rc = false;
  }
  return rc;
}

int _tmain(int argc, _TCHAR* argv[]) {

	int opt = 0;
	BOOL vpc = false;

	printf("Virtual Machine detection tool \n\n");
	printf("1 - SGDT \n");
	printf("2 - SLDT \n");
	printf("3 - STR \n");
	printf("4 - SMSW \n");
	printf("5 - VMWare get memory\n");
	printf("6 - VMWare get version\n");
	printf("7 - VirtualPC detection\n\n");
	scanf_s("%d", &opt);
	switch (opt) {
		case 1: sgdt();
				break;
		case 2: sldt();
				break;
		case 3: str();
				break;
		case 4: smsw();
				break;
		case 5: vmware_get_memory();
				break;
		case 6: vmware_get_version();
				break;
		case 7: vpc = virtualpc_detect();
				if (vpc)
					printf("VirtualPC detected\n");
				else
					printf("VirtualPC not detected\n");
				break;
		default: printf("Invalid option\n");
				break;
	}

	_getch();
	return 0;
}


```

`Csrc/VMDetection/VMDetection/VMDetection.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DC7096E1-91C2-471F-8DED-1F70E4B09551}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VMDetection</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VMDetection.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Csrc/VMDetection/VMDetection/VMDetection.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VMDetection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Csrc/VMDetection/VMDetection/VMDetection.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Csrc/fcall_examples/fcall_examples.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "fcall_examples", "fcall_examples\fcall_examples.vcxproj", "{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}.Debug|Win32.ActiveCfg = Debug|Win32
		{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}.Debug|Win32.Build.0 = Debug|Win32
		{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}.Release|Win32.ActiveCfg = Release|Win32
		{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Csrc/fcall_examples/fcall_examples/ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : fcall_examples Project Overview
========================================================================

AppWizard has created this fcall_examples application for you.

This file contains a summary of what you will find in each of the files that
make up your fcall_examples application.


fcall_examples.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

fcall_examples.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

fcall_examples.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named fcall_examples.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`Csrc/fcall_examples/fcall_examples/defs.h`:

```h
#include "windows.h"

typedef LONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

typedef struct _DEBUG_BUFFER {
	HANDLE SectionHandle;
	PVOID  SectionBase;
	PVOID  RemoteSectionBase;
	ULONG  SectionBaseDelta;
	HANDLE  EventPairHandle;
	ULONG  Unknown[2];
	HANDLE  RemoteThreadHandle;
	ULONG  InfoClassMask;
	ULONG  SizeOfInfo;
	ULONG  AllocatedSize;
	ULONG  SectionSize;
	PVOID  ModuleInformation;
	PVOID  BackTraceInformation;
	PVOID  HeapInformation;
	PVOID  LockInformation;
	PVOID  Reserved[8];
} DEBUG_BUFFER, *PDEBUG_BUFFER;

typedef struct _DEBUG_HEAP_INFORMATION
{
	ULONG Base; // 0×00
	ULONG Flags; // 0×04
	USHORT Granularity; // 0×08
	USHORT Unknown; // 0x0A
	ULONG Allocated; // 0x0C
	ULONG Committed; // 0×10
	ULONG TagCount; // 0×14
	ULONG BlockCount; // 0×18
	ULONG Reserved[7]; // 0x1C
	PVOID Tags; // 0×38
	PVOID Blocks; // 0x3C
} DEBUG_HEAP_INFORMATION, *PDEBUG_HEAP_INFORMATION;

// RtlQueryProcessDebugInformation.DebugInfoClassMask constants
#define PDI_MODULES                       0x01
#define PDI_BACKTRACE                     0x02
#define PDI_HEAPS                         0x04
#define PDI_HEAP_TAGS                     0x08
#define PDI_HEAP_BLOCKS                   0x10
#define PDI_LOCKS                         0x20

#ifdef __cplusplus
extern "C" {  
#endif  

extern "C" __declspec(dllimport) NTSTATUS __stdcall RtlQueryProcessDebugInformation(
	IN ULONG  ProcessId,
	IN ULONG  DebugInfoClassMask,
	IN OUT PDEBUG_BUFFER  DebugBuffer);

extern "C" __declspec(dllimport) PDEBUG_BUFFER __stdcall RtlCreateQueryDebugBuffer(
	IN ULONG  Size,
	IN BOOLEAN  EventPair);

extern "C" __declspec(dllimport) NTSTATUS __stdcall RtlDestroyQueryDebugBuffer(
IN PDEBUG_BUFFER  DebugBuffer);

extern "C" __declspec(dllimport) NTSTATUS __stdcall RtlQueryProcessHeapInformation(
	IN PDEBUG_BUFFER  DebugBuffer
);

#ifdef __cplusplus
}
#endif
```

`Csrc/fcall_examples/fcall_examples/defs2.h`:

```h
#include "windows.h"
#include <tlhelp32.h>

typedef LONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define MAX_UNICODE_PATH 255

/*
typedef struct _SYSTEMTIME {
  WORD wYear;
  WORD wMonth;
  WORD wDayOfWeek;
  WORD wDay;
  WORD wHour;
  WORD wMinute;
  WORD wSecond;
  WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME;

typedef struct _FILETIME {
  DWORD dwLowDateTime;
  DWORD dwHighDateTime;
} FILETIME, *PFILETIME;*/


typedef struct _LSA_UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE           Reserved1[16];
  PVOID          Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  BYTE                          Reserved4[104];
  PVOID                         Reserved5[52];
  ULONG                         PostProcessInitRoutine;
  BYTE                          Reserved6[128];
  PVOID                         Reserved7[1];
  ULONG                         SessionId;
} PEB, *PPEB;

/*
typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PPEB PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;
*/


typedef struct _PROCESS_BASIC_INFORMATION {
    int ExitStatus;
	int PebBaseAddress;
	int AffinityMask;
	int BasePriority;
	int UniqueProcessId;
	int InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;

/*
typedef struct PROCESSINFOCLASS
{
    DWORD   dwPID;
    DWORD   dwParentPID;
    DWORD   dwSessionID;
    DWORD   dwPEBBaseAddress;
    DWORD   dwAffinityMask;
    LONG    dwBasePriority;
    LONG    dwExitStatus;
    BYTE    cBeingDebugged;
    TCHAR   szImgPath[MAX_UNICODE_PATH];
    TCHAR   szCmdLine[MAX_UNICODE_PATH];
} PROCESSINFOCLASS;
*/

// http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Process/PROCESS_INFORMATION_CLASS.html
// http://blogs.norman.com/wp-content/uploads/2011/10/processinfo.png
typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
	ProcessDeviceMap,
	ProcessSessionInformation,
	ProcessForegroundInformation,
	ProcessWow64Information,
	ProcessImageFileName,
	ProcessLUIDDeviceMapsEnabled,
	ProcessBreakOnTermination,
	ProcessDebugObjectHandle,
	ProcessDebugFlags,
	ProcessHandleTracing,
	ProcessIoPriority,
	ProcessExecuteFlags,
	ProcessTlsInformation,
	ProcessCookie,
	ProcessImageInformation,
	ProcessCycleTime,
	ProcessPagePriority,
	ProcessInstrumentationCallback,
	ProcessThreadStackAllocation,
	ProcessWorkingSetWatchEx,
	ProcessImageFileNameWin32,
	ProcessImageFileMapping,
	ProcessAffinityUpdateMode,
	ProcessMemoryAllocationMode,
	ProcessGroupInformation,
	ProcessTokenVirtualizationEnabled,
	ProcessConsoleHostProcess,
	ProcessWindowInformation,
    MaxProcessInfoClass,
} PROCESS_INFORMATION_CLASS, *PPROCESS_INFORMATION_CLASS;

// http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/System%20Information/SYSTEM_INFORMATION_CLASS.html
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemNextEventIdInformation,
    SystemEventIdsInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemPlugPlayBusInformation,
    SystemDockInformation,
	SystemPowerInformation2, // conflitou com winnt.h
    SystemProcessorSpeedInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

/*
typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    BYTE Reserved1[52];
    PVOID Reserved2[3];
    HANDLE UniqueProcessId;
    PVOID Reserved3;
    ULONG HandleCount;
    BYTE Reserved4[4];
    PVOID Reserved5[11];
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved6[6];
} SYSTEM_PROCESS_INFORMATION;
*/

typedef LONG KPRIORITY;

typedef struct _VM_COUNTERS {
#ifdef _WIN64
// the following was inferred by painful reverse engineering
	SIZE_T		   PeakVirtualSize;	// not actually
    SIZE_T         PageFaultCount;
    SIZE_T         PeakWorkingSetSize;
    SIZE_T         WorkingSetSize;
    SIZE_T         QuotaPeakPagedPoolUsage;
    SIZE_T         QuotaPagedPoolUsage;
    SIZE_T         QuotaPeakNonPagedPoolUsage;
    SIZE_T         QuotaNonPagedPoolUsage;
    SIZE_T         PagefileUsage;
    SIZE_T         PeakPagefileUsage;
    SIZE_T         VirtualSize;		// not actually
#else
    SIZE_T         PeakVirtualSize;
    SIZE_T         VirtualSize;
    ULONG          PageFaultCount;
    SIZE_T         PeakWorkingSetSize;
    SIZE_T         WorkingSetSize;
    SIZE_T         QuotaPeakPagedPoolUsage;
    SIZE_T         QuotaPagedPoolUsage;
    SIZE_T         QuotaPeakNonPagedPoolUsage;
    SIZE_T         QuotaNonPagedPoolUsage;
    SIZE_T         PagefileUsage;
    SIZE_T         PeakPagefileUsage;
#endif
} VM_COUNTERS;

typedef struct _CLIENT_ID
{
     PVOID UniqueProcess;
     PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _SYSTEM_THREADS {
    LARGE_INTEGER  KernelTime;
    LARGE_INTEGER  UserTime;
    LARGE_INTEGER  CreateTime;
    ULONG          WaitTime;
    PVOID          StartAddress;
    CLIENT_ID      ClientId;
    KPRIORITY      Priority;
    KPRIORITY      BasePriority;
    ULONG          ContextSwitchCount;
    LONG           State;
    LONG           WaitReason;
} SYSTEM_THREADS, * PSYSTEM_THREADS;


typedef struct _SYSTEM_PROCESS_INFORMATION {

  ULONG                   NextEntryOffset;
  ULONG                   NumberOfThreads;
  LARGE_INTEGER           Reserved[3];
  LARGE_INTEGER           CreateTime;
  LARGE_INTEGER           UserTime;
  LARGE_INTEGER           KernelTime;
  UNICODE_STRING          ImageName;
  KPRIORITY               BasePriority;
  HANDLE                  ProcessId;
  HANDLE                  InheritedFromProcessId;
  ULONG                   HandleCount;
  ULONG                   Reserved2[2];
  ULONG                   PrivatePageCount;
  VM_COUNTERS             VirtualMemoryCounters;
  IO_COUNTERS             IoCounters;
  SYSTEM_THREADS          Threads[0];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _THREAD_INFORMATION_CLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger
} THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;

#ifdef __cplusplus
extern "C" {  
#endif

extern "C" __declspec(dllimport) NTSTATUS __stdcall	NtSetInformationThread(
  IN HANDLE               ThreadHandle,
  IN THREAD_INFORMATION_CLASS ThreadInformationClass,
  IN PVOID                ThreadInformation,
  IN ULONG                ThreadInformationLength
 );

extern "C" __declspec(dllimport) NTSTATUS __stdcall NtQueryInformationProcess(
  IN       HANDLE ProcessHandle,
  IN       PROCESS_INFORMATION_CLASS ProcessInformationClass,
  OUT      PVOID ProcessInformation,
  IN       ULONG ProcessInformationLength,
  IN  PULONG ReturnLength
);

extern "C" __declspec(dllimport) NTSTATUS __stdcall NtQuerySystemInformation(
  __in       SYSTEM_INFORMATION_CLASS SystemInformationClass,
  __inout    PVOID SystemInformation,
  __in       ULONG SystemInformationLength,
  __out_opt  PULONG ReturnLength
);

#ifdef __cplusplus
}
#endif
```

`Csrc/fcall_examples/fcall_examples/fcall_examples.cpp`:

```cpp
/* Qualys Vulnerabliity & Malware Research Labs (VMRL)
Blackhat 2012 Presentation Samples
TiTle: 	A Scientific (but non academic) study of how malware employs anti-debugging,
		anti-disassembly and anti-virtualization technologies
Authors: Rodrigo Rubira Branco <rbranco *NOSPAM* qualys.com>
		 Gabriel Negreira Barbosa <gbarbosa *NOSPAM* qualys.com>
		 Pedro Drimel Neto <pdrimel *NOSPAM* qualys.com>

This is the VS 2010 project implemented to test anti-debugging techniques which were
not implemented in ASM, those are just proof-of-concept (POC) and are not intended to
be fully functional.

The functions are basically divided in three groups:
	Functions (f) which is the call to the function by itself, only calling the function can be a technique.
	Parameters (p) which depends to check the function parameter in order to identify the technique.
	Sequence (s) which is the sequence of functions calls like calling a function two or more times.

*/

#include "windows.h"
#include "conio.h"
#include <tchar.h>
#include <tlhelp32.h>
#include <time.h>
#include <WinUser.h>
#include <stdio.h>
#include <stdlib.h>
#include <Psapi.h>

#include "defs.h"
#include "ntDefs.h"
#include "defs2.h"

// RtlQueryProcessDebugInformation
#define WIN32_LEAN_AND_MEAN

#pragma comment(lib,"ntdll.lib")
#pragma comment(lib,"psapi.lib")
#pragma comment(lib,"user32.lib")

//CsrGetProcessId
typedef DWORD_PTR ( NTAPI *CGPID )( );
typedef DWORD_PTR ( NTAPI *DBGBREAKPOINT ) ();

PSYSTEM_PROCESS_INFORMATION getProcessInfo() {
	ULONG ulSize;
	LONG status;
	LPBYTE pBuffer;
	ULONG bufferSize = 0;

	do {
		bufferSize += 0x10000;
		pBuffer = (LPBYTE)malloc(bufferSize);

	status = NtQuerySystemInformation(SystemProcessInformation, pBuffer, bufferSize, &ulSize);
	if (status == 0xC0000004 /*STATUS_INFO_LENGTH_MISMATCH*/) {
		free(pBuffer);
		}
	} while (status == 0xC0000004 /*STATUS_INFO_LENGTH_MISMATCH*/);

	if (status == 0x00) {
		return (PSYSTEM_PROCESS_INFORMATION)pBuffer;
	}

	return NULL;
}

// 3.2
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void fIsDebuggerPresent() {
	if (IsDebuggerPresent())
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.3
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void fCheckRemoteDebuggerPresent() {

	BOOL isdbg = FALSE;
		
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &isdbg);
	if (isdbg)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.5
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pProcessDebugPort() {
	HANDLE proc;
	NTSTATUS ntStatus;
	DWORD debugport = NULL;

	proc = GetCurrentProcess();
	ntStatus = NtQueryInformationProcess(proc,ProcessDebugPort,&debugport,sizeof(debugport),NULL);
	if (ntStatus != 0)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.6
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pDebugObjectHandle() {

	HANDLE proc;
	NTSTATUS ntStatus;
	HANDLE hDebugHandle = NULL;
	
	proc = GetCurrentProcess();
	ntStatus = NtQueryInformationProcess(proc,ProcessDebugObjectHandle,&hDebugHandle,sizeof(hDebugHandle),NULL);

	if (hDebugHandle)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.7
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pProcessDebugFlags() {
	
	HANDLE proc;
	NTSTATUS ntStatus;
	HANDLE hDebugFlags = NULL;

	proc = GetCurrentProcess();
	ntStatus = NtQueryInformationProcess(proc,ProcessDebugFlags,&hDebugFlags,sizeof(hDebugFlags),NULL);
	if (hDebugFlags == FALSE)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.8
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pSystemKernelDebuggerInformation() {
	HANDLE proc;
	NTSTATUS ntStatus;
	DWORD hKdbg = NULL;
	PULONG hKdbgRetLenght = NULL;
	
	proc = GetCurrentProcess();
	ntStatus = NtQuerySystemInformation(SystemKernelDebuggerInformation,&hKdbg,sizeof(hKdbg),hKdbgRetLenght);

	if (hKdbg)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");

}

// 3.9
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sCsrGetProcessId_OpenProcess() {
	DWORD pid = NULL;
	CGPID CsrGetProcessId = ( CGPID ) GetProcAddress( GetModuleHandle( _T("ntdll.dll") ), "CsrGetProcessId" );
	if (OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, CsrGetProcessId()) != NULL)
		printf("SeDebugPrivilige acquired\n");
	else
		printf("Unable to grab SeDebugPrivilege\n");
}

// 3.10
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sCreateDesktop_SwitchDesktop() {
	HDESK myDesktop = NULL;
	BOOL res = FALSE;

	myDesktop = CreateDesktop(_T("mydesktop"), NULL, NULL, 0, DESKTOP_CREATEWINDOW | DESKTOP_WRITEOBJECTS | DESKTOP_SWITCHDESKTOP, NULL);
	if (myDesktop != NULL)
		res = SwitchDesktop(myDesktop);
			if (res)
				printf("SwitchDesktop works\n");
}

// 3.11
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sCreateProcess_ContinueDebugEvent() {
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	si.dwFlags = 0x1;
	si.wShowWindow = 0x0;
	ZeroMemory( &pi, sizeof(pi) );

	if (CreateProcess( L"C:\\windows\\system32\\calc.exe",
						NULL,
						NULL,
						NULL,
						FALSE,
						DEBUG_PROCESS,
						NULL,
						NULL,
						&si,
						&pi )){
		printf("PID = %d\n", pi.dwProcessId);
		ContinueDebugEvent(pi.dwProcessId, pi.dwThreadId, DBG_CONTINUE);
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);	
	} else
		printf("CreateProcess failed (%d).\n", GetLastError());
}

// 3.12
// references:
// "The Ultimate Anti-Debugging Reference" by Peter Ferrie
// "Anti-Unpacker Tricks - Part Eight" by Peter Ferrie
// Evilcodecave's Weblog - RtlQueryProcessHeapInformation As Anti-Dbg Trick:
//	http://evilcodecave.wordpress.com/2009/04/
void fRtlQueryProcessDebugInformation() {
	PDEBUG_BUFFER buffer;
	NTSTATUS ntStatus;
	ULONG pdi_heaps = 0x04;
	ULONG pdi_heap_blocks = 0x10;

	buffer = RtlCreateQueryDebugBuffer(0,FALSE);

	ntStatus = RtlQueryProcessDebugInformation(GetCurrentProcessId(),PDI_HEAPS|PDI_HEAP_BLOCKS,buffer);
	PDEBUG_HEAP_INFORMATION heapInfo = PDEBUG_HEAP_INFORMATION(PULONG(buffer->HeapInformation) + 1);

	if (heapInfo->Flags == 0x50000062)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");

	RtlDestroyQueryDebugBuffer(buffer);
}

// 3.12
// references:
// "The Ultimate Anti-Debugging Reference" by Peter Ferrie
// "Anti-Unpacker Tricks - Part Eight" by Peter Ferrie
// Evilcodecave's Weblog - RtlQueryProcessHeapInformation As Anti-Dbg Trick:
//	http://evilcodecave.wordpress.com/2009/04/
void fRtlQueryProcessHeapInformation() {
	PDEBUG_BUFFER buffer;
	
	buffer = RtlCreateQueryDebugBuffer(0,FALSE);

	RtlQueryProcessHeapInformation(buffer);

	if (buffer->RemoteSectionBase == (PVOID) 0x50000062)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}


// 3.14
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sOutputDebugString_GetLastError () {
	OutputDebugStringA("Hi Debugger");
	if (GetLastError() == 0)
		printf("Debugger detected\n");
}

// 3.15
// references:
// "Anti-Unpacker Tricks" by Peter Ferrie
// "The Art of Unpacking" by Mark Vincent Yason
void fBlockInput() {
	BOOL lock = TRUE;
	BOOL release = FALSE;

	BlockInput(lock);
	Sleep(5);
	BlockInput(release);
}

// 3.16 (1)
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
int sGetCurrentProcessId_CreateToolhelp32Snapshot() {
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	TCHAR explorer[13] = TEXT("explorer.exe");
	DWORD myPid = NULL;
	DWORD explorerPid = NULL;
	DWORD myParentPid = NULL;

	myPid = GetCurrentProcessId();
	if (myPid == NULL) {
		printf("ERROR: Get CurrentProcessId()\n");
		return 1;
	}

	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE ) {
		printf("ERROR: call CreateToolhelp32Snapshot\n");
		CloseHandle( hProcessSnap );
		return 2;
	}

	pe32.dwSize = sizeof( PROCESSENTRY32 );

	if( !Process32First( hProcessSnap, &pe32 ) ) {
		printf("ERROR: call Process32First\n");
		CloseHandle (hProcessSnap);
		return 3;
	}

	do {
		if (_tcscmp(pe32.szExeFile, explorer) == 0) {// found explorer.exe
			explorerPid = pe32.th32ProcessID;
		}
		if ((pe32.th32ProcessID == myPid) && (explorerPid != NULL)) {
			myParentPid = pe32.th32ParentProcessID;
			break;
		}

	} while ( Process32Next(hProcessSnap, &pe32));

	if (myParentPid != NULL) {
		if (myParentPid == explorerPid)
			printf("Parent is explorer.exe\n");
		else
			printf("Parent is NOT explorer.exe\n");
	} else {
		printf("ERROR: Unable to grab parent Pid\n");
		CloseHandle( hProcessSnap );
		return 4;
	}
	
	CloseHandle( hProcessSnap );
	return 0;

}

// 3.16 (2)
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
int spGetProcessId_NtQuerySystemInformation() {
	DWORD explorerPid = NULL;
	DWORD myPid = NULL;
	const wchar_t explorer[13] = TEXT("explorer.exe");

	myPid = GetCurrentProcessId();
	if (myPid == NULL) {
		printf("ERROR: Grab current process id\n");
		return 2;
	}

	PSYSTEM_PROCESS_INFORMATION head = getProcessInfo();

	if (head != NULL) {
		while (head != NULL) {
			if (head->ImageName.Buffer != NULL) 
				if (wcscmp(head->ImageName.Buffer, explorer) == 0)
					explorerPid = (DWORD)head->ProcessId;

			if ((head->ProcessId == (HANDLE)myPid) && (explorerPid != NULL))
				break;
			if(head->NextEntryOffset == 0)
				head = NULL;
			else
				head = (PSYSTEM_PROCESS_INFORMATION)((LPBYTE)head + head->NextEntryOffset);
		}
	}

	if (head->ProcessId != NULL)
		if ((DWORD)head->ProcessId != myPid) {
			printf("ERROR: Unable to grab current process id\n");
			return 1;
		}

	if ((explorerPid != NULL) && (head->InheritedFromProcessId != NULL)) {
		if (explorerPid == (DWORD)head->InheritedFromProcessId)
			printf("Parent process is explorer.exe:\n\n");
		else
			printf("Parent process is NOT explorer.exe:\n\n");
		printf("Explorer pid = %d\n", explorerPid);
		printf("Current pid = %d\n", head->ProcessId);
		printf("Current parent = %d\n", head->InheritedFromProcessId);
		return 0;
	} else {
		printf("ERROR: Unable to grab explorer PID or parent process ID\n");
		return 3;
	}
}

// 3.16 (3)
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sGetShellWindow_GetWindowThreadProcessId_NtQuerySystemInformation() {
	HWND window = NULL;
	DWORD pid = NULL;
	PROCESS_BASIC_INFORMATION pBasicInfo;
	DWORD ReturnLength = NULL;
	NTSTATUS ntStatus = NULL;

	window = GetShellWindow();
	if (window != NULL)
		GetWindowThreadProcessId(window, &pid);
		if (pid != NULL) 
			printf("PID of explorer.exe = %d\n", pid);
			ntStatus = NtQueryInformationProcess(GetCurrentProcess(),ProcessBasicInformation,&pBasicInfo,sizeof(PROCESS_BASIC_INFORMATION),&ReturnLength);
			if (ntStatus >= 0)
				printf("Current Process Inherit PID: %d\n",pBasicInfo.InheritedFromUniqueProcessId);
				if (pid != pBasicInfo.InheritedFromUniqueProcessId)
					printf("Parent process is not explorer.exe\n");
				else
					printf("Parent process is explorer.exe\n");
}

// 3.17
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pCreateFile() {
	HANDLE hFile = NULL;

	hFile = CreateFile(_T("\\\\.\\NTICE"),0,0,0,OPEN_EXISTING,0,0);
	if (hFile != INVALID_HANDLE_VALUE)
		printf("Existing SoftICE Handle\n");
	else
		printf("SoftICE not found\n");
}

// 3.18
// references:
// "Anti-Unpacker Tricks" by Peter Ferrie
// "The Art Of Unpacking" by Mark Vincent Yason
void pOutputDebugString() {
	OutputDebugString(_T("%s%s%s%s%s%s%s%s%s")); // crashed OllyDBG 1.10
}

// 3.19
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void pFindWindow() {

	HANDLE hJanela = NULL;

	hJanela = FindWindow(_T("OLLYDBG"), NULL);
	if (hJanela != NULL)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");

}

// 3.20
// references:
// "Anti-Unpacker Tricks" by Peter Ferrie
// "The Ultimate Anti-Debugging Reference" by Peter Ferrie
int sSuspendThread() {
	HANDLE hThreadSnap;
	HANDLE hThread;
	THREADENTRY32 te32;
					
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	TCHAR explorer[13] = TEXT("explorer.exe");
	DWORD myPid = NULL;
	DWORD explorerPid = NULL;
	DWORD myParentPid = NULL;

	myPid = GetCurrentProcessId();
	if (myPid == NULL) {
		printf("ERROR: Get CurrentProcessId()\n");
		return 1;
	}

	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE ) {
		printf("ERROR: call CreateToolhelp32Snapshot\n");
		CloseHandle( hProcessSnap );
		return 2;
	}

	pe32.dwSize = sizeof( PROCESSENTRY32 );

	if( !Process32First( hProcessSnap, &pe32 ) ) {
		printf("ERROR: call Process32First\n");
		CloseHandle (hProcessSnap);
		return 3;
	}

	do {
		if (_tcscmp(pe32.szExeFile, explorer) == 0) {// found explorer.exe
			explorerPid = pe32.th32ProcessID;
		}
		if ((pe32.th32ProcessID == myPid) && (explorerPid != NULL)) {
			myParentPid = pe32.th32ParentProcessID;
			break;
		}

	} while ( Process32Next(hProcessSnap, &pe32));

	if (myParentPid != NULL) {
		if (myParentPid == explorerPid)
			printf("Parent is explorer.exe\n");
		else {
			printf("Parent is NOT explorer.exe\n");
			hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
			if( hThreadSnap == INVALID_HANDLE_VALUE ) {
				printf("ERROR: call CreateToolhelp32Snapshot\n");
				CloseHandle( hProcessSnap );
				return 5;
			}

			te32.dwSize = sizeof(te32);

			if (Thread32First(hThreadSnap, &te32)) {
				do {
					if (te32.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te32.th32OwnerProcessID)) {
						if (te32.th32OwnerProcessID == myParentPid) {
							printf("Crashing main Thread of parent process\n");
							Sleep(2);
							hThread = OpenThread(THREAD_SUSPEND_RESUME,0,te32.th32ThreadID);
							if ((SuspendThread(hThread)) != -1)
								printf("Explorer.exe main thread Suspended\n");
						}
					}
					te32.dwSize = sizeof(te32);
				} while (Thread32Next(hThreadSnap, &te32));
			}
			CloseHandle(hThreadSnap);
		}
	} else {
		printf("ERROR: Unable to grab parentPid\n");
		CloseHandle( hProcessSnap );
		return 4;
	}
	
	CloseHandle( hProcessSnap );
	return 0;

}

// 3.23
// references:
// "Anti-Unpacker Tricks" by Peter Ferrie
// "The Art Of Unpacking" by Mark Vincent Yason
// "Windows Anti-Debug Reference" by Nicolas Falliere:
// http://www.symantec.com/connect/articles/windows-anti-debug-reference    
void fSetUnhandledExceptionFilter() {

	SetUnhandledExceptionFilter(NULL);
	_asm int 3;
	printf("Debugger detected\n");
}

// 3.24
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
int psVirtuaAlloc_VirtualProtect() {
	LPVOID lpvAddr;
	DWORD dwPageSize;
	DWORD dwOldProtect;
	BOOL vprotect;
	SYSTEM_INFO sSysInfo;

	GetSystemInfo(&sSysInfo);
	dwPageSize = sSysInfo.dwPageSize;

	lpvAddr = VirtualAlloc(NULL, dwPageSize, MEM_COMMIT , PAGE_EXECUTE_READWRITE);
	if (lpvAddr == NULL) {
		_tprintf(TEXT("Virtual alloc failed. Error %1d\n"), GetLastError());
		return 1;
	}

	vprotect = VirtualProtect(lpvAddr, dwPageSize, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &dwOldProtect);
	if (!vprotect) {
		_ftprintf(stderr, TEXT("Cannot protect to PAGE_GUARD at %lp, error=0x%1x\n"), lpvAddr, GetLastError());
		return 1;
	} else {
		_ftprintf(stderr, TEXT("PAGE_GUARD Achieved at %lp\n"), lpvAddr);
		return 0;
	}
}

// 3.25 GetTickCount
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
void sGetTickCount() {
	DWORD initial = NULL;
	DWORD end = NULL;

	initial = GetTickCount();
	end = GetTickCount();
	if ((initial - end) >= 10)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.25 timeGetTime
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
void stimeGetTime() {
	DWORD initial = NULL;
	DWORD end = NULL;

	initial = timeGetTime();
	end = timeGetTime();
	if ((initial - end) >= 10)
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.25 GetSystemTime
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
void sGetSystemTime() {
	
	SYSTEMTIME initial,end;
	FILETIME finitial, fend;
	GetSystemTime(&initial);
	GetSystemTime(&end);
	SystemTimeToFileTime(&initial, &finitial);
	SystemTimeToFileTime(&end, &fend);
	if (((finitial.dwHighDateTime - fend.dwHighDateTime) > 10) || ((finitial.dwLowDateTime - fend.dwLowDateTime) > 10))
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}

// 3.25 GetLocalTime
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
void sGetLocalTime() {
	
	SYSTEMTIME initial,end;
	FILETIME finitial, fend;
	GetLocalTime(&initial);
	GetLocalTime(&end);
	SystemTimeToFileTime(&initial, &finitial);
	SystemTimeToFileTime(&end, &fend);
	if (((finitial.dwHighDateTime - fend.dwHighDateTime) > 10) || ((finitial.dwLowDateTime - fend.dwLowDateTime) > 10))
		printf("Debugger detected\n");
	else
		printf("Debugger not detected\n");
}


// 3.25 QueryPerformanceCounter
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
// reference: http://www.shell-storm.org/papers/files/764.pdf
void sQueryPerformanceCounter() {
	LARGE_INTEGER initial;
	LARGE_INTEGER end;
	if (QueryPerformanceCounter(&initial))
		if (QueryPerformanceCounter(&end)) {
			printf("\ninitial.LowPart %02d \n" , initial.LowPart);
			printf("\nend.LowPart %02d \n" , end.LowPart);
			if ((initial.QuadPart - end.QuadPart) > 0x10)
				printf("Debugger detected\n");
			else
				printf("Debugger not detected\n");
		} else
			printf("ERROR QueryPerformanceCounter call\n");
	else
		printf("ERROR QueryPerformanceCounter call\n");
}

// 3.27
// references:
// "Anti-Unpacker Tricks" by Peter Ferrie
// "The Art Of Unpacking" by Mark Vincent Yason
// "Windows Anti-Debug Reference" by Nicolas Falliere:
// http://www.symantec.com/connect/articles/windows-anti-debug-reference    
void pThreadHideFromDebugger() {
	HANDLE hThread = NULL;
	NTSTATUS ntStatus;

	hThread = GetCurrentThread();

	ntStatus = NtSetInformationThread(hThread,ThreadHideFromDebugger,NULL,0);
}

// 3.28
// reference: "The Ultimate Anti-Debugging Reference" by Peter Ferrie
void fNtSetDebugFilterState() {
	NTSTATUS ntStatus;
	ntStatus = NtSetDebugFilterState(0,0,TRUE);

	if (ntStatus != STATUS_SUCCESS)
		printf("Debugger not detected\n");
	else
		printf("Debugger detected\n");
}

// 3.31
// reference: "Anti-Unpacker Tricks" by Peter Ferrie
void sCreateProcess_CreateMutex() {
	HANDLE hMutex = NULL;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	si.dwFlags = 0x1;
	si.wShowWindow = 0x0;
	ZeroMemory( &pi, sizeof(pi) );

	hMutex = CreateMutex(NULL, FALSE, TEXT("mymutex"));
	if (hMutex == NULL) 
		printf("ERROR Create Mutex\n");
	else
		if (GetLastError() != ERROR_ALREADY_EXISTS) {
			if ( !CreateProcess( L"C:\\windows\\system32\\calc.exe",
						NULL,
						NULL,
						NULL,
						FALSE,
						CREATE_NEW_CONSOLE,
						NULL,
						NULL,
						&si,
						&pi )) {
				printf("ERROR CreateProcess failed (%d).\n", GetLastError());
			} else {
				WaitForSingleObject(pi.hProcess, INFINITE);
				ExitProcess(0);
			}
	}
}

// 3.32
// reference: http://waleedassar.blogspot.com.br/2011/12/debuggers-anti-attaching-techniques.html
void fDbgBreakPoint() {
	DWORD dwOldProtect;
	unsigned char* DbgBreakPoint=(unsigned char*)GetProcAddress(GetModuleHandle(_T("ntdll.dll") ), "DbgBreakPoint");
	VirtualProtect(DbgBreakPoint, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	*DbgBreakPoint = 0x90;
}

int _tmain(int argc, _TCHAR* argv[])
{
	unsigned int opt = 0;
	unsigned int ret = 0;
	BOOL vpc = false;
	printf("Anti-Debugging POCs\n\n");
	printf("1  - 3.2 IsDebuggerPresent\n");
	printf("2  - 3.3 CheckRemoteDebuggerPresent \n");
	printf("3  - 3.5 NtQueryInformationProcess – ProcessDebugPort\n");
	printf("4  - 3.6 Debug Objects – ProcessDebugObjectHandle Class\n");
	printf("5  - 3.7 Debug Objects – ProcessDebugFlags Class\n");
	printf("6  - 3.8 NtQuerySystemInformation – SystemKernelDebuggerInformation\n");
	printf("7  - 3.9 OpenProcess – SeDebugPrivilege\n");
	printf("8  - 3.10 Alternative Desktop\n");
	printf("9  - 3.11 Self-Debugging\n");
	printf("10 - 3.12 RtlQueryProcessDebugInformation\n");
	printf("11 - 3.12 RtlQueryProcessHeapInformation\n");
	printf("12 - 3.14 OutputDebugString\n");
	printf("13 - 3.15 BlockInput\n");
	printf("14 - 3.16 Parent Process - GetCurrentProcessId() + CreateToolhelp32Snapshot()\n");
	printf("15 - 3.16 Parent Process - GetCurrentProcessId() + NtQuerySystemInformation(SystemProcessInformation)\n");
	printf("16 - 3.16 Parent Process - GetShellWindow()+ GetWindowThreadProcessId() + NtQueryInformationProcess(ProcessBasicInformation)\n");
	printf("17 - 3.17 Device Names\n");
	printf("18 - 3.18 OllyDbg – OutputDebugString\n");
	printf("19 - 3.19 FindWindow\n");
	printf("20 - 3.20 SuspendThread\n");
	printf("21 - 3.23 UnhandledExceptionFilter\n");
	printf("22 - 3.24 Guard Pages\n");
	printf("23 - 3.25 Execution Timing - GetTickCount()\n");
	printf("24 - 3.25 Execution Timing - timeGetTime\n");
	printf("25 - 3.25 Execution Timing - GetSystemTime()\n");
	printf("26 - 3.25 Execution Timing - GetLocalTime()\n");
	printf("27 - 3.25 Execution Timing - QueryPerformanceCounter()\n");
	printf("28 - 3.27 Thread Hiding\n");
	printf("29 - 3.28 NtSetDebugFilterState\n");
	printf("30 - 3.31 Self-Execution\n");
	printf("31 - 3.32 DbgBreakpoint Overwrite\n\n");
	scanf_s("%d", &opt);
	switch (opt) {
	case 1:
		fIsDebuggerPresent();
		break;
	case 2:
		fCheckRemoteDebuggerPresent();
		break;
	case 3:
		pProcessDebugPort();
		break;
	case 4:
		pDebugObjectHandle();
		break;
	case 5:
		pProcessDebugFlags();
		break;
	case 6:
		pSystemKernelDebuggerInformation();
		break;
	case 7:
		sCsrGetProcessId_OpenProcess();
		break;
	case 8:
		sCreateDesktop_SwitchDesktop();
		break;
	case 9:
		sCreateProcess_ContinueDebugEvent();
		break;
	case 10:
		fRtlQueryProcessDebugInformation();
		break;
	case 11:
		fRtlQueryProcessHeapInformation();
		break;
	case 12:
		sOutputDebugString_GetLastError();
		break;
	case 13:
		fBlockInput();
		break;
	case 14:
		ret = sGetCurrentProcessId_CreateToolhelp32Snapshot();
		break;
	case 15:
		spGetProcessId_NtQuerySystemInformation();
		break;
	case 16:
		sGetShellWindow_GetWindowThreadProcessId_NtQuerySystemInformation();
		break;
	case 17:
		pCreateFile();
		break;
	case 18:
		pOutputDebugString();
		break;
	case 19:
		pFindWindow();
		break;
	case 20:
		ret = sSuspendThread();
		break;
	case 21:
		fSetUnhandledExceptionFilter();
		break;
	case 22:
		ret = psVirtuaAlloc_VirtualProtect();
		break;
	case 23:
		sGetTickCount();
		break;
	case 24:
		stimeGetTime();
		break;
	case 25:
		sGetSystemTime();
		break;
	case 26:
		sGetLocalTime();
		break;
	case 27:
		sQueryPerformanceCounter();
		break;
	case 28:
		pThreadHideFromDebugger();
		break;
	case 29:
		fNtSetDebugFilterState();
		break;
	case 30:
		sCreateProcess_CreateMutex();
		break;
	case 31:
		fDbgBreakPoint();
		break;
	default:
		printf("Invalid option\n");
		break;
	}
	_getch();
	return 0;
}
```

`Csrc/fcall_examples/fcall_examples/fcall_examples.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{AFCCCF22-D519-40EE-8F43-E16A245F8E1B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fcall_examples</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;winmm.lib;uuid.lib;odbc32.lib;winmm.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;winmm.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h" />
    <ClInclude Include="defs2.h" />
    <ClInclude Include="ntDefs.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="fcall_examples.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Csrc/fcall_examples/fcall_examples/fcall_examples.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntDefs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="defs2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="fcall_examples.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Csrc/fcall_examples/fcall_examples/fcall_examples.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Csrc/fcall_examples/fcall_examples/ntDefs.h`:

```h
#include "windows.h"
typedef LONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#ifdef __cplusplus
extern "C" {  
#endif 
extern "C"
__declspec(dllimport) 
ULONG __stdcall 
NtSetDebugFilterState(
					 ULONG ComponentId,
					 ULONG Level,
					 BOOLEAN State					 
					 );
#ifdef __cplusplus
}
#endif
```

`README.md`:

```md
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>README</title>
</head>
<body>
<pre>
Qualys Vulnerabliity & Malware Research Labs (VMRL)

Blackhat 2012 Presentation Samples

TiTle: 	A Scientific (but non academic) study of how malware employs anti-debugging,
		anti-disassembly and anti-virtualization technologies

Authors: Rodrigo Rubira Branco  - rbranco *NOSPAM* qualys.com
		 Gabriel Negreira Barbosa - gbarbosa *NOSPAM* qualys.com
		 Pedro Drimel Neto - pdrimel *NOSPAM* qualys.com

The samples are divided in four categories:
	Anti-Debugging
	Anti-Disassembly
	Obfuscation
	Anti-VM

Anti-Debugging POCs were developed in C/C++ using Visual Studio 2010 and Assembly
with Flat Assembler, they are in the folder Csrc and ASMsrc, respectively.

Anti-Disassembly and Obfuscation POCs were developed in Assembly with Flat Assembler and
are available in the folder ASMsrc.

Anti-VM POCs were developed in C/C++ using Visual Studio 2010 and is available in the
Csrc folder.


</pre>
</body>
</html>
```