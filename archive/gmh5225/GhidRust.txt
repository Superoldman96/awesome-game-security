Project Path: arc_gmh5225_GhidRust_6d_yhvhl

Source Tree:

```txt
arc_gmh5225_GhidRust_6d_yhvhl
├── LICENSE
├── Module.manifest
├── README.md
├── build.gradle
├── build.sh
├── data
│   └── libstd-4c74cbab78ec4891.fidb
├── extension.properties
├── media
│   ├── analyzer_entry.png
│   ├── extension_entry.png
│   ├── ghidrust.png
│   ├── not_rust_bin.png
│   ├── report.pdf
│   ├── return_0.png
│   ├── rust_bin.png
│   ├── with_fid.png
│   └── without_fid.png
└── src
    └── main
        ├── help
        │   └── help
        │       ├── TOC_Source.xml
        │       ├── shared
        │       │   └── Frontpage.css
        │       └── topics
        │           └── GhidRust
        │               └── help.html
        ├── java
        │   └── ghidrust
        │       ├── analyzer
        │       │   └── RustStdAnalyzer.java
        │       └── decompiler
        │           ├── RustDecPlugin.java
        │           ├── RustDecProvider.java
        │           └── parser
        │               ├── Run.java
        │               ├── c
        │               │   ├── CVisitor.java
        │               │   └── gen
        │               │       ├── ASTANDExpression.java
        │               │       ├── ASTAbstractDeclarator.java
        │               │       ├── ASTAdditiveExpression.java
        │               │       ├── ASTArgumentExpressionList.java
        │               │       ├── ASTAssignmentExpression.java
        │               │       ├── ASTCastExpression.java
        │               │       ├── ASTCompoundStatement.java
        │               │       ├── ASTConditionalExpression.java
        │               │       ├── ASTConstantExpression.java
        │               │       ├── ASTDeclaration.java
        │               │       ├── ASTDeclarationList.java
        │               │       ├── ASTDeclarationSpecifiers.java
        │               │       ├── ASTDeclarator.java
        │               │       ├── ASTDirectAbstractDeclarator.java
        │               │       ├── ASTDirectDeclarator.java
        │               │       ├── ASTEqualityExpression.java
        │               │       ├── ASTExclusiveORExpression.java
        │               │       ├── ASTExpression.java
        │               │       ├── ASTExpressionStatement.java
        │               │       ├── ASTFunctionDefinition.java
        │               │       ├── ASTGhostStringToken.java
        │               │       ├── ASTIdentifierList.java
        │               │       ├── ASTInclusiveORExpression.java
        │               │       ├── ASTInitDeclarator.java
        │               │       ├── ASTInitDeclaratorList.java
        │               │       ├── ASTInitializer.java
        │               │       ├── ASTInitializerList.java
        │               │       ├── ASTIterationStatement.java
        │               │       ├── ASTJumpStatement.java
        │               │       ├── ASTLabeledStatement.java
        │               │       ├── ASTLogicalANDExpression.java
        │               │       ├── ASTLogicalORExpression.java
        │               │       ├── ASTMultiplicativeExpression.java
        │               │       ├── ASTParameterDeclaration.java
        │               │       ├── ASTParameterList.java
        │               │       ├── ASTParameterTypeList.java
        │               │       ├── ASTPointer.java
        │               │       ├── ASTPostfixExpression.java
        │               │       ├── ASTPrimaryExpression.java
        │               │       ├── ASTRelationalExpression.java
        │               │       ├── ASTSelectionStatement.java
        │               │       ├── ASTShiftExpression.java
        │               │       ├── ASTSpecifierQualifierList.java
        │               │       ├── ASTStatement.java
        │               │       ├── ASTStatementList.java
        │               │       ├── ASTStringToken.java
        │               │       ├── ASTTypeName.java
        │               │       ├── ASTTypeQualifierList.java
        │               │       ├── ASTTypeStringToken.java
        │               │       ├── ASTUnaryExpression.java
        │               │       ├── ASTUnaryOperator.java
        │               │       ├── CParser.java
        │               │       ├── CParserConstants.java
        │               │       ├── CParserDefaultVisitor.java
        │               │       ├── CParserTokenManager.java
        │               │       ├── CParserTreeConstants.java
        │               │       ├── CParserVisitor.java
        │               │       ├── JJTCParserState.java
        │               │       ├── Node.java
        │               │       ├── ParseException.java
        │               │       ├── SimpleCharStream.java
        │               │       ├── SimpleNode.java
        │               │       ├── Token.java
        │               │       ├── TokenMgrError.java
        │               │       ├── c.jj
        │               │       └── c.jjt
        │               └── generate.sh
        └── resources
            └── images
                ├── icon.png
                └── reload.png

```

`LICENSE`:

```
Copyright 2023 Dhruv Maroo

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img width="180" src="./media/ghidrust.png" alt="GhidRust">
  <h1 align="center">GhidRust</h1>
  <p align="center">GhidRust: Rust binary analysis extension for Ghidra</p>
</p>

**Status:** Currently, the plugin is under extensive development. It is far from maturity. But a working prototype can be expected within a few weeks.

![](./media/extension_entry.png)

This project was a part of one of my institute courses. For a detailed overview, please have a look at the [report](./media/report.pdf) created for the course submission. The following README is fairly sparse.

## Features

### Rust binary detection

The plugin can detect Rust binaries. To use the feature, click on `GhidRust -> Check if Rust binary`. It will show a popup indicating whether it's a Rust binary or not.

May not be a Rust binary   |  May be a Rust binary
:-------------------------:|:-------------------------:
![](./media/not_rust_bin.png)   |  ![](./media/rust_bin.png)

### Function ID

The plugin also consists of `RustStdAnalyzer` which analyzes Rust binaries and applies function signatures to the library functions (Rust's `std`) found in the binary. This is done using `.fidb` function ID database. A default database for x86-64 and Rust version 1.58.1 has been provided at [`libstd.fidb`](./data/libstd-4c74cbab78ec4891.fidb). This is useful when analyzing stripped Rust binaries.

Without Function ID        |  With Function ID
:-------------------------:|:-------------------------:
![](./media/without_fid.png)   |  ![](./media/with_fid.png)

The analyzer is enabled by default for Rust binaries, and it's name in analyzer window is _"Detect Rust libstd functions"_.

![](./media/analyzer_entry.png)

### Decompilation

This is a work-in-progress feature as of now. It requires parsing the decompiled C code and then emitting the corresponding Rust code. Once that is done, Rust macro support will also be added in the future.

The decompiler panel can be accessed by clicking `GhidRust -> Open decompiler`. It looks as follows.

![](./media/return_0.png)

## Building

There is a build script provided (`build.sh`) which can build and install the extension.

```
$ ./build.sh -h
GhidRust install script
Usage: build.sh [-i | --install] -g GHIDRA_PATH

        -i | --install           Install the extension
        -g | --ghidra            Path to Ghidra installation (usually /opt/ghidra)
        -h | --help              Show usage/help
```

You can build the extension using the following command.

```
$ ./build.sh -g <GHIDRA_INSTALL_DIR>
```

You can install it using the install flag as follows.

```
./build.sh -ig <GHIDRA_INSTALL_DIR>
```

## Adding it to Ghidra

To add it to Ghidra, just click on `File -> Install Extensions...` and choose GhidRust there. Once installed, you will have a `GhidRust` entry in the Ghidra toolbar which can be used to invoke the plugin.

You might need to activate it from the `File -> Configure...` menu. Choose the `Miscellaneous` section, and click the checkbox beside _RustDecPlugin_.

```

`build.gradle`:

```gradle
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

```

`build.sh`:

```sh
#!/bin/bash

success() {
    echo -e "\033[32;1m[+]\033[0m" "$1"
}

status() {
    echo -e "\033[33;1m[-]\033[0m" "$1"
}

failure() {
    echo -e "\033[31;1m[!]\033[0m" "$1"
}

usage() {
    echo -e "Usage: $(basename $0) [-i | --install] -g GHIDRA_PATH"
    echo -e ""
    echo -e "\t-i | --install\t\t Install the extension"
    echo -e "\t-g | --ghidra\t\t Path to Ghidra installation (usually /opt/ghidra)"
    echo -e "\t-h | --help\t\t Show usage/help"
}

VALID_ARGS=$(getopt -o ig:h --long install,ghidra:,help -- "$@")

if [[ $? -ne 0 ]]; then
    failure "Invalid arguments provided"
    exit 1;
fi

eval set -- "$VALID_ARGS"

INSTALL=0
GHIDRA=""

while [ : ]; do
    case "$1" in
        -i | --install)
            INSTALL=1
            shift
        ;;
        -g | --ghidra)
            GHIDRA="$2"
            shift 2
        ;;
        -h | --help)
            echo -e "GhidRust install script"
            usage
            exit 0
        ;;
        ?)
            failure "Invalid arguments provided"
            echo -e ""
            usage
            exit 1
        ;;
        --) shift;
            break
        ;;
    esac
done

if [ -z "$GHIDRA" ]
then
    failure "Required arguments not provided"
    echo -e ""
    usage
    exit 1
fi

rm dist/* 2> /dev/null

status "Building GhidRust"

gradle -PGHIDRA_INSTALL_DIR="$GHIDRA"

if [[ $? -ne 0 ]]; then
    failure "Build command failed"
    exit 1;
fi

success "Build successful"

if [ "$INSTALL" -eq "0" ]
then
    exit 0
fi

status "Installing GhidRust"

sudo rm -f "$GHIDRA"/Extensions/Ghidra/*GhidRust* 2> /dev/null
sudo cp dist/* "$GHIDRA"/Extensions/Ghidra

if [[ $? -ne 0 ]]; then
    failure "Installation failed"
    exit 1;
fi

success "Installation successful"

status "Next steps"

echo -e "\t 1. Open Ghidra"
echo -e "\t 2. Go to File -> Install Extensions"
echo -e "\t 3. Tick the checkbox beside GhidRust"
echo -e "\t 4. Restart Ghidra"

```

`extension.properties`:

```properties
name=@extname@
description=Helps in analyzing and decompiling Rust binaries.
author=DMaroo
createdOn=4/11/2023
version=@extversion@

```

`src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->

<tocroot>
    <tocref id="Ghidra Functionality">
		<tocdef id="GhidRust" text="GhidRust" target="help/topics/GhidRust/help.html" />
	</tocref>
</tocroot>         

```

`src/main/help/help/shared/Frontpage.css`:

```css
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
									WARNING!
    This file is copied to all help directories.  If you change this file, you must copy it 
    to each src/main/help/help/shared directory.									
									
	
	Java Help Note:  JavaHelp does not accept sizes (like in 'margin-top') in anything but 
	px (pixel) or with no type marking. 

*/ 

body { margin-bottom: 50px; margin-left: 10px; margin-right: 10px; margin-top: 10px; } /* some padding to improve readability */ 
li { font-family:times new roman; font-size:14pt; }
h1 { color:#000080; font-family:times new roman; font-size:36pt; font-style:italic; font-weight:bold; text-align:center; }
h2 { margin: 10px; margin-top: 20px; color:#984c4c; font-family:times new roman; font-size:18pt; font-weight:bold; }
h3 { margin-left: 10px; margin-top: 20px; color:#0000ff; font-family:times new roman; font-size:14pt; font-weight:bold;  }
h4 { margin-left: 10px; margin-top: 20px; font-family:times new roman; font-size:14pt; font-style:italic; }
 
/*
	 P tag code.  Most of the help files nest P tags inside of blockquote tags (the was the 
	 way it had been done in the beginning).  The net effect is that the text is indented.  In 
	 modern HTML we would use CSS to do this.  We need to support the Ghidra P tags, nested in
	 blockquote tags, as well as naked P tags.  The following two lines accomplish this.  Note
	 that the 'blockquote p' definition will inherit from the first 'p' definition.
*/
p { margin-left: 40px; font-family:times new roman; font-size:14pt; }
blockquote p { margin-left: 10px; }

p.providedbyplugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px  }
p.ProvidedByPlugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px }
p.relatedtopic { color:#800080; margin-left: 10px; font-size:14pt; }
p.RelatedTopic { color:#800080; margin-left: 10px; font-size:14pt; }

/* 
	We wish for a tables to have space between it and the preceding element, so that text
	is not too close to the top of the table.  Also, nest the table a bit so that it is clear
	the table relates to the preceding text.
*/
table { margin-left: 20px; margin-top: 10px; width: 80%;}
td { font-family:times new roman; font-size:14pt; vertical-align: top; }
th { font-family:times new roman; font-size:14pt; font-weight:bold; background-color: #EDF3FE; }

code { color: black; font-family: courier new; font-size: 14pt; }

```

`src/main/help/help/topics/GhidRust/help.html`:

```html
<!DOCTYPE HTML>

<html>

<head>
    <meta http-equiv="Content-Language" content="en-us">
    <meta http-equiv="Content-Type" content="text/html">

    <title>GhidRust</title>
    <link rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
</head>

<body>
    <h1><a name="GhidRust_head"></a>GhidRust: Rust binary analysis extension</h1>

    <p>// TODO documentation</p>
</body>

</html>

```

`src/main/java/ghidrust/analyzer/RustStdAnalyzer.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidrust.analyzer;

import generic.jar.ResourceFile;
import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalysisPriority;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;
import ghidra.feature.fid.db.FidFileManager;
import ghidra.framework.Application;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;

public class RustStdAnalyzer extends AbstractAnalyzer {
    private static final String filePath = "/home/dhruv/Education/CS4900/Work/GhidRust/tmp/logs";
    private static BufferedWriter writer;
    private static final byte[][] rust_artifacts = {
            "run with `RUST_BACKTRACE=1` environment variable".getBytes(),
            "called `Option::unwrap()` on a `None` value".getBytes(),
            "called `Result::unwrap()` on an `Err` value".getBytes()
    };
    private static final String ENABLED_PROPERTY = "DecompilerParameterAnalyzer.enabled";

    public RustStdAnalyzer() {
        super("Detect Rust libstd functions",
                "Detects Rust standard library functions from saved signatures and saves analysis time.\n\nProvided by GhidRust",
                AnalyzerType.FUNCTION_ANALYZER);

        /*
         * This is just one above the priority at which the Function ID analyzer runs
         * (FUNCTION_ID_ANALYSIS - 1)
         * We need to run before the Function ID analyzer runs because we are populating
         * the Function ID analyzer
         * with our own Function ID databases.
         */
        setPriority(AnalysisPriority.FUNCTION_ID_ANALYSIS.before().before());

        try {
            writer = new BufferedWriter(new FileWriter(filePath, true));
        } catch (IOException exc) {
            // pass
        }
    }

    private static boolean contains(byte[] hay, byte[] needle) {
        if (hay.length < needle.length) {
            return false;
        }

        for (int i = 0; i <= hay.length - needle.length; i++) {
            int match_len = 0;
            for (int j = 0; j < needle.length; j++) {
                if (needle[j] == hay[i + j]) {
                    match_len++;
                } else {
                    break;
                }
            }
            if (match_len == needle.length) {
                return true;
            }
        }

        return false;
    }

    static private boolean getNextChunk(InputStream stream, byte[] dest, int size) {
        byte end;

        try {
            if (stream.available() <= 0) {
                return false;
            }

            end = (byte) stream.read();
        } catch (IOException exc) {
            return false;
        }

        for (int i = 0; i < size - 1; i++) {
            dest[i] = dest[i + 1];
        }

        dest[size - 1] = end;
        return true;
    }

    @Override
    public boolean getDefaultEnablement(Program program) {
        // Make sure the property has not been disabled
        String default_enabled = System.getProperty(ENABLED_PROPERTY);
        if (default_enabled != null && !Boolean.parseBoolean(default_enabled)) {
            return false;
        }

        /*
         * Be enabled by default so that we can make sure the analysis of Rust functions
         * takes place
         */
        return true;
    }

    @Override
    public boolean canAnalyze(Program program) {
        return isRustBinary(program);
    }

    @Override
    public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
            throws CancelledException {
        FidFileManager ffm = FidFileManager.getInstance();
        if (ffm == null) {
            return false;
        }

        ResourceFile data_dir;
        try {
            data_dir = Application.getModuleDataSubDirectory("");
        } catch (IOException exc) {
            log.appendException(exc);
            return false;
        }

        ResourceFile[] libs = data_dir.listFiles();
        for (ResourceFile lib : libs) {
            monitor.checkCanceled();
            ffm.addUserFidFile(lib.getFile(true));
        }

        return true;
    }

    @Override
    public void analysisEnded(Program program) {
        super.analysisEnded(program);

        try {
            writer.close();
        } catch (IOException exc) {
            // pass
        }
    }

    /* For exposing the Rust checking code */
    public static boolean isRustBinary(Program program) {
        /*
         * Taken from
         * https://github.com/mandiant/capa-rules/blob/master/compiler/rust/compiled-
         * with-rust.yml
         */

        /* We know that the strings would be found in the .rodata section */
        MemoryBlock rodata = program.getMemory().getBlock(".rodata");

        InputStream stream = rodata.getData();

        int search_len = 0;
        for (byte[] artifact : rust_artifacts) {
            int artifact_len = artifact.length;

            if (artifact_len > search_len) {
                search_len = artifact_len;
            }
        }

        int i = 0;
        byte[] chunk = new byte[search_len];

        try {
            while (stream.available() > 0 && i < chunk.length) {
                chunk[i] = (byte) stream.read();
                i++;
            }
        } catch (IOException exc) {
            return false;
        }

        try {
            while (stream.available() > 0) {
                if (!getNextChunk(stream, chunk, search_len)) {
                    break;
                }

                for (byte[] artifact : rust_artifacts) {
                    if (contains(chunk, artifact)) {
                        /* This is a Rust binary */
                        return true;
                    }
                }

            }
        } catch (IOException exc) {
            return false;
        }

        return false;
    }
}

```

`src/main/java/ghidrust/decompiler/RustDecPlugin.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidrust.decompiler;

import ghidra.app.plugin.PluginCategoryNames;
import docking.ActionContext;
import docking.action.DockingAction;
import ghidra.app.events.*;
import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginInfo;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.framework.plugintool.PluginEvent;

import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;
import ghidra.util.Msg;
import ghidrust.analyzer.RustStdAnalyzer;
import docking.action.MenuData;

//@formatter:off
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = "HELLO",
	category = PluginCategoryNames.DECOMPILER,
	shortDescription = "Rust Decompiler",
	description = "Decompile Rust binaries' assembly to Rust code",
    eventsConsumed = {
		ProgramActivatedPluginEvent.class, ProgramLocationPluginEvent.class, ProgramClosedPluginEvent.class
	}
)
//@formatter:on
public class RustDecPlugin extends Plugin {
    Program program;
    RustDecProvider provider;

    public RustDecPlugin(PluginTool tool) {
        super(tool);
        provider = new RustDecProvider(this, getName(), null);

        DockingAction dec_plugin = new DockingAction("GhidRust", getName()) {
            @Override
            public void actionPerformed(ActionContext context) {
                provider.activateProvider();;
            }
        };

        dec_plugin.setEnabled(true);
        dec_plugin.setMenuBarData(new MenuData(new String[] { "GhidRust", "Open decompiler" }));

        DockingAction check_plugin = new DockingAction("GhidRust", getName()) {
            @Override
            public void actionPerformed(ActionContext context) {
                if (RustStdAnalyzer.isRustBinary(program)) {
                    Msg.showInfo(this, null, "GhidRust", "[+] Yes, this may be a Rust binary!");
                } else {
                    Msg.showInfo(this, null, "GhidRust", "[-] No, this may not be a Rust binary!");
                }
            }
        };

        check_plugin.setEnabled(true);
        check_plugin.setMenuBarData(new MenuData(new String[] { "GhidRust", "Check if Rust binary" }));

        tool.addAction(dec_plugin);
        tool.addAction(check_plugin);
    }

    @Override
    public void processEvent(PluginEvent event) {
        if (event instanceof ProgramActivatedPluginEvent) {
            program = ((ProgramActivatedPluginEvent) event).getActiveProgram();
            provider.setProgram(program);
            provider.setLocation(null);
        } else if (event instanceof ProgramLocationPluginEvent) {
            ProgramLocation location = ((ProgramLocationPluginEvent) event).getLocation();
            provider.setLocation(location.getAddress());
        } else if (event instanceof ProgramClosedPluginEvent) {
            program = null;
            provider.setProgram(program);
            provider.setLocation(null);
        }

        provider.reload();
    }
}

```

`src/main/java/ghidrust/decompiler/RustDecProvider.java`:

```java
package ghidrust.decompiler;

import ghidra.program.model.listing.Program;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;

import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.JToolBar;
import javax.swing.JButton;
import javax.swing.Box;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import docking.ComponentProvider;
import ghidra.util.task.ConsoleTaskMonitor;
import resources.ResourceManager;

import ghidrust.decompiler.parser.c.gen.CParser;

public class RustDecProvider extends ComponentProvider {
    private JPanel panel;
    private JTextArea code_area;
    private JLabel func_title;

    private Program prog;
    private Address addr;

    private DecompInterface decomp_ifc = null;

    private static final String EMPTY_LABEL = "<none>";

    public RustDecProvider(RustDecPlugin plugin, String owner, Program p) {
        super(plugin.getTool(), owner, owner);
        setIcon(ResourceManager.loadImage("images/icon.png"));

        decomp_ifc = new DecompInterface();
        setProgram(p);

        buildPanel();
    }

    @Override
    public JComponent getComponent() {
        return panel;
    }

    private void buildPanel() {
        panel = new JPanel(new BorderLayout());

        func_title = new JLabel(EMPTY_LABEL);
        JButton reload = new JButton(ResourceManager.loadImage("images/reload.png"));

        reload.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                reload();
            }
        });

        JToolBar toolbar = new JToolBar("GhidRust", JToolBar.HORIZONTAL);
        toolbar.setFloatable(false);
        toolbar.add(func_title);
        toolbar.add(Box.createHorizontalGlue());
        toolbar.add(reload);

        code_area = new JTextArea();
        code_area.setEditable(false);

        JScrollPane scroll = new JScrollPane(code_area);
        scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        panel.add(toolbar, BorderLayout.PAGE_START);
        panel.add(scroll);
    }

    public void activateProvider() {
        setVisible(true);
    }

    public void setProgram(Program p) {
        prog = p;

        decomp_ifc.closeProgram();
        if (prog != null) {
            decomp_ifc.openProgram(prog);
        }
    }

    public void setLocation(Address a) {
        addr = a;
    }

    public void reload() {
        if (prog == null) {
            func_title.setText(EMPTY_LABEL);
            code_area.setText("[?] Open a program to see the decompilation!\n");
            return;
        }

        if (addr == null) {
            func_title.setText(EMPTY_LABEL);
            code_area.setText("[?] Select a memory location to decompile!\n");
            return;
        }

        Function func = prog.getFunctionManager().getFunctionContaining(addr);
        if (func == null) {
            func_title.setText(EMPTY_LABEL);
            code_area.setText("[!] No function found at " + addr.toString() + "\n");
            return;
        }

        func_title.setText(func.getName());

        if (decomp_ifc == null) {
            code_area.setText("[!] Decompiler has not been initialized!\n");
            return;
        }

        DecompileResults results = decomp_ifc.decompileFunction(func, 0, new ConsoleTaskMonitor());
        if (results == null || results.getDecompiledFunction() == null || results.getDecompiledFunction().getC() == null) {
            code_area.setText("[!] Failed to decompile " + func.getName() + "\n");
            return;
        }

        String decompiled = results.getDecompiledFunction().getC();
        String rust_code = "";

        try {
            rust_code = CParser.transpile(decompiled);
        } catch (Exception e) {
            rust_code = "/* [!] Failed to transpile " + func.getName() + " */\n" + decompiled;
        }

        code_area.setText(rust_code);
    }
}

```

`src/main/java/ghidrust/decompiler/parser/Run.java`:

```java
package ghidrust.decompiler.parser;

import ghidrust.decompiler.parser.c.gen.CParser;

public class Run {
    public static void main(String[] args) {
        System.out.println(CParser.transpile(System.in));
    }
}

```

`src/main/java/ghidrust/decompiler/parser/c/CVisitor.java`:

```java
package ghidrust.decompiler.parser.c;

import ghidrust.decompiler.parser.c.gen.*;
import java.util.HashMap;

/* Generated By:JavaCC: Do not edit this line. CParserDefaultVisitor.java Version 7.0.9 */
public class CVisitor implements CParserVisitor {
    HashMap<String, String> type_map = new HashMap<String, String>();

    int indent_level = 0;

    public CVisitor() {
        type_map.put("void", "");
        type_map.put("int", "i32");

        /* Not entirely true, but works for now */
        type_map.put("char", "char");

        type_map.put("short", "i16");
        type_map.put("long", "i32");
        type_map.put("float", "f32");
        type_map.put("double", "f64");
        type_map.put("signed", "i32");
        type_map.put("unsigned", "u32");
        type_map.put("code", "code");
    }

    private StringBuilder indent(StringBuilder sb) {
        for (int i = 0; i < indent_level; i++) {
            sb.append("\t");
        }

        return sb;
    }

    public Object defaultVisit(SimpleNode node, Object data) {
        StringBuilder sb = new StringBuilder("");

        int child_count = node.jjtGetNumChildren();
        for (int i = 0; i < child_count; i++) {
            Node child = node.jjtGetChild(i);
            String ret = (String) child.jjtAccept(this, data);
            if (ret != null) {
                sb.append(ret);
            }
        }

        return sb.toString();
    }

    public Object defaultSpacedVisit(SimpleNode node, Object data, String separator, boolean last) {
        StringBuilder sb = new StringBuilder("");

        int child_count = node.jjtGetNumChildren();
        for (int i = 0; i < child_count; i++) {
            Node child = node.jjtGetChild(i);
            String ret = (String) child.jjtAccept(this, data);
            if (ret != null) {
                sb.append(ret);
                if (!ret.equals("") && (last || i != child_count - 1)) {
                    sb.append(separator);
                }
            }
        }

        return sb.toString();
    }

    public Object visit(SimpleNode node, Object data) {
        return node.jjtAccept(this, data);
    }

    public Object visit(ASTStringToken node, Object data) {
        return node.getValue();
    }

    public Object visit(ASTGhostStringToken node, Object data) {
        return "";
    }

    public Object visit(ASTTypeStringToken node, Object data) {
        String typename = node.getValue();

        if (type_map.containsKey(typename)) {
            return type_map.get(typename);
        } else {
            return typename;
        }
    }

    public Object visit(ASTFunctionDefinition node, Object data) {
        node.dump("");
        StringBuilder rust_code = new StringBuilder("");

        rust_code.append("fn ");
        rust_code.append(node.jjtGetChild(1).jjtAccept(this, data));

        String ret_type = (String) node.jjtGetChild(0).jjtAccept(this, data);
        if (!ret_type.equals("")) {
            rust_code.append("-> ");
        }
        rust_code.append(ret_type);
        rust_code.append(" {\n");
        indent_level++;
        rust_code.append(node.jjtGetChild(2).jjtAccept(this, data));
        rust_code.append("}\n");
        indent_level--;

        return rust_code.toString();
    }

    public Object visit(ASTDeclaration node, Object data) {
        StringBuilder sb = new StringBuilder("");
        String[] ret = (String[]) node.jjtGetChild(1).jjtAccept(this, data);

        for (int i = 0; i < ret.length / 2; i++) {
            if (i != 0) {
                sb = indent(sb);
            }

            sb.append("let mut ");
            sb.append(ret[2 * i]);
            sb.append(": ");
            sb.append(node.jjtGetChild(0).jjtAccept(this, data));
            if (ret[2 * i + 1] != null) {
                sb.append(" = ");
                sb.append(ret[2 * i + 1]);
            }
            sb.append(";");
            sb.append("\n");
        }

        return sb.toString();
    }

    public Object visit(ASTDeclarationList node, Object data) {
        StringBuilder sb = indent(new StringBuilder(""));
        return sb.toString() + defaultSpacedVisit(node, data, sb.toString(), false);
    }

    public Object visit(ASTDeclarationSpecifiers node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTInitDeclaratorList node, Object data) {
        String[] ret = new String[node.jjtGetNumChildren() * 2];
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            String[] child_ret = (String[]) node.jjtGetChild(i).jjtAccept(this, data);
            ret[2 * i] = child_ret[0];
            ret[2 * i + 1] = child_ret[1];
        }

        return ret;
    }

    public Object visit(ASTInitDeclarator node, Object data) {
        String[] ret = new String[2];
        ret[0] = (String) node.jjtGetChild(0).jjtAccept(this, data);
        if (node.jjtGetNumChildren() == 1) {
            ret[1] = null;
        } else {
            ret[1] = (String) node.jjtGetChild(1).jjtAccept(this, data);
        }

        return ret;
    }

    public Object visit(ASTSpecifierQualifierList node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTDeclarator node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTDirectDeclarator node, Object data) {
        int child_num = node.jjtGetNumChildren();

        StringBuilder sb = new StringBuilder("");
        for (int i = 0; i < child_num; i++) {
            Node child = node.jjtGetChild(i);
            String child_val = (String) child.jjtAccept(this, data);

            if (child instanceof ASTDeclarator || child instanceof ASTParameterTypeList
                    || child instanceof ASTIdentifierList) {
                sb.append("(");
                sb.append(child_val);
                sb.append(") ");
            } else if (child instanceof ASTConstantExpression) {
                sb.append("[");
                sb.append(child_val);
                sb.append("] ");
            } else {
                sb.append(child_val);
            }
        }

        return sb.toString();
    }

    public Object visit(ASTPointer node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTTypeQualifierList node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTParameterTypeList node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTParameterList node, Object data) {
        StringBuilder sb = new StringBuilder("");
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            if (i != 0) {
                sb.append(", ");
            }
            sb.append(node.jjtGetChild(i).jjtAccept(this, data));
        }

        return sb.toString();
    }

    public Object visit(ASTParameterDeclaration node, Object data) {
        StringBuilder sb = new StringBuilder("");

        if (node.jjtGetNumChildren() > 1) {
            sb.append(node.jjtGetChild(1).jjtAccept(this, data));
            sb.append(": ");
        }
        sb.append(node.jjtGetChild(0).jjtAccept(this, data));
        return sb.toString();
    }

    public Object visit(ASTIdentifierList node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTInitializer node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTInitializerList node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTTypeName node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTAbstractDeclarator node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTDirectAbstractDeclarator node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTStatement node, Object data) {
        StringBuilder sb = indent(new StringBuilder(""));
        return sb.toString() + defaultVisit(node, data);
    }

    public Object visit(ASTLabeledStatement node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTExpressionStatement node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTCompoundStatement node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTStatementList node, Object data) {
        return defaultSpacedVisit(node, data, "\n", true);
    }

    public Object visit(ASTSelectionStatement node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTIterationStatement node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTJumpStatement node, Object data) {
        StringBuilder sb = new StringBuilder("");

        if (node.jjtGetNumChildren() > 0 && node.jjtGetChild(0) instanceof ASTExpression) {
            sb.append("return ");
            sb.append(node.jjtGetChild(0).jjtAccept(this, data));
        } else {
            sb.append(defaultVisit(node, data));
        }
        return sb.toString();
    }

    public Object visit(ASTExpression node, Object data) {
        if (node.jjtGetChild(0) instanceof ASTAssignmentExpression) {
            return defaultSpacedVisit(node, data, " ", false) + ";";
        } else {
            ASTDeclaration decl = new ASTDeclaration(0);
            decl.jjtAddChild(node.jjtGetChild(0), 0);
            decl.jjtAddChild(node.jjtGetChild(1), 1);
            return decl.jjtAccept(this, data);
        }
    }

    public Object visit(ASTAssignmentExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTConditionalExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTConstantExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTLogicalORExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTLogicalANDExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTInclusiveORExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTExclusiveORExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTANDExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTEqualityExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTRelationalExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTShiftExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTAdditiveExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTMultiplicativeExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTCastExpression node, Object data) {
        StringBuilder sb = new StringBuilder("");
        if (node.jjtGetNumChildren() > 1) {
            sb.append(node.jjtGetChild(1).jjtAccept(this, data));
            sb.append(" as ");
        }
        sb.append(node.jjtGetChild(0).jjtAccept(this, data));

        return sb.toString();
    }

    public Object visit(ASTUnaryExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTUnaryOperator node, Object data) {
        return defaultVisit(node, data);
    }

    public Object visit(ASTPostfixExpression node, Object data) {
        StringBuilder sb = new StringBuilder("");
        sb.append(node.jjtGetChild(0).jjtAccept(this, data));

        if (node.choice == 2) {
            /* Function call */
            sb.append("(");

            for (int i = 1; i < node.jjtGetNumChildren(); i++) {
                sb.append(node.jjtGetChild(i).jjtAccept(this, data));
            }

            sb.append(")");
            return sb.toString();
        }

        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTPrimaryExpression node, Object data) {
        return defaultSpacedVisit(node, data, " ", false);
    }

    public Object visit(ASTArgumentExpressionList node, Object data) {
        return defaultSpacedVisit(node, data, ", ", false);
    }
}
/*
 * JavaCC - OriginalChecksum=fd39d82df2a1b516298b94d6f4a5e997 (do not edit this
 * line)
 */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTANDExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTANDExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTANDExpression extends SimpleNode {
  public ASTANDExpression(int id) {
    super(id);
  }

  public ASTANDExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=7e93c9974e8f2b14420427b910c803b4 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTAbstractDeclarator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTAbstractDeclarator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAbstractDeclarator extends SimpleNode {
  public ASTAbstractDeclarator(int id) {
    super(id);
  }

  public ASTAbstractDeclarator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=3c80989bb20f86b9b8036d71e7bef9c2 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTAdditiveExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTAdditiveExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAdditiveExpression extends SimpleNode {
  public ASTAdditiveExpression(int id) {
    super(id);
  }

  public ASTAdditiveExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=f71bb1e7a072d878a992f57313d16468 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTArgumentExpressionList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTArgumentExpressionList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTArgumentExpressionList extends SimpleNode {
  public ASTArgumentExpressionList(int id) {
    super(id);
  }

  public ASTArgumentExpressionList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=3d50396a2f3da00f02231d6bf8462c1f (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTAssignmentExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTAssignmentExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAssignmentExpression extends SimpleNode {
  public ASTAssignmentExpression(int id) {
    super(id);
  }

  public ASTAssignmentExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4e1bb62c278549e39d52bdb3b3ba2d83 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTCastExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTCastExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTCastExpression extends SimpleNode {
  public ASTCastExpression(int id) {
    super(id);
  }

  public ASTCastExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=5f74743ccea636bb6764ebed2ac163e2 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTCompoundStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTCompoundStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTCompoundStatement extends SimpleNode {
  public ASTCompoundStatement(int id) {
    super(id);
  }

  public ASTCompoundStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=0e0e31b45cd47c4f4461f95fd3e3de78 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTConditionalExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTConditionalExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTConditionalExpression extends SimpleNode {
  public ASTConditionalExpression(int id) {
    super(id);
  }

  public ASTConditionalExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=0abef7756156c947795a60956e579484 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTConstantExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTConstantExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTConstantExpression extends SimpleNode {
  public ASTConstantExpression(int id) {
    super(id);
  }

  public ASTConstantExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=9f5650e6758d6a765d019f16147af60b (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDeclaration.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDeclaration.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDeclaration extends SimpleNode {
  public ASTDeclaration(int id) {
    super(id);
  }

  public ASTDeclaration(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=348ef19493387532712ee3fd63bef963 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDeclarationList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDeclarationList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDeclarationList extends SimpleNode {
  public ASTDeclarationList(int id) {
    super(id);
  }

  public ASTDeclarationList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=74a8d1f0be8d1ac35c19038dd28661b6 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDeclarationSpecifiers.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDeclarationSpecifiers.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDeclarationSpecifiers extends SimpleNode {
  public ASTDeclarationSpecifiers(int id) {
    super(id);
  }

  public ASTDeclarationSpecifiers(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=2696c846786a5a2eade82856402afbaa (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDeclarator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDeclarator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDeclarator extends SimpleNode {
  public ASTDeclarator(int id) {
    super(id);
  }

  public ASTDeclarator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=8171a8ae0c9b5d4aed5906caced0fc03 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDirectAbstractDeclarator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDirectAbstractDeclarator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDirectAbstractDeclarator extends SimpleNode {
  public ASTDirectAbstractDeclarator(int id) {
    super(id);
  }

  public ASTDirectAbstractDeclarator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=73556b7b7bb74f11f30bb99721dd1118 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTDirectDeclarator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTDirectDeclarator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTDirectDeclarator extends SimpleNode {
  public ASTDirectDeclarator(int id) {
    super(id);
  }

  public ASTDirectDeclarator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4b709aa773fb5b1aa3770e5a95e3fa10 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTEqualityExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTEqualityExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTEqualityExpression extends SimpleNode {
  public ASTEqualityExpression(int id) {
    super(id);
  }

  public ASTEqualityExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=aab2519466666944adaf86111afb0582 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTExclusiveORExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTExclusiveORExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTExclusiveORExpression extends SimpleNode {
  public ASTExclusiveORExpression(int id) {
    super(id);
  }

  public ASTExclusiveORExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=6f56922e1bdf9afc2877228247e2891b (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTExpression extends SimpleNode {
  public ASTExpression(int id) {
    super(id);
  }

  public ASTExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=9adff7edeff999906ffb1039a66f050d (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTExpressionStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTExpressionStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTExpressionStatement extends SimpleNode {
  public ASTExpressionStatement(int id) {
    super(id);
  }

  public ASTExpressionStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=1c74fd0cb78ed440334aeeb1769835bf (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTFunctionDefinition.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTFunctionDefinition.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTFunctionDefinition extends SimpleNode {
  public ASTFunctionDefinition(int id) {
    super(id);
  }

  public ASTFunctionDefinition(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=ceed4da5ab63eb8db1c189c0a2b48e1d (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTGhostStringToken.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTGhostStringToken.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTGhostStringToken extends SimpleNode {
  String str_val;
  
  public ASTGhostStringToken(int id) {
    super(id);
  }

  public ASTGhostStringToken(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }

  public String getValue() {
    return str_val;
  }

  public void setValue(String value) {
    this.str_val = value;
  }
}
/* JavaCC - OriginalChecksum=7d91f560265b12b4f437803bcd66b7ba (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTIdentifierList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTIdentifierList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTIdentifierList extends SimpleNode {
  public ASTIdentifierList(int id) {
    super(id);
  }

  public ASTIdentifierList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4b59a3f78866b6522e8f01a33a7e42ea (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTInclusiveORExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTInclusiveORExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTInclusiveORExpression extends SimpleNode {
  public ASTInclusiveORExpression(int id) {
    super(id);
  }

  public ASTInclusiveORExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4be48bfdf235cd5783ba6d95e5f75d7a (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTInitDeclarator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTInitDeclarator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTInitDeclarator extends SimpleNode {
  public ASTInitDeclarator(int id) {
    super(id);
  }

  public ASTInitDeclarator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=5a3d91755680a04c5498b43e77500777 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTInitDeclaratorList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTInitDeclaratorList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTInitDeclaratorList extends SimpleNode {
  public ASTInitDeclaratorList(int id) {
    super(id);
  }

  public ASTInitDeclaratorList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=a2d08638fd0cf7a82e33e58b0478332a (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTInitializer.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTInitializer.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTInitializer extends SimpleNode {
  public ASTInitializer(int id) {
    super(id);
  }

  public ASTInitializer(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=1e50ef3004d5c30bf923f81791f50da2 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTInitializerList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTInitializerList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTInitializerList extends SimpleNode {
  public ASTInitializerList(int id) {
    super(id);
  }

  public ASTInitializerList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=558244df30965162e70057ea29c24a1b (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTIterationStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTIterationStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTIterationStatement extends SimpleNode {
  public ASTIterationStatement(int id) {
    super(id);
  }

  public ASTIterationStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=7b7c82e89dcb516eca8590537cd9f70a (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTJumpStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTJumpStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTJumpStatement extends SimpleNode {
  public ASTJumpStatement(int id) {
    super(id);
  }

  public ASTJumpStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=8f8900c8aee5bbcbce1cd63910a5145a (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTLabeledStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTLabeledStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTLabeledStatement extends SimpleNode {
  public ASTLabeledStatement(int id) {
    super(id);
  }

  public ASTLabeledStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=90c945b0f67caa48bc985322079aff53 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTLogicalANDExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTLogicalANDExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTLogicalANDExpression extends SimpleNode {
  public ASTLogicalANDExpression(int id) {
    super(id);
  }

  public ASTLogicalANDExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=1d00e1b3f3b5cc84eb240091695aa110 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTLogicalORExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTLogicalORExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTLogicalORExpression extends SimpleNode {
  public ASTLogicalORExpression(int id) {
    super(id);
  }

  public ASTLogicalORExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4b98654445da39285ab465c0e8addd5e (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTMultiplicativeExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTMultiplicativeExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTMultiplicativeExpression extends SimpleNode {
  public ASTMultiplicativeExpression(int id) {
    super(id);
  }

  public ASTMultiplicativeExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=bc0ec0ccb8aa48f86316c0b7a00f830c (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTParameterDeclaration.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTParameterDeclaration.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTParameterDeclaration extends SimpleNode {
  public ASTParameterDeclaration(int id) {
    super(id);
  }

  public ASTParameterDeclaration(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4aebee4940a994d0d51c48c5280f9eb8 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTParameterList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTParameterList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTParameterList extends SimpleNode {
  public ASTParameterList(int id) {
    super(id);
  }

  public ASTParameterList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=4df2dd10fe864789b789e1afaa3b1ed1 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTParameterTypeList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTParameterTypeList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTParameterTypeList extends SimpleNode {
  public ASTParameterTypeList(int id) {
    super(id);
  }

  public ASTParameterTypeList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=2424e97a6a345ef3f2a72b0086086cb7 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTPointer.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTPointer.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTPointer extends SimpleNode {
  public ASTPointer(int id) {
    super(id);
  }

  public ASTPointer(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=e3d91b51bd9822af624c9f60557bbd98 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTPostfixExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTPostfixExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTPostfixExpression extends SimpleNode {
  public int choice;

  public ASTPostfixExpression(int id) {
    super(id);
  }

  public ASTPostfixExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=921e4951da40bb22d131f8b3ba6a1988 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTPrimaryExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTPrimaryExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTPrimaryExpression extends SimpleNode {
  public ASTPrimaryExpression(int id) {
    super(id);
  }

  public ASTPrimaryExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=74ddac2af3988d157a1b94a9d821defd (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTRelationalExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTRelationalExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTRelationalExpression extends SimpleNode {
  public ASTRelationalExpression(int id) {
    super(id);
  }

  public ASTRelationalExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=819382a46b070e41d5029a3e39fe5a89 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTSelectionStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTSelectionStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTSelectionStatement extends SimpleNode {
  public ASTSelectionStatement(int id) {
    super(id);
  }

  public ASTSelectionStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=1d0effb2de665660bde555051d4eaf39 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTShiftExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTShiftExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTShiftExpression extends SimpleNode {
  public ASTShiftExpression(int id) {
    super(id);
  }

  public ASTShiftExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=6e6a85bea0361907c843fbe90c9de598 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTSpecifierQualifierList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTSpecifierQualifierList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTSpecifierQualifierList extends SimpleNode {
  public ASTSpecifierQualifierList(int id) {
    super(id);
  }

  public ASTSpecifierQualifierList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=7fafbaad1e5888617b5543d24af0d7e3 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTStatement.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTStatement.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTStatement extends SimpleNode {
  public ASTStatement(int id) {
    super(id);
  }

  public ASTStatement(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=c72fe84922519215ac2b49c1d95d7b03 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTStatementList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTStatementList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTStatementList extends SimpleNode {
  public ASTStatementList(int id) {
    super(id);
  }

  public ASTStatementList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=7d811424c808895d04aa0efe33fefd71 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTStringToken.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTStringToken.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTStringToken extends SimpleNode {
  String str_val;
  
  public ASTStringToken(int id) {
    super(id);
  }

  public ASTStringToken(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }

  public String getValue() {
    return str_val;
  }

  public void setValue(String value) {
    this.str_val = value;
  }
}
/* JavaCC - OriginalChecksum=c289df07a5b51163b866d4bfab28fb00 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTTypeName.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTTypeName.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTTypeName extends SimpleNode {
  public ASTTypeName(int id) {
    super(id);
  }

  public ASTTypeName(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=6649fc4e18b27ff4c36885518a37d22c (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTTypeQualifierList.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTTypeQualifierList.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTTypeQualifierList extends SimpleNode {
  public ASTTypeQualifierList(int id) {
    super(id);
  }

  public ASTTypeQualifierList(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=9ed914bbeab9d4fba7337616cdf8c796 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTTypeStringToken.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTTypeStringToken.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTTypeStringToken extends SimpleNode {
  String str_val;

  public ASTTypeStringToken(int id) {
    super(id);
  }

  public ASTTypeStringToken(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }

  public String getValue() {
    return str_val;
  }

  public void setValue(String value) {
    this.str_val = value;
  }
}
/* JavaCC - OriginalChecksum=726f5c0cafc2cba1f5ca608dfd54d3e2 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTUnaryExpression.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTUnaryExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTUnaryExpression extends SimpleNode {
  public ASTUnaryExpression(int id) {
    super(id);
  }

  public ASTUnaryExpression(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=d19d61fd0527008bafedc0dbcae70bec (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ASTUnaryOperator.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. ASTUnaryOperator.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTUnaryOperator extends SimpleNode {
  public ASTUnaryOperator(int id) {
    super(id);
  }

  public ASTUnaryOperator(CParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=6c43a4b6e42256ad16599f05ce4392a5 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParser.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* CParser.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. CParser.java */
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import ghidrust.decompiler.parser.c.CVisitor;

public class CParser/*@bgen(jjtree)*/implements CParserTreeConstants, CParserConstants {/*@bgen(jjtree)*/
  protected JJTCParserState jjtree = new JJTCParserState();private static CParser c_parser;

        // Run the parser
        public static String transpile(String c_code) {
                InputStream stream = new ByteArrayInputStream(c_code.getBytes(StandardCharsets.UTF_8));
                return transpile(stream);
        }

        public static String transpile(InputStream stream) {
                c_parser = new CParser(stream);

                try {
                        return parse();
                } catch (ParseException e) {
                        System.out.println("Rust transpiler: Encountered errors during parsing.");
                        e.printStackTrace();
                        return null;
                }
        }

        public static String parse() throws ParseException {
                CParserVisitor visitor = new CVisitor();
        return (String) c_parser.FunctionDefinition().jjtAccept(visitor, null);
        }

  final public SimpleNode FunctionDefinition() throws ParseException {/*@bgen(jjtree) FunctionDefinition */
  ASTFunctionDefinition jjtn000 = new ASTFunctionDefinition(JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_1(2147483647)) {
        DeclarationSpecifiers();
      } else {
        ;
      }
      Declarator();
      CompoundStatement();
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
}

  final public void Declaration() throws ParseException {/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      DeclarationSpecifiers();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case 63:
      case 67:
      case 90:{
        InitDeclaratorList();
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(60);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void DeclarationList() throws ParseException {/*@bgen(jjtree) DeclarationList */
  ASTDeclarationList jjtn000 = new ASTDeclarationList(JJTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        Declaration();
        if (jj_2_2(2147483647)) {
          ;
        } else {
          break label_1;
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void DeclarationSpecifiers() throws ParseException {/*@bgen(jjtree) DeclarationSpecifiers */
  ASTDeclarationSpecifiers jjtn000 = new ASTDeclarationSpecifiers(JJTDECLARATIONSPECIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case REGISTER:
      case TYPEDEF:
      case EXTERN:
      case STATIC:
      case AUTO:{
        StorageClassSpecifier();
        if (jj_2_3(2147483647)) {
          DeclarationSpecifiers();
        } else {
          ;
        }
        break;
        }
      case UNDEFINED_TYPE:
      case UNSIGNED:
      case DOUBLE:
      case SIGNED:
      case FLOAT:
      case SHORT:
      case LONG:
      case VOID:
      case CHAR:
      case INT:
      case BOOL_TYPE:
      case CODE:{
        TypeSpecifier();
        if (jj_2_4(2147483647)) {
          DeclarationSpecifiers();
        } else {
          ;
        }
        break;
        }
      case VOLATILE:
      case CONST:{
        TypeQualifier();
        if (jj_2_5(2147483647)) {
          DeclarationSpecifiers();
        } else {
          ;
        }
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void StorageClassSpecifier() throws ParseException {/*@bgen(jjtree) GhostStringToken */
        ASTGhostStringToken jjtn000 = new ASTGhostStringToken(JJTGHOSTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AUTO:{
        t = jj_consume_token(AUTO);
        break;
        }
      case REGISTER:{
        t = jj_consume_token(REGISTER);
        break;
        }
      case STATIC:{
        t = jj_consume_token(STATIC);
        break;
        }
      case EXTERN:{
        t = jj_consume_token(EXTERN);
        break;
        }
      case TYPEDEF:{
        t = jj_consume_token(TYPEDEF);
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void TypeSpecifier() throws ParseException {/*@bgen(jjtree) TypeStringToken */
        ASTTypeStringToken jjtn000 = new ASTTypeStringToken(JJTTYPESTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VOID:{
        t = jj_consume_token(VOID);
        break;
        }
      case CHAR:{
        t = jj_consume_token(CHAR);
        break;
        }
      case SHORT:{
        t = jj_consume_token(SHORT);
        break;
        }
      case INT:{
        t = jj_consume_token(INT);
        break;
        }
      case LONG:{
        t = jj_consume_token(LONG);
        break;
        }
      case FLOAT:{
        t = jj_consume_token(FLOAT);
        break;
        }
      case DOUBLE:{
        t = jj_consume_token(DOUBLE);
        break;
        }
      case SIGNED:{
        t = jj_consume_token(SIGNED);
        break;
        }
      case UNSIGNED:{
        t = jj_consume_token(UNSIGNED);
        break;
        }
      case BOOL_TYPE:{
        t = jj_consume_token(BOOL_TYPE);
        break;
        }
      case CODE:{
        t = jj_consume_token(CODE);
        break;
        }
      case UNDEFINED_TYPE:{
        t = jj_consume_token(UNDEFINED_TYPE);
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void TypeQualifier() throws ParseException {/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CONST:{
        t = jj_consume_token(CONST);
        break;
        }
      case VOLATILE:{
        t = jj_consume_token(VOLATILE);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void InitDeclaratorList() throws ParseException {/*@bgen(jjtree) InitDeclaratorList */
  ASTInitDeclaratorList jjtn000 = new ASTInitDeclaratorList(JJTINITDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      InitDeclarator();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 61:{
          ;
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
        jj_consume_token(61);
        InitDeclarator();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void InitDeclarator() throws ParseException {/*@bgen(jjtree) InitDeclarator */
  ASTInitDeclarator jjtn000 = new ASTInitDeclarator(JJTINITDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Declarator();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 62:{
        jj_consume_token(62);
        Initializer();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void SpecifierQualifierList() throws ParseException {/*@bgen(jjtree) SpecifierQualifierList */
  ASTSpecifierQualifierList jjtn000 = new ASTSpecifierQualifierList(JJTSPECIFIERQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNDEFINED_TYPE:
      case UNSIGNED:
      case DOUBLE:
      case SIGNED:
      case FLOAT:
      case SHORT:
      case LONG:
      case VOID:
      case CHAR:
      case INT:
      case BOOL_TYPE:
      case CODE:{
        TypeSpecifier();
        if (jj_2_6(2147483647)) {
          SpecifierQualifierList();
        } else {
          ;
        }
        break;
        }
      case VOLATILE:
      case CONST:{
        TypeQualifier();
        if (jj_2_7(2147483647)) {
          SpecifierQualifierList();
        } else {
          ;
        }
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void Declarator() throws ParseException {/*@bgen(jjtree) Declarator */
  ASTDeclarator jjtn000 = new ASTDeclarator(JJTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 67:{
        Pointer();
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      DirectDeclarator();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void DirectDeclarator() throws ParseException {/*@bgen(jjtree) DirectDeclarator */
  ASTDirectDeclarator jjtn000 = new ASTDirectDeclarator(JJTDIRECTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case 90:{
        Identifier();
        break;
        }
      case 63:{
        jj_consume_token(63);
        Declarator();
        jj_consume_token(64);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 63:
        case 65:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 65:{
          jj_consume_token(65);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case BOOLEAN:
          case SIZEOF:
          case IDENTIFIER:
          case 63:
          case 67:
          case 87:
          case 90:
          case 96:
          case 97:
          case 100:
          case 101:
          case 102:
          case 103:{
            ConstantExpression();
            break;
            }
          default:
            jj_la1[11] = jj_gen;
            ;
          }
          jj_consume_token(66);
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          if (jj_2_8(3)) {
            jj_consume_token(63);
            ParameterTypeList();
            jj_consume_token(64);
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 63:{
              jj_consume_token(63);
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case IDENTIFIER:
              case 90:{
                IdentifierList();
                break;
                }
              default:
                jj_la1[12] = jj_gen;
                ;
              }
              jj_consume_token(64);
              break;
              }
            default:
              jj_la1[14] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void Pointer() throws ParseException {/*@bgen(jjtree) Pointer */
  ASTPointer jjtn000 = new ASTPointer(JJTPOINTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(67);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VOLATILE:
      case CONST:{
        TypeQualifierList();
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 67:{
        Pointer();
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void TypeQualifierList() throws ParseException {/*@bgen(jjtree) TypeQualifierList */
  ASTTypeQualifierList jjtn000 = new ASTTypeQualifierList(JJTTYPEQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_4:
      while (true) {
        TypeQualifier();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VOLATILE:
        case CONST:{
          ;
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          break label_4;
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ParameterTypeList() throws ParseException {/*@bgen(jjtree) ParameterTypeList */
  ASTParameterTypeList jjtn000 = new ASTParameterTypeList(JJTPARAMETERTYPELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ParameterList();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 61:{
        jj_consume_token(61);
        jj_consume_token(68);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ParameterList() throws ParseException {/*@bgen(jjtree) ParameterList */
  ASTParameterList jjtn000 = new ASTParameterList(JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ParameterDeclaration();
      label_5:
      while (true) {
        if (jj_2_9(2)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(61);
        ParameterDeclaration();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ParameterDeclaration() throws ParseException {/*@bgen(jjtree) ParameterDeclaration */
  ASTParameterDeclaration jjtn000 = new ASTParameterDeclaration(JJTPARAMETERDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      DeclarationSpecifiers();
      if (jj_2_10(2147483647)) {
        Declarator();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 63:
        case 65:
        case 67:{
          AbstractDeclarator();
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void IdentifierList() throws ParseException {/*@bgen(jjtree) IdentifierList */
  ASTIdentifierList jjtn000 = new ASTIdentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 61:{
          ;
          break;
          }
        default:
          jj_la1[20] = jj_gen;
          break label_6;
        }
        jj_consume_token(61);
        Identifier();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void Initializer() throws ParseException {/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case BOOLEAN:
      case SIZEOF:
      case IDENTIFIER:
      case 63:
      case 67:
      case 87:
      case 90:
      case 96:
      case 97:
      case 100:
      case 101:
      case 102:
      case 103:{
        AssignmentExpression();
        break;
        }
      case 69:{
        jj_consume_token(69);
        InitializerList();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 61:{
          jj_consume_token(61);
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        jj_consume_token(70);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void InitializerList() throws ParseException {/*@bgen(jjtree) InitializerList */
  ASTInitializerList jjtn000 = new ASTInitializerList(JJTINITIALIZERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Initializer();
      label_7:
      while (true) {
        if (jj_2_11(2)) {
          ;
        } else {
          break label_7;
        }
        jj_consume_token(61);
        Initializer();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void TypeName() throws ParseException {/*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SpecifierQualifierList();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 63:
      case 65:
      case 67:{
        AbstractDeclarator();
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void AbstractDeclarator() throws ParseException {/*@bgen(jjtree) AbstractDeclarator */
  ASTAbstractDeclarator jjtn000 = new ASTAbstractDeclarator(JJTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_12(3)) {
        Pointer();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 63:
        case 65:
        case 67:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 67:{
            Pointer();
            break;
            }
          default:
            jj_la1[24] = jj_gen;
            ;
          }
          DirectAbstractDeclarator();
          break;
          }
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void DirectAbstractDeclarator() throws ParseException {/*@bgen(jjtree) DirectAbstractDeclarator */
  ASTDirectAbstractDeclarator jjtn000 = new ASTDirectAbstractDeclarator(JJTDIRECTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_13(2)) {
        jj_consume_token(63);
        AbstractDeclarator();
        jj_consume_token(64);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 65:{
          jj_consume_token(65);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case BOOLEAN:
          case SIZEOF:
          case IDENTIFIER:
          case 63:
          case 67:
          case 87:
          case 90:
          case 96:
          case 97:
          case 100:
          case 101:
          case 102:
          case 103:{
            ConstantExpression();
            break;
            }
          default:
            jj_la1[26] = jj_gen;
            ;
          }
          jj_consume_token(66);
          break;
          }
        case 63:{
          jj_consume_token(63);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNDEFINED_TYPE:
          case VOLATILE:
          case REGISTER:
          case UNSIGNED:
          case TYPEDEF:
          case DOUBLE:
          case EXTERN:
          case STATIC:
          case SIGNED:
          case CONST:
          case FLOAT:
          case SHORT:
          case LONG:
          case AUTO:
          case VOID:
          case CHAR:
          case INT:
          case BOOL_TYPE:
          case CODE:{
            ParameterTypeList();
            break;
            }
          default:
            jj_la1[27] = jj_gen;
            ;
          }
          jj_consume_token(64);
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 63:
        case 65:{
          ;
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 65:{
          jj_consume_token(65);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case BOOLEAN:
          case SIZEOF:
          case IDENTIFIER:
          case 63:
          case 67:
          case 87:
          case 90:
          case 96:
          case 97:
          case 100:
          case 101:
          case 102:
          case 103:{
            ConstantExpression();
            break;
            }
          default:
            jj_la1[30] = jj_gen;
            ;
          }
          jj_consume_token(66);
          break;
          }
        case 63:{
          jj_consume_token(63);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNDEFINED_TYPE:
          case VOLATILE:
          case REGISTER:
          case UNSIGNED:
          case TYPEDEF:
          case DOUBLE:
          case EXTERN:
          case STATIC:
          case SIGNED:
          case CONST:
          case FLOAT:
          case SHORT:
          case LONG:
          case AUTO:
          case VOID:
          case CHAR:
          case INT:
          case BOOL_TYPE:
          case CODE:{
            ParameterTypeList();
            break;
            }
          default:
            jj_la1[31] = jj_gen;
            ;
          }
          jj_consume_token(64);
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void Statement() throws ParseException {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_14(2147483647)) {
        LabeledStatement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DOUBLE:
        case SIZEOF:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case CONST:
        case FLOAT:
        case SHORT:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case INT:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 60:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          ExpressionStatement();
          break;
          }
        case 69:{
          CompoundStatement();
          break;
          }
        case SWITCH:
        case IF:{
          SelectionStatement();
          break;
          }
        case WHILE:
        case FOR:
        case DO:{
          IterationStatement();
          break;
          }
        case CONTINUE:
        case RETURN:
        case BREAK:
        case GOTO:{
          JumpStatement();
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void LabeledStatement() throws ParseException {/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case 90:{
        Identifier();
        jj_consume_token(71);
        Statement();
        break;
        }
      case CASE:{
        jj_consume_token(CASE);
        ConstantExpression();
        jj_consume_token(71);
        Statement();
        break;
        }
      case DFLT:{
        jj_consume_token(DFLT);
        jj_consume_token(71);
        Statement();
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ExpressionStatement() throws ParseException {/*@bgen(jjtree) ExpressionStatement */
  ASTExpressionStatement jjtn000 = new ASTExpressionStatement(JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case BOOLEAN:
      case UNDEFINED_TYPE:
      case VOLATILE:
      case REGISTER:
      case UNSIGNED:
      case TYPEDEF:
      case DOUBLE:
      case SIZEOF:
      case EXTERN:
      case STATIC:
      case SIGNED:
      case CONST:
      case FLOAT:
      case SHORT:
      case LONG:
      case AUTO:
      case VOID:
      case CHAR:
      case INT:
      case BOOL_TYPE:
      case CODE:
      case IDENTIFIER:
      case 63:
      case 67:
      case 87:
      case 90:
      case 96:
      case 97:
      case 100:
      case 101:
      case 102:
      case 103:{
        Expression();
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(60);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void CompoundStatement() throws ParseException {/*@bgen(jjtree) CompoundStatement */
  ASTCompoundStatement jjtn000 = new ASTCompoundStatement(JJTCOMPOUNDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(69);
      if (jj_2_15(2147483647)) {
        DeclarationList();
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case BOOLEAN:
      case UNDEFINED_TYPE:
      case CONTINUE:
      case VOLATILE:
      case REGISTER:
      case UNSIGNED:
      case TYPEDEF:
      case DFLT:
      case DOUBLE:
      case SIZEOF:
      case SWITCH:
      case RETURN:
      case EXTERN:
      case STATIC:
      case SIGNED:
      case WHILE:
      case BREAK:
      case CONST:
      case FLOAT:
      case SHORT:
      case CASE:
      case LONG:
      case AUTO:
      case VOID:
      case CHAR:
      case GOTO:
      case FOR:
      case INT:
      case IF:
      case DO:
      case BOOL_TYPE:
      case CODE:
      case IDENTIFIER:
      case 60:
      case 63:
      case 67:
      case 69:
      case 87:
      case 90:
      case 96:
      case 97:
      case 100:
      case 101:
      case 102:
      case 103:{
        StatementList();
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      jj_consume_token(70);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void StatementList() throws ParseException {/*@bgen(jjtree) StatementList */
  ASTStatementList jjtn000 = new ASTStatementList(JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_9:
      while (true) {
        Statement();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case CONTINUE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DFLT:
        case DOUBLE:
        case SIZEOF:
        case SWITCH:
        case RETURN:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case WHILE:
        case BREAK:
        case CONST:
        case FLOAT:
        case SHORT:
        case CASE:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case GOTO:
        case FOR:
        case INT:
        case IF:
        case DO:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 60:
        case 63:
        case 67:
        case 69:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          ;
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          break label_9;
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void SelectionStatement() throws ParseException {/*@bgen(jjtree) SelectionStatement */
  ASTSelectionStatement jjtn000 = new ASTSelectionStatement(JJTSELECTIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IF:{
        jj_consume_token(IF);
        jj_consume_token(63);
        Expression();
        jj_consume_token(64);
        Statement();
        if (jj_2_16(2)) {
          jj_consume_token(ELSE);
          Statement();
        } else {
          ;
        }
        break;
        }
      case SWITCH:{
        jj_consume_token(SWITCH);
        jj_consume_token(63);
        Expression();
        jj_consume_token(64);
        Statement();
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void IterationStatement() throws ParseException {/*@bgen(jjtree) IterationStatement */
  ASTIterationStatement jjtn000 = new ASTIterationStatement(JJTITERATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WHILE:{
        jj_consume_token(WHILE);
        jj_consume_token(63);
        Expression();
        jj_consume_token(64);
        Statement();
        break;
        }
      case DO:{
        jj_consume_token(DO);
        Statement();
        jj_consume_token(WHILE);
        jj_consume_token(63);
        Expression();
        jj_consume_token(64);
        jj_consume_token(60);
        break;
        }
      case FOR:{
        jj_consume_token(FOR);
        jj_consume_token(63);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DOUBLE:
        case SIZEOF:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case CONST:
        case FLOAT:
        case SHORT:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case INT:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          Expression();
          break;
          }
        default:
          jj_la1[39] = jj_gen;
          ;
        }
        jj_consume_token(60);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DOUBLE:
        case SIZEOF:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case CONST:
        case FLOAT:
        case SHORT:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case INT:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          Expression();
          break;
          }
        default:
          jj_la1[40] = jj_gen;
          ;
        }
        jj_consume_token(60);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DOUBLE:
        case SIZEOF:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case CONST:
        case FLOAT:
        case SHORT:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case INT:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          Expression();
          break;
          }
        default:
          jj_la1[41] = jj_gen;
          ;
        }
        jj_consume_token(64);
        Statement();
        break;
        }
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void JumpStatement() throws ParseException {/*@bgen(jjtree) JumpStatement */
  ASTJumpStatement jjtn000 = new ASTJumpStatement(JJTJUMPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GOTO:{
        jj_consume_token(GOTO);
        Identifier();
        jj_consume_token(60);
        break;
        }
      case CONTINUE:{
        jj_consume_token(CONTINUE);
        jj_consume_token(60);
        break;
        }
      case BREAK:{
        jj_consume_token(BREAK);
        jj_consume_token(60);
        break;
        }
      case RETURN:{
        jj_consume_token(RETURN);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case UNDEFINED_TYPE:
        case VOLATILE:
        case REGISTER:
        case UNSIGNED:
        case TYPEDEF:
        case DOUBLE:
        case SIZEOF:
        case EXTERN:
        case STATIC:
        case SIGNED:
        case CONST:
        case FLOAT:
        case SHORT:
        case LONG:
        case AUTO:
        case VOID:
        case CHAR:
        case INT:
        case BOOL_TYPE:
        case CODE:
        case IDENTIFIER:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          Expression();
          break;
          }
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        jj_consume_token(60);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void Expression() throws ParseException {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case BOOLEAN:
      case SIZEOF:
      case IDENTIFIER:
      case 63:
      case 67:
      case 87:
      case 90:
      case 96:
      case 97:
      case 100:
      case 101:
      case 102:
      case 103:{
        AssignmentExpression();
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 61:{
            ;
            break;
            }
          default:
            jj_la1[45] = jj_gen;
            break label_10;
          }
          jj_consume_token(61);
          AssignmentExpression();
        }
        break;
        }
      case UNDEFINED_TYPE:
      case VOLATILE:
      case REGISTER:
      case UNSIGNED:
      case TYPEDEF:
      case DOUBLE:
      case EXTERN:
      case STATIC:
      case SIGNED:
      case CONST:
      case FLOAT:
      case SHORT:
      case LONG:
      case AUTO:
      case VOID:
      case CHAR:
      case INT:
      case BOOL_TYPE:
      case CODE:{
        DeclarationSpecifiers();
        InitDeclaratorList();
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void AssignmentExpression() throws ParseException {/*@bgen(jjtree) AssignmentExpression */
  ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_17(2147483647)) {
        UnaryExpression();
        AssignmentOperator();
        AssignmentExpression();
      } else if (jj_2_18(3)) {
        ConditionalExpression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void AssignmentOperator() throws ParseException {/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 62:{
        t = jj_consume_token(62);
        break;
        }
      case 72:{
        t = jj_consume_token(72);
        break;
        }
      case 73:{
        t = jj_consume_token(73);
        break;
        }
      case 74:{
        t = jj_consume_token(74);
        break;
        }
      case 75:{
        t = jj_consume_token(75);
        break;
        }
      case 76:{
        t = jj_consume_token(76);
        break;
        }
      case 77:{
        t = jj_consume_token(77);
        break;
        }
      case 78:{
        t = jj_consume_token(78);
        break;
        }
      case 79:{
        t = jj_consume_token(79);
        break;
        }
      case 80:{
        t = jj_consume_token(80);
        break;
        }
      case 81:{
        t = jj_consume_token(81);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ConditionalExpression() throws ParseException {/*@bgen(jjtree) ConditionalExpression */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      LogicalORExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 82:{
        jj_consume_token(82);
        Expression();
        jj_consume_token(71);
        ConditionalExpression();
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ConstantExpression() throws ParseException {/*@bgen(jjtree) ConstantExpression */
  ASTConstantExpression jjtn000 = new ASTConstantExpression(JJTCONSTANTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ConditionalExpression();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void LogicalORExpression() throws ParseException {/*@bgen(jjtree) LogicalORExpression */
  ASTLogicalORExpression jjtn000 = new ASTLogicalORExpression(JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      LogicalANDExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 83:{
        jj_consume_token(83);
        LogicalORExpression();
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void LogicalANDExpression() throws ParseException {/*@bgen(jjtree) LogicalANDExpression */
  ASTLogicalANDExpression jjtn000 = new ASTLogicalANDExpression(JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      InclusiveORExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 84:{
        jj_consume_token(84);
        LogicalANDExpression();
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void InclusiveORExpression() throws ParseException {/*@bgen(jjtree) InclusiveORExpression */
  ASTInclusiveORExpression jjtn000 = new ASTInclusiveORExpression(JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExclusiveORExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 85:{
        jj_consume_token(85);
        InclusiveORExpression();
        break;
        }
      default:
        jj_la1[51] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ExclusiveORExpression() throws ParseException {/*@bgen(jjtree) ExclusiveORExpression */
  ASTExclusiveORExpression jjtn000 = new ASTExclusiveORExpression(JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ANDExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 86:{
        jj_consume_token(86);
        ExclusiveORExpression();
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ANDExpression() throws ParseException {/*@bgen(jjtree) ANDExpression */
  ASTANDExpression jjtn000 = new ASTANDExpression(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      EqualityExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 87:{
        jj_consume_token(87);
        ANDExpression();
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void EqualityExpression() throws ParseException {/*@bgen(jjtree) EqualityExpression */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      RelationalExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 88:
      case 89:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 88:{
          jj_consume_token(88);
          break;
          }
        case 89:{
          jj_consume_token(89);
          break;
          }
        default:
          jj_la1[54] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        EqualityExpression();
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void RelationalExpression() throws ParseException {/*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ShiftExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 90:
      case 91:
      case 92:
      case 93:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 90:{
          jj_consume_token(90);
          break;
          }
        case 91:{
          jj_consume_token(91);
          break;
          }
        case 92:{
          jj_consume_token(92);
          break;
          }
        case 93:{
          jj_consume_token(93);
          break;
          }
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        RelationalExpression();
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ShiftExpression() throws ParseException {/*@bgen(jjtree) ShiftExpression */
  ASTShiftExpression jjtn000 = new ASTShiftExpression(JJTSHIFTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AdditiveExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 94:
      case 95:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 94:{
          jj_consume_token(94);
          break;
          }
        case 95:{
          jj_consume_token(95);
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        ShiftExpression();
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void AdditiveExpression() throws ParseException {/*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      MultiplicativeExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 96:
      case 97:{
        AdditionOperator();
        AdditiveExpression();
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void AdditionOperator() throws ParseException {/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 96:{
        t = jj_consume_token(96);
        break;
        }
      case 97:{
        t = jj_consume_token(97);
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void MultiplicativeExpression() throws ParseException {/*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      CastExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 67:
      case 98:
      case 99:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 67:{
          jj_consume_token(67);
          break;
          }
        case 98:{
          jj_consume_token(98);
          break;
          }
        case 99:{
          jj_consume_token(99);
          break;
          }
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        MultiplicativeExpression();
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void CastExpression() throws ParseException {/*@bgen(jjtree) CastExpression */
  ASTCastExpression jjtn000 = new ASTCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_19(2147483647)) {
        jj_consume_token(63);
        TypeName();
        jj_consume_token(64);
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case BOOLEAN:
        case SIZEOF:
        case IDENTIFIER:
        case 63:
        case 67:
        case 87:
        case 90:
        case 96:
        case 97:
        case 100:
        case 101:
        case 102:
        case 103:{
          UnaryExpression();
          break;
          }
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void UnaryExpression() throws ParseException {/*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_21(3)) {
        PostfixExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 100:{
          jj_consume_token(100);
          UnaryExpression();
          break;
          }
        case 101:{
          jj_consume_token(101);
          UnaryExpression();
          break;
          }
        case 67:
        case 87:
        case 96:
        case 97:
        case 102:
        case 103:{
          UnaryOperator();
          CastExpression();
          break;
          }
        case SIZEOF:{
          jj_consume_token(SIZEOF);
          if (jj_2_20(2147483647)) {
            UnaryExpression();
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 63:{
              jj_consume_token(63);
              TypeName();
              jj_consume_token(64);
              break;
              }
            default:
              jj_la1[65] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
          }
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void UnaryOperator() throws ParseException {/*@bgen(jjtree) UnaryOperator */
  ASTUnaryOperator jjtn000 = new ASTUnaryOperator(JJTUNARYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 87:{
        jj_consume_token(87);
        break;
        }
      case 67:{
        jj_consume_token(67);
        break;
        }
      case 96:{
        jj_consume_token(96);
        break;
        }
      case 97:{
        jj_consume_token(97);
        break;
        }
      case 102:{
        jj_consume_token(102);
        break;
        }
      case 103:{
        jj_consume_token(103);
        break;
        }
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void PostfixExpression() throws ParseException {/*@bgen(jjtree) PostfixExpression */
        ASTPostfixExpression jjtn000 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);int choice = 0;
    try {
      PrimaryExpression();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 63:
        case 65:
        case 100:
        case 101:
        case 104:
        case 105:{
          ;
          break;
          }
        default:
          jj_la1[68] = jj_gen;
          break label_11;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 65:{
          jj_consume_token(65);
          Expression();
          jj_consume_token(66);
choice = 1;
          break;
          }
        case 63:{
          jj_consume_token(63);
          if (jj_2_22(2147483647)) {
            ArgumentExpressionList();
          } else {
            ;
          }
          jj_consume_token(64);
choice = 2;
          break;
          }
        case 104:{
          jj_consume_token(104);
          Identifier();
choice = 3;
          break;
          }
        case 105:{
          jj_consume_token(105);
          Identifier();
          break;
          }
        case 100:{
choice = 4;
          jj_consume_token(100);
          break;
          }
        case 101:{
choice = 5;
          jj_consume_token(101);
choice = 6;
          break;
          }
        default:
          jj_la1[69] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.choice = choice;
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void PrimaryExpression() throws ParseException {/*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case 90:{
        Identifier();
        break;
        }
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case BOOLEAN:{
        Constant();
        break;
        }
      case 63:{
        jj_consume_token(63);
        Expression();
        jj_consume_token(64);
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public void ArgumentExpressionList() throws ParseException {/*@bgen(jjtree) ArgumentExpressionList */
  ASTArgumentExpressionList jjtn000 = new ASTArgumentExpressionList(JJTARGUMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AssignmentExpression();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 61:{
          ;
          break;
          }
        default:
          jj_la1[71] = jj_gen;
          break label_12;
        }
        jj_consume_token(61);
        AssignmentExpression();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  final public ASTStringToken Identifier() throws ParseException {/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token r = null;
        ASTStringToken t = null;
        Token s = null;
        int choice;
    try {
      if (jj_2_23(2147483647)) {
        r = jj_consume_token(IDENTIFIER);
choice = 0;
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case 90:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IDENTIFIER:{
            r = jj_consume_token(IDENTIFIER);
            break;
            }
          default:
            jj_la1[72] = jj_gen;
            ;
          }
          jj_consume_token(90);
          t = Identifier();
          jj_consume_token(91);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IDENTIFIER:{
            s = jj_consume_token(IDENTIFIER);
            break;
            }
          default:
            jj_la1[73] = jj_gen;
            ;
          }
choice = 1;
          break;
          }
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
if (choice == 1) {
                        jjtn000.setValue((r != null ? r.image : "") + "<" + t.getValue() + ">" + (s != null ? s.image : ""));
                } else {
                        jjtn000.setValue(r.image);
                }

                {if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
}

  final public void Constant() throws ParseException {/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:{
        t = jj_consume_token(INTEGER_LITERAL);
        break;
        }
      case FLOATING_POINT_LITERAL:{
        t = jj_consume_token(FLOATING_POINT_LITERAL);
        break;
        }
      case CHARACTER_LITERAL:{
        t = jj_consume_token(CHARACTER_LITERAL);
        break;
        }
      case STRING_LITERAL:{
        t = jj_consume_token(STRING_LITERAL);
        break;
        }
      case BOOLEAN:{
        t = jj_consume_token(BOOLEAN);
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
jjtn000.setValue(t.image);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_3R_ConditionalExpression_371_9_27()
 {
    if (jj_3R_LogicalORExpression_381_9_59()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ConditionalExpression_371_33_60()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_Statement_294_9_24()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    if (jj_3R_AssignmentOperator_363_9_26()) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_363_9_26()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_ConditionalExpression_371_9_27()) return true;
    return false;
  }

  private boolean jj_3R_AssignmentExpression_354_9_66()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AssignmentExpression_354_9_104()) {
    jj_scanpos = xsp;
    if (jj_3_18()) return true;
    }
    return false;
  }

  private boolean jj_3R_AssignmentExpression_354_9_104()
 {
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    if (jj_3R_AssignmentOperator_363_9_26()) return true;
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    return false;
  }

  private boolean jj_3R_Expression_349_9_94()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Expression_349_9_129()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_349_66_130()) return true;
    }
    return false;
  }

  private boolean jj_3R_Expression_349_9_129()
 {
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_Expression_349_34_145()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_JumpStatement_344_9_126()
 {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  private boolean jj_3R_JumpStatement_341_11_123()
 {
    if (jj_scan_token(GOTO)) return true;
    return false;
  }

  private boolean jj_3R_JumpStatement_343_9_125()
 {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  private boolean jj_3R_JumpStatement_342_9_124()
 {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  private boolean jj_3R_JumpStatement_341_9_88()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_JumpStatement_341_11_123()) {
    jj_scanpos = xsp;
    if (jj_3R_JumpStatement_342_9_124()) {
    jj_scanpos = xsp;
    if (jj_3R_JumpStatement_343_9_125()) {
    jj_scanpos = xsp;
    if (jj_3R_JumpStatement_344_9_126()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_IterationStatement_334_11_120()
 {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  private boolean jj_3R_IterationStatement_336_9_122()
 {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  private boolean jj_3R_IterationStatement_335_9_121()
 {
    if (jj_scan_token(DO)) return true;
    return false;
  }

  private boolean jj_3R_IterationStatement_334_9_87()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_IterationStatement_334_11_120()) {
    jj_scanpos = xsp;
    if (jj_3R_IterationStatement_335_9_121()) {
    jj_scanpos = xsp;
    if (jj_3R_IterationStatement_336_9_122()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_289_52_157()
 {
    if (jj_3R_ParameterTypeList_242_9_16()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_3R_DeclarationList_152_9_23()) return true;
    return false;
  }

  private boolean jj_3R_SelectionStatement_328_11_118()
 {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  private boolean jj_3R_SelectionStatement_329_9_119()
 {
    if (jj_scan_token(SWITCH)) return true;
    return false;
  }

  private boolean jj_3R_SelectionStatement_328_9_86()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_SelectionStatement_328_11_118()) {
    jj_scanpos = xsp;
    if (jj_3R_SelectionStatement_329_9_119()) return true;
    }
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_289_46_152()
 {
    if (jj_scan_token(63)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectAbstractDeclarator_289_52_157()) jj_scanpos = xsp;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_ParameterDeclaration_252_76_134()
 {
    if (jj_3R_AbstractDeclarator_279_9_21()) return true;
    return false;
  }

  private boolean jj_3R_ParameterDeclaration_252_74_108()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ParameterDeclaration_252_76_134()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_CompoundStatement_316_9_85()
 {
    if (jj_scan_token(69)) return true;
    return false;
  }

  private boolean jj_3R_ExpressionStatement_311_11_117()
 {
    if (jj_3R_Expression_349_9_94()) return true;
    return false;
  }

  private boolean jj_3R_ExpressionStatement_311_9_84()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ExpressionStatement_311_11_117()) jj_scanpos = xsp;
    if (jj_scan_token(60)) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_3R_Identifier_495_9_22()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_LabeledStatement_304_11_114()
 {
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3R_LabeledStatement_306_9_116()
 {
    if (jj_scan_token(DFLT)) return true;
    return false;
  }

  private boolean jj_3R_LabeledStatement_305_9_115()
 {
    if (jj_scan_token(CASE)) return true;
    return false;
  }

  private boolean jj_3R_LabeledStatement_304_9_83()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_LabeledStatement_304_11_114()) {
    jj_scanpos = xsp;
    if (jj_3R_LabeledStatement_305_9_115()) {
    jj_scanpos = xsp;
    if (jj_3R_LabeledStatement_306_9_116()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_TypeName_273_36_61()
 {
    if (jj_3R_AbstractDeclarator_279_9_21()) return true;
    return false;
  }

  private boolean jj_3R_Statement_299_9_54()
 {
    if (jj_3R_JumpStatement_341_9_88()) return true;
    return false;
  }

  private boolean jj_3R_Statement_298_9_53()
 {
    if (jj_3R_IterationStatement_334_9_87()) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_289_17_156()
 {
    if (jj_3R_ConstantExpression_376_9_139()) return true;
    return false;
  }

  private boolean jj_3R_Statement_297_9_52()
 {
    if (jj_3R_SelectionStatement_328_9_86()) return true;
    return false;
  }

  private boolean jj_3R_Statement_296_9_51()
 {
    if (jj_3R_CompoundStatement_316_9_85()) return true;
    return false;
  }

  private boolean jj_3R_Statement_294_11_49()
 {
    if (jj_3R_LabeledStatement_304_9_83()) return true;
    return false;
  }

  private boolean jj_3R_Statement_295_9_50()
 {
    if (jj_3R_ExpressionStatement_311_9_84()) return true;
    return false;
  }

  private boolean jj_3R_Statement_294_9_24()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Statement_294_11_49()) {
    jj_scanpos = xsp;
    if (jj_3R_Statement_295_9_50()) {
    jj_scanpos = xsp;
    if (jj_3R_Statement_296_9_51()) {
    jj_scanpos = xsp;
    if (jj_3R_Statement_297_9_52()) {
    jj_scanpos = xsp;
    if (jj_3R_Statement_298_9_53()) {
    jj_scanpos = xsp;
    if (jj_3R_Statement_299_9_54()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_287_14_150()
 {
    if (jj_3R_ParameterTypeList_242_9_16()) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_289_11_151()
 {
    if (jj_scan_token(65)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectAbstractDeclarator_289_17_156()) jj_scanpos = xsp;
    if (jj_scan_token(66)) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_286_14_149()
 {
    if (jj_3R_ConstantExpression_376_9_139()) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_289_11_144()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectAbstractDeclarator_289_11_151()) {
    jj_scanpos = xsp;
    if (jj_3R_DirectAbstractDeclarator_289_46_152()) return true;
    }
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_Declarator_219_9_18()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_AbstractDeclarator_279_9_21()) return true;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_287_9_113()
 {
    if (jj_scan_token(63)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectAbstractDeclarator_287_14_150()) jj_scanpos = xsp;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_286_9_112()
 {
    if (jj_scan_token(65)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectAbstractDeclarator_286_14_149()) jj_scanpos = xsp;
    if (jj_scan_token(66)) return true;
    return false;
  }

  private boolean jj_3R_DirectAbstractDeclarator_285_9_82()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_DirectAbstractDeclarator_286_9_112()) {
    jj_scanpos = xsp;
    if (jj_3R_DirectAbstractDeclarator_287_9_113()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_DirectAbstractDeclarator_289_11_144()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_Initializer_262_9_19()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_3R_Pointer_232_9_20()) return true;
    return false;
  }

  private boolean jj_3R_AbstractDeclarator_280_10_81()
 {
    if (jj_3R_Pointer_232_9_20()) return true;
    return false;
  }

  private boolean jj_3R_AbstractDeclarator_280_9_45()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AbstractDeclarator_280_10_81()) jj_scanpos = xsp;
    if (jj_3R_DirectAbstractDeclarator_285_9_82()) return true;
    return false;
  }

  private boolean jj_3R_AbstractDeclarator_279_9_21()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_AbstractDeclarator_280_9_45()) return true;
    }
    return false;
  }

  private boolean jj_3R_ParameterDeclaration_252_35_107()
 {
    if (jj_3R_Declarator_219_9_18()) return true;
    return false;
  }

  private boolean jj_3R_TypeName_273_9_28()
 {
    if (jj_3R_SpecifierQualifierList_211_9_15()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_TypeName_273_36_61()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_IdentifierList_257_23_146()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_ParameterDeclaration_252_9_17()) return true;
    return false;
  }

  private boolean jj_3R_InitializerList_268_9_153()
 {
    if (jj_3R_Initializer_262_9_19()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_Initializer_262_11_41()
 {
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    return false;
  }

  private boolean jj_3R_Initializer_263_9_42()
 {
    if (jj_scan_token(69)) return true;
    if (jj_3R_InitializerList_268_9_153()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(61)) jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    return false;
  }

  private boolean jj_3R_Pointer_232_39_44()
 {
    if (jj_3R_Pointer_232_9_20()) return true;
    return false;
  }

  private boolean jj_3R_Initializer_262_9_19()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Initializer_262_11_41()) {
    jj_scanpos = xsp;
    if (jj_3R_Initializer_263_9_42()) return true;
    }
    return false;
  }

  private boolean jj_3R_ParameterTypeList_242_26_140()
 {
    if (jj_scan_token(61)) return true;
    if (jj_scan_token(68)) return true;
    return false;
  }

  private boolean jj_3R_IdentifierList_257_9_141()
 {
    if (jj_3R_Identifier_495_9_22()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_IdentifierList_257_23_146()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_ParameterDeclaration_252_9_17()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ParameterDeclaration_252_35_107()) {
    jj_scanpos = xsp;
    if (jj_3R_ParameterDeclaration_252_74_108()) return true;
    }
    return false;
  }

  private boolean jj_3R_ParameterList_247_9_38()
 {
    if (jj_3R_ParameterDeclaration_252_9_17()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_ParameterTypeList_242_9_16()
 {
    if (jj_3R_ParameterList_247_9_38()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ParameterTypeList_242_26_140()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_SpecifierQualifierList_211_9_15()) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_224_26_78()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_Declarator_219_9_18()) return true;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_SpecifierQualifierList_211_9_15()) return true;
    return false;
  }

  private boolean jj_3R_Pointer_232_15_43()
 {
    if (jj_3R_TypeQualifierList_237_9_80()) return true;
    return false;
  }

  private boolean jj_3R_TypeQualifierList_237_10_111()
 {
    if (jj_3R_TypeQualifier_193_9_72()) return true;
    return false;
  }

  private boolean jj_3R_TypeQualifierList_237_9_80()
 {
    Token xsp;
    if (jj_3R_TypeQualifierList_237_10_111()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_TypeQualifierList_237_10_111()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_DirectDeclarator_227_15_136()
 {
    if (jj_3R_IdentifierList_257_9_141()) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_225_17_135()
 {
    if (jj_3R_ConstantExpression_376_9_139()) return true;
    return false;
  }

  private boolean jj_3R_Pointer_232_9_20()
 {
    if (jj_scan_token(67)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Pointer_232_15_43()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_Pointer_232_39_44()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_SpecifierQualifierList_213_27_76()
 {
    if (jj_3R_SpecifierQualifierList_211_9_15()) return true;
    return false;
  }

  private boolean jj_3R_SpecifierQualifierList_211_27_75()
 {
    if (jj_3R_SpecifierQualifierList_211_9_15()) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_225_11_79()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectDeclarator_225_11_109()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_DirectDeclarator_227_9_110()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_DirectDeclarator_225_11_109()
 {
    if (jj_scan_token(65)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectDeclarator_225_17_135()) jj_scanpos = xsp;
    if (jj_scan_token(66)) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_227_9_110()
 {
    if (jj_scan_token(63)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectDeclarator_227_15_136()) jj_scanpos = xsp;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_ParameterTypeList_242_9_16()) return true;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_224_11_77()
 {
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3R_DirectDeclarator_224_9_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DirectDeclarator_224_11_77()) {
    jj_scanpos = xsp;
    if (jj_3R_DirectDeclarator_224_26_78()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_DirectDeclarator_225_11_79()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_InitDeclarator_206_24_133()
 {
    if (jj_scan_token(62)) return true;
    if (jj_3R_Initializer_262_9_19()) return true;
    return false;
  }

  private boolean jj_3R_Declarator_219_11_39()
 {
    if (jj_3R_Pointer_232_9_20()) return true;
    return false;
  }

  private boolean jj_3R_Declarator_219_9_18()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Declarator_219_11_39()) jj_scanpos = xsp;
    if (jj_3R_DirectDeclarator_224_9_40()) return true;
    return false;
  }

  private boolean jj_3R_InitDeclaratorList_201_27_106()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_InitDeclarator_206_9_105()) return true;
    return false;
  }

  private boolean jj_3R_SpecifierQualifierList_213_9_37()
 {
    if (jj_3R_TypeQualifier_193_9_72()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_SpecifierQualifierList_213_27_76()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_SpecifierQualifierList_211_9_36()
 {
    if (jj_3R_TypeSpecifier_181_9_70()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_SpecifierQualifierList_211_27_75()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_SpecifierQualifierList_211_9_15()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_SpecifierQualifierList_211_9_36()) {
    jj_scanpos = xsp;
    if (jj_3R_SpecifierQualifierList_213_9_37()) return true;
    }
    return false;
  }

  private boolean jj_3R_InitDeclarator_206_9_105()
 {
    if (jj_3R_Declarator_219_9_18()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_InitDeclarator_206_24_133()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_InitDeclaratorList_201_9_74()
 {
    if (jj_3R_InitDeclarator_206_9_105()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_InitDeclaratorList_201_27_106()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_TypeQualifier_193_9_72()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) return true;
    }
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_157_35_69()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_TypeSpecifier_181_9_70()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_161_27_73()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_159_28_71()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_Declaration_147_35_35()
 {
    if (jj_3R_InitDeclaratorList_201_9_74()) return true;
    return false;
  }

  private boolean jj_3R_Identifier_495_69_47()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(56)) jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    if (jj_3R_Identifier_495_9_22()) return true;
    if (jj_scan_token(91)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(56)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_StorageClassSpecifier_170_9_68()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_Declaration_147_9_14()) return true;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_161_9_34()
 {
    if (jj_3R_TypeQualifier_193_9_72()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DeclarationSpecifiers_161_27_73()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_159_9_33()
 {
    if (jj_3R_TypeSpecifier_181_9_70()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DeclarationSpecifiers_159_28_71()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_157_9_32()
 {
    if (jj_3R_StorageClassSpecifier_170_9_68()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DeclarationSpecifiers_157_35_69()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_DeclarationSpecifiers_157_9_13()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_DeclarationSpecifiers_157_9_32()) {
    jj_scanpos = xsp;
    if (jj_3R_DeclarationSpecifiers_159_9_33()) {
    jj_scanpos = xsp;
    if (jj_3R_DeclarationSpecifiers_161_9_34()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_DeclarationList_152_11_48()
 {
    if (jj_3R_Declaration_147_9_14()) return true;
    return false;
  }

  private boolean jj_3R_DeclarationList_152_9_23()
 {
    Token xsp;
    if (jj_3R_DeclarationList_152_11_48()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_DeclarationList_152_11_48()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    return false;
  }

  private boolean jj_3R_Declaration_147_9_14()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Declaration_147_35_35()) jj_scanpos = xsp;
    if (jj_scan_token(60)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_452_70_91()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_TypeName_273_9_28()) return true;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_Constant_512_9_131()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_ArgumentExpressionList_484_34_67()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_Identifier_495_10_46()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_Identifier_495_9_22()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Identifier_495_10_46()) {
    jj_scanpos = xsp;
    if (jj_3R_Identifier_495_69_47()) return true;
    }
    return false;
  }

  private boolean jj_3R_PostfixExpression_467_29_102()
 {
    if (jj_scan_token(100)) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_464_31_65()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PostfixExpression_464_31_98()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_465_9_99()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_466_9_100()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_467_9_101()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_467_29_102()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_468_16_103()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_PostfixExpression_464_31_98()
 {
    if (jj_scan_token(65)) return true;
    if (jj_3R_Expression_349_9_94()) return true;
    if (jj_scan_token(66)) return true;
    return false;
  }

  private boolean jj_3R_ArgumentExpressionList_484_9_31()
 {
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ArgumentExpressionList_484_34_67()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_3R_ArgumentExpressionList_484_9_31()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryExpression_477_11_95()
 {
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryExpression_479_9_97()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_Expression_349_9_94()) return true;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_PrimaryExpression_478_9_96()
 {
    if (jj_3R_Constant_512_9_131()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryExpression_477_9_64()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PrimaryExpression_477_11_95()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryExpression_478_9_96()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryExpression_479_9_97()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_PostfixExpression_468_16_103()
 {
    if (jj_scan_token(101)) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_465_15_132()
 {
    if (jj_3R_ArgumentExpressionList_484_9_31()) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_467_9_101()
 {
    if (jj_scan_token(105)) return true;
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_466_9_100()
 {
    if (jj_scan_token(104)) return true;
    if (jj_3R_Identifier_495_9_22()) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_465_9_99()
 {
    if (jj_scan_token(63)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PostfixExpression_465_15_132()) jj_scanpos = xsp;
    if (jj_scan_token(64)) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_464_9_30()
 {
    if (jj_3R_PrimaryExpression_477_9_64()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_PostfixExpression_464_31_65()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_UnaryExpression_452_20_90()
 {
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    return false;
  }

  private boolean jj_3R_UnaryOperator_457_9_89()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_437_28_164()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    }
    }
    if (jj_3R_MultiplicativeExpression_437_9_162()) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_TypeName_273_9_28()) return true;
    if (jj_scan_token(64)) return true;
    if (jj_3R_CastExpression_442_9_29()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_452_9_58()
 {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_UnaryExpression_452_20_90()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_452_70_91()) return true;
    }
    return false;
  }

  private boolean jj_3R_UnaryExpression_451_9_57()
 {
    if (jj_3R_UnaryOperator_457_9_89()) return true;
    if (jj_3R_CastExpression_442_9_29()) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_421_38_163()
 {
    if (jj_3R_AdditionOperator_429_9_165()) return true;
    if (jj_3R_AdditiveExpression_421_9_160()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_450_9_56()
 {
    if (jj_scan_token(101)) return true;
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_3R_PostfixExpression_464_9_30()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_449_9_55()
 {
    if (jj_scan_token(100)) return true;
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_448_9_25()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_449_9_55()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_450_9_56()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_451_9_57()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_452_9_58()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_CastExpression_442_11_62()
 {
    if (jj_scan_token(63)) return true;
    if (jj_3R_TypeName_273_9_28()) return true;
    if (jj_scan_token(64)) return true;
    if (jj_3R_CastExpression_442_9_29()) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_443_9_63()
 {
    if (jj_3R_UnaryExpression_448_9_25()) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_442_9_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_CastExpression_442_11_62()) {
    jj_scanpos = xsp;
    if (jj_3R_CastExpression_443_9_63()) return true;
    }
    return false;
  }

  private boolean jj_3R_ShiftExpression_416_32_161()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    if (jj_3R_ShiftExpression_416_9_158()) return true;
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_437_9_162()
 {
    if (jj_3R_CastExpression_442_9_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_MultiplicativeExpression_437_28_164()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_RelationalExpression_411_29_159()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) return true;
    }
    }
    }
    if (jj_3R_RelationalExpression_411_9_154()) return true;
    return false;
  }

  private boolean jj_3R_EqualityExpression_406_34_155()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    }
    if (jj_3R_EqualityExpression_406_9_147()) return true;
    return false;
  }

  private boolean jj_3R_AdditionOperator_429_9_165()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) return true;
    }
    return false;
  }

  private boolean jj_3R_ANDExpression_401_32_148()
 {
    if (jj_scan_token(87)) return true;
    if (jj_3R_ANDExpression_401_9_142()) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_421_9_160()
 {
    if (jj_3R_MultiplicativeExpression_437_9_162()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AdditiveExpression_421_38_163()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_InclusiveORExpression_391_35_138()
 {
    if (jj_scan_token(85)) return true;
    if (jj_3R_InclusiveORExpression_391_9_127()) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_416_9_158()
 {
    if (jj_3R_AdditiveExpression_421_9_160()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ShiftExpression_416_32_161()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_ExclusiveORExpression_396_27_143()
 {
    if (jj_scan_token(86)) return true;
    if (jj_3R_ExclusiveORExpression_396_9_137()) return true;
    return false;
  }

  private boolean jj_3R_LogicalANDExpression_386_35_128()
 {
    if (jj_scan_token(84)) return true;
    if (jj_3R_LogicalANDExpression_386_9_92()) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_411_9_154()
 {
    if (jj_3R_ShiftExpression_416_9_158()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_RelationalExpression_411_29_159()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_EqualityExpression_406_9_147()
 {
    if (jj_3R_RelationalExpression_411_9_154()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_EqualityExpression_406_34_155()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_LogicalORExpression_381_34_93()
 {
    if (jj_scan_token(83)) return true;
    if (jj_3R_LogicalORExpression_381_9_59()) return true;
    return false;
  }

  private boolean jj_3R_Expression_349_66_130()
 {
    if (jj_3R_DeclarationSpecifiers_157_9_13()) return true;
    if (jj_3R_InitDeclaratorList_201_9_74()) return true;
    return false;
  }

  private boolean jj_3R_ANDExpression_401_9_142()
 {
    if (jj_3R_EqualityExpression_406_9_147()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ANDExpression_401_32_148()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_ExclusiveORExpression_396_9_137()
 {
    if (jj_3R_ANDExpression_401_9_142()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ExclusiveORExpression_396_27_143()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_ConditionalExpression_371_33_60()
 {
    if (jj_scan_token(82)) return true;
    if (jj_3R_Expression_349_9_94()) return true;
    if (jj_scan_token(71)) return true;
    if (jj_3R_ConditionalExpression_371_9_27()) return true;
    return false;
  }

  private boolean jj_3R_InclusiveORExpression_391_9_127()
 {
    if (jj_3R_ExclusiveORExpression_396_9_137()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_InclusiveORExpression_391_35_138()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_LogicalANDExpression_386_9_92()
 {
    if (jj_3R_InclusiveORExpression_391_9_127()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_LogicalANDExpression_386_35_128()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_LogicalORExpression_381_9_59()
 {
    if (jj_3R_LogicalANDExpression_386_9_92()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_LogicalORExpression_381_34_93()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_ConstantExpression_376_9_139()
 {
    if (jj_3R_ConditionalExpression_371_9_27()) return true;
    return false;
  }

  private boolean jj_3R_Expression_349_34_145()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_AssignmentExpression_354_9_66()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public CParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[76];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	   jj_la1_init_3();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x17a00000,0x5000000,0x12200000,0x800000,0x0,0x0,0x12a00000,0x0,0x0,0x0,0x201d1000,0x0,0x0,0x0,0x800000,0x0,0x800000,0x0,0x0,0x0,0x0,0x201d1000,0x0,0x0,0x0,0x201d1000,0x17a00000,0x0,0x0,0x201d1000,0x17a00000,0x0,0xf7fd1000,0x8000000,0x37bd1000,0xfffd1000,0xfffd1000,0x40000000,0x37bd1000,0x37bd1000,0x37bd1000,0x0,0x37bd1000,0x80400000,0x0,0x37bd1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201d1000,0x0,0x20000000,0x0,0x0,0x0,0x1d1000,0x0,0x0,0x0,0x0,0x1d1000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x81000000,0xc9d38d,0x4005,0xc99308,0x80,0x20000000,0x40000000,0xc99388,0x0,0x81000000,0x80000000,0x81000000,0x1000000,0x0,0x80000000,0x80,0x0,0x80,0x20000000,0x80000000,0x20000000,0x20000000,0x81000000,0x80000000,0x0,0x80000000,0x81000000,0xc9d38d,0x80000000,0x80000000,0x81000000,0xc9d38d,0x80000000,0x91ffd3bd,0x1000800,0x81c9d38d,0x91ffdbbd,0x91ffdbbd,0x100000,0x81c9d38d,0x81c9d38d,0x81c9d38d,0x240010,0x81c9d38d,0x20020,0x20000000,0x81c9d38d,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x81000000,0x20000000,0x1000000,0x1000000,0x1000000,0x0,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x4000008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x4000000,0x2,0x4800008,0x4000000,0x2,0x0,0x0,0x8,0x0,0x0,0xa,0x0,0x0,0x4800028,0xa,0x8,0xa,0x4800008,0x0,0x2,0x2,0x4800008,0x0,0x2,0x4800028,0x4000000,0x4800008,0x4800028,0x4800028,0x0,0x4800008,0x4800008,0x4800008,0x0,0x4800008,0x0,0x0,0x4800008,0x3ff00,0x40000,0x80000,0x100000,0x200000,0x400000,0x800000,0x3000000,0x3000000,0x3c000000,0x3c000000,0xc0000000,0xc0000000,0x0,0x0,0x8,0x8,0x4800008,0x0,0x800008,0x800008,0x2,0x2,0x4000000,0x0,0x0,0x0,0x4000000,0x0,};
	}
	private static void jj_la1_init_3() {
	   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0x0,0x0,0x0,0xf3,0x0,0x0,0x0,0xf3,0x0,0x0,0xf3,0x0,0xf3,0xf3,0xf3,0x0,0xf3,0xf3,0xf3,0x0,0xf3,0x0,0x0,0xf3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0xc,0xc,0xf3,0x0,0xf3,0xc3,0x330,0x330,0x0,0x0,0x0,0x0,0x0,0x0,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[23];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new CParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CParser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new CParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new CParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CParser(CParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 76; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[106];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 76; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		   if ((jj_la1_3[i] & (1<<j)) != 0) {
			 la1tokens[96+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 106; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 23; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParserConstants.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree&JavaCC: Do not edit this line. CParserConstants.java */

/**
 * Token literal values and constants.
 * Generated by org.javacc.parser.OtherFilesGen#start()
 */
public interface CParserConstants {

  /** End of File. */
  int EOF = 0;
  /** RegularExpression Id. */
  int INTEGER_LITERAL = 12;
  /** RegularExpression Id. */
  int DECIMAL_LITERAL = 13;
  /** RegularExpression Id. */
  int HEX_LITERAL = 14;
  /** RegularExpression Id. */
  int OCTAL_LITERAL = 15;
  /** RegularExpression Id. */
  int FLOATING_POINT_LITERAL = 16;
  /** RegularExpression Id. */
  int EXPONENT = 17;
  /** RegularExpression Id. */
  int CHARACTER_LITERAL = 18;
  /** RegularExpression Id. */
  int STRING_LITERAL = 19;
  /** RegularExpression Id. */
  int BOOLEAN = 20;
  /** RegularExpression Id. */
  int UNDEFINED_TYPE = 21;
  /** RegularExpression Id. */
  int CONTINUE = 22;
  /** RegularExpression Id. */
  int VOLATILE = 23;
  /** RegularExpression Id. */
  int REGISTER = 24;
  /** RegularExpression Id. */
  int UNSIGNED = 25;
  /** RegularExpression Id. */
  int TYPEDEF = 26;
  /** RegularExpression Id. */
  int DFLT = 27;
  /** RegularExpression Id. */
  int DOUBLE = 28;
  /** RegularExpression Id. */
  int SIZEOF = 29;
  /** RegularExpression Id. */
  int SWITCH = 30;
  /** RegularExpression Id. */
  int RETURN = 31;
  /** RegularExpression Id. */
  int EXTERN = 32;
  /** RegularExpression Id. */
  int STRUCT = 33;
  /** RegularExpression Id. */
  int STATIC = 34;
  /** RegularExpression Id. */
  int SIGNED = 35;
  /** RegularExpression Id. */
  int WHILE = 36;
  /** RegularExpression Id. */
  int BREAK = 37;
  /** RegularExpression Id. */
  int UNION = 38;
  /** RegularExpression Id. */
  int CONST = 39;
  /** RegularExpression Id. */
  int FLOAT = 40;
  /** RegularExpression Id. */
  int SHORT = 41;
  /** RegularExpression Id. */
  int ELSE = 42;
  /** RegularExpression Id. */
  int CASE = 43;
  /** RegularExpression Id. */
  int LONG = 44;
  /** RegularExpression Id. */
  int ENUM = 45;
  /** RegularExpression Id. */
  int AUTO = 46;
  /** RegularExpression Id. */
  int VOID = 47;
  /** RegularExpression Id. */
  int CHAR = 48;
  /** RegularExpression Id. */
  int GOTO = 49;
  /** RegularExpression Id. */
  int FOR = 50;
  /** RegularExpression Id. */
  int INT = 51;
  /** RegularExpression Id. */
  int IF = 52;
  /** RegularExpression Id. */
  int DO = 53;
  /** RegularExpression Id. */
  int BOOL_TYPE = 54;
  /** RegularExpression Id. */
  int CODE = 55;
  /** RegularExpression Id. */
  int IDENTIFIER = 56;
  /** RegularExpression Id. */
  int LETTER = 57;
  /** RegularExpression Id. */
  int DIGIT = 58;
  /** RegularExpression Id. */
  int SEPARATOR = 59;

  /** Lexical state. */
  int DEFAULT = 0;
  /** Lexical state. */
  int PREPROCESSOR_OUTPUT = 1;

  /** Literal token values. */
  String[] tokenImage = {
    "<EOF>",
    "\" \"",
    "\"\\t\"",
    "\"\\n\"",
    "\"\\r\"",
    "<token of kind 5>",
    "<token of kind 6>",
    "\"#\"",
    "\"\\n\"",
    "\"\\\\\\n\"",
    "\"\\\\\\r\\n\"",
    "<token of kind 11>",
    "<INTEGER_LITERAL>",
    "<DECIMAL_LITERAL>",
    "<HEX_LITERAL>",
    "<OCTAL_LITERAL>",
    "<FLOATING_POINT_LITERAL>",
    "<EXPONENT>",
    "<CHARACTER_LITERAL>",
    "<STRING_LITERAL>",
    "<BOOLEAN>",
    "<UNDEFINED_TYPE>",
    "\"continue\"",
    "\"volatile\"",
    "\"register\"",
    "\"unsigned\"",
    "\"typedef\"",
    "\"default\"",
    "\"double\"",
    "\"sizeof\"",
    "\"switch\"",
    "\"return\"",
    "\"extern\"",
    "\"struct\"",
    "\"static\"",
    "\"signed\"",
    "\"while\"",
    "\"break\"",
    "\"union\"",
    "\"const\"",
    "\"float\"",
    "\"short\"",
    "\"else\"",
    "\"case\"",
    "\"long\"",
    "\"enum\"",
    "\"auto\"",
    "\"void\"",
    "\"char\"",
    "\"goto\"",
    "\"for\"",
    "\"int\"",
    "\"if\"",
    "\"do\"",
    "\"bool\"",
    "\"code\"",
    "<IDENTIFIER>",
    "<LETTER>",
    "<DIGIT>",
    "<SEPARATOR>",
    "\";\"",
    "\",\"",
    "\"=\"",
    "\"(\"",
    "\")\"",
    "\"[\"",
    "\"]\"",
    "\"*\"",
    "\"...\"",
    "\"{\"",
    "\"}\"",
    "\":\"",
    "\"*=\"",
    "\"/=\"",
    "\"%=\"",
    "\"+=\"",
    "\"-=\"",
    "\"<<=\"",
    "\">>=\"",
    "\"&=\"",
    "\"^=\"",
    "\"|=\"",
    "\"?\"",
    "\"||\"",
    "\"&&\"",
    "\"|\"",
    "\"^\"",
    "\"&\"",
    "\"==\"",
    "\"!=\"",
    "\"<\"",
    "\">\"",
    "\"<=\"",
    "\">=\"",
    "\"<<\"",
    "\">>\"",
    "\"+\"",
    "\"-\"",
    "\"/\"",
    "\"%\"",
    "\"++\"",
    "\"--\"",
    "\"~\"",
    "\"!\"",
    "\".\"",
    "\"->\"",
  };

}

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParserDefaultVisitor.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. CParserDefaultVisitor.java Version 7.0.9 */
public class CParserDefaultVisitor implements CParserVisitor{
  public Object defaultVisit(SimpleNode node, Object data){
    node.childrenAccept(this, data);
    return data;
  }
  public Object visit(SimpleNode node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTFunctionDefinition node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDeclaration node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDeclarationList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDeclarationSpecifiers node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTGhostStringToken node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTTypeStringToken node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTStringToken node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTInitDeclaratorList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTInitDeclarator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTSpecifierQualifierList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDeclarator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDirectDeclarator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTPointer node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTTypeQualifierList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTParameterTypeList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTParameterList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTParameterDeclaration node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTIdentifierList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTInitializer node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTInitializerList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTTypeName node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTAbstractDeclarator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTDirectAbstractDeclarator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTLabeledStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTExpressionStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTCompoundStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTStatementList node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTSelectionStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTIterationStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTJumpStatement node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTAssignmentExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTConditionalExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTConstantExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTLogicalORExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTLogicalANDExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTInclusiveORExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTExclusiveORExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTANDExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTEqualityExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTRelationalExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTShiftExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTAdditiveExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTMultiplicativeExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTCastExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTUnaryExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTUnaryOperator node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTPostfixExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTPrimaryExpression node, Object data){
    return defaultVisit(node, data);
  }
  public Object visit(ASTArgumentExpressionList node, Object data){
    return defaultVisit(node, data);
  }
}
/* JavaCC - OriginalChecksum=02bd2f1bbfbe0abbaf156b1dcc67f14c (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParserTokenManager.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* CParserTokenManager.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. CParserTokenManager.java */
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import ghidrust.decompiler.parser.c.CVisitor;

/** Token Manager. */
@SuppressWarnings ("unused")
public class CParserTokenManager implements CParserConstants {

  /** Debug output. */
  public  java.io.PrintStream debugStream = System.out;
  /** Set debug output. */
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1){
   switch (pos)
   {
      case 0:
         if ((active1 & 0x80L) != 0L)
            return 51;
         if ((active1 & 0x10000000010L) != 0L)
            return 4;
         if ((active0 & 0x4010000000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 35;
         }
         if ((active0 & 0x4000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 31;
         }
         if ((active0 & 0x4002000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 46;
         }
         if ((active0 & 0xfbfebff9c00000L) != 0L)
         {
            jjmatchedKind = 56;
            return 84;
         }
         if ((active1 & 0x400000200L) != 0L)
            return 73;
         return -1;
      case 1:
         if ((active0 & 0x30000010000000L) != 0L)
            return 84;
         if ((active0 & 0x4002000000L) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 56;
               jjmatchedPos = 1;
            }
            return 45;
         }
         if ((active0 & 0xcfffbfedc00000L) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 56;
               jjmatchedPos = 1;
            }
            return 84;
         }
         return -1;
      case 2:
         if ((active0 & 0xc000000000000L) != 0L)
            return 84;
         if ((active0 & 0xc3ffffffc00000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 2;
            return 84;
         }
         return -1;
      case 3:
         if ((active0 & 0xc3fc0000000000L) != 0L)
            return 84;
         if ((active0 & 0x3ffffc00000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 3;
            return 84;
         }
         return -1;
      case 4:
         if ((active0 & 0x3f000000000L) != 0L)
            return 84;
         if ((active0 & 0xfffc00000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 4;
            return 84;
         }
         return -1;
      case 5:
         if ((active0 & 0xff0000000L) != 0L)
            return 84;
         if ((active0 & 0xfc00000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 5;
            return 84;
         }
         return -1;
      case 6:
         if ((active0 & 0xc000000L) != 0L)
            return 84;
         if ((active0 & 0x3c00000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 6;
            return 84;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0, long active1){
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
}
private int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private int jjMoveStringLiteralDfa0_0(){
   switch(curChar)
   {
      case 33:
         jjmatchedKind = 103;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000L);
      case 35:
         return jjStopAtPos(0, 7);
      case 37:
         jjmatchedKind = 99;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x400L);
      case 38:
         jjmatchedKind = 87;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x108000L);
      case 40:
         return jjStopAtPos(0, 63);
      case 41:
         return jjStopAtPos(0, 64);
      case 42:
         jjmatchedKind = 67;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x100L);
      case 43:
         jjmatchedKind = 96;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000800L);
      case 44:
         return jjStopAtPos(0, 61);
      case 45:
         jjmatchedKind = 97;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x22000001000L);
      case 46:
         jjmatchedKind = 104;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x10L);
      case 47:
         jjmatchedKind = 98;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
      case 58:
         return jjStartNfaWithStates_0(0, 71, 51);
      case 59:
         return jjStopAtPos(0, 60);
      case 60:
         jjmatchedKind = 90;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x50002000L);
      case 61:
         jjmatchedKind = 62;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000L);
      case 62:
         jjmatchedKind = 91;
         return jjMoveStringLiteralDfa1_0(0x0L, 0xa0004000L);
      case 63:
         return jjStopAtPos(0, 82);
      case 91:
         return jjStopAtPos(0, 65);
      case 93:
         return jjStopAtPos(0, 66);
      case 94:
         jjmatchedKind = 86;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000L);
      case 97:
         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L);
      case 98:
         return jjMoveStringLiteralDfa1_0(0x40002000000000L, 0x0L);
      case 99:
         return jjMoveStringLiteralDfa1_0(0x81088000400000L, 0x0L);
      case 100:
         return jjMoveStringLiteralDfa1_0(0x20000018000000L, 0x0L);
      case 101:
         return jjMoveStringLiteralDfa1_0(0x240100000000L, 0x0L);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x4010000000000L, 0x0L);
      case 103:
         return jjMoveStringLiteralDfa1_0(0x2000000000000L, 0x0L);
      case 105:
         return jjMoveStringLiteralDfa1_0(0x18000000000000L, 0x0L);
      case 108:
         return jjMoveStringLiteralDfa1_0(0x100000000000L, 0x0L);
      case 114:
         return jjMoveStringLiteralDfa1_0(0x81000000L, 0x0L);
      case 115:
         return jjMoveStringLiteralDfa1_0(0x20e60000000L, 0x0L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0x4000000L, 0x0L);
      case 117:
         return jjMoveStringLiteralDfa1_0(0x4002000000L, 0x0L);
      case 118:
         return jjMoveStringLiteralDfa1_0(0x800000800000L, 0x0L);
      case 119:
         return jjMoveStringLiteralDfa1_0(0x1000000000L, 0x0L);
      case 123:
         return jjStopAtPos(0, 69);
      case 124:
         jjmatchedKind = 85;
         return jjMoveStringLiteralDfa1_0(0x0L, 0xa0000L);
      case 125:
         return jjStopAtPos(0, 70);
      case 126:
         return jjStopAtPos(0, 102);
      default :
         return jjMoveNfa_0(0, 0);
   }
}
private int jjMoveStringLiteralDfa1_0(long active0, long active1){
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0, active1);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active1 & 0x100000L) != 0L)
            return jjStopAtPos(1, 84);
         break;
      case 43:
         if ((active1 & 0x1000000000L) != 0L)
            return jjStopAtPos(1, 100);
         break;
      case 45:
         if ((active1 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 101);
         break;
      case 46:
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10L);
      case 60:
         if ((active1 & 0x40000000L) != 0L)
         {
            jjmatchedKind = 94;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x2000L);
      case 61:
         if ((active1 & 0x100L) != 0L)
            return jjStopAtPos(1, 72);
         else if ((active1 & 0x200L) != 0L)
            return jjStopAtPos(1, 73);
         else if ((active1 & 0x400L) != 0L)
            return jjStopAtPos(1, 74);
         else if ((active1 & 0x800L) != 0L)
            return jjStopAtPos(1, 75);
         else if ((active1 & 0x1000L) != 0L)
            return jjStopAtPos(1, 76);
         else if ((active1 & 0x8000L) != 0L)
            return jjStopAtPos(1, 79);
         else if ((active1 & 0x10000L) != 0L)
            return jjStopAtPos(1, 80);
         else if ((active1 & 0x20000L) != 0L)
            return jjStopAtPos(1, 81);
         else if ((active1 & 0x1000000L) != 0L)
            return jjStopAtPos(1, 88);
         else if ((active1 & 0x2000000L) != 0L)
            return jjStopAtPos(1, 89);
         else if ((active1 & 0x10000000L) != 0L)
            return jjStopAtPos(1, 92);
         else if ((active1 & 0x20000000L) != 0L)
            return jjStopAtPos(1, 93);
         break;
      case 62:
         if ((active1 & 0x80000000L) != 0L)
         {
            jjmatchedKind = 95;
            jjmatchedPos = 1;
         }
         else if ((active1 & 0x20000000000L) != 0L)
            return jjStopAtPos(1, 105);
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x4000L);
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0L);
      case 101:
         return jjMoveStringLiteralDfa2_0(active0, 0x89000000L, active1, 0L);
      case 102:
         if ((active0 & 0x10000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 52, 84);
         break;
      case 104:
         return jjMoveStringLiteralDfa2_0(active0, 0x1021000000000L, active1, 0L);
      case 105:
         return jjMoveStringLiteralDfa2_0(active0, 0x820000000L, active1, 0L);
      case 108:
         return jjMoveStringLiteralDfa2_0(active0, 0x50000000000L, active1, 0L);
      case 110:
         return jjMoveStringLiteralDfa2_0(active0, 0x8204002000000L, active1, 0L);
      case 111:
         if ((active0 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 53;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0xc6908010c00000L, active1, 0L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000L, active1, 0L);
      case 116:
         return jjMoveStringLiteralDfa2_0(active0, 0x600000000L, active1, 0L);
      case 117:
         return jjMoveStringLiteralDfa2_0(active0, 0x400000000000L, active1, 0L);
      case 119:
         return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L);
      case 120:
         return jjMoveStringLiteralDfa2_0(active0, 0x100000000L, active1, 0L);
      case 121:
         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L, active1, 0L);
      case 124:
         if ((active1 & 0x80000L) != 0L)
            return jjStopAtPos(1, 83);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0, active1);
}
private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1){
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(0, old0, old1);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0, active1);
      return 2;
   }
   switch(curChar)
   {
      case 46:
         if ((active1 & 0x10L) != 0L)
            return jjStopAtPos(2, 68);
         break;
      case 61:
         if ((active1 & 0x2000L) != 0L)
            return jjStopAtPos(2, 77);
         else if ((active1 & 0x4000L) != 0L)
            return jjStopAtPos(2, 78);
         break;
      case 97:
         return jjMoveStringLiteralDfa3_0(active0, 0x1000400000000L, active1, 0L);
      case 100:
         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000000L, active1, 0L);
      case 101:
         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000L, active1, 0L);
      case 102:
         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);
      case 103:
         return jjMoveStringLiteralDfa3_0(active0, 0x801000000L, active1, 0L);
      case 105:
         return jjMoveStringLiteralDfa3_0(active0, 0x805040000000L, active1, 0L);
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x800000L, active1, 0L);
      case 110:
         return jjMoveStringLiteralDfa3_0(active0, 0x108000400000L, active1, 0L);
      case 111:
         return jjMoveStringLiteralDfa3_0(active0, 0x40030000000000L, active1, 0L);
      case 112:
         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L, active1, 0L);
      case 114:
         if ((active0 & 0x4000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 50, 84);
         return jjMoveStringLiteralDfa3_0(active0, 0x200000000L, active1, 0L);
      case 115:
         return jjMoveStringLiteralDfa3_0(active0, 0xc0002000000L, active1, 0L);
      case 116:
         if ((active0 & 0x8000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 51, 84);
         return jjMoveStringLiteralDfa3_0(active0, 0x2400180000000L, active1, 0L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x200010000000L, active1, 0L);
      case 122:
         return jjMoveStringLiteralDfa3_0(active0, 0x20000000L, active1, 0L);
      default :
         break;
   }
   return jjStartNfa_0(1, active0, active1);
}
private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1){
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(1, old0, old1);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0, 0L);
      return 3;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa4_0(active0, 0x12008800000L);
      case 98:
         return jjMoveStringLiteralDfa4_0(active0, 0x10000000L);
      case 100:
         if ((active0 & 0x800000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 47, 84);
         break;
      case 101:
         if ((active0 & 0x40000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 42, 84);
         else if ((active0 & 0x80000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 43, 84);
         else if ((active0 & 0x80000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 55, 84);
         return jjMoveStringLiteralDfa4_0(active0, 0x124000000L);
      case 103:
         if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 44, 84);
         break;
      case 105:
         return jjMoveStringLiteralDfa4_0(active0, 0x3000000L);
      case 108:
         if ((active0 & 0x40000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 54, 84);
         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
      case 109:
         if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 45, 84);
         break;
      case 110:
         return jjMoveStringLiteralDfa4_0(active0, 0x800000000L);
      case 111:
         if ((active0 & 0x400000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 46, 84);
         else if ((active0 & 0x2000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 49, 84);
         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L);
      case 114:
         if ((active0 & 0x1000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 48, 84);
         return jjMoveStringLiteralDfa4_0(active0, 0x20000000000L);
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x8000000000L);
      case 116:
         return jjMoveStringLiteralDfa4_0(active0, 0x440400000L);
      case 117:
         return jjMoveStringLiteralDfa4_0(active0, 0x280000000L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0, 0L);
}
private int jjMoveStringLiteralDfa4_0(long old0, long active0){
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(2, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 99:
         return jjMoveStringLiteralDfa5_0(active0, 0x240000000L);
      case 100:
         return jjMoveStringLiteralDfa5_0(active0, 0x4000000L);
      case 101:
         if ((active0 & 0x1000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 36, 84);
         return jjMoveStringLiteralDfa5_0(active0, 0x800000000L);
      case 103:
         return jjMoveStringLiteralDfa5_0(active0, 0x2000000L);
      case 105:
         return jjMoveStringLiteralDfa5_0(active0, 0x400400000L);
      case 107:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 37, 84);
         break;
      case 108:
         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
      case 110:
         if ((active0 & 0x4000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 38, 84);
         break;
      case 111:
         return jjMoveStringLiteralDfa5_0(active0, 0x20000000L);
      case 114:
         return jjMoveStringLiteralDfa5_0(active0, 0x180000000L);
      case 115:
         return jjMoveStringLiteralDfa5_0(active0, 0x1000000L);
      case 116:
         if ((active0 & 0x8000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 39, 84);
         else if ((active0 & 0x10000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 40, 84);
         else if ((active0 & 0x20000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 41, 84);
         return jjMoveStringLiteralDfa5_0(active0, 0x800000L);
      case 117:
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000L);
      default :
         break;
   }
   return jjStartNfa_0(3, active0, 0L);
}
private int jjMoveStringLiteralDfa5_0(long old0, long active0){
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(3, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, active0, 0L);
      return 5;
   }
   switch(curChar)
   {
      case 99:
         if ((active0 & 0x400000000L) != 0L)
            return jjStartNfaWithStates_0(5, 34, 84);
         break;
      case 100:
         if ((active0 & 0x800000000L) != 0L)
            return jjStartNfaWithStates_0(5, 35, 84);
         break;
      case 101:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(5, 28, 84);
         return jjMoveStringLiteralDfa6_0(active0, 0x4000000L);
      case 102:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(5, 29, 84);
         break;
      case 104:
         if ((active0 & 0x40000000L) != 0L)
            return jjStartNfaWithStates_0(5, 30, 84);
         break;
      case 105:
         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
      case 108:
         return jjMoveStringLiteralDfa6_0(active0, 0x8000000L);
      case 110:
         if ((active0 & 0x80000000L) != 0L)
            return jjStartNfaWithStates_0(5, 31, 84);
         else if ((active0 & 0x100000000L) != 0L)
            return jjStartNfaWithStates_0(5, 32, 84);
         return jjMoveStringLiteralDfa6_0(active0, 0x2400000L);
      case 116:
         if ((active0 & 0x200000000L) != 0L)
            return jjStartNfaWithStates_0(5, 33, 84);
         return jjMoveStringLiteralDfa6_0(active0, 0x1000000L);
      default :
         break;
   }
   return jjStartNfa_0(4, active0, 0L);
}
private int jjMoveStringLiteralDfa6_0(long old0, long active0){
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(4, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, active0, 0L);
      return 6;
   }
   switch(curChar)
   {
      case 101:
         return jjMoveStringLiteralDfa7_0(active0, 0x3000000L);
      case 102:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(6, 26, 84);
         break;
      case 108:
         return jjMoveStringLiteralDfa7_0(active0, 0x800000L);
      case 116:
         if ((active0 & 0x8000000L) != 0L)
            return jjStartNfaWithStates_0(6, 27, 84);
         break;
      case 117:
         return jjMoveStringLiteralDfa7_0(active0, 0x400000L);
      default :
         break;
   }
   return jjStartNfa_0(5, active0, 0L);
}
private int jjMoveStringLiteralDfa7_0(long old0, long active0){
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(5, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, active0, 0L);
      return 7;
   }
   switch(curChar)
   {
      case 100:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_0(7, 25, 84);
         break;
      case 101:
         if ((active0 & 0x400000L) != 0L)
            return jjStartNfaWithStates_0(7, 22, 84);
         else if ((active0 & 0x800000L) != 0L)
            return jjStartNfaWithStates_0(7, 23, 84);
         break;
      case 114:
         if ((active0 & 0x1000000L) != 0L)
            return jjStartNfaWithStates_0(7, 24, 84);
         break;
      default :
         break;
   }
   return jjStartNfa_0(6, active0, 0L);
}
private int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
static final long[] jjbitVec0 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
private int jjMoveNfa_0(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 84;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 46:
                  if ((0x3ff001000000000L & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 31:
                  if ((0x3ff001000000000L & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 45:
                  if ((0x3ff001000000000L & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 35:
                  if ((0x3ff001000000000L & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddStates(0, 6); }
                  else if (curChar == 47)
                     { jjAddStates(7, 8); }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  else if (curChar == 36)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 34)
                     { jjCheckNAddStates(9, 11); }
                  else if (curChar == 39)
                     { jjAddStates(12, 13); }
                  else if (curChar == 46)
                     { jjCheckNAdd(4); }
                  if ((0x3fe000000000000L & l) != 0L)
                  {
                     if (kind > 12)
                        kind = 12;
                     { jjCheckNAddTwoStates(1, 2); }
                  }
                  else if (curChar == 48)
                  {
                     if (kind > 12)
                        kind = 12;
                     { jjCheckNAddStates(14, 16); }
                  }
                  break;
               case 73:
                  if (curChar == 42)
                     { jjCheckNAddTwoStates(79, 80); }
                  else if (curChar == 47)
                     { jjCheckNAddStates(17, 19); }
                  break;
               case 84:
                  if ((0x3ff001000000000L & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  else if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 1:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  { jjCheckNAddTwoStates(1, 2); }
                  break;
               case 3:
                  if (curChar == 46)
                     { jjCheckNAdd(4); }
                  break;
               case 4:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddStates(20, 22); }
                  break;
               case 6:
                  if ((0x280000000000L & l) != 0L)
                     { jjCheckNAdd(7); }
                  break;
               case 7:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddTwoStates(7, 8); }
                  break;
               case 9:
                  if (curChar == 39)
                     { jjAddStates(12, 13); }
                  break;
               case 10:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     { jjCheckNAdd(11); }
                  break;
               case 11:
                  if (curChar == 39 && kind > 18)
                     kind = 18;
                  break;
               case 13:
                  if ((0x8400000000L & l) != 0L)
                     { jjCheckNAdd(11); }
                  break;
               case 14:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAddTwoStates(15, 11); }
                  break;
               case 15:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAdd(11); }
                  break;
               case 16:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 17;
                  break;
               case 17:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAdd(15); }
                  break;
               case 18:
                  if (curChar == 34)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 19:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 21:
                  if ((0x8400002400L & l) != 0L)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 22:
                  if (curChar == 34 && kind > 19)
                     kind = 19;
                  break;
               case 23:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAddStates(23, 26); }
                  break;
               case 24:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 25:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 26:
                  if ((0xff000000000000L & l) != 0L)
                     { jjCheckNAdd(24); }
                  break;
               case 27:
                  if (curChar == 10)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 28:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 27;
                  break;
               case 38:
                  if ((0x3fe000000000000L & l) == 0L)
                     break;
                  if (kind > 21)
                     kind = 21;
                  { jjCheckNAdd(39); }
                  break;
               case 39:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 21)
                     kind = 21;
                  { jjCheckNAdd(39); }
                  break;
               case 48:
                  if (curChar != 36)
                     break;
                  if (kind > 56)
                     kind = 56;
                  { jjCheckNAddTwoStates(49, 50); }
                  break;
               case 49:
                  if ((0x3ff001000000000L & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  { jjCheckNAddTwoStates(49, 50); }
                  break;
               case 50:
                  if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 51:
                  if (curChar != 58)
                     break;
                  if (kind > 56)
                     kind = 56;
                  { jjCheckNAddTwoStates(49, 50); }
                  break;
               case 52:
                  if (curChar == 58)
                     { jjCheckNAdd(51); }
                  break;
               case 53:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddStates(0, 6); }
                  break;
               case 54:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddTwoStates(54, 55); }
                  break;
               case 55:
                  if (curChar != 46)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddStates(27, 29); }
                  break;
               case 56:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddStates(27, 29); }
                  break;
               case 58:
                  if ((0x280000000000L & l) != 0L)
                     { jjCheckNAdd(59); }
                  break;
               case 59:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddTwoStates(59, 8); }
                  break;
               case 60:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddTwoStates(60, 61); }
                  break;
               case 62:
                  if ((0x280000000000L & l) != 0L)
                     { jjCheckNAdd(63); }
                  break;
               case 63:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 16)
                     kind = 16;
                  { jjCheckNAddTwoStates(63, 8); }
                  break;
               case 64:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddStates(30, 32); }
                  break;
               case 66:
                  if ((0x280000000000L & l) != 0L)
                     { jjCheckNAdd(67); }
                  break;
               case 67:
                  if ((0x3ff000000000000L & l) != 0L)
                     { jjCheckNAddTwoStates(67, 8); }
                  break;
               case 68:
                  if (curChar != 48)
                     break;
                  if (kind > 12)
                     kind = 12;
                  { jjCheckNAddStates(14, 16); }
                  break;
               case 70:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  { jjCheckNAddTwoStates(70, 2); }
                  break;
               case 71:
                  if ((0xff000000000000L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  { jjCheckNAddTwoStates(71, 2); }
                  break;
               case 72:
                  if (curChar == 47)
                     { jjAddStates(7, 8); }
                  break;
               case 74:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     { jjCheckNAddStates(17, 19); }
                  break;
               case 75:
                  if ((0x2400L & l) != 0L && kind > 5)
                     kind = 5;
                  break;
               case 76:
                  if (curChar == 10 && kind > 5)
                     kind = 5;
                  break;
               case 77:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 76;
                  break;
               case 78:
                  if (curChar == 42)
                     { jjCheckNAddTwoStates(79, 80); }
                  break;
               case 79:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     { jjCheckNAddTwoStates(79, 80); }
                  break;
               case 80:
                  if (curChar == 42)
                     { jjCheckNAddStates(33, 35); }
                  break;
               case 81:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     { jjCheckNAddTwoStates(82, 80); }
                  break;
               case 82:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     { jjCheckNAddTwoStates(82, 80); }
                  break;
               case 83:
                  if (curChar == 47 && kind > 6)
                     kind = 6;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 46:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 45;
                  break;
               case 31:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  if (curChar == 114)
                     jjstateSet[jjnewStateCnt++] = 30;
                  break;
               case 45:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  if (curChar == 100)
                     jjstateSet[jjnewStateCnt++] = 44;
                  break;
               case 35:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  if (curChar == 97)
                     jjstateSet[jjnewStateCnt++] = 34;
                  break;
               case 0:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     { jjCheckNAddTwoStates(49, 50); }
                  }
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 46;
                  else if (curChar == 102)
                     jjstateSet[jjnewStateCnt++] = 35;
                  else if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 31;
                  break;
               case 84:
               case 49:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  { jjCheckNAddTwoStates(49, 50); }
                  break;
               case 2:
                  if ((0x100000001000L & l) != 0L && kind > 12)
                     kind = 12;
                  break;
               case 5:
                  if ((0x2000000020L & l) != 0L)
                     { jjAddStates(36, 37); }
                  break;
               case 8:
                  if ((0x5000000050L & l) != 0L && kind > 16)
                     kind = 16;
                  break;
               case 10:
                  if ((0xffffffffefffffffL & l) != 0L)
                     { jjCheckNAdd(11); }
                  break;
               case 12:
                  if (curChar == 92)
                     { jjAddStates(38, 40); }
                  break;
               case 13:
                  if ((0x14404410000000L & l) != 0L)
                     { jjCheckNAdd(11); }
                  break;
               case 19:
                  if ((0xffffffffefffffffL & l) != 0L)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 20:
                  if (curChar == 92)
                     { jjAddStates(41, 44); }
                  break;
               case 21:
                  if ((0x14404410000000L & l) != 0L)
                     { jjCheckNAddStates(9, 11); }
                  break;
               case 29:
                  if (curChar == 101 && kind > 20)
                     kind = 20;
                  break;
               case 30:
                  if (curChar == 117)
                     { jjCheckNAdd(29); }
                  break;
               case 32:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 31;
                  break;
               case 33:
                  if (curChar == 115)
                     { jjCheckNAdd(29); }
                  break;
               case 34:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 36:
                  if (curChar == 102)
                     jjstateSet[jjnewStateCnt++] = 35;
                  break;
               case 37:
                  if (curChar != 100)
                     break;
                  if (kind > 21)
                     kind = 21;
                  jjstateSet[jjnewStateCnt++] = 38;
                  break;
               case 40:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 37;
                  break;
               case 41:
                  if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 40;
                  break;
               case 42:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 41;
                  break;
               case 43:
                  if (curChar == 102)
                     jjstateSet[jjnewStateCnt++] = 42;
                  break;
               case 44:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 43;
                  break;
               case 47:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 46;
                  break;
               case 48:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  { jjCheckNAddTwoStates(49, 50); }
                  break;
               case 57:
                  if ((0x2000000020L & l) != 0L)
                     { jjAddStates(45, 46); }
                  break;
               case 61:
                  if ((0x2000000020L & l) != 0L)
                     { jjAddStates(47, 48); }
                  break;
               case 65:
                  if ((0x2000000020L & l) != 0L)
                     { jjAddStates(49, 50); }
                  break;
               case 69:
                  if ((0x100000001000000L & l) != 0L)
                     { jjCheckNAdd(70); }
                  break;
               case 70:
                  if ((0x7e0000007eL & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  { jjCheckNAddTwoStates(70, 2); }
                  break;
               case 74:
                  { jjAddStates(17, 19); }
                  break;
               case 79:
                  { jjCheckNAddTwoStates(79, 80); }
                  break;
               case 81:
               case 82:
                  { jjCheckNAddTwoStates(82, 80); }
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 10:
                  if ((jjbitVec0[i2] & l2) != 0L)
                     jjstateSet[jjnewStateCnt++] = 11;
                  break;
               case 19:
                  if ((jjbitVec0[i2] & l2) != 0L)
                     { jjAddStates(9, 11); }
                  break;
               case 74:
                  if ((jjbitVec0[i2] & l2) != 0L)
                     { jjAddStates(17, 19); }
                  break;
               case 79:
                  if ((jjbitVec0[i2] & l2) != 0L)
                     { jjCheckNAddTwoStates(79, 80); }
                  break;
               case 81:
               case 82:
                  if ((jjbitVec0[i2] & l2) != 0L)
                     { jjCheckNAddTwoStates(82, 80); }
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 84 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private int jjMoveStringLiteralDfa0_1(){
   switch(curChar)
   {
      case 10:
         return jjStopAtPos(0, 8);
      case 92:
         return jjMoveStringLiteralDfa1_1(0x600L);
      default :
         return 1;
   }
}
private int jjMoveStringLiteralDfa1_1(long active0){
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      return 1;
   }
   switch(curChar)
   {
      case 10:
         if ((active0 & 0x200L) != 0L)
            return jjStopAtPos(1, 9);
         break;
      case 13:
         return jjMoveStringLiteralDfa2_1(active0, 0x400L);
      default :
         return 2;
   }
   return 2;
}
private int jjMoveStringLiteralDfa2_1(long old0, long active0){
   if (((active0 &= old0)) == 0L)
      return 2;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      return 2;
   }
   switch(curChar)
   {
      case 10:
         if ((active0 & 0x400L) != 0L)
            return jjStopAtPos(2, 10);
         break;
      default :
         return 3;
   }
   return 3;
}

/** Token literal values. */
public static final String[] jjstrLiteralImages = {
"", null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, 
"\143\157\156\164\151\156\165\145", "\166\157\154\141\164\151\154\145", "\162\145\147\151\163\164\145\162", 
"\165\156\163\151\147\156\145\144", "\164\171\160\145\144\145\146", "\144\145\146\141\165\154\164", 
"\144\157\165\142\154\145", "\163\151\172\145\157\146", "\163\167\151\164\143\150", 
"\162\145\164\165\162\156", "\145\170\164\145\162\156", "\163\164\162\165\143\164", 
"\163\164\141\164\151\143", "\163\151\147\156\145\144", "\167\150\151\154\145", "\142\162\145\141\153", 
"\165\156\151\157\156", "\143\157\156\163\164", "\146\154\157\141\164", "\163\150\157\162\164", 
"\145\154\163\145", "\143\141\163\145", "\154\157\156\147", "\145\156\165\155", 
"\141\165\164\157", "\166\157\151\144", "\143\150\141\162", "\147\157\164\157", "\146\157\162", 
"\151\156\164", "\151\146", "\144\157", "\142\157\157\154", "\143\157\144\145", null, null, 
null, null, "\73", "\54", "\75", "\50", "\51", "\133", "\135", "\52", "\56\56\56", 
"\173", "\175", "\72", "\52\75", "\57\75", "\45\75", "\53\75", "\55\75", "\74\74\75", 
"\76\76\75", "\46\75", "\136\75", "\174\75", "\77", "\174\174", "\46\46", "\174", "\136", 
"\46", "\75\75", "\41\75", "\74", "\76", "\74\75", "\76\75", "\74\74", "\76\76", 
"\53", "\55", "\57", "\45", "\53\53", "\55\55", "\176", "\41", "\56", "\55\76", };
protected Token jjFillToken()
{
   final Token t;
   final String curTokenImage;
   final int beginLine;
   final int endLine;
   final int beginColumn;
   final int endColumn;
   String im = jjstrLiteralImages[jjmatchedKind];
   curTokenImage = (im == null) ? input_stream.GetImage() : im;
   beginLine = input_stream.getBeginLine();
   beginColumn = input_stream.getBeginColumn();
   endLine = input_stream.getEndLine();
   endColumn = input_stream.getEndColumn();
   t = Token.newToken(jjmatchedKind, curTokenImage);

   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;

   return t;
}
static final int[] jjnextStates = {
   54, 55, 60, 61, 64, 65, 8, 73, 78, 19, 20, 22, 10, 12, 69, 71, 
   2, 74, 75, 77, 4, 5, 8, 19, 20, 24, 22, 56, 57, 8, 64, 65, 
   8, 80, 81, 83, 6, 7, 13, 14, 16, 21, 23, 25, 28, 58, 59, 62, 
   63, 66, 67, 
};

int curLexState = 0;
int defaultLexState = 0;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;

/** Get the next Token. */
public Token getNextToken() 
{
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(Exception e)
   {
      jjmatchedKind = 0;
      jjmatchedPos = -1;
      matchedToken = jjFillToken();
      return matchedToken;
   }

   for (;;)
   {
     switch(curLexState)
     {
       case 0:
         try { input_stream.backup(0);
            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
               curChar = input_stream.BeginToken();
         }
         catch (java.io.IOException e1) { continue EOFLoop; }
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_0();
         break;
       case 1:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_1();
         if (jjmatchedPos == 0 && jjmatchedKind > 11)
         {
            jjmatchedKind = 11;
         }
         break;
     }
     if (jjmatchedKind != 0x7fffffff)
     {
        if (jjmatchedPos + 1 < curPos)
           input_stream.backup(curPos - jjmatchedPos - 1);
        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           matchedToken = jjFillToken();
       if (jjnewLexState[jjmatchedKind] != -1)
         curLexState = jjnewLexState[jjmatchedKind];
           return matchedToken;
        }
        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
         if (jjnewLexState[jjmatchedKind] != -1)
           curLexState = jjnewLexState[jjmatchedKind];
           continue EOFLoop;
        }
      if (jjnewLexState[jjmatchedKind] != -1)
        curLexState = jjnewLexState[jjmatchedKind];
        curPos = 0;
        jjmatchedKind = 0x7fffffff;
        try {
           curChar = input_stream.readChar();
           continue;
        }
        catch (java.io.IOException e1) { }
     }
     int error_line = input_stream.getEndLine();
     int error_column = input_stream.getEndColumn();
     String error_after = null;
     boolean EOFSeen = false;
     try { input_stream.readChar(); input_stream.backup(1); }
     catch (java.io.IOException e1) {
        EOFSeen = true;
        error_after = curPos <= 1 ? "" : input_stream.GetImage();
        if (curChar == '\n' || curChar == '\r') {
           error_line++;
           error_column = 0;
        }
        else
           error_column++;
     }
     if (!EOFSeen) {
        input_stream.backup(1);
        error_after = curPos <= 1 ? "" : input_stream.GetImage();
     }
     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
   }
  }
}

void SkipLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      default :
         break;
   }
}
void MoreLexicalActions()
{
   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
   switch(jjmatchedKind)
   {
      default :
         break;
   }
}
void TokenLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      default :
         break;
   }
}
private void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}

private void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}

    /** Constructor. */
    public CParserTokenManager(SimpleCharStream stream){

      if (SimpleCharStream.staticFlag)
            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");

    input_stream = stream;
  }

  /** Constructor. */
  public CParserTokenManager (SimpleCharStream stream, int lexState){
    ReInit(stream);
    SwitchTo(lexState);
  }

  /** Reinitialise parser. */
  
  public void ReInit(SimpleCharStream stream)
  {


    jjmatchedPos =
    jjnewStateCnt =
    0;
    curLexState = defaultLexState;
    input_stream = stream;
    ReInitRounds();
  }

  private void ReInitRounds()
  {
    int i;
    jjround = 0x80000001;
    for (i = 84; i-- > 0;)
      jjrounds[i] = 0x80000000;
  }

  /** Reinitialise parser. */
  public void ReInit(SimpleCharStream stream, int lexState)
  
  {
    ReInit(stream);
    SwitchTo(lexState);
  }

  /** Switch to specified lex state. */
  public void SwitchTo(int lexState)
  {
    if (lexState >= 2 || lexState < 0)
      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    else
      curLexState = lexState;
  }


/** Lexer state names. */
public static final String[] lexStateNames = {
   "DEFAULT",
   "PREPROCESSOR_OUTPUT",
};

/** Lex State array. */
public static final int[] jjnewLexState = {
   -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, 
};
static final long[] jjtoToken = {
   0xf1fffffffffd1001L, 0x3ffffffffffL, 
};
static final long[] jjtoSkip = {
   0x1feL, 0x0L, 
};
static final long[] jjtoSpecial = {
   0x0L, 0x0L, 
};
static final long[] jjtoMore = {
   0xe00L, 0x0L, 
};
    protected SimpleCharStream  input_stream;

    private final int[] jjrounds = new int[84];
    private final int[] jjstateSet = new int[2 * 84];
    private final StringBuilder jjimage = new StringBuilder();
    private StringBuilder image = jjimage;
    private int jjimageLen;
    private int lengthOfMatch;
    protected int curChar;
}

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParserTreeConstants.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. CParserTreeConstants.java Version 7.0.9 */
public interface CParserTreeConstants
{
  public int JJTFUNCTIONDEFINITION = 0;
  public int JJTDECLARATION = 1;
  public int JJTDECLARATIONLIST = 2;
  public int JJTDECLARATIONSPECIFIERS = 3;
  public int JJTGHOSTSTRINGTOKEN = 4;
  public int JJTTYPESTRINGTOKEN = 5;
  public int JJTSTRINGTOKEN = 6;
  public int JJTINITDECLARATORLIST = 7;
  public int JJTINITDECLARATOR = 8;
  public int JJTSPECIFIERQUALIFIERLIST = 9;
  public int JJTDECLARATOR = 10;
  public int JJTDIRECTDECLARATOR = 11;
  public int JJTPOINTER = 12;
  public int JJTTYPEQUALIFIERLIST = 13;
  public int JJTPARAMETERTYPELIST = 14;
  public int JJTPARAMETERLIST = 15;
  public int JJTPARAMETERDECLARATION = 16;
  public int JJTIDENTIFIERLIST = 17;
  public int JJTINITIALIZER = 18;
  public int JJTINITIALIZERLIST = 19;
  public int JJTTYPENAME = 20;
  public int JJTABSTRACTDECLARATOR = 21;
  public int JJTDIRECTABSTRACTDECLARATOR = 22;
  public int JJTSTATEMENT = 23;
  public int JJTLABELEDSTATEMENT = 24;
  public int JJTEXPRESSIONSTATEMENT = 25;
  public int JJTCOMPOUNDSTATEMENT = 26;
  public int JJTSTATEMENTLIST = 27;
  public int JJTSELECTIONSTATEMENT = 28;
  public int JJTITERATIONSTATEMENT = 29;
  public int JJTJUMPSTATEMENT = 30;
  public int JJTEXPRESSION = 31;
  public int JJTASSIGNMENTEXPRESSION = 32;
  public int JJTCONDITIONALEXPRESSION = 33;
  public int JJTCONSTANTEXPRESSION = 34;
  public int JJTLOGICALOREXPRESSION = 35;
  public int JJTLOGICALANDEXPRESSION = 36;
  public int JJTINCLUSIVEOREXPRESSION = 37;
  public int JJTEXCLUSIVEOREXPRESSION = 38;
  public int JJTANDEXPRESSION = 39;
  public int JJTEQUALITYEXPRESSION = 40;
  public int JJTRELATIONALEXPRESSION = 41;
  public int JJTSHIFTEXPRESSION = 42;
  public int JJTADDITIVEEXPRESSION = 43;
  public int JJTMULTIPLICATIVEEXPRESSION = 44;
  public int JJTCASTEXPRESSION = 45;
  public int JJTUNARYEXPRESSION = 46;
  public int JJTUNARYOPERATOR = 47;
  public int JJTPOSTFIXEXPRESSION = 48;
  public int JJTPRIMARYEXPRESSION = 49;
  public int JJTARGUMENTEXPRESSIONLIST = 50;


  public String[] jjtNodeName = {
    "FunctionDefinition",
    "Declaration",
    "DeclarationList",
    "DeclarationSpecifiers",
    "GhostStringToken",
    "TypeStringToken",
    "StringToken",
    "InitDeclaratorList",
    "InitDeclarator",
    "SpecifierQualifierList",
    "Declarator",
    "DirectDeclarator",
    "Pointer",
    "TypeQualifierList",
    "ParameterTypeList",
    "ParameterList",
    "ParameterDeclaration",
    "IdentifierList",
    "Initializer",
    "InitializerList",
    "TypeName",
    "AbstractDeclarator",
    "DirectAbstractDeclarator",
    "Statement",
    "LabeledStatement",
    "ExpressionStatement",
    "CompoundStatement",
    "StatementList",
    "SelectionStatement",
    "IterationStatement",
    "JumpStatement",
    "Expression",
    "AssignmentExpression",
    "ConditionalExpression",
    "ConstantExpression",
    "LogicalORExpression",
    "LogicalANDExpression",
    "InclusiveORExpression",
    "ExclusiveORExpression",
    "ANDExpression",
    "EqualityExpression",
    "RelationalExpression",
    "ShiftExpression",
    "AdditiveExpression",
    "MultiplicativeExpression",
    "CastExpression",
    "UnaryExpression",
    "UnaryOperator",
    "PostfixExpression",
    "PrimaryExpression",
    "ArgumentExpressionList",
  };
}
/* JavaCC - OriginalChecksum=6fdc7fd778ad43f052fadf52075bfbaa (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/CParserVisitor.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. CParserVisitor.java Version 7.0.9 */
public interface CParserVisitor
{
  public Object visit(SimpleNode node, Object data);
  public Object visit(ASTFunctionDefinition node, Object data);
  public Object visit(ASTDeclaration node, Object data);
  public Object visit(ASTDeclarationList node, Object data);
  public Object visit(ASTDeclarationSpecifiers node, Object data);
  public Object visit(ASTGhostStringToken node, Object data);
  public Object visit(ASTTypeStringToken node, Object data);
  public Object visit(ASTStringToken node, Object data);
  public Object visit(ASTInitDeclaratorList node, Object data);
  public Object visit(ASTInitDeclarator node, Object data);
  public Object visit(ASTSpecifierQualifierList node, Object data);
  public Object visit(ASTDeclarator node, Object data);
  public Object visit(ASTDirectDeclarator node, Object data);
  public Object visit(ASTPointer node, Object data);
  public Object visit(ASTTypeQualifierList node, Object data);
  public Object visit(ASTParameterTypeList node, Object data);
  public Object visit(ASTParameterList node, Object data);
  public Object visit(ASTParameterDeclaration node, Object data);
  public Object visit(ASTIdentifierList node, Object data);
  public Object visit(ASTInitializer node, Object data);
  public Object visit(ASTInitializerList node, Object data);
  public Object visit(ASTTypeName node, Object data);
  public Object visit(ASTAbstractDeclarator node, Object data);
  public Object visit(ASTDirectAbstractDeclarator node, Object data);
  public Object visit(ASTStatement node, Object data);
  public Object visit(ASTLabeledStatement node, Object data);
  public Object visit(ASTExpressionStatement node, Object data);
  public Object visit(ASTCompoundStatement node, Object data);
  public Object visit(ASTStatementList node, Object data);
  public Object visit(ASTSelectionStatement node, Object data);
  public Object visit(ASTIterationStatement node, Object data);
  public Object visit(ASTJumpStatement node, Object data);
  public Object visit(ASTExpression node, Object data);
  public Object visit(ASTAssignmentExpression node, Object data);
  public Object visit(ASTConditionalExpression node, Object data);
  public Object visit(ASTConstantExpression node, Object data);
  public Object visit(ASTLogicalORExpression node, Object data);
  public Object visit(ASTLogicalANDExpression node, Object data);
  public Object visit(ASTInclusiveORExpression node, Object data);
  public Object visit(ASTExclusiveORExpression node, Object data);
  public Object visit(ASTANDExpression node, Object data);
  public Object visit(ASTEqualityExpression node, Object data);
  public Object visit(ASTRelationalExpression node, Object data);
  public Object visit(ASTShiftExpression node, Object data);
  public Object visit(ASTAdditiveExpression node, Object data);
  public Object visit(ASTMultiplicativeExpression node, Object data);
  public Object visit(ASTCastExpression node, Object data);
  public Object visit(ASTUnaryExpression node, Object data);
  public Object visit(ASTUnaryOperator node, Object data);
  public Object visit(ASTPostfixExpression node, Object data);
  public Object visit(ASTPrimaryExpression node, Object data);
  public Object visit(ASTArgumentExpressionList node, Object data);
}
/* JavaCC - OriginalChecksum=1f05897c3d57918f597035227f8d60dd (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/JJTCParserState.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. JJTCParserState.java Version 7.0.9 */
public class JJTCParserState {
  private java.util.List<Node> nodes;
  private java.util.List<Integer> marks;

  private int sp;        // number of nodes on stack
  private int mk;        // current mark
  private boolean node_created;

  public JJTCParserState() {
    nodes = new java.util.ArrayList<Node>();
    marks = new java.util.ArrayList<Integer>();
    sp = 0;
    mk = 0;
  }

  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  public boolean nodeCreated() {
    return node_created;
  }

  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  public void reset() {
    nodes.clear();
    marks.clear();
    sp = 0;
    mk = 0;
  }

  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  public Node rootNode() {
    return nodes.get(0);
  }

  /* Pushes a node on to the stack. */
  public void pushNode(Node n) {
    nodes.add(n);
    ++sp;
  }

  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  public Node popNode() {
    if (--sp < mk) {
      mk = marks.remove(marks.size()-1);
    }
    return nodes.remove(nodes.size()-1);
  }

  /* Returns the node currently on the top of the stack. */
  public Node peekNode() {
    return nodes.get(nodes.size()-1);
  }

  /* Returns the number of children on the stack in the current node
     scope. */
  public int nodeArity() {
    return sp - mk;
  }


  public void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = marks.remove(marks.size()-1);
  }


  public void openNodeScope(Node n) {
    marks.add(mk);
    mk = sp;
    n.jjtOpen();
  }


  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  public void closeNodeScope(Node n, int num) {
    mk = marks.remove(marks.size()-1);
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  public void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = marks.remove(marks.size()-1);
      while (a-- > 0) {
        Node c = popNode();
        c.jjtSetParent(n);
        n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = marks.remove(marks.size()-1);
      node_created = false;
    }
  }
}
/* JavaCC - OriginalChecksum=ab6c16d936495b21e639077683ccf423 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/Node.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. Node.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/* All AST nodes must implement this interface.  It provides basic
   machinery for constructing the parent and child relationships
   between nodes. */

public
interface Node {

  /** This method is called after the node has been made the current
    node.  It indicates that child nodes can now be added to it. */
  public void jjtOpen();

  /** This method is called after all the child nodes have been
    added. */
  public void jjtClose();

  /** This pair of methods are used to inform the node of its
    parent. */
  public void jjtSetParent(Node n);
  public Node jjtGetParent();

  /** This method tells the node to add its argument to the node's
    list of children.  */
  public void jjtAddChild(Node n, int i);

  /** This method returns a child node.  The children are numbered
     from zero, left to right. */
  public Node jjtGetChild(int i);

  /** Return the number of children the node has. */
  public int jjtGetNumChildren();

  public int getId();

  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data);
}
/* JavaCC - OriginalChecksum=93c32f64ec01c5821c3fb11c9d59d33b (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/ParseException.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 7.0 */
/* JavaCCOptions:KEEP_LINE_COLUMN=true */
/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * The end of line string for this machine.
   */
  protected static String EOL = System.getProperty("line.separator", "\n");

  /**
   * This constructor is used by the method "generateParseException"
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields "currentToken",
   * "expectedTokenSequences", and "tokenImage" set.
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }

  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class "Throwable".  The fields "errorToken",
   * "expectedTokenSequences", and "tokenImage" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */

  public ParseException() {
    super();
  }

  /** Constructor with message. */
  public ParseException(String message) {
    super(message);
  }


  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * following this token will (therefore) be the first error token.
   */
  public Token currentToken;

  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;

  /**
   * This is a reference to the "tokenImage" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;

  /**
   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser) the correct error message
   * gets displayed.
   */
  private static String initialise(Token currentToken,
                           int[][] expectedTokenSequences,
                           String[] tokenImage) {

    StringBuilder expected = new StringBuilder();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append("...");
      }
      expected.append(EOL).append("    ");
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += " " + tokenImage[tok.kind];
      retval += " \"";
      retval += add_escapes(tok.image);
      retval += " \"";
      tok = tok.next;
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + EOL;
    
    
    if (expectedTokenSequences.length == 0) {
        // Nothing to add here
    } else {
	    if (expectedTokenSequences.length == 1) {
	      retval += "Was expecting:" + EOL + "    ";
	    } else {
	      retval += "Was expecting one of:" + EOL + "    ";
	    }
	    retval += expected.toString();
    }
    
    return retval;
  }


  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  static String add_escapes(String str) {
      StringBuilder retval = new StringBuilder();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

}
/* JavaCC - OriginalChecksum=0fbdc1f3a882b6ef66ce3f2a7a0e4228 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/SimpleCharStream.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 7.0 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */

public class SimpleCharStream
{
/** Whether parser is static. */
  public static final boolean staticFlag = false;
  int bufsize;
  int available;
  int tokenBegin;
/** Position in buffer. */
  public int bufpos = -1;
  protected int bufline[];
  protected int bufcolumn[];

  protected int column = 0;
  protected int line = 1;

  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;

  protected java.io.Reader inputStream;

  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int inBuf = 0;
  protected int tabSize = 1;
  protected boolean trackLineColumn = true;

  public void setTabSize(int i) { tabSize = i; }
  public int getTabSize() { return tabSize; }



  protected void ExpandBuff(boolean wrapAround)
  {
    char[] newbuffer = new char[bufsize + 2048];
    int newbufline[] = new int[bufsize + 2048];
    int newbufcolumn[] = new int[bufsize + 2048];

    try
    {
      if (wrapAround)
      {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
      }
      else
      {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos -= tokenBegin);
      }
    }
    catch (Throwable t)
    {
      throw new Error(t.getMessage());
    }


    bufsize += 2048;
    available = bufsize;
    tokenBegin = 0;
  }

  protected void FillBuff() throws java.io.IOException
  {
    if (maxNextCharInd == available)
    {
      if (available == bufsize)
      {
        if (tokenBegin > 2048)
        {
          bufpos = maxNextCharInd = 0;
          available = tokenBegin;
        }
        else if (tokenBegin < 0)
          bufpos = maxNextCharInd = 0;
        else
          ExpandBuff(false);
      }
      else if (available > tokenBegin)
        available = bufsize;
      else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
      else
        available = tokenBegin;
    }

    int i;
    try {
      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)
      {
        inputStream.close();
        throw new java.io.IOException();
      }
      else
        maxNextCharInd += i;
      return;
    }
    catch(java.io.IOException e) {
      --bufpos;
      backup(0);
      if (tokenBegin == -1)
        tokenBegin = bufpos;
      throw e;
    }
  }

/** Start. */
  public char BeginToken() throws java.io.IOException
  {
    tokenBegin = -1;
    char c = readChar();
    tokenBegin = bufpos;

    return c;
  }

  protected void UpdateLineColumn(char c)
  {
    column++;

    if (prevCharIsLF)
    {
      prevCharIsLF = false;
      line += (column = 1);
    }
    else if (prevCharIsCR)
    {
      prevCharIsCR = false;
      if (c == '\n')
      {
        prevCharIsLF = true;
      }
      else
        line += (column = 1);
    }

    switch (c)
    {
      case '\r' :
        prevCharIsCR = true;
        break;
      case '\n' :
        prevCharIsLF = true;
        break;
      case '\t' :
        column--;
        column += (tabSize - (column % tabSize));
        break;
      default :
        break;
    }

    bufline[bufpos] = line;
    bufcolumn[bufpos] = column;
  }

/** Read a character. */
  public char readChar() throws java.io.IOException
  {
    if (inBuf > 0)
    {
      --inBuf;

      if (++bufpos == bufsize)
        bufpos = 0;

      return buffer[bufpos];
    }

    if (++bufpos >= maxNextCharInd)
      FillBuff();

    char c = buffer[bufpos];

    UpdateLineColumn(c);
    return c;
  }

  @Deprecated
  /**
   * @deprecated
   * @see #getEndColumn
   */

  public int getColumn() {
    return bufcolumn[bufpos];
  }

  @Deprecated
  /**
   * @deprecated
   * @see #getEndLine
   */

  public int getLine() {
    return bufline[bufpos];
  }

  /** Get token end column number. */
  public int getEndColumn() {
    return bufcolumn[bufpos];
  }

  /** Get token end line number. */
  public int getEndLine() {
     return bufline[bufpos];
  }

  /** Get token beginning column number. */
  public int getBeginColumn() {
    return bufcolumn[tokenBegin];
  }

  /** Get token beginning line number. */
  public int getBeginLine() {
    return bufline[tokenBegin];
  }

/** Backup a number of characters. */
  public void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0)
      bufpos += bufsize;
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream, int startline,
                          int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream)
  {
    this(dstream, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream, int startline,
                     int startcolumn)
  {
    ReInit(dstream, startline, startcolumn, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream)
  {
    ReInit(dstream, 1, 1, 4096);
  }
  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, int startline,
                          int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, 1, 1, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream)
  {
    this(dstream, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, int startline,
                          int startcolumn, int buffersize)
  {
    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
    ReInit(dstream, encoding, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream)
  {
    ReInit(dstream, 1, 1, 4096);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                     int startcolumn) throws java.io.UnsupportedEncodingException
  {
    ReInit(dstream, encoding, startline, startcolumn, 4096);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, int startline,
                     int startcolumn)
  {
    ReInit(dstream, startline, startcolumn, 4096);
  }
  /** Get token literal value. */
  public String GetImage()
  {
    if (bufpos >= tokenBegin)
      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
    else
      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                            new String(buffer, 0, bufpos + 1);
  }

  /** Get the suffix. */
  public char[] GetSuffix(int len)
  {
    char[] ret = new char[len];

    if ((bufpos + 1) >= len)
      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
    else
    {
      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                        len - bufpos - 1);
      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
    }

    return ret;
  }

  /** Reset buffer when finished. */
  public void Done()
  {
    buffer = null;
    bufline = null;
    bufcolumn = null;
  }

  /**
   * Method to adjust line and column numbers for the start of a token.
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
    int start = tokenBegin;
    int len;

    if (bufpos >= tokenBegin)
    {
      len = bufpos - tokenBegin + inBuf + 1;
    }
    else
    {
      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
    }

    int i = 0, j = 0, k = 0;
    int nextColDiff = 0, columnDiff = 0;

    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
    {
      bufline[j] = newLine;
      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
      bufcolumn[j] = newCol + columnDiff;
      columnDiff = nextColDiff;
      i++;
    }

    if (i < len)
    {
      bufline[j] = newLine++;
      bufcolumn[j] = newCol + columnDiff;

      while (i++ < len)
      {
        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
          bufline[j] = newLine++;
        else
          bufline[j] = newLine;
      }
    }

    line = bufline[j];
    column = bufcolumn[j];
  }
  boolean getTrackLineColumn() { return trackLineColumn; }
  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }
}
/* JavaCC - OriginalChecksum=320e3957affec8972ad656fb86b8d782 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/SimpleNode.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected CParser parser;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(CParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  /** Accept the visitor. **/
  public Object jjtAccept(CParserVisitor visitor, Object data)
{
    return visitor.visit(this, data);
  }

  /** Accept the visitor. **/
  public Object childrenAccept(CParserVisitor visitor, Object data)
{
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);
      }
    }
    return data;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return CParserTreeConstants.jjtNodeName[id];
  }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public int getId() {
    return id;
  }
}

/* JavaCC - OriginalChecksum=97592567112e82e2388d067919812e6e (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/Token.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. Token.java Version 7.0 */
/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COLUMN=true,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Describes the input token stream.
 */

public class Token implements java.io.Serializable {

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;

  /** The line number of the first character of this Token. */
  public int beginLine;
  /** The column number of the first character of this Token. */
  public int beginColumn;
  /** The line number of the last character of this Token. */
  public int endLine;
  /** The column number of the last character of this Token. */
  public int endColumn;

  /**
   * The string image of the token.
   */
  public String image;

  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;

  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;

  /**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-null value can
   * override this method as appropriate.
   */
  public Object getValue() {
    return null;
  }

  /**
   * No-argument constructor
   */
  public Token() {}

  /**
   * Constructs a new token for the specified Image.
   */
  public Token(int kind)
  {
    this(kind, null);
  }

  /**
   * Constructs a new token for the specified Image and Kind.
   */
  public Token(int kind, String image)
  {
    this.kind = kind;
    this.image = image;
  }

  /**
   * Returns the image.
   */
  @Override
  public String toString()
  {
    return image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */
  public static Token newToken(int ofKind, String image)
  {
    switch(ofKind)
    {
      default : return new Token(ofKind, image);
    }
  }

  public static Token newToken(int ofKind)
  {
    return newToken(ofKind, null);
  }

}
/* JavaCC - OriginalChecksum=093f73b266edc0ed6a424fcd3b5446d1 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/TokenMgrError.java`:

```java
package ghidrust.decompiler.parser.c.gen;

/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 7.0 */
/* JavaCCOptions: */
/** Token Manager Error. */
public class TokenMgrError extends Error
{

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /*
   * Ordinals for various reasons why an Error of this type can be thrown.
   */

  /**
   * Lexical error occurred.
   */
  public static final int LEXICAL_ERROR = 0;

  /**
   * An attempt was made to create a second instance of a static token manager.
   */
  public static final int STATIC_LEXER_ERROR = 1;

  /**
   * Tried to change to an invalid lexical state.
   */
  public static final int INVALID_LEXICAL_STATE = 2;

  /**
   * Detected (and bailed out of) an infinite loop in the token manager.
   */
  public static final int LOOP_DETECTED = 3;

  /**
   * Indicates the reason why the exception is thrown. It will have
   * one of the above 4 values.
   */
  int errorCode;

  /**
   * Replaces unprintable characters by their escaped (or unicode escaped)
   * equivalents in the given string
   */
  protected static final String addEscapes(String str) {
    StringBuilder retval = new StringBuilder();
    char ch;
    for (int i = 0; i < str.length(); i++) {
      switch (str.charAt(i))
      {
        case '\b':
          retval.append("\\b");
          continue;
        case '\t':
          retval.append("\\t");
          continue;
        case '\n':
          retval.append("\\n");
          continue;
        case '\f':
          retval.append("\\f");
          continue;
        case '\r':
          retval.append("\\r");
          continue;
        case '\"':
          retval.append("\\\"");
          continue;
        case '\'':
          retval.append("\\\'");
          continue;
        case '\\':
          retval.append("\\\\");
          continue;
        default:
          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
            String s = "0000" + Integer.toString(ch, 16);
            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
          } else {
            retval.append(ch);
          }
          continue;
      }
    }
    return retval.toString();
  }

  /**
   * Returns a detailed message for the Error when it is thrown by the
   * token manager to indicate a lexical error.
   * Parameters :
   *    EOFSeen     : indicates if EOF caused the lexical error
   *    curLexState : lexical state in which this error occurred
   *    errorLine   : line number when the error occurred
   *    errorColumn : column number when the error occurred
   *    errorAfter  : prefix that was seen before this error occurred
   *    curchar     : the offending character
   * Note: You can customize the lexical error message by modifying this method.
   */
  protected static String LexicalErr(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar) {
    char curChar1 = (char)curChar;
    return("Lexical error at line " +
          errorLine + ", column " +
          errorColumn + ".  Encountered: " +
          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar1)) + "\"") + " (" + curChar + "), ") +
          "after : \"" + addEscapes(errorAfter) + "\"");
  }

  /**
   * You can also modify the body of this method to customize your error messages.
   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
   * of end-users concern, so you can return something like :
   *
   *     "Internal Error : Please file a bug report .... "
   *
   * from this method for such cases in the release version of your parser.
   */
  @Override
  public String getMessage() {
    return super.getMessage();
  }

  /*
   * Constructors of various flavors follow.
   */

  /** No arg constructor. */
  public TokenMgrError() {
  }

  /** Constructor with message and reason. */
  public TokenMgrError(String message, int reason) {
    super(message);
    errorCode = reason;
  }

  /** Full Constructor. */
  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar, int reason) {
    this(LexicalErr(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
  }
}
/* JavaCC - OriginalChecksum=9e201c978d59ab6f122a52837e6310b1 (do not edit this line) */

```

`src/main/java/ghidrust/decompiler/parser/c/gen/c.jj`:

```jj
/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. c.jj */
/*@egen*//*
C grammar and JJTree definition for use with JavaCC
Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97
From: https://github.com/javacc/javacc/blob/master/grammars/CParser.jj
*/

/* The following code has been significantly modified so as to make it compatible with Ghidra's decompiled output
* and for the Rust transpilation
*/

options {
	             
	               
	STATIC = false;
}

PARSER_BEGIN(CParser)

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import ghidrust.decompiler.parser.c.CVisitor;

public class CParser/*@bgen(jjtree)*/implements CParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCParserState jjtree = new JJTCParserState();

/*@egen*/
	private static CParser c_parser;
	
	// Run the parser
	public static String transpile(String c_code) {
		InputStream stream = new ByteArrayInputStream(c_code.getBytes(StandardCharsets.UTF_8));
		return transpile(stream);
	}

	public static String transpile(InputStream stream) {
		c_parser = new CParser(stream);
		
		try {
			return parse();
		} catch (ParseException e) {
			System.out.println("Rust transpiler: Encountered errors during parsing.");
			e.printStackTrace();
			return null;
		}
	}
	
	public static String parse() throws ParseException {
		CParserVisitor visitor = new CVisitor();
        return (String) c_parser.FunctionDefinition().jjtAccept(visitor, null);
	}
}

PARSER_END(CParser)

SKIP : {
	" "
	|  "\t"
	|  "\n"
	|  "\r"
	|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
	| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
	"\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
	"\\\n"
	|
	"\\\r\n"
	|
	< ~[] >
}


TOKEN : {
	<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
	|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
	|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
	|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
	|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
	|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
	|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
	|  <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
	|  <BOOLEAN: "true" | "false">
	|  <UNDEFINED_TYPE: "undefined" (<DECIMAL_LITERAL>)?> // Ghidra specific unknown type
}

TOKEN : {
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do"> |
	<BOOL_TYPE: "bool"> |
	<CODE: "code"> // code ptr, Ghidra specific
}

TOKEN : {
	<IDENTIFIER: (<LETTER> | <SEPARATOR> <SEPARATOR>) (<LETTER> | <SEPARATOR> <SEPARATOR> | <DIGIT>)*>
	|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	|  <#DIGIT: ["0"-"9"]>
	|  <#SEPARATOR: [":"]>
}


SimpleNode FunctionDefinition() : {/*@bgen(jjtree) FunctionDefinition */
  ASTFunctionDefinition jjtn000 = new ASTFunctionDefinition(JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDefinition */
        try {
/*@egen*/
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] Declarator()
	CompoundStatement()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Declaration() : {/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
        try {
/*@egen*/
	DeclarationSpecifiers() [ InitDeclaratorList() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DeclarationList() : {/*@bgen(jjtree) DeclarationList */
  ASTDeclarationList jjtn000 = new ASTDeclarationList(JJTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationList */
        try {
/*@egen*/
	( LOOKAHEAD(Declaration()) Declaration() )+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DeclarationSpecifiers() : {/*@bgen(jjtree) DeclarationSpecifiers */
  ASTDeclarationSpecifiers jjtn000 = new ASTDeclarationSpecifiers(JJTDECLARATIONSPECIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationSpecifiers */
        try {
/*@egen*/
	StorageClassSpecifier() [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ] |
	TypeSpecifier()  [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ] |
	TypeQualifier() [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StorageClassSpecifier()                   :
{/*@bgen(jjtree) GhostStringToken */
        ASTGhostStringToken jjtn000 = new ASTGhostStringToken(JJTGHOSTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) GhostStringToken */
        try {
/*@egen*/
	( t = <AUTO> | t = <REGISTER> | t = <STATIC> | t = <EXTERN> | t = <TYPEDEF> )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeSpecifier()                  :
{/*@bgen(jjtree) TypeStringToken */
        ASTTypeStringToken jjtn000 = new ASTTypeStringToken(JJTTYPESTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) TypeStringToken */
        try {
/*@egen*/
	( t = <VOID> | t = <CHAR> | t = <SHORT> | t = <INT> | t = <LONG> | t = <FLOAT> | t = <DOUBLE> | t = <SIGNED> |
	t = <UNSIGNED> | t = <BOOL_TYPE> | t = <CODE> | t = <UNDEFINED_TYPE> )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeQualifier()              :
{/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) StringToken */
        try {
/*@egen*/
	( t = <CONST> | t = <VOLATILE> )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitDeclaratorList() : {/*@bgen(jjtree) InitDeclaratorList */
  ASTInitDeclaratorList jjtn000 = new ASTInitDeclaratorList(JJTINITDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclaratorList */
        try {
/*@egen*/
	InitDeclarator() ("," InitDeclarator())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitDeclarator() : {/*@bgen(jjtree) InitDeclarator */
  ASTInitDeclarator jjtn000 = new ASTInitDeclarator(JJTINITDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclarator */
        try {
/*@egen*/
	Declarator() [ "=" Initializer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SpecifierQualifierList() : {/*@bgen(jjtree) SpecifierQualifierList */
  ASTSpecifierQualifierList jjtn000 = new ASTSpecifierQualifierList(JJTSPECIFIERQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SpecifierQualifierList */
        try {
/*@egen*/
	TypeSpecifier() [ LOOKAHEAD(SpecifierQualifierList())
	SpecifierQualifierList() ]|
	TypeQualifier() [ LOOKAHEAD(SpecifierQualifierList())
	SpecifierQualifierList() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Declarator() : {/*@bgen(jjtree) Declarator */
  ASTDeclarator jjtn000 = new ASTDeclarator(JJTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declarator */
        try {
/*@egen*/
	[ Pointer() ] DirectDeclarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DirectDeclarator() : {/*@bgen(jjtree) DirectDeclarator */
  ASTDirectDeclarator jjtn000 = new ASTDirectDeclarator(JJTDIRECTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DirectDeclarator */
        try {
/*@egen*/
	( Identifier() | "(" Declarator() ")" )
	( "[" [ ConstantExpression() ] "]" |
	LOOKAHEAD(3) "(" ParameterTypeList() ")" |
	"(" [ IdentifierList() ] ")" )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Pointer() : {/*@bgen(jjtree) Pointer */
  ASTPointer jjtn000 = new ASTPointer(JJTPOINTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pointer */
        try {
/*@egen*/
	"*" [ TypeQualifierList() ] [ Pointer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeQualifierList() : {/*@bgen(jjtree) TypeQualifierList */
  ASTTypeQualifierList jjtn000 = new ASTTypeQualifierList(JJTTYPEQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeQualifierList */
        try {
/*@egen*/
	(TypeQualifier())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterTypeList() : {/*@bgen(jjtree) ParameterTypeList */
  ASTParameterTypeList jjtn000 = new ASTParameterTypeList(JJTPARAMETERTYPELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterTypeList */
        try {
/*@egen*/
	ParameterList() ["," "..." ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterList() : {/*@bgen(jjtree) ParameterList */
  ASTParameterList jjtn000 = new ASTParameterList(JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterList */
        try {
/*@egen*/
	ParameterDeclaration() (LOOKAHEAD(2) "," ParameterDeclaration())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterDeclaration() : {/*@bgen(jjtree) ParameterDeclaration */
  ASTParameterDeclaration jjtn000 = new ASTParameterDeclaration(JJTPARAMETERDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterDeclaration */
        try {
/*@egen*/
	DeclarationSpecifiers() ( LOOKAHEAD(Declarator()) Declarator() | [ AbstractDeclarator() ] )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IdentifierList() : {/*@bgen(jjtree) IdentifierList */
  ASTIdentifierList jjtn000 = new ASTIdentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IdentifierList */
        try {
/*@egen*/
	Identifier() ("," Identifier())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Initializer() : {/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initializer */
        try {
/*@egen*/
	( AssignmentExpression() |
	"{" InitializerList() [","] "}" )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitializerList() : {/*@bgen(jjtree) InitializerList */
  ASTInitializerList jjtn000 = new ASTInitializerList(JJTINITIALIZERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitializerList */
        try {
/*@egen*/
	Initializer() (LOOKAHEAD(2) "," Initializer())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeName() : {/*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeName */
        try {
/*@egen*/
	SpecifierQualifierList() [ AbstractDeclarator() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

void AbstractDeclarator() : {/*@bgen(jjtree) AbstractDeclarator */
  ASTAbstractDeclarator jjtn000 = new ASTAbstractDeclarator(JJTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AbstractDeclarator */
        try {
/*@egen*/
	( LOOKAHEAD(3) Pointer() |
	[Pointer()] DirectAbstractDeclarator() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DirectAbstractDeclarator() : {/*@bgen(jjtree) DirectAbstractDeclarator */
  ASTDirectAbstractDeclarator jjtn000 = new ASTDirectAbstractDeclarator(JJTDIRECTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DirectAbstractDeclarator */
        try {
/*@egen*/
	( LOOKAHEAD(2) "(" AbstractDeclarator() ")" |
	"[" [ConstantExpression()] "]" |
	"(" [ParameterTypeList()] ")" )
	
	( "[" [ ConstantExpression() ] "]" | "(" [ ParameterTypeList() ] ")" )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement() : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/
	( LOOKAHEAD(Identifier() ":") LabeledStatement() |
	ExpressionStatement() |
	CompoundStatement() |
	SelectionStatement() |
	IterationStatement() |
	JumpStatement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LabeledStatement() : {/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
	( Identifier() ":" Statement() |
	<CASE> ConstantExpression() ":" Statement() |
	<DFLT> ":" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionStatement() : {/*@bgen(jjtree) ExpressionStatement */
  ASTExpressionStatement jjtn000 = new ASTExpressionStatement(JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionStatement */
        try {
/*@egen*/
	[ Expression() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CompoundStatement() : {/*@bgen(jjtree) CompoundStatement */
  ASTCompoundStatement jjtn000 = new ASTCompoundStatement(JJTCOMPOUNDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompoundStatement */
        try {
/*@egen*/
	"{" [ LOOKAHEAD(DeclarationList()) DeclarationList() ]
	[ StatementList() ]
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementList() : {/*@bgen(jjtree) StatementList */
  ASTStatementList jjtn000 = new ASTStatementList(JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementList */
        try {
/*@egen*/
	(Statement())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SelectionStatement() : {/*@bgen(jjtree) SelectionStatement */
  ASTSelectionStatement jjtn000 = new ASTSelectionStatement(JJTSELECTIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectionStatement */
        try {
/*@egen*/
	( <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
	<SWITCH> "(" Expression() ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IterationStatement() : {/*@bgen(jjtree) IterationStatement */
  ASTIterationStatement jjtn000 = new ASTIterationStatement(JJTITERATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IterationStatement */
        try {
/*@egen*/
	( <WHILE> "(" Expression() ")" Statement() |
	<DO> Statement() <WHILE> "(" Expression() ")" ";" |
	<FOR> "(" [ Expression() ] ";" [ Expression() ] ";" [ Expression() ] ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JumpStatement() : {/*@bgen(jjtree) JumpStatement */
  ASTJumpStatement jjtn000 = new ASTJumpStatement(JJTJUMPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JumpStatement */
        try {
/*@egen*/
	( <GOTO> Identifier() ";" |
	<CONTINUE> ";" |
	<BREAK> ";" |
	<RETURN> [ Expression() ] ";" )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	AssignmentExpression() ( "," AssignmentExpression() )* | DeclarationSpecifiers() InitDeclaratorList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AssignmentExpression() : {/*@bgen(jjtree) AssignmentExpression */
  ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
        try {
/*@egen*/
	LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	LOOKAHEAD(3) ConditionalExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AssignmentOperator()              :
{/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) StringToken */
        try {
/*@egen*/
	( t = "=" | t = "*=" | t = "/=" | t = "%=" | t = "+=" | t = "-=" | t = "<<=" | t = ">>=" | t = "&=" | t = "^=" | t = "|=" )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConditionalExpression() : {/*@bgen(jjtree) ConditionalExpression */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
        try {
/*@egen*/
	LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstantExpression() : {/*@bgen(jjtree) ConstantExpression */
  ASTConstantExpression jjtn000 = new ASTConstantExpression(JJTCONSTANTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstantExpression */
        try {
/*@egen*/
	ConditionalExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalORExpression() : {/*@bgen(jjtree) LogicalORExpression */
  ASTLogicalORExpression jjtn000 = new ASTLogicalORExpression(JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalORExpression */
        try {
/*@egen*/
	LogicalANDExpression() [ "||" LogicalORExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalANDExpression() : {/*@bgen(jjtree) LogicalANDExpression */
  ASTLogicalANDExpression jjtn000 = new ASTLogicalANDExpression(JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalANDExpression */
        try {
/*@egen*/
	InclusiveORExpression() [ "&&" LogicalANDExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InclusiveORExpression() : {/*@bgen(jjtree) InclusiveORExpression */
  ASTInclusiveORExpression jjtn000 = new ASTInclusiveORExpression(JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InclusiveORExpression */
        try {
/*@egen*/
	ExclusiveORExpression() [ "|" InclusiveORExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExclusiveORExpression() : {/*@bgen(jjtree) ExclusiveORExpression */
  ASTExclusiveORExpression jjtn000 = new ASTExclusiveORExpression(JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExclusiveORExpression */
        try {
/*@egen*/
	ANDExpression() [ "^" ExclusiveORExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ANDExpression() : {/*@bgen(jjtree) ANDExpression */
  ASTANDExpression jjtn000 = new ASTANDExpression(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ANDExpression */
        try {
/*@egen*/
	EqualityExpression() [ "&" ANDExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EqualityExpression() : {/*@bgen(jjtree) EqualityExpression */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualityExpression */
        try {
/*@egen*/
	RelationalExpression() [ ( "==" | "!=" ) EqualityExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RelationalExpression() : {/*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpression */
        try {
/*@egen*/
	ShiftExpression() [ ( "<" | ">" | "<=" | ">=" ) RelationalExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ShiftExpression() : {/*@bgen(jjtree) ShiftExpression */
  ASTShiftExpression jjtn000 = new ASTShiftExpression(JJTSHIFTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ShiftExpression */
        try {
/*@egen*/
	AdditiveExpression() [ ( "<<" | ">>" ) ShiftExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AdditiveExpression() : {/*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AdditiveExpression */
        try {
/*@egen*/
	MultiplicativeExpression() [ AdditionOperator() AdditiveExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AdditionOperator()              :
{/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) StringToken */
        try {
/*@egen*/
	( t = "+" | t = "-" )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MultiplicativeExpression() : {/*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiplicativeExpression */
        try {
/*@egen*/
	CastExpression() [ ( "*" | "/" | "%" ) MultiplicativeExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CastExpression() : {/*@bgen(jjtree) CastExpression */
  ASTCastExpression jjtn000 = new ASTCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CastExpression */
        try {
/*@egen*/
	( LOOKAHEAD("(" TypeName() ")" CastExpression() ) "(" TypeName() ")" CastExpression() |
	UnaryExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/
	( LOOKAHEAD(3) PostfixExpression() |
	"++" UnaryExpression() |
	"--" UnaryExpression() |
	UnaryOperator() CastExpression() |
	<SIZEOF> ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" ) )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UnaryOperator() : {/*@bgen(jjtree) UnaryOperator */
  ASTUnaryOperator jjtn000 = new ASTUnaryOperator(JJTUNARYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryOperator */
        try {
/*@egen*/
	( "&" | "*" | "+" | "-" | "~" | "!" )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PostfixExpression() : {/*@bgen(jjtree) PostfixExpression */
        ASTPostfixExpression jjtn000 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int choice = 0;
}
{/*@bgen(jjtree) PostfixExpression */
        try {
/*@egen*/
	PrimaryExpression() ( "[" Expression() "]" { choice = 1; } |
	"(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" { choice = 2; } |
	"." Identifier() { choice = 3; } |
	"->" Identifier() | { choice = 4; }
	"++" | { choice = 5; }
	"--" { choice = 6; } )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.choice = choice;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PrimaryExpression() : {/*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimaryExpression */
        try {
/*@egen*/
	( Identifier() |
	Constant() |
	"(" Expression() ")" )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArgumentExpressionList() : {/*@bgen(jjtree) ArgumentExpressionList */
  ASTArgumentExpressionList jjtn000 = new ASTArgumentExpressionList(JJTARGUMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentExpressionList */
        try {
/*@egen*/
	AssignmentExpression() ( "," AssignmentExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTStringToken Identifier()              :
{/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token r = null;
	ASTStringToken t = null;
	Token s = null;
	int choice;
}
{/*@bgen(jjtree) StringToken */
        try {
/*@egen*/
	(LOOKAHEAD(<IDENTIFIER>) r = <IDENTIFIER> { choice = 0; } | [ r = <IDENTIFIER> ] "<" t = Identifier() ">" [ s = <IDENTIFIER> ] { choice = 1; })/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (choice == 1) {
			jjtn000.setValue((r != null ? r.image : "") + "<" + t.getValue() + ">" + (s != null ? s.image : ""));
		} else {
			jjtn000.setValue(r.image);
		}

		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Constant()              :
{/*@bgen(jjtree) StringToken */
        ASTStringToken jjtn000 = new ASTStringToken(JJTSTRINGTOKEN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) StringToken */
        try {
/*@egen*/
	(t = <INTEGER_LITERAL> | t = <FLOATING_POINT_LITERAL> | t = <CHARACTER_LITERAL> | t = <STRING_LITERAL> | t = <BOOLEAN>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setValue(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
```

`src/main/java/ghidrust/decompiler/parser/c/gen/c.jjt`:

```jjt
/*
C grammar and JJTree definition for use with JavaCC
Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97
From: https://github.com/javacc/javacc/blob/master/grammars/CParser.jj
*/

/* The following code has been significantly modified so as to make it compatible with Ghidra's decompiled output
* and for the Rust transpilation
*/

options {
	MULTI = true;
	VISITOR = true;
	STATIC = false;
}

PARSER_BEGIN(CParser)

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import ghidrust.decompiler.parser.c.CVisitor;

public class CParser {
	private static CParser c_parser;
	
	// Run the parser
	public static String transpile(String c_code) {
		InputStream stream = new ByteArrayInputStream(c_code.getBytes(StandardCharsets.UTF_8));
		return transpile(stream);
	}

	public static String transpile(InputStream stream) {
		c_parser = new CParser(stream);
		
		try {
			return parse();
		} catch (ParseException e) {
			System.out.println("Rust transpiler: Encountered errors during parsing.");
			e.printStackTrace();
			return null;
		}
	}
	
	public static String parse() throws ParseException {
		CParserVisitor visitor = new CVisitor();
        return (String) c_parser.FunctionDefinition().jjtAccept(visitor, null);
	}
}

PARSER_END(CParser)

SKIP : {
	" "
	|  "\t"
	|  "\n"
	|  "\r"
	|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
	| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
	"\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
	"\\\n"
	|
	"\\\r\n"
	|
	< ~[] >
}


TOKEN : {
	<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
	|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
	|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
	|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
	|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
	|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
	|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
	|  <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
	|  <BOOLEAN: "true" | "false">
	|  <UNDEFINED_TYPE: "undefined" (<DECIMAL_LITERAL>)?> // Ghidra specific unknown type
}

TOKEN : {
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do"> |
	<BOOL_TYPE: "bool"> |
	<CODE: "code"> // code ptr, Ghidra specific
}

TOKEN : {
	<IDENTIFIER: (<LETTER> | <SEPARATOR> <SEPARATOR>) (<LETTER> | <SEPARATOR> <SEPARATOR> | <DIGIT>)*>
	|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	|  <#DIGIT: ["0"-"9"]>
	|  <#SEPARATOR: [":"]>
}


SimpleNode FunctionDefinition() : {}
{
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] Declarator()
	CompoundStatement()
	{
		return jjtThis;
	}
}

void Declaration() : {}
{
	DeclarationSpecifiers() [ InitDeclaratorList() ] ";"
}

void DeclarationList() : {}
{
	( LOOKAHEAD(Declaration()) Declaration() )+
}

void DeclarationSpecifiers() : {}
{
	StorageClassSpecifier() [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ] |
	TypeSpecifier()  [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ] |
	TypeQualifier() [ LOOKAHEAD(DeclarationSpecifiers())
	DeclarationSpecifiers() ]
}

void StorageClassSpecifier() #GhostStringToken :
{
	Token t;
}
{
	( t = <AUTO> | t = <REGISTER> | t = <STATIC> | t = <EXTERN> | t = <TYPEDEF> )
	{
		jjtThis.setValue(t.image);
	}
}

void TypeSpecifier() #TypeStringToken :
{
	Token t;
}
{
	( t = <VOID> | t = <CHAR> | t = <SHORT> | t = <INT> | t = <LONG> | t = <FLOAT> | t = <DOUBLE> | t = <SIGNED> |
	t = <UNSIGNED> | t = <BOOL_TYPE> | t = <CODE> | t = <UNDEFINED_TYPE> )
	{
		jjtThis.setValue(t.image);
	}
}

void TypeQualifier() #StringToken :
{
	Token t;
}
{
	( t = <CONST> | t = <VOLATILE> )
	{
		jjtThis.setValue(t.image);
	}
}

void InitDeclaratorList() : {}
{
	InitDeclarator() ("," InitDeclarator())*
}

void InitDeclarator() : {}
{
	Declarator() [ "=" Initializer() ]
}

void SpecifierQualifierList() : {}
{
	TypeSpecifier() [ LOOKAHEAD(SpecifierQualifierList())
	SpecifierQualifierList() ]|
	TypeQualifier() [ LOOKAHEAD(SpecifierQualifierList())
	SpecifierQualifierList() ]
}

void Declarator() : {}
{
	[ Pointer() ] DirectDeclarator()
}

void DirectDeclarator() : {}
{
	( Identifier() | "(" Declarator() ")" )
	( "[" [ ConstantExpression() ] "]" |
	LOOKAHEAD(3) "(" ParameterTypeList() ")" |
	"(" [ IdentifierList() ] ")" )*
}

void Pointer() : {}
{
	"*" [ TypeQualifierList() ] [ Pointer() ]
}

void TypeQualifierList() : {}
{
	(TypeQualifier())+
}

void ParameterTypeList() : {}
{
	ParameterList() ["," "..." ]
}

void ParameterList() : {}
{
	ParameterDeclaration() (LOOKAHEAD(2) "," ParameterDeclaration())*
}

void ParameterDeclaration() : {}
{
	DeclarationSpecifiers() ( LOOKAHEAD(Declarator()) Declarator() | [ AbstractDeclarator() ] )
}

void IdentifierList() : {}
{
	Identifier() ("," Identifier())*
}

void Initializer() : {}
{
	( AssignmentExpression() |
	"{" InitializerList() [","] "}" )
}

void InitializerList() : {}
{
	Initializer() (LOOKAHEAD(2) "," Initializer())*
}

void TypeName() : {}
{
	SpecifierQualifierList() [ AbstractDeclarator() ]
	
}

void AbstractDeclarator() : {}
{
	( LOOKAHEAD(3) Pointer() |
	[Pointer()] DirectAbstractDeclarator() )
}

void DirectAbstractDeclarator() : {}
{
	( LOOKAHEAD(2) "(" AbstractDeclarator() ")" |
	"[" [ConstantExpression()] "]" |
	"(" [ParameterTypeList()] ")" )
	
	( "[" [ ConstantExpression() ] "]" | "(" [ ParameterTypeList() ] ")" )*
}

void Statement() : {}
{
	( LOOKAHEAD(Identifier() ":") LabeledStatement() |
	ExpressionStatement() |
	CompoundStatement() |
	SelectionStatement() |
	IterationStatement() |
	JumpStatement() )
}

void LabeledStatement() : {}
{
	( Identifier() ":" Statement() |
	<CASE> ConstantExpression() ":" Statement() |
	<DFLT> ":" Statement() )
}

void ExpressionStatement() : {}
{
	[ Expression() ] ";"
}

void CompoundStatement() : {}
{
	"{" [ LOOKAHEAD(DeclarationList()) DeclarationList() ]
	[ StatementList() ]
	"}"
}

void StatementList() : {}
{
	(Statement())+
}

void SelectionStatement() : {}
{
	( <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
	<SWITCH> "(" Expression() ")" Statement() )
}

void IterationStatement() : {}
{
	( <WHILE> "(" Expression() ")" Statement() |
	<DO> Statement() <WHILE> "(" Expression() ")" ";" |
	<FOR> "(" [ Expression() ] ";" [ Expression() ] ";" [ Expression() ] ")" Statement() )
}

void JumpStatement() : {}
{
	( <GOTO> Identifier() ";" |
	<CONTINUE> ";" |
	<BREAK> ";" |
	<RETURN> [ Expression() ] ";" )
}

void Expression() : {}
{
	AssignmentExpression() ( "," AssignmentExpression() )* | DeclarationSpecifiers() InitDeclaratorList()
}

void AssignmentExpression() : {}
{
	LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	LOOKAHEAD(3) ConditionalExpression()
}

void AssignmentOperator() #StringToken :
{
	Token t;
}
{
	( t = "=" | t = "*=" | t = "/=" | t = "%=" | t = "+=" | t = "-=" | t = "<<=" | t = ">>=" | t = "&=" | t = "^=" | t = "|=" )
	{
		jjtThis.setValue(t.image);
	}
}

void ConditionalExpression() : {}
{
	LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConstantExpression() : {}
{
	ConditionalExpression()
}

void LogicalORExpression() : {}
{
	LogicalANDExpression() [ "||" LogicalORExpression() ]
}

void LogicalANDExpression() : {}
{
	InclusiveORExpression() [ "&&" LogicalANDExpression() ]
}

void InclusiveORExpression() : {}
{
	ExclusiveORExpression() [ "|" InclusiveORExpression() ]
}

void ExclusiveORExpression() : {}
{
	ANDExpression() [ "^" ExclusiveORExpression() ]
}

void ANDExpression() : {}
{
	EqualityExpression() [ "&" ANDExpression() ]
}

void EqualityExpression() : {}
{
	RelationalExpression() [ ( "==" | "!=" ) EqualityExpression() ]
}

void RelationalExpression() : {}
{
	ShiftExpression() [ ( "<" | ">" | "<=" | ">=" ) RelationalExpression() ]
}

void ShiftExpression() : {}
{
	AdditiveExpression() [ ( "<<" | ">>" ) ShiftExpression() ]
}

void AdditiveExpression() : {}
{
	MultiplicativeExpression() [ AdditionOperator() AdditiveExpression() ]
}

void AdditionOperator() #StringToken :
{
	Token t;
}
{
	( t = "+" | t = "-" )
	{
		jjtThis.setValue(t.image);
	}
}

void MultiplicativeExpression() : {}
{
	CastExpression() [ ( "*" | "/" | "%" ) MultiplicativeExpression() ]
}

void CastExpression() : {}
{
	( LOOKAHEAD("(" TypeName() ")" CastExpression() ) "(" TypeName() ")" CastExpression() |
	UnaryExpression() )
}

void UnaryExpression() : {}
{
	( LOOKAHEAD(3) PostfixExpression() |
	"++" UnaryExpression() |
	"--" UnaryExpression() |
	UnaryOperator() CastExpression() |
	<SIZEOF> ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" ) )
}

void UnaryOperator() : {}
{
	( "&" | "*" | "+" | "-" | "~" | "!" )
}

void PostfixExpression() : {
	int choice = 0;
}
{
	PrimaryExpression() ( "[" Expression() "]" { choice = 1; } |
	"(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" { choice = 2; } |
	"." Identifier() { choice = 3; } |
	"->" Identifier() | { choice = 4; }
	"++" | { choice = 5; }
	"--" { choice = 6; } )*
	{
		jjtThis.choice = choice;
	}
}

void PrimaryExpression() : {}
{
	( Identifier() |
	Constant() |
	"(" Expression() ")" )
}

void ArgumentExpressionList() : {}
{
	AssignmentExpression() ( "," AssignmentExpression() )*
}

ASTStringToken Identifier() #StringToken :
{
	Token r = null;
	ASTStringToken t = null;
	Token s = null;
	int choice;
}
{
	(LOOKAHEAD(<IDENTIFIER>) r = <IDENTIFIER> { choice = 0; } | [ r = <IDENTIFIER> ] "<" t = Identifier() ">" [ s = <IDENTIFIER> ] { choice = 1; })
	{
		if (choice == 1) {
			jjtThis.setValue((r != null ? r.image : "") + "<" + t.getValue() + ">" + (s != null ? s.image : ""));
		} else {
			jjtThis.setValue(r.image);
		}

		return jjtThis;
	}
}

void Constant() #StringToken :
{
	Token t;
}
{
	(t = <INTEGER_LITERAL> | t = <FLOATING_POINT_LITERAL> | t = <CHARACTER_LITERAL> | t = <STRING_LITERAL> | t = <BOOLEAN>)
	{
		jjtThis.setValue(t.image);
	}
}

```

`src/main/java/ghidrust/decompiler/parser/generate.sh`:

```sh
#!/bin/sh

# Shell script to generate the parsers and add the package statement to the top of each file

cd c/gen

BACKUP_FILES="ASTPostfixExpression \
$(ls -1 AST*Token.java | cut -d. -f1 | tr '\n' ' ')"

for file in $BACKUP_FILES; do
    mv -- "${file}.java" "${file}.bak"
done

rm -f *.java c.jj

jjtree c.jjt
javacc c.jj

sleep 1

for file in *.java; do
    sed -i '1s/^/package ghidrust.decompiler.parser.c.gen;\n\n/' $file
done

for file in $BACKUP_FILES; do
    mv -- "${file}.bak" "${file}.java"
done

```