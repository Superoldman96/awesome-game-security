Project Path: arc_gmh5225_Kernelmode-manual-mapping-through-IAT_1dzdr4_4

Source Tree:

```txt
arc_gmh5225_Kernelmode-manual-mapping-through-IAT_1dzdr4_4
├── README.md
├── driver
│   ├── definitions.h
│   ├── ioctls.h
│   └── main.c
├── example_dll
│   └── dllmain.cpp
└── mmap
    ├── kernelmode_proc_handler.cpp
    ├── kernelmode_proc_handler.hpp
    ├── logger.hpp
    ├── main.cpp
    ├── mmap.cpp
    ├── mmap.hpp
    ├── process_handler.hpp
    ├── stub
    ├── stub.asm
    ├── usermode_proc_handler.cpp
    ├── usermode_proc_handler.hpp
    ├── utils.cpp
    └── utils.h

```

`README.md`:

```md
## Manual mapping x64 without creating any threads

Instead of using CreateRemoteThread or typical thread hijacking methods(e.g. GetThreadContext), 
this mapper injects into code flow through import table. 
Address of function is overwritten with stub address, it is later restored after calling the stub.
It supports interacting with the process by handle or kernel driver.
Injecting with a driver allows you to execute code inside protected processes. 

#### Usage:
```cpp
mmap mapper(INJECTION_TYPE::KERNEL); // or INJECTION_TYPE::USERMODE

if (!mapper.attach_to_process("example_process.exe"))
	return 1;

if (!mapper.load_dll("example_dll.dll"))
	return 1;

if (!mapper.inject())
	return 1;
```
![](https://i.imgur.com/cKyFRrb.png)

</br></br>

#### Credits
- [teosek](https://github.com/teosek "teosek") //usermode_proc class, import walking
- Daquas //testing
```

`driver/definitions.h`:

```h
#pragma once 
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>

//most of those structures comes from http://nirsoft.net/

typedef unsigned long long QWORD;
typedef unsigned short WORD;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _NON_PAGED_DEBUG_INFO
{
	USHORT      Signature;
	USHORT      Flags;
	ULONG       Size;
	USHORT      Machine;
	USHORT      Characteristics;
	ULONG       TimeDateStamp;
	ULONG       CheckSum;
	ULONG       SizeOfImage;
	ULONGLONG   ImageBase;
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	WORD LoadCount;
	WORD TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	VOID * EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_CRITICAL_SECTION_DEBUG
{
	WORD Type;
	WORD CreatorBackTraceIndex;
	VOID *CriticalSection;
	LIST_ENTRY ProcessLocksList;
	ULONG EntryCount;
	ULONG ContentionCount;
	ULONG Flags;
	WORD CreatorBackTraceIndexHigh;
	WORD SpareUSHORT;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION
{
	VOID * DebugInfo;
	LONG LockCount;
	LONG RecursionCount;
	PVOID OwningThread;
	PVOID LockSemaphore;
	ULONG SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG ImageUsesLargePages : 1;
	ULONG IsProtectedProcess : 1;
	ULONG IsLegacyProcess : 1;
	ULONG IsImageDynamicallyRelocated : 1;
	ULONG SpareBits : 4;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	VOID *ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	ULONG CrossProcessFlags;
	ULONG ProcessInJob : 1;
	ULONG ProcessInitializing : 1;
	ULONG ReservedBits0 : 30;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};
	ULONG SystemReserved[1];
	ULONG SpareUlong;
	VOID* FreeList;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;
	PVOID HotpatchInformation;
	VOID * * ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG HeapSegmentReserve;
	ULONG HeapSegmentCommit;
	ULONG HeapDeCommitTotalFreeThreshold;
	ULONG HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	VOID * * ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;
	PRTL_CRITICAL_SECTION LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	WORD OSBuildNumber;
	WORD OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG ImageProcessAffinityMask;
	ULONG GdiHandleBuffer[34];
	PVOID PostProcessInitRoutine;
	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];
	ULONG SessionId;
	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo;
	UNICODE_STRING CSDVersion;
	VOID * ActivationContextData;
	VOID * ProcessAssemblyStorageMap;
	VOID * SystemDefaultActivationContextData;
	VOID * SystemAssemblyStorageMap;
	ULONG MinimumStackCommit;
	VOID * FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[4];
	ULONG FlsHighIndex;
	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
} PEB, *PPEB;

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS *Process
);

NTSTATUS NTAPI MmCopyVirtualMemory(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

NTSTATUS ZwAllocateVirtualMemory(
	_In_    HANDLE    ProcessHandle,
	_Inout_ PVOID     *BaseAddress,
	_In_    ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T   RegionSize,
	_In_    ULONG     AllocationType,
	_In_    ULONG     Protect
);

NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

NTKERNELAPI
NTSTATUS
IoCreateDriver(
	IN PUNICODE_STRING DriverName, OPTIONAL
	IN PDRIVER_INITIALIZE InitializationFunction
);

NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG NewProtect,
	__out PULONG OldProtect
);

```

`driver/ioctls.h`:

```h
#pragma once
#include "definitions.h"
#define ioctl_read_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_write_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_get_module_base CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) 
#define ioctl_protect_virutal_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) 
#define ioctl_allocate_virtual_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x812, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _k_get_base_module_request {
	ULONG pid;
	ULONGLONG handle;
	WCHAR name[260];
} k_get_base_module_request, *pk_get_base_module_request;

typedef struct _k_rw_request {
	ULONG pid;
	ULONGLONG src;
	ULONGLONG dst;
	ULONGLONG size;
} k_rw_request, *pk_rw_request;

typedef struct _k_alloc_mem_request {
	ULONG pid, allocation_type, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_alloc_mem_request, *pk_alloc_mem_request;

typedef struct _k_protect_mem_request {
	ULONG pid, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_protect_mem_request, *pk_protect_mem_request;
```

`driver/main.c`:

```c
#include "definitions.h"
#include "ioctls.h"

#define drv_device L"\\Device\\injdrv"
#define drv_dos_device L"\\DosDevices\\injdrv"
#define drv  L"\\Driver\\injdrv"

PDEVICE_OBJECT driver_object;
UNICODE_STRING dev, dos;

NTSTATUS unload_driver(PDRIVER_OBJECT driver);
NTSTATUS ioctl_create(PDEVICE_OBJECT device, PIRP irp); 
NTSTATUS ioctl_close(PDEVICE_OBJECT device, PIRP irp);
NTSTATUS io_device_control(PDEVICE_OBJECT device, PIRP Irp);
__inline NTSTATUS copy_memory(PEPROCESS src_proc, PEPROCESS target_proc, PVOID src, PVOID dst, SIZE_T size);
ULONGLONG get_module_handle(ULONG pid, LPCWSTR module_name);

NTSTATUS init(PDRIVER_OBJECT driver, PUNICODE_STRING path) { 
	RtlInitUnicodeString(&dev, drv_device);
	RtlInitUnicodeString(&dos, drv_dos_device);

	IoCreateDevice(driver, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &driver_object);
	IoCreateSymbolicLink(&dos, &dev);

	driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = io_device_control;
	driver->MajorFunction[IRP_MJ_CREATE] = ioctl_create;
	driver->MajorFunction[IRP_MJ_CLOSE] = ioctl_close;
	driver->DriverUnload = unload_driver;

	driver_object->Flags |= DO_DIRECT_IO;
	driver_object->Flags &= ~DO_DEVICE_INITIALIZING;

	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT driver,	PUNICODE_STRING path) { 
	NTSTATUS        status;
	UNICODE_STRING drv_name;
	RtlInitUnicodeString(&drv_name, drv);
	return IoCreateDriver(&drv_name, &init); 
}
 
NTSTATUS io_device_control(PDEVICE_OBJECT device, PIRP irp){
	NTSTATUS status;
	ULONG info_size = 0; 
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
	ULONG control_code = stack->Parameters.DeviceIoControl.IoControlCode; 
	
	switch (control_code) {
	case ioctl_allocate_virtual_memory: {
			pk_alloc_mem_request in = (pk_alloc_mem_request)irp->AssociatedIrp.SystemBuffer;
			PEPROCESS target_proc;
			status = PsLookupProcessByProcessId(in->pid, &target_proc); 
			if (NT_SUCCESS(status)) {
				KAPC_STATE apc;
				KeStackAttachProcess(target_proc, &apc);
				status = ZwAllocateVirtualMemory(ZwCurrentProcess(), &in->addr, 0, &in->size,
					in->allocation_type, in->protect);
				KeUnstackDetachProcess(&apc);
				ObfDereferenceObject(target_proc);
			} 
			info_size = sizeof(k_alloc_mem_request);
		} break;

	case ioctl_protect_virutal_memory: {
			pk_protect_mem_request in = (pk_protect_mem_request)irp->AssociatedIrp.SystemBuffer;
			PEPROCESS target_proc;
			status = PsLookupProcessByProcessId(in->pid, &target_proc);
			if (NT_SUCCESS(status)) {
				KAPC_STATE apc;
				ULONG old_protection;
				KeStackAttachProcess(target_proc, &apc);
				status = ZwProtectVirtualMemory(ZwCurrentProcess(), &in->addr, &in->size, in->protect, &old_protection);
				KeUnstackDetachProcess(&apc);
				in->protect = old_protection;
				ObfDereferenceObject(target_proc);
			}
			info_size = sizeof(k_protect_mem_request);
		} break;
	
	case ioctl_read_memory: {
			pk_rw_request in = (pk_rw_request)irp->AssociatedIrp.SystemBuffer;
			PEPROCESS target_proc; 
			status = PsLookupProcessByProcessId(in->pid, &target_proc);
			if (NT_SUCCESS(status)) {
				status = copy_memory(PsGetCurrentProcess(), target_proc, in->src, in->dst, in->size);
				ObfDereferenceObject(target_proc);
			} 
			info_size = sizeof(k_rw_request);
		} break;

	case ioctl_write_memory: {
			pk_rw_request in = (pk_rw_request)irp->AssociatedIrp.SystemBuffer;
			PEPROCESS target_proc; 
			status = PsLookupProcessByProcessId(in->pid, &target_proc);
			if (NT_SUCCESS(status)) {
				status = copy_memory(target_proc, PsGetCurrentProcess(), in->src, in->dst, in->size);
				ObfDereferenceObject(target_proc);
			}
			info_size = sizeof(k_rw_request);
		} break;

	case ioctl_get_module_base: {
			pk_get_base_module_request in = (pk_get_base_module_request)irp->AssociatedIrp.SystemBuffer;
			ULONGLONG handle = get_module_handle(in->pid, in->name);
			in->handle = handle;
			status = STATUS_SUCCESS;
			info_size = sizeof(k_get_base_module_request);
		} break;

	default:
			status = STATUS_INVALID_PARAMETER;
			info_size = 0;
		break;
	}


	irp->IoStatus.Status = status;
	irp->IoStatus.Information = info_size;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return status;
}

NTSTATUS unload_driver(PDRIVER_OBJECT driver) {
	IoDeleteSymbolicLink(&dos);
	IoDeleteDevice(driver->DeviceObject);
}

NTSTATUS ioctl_create(PDEVICE_OBJECT device, PIRP irp) {
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS ioctl_close(PDEVICE_OBJECT device, PIRP irp) {
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

__inline NTSTATUS copy_memory(PEPROCESS src_proc, PEPROCESS target_proc, PVOID src, PVOID dst, SIZE_T size) {
	PSIZE_T bytes;
	return MmCopyVirtualMemory(target_proc, src, src_proc, dst, size, UserMode, &bytes);
}

ULONGLONG get_module_handle(ULONG pid, LPCWSTR module_name) {
	PEPROCESS target_proc;
	ULONGLONG base = 0;
	if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &target_proc)))
		return 0;

	KeAttachProcess((PKPROCESS)target_proc);

	PPEB peb = PsGetProcessPeb(target_proc);
	if (!peb)
		goto end;

	if (!peb->Ldr || !peb->Ldr->Initialized)
		goto end;


	UNICODE_STRING module_name_unicode;
	RtlInitUnicodeString(&module_name_unicode, module_name);
	for (PLIST_ENTRY list = peb->Ldr->InLoadOrderModuleList.Flink;
		list != &peb->Ldr->InLoadOrderModuleList;
		list = list->Flink) {
		PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (RtlCompareUnicodeString(&entry->BaseDllName, &module_name_unicode, TRUE) == 0) {
			base = entry->DllBase;
			goto end;
		}
	}

end:
	KeDetachProcess();
	ObDereferenceObject(target_proc);
	return base;
}

```

`example_dll/dllmain.cpp`:

```cpp
#include <windows.h>
#include <stdint.h>


/* Compile as x64 Release !!! */

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 ) { 
					 
	if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
		MessageBox(0, L"Done.", L"Injected", MB_OK | MB_ICONERROR);
	}
}



```

`mmap/kernelmode_proc_handler.cpp`:

```cpp
#include "kernelmode_proc_handler.hpp"

kernelmode_proc_handler::kernelmode_proc_handler() 
	:handle{ INVALID_HANDLE_VALUE }, pid{ 0 } {}

kernelmode_proc_handler::~kernelmode_proc_handler() { if (is_attached()) CloseHandle(handle); }

bool kernelmode_proc_handler::is_attached() { return handle != INVALID_HANDLE_VALUE; }

bool kernelmode_proc_handler::attach(const char* proc_name) {
	bool is_admin{ false };
	HANDLE token_handle{ NULL };
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token_handle)) {
		TOKEN_ELEVATION token;
		DWORD size = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(token_handle, TokenElevation, &token, sizeof(TOKEN_ELEVATION), &size)) {
			is_admin = true;
		}
		CloseHandle(token_handle);
	}

	if (!is_admin) {
		LOG_ERROR("Launch as admin");
		return false;
	}

	while (!is_process_running(proc_name, pid))
		std::this_thread::sleep_for(std::chrono::seconds(1));

	handle = CreateFileA("\\\\.\\injdrv", GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);

	if (handle == INVALID_HANDLE_VALUE) {
		LOG_ERROR("Load the driver first");
		return false;
	}

	return true;
};

uint64_t kernelmode_proc_handler::get_module_base(const std::string &module_name) {
	if (handle == INVALID_HANDLE_VALUE)
		return 0;
	k_get_base_module_request req;
	req.pid = pid;
	req.handle = 0;
	std::wstring wstr{ std::wstring(module_name.begin(), module_name.end()) };
	memset(req.name, 0, sizeof(WCHAR) * 260);
	wcscpy(req.name, wstr.c_str());
	DWORD bytes_read;
	if (DeviceIoControl(handle, ioctl_get_module_base, &req,
		sizeof(k_get_base_module_request), &req, sizeof(k_get_base_module_request), &bytes_read, 0)) {
		return req.handle;
	}
	return req.handle;
}

void kernelmode_proc_handler::read_memory(uintptr_t src, uintptr_t dst, size_t size) {
	if (handle == INVALID_HANDLE_VALUE)
		return;
	k_rw_request request{ pid, src, dst, size };
	DWORD bytes_read;
	DeviceIoControl(handle, ioctl_read_memory, &request, sizeof(k_rw_request), 0, 0, &bytes_read, 0);
}

void kernelmode_proc_handler::write_memory(uintptr_t dst, uintptr_t src, size_t size) {
	if (handle == INVALID_HANDLE_VALUE)
		return;
	DWORD bytes_read;
	k_rw_request request{ pid, src, dst, size };
	DeviceIoControl(handle, ioctl_write_memory, &request, sizeof(k_rw_request), 0, 0, &bytes_read, 0);
}

uint32_t kernelmode_proc_handler::virtual_protect(uint64_t address, size_t size, uint32_t protect) {
	if (handle == INVALID_HANDLE_VALUE)
		return 0;
	DWORD bytes_read;
	k_protect_mem_request request{ pid, protect, address, size };
	if (DeviceIoControl(handle, ioctl_protect_virutal_memory, &request, sizeof(k_protect_mem_request), &request, sizeof(k_protect_mem_request), &bytes_read, 0))
		return protect;
	return 0;
}

uint64_t kernelmode_proc_handler::virtual_alloc(size_t size, uint32_t allocation_type, uint32_t protect, uint64_t address) {
	if (handle == INVALID_HANDLE_VALUE)
		return 0;
	DWORD bytes_read;
	k_alloc_mem_request request{ pid, MEM_COMMIT | MEM_RESERVE, protect, address, size };
	if (DeviceIoControl(handle, ioctl_allocate_virtual_memory, &request, sizeof(k_rw_request), &request, sizeof(k_rw_request), &bytes_read, 0))
		return request.addr;
	return 0;
}
 

```

`mmap/kernelmode_proc_handler.hpp`:

```hpp
#pragma once 
#include "process_handler.hpp"
#include "logger.hpp"
#include "utils.h"

#define ioctl_read_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_write_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_get_module_base CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) 
#define ioctl_protect_virutal_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) 
#define ioctl_allocate_virtual_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x812, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)


typedef struct _k_get_base_module_request {
	ULONG pid;
	ULONGLONG handle;
	WCHAR name[260];
} k_get_base_module_request, *pk_get_base_module_request;

typedef struct _k_rw_request {
	ULONG pid;
	ULONGLONG src;
	ULONGLONG dst;
	ULONGLONG size; 
} k_rw_request, *pk_rw_request;

typedef struct _k_alloc_mem_request {
	ULONG pid, allocation_type, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_alloc_mem_request, *pk_alloc_mem_request;

typedef struct _k_protect_mem_request {
	ULONG pid, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_protect_mem_request, *pk_protect_mem_request;

class kernelmode_proc_handler final : public process_handler {
	HANDLE handle;
	uint32_t pid;
public:
	kernelmode_proc_handler();

	~kernelmode_proc_handler();

	virtual bool is_attached() override;

	virtual bool attach(const char* proc_name) override;

	virtual	uint64_t get_module_base(const std::string &module_name) override;

	virtual void read_memory(uintptr_t src, uintptr_t dst, size_t size) override;

	virtual void write_memory(uintptr_t dst, uintptr_t src, size_t size) override;

	virtual uint32_t virtual_protect(uint64_t address, size_t size, uint32_t protect) override;

	virtual uint64_t virtual_alloc(size_t size, uint32_t allocation_type, uint32_t protect, uint64_t address = NULL) override;
};
```

`mmap/logger.hpp`:

```hpp
#include <cstdio>

#define LOG_ERROR(str, ...) fprintf(stderr,"ERROR: " str "\n", ##__VA_ARGS__)

#define LOG(str, ...) fprintf(stdout, str "\n", ##__VA_ARGS__)

```

`mmap/main.cpp`:

```cpp
#include "mmap.hpp"

int main(int argc, char **argv) { 
	mmap mapper(INJECTION_TYPE::KERNEL);

	if (!mapper.attach_to_process("notepad.exe"))
		return 1;

	if (!mapper.load_dll("example_dll.dll"))
		return 1;

	if (!mapper.inject())
		return 1;

	LOG("\nPress any key to close.");
	std::getchar();
	 
	return 0;
}
```

`mmap/mmap.cpp`:

```cpp
#include "mmap.hpp"

mmap::mmap(INJECTION_TYPE type) {
	if (type == INJECTION_TYPE::KERNEL)
		proc = std::make_unique<kernelmode_proc_handler>();
	else
		proc = std::make_unique<usermode_proc_handler>();
}

bool mmap::attach_to_process(const char* process_name) {
	this->process_name = process_name;
	if (!proc->attach(process_name)) {
		LOG_ERROR("Unable to attach to process!");
		return false;
	}
	 
	LOG("Attached to process %s successfully...", process_name); 
	return true;
}
 
bool mmap::load_dll(const char* file_name) {
	std::ifstream f(file_name, std::ios::binary | std::ios::ate);

	if (!f) {
		LOG_ERROR("Unable to open DLL file!");
		return false;
	}

	std::ifstream::pos_type pos{ f.tellg() };
	data_size = pos; 

	raw_data = new uint8_t[data_size];

	if (!raw_data)
		return false;

	f.seekg(0, std::ios::beg);
	f.read((char*)raw_data, data_size);
	 
	f.close();
	return true;
}
  
bool mmap::inject() {

	if (!proc->is_attached()) {
		LOG_ERROR("Not attached to process!");
		return false;
	}

	if (!raw_data) {
		LOG_ERROR("Data buffer is empty!");
		return false;
	}

	//stub compiled with nasm: https://www.nasm.us/
	uint8_t dll_stub[] = { "\x51\x52\x55\x56\x53\x57\x41\x50\x41\x51\x41\x52\x41\x53\x41\x54\x41\x55\x41\x56\x41\x57\x48\xB8\xFF\x00\xDE\xAD\xBE\xEF\x00\xFF\x48\xBA\xFF\x00\xDE\xAD\xC0\xDE\x00\xFF\x48\x89\x10\x48\x31\xC0\x48\x31\xD2\x48\x83\xEC\x28\x48\xB9\xDE\xAD\xBE\xEF\xDE\xAD\xBE\xEF\x48\x31\xD2\x48\x83\xC2\x01\x48\xB8\xDE\xAD\xC0\xDE\xDE\xAD\xC0\xDE\xFF\xD0\x48\x83\xC4\x28\x41\x5F\x41\x5E\x41\x5D\x41\x5C\x41\x5B\x41\x5A\x41\x59\x41\x58\x5F\x5B\x5E\x5D\x5A\x59\x48\x31\xC0\xC3" }; 
	
	/*
		dll_stub:
		00000000  51                push rcx
		00000001  52                push rdx
		00000002  55                push rbp
		00000003  56                push rsi
		00000004  53                push rbx
		00000005  57                push rdi
		00000006  4150              push r8
		00000008  4151              push r9
		0000000A  4152              push r10
		0000000C  4153              push r11
		0000000E  4154              push r12
		00000010  4155              push r13
		00000012  4156              push r14
		00000014  4157              push r15
		00000016  48B8FF00DEADBEEF  mov rax,0xff00efbeadde00ff
				 -00FF
		00000020  48BAFF00DEADC0DE  mov rdx,0xff00dec0adde00ff
				 -00FF
		0000002A  488910            mov [rax],rdx
		0000002D  4831C0            xor rax,rax
		00000030  4831D2            xor rdx,rdx
		00000033  4883EC28          sub rsp,byte +0x28
		00000037  48B9DEADBEEFDEAD  mov rcx,0xefbeaddeefbeadde
				 -BEEF
		00000041  4831D2            xor rdx,rdx
		00000044  4883C201          add rdx,byte +0x1
		00000048  48B8DEADC0DEDEAD  mov rax,0xdec0addedec0adde
				 -C0DE
		00000052  FFD0              call rax
		00000054  4883C428          add rsp,byte +0x28
		00000058  415F              pop r15
		0000005A  415E              pop r14
		0000005C  415D              pop r13
		0000005E  415C              pop r12
		00000060  415B              pop r11
		00000062  415A              pop r10
		00000064  4159              pop r9
		00000066  4158              pop r8
		00000068  5F                pop rdi
		00000069  5B                pop rbx
		0000006A  5E                pop rsi
		0000006B  5D                pop rbp
		0000006C  5A                pop rdx
		0000006D  59                pop rcx
		0000006E  4831C0            xor rax,rax
		00000071  C3                ret
	*/

	IMAGE_DOS_HEADER *dos_header{ (IMAGE_DOS_HEADER *)raw_data };

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
		LOG_ERROR("Invalid DOS header signature!");
		return false;
	}

	IMAGE_NT_HEADERS *nt_header{ (IMAGE_NT_HEADERS *)(&raw_data[dos_header->e_lfanew]) };

	if (nt_header->Signature != IMAGE_NT_SIGNATURE) {
		LOG_ERROR("Invalid NT header signature!");
		return false;
	}

	uint64_t base{ proc->virtual_alloc(nt_header->OptionalHeader.SizeOfImage,
									   MEM_COMMIT | MEM_RESERVE,
									   PAGE_EXECUTE_READWRITE) };

	if (!base) {
		LOG_ERROR("Unable to allocate memory for the image!");
		return false;
	}

	LOG("Image base: 0x%p", base);

	uint64_t stub_base{ proc->virtual_alloc(sizeof(dll_stub),
											MEM_COMMIT | MEM_RESERVE,
											PAGE_EXECUTE_READWRITE) };

	if (!stub_base) {
		LOG_ERROR("Unable to allocate memory for the stub!");
		return false;
	}

	LOG("Stub base: 0x%p", stub_base);

	PIMAGE_IMPORT_DESCRIPTOR import_descriptor{ (PIMAGE_IMPORT_DESCRIPTOR)get_ptr_from_rva(
												(uint64_t)(nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress),
												nt_header,
												raw_data) };

	if (nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
		LOG("Solving imports...");
		solve_imports(raw_data, nt_header, import_descriptor);
	}

	PIMAGE_BASE_RELOCATION base_relocation{ (PIMAGE_BASE_RELOCATION) get_ptr_from_rva(
																		nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
																		nt_header, 
																		raw_data)};

	if (nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
		LOG("Solving relocations..."); 
		solve_relocations((uint64_t) raw_data,
						  base,
						  nt_header,
						  base_relocation,
						  nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
	}

	 
	if (!parse_imports()) {
		LOG_ERROR("Unable to parse imports!");
		return false;
	} 

	uint64_t iat_function_ptr{ imports["TranslateMessage"] };
	if (!iat_function_ptr) { 
		LOG_ERROR("Cannot find import");
		return false;
	}

	uint64_t orginal_function_addr{ read_memory<uint64_t>(iat_function_ptr) };
	LOG("IAT function pointer: 0x%p", iat_function_ptr);

	*(uint64_t*)(dll_stub + 0x18) = iat_function_ptr;
	*(uint64_t*)(dll_stub + 0x22) = orginal_function_addr;
	/* Save pointer and orginal function address for stub to restre it.
	mov rax, 0xff00efbeadde00ff  ; dll_stub + 0x18 (iat_function_ptr)
	mov rdx, 0xff00dec0adde00ff  ; dll_stub + 0x22 (orginal_function_addr)
	mov qword [rax], rdx
	xor rax, rax
	xor rdx, rdx
	*/

	proc->write_memory(base, (uintptr_t)raw_data, nt_header->FileHeader.SizeOfOptionalHeader + sizeof(nt_header->FileHeader) + sizeof(nt_header->Signature));

	LOG("Mapping PE sections...");
	map_pe_sections(base, nt_header);

	uint64_t entry_point{ (uint64_t)base + nt_header->OptionalHeader.AddressOfEntryPoint };
	*(uint64_t*)(dll_stub + 0x39) = (uint64_t)base;
	*(uint64_t*)(dll_stub + 0x4a) = entry_point;
	/* Save module_base and entry_point to call dllmain correctly
	sub rsp, 0x28
	mov rcx, 0xefbeaddeefbeadde ; dll_stub + 0x39 (base)
	xor rdx, rdx
	add rdx, 1
	mov rax, 0xdec0addedec0adde ; dll_stub + 0x4a (entry_point)
	call rax
	*/

	LOG("Entry point: 0x%p", entry_point);	

	proc->write_memory(stub_base, (uintptr_t)dll_stub, sizeof(dll_stub));

	proc->virtual_protect(iat_function_ptr, sizeof(uint64_t), PAGE_READWRITE);
	proc->write_memory(iat_function_ptr, (uintptr_t)&stub_base, sizeof(uint64_t));

	LOG("Injected successfully!");

	system("Pause");
	proc->virtual_protect(iat_function_ptr, sizeof(uint64_t), PAGE_READONLY);

	delete [] raw_data;
	return true;
} 

uint64_t* mmap::get_ptr_from_rva(uint64_t rva, IMAGE_NT_HEADERS * nt_header, uint8_t * image_base) {
	PIMAGE_SECTION_HEADER section_header{ get_enclosing_section_header(rva, nt_header) };

	if (!section_header)
		return 0; 

	int64_t delta{ (int64_t)(section_header->VirtualAddress - section_header->PointerToRawData) };
	return (uint64_t*)(image_base + rva - delta);
}

PIMAGE_SECTION_HEADER mmap::get_enclosing_section_header(uint64_t rva, PIMAGE_NT_HEADERS nt_header) {
	PIMAGE_SECTION_HEADER section{ IMAGE_FIRST_SECTION(nt_header) };  

	for (int i = 0; i < nt_header->FileHeader.NumberOfSections; i++, section++) { 
		uint64_t size{ section->Misc.VirtualSize };
		if (!size)
			size = section->SizeOfRawData;

		if ((rva >= section->VirtualAddress) &&
			(rva < (section->VirtualAddress + size)))
			return section;
	} 

	return 0;
}
  
void mmap::solve_imports(uint8_t *base, IMAGE_NT_HEADERS *nt_header, IMAGE_IMPORT_DESCRIPTOR *import_descriptor) {
	char* module; 
	while ((module = (char *)get_ptr_from_rva((DWORD64)(import_descriptor->Name), nt_header, (PBYTE)base))) {
		HMODULE local_module{ LoadLibrary(module) };
		/*dll should be compiled statically to avoid loading new libraries
		if (!process.get_module_base(module)) {
				process.load_library(module);
		}*/
		
		IMAGE_THUNK_DATA *thunk_data{ (IMAGE_THUNK_DATA *)get_ptr_from_rva((DWORD64)(import_descriptor->FirstThunk), nt_header, (PBYTE)base) };

		while (thunk_data->u1.AddressOfData) {
			IMAGE_IMPORT_BY_NAME *iibn{ (IMAGE_IMPORT_BY_NAME *)get_ptr_from_rva((DWORD64)((thunk_data->u1.AddressOfData)), nt_header, (PBYTE)base) };
			thunk_data->u1.Function = (uint64_t)(get_proc_address(module, (char *)iibn->Name));
			thunk_data++;
		} 
		import_descriptor++;
	} 

	return;
}
 
void mmap::solve_relocations(uint64_t base, uint64_t relocation_base, IMAGE_NT_HEADERS * nt_header, IMAGE_BASE_RELOCATION * reloc, size_t size) {
	uint64_t image_base{ nt_header->OptionalHeader.ImageBase };
	uint64_t delta{ relocation_base - image_base };
	unsigned int bytes{ 0 };  

	while (bytes < size) {
		uint64_t *reloc_base{ (uint64_t *)get_ptr_from_rva((uint64_t)(reloc->VirtualAddress), nt_header, (PBYTE)base) };
		auto num_of_relocations{ (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD) };
		auto reloc_data = (uint16_t*)((uint64_t)reloc + sizeof(IMAGE_BASE_RELOCATION));

		for (unsigned int i = 0; i < num_of_relocations; i++) {
			if (((*reloc_data >> 12) & IMAGE_REL_BASED_HIGHLOW))
				*(uint64_t*)((uint64_t)reloc_base + ((uint64_t)(*reloc_data & 0x0FFF))) += delta;
			reloc_data++;
		}

		bytes += reloc->SizeOfBlock;
		reloc = (IMAGE_BASE_RELOCATION *)reloc_data;
	}

	return;
}

void mmap::map_pe_sections(uint64_t base, IMAGE_NT_HEADERS * nt_header) {
	auto header{ IMAGE_FIRST_SECTION(nt_header) };
	size_t virtual_size{ 0 };
	size_t bytes{ 0 }; 

	while(nt_header->FileHeader.NumberOfSections&&(bytes<nt_header->OptionalHeader.SizeOfImage)) { 
		proc->write_memory(base + header->VirtualAddress, (uintptr_t)(raw_data + header->PointerToRawData), header->SizeOfRawData); 
		virtual_size = header->VirtualAddress; 
		virtual_size = (++header)->VirtualAddress - virtual_size;
		bytes += virtual_size;

		/*
			TODO:
			Add page protection
		*/
	}

	return;
}

uint64_t mmap::get_proc_address(const char* module_name, const char* func) {
	uint64_t remote_module{ proc->get_module_base(module_name) };
	uint64_t local_module{ (uint64_t)GetModuleHandle(module_name) };
	uint64_t delta{ remote_module - local_module };
	return ((uint64_t)GetProcAddress((HMODULE)local_module, func) + delta);
}

bool mmap::parse_imports() {
	auto base{ proc->get_module_base(process_name.c_str()) };
	if (!base) {
		LOG_ERROR("Cannot get module base");
		return false;
	}

	auto dos_header{ read_memory< IMAGE_DOS_HEADER >(base) };
	auto nt_headers{ read_memory< IMAGE_NT_HEADERS >(base + dos_header.e_lfanew) };
	auto descriptor{ read_memory< IMAGE_IMPORT_DESCRIPTOR >(base + nt_headers.OptionalHeader.DataDirectory[1].VirtualAddress) };

	int descriptor_count{ 0 };
	int thunk_count{ 0 };

	while (descriptor.Name) {
		auto first_thunk{ read_memory< IMAGE_THUNK_DATA >(base + descriptor.FirstThunk) };
		auto original_first_thunk{ read_memory< IMAGE_THUNK_DATA >(base + descriptor.OriginalFirstThunk) };
		thunk_count = 0;

		while (original_first_thunk.u1.AddressOfData) {
			char name[256];
			proc->read_memory(base + original_first_thunk.u1.AddressOfData + 0x2, (uintptr_t)name, 256);
			std::string str_name(name);
			auto thunk_offset{ thunk_count * sizeof(uintptr_t) };

			if (str_name.length() > 0)
				imports[str_name] = base + descriptor.FirstThunk + thunk_offset; 
			

			++thunk_count;
			first_thunk = read_memory< IMAGE_THUNK_DATA >(base + descriptor.FirstThunk + sizeof(IMAGE_THUNK_DATA) * thunk_count);
			original_first_thunk = read_memory< IMAGE_THUNK_DATA >(base + descriptor.OriginalFirstThunk + sizeof(IMAGE_THUNK_DATA) * thunk_count);
		}

		++descriptor_count;
		descriptor = read_memory< IMAGE_IMPORT_DESCRIPTOR >(base + nt_headers.OptionalHeader.DataDirectory[1].VirtualAddress + sizeof(IMAGE_IMPORT_DESCRIPTOR) * descriptor_count);
	}

	return (imports.size() > 0);
}

```

`mmap/mmap.hpp`:

```hpp
#pragma once
#include "usermode_proc_handler.hpp"
#include "kernelmode_proc_handler.hpp"
#include <thread>
#include <chrono>
#include <fstream>
#include <string>
#include <sstream>
#include "logger.hpp"

enum INJECTION_TYPE{
	KERNEL,
	USERMODE
};

class mmap {
	std::unique_ptr<process_handler> proc;
	std::string process_name;
	std::map<std::string, uint64_t> imports;
	uint8_t *raw_data;
	size_t data_size;
	
public:
	bool attach_to_process(const char* process_name);
	bool load_dll(const char* file_name);
	bool inject();

	mmap(INJECTION_TYPE type);

private:
	//https://github.com/martell/pedump/blob/master/common.h
	uint64_t * get_ptr_from_rva(uint64_t rva, IMAGE_NT_HEADERS * nt_header, uint8_t * image_base);
	PIMAGE_SECTION_HEADER get_enclosing_section_header(uint64_t rva, PIMAGE_NT_HEADERS nt_header);

	void solve_imports(uint8_t *base, IMAGE_NT_HEADERS *nt_header, IMAGE_IMPORT_DESCRIPTOR *impDesc);
	void solve_relocations(uint64_t base, uint64_t relocation_base, IMAGE_NT_HEADERS *nt_header, IMAGE_BASE_RELOCATION *reloc, size_t size);
	void map_pe_sections(uint64_t base, IMAGE_NT_HEADERS *nt_header);


	uint64_t get_proc_address(const char* module_name, const char* func);
	bool parse_imports();

	template <typename type>
	type read_memory(uint64_t src, uint64_t size = sizeof(type)) {
		type ret;
		proc->read_memory(src, (uintptr_t)&ret, size);
		return ret;
	}

};



```

`mmap/process_handler.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <cstdint>
#include <TlHelp32.h>
#include <map>
#include <iostream>
#include <string>
#include <iomanip>
#include <chrono>
#include <thread>
#include "utils.h"

class process_handler { 
public:
	virtual ~process_handler() { };

	virtual bool is_attached() = 0;

	virtual bool attach(const char* proc_name) = 0;

	virtual	uint64_t get_module_base(const std::string &module_name) = 0;

	virtual void read_memory(uintptr_t src, uintptr_t dst, size_t size) = 0;

	virtual void write_memory(uintptr_t dst, uintptr_t src, size_t size) = 0; 

	virtual uint32_t virtual_protect(uint64_t address, size_t size, uint32_t protect) = 0;

	virtual uint64_t virtual_alloc(size_t size, uint32_t allocation_type, uint32_t protect, uint64_t address = NULL) = 0;
};

```

`mmap/stub.asm`:

```asm
[bits 64]

;backup registers
push rcx
push rdx  
push rbp
push rsi
push rbx
push rdi
push r8
push r9
push r10
push r11
push r12
push r13
push r14
push r15
 
;restore import
mov rax, 0xff00efbeadde00ff
mov rdx, 0xff00dec0adde00ff
mov qword [rax], rdx
xor rax, rax
xor rdx, rdx
 
;prepare dllmain args
sub rsp, 0x28
mov rcx, 0xefbeaddeefbeadde ; hModule
xor rdx, rdx
add rdx, 1
 
mov rax, 0xdec0addedec0adde ; entry point
call rax
add rsp, 0x28
 
;restore registers
pop r15
pop r14
pop r13
pop r12
pop r11
pop r10
pop r9
pop r8
pop rdi
pop rbx
pop rsi
pop rbp
pop rdx
pop rcx
 
xor rax, rax
ret
```

`mmap/usermode_proc_handler.cpp`:

```cpp
#include "usermode_proc_handler.hpp"

usermode_proc_handler::usermode_proc_handler() 
	:handle{ NULL }, pid{ 0 } {}

usermode_proc_handler::~usermode_proc_handler() { if (handle) CloseHandle(handle); }

bool usermode_proc_handler::is_attached() {	return handle; }

bool usermode_proc_handler::attach(const char* proc_name) {
	while (!is_process_running(proc_name, pid))
		std::this_thread::sleep_for(std::chrono::seconds(1));

	handle = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, pid);

	return handle;
}

uint64_t usermode_proc_handler::get_module_base(const std::string &module_name) {
	MODULEENTRY32 module_entry{};
	module_entry.dwSize = sizeof(MODULEENTRY32);
	auto snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid) };
	if (snapshot == INVALID_HANDLE_VALUE)
		return false;
	if (Module32First(snapshot, &module_entry)) {
		do {
			if (!_stricmp(module_entry.szModule, module_name.c_str())) {
				CloseHandle(snapshot);
				return (uint64_t)module_entry.hModule;
			}
			module_entry.dwSize = sizeof(MODULEENTRY32);
		} while (Module32Next(snapshot, &module_entry));
	}
	CloseHandle(snapshot);
	return NULL;
}

void usermode_proc_handler::read_memory(uintptr_t src, uintptr_t dst, size_t size) {
	ReadProcessMemory(handle, (LPCVOID)src, (LPVOID)dst, size, NULL);
}

void usermode_proc_handler::write_memory(uintptr_t dst, uintptr_t src, size_t size) {
	WriteProcessMemory(handle, (LPVOID)dst, (LPVOID)src, size, NULL);
}

uint32_t usermode_proc_handler::virtual_protect(uint64_t address, size_t size, uint32_t protect) {
	DWORD old_protect{};
	VirtualProtectEx(handle, (LPVOID)address, size, protect, &old_protect);
	return old_protect;
}

uint64_t usermode_proc_handler::virtual_alloc(size_t size, uint32_t allocation_type, uint32_t protect, uint64_t address) {
	return (uint64_t)VirtualAllocEx(handle, (void*)address, size, allocation_type, protect);
}
```

`mmap/usermode_proc_handler.hpp`:

```hpp
#pragma once
#include "process_handler.hpp"

class usermode_proc_handler final : public process_handler {
	HANDLE handle;
	uint32_t pid;
public:
	usermode_proc_handler();

	~usermode_proc_handler();

	virtual bool is_attached() override;

	virtual bool attach(const char* proc_name) override;

	virtual	uint64_t get_module_base(const std::string &module_name) override;

	virtual void read_memory(uintptr_t src, uintptr_t dst, size_t size) override;

	virtual void write_memory(uintptr_t dst, uintptr_t src, size_t size) override; 

	virtual uint32_t virtual_protect(uint64_t address, size_t size, uint32_t protect) override;

	virtual uint64_t virtual_alloc(size_t size, uint32_t allocation_type, uint32_t protect, uint64_t address = NULL) override;
};
```

`mmap/utils.cpp`:

```cpp
#include "utils.h"

bool is_process_running(const char* process_name, uint32_t& pid) {
	PROCESSENTRY32 process_entry{};
	process_entry.dwSize = sizeof(PROCESSENTRY32);
	pid = 0;
	auto snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL) };
	if (snapshot == INVALID_HANDLE_VALUE)
		return false;
	if (Process32First(snapshot, &process_entry)) {
		do {
			if (!strcmp(process_name, process_entry.szExeFile)) {
				pid = process_entry.th32ProcessID;
				CloseHandle(snapshot);
				return true;
			}
		} while (Process32Next(snapshot, &process_entry));
	} 
	CloseHandle(snapshot);
	return false;
}
```

`mmap/utils.h`:

```h
#pragma once
#include <Windows.h>
#include <cstdint>
#include <TlHelp32.h>

bool is_process_running(const char* process_name, uint32_t& pid);
```