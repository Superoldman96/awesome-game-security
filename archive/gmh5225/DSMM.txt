Project Path: arc_gmh5225_DSMM_ay283t7p

Source Tree:

```txt
arc_gmh5225_DSMM_ay283t7p
├── DSMM
│   ├── DSMM.sln
│   ├── DSMM.vcxproj
│   ├── DSMM.vcxproj.filters
│   ├── DSMM.vcxproj.user
│   ├── Definitions.h
│   ├── Driver.c
│   ├── Ldrreloc.h
│   ├── Mmpte.h
│   ├── Payload.h
│   └── Shared.h
├── Payload
│   ├── Driver.c
│   ├── Payload.sln
│   ├── Payload.vcxproj
│   ├── Payload.vcxproj.filters
│   ├── Payload.vcxproj.user
│   ├── Shared.h
│   └── bin
│       └── Payload.sys
└── README.md

```

`DSMM/DSMM.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.62
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DSMM", "DSMM.vcxproj", "{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.ActiveCfg = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Build.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A19C5621-9017-4AD4-B672-8F78E12CCBD3}
	EndGlobalSection
EndGlobal

```

`DSMM/DSMM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DSMM</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Platform)\$(ConfigurationName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <PostBuildEvent>
      <Command>call "$(ProjectDir)peupdate\peupdate.exe" -c "$(TargetPath)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shared.h" />
    <ClInclude Include="Definitions.h" />
    <ClInclude Include="Ldrreloc.h" />
    <ClInclude Include="Mmpte.h" />
    <ClInclude Include="Payload.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DSMM/DSMM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Ldrreloc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Payload.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mmpte.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Shared.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DSMM/DSMM.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`DSMM/Definitions.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <ntddmou.h>
#include "Mmpte.h"

// Expand byte pattern
#define EXP(x) (PBYTE)x, sizeof(x) - 1

// Use debug output
#define DBG

#ifdef DBG
#define DPRINT(format, ...) DbgPrintEx(DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, format, __VA_ARGS__)
#else
#define DPRINT(...)
#endif

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif

#ifndef _WIN64
#define DUMP_BLOCK_SIZE 0x20000
#else
#define DUMP_BLOCK_SIZE 0x40000
#endif

#define MI_SYSTEM_RANGE_START 0xFFFF080000000000

#define MM_PTE_VALID_MASK 0x1
#define MM_PTE_WRITE_MASK 0x800
#define MM_PTE_OWNER_MASK 0x4
#define MM_PTE_WRITE_THROUGH_MASK 0x8
#define MM_PTE_CACHE_DISABLE_MASK 0x10
#define MM_PTE_ACCESS_MASK 0x20
#define MM_PTE_DIRTY_MASK 0x42
#define MM_PTE_LARGE_PAGE_MASK 0x80
#define MM_PTE_GLOBAL_MASK 0x100
#define MM_PTE_COPY_ON_WRITE_MASK 0x200
#define MM_PTE_PROTOTYPE_MASK 0x400
#define MM_PTE_TRANSITION_MASK 0x800

//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

	//
	// Link to other blocks
	//

	LIST_ENTRY64 List;

	//
	// This is a unique tag to identify the owner of the block.
	// If your component only uses one pool tag, use it for this, too.
	//

	ULONG           OwnerTag;

	//
	// This must be initialized to the size of the data block,
	// including this structure.
	//

	ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;

//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

	DBGKD_DEBUG_DATA_HEADER64 Header;

	//
	// Base address of kernel image
	//

	ULONG64   KernBase;

	//
	// DbgBreakPointWithStatus is a function which takes an argument
	// and hits a breakpoint.  This field contains the address of the
	// breakpoint instruction.  When the debugger sees a breakpoint
	// at this address, it may retrieve the argument from the first
	// argument register, or on x86 the eax register.
	//

	ULONG64   BreakpointWithStatus;       // address of breakpoint

										  //
										  // Address of the saved context record during a bugcheck
										  //
										  // N.B. This is an automatic in KeBugcheckEx's frame, and
										  // is only valid after a bugcheck.
										  //

	ULONG64   SavedContext;

	//
	// help for walking stacks with user callbacks:
	//

	//
	// The address of the thread structure is provided in the
	// WAIT_STATE_CHANGE packet.  This is the offset from the base of
	// the thread structure to the pointer to the kernel stack frame
	// for the currently active usermode callback.
	//

	USHORT  ThCallbackStack;            // offset in thread data

										//
										// these values are offsets into that frame:
										//

	USHORT  NextCallback;               // saved pointer to next callback frame
	USHORT  FramePointer;               // saved frame pointer

										//
										// pad to a quad boundary
										//
	USHORT  PaeEnabled;

	//
	// Address of the kernel callout routine.
	//

	ULONG64   KiCallUserMode;             // kernel routine

										  //
										  // Address of the usermode entry point for callbacks.
										  //

	ULONG64   KeUserCallbackDispatcher;   // address in ntdll


										  //
										  // Addresses of various kernel data structures and lists
										  // that are of interest to the kernel debugger.
										  //

	ULONG64   PsLoadedModuleList;
	ULONG64   PsActiveProcessHead;
	ULONG64   PspCidTable;

	ULONG64   ExpSystemResourcesList;
	ULONG64   ExpPagedPoolDescriptor;
	ULONG64   ExpNumberOfPagedPools;

	ULONG64   KeTimeIncrement;
	ULONG64   KeBugCheckCallbackListHead;
	ULONG64   KiBugcheckData;

	ULONG64   IopErrorLogListHead;

	ULONG64   ObpRootDirectoryObject;
	ULONG64   ObpTypeObjectType;

	ULONG64   MmSystemCacheStart;
	ULONG64   MmSystemCacheEnd;
	ULONG64   MmSystemCacheWs;

	ULONG64   MmPfnDatabase;
	ULONG64   MmSystemPtesStart;
	ULONG64   MmSystemPtesEnd;
	ULONG64   MmSubsectionBase;
	ULONG64   MmNumberOfPagingFiles;

	ULONG64   MmLowestPhysicalPage;
	ULONG64   MmHighestPhysicalPage;
	ULONG64   MmNumberOfPhysicalPages;

	ULONG64   MmMaximumNonPagedPoolInBytes;
	ULONG64   MmNonPagedSystemStart;
	ULONG64   MmNonPagedPoolStart;
	ULONG64   MmNonPagedPoolEnd;

	ULONG64   MmPagedPoolStart;
	ULONG64   MmPagedPoolEnd;
	ULONG64   MmPagedPoolInformation;
	ULONG64   MmPageSize;

	ULONG64   MmSizeOfPagedPoolInBytes;

	ULONG64   MmTotalCommitLimit;
	ULONG64   MmTotalCommittedPages;
	ULONG64   MmSharedCommit;
	ULONG64   MmDriverCommit;
	ULONG64   MmProcessCommit;
	ULONG64   MmPagedPoolCommit;
	ULONG64   MmExtendedCommit;

	ULONG64   MmZeroedPageListHead;
	ULONG64   MmFreePageListHead;
	ULONG64   MmStandbyPageListHead;
	ULONG64   MmModifiedPageListHead;
	ULONG64   MmModifiedNoWritePageListHead;
	ULONG64   MmAvailablePages;
	ULONG64   MmResidentAvailablePages;

	ULONG64   PoolTrackTable;
	ULONG64   NonPagedPoolDescriptor;

	ULONG64   MmHighestUserAddress;
	ULONG64   MmSystemRangeStart;
	ULONG64   MmUserProbeAddress;

	ULONG64   KdPrintCircularBuffer;
	ULONG64   KdPrintCircularBufferEnd;
	ULONG64   KdPrintWritePointer;
	ULONG64   KdPrintRolloverCount;

	ULONG64   MmLoadedUserImageList;

	// NT 5.1 Addition

	ULONG64   NtBuildLab;
	ULONG64   KiNormalSystemCall;

	// NT 5.0 hotfix addition

	ULONG64   KiProcessorBlock;
	ULONG64   MmUnloadedDrivers;
	ULONG64   MmLastUnloadedDriver;
	ULONG64   MmTriageActionTaken;
	ULONG64   MmSpecialPoolTag;
	ULONG64   KernelVerifier;
	ULONG64   MmVerifierData;
	ULONG64   MmAllocatedNonPagedPool;
	ULONG64   MmPeakCommitment;
	ULONG64   MmTotalCommitLimitMaximum;
	ULONG64   CmNtCSDVersion;

	// NT 5.1 Addition

	ULONG64   MmPhysicalMemoryBlock;
	ULONG64   MmSessionBase;
	ULONG64   MmSessionSize;
	ULONG64   MmSystemParentTablePage;

	// Server 2003 addition

	ULONG64   MmVirtualTranslationBase;

	USHORT    OffsetKThreadNextProcessor;
	USHORT    OffsetKThreadTeb;
	USHORT    OffsetKThreadKernelStack;
	USHORT    OffsetKThreadInitialStack;

	USHORT    OffsetKThreadApcProcess;
	USHORT    OffsetKThreadState;
	USHORT    OffsetKThreadBStore;
	USHORT    OffsetKThreadBStoreLimit;

	USHORT    SizeEProcess;
	USHORT    OffsetEprocessPeb;
	USHORT    OffsetEprocessParentCID;
	USHORT    OffsetEprocessDirectoryTableBase;

	USHORT    SizePrcb;
	USHORT    OffsetPrcbDpcRoutine;
	USHORT    OffsetPrcbCurrentThread;
	USHORT    OffsetPrcbMhz;

	USHORT    OffsetPrcbCpuType;
	USHORT    OffsetPrcbVendorString;
	USHORT    OffsetPrcbProcStateContext;
	USHORT    OffsetPrcbNumber;

	USHORT    SizeEThread;

	ULONG64   KdPrintCircularBufferPtr;
	ULONG64   KdPrintBufferSize;

	ULONG64   KeLoaderBlock;

	USHORT    SizePcr;
	USHORT    OffsetPcrSelfPcr;
	USHORT    OffsetPcrCurrentPrcb;
	USHORT    OffsetPcrContainedPrcb;

	USHORT    OffsetPcrInitialBStore;
	USHORT    OffsetPcrBStoreLimit;
	USHORT    OffsetPcrInitialStack;
	USHORT    OffsetPcrStackLimit;

	USHORT    OffsetPrcbPcrPage;
	USHORT    OffsetPrcbProcStateSpecialReg;
	USHORT    GdtR0Code;
	USHORT    GdtR0Data;

	USHORT    GdtR0Pcr;
	USHORT    GdtR3Code;
	USHORT    GdtR3Data;
	USHORT    GdtR3Teb;

	USHORT    GdtLdt;
	USHORT    GdtTss;
	USHORT    Gdt64R3CmCode;
	USHORT    Gdt64R3CmTeb;

	ULONG64   IopNumTriageDumpDataBlocks;
	ULONG64   IopTriageDumpDataBlocks;

	// Longhorn addition

	ULONG64   VfCrashDataBlock;
	ULONG64   MmBadPagesDetected;
	ULONG64   MmZeroedPageSingleBitErrorsDetected;

	// Windows 7 addition

	ULONG64   EtwpDebuggerData;
	USHORT    OffsetPrcbContext;

	// Windows 8 addition

	USHORT    OffsetPrcbMaxBreakpoints;
	USHORT    OffsetPrcbMaxWatchpoints;

	ULONG     OffsetKThreadStackLimit;
	ULONG     OffsetKThreadStackBase;
	ULONG     OffsetKThreadQueueListEntry;
	ULONG     OffsetEThreadIrpList;

	USHORT    OffsetPrcbIdleThread;
	USHORT    OffsetPrcbNormalDpcState;
	USHORT    OffsetPrcbDpcStack;
	USHORT    OffsetPrcbIsrStack;

	USHORT    SizeKDPC_STACK_FRAME;

	// Windows 8.1 Addition

	USHORT    OffsetKPriQueueThreadListHead;
	USHORT    OffsetKThreadWaitReason;

	// Windows 10 RS1 Addition

	USHORT    Padding;
	ULONG64   PteBase;

	// Windows 10 RS5 Addition

	ULONG64 RetpolineStubFunctionTable;
	ULONG RetpolineStubFunctionTableSize;
	ULONG RetpolineStubOffset;
	ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

typedef struct _DUMP_HEADER
{
	ULONG Signature;
	ULONG ValidDump;
	ULONG MajorVersion;
	ULONG MinorVersion;
	ULONG_PTR DirectoryTableBase;
	ULONG_PTR PfnDataBase;
	PLIST_ENTRY PsLoadedModuleList;
	PLIST_ENTRY PsActiveProcessHead;
	ULONG MachineImageType;
	ULONG NumberProcessors;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParameter1;
	ULONG_PTR BugCheckParameter2;
	ULONG_PTR BugCheckParameter3;
	ULONG_PTR BugCheckParameter4;
	CHAR VersionUser[32];
	struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, *PDUMP_HEADER;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;
typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef VOID
(*fCUSTOM_INITIALIZE)(
	PVOID a1);

typedef PFN_NUMBER
(*fMiGetPage)(
	ULONG64 a1,
	ULONG a2,
	BYTE a3);

typedef BYTE
(*fMiInitializePfn)(
	PFN_NUMBER PageFrameIndex,
	PMMPTE PointerPte,
	ULONG ModifiedState,
	BYTE a4);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
	PVOID Base
);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
	PVOID ImageBase,
	BOOLEAN MappedAsImage,
	USHORT DirectoryEntry,
	PULONG Size
);

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);

ULONG
NTAPI
KeCapturePersistentThreadState(
	IN PCONTEXT Context,
	IN PKTHREAD Thread,
	IN ULONG BugCheckCode,
	IN ULONG BugCheckParameter1,
	IN ULONG BugCheckParameter2,
	IN ULONG BugCheckParameter3,
	IN ULONG BugCheckParameter4,
	OUT PVOID VirtualAddress
);
```

`DSMM/Driver.c`:

```c
#include "Definitions.h"
#include "Ldrreloc.h"
#include "Payload.h"
#include "Shared.h"

// Debug block
ULONG64 g_KernelBase = 0;
ULONG g_KernelSize = 0;
ULONG64 g_PTE_BASE = 0;
ULONG64 g_PDE_BASE = 0;
ULONG64 g_PPE_BASE = 0;
ULONG64 g_PXE_BASE = 0;
ULONG64 g_MmPfnDatabase = 0;

// Pattern scanned
fMiGetPage g_pMiGetPage = NULL;
fMiInitializePfn g_pMiInitializePfn = NULL;
PVOID g_pMiSystemPartition = NULL;

// Anti-resolve imports
IMPORTS g_Imports;

PMMPTE GetPxeAddress(_In_ PVOID addr)
{
	return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 39) << 3) + g_PXE_BASE);
}
PMMPTE GetPpeAddress(_In_ PVOID addr)
{
	return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 30) << 3) + g_PPE_BASE);
}
PMMPTE GetPdeAddress(_In_ PVOID addr)
{
	return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 21) << 3) + g_PDE_BASE);
}
PMMPTE GetPteAddress(_In_ PVOID addr)
{
	return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 12) << 3) + g_PTE_BASE);
}

PVOID FindPattern(_In_ ULONG64 qwBase, _In_ ULONG dwSize, _In_ PBYTE pbPattern, _In_ UINT uLength)
{
	UCHAR bWildcard = 0xAA;

	for (ULONG i = 0; i < dwSize - uLength; i++)
	{
		BOOLEAN bFound = TRUE;

		for (UINT j = 0; j < uLength; j++)
		{
			if (pbPattern[j] != bWildcard && pbPattern[j] != ((PBYTE)qwBase)[i + j])
			{
				bFound = FALSE;
				break;
			}
		}

		if (bFound != FALSE)
		{
			return (PBYTE)qwBase + i;
		}
	}

	return NULL;
}

NTSTATUS AllocateCodeCave(_In_ PVOID pBaseAddr, _In_ ULONG dwSize)
{
	MMPTE ValidKernelPte = {
		MM_PTE_VALID_MASK |
		MM_PTE_WRITE_MASK |
		MM_PTE_GLOBAL_MASK |
		MM_PTE_DIRTY_MASK |
		MM_PTE_ACCESS_MASK
	};

	UINT uCount = 0;
	UINT uPages = BYTES_TO_PAGES(dwSize);

	PMMPTE pStartPTE = GetPteAddress(pBaseAddr);
	PMMPTE pEndPTE = pStartPTE + uPages;

	// Show in WinDbg: dt !_mmpte pPTE -b
	for (PMMPTE pPTE = pStartPTE; pPTE < pEndPTE; ++pPTE)
	{
		DPRINT("[DSMM] %s: PTE %u/%u...\n", __FUNCTION__, uCount + 1, uPages);

		// Make PTE valid, executable, etc...
		*pPTE = ValidKernelPte;

		// Show in WinDbg: !pfn #
		PFN_NUMBER pfn = g_pMiGetPage((ULONG64)g_pMiSystemPartition, 0, 8);
		DPRINT("[DSMM] %s: pfn: 0x%llx\n", __FUNCTION__, pfn);

		BYTE result = g_pMiInitializePfn(g_MmPfnDatabase + (pfn * 0x30), pPTE, 4, 4);
		DPRINT("[DSMM] %s: result: %02x\n", __FUNCTION__, result);

		// Assign page frame number
		pPTE->u.Hard.PageFrameNumber = pfn;

		DPRINT("[DSMM] %s: Long: 0x%llx\n", __FUNCTION__, pPTE->u.Long);
		DPRINT("[DSMM] %s: Valid: %llu\n", __FUNCTION__, pPTE->u.Hard.Valid);
		DPRINT("[DSMM] %s: Write: %llu\n", __FUNCTION__, pPTE->u.Hard.Write);
		DPRINT("[DSMM] %s: NoExecute: %llu\n", __FUNCTION__, pPTE->u.Hard.NoExecute);
		DPRINT("[DSMM] %s: PageFrameNumber: 0x%llx\n", __FUNCTION__, pPTE->u.Hard.PageFrameNumber);

		if (result == 0)
		{
			uCount++;
		}
	}

	if (uCount == uPages)
	{
		return STATUS_SUCCESS;
	}

	return STATUS_UNSUCCESSFUL;
}
NTSTATUS FindReusablePteRegion(_In_ ULONG dwSize, _Out_ PVOID* ppBaseAddr)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;

	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		DPRINT("[DSMM] %s: Invalid SystemModuleInformation size\n", __FUNCTION__);
		return STATUS_UNSUCCESSFUL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPool, bytes);
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);
	if (NT_SUCCESS(status))
	{
		DPRINT("[DSMM] %s: NumberOfModules: %u\n", __FUNCTION__, pMods->NumberOfModules);

		status = STATUS_UNSUCCESSFUL;

		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

		for (ULONG i = 0; i < pMods->NumberOfModules - 1; i++) // Skip last loaded module (this module)
		{
			if (pMod[i].ImageBase > pMod[0].ImageBase) // Skip ntoskrnl and modules that are loaded in session space
			{
				if (!strstr((PCHAR)pMod[i].FullPathName, ".dll")) // Skip .dll modules
				{
					ULONG64 qwBase = 0;

					for (ULONG64 qwAddr = (ULONG64)pMod[i].ImageBase; qwAddr < (ULONG64)pMod[i].ImageBase + pMod[i].ImageSize; qwAddr += PAGE_SIZE)
					{
						// Check if pages of the driver's discardable section have been freed using their page table entries
						if (GetPdeAddress((PVOID)qwAddr)->u.Hard.Valid == 1 &&
							GetPpeAddress((PVOID)qwAddr)->u.Hard.Valid == 1 &&
							GetPxeAddress((PVOID)qwAddr)->u.Hard.Valid == 1 &&
							GetPteAddress((PVOID)qwAddr)->u.Long == 0)
						{
							DPRINT("[DSMM] %s: Invalid page inside module %s at: 0x%llx, base: 0x%llx\n",
								__FUNCTION__, pMod[i].FullPathName + pMod[i].OffsetToFileName, qwAddr, qwBase);

							if (qwBase)
							{
								if (qwAddr >= qwBase + dwSize)
								{
									status = STATUS_SUCCESS;
									break;
								}
							}
							else
							{
								qwBase = qwAddr;
							}
						}
						else
						{
							qwBase = 0;
						}
					}

					if (NT_SUCCESS(status))
					{
						DPRINT("[DSMM] %s: Largest region with invalid PTE's found inside module %s starting at: 0x%llx\n",
							__FUNCTION__, pMod[i].FullPathName + pMod[i].OffsetToFileName, qwBase);

						*ppBaseAddr = (PVOID)qwBase;
						break;
					}
				}
			}
		}
	}

	if (pMods)
	{
		ExFreePool(pMods);
	}

	return status;
}

NTSTATUS MMapDriver()
{
	NTSTATUS status = STATUS_SUCCESS;
	PVOID imageSection = NULL;

	PIMAGE_NT_HEADERS pNTHeader = RtlImageNtHeader(payload);
	if (!pNTHeader)
	{
		DPRINT("[DSMM] %s: Failed to obtain NT Header for driver\n", __FUNCTION__);
		return STATUS_INVALID_IMAGE_FORMAT;
	}

	DPRINT("[DSMM] %s: SizeOfImage: 0x%x\n", __FUNCTION__, pNTHeader->OptionalHeader.SizeOfImage);

	status = FindReusablePteRegion(pNTHeader->OptionalHeader.SizeOfImage, &imageSection);

	if (NT_SUCCESS(status) && imageSection)
	{
		status = AllocateCodeCave(imageSection, pNTHeader->OptionalHeader.SizeOfImage);

		DPRINT("[DSMM] %s: AllocateCodeCave: 0x%08x\n", __FUNCTION__, status);
	}

	if (NT_SUCCESS(status) && imageSection)
	{
		// Copy header
		RtlCopyMemory(imageSection, payload, pNTHeader->OptionalHeader.SizeOfHeaders);

		// Copy sections
		for (PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)(pNTHeader + 1);
			pSection < (PIMAGE_SECTION_HEADER)(pNTHeader + 1) + pNTHeader->FileHeader.NumberOfSections;
			pSection++)
		{
			RtlCopyMemory(
				(PUCHAR)imageSection + pSection->VirtualAddress,
				(PUCHAR)payload + pSection->PointerToRawData,
				pSection->SizeOfRawData
			);
		}

		// Relocate image
		status = LdrRelocateImage(imageSection, STATUS_SUCCESS, STATUS_CONFLICTING_ADDRESSES, STATUS_INVALID_IMAGE_FORMAT);
		if (!NT_SUCCESS(status))
		{
			DPRINT("[DSMM] %s: Failed to relocate image. Status: 0x%08x\n", __FUNCTION__, status);
		}
	}
	else
	{
		DPRINT("[DSMM] %s: Failed to allocate memory for driver mapping\n", __FUNCTION__);
		status = STATUS_MEMORY_NOT_ALLOCATED;
	}

	// Call entry point
	if (NT_SUCCESS(status) && pNTHeader->OptionalHeader.AddressOfEntryPoint)
	{
		fCUSTOM_INITIALIZE pEntryPoint = (fCUSTOM_INITIALIZE)((ULONG_PTR)imageSection + pNTHeader->OptionalHeader.AddressOfEntryPoint);

		// Resolving imports for a hack driver in 2020
		pEntryPoint(&g_Imports);
	}

	// Wipe header
	if (NT_SUCCESS(status) && imageSection)
	{
		RtlZeroMemory(imageSection, pNTHeader->OptionalHeader.SizeOfHeaders);
	}

	if (NT_SUCCESS(status))
	{
		DPRINT("[DSMM] %s: Successfully mapped driver at 0x%p\n", __FUNCTION__, imageSection);
	}

	return status;
}

BOOLEAN InitDebugBlock()
{
	KDDEBUGGER_DATA64 kdBlock = { 0 };

	CONTEXT context = { 0 };
	context.ContextFlags = CONTEXT_FULL;
	RtlCaptureContext(&context);

	PDUMP_HEADER dumpHeader = ExAllocatePool(NonPagedPool, DUMP_BLOCK_SIZE);
	if (dumpHeader)
	{
		KeCapturePersistentThreadState(&context, NULL, 0, 0, 0, 0, 0, dumpHeader);
		RtlCopyMemory(&kdBlock, (PUCHAR)dumpHeader + KDDEBUGGER_DATA_OFFSET, sizeof(kdBlock));

		ExFreePool(dumpHeader);

		g_KernelBase = kdBlock.KernBase;

		PIMAGE_NT_HEADERS pNTHeader = RtlImageNtHeader((PVOID)g_KernelBase);
		g_KernelSize = pNTHeader->OptionalHeader.SizeOfImage;

		// Get database base address
		// Show in windbg: ? poi(nt!MmPfnDatabase)
		g_MmPfnDatabase = *(ULONG64*)(kdBlock.MmPfnDatabase);
		
		// Only RS1+
		// Show in windbg: !pte
		g_PTE_BASE = kdBlock.PteBase;
		g_PDE_BASE = (g_PTE_BASE + ((g_PTE_BASE & 0xffffffffffff) >> 9));
		g_PPE_BASE = (g_PTE_BASE + ((g_PDE_BASE & 0xffffffffffff) >> 9));
		g_PXE_BASE = (g_PTE_BASE + ((g_PPE_BASE & 0xffffffffffff) >> 9));

		DPRINT("[DSMM] %s: KernelBase: 0x%llx\n", __FUNCTION__, g_KernelBase);
		DPRINT("[DSMM] %s: KernelSize: 0x%x\n", __FUNCTION__, g_KernelSize);
		DPRINT("[DSMM] %s: MmPfnDatabase: 0x%llx\n", __FUNCTION__, g_MmPfnDatabase);
		DPRINT("[DSMM] %s: PTE_BASE: 0x%llx\n", __FUNCTION__, g_PTE_BASE);
		DPRINT("[DSMM] %s: PDE_BASE: 0x%llx\n", __FUNCTION__, g_PDE_BASE);
		DPRINT("[DSMM] %s: PPE_BASE: 0x%llx\n", __FUNCTION__, g_PPE_BASE);
		DPRINT("[DSMM] %s: PXE_BASE: 0x%llx\n", __FUNCTION__, g_PXE_BASE);

		if (g_KernelBase &&
			g_KernelSize &&
			g_MmPfnDatabase &&
			g_PTE_BASE >= MI_SYSTEM_RANGE_START &&
			g_PDE_BASE >= MI_SYSTEM_RANGE_START &&
			g_PPE_BASE >= MI_SYSTEM_RANGE_START &&
			g_PXE_BASE >= MI_SYSTEM_RANGE_START)
		{
			return TRUE;
		}
	}

	return FALSE;
}
BOOLEAN InitDSMMRoutines()
{
	// These can be found in Windows symbol PDB's

	g_pMiSystemPartition = FindPattern(g_KernelBase, g_KernelSize, EXP("\x00\x00\x00\x00\x06\x00\x00\x00\x40\x19\x36\x12\x00\x00\x00\x00\x00\x70\x00\x00\xAA\xAA\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00"));
	g_pMiGetPage = (fMiGetPage)FindPattern(g_KernelBase, g_KernelSize, EXP("\x48\x89\x5C\x24\x18\x89\x54\x24\x10\x48\x89\x4C\x24\x08\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x81\xEC\x90\x00\x00\x00"));
	g_pMiInitializePfn = (fMiInitializePfn)FindPattern(g_KernelBase, g_KernelSize, EXP("\x48\x89\x5C\x24\x10\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x83\xEC\x20\x4C\x8B\x12\x41\x8B\xF9\x48\x8B\xD9\x49\xBB\x00"));

	DPRINT("[DSMM] %s: MiSystemPartition: 0x%p\n", __FUNCTION__, g_pMiSystemPartition);
	DPRINT("[DSMM] %s: MiGetPage: 0x%p\n", __FUNCTION__, g_pMiGetPage);
	DPRINT("[DSMM] %s: MiInitializePfn: 0x%p\n", __FUNCTION__, g_pMiInitializePfn);

	return (g_pMiSystemPartition &&
		g_pMiGetPage &&
		g_pMiInitializePfn);
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT pDriverObject, _In_ PUNICODE_STRING pusRegistryPath)
{
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pusRegistryPath);

	if (InitDebugBlock() && InitDSMMRoutines())
	{
		g_Imports.pDbgPrintEx = DbgPrintEx;
		g_Imports.pPsCreateSystemThread = PsCreateSystemThread;
		g_Imports.pKeDelayExecutionThread = KeDelayExecutionThread;

		MMapDriver();
	}

	// Make the driver unload itself after doing the mapping

	return STATUS_UNSUCCESSFUL;
}
```

`DSMM/Ldrreloc.h`:

```h
#pragma once
#include "Definitions.h"

#define IMAGE_REL_BASED_SECTION 6
#define IMAGE_REL_BASED_REL32 7

// prototypes

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONGLONG Diff
);

NTSTATUS
LdrRelocateImage(
	IN PVOID NewBase,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
);

NTSTATUS
LdrRelocateImageWithBias(
	IN PVOID NewBase,
	IN LONGLONG AdditionalBias,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
);

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONG_PTR Diff
);

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONGLONG Diff
);

/*++

Copyright (c) Microsoft Corporation. All rights reserved.

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

ldrreloc.c

Abstract:

This module contains the code to relocate an image when
the preferred base isn't available. This is called by the
boot loader, device driver loader, and system loader.

--*/


//
// Mark a HIGHADJ entry as needing an increment if reprocessing.
//
#define LDRP_RELOCATION_INCREMENT   0x1

//
// Mark a HIGHADJ entry as not suitable for reprocessing.
//
#define LDRP_RELOCATION_FINAL       0x2


/*
#pragma alloc_text(PAGE,LdrRelocateImage)
#pragma alloc_text(PAGE,LdrRelocateImageWithBias)
#pragma alloc_text(PAGE,LdrProcessRelocationBlock)
#pragma alloc_text(PAGE,LdrProcessRelocationBlockLongLong)*/

typedef NTSTATUS LDR_RELOCATE_IMAGE_RETURN_TYPE;

LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImage(
	__in PVOID NewBase,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
)
/*++

Routine Description:

This routine relocates an image file that was not loaded into memory
at the preferred address.

Arguments:

NewBase - Supplies a pointer to the image base.

Success - Value to return if relocation successful.

Conflict - Value to return if can't relocate.

Invalid - Value to return if relocations are invalid.

Return Value:

Success if image is relocated.
Conflict if image can't be relocated.
Invalid if image contains invalid fixups.

--*/

{
	//
	// Just call LdrRelocateImageWithBias() with a zero bias.
	//
	return LdrRelocateImageWithBias(NewBase, 0, Success, Conflict, Invalid);
}


LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImageWithBias(
	__in PVOID NewBase,
	__in LONGLONG AdditionalBias,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
	__in LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
)
/*++

Routine Description:

This routine relocates an image file that was not loaded into memory
at the preferred address.

Arguments:

NewBase - Supplies a pointer to the image base.

AdditionalBias - An additional quantity to add to all fixups.  The
32-bit X86 loader uses this when loading 64-bit images
to specify a NewBase that is actually a 64-bit value.

Success - Value to return if relocation successful.

Conflict - Value to return if can't relocate.

Invalid - Value to return if relocations are invalid.

Return Value:

Success if image is relocated.
Conflict if image can't be relocated.
Invalid if image contains invalid fixups.

--*/

{
	LONGLONG Diff;
	ULONG TotalCountBytes = 0;
	ULONG_PTR VA;
	ULONGLONG OldBase;
	ULONG SizeOfBlock;
	PUSHORT NextOffset = NULL;
	PIMAGE_NT_HEADERS NtHeaders;
	PIMAGE_BASE_RELOCATION NextBlock;
	LDR_RELOCATE_IMAGE_RETURN_TYPE Status;

	NtHeaders = RtlImageNtHeader(NewBase);
	if (NtHeaders == NULL) {
		Status = Invalid;
		goto Exit;
	}

	switch (NtHeaders->OptionalHeader.Magic) {

	case IMAGE_NT_OPTIONAL_HDR32_MAGIC:

		OldBase =
			((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;
		break;

	case IMAGE_NT_OPTIONAL_HDR64_MAGIC:

		OldBase =
			((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;
		break;

	default:

		Status = Invalid;
		goto Exit;
	}

	//
	// Locate the relocation section.
	//

	NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
		NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

	//
	// It is possible for a file to have no relocations, but the relocations
	// must not have been stripped.
	//

	if (!NextBlock || !TotalCountBytes)
	{
		Status = (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) ? Conflict : Success;
		goto Exit;
	}

	//
	// If the image has a relocation table, then apply the specified fixup
	// information to the image.
	//
	Diff = (ULONG_PTR)NewBase - OldBase + AdditionalBias;
	while (TotalCountBytes)
	{
		SizeOfBlock = NextBlock->SizeOfBlock;

		// Prevent crash
		if (SizeOfBlock == 0)
		{
			Status = Invalid;
			goto Exit;
		}

		TotalCountBytes -= SizeOfBlock;
		SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
		SizeOfBlock /= sizeof(USHORT);
		NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

		VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;
		NextBlock = LdrProcessRelocationBlockLongLong(VA, SizeOfBlock, NextOffset, Diff);

		if (!NextBlock)
		{
			Status = Invalid;
			goto Exit;
		}
	}

	Status = Success;
Exit:
	return Status;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONG_PTR Diff
)
{
	PIMAGE_BASE_RELOCATION baseRelocation;

	baseRelocation = LdrProcessRelocationBlockLongLong(VA, SizeOfBlock, NextOffset, (LONGLONG)Diff);

	return baseRelocation;
}

// begin_rebase
PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONGLONG Diff
)
{
	PUCHAR FixupVA;
	USHORT Offset;
	LONG Temp;
	//ULONG Temp32;
	ULONGLONG Value64;
	//LONGLONG Temp64;

	while (SizeOfBlock--) {

		Offset = *NextOffset & (USHORT)0xfff;
		FixupVA = (PUCHAR)(VA + Offset);

		//
		// Apply the fixups.
		//

		switch ((*NextOffset) >> 12) {

		case IMAGE_REL_BASED_HIGHLOW:
			//
			// HighLow - (32-bits) relocate the high and low half
			//      of an address.
			//
			*(LONG UNALIGNED*)FixupVA += (ULONG)Diff;
			break;

		case IMAGE_REL_BASED_HIGH:
			//
			// High - (16-bits) relocate the high half of an address.
			//
			Temp = *(PUSHORT)FixupVA << 16;
			Temp += (ULONG)Diff;
			*(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
			break;

		case IMAGE_REL_BASED_HIGHADJ:
			//
			// Adjust high - (16-bits) relocate the high half of an
			//      address and adjust for sign extension of low half.
			//

			//
			// If the address has already been relocated then don't
			// process it again now or information will be lost.
			//
			if (Offset & LDRP_RELOCATION_FINAL) {
				++NextOffset;
				--SizeOfBlock;
				break;
			}

			Temp = *(PUSHORT)FixupVA << 16;
			++NextOffset;
			--SizeOfBlock;
			Temp += (LONG)(*(PSHORT)NextOffset);
			Temp += (ULONG)Diff;
			Temp += 0x8000;
			*(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

			break;

		case IMAGE_REL_BASED_LOW:
			//
			// Low - (16-bit) relocate the low half of an address.
			//
			Temp = *(PSHORT)FixupVA;
			Temp += (ULONG)Diff;
			*(PUSHORT)FixupVA = (USHORT)Temp;
			break;

		case IMAGE_REL_BASED_IA64_IMM64:

			//
			// Align it to bundle address before fixing up the
			// 64-bit immediate value of the movl instruction.
			//

			FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
			Value64 = (ULONGLONG)0;

			//
			// Extract the lower 32 bits of IMM64 from bundle
			//

			/*
			EXT_IMM64(Value64,
			(PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
			EMARCH_ENC_I17_IMM7B_SIZE_X,
			EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM7B_VAL_POS_X);
			EXT_IMM64(Value64,
			(PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
			EMARCH_ENC_I17_IMM9D_SIZE_X,
			EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM9D_VAL_POS_X);
			EXT_IMM64(Value64,
			(PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
			EMARCH_ENC_I17_IMM5C_SIZE_X,
			EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM5C_VAL_POS_X);
			EXT_IMM64(Value64,
			(PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
			EMARCH_ENC_I17_IC_SIZE_X,
			EMARCH_ENC_I17_IC_INST_WORD_POS_X,
			EMARCH_ENC_I17_IC_VAL_POS_X);
			EXT_IMM64(Value64,
			(PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
			EMARCH_ENC_I17_IMM41a_SIZE_X,
			EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41a_VAL_POS_X);

			EXT_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
			EMARCH_ENC_I17_IMM41b_SIZE_X,
			EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41b_VAL_POS_X);
			EXT_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
			EMARCH_ENC_I17_IMM41c_SIZE_X,
			EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41c_VAL_POS_X);
			EXT_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
			EMARCH_ENC_I17_SIGN_SIZE_X,
			EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
			EMARCH_ENC_I17_SIGN_VAL_POS_X);
			//
			// Update 64-bit address
			//

			Value64+=Diff;

			//
			// Insert IMM64 into bundle
			//

			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
			EMARCH_ENC_I17_IMM7B_SIZE_X,
			EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM7B_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
			EMARCH_ENC_I17_IMM9D_SIZE_X,
			EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM9D_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
			EMARCH_ENC_I17_IMM5C_SIZE_X,
			EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM5C_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
			EMARCH_ENC_I17_IC_SIZE_X,
			EMARCH_ENC_I17_IC_INST_WORD_POS_X,
			EMARCH_ENC_I17_IC_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
			EMARCH_ENC_I17_IMM41a_SIZE_X,
			EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41a_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
			EMARCH_ENC_I17_IMM41b_SIZE_X,
			EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41b_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
			EMARCH_ENC_I17_IMM41c_SIZE_X,
			EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
			EMARCH_ENC_I17_IMM41c_VAL_POS_X);
			INS_IMM64(Value64,
			((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
			EMARCH_ENC_I17_SIGN_SIZE_X,
			EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
			EMARCH_ENC_I17_SIGN_VAL_POS_X);
			*/
			break;

		case IMAGE_REL_BASED_DIR64:

			*(ULONGLONG UNALIGNED*)FixupVA += Diff;

			break;

		case IMAGE_REL_BASED_MIPS_JMPADDR:
			//
			// JumpAddress - (32-bits) relocate a MIPS jump address.
			//
			Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
			Temp += (ULONG)Diff;
			*(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
				((Temp >> 2) & 0x3ffffff);

			break;

		case IMAGE_REL_BASED_ABSOLUTE:
			//
			// Absolute - no fixup required.
			//
			break;

		case IMAGE_REL_BASED_SECTION:
			//
			// Section Relative reloc.  Ignore for now.
			//
			break;

		case IMAGE_REL_BASED_REL32:
			//
			// Relative intrasection. Ignore for now.
			//
			break;

		default:
			//
			// Illegal - illegal relocation type.
			//

			return (PIMAGE_BASE_RELOCATION)NULL;
		}
		++NextOffset;
	}
	return (PIMAGE_BASE_RELOCATION)NextOffset;
}

// end_rebase
```

`DSMM/Mmpte.h`:

```h
#pragma once

#pragma warning (disable: 4214)
typedef struct _MMPTE_HARDWARE
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 Dirty1 : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 Owner : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 WriteThrough : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned __int64 CacheDisable : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Accessed : 1; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Dirty : 1; /* bit position: 6 */
	/* 0x0000 */ unsigned __int64 LargePage : 1; /* bit position: 7 */
	/* 0x0000 */ unsigned __int64 Global : 1; /* bit position: 8 */
	/* 0x0000 */ unsigned __int64 CopyOnWrite : 1; /* bit position: 9 */
	/* 0x0000 */ unsigned __int64 Unused : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Write : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 PageFrameNumber : 36; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 ReservedForHardware : 4; /* bit position: 48 */
	/* 0x0000 */ unsigned __int64 ReservedForSoftware : 4; /* bit position: 52 */
	/* 0x0000 */ unsigned __int64 WsleAge : 4; /* bit position: 56 */
	/* 0x0000 */ unsigned __int64 WsleProtection : 3; /* bit position: 60 */
	/* 0x0000 */ unsigned __int64 NoExecute : 1; /* bit position: 63 */
} MMPTE_HARDWARE, *PMMPTE_HARDWARE; /* size: 0x0008 */
typedef struct _MMPTE_LIST
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 OneEntry : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 filler0 : 2; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Transition : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 filler1 : 16; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 NextEntry : 36; /* bit position: 28 */
} MMPTE_LIST, *PMMPTE_LIST; /* size: 0x0008 */
typedef struct _MMPTE_PROTOTYPE
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 DemandFillProto : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 HiberVerifyConverted : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 ReadOnly : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Combined : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 Unused1 : 4; /* bit position: 12 */
	/* 0x0000 */ __int64 ProtoAddress : 48; /* bit position: 16 */
} MMPTE_PROTOTYPE, *PMMPTE_PROTOTYPE; /* size: 0x0008 */
typedef struct _MMPTE_SOFTWARE
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 PageFileReserved : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 PageFileAllocated : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 ColdPage : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Transition : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 PageFileLow : 4; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 UsedPageTableEntries : 10; /* bit position: 16 */
	/* 0x0000 */ unsigned __int64 ShadowStack : 1; /* bit position: 26 */
	/* 0x0000 */ unsigned __int64 Unused : 5; /* bit position: 27 */
	/* 0x0000 */ unsigned __int64 PageFileHigh : 32; /* bit position: 32 */
} MMPTE_SOFTWARE, *PMMPTE_SOFTWARE; /* size: 0x0008 */
typedef struct _MMPTE_SUBSECTION
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 Unused0 : 3; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 ColdPage : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 Unused1 : 3; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 ExecutePrivilege : 1; /* bit position: 15 */
	/* 0x0000 */ __int64 SubsectionAddress : 48; /* bit position: 16 */
} MMPTE_SUBSECTION, *PMMPTE_SUBSECTION; /* size: 0x0008 */
typedef struct _MMPTE_TIMESTAMP
{
	/* 0x0000 */ unsigned __int64 MustBeZero : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 Unused : 3; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Transition : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 PageFileLow : 4; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 Reserved : 16; /* bit position: 16 */
	/* 0x0000 */ unsigned __int64 GlobalTimeStamp : 32; /* bit position: 32 */
} MMPTE_TIMESTAMP, *PMMPTE_TIMESTAMP; /* size: 0x0008 */
typedef struct _MMPTE_TRANSITION
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 Write : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 Spare : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 IoTracker : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned __int64 SwizzleBit : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Protection : 5; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Prototype : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Transition : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 PageFrameNumber : 36; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 Unused : 16; /* bit position: 48 */
} MMPTE_TRANSITION, *PMMPTE_TRANSITION; /* size: 0x0008 */
typedef struct _MMPTE
{
	union
	{
		/* 0x0000 */ unsigned __int64 Long;
		/* 0x0000 */ volatile unsigned __int64 VolatileLong;
		/* 0x0000 */ struct _MMPTE_HARDWARE Hard;
		/* 0x0000 */ struct _MMPTE_PROTOTYPE Proto;
		/* 0x0000 */ struct _MMPTE_SOFTWARE Soft;
		/* 0x0000 */ struct _MMPTE_TIMESTAMP TimeStamp;
		/* 0x0000 */ struct _MMPTE_TRANSITION Trans;
		/* 0x0000 */ struct _MMPTE_SUBSECTION Subsect;
		/* 0x0000 */ struct _MMPTE_LIST List;
	} /* size: 0x0008 */ u;
} MMPTE, *PMMPTE; /* size: 0x0008 */
#pragma warning (default: 4214)
```

`DSMM/Payload.h`:

```h
const unsigned char payload[] = {
0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xD0, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 
0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 
0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 
0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x67, 0xE9, 0xC5, 0xB7, 0x06, 0x87, 0x96, 0xB7, 0x06, 0x87, 0x96, 
0xB7, 0x06, 0x87, 0x96, 0xEC, 0x6E, 0x84, 0x97, 0xB6, 0x06, 0x87, 0x96, 0xEC, 0x6E, 0x83, 0x97, 0xB4, 0x06, 0x87, 0x96, 
0x75, 0x69, 0x83, 0x97, 0xB6, 0x06, 0x87, 0x96, 0x75, 0x69, 0x85, 0x97, 0xB6, 0x06, 0x87, 0x96, 0x52, 0x69, 0x63, 0x68, 
0xB7, 0x06, 0x87, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x02, 0x00, 0xF7, 0xF2, 0xEB, 0x5E, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00, 0x0B, 0x02, 0x0E, 0x19, 0x00, 0x06, 0x00, 0x00, 
0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x98, 0x04, 0x01, 0x00, 
0x01, 0x00, 0x60, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xA0, 0x10, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 
0x58, 0x05, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68, 0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00, 
0x14, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xB8, 0x13, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xD0, 0x13, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 
0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF, 0xC0, 0x12, 0x00, 0x00, 
0x51, 0x13, 0x00, 0x00, 0x70, 0x14, 0x00, 0x00, 0x54, 0x13, 0x00, 0x00, 0x7A, 0x13, 0x00, 0x00, 0x58, 0x14, 0x00, 0x00, 
0x7C, 0x13, 0x00, 0x00, 0xB7, 0x13, 0x00, 0x00, 0x64, 0x14, 0x00, 0x00, 0xD0, 0x13, 0x00, 0x00, 0xD5, 0x13, 0x00, 0x00, 
0x90, 0x14, 0x00, 0x00, 0x94, 0x14, 0x00, 0x00, 0xBF, 0x14, 0x00, 0x00, 0x7C, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xF7, 0xF2, 0xEB, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 
0xA8, 0x11, 0x00, 0x00, 0xA8, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xF2, 0xEB, 0x5E, 0x00, 0x00, 0x00, 0x00, 
0x0D, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0xF0, 0x11, 0x00, 0x00, 0xF0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x40, 
0x01, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53, 0xC4, 0x08, 0x48, 0xCC, 0xC8, 0xF5, 0x3B, 0x40, 
0x9E, 0xCF, 0x45, 0xC1, 0x05, 0xCC, 0x26, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x30, 0x30, 0x63, 0x66, 0x67, 0x00, 0x00, 
0x10, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 
0x40, 0x00, 0x00, 0x00, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 
0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xA8, 0x11, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 
0x74, 0x61, 0x24, 0x7A, 0x7A, 0x7A, 0x64, 0x62, 0x67, 0x00, 0x00, 0x00, 0xC0, 0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x13, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x24, 0x30, 0x30, 0x00, 0xE0, 0x13, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 
0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x73, 0x00, 0x58, 0x14, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x2E, 0x78, 0x64, 0x61, 
0x74, 0x61, 0x00, 0x00, 0x94, 0x14, 0x00, 0x00, 0xAC, 0x00, 0x00, 0x00, 0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 
0x40, 0x15, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x2E, 0x62, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xDC, 0x48, 0x83, 0xEC, 0x48, 0x0F, 0x10, 0x09, 0x33, 0xD2, 
0x0F, 0x11, 0x0D, 0x6D, 0x02, 0x00, 0x00, 0xF2, 0x0F, 0x10, 0x41, 0x10, 0x66, 0x49, 0x0F, 0x7E, 0xC9, 0xF2, 0x0F, 0x11, 
0x05, 0x6B, 0x02, 0x00, 0x00, 0x4D, 0x85, 0xC9, 0x74, 0x62, 0x48, 0x8B, 0x05, 0x57, 0x02, 0x00, 0x00, 0x48, 0x85, 0xC0, 
0x74, 0x4A, 0x48, 0x39, 0x15, 0x53, 0x02, 0x00, 0x00, 0x74, 0x41, 0x49, 0x89, 0x53, 0xE8, 0x48, 0x8D, 0x0D, 0x72, 0x00, 
0x00, 0x00, 0x49, 0x89, 0x4B, 0xE0, 0x45, 0x33, 0xC9, 0x49, 0x89, 0x53, 0xD8, 0x49, 0x8D, 0x4B, 0x08, 0x49, 0x89, 0x53, 
0x08, 0x45, 0x33, 0xC0, 0xBA, 0x00, 0x00, 0x1F, 0x00, 0xFF, 0xD0, 0x44, 0x8B, 0xC8, 0x4C, 0x8D, 0x05, 0xDF, 0x00, 0x00, 
0x00, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0x15, 0x05, 0x02, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x48, 0xC3, 0x4C, 0x8D, 0x05, 0xF9, 
0x00, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xFF, 0xD1, 0x48, 0x83, 0xC4, 0x48, 0xC3, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 
0x8B, 0xC1, 0x4C, 0x8D, 0x44, 0x24, 0x38, 0x48, 0x69, 0xC8, 0xF0, 0xD8, 0xFF, 0xFF, 0x33, 0xD2, 0x48, 0x89, 0x4C, 0x24, 
0x38, 0x33, 0xC9, 0xFF, 0x15, 0xDB, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 
0xEC, 0x20, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xCB, 0x4C, 0x8D, 0x05, 0x4F, 0x00, 0x00, 0x00, 0x33, 0xD2, 0x33, 
0xC9, 0xFF, 0x15, 0xA5, 0x01, 0x00, 0x00, 0xB9, 0xC4, 0x09, 0x00, 0x00, 0xE8, 0xAF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x81, 
0xFB, 0xE8, 0x03, 0x00, 0x00, 0x72, 0xD8, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xC2, 0x00, 0x00, 0xCC, 
0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xFF, 0xE0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x2A, 0x2A, 0x2A, 0x2A, 
0x2A, 0x20, 0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x20, 0x46, 0x52, 0x4F, 0x4D, 0x20, 0x4D, 0x41, 0x50, 0x50, 0x45, 0x44, 0x20, 
0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x21, 0x20, 0x25, 0x75, 0x20, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x0A, 0x00, 0xCC, 0xCC, 
0xCC, 0xCC, 0xCC, 0xCC, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 0x61, 
0x74, 0x75, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x30, 0x38, 0x78, 0x20, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x0A, 0x00, 0xCC, 
0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x20, 0x65, 0x72, 
0x72, 0x6F, 0x72, 0x20, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x02, 0x04, 0x03, 0x00, 
0x01, 0x16, 0x00, 0x06, 0x04, 0x42, 0x00, 0x00, 0x02, 0x06, 0x04, 0x00, 0x02, 0x16, 0x00, 0x06, 0x06, 0x32, 0x02, 0x30, 
0x02, 0x07, 0x03, 0x00, 0x01, 0x16, 0x12, 0x06, 0x07, 0x82, 0x00, 0x00, 0x02, 0x0A, 0x06, 0x00, 0x02, 0x16, 0x00, 0x06, 
0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 
0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xDA, 0x48, 0x8B, 0xF9, 0xE8, 0x17, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD3, 
0x48, 0x8B, 0xCF, 0xE8, 0x0C, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 
0x48, 0x8B, 0x05, 0x49, 0xFB, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x49, 0xB8, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 
0x48, 0x85, 0xC0, 0x74, 0x05, 0x49, 0x3B, 0xC0, 0x75, 0x38, 0x0F, 0x31, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x8D, 0x0D, 0x25, 
0xFB, 0xFF, 0xFF, 0x48, 0x0B, 0xC2, 0x48, 0x33, 0xC1, 0x48, 0x89, 0x05, 0x18, 0xFB, 0xFF, 0xFF, 0x66, 0x44, 0x89, 0x0D, 
0x16, 0xFB, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0x09, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x75, 0x0A, 0x49, 0x8B, 0xC0, 0x48, 
0x89, 0x05, 0xFA, 0xFA, 0xFF, 0xFF, 0x48, 0xF7, 0xD0, 0x48, 0x89, 0x05, 0xF8, 0xFA, 0xFF, 0xFF, 0xC3, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x10, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x08, 0xA0, 0xF8, 0xA0, 0x10, 0xA1, 0x18, 0xA1, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
```

`DSMM/Shared.h`:

```h
#pragma once
#include <ntifs.h>

typedef ULONG
(*fDbgPrintEx)(
	ULONG ComponentId,
	ULONG Level,
	PCSTR Format,
	...);

typedef NTSTATUS
(*fPsCreateSystemThread)(
	PHANDLE ThreadHandle,
	ULONG DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PCLIENT_ID ClientId,
	PKSTART_ROUTINE StartRoutine,
	PVOID StartContext);

typedef NTSTATUS
(*fKeDelayExecutionThread)(
	KPROCESSOR_MODE WaitMode,
	BOOLEAN Alertable,
	PLARGE_INTEGER Interval);

typedef struct _IMPORTS
{
	fDbgPrintEx pDbgPrintEx;
	fPsCreateSystemThread pPsCreateSystemThread;
	fKeDelayExecutionThread pKeDelayExecutionThread;
} IMPORTS, *PIMPORTS;
```

`Payload/Driver.c`:

```c
#pragma comment(linker, "/merge:.pdata=.rdata")
#pragma comment(linker, "/merge:.rdata=.text")
#pragma comment(linker, "/merge:.data=.text") // linker warning 4254
#pragma comment(linker, "/merge:INIT=.text")

#include <ntifs.h>
#include <ntddmou.h>
#include <windef.h>
#include "Shared.h"

IMPORTS g_Imports;

NTSTATUS Sleep(_In_ ULONG dwMilliseconds)
{
	LARGE_INTEGER interval;
	interval.QuadPart = -(ULONGLONG)dwMilliseconds * 10000;
	return g_Imports.pKeDelayExecutionThread(KernelMode, FALSE, &interval);
}
NTSTATUS Thread()
{
	UINT count = 0;

	while (++count < 1000)
	{
		g_Imports.pDbgPrintEx(0, 0, "***** HELLO FROM MAPPED DRIVER! %u *****\n", count);
		Sleep(2500);
	}

	return STATUS_SUCCESS;
}

VOID DriverEntry(_In_ PVOID arg1)
{
	memcpy(&g_Imports, arg1, sizeof(g_Imports));

	if (g_Imports.pDbgPrintEx)
	{
		if (g_Imports.pPsCreateSystemThread && g_Imports.pKeDelayExecutionThread)
		{
			HANDLE hThread = NULL;
			NTSTATUS status = g_Imports.pPsCreateSystemThread(&hThread, STANDARD_RIGHTS_ALL, NULL, NULL, NULL, (PKSTART_ROUTINE)Thread, NULL);

			g_Imports.pDbgPrintEx(0, 0, "***** thread status: 0x%08x *****\n", status);
		}
		else
		{
			g_Imports.pDbgPrintEx(0, 0, "***** error *****\n");
		}
	}
}
```

`Payload/Payload.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.62
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Payload", "Payload.vcxproj", "{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.ActiveCfg = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Build.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A19C5621-9017-4AD4-B672-8F78E12CCBD3}
	EndGlobalSection
EndGlobal

```

`Payload/Payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Payload</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Platform)\$(ConfigurationName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <PostBuildEvent>
      <Command>call "$(ProjectDir)peupdate\peupdate.exe" -c "$(TargetPath)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shared.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Payload/Payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shared.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Payload/Payload.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Payload/Shared.h`:

```h
#pragma once
#include <ntifs.h>

typedef ULONG
(*fDbgPrintEx)(
	ULONG ComponentId,
	ULONG Level,
	PCSTR Format,
	...);

typedef NTSTATUS
(*fPsCreateSystemThread)(
	PHANDLE ThreadHandle,
	ULONG DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PCLIENT_ID ClientId,
	PKSTART_ROUTINE StartRoutine,
	PVOID StartContext);

typedef NTSTATUS
(*fKeDelayExecutionThread)(
	KPROCESSOR_MODE WaitMode,
	BOOLEAN Alertable,
	PLARGE_INTEGER Interval);

typedef struct _IMPORTS
{
	fDbgPrintEx pDbgPrintEx;
	fPsCreateSystemThread pPsCreateSystemThread;
	fKeDelayExecutionThread pKeDelayExecutionThread;
} IMPORTS, *PIMPORTS;
```

`README.md`:

```md
# DSMM: Discarded Section Manual Map

Manual map your driver and create a system thread inside a legit Windows driver (post-boot).

This method doesn't trigger PatchGuard.

Tested on Windows 10 x64 build 17763.

![Screenshot](https://i.imgur.com/lzLNKaC.png)

## (Re)sources:

- [Blackbone](https://github.com/DarthTon/Blackbone)
- [owned_alignment](https://github.com/vmcall/owned_alignment)
- [https://rayanfam.com/topics/inside-windows-page-frame-number-part2/](https://rayanfam.com/topics/inside-windows-page-frame-number-part2/)
```