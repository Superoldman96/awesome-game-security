Project Path: arc_gmh5225_shibari_7rhuhk8k

Source Tree:

```txt
arc_gmh5225_shibari_7rhuhk8k
├── LICENSE
├── enma_pe
├── readme.md
├── shibari
│   ├── shibari.cpp
│   ├── shibari.h
│   ├── shibari.vcxproj
│   ├── shibari.vcxproj.filters
│   ├── shibari_builder.cpp
│   ├── shibari_builder.h
│   ├── shibari_data_linker.cpp
│   ├── shibari_data_linker.h
│   ├── shibari_data_linker_rtti_msvc.h
│   ├── shibari_exceptions_linker.cpp
│   ├── shibari_exceptions_linker.h
│   ├── shibari_export_linker.cpp
│   ├── shibari_export_linker.h
│   ├── shibari_import_linker.cpp
│   ├── shibari_import_linker.h
│   ├── shibari_linker.cpp
│   ├── shibari_linker.h
│   ├── shibari_loadconfigs_linker.cpp
│   ├── shibari_loadconfigs_linker.h
│   ├── shibari_module.cpp
│   ├── shibari_module.h
│   ├── shibari_relocations_linker.cpp
│   ├── shibari_relocations_linker.h
│   ├── shibari_tls_linker.cpp
│   ├── shibari_tls_linker.h
│   ├── stdafx.cpp
│   └── stdafx.h
├── shibari.sln
└── shibari_console
    ├── shibari_console.cpp
    ├── shibari_console.vcxproj
    ├── shibari_console.vcxproj.filters
    ├── stdafx.cpp
    └── stdafx.h

```

`LICENSE`:

```
Copyright (c) 2018, JNA aka jnastarot
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 - Neither the name of JNA nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`readme.md`:

```md
SHIBARI project
---

| License | Windows | Linux |
| ------- |  ----------- | ------ |
| [![License](https://img.shields.io/badge/license-BSD3-blue.svg)](https://github.com/jnastarot/enma_pe/blob/master/LICENSE) | [![Build status](https://ci.appveyor.com/api/projects/status/xyab2hakbbbou9a0?svg=true)](https://ci.appveyor.com/project/jnastarot/shibari) | [![Build Status](https://travis-ci.org/jnastarot/shibari.svg?branch=master)](https://travis-ci.org/jnastarot/shibari) |


```
--------------------------------------------------------------------------------
Name....: shibari
Author..: JNA
Date....: 2018
e.mail..: jnastarot@yandex.ru
--------------------------------------------------------------------------------
```

[shibari project https://www.youtube.com/watch?v=IDmf7O5_S_g](https://www.youtube.com/watch?v=IDmf7O5_S_g)

```

`shibari.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shibari", "shibari\shibari.vcxproj", "{1EA29A42-AEF8-45A7-83EC-2E5400893596}"
	ProjectSection(ProjectDependencies) = postProject
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC} = {5B0E07A2-6928-44E0-AF0A-445B067C71CC}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "enma_pe", "enma_pe\enma_pe\enma_pe.vcxproj", "{5B0E07A2-6928-44E0-AF0A-445B067C71CC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shibari_console", "shibari_console\shibari_console.vcxproj", "{00D6C615-EA3A-4D90-A09C-24D743918EFF}"
	ProjectSection(ProjectDependencies) = postProject
		{1EA29A42-AEF8-45A7-83EC-2E5400893596} = {1EA29A42-AEF8-45A7-83EC-2E5400893596}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Debug|x64.ActiveCfg = Debug|x64
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Debug|x64.Build.0 = Debug|x64
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Debug|x86.ActiveCfg = Debug|Win32
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Debug|x86.Build.0 = Debug|Win32
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Release|x64.ActiveCfg = Release|x64
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Release|x64.Build.0 = Release|x64
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Release|x86.ActiveCfg = Release|Win32
		{1EA29A42-AEF8-45A7-83EC-2E5400893596}.Release|x86.Build.0 = Release|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x64.ActiveCfg = Debug|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x64.Build.0 = Debug|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x86.ActiveCfg = Debug|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x86.Build.0 = Debug|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x64.ActiveCfg = Release|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x64.Build.0 = Release|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x86.ActiveCfg = Release|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x86.Build.0 = Release|Win32
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Debug|x64.ActiveCfg = Debug|x64
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Debug|x64.Build.0 = Debug|x64
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Debug|x86.ActiveCfg = Debug|Win32
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Debug|x86.Build.0 = Debug|Win32
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Release|x64.ActiveCfg = Release|x64
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Release|x64.Build.0 = Release|x64
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Release|x86.ActiveCfg = Release|Win32
		{00D6C615-EA3A-4D90-A09C-24D743918EFF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`shibari/shibari.cpp`:

```cpp
#include "stdafx.h"
#include "shibari.h"



shibari::shibari() 
 : main_module(0){}

shibari::~shibari() 
{}

shibari_linker_errors shibari::exec_shibari(uint32_t enma_build_flags, std::vector<uint8_t>& out_image) {

    shibari_linker_errors linker_ret = shibari_linker(extended_modules, main_module).link_modules();

    if (linker_ret != shibari_linker_errors::shibari_linker_ok) {
        return linker_ret;
    }

    return build_shibari_image(main_module->get_module_image(),
        PE_IMAGE_BUILD_ALL_DIRECTORIES | enma_build_flags,
        out_image) ? shibari_linker_ok : shibari_linker_error_build;
}


void shibari::set_main_module(shibari_module* module) {
    if (module) {
        this->main_module = module;
    }
}

void shibari::add_extended_module(shibari_module* module) {
    if (module) {
        this->extended_modules.push_back(module);
    }
}

std::vector<shibari_module*>& shibari::get_extended_modules() {
    return this->extended_modules;
}

const std::vector<shibari_module*>& shibari::get_extended_modules() const {
    return this->extended_modules;
}

shibari_module* shibari::get_main_module() {
    return this->main_module;
}

const shibari_module* shibari::get_main_module() const {
    return this->main_module;
}
```

`shibari/shibari.h`:

```h
#pragma once

class shibari_module;
class shibari_linker;


#include "shibari_module.h"
#include "shibari_linker.h"
#include "shibari_builder.h"


class shibari {
    std::vector<shibari_module*> extended_modules;
    shibari_module* main_module;
public:
    shibari();
    ~shibari();

    shibari_linker_errors exec_shibari(uint32_t enma_build_flags, std::vector<uint8_t>& out_image);
public:
    void set_main_module(shibari_module* module);
    void add_extended_module(shibari_module* module);
public:
    std::vector<shibari_module*>& get_extended_modules();
    const std::vector<shibari_module*>& get_extended_modules() const;
    shibari_module* get_main_module();
    const shibari_module* get_main_module() const;
};
```

`shibari/shibari.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1EA29A42-AEF8-45A7-83EC-2E5400893596}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>shibari</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>false</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="shibari.h" />
    <ClInclude Include="shibari_builder.h" />
    <ClInclude Include="shibari_data_linker.h" />
    <ClInclude Include="shibari_data_linker_rtti_msvc.h" />
    <ClInclude Include="shibari_exceptions_linker.h" />
    <ClInclude Include="shibari_export_linker.h" />
    <ClInclude Include="shibari_import_linker.h" />
    <ClInclude Include="shibari_linker.h" />
    <ClInclude Include="shibari_loadconfigs_linker.h" />
    <ClInclude Include="shibari_module.h" />
    <ClInclude Include="shibari_relocations_linker.h" />
    <ClInclude Include="shibari_tls_linker.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="shibari.cpp" />
    <ClCompile Include="shibari_builder.cpp" />
    <ClCompile Include="shibari_data_linker.cpp" />
    <ClCompile Include="shibari_exceptions_linker.cpp" />
    <ClCompile Include="shibari_export_linker.cpp" />
    <ClCompile Include="shibari_import_linker.cpp" />
    <ClCompile Include="shibari_linker.cpp" />
    <ClCompile Include="shibari_loadconfigs_linker.cpp" />
    <ClCompile Include="shibari_module.cpp" />
    <ClCompile Include="shibari_relocations_linker.cpp" />
    <ClCompile Include="shibari_tls_linker.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shibari/shibari.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari">
      <UniqueIdentifier>{a6a96657-6852-4072-8edb-294cb83ec105}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\module">
      <UniqueIdentifier>{1fd0ff7d-3f98-491b-b54e-c7c76dd381be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\builder">
      <UniqueIdentifier>{89944bb0-0eca-4487-ba40-248fdc1193e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker">
      <UniqueIdentifier>{8924e9f5-a3f0-41c4-a259-6d3d5a09abcc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\data">
      <UniqueIdentifier>{bac26ed6-0f84-494b-a76f-e1bb133adaeb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\exceptions">
      <UniqueIdentifier>{36427d0b-b7cf-464d-a46e-e6a91fb543de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\export">
      <UniqueIdentifier>{45e09fde-b788-4db4-be2e-2f49fcbb0cad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\import">
      <UniqueIdentifier>{9cbec75d-2f51-44d1-b878-dda80e42f804}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\loadconfigs">
      <UniqueIdentifier>{a237b9fd-a027-466b-9554-475ab5eef62a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\relocations">
      <UniqueIdentifier>{46592ae8-8090-4573-a477-21d6bb61ad74}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\shibari\linker\tls">
      <UniqueIdentifier>{b6ab1391-ae4f-4beb-8730-8ab414104cc8}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="shibari.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="shibari_module.h">
      <Filter>Заголовочные файлы\shibari\module</Filter>
    </ClInclude>
    <ClInclude Include="shibari_builder.h">
      <Filter>Заголовочные файлы\shibari\builder</Filter>
    </ClInclude>
    <ClInclude Include="shibari_linker.h">
      <Filter>Заголовочные файлы\shibari\linker</Filter>
    </ClInclude>
    <ClInclude Include="shibari_export_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\export</Filter>
    </ClInclude>
    <ClInclude Include="shibari_import_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\import</Filter>
    </ClInclude>
    <ClInclude Include="shibari_loadconfigs_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\loadconfigs</Filter>
    </ClInclude>
    <ClInclude Include="shibari_exceptions_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\exceptions</Filter>
    </ClInclude>
    <ClInclude Include="shibari_relocations_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\relocations</Filter>
    </ClInclude>
    <ClInclude Include="shibari_tls_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\tls</Filter>
    </ClInclude>
    <ClInclude Include="shibari_data_linker.h">
      <Filter>Заголовочные файлы\shibari\linker\data</Filter>
    </ClInclude>
    <ClInclude Include="shibari_data_linker_rtti_msvc.h">
      <Filter>Заголовочные файлы\shibari\linker\data</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="shibari.cpp">
      <Filter>Заголовочные файлы</Filter>
    </ClCompile>
    <ClCompile Include="shibari_module.cpp">
      <Filter>Заголовочные файлы\shibari\module</Filter>
    </ClCompile>
    <ClCompile Include="shibari_builder.cpp">
      <Filter>Заголовочные файлы\shibari\builder</Filter>
    </ClCompile>
    <ClCompile Include="shibari_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker</Filter>
    </ClCompile>
    <ClCompile Include="shibari_export_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\export</Filter>
    </ClCompile>
    <ClCompile Include="shibari_import_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\import</Filter>
    </ClCompile>
    <ClCompile Include="shibari_loadconfigs_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\loadconfigs</Filter>
    </ClCompile>
    <ClCompile Include="shibari_exceptions_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\exceptions</Filter>
    </ClCompile>
    <ClCompile Include="shibari_relocations_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\relocations</Filter>
    </ClCompile>
    <ClCompile Include="shibari_tls_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\tls</Filter>
    </ClCompile>
    <ClCompile Include="shibari_data_linker.cpp">
      <Filter>Заголовочные файлы\shibari\linker\data</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`shibari/shibari_builder.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_builder.h"



std::vector<uint8_t> get_dos_headers(pe_image& image, uint32_t build_flags, size_t& headers_size) {
#define GET_RICH_HASH(x,i) (((x) << (i)) | ((x) >> (32 - (i))))

    std::vector<uint8_t> image_start;


    {   //add dos header

        image_dos_header dos_header;
        image.get_dos_header(dos_header);

        if (dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
            dos_header.e_magic = IMAGE_DOS_SIGNATURE;
        }

        image_start.resize(sizeof(image_dos_header));


        memcpy(image_start.data(), &dos_header, sizeof(image_dos_header));  //write dos header
    }


    {   //add dos stub

        pe_dos_stub dos_header;

        if (get_image_dos_stub(image.get_headers_data(), dos_header)) {
            auto& dos_stub = dos_header.get_stub();

            image_start.resize(sizeof(image_dos_header) + dos_stub.size());

            memcpy(&image_start.data()[sizeof(image_dos_header)], dos_stub.data(), dos_stub.size()); //write dos stub
        }

    }


    if (build_flags & PE_IMAGE_BUILD_UPD_RICH_DATA) {   //add rich data

        pe_rich_header &rich_header = image.get_rich_header();

        if (rich_header.get_entries().size()) {

            std::vector<uint32_t> rich_stub;

            size_t image_start_size = image_start.size();

            rich_stub.resize(4 + (rich_header.get_entries().size() * 2) + 4); /* DanS sign size + size of item + Rich sign size */

            uint32_t * rich_dw = rich_stub.data();

            rich_dw[0] = 0x536E6144; //start DanS sign

            for (size_t entry_idx = 0; entry_idx < rich_header.get_entries().size(); entry_idx++) {      //init rich items    
                rich_dw[4 + (entry_idx * 2)] = (rich_header.get_entries()[entry_idx].get_compiler_build() & 0xFFFF) |
                    ((rich_header.get_entries()[entry_idx].get_type() & 0xFFFF) << 16);
                rich_dw[4 + (entry_idx * 2) + 1] = rich_header.get_entries()[entry_idx].get_count();
            }

            rich_dw[4 + (rich_header.get_entries().size() * 2)] = 0x68636952;//end Rich sign

            uint32_t rich_hash = uint32_t(image_start.size());

            for (size_t i = 0; i < image_start.size(); i++) {  //calc rich hash (dos header + stub) 
                if (i >= 0x3C && i < 0x40) { continue; }//skip e_lfanew

                rich_hash += GET_RICH_HASH((uint32_t)image_start.data()[i], i);
            }

            for (size_t i = 0; i < rich_header.get_entries().size(); i++) { //calc rich hash (Rich struct)
                rich_hash += GET_RICH_HASH(rich_dw[4 + (i * 2)], rich_dw[4 + (i * 2) + 1]);
            }

            for (size_t i = 0; i < 4 + (rich_header.get_entries().size() * 2); i++) { //crypt rich data by hash
                rich_dw[i] ^= rich_hash;
            }

            rich_dw[4 + (rich_header.get_entries().size() * 2) + 1] = rich_hash; //set Rich hash


            image_start.resize(image_start.size() + rich_stub.size() * sizeof(uint32_t));
            memcpy(&image_start.data()[image_start_size], rich_stub.data(), rich_stub.size() * sizeof(uint32_t));   //write rich data
        }
    }

    image_start.resize(ALIGN_UP(image_start.size(), 0x10)); //align start header size
    pimage_dos_header(image_start.data())->e_lfanew = uint32_t(image_start.size());

    headers_size = image_start.size();
    return image_start;
}


template<typename pe_image_format>
void _get_nt_header(pe_image& image, uint32_t header_size, std::vector<uint8_t>& header) {

    typename pe_image_format::image_nt_headers nt_header;


    memset(&nt_header, 0, sizeof(typename pe_image_format::image_nt_headers));

    nt_header.signature = IMAGE_NT_SIGNATURE;

    nt_header.file_header.machine = image.get_machine();
    nt_header.file_header.number_of_sections = (uint16_t)image.get_sections_number();
    nt_header.file_header.time_date_stamp = image.get_timestamp();
    nt_header.file_header.pointer_to_symbol_table = image.get_pointer_to_symbol_table();
    nt_header.file_header.number_of_symbols = image.get_number_of_symbols();
    nt_header.file_header.size_of_optional_header = sizeof(nt_header.optional_header);
    nt_header.file_header.characteristics = image.get_characteristics();

    nt_header.optional_header.magic = pe_image_format::image_magic;

    nt_header.optional_header.major_linker_version = image.get_major_linker();
    nt_header.optional_header.minor_linker_version = image.get_minor_linker();

    nt_header.optional_header.size_of_code = image.get_size_of_code();
    nt_header.optional_header.size_of_initialized_data = image.get_size_of_init_data();
    nt_header.optional_header.size_of_uninitialized_data = image.get_size_of_uninit_data();

    nt_header.optional_header.address_of_entry_point = image.get_entry_point();

    nt_header.optional_header.base_of_code = image.get_base_of_code();

    nt_header.optional_header.image_base = (typename pe_image_format::ptr_size)image.get_image_base();

    nt_header.optional_header.section_alignment = image.get_section_align();
    nt_header.optional_header.file_alignment = image.get_file_align();

    nt_header.optional_header.major_operating_system_version = image.get_os_ver_major();
    nt_header.optional_header.minor_operating_system_version = image.get_os_ver_minor();
    nt_header.optional_header.major_image_version = image.get_image_ver_major();
    nt_header.optional_header.minor_image_version = image.get_image_ver_minor();
    nt_header.optional_header.major_subsystem_version = image.get_subsystem_ver_major();
    nt_header.optional_header.minor_subsystem_version = image.get_subsystem_ver_minor();

    nt_header.optional_header.win32_version_value = image.get_win32_version_value();

    nt_header.optional_header.size_of_image = ALIGN_UP(
        (image.get_sections()[image.get_sections_number() - 1]->get_virtual_address() +
            image.get_sections()[image.get_sections_number() - 1]->get_virtual_size()),
        image.get_section_align());

    nt_header.optional_header.size_of_headers = ALIGN_UP(header_size, image.get_file_align());

    nt_header.optional_header.checksum = 0;

    nt_header.optional_header.subsystem = image.get_sub_system();
    nt_header.optional_header.dll_characteristics = image.get_characteristics_dll();

    nt_header.optional_header.size_of_stack_reserve = (typename pe_image_format::ptr_size)image.get_stack_reserve_size();
    nt_header.optional_header.size_of_stack_commit = (typename pe_image_format::ptr_size)image.get_stack_commit_size();
    nt_header.optional_header.size_of_heap_reserve = (typename pe_image_format::ptr_size)image.get_heap_reserve_size();
    nt_header.optional_header.size_of_heap_commit = (typename pe_image_format::ptr_size)image.get_heap_commit_size();

    nt_header.optional_header.loader_flags = image.get_loader_flags();
    nt_header.optional_header.number_of_rva_and_sizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

    for (unsigned int dir_idx = 0; dir_idx < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; dir_idx++) {
        nt_header.optional_header.data_directory[dir_idx].virtual_address = image.get_directory_virtual_address(dir_idx);
        nt_header.optional_header.data_directory[dir_idx].size = image.get_directory_virtual_size(dir_idx);
    }

    header.resize(sizeof(typename pe_image_format::image_nt_headers));
    memcpy(header.data(), &nt_header, sizeof(nt_header));
}

void get_nt_header(pe_image& image, uint32_t header_size, std::vector<uint8_t>& header) {

    if (image.is_x32_image()) {
        _get_nt_header<pe_image_32>(image, header_size, header);
    }
    else {
        _get_nt_header<pe_image_64>(image, header_size, header);
    }
}

size_t calculate_headers_size(pe_image& image, size_t dos_headers_size, uint32_t new_sections) {

    uint32_t total_sections = (uint32_t)image.get_sections_number() + new_sections;

    return ALIGN_UP(
        dos_headers_size +  //start headers size
        (image.is_x32_image() ? sizeof(image_nt_headers32) : sizeof(image_nt_headers64)) + //nt header size
        total_sections * sizeof(image_section_header) //sections desc size

        , image.get_file_align() //alignment
    );
}

uint32_t get_new_sections_count(pe_image_full& image_full, uint32_t build_flags) {

    uint32_t new_sections = 0;

    if (!image_full.get_load_config().get_size() && (build_flags & PE_IMAGE_BUILD_DIR_LOAD_CONFIG)) {

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RDATA) {
            new_sections++;
        }
    }

    if ((!image_full.get_image().is_x32_image() && image_full.get_exceptions().size()) && (build_flags & PE_IMAGE_BUILD_DIR_EXCEPTIONS)) {

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_PDATA) {
            new_sections++;
        }
    }

    if ((image_full.get_imports().size() && (build_flags & PE_IMAGE_BUILD_DIR_IMPORT)) ||
        (image_full.get_exports().get_number_of_functions() && (build_flags & PE_IMAGE_BUILD_DIR_EXPORT)) ||
        ((image_full.get_tls().get_address_of_index() || image_full.get_tls().get_callbacks().size()) && (build_flags & PE_IMAGE_BUILD_DIR_TLS))
        ) {

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_EDATA) {
            new_sections++;
        }
    }

    if (image_full.get_relocations().size() && (build_flags & PE_IMAGE_BUILD_DIR_RELOCATIONS)) {     //build relocations

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RSRC) {
            new_sections++;
        }
    }

    if (image_full.get_resources().get_entry_list().size() && (build_flags & PE_IMAGE_BUILD_DIR_RESOURCES)) {   //build resources

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RSRC) {
            new_sections++;
        }
    }

    return new_sections;
}

void align_sections(pe_image& image, uint32_t start_header_size) {

    uint32_t current_section_raw = start_header_size;

    for (auto & section_ : image.get_sections()) {
        if (section_->get_size_of_raw_data() > section_->get_virtual_size()) {
            section_->set_virtual_size(section_->get_size_of_raw_data());
        }
        section_->set_pointer_to_raw(current_section_raw);

        current_section_raw += ALIGN_UP(section_->get_size_of_raw_data(), image.get_file_align());
    }
}

void process_relocations(pe_image_full& image_full) {

    for (auto& reloc_item : image_full.get_relocations().get_entries()) {

        if (reloc_item.relocation_id & relocation_index_iat_address) {

            unsigned int reloc_lib_idx = GET_HI_NUMBER(reloc_item.relocation_id);
            unsigned int reloc_func_idx = GET_LO_NUMBER(reloc_item.relocation_id);

            pe_import_library& reloc_ref_lib = image_full.get_imports().get_libraries()[reloc_lib_idx];
            pe_import_function& reloc_ref_func = reloc_ref_lib.get_entries()[reloc_func_idx];

            pe_section * target_section = image_full.get_image().get_section_by_rva(reloc_item.relative_virtual_address);

            if (!target_section) { continue; }

            if (image_full.get_image().is_x32_image()) {
                (*(uint32_t*)&target_section->get_section_data()[
                    (reloc_item.relative_virtual_address) - target_section->get_virtual_address()
                ]) = (uint32_t)image_full.get_image().rva_to_va(reloc_ref_func.get_iat_rva());
            }
            else {
                (*(uint64_t*)&target_section->get_section_data()[
                    (reloc_item.relative_virtual_address) - target_section->get_virtual_address()
                ]) = image_full.get_image().rva_to_va(reloc_ref_func.get_iat_rva());
            }
        }
    }
}

void build_directories(pe_image_full& image_full, uint32_t build_flags) {

    if ((image_full.get_imports().size() && (build_flags & PE_IMAGE_BUILD_DIR_IMPORT)) ||
        (image_full.get_exports().get_number_of_functions() && (build_flags & PE_IMAGE_BUILD_DIR_EXPORT)) ||
        ((image_full.get_tls().get_address_of_index() || image_full.get_tls().get_callbacks().size()) && (build_flags & PE_IMAGE_BUILD_DIR_TLS)) ||
        ((!image_full.get_image().is_x32_image() && image_full.get_exceptions().get_exception_entries().size()) && (build_flags & PE_IMAGE_BUILD_DIR_EXCEPTIONS)) ||
        ((!image_full.get_load_config().get_size()) && (build_flags & PE_IMAGE_BUILD_DIR_LOAD_CONFIG))
        ) {


        if (!image_full.get_load_config().get_size() && (build_flags & PE_IMAGE_BUILD_DIR_LOAD_CONFIG)) {
            pe_section* rdata_section = 0;

            if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RDATA) {
                rdata_section = &image_full.get_image().add_section();
                rdata_section->set_section_name(std::string(".rdata"));
                rdata_section->set_readable(true).set_writeable(false).set_executable(false);
            }
            else {
                rdata_section = image_full.get_image().get_last_section();
                rdata_section->set_readable(true);
            }


            build_load_config_directory_full(image_full.get_image(), *rdata_section, image_full.get_load_config(), image_full.get_relocations()); //build load config

        }

        if ((!image_full.get_image().is_x32_image() && image_full.get_exceptions().size()) && (build_flags & PE_IMAGE_BUILD_DIR_EXCEPTIONS)) {
            pe_section* pdata_section = 0;

            if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_PDATA) {
                pdata_section = &image_full.get_image().add_section();
                pdata_section->set_section_name(std::string(".pdata"));
                pdata_section->set_readable(true).set_writeable(false).set_executable(false);
            }
            else {
                pdata_section = image_full.get_image().get_last_section();
                pdata_section->set_readable(true);
            }

            if ((!image_full.get_image().is_x32_image() && image_full.get_exceptions().size())) {
                build_extended_exceptions_info(image_full);
                build_exceptions_directory(image_full.get_image(), *pdata_section, image_full.get_exceptions(), image_full.get_relocations(), true);  //build exceptions
            }
        }

        if ((image_full.get_imports().size() && (build_flags & PE_IMAGE_BUILD_DIR_IMPORT)) ||
            (image_full.get_exports().get_number_of_functions() && (build_flags & PE_IMAGE_BUILD_DIR_EXPORT)) ||
            ((image_full.get_tls().get_address_of_index() || image_full.get_tls().get_callbacks().size()) && (build_flags & PE_IMAGE_BUILD_DIR_TLS))
            ) {

            pe_section* edata_section = 0;

            if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_EDATA) {
                edata_section = &image_full.get_image().add_section();
                edata_section->set_section_name(std::string(".edata"));
                edata_section->set_readable(true).set_writeable(false).set_executable(false);
            }
            else {
                edata_section = image_full.get_image().get_last_section();
                edata_section->set_readable(true);
            }


            if (image_full.get_exports().get_number_of_functions()) {                                    //build export
                build_export_directory(image_full.get_image(), *edata_section, image_full.get_exports());
            }
            if (image_full.get_imports().size()) {                                                        //build import
                build_import_directory_full(image_full.get_image(), *edata_section, image_full.get_imports());
            }
            if (image_full.get_tls().get_address_of_index() || image_full.get_tls().get_callbacks().size()) { //build tls
                build_tls_directory_full(image_full.get_image(), *edata_section, image_full.get_tls(), image_full.get_relocations());
                edata_section->set_writeable(true);
            }
        }
    }

    process_relocations(image_full);

    if (image_full.get_relocations().size() && (build_flags & PE_IMAGE_BUILD_DIR_RELOCATIONS)) {     //build relocations

        pe_section* reloc_section = 0;

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RSRC) {
            reloc_section = &image_full.get_image().add_section();
            reloc_section->set_section_name(std::string(".reloc"));
            reloc_section->set_readable(true).set_writeable(false).set_executable(false);
        }
        else {
            reloc_section = image_full.get_image().get_last_section();
            reloc_section->set_readable(true);
        }

        build_relocation_directory(image_full.get_image(), *reloc_section, image_full.get_relocations());

    }

    if (image_full.get_resources().get_entry_list().size() && (build_flags & PE_IMAGE_BUILD_DIR_RESOURCES)) {   //build resources

        pe_section* rsrc_section = 0;

        if (build_flags & PE_IMAGE_BUILD_SEP_SECTION_RSRC) {
            rsrc_section = &image_full.get_image().add_section();
            rsrc_section->set_section_name(std::string(".rsrc"));
            rsrc_section->set_readable(true).set_writeable(false).set_executable(false);
        }
        else {
            rsrc_section = image_full.get_image().get_last_section();
            rsrc_section->set_readable(true);
        }


        build_resources_directory(image_full.get_image(), *rsrc_section, image_full.get_resources());
    }
}

bool build_pe_image(pe_image& image, uint32_t build_flags, std::vector<uint8_t>& out_image) {

    out_image.clear();

    size_t dos_headers_size;
    size_t nt_headers_size;
    size_t headers_size;

    out_image = get_dos_headers(image, build_flags, dos_headers_size);
    nt_headers_size = dos_headers_size + (image.is_x32_image() ? sizeof(image_nt_headers32) : sizeof(image_nt_headers64));
    headers_size = calculate_headers_size(image, dos_headers_size, 0);

    out_image.resize(headers_size);

    align_sections(image, (uint32_t)headers_size);

    {
        std::vector<uint8_t> nt_header;
        get_nt_header(image, (uint32_t)headers_size, nt_header);
        memcpy(&out_image[dos_headers_size], nt_header.data(), nt_header.size());
    }

    if (image.get_sections_number()) {

        uint32_t section_raw_top = 0;
        uint32_t section_raw_top_size = 0;


        {
            uint8_t * p_sections_header = &out_image[nt_headers_size];

            for (unsigned int section_idx = 0; section_idx < image.get_sections_number(); section_idx++) {

                if (section_raw_top < image.get_section_by_idx(section_idx)->get_pointer_to_raw()) {
                    section_raw_top = image.get_section_by_idx(section_idx)->get_pointer_to_raw();
                    section_raw_top_size = image.get_section_by_idx(section_idx)->get_size_of_raw_data();
                }

                image_section_header section_hdr = { 0 };

                memcpy(section_hdr.name, image.get_section_by_idx(section_idx)->get_section_name().c_str(),
                    min(image.get_section_by_idx(section_idx)->get_section_name().length(), 8));

                section_hdr.virtual_size = image.get_section_by_idx(section_idx)->get_virtual_size();
                section_hdr.virtual_address = image.get_section_by_idx(section_idx)->get_virtual_address();
                section_hdr.size_of_raw_data = image.get_section_by_idx(section_idx)->get_size_of_raw_data();
                section_hdr.pointer_to_raw_data = image.get_section_by_idx(section_idx)->get_pointer_to_raw();
                section_hdr.characteristics = image.get_section_by_idx(section_idx)->get_characteristics();

                memcpy(p_sections_header, &section_hdr, sizeof(image_section_header));

                p_sections_header += sizeof(image_section_header);
            }
        }


        out_image.resize(headers_size +
            image.get_section_by_idx(uint32_t(image.get_sections_number()) - 1)->get_pointer_to_raw() +
            ALIGN_UP(
                image.get_section_by_idx(uint32_t(image.get_sections_number()) - 1)->get_size_of_raw_data()
                , image.get_file_align()));

        for (auto& section_ : image.get_sections()) { //write sections data
            memcpy(&out_image[section_->get_pointer_to_raw()], section_->get_section_data().data(), section_->get_size_of_raw_data());
        }
    }

    if (build_flags & PE_IMAGE_BUILD_UPD_CHECKSUM) {
        *(uint32_t*)&out_image[dos_headers_size + offsetof(image_nt_headers32, optional_header.checksum)] = calculate_checksum(out_image);
    }

    if (image.get_overlay_data().size() && build_flags & PE_IMAGE_BUILD_OVERLAY) {
        size_t overlay_offset = out_image.size();
        out_image.resize(out_image.size() + image.get_overlay_data().size());

        memcpy(&out_image[overlay_offset], image.get_overlay_data().data(), image.get_overlay_data().size());
    }

    return true;
}

bool build_shibari_image(pe_image_full& image_full, uint32_t enma_build_flags, std::vector<uint8_t>& out_image) {

    size_t dos_headers_size;
    size_t nt_headers_size;
    size_t headers_size;

    get_dos_headers(image_full.get_image(), enma_build_flags, dos_headers_size);
    nt_headers_size = dos_headers_size + (image_full.get_image().is_x32_image() ? sizeof(image_nt_headers32) : sizeof(image_nt_headers64));
    headers_size = calculate_headers_size(image_full.get_image(), dos_headers_size, get_new_sections_count(image_full, enma_build_flags));

    align_sections(image_full.get_image(), (uint32_t)headers_size);

    build_directories(image_full, enma_build_flags);

    return build_pe_image(image_full.get_image(), enma_build_flags, out_image);
}
```

`shibari/shibari_builder.h`:

```h
#pragma once


bool build_shibari_image(pe_image_full& image_full, uint32_t enma_build_flags, std::vector<uint8_t>& out_image);
```

`shibari/shibari_data_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_data_linker.h"
#include "shibari_data_linker_rtti_msvc.h"


shibari_data_linker::shibari_data_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module){}


shibari_data_linker::~shibari_data_linker()
{
}

shibari_linker_errors shibari_data_linker::link_modules_start() {

    for (auto& module_ : *extended_modules) {            //merge sections

        module_->get_module_position().set_current_position(
            ALIGN_UP(main_module->get_module_image().get_image().get_sections()[
                main_module->get_module_image().get_image().get_sections_number() - 1
            ]->get_virtual_address() + main_module->get_module_image().get_image().get_sections()[
                main_module->get_module_image().get_image().get_sections_number() - 1]->get_virtual_size(),
                    main_module->get_module_image().get_image().get_section_align())
        );

        module_->get_module_position().set_address_offset(
            module_->get_module_position().get_current_position() - module_->get_module_image().get_image().get_sections()[0]->get_virtual_address()
        );

        uint32_t section_top_rva = module_->get_module_position().get_current_position();
        uint32_t section_top_raw = ALIGN_UP(main_module->get_module_image().get_image().get_sections()[
            main_module->get_module_image().get_image().get_sections_number() - 1
        ]->get_pointer_to_raw() + main_module->get_module_image().get_image().get_sections()[
            main_module->get_module_image().get_image().get_sections_number() - 1]->get_size_of_raw_data(),
                main_module->get_module_image().get_image().get_section_align());

        for (auto& section_ : module_->get_module_image().get_image().get_sections()) { //add sections
            pe_section pre_section = *section_;
            pre_section.set_virtual_address(section_top_rva);
            pre_section.set_pointer_to_raw(section_top_raw);
            main_module->get_module_image().get_image().add_section(pre_section);

            section_top_raw += ALIGN_UP(pre_section.get_pointer_to_raw() + pre_section.get_size_of_raw_data(),
                main_module->get_module_image().get_image().get_section_align());

            section_top_rva += ALIGN_UP(pre_section.get_virtual_size(),
                main_module->get_module_image().get_image().get_section_align());
        }
    }

    for (uint32_t dir_idx = 0; dir_idx < 16; dir_idx++) {
        main_module->get_module_image().get_image().set_directory_virtual_address(dir_idx, 0);
        main_module->get_module_image().get_image().set_directory_virtual_size(dir_idx, 0);
    }

    return shibari_linker_errors::shibari_linker_ok;
}

shibari_linker_errors shibari_data_linker::link_modules_finalize() {

    pe_image_io image_io(main_module->get_module_image().get_image(), enma_io_mode::enma_io_mode_allow_expand);
    pe_section *last_section = main_module->get_module_image().get_image().get_last_section();

    image_io.set_image_offset(
        last_section->get_virtual_address() +
        max(last_section->get_virtual_size(), last_section->get_size_of_raw_data())
    );

    last_section->set_executable(true); //TODO: FIXIT last section can be not last ;)

    for (auto& module_ : *extended_modules) {

        for (auto& item : module_->get_free_space()) {//link free spaces
            main_module->get_free_space()[item.first + module_->get_module_position().get_address_offset()] = item.second;
        }

        shift_rtti_data(module_, main_module); //link rtti data

        { //link rtti exports

            shibari_module_export& module_export = module_->get_module_exports();

            if (module_export.get_exports_number()) {
                for (auto& exp_item : module_export.get_export_items()) {
                    pe_export_entry entry = exp_item;
                    entry.set_rva(exp_item.get_rva() + module_->get_module_position().get_address_offset());

                    main_module->get_module_exports().add_export(entry);
                }

                for (auto& exp_name : module_export.get_names()) {
                    main_module->get_module_exports().add_name(exp_name);
                }
            }
        }

        { //link sumbols

            for (auto& code_symbol : module_->get_code_symbols()) {
                main_module->get_code_symbols().push_back({
                    code_symbol.symbol_info_rva + module_->get_module_position().get_address_offset() ,
                    code_symbol.symbol_info_size
                    });
            }

            for (auto& data_symbol : module_->get_data_symbols()) {
                main_module->get_data_symbols().push_back({
                    data_symbol.symbol_info_rva + module_->get_module_position().get_address_offset() ,
                    data_symbol.symbol_info_size
                    });
            }
        }

        if (module_->get_module_image().get_image().get_characteristics()&IMAGE_FILE_DLL) {
            main_module->get_module_entrys().push_back({ shibari_entry_point_dll,
                module_->get_module_position().get_address_offset() + module_->get_module_image().get_image().get_entry_point()
                });


            main_module->get_module_image().get_tls().get_callbacks().push_back({
                module_->get_module_image().get_image().get_entry_point() + module_->get_module_position().get_address_offset(), true
                });

        }
        else {
            main_module->get_module_entrys().push_back({ shibari_entry_point_exe,
                module_->get_module_position().get_address_offset() + module_->get_module_image().get_image().get_entry_point()
                });

            main_module->get_module_image().get_tls().get_callbacks().push_back({
                image_io.get_image_offset(), true
                });

            if (this->main_module->get_module_image().get_image().is_x32_image()) {

                uint8_t wrapper_stub[] = {
                    0x55,                       //push ebp
                    0x8B,0xEC,                  //mov ebp,esp
                    0x6A,0x00,                  //push 0
                    0x6A,0x00,                  //push 0
                    0x6A,0x00,                  //push 0
                    0xFF,0x75,0x08,             //push[ebp + 08]
                    0xB8,0x78,0x56,0x34,0x12,   //mov eax,12345678
                    0xFF,0xD0,                  //call eax
                    0x5D,                       //pop ebp
                    0xC2,0x0C,0x00              //ret 0xC
                };

                *(uint32_t*)&wrapper_stub[13] = uint32_t(main_module->get_module_image().get_image().get_image_base() +
                    module_->get_module_position().get_address_offset() + module_->get_module_image().get_image().get_entry_point());

                main_module->get_module_image().get_relocations().add_entry(image_io.get_image_offset() + 13, 0);

                main_module->get_code_symbols().push_back({
                    image_io.get_image_offset() , sizeof(wrapper_stub)
                    });

                image_io.write(wrapper_stub, sizeof(wrapper_stub));

            }
            else {

                uint8_t wrapper_stub[] = {
                    0x45,0x31,0xC9,              //xor r9d,r9d
                    0x45,0x31,0xC0,              //xor r8d,r8d
                    0x31,0xD2,                   //xor edx,edx
                    0xFF,0x25,0x00,0x00,0x00,    //jmp qword ptr [$+5] ---||
                                                 //     ||
                                                 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   //   <-//
                };

                *(uint64_t*)&wrapper_stub[13] = main_module->get_module_image().get_image().get_image_base() +
                    module_->get_module_position().get_address_offset() + module_->get_module_image().get_image().get_entry_point();

                main_module->get_module_image().get_relocations().add_entry(image_io.get_image_offset() + 13, 0);

                main_module->get_code_symbols().push_back({
                    image_io.get_image_offset() , sizeof(wrapper_stub)
                    });

                image_io.write(wrapper_stub, sizeof(wrapper_stub));
            }
        }
    }

    return shibari_linker_errors::shibari_linker_ok;
}


void shibari_data_linker::shift_rtti_data(shibari_module* extended_module, shibari_module* main_module) {

    msvc_shift_module_rtti(extended_module, main_module);

    


}
```

`shibari/shibari_data_linker.h`:

```h
#pragma once
class shibari_data_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;

    void shift_rtti_data(shibari_module* extended_module, shibari_module* main_module);

public:
    shibari_data_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_data_linker();

public:
    shibari_linker_errors link_modules_start();
    shibari_linker_errors link_modules_finalize();

};


```

`shibari/shibari_data_linker_rtti_msvc.h`:

```h
#pragma once


#define MSVC_GET_RESULT_OFFSET(fixed_data) (\
    ( (fixed_data) + _module->get_module_position().get_address_offset()) + (main_module->get_module_image().get_image().is_x32_image() ? main_module->get_module_image().get_image().get_image_base() : 0) \
)

#define MSVC_RTTI_FIX_OFFSET(fix_rva, fixed_data) {\
    uint32_t fixed_data_ = uint32_t(MSVC_GET_RESULT_OFFSET(fixed_data)); \
    image_io.set_image_offset( uint32_t(fix_rva) + _module->get_module_position().get_address_offset()).write(&fixed_data_, sizeof(fixed_data_)); \
}

#define MSVC_RTTI_FIX_ABSOLUTE64(fix_rva, fixed_data) {\
    uint64_t fixed_data_ = main_module->get_module_image().get_image().get_image_base() + (fixed_data) + _module->get_module_position().get_address_offset(); \
    image_io.set_image_offset( uint32_t(fix_rva) + _module->get_module_position().get_address_offset()).write(&fixed_data_, sizeof(fixed_data_)); \
}



void msvc_shift_module_rtti(shibari_module* _module, shibari_module* main_module) {

    auto& msvc_rtti = _module->get_rtti();

    pe_image_io image_io(main_module->get_module_image().get_image());
    
    
    for (auto& comp_obj_loc : msvc_rtti.complete_object_locator_entries) {

        if (comp_obj_loc.second.get_class_descriptor_addr_rva()) {
            MSVC_RTTI_FIX_OFFSET(
                comp_obj_loc.first + offsetof(msvc_rtti_complete_object_locator, type_descriptor_addr),
                comp_obj_loc.second.get_class_descriptor_addr_rva()
            )
        }

        if (comp_obj_loc.second.get_type_descriptor_addr_rva()) {
            MSVC_RTTI_FIX_OFFSET(
                comp_obj_loc.first + offsetof(msvc_rtti_complete_object_locator, class_descriptor_addr),
                comp_obj_loc.second.get_type_descriptor_addr_rva()
            )
        }

        if (!main_module->get_module_image().get_image().is_x32_image()) {
            
            if (comp_obj_loc.second.get_object_base_rva()) {
                MSVC_RTTI_FIX_OFFSET(
                    comp_obj_loc.first + offsetof(msvc_rtti_complete_object_locator, object_base),
                    comp_obj_loc.second.get_object_base_rva()
                )
            }
        }
    }

    for (auto& class_hier_entry : msvc_rtti.class_hierarchy_descriptor_entries) {

        if (class_hier_entry.second.get_base_class_array_addr_rva()) {
            MSVC_RTTI_FIX_OFFSET(
                class_hier_entry.first + offsetof(msvc_rtti_class_hierarchy_descriptor, base_class_array_addr),
                class_hier_entry.second.get_base_class_array_addr_rva()
            )


            for (size_t base_entry_idx = 0; base_entry_idx < class_hier_entry.second.get_num_base_classes(); base_entry_idx++) {
                
                MSVC_RTTI_FIX_OFFSET(
                    class_hier_entry.second.get_base_class_array_addr_rva() + sizeof(uint32_t) * base_entry_idx,
                    (class_hier_entry.second.get_base_class_entries())[base_entry_idx]
                )           
            }
        }
    }


    for (auto& base_entry : msvc_rtti.base_class_descriptor_entries) {

        if (base_entry.second.get_type_descriptor_addr_rva()) {
            MSVC_RTTI_FIX_OFFSET(
                base_entry.first + offsetof(msvc_rtti_base_class_descriptor, type_descriptor_addr),
                base_entry.second.get_type_descriptor_addr_rva()
            )
        }

        if (base_entry.second.get_hierarchy_descriptor_ref()) {
            MSVC_RTTI_FIX_OFFSET(
                base_entry.first + offsetof(msvc_rtti_base_class_descriptor, hierarchy_descriptor_ref),
                base_entry.second.get_hierarchy_descriptor_ref()
            )
        }
    }

    if (main_module->get_module_image().get_image().is_x32_image()) {
        for (auto& type_entry : msvc_rtti.type_descriptor_entries) {

            if (type_entry.second.get_vtable_addr_rva()) {
                MSVC_RTTI_FIX_OFFSET(
                    type_entry.first + offsetof(msvc_rtti_32_type_descriptor, vtable_addr),
                    type_entry.second.get_vtable_addr_rva()
                )
            }

            if (type_entry.second.get_spare_rva()) {
                MSVC_RTTI_FIX_OFFSET(
                    type_entry.first + offsetof(msvc_rtti_32_type_descriptor, spare),
                    type_entry.second.get_spare_rva()
                )
            }
        }
    }
    else {

        for (auto& type_entry : msvc_rtti.type_descriptor_entries) {

            if (type_entry.second.get_vtable_addr_rva()) {
                MSVC_RTTI_FIX_ABSOLUTE64(
                    type_entry.first + offsetof(msvc_rtti_64_type_descriptor, vtable_addr),
                    type_entry.second.get_vtable_addr_rva()
                )
            }

            if (type_entry.second.get_spare_rva()) {
                MSVC_RTTI_FIX_ABSOLUTE64(
                    type_entry.first + offsetof(msvc_rtti_64_type_descriptor, spare),
                    type_entry.second.get_spare_rva()
                )
            }
        }
    }
}

```

`shibari/shibari_exceptions_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_exceptions_linker.h"


shibari_exceptions_linker::shibari_exceptions_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}


shibari_exceptions_linker::~shibari_exceptions_linker()
{
}


shibari_linker_errors shibari_exceptions_linker::link_modules() {
    if (main_module->get_module_image().get_image().is_x32_image()) { return shibari_linker_errors::shibari_linker_error_bad_input; }

    for (auto& ex_module : *extended_modules) {
        uint32_t module_offset = ex_module->get_module_position().get_address_offset();


        for (auto& unwind_entry_ : ex_module->get_module_image().get_exceptions().get_unwind_entries()) {

            main_module->get_module_image().get_exceptions().get_unwind_entries().push_back(unwind_entry_);

            auto& temp_unwind_entry = main_module->get_module_image().get_exceptions().get_unwind_entries()[
                main_module->get_module_image().get_exceptions().get_unwind_entries().size() - 1
            ];

            temp_unwind_entry.set_unwind_info_rva(temp_unwind_entry.get_unwind_info_rva() + module_offset);
            temp_unwind_entry.set_handler_rva(temp_unwind_entry.get_handler_rva() + module_offset);

            if (temp_unwind_entry.get_chained_entry()) {
                auto *chained_entry = temp_unwind_entry.get_chained_entry();
                
                chained_entry->set_begin_address(chained_entry->get_begin_address() + module_offset);
                chained_entry->set_end_address(chained_entry->get_end_address() + module_offset);
                chained_entry->set_unwind_data_address(chained_entry->get_unwind_data_address() + module_offset);
            }


            if (temp_unwind_entry.get_custom_parameter().get_data_type() != unknown_handler) {

                switch (temp_unwind_entry.get_custom_parameter().get_data_type()) {

                case unknown_handler: { break; }

                case __c_specific_handler: {
                    auto* data_ = temp_unwind_entry.get_custom_parameter().get_c_specific_handler_parameters_data();

                    for (auto& scope_entry : data_->table) {
                        scope_entry.begin_address += module_offset;
                        scope_entry.end_address += module_offset;

                        if (scope_entry.handler_address) {
                            scope_entry.handler_address += module_offset;
                        }
                        if (scope_entry.jump_target) {
                            scope_entry.jump_target += module_offset;
                        }
                    }

                    break;
                }
                case __delphi_specific_handler: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_delphi_specific_handler_parameters_data();

                    for (auto& scope_entry : data_->table) {
                        scope_entry.begin_address += module_offset;
                        scope_entry.end_address += module_offset;

                        if (scope_entry.handle_type > 2) {
                            scope_entry.handle_type += module_offset;
                        }
                        if (scope_entry.jump_target) {
                            scope_entry.jump_target += module_offset;
                        }
                    }
                    break;
                }
                case __llvm_specific_handler: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_llvm_specific_handler_parameters_data();

                    data_->data_rva += module_offset;

                    break;
                }
                case __gs_handler_check: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_gs_handler_check_parameters_data();
                    break;
                }
                case __gs_handler_check_seh: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_gs_handler_check_seh_parameters_data();

                    for (auto& scope_entry : data_->table) {
                        scope_entry.begin_address += module_offset;
                        scope_entry.end_address += module_offset;

                        if (scope_entry.handler_address) {
                            scope_entry.handler_address += module_offset;
                        }
                        if (scope_entry.jump_target) {
                            scope_entry.jump_target += module_offset;
                        }
                    }

                    break;
                }
                case __cxx_frame_handler3: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_cxx_frame_handler3_parameters_data();


                    for (auto& unwind_map_entry : data_->func_info.get_unwind_map_entries()) {
                        if (unwind_map_entry.p_action) {
                            unwind_map_entry.p_action += module_offset;
                        }
                    }

                    for (auto& try_block_entry : data_->func_info.get_try_block_map_entries()) {
                        for (auto& handler_type_entry : try_block_entry.get_handler_entries()) {
                            if (handler_type_entry.p_type) {
                                handler_type_entry.p_type += module_offset;
                            }
                            if (handler_type_entry.p_address_of_handler) {
                                handler_type_entry.p_address_of_handler += module_offset;
                            }
                        }

                        try_block_entry.set_p_handler_array(try_block_entry.get_p_handler_array() + module_offset);
                    }

                    for (auto& state_map_entry : data_->func_info.get_ip_to_state_map_entries()) {
                        if (state_map_entry.ip) {
                            state_map_entry.ip += module_offset;
                        }
                    }

                    break;
                }
                case __gs_handler_check_eh: {
                    auto* data_ = unwind_entry_.get_custom_parameter().get_gs_handler_check_eh_parameters_data();

                    for (auto& unwind_map_entry : data_->func_info.get_unwind_map_entries()) {
                        if (unwind_map_entry.p_action) {
                            unwind_map_entry.p_action += module_offset;
                        }
                    }

                    for (auto& try_block_entry : data_->func_info.get_try_block_map_entries()) {
                        for (auto& handler_type_entry : try_block_entry.get_handler_entries()) {
                            if (handler_type_entry.p_type) {
                                handler_type_entry.p_type += module_offset;
                            }
                            if (handler_type_entry.p_address_of_handler) {
                                handler_type_entry.p_address_of_handler += module_offset;
                            }
                        }

                        try_block_entry.set_p_handler_array(try_block_entry.get_p_handler_array() + module_offset);
                    }

                    for (auto& state_map_entry : data_->func_info.get_ip_to_state_map_entries()) {
                        if (state_map_entry.ip) {
                            state_map_entry.ip += module_offset;
                        }
                    }

                    break;
                }
                }
            }

        }

        for (auto& exception_entry : ex_module->get_module_image().get_exceptions().get_exception_entries()) {
            auto temp_entry = exception_entry;
            temp_entry.set_begin_address(temp_entry.get_begin_address() + module_offset);
            temp_entry.set_end_address(temp_entry.get_end_address() + module_offset);
            temp_entry.set_unwind_data_address(temp_entry.get_unwind_data_address() + module_offset);

            main_module->get_module_image().get_exceptions().add_exception_entry(temp_entry);
        }
    }

    return shibari_linker_errors::shibari_linker_ok;
}



```

`shibari/shibari_exceptions_linker.h`:

```h
#pragma once
class shibari_exceptions_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_exceptions_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_exceptions_linker();

public:
    shibari_linker_errors link_modules();
};


```

`shibari/shibari_export_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_export_linker.h"


struct export_references {
    uint32_t wrapper_rva;
    std::string lib_name;
    pe_export_entry export_entry;
    unsigned int module_export_owner;//-1 = main module other in bound modules
};

bool get_export_references(std::vector<shibari_module*>& extended_modules, shibari_module& main_module, std::vector<export_references>& export_refs);
void initialize_export_redirect_table(std::vector<shibari_module*>& extended_modules, shibari_module& main_module, std::vector<export_references>& export_refs);


shibari_export_linker::shibari_export_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}

shibari_export_linker::~shibari_export_linker(){}

shibari_linker_errors shibari_export_linker::link_modules() {

    std::vector<export_references> export_refs;

    if (!get_export_references(*extended_modules, *main_module, export_refs)) { 
        return shibari_linker_errors::shibari_linker_ok;
    }

    initialize_export_redirect_table(*extended_modules, *main_module, export_refs);       //create table in last section for export redirect


    for (auto& ref : export_refs) {                      //fix relocations for redirected import 
        unsigned int ref_lib_idx;
        unsigned int ref_func_idx;

        if (ref.export_entry.has_name()) {
            if (!shibari_import_linker::get_import_func_index(main_module->get_module_image().get_imports(),
                ref.lib_name, ref.export_entry.get_func_name(),
                ref_lib_idx, ref_func_idx)) {

                return shibari_linker_errors::shibari_linker_error_export_linking; // =\ why?
            }
        }
        else {
            if (!shibari_import_linker::get_import_func_index(main_module->get_module_image().get_imports(),
                ref.lib_name, ref.export_entry.get_ordinal(),
                ref_lib_idx, ref_func_idx)) {

                return shibari_linker_errors::shibari_linker_error_export_linking; // =\ why?
            }
        }

        std::vector<pe_relocation_entry*> found_relocs;
        main_module->get_module_image().get_relocations().get_items_by_relocation_id(found_relocs, SET_RELOCATION_ID_IAT(ref_lib_idx, ref_func_idx));

        for (auto & found_item : found_relocs) {

            if (main_module->get_module_image().get_image().is_x32_image()) {
                uint32_t new_rel = (uint32_t)main_module->get_module_image().get_image().rva_to_va(ref.wrapper_rva);

                pe_image_io(main_module->get_module_image().get_image(), enma_io_mode_allow_expand).set_image_offset(found_item->relative_virtual_address).write(
                    &new_rel, sizeof(new_rel));
            }
            else {
                uint64_t new_rel = main_module->get_module_image().get_image().rva_to_va(ref.wrapper_rva);

                pe_image_io(main_module->get_module_image().get_image(), enma_io_mode_allow_expand).set_image_offset(found_item->relative_virtual_address).write(
                    &new_rel, sizeof(new_rel));
            }

            found_item->relocation_id = relocation_index_default;
        }
    }


    pe_import_directory new_import_table = main_module->get_module_image().get_imports();
    for (auto& ref : export_refs) {                             //erase items from import by export lib name and export item 

        for (unsigned int import_lib_idx = 0, original_import_lib_idx = 0;
            import_lib_idx < new_import_table.get_libraries().size();
            import_lib_idx++, original_import_lib_idx++) {

            auto & import_lib = new_import_table.get_libraries()[import_lib_idx];
            auto& import_lib_name = import_lib.get_library_name();
            
            if (std::equal(ref.lib_name.begin(), ref.lib_name.end(),
                import_lib_name.begin(), import_lib_name.end(),
                [](char a, char b) { return tolower(a) == tolower(b); })) {

                for (unsigned int import_func_idx = 0, original_import_func_idx = 0;
                    import_func_idx < import_lib.get_entries().size();
                    import_func_idx++, original_import_func_idx++) {

                    auto & import_func = import_lib.get_entries()[import_func_idx];

                    if (ref.export_entry.has_name()) {
                        if (import_func.is_import_by_name() && import_func.get_func_name() == ref.export_entry.get_func_name()) {
                            import_lib.get_entries().erase(import_lib.get_entries().begin() + import_func_idx);
                            import_func_idx--;
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        if (!import_func.is_import_by_name() && import_func.get_ordinal() == ref.export_entry.get_ordinal()) {
                            import_lib.get_entries().erase(import_lib.get_entries().begin() + import_func_idx);
                            import_func_idx--;
                        }
                        else {
                            continue;
                        }
                    }
                }

                if (!import_lib.get_entries().size()) {                    //delete if lib empty
                    new_import_table.get_libraries().erase(new_import_table.get_libraries().begin() + import_lib_idx);
                    import_lib_idx--;
                }
            }
        }
    }

    if (!shibari_import_linker::switch_import_refs(main_module->get_module_image(), new_import_table)) {
        return shibari_linker_errors::shibari_linker_error_export_linking;
    }

    return shibari_linker_errors::shibari_linker_ok;
}

bool get_export_references(std::vector<shibari_module*>& extended_modules, shibari_module& main_module, std::vector<export_references>& export_refs) {
    pe_import_directory imports = main_module.get_module_image().get_imports();
    std::vector<shibari_module*> modules_pool;

    modules_pool.push_back(&main_module);
    for (auto& module_ : extended_modules) { modules_pool.push_back(module_); }


    for (unsigned int module_idx = 0; module_idx < modules_pool.size(); module_idx++) {
        shibari_module* current_module = modules_pool[module_idx];
        shibari_module_export& module_export = current_module->get_module_exports();

        if (module_export.get_exports_number()) {

            for (unsigned int import_lib_idx = 0; import_lib_idx < imports.get_libraries().size(); import_lib_idx++) {
                pe_import_library & import_lib = imports.get_libraries()[import_lib_idx];
                std::string current_export_lib_name;

                bool is_lib_name_match = false;

                auto& import_lib_name = import_lib.get_library_name();

                for (auto& exp_name : module_export.get_names()) {

                    if (std::equal(exp_name.begin(), exp_name.end(),
                        import_lib_name.begin(), import_lib_name.end(),
                        [](char a, char b) { return tolower(a) == tolower(b); })) { //check for library name

                        current_export_lib_name = exp_name;
                        is_lib_name_match = true;
                    }
                }

                if (is_lib_name_match) {

                    for (unsigned int import_func_idx = 0; import_func_idx < import_lib.get_entries().size(); import_func_idx++) {
                        pe_import_function& import_func = import_lib.get_entries()[import_func_idx];

                        for (auto & export_item : module_export.get_export_items()) {

                            if (import_func.is_import_by_name() == export_item.has_name()) {

                                if (import_func.is_import_by_name()) {

                                    if (import_func.get_func_name() == export_item.get_func_name()) {

                                        export_refs.push_back({
                                            0,
                                            current_export_lib_name,
                                            export_item,
                                            module_idx - 1
                                            });

                                        import_lib.get_entries().erase(import_lib.get_entries().begin() + import_func_idx);
                                        import_func_idx--;

                                        break;
                                    }
                                }
                                else {

                                    if (import_func.get_ordinal() == export_item.get_name_ordinal()) {
                                        export_refs.push_back({
                                            0,
                                            current_export_lib_name,
                                            export_item,
                                            module_idx - 1
                                            });

                                        import_lib.get_entries().erase(import_lib.get_entries().begin() + import_func_idx);
                                        import_func_idx--;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (!import_lib.get_entries().size()) { //delete import lib if its empty
                        imports.get_libraries().erase(imports.get_libraries().begin() + import_lib_idx);
                        import_lib_idx--;
                    }
                }
            }
        }
    }

    return export_refs.size() != 0;
}



void initialize_export_redirect_table(std::vector<shibari_module*>& extended_modules, shibari_module& main_module, std::vector<export_references>& export_refs) {

    pe_section *table_section = main_module.get_module_image().get_image().get_section_by_idx(    //get last section
        uint32_t(main_module.get_module_image().get_image().get_sections_number()) - 1
    );

    uint32_t redirect_table_rva = table_section->get_virtual_address() + table_section->get_virtual_size();
    pe_image_io redirect_io = pe_image_io(main_module.get_module_image().get_image(), enma_io_mode_allow_expand);
    redirect_io.set_image_offset(redirect_table_rva);

    for (unsigned int i = 0; i < export_refs.size(); i++) { //initialize redirect table

        if (main_module.get_module_image().get_image().is_x32_image()) {
            export_refs[i].wrapper_rva = redirect_io.get_image_offset();

            uint32_t reloc = (uint32_t)main_module.get_module_image().get_image().rva_to_va(export_refs[i].export_entry.get_rva());

            if (export_refs[i].module_export_owner != -1) {
                reloc += extended_modules[export_refs[i].module_export_owner]->get_module_position().get_address_offset();
            }


            redirect_io.write(&reloc, sizeof(reloc));
        }
        else {
            export_refs[i].wrapper_rva = redirect_io.get_image_offset();

            uint64_t reloc = main_module.get_module_image().get_image().rva_to_va(export_refs[i].export_entry.get_rva());

            if (export_refs[i].module_export_owner != -1) {
                reloc += extended_modules[export_refs[i].module_export_owner]->get_module_position().get_address_offset();
            }

            redirect_io.write(&reloc, sizeof(reloc));
        }

        main_module.get_module_image().get_relocations().add_entry(export_refs[i].wrapper_rva, relocation_index_default);
    }
}
```

`shibari/shibari_export_linker.h`:

```h
#pragma once
class shibari_export_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_export_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_export_linker();

public:
    shibari_linker_errors link_modules();

};


```

`shibari/shibari_import_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_import_linker.h"


shibari_import_linker::shibari_import_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}

shibari_import_linker::~shibari_import_linker(){}


shibari_linker_errors shibari_import_linker::link_modules() {

    for (auto& module : *extended_modules) {
        for (auto & lib : module->get_module_image().get_imports().get_libraries()) {
            pe_import_library* main_lib;
            if (main_module->get_module_image().get_imports().get_imported_lib(lib.get_library_name(), main_lib)) {

                for (auto & func : lib.get_entries()) {
                    pe_import_library* main_lib_;
                    pe_import_function * main_func_;
                    if (func.is_import_by_name()) {
                        if (!main_module->get_module_image().get_imports().get_imported_func(lib.get_library_name(), func.get_func_name(), main_lib_, main_func_)) {
                            main_lib->add_entry(func);
                        }
                    }
                    else {
                        if (!main_module->get_module_image().get_imports().get_imported_func(lib.get_library_name(), func.get_ordinal(), main_lib_, main_func_)) {
                            main_lib->add_entry(func);
                        }
                    }
                }
            }
            else {
                main_module->get_module_image().get_imports().add_library(lib);
            }
        }
    }


    //
    pe_import_directory new_import_table = main_module->get_module_image().get_imports();

    for (unsigned int main_lib_idx = 0; main_lib_idx < new_import_table.get_libraries().size(); main_lib_idx++) {

        for (unsigned int lib_idx = main_lib_idx + 1; lib_idx < new_import_table.get_libraries().size(); lib_idx++) {

            auto& main_lib_name = new_import_table.get_libraries()[main_lib_idx].get_library_name();
            auto& current_lib_name = new_import_table.get_libraries()[lib_idx].get_library_name();


            if (std::equal(main_lib_name.begin(), main_lib_name.end(),
                current_lib_name.begin(), current_lib_name.end(),
                [](char a, char b) { return tolower(a) == tolower(b); })) {

                for (auto& func_entry : new_import_table.get_libraries()[lib_idx].get_entries()) {
                    for (auto& func_entry_main : new_import_table.get_libraries()[main_lib_idx].get_entries()) {
                        if (func_entry.is_import_by_name() == func_entry_main.is_import_by_name()) {

                            if (func_entry.is_import_by_name()) {
                                if (func_entry.get_func_name() == func_entry_main.get_func_name()) {
                                    goto func_found;
                                }
                            }
                            else {
                                if (func_entry.get_ordinal() == func_entry_main.get_ordinal()) {
                                    goto func_found;
                                }
                            }


                        }
                    }
                    new_import_table.get_libraries()[main_lib_idx].get_entries().push_back(func_entry);
                func_found:;
                }

                new_import_table.get_libraries().erase(
                    new_import_table.get_libraries().begin() + lib_idx
                );

                lib_idx--;
            }
        }
    }


    if (!switch_import_refs(main_module->get_module_image(), new_import_table)) {
        return shibari_linker_errors::shibari_linker_error_import_linking;
    }


    return shibari_linker_errors::shibari_linker_ok;
}


bool shibari_import_linker::switch_import_refs(pe_image_full& image_full, pe_import_directory& new_import_table) {
    //rebuild relocations refs to import and switch import to new_import_table
    for (unsigned int reloc_idx = 0; reloc_idx < image_full.get_relocations().size(); reloc_idx++) {
        pe_relocation_entry & reloc_entry = image_full.get_relocations().get_entries()[reloc_idx];

        if (reloc_entry.relocation_id & relocation_index_iat_address) {

            unsigned int reloc_lib_idx = GET_HI_NUMBER(reloc_entry.relocation_id);
            unsigned int reloc_func_idx = GET_LO_NUMBER(reloc_entry.relocation_id);

            pe_import_library& reloc_ref_lib = image_full.get_imports().get_libraries()[reloc_lib_idx];
            pe_import_function& reloc_ref_func = reloc_ref_lib.get_entries()[reloc_func_idx];


            //handle refs to import
            for (unsigned int new_import_lib_idx = 0; new_import_lib_idx < new_import_table.size(); new_import_lib_idx++) {
                pe_import_library& new_import_lib = new_import_table.get_libraries()[new_import_lib_idx];


                auto& new_import_lib_name = new_import_lib.get_library_name();
                auto& reloc_ref_lib_name = reloc_ref_lib.get_library_name();

                if (std::equal(new_import_lib_name.begin(), new_import_lib_name.end(),
                    reloc_ref_lib_name.begin(), reloc_ref_lib_name.end(),
                    [](char a, char b) { return tolower(a) == tolower(b); })) {

                    for (unsigned int new_import_func_idx = 0; new_import_func_idx < new_import_lib.size(); new_import_func_idx++) {
                        pe_import_function& new_import_func = new_import_lib.get_entries()[new_import_func_idx];

                        if (reloc_ref_func.is_import_by_name()) {

                            if (new_import_func.is_import_by_name() && new_import_func.get_func_name() == reloc_ref_func.get_func_name()) {
                                reloc_entry.relocation_id = SET_RELOCATION_ID_IAT(new_import_lib_idx, new_import_func_idx);
                                goto next_reloc_ref;
                            }
                        }
                        else {
                            if (!new_import_func.is_import_by_name() && new_import_func.get_ordinal() == reloc_ref_func.get_ordinal()) {
                                reloc_entry.relocation_id = SET_RELOCATION_ID_IAT(new_import_lib_idx, new_import_func_idx);
                                goto next_reloc_ref;
                            }
                        }
                    }
                }
            }
            return false;
        next_reloc_ref:;
        }
    }

    image_full.get_imports() = new_import_table;

    return true;
}

bool shibari_import_linker::process_import(shibari_module& target_module) {
    //x32 stub
    //jmp dword ptr [dd relocate to iat]

    //x64 stub
    //push rax
    //mov rax,[dq relocate to iat]
    //xchg rax,[rsp]
    //ret

    auto& image_full = target_module.get_module_image();

    pe_section* last_section = image_full.get_image().get_sections()[image_full.get_image().get_sections_number() - 1];

    if (last_section->get_virtual_size() > last_section->get_size_of_raw_data()) {
        pe_section_io(*last_section, image_full.get_image(), enma_io_mode_allow_expand).add_size(
            last_section->get_virtual_size() - last_section->get_size_of_raw_data()
        );
    }

    last_section->set_executable(true);

    pe_image_io iat_wrapper_io(image_full.get_image(), enma_io_mode_allow_expand);
    iat_wrapper_io.seek_to_end();

    image_full.get_image().get_last_section()->set_executable(true); //TODO: FIXIT last section can be not last ;)

    for (unsigned int lib_idx = 0; lib_idx < image_full.get_imports().size(); lib_idx++) {
        pe_import_library& current_lib = image_full.get_imports().get_libraries()[lib_idx];

        pe_image_io iat_io(image_full.get_image(), enma_io_mode_allow_expand);


        for (unsigned int func_idx = 0; func_idx < current_lib.size(); func_idx++) {
            pe_import_function& current_func = current_lib.get_entries()[func_idx];

            if (image_full.get_image().is_x32_image()) {
                uint32_t import_wrapper_rva = iat_wrapper_io.get_image_offset();
                uint8_t wrapper_stub[] = { 0xFF ,0x25 ,0,0,0,0 };

                target_module.get_code_symbols().push_back({ import_wrapper_rva , sizeof(wrapper_stub) });

                uint32_t iat_reloc = (uint32_t)image_full.get_image().rva_to_va(import_wrapper_rva);


                if (iat_io.set_image_offset(current_func.get_iat_rva()).write(
                    &iat_reloc, sizeof(iat_reloc)) == enma_io_success) {
                    image_full.get_relocations().add_entry(current_func.get_iat_rva(), relocation_index_default);
                }
                else {
                    return false;
                }

                if (iat_wrapper_io.write(
                    wrapper_stub, sizeof(wrapper_stub)) == enma_io_success) {
                    image_full.get_relocations().add_entry(import_wrapper_rva + 2, SET_RELOCATION_ID_IAT(lib_idx, func_idx));
                }
                else {
                    return false;
                }
            }
            else {
                uint32_t import_wrapper_rva = iat_wrapper_io.get_image_offset();
                uint8_t wrapper_stub[] = {
                    0x50,                       //push rax
                    0x48 ,0xA1 ,0,0,0,0,0,0,0,0,//mov rax,[dq relocate to iat]
                    0x48 ,0x87 ,4,0x24,         //xchg [rsp],rax
                    0xC3,                       //ret
                };

                target_module.get_code_symbols().push_back({ import_wrapper_rva , sizeof(wrapper_stub) });

                uint64_t iat_reloc = image_full.get_image().rva_to_va(import_wrapper_rva);

                if (iat_io.set_image_offset(current_func.get_iat_rva()).write(
                    &iat_reloc, sizeof(iat_reloc)) == enma_io_success) {
                    image_full.get_relocations().add_entry(current_func.get_iat_rva(), relocation_index_default);
                }
                else {
                    return false;
                }

                if (iat_wrapper_io.write(
                    wrapper_stub, sizeof(wrapper_stub)) == enma_io_success) {
                    image_full.get_relocations().add_entry(import_wrapper_rva + 3, SET_RELOCATION_ID_IAT(lib_idx, func_idx));
                }
                else {
                    return false;
                }
            }
        }
    }

    return true;
}

bool shibari_import_linker::get_import_func_index(const pe_import_directory& imports,
    const std::string& lib_name,const std::string& funcname,
    uint32_t & lib_idx, uint32_t & func_idx) {

    for (unsigned int current_lib_idx = 0; current_lib_idx < imports.get_libraries().size(); current_lib_idx++) {
        auto& current_library = imports.get_libraries()[current_lib_idx];

        auto& current_lib_name = current_library.get_library_name();

        if (std::equal(current_lib_name.begin(), current_lib_name.end(), 
            lib_name.begin(), lib_name.end(), 
            [](char a, char b) { return tolower(a) == tolower(b); })) {

            for (unsigned int current_func_idx = 0; current_func_idx < current_library.get_entries().size(); current_func_idx++) {
                auto& current_func = current_library.get_entries()[current_func_idx];

                if (current_func.is_import_by_name() && current_func.get_func_name() == funcname) {

                    lib_idx = current_lib_idx;
                    func_idx = current_func_idx;
                    return true;
                }
            }
        }

    }

    return false;
}

bool shibari_import_linker::get_import_func_index(const pe_import_directory& imports,
    const std::string& lib_name, uint16_t func_ordinal,
    uint32_t & lib_idx, uint32_t & func_idx) {

    for (unsigned int current_lib_idx = 0; current_lib_idx < imports.get_libraries().size(); current_lib_idx++) {
        auto& current_library = imports.get_libraries()[current_lib_idx];

        auto& current_lib_name = current_library.get_library_name();

        if (std::equal(current_lib_name.begin(), current_lib_name.end(), 
            lib_name.begin(), lib_name.end(), 
            [](char a, char b) { return tolower(a) == tolower(b); })) {

            for (unsigned int current_func_idx = 0; current_func_idx < current_library.get_entries().size(); current_func_idx++) {
                auto& current_func = current_library.get_entries()[current_func_idx];

                if (!current_func.is_import_by_name() && current_func.get_ordinal() == func_ordinal) {

                    lib_idx = current_lib_idx;
                    func_idx = current_func_idx;
                    return true;
                }
            }
        }

    }

    return false;
}
```

`shibari/shibari_import_linker.h`:

```h
#pragma once

class shibari_import_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_import_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_import_linker();

public:
    shibari_linker_errors link_modules();


public:
    static bool process_import(shibari_module& target_module);

    static bool switch_import_refs(pe_image_full& image_full,
        pe_import_directory& new_import_table);

    static bool get_import_func_index(const pe_import_directory& imports,
        const std::string& lib_name, const std::string& funcname,
        uint32_t & lib_idx, uint32_t & func_idx);

    static bool get_import_func_index(const pe_import_directory& imports,
        const std::string& lib_name, uint16_t func_ordinal,
        uint32_t & lib_idx, uint32_t & func_idx);
};


```

`shibari/shibari_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_linker.h"

shibari_linker::shibari_linker(std::vector<shibari_module*>& extended_modules, shibari_module* main_module){
    this->extended_modules = extended_modules;
    this->main_module = main_module;
}


shibari_linker::~shibari_linker(){

}


shibari_linker_errors shibari_linker::link_modules() {

    if (!main_module) {
        return shibari_linker_errors::shibari_linker_error_bad_input;
    }
    else {
        if (!explore_module(main_module)) {
            return shibari_linker_errors::shibari_linker_error_bad_input;
        }
    }

    for (auto &module : extended_modules) {
        if (!module || main_module->get_module_image().get_image().is_x32_image() != module->get_module_image().get_image().is_x32_image() || !explore_module(module)) {
            return shibari_linker_errors::shibari_linker_error_bad_input;
        }
    }

    shibari_data_linker        linker_data(&extended_modules, main_module);
    shibari_import_linker      linker_imports(&extended_modules, main_module);
    shibari_export_linker      linker_exports(&extended_modules, main_module);
    shibari_relocations_linker linker_relocations(&extended_modules, main_module);
    shibari_loadconfigs_linker linker_loadconfigs(&extended_modules, main_module);
    shibari_tls_linker         linker_tls(&extended_modules, main_module);
    shibari_exceptions_linker  linker_exceptions(&extended_modules, main_module);


    shibari_linker_errors result = shibari_linker_errors::shibari_linker_ok;

    result = linker_data.link_modules_start();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    result = linker_imports.link_modules();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    result = linker_relocations.link_modules();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    result = linker_exports.link_modules();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    result = linker_tls.link_modules();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    result = linker_loadconfigs.link_modules();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }

    if (!main_module->get_module_image().get_image().is_x32_image()) {
        result = linker_exceptions.link_modules();
        if (result != shibari_linker_errors::shibari_linker_ok) { return result; }
    }

    result = linker_data.link_modules_finalize();
    if (result != shibari_linker_errors::shibari_linker_ok) { return result; }


    return shibari_linker_errors::shibari_linker_ok;
}


bool shibari_linker::explore_module(shibari_module * target_module) {

    if (!target_module) { 
        return false; 
    }

    switch (target_module->get_module_code()) {

        case shibari_module_code::shibari_module_incorrect:
        case shibari_module_code::shibari_module_initialization_failed: {
            return false;
        }

        case shibari_module_code::shibari_module_initialization_success: {
            return true;
        }

        default: {
            break; 
        }

    }

    
    pe_placement placement;
    pe_directory_code code =  get_directories_placement(target_module->get_module_image().get_image(), placement, &target_module->get_module_image().get_bound_imports());
    get_extended_exception_info_placement(target_module->get_module_image(), placement);


    if (code != pe_directory_code_success) { 
        return false; 
    }

    pe_erase_placement(target_module->get_module_image().get_image(), placement, &target_module->get_module_image().get_relocations(), true);

    target_module->get_free_space() = placement;

    if (target_module->get_module_image().get_delay_imports().get_libraries().size()) {//merge delay import
        for (auto &item : target_module->get_module_image().get_delay_imports().get_libraries()) {
            target_module->get_module_image().get_imports().add_library(item.convert_to_pe_import_library());
        }
    }

    if (!shibari_relocations_linker::process_relocations(*target_module)) {
        return false; 
    }

    if (!shibari_import_linker::process_import(*target_module)) {
        return false; 
    }


    for (auto& section_ : target_module->get_module_image().get_image().get_sections()) {
        if (section_->get_virtual_size() < section_->get_size_of_raw_data()) {
            section_->set_virtual_size(section_->get_size_of_raw_data());
        }
    }

    if (target_module->get_module_image().get_exports().get_entries().size()) {
        for (auto& export_func : target_module->get_module_image().get_exports().get_entries()) {
            target_module->get_module_exports().add_export(export_func);
        }

        target_module->get_module_exports().add_name(target_module->get_module_image().get_exports().get_library_name());
    }

    target_module->set_module_code(shibari_module_initialization_success);

    return true; 
}


```

`shibari/shibari_linker.h`:

```h
#pragma once

enum shibari_linker_errors {
    shibari_linker_ok,
    shibari_linker_error_build,
    shibari_linker_error_bad_input,
    shibari_linker_error_export_linking,
    shibari_linker_error_import_linking,
    shibari_linker_error_loadconfig_linking,
    shibari_linker_error_relocation_linking,
    shibari_linker_error_exceptions_linking,
    shibari_linker_error_tls_linking,
};


#include "shibari_import_linker.h"
#include "shibari_export_linker.h"
#include "shibari_loadconfigs_linker.h"
#include "shibari_exceptions_linker.h"
#include "shibari_relocations_linker.h"
#include "shibari_tls_linker.h"
#include "shibari_data_linker.h"

class shibari_linker{
    std::vector<shibari_module*> extended_modules;
    shibari_module* main_module;

    void process_relocations();
    bool explore_module(shibari_module * module);
public:
    shibari_linker(std::vector<shibari_module*>& extended_modules,shibari_module* main_module);
    ~shibari_linker();

    shibari_linker_errors link_modules();

};


```

`shibari/shibari_loadconfigs_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_loadconfigs_linker.h"


shibari_loadconfigs_linker::shibari_loadconfigs_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}


shibari_loadconfigs_linker::~shibari_loadconfigs_linker()
{
}

shibari_linker_errors shibari_loadconfigs_linker::link_modules() {

    for (auto & module : *extended_modules) {
        for (auto& se_handler : module->get_module_image().get_load_config().get_se_handlers()) {
            main_module->get_module_image().get_load_config().get_se_handlers().push_back(se_handler + module->get_module_position().get_address_offset());
        }
        for (auto& lock_prefix_rva : module->get_module_image().get_load_config().get_lock_prefixes()) {
            main_module->get_module_image().get_load_config().get_lock_prefixes().push_back(lock_prefix_rva + module->get_module_position().get_address_offset());
        }
        for (auto& guard_cf_func_rva : module->get_module_image().get_load_config().get_guard_cf_functions()) {
            main_module->get_module_image().get_load_config().get_guard_cf_functions().push_back(guard_cf_func_rva + module->get_module_position().get_address_offset());
        }
        for (auto& guard_iat_rva : module->get_module_image().get_load_config().get_guard_iat_entries()) {
            main_module->get_module_image().get_load_config().get_guard_iat_entries().push_back(guard_iat_rva + module->get_module_position().get_address_offset());
        }
        for (auto& guard_long_jump_rva : module->get_module_image().get_load_config().get_guard_long_jump_targets()) {
            main_module->get_module_image().get_load_config().get_guard_iat_entries().push_back(guard_long_jump_rva + module->get_module_position().get_address_offset());
        }
    }

    return shibari_linker_errors::shibari_linker_ok;
}
```

`shibari/shibari_loadconfigs_linker.h`:

```h
#pragma once
class shibari_loadconfigs_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_loadconfigs_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_loadconfigs_linker();

public:
    shibari_linker_errors link_modules();

};


```

`shibari/shibari_module.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_module.h"


shibari_module_position::shibari_module_position() {
    this->current_position = 0;
    this->address_offset = 0;
}
shibari_module_position::shibari_module_position(const shibari_module_position& position) {
    this->operator=(position);
}
shibari_module_position::~shibari_module_position() {

}
shibari_module_position& shibari_module_position::operator=(const shibari_module_position& position) {

    this->current_position = position.current_position;
    this->address_offset = position.address_offset;

    return *this;
}

void shibari_module_position::set_current_position(uint32_t position) {
    this->current_position = position;
}
void shibari_module_position::set_address_offset(uint32_t offset) {
    this->address_offset = offset;
}

uint32_t shibari_module_position::get_current_position() const {
    return this->current_position;
}
uint32_t shibari_module_position::get_address_offset() const {
    return this->address_offset;
}


shibari_module_export::shibari_module_export() {

}
shibari_module_export::shibari_module_export(const shibari_module_export& module_export) {
    this->operator=(module_export);
}
shibari_module_export::~shibari_module_export() {

}

shibari_module_export& shibari_module_export::operator=(const shibari_module_export& module_export) {
    this->extended_names = module_export.extended_names;
    this->export_entries = module_export.export_entries;

    return *this;
}

void shibari_module_export::add_name(const std::string& name) {
    this->extended_names.push_back(name);
}

void shibari_module_export::add_export(const pe_export_entry& entry) {
    this->export_entries.push_back(entry);
}

void shibari_module_export::clear_names() {
    this->extended_names.clear();
}
void shibari_module_export::clear_exports() {
    this->export_entries.clear();
}

size_t shibari_module_export::get_names_number() const {
    return this->extended_names.size();
}
size_t shibari_module_export::get_exports_number() const {
    return this->export_entries.size();
}

std::vector<std::string>&       shibari_module_export::get_names() {
    return this->extended_names;
}
const std::vector<std::string>& shibari_module_export::get_names() const {
    return this->extended_names;
}

std::vector<pe_export_entry>& shibari_module_export::get_export_items() {
    return this->export_entries;
}
const std::vector<pe_export_entry>& shibari_module_export::get_export_items() const {
    return this->export_entries;
}

shibari_module::shibari_module() {
    this->module_code = shibari_module_code::shibari_module_incorrect;
}

shibari_module::shibari_module(const pe_image& image) {

    if (image.get_image_status() == pe_image_status::pe_image_status_ok) {

        this->image_full = image;

        get_extended_exception_info(this->image_full);
        get_runtime_type_information(this->image_full, this->rtti);

        if (this->image_full.get_directory_code() != pe_directory_code_success) {
            this->module_code = shibari_module_code::shibari_module_incorrect;
        }
        else {
            this->module_code = shibari_module_code::shibari_module_correct;
        }
    }
    else {
        this->module_code = shibari_module_code::shibari_module_incorrect;
    }
}

shibari_module::shibari_module(const std::string& path) {
    this->operator=(shibari_module(pe_image(path)));
}
shibari_module::shibari_module(const shibari_module &module) {
    this->operator=(module);
}
shibari_module::~shibari_module() { }

shibari_module& shibari_module::operator=(const shibari_module& _module) {

    this->module_code     = _module.module_code;
    this->image_full      = _module.image_full;
    this->module_position = _module.module_position;
    this->module_exports  = _module.module_exports;
    this->module_entrys   = _module.module_entrys;

    this->rtti = _module.rtti;

    return *this;
}

void shibari_module::set_module_code(shibari_module_code code) {
    this->module_code = code;
}

msvc_rtti_desc& shibari_module::get_rtti() {
    return this->rtti;
}
pe_placement& shibari_module::get_free_space() {
    return this->free_space;
}

const msvc_rtti_desc& shibari_module::get_rtti() const {
    return this->rtti;
}

const pe_placement& shibari_module::get_free_space() const {
    return this->free_space;
}

pe_image_full&                       shibari_module::get_module_image() {
    return this->image_full;
}
shibari_module_position&                 shibari_module::get_module_position() {
    return this->module_position;
}
shibari_module_export&                   shibari_module::get_module_exports() {
    return this->module_exports;
}
std::vector<shibari_module_entry_point>& shibari_module::get_module_entrys() {
    return this->module_entrys;
}
std::vector<shibari_module_symbol_info>& shibari_module::get_code_symbols() {
    return this->code_symbols;
}
std::vector<shibari_module_symbol_info>& shibari_module::get_data_symbols() {
    return this->data_symbols;
}

const pe_image_full&                       shibari_module::get_module_image() const {
    return this->image_full;
}
const shibari_module_position&                 shibari_module::get_module_position() const {
    return this->module_position;
}
const shibari_module_export&                   shibari_module::get_module_exports() const {
    return this->module_exports;
}
const std::vector<shibari_module_entry_point>& shibari_module::get_module_entrys() const {
    return this->module_entrys;
}
const std::vector<shibari_module_symbol_info>& shibari_module::get_code_symbols() const {
    return this->code_symbols;
}
const std::vector<shibari_module_symbol_info>& shibari_module::get_data_symbols() const {
    return this->data_symbols;
}

shibari_module_code shibari_module::get_module_code() const {
    return this->module_code;
}
```

`shibari/shibari_module.h`:

```h
#pragma once

#define SET_HI_NUMBER(x,num) (((x)&0xF000FFFF)|(((num)&0xFFF)<<16))
#define SET_LO_NUMBER(x,num) (((x)&0xFFFF0000)| ((num)&0xFFFF))

#define GET_HI_NUMBER(x) (((x)&0x0FFF0000)>>16)
#define GET_LO_NUMBER(x) (((x)&0x0000FFFF))

#define SET_RELOCATION_ID_IAT(lib_num,func_num) ((((lib_num)&0xFFF)<<16)|((func_num)&0xFFFF)|relocation_index_iat_address)

enum shibari_module_relocation_index {
    relocation_index_default = 1,
    relocation_index_iat_address = 0xF0000000,//((reloc_id&0x0FFF0000)>>16) module id (reloc_id&0x0000FFFF) function id
};

enum shibari_module_code {
    shibari_module_incorrect,
    shibari_module_correct,
    shibari_module_initialization_failed,
    shibari_module_initialization_success,
};

enum shibari_entry_point {
    shibari_entry_point_exe = 1,
    shibari_entry_point_dll = 2,
    shibari_entry_point_sys = 3,
};

struct shibari_module_entry_point {
    shibari_entry_point type;
    uint32_t entry_point_rva;
};

struct shibari_module_symbol_info {
    uint32_t symbol_info_rva;
    uint32_t symbol_info_size;
};

class shibari_module_position {
    uint32_t current_position;//where first section is started in main module 
    uint32_t address_offset;//current position - original position
public:
    shibari_module_position();
    shibari_module_position(const shibari_module_position& position);
    ~shibari_module_position();

    shibari_module_position& operator=(const shibari_module_position& position);
public:
    void set_current_position(uint32_t position);
    void set_address_offset(uint32_t offset);
public:
    uint32_t get_current_position() const;
    uint32_t get_address_offset() const;
};

class shibari_module_export {
    std::vector<std::string>       extended_names;
    std::vector<pe_export_entry>   export_entries;
public:
    shibari_module_export();
    shibari_module_export(const shibari_module_export& module_export);
    ~shibari_module_export();


    shibari_module_export& operator=(const shibari_module_export& module_export);
public:
    void add_name(const std::string& name);
    void add_export(const pe_export_entry& item);
    
    void clear_names();
    void clear_exports();
public:
    size_t get_names_number() const;
    size_t get_exports_number() const;

    std::vector<std::string>&       get_names() ;
    const std::vector<std::string>&       get_names() const;
    std::vector<pe_export_entry>& get_export_items();
    const std::vector<pe_export_entry>& get_export_items() const;
};


class shibari_module{
    shibari_module_code     module_code;
    pe_image_full           image_full;
    shibari_module_position module_position;
    shibari_module_export   module_exports;

    msvc_rtti_desc rtti;

    std::vector<shibari_module_entry_point> module_entrys;

    std::vector<shibari_module_symbol_info> code_symbols;
    std::vector<shibari_module_symbol_info> data_symbols;

    pe_placement free_space;
public:
    shibari_module();
    shibari_module(const std::string& path);
    shibari_module(const pe_image& image);
    shibari_module(const shibari_module &module);
    ~shibari_module();

    shibari_module& operator=(const shibari_module& module);

    void set_module_code(shibari_module_code code);
public:
    msvc_rtti_desc& get_rtti();
    pe_placement& get_free_space();

public:
    const msvc_rtti_desc& get_rtti() const;
    const pe_placement& get_free_space() const;
public:
    pe_image_full&                           get_module_image();
    shibari_module_position&                 get_module_position();
    shibari_module_export&                   get_module_exports();
    std::vector<shibari_module_entry_point>& get_module_entrys();
    std::vector<shibari_module_symbol_info>& get_code_symbols();
    std::vector<shibari_module_symbol_info>& get_data_symbols();

public:
    const pe_image_full&                           get_module_image() const;
    const shibari_module_position&                 get_module_position() const;
    const shibari_module_export&                   get_module_exports() const;
    const std::vector<shibari_module_entry_point>& get_module_entrys() const;
    const std::vector<shibari_module_symbol_info>& get_code_symbols() const;
    const std::vector<shibari_module_symbol_info>& get_data_symbols() const;

    shibari_module_code get_module_code() const;
};


```

`shibari/shibari_relocations_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_relocations_linker.h"


shibari_relocations_linker::shibari_relocations_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}


shibari_relocations_linker::~shibari_relocations_linker()
{

}

shibari_linker_errors shibari_relocations_linker::link_modules() {

    for (auto& module : *extended_modules) {

        for (auto& entry : module->get_module_image().get_relocations().get_entries()) { //handle image relocations

            switch (entry.relocation_id) {

            case relocation_index_default: {

                pe_section * target_section = main_module->get_module_image().get_image().get_section_by_rva(
                    entry.relative_virtual_address + module->get_module_position().get_address_offset()
                );

                if (!target_section) {
                    return shibari_linker_errors::shibari_linker_error_relocation_linking;
                }

                if (main_module->get_module_image().get_image().is_x32_image()) {
                    (*(uint32_t*)&target_section->get_section_data()[
                        (entry.relative_virtual_address + module->get_module_position().get_address_offset()) -
                            target_section->get_virtual_address()]) += (uint32_t(main_module->get_module_image().get_image().get_image_base() -
                                module->get_module_image().get_image().get_image_base()) +
                                module->get_module_position().get_address_offset()
                                );
                }
                else {
                    (*(uint64_t*)&target_section->get_section_data()[
                        (entry.relative_virtual_address + module->get_module_position().get_address_offset()) -
                            target_section->get_virtual_address()]) += ((
                                main_module->get_module_image().get_image().get_image_base() -
                                module->get_module_image().get_image().get_image_base()) +
                                module->get_module_position().get_address_offset()
                                );
                }

                main_module->get_module_image().get_relocations().add_entry(
                    entry.relative_virtual_address + module->get_module_position().get_address_offset(), entry.relocation_id);
                break;
            }

            default: {

                if (entry.relocation_id&relocation_index_iat_address) {

                    unsigned int src_lib_idx = GET_HI_NUMBER(entry.relocation_id);
                    unsigned int src_func_idx = GET_LO_NUMBER(entry.relocation_id);

                    pe_import_library& src_library = module->get_module_image().get_imports().get_libraries()[src_lib_idx];
                    pe_import_function&    src_func = src_library.get_entries()[src_func_idx];

                    unsigned int dst_lib_idx;
                    unsigned int dst_func_idx;

                    if (src_func.is_import_by_name()) {
                        if (shibari_import_linker::get_import_func_index(main_module->get_module_image().get_imports(),
                            src_library.get_library_name(), src_func.get_func_name(),
                            dst_lib_idx, dst_func_idx)) {

                            main_module->get_module_image().get_relocations().add_entry(
                                entry.relative_virtual_address + module->get_module_position().get_address_offset(),
                                SET_RELOCATION_ID_IAT(dst_lib_idx, dst_func_idx)
                            );

                            break;
                        }
                    }
                    else {
                        if (shibari_import_linker::get_import_func_index(main_module->get_module_image().get_imports(),
                            src_library.get_library_name(), src_func.get_ordinal(),
                            dst_lib_idx, dst_func_idx)) {

                            main_module->get_module_image().get_relocations().add_entry(
                                entry.relative_virtual_address + module->get_module_position().get_address_offset(),
                                SET_RELOCATION_ID_IAT(dst_lib_idx, dst_func_idx)
                            );

                            break;
                        }
                    }
                }

                return shibari_linker_errors::shibari_linker_error_relocation_linking;
            }
            }
        }
    }

    return shibari_linker_errors::shibari_linker_ok;
}

bool shibari_relocations_linker::process_relocations(shibari_module& target_module) {

    auto& image_full = target_module.get_module_image();

    image_full.get_relocations().sort();
    std::vector<pe_relocation_entry>& entries = image_full.get_relocations().get_entries();

    pe_section * entry_section = 0;
    for (size_t entry_idx = 0, entry_rva_low = 0, entry_rva_high = 0; entry_idx < image_full.get_relocations().size(); entry_idx++) {

        if (!entry_rva_low || !entry_section ||
            entries[entry_idx].relative_virtual_address < entry_rva_low ||
            entries[entry_idx].relative_virtual_address >= entry_rva_high
            ) {

            entry_section = image_full.get_image().get_section_by_rva(entries[entry_idx].relative_virtual_address);
            if (!entry_section) { return false; }

            entry_rva_low = entry_section->get_virtual_address();
            entry_rva_high = ALIGN_UP(entry_section->get_virtual_address() + entry_section->get_virtual_size(), 0x1000);
        }


        if (image_full.get_image().is_x32_image()) {
            entries[entry_idx].data = image_full.get_image().va_to_rva(*(uint32_t*)&entry_section->get_section_data().data()[
                entries[entry_idx].relative_virtual_address - entry_section->get_virtual_address()
            ]);
        }
        else {
            entries[entry_idx].data = image_full.get_image().va_to_rva(*(uint64_t*)&entry_section->get_section_data().data()[
                entries[entry_idx].relative_virtual_address - entry_section->get_virtual_address()
            ]);
        }
    }

    for (auto& entry : image_full.get_relocations().get_entries()) {

        uint32_t relocation_dst_rva = (uint32_t)entry.data;


        for (unsigned int lib_idx = 0; lib_idx < image_full.get_imports().get_libraries().size(); lib_idx++) {//find rva in imports

            if (image_full.get_image().is_x32_image()) {
                if (relocation_dst_rva >= image_full.get_imports().get_libraries()[lib_idx].get_rva_iat() &&
                    relocation_dst_rva < image_full.get_imports().get_libraries()[lib_idx].get_entries().size() * sizeof(uint32_t) + image_full.get_imports().get_libraries()[lib_idx].get_rva_iat()) {

                    entry.relocation_id = SET_RELOCATION_ID_IAT(lib_idx,
                        ((relocation_dst_rva - image_full.get_imports().get_libraries()[lib_idx].get_rva_iat()) / sizeof(uint32_t)));

                    goto go_next_entry_;
                }
            }
            else {
                if (relocation_dst_rva >= image_full.get_imports().get_libraries()[lib_idx].get_rva_iat() &&
                    relocation_dst_rva < image_full.get_imports().get_libraries()[lib_idx].get_entries().size() * sizeof(uint64_t) + image_full.get_imports().get_libraries()[lib_idx].get_rva_iat()) {

                    entry.relocation_id = SET_RELOCATION_ID_IAT(lib_idx,
                        ((relocation_dst_rva - image_full.get_imports().get_libraries()[lib_idx].get_rva_iat()) / sizeof(uint64_t)));

                    goto go_next_entry_;
                }
            }

        }


        entry.relocation_id = relocation_index_default;

    go_next_entry_:;
    }


    return true;
}
```

`shibari/shibari_relocations_linker.h`:

```h
#pragma once
class shibari_relocations_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_relocations_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_relocations_linker();
    
public:
    shibari_linker_errors link_modules();

public:
    static bool process_relocations(shibari_module& target_module);

};


```

`shibari/shibari_tls_linker.cpp`:

```cpp
#include "stdafx.h"
#include "shibari_tls_linker.h"


shibari_tls_linker::shibari_tls_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module)
    : extended_modules(extended_modules), main_module(main_module) {}


shibari_tls_linker::~shibari_tls_linker()
{
}


shibari_linker_errors shibari_tls_linker::link_modules() {

    for (auto& module : *extended_modules) {

        if (module->get_module_image().get_tls().get_callbacks().size()) {

            for (auto& item : module->get_module_image().get_tls().get_callbacks()) {
                main_module->get_module_image().get_tls().get_callbacks().push_back({
                    module->get_module_position().get_address_offset() + item.rva_callback ,item.use_relocation
                    });
            }
        }
    }

    return shibari_linker_errors::shibari_linker_ok;
}
```

`shibari/shibari_tls_linker.h`:

```h
#pragma once
class shibari_tls_linker {
    std::vector<shibari_module*>* extended_modules;
    shibari_module* main_module;
public:
    shibari_tls_linker(std::vector<shibari_module*>* extended_modules, shibari_module* main_module);
    ~shibari_tls_linker();

public:
    shibari_linker_errors link_modules();

};


```

`shibari/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`shibari/stdafx.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN       

#include <algorithm>
#include <cstdint>
#include <vector>
#include <list>
#include <math.h>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <sstream>
#include <stdarg.h> 
#include <iostream>
#include <iostream>

using namespace std;


#pragma comment(lib,"enma_pe.lib")
#include "enma_pe\enma_pe\enma_pe.h"
#include "shibari.h"
```

`shibari_console/shibari_console.cpp`:

```cpp

#include "stdafx.h"


int main(int argc, const char **argv){

    shibari shi;
    std::vector<shibari_module *> modules;
    std::string out_name = "shibari_result.exe";
 
    if (argc < 2) {
        printf("need more parameters !\n");
        system("PAUSE");
        return 0;
    }
    
    for (int arg_idx = 1; arg_idx < argc; arg_idx++) {

        //module=
        if (strlen(argv[arg_idx]) > 7 && !strncmp(argv[arg_idx],"module=",7)) {
            pe_image image = pe_image(std::string(argv[arg_idx]+7));
            if (image.get_image_status() == pe_image_status::pe_image_status_ok) {
                modules.push_back(new shibari_module(image));
                continue;
            }
            printf("[%s] image error!\n", std::string(argv[arg_idx] + 7).c_str());
            system("PAUSE");
            return 0;
        }
        //extname=
        if (strlen(argv[arg_idx]) > 8 && !strncmp(argv[arg_idx], "extname=", 8)) {
            if (modules.size()) {
                modules[modules.size() - 1]->get_module_exports().add_name(std::string(argv[arg_idx] + 8));
                continue;
            }
            printf("[%s] extname error!\n", std::string(argv[arg_idx] + 8).c_str());
            system("PAUSE");
            return 0;
        }
        //outname=
        if (strlen(argv[arg_idx]) > 8 && !strncmp(argv[arg_idx], "outname=", 8)) {
            out_name = std::string(argv[arg_idx] + 8);
        }
    }
    

    
    shi.set_main_module(modules[0]);
    for (unsigned int module_idx = 1; module_idx < modules.size(); module_idx++) {
        shi.add_extended_module(modules[module_idx]);
    }

    std::vector<uint8_t> out_exe;

    unsigned int exec_start_time = clock();
    switch (shi.exec_shibari(PE_IMAGE_BUILD_ALL_EXTENDED_SECTIONS, out_exe)) {

    case shibari_linker_ok: {
        printf("finished in %f\n",(clock() - exec_start_time)/1000.f);
        printf("result code: shibari_linker_ok\n");

        FILE* hTargetFile;
        fopen_s(&hTargetFile,out_name.c_str(), "wb");

        if (hTargetFile) {
            fwrite(out_exe.data(), out_exe.size(), 1, hTargetFile);
            fclose(hTargetFile);
        }
        break;
    }
    case shibari_linker_error_bad_input: {
        printf("result code: shibari_linker_error_bad_input\n");
        break;
    }
    case shibari_linker_error_export_linking: {
        printf("result code: shibari_linker_error_export_linking\n");
        break;
    }
    case shibari_linker_error_import_linking: {
        printf("result code: shibari_linker_error_import_linking\n");
        break;
    }
    case shibari_linker_error_loadconfig_linking: {
        printf("result code: shibari_linker_error_loadconfig_linking\n");
        break;
    }
    case shibari_linker_error_relocation_linking: {
        printf("result code: shibari_linker_error_relocation_linking\n");
        break;
    }
    case shibari_linker_error_exceptions_linking: {
        printf("result code: shibari_linker_error_exceptions_linking\n");
        break;
    }
    case shibari_linker_error_tls_linking: {
        printf("result code: shibari_linker_error_tls_linking\n");
        break;
    }

    default:
        break;
    }
    

    system("PAUSE");
    return 0;
}


```

`shibari_console/shibari_console.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{00D6C615-EA3A-4D90-A09C-24D743918EFF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>shibari_console</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="shibari_console.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shibari_console/shibari_console.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="shibari_console.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`shibari_console/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`shibari_console/stdafx.h`:

```h
#pragma once


#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>
#include <stdarg.h> 
#include <cstdint>

using namespace std;

#pragma comment(lib,"enma_pe.lib")
#pragma comment(lib,"shibari.lib")
#include "enma_pe\enma_pe\enma_pe.h"
#include "..\shibari\shibari.h"
```