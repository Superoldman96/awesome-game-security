Project Path: arc_gmh5225_Stresser_aikjjg9w

Source Tree:

```txt
arc_gmh5225_Stresser_aikjjg9w
├── FakeProcess
│   ├── FakeProcess.vcxproj
│   ├── FakeProcess.vcxproj.filters
│   └── main.cpp
├── LICENSE
├── Props
│   └── Stresser.General.props
├── README.md
├── SimpleMainTester
│   ├── Main.cpp
│   ├── SimpleMainTester.vcxproj
│   ├── SimpleMainTester.vcxproj.filters
│   ├── StresserEngine.cpp
│   └── StresserEngine.h
├── Stresser
│   ├── ArtifactFactory.cpp
│   ├── ArtifactFactory.h
│   ├── ArtifactManager.cpp
│   ├── ArtifactManager.h
│   ├── ArtifactTypes.h
│   ├── AuthorizedHttpRequest.cpp
│   ├── AuthorizedHttpRequest.h
│   ├── AutoEtwTraceSession.cpp
│   ├── AutoEtwTraceSession.h
│   ├── AutoSetLostConnectionEvent.cpp
│   ├── AutoSetLostConnectionEvent.h
│   ├── CollectorManager.cpp
│   ├── CollectorManager.h
│   ├── Controllers.h
│   ├── EndpointController.cpp
│   ├── EndpointController.h
│   ├── EndpointEntity.cpp
│   ├── EndpointEntity.h
│   ├── Entities.h
│   ├── EtwEventTypes.h
│   ├── EtwManager.cpp
│   ├── EtwManager.h
│   ├── EtwUtils.cpp
│   ├── EtwUtils.h
│   ├── EventController.cpp
│   ├── EventController.h
│   ├── EventEntity.cpp
│   ├── EventEntity.h
│   ├── EventParser.cpp
│   ├── EventParser.h
│   ├── EventProvidersGuid.h
│   ├── FileArtifact.cpp
│   ├── FileArtifact.h
│   ├── FileEventHandler.cpp
│   ├── FileEventHandler.h
│   ├── HttpRequest.cpp
│   ├── HttpRequest.h
│   ├── IArtifact.cpp
│   ├── IArtifact.h
│   ├── IArtifactSubscriber.cpp
│   ├── IArtifactSubscriber.h
│   ├── IEtwEventHandler.cpp
│   ├── IEtwEventHandler.h
│   ├── IEventCollector.h
│   ├── IPolicySubscriber.h
│   ├── IStresserApplication.h
│   ├── IStresserDetector.cpp
│   ├── IStresserDetector.h
│   ├── InvalidResponseException.cpp
│   ├── InvalidResponseException.h
│   ├── KernelDetector.cpp
│   ├── KernelDetector.h
│   ├── NetworkConnectionException.cpp
│   ├── NetworkConnectionException.h
│   ├── ParsingJsonException.cpp
│   ├── ParsingJsonException.h
│   ├── PolicyController.cpp
│   ├── PolicyController.h
│   ├── PolicyEntity.cpp
│   ├── PolicyEntity.h
│   ├── PolicyNotifications.cpp
│   ├── PolicyNotifications.h
│   ├── ProcessArtifact.cpp
│   ├── ProcessArtifact.h
│   ├── ProcessDetector.cpp
│   ├── ProcessDetector.h
│   ├── RegistryArtifact.cpp
│   ├── RegistryArtifact.h
│   ├── RegistryEventHandler.cpp
│   ├── RegistryEventHandler.h
│   ├── RuleController.cpp
│   ├── RuleController.h
│   ├── RuleEntity.cpp
│   ├── RuleEntity.h
│   ├── ServerDetails.cpp
│   ├── ServerDetails.h
│   ├── Stresser.rc
│   ├── Stresser.vcxproj
│   ├── Stresser.vcxproj.filters
│   ├── StresserApplication.cpp
│   ├── StresserApplication.h
│   ├── UserModeDetector.cpp
│   ├── UserModeDetector.h
│   ├── main.cpp
│   ├── packages.config
│   └── resource.h
├── Stresser.sln
├── StresserEngine
│   ├── AutoBuffer.h
│   ├── AutoLock.h
│   ├── AutoObjectDereference.h
│   ├── DriverConfiguration.h
│   ├── Event.cpp
│   ├── Event.h
│   ├── FastMutex.cpp
│   ├── FastMutex.h
│   ├── GenericHandle.h
│   ├── HelperMacros.h
│   ├── IrpUtils.cpp
│   ├── IrpUtils.h
│   ├── LinkedList.h
│   ├── Memory.cpp
│   ├── Memory.h
│   ├── Move.h
│   ├── ObjectNotification.cpp
│   ├── ObjectNotification.h
│   ├── ProcessUtils.cpp
│   ├── ProcessUtils.h
│   ├── StresserEngine.cpp
│   ├── StresserEngine.h
│   ├── StresserEngine.inf
│   ├── StresserEngine.vcxproj
│   ├── StresserEngine.vcxproj.filters
│   ├── StresserEngineCommon.h
│   ├── String.h
│   ├── Value.h
│   └── Vector.h
└── Utils
    ├── AutoCriticalSection.cpp
    ├── AutoCriticalSection.h
    ├── AutoHandle.cpp
    ├── AutoHandle.h
    ├── AutoRegistryKeyHandle.cpp
    ├── AutoRegistryKeyHandle.h
    ├── AutoServiceHandle.cpp
    ├── AutoServiceHandle.h
    ├── AutoSignedImageVerifier.cpp
    ├── AutoSignedImageVerifier.h
    ├── CriticalSection.cpp
    ├── CriticalSection.h
    ├── DebugPrint.h
    ├── EventsNames.h
    ├── LocalPcUtils.cpp
    ├── LocalPcUtils.h
    ├── PeResource.cpp
    ├── PeResource.h
    ├── RegistryArtifactUtils.cpp
    ├── RegistryArtifactUtils.h
    ├── SehException.cpp
    ├── SehException.h
    ├── SehTranslatorGuard.cpp
    ├── SehTranslatorGuard.h
    ├── Service.cpp
    ├── Service.h
    ├── ServiceManager.cpp
    ├── ServiceManager.h
    ├── ShutdownSignal.cpp
    ├── ShutdownSignal.h
    ├── StandardThread.cpp
    ├── StandardThread.h
    ├── StringUtils.cpp
    ├── StringUtils.h
    ├── TimeUtils.cpp
    ├── TimeUtils.h
    ├── Utils.vcxproj
    ├── Utils.vcxproj.filters
    ├── Win32ErrorCodeException.cpp
    ├── Win32ErrorCodeException.h
    ├── WindowsEvent.cpp
    ├── WindowsEvent.h
    ├── packages.config
    ├── pch.cpp
    └── pch.h

```

`FakeProcess/FakeProcess.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{74059d08-48af-42dc-b2d2-8f8fbb939927}</ProjectGuid>
    <RootNamespace>FakeProcess</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Utils\Utils.vcxproj">
      <Project>{bb0147eb-6672-4d50-b5bb-9ebeff8d5ed7}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FakeProcess/FakeProcess.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FakeProcess/main.cpp`:

```cpp
#include "../Utils/AutoHandle.h"
#include "../Utils/EventsNames.h"
#include "../Utils/SehTranslatorGuard.h"

INT WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PSTR lpCmdLine, INT nCmdShow)
{
	try
	{
		SehTranslatorGuard sehTranslatorGuard;
		
		AutoHandle events[2]{
			AutoHandle(OpenEvent(SYNCHRONIZE, FALSE, CHANGE_POLICY)),
			AutoHandle(OpenEvent(SYNCHRONIZE, FALSE, STOP_STRESSER))
		};

		HANDLE hEvents[]{ events[0].get(), events[1].get() };

		WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
	}
	catch (...)
	{
	}

    return 0;
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Aviv Shabtay

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Props/Stresser.General.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>Async</ExceptionHandling>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN_DEBUG;_CONSOLE;_WIN32_WINNT=0x0A00;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkIncremental>true</LinkIncremental>
      <!-- Needs to move to Release version -->
      <LinkIncremental>false</LinkIncremental>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>FAKE_PROCESS_RELATIVE_PATH=$(OutDir)FakeProcess.exe;KERNEL_DRIVER_RELATIVE_PATH=$(OutDir)StresserEngine.sys;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup />
</Project>
```

`README.md`:

```md
# Stresser

<p align="left">
    <img src="https://img.shields.io/badge/language-Node.js-yellow.svg">
    <img src="https://img.shields.io/badge/language-React.js-yellow.svg">
    <img src="https://img.shields.io/badge/language-C++-yellow.svg">
    <img src="https://img.shields.io/badge/license-MIT-blue.svg">
</p>

## Team

[Aviv Shabtay](https://github.com/AvivShabtay) |
[Elior Shriki](https://github.com/EliorShriki) |
[Or Pinhas](https://github.com/orpinhas20)

---

## Background

Stresser is a complete Endpoint Security Solution contains Central management and Agents using unique method to protect against sophisticated Malwares.

---

## Main features

- Anti-Malware protections - exploiting malware's Anti-Technics (Anti-Detection, Anti-VM, Anti-Sandbox, etc) in order to supply protection.
- Centralized Management - provides greater visibility, manage operations, unifies security with a simple UI.
- Dynamic & Static operation - support both capabilities, giving the user control of the overload on the system.
- Simple to deploy and maintains - ready-to-use suite for Windows environment.

---

## Main components

- Server - interface for clients (Web management, Agents), interface to data, manage tasks and operation of the agent.
- Web management - UI for the users, provide easy interface to configure policy, manage rules, check events and control the entire solution.
- Agent - background service, contains user-mode client and kernel-mode engine, enforce the policy and provides protection on the endpoint.

---

## Useful links

- Microsoft example for demonstrating the difference between various types of IO communication: https://github.com/microsoft/Windows-driver-samples/tree/master/general/ioctl/wdm
- OSR example of using kernel notifications (Object notification and more) can be found here: https://github.com/OSRDrivers/kmexts
- Microsoft example for demonstrating usage of Object callback: https://github.com/microsoft/Windows-driver-samples/tree/master/general/obcallback
- Microsoft example for shared event between UM application and KM driver: https://github.com/microsoft/Windows-driver-samples/tree/master/general/event

---

## Common issues
### "Inf2Cat, signability test failed." Error: 22.9.7 "DriverVer set to a date in the future"
- Possible solution is to set the `Run Inf2Cat` option (under project Properties -> Inf2Cat) to turn `Off`.
- Another solution is to set the `Use Local Time` option (under project Properties -> Inf2Cat) to `Yes`
- More information about this issues can be found here: https://stackoverflow.com/a/17005092

### `SYSTEM_THREAD_EXCEPTION_NOT_HANDLED` when calling `ObRegisterCallbacks`
- Caused by the lake of `/integritycheck` flags in driver project.
- Under project Properties -> Linker -> Command Line -> add the following flag: `/integritycheck`.
- More information about this issues can be found here: https://community.osr.com/discussion/189136/about-obregistercallbacks

### error C2371: `'PEPROCESS'` : redefinition; different basic types
- This caused by conflicts between two included headers: `ntddk.h` and `ntifs.h`.
- The solution is to only include `ntifs.h`.
- More information about this issue can be found here: https://community.osr.com/discussion/170511

### Convert resource path to relative path
- Use pre-processor symbols and create kind of "compile time-constant"
- Under your property settings to go: Resource -> General -> Preprocessor Definitions -> Edit
- Add your compile time symbol and use VS macros to get relative path, for example: `SOLUTION=$(SolutionDir)`
- Right click on your `.rc` file and choose `view code`
- Use the symbol instead of using relative paths
- For more info check my `props` folder -> `.props` file and `.rc` file

---
```

`SimpleMainTester/Main.cpp`:

```cpp
#include "StresserEngine.h"

#include "../Utils/AutoHandle.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/SehTranslatorGuard.h"
#include "../Utils/Win32ErrorCodeException.h"
#include "../Utils/StringUtils.h"
#include "../Utils/TimeUtils.h"

#include <exception>
#include <iostream>
#include <sstream>
#include  <iomanip>

#include <conio.h>
#include <stdio.h>

#include <Windows.h>

const std::wstring EVENT_NAME(L"OnFakeProcess");
const std::wstring UM_GLOBAL_FAKE_PROCESS_EVENT(L"Global\\" + EVENT_NAME);
const std::wstring KM_FAKE_PROCESS_EVENT(L"\\BaseNamedObjects\\" + EVENT_NAME);
const ULONG FAKE_PROCESS_ID_FOR_TESTING = 15;
const std::wstring TIME_FORMAT(L"%d/%m/%Y - %H:%M:%S");
constexpr int NUMBER_OF_EVENTS_TO_CONSUME = 10;

void printUsage();
std::string convertSystemTimeToString(const LARGE_INTEGER& time);
void addFakeProcessId(ULONG processId);
void removeFakeProcessId(ULONG processId);
void registerNotificationEventAndWait();
void unregisterNotificationEvent();
void consumeEvents();
void printEvents(const EventsResult& eventsResult);

int main(int argc, PWCHAR argv[])
{

	SehTranslatorGuard sehTranslatorGuard;

	if (argc < 2)
	{
		printUsage();
		return -1;
	}

	try
	{
		const int choice = _wtoi(argv[1]);

		switch (choice)
		{
		case 1:
		{
			// Add fake process ID
			if (argc < 3)
			{
				printUsage();
				return -1;
			}

			const ULONG processId = atoi(reinterpret_cast<PCHAR>(argv[2]));
			std::cout << "Process ID: " << processId << std::endl;

			addFakeProcessId(processId);
			break;
		}
		case 2:
		{
			// Remove fake process ID
			if (argc < 3)
			{
				printUsage();
				return -1;
			}

			const ULONG processId = atoi(reinterpret_cast<PCHAR>(argv[2]));
			std::cout << "Process ID: " << processId << std::endl;

			removeFakeProcessId(processId);
			break;
		}
		case 3:
		{
			// Register notification event

			registerNotificationEventAndWait();
			break;
		}
		case 4:
		{
			// Unregister notification event

			unregisterNotificationEvent();
			break;
		}
		case 5:
		{
			// Get collected events

			consumeEvents();
			break;
		}
		default:
		{
			throw std::runtime_error("Invalid user choice");
		}
		}
	}
	catch (std::exception& exception)
	{
		DEBUG_PRINT(exception.what());
		return -1;
	}

	return 0;
}

void printUsage()
{
	std::cout << "Usage: SimpleMainTester.exe < 1 | 2 | 3 > [parameters]" << std::endl;
	std::cout << "\t1 [pid] - add fake process ID" << std::endl;
	std::cout << "\t2 [pid] - remove fake process ID" << std::endl;
	std::cout << "\t3 - register notification event and wait for signal" << std::endl;
	std::cout << "\t4 - unregister any existing notification event" << std::endl;
	std::cout << "\t5 - consume events" << std::endl;
}

void addFakeProcessId(ULONG processId)
{
	const StresserEngine kernelDetector;
	kernelDetector.addFakeProcessId(processId);

	std::cout << "Add fake process ID: " << FAKE_PROCESS_ID_FOR_TESTING << std::endl;
}

void removeFakeProcessId(ULONG processId)
{
	const StresserEngine kernelDetector;
	kernelDetector.removeFakeProcessId(processId);

	std::cout << "Remove fake process ID: " << FAKE_PROCESS_ID_FOR_TESTING << std::endl;
}

void registerNotificationEventAndWait()
{
	const AutoHandle objectNotificationEvent(CreateEvent(
		nullptr,							// lpEventAttributes
		FALSE,								// auto-reset event
		FALSE,								// non-signaled event
		UM_GLOBAL_FAKE_PROCESS_EVENT.c_str()// event name
	));
	if (!objectNotificationEvent.get())
	{
		throw Win32ErrorCodeException("Could not create global event");
	}

	std::cout << "Event handle: " << std::hex << objectNotificationEvent.get() << std::endl;

	const StresserEngine kernelDetector;

	// Close any existing event:
	kernelDetector.unregisterEvent();

	// Register new event:
	kernelDetector.registerEvent(KM_FAKE_PROCESS_EVENT);

	if (WAIT_OBJECT_0 != WaitForSingleObject(objectNotificationEvent.get(), INFINITE))
	{
		throw Win32ErrorCodeException("Wait for signal from Driver failed");
	}

	// Consume and print events:
	const EventsResult eventsResult = kernelDetector.receiveEvents(NUMBER_OF_EVENTS_TO_CONSUME);
	printEvents(eventsResult);

	// Close the newly shared event:
	kernelDetector.unregisterEvent();
}

void unregisterNotificationEvent()
{
	const StresserEngine kernelDetector;

	// Close any existing event:
	kernelDetector.unregisterEvent();
}

void consumeEvents()
{
	const StresserEngine kernelDetector;

	const EventsResult eventsResult = kernelDetector.receiveEvents(NUMBER_OF_EVENTS_TO_CONSUME);

	printEvents(eventsResult);
}

void printEvents(const EventsResult& eventsResult)
{
	if (0 == eventsResult.size)
	{
		std::cout << "There are no available events" << std::endl;
		return;
	}

	if (nullptr == eventsResult.events)
	{
		throw std::runtime_error("Invalid events buffer");
	}

	for (int i = 0; i < eventsResult.size; ++i)
	{
		const auto& eventInfo = eventsResult.events.get()[i];

		std::wcout
			<< "~~~~Event~~~~\n"
			<< "Called PID=" << eventInfo.processId << "\n"
			<< "Called Filename: " << eventInfo.processName << "\n"
			<< "Fake process ID=" << eventInfo.fakeProcessId << "\n"
			<< "Event time: " << TimeUtils::systemTimeToTimestamp(eventInfo.time, TIME_FORMAT) << "\n"
			<< std::endl;
	}
}

std::string convertSystemTimeToString(const LARGE_INTEGER& time)
{
	//SYSTEMTIME systemTime;
	//FileTimeToSystemTime((FILETIME*)&time, &systemTime);

	FILETIME localTime{ 0 };
	FileTimeToLocalFileTime((FILETIME*)&time, &localTime);

	SYSTEMTIME systemTime;
	FileTimeToSystemTime(&localTime, &systemTime);

	std::stringstream timeStream;
	timeStream << std::setfill('0') << std::setw(2) << systemTime.wDay;
	timeStream << "/";
	timeStream << std::setfill('0') << std::setw(2) << systemTime.wMonth;
	timeStream << "/";
	timeStream << std::setfill('0') << std::setw(4) << systemTime.wYear;
	timeStream << "-";
	timeStream << std::setfill('0') << std::setw(2) << systemTime.wHour;
	timeStream << ":";
	timeStream << std::setfill('0') << std::setw(2) << systemTime.wMinute;
	timeStream << ":";
	timeStream << std::setfill('0') << std::setw(2) << systemTime.wSecond;
	timeStream << ".";
	timeStream << std::setfill('0') << std::setw(3) << systemTime.wMilliseconds;

	std::string timeString(timeStream.str());
	return timeString;
}
```

`SimpleMainTester/SimpleMainTester.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2ded3aea-aca3-4123-8704-6d17d375d1e3}</ProjectGuid>
    <RootNamespace>SimpleMainTester</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeaderFile />
      <ExceptionHandling>Async</ExceptionHandling>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="StresserEngine.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Utils\Utils.vcxproj">
      <Project>{bb0147eb-6672-4d50-b5bb-9ebeff8d5ed7}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StresserEngine.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SimpleMainTester/SimpleMainTester.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StresserEngine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StresserEngine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`SimpleMainTester/StresserEngine.cpp`:

```cpp
#include "StresserEngine.h"

#include "../Utils/Win32ErrorCodeException.h"

#include "../StresserEngine/StresserEngineCommon.h"

StresserEngine::StresserEngine()
{
	this->stresserDevice.reset(CreateFile(DEVICE_NAME.c_str(), GENERIC_READ | GENERIC_WRITE, 0,
		nullptr, OPEN_EXISTING, 0, nullptr));

	if (INVALID_HANDLE_VALUE == this->stresserDevice.get())
	{
		throw Win32ErrorCodeException("Could not get Stresser engine device");
	}
}

void StresserEngine::addFakeProcessId(ULONG processId) const
{
	FakeProcessId fakeProcessId{ processId };

	DWORD returnedBytes;
	if (!DeviceIoControl(this->stresserDevice.get(), IOCTL_STRESSER_ENGINE_ADD_FAKE_PID, &fakeProcessId,
		FAKE_PROCESS_ID_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

void StresserEngine::removeFakeProcessId(ULONG processId) const
{
	FakeProcessId fakeProcessId{ processId };

	DWORD returnedBytes;
	if (!DeviceIoControl(this->stresserDevice.get(), IOCTL_STRESSER_ENGINE_REMOVE_FAKE_PID, &fakeProcessId,
		FAKE_PROCESS_ID_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

void StresserEngine::registerEvent(std::wstring eventName) const
{
	if (MAX_EVENT_NAME_LENGTH < eventName.length())
	{
		throw std::runtime_error("Invalid length of event name");
	}

	if (eventName.empty())
	{
		throw std::runtime_error("Invalid event name");
	}

	RegisterEvent registerEvent{ 0 };

	// Make sure for null-terminator:
	memset(registerEvent.eventName, 0, sizeof(WCHAR) * MAX_EVENT_NAME_LENGTH);

	wcscpy_s(registerEvent.eventName, MAX_EVENT_NAME_LENGTH, eventName.c_str());

	DWORD returnedBytes;
	if (!DeviceIoControl(this->stresserDevice.get(), IOCTL_STRESSER_ENGINE_REGISTER_EVENT, &registerEvent,
		REGISTER_EVENT_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

EventsResult StresserEngine::receiveEvents(ULONG numberOfEvents) const
{
	if (numberOfEvents < 1)
	{
		throw std::runtime_error("Invalid number of events to receive");
	}

	auto eventsBuffer = std::make_unique<EventInfo[]>(numberOfEvents);
	if (nullptr == eventsBuffer)
	{
		throw std::runtime_error("Could not allocate memory for events buffer");
	}

	// Zero all the memory:
	memset(eventsBuffer.get(), 0, EVENT_INFO_SIZE * numberOfEvents);

	// Prepare the request:
	EventsHeader eventsHeader
	{
		numberOfEvents,
		eventsBuffer.get()
	};

	DWORD returnedBytes;
	if (!DeviceIoControl(this->stresserDevice.get(), IOCTL_STRESSER_ENGINE_GET_EVENTS, nullptr, 0, &eventsHeader,
		EVENTS_HEADER_SIZE, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}

	// There are no available events:
	if (0 == returnedBytes)
	{
		return EventsResult{ 0, nullptr };
	}

	const int size = returnedBytes / EVENT_INFO_SIZE;

	EventsResult result
	{
		size,
		std::move(eventsBuffer)
	};

	return result;
}

void StresserEngine::unregisterEvent() const
{
	DWORD returnedBytes;
	if (!DeviceIoControl(this->stresserDevice.get(), IOCTL_STRESSER_ENGINE_UNREGISTER_EVENT, nullptr,
		0, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

```

`SimpleMainTester/StresserEngine.h`:

```h
#pragma once

#include "../Utils/AutoHandle.h"
#include "../StresserEngine/StresserEngineCommon.h"

#include <Windows.h>

const std::wstring DEVICE_NAME = L"\\\\.\\StresserEngine";

/*
	Result of calling for getting events from Driver.
 */
struct EventsResult
{
	int size;								// Number of received events
	std::unique_ptr < EventInfo[]> events;	// Buffer with the received events
};

/*
	Interface for communication with Stresser Driver through I\O calls.
 */
class StresserEngine
{
public:
	StresserEngine();

	virtual ~StresserEngine() = default;

	// Delete copyable, movable:
	StresserEngine(const StresserEngine&) = delete;
	StresserEngine& operator=(const StresserEngine&) = delete;
	StresserEngine(StresserEngine&&) = delete;
	StresserEngine& operator=(StresserEngine&&) = delete;

	/* Add process ID to be monitored. */
	void addFakeProcessId(ULONG processId) const;

	/* Remove process ID from being monitored. */
	void removeFakeProcessId(ULONG processId) const;

	/*
		Register shared event with the Driver for synchronization when
		there are available events to consume.
	*/
	void registerEvent(std::wstring eventName) const;

	/* Fetch the events from the Driver. */
	EventsResult receiveEvents(ULONG numberOfEvents = 10) const;

	void unregisterEvent() const;

private:
	AutoHandle stresserDevice;
};


```

`Stresser.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StresserEngine", "StresserEngine\StresserEngine.vcxproj", "{92E95C51-6BD3-44AA-BADF-531C6F488C16}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SimpleMainTester", "SimpleMainTester\SimpleMainTester.vcxproj", "{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Utils", "Utils\Utils.vcxproj", "{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Stresser", "Stresser\Stresser.vcxproj", "{42CDE09C-C687-46B9-A708-B68B2B8F87DD}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FakeProcess", "FakeProcess\FakeProcess.vcxproj", "{74059D08-48AF-42DC-B2D2-8F8FBB939927}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM.ActiveCfg = Debug|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM.Build.0 = Debug|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM.Deploy.0 = Debug|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM64.Build.0 = Debug|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x64.ActiveCfg = Debug|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x64.Build.0 = Debug|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x64.Deploy.0 = Debug|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x86.ActiveCfg = Debug|Win32
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x86.Build.0 = Debug|Win32
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Debug|x86.Deploy.0 = Debug|Win32
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM.ActiveCfg = Release|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM.Build.0 = Release|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM.Deploy.0 = Release|ARM
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM64.ActiveCfg = Release|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM64.Build.0 = Release|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|ARM64.Deploy.0 = Release|ARM64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x64.ActiveCfg = Release|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x64.Build.0 = Release|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x64.Deploy.0 = Release|x64
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x86.ActiveCfg = Release|Win32
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x86.Build.0 = Release|Win32
		{92E95C51-6BD3-44AA-BADF-531C6F488C16}.Release|x86.Deploy.0 = Release|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|ARM.ActiveCfg = Debug|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|ARM64.ActiveCfg = Debug|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|x64.ActiveCfg = Debug|x64
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|x64.Build.0 = Debug|x64
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|x86.ActiveCfg = Debug|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Debug|x86.Build.0 = Debug|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|ARM.ActiveCfg = Release|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|ARM64.ActiveCfg = Release|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|x64.ActiveCfg = Release|x64
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|x64.Build.0 = Release|x64
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|x86.ActiveCfg = Release|Win32
		{2DED3AEA-ACA3-4123-8704-6D17D375D1E3}.Release|x86.Build.0 = Release|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|ARM.ActiveCfg = Debug|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|ARM64.ActiveCfg = Debug|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|x64.ActiveCfg = Debug|x64
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|x64.Build.0 = Debug|x64
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|x86.ActiveCfg = Debug|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Debug|x86.Build.0 = Debug|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|ARM.ActiveCfg = Release|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|ARM64.ActiveCfg = Release|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|x64.ActiveCfg = Release|x64
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|x64.Build.0 = Release|x64
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|x86.ActiveCfg = Release|Win32
		{BB0147EB-6672-4D50-B5BB-9EBEFF8D5ED7}.Release|x86.Build.0 = Release|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|ARM.ActiveCfg = Debug|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|ARM64.ActiveCfg = Debug|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|x64.ActiveCfg = Debug|x64
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|x64.Build.0 = Debug|x64
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|x86.ActiveCfg = Debug|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Debug|x86.Build.0 = Debug|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|ARM.ActiveCfg = Release|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|ARM64.ActiveCfg = Release|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|x64.ActiveCfg = Release|x64
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|x64.Build.0 = Release|x64
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|x86.ActiveCfg = Release|Win32
		{42CDE09C-C687-46B9-A708-B68B2B8F87DD}.Release|x86.Build.0 = Release|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|ARM.ActiveCfg = Debug|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|ARM64.ActiveCfg = Debug|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|x64.ActiveCfg = Debug|x64
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|x64.Build.0 = Debug|x64
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|x86.ActiveCfg = Debug|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Debug|x86.Build.0 = Debug|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|ARM.ActiveCfg = Release|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|ARM64.ActiveCfg = Release|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|x64.ActiveCfg = Release|x64
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|x64.Build.0 = Release|x64
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|x86.ActiveCfg = Release|Win32
		{74059D08-48AF-42DC-B2D2-8F8FBB939927}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {41473161-BF27-4B41-90E6-B794DC38D5D4}
	EndGlobalSection
EndGlobal

```

`Stresser/ArtifactFactory.cpp`:

```cpp
#include "ArtifactFactory.h"
#include "ArtifactTypes.h"

std::unique_ptr<IArtifact> ArtifactFactory::BuildArtifact(const std::string& ruleType, const std::string& ruleName, const std::string& data)
{
	if (ruleType == ArtifactNames[static_cast<size_t>(ArtifactTypes::Registry)])
	{
		return std::make_unique<RegistryArtifact>(ruleName, data);
	}
	if (ruleType == ArtifactNames[static_cast<size_t>(ArtifactTypes::File)])
	{
		return std::make_unique<FileArtifact>(ruleName, data);
	}
	if (ruleType == ArtifactNames[static_cast<size_t>(ArtifactTypes::Process)])
	{
		return std::make_unique<ProcessArtifact>(ruleName, data);
	}

	throw std::runtime_error("Unknown rule type!");
}

```

`Stresser/ArtifactFactory.h`:

```h
#pragma once
#include "FileArtifact.h"
#include "ProcessArtifact.h"
#include "RegistryArtifact.h"

class ArtifactFactory
{
public:
	static std::unique_ptr<IArtifact> BuildArtifact(const std::string& ruleType, const std::string& ruleName, const std::string& data);
};

```

`Stresser/ArtifactManager.cpp`:

```cpp
#include "ArtifactManager.h"
#include "ArtifactFactory.h"
#include "../Utils/AutoCriticalSection.h"

void ArtifactManager::policyChanged(const std::vector<RuleEntity>& rules)
{
	DEBUG_WTRACE(ArtifactManager, "Receive policy update");
	{
		AutoCriticalSection autoCriticalSection;

		// Uninstall the old artifacts
		for (auto* subscriber : this->m_subscribers)
		{
			subscriber->reset();
		}

		this->m_artifactsVector.clear();
	}

	// Getting the new artifacts
	for (const RuleEntity& ruleEntity : rules)
	{
		std::shared_ptr<IArtifact> artifact = ArtifactFactory::BuildArtifact(ruleEntity.getType(),
			ruleEntity.getName(), ruleEntity.getData());

		this->m_artifactsVector.push_back(artifact);
	}

	// Update the subscribers artifacts
	for (auto* subscriber : this->m_subscribers)
	{
		subscriber->setNewArtifacts(this->m_artifactsVector);
	}
}

void ArtifactManager::subscribe(IArtifactSubscriber* subscriber)
{
	this->m_subscribers.push_back(subscriber);
}

```

`Stresser/ArtifactManager.h`:

```h
#pragma once
#include "IArtifact.h"
#include "IPolicySubscriber.h"
#include "IArtifactSubscriber.h"

#include <vector>


class ArtifactManager : public IPolicySubscriber
{
public:
	ArtifactManager() = default;

	~ArtifactManager() = default;

	void policyChanged(const std::vector<RuleEntity>& rules) override;

	void subscribe(IArtifactSubscriber* subscriber);

private:
	std::vector<std::shared_ptr<IArtifact>> m_artifactsVector;
	std::vector<IArtifactSubscriber*> m_subscribers;
};

```

`Stresser/ArtifactTypes.h`:

```h
#pragma once

inline const char* ArtifactNames[] = { "Registry", "File", "Process" };

enum class ArtifactTypes
{
	Registry,
	File,
	Process
};

```

`Stresser/AuthorizedHttpRequest.cpp`:

```cpp
#include "AuthorizedHttpRequest.h"
#include "NetworkConnectionException.h"
#include "AutoSetLostConnectionEvent.h"
#include "InvalidResponseException.h"
#include "ParsingJsonException.h"

#include "../Utils/AutoCriticalSection.h"
#include "../Utils/ShutdownSignal.h"
#include "../Utils/StringUtils.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/SehTranslatorGuard.h"
#include "../Utils/WindowsEvent.h"
#include "../Utils/EventsNames.h"

#include <Windows.h>

AuthorizedHttpRequest& AuthorizedHttpRequest::getInstance(ServerDetails server, HANDLE shutdownEvent)
{
	static AuthorizedHttpRequest g_tokenManager(server, shutdownEvent);
	return g_tokenManager;
}

AuthorizedHttpRequest::AuthorizedHttpRequest(ServerDetails server, HANDLE shutdownEvent)
	: m_server(server),
	m_shutdownEvent(shutdownEvent)
{
}

void AuthorizedHttpRequest::refreshToken()
{
	const std::string targetPath("/endpoint/" + m_endpointId);

	Json jsEndpointData;
	jsEndpointData["id"] = this->m_endpointId;
	jsEndpointData["apiKey"] = this->m_token;

	Json jsResponse = this->sendRequest(http::verb::put, targetPath, jsEndpointData);
	if (jsResponse.empty())
	{
		throw InvalidResponseException("Server return with no data");
	}

	const std::string newToken = StringUtils::RemoveQuotationMarks(jsResponse["apiKey"].dump());
	this->setToken(newToken);
}

void AuthorizedHttpRequest::setToken(const std::string& newToken)
{
	AutoCriticalSection autoCriticalSection;
	this->m_token = newToken;
}

bool AuthorizedHttpRequest::startTokenRefresherThread(const std::string& endpointId, const std::string& initialToken)
{
	this->m_endpointId = endpointId;
	this->m_token = initialToken;

	auto threadStartRoutine = [](auto params)
	{
		DEBUG_WTRACE(AuthorizedHttpRequest, "Start authorization thread");

		SehTranslatorGuard sehTranslatorGuard;

		auto* const tokenManager = reinterpret_cast<AuthorizedHttpRequest*>(params);

		WindowsEvent lostConnectionEvent;
		lostConnectionEvent.open(LOST_CONNECTION_EVENT_NAME);

		constexpr int TRIGGER_EVENT_COUNT = 2;
		HANDLE triggerEvents[TRIGGER_EVENT_COUNT] =
		{
			tokenManager->m_shutdownEvent,
			lostConnectionEvent.get()
		};

		constexpr DWORD TIMEOUT = 30 * 1000;

		while (WAIT_TIMEOUT == WaitForMultipleObjects(TRIGGER_EVENT_COUNT, triggerEvents, FALSE, TIMEOUT))
		{
			try
			{
				tokenManager->refreshToken();
			}
			catch (const InvalidResponseException&)
			{
				DEBUG_TRACE(AuthorizedHttpRequest, "Could not refresh token");
			}
		}

		DEBUG_WTRACE(AuthorizedHttpRequest, "Stop authorization thread");
		return static_cast<DWORD>(0);
	};

	this->m_ahTokenRefresherThread.reset(
		CreateThread(nullptr, 0, threadStartRoutine, this, 0, nullptr));

	if (INVALID_HANDLE_VALUE == this->m_ahTokenRefresherThread.get())
	{
		throw std::runtime_error("Could not create thread for refreshing tokens");
	}

	return true;
}

Json AuthorizedHttpRequest::sendRequest(const http::verb& requestMethod, const std::string& target, const Json& payload) const
{
	std::string path = this->m_server.getApiPrefix() + target;

	try
	{
		if (this->m_token.empty())
		{
			return HttpRequest::sendRequest(this->m_server.getUserAgent(), this->m_server.getHttpVersion(), this->m_server.getContentType(), "",
				requestMethod, this->m_server.getHostname(), path, this->m_server.getPort(), payload);
		}
		else
		{
			return HttpRequest::sendRequest(this->m_server.getUserAgent(), this->m_server.getHttpVersion(), this->m_server.getContentType(),
				this->m_token, requestMethod, this->m_server.getHostname(), path, this->m_server.getPort(), payload);
		}
	}
	catch (const NetworkConnectionException& exception)
	{
		DEBUG_TRACE(AuthorizedHttpRequest, "Lost network connection, signal global event");

		AutoSetLostConnectionEvent setLostConnectionEvent;
		return {}; // return empty JSON
	}
	catch (const ParsingJsonException&)
	{
		return {}; // return empty JSON
	}
}

```

`Stresser/AuthorizedHttpRequest.h`:

```h
#pragma once

#include "ServerDetails.h"
#include "HttpRequest.h"
#include "../Utils/AutoHandle.h"

#include "nlohmann/json.hpp"

#include <boost/beast/http.hpp>

#include <string>

using Json = nlohmann::json;

/*
 * Used to provide communication with the application server by managing unique token
 * representing authorized endpoint.
 */
class AuthorizedHttpRequest
{
public:
	/*
	 * Return instance of this class for the given server configuration.
	 * @param server - Current server configuration.
	 * @shutdownEvent - Handle to signal object representing the application to stop.
	 * @note - This class is NOT responsible to close the signale object.
	 */
	static AuthorizedHttpRequest& getInstance(ServerDetails server = ServerDetails(), HANDLE shutdownEvent = 0);

	/*
	 * Start sending request to the server to keep the endpoint token valid.
	 * @param endpointId - Unique ID of the endpoint that received from the server.
	 * @param initialToken - Token value that was received from the server before.
	 */
	bool startTokenRefresherThread(const std::string& endpointId, const std::string& initialToken);

	/*
	 * Simplified HTTP request that automatically inject the valid token value.
	 * @param requestMethod - Boost	type represent request type.
	 * @param target - Represent the URI path in the server.
	 * @param payload - The data to be send in the HTTP request.
	 */
	Json sendRequest(const http::verb& requestMethod, const std::string& target, const Json& payload) const;

private:
	/* Keep class as singleton. */
	AuthorizedHttpRequest(ServerDetails server, HANDLE shutdownEvent);

	/*
	 * Send HTTP request the expected arguments to the server for refreshing the
	 * endpoint token.
	 * @note Using Endpoint data such as ID.
	 */
	void refreshToken();

	/*
	 * Thread safe setter for token value.
	 * @param newToken - The new token value.
	 */
	void setToken(const std::string& newToken);

	ServerDetails m_server;
	std::string m_endpointId;
	std::string m_token;
	AutoHandle m_ahTokenRefresherThread;
	std::thread m_refreshTokenThread;
	HANDLE m_shutdownEvent;
};


```

`Stresser/AutoEtwTraceSession.cpp`:

```cpp
#include "AutoEtwTraceSession.h"

#include "../Utils/DebugPrint.h"
#include "../Utils/Win32ErrorCodeException.h"

#include <exception>
#include <iostream>

AutoEtwTraceSession::AutoEtwTraceSession()
	: m_traceSessionHandle{ 0 }, m_traceHandle{ 0 }, m_propertiesBuffer(nullptr), m_traceLogfile{ 0 }
{
}

AutoEtwTraceSession::AutoEtwTraceSession(EVENT_TRACE_PROPERTIES properties, EVENT_TRACE_LOGFILEW logfile, const std::wstring& sessionName)
	: m_traceSessionHandle{ 0 }, m_traceHandle{ 0 }, m_propertiesBuffer(nullptr), m_traceLogfile(logfile), m_sessionName(sessionName)
{
	this->setProperties(properties);
	this->m_traceLogfile = logfile;
	this->m_sessionName = sessionName;

	this->startTrace();
}

AutoEtwTraceSession::~AutoEtwTraceSession()
{
	try
	{
		this->stopTrace();
	}
	catch (const std::exception& exception)
	{
		DEBUG_PRINT(exception.what());
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in AutoTraceManager destructor");
	}
}

void AutoEtwTraceSession::reset(EVENT_TRACE_PROPERTIES properties, EVENT_TRACE_LOGFILEW logfile,
	const std::wstring& sessionName)
{
	this->stopTrace();

	this->setProperties(properties);
	this->m_traceLogfile = logfile;
	this->m_sessionName = sessionName;

	this->startTrace();
}

void AutoEtwTraceSession::release()
{
	this->stopTrace();
}

void AutoEtwTraceSession::startTrace()
{
	// Trace already running:
	if (0 != m_traceSessionHandle || 0 != m_traceHandle)
	{
		return;
	}

	auto* properties = reinterpret_cast<PEVENT_TRACE_PROPERTIES>(this->m_propertiesBuffer.get());

	// If exists stop the trace session with the same name
	EVENT_TRACE_PROPERTIES prop = { sizeof(EVENT_TRACE_PROPERTIES) };
	ULONG error = ControlTrace(NULL, this->m_sessionName.c_str(), &prop, EVENT_TRACE_CONTROL_STOP);
	if (error != ERROR_SUCCESS && error != ERROR_MORE_DATA && error != ERROR_WMI_INSTANCE_NOT_FOUND)
	{
		throw Win32ErrorCodeException("Could not close running ETW trace");
	}

	error = ::StartTrace(&this->m_traceSessionHandle, this->m_sessionName.c_str(), properties);
	if (ERROR_SUCCESS != error)
	{
		// ERROR_ALREADY_EXISTS indicates the trace session is already running:
		if (ERROR_ALREADY_EXISTS != error)
		{
			throw Win32ErrorCodeException("Could not start ETW trace");
		}
	}

	m_traceHandle = ::OpenTrace(&m_traceLogfile);
	if (INVALID_PROCESSTRACE_HANDLE == this->m_traceHandle)
	{
		throw Win32ErrorCodeException("Could not open ETW trace");
	}

	this->m_processTraceThread.reset([](auto params)
		{
			auto* const etwTraceSession = static_cast<AutoEtwTraceSession*>(params);
			const ULONG error = ::ProcessTrace(&etwTraceSession->m_traceHandle, 1, nullptr, nullptr);
			if (ERROR_SUCCESS != error)
			{
				throw Win32ErrorCodeException("ProcessTrace failed");
			}
			return error;
		}, this);

	error = ControlTrace(this->m_traceHandle, this->m_sessionName.c_str(), properties, EVENT_TRACE_CONTROL_FLUSH);
	if (ERROR_SUCCESS != error)
	{
		throw Win32ErrorCodeException("Could not flush the trace session buffers");
	}
}

void AutoEtwTraceSession::stopTrace()
{
	if (0 != m_traceHandle)
	{
		const ULONG error = CloseTrace(m_traceHandle);

		if (ERROR_SUCCESS != error)
		{
			// ERROR_CTX_CLOSE_PENDING indicates successful call and
			// ProcessTrace function will stop after it has processed all real-time events in its buffers.
			if (ERROR_CTX_CLOSE_PENDING != error)
			{
				throw Win32ErrorCodeException("CloseTrace failed");
			}
		}
		m_traceHandle = 0;
	}

	if (0 != m_traceSessionHandle)
	{
		auto* properties = reinterpret_cast<PEVENT_TRACE_PROPERTIES>(this->m_propertiesBuffer.get());

		const ULONG  error = ControlTrace(this->m_traceHandle, this->m_sessionName.c_str(), properties, EVENT_TRACE_CONTROL_STOP);
		if (ERROR_SUCCESS != error)
		{
			// ERROR_MORE_DATA indicates that ETW stop the session before
			// generating this error.
			if (ERROR_MORE_DATA != error)
			{
				throw Win32ErrorCodeException("Could not stop the ETW trace session");
			}
		}

		m_traceSessionHandle = 0;
	}

	// Blocking call:
	this->m_processTraceThread.release();
}

void AutoEtwTraceSession::setProperties(EVENT_TRACE_PROPERTIES properties)
{
	const auto size = properties.Wnode.BufferSize;
	if (0 >= size)
	{
		throw std::runtime_error("Invalid properties buffer size");
	}

	this->m_propertiesBuffer.reset(new BYTE[size]);
	if (nullptr == this->m_propertiesBuffer)
	{
		throw std::runtime_error("Could not allocate memory for properties");
	}

	memset(this->m_propertiesBuffer.get(), 0, size);
	memcpy(this->m_propertiesBuffer.get(), &properties, sizeof(EVENT_TRACE_PROPERTIES));
}

PEVENT_TRACE_PROPERTIES AutoEtwTraceSession::getProperties() const
{
	if (nullptr == this->m_propertiesBuffer)
	{
		throw std::runtime_error("Properties memory is invalid");
	}

	return reinterpret_cast<PEVENT_TRACE_PROPERTIES>(this->m_propertiesBuffer.get());
}

```

`Stresser/AutoEtwTraceSession.h`:

```h
#pragma once

#include "../Utils/StandardThread.h"

#include <functional>
#include <string>
#include <thread>

#include <Windows.h>
#include <tdh.h>

/*
 * Safe object for ETW trace session.
 * Accept configuration (properties, logfile), initiate the trace session and mange it.
 */
class AutoEtwTraceSession
{
public:
	AutoEtwTraceSession();

	/* Automatically create new trace session. */
	explicit AutoEtwTraceSession(EVENT_TRACE_PROPERTIES properties, EVENT_TRACE_LOGFILE logfile,
		const std::wstring& sessionName);

	virtual ~AutoEtwTraceSession();

	/* Close the current trace session and start new one. */
	void reset(EVENT_TRACE_PROPERTIES properties, EVENT_TRACE_LOGFILE logfile, const std::wstring& sessionName);

	/* Stop the current trace session. */
	void release();

private:
	/* Stops the trace session. */
	void startTrace();

	/* Start the trace session. */
	void stopTrace();

	/* Allocate dynamic memory and copy the structure data into it. */
	void setProperties(EVENT_TRACE_PROPERTIES properties);

	/* Return pointer to the trace properties member. */
	PEVENT_TRACE_PROPERTIES getProperties() const;

	TRACEHANDLE m_traceSessionHandle;
	TRACEHANDLE m_traceHandle;
	std::unique_ptr<BYTE[]> m_propertiesBuffer;
	EVENT_TRACE_LOGFILE m_traceLogfile;
	std::wstring m_sessionName;
	StandardThread m_processTraceThread;
};


```

`Stresser/AutoSetLostConnectionEvent.cpp`:

```cpp
#include "AutoSetLostConnectionEvent.h"

#include "../Utils/EventsNames.h"
#include "../Utils/WindowsEvent.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/StringUtils.h"

AutoSetLostConnectionEvent::AutoSetLostConnectionEvent()
{
	try
	{
		WindowsEvent lostConnectionEvent;
		lostConnectionEvent.open(LOST_CONNECTION_EVENT_NAME);
		lostConnectionEvent.setEvent();
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(AutoSetLostConnectionEvent, "Exception when trying to open: ", StringUtils::wstringToString(LOST_CONNECTION_EVENT_NAME),
			" connection: ", exception.what());

		throw exception;
	}
}

```

`Stresser/AutoSetLostConnectionEvent.h`:

```h
#pragma once

class AutoSetLostConnectionEvent
{
public:
	AutoSetLostConnectionEvent();
};


```

`Stresser/CollectorManager.cpp`:

```cpp
#include "CollectorManager.h"

void CollectorManager::addCollector(IEventCollector* collector, std::string collectorName)
{
	// TODO
}

void CollectorManager::removeCollector(std::string collectorName)
{
	// TODO
}

```

`Stresser/CollectorManager.h`:

```h
#pragma once

#include <functional>

#include "IEventCollector.h"

#include <string>
#include <vector>
#include <memory>
#include <map>

class CollectorManager
{
public:
	CollectorManager() = default;

	virtual ~CollectorManager() = default;

	void addCollector(IEventCollector* collector, std::string collectorName);

	void removeCollector(std::string collectorName);

private:
	std::map<std::unique_ptr<IEventCollector>, std::string> m_collectors;
};


```

`Stresser/Controllers.h`:

```h
#pragma once

#include "EndpointController.h"
#include "PolicyController.h"
#include "RuleController.h"
#include "EventController.h"
```

`Stresser/EndpointController.cpp`:

```cpp
#include "EndpointController.h"
#include "InvalidResponseException.h"

#include "../Utils/TimeUtils.h"
#include "../Utils/LocalPcUtils.h"
#include "../Utils/StringUtils.h"

#include <atlstr.h>
#include <Windows.h>

EndpointController::EndpointController(AuthorizedHttpRequest& authorizedHttpRequest)
	: m_authorizedHttpRequest(authorizedHttpRequest)
{
}

EndpointController& EndpointController::getInstance(AuthorizedHttpRequest& authorizedHttpRequest) {
	// Keep static instance of this class in order to prevent
	// new creations of this class:
	static EndpointController g_instance(authorizedHttpRequest);
	return g_instance;
}


EndpointEntity EndpointController::createEndpoint()
{
	this->setHostname();

	std::wstring wideIp = LocalPcUtils::getLocalComputerIp();
	std::string ip = StringUtils::wstringToString(wideIp);

	EndpointEntity endpointEntity;
	endpointEntity.SetIPAddress(ip);
	endpointEntity.SetHostname(StringUtils::wstringToString(this->m_computerName));

	const Json jsEndpoint = EndpointEntity::ConvertFromEntity(endpointEntity);
	const std::string targetPath("/endpoint");

	const Json responseJson = this->m_authorizedHttpRequest.sendRequest(http::verb::post, targetPath, jsEndpoint);
	if (responseJson.empty())
	{
		throw InvalidResponseException("Server return with no data");
	}

	return EndpointEntity::ConvertFromJson(responseJson);
}

EndpointEntity EndpointController::getEndpoint(const std::string& endpointId) const
{
	const std::string targetPath("/endpoint/" + endpointId);

	const Json responseJson = this->m_authorizedHttpRequest.sendRequest(http::verb::get, targetPath, "");
	if (responseJson.empty())
	{
		throw InvalidResponseException("Could not get endpoint data from Server");
	}

	return EndpointEntity::ConvertFromJson(responseJson);
}

void EndpointController::setHostname()
{
#ifdef DEBUG
	/*
	* Use unique value each time while in debug mode because the server keeps
	* endpoint registration for a while before removing it and allowing registering again.
	*/
	std::wstring computerName(LocalPcUtils::getLocalComputerName());
	const std::string currentDateTime(TimeUtils::GetCurrentDateTime());

	computerName += std::wstring(CA2W(currentDateTime.c_str()));
	this->m_computerName = computerName;
#else
	this->m_computerName = LocalPcUtils::getLocalComputerName();
#endif // DEBUG
}
```

`Stresser/EndpointController.h`:

```h
#pragma once

#include "AuthorizedHttpRequest.h"
#include "EndpointEntity.h"

#include "nlohmann/json.hpp"

#include <string>

using Json = nlohmann::json;

/*
* Represent the local computer as Endpoint in the Stresser security solution.
* Responsible for updating the Stresser server of endpoint status
* and manage the Agent API key for server-client operations.
*/
class EndpointController
{
public:
	// Disable: cloneable, assignable, movable:
	EndpointController(EndpointController&) = delete;
	void operator=(const EndpointController&) = delete;
	EndpointController(EndpointController&&) = delete;
	void operator=(const EndpointController&&) = delete;

	virtual ~EndpointController() = default;

	/*
	* Return the singleton instance of this class.
	* @param authorizedHttpRequest - HTTP request provider.
	* @return Global instance of this class.
	*/
	static EndpointController& getInstance(AuthorizedHttpRequest& authorizedHttpRequest);

	/*
		Create new endpoint entity in the server
		@return The new endpoint details: ID and token.
	*/
	EndpointEntity createEndpoint();

	/*
		Return the endpoint data from the server by it's endpoint ID.
		@param endpointId - The associated ID of the endpoint.
		@return The corresponding endpoint data.
	*/
	EndpointEntity getEndpoint(const std::string& endpointId) const;

private:
	EndpointController(AuthorizedHttpRequest& authorizedHttpRequest);

	void setHostname();

	AuthorizedHttpRequest& m_authorizedHttpRequest;
	std::wstring m_computerName;
};


```

`Stresser/EndpointEntity.cpp`:

```cpp
#include "EndpointEntity.h"
#include "../Utils/StringUtils.h"

EndpointEntity::EndpointEntity()
	: m_id(""), m_hostname(""), m_ipAddress(""), m_apiKey(""), m_policyId(""), m_status("") { }

EndpointEntity::EndpointEntity(std::string id, std::string hostname, std::string ipAddress, std::string apiKey,
	std::string policyId, std::string status)
	: m_id(id), m_hostname(hostname), m_ipAddress(ipAddress), m_apiKey(apiKey), m_policyId(policyId), m_status(status) { }

EndpointEntity::~EndpointEntity() { }

const std::string EndpointEntity::GetID()
{
	return this->m_id;
}

const std::string EndpointEntity::GetHostname()
{
	return this->m_hostname;
}

const std::string EndpointEntity::GetIPAddress()
{
	return this->m_ipAddress;
}

const std::string EndpointEntity::GetAPIKey()
{
	return this->m_apiKey;
}

const std::string EndpointEntity::GetPolicyID()
{
	return this->m_policyId;
}

const std::string EndpointEntity::GetStatus()
{
	return this->m_status;
}

void EndpointEntity::SetHostname(const std::string hostname)
{
	this->m_hostname = hostname;
}

void EndpointEntity::SetIPAddress(const std::string ipAddress)
{
	this->m_ipAddress = ipAddress;
}

void EndpointEntity::GetStatus(const std::string status)
{
	this->m_status = status;
}

EndpointEntity EndpointEntity::ConvertFromJson(Json jsEndpoint)
{
	return EndpointEntity(
		StringUtils::RemoveQuotationMarks(jsEndpoint["id"].dump()),
		StringUtils::RemoveQuotationMarks(jsEndpoint["hostname"].dump()),
		StringUtils::RemoveQuotationMarks(jsEndpoint["IPAddress"].dump()),
		StringUtils::RemoveQuotationMarks(jsEndpoint["apiKey"].dump()),
		StringUtils::RemoveQuotationMarks(jsEndpoint["policyId"].dump()),
		StringUtils::RemoveQuotationMarks(jsEndpoint["status"].dump())
	);
}

Json EndpointEntity::ConvertFromEntity(EndpointEntity entity)
{
	Json jsEndpoint;
	jsEndpoint["id"] = entity.GetID();
	jsEndpoint["hostname"] = entity.GetHostname();
	jsEndpoint["IPAddress"] = entity.GetIPAddress();;
	jsEndpoint["apiKey"] = entity.GetAPIKey();
	jsEndpoint["policyId"] = entity.GetPolicyID();
	jsEndpoint["status"] = entity.GetStatus();

	return jsEndpoint;
}

std::ostream& operator<<(std::ostream& out, const EndpointEntity& endpointEntity)
{
	return out
		<< "ID: " << endpointEntity.m_id
		<< ", Hostname: " << endpointEntity.m_hostname
		<< ", IP Address: " << endpointEntity.m_ipAddress
		<< ", API Key: " << endpointEntity.m_apiKey
		<< ", Status: " << endpointEntity.m_status;
}

```

`Stresser/EndpointEntity.h`:

```h
#pragma once
#include <iostream>

#include "nlohmann/json.hpp"

using Json = nlohmann::json;

class EndpointEntity
{
public:
	EndpointEntity();
	EndpointEntity(std::string id, std::string hostname, std::string ipAddress, std::string apiKey,
		std::string policyId, std::string status);
	~EndpointEntity();

	const std::string GetID();
	const std::string GetHostname();
	const std::string GetIPAddress();
	const std::string GetAPIKey();
	const std::string GetPolicyID();
	const std::string GetStatus();
	void SetHostname(const std::string hostname);
	void SetIPAddress(const std::string ipAddress);
	void GetStatus(const std::string status);

	static EndpointEntity ConvertFromJson(Json jsonEndpointEntity);
	static Json ConvertFromEntity(EndpointEntity entity);

	friend std::ostream& operator << (std::ostream& out, const EndpointEntity& endpointEntity);

private:
	std::string m_id;
	std::string m_hostname;
	std::string m_ipAddress;
	std::string m_apiKey;
	std::string m_policyId;
	std::string m_status;
};
```

`Stresser/Entities.h`:

```h
#pragma once

#include "EndpointEntity.h"
#include "PolicyEntity.h"
#include "EventEntity.h"
#include "RuleEntity.h"
```

`Stresser/EtwEventTypes.h`:

```h
#pragma once
#include "EventProvidersGuid.h"
#include <map>

#include <Windows.h>

// must be after Windows.h:
#include <evntrace.h>

enum class EtwEventTypes : ULONG
{
	DiskIo = EVENT_TRACE_FLAG_DISK_IO,
	DiskFileIo = EVENT_TRACE_FLAG_DISK_FILE_IO,
	FileIo = EVENT_TRACE_FLAG_FILE_IO,
	FileIoInit = EVENT_TRACE_FLAG_FILE_IO_INIT,
	Registry = EVENT_TRACE_FLAG_REGISTRY,
	Process = EVENT_TRACE_FLAG_PROCESS,
	ProcessCounters = EVENT_TRACE_FLAG_PROCESS_COUNTERS
};

```

`Stresser/EtwManager.cpp`:

```cpp
#include "EtwManager.h"

#include "../Utils/DebugPrint.h"

EtwManager::EtwManager()
{
	this->initializeGuids();
}

EtwManager::~EtwManager()
{
	try
	{
		this->stop();
	}
	catch (const std::exception& exception)
	{
		DEBUG_PRINT(exception.what());
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in TraceManager destructor");
	}
}

void EtwManager::start()
{
	DEBUG_WTRACE(EtwManager, "Start ETW manager");

	this->m_autoTraceSession.reset(this->getProperties(), this->getTraceLogFile(), KERNEL_LOGGER_NAME);
}

void EtwManager::stop()
{
	DEBUG_WTRACE(EtwManager, "Stop ETW manager");

	this->m_autoTraceSession.release();
}

void EtwManager::onEventRecord(PEVENT_RECORD record)
{
	for (const auto& eventHandler : this->m_eventsHandlers)
	{
		if (m_etwEventsGuid.at(eventHandler->getType()) == record->EventHeader.ProviderId)
		{
			std::optional<EventEntity> eventEntity = eventHandler->onEventRecord(record);
			if (eventEntity)
			{
				this->m_callback(eventEntity.value());
			}
		}
	}
}

void EtwManager::setCallback(const std::function<void(EventEntity&)>& callback)
{
	m_callback = callback;
}

void EtwManager::registerEventHandle(std::shared_ptr<IEtwEventHandler> eventHandler)
{
	this->m_eventsHandlers.push_back(eventHandler);
}

EVENT_TRACE_PROPERTIES EtwManager::getProperties() const
{
	EVENT_TRACE_PROPERTIES properties = { 0 };

	properties.EnableFlags = this->getEventTypes();

	// Allocating memory for EVENT_TRACE_PROPERTIES + the log file name memory (KERNEL_LOGGER_NAME)
	// See MSDN about EVENT_TRACE_PROPERTIES, LogFileNameOffset filed for more info.
	const auto size = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(KERNEL_LOGGER_NAME);
	properties.Wnode.BufferSize = static_cast<ULONG>(size);

	properties.Wnode.Guid = SystemTraceControlGuid;
	properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
	properties.Wnode.ClientContext = 1;
	properties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;

	// Offset from the start of the allocated memory to the log file name:
	properties.LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

	return properties;
}

EVENT_TRACE_LOGFILE EtwManager::getTraceLogFile()
{
	EVENT_TRACE_LOGFILE traceLogfile = { 0 };

	// On event, pass this class reference:
	traceLogfile.Context = this;

	traceLogfile.LoggerName = const_cast<LPWSTR>(LOGGER_NAME.c_str());
	traceLogfile.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_REAL_TIME;
	traceLogfile.EventRecordCallback = [](const PEVENT_RECORD record) {
		auto* const etwManager = static_cast<EtwManager*>(record->UserContext);
		etwManager->onEventRecord(record);
	};

	return traceLogfile;
}

ULONG EtwManager::getEventTypes() const
{
	ULONG eventTypes = 0;
	for (const auto& eventHandler : this->m_eventsHandlers)
	{
		eventTypes |= static_cast<ULONG>(eventHandler->getType());
	}

	return eventTypes;
}

void EtwManager::initializeGuids()
{
	this->m_etwEventsGuid =
	{
		{EtwEventTypes::DiskIo, DiskIoGuid},
		{EtwEventTypes::DiskFileIo, FileIoGuid},
		{EtwEventTypes::FileIo, FileIoGuid},
		{EtwEventTypes::FileIoInit, FileIoGuid},
		{EtwEventTypes::Registry, RegistryGuid},
		{EtwEventTypes::Process, ProcessGuid},
		{EtwEventTypes::ProcessCounters, ProcessGuid}
	};
}

```

`Stresser/EtwManager.h`:

```h
#pragma once

// Used for SystemTraceControlGuid:
#define INITGUID

#include "IEventCollector.h"
#include "IEtwEventHandler.h"
#include "AutoEtwTraceSession.h"

#include <functional>
#include <vector>

#include <Windows.h>

// must be after Windows.h:
#include <evntrace.h>
#include <evntcons.h>

// Default logger name:
const std::wstring LOGGER_NAME(KERNEL_LOGGER_NAME);

/*
 * Manage the ETW trace session.
 * Define the default properties and the default logfile for the ETW session
 * and start the trace session, stop it, etc.
 */
class EtwManager : public IEventCollector
{
public:
	EtwManager();

	virtual ~EtwManager();

	/* Start the start the trace session. */
	void start() override;

	/* Stop the start the trace session. */
	void stop() override;

	/* Called whenever new event accepted by the trace session. */
	void onEventRecord(PEVENT_RECORD record);

	/* Set the callback which called when event is returned from events handlers */
	void setCallback(const std::function<void(EventEntity&)>& callback);

	void registerEventHandle(std::shared_ptr<IEtwEventHandler> eventHandler);

private:
	/* Create default properties structure for the trace session. */
	EVENT_TRACE_PROPERTIES getProperties() const;

	/* Create default logfile structure for the trace session. */
	EVENT_TRACE_LOGFILE getTraceLogFile();

	/* Construct all the event types bits. */
	ULONG getEventTypes() const;

private:
	void initializeGuids();

	std::function<void(EventEntity&)> m_callback;
	std::vector<std::shared_ptr<IEtwEventHandler>> m_eventsHandlers;
	AutoEtwTraceSession m_autoTraceSession;
	std::map<EtwEventTypes, GUID> m_etwEventsGuid;
};

```

`Stresser/EtwUtils.cpp`:

```cpp
#include "EtwUtils.h"

std::map<UCHAR, std::wstring> EtwUtils::getFileIoNameEventTypes()
{
	std::map<UCHAR, std::wstring> types;

	types.insert({ 0, L"Name" });
	types.insert({ 32, L"FileCreate" });
	types.insert({ 35, L"FileDelete" });
	types.insert({ 36, L"FileRundown" });

	return types;
}

std::map<UCHAR, std::wstring> EtwUtils::getFileIoDirectoryEnumerationEventTypes()
{
	std::map<UCHAR, std::wstring> types;

	types.insert({ 72, L"DirEnum" });
	types.insert({ 77, L"DirNotify" });

	return types;
}

```

`Stresser/EtwUtils.h`:

```h
#pragma once

#include <string>
#include <map>

#include <Windows.h>

class EtwUtils final
{
public:
	static std::map<UCHAR, std::wstring> getFileIoNameEventTypes();

	static std::map<UCHAR, std::wstring> getFileIoDirectoryEnumerationEventTypes();
};


```

`Stresser/EventController.cpp`:

```cpp
#include "EventController.h"
#include "InvalidResponseException.h"

#include "../Utils/StringUtils.h"
#include "../Utils/LocalPcUtils.h"

EventController& EventController::getInstance(AuthorizedHttpRequest& authorizedHttpRequest)
{
	// Keep static instance of this class in order to prevent
	// new creations of this class:
	static EventController g_instance(authorizedHttpRequest);
	return g_instance;
}

void EventController::sendEvent(EventEntity& eventEntity) const
{
	const std::string targetPath("/event");

	eventEntity.setIpAddress(this->m_ipAddress);
	eventEntity.setHostname(this->m_hostname);

	const Json jsEvent = EventEntity::ConvertFromEntity(eventEntity);

	const Json responseJson = this->m_authorizedHttpRequest.sendRequest(http::verb::post, targetPath, jsEvent);
	if (responseJson.empty())
	{
		throw InvalidResponseException("Server return with no data");
	}
}

EventController::EventController(AuthorizedHttpRequest& authorizedHttpRequest)
	: m_authorizedHttpRequest(authorizedHttpRequest)
{
	const std::wstring wideHostname = LocalPcUtils::getLocalComputerName();
	const std::wstring wideIp = LocalPcUtils::getLocalComputerIp();

	this->m_hostname = StringUtils::wstringToString(wideHostname);
	this->m_ipAddress = StringUtils::wstringToString(wideIp);
}

```

`Stresser/EventController.h`:

```h
#pragma once

#include "AuthorizedHttpRequest.h"
#include "EventEntity.h"

#include "nlohmann/json.hpp"

using Json = nlohmann::json;

/*
	Used to manage all the communication related to events between the client and the server.
*/
class EventController
{
public:
	// Disable: cloneable, assignable, movable:
	EventController(EventController&) = delete;
	void operator=(const EventController&) = delete;
	EventController(EventController&&) = delete;
	void operator=(const EventController&&) = delete;

	virtual ~EventController() = default;

	/*
	* Return the singleton instance of this class.
	* @param authorizedHttpRequest - HTTP request provider.
	* @return Global instance of this class.
	*/
	static EventController& getInstance(AuthorizedHttpRequest& authorizedHttpRequest);

	/*
	 * Send event to the server.
	 * @param eventEntity - Represent the event.
	 */
	void sendEvent(EventEntity& eventEntity) const;

private:
	explicit EventController(AuthorizedHttpRequest& authorizedHttpRequest);

	AuthorizedHttpRequest& m_authorizedHttpRequest;
	std::string m_ipAddress;
	std::string m_hostname;
};


```

`Stresser/EventEntity.cpp`:

```cpp
#include "EventEntity.h"

#include <utility>

EventEntity::EventEntity(std::string name, std::string type, std::string data, std::string timestamp)
	: m_name(std::move(name)), m_type(std::move(type)), m_data(std::move(data)), m_timestamp(std::move(timestamp))
{
}

const std::string& EventEntity::getId() const
{
	return this->m_id;
}

const std::string& EventEntity::getName() const
{
	return this->m_name;
}

const std::string& EventEntity::getType() const
{
	return this->m_type;
}

const std::string& EventEntity::getData() const
{
	return this->m_data;
}

const std::string& EventEntity::getHostname() const
{
	return this->m_hostname;
}

const std::string& EventEntity::getIpAddress() const
{
	return this->m_ipAddress;
}

const std::string& EventEntity::getTimestamp() const
{
	return this->m_timestamp;
}

void EventEntity::setId(const std::string& mId)
{
	m_id = mId;
}

void EventEntity::setName(const std::string& mName)
{
	m_name = mName;
}

void EventEntity::setType(const std::string& mType)
{
	m_type = mType;
}

void EventEntity::setData(const std::string& mData)
{
	m_data = mData;
}

void EventEntity::setHostname(const std::string& mHostname)
{
	m_hostname = mHostname;
}

void EventEntity::setIpAddress(const std::string& mIpAddress)
{
	m_ipAddress = mIpAddress;
}

void EventEntity::setTimestamp(const std::string& mTimestamp)
{
	m_timestamp = mTimestamp;
}

Json EventEntity::ConvertFromEntity(const EventEntity& entity)
{
	Json jsEvent;

	jsEvent["id"] = entity.m_id;
	jsEvent["eventName"] = entity.m_name;
	jsEvent["eventType"] = entity.m_type;
	jsEvent["eventData"] = entity.m_data;
	jsEvent["hostname"] = entity.m_hostname;
	jsEvent["IPAddress"] = entity.m_ipAddress;
	jsEvent["timeStamp"] = entity.m_timestamp;

	return jsEvent;
}

std::ostream& operator<<(std::ostream& out, const EventEntity& eventEntity)
{
	return out
		<< "ID: " << eventEntity.m_id
		<< ", Name: " << eventEntity.m_name
		<< ", Type: " << eventEntity.m_type
		<< ", Hostname: " << eventEntity.m_hostname
		<< ", IP Address: " << eventEntity.m_ipAddress
		<< ", Timestamp: " << eventEntity.m_timestamp;
}

```

`Stresser/EventEntity.h`:

```h
#pragma once
#include <string>
#include "nlohmann/json.hpp"

using Json = nlohmann::json;

class EventEntity
{
public:
	EventEntity() = default;

	explicit EventEntity(std::string name, std::string type, std::string data, std::string timestamp);

	virtual ~EventEntity() = default;

	const std::string& getId() const;
	const std::string& getName() const;
	const std::string& getType() const;
	const std::string& getData() const;
	const std::string& getHostname() const;
	const std::string& getIpAddress() const;
	const std::string& getTimestamp() const;

	void setId(const std::string& mId);
	void setName(const std::string& mName);
	void setType(const std::string& mType);
	void setData(const std::string& mData);
	void setHostname(const std::string& mHostname);
	void setIpAddress(const std::string& mIpAddress);
	void setTimestamp(const std::string& mTimestamp);

	static Json ConvertFromEntity(const EventEntity& entity);

	friend std::ostream& operator << (std::ostream& out, const EventEntity& eventEntity);

private:
	std::string m_id;
	std::string m_name;
	std::string m_type;
	std::string m_data;
	std::string m_hostname;
	std::string m_ipAddress;
	std::string m_timestamp;
};


```

`Stresser/EventParser.cpp`:

```cpp
#include "EventParser.h"

#include <Windows.h>

EventParser::EventParser(PEVENT_RECORD record) : m_record(record) {
	ULONG size = 0;
	auto error = ::TdhGetEventInformation(record, 0, nullptr, m_info, &size);
	if (error == ERROR_INSUFFICIENT_BUFFER) {
		m_buffer = std::make_unique<BYTE[]>(size);
		m_info = reinterpret_cast<PTRACE_EVENT_INFO>(m_buffer.get());
		error = ::TdhGetEventInformation(record, 0, nullptr, m_info, &size);
	}
	::SetLastError(error);
}

PTRACE_EVENT_INFO EventParser::getEventInfo() const {
	return m_info;
}

PEVENT_RECORD EventParser::getEventRecord() const {
	return m_record;
}

const EVENT_HEADER& EventParser::getEventHeader() const {
	return m_record->EventHeader;
}

const std::vector<EventProperty>& EventParser::getProperties() const {
	if (!m_properties.empty())
		return m_properties;

	m_properties.reserve(m_info->TopLevelPropertyCount);
	auto userDataLength = m_record->UserDataLength;
	BYTE* data = (BYTE*)m_record->UserData;

	for (ULONG i = 0; i < m_info->TopLevelPropertyCount; i++) {
		auto& prop = m_info->EventPropertyInfoArray[i];
		EventProperty property(prop);
		property.Name.assign((WCHAR*)((BYTE*)m_info + prop.NameOffset));
		auto len = prop.length;
		property.Length = len;
		property.Data = data;
		data += len;
		userDataLength -= len;

		m_properties.push_back(std::move(property));
	}

	return m_properties;
}

const EventProperty* EventParser::getProperty(PCWSTR name) const {
	for (auto& prop : getProperties())
		if (prop.Name == name)
			return &prop;
	return nullptr;
}

DWORD EventParser::getProcessId() const {
	return m_record->EventHeader.ProcessId;
}

std::wstring EventParser::getDosNameFromNtName(PCWSTR name) {
	static std::vector<std::pair<std::wstring, std::wstring>> deviceNames;
	static bool first = true;
	if (first) {
		auto drives = ::GetLogicalDrives();
		int drive = 0;
		while (drives) {
			if (drives & 1) {
				// drive exists
				WCHAR driveName[] = L"X:";
				driveName[0] = (WCHAR)(drive + 'A');
				WCHAR path[MAX_PATH];
				if (::QueryDosDevice(driveName, path, MAX_PATH)) {
					deviceNames.push_back({ path, driveName });
				}
			}
			drive++;
			drives >>= 1;
		}
		first = false;
	}

	for (auto& [ntName, dosName] : deviceNames) {
		if (::_wcsnicmp(name, ntName.c_str(), ntName.size()) == 0)
			return dosName + (name + ntName.size());
	}
	return L"";
}

EventProperty::EventProperty(EVENT_PROPERTY_INFO& info) : Info(info) {
}

PCWSTR EventProperty::getUnicodeString() const {
	return (PCWSTR)Data;
}

PCSTR EventProperty::getAnsiString() const {
	return (PCSTR)Data;
}
```

`Stresser/EventParser.h`:

```h
#pragma once

#include <memory>
#include <string>
#include <vector>

#include <Windows.h>
#include <tdh.h>

#pragma comment(lib, "tdh")

struct EventProperty {
	EventProperty(EVENT_PROPERTY_INFO& info);

	std::wstring Name;
	BYTE* Data;
	ULONG Length;
	EVENT_PROPERTY_INFO& Info;

	template<typename T>
	T getValue() const {
		static_assert(std::is_pod<T>() && !std::is_pointer<T>());
		return *(T*)Data;
	}

	PCWSTR getUnicodeString() const;
	PCSTR getAnsiString() const;
};

class EventParser {
public:
	EventParser(PEVENT_RECORD record);

	PTRACE_EVENT_INFO getEventInfo() const;
	PEVENT_RECORD getEventRecord() const;
	const EVENT_HEADER& getEventHeader() const;
	const std::vector<EventProperty>& getProperties() const;
	const EventProperty* getProperty(PCWSTR name) const;

	DWORD getProcessId() const;

	static std::wstring getDosNameFromNtName(PCWSTR name);

private:
	std::unique_ptr<BYTE[]> m_buffer;
	PTRACE_EVENT_INFO m_info{ nullptr };
	PEVENT_RECORD m_record;
	mutable std::vector<EventProperty> m_properties;
};
```

`Stresser/EventProvidersGuid.h`:

```h
#pragma once
#include <initguid.h>

DEFINE_GUID( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
	DiskIoGuid,
	0x3d6fa8d4,
	0xfe05,
	0x11d0,
	0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
);

DEFINE_GUID( /* AE53722E-C863-11d2-8659-00C04FA321A1 */
	RegistryGuid,
	0xae53722e,
	0xc863,
	0x11d2,
	0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1
);

DEFINE_GUID( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
	FileIoGuid,
	0x90cbdc39,
	0x4a3e,
	0x11d1,
	0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
);

DEFINE_GUID( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
	ProcessGuid,
	0x3d6fa8d0,
	0xfe05,
	0x11d0,
	0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
);
```

`Stresser/FileArtifact.cpp`:

```cpp
#include "FileArtifact.h"

#include "../Utils/DebugPrint.h"

FileArtifact::FileArtifact(const std::string& name, const  std::string& data) : IArtifact(name, data)
{
	// https://stackoverflow.com/a/962148
	this->FileArtifact::install();
}

FileArtifact::~FileArtifact()
{
	// https://stackoverflow.com/a/962148
	this->FileArtifact::uninstall();
}

ArtifactTypes FileArtifact::getType() const
{
	return ArtifactTypes::File;
}

void FileArtifact::install()
{
	const std::string fileName = this->m_data;

	const AutoHandle hFile(CreateFileA(
		fileName.c_str(),		// Open file
		GENERIC_WRITE, 			// Open for writing
		0, 						// Do not share
		nullptr, 					// Default security
		OPEN_ALWAYS, 			// Open or create
		FILE_ATTRIBUTE_NORMAL, 	// Normal file
		nullptr
	));

	if (hFile.get() == INVALID_HANDLE_VALUE)
	{
		throw Win32ErrorCodeException("Failed to create a File!");
	}

	DEBUG_TRACE(FileArtifact, "Install fake file: ", fileName.c_str());
}

void FileArtifact::uninstall()
{
	const std::string fileName = this->m_data;

	if (!DeleteFileA(fileName.c_str()))
	{
		throw Win32ErrorCodeException("Failed to delete a File!");
	}

	DEBUG_TRACE(FileArtifact, "Uninstall fake file: ", fileName.c_str());
}

```

`Stresser/FileArtifact.h`:

```h
#pragma once
#include "IArtifact.h"
#include "../Utils/AutoHandle.h"
#include "../Utils/Win32ErrorCodeException.h"

class FileArtifact : public IArtifact
{
public:
	explicit FileArtifact(const std::string& name, const std::string& data);
	virtual ~FileArtifact();

	ArtifactTypes getType() const override;

	void install() override;
	void uninstall() override;
};

```

`Stresser/FileEventHandler.cpp`:

```cpp
#include "FileEventHandler.h"

#include "EtwUtils.h"
#include "EventParser.h"
#include "ArtifactTypes.h"

#include "../Utils/TimeUtils.h"
#include "../Utils/StringUtils.h"
#include "../Utils/LocalPcUtils.h"
#include "../Utils/AutoCriticalSection.h"
#include "../Utils/DebugPrint.h"

#include "boost/algorithm/string.hpp"

FileEventHandler::FileEventHandler(std::vector<std::shared_ptr<IArtifact>>& artifacts)
	: IEtwEventHandler(EtwEventTypes::FileIoInit), m_artifacts(artifacts)
{
}

std::optional<EventEntity> FileEventHandler::onEventRecord(PEVENT_RECORD record)
{
	if (m_artifacts.empty())
	{
		return std::nullopt;
	}

	const EventParser parser(record);

	const std::wstring timestamp = TimeUtils::systemTimeToTimestamp(parser.getEventHeader().TimeStamp);
	const std::uint32_t processPid = parser.getProcessId();
	const std::wstring eventData = L"Time= " + timestamp + L", PID= " + std::to_wstring(processPid);

	const UCHAR eventOpcode = parser.getEventHeader().EventDescriptor.Opcode;

	if (FILE_CREATE_OPCODE != eventOpcode)
	{
		return std::nullopt;
	}

	std::string eventType = ArtifactNames[static_cast<size_t>(ArtifactTypes::File)];
	std::wstring wideEventType = StringUtils::stringToWString(eventType);
	const EventProperty* openPathProperty = parser.getProperty(L"OpenPath");
	if (nullptr == openPathProperty)
	{
		return std::nullopt;
	}

	const std::wstring openPath(openPathProperty->getUnicodeString());
	std::wstring filePath;

	try
	{
		filePath = LocalPcUtils::getDosNameFromNtName(openPath);
	}
	catch (...)
	{
		// Cannot convert the ntPath to dosPath
		return std::nullopt;
	}

	{
		AutoCriticalSection autoCriticalSection;

		for (const auto& artifact : this->m_artifacts)
		{
			if (artifact->getType() == ArtifactTypes::File)
			{
				const std::wstring artifactFilePath = StringUtils::stringToWString(artifact->getData());
				const std::wstring trimmedArtifactFilePath = StringUtils::trimBackslash(artifactFilePath);
				if (boost::iequals(filePath, artifactFilePath) || boost::iequals(filePath, trimmedArtifactFilePath))
				{
					const std::wstring wideTimestamp = TimeUtils::systemTimeToTimestamp(parser.getEventHeader().TimeStamp);
					const std::string timestamp = StringUtils::wstringToString(wideTimestamp);

					const std::string eventType = ArtifactNames[static_cast<size_t>(ArtifactTypes::File)];
					const std::uint32_t processPid = parser.getProcessId();

					const std::wstring eventData = L"PID= " + std::to_wstring(processPid) + L" FilePath= " + filePath;
					std::string narrowEventData = StringUtils::wstringToString(eventData);

					DEBUG_WTRACE(FileEventHandler, "RegistryDetectionEvent: Event timestamp=", wideTimestamp, eventData);

					return EventEntity("File Artifact touched", eventType, narrowEventData, timestamp);
				}
			}
		}
	}

	return std::nullopt;
}

```

`Stresser/FileEventHandler.h`:

```h
#pragma once
#include "IArtifact.h"
#include "IEtwEventHandler.h"

#include <memory>
#include <vector>

constexpr size_t FILE_CREATE_OPCODE = 64;

class FileEventHandler : public IEtwEventHandler
{
public:
	explicit FileEventHandler(std::vector<std::shared_ptr<IArtifact>>& artifacts);

	~FileEventHandler() override = default;

	std::optional<EventEntity> onEventRecord(PEVENT_RECORD record) override;

private:
	std::vector<std::shared_ptr<IArtifact>>& m_artifacts;
};

```

`Stresser/HttpRequest.cpp`:

```cpp
#include "HttpRequest.h"
#include "ParsingJsonException.h"
#include "NetworkConnectionException.h"

Json HttpRequest::sendRequest(const std::string& userAgent, int version, const std::string& contentType,
	const std::string& authorization, const http::verb& requestMethod, const std::string& hostname,
	const std::string& target, const std::string& port, const Json& payload)
{
	if (userAgent.empty() || hostname.empty() || target.empty())
	{
		throw std::runtime_error("Could not preform request if any of: hostname, user agent, target is missing");
	}

	if (version != 10 && version != 11)
	{
		throw std::runtime_error("Invalid HTTP version");
	}

	try
	{
		// The io_context is required for all I/O
		net::io_context ioc;

		// These objects perform our I/O
		tcp::resolver resolver(ioc);
		beast::tcp_stream stream(ioc);

		// Look up the domain name
		auto const results = resolver.resolve(hostname, port);

		// Make the connection on the IP address we get from a lookup
		stream.connect(results);

		// Set up an HTTP GET request message
		http::request<http::string_body> req{ requestMethod, target, version };
		req.set(http::field::host, hostname);
		req.set(http::field::user_agent, userAgent);

		if (!contentType.empty())
		{
			req.set(http::field::content_type, contentType);
		}

		if (!authorization.empty())
		{
			req.set(http::field::authorization, authorization);
		}

		const std::string requestPayload = payload.dump();
		if (!requestPayload.empty())
		{
			req.body() = requestPayload;
		}

		req.prepare_payload();
		//std::cout << req << std::endl;

		// Send the HTTP request to the remote host
		http::write(stream, req);

		// This buffer is used for reading and must be persisted
		beast::flat_buffer buffer;

		// Declare a container to hold the response
		http::response<http::dynamic_body> res;

		// Receive the HTTP response
		http::read(stream, buffer, res);

		// Print response:
		//std::cout << res << std::endl;
		std::string responseData = beast::buffers_to_string(res.body().data());

		Json jsResponseData;

		jsResponseData = Json::parse(responseData);

		// Gracefully close the socket
		beast::error_code ec;
		stream.socket().shutdown(tcp::socket::shutdown_both, ec);
		stream.socket().close(ec);

		// not_connected happens sometimes
		// so don't bother reporting it.
		//
		if (ec && ec != beast::errc::not_connected)
			throw beast::system_error{ ec };

		// If we get here then the connection is closed gracefully
		return jsResponseData;
	}
	catch (const nlohmann::detail::exception& exception)
	{
		throw ParsingJsonException(exception.what());
	}
	catch (const boost::system::system_error& exception)
	{
		throw NetworkConnectionException(exception.what());
	}
}

```

`Stresser/HttpRequest.h`:

```h
#pragma once


#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/version.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/ip/tcp.hpp>

#include "nlohmann/json.hpp"

#include <cstdlib>
#include <iostream>
#include <string>

#include <Windows.h>

namespace beast = boost::beast;     // from <boost/beast.hpp>
namespace http = beast::http;       // from <boost/beast/http.hpp>
namespace net = boost::asio;        // from <boost/asio.hpp>
using tcp = net::ip::tcp;           // from <boost/asio/ip/tcp.hpp>
using Json = nlohmann::json;

class HttpRequest
{
public:

	/*
		Send HTTP request using the given parameters over socket communication.
		@return Json object represent the response data from the server.
	 */
	static Json sendRequest(const std::string& userAgent, int version, const std::string& contentType, const std::string& authorization,
		const http::verb& requestMethod, const std::string& hostname, const std::string& target, const std::string& port,
		const Json& payload);
};


```

`Stresser/IArtifact.cpp`:

```cpp
#include "IArtifact.h"

IArtifact::IArtifact(std::string name, std::string data) :
m_data(std::move(data)), m_name(std::move(name))
{
}

std::string IArtifact::getData() const
{
	return this->m_data;
}

std::string IArtifact::getName() const
{
	return this->m_name;
}

```

`Stresser/IArtifact.h`:

```h
#pragma once
#include "ArtifactTypes.h"
#include <string>

class IArtifact
{
public:
	explicit IArtifact(std::string name, std::string data);
	virtual ~IArtifact() = default;

	std::string getData() const;
	std::string getName() const;
	virtual ArtifactTypes getType() const = 0;

	virtual void install() = 0;
	virtual void uninstall() = 0;

protected:
	std::string m_data;
	std::string m_name;
};

```

`Stresser/IArtifactSubscriber.cpp`:

```cpp
#include "IArtifactSubscriber.h"

void IArtifactSubscriber::reset()
{
	this->m_artifactsToReport.clear();
}

void IArtifactSubscriber::setNewArtifacts(const std::vector<std::shared_ptr<IArtifact>>& artifacts)
{
	this->m_artifactsToReport = artifacts;
}

```

`Stresser/IArtifactSubscriber.h`:

```h
#pragma once
#include <memory>

#include "IArtifact.h"
#include <vector>

class IArtifactSubscriber
{
public:
	IArtifactSubscriber() = default;

	virtual ~IArtifactSubscriber() = default;

	void reset();

	virtual void setNewArtifacts(const std::vector<std::shared_ptr<IArtifact>>& artifacts);

protected:
	std::vector<std::shared_ptr<IArtifact>> m_artifactsToReport;
};

```

`Stresser/IEtwEventHandler.cpp`:

```cpp
#include "IEtwEventHandler.h"

IEtwEventHandler::IEtwEventHandler(EtwEventTypes eventType) :
	m_eventType(eventType)
{
}

EtwEventTypes IEtwEventHandler::getType() const
{
	return m_eventType;
}

```

`Stresser/IEtwEventHandler.h`:

```h
#pragma once
#include "EtwEventTypes.h"
#include "EventEntity.h"

#include <optional>

/*
 * Represent class that have implemented ETW event callback for incoming events.
 */
class IEtwEventHandler
{
public:
	IEtwEventHandler(EtwEventTypes eventType);

	EtwEventTypes getType() const;

	virtual ~IEtwEventHandler() = default;

	virtual std::optional<EventEntity> onEventRecord(PEVENT_RECORD record) = 0;

private:
	EtwEventTypes m_eventType;
};

```

`Stresser/IEventCollector.h`:

```h
#pragma once

class IEventCollector
{
public:
	virtual ~IEventCollector() = default;

	virtual void start() = 0;

	virtual void stop() = 0;
};
```

`Stresser/IPolicySubscriber.h`:

```h
#pragma once
#include "RuleEntity.h"

class IPolicySubscriber
{
public:
	virtual ~IPolicySubscriber() = default;
	virtual void policyChanged(const std::vector<RuleEntity>& rules) = 0;
};

```

`Stresser/IStresserApplication.h`:

```h
#pragma once
class IStresserApplication
{
public:
	virtual ~IStresserApplication() = default;

	virtual void start() = 0;

	virtual void stop() = 0;

	virtual void pause() = 0;

	virtual void waitForShutdown() = 0;
};

```

`Stresser/IStresserDetector.cpp`:

```cpp
#include "IStresserDetector.h"
#include "InvalidResponseException.h"

#include "../Utils/DebugPrint.h"

IStresserDetector::IStresserDetector(const EventController& eventController)
	:m_eventController(eventController)
{
}

void IStresserDetector::sendEvent(EventEntity& eventEntity) const
{
	try
	{
		this->m_eventController.sendEvent(eventEntity);
	}
	catch (const InvalidResponseException& exception)
	{
		DEBUG_TRACE(IStresserDetector, "Could not send event to server");
	}
}


```

`Stresser/IStresserDetector.h`:

```h
#pragma once

#include "EventController.h"

/*
	Represent detector class in the application.
	Using this layer divide between the communication application and the detection application.
 */
class IStresserDetector
{
public:
	explicit IStresserDetector(const EventController& eventController);

	virtual ~IStresserDetector() = default;

	/* Start the detector */
	virtual void start() = 0;

	/* Stop the detector */
	virtual void stop() = 0;

protected:
	/*
		send event to the server.
		@param eventEntity - Event to send.
	 */
	void sendEvent(EventEntity& eventEntity) const;

private:
	const EventController& m_eventController;
};

```

`Stresser/InvalidResponseException.cpp`:

```cpp
#include "InvalidResponseException.h"

InvalidResponseException::InvalidResponseException(char const* message)
	: std::exception(message)
{
}

char const* InvalidResponseException::what() const
{
	return std::exception::what();
}
```

`Stresser/InvalidResponseException.h`:

```h
#pragma once

#include <exception>

class InvalidResponseException : public std::exception
{
public:
	InvalidResponseException() = default;

	explicit InvalidResponseException(char const* message);

	char const* what() const override;
};


```

`Stresser/KernelDetector.cpp`:

```cpp
#include "KernelDetector.h"

#include "../Utils/LocalPcUtils.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/PeResource.h"
#include "../Utils/ServiceManager.h"
#include "../Utils/AutoCriticalSection.h"
#include "../Utils/AutoSignedImageVerifier.h"
#include "../Utils/EventsNames.h"

#include "resource.h"

#include <sstream>

#include "ProcessArtifact.h"
#include "../Utils/StringUtils.h"
#include "../Utils/TimeUtils.h"

KernelDetector::KernelDetector(const EventController& eventController)
	: IStresserDetector(eventController), m_doesTestSigning(false),
	m_onProcessEvent(UM_ON_FAKE_PROCESS_EVENT_NAME, FALSE, FALSE),
	m_stopDetectionThreadEvent(STOP_FETCH_THREAD_EVENT_NAME)
{
	DEBUG_WTRACE(KernelDetector, "Initiating kernel mode detector");
}

KernelDetector::~KernelDetector()
{
	try
	{
		if (this->m_doesTestSigning)
		{
			this->stop();
		}
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(~KernelDetector, exception.what());
	}
	catch (...)
	{
		DEBUG_WTRACE(KernelDetector, "Undefined exception was thrown in destructor");
	}
}

void KernelDetector::start()
{
	DEBUG_WTRACE(KernelDetector, "Start kernel mode detector");

	this->m_doesTestSigning = LocalPcUtils::doesTestSigningEnabled();
	if (!this->m_doesTestSigning)
	{
		DEBUG_WTRACE(start, "Running on system without testsigning enabled");
		DEBUG_WTRACE(start, "Could not install process detector driver");

		// Continue Stresser without kernel detector
		return;
	}

	try
	{
		KernelDetector::installStresserDriver();

		this->registerFakeProcessIds();
	}
	catch (const std::exception& exception)
	{
		DEBUG_PRINT(exception.what());
	}
}

void KernelDetector::stop()
{
	DEBUG_WTRACE(KernelDetector, "Stop kernel mode detector");

	if (!this->m_doesTestSigning)
	{
		DEBUG_TRACE(stop, "Running on system without testsigning enabled");
		return;
	}

	try
	{
		this->stopDetectionThread();

		KernelDetector::uninstallStresserDriver();
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(stop, exception.what());
	}
}

void KernelDetector::setNewArtifacts(const std::vector<std::shared_ptr<IArtifact>>& artifacts)
{
	if (!this->m_doesTestSigning)
	{
		return;
	}

	AutoCriticalSection autoCriticalSection;

	// Set new artifacts:
	this->m_artifactsToReport = artifacts;
	if (this->m_artifactsToReport.empty())
	{
		return;
	}

	try
	{
		this->stopDetectionThread();

		KernelDetector::removeAllRegisteredFakeProcessIds();

		this->registerFakeProcessIds();

		this->startDetectionThread();
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(setNewArtifacts, exception.what());
	}
}

void KernelDetector::installStresserDriver()
{
	const PeResource resource(STRESSER_ENGINE, L"BIN");
	const std::wstring binaryPath(KernelDetector::createTemporaryPath(STRESSER_DRIVER_NAME_WITH_EXTENSION));

	resource.saveResourceToFileSystem(binaryPath);
	DEBUG_WTRACE(installStresserDriver, "Save Stresser driver locally: ", binaryPath);

	ServiceManager serviceManager(STRESSER_DRIVER_SERVICE_NAME, binaryPath, STRESSER_DRIVER_SERVICE_TYPE);

	serviceManager.installAndStart();
	DEBUG_WTRACE(installStresserDriver, "Install and start Stresser driver service: ", STRESSER_DRIVER_SERVICE_NAME);
}

void KernelDetector::uninstallStresserDriver()
{
	const std::wstring binaryPath(KernelDetector::createTemporaryPath(STRESSER_DRIVER_NAME_WITH_EXTENSION));
	const ServiceManager serviceManager(STRESSER_DRIVER_SERVICE_NAME, binaryPath, STRESSER_DRIVER_SERVICE_TYPE);

	serviceManager.stopAndRemove();
	DEBUG_WTRACE(uninstallStresserDriver, "Stop and uninstall Stresser driver service: ", STRESSER_DRIVER_SERVICE_NAME);

	if (!DeleteFile(binaryPath.c_str()))
	{
		throw Win32ErrorCodeException("Could not delete Stresser driver: " +
			StringUtils::wstringToString(binaryPath));
	}
	DEBUG_WTRACE(uninstallStresserDriver, "Delete Stresser driver binary file");
}

void KernelDetector::registerFakeProcessIds()
{
	if (this->m_artifactsToReport.empty())
	{
		return;
	}

	AutoCriticalSection autoCriticalSection;

	for (const auto& artifact : this->m_artifactsToReport)
	{
		if (ArtifactTypes::Process != artifact->getType())
		{
			continue;
		}

		const auto* processArtifact = dynamic_cast<ProcessArtifact*>(artifact.get());

		const ULONG processId = processArtifact->getFakeProcessId();

		const ProcessDetector processDetector;
		processDetector.addFakeProcessId(processId);

		DEBUG_TRACE(KernelDetector, "Register fake process ID for detection: ", processId);
	}
}

void KernelDetector::removeAllRegisteredFakeProcessIds()
{
	const ProcessDetector processDetector;
	processDetector.removeAllFakeProcessIds();
}

std::wstring KernelDetector::createTemporaryPath(const std::wstring& exeNameWithExtension)
{
	std::wstringstream binPathStream;
	binPathStream << LocalPcUtils::getTempPath();
	binPathStream << "\\";
	binPathStream << exeNameWithExtension;

	return binPathStream.str();
}

void KernelDetector::fetchAndSendEvents(LPVOID params)
{
	auto* kernelDetector = static_cast<KernelDetector*>(params);

	WindowsEvent stresserShutdownEvent;
	stresserShutdownEvent.open(STOP_STRESSER);

	// Check if requested to stop the thread functionality:
	while (!kernelDetector->m_stopDetectionThreadEvent.isSignaled()
		&& !stresserShutdownEvent.isSignaled())
	{
		const ProcessDetector processDetector;

		// Check if there are already events:
		const EventsResult eventsResult = processDetector.receiveEvents();
		if (0 < eventsResult.size)
		{
			this->onProcessDetectionEvent(eventsResult);
		}
		else
		{
			// Register synchronization event:
			processDetector.registerEvent(KM_ON_FAKE_PROCESS_EVENT_NAME);

			// Wait for event
			if (WAIT_OBJECT_0 == kernelDetector->m_onProcessEvent.wait(WAIT_BETWEEN_FETCH_EVENT_MS))
			{
				const EventsResult eventsResult = processDetector.receiveEvents();
				this->onProcessDetectionEvent(eventsResult);
			}
		}
	}
}

void KernelDetector::onProcessDetectionEvent(const EventsResult& eventsResult) const
{
	if (0 >= eventsResult.size)
	{
		return;
	}

	std::set<EventInfo, EventInfoComparator> uniqueEvents = this->getUniqueEvents(eventsResult);

	for (const auto& eventInfo : uniqueEvents)
	{
		AutoSignedImageVerifier verify(eventInfo.processName);
		const VerificationResult result = verify.verify();

		// Not signed process:
		if (!result.first)
		{
			const std::wstring eventTimestamp(TimeUtils::systemTimeToTimestamp(eventInfo.time, TIME_FORMAT));

			std::wstringstream eventStream;
			eventStream << "ProcessDetectionEvent: Event timestamp=";
			eventStream << eventTimestamp;
			eventStream << " PID=";
			eventStream << eventInfo.processId;
			eventStream << " Filename=";
			eventStream << eventInfo.processName;
			eventStream << " touch Fake process PID=";
			eventStream << eventInfo.fakeProcessId;

			const std::wstring eventData(eventStream.str());

			DEBUG_WTRACE(KernelDetector, eventData);

			EventEntity eventEntity("Process Artifact touched", "Process", "Fake process touched",
				StringUtils::wstringToString(eventTimestamp));

			this->sendEvent(eventEntity);
		}
	}
}

void KernelDetector::startDetectionThread()
{
	this->m_stopDetectionThreadEvent.resetEvent();
	this->m_fetchEventThread.reset([this](auto params)
		{
			KernelDetector::fetchAndSendEvents(params);
		}, this);
}

void KernelDetector::stopDetectionThread()
{
	this->m_stopDetectionThreadEvent.setEvent();
	this->m_fetchEventThread.release();
}

std::set<EventInfo, EventInfoComparator> KernelDetector::getUniqueEvents(const EventsResult& eventsResult) const
{
	const std::unique_ptr<EventInfo[]>& eventInfo = eventsResult.events;

	std::vector<EventInfo> events;

	for (int i = 0; i < eventsResult.size; ++i)
	{
		events.push_back(eventInfo[i]);
	}

	std::set<EventInfo, EventInfoComparator> uniqueEvents;

	for (const auto& eventInfo : events)
	{
		uniqueEvents.insert(eventInfo);
	}

	return uniqueEvents;
}

```

`Stresser/KernelDetector.h`:

```h
#pragma once

#include "IStresserDetector.h"
#include "IArtifactSubscriber.h"
#include "ProcessDetector.h"

#include "../Utils/StandardThread.h"
#include "../Utils/WindowsEvent.h"

#include <set>

const int STRESSER_DRIVER_RESOURCE_ID = 5;
const std::wstring STRESSER_DRIVER_RESOURCE_NAME(L"STRESSER_ENGINE");
const std::wstring STRESSER_DRIVER_SERVICE_NAME(L"StresserProcessDetector");
const std::wstring STRESSER_DRIVER_NAME_WITH_EXTENSION(L"StresserEngine.sys");
const std::uint32_t STRESSER_DRIVER_SERVICE_TYPE = SERVICE_KERNEL_DRIVER;
const std::wstring STOP_FETCH_THREAD_EVENT_NAME(L"StopFetchProcessEvents");
const int WAIT_BETWEEN_FETCH_EVENT_MS = 20000;
const std::wstring TIME_FORMAT(L"%d/%m/%Y - %H:%M:%S");
const std::wstring ON_FAKE_PROCESS_EVENT_NAME(L"OnFakeProcess");
const std::wstring UM_ON_FAKE_PROCESS_EVENT_NAME(L"Global\\" + ON_FAKE_PROCESS_EVENT_NAME);
const std::wstring KM_ON_FAKE_PROCESS_EVENT_NAME(L"\\BaseNamedObjects\\" + ON_FAKE_PROCESS_EVENT_NAME);

class KernelDetector : public IStresserDetector, public IArtifactSubscriber
{
public:
	explicit KernelDetector(const EventController& eventController);

	// Disable: copyable, assignable, movable:
	KernelDetector(KernelDetector&) = delete;
	KernelDetector& operator=(KernelDetector&) = delete;
	KernelDetector(KernelDetector&&) = delete;
	KernelDetector& operator=(KernelDetector&&) = delete;

	virtual ~KernelDetector();

	/*
		Start the detector.
		If encounter any error, log it and keep running Stresser without terminating it.
	*/
	void start() override;

	/* Stop the detector */
	void stop() override;

	/*
		Called by the ArtifactManager whenever new Artifacts arrived.
		Used to stop flush the kernel detector fake process IDs and start
		detection on new ones.
	 */
	void setNewArtifacts(const std::vector<std::shared_ptr<IArtifact>>& artifacts) override;

private:
	/* Extract driver from PE resources and dump it to disk, create Win32 service and start it. */
	static void installStresserDriver();

	/* Stop the service and delete the driver binary from the disk. */
	static void uninstallStresserDriver();

	/* Register available process ID for detection. */
	void registerFakeProcessIds();

	/* Request to remove detection of all the registered process IDs. */
	static void removeAllRegisteredFakeProcessIds();

	/* Helper for concatenating temporary path with filename. */
	static std::wstring createTemporaryPath(const std::wstring& exeNameWithExtension);

	/*
		Represent the detection thread.
		Try to consume available events or wait for the kernel detector to signal
		on new arrived events to be consumed.
	*/
	void fetchAndSendEvents(LPVOID params);

	/* Handler the received events. */
	void onProcessDetectionEvent(const EventsResult& eventsResult) const;

	/* Reset stop event and start the detection thread. */
	void startDetectionThread();

	/* Set the stop event and stop the detection thread. */
	void stopDetectionThread();

	/* Return set of unique EventInfo objects. */
	std::set<EventInfo, EventInfoComparator> getUniqueEvents(const EventsResult& eventsResult) const;

	bool m_doesTestSigning;
	StandardThread m_fetchEventThread;
	WindowsEvent m_onProcessEvent;
	WindowsEvent m_stopDetectionThreadEvent;
};

```

`Stresser/NetworkConnectionException.cpp`:

```cpp
#include "NetworkConnectionException.h"

NetworkConnectionException::NetworkConnectionException(char const* message)
	: std::exception(message)
{
}

char const* NetworkConnectionException::what() const
{
	return std::exception::what();
}


```

`Stresser/NetworkConnectionException.h`:

```h
#pragma once

#include <exception>

class NetworkConnectionException : public std::exception
{
public:
	NetworkConnectionException() = default;

	explicit NetworkConnectionException(char const* message);

	char const* what() const override;
};


```

`Stresser/ParsingJsonException.cpp`:

```cpp
#include "ParsingJsonException.h"

ParsingJsonException::ParsingJsonException(char const* message)
	:std::exception(message)
{
}

char const* ParsingJsonException::what() const
{
	return std::exception::what();
}

```

`Stresser/ParsingJsonException.h`:

```h
#pragma once

#include <exception>

class ParsingJsonException final : public std::exception
{
public:
	ParsingJsonException() = default;

	explicit ParsingJsonException(char const* message);

	char const* what() const override;
};


```

`Stresser/PolicyController.cpp`:

```cpp
#include "PolicyController.h"
#include "InvalidResponseException.h"

#include <sstream>

PolicyController& PolicyController::getInstance(AuthorizedHttpRequest& authorizedHttpRequest)
{
	// Keep static instance of this class in order to prevent
	// new creations of this class:
	static PolicyController g_instance(authorizedHttpRequest);
	return g_instance;
}

PolicyEntity PolicyController::getPolicy(const std::string& policyId) const
{
	std::stringstream targetPath;
	targetPath << "/policy/";
	targetPath << policyId;

	const Json responseJson = this->m_authorizedHttpRequest.sendRequest(http::verb::get, targetPath.str(), "");
	if (responseJson.empty())
	{
		throw InvalidResponseException("Server return with no data");
	}

	return PolicyEntity::convertFromJson(responseJson);
}

PolicyController::PolicyController(AuthorizedHttpRequest& authorizedHttpRequest)
	: m_authorizedHttpRequest(authorizedHttpRequest)
{
}

```

`Stresser/PolicyController.h`:

```h
#pragma once

#include "AuthorizedHttpRequest.h"
#include "PolicyEntity.h"

#include <iostream>

class PolicyController
{
public:
	// Disable: cloneable, assignable, movable:
	PolicyController(PolicyController&) = delete;
	void operator=(const PolicyController&) = delete;
	PolicyController(PolicyController&&) = delete;
	void operator=(const PolicyController&&) = delete;

	virtual ~PolicyController() = default;

	/*
	* Return the singleton instance of this class.
	* @param authorizedHttpRequest - HTTP request provider.
	* @return Global instance of this class.
	*/
	static PolicyController& getInstance(AuthorizedHttpRequest& authorizedHttpRequest);

	/*
		Return the policy data from the server by it's policy ID.
		@param policyID - The associated ID of the policy.
		@return The corresponding policy data.
	*/
	PolicyEntity getPolicy(const std::string& policyId) const;

public:
	explicit PolicyController(AuthorizedHttpRequest& authorizedHttpRequest);

	AuthorizedHttpRequest& m_authorizedHttpRequest;
};

```

`Stresser/PolicyEntity.cpp`:

```cpp
#include "PolicyEntity.h"
#include "../Utils/StringUtils.h"

PolicyEntity::PolicyEntity()
	: m_id(""), m_name(""), m_numberOfRules(0), m_rules(std::vector<std::string>()), m_updateCount(0)
{
}

PolicyEntity::PolicyEntity(std::string id, std::string name, int numberOfRules, std::vector<std::string> rules, int updateCount)
	: m_id(id), m_name(name), m_numberOfRules(numberOfRules), m_rules(rules), m_updateCount(updateCount) { }

std::string PolicyEntity::getId() const
{
	return this->m_id;
}

std::string PolicyEntity::getName() const
{
	return this->m_name;
}

int PolicyEntity::getSize() const
{
	return this->m_numberOfRules;
}

std::vector<std::string> PolicyEntity::getRulesIds() const
{
	return this->m_rules;
}

int PolicyEntity::getUpdateCount() const
{
	return this->m_updateCount;
}

PolicyEntity PolicyEntity::convertFromJson(Json jsonPolicy)
{
	const std::string policyID = StringUtils::RemoveQuotationMarks(jsonPolicy["id"].dump());
	const std::string policyName = StringUtils::RemoveQuotationMarks(jsonPolicy["policyName"].dump());
	const int numberOfRules = stoi(StringUtils::RemoveQuotationMarks(jsonPolicy["numberOfRules"].dump()));
	const int updateCount = stoi(StringUtils::RemoveQuotationMarks(jsonPolicy["updateCount"].dump()));

	std::vector<std::string> rules;
	rules.reserve(numberOfRules);

	Json jsRules = jsonPolicy["rules"];
	for (const auto& jsRuleId : jsRules)
		rules.push_back(StringUtils::RemoveQuotationMarks(jsRuleId.dump()));

	return PolicyEntity(policyID, policyName, numberOfRules, rules, updateCount);
}

Json PolicyEntity::convertFromEntity(const PolicyEntity& policyEntity)
{
	Json jsPolicy;
	jsPolicy["id"] = policyEntity.getId();
	jsPolicy["policyName"] = policyEntity.getName();
	jsPolicy["numberOfRules"] = std::string("" + policyEntity.getSize());

	Json jsRules = Json::array();
	auto rules = policyEntity.getRulesIds();

	for (const auto& jsRule : rules)
	{
		jsRules.push_back(jsRule);
	}

	jsPolicy["rules"] = jsRules;
	jsPolicy["updateCount"] = std::string("" + policyEntity.getUpdateCount());

	return jsPolicy;
}

std::ostream& operator<<(std::ostream& out, const PolicyEntity& policyEntity)
{
	out
		<< "ID: " << policyEntity.m_id
		<< ", Name: " << policyEntity.m_name
		<< ", Update Count: " << policyEntity.m_updateCount
		<< ", Number of rules: " << policyEntity.m_numberOfRules
		<< std::endl;
	out << "Rules:" << std::endl;

	for (const auto& rule : policyEntity.m_rules)
	{
		out << rule << std::endl;
	}

	return out;
}

bool PolicyEntity::operator==(const PolicyEntity& rPolicy) const
{
	if (this->m_id != rPolicy.m_id)
	{
		return false;
	}
	if (this->m_updateCount != rPolicy.m_updateCount)
	{
		return false;
	}

	return true;
}

```

`Stresser/PolicyEntity.h`:

```h
#pragma once

#include "RuleEntity.h"

#include "nlohmann/json.hpp"

#include <iostream>
#include <vector>

using Json = nlohmann::json;

/*
 * Represent Policy entity in the application server.
 */
class PolicyEntity
{
public:
	PolicyEntity();
	explicit PolicyEntity(std::string id, std::string name, int numberOfRules, std::vector<std::string> rules, int updateCount);

	virtual ~PolicyEntity() = default;

	std::string getId() const;
	std::string getName() const;
	int getSize() const;
	std::vector<std::string> getRulesIds() const;
	int getUpdateCount() const;

	static PolicyEntity convertFromJson(Json jsonPolicy);
	static Json convertFromEntity(const PolicyEntity& policyEntity);

	friend std::ostream& operator << (std::ostream& out, const PolicyEntity& policyEntity);
	bool operator==(const PolicyEntity& rPolicy) const;

private:
	std::string m_id;
	std::string m_name;
	int m_numberOfRules;
	std::vector<std::string> m_rules;
	int m_updateCount;
};


```

`Stresser/PolicyNotifications.cpp`:

```cpp
#include "PolicyNotifications.h"
#include "ParsingJsonException.h"
#include "InvalidResponseException.h"

#include "../Utils/DebugPrint.h"
#include "../Utils/EventsNames.h"
#include "../Utils/LocalPcUtils.h"
#include "../Utils/SehTranslatorGuard.h"
#include "../Utils/AutoCriticalSection.h"

PolicyNotifications::PolicyNotifications(const std::string& endpointId, const HANDLE& shutdownEvent,
	const EndpointController& endpointController, const PolicyController& policyController, const RuleController& ruleController) :
	m_endpointId(endpointId), m_changePolicyEvent(CHANGE_POLICY), m_shutdownEvent(shutdownEvent),
	m_endpointController(endpointController), m_policyController(policyController), m_ruleController(ruleController)
{
	this->m_lostConnectionEvent.open(LOST_CONNECTION_EVENT_NAME);

	this->startFetchPolicyThread();
}

void PolicyNotifications::subscribe(IPolicySubscriber* subscriber)
{
	if (nullptr == subscriber)
	{
		throw std::runtime_error("Received null pointer");
	}

	this->m_subscribers.push_back(subscriber);
}

void PolicyNotifications::startFetchPolicyThread()
{
	this->m_changePolicyThread = StandardThread([this]()
		{
			this->changePolicyThreadFunction(this->m_endpointController, this->m_policyController, this->m_ruleController);
		});
}

void PolicyNotifications::resetEndpointId(std::string endpointId)
{
	AutoCriticalSection autoCriticalSection;
	this->m_endpointId = endpointId;
}

void PolicyNotifications::changePolicyThreadFunction(const EndpointController& endpointController,
	const PolicyController& policyController, const RuleController& ruleController)
{
	DEBUG_WTRACE(PolicyNotifications, "Start fetching policy updates");

	SehTranslatorGuard sehTranslatorGuard;

	constexpr int CLOSE_THREAD_EVENTS_COUNT = 2;
	HANDLE closeThreadEvents[CLOSE_THREAD_EVENTS_COUNT] =
	{
		this->m_shutdownEvent,
		this->m_lostConnectionEvent.get()
	};

	while (WAIT_TIMEOUT == WaitForMultipleObjects(CLOSE_THREAD_EVENTS_COUNT, closeThreadEvents, FALSE, 30 * 1000))
	{
		try
		{
			EndpointEntity endpointEntity = endpointController.getEndpoint(this->m_endpointId);
			DEBUG_TRACE(changePolicyThreadFunction, "Fetch policy data for endpoint ID=", endpointEntity.GetID());

			PolicyEntity policyEntity = policyController.getPolicy(endpointEntity.GetPolicyID());
			if (this->m_currentPolicy == policyEntity)
			{
				continue;
			}

			this->m_currentRules.clear();
			this->m_currentPolicy = policyEntity;

			DEBUG_TRACE(changePolicyThreadFunction, "New policy data, ID=", this->m_currentPolicy.getId(),
				", Version=", this->m_currentPolicy.getUpdateCount());

			this->m_changePolicyEvent.setEvent();
			this->m_changePolicyEvent.resetEvent();

			for (std::string& ruleId : this->m_currentPolicy.getRulesIds())
			{
				RuleEntity ruleEntity = ruleController.getRule(ruleId);
				this->m_currentRules.push_back(ruleEntity);

				DEBUG_TRACE(changePolicyThreadFunction, "Rule: ", ruleEntity.getName(), "ID=", ruleEntity.getId());
			}

			this->notifySubscribers();
		}
		catch (const InvalidResponseException& exception)
		{
			DEBUG_TRACE(PolicyNotifications, "Invalid response from server, Exception: ", exception.what());
		}
	}

	DEBUG_WTRACE(PolicyNotifications, "Stop fetching policy updates");
}

void PolicyNotifications::notifySubscribers()
{
	for (IPolicySubscriber* subscriber : this->m_subscribers)
	{
		subscriber->policyChanged(this->m_currentRules);
	}
}

```

`Stresser/PolicyNotifications.h`:

```h
#pragma once
#include "EndpointController.h"
#include "PolicyController.h"
#include "PolicyEntity.h"
#include "RuleController.h"
#include "../Utils/StandardThread.h"
#include "../Utils/WindowsEvent.h"

#include <string>
#include <vector>

#include "IPolicySubscriber.h"


class PolicyNotifications
{
public:
	explicit PolicyNotifications(const std::string& endpointId, const HANDLE& shutdownEvent, const EndpointController& endpointController,
		const PolicyController& policyController, const RuleController& ruleController);
	~PolicyNotifications() = default;

	void subscribe(IPolicySubscriber* subscriber);

	void startFetchPolicyThread();

	void resetEndpointId(std::string endpointId);

private:
	void changePolicyThreadFunction(const EndpointController& endpointController,
		const PolicyController& policyController, const RuleController& ruleController);

	void notifySubscribers();

	std::vector<IPolicySubscriber*> m_subscribers;
	PolicyEntity m_currentPolicy;
	std::string m_endpointId;
	WindowsEvent m_changePolicyEvent;
	WindowsEvent m_lostConnectionEvent;
	HANDLE m_shutdownEvent;
	StandardThread m_changePolicyThread;
	std::vector<RuleEntity> m_currentRules;

	// Save locally for supporting start inner thread again:
	const EndpointController& m_endpointController;
	const PolicyController& m_policyController;
	const RuleController& m_ruleController;
};


```

`Stresser/ProcessArtifact.cpp`:

```cpp
#include "ProcessArtifact.h"

#include "../Utils/DebugPrint.h"

ProcessArtifact::ProcessArtifact(const std::string& name, const std::string& data) : IArtifact(name, data)
{
	const std::wstring tempPath = LocalPcUtils::getTempPath();
	const std::wstring wideFileName = StringUtils::stringToWString(data);

	this->m_filePath = std::wstring(tempPath + wideFileName);
	this->m_pid = INVALID_PID;

	// https://stackoverflow.com/a/962148
	this->ProcessArtifact::install();
}

ProcessArtifact::~ProcessArtifact()
{
	// https://stackoverflow.com/a/962148
	this->ProcessArtifact::uninstall();
}

ArtifactTypes ProcessArtifact::getType() const
{
	return ArtifactTypes::Process;
}

void ProcessArtifact::install()
{
	const PeResource fakeProcess(FAKE_PROCESS, L"BIN");

	fakeProcess.saveResourceToFileSystem(this->m_filePath);

	STARTUPINFO info = { sizeof(info) };
	PROCESS_INFORMATION processInfo{ nullptr, nullptr, 0, 0 };
	if (!CreateProcess(
		this->m_filePath.c_str(),
		nullptr,
		nullptr,
		nullptr,
		TRUE,
		0,
		nullptr,
		nullptr,
		&info,
		&processInfo
	))
	{
		throw Win32ErrorCodeException("Failed to create a process!");
	}

	AutoHandle process(processInfo.hProcess);
	AutoHandle thread(processInfo.hThread);
	this->m_pid = processInfo.dwProcessId;

	DEBUG_WTRACE(ProcessArtifact, "Install fake process: ", this->m_filePath.c_str());
}

void ProcessArtifact::uninstall()
{
	if (INVALID_PID == this->m_pid)
	{
		throw Win32ErrorCodeException("Invalid PID");
	}

	// SYNCHRONIZE for WaitForSingleObject - when the wait stop the process is terminated
	// The process need to be terminated before we try to delete his file from the disk
	const AutoHandle process(OpenProcess(SYNCHRONIZE, FALSE, this->m_pid));
	if (nullptr != process.get())
	{
		WaitForSingleObject(process.get(), PROCESS_TERMINATE_WAIT_TIME);
	}

	if (!DeleteFile(this->m_filePath.c_str()))
	{
		throw Win32ErrorCodeException("Failed to delete the fake process file!");
	}

	DEBUG_WTRACE(ProcessArtifact, "Uninstall fake process: ", this->m_filePath.c_str());
}

DWORD ProcessArtifact::getFakeProcessId() const
{
	return this->m_pid;
}

```

`Stresser/ProcessArtifact.h`:

```h
#pragma once
#include "IArtifact.h"
#include "resource.h"
#include "../Utils/PeResource.h"
#include "../Utils/LocalPcUtils.h"
#include "../Utils/StringUtils.h"

constexpr size_t PROCESS_TERMINATE_WAIT_TIME = 10000;
constexpr size_t INVALID_PID = 0;

class ProcessArtifact : public IArtifact
{
public:
	explicit ProcessArtifact(const std::string& name, const std::string& data);
	virtual ~ProcessArtifact();

	ArtifactTypes getType() const override;

	void install() override;
	void uninstall() override;

	DWORD getFakeProcessId() const;

private:
	std::wstring m_filePath;
	DWORD m_pid;
};


```

`Stresser/ProcessDetector.cpp`:

```cpp
#include "ProcessDetector.h"
#include "../Utils/Win32ErrorCodeException.h"

ProcessDetector::ProcessDetector()
{
	this->detectorDevice.reset(CreateFile(DEVICE_NAME.c_str(), GENERIC_READ | GENERIC_WRITE, 0,
		nullptr, OPEN_EXISTING, 0, nullptr));

	if (INVALID_HANDLE_VALUE == this->detectorDevice.get())
	{
		throw Win32ErrorCodeException("Could not get Stresser engine device");
	}
}

void ProcessDetector::addFakeProcessId(ULONG processId) const
{
	FakeProcessId fakeProcessId{ processId };

	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_ADD_FAKE_PID, &fakeProcessId,
		FAKE_PROCESS_ID_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

void ProcessDetector::removeFakeProcessId(ULONG processId) const
{
	FakeProcessId fakeProcessId{ processId };

	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_REMOVE_FAKE_PID, &fakeProcessId,
		FAKE_PROCESS_ID_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

void ProcessDetector::registerEvent(std::wstring eventName) const
{
	if (MAX_EVENT_NAME_LENGTH < eventName.length())
	{
		throw std::runtime_error("Invalid length of event name");
	}

	if (eventName.empty())
	{
		throw std::runtime_error("Invalid event name");
	}

	RegisterEvent registerEvent{ 0 };

	// Make sure for null-terminator:
	memset(registerEvent.eventName, 0, sizeof(WCHAR) * MAX_EVENT_NAME_LENGTH);

	wcscpy_s(registerEvent.eventName, MAX_EVENT_NAME_LENGTH, eventName.c_str());

	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_REGISTER_EVENT, &registerEvent,
		REGISTER_EVENT_SIZE, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

EventsResult ProcessDetector::receiveEvents(ULONG numberOfEvents) const
{
	if (numberOfEvents < 1)
	{
		throw std::runtime_error("Invalid number of events to receive");
	}

	auto eventsBuffer = std::make_unique<EventInfo[]>(numberOfEvents);
	if (nullptr == eventsBuffer)
	{
		throw std::runtime_error("Could not allocate memory for events buffer");
	}

	// Zero all the memory:
	memset(eventsBuffer.get(), 0, EVENT_INFO_SIZE * numberOfEvents);

	// Prepare the request:
	EventsHeader eventsHeader
	{
		numberOfEvents,
		eventsBuffer.get()
	};

	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_GET_EVENTS, nullptr, 0, &eventsHeader,
		EVENTS_HEADER_SIZE, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}

	// There are no available events:
	if (0 == returnedBytes)
	{
		return EventsResult{ 0, nullptr };
	}

	const int size = returnedBytes / EVENT_INFO_SIZE;

	EventsResult result
	{
		size,
		std::move(eventsBuffer)
	};

	return result;
}

void ProcessDetector::unregisterEvent() const
{
	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_UNREGISTER_EVENT, nullptr,
		0, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

void ProcessDetector::removeAllFakeProcessIds() const
{
	DWORD returnedBytes;
	if (!DeviceIoControl(this->detectorDevice.get(), IOCTL_STRESSER_ENGINE_REMOVE_ALL_FAKE_PROCESS_IDS, nullptr,
		0, nullptr, 0, &returnedBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not commit device control request");
	}
}

```

`Stresser/ProcessDetector.h`:

```h
#pragma once

#include "../Utils/AutoHandle.h"
#include "../StresserEngine/StresserEngineCommon.h"

#include <string>

const std::wstring DEVICE_NAME = L"\\\\.\\StresserEngine";

/*
	Result of calling for getting events from Driver.
 */
struct EventsResult
{
	int size;								// Number of received events
	std::unique_ptr < EventInfo[]> events;	// Buffer with the received events
};

class ProcessDetector
{
public:
	ProcessDetector();

	// Disable copyable, assignable, movable:
	ProcessDetector(ProcessDetector&) = delete;
	ProcessDetector& operator=(ProcessDetector&) = delete;
	ProcessDetector(ProcessDetector&&) = delete;
	ProcessDetector& operator=(ProcessDetector&&) = delete;

	virtual ~ProcessDetector() = default;

	/* Add process ID to be monitored. */
	void addFakeProcessId(ULONG processId) const;

	/* Remove process ID from being monitored. */
	void removeFakeProcessId(ULONG processId) const;

	/*
		Register shared event with the Driver for synchronization when
		there are available events to consume.
	*/
	void registerEvent(std::wstring eventName) const;

	/* Fetch the events from the Driver. */
	EventsResult receiveEvents(ULONG numberOfEvents = 10) const;

	/* Send request to remove any registered event. */
	void unregisterEvent() const;

	/* Send request to remove all the registered fake process IDs. */
	void removeAllFakeProcessIds() const;

private:
	AutoHandle detectorDevice;
};


```

`Stresser/RegistryArtifact.cpp`:

```cpp
#include "RegistryArtifact.h"

#include "../Utils/DebugPrint.h"

RegistryArtifact::RegistryArtifact(const std::string& name, const std::string& data) : IArtifact(name, data)
{
	this->m_registryPrefix = RegistryArtifactUtils::getRegistryPrefix(this->m_data);
	this->m_registrySubKey = RegistryArtifactUtils::getRegistrySubKey(this->m_data);

	// https://stackoverflow.com/a/962148
	this->RegistryArtifact::install();
}

RegistryArtifact::~RegistryArtifact()
{
	// https://stackoverflow.com/a/962148
	this->RegistryArtifact::uninstall();
}

ArtifactTypes RegistryArtifact::getType() const
{
	return ArtifactTypes::Registry;
}

void RegistryArtifact::install()
{
	HKEY hKey;

	LSTATUS createRegStatus = RegCreateKeyExA(
		this->m_registryPrefix, 			// Registry key
		this->m_registrySubKey.c_str(), 	// Sub key
		0, 								// Reserved and must be 0
		nullptr, 							// Class type of the key
		REG_OPTION_NON_VOLATILE,		// Keep the key after reboot
		KEY_WRITE, 						// Registry key security and access right
		nullptr, 							// Security attributes
		&hKey, 							// Handle to the opened key
		nullptr 							// Determine either the key exists or not
	);

	if (ERROR_SUCCESS != createRegStatus)
	{
		throw Win32ErrorCodeException("Failed to create registry key!");
	}

	AutoRegistryKeyHandle autoHKey(hKey);

	DEBUG_TRACE(RegistryArtifact, "Install fake registry: ", this->m_registrySubKey.c_str());
}

void RegistryArtifact::uninstall()
{
	if (ERROR_SUCCESS != RegDeleteKeyA(this->m_registryPrefix, this->m_registrySubKey.c_str()))
	{
		throw Win32ErrorCodeException("Failed to delete the registry key!");
	}

	DEBUG_TRACE(RegistryArtifact, "Uninstall fake registry: ", this->m_registrySubKey.c_str());
}

```

`Stresser/RegistryArtifact.h`:

```h
#pragma once
#include "IArtifact.h"
#include "../Utils/AutoRegistryKeyHandle.h"
#include "../Utils/RegistryArtifactUtils.h"

class RegistryArtifact : public IArtifact
{
public:
	explicit RegistryArtifact(const std::string& name, const std::string& data);
	virtual ~RegistryArtifact();

	ArtifactTypes getType() const override;

	void install() override;
	void uninstall() override;

private:
	HKEY m_registryPrefix;
	std::string m_registrySubKey;
};

```

`Stresser/RegistryEventHandler.cpp`:

```cpp
#include "RegistryEventHandler.h"

#include "EventParser.h"
#include "ArtifactTypes.h"
#include "../Utils/TimeUtils.h"
#include "../Utils/StringUtils.h"
#include "../Utils/RegistryArtifactUtils.h"
#include "../Utils/AutoCriticalSection.h"
#include "../Utils/DebugPrint.h"
#include "boost/algorithm/string.hpp"

RegistryEventHandler::RegistryEventHandler(std::vector<std::shared_ptr<IArtifact>>& artifacts)
	:IEtwEventHandler(EtwEventTypes::Registry), m_artifacts(artifacts)
{
}

std::optional<EventEntity> RegistryEventHandler::onEventRecord(PEVENT_RECORD record)
{
	if (m_artifacts.empty())
	{
		return std::nullopt;
	}

	const EventParser parser(record);

	const std::wstring timestamp = TimeUtils::systemTimeToTimestamp(parser.getEventHeader().TimeStamp);
	const std::uint32_t processPid = parser.getProcessId();
	const std::wstring eventData = L"Time= " + timestamp + L", PID= " + std::to_wstring(processPid);

	const UCHAR eventOpcode = parser.getEventHeader().EventDescriptor.Opcode;

	if (EVENT_TRACE_TYPE_REGOPEN != eventOpcode)
	{
		return std::nullopt;
	}

	const std::string eventType = ArtifactNames[static_cast<size_t>(ArtifactTypes::Registry)];
	const std::wstring wideEventType = StringUtils::stringToWString(eventType);
	const EventProperty* keyNameProperty = parser.getProperty(L"KeyName");
	if (nullptr == keyNameProperty)
	{
		return std::nullopt;
	}

	const std::wstring keyName(keyNameProperty->getUnicodeString());

	{
		AutoCriticalSection autoCriticalSection;

		for (const auto& artifact : this->m_artifacts)
		{
			if (artifact->getType() == ArtifactTypes::Registry)
			{
				std::string registrySubKey = RegistryArtifactUtils::getRegistrySubKey(artifact->getData());
				std::wstring artifactKey = StringUtils::stringToWString(registrySubKey);
				std::wstring trimmedArtifactKey = StringUtils::trimBackslash(artifactKey);
				if (boost::iequals(keyName, artifactKey) || boost::iequals(keyName, trimmedArtifactKey))
				{
					const std::wstring wideTimestamp = TimeUtils::systemTimeToTimestamp(parser.getEventHeader().TimeStamp);
					const std::string timestamp = StringUtils::wstringToString(wideTimestamp);

					const std::string eventType = ArtifactNames[static_cast<size_t>(ArtifactTypes::Registry)];
					const std::uint32_t processPid = parser.getProcessId();

					const std::wstring eventData = L"PID= " + std::to_wstring(processPid) + L" Key= " + keyName;
					const std::string narrowEventData = StringUtils::wstringToString(eventData);

					DEBUG_WTRACE(RegistryEventHandler, "RegistryDetectionEvent: Event timestamp=", wideTimestamp,
						" PID=", processPid, " touch Fake registry value=", artifactKey);

					return EventEntity("Registry Artifact touched", eventType, narrowEventData, timestamp);
				}
			}
		}
	}

	return std::nullopt;
}

```

`Stresser/RegistryEventHandler.h`:

```h
#pragma once
#include "IArtifact.h"
#include "IEtwEventHandler.h"

#include <memory>
#include <vector>


class RegistryEventHandler : public IEtwEventHandler
{
public:
	explicit RegistryEventHandler(std::vector<std::shared_ptr<IArtifact>>& artifacts);

	~RegistryEventHandler() override = default;

	std::optional<EventEntity> onEventRecord(PEVENT_RECORD record) override;

private:
	std::vector<std::shared_ptr<IArtifact>>& m_artifacts;
};

```

`Stresser/RuleController.cpp`:

```cpp
#include "RuleController.h"
#include "InvalidResponseException.h"

RuleController& RuleController::getInstance(AuthorizedHttpRequest& authorizedHttpRequest)
{
	// Keep static instance of this class in order to prevent
	// new creations of this class:
	static RuleController g_instance(authorizedHttpRequest);
	return g_instance;
}

RuleEntity RuleController::getRule(const std::string& ruleId) const
{
	std::stringstream targetPath;
	targetPath << "/rule/";
	targetPath << ruleId;

	const Json responseJson = this->m_authorizedHttpRequest.sendRequest(http::verb::get, targetPath.str(), "");
	if (responseJson.empty())
	{
		throw InvalidResponseException("Server return with no data");
	}

	return RuleEntity::convertFromJson(responseJson);
}

RuleController::RuleController(AuthorizedHttpRequest& authorizedHttpRequest)
	:m_authorizedHttpRequest(authorizedHttpRequest)
{
}

```

`Stresser/RuleController.h`:

```h
#pragma once
#include "RuleEntity.h"
#include "AuthorizedHttpRequest.h"

#include <iostream>

class RuleController
{
public:
	// Disable: cloneable, assignable, movable:
	RuleController(RuleController&) = delete;
	void operator=(const RuleController&) = delete;
	RuleController(RuleController&&) = delete;
	void operator=(const RuleController&&) = delete;

	virtual ~RuleController() = default;

	/*
	* Return the singleton instance of this class.
	* @param authorizedHttpRequest - HTTP request provider.
	* @return Global instance of this class.
	*/
	static RuleController& getInstance(AuthorizedHttpRequest& authorizedHttpRequest);

	/*
		Return the rule data from the server by it's rule ID.
		@param ruleID - The associated ID of the rule.
		@return The corresponding rule data.
	*/
	RuleEntity getRule(const std::string& ruleId) const;

private:
	explicit RuleController(AuthorizedHttpRequest& authorizedHttpRequest);

	AuthorizedHttpRequest& m_authorizedHttpRequest;
};


```

`Stresser/RuleEntity.cpp`:

```cpp
#include "RuleEntity.h"

#include "../Utils/StringUtils.h"

RuleEntity::RuleEntity(std::string id, std::string name, std::string type, std::string data)
	: m_id(id), m_name(name), m_type(type), m_data(data) { }

const std::string& RuleEntity::getId() const
{
	return this->m_id;
}

const std::string& RuleEntity::getName() const
{
	return this->m_name;
}

const std::string& RuleEntity::getType() const
{
	return this->m_type;
}

const std::string& RuleEntity::getData() const
{
	return this->m_data;
}

RuleEntity RuleEntity::convertFromJson(Json jsRule)
{
	return RuleEntity(
		StringUtils::RemoveQuotationMarks(jsRule["id"].dump()),
		StringUtils::RemoveQuotationMarks(jsRule["ruleName"].dump()),
		StringUtils::RemoveQuotationMarks(jsRule["ruleType"].dump()),
		StringUtils::RemoveQuotationMarks(jsRule["ruleData"].dump())
	);
}

Json RuleEntity::convertFromEntity(const RuleEntity& ruleEntity)
{
	Json jsRule;
	jsRule["ruleId"] = ruleEntity.getId();
	jsRule["ruleName"] = ruleEntity.getName();
	jsRule["ruleType"] = ruleEntity.getType();
	jsRule["ruleData"] = ruleEntity.getData();

	return jsRule;
}

std::ostream& operator<<(std::ostream& out, const RuleEntity& ruleEntity)
{
	return out
		<< "ID: " << ruleEntity.m_id
		<< ", Name: " << ruleEntity.m_name
		<< ", Type: " << ruleEntity.m_type
		<< ", Data: " << ruleEntity.m_data;
}

```

`Stresser/RuleEntity.h`:

```h
#pragma once

#include "nlohmann/json.hpp"

#include <iostream>

using Json = nlohmann::json;

/*
 * Represent Rule entity in the application server.
 */
class RuleEntity
{
public:
	explicit RuleEntity(std::string id = "", std::string name = "", std::string type = "", std::string data = "");
	virtual ~RuleEntity() = default;

	const std::string& getId() const;
	const std::string& getName() const;
	const std::string& getType() const;
	const std::string& getData() const;

	static RuleEntity convertFromJson(Json jsRule);
	static Json convertFromEntity(const RuleEntity& ruleEntity);

	friend std::ostream& operator << (std::ostream& out, const RuleEntity& ruleEntity);

private:
	std::string m_id;
	std::string m_name;
	std::string m_type;
	std::string m_data;
};


```

`Stresser/ServerDetails.cpp`:

```cpp
#include "ServerDetails.h"

ServerDetails::ServerDetails(const std::string& userAgent, int httpVersion, const std::string& contentType,
	const std::string& hostname, const std::string& port, const std::string& apiPrefix)
	: m_userAgent(userAgent), m_httpVersion(httpVersion), m_contentType(contentType),
	m_hostname(hostname), m_port(port), m_apiPrefix(apiPrefix)
{
}

std::string ServerDetails::getUserAgent() const
{
	return this->m_userAgent;
}

int ServerDetails::getHttpVersion() const
{
	return this->m_httpVersion;
}

std::string ServerDetails::getContentType() const
{
	return this->m_contentType;
}

std::string ServerDetails::getHostname() const
{
	return this->m_hostname;
}

std::string ServerDetails::getPort() const
{
	return this->m_port;
}

std::string ServerDetails::getApiPrefix() const
{
	return this->m_apiPrefix;
}

std::ostream& operator<<(std::ostream& out, const ServerDetails& serverDetails)
{
	return out
		<< "[Server] Hostname: " << serverDetails.m_hostname
		<< ", User-Agent: " << serverDetails.m_userAgent
		<< ", HTTP-Version: " << serverDetails.m_httpVersion
		<< ", Content-Type: " << serverDetails.m_contentType
		<< ", Port: " << serverDetails.m_port
		<< ", ApiPrefix: " << serverDetails.m_apiPrefix
		<< std::endl;
}

```

`Stresser/ServerDetails.h`:

```h
#pragma once

#include <iostream>

class ServerDetails final
{
public:
	ServerDetails() = default;

	explicit ServerDetails(const std::string& userAgent, int httpVersion, const std::string& contentType, const std::string& hostname,
		const std::string& port, const std::string& apiPrefix);

	~ServerDetails() = default;


	std::string getUserAgent() const;
	int getHttpVersion() const;
	std::string getContentType() const;
	std::string getHostname() const;
	std::string getPort() const;
	std::string getApiPrefix() const;

	friend std::ostream& operator << (std::ostream& out, const ServerDetails& serverDetails);

private:
	std::string m_userAgent;
	int m_httpVersion;
	std::string m_contentType;
	std::string m_hostname;
	std::string m_port;
	std::string m_apiPrefix;
};


```

`Stresser/Stresser.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// BIN
//

FAKE_PROCESS            BIN                     FAKE_PROCESS_RELATIVE_PATH
STRESSER_ENGINE         BIN                     KERNEL_DRIVER_RELATIVE_PATH

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Hebrew (Israel) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_HEB)
LANGUAGE LANG_HEBREW, SUBLANG_DEFAULT
#pragma code_page(1255)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
"resource.h\0"
END

2 TEXTINCLUDE
BEGIN
"#include ""winres.h""\r\n"
"\0"
END

3 TEXTINCLUDE
BEGIN
"\r\n"
"\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Hebrew (Israel) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Stresser/Stresser.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{42cde09c-c687-46b9-a708-b68b2b8f87dd}</ProjectGuid>
    <RootNamespace>Stresser2</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Stresser</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Props\Stresser.General.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Props\Stresser.General.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Props\Stresser.General.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Props\Stresser.General.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\x64\Debug\StresserEngine.sys" />
    <None Include="..\x64\Release\FakeProcess.exe" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ArtifactFactory.cpp" />
    <ClCompile Include="ArtifactManager.cpp" />
    <ClCompile Include="AuthorizedHttpRequest.cpp" />
    <ClCompile Include="AutoEtwTraceSession.cpp" />
    <ClCompile Include="AutoSetLostConnectionEvent.cpp" />
    <ClCompile Include="CollectorManager.cpp" />
    <ClCompile Include="EndpointController.cpp" />
    <ClCompile Include="EndpointEntity.cpp" />
    <ClCompile Include="EtwEventTypes.h" />
    <ClCompile Include="EtwUtils.cpp" />
    <ClCompile Include="EventController.cpp" />
    <ClCompile Include="EventEntity.cpp" />
    <ClCompile Include="EventParser.cpp" />
    <ClCompile Include="FileArtifact.cpp" />
    <ClCompile Include="FileEventHandler.cpp" />
    <ClCompile Include="HttpRequest.cpp" />
    <ClCompile Include="IArtifact.cpp" />
    <ClCompile Include="IArtifactSubscriber.cpp" />
    <ClCompile Include="InvalidResponseException.cpp" />
    <ClCompile Include="IStresserDetector.cpp" />
    <ClCompile Include="IEtwEventHandler.cpp" />
    <ClCompile Include="IEtwEventHandler.h" />
    <ClCompile Include="IEventCollector.h" />
    <ClCompile Include="KernelDetector.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="NetworkConnectionException.cpp" />
    <ClCompile Include="ParsingJsonException.cpp" />
    <ClCompile Include="PolicyController.cpp" />
    <ClCompile Include="PolicyEntity.cpp" />
    <ClCompile Include="PolicyNotifications.cpp" />
    <ClCompile Include="ProcessArtifact.cpp" />
    <ClCompile Include="ProcessDetector.cpp" />
    <ClCompile Include="RegistryArtifact.cpp" />
    <ClCompile Include="RegistryEventHandler.cpp" />
    <ClCompile Include="RuleController.cpp" />
    <ClCompile Include="RuleEntity.cpp" />
    <ClCompile Include="ServerDetails.cpp" />
    <ClCompile Include="EtwManager.cpp" />
    <ClCompile Include="StresserApplication.cpp" />
    <ClCompile Include="UserModeDetector.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ArtifactFactory.h" />
    <ClInclude Include="ArtifactManager.h" />
    <ClInclude Include="ArtifactTypes.h" />
    <ClInclude Include="AuthorizedHttpRequest.h" />
    <ClInclude Include="AutoEtwTraceSession.h" />
    <ClInclude Include="AutoSetLostConnectionEvent.h" />
    <ClInclude Include="CollectorManager.h" />
    <ClInclude Include="Controllers.h" />
    <ClInclude Include="EndpointController.h" />
    <ClInclude Include="EndpointEntity.h" />
    <ClInclude Include="Entities.h" />
    <ClInclude Include="EtwUtils.h" />
    <ClInclude Include="EventController.h" />
    <ClInclude Include="EventEntity.h" />
    <ClInclude Include="EventParser.h" />
    <ClInclude Include="EventProvidersGuid.h" />
    <ClInclude Include="FileArtifact.h" />
    <ClInclude Include="FileEventHandler.h" />
    <ClInclude Include="HttpRequest.h" />
    <ClInclude Include="IArtifact.h" />
    <ClInclude Include="IArtifactSubscriber.h" />
    <ClInclude Include="InvalidResponseException.h" />
    <ClInclude Include="IStresserApplication.h" />
    <ClInclude Include="IStresserDetector.h" />
    <ClInclude Include="KernelDetector.h" />
    <ClInclude Include="NetworkConnectionException.h" />
    <ClInclude Include="ParsingJsonException.h" />
    <ClInclude Include="PolicyController.h" />
    <ClInclude Include="PolicyEntity.h" />
    <ClInclude Include="PolicyNotifications.h" />
    <ClInclude Include="IPolicySubscriber.h" />
    <ClInclude Include="ProcessArtifact.h" />
    <ClInclude Include="ProcessDetector.h" />
    <ClInclude Include="RegistryArtifact.h" />
    <ClInclude Include="RegistryEventHandler.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="RuleController.h" />
    <ClInclude Include="RuleEntity.h" />
    <ClInclude Include="ServerDetails.h" />
    <ClInclude Include="EtwManager.h" />
    <ClInclude Include="StresserApplication.h" />
    <ClInclude Include="UserModeDetector.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Utils\Utils.vcxproj">
      <Project>{bb0147eb-6672-4d50-b5bb-9ebeff8d5ed7}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Stresser.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="..\packages\boost.1.72.0.0\build\boost.targets" Condition="Exists('..\packages\boost.1.72.0.0\build\boost.targets')" />
    <Import Project="..\packages\nlohmann.json.3.9.1\build\native\nlohmann.json.targets" Condition="Exists('..\packages\nlohmann.json.3.9.1\build\native\nlohmann.json.targets')" />
    <Import Project="..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets" Condition="Exists('..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets')" />
    <Import Project="..\packages\Microsoft.Windows.ImplementationLibrary.1.0.210204.1\build\native\Microsoft.Windows.ImplementationLibrary.targets" Condition="Exists('..\packages\Microsoft.Windows.ImplementationLibrary.1.0.210204.1\build\native\Microsoft.Windows.ImplementationLibrary.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\boost.1.72.0.0\build\boost.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\boost.1.72.0.0\build\boost.targets'))" />
    <Error Condition="!Exists('..\packages\nlohmann.json.3.9.1\build\native\nlohmann.json.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\nlohmann.json.3.9.1\build\native\nlohmann.json.targets'))" />
    <Error Condition="!Exists('..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets'))" />
    <Error Condition="!Exists('..\packages\Microsoft.Windows.ImplementationLibrary.1.0.210204.1\build\native\Microsoft.Windows.ImplementationLibrary.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.Windows.ImplementationLibrary.1.0.210204.1\build\native\Microsoft.Windows.ImplementationLibrary.targets'))" />
  </Target>
</Project>
```

`Stresser/Stresser.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="AuthorizedHttpRequest.cpp">
      <Filter>Communication\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HttpRequest.cpp">
      <Filter>Communication\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EndpointController.cpp">
      <Filter>Controllers\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EndpointEntity.cpp">
      <Filter>Entities\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventEntity.cpp">
      <Filter>Entities\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PolicyEntity.cpp">
      <Filter>Entities\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RuleEntity.cpp">
      <Filter>Entities\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ServerDetails.cpp">
      <Filter>Configurations\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PolicyController.cpp">
      <Filter>Controllers\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RuleController.cpp">
      <Filter>Controllers\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoEtwTraceSession.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventParser.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IEtwEventHandler.h">
      <Filter>ETW\Header Files</Filter>
    </ClCompile>
    <ClCompile Include="EtwManager.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EtwEventTypes.h">
      <Filter>ETW\Header Files</Filter>
    </ClCompile>
    <ClCompile Include="IEventCollector.h">
      <Filter>Collectors\Header Files</Filter>
    </ClCompile>
    <ClCompile Include="CollectorManager.cpp">
      <Filter>Collectors\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegistryArtifact.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FileArtifact.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessArtifact.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IArtifact.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ArtifactFactory.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ArtifactManager.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PolicyNotifications.cpp">
      <Filter>PolicyNotifications</Filter>
    </ClCompile>
    <ClCompile Include="IEtwEventHandler.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegistryEventHandler.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IArtifactSubscriber.cpp">
      <Filter>Artifacts\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EtwUtils.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventController.cpp">
      <Filter>Controllers\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IStresserDetector.cpp">
      <Filter>Detectors\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UserModeDetector.cpp">
      <Filter>Detectors\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FileEventHandler.cpp">
      <Filter>ETW\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernelDetector.cpp">
      <Filter>Detectors\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessDetector.cpp">
      <Filter>Detectors\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ParsingJsonException.cpp">
      <Filter>Communication\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NetworkConnectionException.cpp">
      <Filter>Communication\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InvalidResponseException.cpp">
      <Filter>Controllers\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoSetLostConnectionEvent.cpp">
      <Filter>Application\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StresserApplication.cpp">
      <Filter>Application\Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AuthorizedHttpRequest.h">
      <Filter>Communication\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HttpRequest.h">
      <Filter>Communication\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EndpointController.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PolicyController.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EndpointEntity.h">
      <Filter>Entities\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventEntity.h">
      <Filter>Entities\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PolicyEntity.h">
      <Filter>Entities\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RuleEntity.h">
      <Filter>Entities\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ServerDetails.h">
      <Filter>Configurations\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RuleController.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoEtwTraceSession.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventParser.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EtwManager.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CollectorManager.h">
      <Filter>Collectors\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Controllers.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Entities.h">
      <Filter>Entities\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RegistryArtifact.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FileArtifact.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessArtifact.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IArtifact.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArtifactFactory.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArtifactManager.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PolicyNotifications.h">
      <Filter>PolicyNotifications</Filter>
    </ClInclude>
    <ClInclude Include="IPolicySubscriber.h">
      <Filter>PolicyNotifications</Filter>
    </ClInclude>
    <ClInclude Include="RegistryEventHandler.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventProvidersGuid.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IArtifactSubscriber.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArtifactTypes.h">
      <Filter>Artifacts\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EtwUtils.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resource Files</Filter>
    </ClInclude>
    <ClInclude Include="IStresserDetector.h">
      <Filter>Detectors\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventController.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UserModeDetector.h">
      <Filter>Detectors\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FileEventHandler.h">
      <Filter>ETW\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KernelDetector.h">
      <Filter>Detectors\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessDetector.h">
      <Filter>Detectors\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ParsingJsonException.h">
      <Filter>Communication\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NetworkConnectionException.h">
      <Filter>Communication\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InvalidResponseException.h">
      <Filter>Controllers\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoSetLostConnectionEvent.h">
      <Filter>Application\Headers Files</Filter>
    </ClInclude>
    <ClInclude Include="IStresserApplication.h">
      <Filter>Application\Headers Files</Filter>
    </ClInclude>
    <ClInclude Include="StresserApplication.h">
      <Filter>Application\Headers Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Configurations">
      <UniqueIdentifier>{a4c0e17e-0e7a-42da-95d4-8b660b47740b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Communication">
      <UniqueIdentifier>{f1015edf-0047-44d4-8461-4ae534d74a15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Controllers">
      <UniqueIdentifier>{8c957416-eb8d-430c-af55-86825ca5ee2a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Entities">
      <UniqueIdentifier>{ff48e64a-f6e3-4544-9d64-1e301ca08a75}</UniqueIdentifier>
    </Filter>
    <Filter Include="Communication\Header Files">
      <UniqueIdentifier>{b5a9c99b-141b-4f3e-8b49-3f9dd4a93d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Communication\Source Files">
      <UniqueIdentifier>{992f7f89-78de-44bf-aa00-c9ed26760436}</UniqueIdentifier>
    </Filter>
    <Filter Include="Controllers\Source Files">
      <UniqueIdentifier>{25f11d42-c601-437c-8e90-964b08f660d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Controllers\Header Files">
      <UniqueIdentifier>{be1b8ba8-1c90-4b81-a509-d4ff3f16270a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Entities\Source Files">
      <UniqueIdentifier>{eb1167ae-f0b9-4ece-a839-e748acdf8f59}</UniqueIdentifier>
    </Filter>
    <Filter Include="Entities\Header Files">
      <UniqueIdentifier>{62ce8439-6d25-4542-b6f6-512a804e2bf9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Configurations\Source Files">
      <UniqueIdentifier>{a7e8cd9f-cdfe-4ac3-8189-93f65e667898}</UniqueIdentifier>
    </Filter>
    <Filter Include="Configurations\Header Files">
      <UniqueIdentifier>{0469e3dc-38f0-4b80-9512-0cf08195247b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ETW">
      <UniqueIdentifier>{78205740-309a-451c-bd2d-a6a16bd59175}</UniqueIdentifier>
    </Filter>
    <Filter Include="ETW\Header Files">
      <UniqueIdentifier>{2b494fd6-4b1e-4df1-b4bf-7238b792880d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ETW\Source Files">
      <UniqueIdentifier>{527a6985-0908-4fff-b23d-6594964620e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Collectors">
      <UniqueIdentifier>{cfd3cbe9-1b50-4e08-a182-baf99a75c2b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Collectors\Header Files">
      <UniqueIdentifier>{51c6f9e0-aa71-4e33-9555-7b61fb0be504}</UniqueIdentifier>
    </Filter>
    <Filter Include="Collectors\Source Files">
      <UniqueIdentifier>{de3cffc8-122a-4b96-b190-b20d694b7f0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Artifacts">
      <UniqueIdentifier>{9a0d5091-b879-4803-a832-e496b23016ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Artifacts\Header Files">
      <UniqueIdentifier>{cb090f2b-f0e2-44a0-8a72-82a27ae7b290}</UniqueIdentifier>
    </Filter>
    <Filter Include="Artifacts\Source Files">
      <UniqueIdentifier>{3efedbac-158a-40e2-ae6e-6504a3526100}</UniqueIdentifier>
    </Filter>
    <Filter Include="PolicyNotifications">
      <UniqueIdentifier>{c5ce2fbe-7a94-47e4-ae25-9f8864b7faab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{c64bfbd0-a812-4de3-a88f-36780b2d940d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Detectors">
      <UniqueIdentifier>{3ca5a362-60f1-44d5-b065-1f019f80e138}</UniqueIdentifier>
    </Filter>
    <Filter Include="Detectors\Header Files">
      <UniqueIdentifier>{b8dee090-8b07-4b76-8330-e8b12854cee7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Detectors\Source Files">
      <UniqueIdentifier>{b2b56f25-3945-42bc-8579-b3d9b9d20b36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Application">
      <UniqueIdentifier>{4919a036-2a97-4d71-8a9d-2be05a3685c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Application\Source Files">
      <UniqueIdentifier>{145d5036-064e-4c2e-a259-e0c7b0c803c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Application\Headers Files">
      <UniqueIdentifier>{37832c84-b8b9-4128-b854-1e9c2316647c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
    <None Include="..\x64\Release\FakeProcess.exe">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\x64\Debug\StresserEngine.sys">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Stresser.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Stresser/StresserApplication.cpp`:

```cpp
#include "StresserApplication.h"
#include "Controllers.h"
#include "NetworkConnectionException.h"

#include "../Utils/EventsNames.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/SehTranslatorGuard.h"
#include "../Utils/LocalPcUtils.h"

StresserApplication::StresserApplication(ServerDetails serverDetails)
	: m_shutdownEvent(STOP_STRESSER),
	m_lostConnection(LOST_CONNECTION_EVENT_NAME)
{
	this->m_artifactManager.reset(new ArtifactManager());

	// Define communication object:
	AuthorizedHttpRequest& authorizedHttpRequest = AuthorizedHttpRequest::getInstance(serverDetails, m_shutdownEvent.get());

	this->initializeEndpoint(authorizedHttpRequest);

	this->initializeDetectors(authorizedHttpRequest);

	this->startNetworkConnectionMonitoringThread();
}

StresserApplication::~StresserApplication()
{
	try
	{
		this->StresserApplication::stop();
		for (auto& detector : this->m_detectors)
		{
			detector->stop();
		}
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserApplication, "Exception in destructor\n", exception.what());
	}
	catch (...)
	{
		DEBUG_TRACE(StresserApplication, "Undefined exception in destructor");
	}
}

void StresserApplication::initializeEndpoint(AuthorizedHttpRequest& authorizedHttpRequest)
{
	// Define application controllers:
	EndpointController& endpointController = EndpointController::getInstance(authorizedHttpRequest);
	PolicyController& policyController = PolicyController::getInstance(authorizedHttpRequest);
	RuleController& ruleController = RuleController::getInstance(authorizedHttpRequest);

	// Register new endpoint in the server:
	EndpointEntity endpoint = endpointController.createEndpoint();
	std::string endpointId = endpoint.GetID();

	// Start token manager:
	authorizedHttpRequest.startTokenRefresherThread(endpointId, endpoint.GetAPIKey());

	this->m_policyNotifications = std::make_unique<PolicyNotifications>(endpointId, this->m_shutdownEvent.get(), endpointController, policyController, ruleController);

	this->m_policyNotifications->subscribe(this->m_artifactManager.get());
}

void StresserApplication::initializeDetectors(AuthorizedHttpRequest& authorizedHttpRequest)
{
	EventController& eventController = EventController::getInstance(authorizedHttpRequest);

	std::unique_ptr<UserModeDetector> userModeDetector(new UserModeDetector(eventController));
	std::unique_ptr<KernelDetector> kernelDetector(new KernelDetector(eventController));

	this->m_artifactManager->subscribe(userModeDetector.get());
	this->m_artifactManager->subscribe(kernelDetector.get());

	this->m_detectors.push_back(std::move(userModeDetector));
	this->m_detectors.push_back(std::move(kernelDetector));
}

void StresserApplication::startNetworkConnectionMonitoringThread()
{
	this->m_networkConnectionMonitorThread = StandardThread([this]()
		{
			this->networkConnectionMonitor();
		});
}

void StresserApplication::networkConnectionMonitor() const
{
	SehTranslatorGuard sehTranslatorGuard;

	constexpr int SLEEP_BETWEEN_RECONNECTION = 30 * 1000;
	constexpr int TRIGGER_EVENTS_COUNT = 2;

	HANDLE triggerEvents[TRIGGER_EVENTS_COUNT] =
	{
		this->m_shutdownEvent.get(),
		this->m_lostConnection.get()
	};

	do
	{
		const DWORD waitResult = WaitForMultipleObjects(TRIGGER_EVENTS_COUNT, triggerEvents, FALSE, INFINITE);
		if (WAIT_OBJECT_0 >= waitResult)
		{
			break;
		}

		if (this->m_shutdownEvent.isSignaled())
		{
			// Signaled to stop the application, exit from the thread
			break;
		}

		if (!this->m_lostConnection.isSignaled())
		{
			// No need to reconnect, network connection available
			continue;
		}

		DEBUG_TRACE(StresserApplication::networkConnectionMonitor, "Try reconnecting to server");

		try
		{
			this->reconnect();
			this->m_lostConnection.resetEvent();

			DEBUG_TRACE(StresserApplication::networkConnectionMonitor, "Successfully reconnected to server");
		}
		catch (const NetworkConnectionException&)
		{
			DEBUG_TRACE(StresserApplication::networkConnectionMonitor, "Could not reconnect yet, network is unavailable");
			Sleep(SLEEP_BETWEEN_RECONNECTION);
		}
		catch (const std::exception& exception)
		{
			DEBUG_TRACE(StresserApplication::networkConnectionMonitor, "Exception thrown in reconnect, Error: ", exception.what());
		}

	} while (true);
}

void StresserApplication::reconnect() const
{
	if (!LocalPcUtils::doesNetworkConnectionAvailable())
	{
		throw NetworkConnectionException("Network connection doesn't available");
	}

	AuthorizedHttpRequest& authorizedHttpRequest = AuthorizedHttpRequest::getInstance();
	EndpointController& endpointController = EndpointController::getInstance(authorizedHttpRequest);

	// Re-register the endpoint in the server:
	EndpointEntity endpoint = endpointController.createEndpoint();
	const std::string endpointId = endpoint.GetID();

	// Restart token refreshing:
	authorizedHttpRequest.startTokenRefresherThread(endpointId, endpoint.GetAPIKey());

	// Reinitialize policy fetching:
	this->m_policyNotifications->resetEndpointId(endpointId);
	this->m_policyNotifications->startFetchPolicyThread();
}

void StresserApplication::start()
{
	try
	{
		for (auto& detector : this->m_detectors)
		{
			detector->start();
		}
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserApplication, "Exception was thrown in stresser start", exception.what());
		throw;
	}
}

void StresserApplication::stop()
{
	try
	{
		this->m_shutdownEvent.setEvent();
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserApplication, "Exception was thrown in stresser stop", exception.what());
		throw;
	}
}

void StresserApplication::pause()
{
	try
	{
		for (auto& detector : this->m_detectors)
		{
			detector->stop();
		}
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserApplication, "Exception was thrown in stresser pause", exception.what());
		throw;
	}
}

void StresserApplication::waitForShutdown()
{
	try
	{
		if (WAIT_OBJECT_0 != this->m_shutdownEvent.wait())
		{
			throw std::runtime_error("Unexpected error with the shutdown wait!");
		}
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserApplication, "Exception was thrown in stresser waitForShutdown", exception.what());
		throw;
	}
}

```

`Stresser/StresserApplication.h`:

```h
#pragma once
#include "IStresserApplication.h"
#include "ServerDetails.h"
#include "ArtifactManager.h"
#include "PolicyNotifications.h"
#include "KernelDetector.h"
#include "UserModeDetector.h"

#include "../Utils/StandardThread.h"

class StresserApplication : public IStresserApplication
{
public:
	explicit StresserApplication(ServerDetails serverDetails);

	StresserApplication(const StresserApplication&) = delete;

	StresserApplication(StresserApplication&&) = delete;

	StresserApplication& operator=(StresserApplication&&) = delete;

	~StresserApplication() override;

	void start() override;

	void stop() override;

	void pause() override;

	void waitForShutdown() override;

private:
	void initializeEndpoint(AuthorizedHttpRequest& authorizedHttpRequest);
	void initializeDetectors(AuthorizedHttpRequest& authorizedHttpRequest);

	void startNetworkConnectionMonitoringThread();

	void networkConnectionMonitor() const;

	void reconnect() const;

	WindowsEvent m_shutdownEvent;
	WindowsEvent m_lostConnection;
	std::unique_ptr<PolicyNotifications> m_policyNotifications;
	std::unique_ptr<ArtifactManager> m_artifactManager;
	std::vector<std::unique_ptr<IStresserDetector>> m_detectors;
	StandardThread m_networkConnectionMonitorThread;
};


```

`Stresser/UserModeDetector.cpp`:

```cpp
#include "UserModeDetector.h"
#include "FileEventHandler.h"
#include "RegistryEventHandler.h"
#include "../Utils/DebugPrint.h"

UserModeDetector::UserModeDetector(const EventController& eventController)
	: IStresserDetector(eventController)
{
	DEBUG_WTRACE(UserModeDetector, "Initiating user mode detector");

	this->m_etwManager.reset(new EtwManager());
	this->m_etwManager->setCallback([this](EventEntity& eventEntity)
		{
			this->sendEvent(eventEntity);
		});

	const std::shared_ptr<RegistryEventHandler> registryEventHandler(new RegistryEventHandler(this->m_artifactsToReport));
	const std::shared_ptr<FileEventHandler> fileEventHandler(new FileEventHandler(this->m_artifactsToReport));

	this->m_etwManager->registerEventHandle(registryEventHandler);
	this->m_etwManager->registerEventHandle(fileEventHandler);
}

void UserModeDetector::start()
{
	DEBUG_WTRACE(UserModeDetector, "Start user mode detector");

	this->m_etwManager->start();
}

void UserModeDetector::stop()
{
	DEBUG_WTRACE(UserModeDetector, "Stop user mode detector");

	this->m_etwManager->stop();
}

```

`Stresser/UserModeDetector.h`:

```h
#pragma once
#include "IArtifactSubscriber.h"
#include "IStresserDetector.h"
#include "EtwManager.h"

class UserModeDetector : public IStresserDetector, public IArtifactSubscriber
{
public:
	explicit UserModeDetector(const EventController& eventController);

	void start() override;
	void stop() override;

private:
	std::unique_ptr<EtwManager> m_etwManager;
};


```

`Stresser/main.cpp`:

```cpp
#include "Controllers.h"
#include "ServerDetails.h"
#include "AuthorizedHttpRequest.h"

#include "UserModeDetector.h"

#include "../Utils/AutoCriticalSection.h"
#include "../Utils/DebugPrint.h"
#include "../Utils/SehTranslatorGuard.h"

#include "nlohmann/json.hpp"

#include <iostream>

#include "KernelDetector.h"
#include "StresserApplication.h"

#include <Windows.h>

std::shared_ptr<IStresserApplication> g_application;

BOOL consoleHandler(const DWORD signal)
{
	if (CTRL_C_EVENT == signal)
	{
		AutoCriticalSection autoCriticalSection;

		DEBUG_TRACE(StresserMainThread, "Counter CTRL + C event, signaling to stop all functionality");

		g_application->stop();

		return true;
	}
	return false;
}

int wmain(int argc, PWCHAR argv[])
{
	try
	{
		SehTranslatorGuard sehTranslatorGuard;

		const ServerDetails serverDetails("Stresser Client / 1.0", 11, "application/json", "stresser-project.herokuapp.com", "80", "/api");

		g_application = std::make_unique<StresserApplication>(serverDetails);

		if (!SetConsoleCtrlHandler(consoleHandler, TRUE))
		{
			throw std::runtime_error("Could not set console handler");
		}

		g_application->start();

		g_application->waitForShutdown();
	}
	catch (const std::exception& exception)
	{
		DEBUG_TRACE(StresserMainThread, exception.what());
		return 1;
	}
	catch (...)
	{
		DEBUG_TRACE(StresserMainThread, "Unknown exeption");
		return 1;
	}

	DEBUG_TRACE(StresserMainThread, "Stresser shuting down...");
	return 0;
}

```

`Stresser/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="boost" version="1.72.0.0" targetFramework="native" />
  <package id="boost_date_time-vc142" version="1.72.0.0" targetFramework="native" />
  <package id="Microsoft.Windows.ImplementationLibrary" version="1.0.210204.1" targetFramework="native" />
  <package id="nlohmann.json" version="3.9.1" targetFramework="native" />
</packages>
```

`Stresser/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Stresser.rc
//
#define FAKE_PROCESS                    4
#define STRESSER_ENGINE                 5

```

`StresserEngine/AutoBuffer.h`:

```h
#pragma once

#include <ntifs.h>

template<ULONG Tag, POOL_TYPE PoolType = PagedPool>
class AutoBuffer final
{
public:
	explicit AutoBuffer(const SIZE_T size)
		: m_size(size)
	{
		this->allocateBuffer();
	}

	// Disable copyable, movable, assignable:
	AutoBuffer(AutoBuffer&) = delete;
	AutoBuffer& operator=(AutoBuffer&) = delete;

	// Allow movable:
	AutoBuffer(AutoBuffer&& other)
	{
		this->m_data = other.m_data;
		this->m_size = other.m_size;

		other.m_data = nullptr;
		other.m_size = 0;
	}

	AutoBuffer& operator=(AutoBuffer&& other)
	{
		this->release();

		this->m_data = other.m_data;
		this->m_size = other.m_size;

		other.m_data = nullptr;
		other.m_size = 0;
	}

	/* Destructor */
	~AutoBuffer()
	{
		__try
		{
			this->release();
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			KdPrint(("Exception was thrown in AutoUnicodeString destructor\n"));
		}
	}

	/* Return the data member. */
	PVOID get() const
	{
		return this->m_data;
	}

	/* Return the size of the allocated buffer for the data member. */
	SIZE_T size() const
	{
		return this->size();
	}

private:
	/* Allocate memory for the data member. */
	void allocateBuffer()
	{
		if (0 >= this->m_size)
		{
			return;
		}

		this->m_data = ExAllocatePoolWithTag(PoolType, this->m_size, Tag);
		if (nullptr == this->m_data)
		{
			KdPrint(("Could not allocate memory in size %d\n", this->m_size));
			return;
		}

		RtlZeroMemory(this->m_data, this->m_size);
	}

	/* Release memory used for the data member. */
	void release()
	{
		if (nullptr != this->m_data)
		{
			ExFreePoolWithTag(this->m_data, Tag);

			this->m_data = nullptr;
			this->m_size = 0;
		}
	}

	SIZE_T m_size;
	PVOID m_data;
};

```

`StresserEngine/AutoLock.h`:

```h
#pragma once

/*
 * Represent to functions that lock should implement.
 */
struct LockTraits
{
	void lock()
	{
	}

	void unlock()
	{
	}
};

template<typename Lock = LockTraits>
struct AutoLock
{
	AutoLock(Lock& lock)
		: m_lock(lock)
	{
		this->m_lock.lock();
	}

	~AutoLock()
	{
		this->m_lock.unlock();
	}

private:
	Lock& m_lock;
};
```

`StresserEngine/AutoObjectDereference.h`:

```h
#pragma once

#include <ntifs.h>

template<typename Object>
class AutoObjectDereference
{
public:
	explicit AutoObjectDereference(Object object = nullptr)
		: m_object(object)
	{
	}

	// Disable copyable:
	AutoObjectDereference(AutoObjectDereference& other) = delete;
	AutoObjectDereference& operator=(AutoObjectDereference& other) = delete;

	/* Move constructor */
	AutoObjectDereference(AutoObjectDereference&& other) noexcept
	{
		this->m_object = other.m_object;
		other.m_object = nullptr;
	}

	/* Move assignment */
	AutoObjectDereference& operator=(AutoObjectDereference&& other) noexcept
	{
		this->dereference();

		this->m_object = other.m_object;
		other.m_object = nullptr;
		return *this;
	}

	/* Destructor */
	~AutoObjectDereference()
	{
		__try
		{

			this->dereference();
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			KdPrint(("Exception was thrown in ObDereferenceObject destructor"));
		}
	}

	/* Return the object member. */
	Object& get()
	{
		return this->m_object;
	}

	/* Return if the object member address is valid. */
	bool isValid()
	{
		return nullptr != this->m_object;
	}

private:
	/* Decrease the reference count to the object member. */
	void dereference()
	{
		if (nullptr != this->m_object)
		{
			ObDereferenceObject(m_object);
		}
	}

	Object m_object;
};
```

`StresserEngine/DriverConfiguration.h`:

```h
#pragma once

#include "String.h"
#include "AutoBuffer.h"

#define DRIVER_PREFIX "Stresser Engine: "
#define DRIVER_TAG 'Strs'
#define DEVICE_NAME L"\\Device\\StresserEngine"
#define SYMBOLIC_LINK_PATH L"\\??\\StresserEngine"
#define DRIVER_ALTITUDE L"7657.124"

using StresserString = String<DRIVER_TAG, PagedPool>;
using StresserBuffer = AutoBuffer<DRIVER_TAG, PagedPool>;
```

`StresserEngine/Event.cpp`:

```cpp
#include "Event.h"
#include "HelperMacros.h"
#include "Move.h"

Event::Event()
	: m_event(nullptr)
{
}

Event::Event(StresserString eventName)
	: m_event(nullptr), m_eventName(move(eventName))
{
	Value<bool, NTSTATUS> result = this->open(eventName);
	if (result.isError())
	{
		PRINT_ON_STATUS_FAILURE(result.getError(), "Could not open event");
	}
}

Event::~Event()
{
	__try
	{
		auto result = this->close();
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		LOG_MESSAGE("exception was thrown in destructor");
	}
}

Event::Event(Event&& other) noexcept
{
	this->m_event = other.m_event;
	this->m_eventName = move(other.m_eventName);

	other.m_event = nullptr;
	other.m_eventName.release();
}

Event& Event::operator=(Event&& other) noexcept
{
	Value<bool, NTSTATUS> result = this->close();
	if (result.isError())
	{
		PRINT_ON_STATUS_FAILURE(result.getError(), "could not close current event object");
		return *this;
	}

	this->m_event = other.m_event;
	this->m_eventName = move(other.m_eventName);

	other.m_event = nullptr;
	other.m_eventName.release();

	return *this;
}

Value<bool, NTSTATUS> Event::open(StresserString eventName)
{
	this->m_eventName = move(eventName);
	RETURN_STATUS_ON_CONDITION(this->m_eventName.empty(), "got empty event name", STATUS_INVALID_PARAMETER);

	const StresserBuffer eventNameBuffer(sizeof(UNICODE_STRING));

	const PUNICODE_STRING eventNameUnicodeString =
		this->m_eventName.getUnicodeString(static_cast<PUNICODE_STRING>(eventNameBuffer.get()));

	OBJECT_ATTRIBUTES eventAttribute{ 0 };
	InitializeObjectAttributes(
		&eventAttribute,
		eventNameUnicodeString,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		nullptr,
		nullptr
	);

	const NTSTATUS status = ZwOpenEvent(&this->m_event, EVENT_MODIFY_STATE, &eventAttribute);
	RETURN_ON_STATUS_FAILURE(status, "could not open handle to event object");

	if (nullptr == this->m_event)
	{
		return false;
	}

	return true;
}

Value<bool, NTSTATUS> Event::close()
{
	if (nullptr == this->m_event)
	{
		return false;
	}

	const NTSTATUS status = ZwClose(this->m_event);
	RETURN_ON_STATUS_FAILURE(status, "could not close event handle");

	this->m_event = nullptr;

	return true;
}

Value<bool, NTSTATUS> Event::set() const
{
	if (nullptr == this->m_event)
	{
		return false;
	}

	LONG previousStatus = 0;

	const NTSTATUS status = ZwSetEvent(this->m_event, &previousStatus);
	RETURN_ON_STATUS_FAILURE(status, "could not set the event");

	return true;
}

void Event::release()
{
	this->m_event = nullptr;
}

const HANDLE& Event::get() const
{
	return this->m_event;
}

const StresserString& Event::getEventName() const
{
	return this->m_eventName;
}

```

`StresserEngine/Event.h`:

```h
#pragma once

#include "DriverConfiguration.h"
#include "GenericHandle.h"
#include "Value.h"

class Event final
{
public:
	Event();

	explicit Event(StresserString eventName);

	~Event();

	Event(Event&& other) noexcept;
	Event& operator=(Event&& other) noexcept;

	Value<bool, NTSTATUS> open(StresserString eventName);

	Value<bool, NTSTATUS> close();

	Value<bool, NTSTATUS> set() const;

	void release();

	const HANDLE& get() const;

	const StresserString& getEventName() const;

private:
	HANDLE m_event;
	StresserString m_eventName;
};


```

`StresserEngine/FastMutex.cpp`:

```cpp
#include "FastMutex.h"

FastMutex::FastMutex(const FAST_MUTEX& mutex, bool autoInitialize)
	: m_mutex(mutex)
{
	if (autoInitialize)
	{
		this->init();
	}
}

void FastMutex::init()
{
	ExInitializeFastMutex(&m_mutex);
}

void FastMutex::lock()
{
	ExAcquireFastMutex(&m_mutex);
}

void FastMutex::unlock()
{
	ExReleaseFastMutex(&m_mutex);
}


```

`StresserEngine/FastMutex.h`:

```h
#pragma once

#include "AutoLock.h"
#include <ntifs.h>

class FastMutex : LockTraits
{
public:
	FastMutex() = default;

	explicit FastMutex(const FAST_MUTEX& mutex, bool autoInitialize = false);

	void init();

	void lock();

	void unlock();

private:
	FAST_MUTEX m_mutex;
};

```

`StresserEngine/GenericHandle.h`:

```h
#pragma once

#include <ntifs.h>

/* Represent the valid traits for using GenericHandle object. */
struct CommonTraits
{
	static void close(const HANDLE handle)
	{
		UNREFERENCED_PARAMETER(handle);
	}

	static bool isValid(const HANDLE handle)
	{
		UNREFERENCED_PARAMETER(handle);
		return false;
	}

	static HANDLE invalidHandle()
	{
		return nullptr;
	}
};

/*
 * Define object for managing handle safely.
 * Credit for @Zodiacon: https://github.com/zodiacon/ndcoslo2019/tree/master/CppKernel
 */
template<typename T, typename Traits = CommonTraits>
class GenericHandle final
{
public:
	explicit GenericHandle(T handle = Traits::invalidHandle(), const bool owner = true)
		: m_handle(handle), m_owner(owner)
	{
	}

	/* Destructor */
	~GenericHandle()
	{
		__try
		{
			this->reset();
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			KdPrint(("Exception accrued in GenericHandle destructor\n"));
		}
	}

	// Disable copyable:
	GenericHandle(GenericHandle&) = delete;
	GenericHandle& operator=(const GenericHandle&) = delete;

	/* Move constructor */
	GenericHandle(GenericHandle&& other) noexcept
	{
		this->m_handle = other.m_handle;
		this->m_owner = other.m_owner;
		other.m_handle = nullptr;
	}

	/* Move assignment */
	GenericHandle& operator=(GenericHandle&& other) noexcept
	{
		if (this != &other)
		{
			this->reset();
			this->m_handle = other.m_handle;
			this->m_owner = other.m_owner;
			other.m_handle = nullptr;
		}
		return *this;
	}

	/* Equality operator. */
	bool operator==(const GenericHandle& other)
	{
		return this->m_handle == other.m_handle;
	}

	/* Function like call to return the object handle member. */
	operator T() const
	{
		return this->get();
	}

	/* Return the handle member. */
	T get() const
	{
		return this->m_handle;
	}

	/* Verify if the handle member is valid. */
	operator bool const()
	{
		return Traits::isValid(this->m_handle);
	}

	/* Return the address of the handle member. */
	T* getAddressOf()
	{
		NT_ASSERT(!Traits::isValid(this->m_handle));
		return &this->m_handle;
	}

	/* Close the current handle and manage another one. */
	void reset(T handle = nullptr, bool owner = true)
	{
		if (this->m_owner && this->m_handle)
		{
			Traits::close(this->m_handle);
		}

		this->m_handle = handle;
		this->m_owner = owner;
	}

	/*
	 * Stop manage the handle member.
	 * @note The handle would not be release in class destruction.
	 */
	T detach()
	{
		auto handle = this->m_handle;
		this->m_handle = nullptr;
		return handle;
	}

private:
	T m_handle;
	bool m_owner;
};


/* Represent traits for simple kernel handle. */
struct KernelHandleTraits : CommonTraits
{
	static void close(const HANDLE handle)
	{
		if (nullptr != handle)
		{
			ZwClose(handle);
		}
	}

	static bool isValid(const HANDLE handle)
	{
		return handle != nullptr;
	}

	static HANDLE invalidHandle()
	{
		return nullptr;
	}
};

/* Define smart pointer for kernel space. */
using AutoKernelHandle = GenericHandle<HANDLE, KernelHandleTraits>;
```

`StresserEngine/HelperMacros.h`:

```h
#pragma once

#include "DriverConfiguration.h"

#include <ntifs.h>

/*
	Verify if the given status is NT_SUCCESS and prints to
	corresponding message.
 */
#define PRINT_STATUS_SUCCESS_FAILURE(status, successMsg, failureMsg)	\
do {																	\
	if(NT_SUCCESS(status))												\
	{																	\
		KdPrint((DRIVER_PREFIX CURRENT_FILE ": " successMsg "\n"));						\
	}																	\
	else																\
	{																	\
		KdPrint((DRIVER_PREFIX CURRENT_FILE failureMsg " (0x%08X)\n", status));		\
	}																	\
} while (false);

#define PRINT_ON_STATUS_FAILURE(status, failureMsg)	\
do {												\
	if(!NT_SUCCESS(status))							\
	{												\
		KdPrint((DRIVER_PREFIX CURRENT_FILE failureMsg "\n"));	\
	}												\
} while (false);

 /*
	 Verify if the given status is NT_SUCCESS and prints to
	 corresponding message.
  */
#define PRINT_IF_CONDITION(condition, successMsg, failureMsg)		\
do {																	\
	if(condition)														\
	{																	\
		KdPrint((DRIVER_PREFIX CURRENT_FILE successMsg "\n"));						\
	}																	\
	else																\
	{																	\
		KdPrint((DRIVER_PREFIX CURRENT_FILE failureMsg " (0x%08X)\n", status));		\
	}																	\
} while (false);

  /*
	 Verify is the given status isn't NT_SUCCESS and break.
  */
#define BREAK_ON_FAILURE(status) if(!NT_SUCCESS(status)) { break; }

#define RETURN_ON_STATUS_FAILURE(status, failureMsg)				\
do {																\
	if(!NT_SUCCESS(status))											\
	{																\
		KdPrint((DRIVER_PREFIX CURRENT_FILE failureMsg " (0x%08X)\n", status));	\
		return status;												\
	}																\
} while (false);

  /*

   */
#define RETURN_STATUS_ON_CONDITION(condition, message, status)			\
do {															\
	if(condition)												\
	{															\
		KdPrint((DRIVER_PREFIX CURRENT_FILE message " (0x%08X)\n", status));	\
		return status;											\
	}															\
} while (false);

   /*

	*/
#define RETURN_ON_CONDITION(condition)	\
do {									\
	if(condition)						\
	{									\
		return;							\
	}									\
} while (false);

	/*

	 */
#define PRINT_MESSAGE_AND_RETURN_ON_CONDITION(condition, message)	\
do {									\
	if(condition)						\
	{									\
		KdPrint((DRIVER_PREFIX CURRENT_FILE message "\n"));	\
		return;							\
	}									\
} while (false);

	 /*
	  *
	  */
#define CURRENT_FILE __FILE__

	  /*
		  Return the token himself.
		  https://stackoverflow.com/q/55636670
	  */
#define STRINGIFY(x) #x

	  /*
	   *
	   */
#define LOG_MESSAGE(msg)							\
do {												\
	KdPrint((DRIVER_PREFIX CURRENT_FILE ": " msg "\n"));	\
} while (false);

	   /*
		*
		*/
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
```

`StresserEngine/IrpUtils.cpp`:

```cpp
#include "IrpUtils.h"

bool IrpUtils::isValidInputBuffer(PIO_STACK_LOCATION StackLocation, ULONGLONG validSize)
{
	auto& deviceIoControl = StackLocation->Parameters.DeviceIoControl;

	if (validSize > deviceIoControl.InputBufferLength)
	{
		return false;
	}

	return true;
}

bool IrpUtils::isValidOutputBuffer(PIO_STACK_LOCATION StackLocation, ULONGLONG validSize)
{
	auto& deviceIoControl = StackLocation->Parameters.DeviceIoControl;

	if (validSize > deviceIoControl.OutputBufferLength)
	{
		return false;
	}

	return true;
}

```

`StresserEngine/IrpUtils.h`:

```h
#pragma once

#include <ntifs.h>

class IrpUtils final
{
public:
	/* Check if the input buffer size is not smaller than required. */
	static bool isValidInputBuffer(_In_ PIO_STACK_LOCATION StackLocation, _In_ ULONGLONG validSize);

	/* Check if the output buffer size is not smaller than required. */
	static bool isValidOutputBuffer(_In_ PIO_STACK_LOCATION StackLocation, _In_ ULONGLONG validSize);
};


```

`StresserEngine/LinkedList.h`:

```h
#pragma once

#include "AutoLock.h"
#include "FastMutex.h"

/*
	Linked list data structure.
	Accept allocated item and mange it under the linked list data structure.
	@note Assuming item in the linked list contains field with LIST_ENTRY member named "Entry".
	@note Make sure to free the memory.
 */
template<typename T, typename Lock = FastMutex>
class LinkedList
{
public:
	LinkedList()
		: m_head{ nullptr, nullptr }, m_size(0)
	{
		this->init();
	}

	/* Initialize the linked list and the private lock. */
	void init()
	{
		InitializeListHead(&m_head);
		m_lock.init();
	}

	/* Insert allocated item to tail of the linked list. */
	void insertTail(T* item)
	{
		AutoLock locker(m_lock);
		InsertTailList(&m_head, &item->Entry);
		this->increaseSize();
	}

	/* Insert allocated memory to the head of the linked list. */
	void insertHead(T* item)
	{
		AutoLock locker(m_lock);
		InsertHeadList(&m_head, &item->Entry);
		this->increaseSize();
	}

	/* Remove item from the linked list, without free it's memory. */
	T* removeHead()
	{
		AutoLock locker(m_lock);
		auto* const entry = RemoveHeadList(&m_head);
		this->decreaseSize();
		return CONTAINING_RECORD(entry, T, Entry);
	}

	/* Get the item in the head of the linked list. */
	T* getHead()
	{
		AutoLock locker(m_lock);
		auto* const entry = m_head.Flink;
		return CONTAINING_RECORD(entry, T, Entry);
	}

	ULONG size()
	{
		AutoLock locker(m_lock);
		return this->m_size;
	}

private:
	void increaseSize()
	{
		++this->m_size;
	}

	void decreaseSize()
	{
		this->m_size = (this->m_size > 0 ? --this->m_size : 0);
	}

	LIST_ENTRY m_head;
	Lock m_lock;
	ULONG m_size;
};

```

`StresserEngine/Memory.cpp`:

```cpp
#include "Memory.h"
#include "DriverConfiguration.h"

void* __cdecl operator new(size_t size, POOL_TYPE type, ULONG tag)
{
	PVOID buffer = nullptr;

	if (0 == tag)
	{
		// Kernel allocating default tag:
		buffer = ExAllocatePool(type, size);
	}
	else
	{
		buffer = ExAllocatePoolWithTag(type, size, tag);
	}

	if (nullptr == buffer)
	{
		KdPrint((DRIVER_PREFIX "Failed to allocate %u bytes\n", size));
	}

	return buffer;

	// Calls the object constructor automatically
}

void* __cdecl operator new(size_t size, PVOID pointer)
{
	UNREFERENCED_PARAMETER(size);

	return pointer;

	// Calls the object constructor automatically
}

void operator delete(PVOID pointer, size_t size)
{
	UNREFERENCED_PARAMETER(size);
	ExFreePool(pointer);
}

```

`StresserEngine/Memory.h`:

```h
#pragma once

#include <ntifs.h>

/*
 * Overloading the new operator.
 * @note The first parameter must be size_t size.
 * @note Using the new operator will call the object constructor automatically.
 * @usage:
 *		auto data = new (NonPagedPool, YOUR_DRIVER_TAG) MyDataObject;
 */
void* __cdecl operator new(size_t size, POOL_TYPE type, ULONG tag = 0);

/*
 * Overloading placement new operator.
 * Get allocated memory (not allocating by itself) and construct the object in it.
 * @note JUST constructing the object in that memory.

 * @usage:
 *		auto buffer = (..)ExAllocatePoolWithTag(..);	// allocated in some way
 *		auto data = new (buffer) MyDataObject;			// redundant
 *		new(buffer) MyDataObject;						// the right way
 *
 * @note DO NOT call the delete operator on the buffer, because you cannot know
 * how it got allocated in first place. instead call the object destructor explicitly:
 *		data->~MyDataObject();
 */
void* __cdecl operator new(size_t size, PVOID pointer);

/*
 * Overloading the delete operator.
 */
void operator delete(PVOID pointer, size_t size);
```

`StresserEngine/Move.h`:

```h
#pragma once

// STRUCT TEMPLATE remove_reference
template <class _Ty>
struct remove_reference
{
	using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&>
{
	using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&&>
{
	using type = _Ty;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;


// FUNCTION TEMPLATE move
template <class _Ty>
constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
	return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```

`StresserEngine/ObjectNotification.cpp`:

```cpp
#include "ObjectNotification.h"
#include "DriverConfiguration.h"
#include "ProcessUtils.h"
#include "StresserEngine.h"
#include "AutoLock.h"

OB_PREOP_CALLBACK_STATUS StresserEngineObPreOpCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	UNREFERENCED_PARAMETER(OperationInformation);

	return OB_PREOP_SUCCESS;
}

void StresserEngineObPostOpCallback(PVOID RegistrationContext, POB_POST_OPERATION_INFORMATION OperationInformation)
{
	// Doesn't interfere System operations:
	RETURN_ON_CONDITION(OperationInformation->KernelHandle);

	// Get driver's specific context:
	auto* notificationContext = static_cast<PNotificationContext>(RegistrationContext);
	RETURN_ON_CONDITION(nullptr == notificationContext);

	// Get data corresponding to the requested process:
	auto* const requestedProcess = static_cast<PEPROCESS>(OperationInformation->Object);
	auto requestedProcessPid = ProcessUtils::getPidFromProcess(requestedProcess);

	PRINT_MESSAGE_AND_RETURN_ON_CONDITION(requestedProcessPid.isError(), STRINGIFY(StresserEngineObPostOpCallback) " invalid PID");

	bool doesFakeProcess = false;

	{
		AutoLock lock(notificationContext->mutex);

		auto* fakeProcessIds = notificationContext->fakeProcessIds;
		RETURN_ON_CONDITION(nullptr == fakeProcessIds);

		for (ULONG i = 0; i < fakeProcessIds->size(); ++i)
		{
			const FakeProcessId* fakeProcessId = fakeProcessIds->getAt(i);
			if (requestedProcessPid.getValue() == fakeProcessId->processId)
			{
				doesFakeProcess = true;
			}
		}
	}

	// Current process doesn't fake process:
	RETURN_ON_CONDITION(false == doesFakeProcess);

	// Create event item memory:
	auto* eventItem = new (PagedPool, DRIVER_TAG) EventItem<EventInfo>;
	PRINT_MESSAGE_AND_RETURN_ON_CONDITION(nullptr == eventItem, "Could not allocate memory for " STRINGIFY(EventItem));

	// Set event info:
	auto* eventInfo = &eventItem->data;
	KeQuerySystemTimePrecise(&eventInfo->time);
	eventInfo->processId = HandleToULong(PsGetCurrentProcessId());
	eventInfo->fakeProcessId = requestedProcessPid.getValue();

	// Force null-terminated string:
	memset(eventInfo->processName, 0, MAX_PROCESS_NAME_LENGTH + 1);

	// Get filename path of the calling process:
	auto processFileName = ProcessUtils::getProcessFileNameByPid(eventInfo->processId);
	if (!processFileName.isError())
	{
		const StresserString filenamePath = processFileName.getValue();
		wcscpy_s(eventInfo->processName, MAX_PROCESS_NAME_LENGTH, filenamePath.get());
	}

	KdPrint((DRIVER_PREFIX "PID=0x%08X open handle to fake process PID=0x%08X\n", eventInfo->processId, eventInfo->fakeProcessId));

	// Add new event:
	{
		AutoLock lock(notificationContext->mutex);

		auto* fakeProcessEvents = notificationContext->fakeProcessEvents;
		RETURN_ON_CONDITION(nullptr == fakeProcessEvents);

		fakeProcessEvents->insertTail(eventItem);
	}

	auto* sharedEvent = notificationContext->onFakeProcessEvent;
	if (nullptr != sharedEvent->get())
	{
		Value<bool, NTSTATUS> result = sharedEvent->set();
		if (result.isError())
		{
			KdPrint((DRIVER_PREFIX STRINGIFY(StresserEngineObPostOpCallback) " could not signal UM, status: 0x%08X\n",
				result.getError()));
		}
	}
}

void signalNotificationEvent(const Event& notificationEvent)
{
	if (nullptr != notificationEvent.get())
	{
		Value<bool, NTSTATUS> result = notificationEvent.set();
		if (result.isError())
		{
			KdPrint((DRIVER_PREFIX STRINGIFY(StresserEngineObPostOpCallback) " could not signal UM, status: 0x%08X\n",
				result.getError()));
		}
	}
}
```

`StresserEngine/ObjectNotification.h`:

```h
#pragma once

#include "Event.h"
#include "HelperMacros.h"

#define STRESSER_OBJECT_NOTIFICATION_TYPE PsProcessType
#define STRESSER_OBJECT_CALLBACK_COUNT 1
#define STRESSER_PROCESS_OBJECT_TYPE 0

/* Dummy callback function for object pre operations, process events. */
OB_PREOP_CALLBACK_STATUS StresserEngineObPreOpCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation);

/* Callback function for object post operations, process events. */
void StresserEngineObPostOpCallback(PVOID RegistrationContext, POB_POST_OPERATION_INFORMATION OperationInformation);

/* Signal notification event. */
void signalNotificationEvent(const Event& notificationEvent);
```

`StresserEngine/ProcessUtils.cpp`:

```cpp
#include "ProcessUtils.h"
#include "HelperMacros.h"
#include "GenericHandle.h"
#include "AutoObjectDereference.h"
#include "AutoBuffer.h"

Value<const ULONG, ProcessUtils::ErrorCodes> ProcessUtils::getPidFromProcess(const PEPROCESS& process)
{
	if (nullptr == process)
	{
		return INVALID_PID_VALUE;
	}

	const HANDLE processHandle = PsGetProcessId(process);
	if (nullptr >= processHandle)
	{
		return INVALID_PID_VALUE;
	}

	const ULONG pid = HandleToULong(processHandle);

	/*
	 * TODO: Verify PID value:
	 * Possible solution: iterates over all the running processes and verify
	 * if the PID exists in the system.
	 */

	return pid;
}

bool ProcessUtils::doesValidProcessId(ULONG processId)
{
	if (ProcessUtils::INVALID_PID_VALUE == processId)
	{
		return false;
	}

	if (ProcessUtils::SYSTEM_PID_VALUE == processId)
	{
		return false;
	}

	/*
	 * TODO: Verify PID value:
	 * Possible solution: iterates over all the running processes and verify
	 * if the PID exists in the system.
	 */

	return true;
}

Value<StresserString, NTSTATUS> ProcessUtils::getProcessFileNameByPid(const ULONG processId)
{
	if (0 == processId)
	{
		return STATUS_INVALID_PARAMETER;
	}

	if (ProcessUtils::SYSTEM_PID_VALUE == processId)
	{
		return StresserString(L"System");
	}

	AutoObjectDereference<PEPROCESS> process;
	const HANDLE pseudoProcessHandle = ULongToHandle(processId);

	NTSTATUS status = PsLookupProcessByProcessId(pseudoProcessHandle, &process.get());
	RETURN_ON_STATUS_FAILURE(status, "PsLookupProcessByProcessId failed");

	HANDLE handle;
	status = ObOpenObjectByPointer(process.get(), OBJ_KERNEL_HANDLE, nullptr, 0, nullptr, KernelMode, &handle);
	RETURN_ON_STATUS_FAILURE(status, "ObOpenObjectByPointer failed");

	// RAII safe handle
	const AutoKernelHandle processHandle(handle);

	const StresserBuffer imageFileNameBuffer(ProcessUtils::FILE_NAME_SIZE);
	if (nullptr == imageFileNameBuffer.get())
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	ULONG returnedSize = 0;

	status = ZwQueryInformationProcess(processHandle, ProcessImageFileName, imageFileNameBuffer.get(),
		FILE_NAME_SIZE - sizeof(WCHAR), &returnedSize);
	RETURN_ON_STATUS_FAILURE(status, "ZwQueryInformationProcess failed");

	return StresserString(static_cast<PUNICODE_STRING>(imageFileNameBuffer.get()));
}

```

`StresserEngine/ProcessUtils.h`:

```h
#pragma once

#include "DriverConfiguration.h"
#include "Value.h"

#include <ntifs.h>

extern "C" NTSTATUS ZwQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength);

class ProcessUtils
{
public:
	enum ErrorCodes
	{
		INVALID_PEPROCESS,
		COULD_NOT_FIND_EPROCESS,
		COULD_NOT_CREATE_OBJECT_REFERENCE,
		COULD_NOT_QUERY_PROCESS_INFORMATION
	};

	static constexpr ULONG INVALID_PID_VALUE = 0;
	static constexpr ULONG SYSTEM_PID_VALUE = 4;
	static constexpr SIZE_T FILE_NAME_SIZE = 300;

	static Value<const ULONG, ErrorCodes> getPidFromProcess(const PEPROCESS& process);

	static bool doesValidProcessId(ULONG processId);

	static Value<StresserString, NTSTATUS> getProcessFileNameByPid(const ULONG processId);
};


```

`StresserEngine/StresserEngine.cpp`:

```cpp
#include "StresserEngine.h"
#include "DriverConfiguration.h"
#include "StresserEngineCommon.h"
#include "HelperMacros.h"
#include "IrpUtils.h"
#include "ObjectNotification.h"
#include "Memory.h"
#include "ProcessUtils.h"

/*
 * Driver entry point.
 * Responsible for creating driver's device object, allocate driver's shared memory,
 * initialize data structures, register to dispatch function, etc.
 */
extern "C"
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	KdPrint((DRIVER_PREFIX "DriverEntry started\n"));

	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_OBJECT deviceObject = nullptr;
	PDeviceExtension deviceExtension = nullptr;
	UNICODE_STRING symLink = RTL_CONSTANT_STRING(SYMBOLIC_LINK_PATH);
	bool symbolicLinkCreated = false;

	do
	{
		// Create device object for user-mode communication:
		UNICODE_STRING devName = RTL_CONSTANT_STRING(DEVICE_NAME);
		status = IoCreateDevice(DriverObject, DEVICE_EXTENSION_SIZE, &devName, FILE_DEVICE_UNKNOWN, 0, TRUE, &deviceObject);
		PRINT_STATUS_SUCCESS_FAILURE(status, "Create device object successfully", "Failed to create device");
		BREAK_ON_FAILURE(status);

		// Set the IO communication method:
		deviceObject->Flags |= DO_DIRECT_IO;

		// Get device extensions:
		deviceExtension = static_cast<PDeviceExtension>(deviceObject->DeviceExtension);
		deviceExtension->notificationContext = nullptr;
		deviceExtension->objectNotificationRegistrationHandle = nullptr;

		// Create symbolic link to the device object:
		status = IoCreateSymbolicLink(&symLink, &devName);
		PRINT_STATUS_SUCCESS_FAILURE(status, "Create symbolic link successfully", "Failed to create symbolic link");
		BREAK_ON_FAILURE(status);

		symbolicLinkCreated = true;

		LOG_MESSAGE("allocate memory for notification event");

		// Register to object notifications:
		// TODO: Verify we are on Vista and above, otherwise: "OS version doesn't support Object notifications"

		OB_OPERATION_REGISTRATION objectOperationsRegistration[STRESSER_OBJECT_CALLBACK_COUNT];

		static_assert(STRESSER_PROCESS_OBJECT_TYPE < STRESSER_OBJECT_CALLBACK_COUNT, "Out of bounds");

		// Set object notification callbacks:
		objectOperationsRegistration[STRESSER_PROCESS_OBJECT_TYPE] =
		{
			STRESSER_OBJECT_NOTIFICATION_TYPE,	// ObjectType
			OB_OPERATION_HANDLE_CREATE,			// Operations
			StresserEngineObPreOpCallback,		// PreOperation
			StresserEngineObPostOpCallback		// PostOperation
		};

		const UNICODE_STRING altitude = RTL_CONSTANT_STRING(DRIVER_ALTITUDE);

		// Create shared memory for notifications:
		Value<PVOID, StresserString> result = createNotificationContext(deviceObject);
		if (result.isError())
		{
			LOG_MESSAGE("could not allocate memory for notification context");
			status = STATUS_INSUFFICIENT_RESOURCES;
			BREAK_ON_FAILURE(status);
		}

		// Add shared structure to device extensions:
		deviceExtension->notificationContext = static_cast<PNotificationContext>(result.getValue());

		// Set object notification registration:
		OB_CALLBACK_REGISTRATION objectCallbackRegistration =
		{
			OB_FLT_REGISTRATION_VERSION,		// Version
			STRESSER_OBJECT_CALLBACK_COUNT,		// OperationRegistrationCount
			altitude,							// Altitude
			deviceExtension->notificationContext, // RegistrationContext
			objectOperationsRegistration		// OperationRegistration
		};

		// Register to object notifications:
		status = ObRegisterCallbacks(&objectCallbackRegistration, &deviceExtension->objectNotificationRegistrationHandle);
		PRINT_STATUS_SUCCESS_FAILURE(status, "Register to object notifications successfully", "Failed to register to object notifications");
		BREAK_ON_FAILURE(status);

	} while (false);

	// In case of failure:
	if (!NT_SUCCESS(status))
	{
		if (symbolicLinkCreated)
		{
			IoDeleteSymbolicLink(&symLink);
		}
		if (nullptr != deviceExtension && nullptr != deviceExtension->objectNotificationRegistrationHandle)
		{
			ObUnRegisterCallbacks(deviceExtension->objectNotificationRegistrationHandle);
		}
		if (nullptr != deviceExtension && nullptr != deviceExtension->notificationContext)
		{
			releaseNotificationContext(deviceObject);
		}
		// MUST be after freeing other resources:
		if (nullptr != deviceObject)
		{
			IoDeleteDevice(deviceObject);
		}
	}

	for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; ++i)
	{
		DriverObject->MajorFunction[i] = StresserEngineDefaultDispatch;
	}

	DriverObject->DriverUnload = StresserEngineUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = StresserEngineCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = StresserEngineCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = StresserEngineDeviceControl;

	LOG_MESSAGE("DriverEntry completed successfully\n");

	return status;
}

void StresserEngineUnload(PDRIVER_OBJECT DriverObject)
{
	LOG_MESSAGE(STRINGIFY(StresserEngineUnload) " started");

	// Remove symbolic link:
	UNICODE_STRING symLink = RTL_CONSTANT_STRING(SYMBOLIC_LINK_PATH);
	const NTSTATUS status = IoDeleteSymbolicLink(&symLink);
	PRINT_STATUS_SUCCESS_FAILURE(status, "remove symbolic link successfully", "failed to delete symbolic link");

	// Get driver's device object:
	const PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
	PRINT_MESSAGE_AND_RETURN_ON_CONDITION(nullptr == deviceObject,
		STRINGIFY(StresserEngineUnload) " device object is null, cannot continue cleanup, returning...");

	// Release notification context memory:
	const Value<bool, StresserString> result = releaseNotificationContext(deviceObject);
	if (result.isError())
	{
		LOG_MESSAGE("could not release notification context memory");
	}

	LOG_MESSAGE("release notification context memory");

	// Get device extensions:
	auto* deviceExtensions = static_cast<PDeviceExtension>(deviceObject->DeviceExtension);
	PRINT_MESSAGE_AND_RETURN_ON_CONDITION(nullptr == deviceExtensions,
		STRINGIFY(StresserEngineUnload) " device extensions is null, cannot continue cleanup, returning...");

	// Remove registered callbacks:
	if (nullptr != deviceExtensions->objectNotificationRegistrationHandle)
	{
		//ObUnRegisterCallbacks(g_registrationHandle);
		ObUnRegisterCallbacks(deviceExtensions->objectNotificationRegistrationHandle);
		LOG_MESSAGE("remove object notification callback successfully");
	}

	// Remove device object
	IoDeleteDevice(deviceObject);
	LOG_MESSAGE("delete device object");

	LOG_MESSAGE(STRINGIFY(StresserEngineUnload) " completed successfully");
}

NTSTATUS StresserEngineCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, 0);
	return STATUS_SUCCESS;
}

NTSTATUS StresserEngineDefaultDispatch(PDEVICE_OBJECT, PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, 0);
	return STATUS_NOT_SUPPORTED;
}

NTSTATUS completeIrp(PIRP Irp, NTSTATUS status, ULONG_PTR info)
{
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = info;
	IoCompleteRequest(Irp, 0);
	return status;
}

NTSTATUS StresserEngineDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	LOG_MESSAGE(STRINGIFY(StresserEngineDeviceControl) " DeviceControl started");

	const PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	const ULONG controlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	NTSTATUS status = STATUS_NOT_SUPPORTED;

	if (nullptr == Irp)
	{
		return completeIrp(Irp, status);
	}

	// Run the corresponding handler for the request:
	switch (controlCode) {
	case IOCTL_STRESSER_ENGINE_REGISTER_EVENT:
	{
		status = registerEventHandler(DeviceObject, Irp, stack);
		break;
	}
	case IOCTL_STRESSER_ENGINE_UNREGISTER_EVENT:
	{
		status = unregisterEventHandler(DeviceObject);
		break;
	}
	case IOCTL_STRESSER_ENGINE_ADD_FAKE_PID:
	{
		status = addFakeProcessIdHandler(DeviceObject, Irp, stack);
		break;
	}
	case IOCTL_STRESSER_ENGINE_REMOVE_FAKE_PID:
	{
		status = removeFakeProcessIdHandler(DeviceObject, Irp, stack);
		break;
	}
	case IOCTL_STRESSER_ENGINE_GET_EVENTS:
	{
		status = getEventsHandler(DeviceObject, Irp, stack);
		break;
	}
	case IOCTL_STRESSER_ENGINE_REMOVE_ALL_FAKE_PROCESS_IDS:
	{
		status = removeAllFakeProcessIds(DeviceObject);
		break;
	}
	default:
	{
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	}

	LOG_MESSAGE(STRINGIFY(StresserEngineDeviceControl) " DeviceControl completed successfully");

	return completeIrp(Irp, status, Irp->IoStatus.Information);
}

NTSTATUS registerEventHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp, PIO_STACK_LOCATION StackLocation)
{
	LOG_MESSAGE(STRINGIFY(RegisterEventHandler) " started");

	if (!IrpUtils::isValidInputBuffer(StackLocation, REGISTER_EVENT_SIZE))
	{
		LOG_MESSAGE(STRINGIFY(RegisterEventHandler) " user buffer is invalid");

		return STATUS_BUFFER_TOO_SMALL;
	}

	auto* const registerEvent = static_cast<RegisterEvent*>(Irp->AssociatedIrp.SystemBuffer);
	if (nullptr == registerEvent)
	{
		LOG_MESSAGE(STRINGIFY(RegisterEventHandler) " Invalid memory");
		STATUS_INVALID_PARAMETER;
	}

	const StresserString eventName(registerEvent->eventName);

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	auto* notificationContext = deviceExtensions->notificationContext;
	auto* onFakeProcessEvent = notificationContext->onFakeProcessEvent;

	Value<bool, NTSTATUS> result = onFakeProcessEvent->open(eventName);

	if (result.isError())
	{
		RETURN_ON_STATUS_FAILURE(result.getError(), "could not open event by the given event name");
	}

	LOG_MESSAGE(STRINGIFY(RegisterEventHandler) " completed successfully");

	return STATUS_SUCCESS;
}

NTSTATUS unregisterEventHandler(_In_ PDEVICE_OBJECT DeviceObject)
{
	LOG_MESSAGE(STRINGIFY(unregisterEventHandler) " started");

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	RETURN_STATUS_ON_CONDITION(nullptr == deviceExtensions,
		STRINGIFY(unregisterEventHandler) " invalid device extension", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	auto* notificationContext = deviceExtensions->notificationContext;
	RETURN_STATUS_ON_CONDITION(nullptr == notificationContext,
		STRINGIFY(unregisterEventHandler) " invalid notification context", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	auto* onFakeProcessEvent = notificationContext->onFakeProcessEvent;
	RETURN_STATUS_ON_CONDITION(nullptr == onFakeProcessEvent,
		STRINGIFY(unregisterEventHandler) " invalid vector of events", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	Value<bool, NTSTATUS> result = onFakeProcessEvent->close();

	if (result.isError())
	{
		KdPrint((DRIVER_PREFIX STRINGIFY(unregisterEventHandler) " could not close shared event, status: 0x%08X\n",
			result.getError()));

		return result.getError();
	}

	LOG_MESSAGE(STRINGIFY(unregisterEventHandler) " completed successfully");

	return STATUS_SUCCESS;
}

NTSTATUS addFakeProcessIdHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp, PIO_STACK_LOCATION StackLocation)
{
	LOG_MESSAGE(STRINGIFY(addFakeProcessIdHandler) " started");

	if (!IrpUtils::isValidInputBuffer(StackLocation, FAKE_PROCESS_ID_SIZE))
	{
		LOG_MESSAGE(STRINGIFY(addFakeProcessIdHandler) " user buffer is invalid");

		return STATUS_BUFFER_TOO_SMALL;
	}

	auto* const fakeProcessId = static_cast<FakeProcessId*>(Irp->AssociatedIrp.SystemBuffer);
	if (nullptr == fakeProcessId)
	{
		KdPrint((DRIVER_PREFIX STRINGIFY(addFakeProcessIdHandler) " Invalid type for request\n"));
		return STATUS_INVALID_PARAMETER;
	}

	if (!ProcessUtils::doesValidProcessId(fakeProcessId->processId))
	{
		LOG_MESSAGE(STRINGIFY(addFakeProcessIdHandler) " Invalid process ID");
		return STATUS_INVALID_PARAMETER;
	}

	auto* processId = new (NonPagedPool, DRIVER_TAG) FakeProcessId;

	processId->processId = fakeProcessId->processId;

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	auto* notificationContext = deviceExtensions->notificationContext;

	{

		AutoLock lock(notificationContext->mutex);

		auto* fakeProcessIds = notificationContext->fakeProcessIds;
		fakeProcessIds->add(processId);
	}

	KdPrint((DRIVER_PREFIX STRINGIFY(addFakeProcessIdHandler)" Add fake process ID=%d\n", processId->processId));
	LOG_MESSAGE(STRINGIFY(addFakeProcessIdHandler) " completed successfully");

	return STATUS_SUCCESS;
}

NTSTATUS removeFakeProcessIdHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp, PIO_STACK_LOCATION StackLocation)
{
	KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler) " started\n"));

	if (!IrpUtils::isValidInputBuffer(StackLocation, FAKE_PROCESS_ID_SIZE))
	{
		KdPrint((DRIVER_PREFIX STRINGIFY(RemoveFakeProcessIdHandler) " user buffer is invalid\n"));

		return STATUS_BUFFER_TOO_SMALL;
	}

	auto* const fakeProcessId = static_cast<FakeProcessId*>(Irp->AssociatedIrp.SystemBuffer);
	if (nullptr == fakeProcessId)
	{
		KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler) " invalid type for request\n"));
		return STATUS_INVALID_PARAMETER;
	}

	if (!ProcessUtils::doesValidProcessId(fakeProcessId->processId))
	{
		KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler) " invalid process ID\n"));
		return STATUS_INVALID_PARAMETER;
	}

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	auto* notificationContext = deviceExtensions->notificationContext;

	{
		AutoLock lock(notificationContext->mutex);

		auto* fakeProcessIds = notificationContext->fakeProcessIds;

		for (ULONG i = 0; i < fakeProcessIds->size(); ++i)
		{
			const FakeProcessId* current = fakeProcessIds->getAt(i);
			if (nullptr != current)
			{
				if (fakeProcessId->processId == current->processId)
				{
					KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler)" remove fake process ID=%d\n", current->processId));

					fakeProcessIds->removeAt(i);
					delete current;

					KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler) " completed successfully\n"));
					return STATUS_SUCCESS;
				}
			}
		}
	}

	KdPrint((DRIVER_PREFIX STRINGIFY(removeFakeProcessIdHandler) " could not remove process ID=%d\n", fakeProcessId->processId));
	return STATUS_INVALID_PARAMETER;
}

NTSTATUS getEventsHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp, PIO_STACK_LOCATION StackLocation)
{
	LOG_MESSAGE(STRINGIFY(getEventsHandler) " started");

	// Validates input data:
	RETURN_STATUS_ON_CONDITION(!IrpUtils::isValidOutputBuffer(StackLocation, EVENTS_HEADER_SIZE),
		STRINGIFY(getEventsHandler) " events header is too small", STATUS_BUFFER_TOO_SMALL);

	// Get data from the request:
	auto* eventsHeader = static_cast<EventsHeader*>(MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority));
	RETURN_STATUS_ON_CONDITION(nullptr == eventsHeader,
		STRINGIFY(getEventsHandler) " events buffer is too small", STATUS_INVALID_DEVICE_REQUEST);

	// Validates minimum output buffer size:
	const ULONG eventsBufferSize = eventsHeader->size;
	RETURN_STATUS_ON_CONDITION(eventsBufferSize < 1,
		STRINGIFY(getEventsHandler) " events buffer is too small", STATUS_BUFFER_TOO_SMALL);

	// Validates output buffer:
	auto* const eventsBuffer = reinterpret_cast<EventInfo*>(eventsHeader->events);
	RETURN_STATUS_ON_CONDITION(nullptr == eventsBuffer,
		STRINGIFY(getEventsHandler) " invalid events buffer", STATUS_INVALID_PARAMETER);

	// TODO: Validates output buffer size, not by given user buffer size

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	auto* notificationContext = deviceExtensions->notificationContext;

	{
		AutoLock lock(notificationContext->mutex);

		auto* fakeProcessEvents = notificationContext->fakeProcessEvents;

		// Verify if the list contains any events:
		const ULONG listSize = fakeProcessEvents->size();
		RETURN_STATUS_ON_CONDITION(0 == listSize,
			STRINGIFY(getEventsHandler) " empty events list", STATUS_SUCCESS);

		const ULONG maxIterations = min(listSize, eventsBufferSize);

		for (ULONG i = 0; i < maxIterations; ++i)
		{
			const auto* eventItem = fakeProcessEvents->removeHead();
			const EventInfo& eventInfo = eventItem->data;

			memcpy(&eventsBuffer[i], &eventInfo, EVENT_INFO_SIZE);

			delete eventItem;
		}

		// Pass how much size of buffer have been used:
		Irp->IoStatus.Information = maxIterations * EVENT_INFO_SIZE;
	}

	LOG_MESSAGE(STRINGIFY(getEventsHandler) " completed successfully");
	return STATUS_SUCCESS;
}

NTSTATUS removeAllFakeProcessIds(_In_ PDEVICE_OBJECT DeviceObject)
{
	LOG_MESSAGE(STRINGIFY(removeAllFakeProcessIds) " started");

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	RETURN_STATUS_ON_CONDITION(nullptr == deviceExtensions,
		STRINGIFY(removeAllFakeProcessIds) " invalid device extension", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	auto* notificationContext = deviceExtensions->notificationContext;
	RETURN_STATUS_ON_CONDITION(nullptr == notificationContext,
		STRINGIFY(removeAllFakeProcessIds) " invalid notification context", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	auto* fakeProcessIds = notificationContext->fakeProcessIds;
	RETURN_STATUS_ON_CONDITION(nullptr == fakeProcessIds,
		STRINGIFY(removeAllFakeProcessIds) " invalid vector of process IDs", STATUS_INVALID_DEVICE_OBJECT_PARAMETER);

	{
		AutoLock lock(notificationContext->mutex);

		const ULONG numberOfIds = fakeProcessIds->size();

		for (ULONG i = 0; i < numberOfIds; ++i)
		{
			const FakeProcessId* current = fakeProcessIds->getAt(i);
			if (nullptr != current)
			{
				KdPrint((DRIVER_PREFIX STRINGIFY(removeAllFakeProcessIds) " stop watching fake process PID=%d\n", current->processId));

				delete current;
			}
		}

		fakeProcessIds->clear();
	}

	LOG_MESSAGE(STRINGIFY(removeAllFakeProcessIds) " completed successfully");

	return STATUS_SUCCESS;
}

Value<PVOID, StresserString> createNotificationContext(PDEVICE_OBJECT DeviceObject)
{
	LOG_MESSAGE(STRINGIFY(createNotificationContext) " called");

	auto* notificationContext = new (NonPagedPool, DRIVER_TAG) NotificationContext;
	if (nullptr == notificationContext)
	{
		StresserString errorMessage(L"Could not allocate memory for " STRINGIFY(NotificationContext));
		return errorMessage;
	}

	notificationContext->fakeProcessIds = new (NonPagedPool, DRIVER_TAG) Vector<FakeProcessId*, DRIVER_TAG>();
	if (nullptr == notificationContext->fakeProcessIds)
	{
		StresserString errorMessage(L"Could not allocate memory for " STRINGIFY(Vector));
		return errorMessage;
	}

	notificationContext->fakeProcessEvents = new (NonPagedPool, DRIVER_TAG) LinkedList<EventItem<EventInfo>, FastMutex>();
	if (nullptr == notificationContext->fakeProcessEvents)
	{
		StresserString errorMessage(L"Could not allocate memory for " STRINGIFY(LinkedList));
		return errorMessage;
	}

	notificationContext->onFakeProcessEvent = new (NonPagedPool, DRIVER_TAG) Event();
	if (nullptr == notificationContext->onFakeProcessEvent)
	{
		StresserString errorMessage(L"Could not allocate memory for " STRINGIFY(Event));
		return errorMessage;
	}

	// Initialize global lock object:
	notificationContext->mutex.init();

	LOG_MESSAGE(STRINGIFY(createNotificationContext) " ended");

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	deviceExtensions->notificationContext = notificationContext;

	return notificationContext;
}

Value<bool, StresserString> releaseNotificationContext(PDEVICE_OBJECT DeviceObject)
{
	LOG_MESSAGE(STRINGIFY(releaseNotificationContext) " called");

	auto* deviceExtensions = static_cast<PDeviceExtension>(DeviceObject->DeviceExtension);
	auto* notificationContext = deviceExtensions->notificationContext;

	if (nullptr == notificationContext)
	{
		StresserString errorMessage(L"Notification context pointer already null");
		return errorMessage;
	}

	{
		AutoLock(notificationContext->mutex);

		auto* fakeProcessIds = notificationContext->fakeProcessIds;
		if (nullptr != fakeProcessIds)
		{
			for (auto& fakeProcessId : *fakeProcessIds)
			{
				delete fakeProcessId;
			}
		}

		auto* events = notificationContext->fakeProcessEvents;
		if (nullptr != events || nullptr != events->getHead())
		{
			const ULONG numberOfEvents = events->size();

			for (ULONG i = 0; i < numberOfEvents; ++i)
			{
				EventItem<EventInfo>* removedItem = events->removeHead();
				delete removedItem;
			}
		}

		auto* onFakeProcessEvent = notificationContext->onFakeProcessEvent;
		if (nullptr != onFakeProcessEvent)
		{
			delete onFakeProcessEvent;
		}
	}

	delete notificationContext;

	LOG_MESSAGE(STRINGIFY(releaseNotificationContext) " ended");

	return true;
}
```

`StresserEngine/StresserEngine.h`:

```h
#pragma once

#include "DriverConfiguration.h"
#include "StresserEngineCommon.h"
#include "Vector.h"
#include "LinkedList.h"
#include "Event.h"

#include <ntifs.h>


/*
	Represent event in the item's linked list.
 */
template<typename T>
struct EventItem
{
	LIST_ENTRY Entry; // Must named with capital 'E'
	T data;
};


/*
	Represent the context each notification callback will receive.
	This data used for the callback logic.
 */
typedef struct _NotificationContext
{
	FastMutex mutex;
	Vector<FakeProcessId*, DRIVER_TAG>* fakeProcessIds;
	LinkedList<EventItem<EventInfo>, FastMutex>* fakeProcessEvents;
	Event* onFakeProcessEvent;
} NotificationContext, * PNotificationContext;


/*
	Represent driver defined data structure used for the driver operations.
 */
typedef struct _DeviceExtension
{
	PNotificationContext notificationContext;
	PVOID objectNotificationRegistrationHandle;
} DeviceExtension, * PDeviceExtension;

constexpr ULONG DEVICE_EXTENSION_SIZE = sizeof(DEVICE_EXTENSION_SIZE);

/* The Driver's unload function called whenever the kernel unloads the driver. */
DRIVER_UNLOAD StresserEngineUnload;

/* The Driver's default dispatch to all the unimplemented dispatch. */
DRIVER_DISPATCH StresserEngineDefaultDispatch;

/* The Driver's default dispatch for create and close dispatch. */
DRIVER_DISPATCH StresserEngineCreateClose;

/* Dispatch function for device control I\O requests. */
DRIVER_DISPATCH StresserEngineDeviceControl;

/* Helper function to return the IRP to the caller. */
NTSTATUS completeIrp(PIRP Irp, NTSTATUS status = STATUS_SUCCESS, ULONG_PTR info = 0);

/* Handler function for registering event  from user mode. */
NTSTATUS registerEventHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp, _In_ PIO_STACK_LOCATION StackLocation);

/* Handler function for unregistering the event if exists. */
NTSTATUS unregisterEventHandler(_In_ PDEVICE_OBJECT DeviceObject);

/* Handler function for adding fake process ID to be monitored. */
NTSTATUS addFakeProcessIdHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp, _In_ PIO_STACK_LOCATION StackLocation);

/* Handler function for removing fake process ID from being monitored. */
NTSTATUS removeFakeProcessIdHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp, _In_ PIO_STACK_LOCATION StackLocation);

/* Handler function for passing event to user mode. */
NTSTATUS getEventsHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp, _In_ PIO_STACK_LOCATION StackLocation);

/* Handler function for removing all the registered fake process IDs. */
NTSTATUS removeAllFakeProcessIds(_In_ PDEVICE_OBJECT DeviceObject);

/* Allocate shared memory used for object notification callbacks. */
Value<PVOID, StresserString> createNotificationContext(PDEVICE_OBJECT DeviceObject);

/* Free shared memory used in object notification callbacks. */
Value<bool, StresserString> releaseNotificationContext(PDEVICE_OBJECT DeviceObject);
```

`StresserEngine/StresserEngine.inf`:

```inf
;
; StresserEngine.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=StresserEngine.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="StresserEngine Source Disk"

```

`StresserEngine/StresserEngine.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{92E95C51-6BD3-44AA-BADF-531C6F488C16}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>StresserEngine</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="StresserEngine.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Event.cpp" />
    <ClCompile Include="FastMutex.cpp" />
    <ClCompile Include="IrpUtils.cpp" />
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="ObjectNotification.cpp" />
    <ClCompile Include="ProcessUtils.cpp" />
    <ClCompile Include="StresserEngine.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AutoLock.h" />
    <ClInclude Include="AutoObjectDereference.h" />
    <ClInclude Include="AutoBuffer.h" />
    <ClInclude Include="DriverConfiguration.h" />
    <ClInclude Include="Event.h" />
    <ClInclude Include="FastMutex.h" />
    <ClInclude Include="HelperMacros.h" />
    <ClInclude Include="IrpUtils.h" />
    <ClInclude Include="LinkedList.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Move.h" />
    <ClInclude Include="ObjectNotification.h" />
    <ClInclude Include="ProcessUtils.h" />
    <ClInclude Include="StresserEngine.h" />
    <ClInclude Include="StresserEngineCommon.h" />
    <ClInclude Include="GenericHandle.h" />
    <ClInclude Include="String.h" />
    <ClInclude Include="Value.h" />
    <ClInclude Include="Vector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`StresserEngine/StresserEngine.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="StresserEngine.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="StresserEngine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IrpUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ObjectNotification.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FastMutex.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Event.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StresserEngine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StresserEngineCommon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IrpUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ObjectNotification.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HelperMacros.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GenericHandle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverConfiguration.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="String.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Value.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Move.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoObjectDereference.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoBuffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LinkedList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoLock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FastMutex.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Event.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`StresserEngine/StresserEngineCommon.h`:

```h
#pragma once

//#include <ntdef.h>

/* Define globals types for User to Kernel communication. */

#define STRESSER_ENGINE_DEVICE 0x8000

/* Register shared event by it's name for signaling from kernel mode to user mode. */
#define IOCTL_STRESSER_ENGINE_REGISTER_EVENT CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

/* If exists, unregister the shared event. */
#define IOCTL_STRESSER_ENGINE_UNREGISTER_EVENT CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

/* Register PID of fake process to be monitored. */
#define IOCTL_STRESSER_ENGINE_ADD_FAKE_PID CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

/* Remove PID of fake process from being monitored. */
#define IOCTL_STRESSER_ENGINE_REMOVE_FAKE_PID CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

/* Send buffer and receive the current recorded events. */
#define IOCTL_STRESSER_ENGINE_GET_EVENTS CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x804, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

/* Remove all fake process IDs */
#define IOCTL_STRESSER_ENGINE_REMOVE_ALL_FAKE_PROCESS_IDS CTL_CODE(STRESSER_ENGINE_DEVICE, \
	0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Sizes of fields shared by user mode and kernel mode:
const int MAX_EVENT_NAME_LENGTH = 100;
const int MAX_PROCESS_NAME_LENGTH = 300;

/*
	Used for sending event handle throw IOCTL.
*/
struct RegisterEvent
{
	WCHAR eventName[MAX_EVENT_NAME_LENGTH + 1];
};

/*
	Used for sending fake process ID throw IOCTL.
*/
struct FakeProcessId
{
	ULONG processId;
};

/*
	Represent process detection event.
	Fires whenever process try to open handle to fake process.
*/
struct EventInfo
{
	ULONG processId;								// ID of calling process
	WCHAR processName[MAX_PROCESS_NAME_LENGTH + 1];	// Filename path of calling process
	ULONG fakeProcessId;							// Called for this fake process
	LARGE_INTEGER time;								// Timestamp of the call
};

/*
 * Used for comparison between two referent EventInfo objects.
 */
struct EventInfoComparator
{
	bool operator()(const EventInfo& e1, const EventInfo& e2) const
	{
		return
			wcscmp(e1.processName, e2.processName) == 0
			&& e1.fakeProcessId == e2.fakeProcessId
			&& e1.processId == e2.processId
			&& e1.time.QuadPart == e2.time.QuadPart;
	}
};

/*

 */
struct EventsHeader
{
	ULONG size;
	EventInfo* events;
};

constexpr SIZE_T REGISTER_EVENT_SIZE = sizeof(RegisterEvent);
constexpr SIZE_T FAKE_PROCESS_ID_SIZE = sizeof(FakeProcessId);
constexpr SIZE_T EVENT_INFO_SIZE = sizeof(EventInfo);
constexpr SIZE_T EVENTS_HEADER_SIZE = sizeof(EventsHeader);
```

`StresserEngine/String.h`:

```h
#pragma once

#include "Memory.h"

#include <ntifs.h>

template<ULONG Tag, POOL_TYPE PoolType = PagedPool>
class String
{
public:
	String(const PCWCHAR str = nullptr)
		: String(const_cast<PWCHAR>(str), 0)
	{
	}

	/* Construct new empty String object. */
	explicit String(const PWCHAR str)
		: String(str, 0)
	{
	}

	/* Construct new String object with reserved size. */
	explicit String(const PCWCHAR data, ULONG count)
		: String(const_cast<PWCHAR>(data), count)
	{
	}

	/* Construct new String object with reserved size. */
	explicit String(const PWCHAR data, ULONG count)
		: m_data(nullptr), m_length(0), m_capacity(0), m_pool(PoolType), m_tag(Tag)
	{
		if (nullptr != data)
		{
			if (0 == count)
			{
				this->m_length = static_cast<ULONG>(wcslen(data));
			}
			else
			{
				this->m_length = count;
			}

			this->m_capacity = this->m_length + 1; // Null-terminator
			this->m_data = this->allocate(this->m_capacity, data);
			if (nullptr == this->m_data)
			{
				ExRaiseStatus(STATUS_NO_MEMORY);
			}
		}
		else
		{
			this->m_data = nullptr;
			this->m_length = 0;
		}
	}

	explicit String(ULONG reservedSize)
		: m_pool(PoolType), m_tag(Tag)
	{
		this->m_data = String::allocateReservedBuffer(reservedSize);
		this->m_capacity = reservedSize;
		this->m_length = 0;
	}

	/* Copy constructor */
	String(const String& other)
	{
		this->m_length = other.m_length;
		this->m_pool = other.m_pool;
		this->m_tag = other.m_tag;
		this->m_capacity = other.m_capacity;

		if (0 < this->m_length)
		{
			this->m_data = this->allocate(this->m_capacity, other.m_data);
		}
		else
		{
			this->m_data = nullptr;
		}
	}

	/* Construct new String object from UNICODE_STRING type. */
	explicit String(const PUNICODE_STRING unicodeString)
		: m_data(nullptr), m_length(0), m_capacity(0), m_pool(PoolType), m_tag(Tag)
	{
		if (nullptr != unicodeString)
		{
			// UNICODE_STRING length is in bytes and not WCHARs
			this->m_length = unicodeString->Length / sizeof(WCHAR);
			this->m_capacity = m_length + 1;

			this->m_data = this->allocate(this->m_capacity, unicodeString->Buffer);
		}
	}

	/* Assignment operator. */
	String& operator=(const String& other)
	{
		if (&other != this)
		{
			this->release();

			this->m_length = other.m_length;
			this->m_capacity = other.m_capacity;
			this->m_tag = other.m_tag;
			this->m_pool = other.m_pool;

			if (nullptr != other.m_data)
			{
				this->m_data = this->allocate(this->m_capacity, other.m_data);
			}
		}

		return *this;
	}

	/* Move constructor. */
	String(String&& other) noexcept
	{
		this->m_length = other.m_length;
		this->m_capacity = other.m_capacity;
		this->m_pool = other.m_pool;
		this->m_tag = other.m_tag;
		this->m_data = other.m_data;

		other.m_length = 0;
		other.m_data = nullptr;
	}

	/* Move assignment. */
	String& operator=(String&& other) noexcept
	{
		if (&other != this)
		{
			this->release();

			this->m_length = other.m_length;
			this->m_capacity = other.m_capacity;
			this->m_pool = other.m_pool;
			this->m_tag = other.m_tag;
			this->m_data = other.m_data;

			other.m_length = 0;
			other.m_data = nullptr;
		}

		return *this;
	}

	/* Destructor */
	~String()
	{
		this->release();
	}

	/* Append operator. */
	String& operator+=(const String& other)
	{
		return this->append(other.m_data, other.m_length);
	}

	/* Append operator for WCHAR type. */
	String& operator+=(const PCWSTR data)
	{
		this->m_length += static_cast<ULONG>(wcslen(data));
		PWCHAR newBuffer = this->allocate(this->m_length, this->m_data);

		wcscat_s(newBuffer, this->m_length + 1, data);

		this->release();
		this->m_data = newBuffer;

		return *this;
	}

	/* Equality operator. */
	bool operator==(const String& other)
	{
		return
			this->m_data == other.m_data &&
			this->m_pool == other.m_pool &&
			this->m_tag == other.m_tag &&
			this->m_length == other.m_length;
	}

	/*
	 * Compare given String with this one.
	 * Return a zero value if both Strings are considered equal.
	 * otherwise return a value represent which String is greater.
	 */
	int compare(const String& other)
	{
		return wcscmp(this->m_data, other.m_data);
	}

	operator const PWCHAR() const {
		return this->m_data;
	}

	PWCHAR get() const
	{
		return static_cast<const PWCHAR>(this->m_data);
	}

	ULONG length() const
	{
		return this->m_length;
	}

	bool empty() const
	{
		return 0 == this->m_length;
	}

	/*
	 * Return copy of this String with lower case data.
	 */
	String toLower() const
	{
		String temp(this->m_data);
		_wcslwr(temp.m_data);

		return temp;
	}

	/*
	 * Convert data to lower case.
	 */
	String& toLower()
	{
		_wcslwr(this->m_data);
		return *this;
	}

	/*
	 * Return copy of this String with upper case data.
	 */
	String toUpper() const
	{
		String temp(this->m_data);
		_wcsupr(temp.m_data);

		return temp;
	}

	/*
	 * Convert data to upper case.
	 */
	String& toUpper()
	{
		_wcsupr(this->m_data);
		return *this;
	}

	/*
	 * Place null terminator in the String data at given index.
	 */
	String& truncate(ULONG index)
	{
		NT_ASSERT(index >= this->m_length);

		this->m_length = index;
		this->m_data[this->m_length] = L'\0';

		return *this;
	}

	/*
	 * Return character of the data at given index.
	 */
	const WCHAR getAt(const size_t index) const
	{
		NT_ASSERT(index < this->m_length);

		return const_cast<const WCHAR>(this->m_data[index]);
	}

	/*
	 * Return reference for character of the data at given index.
	 */
	WCHAR& getAt(const size_t index)
	{
		NT_ASSERT(index < this->m_length);

		return this->m_data[index];
	}

	/*
	 * Return character of the data at given index using [] operator.
	 */
	const WCHAR operator[](const size_t index) const
	{
		return getAt(index);
	}

	/*
	 * Return reference for character of the data at given index using [] operator.
	 */
	WCHAR& operator[](const size_t index)
	{
		return getAt(index);
	}

	/*
	 * Convert class data to UNICODE_STRING type.
	 */
	UNICODE_STRING* getUnicodeString(const PUNICODE_STRING unicodeString)
	{
		RtlInitUnicodeString(unicodeString, this->m_data);
		return unicodeString;
	}

	/*
	 * Find the first occurrence of this String in other String
	 * and return the pointer to this location.
	 */
	const WCHAR* findOccurrence(const String& other)
	{
		if (0 >= this->m_length || 0 >= other.m_length)
		{
			return nullptr;
		}

		return wcsstr(other.m_data, this->m_data);
	}

	/*
	 * Check if this String is sub-string of other String.
	 */
	bool isSubString(const String& other)
	{
		return nullptr != this->findOccurrence(other);
	}

	/* Release allocated memory for class data. */
	void release()
	{
		if (nullptr != this->m_data)
		{
			delete this->m_data;
			this->m_data = nullptr;
		}
	}

private:
	/* Allocate memory and copy the data from the source to the new allocated memory. */
	PWCHAR allocate(size_t numOfChars, const PWCHAR source = nullptr) const
	{
		const auto buffer = static_cast<PWCHAR>(ExAllocatePoolWithTag(PoolType, sizeof(WCHAR) * (numOfChars + 1), Tag));
		if (nullptr == buffer)
		{
			KdPrint(("Failed to allocate kstring of length %d chars\n", numOfChars));
			return nullptr;
		}
		else
		{
			const SIZE_T sourceLength = wcslen(source) + 1;
			const SIZE_T size = (sourceLength < numOfChars ? sourceLength : numOfChars);
			wcscpy_s(buffer, size, source);
		}
		return buffer;
	}

	static PWCHAR allocateReservedBuffer(ULONG bufferSize)
	{
		const auto buffer = static_cast<PWCHAR>(ExAllocatePoolWithTag(PoolType, bufferSize, Tag));
		if (nullptr == buffer)
		{
			KdPrint(("Failed to allocate buffer of length %d chars\n", bufferSize));
			return nullptr;
		}
		else
		{
			RtlZeroMemory(buffer, bufferSize);
		}
		return buffer;
	}

	/* Concatenate another string to this string. */
	String& append(const PCWSTR data, ULONG len = 0)
	{
		if (0 == len)
		{
			len = static_cast<ULONG>(wcslen(data));
		}

		bool newAlloc = false;
		PWCHAR newBuffer = this->m_data;

		this->m_length += len;

		if (this->m_length + 1 > this->m_capacity)
		{
			this->m_capacity = this->m_length + this->INCREASE_SIZE;
			newBuffer = this->allocate(this->m_capacity, this->m_data);
			newAlloc = true;
		}

		wcsncat_s(newBuffer, this->m_capacity, data, len);

		if (newAlloc)
		{
			this->release();
			this->m_data = newBuffer;
		}
		return *this;
	}

	const ULONG INCREASE_SIZE = 9;

	PWCHAR m_data;
	ULONG m_length;
	ULONG m_capacity;
	POOL_TYPE m_pool;
	ULONG m_tag;
};
```

`StresserEngine/Value.h`:

```h
#pragma once

#include "DriverConfiguration.h"
#include "Move.h"

#include <ntifs.h>

template<typename ReturnedValue, typename Error = ULONG>
class Value
{
public:
	// Disable default constructor:
	Value() = delete;

	// Allow conversion:
	Value(ReturnedValue& value) : m_value(value), m_isError(false) { }
	Value(ReturnedValue&& value) : m_value(move(value)), m_isError(false) { }

	// Allow conversion from ErrorValue:
	Value(Error& error) : m_isError(true), m_error(error) { }
	Value(Error&& error) : m_value(), m_isError(true), m_error(move(error)) { }

	/* Return the value data. */
	const ReturnedValue& getValue() { return this->m_value; }

	/* Return if there is an error. */
	bool isError() const { return this->m_isError; }

	/* If exists return the error value, otherwise throw. */
	const Error& getError()
	{
		return this->m_error;
	}

private:
	ReturnedValue m_value;
	bool m_isError;
	Error m_error;
};
```

`StresserEngine/Vector.h`:

```h
#pragma once

#include "FastMutex.h"
#include "AutoLock.h"

#include <ntifs.h>

template<typename T, ULONG Tag, POOL_TYPE PoolType = PagedPool>
class Vector
{
	static_assert(Tag != 0, "Tag cannot be zero");

public:
	explicit Vector(const ULONG capacity = 4)
		: m_items(nullptr), m_size(0), m_capacity(capacity)
	{
		this->m_items = this->allocate(capacity);
		this->m_lock.init();
	}

	~Vector()
	{
		__try
		{
			this->free();
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			KdPrint(("Exception was thrown in Vector destructor\n"));
		}
	}

	// Delete copy constructor, assignment operator, move constructor, move operator:
	Vector(const Vector&) = delete;
	Vector& operator=(const Vector&) = delete;
	Vector(Vector&&) = delete;
	Vector& operator=(Vector&&) = delete;

	/*
	 * Return the number of items in the vector.
	 */
	const ULONG size() const
	{
		return this->m_size;
	}

	/*
	 * Return the maximum number of items that could be stored in the vector.
	 */
	size_t capacity() const
	{
		return this->m_capacity;
	}

	/*
	 * Add new item to the vector, update the capacity (if needed) and the size of the vector.
	 */
	void add(const T& item)
	{
		AutoLock<FastMutex> lock(this->m_lock);

		if (this->m_size == this->m_capacity)
		{
			this->resize(this->m_capacity * 2);
		}

		this->m_items[this->m_size] = item;
		++this->m_size;
	}

	/*
	 * Return item by it's index.
	 */
	T getAt(const ULONG index)
	{
		AutoLock<FastMutex> lock(this->m_lock);

		if (this->isValidIndexCapacity(index))
		{
			return this->m_items[index];
		}

		return nullptr;
	}

	/*
	 * Return reference to item by it's index.
	 */
	const T getAt(const ULONG index) const
	{
		AutoLock<FastMutex> lock(this->m_lock);

		if (this->isValidIndexCapacity(index))
		{
			return this->m_items[index];
		}


		return nullptr;
	}

	/*
	 * Return item by it's index using the [] operator.
	 */
	T& operator[](const size_t index)
	{
		return this->getAt(index);
	}

	/*
	 * Return reference to item by it's index using the[] operator.
	 */
	const T& operator[](const size_t index) const
	{
		return this->getAt(index);
	}

	/*
	 * Set item by it's index.
	 */
	void setAt(ULONG index, const T& item)
	{
		AutoLock<FastMutex> lock(this->m_lock);

		if (this->isValidIndexSize(index))
		{
			this->m_items[index] = item;
		}
	}

	/*
	 * Remove item by it's index.
	 */
	void removeAt(ULONG index)
	{
		AutoLock<FastMutex> lock(this->m_lock);

		if (!this->isValidIndexSize(index))
		{
			return;
		}

		// The item is not the last item:
		if (index < this->m_size - 1)
		{
			// Shift all the items one index backward:
			memcpy(this->m_items + index, this->m_items + index + 1, sizeof(T) * (this->m_size - index - 1));
		}

		// The item is the last item:
		--this->m_size;
	}

	/*
	 * Return pointer to the begin of the data.
	 */
	T* begin()
	{
		return this->m_items;
	}

	/*
	 * Return constant pointer to the begin of the data.
	 */
	const T* begin() const
	{
		return this->m_items;
	}

	/*
	 * Return pointer to the end of the data.
	 */
	T* end()
	{
		return this->m_items + this->m_size;
	}

	/*
	 * Return constant pointer to the end of the data.
	 */
	const T* end() const
	{
		return m_items + this->m_size;
	}

	/*
	 * Change the maximum number of items the vector could store.
	 */
	void resize(const ULONG capacity)
	{
		if (!this->isValidIndexCapacity(capacity))
		{
			return;
		}

		this->m_capacity = capacity;

		T* items = this->allocate(this->m_capacity);
		if (nullptr == items)
		{
			return;
		}

		memcpy(items, this->m_items, sizeof(T) * this->m_size);

		this->m_items = items;
	}

	/* Release all the allocated memory and zero sizes. */
	void clear()
	{
		AutoLock<FastMutex> lock(this->m_lock);

		memset(this->m_items, 0, this->m_capacity);

		this->m_size = 0;
	}

private:
	/*
	 * Allocate continues memory in size of the given size.
	 */
	T* allocate(const ULONG size)
	{
		if (!this->isValidIndexCapacity(size))
		{
			return nullptr;
		}

		auto* buffer = static_cast<T*>(ExAllocatePoolWithTag(PoolType, sizeof(T) * size, Tag));
		if (nullptr == buffer)
		{
			KdPrint(("Could not resize the vector, invalid memory\n"));
			return nullptr;
		}

		RtlZeroMemory(buffer, sizeof(T) * size);
		return buffer;
	}

	/* Free all the allocated memory */
	void free()
	{
		if (nullptr != this->m_items)
		{
			ExFreePoolWithTag(this->m_items, Tag);
		}
	}

	bool isValidIndexCapacity(ULONG index)
	{
		return (0 <= index && index <= this->m_capacity);
	}

	bool isValidIndexSize(ULONG index)
	{
		return (0 <= index && index <= this->m_size);
	}

	T* m_items;			// Pointer to the items in the vector
	ULONG m_size;		// The actual number of items in the vector
	ULONG m_capacity;	// The maximum number of items in the vector
	FastMutex m_lock{};
};

```

`Utils/AutoCriticalSection.cpp`:

```cpp
#include "pch.h"
#include "AutoCriticalSection.h"

AutoCriticalSection::AutoCriticalSection()
{
	this->m_criticalSection.reset(new CriticalSection());
	if (nullptr == this->m_criticalSection.get())
	{
		throw std::runtime_error("Could not create CriticalSection");
	}

	this->m_criticalSection->enter();
}

AutoCriticalSection::~AutoCriticalSection()
{
	this->m_criticalSection->leave();
}

```

`Utils/AutoCriticalSection.h`:

```h
#pragma once
#include "CriticalSection.h"

class AutoCriticalSection
{
public:
	AutoCriticalSection();
	~AutoCriticalSection();

	// delete copy ctor, move ctor, assignment
	AutoCriticalSection(const AutoCriticalSection&) = delete;
	AutoCriticalSection& operator=(const AutoCriticalSection&) = delete;
	AutoCriticalSection(AutoCriticalSection&&) = delete;
	AutoCriticalSection& operator=(AutoCriticalSection&&) = delete;

private:
	std::unique_ptr<CriticalSection> m_criticalSection;
};


```

`Utils/AutoHandle.cpp`:

```cpp
#include "pch.h"
#include "AutoHandle.h"

void HandleDeleter::operator()(const HANDLE& handle) const
{
	if (INVALID_HANDLE_VALUE != handle)
	{
		CloseHandle(handle);
	}
}

```

`Utils/AutoHandle.h`:

```h
#pragma once
#include "pch.h"
#include <memory>
#include <Windows.h>

struct HandleDeleter
{
	void operator()(const HANDLE& handle) const;
};

using AutoHandle = std::unique_ptr<void, HandleDeleter>;
```

`Utils/AutoRegistryKeyHandle.cpp`:

```cpp
#include "pch.h"
#include "AutoRegistryKeyHandle.h"

AutoRegistryKeyHandle::AutoRegistryKeyHandle(const HKEY& handle)
	: m_handle(handle)
{
}

AutoRegistryKeyHandle::~AutoRegistryKeyHandle()
{
	try
	{
		this->registryKeyHandleDeleter();
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in AutoRegistryKeyHandle destructor");
	}
}

void AutoRegistryKeyHandle::reset(const HKEY& handle)
{
	if (nullptr != this->m_handle)
	{
		this->registryKeyHandleDeleter();
	}

	this->m_handle = handle;
}

HKEY AutoRegistryKeyHandle::get() const
{
	return this->m_handle;
}

void AutoRegistryKeyHandle::registryKeyHandleDeleter() const
{
	if (nullptr != this->m_handle)
	{
		if (ERROR_SUCCESS != RegCloseKey(this->m_handle))
		{
			throw Win32ErrorCodeException("Could not close the registry key handle");
		}
	}
}
```

`Utils/AutoRegistryKeyHandle.h`:

```h
#pragma once
#include "Win32ErrorCodeException.h"
#include "DebugPrint.h"
#include <Windows.h>

class AutoRegistryKeyHandle final
{
public:
	explicit AutoRegistryKeyHandle(const HKEY& handle);

	~AutoRegistryKeyHandle();

	// Delete copy constructor, assignment operator, move constructor, move operator:
	AutoRegistryKeyHandle(const AutoRegistryKeyHandle&) = delete;
	AutoRegistryKeyHandle& operator=(const AutoRegistryKeyHandle&) = delete;
	AutoRegistryKeyHandle(AutoRegistryKeyHandle&&) = delete;
	AutoRegistryKeyHandle& operator=(AutoRegistryKeyHandle&&) = delete;

	/* Set the HKEY member, close the old one if exists. */
	void reset(const HKEY& handle);

	/* Return the HKEY member. */
	HKEY get() const;

protected:
	/* Try to close the HKEY, throw exception if failed. */
	void registryKeyHandleDeleter() const;

	HKEY m_handle;
};
```

`Utils/AutoServiceHandle.cpp`:

```cpp
#include "pch.h"
#include "AutoServiceHandle.h"
#include "Win32ErrorCodeException.h"

AutoServiceHandle::AutoServiceHandle(const SC_HANDLE& handle)
	: m_handle(handle)
{
}

AutoServiceHandle::~AutoServiceHandle()
{
	try
	{
		this->serviceHandleDeleter();
	}
	catch (...)
	{
		// Intentionally left black
	}
}

void AutoServiceHandle::reset(const SC_HANDLE& handle)
{
	if (nullptr != this->m_handle)
	{
		this->serviceHandleDeleter();
	}

	this->m_handle = handle;
}

SC_HANDLE AutoServiceHandle::get() const
{
	return this->m_handle;
}

void AutoServiceHandle::serviceHandleDeleter() const
{
	if (nullptr != this->m_handle)
	{
		if (!CloseServiceHandle(this->m_handle))
		{
			throw Win32ErrorCodeException("Could not close the service handle");
		}
	}
}
```

`Utils/AutoServiceHandle.h`:

```h
#pragma once

#include <Windows.h>

class AutoServiceHandle final
{
public:
	explicit AutoServiceHandle(const SC_HANDLE& handle);

	~AutoServiceHandle();

	// Disable: copyable, assignable, movable:
	AutoServiceHandle(const AutoServiceHandle&) = delete;
	AutoServiceHandle& operator=(const AutoServiceHandle&) = delete;
	AutoServiceHandle(AutoServiceHandle&&) = delete;
	AutoServiceHandle& operator=(AutoServiceHandle&&) = delete;

	/* Set the SC_HANDLE member, close the old one if exists. */
	void reset(const SC_HANDLE& handle);

	/* Return the SC_HANDLE member. */
	SC_HANDLE get() const;

protected:
	/* Try to close the SC_HANDLE, throw exception if failed. */
	void serviceHandleDeleter() const;

	SC_HANDLE m_handle;
};
```

`Utils/AutoSignedImageVerifier.cpp`:

```cpp
#include "pch.h"
#include "AutoSignedImageVerifier.h"
#include "DebugPrint.h"
#include "Win32ErrorCodeException.h"

#include <stdexcept>

AutoSignedImageVerifier::AutoSignedImageVerifier(std::wstring filePath, GUID trustProvider)
	: m_filePath(filePath), m_trustProviderGuid(trustProvider), m_fileInfo{ 0 }, m_winTrustData{ 0 }
{
	if (m_filePath.empty())
	{
		throw std::runtime_error("Invalid filename");
	}

	this->m_fileInfo = this->getDefaultFileInfo();
	this->m_winTrustData = this->getDefaultWinTrustData();
}

AutoSignedImageVerifier::~AutoSignedImageVerifier()
{
	try
	{
		this->closeResources();
	}
	catch (const Win32ErrorCodeException& exception)
	{
		DEBUG_PRINT(exception.what());
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in AutoSignedImageVerifier destructor");
	}
}

VerificationResult AutoSignedImageVerifier::verify()
{
	const LONG status = WinVerifyTrust(nullptr, &m_trustProviderGuid, &m_winTrustData);
	if (ERROR_SUCCESS == status)
	{
		return { true, status };
	}
	else
	{
		return { false, status };
	}
}

WINTRUST_FILE_INFO AutoSignedImageVerifier::getDefaultFileInfo() const
{
	const WINTRUST_FILE_INFO fileInfo
	{
		sizeof(WINTRUST_FILE_INFO), // Structure size
		this->m_filePath.c_str(),	// Full path to the file
		nullptr,					// Optional, handle to file
		nullptr						// Optional, GUID
	};

	return fileInfo;
}

WINTRUST_DATA AutoSignedImageVerifier::getDefaultWinTrustData() const
{
	WINTRUST_DATA winTrustData{ 0 };

	memset(&winTrustData, 0, sizeof(winTrustData));

	winTrustData.cbStruct = sizeof(winTrustData);
	winTrustData.pPolicyCallbackData = nullptr; // Use default code signing EKU.
	winTrustData.pSIPClientData = nullptr; // No data to pass to SIP.
	winTrustData.dwUIChoice = WTD_UI_NONE; // Disable WVT UI.
	winTrustData.fdwRevocationChecks = WTD_REVOKE_NONE; // No revocation checking.
	winTrustData.dwUnionChoice = WTD_CHOICE_FILE; // Verify an embedded signature on a file.
	winTrustData.dwStateAction = WTD_STATEACTION_VERIFY; // Verify action.
	winTrustData.hWVTStateData = nullptr; // Verification sets this value.
	winTrustData.pwszURLReference = nullptr; // Not used.
	winTrustData.dwUIContext = 0; // Not used if WVT UI disabled
	winTrustData.pFile = const_cast<WINTRUST_FILE_INFO_*>(&this->m_fileInfo); // Set pFile.

	return winTrustData;
}

void AutoSignedImageVerifier::closeResources()
{
	// Any hWVTStateData must be released by a call with close.
	m_winTrustData.dwStateAction = WTD_STATEACTION_CLOSE;

	const LONG status = WinVerifyTrust(nullptr, &m_trustProviderGuid, &m_winTrustData);

	if (ERROR_SUCCESS != status)
	{
		throw Win32ErrorCodeException("Could not release verification handle");
	}
}

```

`Utils/AutoSignedImageVerifier.h`:

```h
#pragma once

#include <string>

#include <SoftPub.h>
#include <WinTrust.h>

#pragma comment (lib, "wintrust")

using VerificationResult = std::pair<bool, LONG>;

/*
	Verify if given path to PE file is signed by valid certificate.
	Signed file:
		- Hash that represents the subject is trusted.
		- Trusted publisher without any verification errors.
		- No publisher or time stamp chain errors
 */
class AutoSignedImageVerifier
{
public:
	explicit AutoSignedImageVerifier(std::wstring filePath, GUID trustProvider = WINTRUST_ACTION_GENERIC_VERIFY_V2);

	virtual ~AutoSignedImageVerifier();

	// Disable: copyable, assignable, movable:
	AutoSignedImageVerifier(AutoSignedImageVerifier&) = delete;
	AutoSignedImageVerifier& operator=(AutoSignedImageVerifier&) = delete;
	AutoSignedImageVerifier(AutoSignedImageVerifier&&) = delete;
	AutoSignedImageVerifier& operator=(AutoSignedImageVerifier&&) = delete;

	VerificationResult verify();

private:
	WINTRUST_FILE_INFO getDefaultFileInfo() const;
	WINTRUST_DATA getDefaultWinTrustData() const;

	void closeResources();

	std::wstring m_filePath;
	GUID m_trustProviderGuid;
	WINTRUST_FILE_INFO m_fileInfo;
	WINTRUST_DATA m_winTrustData;
};


```

`Utils/CriticalSection.cpp`:

```cpp
#include "pch.h"
#include "CriticalSection.h"
#include "Win32ErrorCodeException.h"

CriticalSection::CriticalSection(DWORD spinCount, DWORD flags)
{
	if (!InitializeCriticalSectionEx(&this->m_criticalSection, spinCount, flags))
	{
		throw Win32ErrorCodeException("Could not initialize critical section");
	}
}

CriticalSection::~CriticalSection()
{
	DeleteCriticalSection(&this->m_criticalSection);
}

void CriticalSection::enter()
{
	EnterCriticalSection(&this->m_criticalSection);
}

bool CriticalSection::tryEnter()
{
	return TryEnterCriticalSection(&this->m_criticalSection);
}

void CriticalSection::leave()
{
	LeaveCriticalSection(&this->m_criticalSection);
}

```

`Utils/CriticalSection.h`:

```h
#pragma once

#include <Windows.h>

/*
 * Wrapper class for Win32 CRITICAL_SECTION type.
 */
class CriticalSection
{
public:
	CriticalSection(DWORD spinCount = 0, DWORD flags = 0);
	~CriticalSection();

	void enter();
	bool tryEnter();
	void leave();

private:
	CRITICAL_SECTION m_criticalSection;
};


```

`Utils/DebugPrint.h`:

```h
#pragma once

#include "TimeUtils.h"
#include "StringUtils.h"

#include <iostream>
#include <utility>

/*
	Helper Macro to print message only in debug mode.
 */
#ifdef _DEBUG
#define DEBUG_PRINT(message)			\
do {									\
  std::cout << (message) << std::endl;	\
} while (0)
#else
#define DEBUG_PRINT(message)	// <-- Empty on purpose to prevent printing message in release mode
#endif

#ifdef _DEBUG
#define DEBUG_WPRINT(message)			\
do {									\
  std::wcout << (message) << std::endl;	\
} while (0)
#else
#define DEBUG_WPRINT(message)	// <-- Empty on purpose to prevent printing message in release mode
#endif

 /*
	 Return the token himself.
	 https://stackoverflow.com/q/55636670
 */
#define STRINGIFY(x) #x
#define STRINGIFY_A(x) #x

 /*
  * Print varargs.
  * https://stackoverflow.com/a/29326784
  */
template<typename ...Args>
void logA(Args&& ...args)
{
	(std::cout << ... << args);
}

template<typename ...Args>
void logW(Args&& ...args)
{
	(std::wcout << ... << args);
}

/*
 *
 */
#ifdef _DEBUG
#define DEBUG_TRACE(symbol, ...)		\
do{										\
	std::cout							\
	<< TimeUtils::getCurrentTimestamp()	\
	<< " "								\
	<< STRINGIFY_A(symbol)				\
	<< " ";								\
	logA(__VA_ARGS__);					\
	std::cout << std::endl;				\
} while (0)
#else
#define debugTrace(message, ...)	// <-- Empty on purpose to prevent printing message in release mode
#endif

 /*
  *
  */
#ifdef _DEBUG
#define DEBUG_WTRACE(symbol, ...)										\
do {																	\
	std::wcout															\
	<< StringUtils::stringToWString(TimeUtils::getCurrentTimestamp())	\
	<< " "																\
	<< STRINGIFY(symbol)												\
	<< " ";																\
	logW(__VA_ARGS__);													\
	std::wcout << std::endl;											\
} while (0)
#else
#define DEBUG_WPRINT(message)	// <-- Empty on purpose to prevent printing message in release mode
#endif
```

`Utils/EventsNames.h`:

```h
#pragma once
constexpr wchar_t STOP_STRESSER[] = L"Global\\StopStresser";
constexpr wchar_t CHANGE_POLICY[] = L"Global\\ChangePolicy";
constexpr wchar_t LOST_CONNECTION_EVENT_NAME[] = L"Global\\StresserLostConnection";
```

`Utils/LocalPcUtils.cpp`:

```cpp
#include "pch.h"
#include "LocalPcUtils.h"

#include "StringUtils.h"
#include "Win32ErrorCodeException.h"

#include <boost/asio/ip/udp.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/ip/tcp.hpp>

#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

namespace net = boost::asio;        // from <boost/asio.hpp>
using udp = net::ip::udp;
using tcp = net::ip::tcp;

std::wstring LocalPcUtils::getLocalComputerName()
{
	std::vector<WCHAR> buffer(MAX_COMPUTERNAME_LENGTH + 1);
	DWORD dwNameLength = MAX_COMPUTERNAME_LENGTH + 1;

	if (!GetComputerName(reinterpret_cast<LPWSTR>(&buffer[0]), &dwNameLength)) {
		throw Win32ErrorCodeException("Could not get local computer name");
	}

	return std::wstring(&buffer[0]);
}

bool LocalPcUtils::doesFileExists(const std::wstring& path)
{
	const DWORD fileAttributes = GetFileAttributes(path.c_str());
	return (fileAttributes != INVALID_FILE_ATTRIBUTES) &&
		!(fileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

std::wstring LocalPcUtils::getTempPath()
{
	std::vector<WCHAR> tempPath(MAX_PATH + 1);
	if (GetTempPath(MAX_PATH + 1, reinterpret_cast<LPWSTR>(&tempPath[0])) == 0)
	{
		throw Win32ErrorCodeException("Can't retrieve the temp directory path!");
	}

	return std::wstring(reinterpret_cast<LPWSTR>(&tempPath[0]));
}

std::wstring LocalPcUtils::getDosNameFromNtName(const std::wstring& ntPath)
{
	static std::vector<std::pair<std::wstring, std::wstring>> deviceNames;
	if (deviceNames.empty())
	{
		auto drives = GetLogicalDrives();
		size_t drive = 0;
		while (drives)
		{
			if (drives & 1)
			{
				// drive exists
				WCHAR driveName[] = L"X:";
				driveName[0] = (WCHAR)(drive + 'A');
				WCHAR path[MAX_PATH];
				if (QueryDosDevice(driveName, path, MAX_PATH))
				{
					deviceNames.emplace_back(path, driveName);
				}
			}
			drive++;
			drives >>= 1;
		}
	}

	for (auto& deviceName : deviceNames)
	{
		if (ntPath.find(deviceName.first) != std::wstring::npos)
		{
			return deviceName.second + (ntPath.c_str() + deviceName.first.size());
		}
	}

	throw std::runtime_error("could not find relevant DOS path");
}

bool LocalPcUtils::doesTestSigningEnabled()
{
	SYSTEM_CODEINTEGRITY_INFORMATION systemCodeIntegrityInformation = { 0 };
	systemCodeIntegrityInformation.Length = sizeof(systemCodeIntegrityInformation);

	ULONG returnLength = 0;
	const NTSTATUS status = NtQuerySystemInformation(
		SystemCodeIntegrityInformation,
		&systemCodeIntegrityInformation,
		sizeof(systemCodeIntegrityInformation),
		&returnLength
	);

	if (NT_SUCCESS(status) && returnLength == sizeof(systemCodeIntegrityInformation))
	{
		// Note that testsigning will play no role if bit CODEINTEGRITY_OPTION_ENABLED (or 0x1)
		// is not set in sci.CodeIntegrityOptions
		const bool doesTestSignEnabled = (systemCodeIntegrityInformation.CodeIntegrityOptions & CODEINTEGRITY_OPTION_TESTSIGN);
		return doesTestSignEnabled;
	}

	return false;
}
std::wstring LocalPcUtils::getLocalComputerIp()
{
	try {
		boost::asio::io_service netService;
		udp::endpoint ep(net::ip::address::from_string("8.8.8.8"), 53);
		udp::socket socket(netService);
		socket.connect(ep);
		boost::asio::ip::address addr = socket.local_endpoint().address();
		return StringUtils::stringToWString(addr.to_string());
	}
	catch (std::exception& e) {
		std::cerr << "Could not deal with socket. Exception: " << e.what() << std::endl;

	}

	throw std::exception("Cant get local computer ip");
}

bool LocalPcUtils::doesNetworkConnectionAvailable()
{
	try
	{
		std::string googleAddress("8.8.8.8");
		std::string googlePort("53");

		boost::asio::io_service io_service;

		tcp::resolver resolver(io_service);
		tcp::resolver::query query(tcp::v4(), googleAddress, googlePort);
		tcp::resolver::iterator iterator = resolver.resolve(query);

		tcp::socket s(io_service);

		s.connect(*iterator);
		Sleep(250);
		s.close();

		return true;
	}
	catch (const boost::system::system_error& exception)
	{
		return false;
	}
}


```

`Utils/LocalPcUtils.h`:

```h
#pragma once
#include <string>

/*
 * Include helper methods to query and preform actions on the local PC.
 */
class LocalPcUtils final
{
public:
	/* Return the local computer name in string (ASCII) format. */
	static std::wstring getLocalComputerName();

	static bool doesFileExists(const std::wstring& path);

	static std::wstring getTempPath();

	static std::wstring getDosNameFromNtName(const std::wstring& ntPath);
	/*
		Return if the system setting: testsigning enabled.
		Taken from here:
			https://social.msdn.microsoft.com/Forums/Windowsapps/en-US/e6c1be93-7003-4594-b8e4-18ab4a75d273/
			detecting-testsigning-onoff-via-api?forum=windowsgeneraldevelopmentissues
	*/
	static bool doesTestSigningEnabled();

	static std::wstring getLocalComputerIp();

	static bool doesNetworkConnectionAvailable();
};


```

`Utils/PeResource.cpp`:

```cpp
#include "pch.h"
#include "PeResource.h"

PeResource::PeResource(int resourceId, std::wstring resourceType)
	: m_resourceId(resourceId), m_resourceType(resourceType)
{
	// Search for the resource in the current module
	const HRSRC resource = FindResource(nullptr, MAKEINTRESOURCE(this->m_resourceId), this->m_resourceType.c_str());
	if (nullptr == resource)
	{
		throw Win32ErrorCodeException("Could not find resource with ID: " + this->m_resourceId);
	}

	// Get the resource size
	this->m_resourceSize = SizeofResource(nullptr, resource);
	if (0 >= this->m_resourceSize)
	{
		throw Win32ErrorCodeException("Invalid resource size");
	}

	// Load the resource from the current module
	const HGLOBAL loadedResource = LoadResource(nullptr, resource);
	if (nullptr == loadedResource)
	{
		throw Win32ErrorCodeException("Could not load the resource");
	}

	this->m_resourceData = LockResource(loadedResource);
	if (nullptr == this->m_resourceData)
	{
		throw Win32ErrorCodeException("Could not retrieve pointer to the resource");
	}
}

LPVOID PeResource::getResourceData() const
{
	return this->m_resourceData;
}

void PeResource::saveResourceToFileSystem(const std::wstring& path) const
{
	if (nullptr == this->m_resourceData)
	{
		throw std::runtime_error("Invalid resource data");
	}

	const AutoHandle file(CreateFile(path.c_str(), GENERIC_WRITE, 0, nullptr,
		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr));
	if (INVALID_HANDLE_VALUE == file.get())
	{
		throw Win32ErrorCodeException("Could not create target file");
	}

	DWORD writeBytes;
	if (!WriteFile(file.get(), this->m_resourceData, this->m_resourceSize, &writeBytes, nullptr))
	{
		throw Win32ErrorCodeException("Could not write resource data to target file");
	}
}
```

`Utils/PeResource.h`:

```h
#pragma once
#include "Win32ErrorCodeException.h"
#include "AutoHandle.h"

class PeResource
{
public:
	explicit PeResource(int resourceId, std::wstring resourceType);

	virtual ~PeResource() = default;	// According to MSDN no need to release the lock or the resource.

	// Delete copy constructor, assignment operator, move constructor, move operator:
	PeResource& operator=(const PeResource&) = delete;
	PeResource(const PeResource&) = delete;
	PeResource(PeResource&&) = delete;
	PeResource& operator=(PeResource&&) = delete;

	LPVOID getResourceData() const;

	void saveResourceToFileSystem(const std::wstring& path) const;

private:
	int m_resourceId;
	std::wstring m_resourceType;
	LPVOID m_resourceData;
	int m_resourceSize;
};
```

`Utils/RegistryArtifactUtils.cpp`:

```cpp
#include "pch.h"
#include "RegistryArtifactUtils.h"

const std::map<std::string, HKEY> RegistryArtifactUtils::REGISTRY_PREFIX_DICTIONARY = {
	{ "HKLM", HKEY_LOCAL_MACHINE },
	{ "HKCR", HKEY_CLASSES_ROOT },
	{ "HKU", HKEY_USERS },
	{ "HKCU", HKEY_CURRENT_USER }
};

HKEY RegistryArtifactUtils::getRegistryPrefix(std::string regKey)
{
    std::string regPrefix = regKey.substr(0, regKey.find_first_of("\\"));
    return REGISTRY_PREFIX_DICTIONARY.at(regPrefix);
}

std::string RegistryArtifactUtils::getRegistrySubKey(std::string regKey)
{
	return regKey.substr(regKey.find_first_of("\\") + 2);
}

```

`Utils/RegistryArtifactUtils.h`:

```h
#pragma once
#include <map>
#include <Windows.h>

class RegistryArtifactUtils
{
public:
	static HKEY getRegistryPrefix(std::string regKey);

	static std::string getRegistrySubKey(std::string regKey);

private:
	static const std::map<std::string, HKEY> REGISTRY_PREFIX_DICTIONARY;
};


```

`Utils/SehException.cpp`:

```cpp
#include "pch.h"
#include "SehException.h"

#include <iomanip>
#include <sstream>

SehException::SehException(const std::uint32_t errorCode)
	: m_errorCode(errorCode)
{
	std::stringstream stringStream;
	stringStream << "Got SEH exception, error code: ";
	stringStream << std::hex << std::setw(8) << std::setfill('0') << this->m_errorCode;

	this->m_errorMessage = stringStream.str();
}

char const* SehException::what() const
{
	return this->m_errorMessage.c_str();
}

std::uint32_t SehException::getErrorCode() const
{
	return this->m_errorCode;
}
```

`Utils/SehException.h`:

```h
#pragma once

#include <exception>
#include <iostream>

class SehException : public std::exception
{
public:
	explicit SehException(std::uint32_t errorCode);

	virtual ~SehException() = default;

	// Delete copy constructor & assignment operator
	// @note std::exception using the move constructor when throwing exception.
	SehException(const SehException&) = delete;
	SehException& operator=(const SehException&) = delete;
	SehException(SehException&&) = default;
	SehException& operator=(SehException&&) = default;

	char const* what() const override;

	std::uint32_t getErrorCode() const;

private:
	std::uint32_t m_errorCode;
	std::string m_errorMessage;
};
```

`Utils/SehTranslatorGuard.cpp`:

```cpp
#include "pch.h"
#include "SehTranslatorGuard.h"
#include "SehException.h"

SehTranslatorGuard::SehTranslatorGuard()
	: m_originalSehTranslator(nullptr)
{
	this->m_originalSehTranslator = _set_se_translator(SehTranslatorGuard::sehTranslatorFunction);
}

SehTranslatorGuard::~SehTranslatorGuard()
{
	try
	{
		if (nullptr != this->m_originalSehTranslator)
		{
			_set_se_translator(this->m_originalSehTranslator);
		}
	}
	catch (...)
	{
		// Internationally left blank
	}
}

void SehTranslatorGuard::sehTranslatorFunction(unsigned errorCode, EXCEPTION_POINTERS*)
{
	throw SehException(errorCode);
}
```

`Utils/SehTranslatorGuard.h`:

```h
#pragma once

#include <eh.h>
#include <Windows.h>

/*
 * Set a per-thread callback function to translate Win32 SEH exception into C++ exceptions.
 * @note You must use /EHa when using _set_se_translator.
 * @note _se_translator_function is the type of the translator function.
 * @note _set_se_translator is the function that used to set the translator function.
 */
class SehTranslatorGuard final
{
public:
	SehTranslatorGuard();

	~SehTranslatorGuard();

	// Delete copy constructor, assignment operator, move constructor, move operator:
	SehTranslatorGuard(const SehTranslatorGuard&) = delete;
	SehTranslatorGuard& operator=(const SehTranslatorGuard&) = delete;
	SehTranslatorGuard(SehTranslatorGuard&&) = delete;
	SehTranslatorGuard& operator=(SehTranslatorGuard&&) = delete;

private:
	static void sehTranslatorFunction(unsigned int errorCode, EXCEPTION_POINTERS*);

	_se_translator_function m_originalSehTranslator;
};
```

`Utils/Service.cpp`:

```cpp
#include "pch.h"
#include "Service.h"

Service::Service(std::wstring srvName, std::wstring srvExePath, std::uint32_t srvType) {

	// Set class members:
	this->serviceName = srvName;
	this->serviceExePath = srvExePath;
	this->serviceType = srvType;

	// Connect to the Service Control Manager
	// and open the Services database:
	this->hSCManager = ::OpenSCManager(
		nullptr,				// local machine
		nullptr,				// local database
		SC_MANAGER_ALL_ACCESS	// access required
	);

	// TODO: Take care in failure.
}

bool Service::Install() {

	if (!this->hSCManager)
		return false;

	// Create a new a service object:
	this->hService = ::CreateService(
		this->hSCManager,				// handle of service control manager database
		this->serviceName.c_str(),		// address of name of service to start
		this->serviceName.c_str(),		// address of display name
		SERVICE_ALL_ACCESS,				// type of access to service
		//SERVICE_KERNEL_DRIVER,			// type of service
		static_cast<DWORD>(this->serviceType),	// type of service
		SERVICE_DEMAND_START,			// when to start service
		SERVICE_ERROR_NORMAL,			// severity if service fails to start
		this->serviceExePath.c_str(),   // address of name of binary file
		nullptr,						// service does not belong to a group
		nullptr,						// no tag requested
		nullptr,						// no dependency names
		nullptr,						// use LocalSystem account
		nullptr							// no password for service account
	);

	if (this->hService == NULL)
		return false;

	return true;
}

bool Service::Remove() {

	if (this->hService == NULL)
		return false;

	// Mark the service for deletion from the service control manager database:
	if (::DeleteService(this->hService))
		return true;

	return false;
}

bool Service::Start() {

	BOOL result;

	if (this->hService == NULL)
		return false;

	// Start the execution of the service (i.e. start the driver):
	result = ::StartService(
		this->hService,	// service handler
		0,				// number of arguments
		nullptr			// pointer to arguments
	);

	if (result)
		return true;

	return false;
}

bool Service::Stop() {

	BOOL result;
	SERVICE_STATUS  serviceStatus;

	if (this->hService == NULL)
		return false;

	// Request that the service stop:
	result = ::ControlService(
		this->hService,			// service handler
		SERVICE_CONTROL_STOP,	// control codes
		&serviceStatus			// most recent status
	);

	if (result)
		return true;

	return false;
}

Service::~Service() {
	try {
		if (this->hSCManager)
			::CloseServiceHandle(this->hSCManager);

		if (this->hService)
			::CloseServiceHandle(this->hService);
	}
	catch (...) {
		// TODO: Log the error
	}
}

```

`Utils/Service.h`:

```h
#pragma once

#ifndef __SERVICE_H
#define __SERVICE_H

class Service
{
private:
	SC_HANDLE hService;
	SC_HANDLE hSCManager;
	std::wstring serviceName;
	std::wstring serviceExePath;
	std::uint32_t serviceType;

public:
	Service(std::wstring srvName, std::wstring srvExePath, std::uint32_t srvType);
	~Service();
	bool Install();
	bool Remove();
	bool Start();
	bool Stop();
};

#endif // !__SERVICE_H
```

`Utils/ServiceManager.cpp`:

```cpp
#include "pch.h"
#include "ServiceManager.h"
#include "Win32ErrorCodeException.h"

#include <stdexcept>

ServiceManager::ServiceManager(const std::wstring& serviceName, const std::wstring& filePath, std::uint32_t serviceType)
	: m_serviceName(serviceName), m_serviceBinPath(filePath), m_serviceType(serviceType), m_service(nullptr),
	m_serviceControlManager(nullptr)
{
	this->m_serviceControlManager.reset(OpenSCManager(
		nullptr,				// local machine
		nullptr,				// local database
		SC_MANAGER_ALL_ACCESS	// access required
	));

	if (nullptr == this->m_serviceControlManager.get())
	{
		throw Win32ErrorCodeException("Could not open handle to the SCManager");
	}

	this->tryOpenService();
}

void ServiceManager::install()
{
	if (nullptr == this->m_serviceControlManager.get())
	{
		throw std::runtime_error("Invalid SCManager, could not install the service");
	}

	this->m_service.reset(CreateService(
		this->m_serviceControlManager.get(), // handle of service control manager database
		this->m_serviceName.c_str(),	// address of name of service to start
		this->m_serviceName.c_str(),	// address of display name
		SERVICE_ALL_ACCESS,				// type of access to service
		this->m_serviceType,			// type of service
		SERVICE_DEMAND_START,			// when to start service
		SERVICE_ERROR_NORMAL,			// severity if service fails to start
		this->m_serviceBinPath.c_str(), // address of name of binary file
		nullptr,						// service does not belong to a group
		nullptr,						// no tag requested
		nullptr,						// no dependency names
		nullptr,						// use LocalSystem account
		nullptr							// no password for service account
	));

	if (nullptr == this->m_service.get())
	{
		throw Win32ErrorCodeException("Could not create the service");
	}
}

void ServiceManager::remove() const
{
	if (nullptr == this->m_service.get())
	{
		throw std::runtime_error("Invalid service handle, could not remove the service");
	}

	if (!DeleteService(this->m_service.get()))
	{
		throw Win32ErrorCodeException("Could not remove the service");
	}
}

void ServiceManager::start() const
{
	if (nullptr == this->m_service.get())
	{
		throw std::runtime_error("Invalid service handle, could not start service");
	}

	if (!StartService(this->m_service.get(),
		0,				// number of arguments
		nullptr			// pointer to arguments
	))
	{
		throw Win32ErrorCodeException("Could not start the service");
	}
}

void ServiceManager::stop() const
{
	if (nullptr == this->m_service.get())
	{
		throw std::runtime_error("Invalid service handle, could not stop service");
	}

	SERVICE_STATUS  serviceStatus;
	if (!ControlService(this->m_service.get(),
		SERVICE_CONTROL_STOP,	// control codes
		&serviceStatus			// most recent status
	))
	{
		throw Win32ErrorCodeException("Could not stop the service");
	}
}

void ServiceManager::installAndStart()
{
	this->install();
	this->start();
}

void ServiceManager::stopAndRemove() const
{
	this->stop();
	this->remove();
}

void ServiceManager::tryOpenService()
{
	const SC_HANDLE service = OpenService(this->m_serviceControlManager.get(), this->m_serviceName.c_str(),
		SC_MANAGER_ALL_ACCESS);

	if (nullptr != service)
	{
		this->m_service.reset(service);
	}
}
```

`Utils/ServiceManager.h`:

```h
#pragma once
#include "AutoServiceHandle.h"

#include <iostream>

class ServiceManager
{
public:
	explicit ServiceManager(const std::wstring& serviceName, const std::wstring& filePath, std::uint32_t serviceType);

	virtual ~ServiceManager() = default;

	// Disable: copyable, assignable, movable:
	ServiceManager& operator=(const ServiceManager&) = delete;
	ServiceManager(const ServiceManager&) = delete;
	ServiceManager(ServiceManager&&) = delete;
	ServiceManager& operator=(ServiceManager&&) = delete;

	/* Create a new a service object. */
	void install();

	/* Mark the service for deletion from the service control manager database. */
	void remove() const;

	/* Start the execution of the service. */
	void start() const;

	/* Stop the execution of the service. */
	void stop() const;

	/* Register the service in the SCM and start it. */
	void installAndStart();

	/* Stop the service, remove the service from the SCM. */
	void stopAndRemove() const;

private:
	/* Try open service handle, if succeeded set the service handle member. */
	void tryOpenService();

	std::wstring m_serviceName;
	std::wstring m_serviceBinPath;
	std::uint32_t m_serviceType;
	AutoServiceHandle m_service;
	AutoServiceHandle m_serviceControlManager;
};
```

`Utils/ShutdownSignal.cpp`:

```cpp
#include "pch.h"
#include "ShutdownSignal.h"

ShutdownSignal::ShutdownSignal(std::wstring signalName)
	:m_eventName(signalName) {

	AutoHandle hEvent(::CreateEvent(nullptr, TRUE, FALSE, this->m_eventName.c_str()));
	this->ahShutdownEvent = std::move(hEvent);
}

ShutdownSignal& ShutdownSignal::GetInstance(const std::wstring signalName) {
	// Keep static instance of this class in order to prevent
	// new creations of this class:
	static ShutdownSignal g_instance(signalName);
	return g_instance;
}

ShutdownSignal::~ShutdownSignal() {
	if (this->ahShutdownEvent.get()) {
		::SetEvent(this->ahShutdownEvent.get());
	}
}

const HANDLE ShutdownSignal::Get() {
	return const_cast<HANDLE>(this->ahShutdownEvent.get());
}

```

`Utils/ShutdownSignal.h`:

```h
#pragma once

#include <Windows.h>
#include <iostream>

#include "AutoHandle.h"

/*
* Wrapper class for Win32 event object.
* Auto initiating name event object and managing the access to this object
* as singleton instance fot the entire application.
*/
class ShutdownSignal
{
public:
	// Disable: cloneable, assignable:
	ShutdownSignal(ShutdownSignal& other) = delete;
	void operator=(const ShutdownSignal&) = delete;

	/*
	* Return the singleton instance of this class.
	* @param signalName - the name of the Win32 event.
	* @return Instance of ShutdownSignal.
	*/
	static ShutdownSignal& GetInstance(const std::wstring signalName = L"StresserShutdown");

	~ShutdownSignal();

	/*
	* Returns constant instance of this class event handle.
	* @return Win32 handle for event used to signal application shutdown.
	*/
	const HANDLE Get();

private:
	ShutdownSignal(std::wstring signalName);
	std::wstring m_eventName;
	AutoHandle ahShutdownEvent;
};


```

`Utils/StandardThread.cpp`:

```cpp
#include "pch.h"
#include "StandardThread.h"
#include "DebugPrint.h"

StandardThread::StandardThread(std::function<void()> threadFunction)
	: m_thread(threadFunction)
{
}

StandardThread::StandardThread(std::function<void(LPVOID params)> threadFunction, LPVOID params)
	: m_thread(threadFunction, params)
{
}

StandardThread::~StandardThread()
{
	try
	{
		this->stop();
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in ThreadWrapper destructor");
	}
}

StandardThread::StandardThread(StandardThread&& other)
	: m_thread(std::move(other.m_thread))
{
}

StandardThread& StandardThread::operator=(StandardThread&& other)
{
	this->stop();

	this->m_thread = std::move(other.m_thread);
	return *this;
}

void StandardThread::reset(std::function<void(LPVOID params)> threadFunction, LPVOID params)
{
	this->stop();
	this->m_thread = std::move(std::thread(threadFunction, params));
}

void StandardThread::release()
{
	this->stop();
}

void StandardThread::stop()
{
	if (this->m_thread.joinable())
	{
		this->m_thread.join();
	}
}

```

`Utils/StandardThread.h`:

```h
#pragma once

#include <thread>
#include <functional>

#include <Windows.h>

/*
 * Wrapper for std::thread.
 */
class StandardThread
{
public:
	StandardThread() = default;
	explicit StandardThread(std::function<void()> threadFunction);
	explicit StandardThread(std::function<void(LPVOID params)> threadFunction, LPVOID params);

	virtual ~StandardThread();

	StandardThread(const StandardThread&) = delete;
	StandardThread& operator=(const StandardThread&) = delete;

	StandardThread(StandardThread&& other);
	StandardThread& operator=(StandardThread&& other);

	/* Stop the current running thread and start a new one. */
	void reset(std::function<void(LPVOID params)> threadFunction, LPVOID params);

	/* Stop the current running thread. */
	void release();

private:
	/* Signal the current thread to stop. */
	void stop();

	std::thread m_thread;
};


```

`Utils/StringUtils.cpp`:

```cpp
#include "pch.h"
#include "StringUtils.h"
#include <regex>

std::wstring StringUtils::RemoveQuotationMarks(std::wstring data) {
	static const std::wstring QUOTATION_MARKS(L"\"");

	if (data.size() <= 0) {
		return data;
	}

	auto newData = data;
	if (newData.substr(0, 1).compare(QUOTATION_MARKS) == 0) {
		newData = newData.substr(1, newData.size());
	}

	if (newData.substr(newData.size() - 1, 1).compare(QUOTATION_MARKS) == 0) {
		newData = newData.substr(0, newData.size() - 1);
	}

	return newData;
}

std::string StringUtils::RemoveQuotationMarks(std::string data) {
	static const std::string QUOTATION_MARKS("\"");

	if (data.size() <= 0) {
		return data;
	}

	auto newData = data;
	if (newData.substr(0, 1).compare(QUOTATION_MARKS) == 0) {
		newData = newData.substr(1, newData.size());
	}

	if (newData.substr(newData.size() - 1, 1).compare(QUOTATION_MARKS) == 0) {
		newData = newData.substr(0, newData.size() - 1);
	}

	return newData;
}

std::wstring StringUtils::RemoveNewLine(const std::wstring data)
{
	static const std::wstring NEW_LINE(L"\n");

	if (data.size() <= 0) {
		return data;
	}

	auto newData = data;
	if (newData.substr(newData.size() - 1, 1).compare(NEW_LINE) == 0) {
		newData = newData.substr(0, newData.size() - 1);
	}

	return newData;
}

std::string StringUtils::RemoveNewLine(const std::string data)
{
	static const std::string NEW_LINE("\n");

	if (data.size() <= 0) {
		return data;
	}

	auto newData = data;
	if (newData.substr(newData.size() - 1, 1).compare(NEW_LINE) == 0) {
		newData = newData.substr(0, newData.size() - 1);
	}

	return newData;
}

bool StringUtils::DoesEmptyJSON(const std::wstring data)
{
	static const std::wstring PARENTHESIS(L"{}");

	if (data.size() <= 0) {
		return false;
	}

	if (data.compare(PARENTHESIS) == 0)
		return true;

	return false;
}


bool StringUtils::DoesEmptyJSON(const std::string data)
{
	static const std::string PARENTHESIS("{}");

	if (data.size() <= 0) {
		return false;
	}

	if (data.compare(PARENTHESIS) == 0)
		return true;

	return false;
}

std::wstring StringUtils::stringToWString(const std::string& data)
{
	return std::wstring(ATL::CA2W(data.c_str()));
}

std::string StringUtils::wstringToString(const std::wstring& data)
{
	return std::string(ATL::CW2A(data.c_str()));
}

std::wstring StringUtils::trimBackslash(const std::wstring& data)
{
	return std::regex_replace(data, std::wregex(L"(\\\\)+"), L"\\");
}

```

`Utils/StringUtils.h`:

```h
#pragma once

#include <iostream>
#include <atlconv.h>

class StringUtils final
{
public:
	static std::wstring RemoveQuotationMarks(const std::wstring data);

	static std::string RemoveQuotationMarks(const std::string data);

	static std::wstring RemoveNewLine(const std::wstring data);

	static std::string RemoveNewLine(const std::string data);

	static bool DoesEmptyJSON(const std::wstring data);

	static bool DoesEmptyJSON(const std::string data);

	static std::wstring stringToWString(const std::string& data);

	static std::string wstringToString(const std::wstring& data);

	static std::wstring trimBackslash(const std::wstring& data);
};


```

`Utils/TimeUtils.cpp`:

```cpp
#include "pch.h"
#include "TimeUtils.h"

#include <boost/date_time.hpp>

#include <ctime>

// Add before any ATL header:
// https://social.msdn.microsoft.com/Forums/vstudio/en-US/371a069b-f428-47b5-8f7b-e9ad85964bce/guidnull-undeclared-identifier?forum=vclanguage
#include <cguid.h>
#include <atlbase.h>
#include <atltime.h>

std::string TimeUtils::GetCurrentDateTime() {
	std::time_t tt = std::time(nullptr);
	CHAR buffer[35];
	ctime_s(buffer, 35, &tt);
	return std::string(buffer);
}

std::string TimeUtils::getCurrentTimestamp(std::string format)
{
	const boost::posix_time::ptime now = boost::posix_time::second_clock::local_time();
	const std::tm timestamp = boost::posix_time::to_tm(now);

	std::stringstream stream;
	stream << std::put_time(&timestamp, format.c_str());

	return stream.str();
}

std::wstring TimeUtils::systemTimeToTimestamp(LARGE_INTEGER systemTimeValue, std::wstring format)
{
	// QuadPart representing the LARGE_INTEGER data:
	auto* const systemTime = reinterpret_cast<FILETIME*>(&systemTimeValue.QuadPart);

	// Converting the
	const CTime time(*systemTime);
	return std::wstring(time.Format(format.c_str()));
}

```

`Utils/TimeUtils.h`:

```h
#pragma once

#include <string>

//std::string TIMESTAMP_FORMAT("%d-%m-%Y %H:%M:%S");

/* https://www.boost.org/doc/libs/1_49_0/doc/html/date_time/date_time_io.html */
//std::string SHORT_TIMESTAMP_FORMAT("%x %X");

class TimeUtils final
{
public:
	static std::string GetCurrentDateTime();

	static std::string getCurrentTimestamp(std::string format = "%x %X");

	/*
		Convert system time value to local system time depending the given format.
		@note Formatting codes can be found here:
		https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strftime-wcsftime-strftime-l-wcsftime-l?view=msvc-160#remarks
	 */
	static std::wstring systemTimeToTimestamp(LARGE_INTEGER systemTimeValue, std::wstring format = L"%c");
};


```

`Utils/Utils.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bb0147eb-6672-4d50-b5bb-9ebeff8d5ed7}</ProjectGuid>
    <RootNamespace>Utils</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="AutoCriticalSection.h" />
    <ClInclude Include="AutoRegistryKeyHandle.h" />
    <ClInclude Include="AutoServiceHandle.h" />
    <ClInclude Include="AutoSignedImageVerifier.h" />
    <ClInclude Include="CriticalSection.h" />
    <ClInclude Include="DebugPrint.h" />
    <ClInclude Include="EventsNames.h" />
    <ClInclude Include="PeResource.h" />
    <ClInclude Include="RegistryArtifactUtils.h" />
    <ClInclude Include="ServiceManager.h" />
    <ClInclude Include="StandardThread.h" />
    <ClInclude Include="Win32ErrorCodeException.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="LocalPcUtils.h" />
    <ClInclude Include="SehException.h" />
    <ClInclude Include="SehTranslatorGuard.h" />
    <ClInclude Include="Service.h" />
    <ClInclude Include="ShutdownSignal.h" />
    <ClInclude Include="StringUtils.h" />
    <ClInclude Include="TimeUtils.h" />
    <ClInclude Include="WindowsEvent.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AutoCriticalSection.cpp" />
    <ClCompile Include="AutoHandle.cpp" />
    <ClCompile Include="AutoHandle.h" />
    <ClCompile Include="AutoRegistryKeyHandle.cpp" />
    <ClCompile Include="AutoServiceHandle.cpp" />
    <ClCompile Include="AutoSignedImageVerifier.cpp" />
    <ClCompile Include="CriticalSection.cpp" />
    <ClCompile Include="PeResource.cpp" />
    <ClCompile Include="RegistryArtifactUtils.cpp" />
    <ClCompile Include="ServiceManager.cpp" />
    <ClCompile Include="StandardThread.cpp" />
    <ClCompile Include="Win32ErrorCodeException.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="LocalPcUtils.cpp" />
    <ClCompile Include="SehException.cpp" />
    <ClCompile Include="SehTranslatorGuard.cpp" />
    <ClCompile Include="Service.cpp" />
    <ClCompile Include="ShutdownSignal.cpp" />
    <ClCompile Include="StringUtils.cpp" />
    <ClCompile Include="TimeUtils.cpp" />
    <ClCompile Include="WindowsEvent.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="..\packages\boost.1.72.0.0\build\boost.targets" Condition="Exists('..\packages\boost.1.72.0.0\build\boost.targets')" />
    <Import Project="..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets" Condition="Exists('..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\boost.1.72.0.0\build\boost.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\boost.1.72.0.0\build\boost.targets'))" />
    <Error Condition="!Exists('..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\boost_date_time-vc142.1.72.0.0\build\boost_date_time-vc142.targets'))" />
  </Target>
</Project>
```

`Utils/Utils.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Service.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TimeUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StringUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ShutdownSignal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CriticalSection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoCriticalSection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DebugPrint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Win32ErrorCodeException.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LocalPcUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SehException.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SehTranslatorGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StandardThread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WindowsEvent.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoRegistryKeyHandle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PeResource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RegistryArtifactUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventsNames.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ServiceManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoServiceHandle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AutoSignedImageVerifier.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Service.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoHandle.h">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="TimeUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StringUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ShutdownSignal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CriticalSection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoCriticalSection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Win32ErrorCodeException.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LocalPcUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SehException.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SehTranslatorGuard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StandardThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WindowsEvent.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoRegistryKeyHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PeResource.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegistryArtifactUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ServiceManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoServiceHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AutoSignedImageVerifier.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
</Project>
```

`Utils/Win32ErrorCodeException.cpp`:

```cpp
#include "pch.h"
#include "Win32ErrorCodeException.h"

#include <vector>
#include <sstream>

#include <atlstr.h>

Win32ErrorCodeException::Win32ErrorCodeException(const std::string& errorMessage)
	: std::exception(errorMessage.c_str()), m_errorCode(0)
{
	this->m_errorCode = GetLastError();
	this->m_winErrorMessage = this->getLastErrorMessage();

	std::stringstream messageStream;
	messageStream << std::exception::what();
	messageStream << "\nWindows last error code: 0x";
	messageStream << std::hex << this->m_errorCode;
	messageStream << "\nWindows error message: ";
	messageStream << this->m_winErrorMessage;

	this->m_errorMessage = messageStream.str();
}

const char* Win32ErrorCodeException::what() const
{
	return this->m_errorMessage.c_str();
}

DWORD Win32ErrorCodeException::getErrorCode() const
{
	return this->m_errorCode;
}

std::string Win32ErrorCodeException::getWinErrorMessage() const
{
	return this->m_winErrorMessage;
}

std::string Win32ErrorCodeException::getLastErrorMessage() const
{
	if (m_errorCode == 0)
	{
		return "";
	}

	const int MESSAGE_SIZE = 512;
	std::vector<WCHAR> message(MESSAGE_SIZE);

	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, this->m_errorCode,
		0, &message[0], MESSAGE_SIZE, nullptr);

	return std::string(CW2A(message.data()));
}

```

`Utils/Win32ErrorCodeException.h`:

```h
#pragma once
#include <string>
#include <Windows.h>

class Win32ErrorCodeException : public std::exception
{
public:
	explicit Win32ErrorCodeException(const std::string& message);
	virtual ~Win32ErrorCodeException() = default;

	const char* what() const override;

	// delete copy ctor, move ctor, assignment
	Win32ErrorCodeException(const Win32ErrorCodeException&) = delete;
	Win32ErrorCodeException& operator=(const Win32ErrorCodeException&) = delete;
	Win32ErrorCodeException(Win32ErrorCodeException&&) = default;
	Win32ErrorCodeException& operator=(Win32ErrorCodeException&&) = default;

	/* Get Windows last error code. */
	DWORD getErrorCode() const;

	/* Get Windows message corresponding to the last error that occurred. */
	std::string getWinErrorMessage() const;

protected:
	std::string getLastErrorMessage() const;

	DWORD m_errorCode;
	std::string m_winErrorMessage;
	std::string m_errorMessage;
};


```

`Utils/WindowsEvent.cpp`:

```cpp
#include "pch.h"
#include "WindowsEvent.h"
#include "DebugPrint.h"
#include "Win32ErrorCodeException.h"
#include "AutoCriticalSection.h"

#include <exception>

WindowsEvent::WindowsEvent(const std::wstring& eventName, BOOL initialState, BOOL manualReset,
	LPSECURITY_ATTRIBUTES eventAttributes)
	: m_event(nullptr), m_eventName(eventName)
{
	this->createEvent(eventName, initialState, manualReset, eventAttributes);
}

WindowsEvent::~WindowsEvent()
{
	try
	{
		this->close();
	}
	catch (const std::exception& exception)
	{
		DEBUG_PRINT(exception.what());
	}
	catch (...)
	{
		DEBUG_PRINT("Exception was thrown in WindowsEvent destructor");
	}
}

WindowsEvent::WindowsEvent(const WindowsEvent& other)
{
	this->m_event = other.m_event;
	this->m_eventName = other.m_eventName;
}

WindowsEvent& WindowsEvent::operator=(const WindowsEvent& other)
{
	this->close();

	this->m_event = other.m_event;
	this->m_eventName = other.m_eventName;

	return *this;
}

WindowsEvent::WindowsEvent(WindowsEvent&& other)
{
	this->move(std::move(other));
}

WindowsEvent& WindowsEvent::operator=(WindowsEvent&& other)
{
	this->close();

	this->move(std::move(other));

	return *this;
}

const HANDLE& WindowsEvent::get() const
{
	return this->m_event;
}

void WindowsEvent::setEvent() const
{
	if (!SetEvent(this->m_event))
	{
		throw Win32ErrorCodeException("Could not set the event");
	}
}

void WindowsEvent::resetEvent() const
{
	if (!ResetEvent(this->m_event))
	{
		throw Win32ErrorCodeException("Could not set the event");
	}
}

const std::wstring& WindowsEvent::getName() const
{
	return this->m_eventName;
}

void WindowsEvent::release()
{
	this->close();
}

void WindowsEvent::reset(const std::wstring& eventName, BOOL initialState, BOOL manualReset,
	LPSECURITY_ATTRIBUTES eventAttributes)
{
	this->close();

	this->createEvent(eventName, initialState, manualReset, eventAttributes);
}

DWORD WindowsEvent::wait(DWORD timeout) const
{
	return WaitForSingleObject(this->m_event, timeout);
}

void WindowsEvent::open(const std::wstring& eventName)
{
	if (eventName.empty())
	{
		throw std::runtime_error("Invalid event name to open");
	}

	this->release();

	this->m_event = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, eventName.c_str());
	if (nullptr == this->m_event)
	{
		throw Win32ErrorCodeException("Could not open event object");
	}
}

void WindowsEvent::createEvent(const std::wstring& eventName, BOOL initialState, BOOL manualReset,
	LPSECURITY_ATTRIBUTES eventAttributes)
{
	this->m_event = CreateEvent(eventAttributes, manualReset, initialState, eventName.c_str());
	if (nullptr == this->m_event)
	{
		throw Win32ErrorCodeException("Could not create event object");
	}
}

void WindowsEvent::close()
{
	if (nullptr != this->m_event)
	{
		if (!CloseHandle(this->m_event))
		{
			throw Win32ErrorCodeException("Could not close the event handle");
		}
	}

	this->m_eventName = L"";
}

void WindowsEvent::move(WindowsEvent&& other)
{
	this->m_event = other.m_event;
	this->m_eventName = other.m_eventName;

	other.m_event = nullptr;
	other.m_eventName = L"";
}

```

`Utils/WindowsEvent.h`:

```h
#pragma once

#include <string>

#include <Windows.h>

/*
 * Wrapper for Win32 Event objects.
 */
class WindowsEvent
{
public:
	explicit WindowsEvent(const std::wstring& eventName = L"", BOOL initialState = FALSE, BOOL manualReset = TRUE,
		LPSECURITY_ATTRIBUTES eventAttributes = nullptr);

	virtual ~WindowsEvent();

	// Disable: copyable, assignable:
	WindowsEvent(const WindowsEvent& other);

	WindowsEvent& operator=(const WindowsEvent& other);

	WindowsEvent(WindowsEvent&& other);

	WindowsEvent& operator=(WindowsEvent&& other);

	/* Return handle to the event object. */
	const HANDLE& get() const;

	/* Signal the event object. */
	void setEvent() const;

	/* Reset the event object state.  */
	void resetEvent() const;

	/* Get the name of the event object. */
	const std::wstring& getName() const;

	/* Close the event object resource. */
	void release();

	/* If exists, close the current event object resource and create new one. */
	void reset(const std::wstring& eventName = L"", BOOL initialState = FALSE, BOOL manualReset = TRUE,
		LPSECURITY_ATTRIBUTES eventAttributes = nullptr);

	/* Wait on the event object and return the result. */
	DWORD wait(DWORD timeout = INFINITE) const;

	/* Return if the event object signaled. */
	bool isSignaled() const
	{
		return (WAIT_OBJECT_0 == this->wait(0));
	}

	void open(const std::wstring& eventName);

private:
	/* Create event object from by given values. */
	void createEvent(const std::wstring& eventName, BOOL initialState, BOOL manualReset, LPSECURITY_ATTRIBUTES eventAttributes);

	/* If exists, close the current event object resource. */
	void close();

	/* Move the event object resource form other object to this one. */
	void move(WindowsEvent&& other);

	HANDLE m_event;
	std::wstring m_eventName;
};


```

`Utils/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="boost" version="1.72.0.0" targetFramework="native" />
  <package id="boost_date_time-vc142" version="1.72.0.0" targetFramework="native" />
</packages>
```

`Utils/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`Utils/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef __PCH_UTILS_H
#define __PCH_UTILS_H

// add headers that you want to pre-compile here
#include <iostream>
#include <sstream>
#include <memory>
#include <vector>

#include <Windows.h>
#include <winhttp.h>

#endif //__PCH_UTILS_H

```