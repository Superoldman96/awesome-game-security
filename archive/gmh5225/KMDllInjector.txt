Project Path: arc_gmh5225_KMDllInjector_1suut957

Source Tree:

```txt
arc_gmh5225_KMDllInjector_1suut957
├── DllInjector
│   ├── Callbacks.cpp
│   ├── Callbacks.h
│   ├── Common.h
│   ├── DllInjector.vcxproj
│   ├── DllInjector.vcxproj.filters
│   ├── DrvMain.cpp
│   ├── DrvTypes.h
│   ├── Injector.cpp
│   ├── Injector.h
│   ├── PIC.cpp
│   ├── PIC.h
│   ├── Utils.cpp
│   └── Utils.h
├── DllInjectorClient
│   ├── DllInjectorClient.vcxproj
│   ├── DllInjectorClient.vcxproj.filters
│   ├── Header.h
│   └── Main.cpp
├── KMDllInjector.sln
└── README.md

```

`DllInjector/Callbacks.cpp`:

```cpp
#include "Callbacks.h"

/**
 * @brief Callback function triggered when a process is created.
 *
 * @param Process		A pointer to the EPROCESS structure of the newly created process.
 * @param ProcessId		The process identifier (PID) of the newly created process.
 * @param CreateInfo	A pointer to a PS_CREATE_NOTIFY_INFO structure containing
 *						additional information about the process creation.
 */
VOID OnProcessCreate( PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo )
{
	UNREFERENCED_PARAMETER( Process );

	UNICODE_STRING uProcessName = { 0 };

	if ( !CreateInfo || !CreateInfo->FileOpenNameAvailable ) {
		return;
	}

	RtlInitUnicodeString( &uProcessName, g_ProcessToInject );

	if ( Utils::EndsWithUnicodeString( ( PUNICODE_STRING ) CreateInfo->ImageFileName, &uProcessName, TRUE ) )
	{
		DBG_PRINT( "New process created: %wZ (PID: %d)", CreateInfo->ImageFileName, ( ULONG ) ( ULONG_PTR ) ProcessId );
	
		if ( Injector::InjectDllHook( Process, g_DllToInject ) == FALSE )
			DBG_PRINT( "InjectDllHook Failed" );
	}
}

/**
 * @brief Callback function triggered when an image is loaded.
 *
 * @param FullImageName A pointer to a UNICODE_STRING containing the full path of the loaded image.
 * @param ProcessId		The process identifier (PID) of the process into which the image is being loaded.
 * @param ImageInfo		A pointer to an IMAGE_INFO structure containing details about the loaded image.
 */
VOID OnLoadImage( PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo )
{
	UNREFERENCED_PARAMETER( FullImageName );
	UNREFERENCED_PARAMETER( ProcessId );
	UNREFERENCED_PARAMETER( ImageInfo );

	ASSERT( FullImageName );
	ASSERT( ImageInfo );

	UNICODE_STRING	DllName = { 0 };
	//NTSTATUS		status = 0;

	RtlInitUnicodeString( &DllName, L"\\kernel32.dll" );

	if ( !ImageInfo->SystemModeImage &&
		 ProcessId == PsGetCurrentProcessId( ) &&
		 Utils::EndsWithUnicodeString( FullImageName, &DllName, TRUE ) &&
		 Utils::IsLoadedByLdrLoadDll( &DllName )
		 && Utils::IsSpecificProcessW( ProcessId, g_ProcessToInject, FALSE )
		 )
	{
		DBG_PRINT( "Image load for PID=%u: %wZ", ( ULONG ) ( ULONG_PTR ) ProcessId, FullImageName );
		
		if ( Injector::InjectDllAPC( ProcessId, g_DllToInject ) == FALSE )
			DBG_PRINT( "InjectDllAPC Failed" );
	}
}

```

`DllInjector/Callbacks.h`:

```h
#pragma once

#include "Utils.h"
#include "DrvTypes.h"
#include "Injector.h"
#include "Utils.h"

VOID OnProcessCreate( PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo );
VOID OnLoadImage( PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo );
```

`DllInjector/Common.h`:

```h
#pragma once

#include <ntifs.h>
#include <minwindef.h>
#include <ntimage.h>

#define POOL_TAG		'cjni'

#define DBG_PREFIX	"[>] DLLInjector: "
#define DBG_PRINT(x, ...) DbgPrint(DBG_PREFIX x "\n", __VA_ARGS__)

typedef struct _LDR_MODULE {
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
	PVOID                   BaseAddress;
	PVOID                   EntryPoint;
	ULONG                   SizeOfImage;
	UNICODE_STRING          FullDllName;
	UNICODE_STRING          BaseDllName;
	ULONG                   Flags;
	SHORT                   LoadCount;
	SHORT                   TlsIndex;
	LIST_ENTRY              HashTableEntry;
	ULONG                   TimeDateStamp;
} LDR_MODULE, * PLDR_MODULE;

typedef struct _PEB_LDR_DATA {
	ULONG                   Length;
	BOOLEAN                 Initialized;
	PVOID                   SsHandle;
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;


typedef struct _PEB {
	BOOLEAN                 InheritedAddressSpace;
	BOOLEAN                 ReadImageFileExecOptions;
	BOOLEAN                 BeingDebugged;
	BOOLEAN                 Spare;
	HANDLE                  Mutant;
	PVOID                   ImageBaseAddress;
	PPEB_LDR_DATA           LoaderData;
	PVOID					ProcessParameters;
	PVOID                   SubSystemData;
	PVOID                   ProcessHeap;
	PVOID                   FastPebLock;
	PVOID					FastPebLockRoutine;
	PVOID					FastPebUnlockRoutine;
	ULONG                   EnvironmentUpdateCount;
	PVOID* KernelCallbackTable;
	PVOID                   EventLogSection;
	PVOID                   EventLog;
	PVOID					FreeList;
	ULONG                   TlsExpansionCounter;
	PVOID                   TlsBitmap;
	ULONG                   TlsBitmapBits[ 0x2 ];
	PVOID                   ReadOnlySharedMemoryBase;
	PVOID                   ReadOnlySharedMemoryHeap;
	PVOID* ReadOnlyStaticServerData;
	PVOID                   AnsiCodePageData;
	PVOID                   OemCodePageData;
	PVOID                   UnicodeCaseTableData;
	ULONG                   NumberOfProcessors;
	ULONG                   NtGlobalFlag;
	BYTE                    Spare2[ 0x4 ];
	LARGE_INTEGER           CriticalSectionTimeout;
	ULONG                   HeapSegmentReserve;
	ULONG                   HeapSegmentCommit;
	ULONG                   HeapDeCommitTotalFreeThreshold;
	ULONG                   HeapDeCommitFreeBlockThreshold;
	ULONG                   NumberOfHeaps;
	ULONG                   MaximumNumberOfHeaps;
	PVOID** ProcessHeaps;
	PVOID                   GdiSharedHandleTable;
	PVOID                   ProcessStarterHelper;
	PVOID                   GdiDCAttributeList;
	PVOID                   LoaderLock;
	ULONG                   OSMajorVersion;
	ULONG                   OSMinorVersion;
	ULONG                   OSBuildNumber;
	ULONG                   OSPlatformId;
	ULONG                   ImageSubSystem;
	ULONG                   ImageSubSystemMajorVersion;
	ULONG                   ImageSubSystemMinorVersion;
	ULONG                   GdiHandleBuffer[ 0x22 ];
	ULONG                   PostProcessInitRoutine;
	ULONG                   TlsExpansionBitmap;
	BYTE                    TlsExpansionBitmapBits[ 0x80 ];
	ULONG                   SessionId;

} PEB, * PPEB;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[ 1 ];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef enum _KAPC_ENVIRONMENT {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT, * PKAPC_ENVIRONMENT;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct {
	struct _DISPATCHER_HEADER Header;
	struct _LIST_ENTRY ProfileListHead;
	unsigned int DirectoryTableBase;
	unsigned long Asid;
	struct _LIST_ENTRY ThreadListHead;
} __KPROCESS, *__PKPROCESS;

typedef VOID( NTAPI* PKNORMAL_ROUTINE )(
	_In_ PVOID NormalContext,
	_In_ PVOID SystemArgument1,
	_In_ PVOID SystemArgument2);
typedef VOID KKERNEL_ROUTINE(
	_In_ PRKAPC Apc,
	_Inout_opt_ PKNORMAL_ROUTINE* NormalRoutine,
	_Inout_opt_ PVOID* NormalContext,
	_Inout_ PVOID* SystemArgument1,
	_Inout_ PVOID* SystemArgument2
);
typedef KKERNEL_ROUTINE( NTAPI* PKKERNEL_ROUTINE );
typedef VOID( NTAPI* PKRUNDOWN_ROUTINE )( _In_ PRKAPC Apc );
typedef PETHREAD( NTAPI* PsGetNextProcessThread_t )( PEPROCESS process, PETHREAD thread );

extern "C" {
	NTSTATUS
		NTAPI
		ZwProtectVirtualMemory(
			IN HANDLE               ProcessHandle,
			IN OUT PVOID* BaseAddress,
			IN OUT PULONG           NumberOfBytesToProtect,
			IN ULONG                NewAccessProtection,
			OUT PULONG              OldAccessProtection );
	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwQuerySystemInformation(
			IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
			OUT PVOID SystemInformation,
			IN ULONG SystemInformationLength,
			OUT PULONG ReturnLength OPTIONAL
		);
	VOID NTAPI KeInitializeApc(
		_Out_ PRKAPC Apc,
		_In_ PRKTHREAD Thread,
		_In_ KAPC_ENVIRONMENT Environment,
		_In_ PKKERNEL_ROUTINE KernelRoutine,
		_In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
		_In_opt_ PKNORMAL_ROUTINE NormalRoutine,
		_In_opt_ KPROCESSOR_MODE ProcessorMode,
		_In_opt_ PVOID NormalContext
	);
	BOOLEAN NTAPI KeInsertQueueApc(
		_Inout_ PRKAPC Apc,
		_In_opt_ PVOID SystemArgument1,
		_In_opt_ PVOID SystemArgument2,
		_In_ KPRIORITY Increment
	);

	PPEB NTAPI PsGetProcessPeb( PEPROCESS Process );
	BOOLEAN PsIsProcessBeingDebugged( PEPROCESS Process );
	NTSTATUS WINAPI ZwQueryInformationProcess(
		HANDLE           ProcessHandle,
		PROCESSINFOCLASS ProcessInformationClass,
		PVOID            ProcessInformation,
		ULONG            ProcessInformationLength,
		PULONG           ReturnLength
	);
}

```

`DllInjector/DllInjector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A831FEDD-DC30-4A60-9A23-3F7746001CC2}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>DllInjector</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>$(TargetName.Replace(' ',''))64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>$(TargetName.Replace(' ',''))64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <AdditionalOptions>/INTEGRITIYCHECK %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>false</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Callbacks.cpp" />
    <ClCompile Include="Injector.cpp" />
    <ClCompile Include="DrvMain.cpp" />
    <ClCompile Include="PIC.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Callbacks.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Injector.h" />
    <ClInclude Include="DrvTypes.h" />
    <ClInclude Include="PIC.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DllInjector/DllInjector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DrvMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PIC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DrvTypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PIC.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DllInjector/DrvMain.cpp`:

```cpp
// DrvMain.cpp 

#include "DrvTypes.h"
#include "Callbacks.h"
#include "Injector.h"
#include "Utils.h"

DRIVER_FLAGS	g_Flags = DRIVER_FLAGS::flNone;
WCHAR			g_ProcessToInject[ MAX_PATH ];
WCHAR			g_DllToInject[ MAX_PATH ];

/**
 * @brief Entry point for the driver.
 *
 * @param DriverObject A pointer to the DRIVER_OBJECT structure representing this driver.
 * @param RegistryPath A pointer to a UNICODE_STRING containing the registry path
 *
 * @return STATUS_SUCCESS if the driver initialized successfully.
 *         Otherwise, an appropriate NTSTATUS error code.
 */
extern "C"
NTSTATUS NTAPI DriverEntry( PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath )
{
	UNREFERENCED_PARAMETER( RegistryPath );

	NTSTATUS		status = STATUS_SUCCESS;
	PDEVICE_OBJECT	DeviceObject = NULL;

	// Setting up the device object.
	UNICODE_STRING DeviceName = RTL_CONSTANT_STRING( DRIVER_DEVICE_NAME );
	UNICODE_STRING SymbolicLink = RTL_CONSTANT_STRING( DRIVER_SYMBOLIC_LINK );

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->MajorFunction[ IRP_MJ_CREATE ] = DriverObject->MajorFunction[ IRP_MJ_CLOSE ] = DriverCreateClose;
	DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = DriverDeviceControl;

	// Creating device.
	status = IoCreateDevice( DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject );
	if ( !NT_SUCCESS( status ) ) {
		DBG_PRINT( "Failed to create device: (0x%08X)\n", status );
		return status;
	}

	// Creating symbolic link.
	status = IoCreateSymbolicLink( &SymbolicLink, &DeviceName );
	if ( !NT_SUCCESS( status ) ) {
		DBG_PRINT( "Failed to create symbolic link: (0x%08X)\n", status );
		IoDeleteDevice( DeviceObject );
		return status;
	}

	DBG_PRINT( "Driver Loaded" );
	return STATUS_SUCCESS;
}

/**
 * @brief Handles I/O control requests (IOCTLs) for the driver.
 *
 * @param DriverObject	A pointer to the DEVICE_OBJECT representing the driver's device.
 * @param Irp			A pointer to the I/O request packet (IRP) containing the details of the request.
 *
 * @return An NTSTATUS code indicating success or failure of the operation.
 */
NTSTATUS DriverDeviceControl( PDEVICE_OBJECT DriverObject, PIRP Irp ) {
	UNREFERENCED_PARAMETER( DriverObject );

	NTSTATUS status = STATUS_SUCCESS;
	SIZE_T len = 0;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation( Irp );

	DBG_PRINT( "DriverDeviceControl Called" );

	switch ( stack->Parameters.DeviceIoControl.IoControlCode )
	{
		case IOCTL_START_HOOKING:
		{
			ULONG size = stack->Parameters.DeviceIoControl.InputBufferLength;
			PREQUEST data = ( PREQUEST ) Irp->AssociatedIrp.SystemBuffer;

			DBG_PRINT( "data->PathToDll: %ws", data->PathToDll );
			DBG_PRINT( "data->ProcessToInject: %ws", data->ProcessToInject );
			DBG_PRINT( "data->Method: %d", data->Method );

			if ( g_Flags != DRIVER_FLAGS::flImageNotifySet && g_Flags != DRIVER_FLAGS::flProcessNotifySet )
			{

				wcsncpy( g_DllToInject, data->PathToDll, MAX_PATH );
				wcsncpy( g_ProcessToInject, data->ProcessToInject, MAX_PATH );

				DBG_PRINT( "Injecting %ws into %ws", g_DllToInject, g_ProcessToInject );
				if ( data->Method == HOOK_TECHNIQUE::APC_CALLBACK )
				{
					status = PsSetLoadImageNotifyRoutine( OnLoadImage );
					if ( !NT_SUCCESS( status ) )
						DBG_PRINT( "PsSetLoadImageNotifyRoutine failed with error code %d", status );

					g_Flags = DRIVER_FLAGS::flImageNotifySet;
				}
				else if ( data->Method == HOOK_TECHNIQUE::TRAMPOLINE )
				{
					status = PsSetCreateProcessNotifyRoutineEx( OnProcessCreate, FALSE );
					if ( !NT_SUCCESS( status ) )
						DBG_PRINT( "PsSetCreateProcessNotifyRoutineEx failed with error code %d", status );

					g_Flags = DRIVER_FLAGS::flProcessNotifySet;
				}
				else
				{
					status = STATUS_INVALID_PARAMETER;
					DBG_PRINT( "Invalid Hooking Technique" );
				}
			}
			else {
				status = STATUS_DEVICE_BUSY;
				DBG_PRINT( "Callback already registered" );
			}

			len += size;
			break;
		}
		case IOCTL_STOP_HOOKING:
		{
			RtlZeroMemory( g_DllToInject, sizeof( g_DllToInject ) );
			RtlZeroMemory( g_ProcessToInject, sizeof( g_ProcessToInject ) );

			if ( g_Flags == DRIVER_FLAGS::flImageNotifySet )
			{
				status = PsRemoveLoadImageNotifyRoutine( OnLoadImage );
				if ( !NT_SUCCESS( status ) )
					DBG_PRINT( "PsRemoveLoadImageNotifyRoutine failed with code %d", status );
				else
					g_Flags = DRIVER_FLAGS::flImageNotifyUnset;
			}
			else if ( g_Flags == DRIVER_FLAGS::flProcessNotifySet )
			{
				status = PsSetCreateProcessNotifyRoutineEx( OnProcessCreate, TRUE );
				if ( !NT_SUCCESS( status ) )
					DBG_PRINT( "PsSetCreateProcessNotifyRoutineEx failed with code %d", status );
				else
					g_Flags = DRIVER_FLAGS::flProcessNotifyUnset;
			}
			else {
				DBG_PRINT( "No callback registered" );
				status = STATUS_INVALID_DEVICE_STATE;
			}

			break;
		}
		default:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = len;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return status;
}

/**
 * @brief Handles create and close requests for the driver.
 *
 * @param DriverObject	A pointer to the DEVICE_OBJECT representing the driver's device.
 * @param Irp			A pointer to the I/O request packet (IRP) containing the request details.
 *
 * @return An NTSTATUS code indicating success or failure of the operation.
 */
NTSTATUS DriverCreateClose( PDEVICE_OBJECT DriverObject, PIRP Irp ) {
	UNREFERENCED_PARAMETER( DriverObject );

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

/**
 * @brief Unloads the driver and cleans up resources.
 *
 * @param DriverObject A pointer to the DRIVER_OBJECT representing this driver.
 */
VOID DriverUnload( PDRIVER_OBJECT DriverObject )
{
	UNREFERENCED_PARAMETER( DriverObject );
	NTSTATUS		status = STATUS_SUCCESS;
	UNICODE_STRING	SymbolicLink = RTL_CONSTANT_STRING( DRIVER_SYMBOLIC_LINK );

	IoDeleteSymbolicLink( &SymbolicLink );
	IoDeleteDevice( DriverObject->DeviceObject );

	if ( g_Flags == DRIVER_FLAGS::flImageNotifySet )
	{
		status = PsRemoveLoadImageNotifyRoutine( OnLoadImage );
		if ( !NT_SUCCESS( status ) )
			DBG_PRINT( "PsRemoveLoadImageNotifyRoutine failed with code %d", status );
	}

	if ( g_Flags == DRIVER_FLAGS::flProcessNotifySet )
	{
		status = PsSetCreateProcessNotifyRoutineEx( OnProcessCreate, TRUE );
		if ( !NT_SUCCESS( status ) )
			DBG_PRINT( "PsSetCreateProcessNotifyRoutineEx failed with code %d", status );
	}

	DBG_PRINT( "Driver Unload" );
}
```

`DllInjector/DrvTypes.h`:

```h
#pragma once

#include "Common.h"
#include <ntddk.h>
#include <wdm.h>

#define IOCTL_START_HOOKING CTL_CODE(0x8000, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STOP_HOOKING CTL_CODE(0x8000, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DRIVER_DEVICE_NAME L"\\Device\\DllInjector"
#define DRIVER_SYMBOLIC_LINK L"\\??\\DllInjector"

enum DRIVER_FLAGS
{
	flNone,
	flImageNotifySet,
	flImageNotifyUnset,

	flProcessNotifySet,
	flProcessNotifyUnset,
};

enum HOOK_TECHNIQUE
{
	APC_CALLBACK,
	TRAMPOLINE
};

typedef struct {
	HOOK_TECHNIQUE	Method;
	WCHAR			ProcessToInject[ MAX_PATH ];
	WCHAR			PathToDll[ MAX_PATH ];
} REQUEST, * PREQUEST;

NTSTATUS	DriverCreateClose( PDEVICE_OBJECT DriverObject, PIRP Irp );
NTSTATUS	DriverDeviceControl( PDEVICE_OBJECT DriverObject, PIRP Irp );
VOID		DriverUnload( PDRIVER_OBJECT DriverObject );
VOID		OnLoadImage( PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo );

extern DRIVER_FLAGS		g_Flags;
extern WCHAR			g_ProcessToInject[ MAX_PATH ];
extern WCHAR			g_DllToInject[ MAX_PATH ];
```

`DllInjector/Injector.cpp`:

```cpp
#include "Utils.h"
#include "Injector.h"

/******************************************************************
*		  Inject Shellcode + Hook LdrLoadDll Technique
*******************************************************************/

/**
 * @brief Injects a DLL into a process by hooking LdrLoadDll.
 *
 * @param pProcess		A pointer to the EPROCESS structure of the target process.
 * @param pwDllToInject A pointer to a wide-character string containing the full path
 *                      of the DLL to be injected.
 *
 * @return TRUE if the injection was successful, FALSE otherwise.
 */
BOOL Injector::InjectDllHook( PEPROCESS pProcess, PWCH pwDllToInject )
{
	BOOL bStatus = FALSE;
	NTSTATUS ntStatus = STATUS_SUCCESS;
	KAPC_STATE kapcState = { 0 };
	PBYTE pbNtdll = NULL;
	PVOID pLdrLoadDll = NULL;
	HOOK_CONTEXT HookContext;
	SIZE_T sHookFuncSize = 0;
	PVOID pBuffer = NULL;
	SIZE_T sTotalSize = 0;
	DWORD dwOldProtect = 0;
	SIZE_T sBytesSize = 12;
	PVOID pFunctionBuffer = NULL;
	PBYTE pbFunctionStart = NULL;
	BOOL bIsFound = FALSE;
	BYTE bTrampoline[ ] = {
		0x48, 0xB8, 00, 00, 00, 00, 00, 00, 00, 00,		// mov rax, <address>
		0xFF, 0xE0										// jmp rax
	};


	KeStackAttachProcess( pProcess, &kapcState );
	ntStatus = Utils::GetNtdllBaseAddress( pProcess, ( PVOID* ) &pbNtdll );
	if ( !NT_SUCCESS( ntStatus ) )
	{
		DBG_PRINT( "Failed to get ntdll base address" );
		goto __END;
	}

	pLdrLoadDll = HookContext.Win32.LdrLoadDll = ( LDRLOADDLL ) Utils::GetProcAddress( pbNtdll, "LdrLoadDll" );
	if ( !HookContext.Win32.LdrLoadDll )
	{
		DBG_PRINT( "Failed to get LdrLoadDll function address" );
		goto __END;
	}

	HookContext.Win32.RtlInitUnicodeString = ( RTLINITUNICODESTRING ) Utils::GetProcAddress( pbNtdll, "RtlInitUnicodeString" );
	if ( !HookContext.Win32.RtlInitUnicodeString )
	{
		DBG_PRINT( "Failed to get RtlInitUnicodeString function address" );
		goto __END;
	}

	HookContext.Win32.NtProtectVirtualMemory = ( NTPROTECTVIRTUALMEMORY ) Utils::GetProcAddress( pbNtdll, "NtProtectVirtualMemory" );
	if ( !HookContext.Win32.NtProtectVirtualMemory )
	{
		DBG_PRINT( "Failed to get NtProtectVirtualMemory function address" );
		goto __END;
	}

	sHookFuncSize = ( ( DWORD_PTR ) HookLdrLoadDllEnd ) - ( ( DWORD_PTR ) HookLdrLoadDll );
	sTotalSize = sHookFuncSize + sizeof( HOOK_CONTEXT );

	ntStatus = ZwAllocateVirtualMemory( NtCurrentProcess( ), &pBuffer, 0, &sTotalSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
	if ( !NT_SUCCESS( ntStatus ) )
	{
		DBG_PRINT( "ZwAllocateVirtualMemory failed with error code %d", ntStatus );
		goto __END;
	}


	RtlCopyMemory( HookContext.SavedBytes, HookContext.Win32.LdrLoadDll, 12 );
	wcsncpy( HookContext.ModuleFileName, pwDllToInject, MAX_PATH );

	RtlCopyMemory( pBuffer, &HookContext, sizeof( HOOK_CONTEXT ) );
	RtlCopyMemory( ( PVOID ) ( ( DWORD_PTR ) pBuffer + sizeof( HOOK_CONTEXT ) ), HookLdrLoadDll, sHookFuncSize );

	pbFunctionStart = ( PBYTE ) ( ( DWORD_PTR ) pBuffer + sizeof( HOOK_CONTEXT ) );
	for ( DWORD dwIndex = 0; dwIndex < sTotalSize; dwIndex++ )
	{
		if ( *( DWORD64* ) ( pbFunctionStart + dwIndex ) == 0xBAADF00DBAADBEEF )
		{
			*( DWORD64* ) ( pbFunctionStart + dwIndex ) = ( DWORD64 ) pBuffer;
			bIsFound = TRUE;
			break;
		}
	}

	if ( !bIsFound )
	{
		DBG_PRINT( "Couldn't find the pattern in function" );
		goto __END;
	}

	pFunctionBuffer = pLdrLoadDll;
	*( DWORD64* ) ( bTrampoline + 2 ) = ( DWORD64 ) pbFunctionStart;

	ntStatus = ZwProtectVirtualMemory( ZwCurrentProcess( ), &pFunctionBuffer, ( PULONG ) &sBytesSize, PAGE_EXECUTE_READWRITE, &dwOldProtect );
	if ( !NT_SUCCESS( ntStatus ) )
	{
		DBG_PRINT( "NtProtectVirtualMemory failed with error code %d", ntStatus );
		goto __END;
	}

	RtlCopyMemory( pLdrLoadDll, bTrampoline, 12 );

	ntStatus = ZwProtectVirtualMemory( ZwCurrentProcess( ), &pFunctionBuffer, ( PULONG ) &sBytesSize, dwOldProtect, &dwOldProtect );
	if ( !NT_SUCCESS( ntStatus ) )
	{
		DBG_PRINT( "NtProtectVirtualMemory failed with error code %d", ntStatus );
		goto __END;
	}

	bStatus = TRUE;
__END:
	KeUnstackDetachProcess( &kapcState );
	return bStatus;
}

/******************************************************************
*			  Asynchronous Procedure Call Technique
*******************************************************************/

VOID KernelAPC( PVOID, PVOID, PVOID, PVOID, PVOID ) { }

/**
 * @brief Injects a DLL into a process using an Asynchronous Procedure Call (APC).
 *
 * @param ProcessPid	The process identifier (PID) of the target process.
 * @param DllToInject	A pointer to a wide-character string containing the full path
 *						of the DLL to be injected.
 *
 * @return TRUE if the injection was successful, FALSE otherwise.
 */
BOOL Injector::InjectDllAPC( HANDLE ProcessPid, PWCH DllToInject )
{
	NTSTATUS status = 0;
	BOOL bStatus = FALSE;
	PEPROCESS Process = NULL;
	PETHREAD Thread = NULL;
	KAPC_STATE apcState = { 0 };
	PBYTE pNtdll = NULL;
	PVOID pLdrLoadDll = NULL;
	PLDR_LAOD_DLL_CALL pArguments = NULL;
	SIZE_T sArgumentsSize = sizeof( LDR_LAOD_DLL_CALL );
	SIZE_T sAPCCallbackSize = 0, stempAPCCallbackSize = 0;
	PVOID pAPCCallbackCodeCave = NULL;
	HANDLE ThreadId = 0;
	PKAPC apc = 0;

	status = PsLookupProcessByProcessId( ProcessPid, &Process );
	if ( !NT_SUCCESS( status ) )
		return FALSE;

	KeStackAttachProcess( Process, &apcState );

	pNtdll = ( PBYTE ) Utils::GetModuleHandle( Process, L"ntdll.dll" );
	if ( !pNtdll )
		goto __END;

	pLdrLoadDll = Utils::GetProcAddress( pNtdll, "LdrLoadDll" );
	if ( !pLdrLoadDll )
		goto __END;

	status = ZwAllocateVirtualMemory( NtCurrentProcess( ), ( PVOID* ) &pArguments, 0, &sArgumentsSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !NT_SUCCESS( status ) )
		goto __END;

	RtlZeroMemory( pArguments, sArgumentsSize );

	pArguments->PathToFile = NULL;
	pArguments->Flags = 0;
	pArguments->LdrLoadDll = ( LDRLOADDLL ) pLdrLoadDll;
	pArguments->uModuleFileName.Buffer = pArguments->pwBuffer;
	wcsncpy( pArguments->pwBuffer, DllToInject, MAX_PATH );
	pArguments->uModuleFileName.Length = ( USHORT ) ( wcslen( DllToInject ) * sizeof( WCHAR ) );
	pArguments->uModuleFileName.MaximumLength = sizeof( WCHAR ) * MAX_PATH;
	pArguments->hModule = NULL;

	sAPCCallbackSize = ( ( DWORD_PTR ) APCCallbackEnd ) - ( ( DWORD_PTR ) APCCallback );
	stempAPCCallbackSize = sAPCCallbackSize;
	pAPCCallbackCodeCave = NULL;

	status = ZwAllocateVirtualMemory( NtCurrentProcess( ), &pAPCCallbackCodeCave, 0, &stempAPCCallbackSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
	if ( !NT_SUCCESS( status ) )
		goto __END;

	RtlCopyMemory( pAPCCallbackCodeCave, APCCallback, sAPCCallbackSize );

	ThreadId = Utils::GetMainThreadId( ProcessPid );
	if ( !ThreadId )
		goto __END;

	status = PsLookupThreadByThreadId( ThreadId, &Thread );
	if ( !NT_SUCCESS( status ) )
	{
		DBG_PRINT( "PsLookupThreadByThreadId failed with code %X", status );
		goto __END;
	}

	KeUnstackDetachProcess( &apcState );
	apc = ( PKAPC ) ExAllocatePool2( POOL_FLAG_NON_PAGED, sizeof( KAPC ), POOL_TAG );
	if ( apc == NULL )
		goto __END_1;

	KeInitializeApc( apc,
					 Thread,
					 OriginalApcEnvironment,
					 ( PKKERNEL_ROUTINE ) KernelAPC,
					 NULL,
					 ( PKNORMAL_ROUTINE ) pAPCCallbackCodeCave,
					 UserMode,
					 pArguments );

	if ( !KeInsertQueueApc( apc, NULL, NULL, 0 ) ) {
		ExFreePool( apc );
		goto __END_1;
	}

	bStatus = TRUE;
	goto __END_1;

__END:
	if ( pAPCCallbackCodeCave ) {
		status = ZwFreeVirtualMemory( NtCurrentProcess( ), &pAPCCallbackCodeCave, &stempAPCCallbackSize, MEM_RELEASE );
		if ( !NT_SUCCESS( status ) )
			DBG_PRINT( "ZwFreeVirtualMemory failed with code %X\n", status );
	}

	if ( pArguments ) {
		status = ZwFreeVirtualMemory( NtCurrentProcess( ), ( PVOID* ) &pArguments, &sArgumentsSize, MEM_RELEASE );
		if ( !NT_SUCCESS( status ) )
			DBG_PRINT( "ZwFreeVirtualMemory failed with code %X\n", status );
	}

	KeUnstackDetachProcess( &apcState );

__END_1:
	if ( Thread )
		ObDereferenceObject( Thread );
	if ( Process )
		ObDereferenceObject( Process );

	return bStatus;
}
```

`DllInjector/Injector.h`:

```h
#pragma once

#include <ntifs.h>
#include <minwindef.h>

#include "Common.h"
#include "PIC.h"

NTSTATUS HookLdrLoadDll( PWCHAR pwPathToFile, ULONG ulFlags, PUNICODE_STRING puModuleFileName, PHANDLE phModuleHandle );
DWORD HookLdrLoadDllEnd( );
VOID APCCallback( PLDR_LAOD_DLL_CALL LdrLoadDllCall );
DWORD APCCallbackEnd( );

class Injector {
public:
	static BOOL InjectDllAPC( HANDLE ProcessPid, PWCH DllToInject );
	static BOOL InjectDllHook( PEPROCESS Process, PWCH DllToInject );
};
```

`DllInjector/PIC.cpp`:

```cpp
#include "PIC.h"

/**
 * @brief Position Independent Code (PIC) Hook for intercepting calls to LdrLoadDll.
 */
#pragma optimize("", off)
#pragma code_seg(".text$A")
__declspec( safebuffers )
NTSTATUS HookLdrLoadDll( PWCHAR pwPathToFile, ULONG ulFlags, PUNICODE_STRING puModuleFileName, PHANDLE phModuleHandle )
{
	NTSTATUS status = STATUS_SUCCESS;
	PHOOK_CONTEXT pContext = ( PHOOK_CONTEXT ) 0xBAADF00DBAADBEEF; // The driver will replace this with the address to the allocated and initialized context
	PVOID pLdrLoadDll = NULL;
	SIZE_T sNumberOfBytes = 12;
	DWORD dwOldProtect = 0;
	HANDLE hModule;
	UNICODE_STRING uMyDll;
	PVOID pBuffer = NULL;

	pBuffer = pLdrLoadDll = ( PVOID ) pContext->Win32.LdrLoadDll;
	status = pContext->Win32.NtProtectVirtualMemory( ( HANDLE ) -1, &pBuffer, ( PULONG ) &sNumberOfBytes, PAGE_EXECUTE_READWRITE, &dwOldProtect );
	if ( !NT_SUCCESS( status ) )
		return status;

	MEMCPY( pLdrLoadDll, pContext->SavedBytes, 12 );

	status = pContext->Win32.NtProtectVirtualMemory( ( HANDLE ) -1, &pBuffer, ( PULONG ) &sNumberOfBytes, PAGE_EXECUTE_READWRITE, &dwOldProtect );
	if ( !NT_SUCCESS( status ) )
		return status;

	status = pContext->Win32.LdrLoadDll( pwPathToFile, ulFlags, puModuleFileName, phModuleHandle );
	if ( !NT_SUCCESS( status ) )
		return status;

	pContext->Win32.RtlInitUnicodeString( &uMyDll, pContext->ModuleFileName );
	status = pContext->Win32.LdrLoadDll( NULL, 0, &uMyDll, &hModule );
	if ( !NT_SUCCESS( status ) )
		return status;

	return status;
}
#pragma code_seg(".text$B")
DWORD HookLdrLoadDllEnd( ) {
	return 2;
}

/**
 * @brief APC callback function for loading a DLL in a target process.
 *
 * @param LdrLoadDllCall A pointer to an LDR_LOAD_DLL_CALL structure containing
 *                        the necessary parameters for calling LdrLoadDll.
 */
#pragma code_seg(".text$C")
VOID APCCallback( PLDR_LAOD_DLL_CALL LdrLoadDllCall ) {
	LdrLoadDllCall->LdrLoadDll( LdrLoadDllCall->PathToFile, LdrLoadDllCall->Flags, &LdrLoadDllCall->uModuleFileName, &LdrLoadDllCall->ModuleHandle );
}
#pragma code_seg(".text$D")
DWORD APCCallbackEnd( ) {
	return 1;
}

#pragma code_seg()
#pragma optimize("", on)

```

`DllInjector/PIC.h`:

```h
#pragma once

#include <ntifs.h>
#include <minwindef.h>

// 
// https://5pider.net/blog/2024/01/27/modern-shellcode-implant-design/
//

#define MEMSET(dst, val, size) __stosb( ( unsigned char* ) dst, ( unsigned char ) val, size )
#define MEMCPY(dst, src, size) __movsb( (PUCHAR)dst, (const UCHAR *)src, size)

typedef VOID( *RTLINITUNICODESTRING )(
	PUNICODE_STRING         DestinationString,
	PCWSTR SourceString
	);

typedef NTSTATUS( NTAPI* NTPROTECTVIRTUALMEMORY )(
	IN HANDLE               ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN OUT PULONG           NumberOfBytesToProtect,
	IN ULONG                NewAccessProtection,
	OUT PULONG              OldAccessProtection );

typedef NTSTATUS( NTAPI* LDRLOADDLL )(
	IN PWCHAR               PathToFile OPTIONAL,
	IN ULONG                Flags OPTIONAL,
	IN PUNICODE_STRING      ModuleFileName,
	OUT PHANDLE             ModuleHandle );

typedef struct {
	LDRLOADDLL				LdrLoadDll;
	PWCHAR					PathToFile;
	ULONG					Flags;
	HANDLE					ModuleHandle;

	WCHAR					pwBuffer[ MAX_PATH * sizeof( WCHAR ) ];
	UNICODE_STRING			uModuleFileName;
	HANDLE					hModule;
} LDR_LAOD_DLL_CALL, * PLDR_LAOD_DLL_CALL;

typedef struct {
	BYTE SavedBytes[ 12 ];
	WCHAR ModuleFileName[ MAX_PATH ];

	struct {
		LDRLOADDLL				LdrLoadDll;
		NTPROTECTVIRTUALMEMORY	NtProtectVirtualMemory;
		RTLINITUNICODESTRING	RtlInitUnicodeString;
	} Win32;
} HOOK_CONTEXT, * PHOOK_CONTEXT;
```

`DllInjector/Utils.cpp`:

```cpp
// Utils.cpp

#include "Utils.h"

BOOLEAN IsDllModule( PVOID BaseAddress )
{
	PIMAGE_DOS_HEADER dosHeader = ( PIMAGE_DOS_HEADER ) BaseAddress;

	if ( dosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
		return FALSE;
	}

	PIMAGE_NT_HEADERS ntHeaders = ( PIMAGE_NT_HEADERS ) ( ( ULONG_PTR ) BaseAddress + dosHeader->e_lfanew );

	if ( ntHeaders->Signature != IMAGE_NT_SIGNATURE ) {
		return FALSE;
	}

	if ( ntHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL ) {
		return TRUE;
	}

	return FALSE;
}

NTSTATUS Utils::GetNtdllBaseAddress( PEPROCESS Process, PVOID* NtdllBase )
{
	MEMORY_BASIC_INFORMATION memInfo;
	SIZE_T returnLength;
	PVOID baseAddress = NULL;
	NTSTATUS status;
	PPEB processPeb = NULL;

	// Get PEB
	processPeb = PsGetProcessPeb( Process );

	// Read the base address from PEB
	if ( processPeb != NULL ) {
		__try {
			ProbeForRead( processPeb, sizeof( PEB ), 1 );
			baseAddress = processPeb->ImageBaseAddress;
		}
		__except ( EXCEPTION_EXECUTE_HANDLER ) {
			DBG_PRINT( "Error accessing PEB" );
		}
	}

	// Start the search
	while ( TRUE ) {
		status = ZwQueryVirtualMemory(
			ZwCurrentProcess( ),
			baseAddress,
			MemoryBasicInformation,
			&memInfo,
			sizeof( memInfo ),
			&returnLength
		);

		if ( !NT_SUCCESS( status ) ) {
			break;
		}

		// Check if this region is a mapped image
		if ( memInfo.Type == MEM_IMAGE ) {
			// You need a way to identify NTDLL - one approach is to check for known patterns
			// or read the PE headers to identify NTDLL.dll
			if ( IsDllModule( memInfo.BaseAddress ) ) {

				DBG_PRINT( "Ntdll: %p", memInfo.BaseAddress );
				*NtdllBase = memInfo.BaseAddress;
				return STATUS_SUCCESS;
			}
		}

		// Move to the next region
		baseAddress = ( PVOID ) ( ( ULONG_PTR ) memInfo.BaseAddress + memInfo.RegionSize );
	}

	return STATUS_NOT_FOUND;
}

PVOID Utils::GetModuleHandle( PEPROCESS Process, LPCWCH lpcModuleName )
{
	UNICODE_STRING	uModuleName = { 0 };
	PLIST_ENTRY		pListEntry = NULL;
	PPEB			pPeb = NULL;

	RtlInitUnicodeString( &uModuleName, lpcModuleName );
	pPeb = PsGetProcessPeb( Process );
	if ( !pPeb )
		return NULL;

	for ( pListEntry = pPeb->LoaderData->InLoadOrderModuleList.Flink;
		  pListEntry != &pPeb->LoaderData->InLoadOrderModuleList;
		  pListEntry = pListEntry->Flink ) {

		PLDR_MODULE pEntry = CONTAINING_RECORD( pListEntry, LDR_MODULE, InLoadOrderModuleList );

		if ( pEntry->BaseDllName.Length > 0 ) {

			if ( RtlCompareUnicodeString( &pEntry->BaseDllName, &uModuleName, TRUE ) == 0 )
				return pEntry->BaseAddress;
		}
	}

	return NULL;
}

PVOID Utils::GetProcAddress( PBYTE hModule, LPCSTR lpcFuncName )
{
	PIMAGE_DOS_HEADER pDosHdr = NULL;
	PIMAGE_NT_HEADERS pNtHdrs = NULL;
	IMAGE_OPTIONAL_HEADER pOptionalHdr = { 0 };
	PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL;
	PVOID pFuncAddress = NULL;

	pDosHdr = ( PIMAGE_DOS_HEADER ) hModule;
	if ( !pDosHdr )
		return NULL;

	if ( pDosHdr->e_magic != IMAGE_DOS_SIGNATURE )
		return NULL;

	pNtHdrs = ( PIMAGE_NT_HEADERS ) ( hModule + pDosHdr->e_lfanew );
	if ( pNtHdrs->Signature != IMAGE_NT_SIGNATURE )
		return NULL;

	pOptionalHdr = pNtHdrs->OptionalHeader;
	if ( pOptionalHdr.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress == 0 )
		return NULL;

	pExportDirectory = ( PIMAGE_EXPORT_DIRECTORY ) ( hModule + pOptionalHdr.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress );

	// Iterating the export directory.
	DWORD* addresses = ( DWORD* ) ( hModule + pExportDirectory->AddressOfFunctions );
	WORD* ordinals = ( WORD* ) ( hModule + pExportDirectory->AddressOfNameOrdinals );
	DWORD* names = ( DWORD* ) ( hModule + pExportDirectory->AddressOfNames );
	for ( DWORD j = 0; j < pExportDirectory->NumberOfNames; j++ ) {
		if ( _stricmp( ( char* ) ( hModule + names[ j ] ), lpcFuncName ) == 0 ) {
			pFuncAddress = hModule + addresses[ ordinals[ j ] ];
			return pFuncAddress;
		}
	}

	return NULL;
}

HANDLE Utils::GetMainThreadId( HANDLE ProcessId )
{
	SIZE_T sSystemProcInfoSize = 0;
	PSYSTEM_PROCESS_INFO pSystemProcInfo = NULL, pTempPtr = NULL;
	NTSTATUS status = 0;
	HANDLE ThreadId = NULL;


	ZwQuerySystemInformation( SystemProcessInformation, NULL, NULL, ( PULONG ) &sSystemProcInfoSize );

	pTempPtr = pSystemProcInfo = ( PSYSTEM_PROCESS_INFO ) ExAllocatePool2( POOL_FLAG_NON_PAGED, sSystemProcInfoSize, POOL_TAG );;
	if ( pSystemProcInfo == NULL )
	{
		DBG_PRINT( "ExAllocatePool2 failed" );
		return NULL;
	}

	status = ZwQuerySystemInformation( SystemProcessInformation, pSystemProcInfo, ( ULONG ) sSystemProcInfoSize, ( PULONG ) &sSystemProcInfoSize );
	if ( !NT_SUCCESS( status ) )
	{
		DBG_PRINT( "ZwQuerySystemInformation failed with code %X", status );
		goto _END;
	}

	// Enumerating running processes
	while ( TRUE )
	{
		if ( pSystemProcInfo->UniqueProcessId == ProcessId )
		{
			ThreadId = pSystemProcInfo->Threads[ 0 ].ClientId.UniqueThread;
			break;
		}

		if ( pSystemProcInfo->NextEntryOffset == NULL )
			break;

		pSystemProcInfo = ( PSYSTEM_PROCESS_INFO ) ( ( DWORD_PTR ) pSystemProcInfo + pSystemProcInfo->NextEntryOffset );
	}

_END:
	if ( pTempPtr )
		ExFreePool( pTempPtr );
	return ThreadId;
}


/*
* @brief	EndsWithUnicodeString Checks if the 'FullName' is suffix/end with 'ShortName'.
* @param	FullName	Unicode string to check
* @param	ShortName	Suffix
* @param	CaseInsensitive
*/
BOOLEAN Utils::EndsWithUnicodeString( PUNICODE_STRING FullName, PUNICODE_STRING ShortName, BOOLEAN CaseInsensitive )
{
	if ( FullName && ShortName && ShortName->Length <= FullName->Length )
	{
		UNICODE_STRING uString = {
			ShortName->Length,
			uString.Length,
			( PWSTR ) RtlOffsetToPointer( FullName->Buffer, FullName->Length - uString.Length )
		};

		return RtlEqualUnicodeString( &uString, ShortName, CaseInsensitive );
	}

	return FALSE;
}

/*
* @brief	IsLoadedByLdrLoadDll checks if the module is loaded by LdrLoadDll API
* @param	ShortName	module name to check for
*/
BOOLEAN Utils::IsLoadedByLdrLoadDll( PUNICODE_STRING ShortName )
{
	UNICODE_STRING Name = { 0 };

	__try
	{
		PNT_TIB Teb = ( PNT_TIB ) PsGetCurrentThreadTeb( );

		if ( !Teb || !Teb->ArbitraryUserPointer )
			return FALSE;

		Name.Buffer = ( PWSTR ) Teb->ArbitraryUserPointer;

		// check if we have valid user-mode address
		ProbeForRead( Name.Buffer, sizeof( WCHAR ), __alignof( WCHAR ) );

		// check buffer length
		Name.Length = ( USHORT ) wcsnlen( Name.Buffer, MAXSHORT );
		if ( Name.Length == MAXSHORT )
		{
			DBG_PRINT( "Name is too long" );
			return FALSE;
		}

		Name.Length *= sizeof( WCHAR );
		Name.MaximumLength = Name.Length;

		return EndsWithUnicodeString( &Name, ShortName, TRUE );
	}
	__except ( EXCEPTION_EXECUTE_HANDLER )
	{
		DBG_PRINT( "Exception: (0x%X)", GetExceptionCode( ) );
	}

	return FALSE;
}

BOOLEAN Utils::IsSpecificProcessW( HANDLE ProcessId, const WCHAR* ImageName, BOOLEAN bIsDebugged )
{
	ASSERT( ImageName );
	BOOLEAN			bResult = FALSE;
	NTSTATUS		status = 0;
	PEPROCESS		Process = NULL;

	status = PsLookupProcessByProcessId( ProcessId, &Process );
	if ( NT_SUCCESS( status ) )
	{

		if ( !bIsDebugged ||
			 PsIsProcessBeingDebugged( Process ) )
		{
			HANDLE hProcess = NULL;

			if ( ObOpenObjectByPointer( Process, OBJ_KERNEL_HANDLE, NULL, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, &hProcess ) == STATUS_SUCCESS )
			{
				WCHAR buff[ sizeof( UNICODE_STRING ) + ( MAX_PATH + 1 ) * sizeof( WCHAR ) ];
				PUNICODE_STRING puProcessName = ( PUNICODE_STRING ) buff;
				PWCH pwBuff = ( PWCH ) ( ( PBYTE ) buff + sizeof( UNICODE_STRING ) );

				puProcessName->Length = 0;
				puProcessName->MaximumLength = ( USHORT ) ( sizeof( buff ) - sizeof( UNICODE_STRING ) );
				puProcessName->Buffer = pwBuff;

				if ( ZwQueryInformationProcess( hProcess, ProcessImageFileName, puProcessName, sizeof( buff ), NULL ) == STATUS_SUCCESS )
				{
					*( WCHAR* ) ( ( BYTE* ) buff + sizeof( buff ) - sizeof( WCHAR ) ) = 0;

					if ( puProcessName->Length + sizeof( WCHAR ) <= puProcessName->MaximumLength )
					{
						*( WCHAR* ) ( ( BYTE* ) puProcessName->Buffer + puProcessName->Length ) = 0;
					}

					WCHAR* pLastSlash = NULL;
					for ( WCHAR* pS = pwBuff;; pS++ )
					{
						WCHAR z = *pS;
						if ( !z )
						{
							if ( pLastSlash )
							{
								pwBuff = pLastSlash + 1;
							}

							break;
						}
						else if ( z == L'\\' )
						{
							pLastSlash = pS;
						}
					}

					if ( _wcsicmp( ImageName, pwBuff ) == 0 )
					{
						bResult = TRUE;
					}
				}

				ZwClose( hProcess );
			}
		}

		ObDereferenceObject( Process );
	}
	else {
		DBG_PRINT( "PsLookupProcessByProcessId failed with error code %d", status );
	}

	return bResult;
}
```

`DllInjector/Utils.h`:

```h
#pragma once

#include "Common.h"

#define MEM_IMAGE		0x1000000

class Utils {
public:
	static BOOLEAN	EndsWithUnicodeString( PUNICODE_STRING FullName, PUNICODE_STRING ShortName, BOOLEAN CaseInsensitive );
	static BOOLEAN	IsLoadedByLdrLoadDll( PUNICODE_STRING ShortName );
	static BOOLEAN	IsSpecificProcessW( HANDLE ProcessId, const WCHAR* ImageName, BOOLEAN bIsDebugged );
	static PVOID	GetModuleHandle( PEPROCESS Process, LPCWCH lpcModuleName );
	static NTSTATUS GetNtdllBaseAddress( PEPROCESS Process, PVOID* NtdllBase );
	static PVOID	GetProcAddress( PBYTE hModule, LPCSTR lpcFuncName );
	static HANDLE	GetMainThreadId( HANDLE ProcessId );
};
```

`DllInjectorClient/DllInjectorClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b958013b-0f01-40b5-9a80-686fa62a24aa}</ProjectGuid>
    <RootNamespace>DllInjectorClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DllInjectorClient/DllInjectorClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DllInjectorClient/Header.h`:

```h
#pragma once

#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <string>
#include <shlwapi.h>

#pragma comment(lib, "Shlwapi.lib") // Link Shlwapi.lib

#define IOCTL_START_HOOKING CTL_CODE(0x8000, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STOP_HOOKING CTL_CODE(0x8000, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DRIVER_NAME L"\\\\.\\DllInjector"

enum HOOK_TECHNIQUE
{
	APC_CALLBACK,
	TRAMPOLINE
};

typedef struct {
	HOOK_TECHNIQUE	Technique;
	WCHAR			ProcessToInject[ MAX_PATH ];
	WCHAR			PathToDll[ MAX_PATH ];
} REQUEST, * PREQUEST;
```

`DllInjectorClient/Main.cpp`:

```cpp
#include "Header.h"

VOID Banner( )
{
	std::cout << "    ____  ________        _           __            " << std::endl;
	std::cout << "   / __ \\/ / /  _/___    (_)__  _____/ /_____  _____" << std::endl;
	std::cout << "  / / / / / // // __ \\  / / _ \\/ ___/ __/ __ \\/ ___/" << std::endl;
	std::cout << " / /_/ / / // // / / / / /  __/ /__/ /_/ /_/ / /    " << std::endl;
	std::cout << "/_____/_/_/___/_/ /_/_/ /\\___/\\___/\\__/\\____/_/     " << std::endl;
	std::cout << "                   /___/                            " << std::endl;

}

VOID Menu1( PDWORD Index )
{
	system( "cls" );
	Banner( );

	std::wcout << "   [0] APC Hooking Technique (Inject APC into a Process)" << std::endl;
	std::wcout << "   [1] Trampoling Hooking Technique (Inject Shellcode + Hook LdrLoadDll)" << std::endl;
	std::wcout << "   [2] Stop Hooking" << std::endl;
	std::wcout << "   [3] Exit" << std::endl << std::endl;

	std::wcout << "   [>] Enter a Number: ";
	std::wcin >> *Index;

	system( "cls" );
}

VOID Menu2( std::wstring& ProcessName, std::wstring& DllToInject )
{
	Banner( );
	std::wcin.ignore( );

	std::wcout << "   [>] Process Name: ";
	std::getline( std::wcin, ProcessName );

	std::wcout << "   [>] Full Dll Path: ";
	std::getline( std::wcin, DllToInject );
}

int wmain( int ac, wchar_t* av[ ] ) {

	HANDLE hDriver = NULL;
	REQUEST Request;
	SIZE_T RequestSize = sizeof( REQUEST );

	hDriver = CreateFile( DRIVER_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
	if ( hDriver == INVALID_HANDLE_VALUE )
	{
		std::wcout << "   [!] Failed to open handle to the driver." << std::endl;
		return ( 0 );
	}

	do {

		/* Display the menu */
		DWORD Index = -1;
		std::wstring ProcessName;
		std::wstring DllToInject;

		Menu1( &Index );

		if ( Index == -1 )
			continue;

		if ( Index < 2 )
		{
			Menu2( ProcessName, DllToInject );
			if ( !PathFileExistsW( DllToInject.c_str( ) ) )
			{
				std::cout << "   [!] Dll doesn't exist" << std::endl;
				Sleep( 1000 );
				continue;
			}
		}

		switch ( Index )
		{

			case 0:
			{
				// Initialize the request struct
				Request.Technique = HOOK_TECHNIQUE::APC_CALLBACK;
				wcsncpy( Request.ProcessToInject, ProcessName.c_str( ), MAX_PATH );
				wcsncpy( Request.PathToDll, DllToInject.c_str( ), MAX_PATH );

				if ( !DeviceIoControl( hDriver, IOCTL_START_HOOKING, &Request, sizeof( REQUEST ), &Request,
									   sizeof( REQUEST ), NULL, NULL ) )
				{
					std::cout << "   [!] DeviceIoControl Failed: " << GetLastError( ) << std::endl;
					Sleep( 2000 );

				}
				break;
			}
			case 1:
			{
				// Initialize the request struct
				Request.Technique = HOOK_TECHNIQUE::TRAMPOLINE;
				wcsncpy( Request.ProcessToInject, ProcessName.c_str( ), MAX_PATH );
				wcsncpy( Request.PathToDll, DllToInject.c_str( ), MAX_PATH );

				if ( !DeviceIoControl( hDriver, IOCTL_START_HOOKING, &Request, sizeof( REQUEST ), &Request,
									   sizeof( REQUEST ), NULL, NULL ) )
				{
					std::cout << "   [!] DeviceIoControl Failed: " << GetLastError( ) << std::endl;
					Sleep( 2000 );
				}
				break;
			}
			case 2:
			{
				DeviceIoControl( hDriver, IOCTL_STOP_HOOKING, NULL, 0, NULL, 0, NULL, NULL );
				break;
			}
			case 3:
			{
				ExitProcess( 0 );
				break;
			}
			default:
				break;
		}
	} while ( TRUE );

	return ( 0 );
}
```

`KMDllInjector.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35707.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllInjector", "DllInjector\DllInjector.vcxproj", "{A831FEDD-DC30-4A60-9A23-3F7746001CC2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllInjectorClient", "DllInjectorClient\DllInjectorClient.vcxproj", "{B958013B-0F01-40B5-9A80-686FA62A24AA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|ARM64.Build.0 = Debug|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|x64.ActiveCfg = Debug|x64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|x64.Build.0 = Debug|x64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Debug|x64.Deploy.0 = Debug|x64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|ARM64.ActiveCfg = Release|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|ARM64.Build.0 = Release|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|ARM64.Deploy.0 = Release|ARM64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|x64.ActiveCfg = Release|x64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|x64.Build.0 = Release|x64
		{A831FEDD-DC30-4A60-9A23-3F7746001CC2}.Release|x64.Deploy.0 = Release|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Debug|ARM64.ActiveCfg = Debug|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Debug|ARM64.Build.0 = Debug|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Debug|x64.ActiveCfg = Debug|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Debug|x64.Build.0 = Debug|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Release|ARM64.ActiveCfg = Release|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Release|ARM64.Build.0 = Release|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Release|x64.ActiveCfg = Release|x64
		{B958013B-0F01-40B5-9A80-686FA62A24AA}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# About
KMDllInjector is a kernel-mode based DLL injector. The driver can be configured with `DllInjectorClient.exe` to use either `PsSetLoadImageNotifyRoutine` or `PsSetCreateProcessNotifyRoutineEx` to register a kernel callback.
Once the callback is triggered (image is loaded \ process created), it injects a DLL into the target user-mode process.
# How it works?
To inject a dll before process entrypoint is called the driver can use two techniques:

## PsSetCreateProcessNotifyRoutineEx + Shellcode Injection

This technique uses `PsSetCreateProcessNotifyRoutineEx` to register a callback that gets triggered whenever a new process is created.
Since `ntdll.dll` is loaded from kernel-mode, in the callback, we'll hook `Ntdll!LdrLoadDll` with a detour shellcode. 

The problem is that at this stage of process creation, the `PEB->Ldr` structure isn't initialized yet.

![LdrIsNull](https://github.com/user-attachments/assets/abe5f29e-565b-4c49-9b73-cbf61a38e8c1)

So how can we find base address of `ntdll.dll`?


The solution I came up with is since the `ntdll.dll` is mapped into the process virtual memory space, 
I can use `ntoskernel!ZwQueryVirtualMemory` to enumerate image mapped type of memory regions, check if the memory region base address contains a valid PE header, then parse the PE header to determine if it's a DLL.
```c
while ( TRUE ) {
  status = ZwQueryVirtualMemory( ZwCurrentProcess( ), baseAddress, MemoryBasicInformation, &memInfo, sizeof( memInfo ), &returnLength );
  if ( !NT_SUCCESS( status ) )
			break;

  // Check if this region is a mapped image
  if ( memInfo.Type == MEM_IMAGE ) {
    if ( IsDllModule( memInfo.BaseAddress ) ) {
      DBG_PRINT( "Ntdll: %p", memInfo.BaseAddress );
      *NtdllBase = memInfo.BaseAddress;
      return STATUS_SUCCESS;
    }
  }

  // Move to the next region
  baseAddress = ( PVOID ) ( ( ULONG_PTR ) memInfo.BaseAddress + memInfo.RegionSize );
}
```

After we found the base address of `ntdll.dll` of the target process we hook `Ntdll!LdrLoadDll` with a detour shellcode, the shellcode will do the following:
1. Restores the original prologue of LdrLoadDll (removing the hook),
2. Calls LdrLoadDll with the passed arguments.
3. Then loads our custom DLL into the process.

Instead of writing the shellcode in assembly, I used a trick I saw from [Rhydon1337: windows-kernel-dll-injector](https://github.com/Rhydon1337/windows-kernel-dll-injector/blob/main/DLLInjector/DLLInjector/dll_injection.cpp#L18) to use a function as a shellcode.
Since the function will be position-independent code, I disabled stack cookies, optimization, and Control Flow Guard (CFG).
I also used `#pragma code_seg(".text$")` to ensure that the functions is in the same order as in cpp file.
```c
#pragma optimize("", off)
#pragma code_seg(".text$A")
__declspec( safebuffers ) // disable stack cookies
// CFG can be disabled from Properties > C/C++ > Code Generation > Control Flow Guad > No
NTSTATUS HookLdrLoadDll( PWCHAR pwPathToFile, ULONG ulFlags, PUNICODE_STRING puModuleFileName, PHANDLE phModuleHandle )
{
	PHOOK_CONTEXT pContext = ( PHOOK_CONTEXT ) 0xBAADF00DBAADBEEF;
}
#pragma code_seg(".text$B")
DWORD HookLdrLoadDllEnd( ) {
	return 2;
}
#pragma optimize("", on)
```

The shellcode will need a context that will have a saved copy of ldrloaddll prologue (use it to restore `Ntdll!LdrLoadDll`)
and some ntdll exports (`NtProtectVirtualMemory`, `LdrLoadDLl`, `RtlInitUnicodeString`)

After context is initialized we scan for the pattern `0xBAADF00DBAADBEEF` and replace it with the address of the context.
```c
// Search for '0xBAADF00DBAADBEEF' pattern and replace it with the address to the context
pbFunctionStart = ( PBYTE ) ( ( DWORD_PTR ) pBuffer + sizeof( HOOK_CONTEXT ) );
for ( DWORD dwIndex = 0; dwIndex < sTotalSize; dwIndex++ )
{
	if ( *( DWORD64* ) ( pbFunctionStart + dwIndex ) == 0xBAADF00DBAADBEEF )
	{
		*( DWORD64* ) ( pbFunctionStart + dwIndex ) = ( DWORD64 ) pBuffer;
		bIsFound = TRUE;
		break;
	}
}
```
The figure shows how the allocated memory in the target process looks like:
![image](https://github.com/user-attachments/assets/9e58b5dd-e27b-4f3b-9d5e-c670a1458e82)

### Demo 01

https://github.com/user-attachments/assets/c4f361ca-3235-4dae-96b7-6d12c2bb92da


## PsImageLoadNotify + APC Injection
`PsImageLoadNotify` is used to register kernel callback that get triggered whenever an image is loaded. 
Since we only want to inject the DLL into newly created user-mode processes, we'll apply a filter using the following if statement:
```c
if (
      // Exclude system images.
      !ImageInfo->SystemModeImage &&

      // Exclude images loaded remotely.
      ProcessId == PsGetCurrentProcessId( ) &&

      // Exclude image name that not end with kernel32.dll.
      (the first dll that is get loaded from user-mode on process creation is kernel32.dll)
      Utils::EndsWithUnicodeString( FullImageName, &uKernel32, TRUE ) &&

      // Exclude images that not get loaded via `LdrLoadDll`.
      // (This is checked by verifying if Teb->ArbitraryUserPointer == L"...\kernel32.dll".)
      Utils::IsLoadedByLdrLoadDll( &uKernel32 )
)
{
    // At this point, we're in a good position to inject the DLL
    // right after kernel32.dll has been loaded. 
}
```

`LdrInitializeThunk` is the first function executed in user-mode where process is still in the creation steps. 
The last thing this function do is it calls `Ntdll!NtTestAlert` to free the APC queue. to know more about this function you can read this blog [@outflank: Introducing Early Cascade Injection](https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection)

This makes it a great opportunity to inject our DLL, so if we queue an APC before `Ntdll!NtTestAlert` is called, our code will be executed as part of the process's normal flow.
We can inject/queue APC from kernel-mode with	`KeInitializeApc` and `KeInsertQueueApc`.
```c
KeInitializeApc( apc, Thread, OriginalApcEnvironment, KernelAPC, NULL, APCCallbackCodeCave, UserMode, Arguments );
KeInsertQueueApc( apc, NULL, NULL, 0 );
```

### Demo 02
https://github.com/user-attachments/assets/f132bb18-3c9f-472b-878c-c820fe342472

# Credits
- [@outflank: Introducing Early Cascade Injection](https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection)
- [@Rhydon1337: windows-kernel-dll-injector](https://github.com/Rhydon1337/windows-kernel-dll-injector)
- [@dennisbabkin: DLL Injection playlist](https://www.youtube.com/watch?v=_k3njkNkvmI&list=PLo7Gwt6RpLEdF1cdS7rJ3AFv_Qusbs9hD)
- [@5pider: Modern shellcode implant design](https://5pider.net/blog/2024/01/27/modern-shellcode-implant-design)

```