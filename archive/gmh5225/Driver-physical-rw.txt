Project Path: arc_gmh5225_Driver-physical-rw_l25y4h4e

Source Tree:

```txt
arc_gmh5225_Driver-physical-rw_l25y4h4e
├── LICENSE
├── README.md
├── comms.h
├── entry.cpp
├── functions.cpp
├── functions.h
└── globals.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 CowNow

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Driver-physical-rw
Driver using IOCTL for some cheat, with physical read and write

## functions
```cpp
ReadPhysicalMemory();
WritePhysicalMemory();
ProtectProcess();
GetModuleBase();
AllocateVirtualMemory();
FreeVirtualMemory();
ProtectVirtualMemory();
CopyVirtualMemory();
```

## Application calling function
```cpp
bool __fastcall SendRequest(void* data, request_codes code)
{
    if (!data || !code || hDriver == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    request_data request{ 0 };
    request.unique = request_unique;
    request.data = data;
    request.code = code;
    DWORD bytesReturned = 0;

    BOOL success = DeviceIoControl(
        hDriver,
        static_cast<DWORD>(code),
        &request,
        sizeof(request_data),
        &request,
        sizeof(request_data),
        &bytesReturned,
        NULL
    );

    if (!success)
        return false;

    return true;
}
```

```

`comms.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <cstdint>

typedef enum _request_codes
{
	init_driver = 0x358,
	get_base = 0x359,
	read_memory = 0x355,
	write_memory = 0x325,
	alloc_memory = 0x323,
	copy_memory = 0x324,
	protect_memory = 0x322,
	call_entry = 0x320,
	free_memory = 0x321,
	request_success = 0x22c,
	request_unique = 0x92b,
	request_unload = 0x93b,
	protect_process = 0x94b,
}request_codes, * prequest_codes;

typedef struct _unload_request
{
	bool buffer;
}unload_request, * punload_request;

typedef struct _read_request {
	HANDLE pid;
	PVOID address;
	PVOID buffer;
	SIZE_T size;
} read_request, * pread_request;

struct process_request_t
{
	ULONG process_id;
};


typedef struct _write_request {
	HANDLE pid;
	PVOID address;
	PVOID buffer;
	SIZE_T size;
} write_request, * pwrite_request;

typedef struct _base_request {
	HANDLE pid;
	HANDLE handle;
	CHAR name[100];
} base_request, * pbase_request;

typedef struct _driver_init {
	bool init;
} driver_init, * pdriver_init;

typedef struct _swap_request
{
	ULONG pid;
	PVOID dst;
	PVOID src;
	PVOID old;
}swap_request, * pswap_request;

typedef struct _free_request
{
	HANDLE targetPid;
	PVOID address;
	SIZE_T code;
}free_request, * pfree_request;

typedef struct _call_entry_request
{
	HANDLE process_id;
	PVOID address;
	PVOID shellcode;

	BOOLEAN result;
} call_entry_request, * pcall_entry_request;

typedef struct _allocate_request
{
	HANDLE targetPid;
	ULONG allocationType, protect;
	PVOID sourceAddress;
	PVOID targetAddress;
	SIZE_T size;
	SIZE_T code;

}allocate_request, * pallocate_request;

typedef struct _copy_request
{
	HANDLE targetPid;
	PVOID targetAddress;
	HANDLE sourcePid;
	PVOID sourceAddress;
	SIZE_T size;

} copy_request, * pcopy_request;


typedef struct _protect_request
{
	HANDLE targetPid;
	ULONG protect;
	uintptr_t sourceAddress;
	size_t size;
	size_t code;
}protect_request, * pprotect_request;

typedef struct _expose_request
{
	void* address;
	size_t size;
	uint32_t pid;
}expose_request, * pexpose_request;

typedef struct _pattern_request
{
	int pid;
	uintptr_t base;
	char signature[260];
	uintptr_t address;
}pattern_request, * ppattern_request;

typedef struct _request_data
{
	uint32_t unique;
	request_codes code;
	void* data;
}request_data, * prequest_data;
```

`entry.cpp`:

```cpp
#include "functions.h"
#include "comms.h"

#define WINDOWS_IGNORE_PACKING_MISMATCH

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\ApexDriver");
    UNICODE_STRING SymbolicLink = RTL_CONSTANT_STRING(L"\\??\\ApexDriver");
    PDEVICE_OBJECT DeviceObject;

    NTSTATUS Status = IoCreateDevice(
        DriverObject,
        0,
        &DeviceName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &DeviceObject
    );

    if (!NT_SUCCESS(Status))
        return Status;
    DeviceObject->Flags = DO_BUFFERED_IO;

    Status = IoCreateSymbolicLink(&SymbolicLink, &DeviceName);
    if (!NT_SUCCESS(Status)) {
        IoDeleteDevice(DeviceObject);
        return Status;
    }

    for (ULONG i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        DriverObject->MajorFunction[i] = HandleDriverRequest;

    DriverObject->DriverUnload = DriverUnload;
    return STATUS_SUCCESS;
}

void DriverUnload(PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING SymbolicLink = RTL_CONSTANT_STRING(L"\\??\\ApexDriver");
    IoDeleteSymbolicLink(&SymbolicLink);
    IoDeleteDevice(DriverObject->DeviceObject);
}

```

`functions.cpp`:

```cpp
#include "functions.h"
#include "comms.h"

NTSTATUS ReadPhysicalMemory(HANDLE ProcessId, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
    PEPROCESS SourceProcess;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &SourceProcess);
    if (!NT_SUCCESS(Status))
        return Status;

    KAPC_STATE ApcState;
    KeStackAttachProcess(SourceProcess, &ApcState);
    PHYSICAL_ADDRESS PhysicalAddr = MmGetPhysicalAddress(SourceAddress);
    KeUnstackDetachProcess(&ApcState);

    if (PhysicalAddr.QuadPart == 0)
    {
        ObDereferenceObject(SourceProcess);
        return STATUS_INVALID_ADDRESS;
    }

    PVOID MappedMemory = MmMapIoSpace(PhysicalAddr, Size, MmNonCached);
    if (!MappedMemory)
    {
        ObDereferenceObject(SourceProcess);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(TargetAddress, MappedMemory, Size);

    MmUnmapIoSpace(MappedMemory, Size);

    ObDereferenceObject(SourceProcess);
    return STATUS_SUCCESS;
}

NTSTATUS WritePhysicalMemory(HANDLE ProcessId, PVOID TargetAddress, PVOID SourceAddress, SIZE_T Size)
{
    PEPROCESS TargetProcess;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &TargetProcess);
    if (!NT_SUCCESS(Status))
        return Status;

    KAPC_STATE ApcState;
    KeStackAttachProcess(TargetProcess, &ApcState);
    PHYSICAL_ADDRESS PhysicalAddr = MmGetPhysicalAddress(TargetAddress);
    KeUnstackDetachProcess(&ApcState);

    if (PhysicalAddr.QuadPart == 0)
    {
        ObDereferenceObject(TargetProcess);
        return STATUS_INVALID_ADDRESS;
    }

    PVOID MappedMemory = MmMapIoSpace(PhysicalAddr, Size, MmNonCached);
    if (!MappedMemory)
    {
        ObDereferenceObject(TargetProcess);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(MappedMemory, SourceAddress, Size);

    MmUnmapIoSpace(MappedMemory, Size);

    ObDereferenceObject(TargetProcess);
    return STATUS_SUCCESS;
}

NTSTATUS ProtectProcess(HANDLE ProcessId)
{
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;

    PUCHAR ProcessObject = (PUCHAR)Process;

    *(PUCHAR)(ProcessObject + 0x87A) = 1;

    ObDereferenceObject(Process);
    return STATUS_SUCCESS;
}

NTSTATUS GetModuleBase(HANDLE ProcessId, LPCSTR ModuleName, PVOID* BaseAddress)
{
    if (!ModuleName || !BaseAddress) {
        return STATUS_INVALID_PARAMETER;
    }
    
    *BaseAddress = NULL;
    
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;
    
    __try {
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        
        __try {
            PPEB Peb = PsGetProcessPeb(Process);
            if (!Peb) {
                Status = STATUS_UNSUCCESSFUL;
                __leave;
            }
            
            if (_stricmp(ModuleName, "") == 0 || _stricmp(ModuleName, "exe") == 0) {
                *BaseAddress = Peb->ImageBaseAddress;
                Status = *BaseAddress ? STATUS_SUCCESS : STATUS_NOT_FOUND;
                __leave;
            }
            
            if (!Peb->Ldr) {
                Status = STATUS_UNSUCCESSFUL;
                __leave;
            }
            
            PPEB_LDR_DATA Ldr = Peb->Ldr;
            PLIST_ENTRY ModuleList = &Ldr->InLoadOrderModuleList;
            PLIST_ENTRY Entry = ModuleList->Flink;
            
            // 遍历模块列表
            while (Entry && Entry != ModuleList) {
                PLDR_DATA_TABLE_ENTRY Module = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                
                // 安全检查
                if (!Module || !Module->BaseDllName.Buffer) {
                    Entry = Entry->Flink;
                    continue;
                }
                
                // 转换模块名称为ANSI字符串进行比较
                char ModuleNameBuffer[256] = {0};
                ULONG ConvertedLength = 0;
                
                Status = RtlUnicodeToMultiByteN(
                    ModuleNameBuffer,
                    sizeof(ModuleNameBuffer) - 1,
                    &ConvertedLength,
                    Module->BaseDllName.Buffer,
                    Module->BaseDllName.Length
                );
                
                if (NT_SUCCESS(Status)) {
                    ModuleNameBuffer[ConvertedLength] = '\0';
                    
                    if (_stricmp(ModuleNameBuffer, ModuleName) == 0) {
                        *BaseAddress = Module->DllBase;
                        Status = STATUS_SUCCESS;
                        __leave;
                    }
                }
                
                Entry = Entry->Flink;
            }
            
            Status = STATUS_NOT_FOUND;
        }
        __finally {
            KeUnstackDetachProcess(&ApcState);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    
    ObDereferenceObject(Process);
    return Status;
}

NTSTATUS AllocateVirtualMemory(
    HANDLE ProcessId,
    PVOID* BaseAddress,
    SIZE_T Size,
    ULONG AllocationType,
    ULONG Protect)
{
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;

    KAPC_STATE ApcState;
    KeStackAttachProcess(Process, &ApcState);

    Status = ZwAllocateVirtualMemory(
        NtCurrentProcess(),
        BaseAddress,
        0,
        &Size,
        AllocationType,
        Protect
    );

    KeUnstackDetachProcess(&ApcState);
    ObDereferenceObject(Process);
    return Status;
}

NTSTATUS FreeVirtualMemory(HANDLE ProcessId, PVOID BaseAddress)
{
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;

    KAPC_STATE ApcState;
    KeStackAttachProcess(Process, &ApcState);

    SIZE_T Size = 0;
    Status = ZwFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &Size,
        MEM_RELEASE
    );

    KeUnstackDetachProcess(&ApcState);
    ObDereferenceObject(Process);
    return Status;
}

NTSTATUS ProtectVirtualMemory(
    HANDLE ProcessId,
    PVOID BaseAddress,
    SIZE_T Size,
    ULONG NewProtect,
    PULONG OldProtect)
{
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;

    KAPC_STATE ApcState;
    KeStackAttachProcess(Process, &ApcState);

    Status = ZwProtectVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &Size,
        NewProtect,
        OldProtect
    );

    KeUnstackDetachProcess(&ApcState);
    ObDereferenceObject(Process);
    return Status;
}

NTSTATUS CopyVirtualMemory(
    HANDLE SourceProcessId,
    PVOID SourceAddress,
    HANDLE TargetProcessId,
    PVOID TargetAddress,
    SIZE_T Size)
{
    PEPROCESS SourceProcess, TargetProcess;
    NTSTATUS Status;

    Status = PsLookupProcessByProcessId(SourceProcessId, &SourceProcess);
    if (!NT_SUCCESS(Status))
        return Status;

    Status = PsLookupProcessByProcessId(TargetProcessId, &TargetProcess);
    if (!NT_SUCCESS(Status))
    {
        ObDereferenceObject(SourceProcess);
        return Status;
    }

    SIZE_T Result;
    Status = MmCopyVirtualMemory(
        SourceProcess,
        SourceAddress,
        TargetProcess,
        TargetAddress,
        Size,
        KernelMode,
        &Result
    );

    ObDereferenceObject(SourceProcess);
    ObDereferenceObject(TargetProcess);
    return Status;
}

NTSTATUS CallKernelFunction(HANDLE ProcessId, PVOID EntryPoint, PVOID Context)
{
    PEPROCESS Process;
    NTSTATUS Status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (!NT_SUCCESS(Status))
        return Status;

    HANDLE ThreadHandle;
    Status = PsCreateSystemThread(
        &ThreadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        (PKSTART_ROUTINE)EntryPoint,
        Context
    );

    if (NT_SUCCESS(Status)) {
        ZwClose(ThreadHandle);
    }

    ObDereferenceObject(Process);
    return Status;
}

NTSTATUS HandleDriverRequest(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
    PVOID InputBuffer = NULL;
    PVOID OutputBuffer = NULL;
    ULONG InputBufferLength = 0;
    ULONG OutputBufferLength = 0;

    switch (Stack->MajorFunction)
    {
    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IRP_MJ_DEVICE_CONTROL:
    {
        InputBuffer = Irp->AssociatedIrp.SystemBuffer;
        OutputBuffer = Irp->AssociatedIrp.SystemBuffer;
        InputBufferLength = Stack->Parameters.DeviceIoControl.InputBufferLength;
        OutputBufferLength = Stack->Parameters.DeviceIoControl.OutputBufferLength;

        if (!InputBuffer || !OutputBuffer || !InputBufferLength || !OutputBufferLength)
        {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            break;
        }

        prequest_data Request = (prequest_data)InputBuffer;
        if (!Request)
        {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            break;
        }

        switch (Request->code)
        {
        case init_driver:
        {
            pdriver_init Init = (pdriver_init)Request->data;
            if (!Init)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Init->init = true;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }
        case get_base:
        {
            pbase_request Base = (pbase_request)Request->data;
            if (!Base)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            PVOID BaseAddress;
            Irp->IoStatus.Status = GetModuleBase(Base->pid, Base->name, &BaseAddress);
            if (NT_SUCCESS(Irp->IoStatus.Status))
                Base->handle = BaseAddress;
            break;
        }
        case read_memory:
        {
            pread_request Read = (pread_request)Request->data;
            if (!Read)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = ReadPhysicalMemory(Read->pid, Read->address, Read->buffer, Read->size);
            break;
        }
        case write_memory:
        {
            pwrite_request Write = (pwrite_request)Request->data;
            if (!Write)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = WritePhysicalMemory(Write->pid, Write->address, Write->buffer, Write->size);
            break;
        }
        case protect_process:
        {
            process_request_t* ProcessRequest = (process_request_t*)Request->data;
            if (!ProcessRequest)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = ProtectProcess((HANDLE)ProcessRequest->process_id);
            break;
        }
        case alloc_memory:
        {
            pallocate_request Alloc = (pallocate_request)Request->data;
            if (!Alloc)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = AllocateVirtualMemory(
                Alloc->targetPid,
                &Alloc->targetAddress,
                Alloc->size,
                Alloc->allocationType,
                Alloc->protect
            );
            break;
        }
        case free_memory:
        {
            pfree_request Free = (pfree_request)Request->data;
            if (!Free)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = FreeVirtualMemory(Free->targetPid, Free->address);
            break;
        }
        case protect_memory:
        {
            pprotect_request Protect = (pprotect_request)Request->data;
            if (!Protect)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            ULONG OldProtect;
            Irp->IoStatus.Status = ProtectVirtualMemory(
                Protect->targetPid,
                (PVOID)Protect->sourceAddress,
                Protect->size,
                Protect->protect,
                &OldProtect
            );
            break;
        }
        case copy_memory:
        {
            pcopy_request Copy = (pcopy_request)Request->data;
            if (!Copy)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = CopyVirtualMemory(
                Copy->sourcePid,
                Copy->sourceAddress,
                Copy->targetPid,
                Copy->targetAddress,
                Copy->size
            );
            break;
        }
        case call_entry:
        {
            pcall_entry_request Call = (pcall_entry_request)Request->data;
            if (!Call)
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Irp->IoStatus.Status = CallKernelFunction(
                Call->process_id,
                Call->address,
                Call->shellcode
            );
            break;
        }
        default:
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (NT_SUCCESS(Irp->IoStatus.Status))
            Irp->IoStatus.Information = OutputBufferLength;
        break;
    }
    default:
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        break;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

```

`functions.h`:

```h
#pragma once
#include "globals.h"

EXTERN_C NTSTATUS __declspec(dllexport) DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
void DriverUnload(PDRIVER_OBJECT DriverObject);

NTSTATUS ReadPhysicalMemory(HANDLE ProcessId, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);
NTSTATUS WritePhysicalMemory(HANDLE ProcessId, PVOID TargetAddress, PVOID SourceAddress, SIZE_T Size);

NTSTATUS ProtectProcess(HANDLE ProcessId);

NTSTATUS GetModuleBase(HANDLE ProcessId, LPCSTR ModuleName, PVOID* BaseAddress);

NTSTATUS AllocateVirtualMemory(
    HANDLE ProcessId,
    PVOID* BaseAddress,
    SIZE_T Size,
    ULONG AllocationType,
    ULONG Protect
);

NTSTATUS FreeVirtualMemory(
    HANDLE ProcessId,
    PVOID BaseAddress
);

NTSTATUS ProtectVirtualMemory(
    HANDLE ProcessId,
    PVOID BaseAddress,
    SIZE_T Size,
    ULONG NewProtect,
    PULONG OldProtect
);

NTSTATUS CopyVirtualMemory(
    HANDLE SourceProcessId,
    PVOID SourceAddress,
    HANDLE TargetProcessId,
    PVOID TargetAddress,
    SIZE_T Size
);

NTSTATUS CallKernelFunction(
    HANDLE ProcessId,
    PVOID EntryPoint,
    PVOID Context
);

NTSTATUS HandleDriverRequest(PDEVICE_OBJECT DeviceObject, PIRP Irp);

```

`globals.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>

EXTERN_C PVOID MmMapIoSpace(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
);

EXTERN_C VOID MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
);

EXTERN_C PHYSICAL_ADDRESS MmGetPhysicalAddress(
    IN PVOID BaseAddress
);

EXTERN_C NTSTATUS MmCopyVirtualMemory(
	IN PEPROCESS FromProcess,
	IN CONST VOID* FromAddress,
	IN PEPROCESS ToProcess,
	OUT PVOID ToAddress,
	IN SIZE_T BufferSize,
	IN KPROCESSOR_MODE PreviousMode,
	OUT PSIZE_T NumberOfBytesCopied
);

EXTERN_C NTSTATUS ZwProtectVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID* BaseAddress,
	IN PSIZE_T RegionSize,
	IN ULONG NewProtect,
	OUT PULONG OldProtect
);

EXTERN_C NTKERNELAPI PPEB NTAPI PsGetProcessPeb(
	IN PEPROCESS Process
);

EXTERN_C NTKERNELAPI PPEB NTAPI PsGetProcessWow64Process(
	IN PEPROCESS Process
);

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	UCHAR Mutant;
	UCHAR ImageBaseAddress;;
	UCHAR Ldr;
	UCHAR ProcessParameters;
	UCHAR SubSystemData;
	UCHAR ProcessHeap;
	UCHAR FastPebLock;
	UCHAR AtlThunkSListPtr;
	UCHAR IFEOKey;
	UCHAR CrossProcessFlags;
	UCHAR UserSharedInfoPtr;
	UCHAR SystemReserved;
	UCHAR AtlThunkSListPtr32;
	UCHAR ApiSetMap;
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, *PPEB;

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT Obsolete1;
	USHORT HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT Obsolete1;
	USHORT HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;
```