Project Path: arc_gmh5225_Android_Inline_Hook_ARM64_v_7wvu9_

Source Tree:

```txt
arc_gmh5225_Android_Inline_Hook_ARM64_v_7wvu9_
├── README.md
├── STACK1.pdf
├── STACK1.png
├── STACK2.pdf
├── STACK2.png
├── arm64hook.pdf
├── arm64hook.png
├── arm64hook.vsdx
├── arm64hook4.png
├── jni
│   ├── Android.mk
│   ├── Application.mk
│   ├── InlineHook
│   │   ├── Android.mk
│   │   ├── Ihook.c
│   │   ├── Ihook.h
│   │   ├── fixPCOpcode.c
│   │   ├── fixPCOpcode.h
│   │   └── ihookstub.s
│   └── Interface
│       ├── Android.mk
│       └── InlineHook.cpp
├── libs
│   └── arm64-v8a
│       └── libInlineHook.so
├── obj
│   └── local
│       ├── arm64-v8a
│       │   ├── libIHook.a
│       │   ├── libInlineHook.so
│       │   └── objs
│       │       ├── IHook
│       │       │   ├── IHook.o
│       │       │   ├── IHook.o.d
│       │       │   ├── fixPCOpcode.o
│       │       │   ├── fixPCOpcode.o.d
│       │       │   └── ihookstub.o
│       │       └── InlineHook
│       │           ├── InlineHook.o
│       │           └── InlineHook.o.d
│       └── armeabi-v7a
│           ├── libIHook.a
│           ├── libInlineArmHook.so
│           ├── libInlineHook.so
│           └── objs
│               ├── IHook
│               │   ├── IHook.o
│               │   ├── IHook.o.d
│               │   ├── fixPCOpcode.o
│               │   ├── fixPCOpcode.o.d
│               │   ├── ihookstub.o
│               │   └── ihookstubthumb.o
│               ├── InlineArmHook
│               │   ├── InlineHook.o
│               │   └── InlineHook.o.d
│               └── InlineHook
│                   ├── InlineHook.o
│                   └── InlineHook.o.d
├── stack.pdf
├── stack.vsdx
└── stack.xlsx

```

`README.md`:

```md
# Android Inline Hook ARM64

This is the ARM64 version of [Android Inline Hook](https://github.com/GToad/Android_Inline_Hook.git). I highly recommend you to view [Android Inline Hook](https://github.com/GToad/Android_Inline_Hook.git) first.

`This arm64-version is almost finished. But I still need some time on the docs and code-fix work. Thank you for your patience!`

# Android Inline Hook

This project make an Android .so file that can automatically do some native hook works.

It mainly use Android Inline Hook, not PLT Hook.

If you can read Chinese or wanna see more picture, I've wrote some articles about this repo and the first one is the main article. `I highly recommend you to read the articles before reading the code.` These article will save you a lot of time, I promise.

1. [Android Inline Hook Practice](https://gtoad.github.io/2018/07/06/Android-Native-Hook-Practice/)
2. [Opcode Fix In Android Inline Hook](https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/)
3. [An Introduction to Android Native Hook](https://gtoad.github.io/2018/07/05/Android-Native-Hook/)
4. [Android Inline Hook ARM64 Practice](https://gtoad.github.io/2018/09/20/Android-Native-Hook-Practice-Arm64/)

# Articles in English

I've received several e-mails and all the questions in them have been written in the Chinese articles. So i think it's necessary translate some part of the articles in English. I will try my best to tanslate more part and the parts metioned by the questions in issue will have high priority.

1. [Android Inline Hook Practice EN](https://gtoad.github.io/2018/08/03/Android-Native-Hook-Practice-EN/)

# Features

1. No ptrace -- So the anti-debug tech won't affect on this tool.
2. Auto run -- Just use Xposed or other tools to load it into the memory and it will do the native hook work.
3. Pure inline hook -- No other imprint left so it's hard to anti.
4. Flexible -- Fine docs for users to understand the code and change it on your own perpose.
5. Active support -- Brand new so I'm still keen on fix the bugs and arm32/thumb-2/arm64 has been finished one by one.

# How To Use

The only thing you have to change is the code in `InlineHook.cpp`.

You can name the `__attribute__((constructor)) ModifyIBored()` function at your will and change the follow arg in it:

1. `pModuleBaseAddr` is the address of your target so.
2. `target_offset` is the offset of your hook point in the target so.

`EvilHookStubFunctionForIBored` function is the thing you really wanna do when the hook works. You can name at your will, but keep the arg `(pt_regs *regs)`. It brings you the power to control the registers, like set r0 to 0x333 : `regs->uregs[0]=0x333;`.

After you finish the args above, just `ndk-build` and you will get your .so file.

# ARM64 Design

![](https://gtoad.github.io/img/in-post/post-android-native-hook-practice-ARM64/arm64hook.png)

# Example

I've make some examples in other repo, it includes code and the target APK file.

1. [thumb-2 example](https://github.com/GToad/Android_Inline_Hook_Thumb_Example.git)
2. [arm32 example](https://github.com/GToad/Android_Inline_Hook_Arm_Example.git)

# Contact

I believe that this project still has some problems. If you find some bugs or have some problems, you can send e-mail to `gtoad1994@aliyun.com`. I wish we can fix it together!

# Reference

[Game Security Lab of Tencent](http://gslab.qq.com/portal.php?mod=view&aid=168)

[Ele7enxxh's Blog](http://ele7enxxh.com/Android-Arm-Inline-Hook.html)





```

`jni/Android.mk`:

```mk
include $(call all-subdir-makefiles)
```

`jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := gnustl_static
APP_CPPFLAGS += -fexceptions
```

`jni/InlineHook/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)  


include $(CLEAR_VARS)

LOCAL_CXXFLAGS +=  -g -O0
LOCAL_ARM_MODE := arm
LOCAL_MODULE    := IHook
LOCAL_SRC_FILES := IHook.c ihookstub.s fixPCOpcode.c
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog

include $(BUILD_STATIC_LIBRARY)

```

`jni/InlineHook/Ihook.c`:

```c
#include "Ihook.h"
#include "fixPCOpcode.h"

#define ALIGN_PC(pc)	(pc & 0xFFFFFFFC)

/**
 * 修改页属性，改成可读可写可执行
 * @param   pAddress   需要修改属性起始地址
 * @param   size       需要修改页属性的长度，byte为单位
 * @return  bool       修改是否成功
 */
bool ChangePageProperty(void *pAddress, size_t size)
{
    bool bRet = false;
    
    if(pAddress == NULL)
    {
        LOGI("change page property error.");
        return bRet;
    }
    
    //计算包含的页数、对齐起始地址
    unsigned long ulPageSize = sysconf(_SC_PAGESIZE); //得到页的大小
    int iProtect = PROT_READ | PROT_WRITE | PROT_EXEC;
    unsigned long ulNewPageStartAddress = (unsigned long)(pAddress) & ~(ulPageSize - 1); //pAddress & 0x1111 0000 0000 0000
    long lPageCount = (size / ulPageSize) + 1;
    
    long l = 0;
    while(l < lPageCount)
    {
        //利用mprotect改页属性
        int iRet = mprotect((const void *)(ulNewPageStartAddress), ulPageSize, iProtect);
        if(-1 == iRet)
        {
            LOGI("mprotect error:%s", strerror(errno));
            return bRet;
        }
        l++; 
    }
    
    return true;
}

/**
 * 通过/proc/$pid/maps，获取模块基址
 * @param   pid                 模块所在进程pid，如果访问自身进程，可填小余0的值，如-1
 * @param   pszModuleName       模块名字
 * @return  void*               模块基址，错误则返回0
 */
void * GetModuleBaseAddr(pid_t pid, char* pszModuleName)
{
    FILE *pFileMaps = NULL;
    unsigned long ulBaseValue = 0;
    char szMapFilePath[256] = {0};
    char szFileLineBuffer[1024] = {0};
    LOGI("first fork(): I'am father pid=%d", getpid());

    LOGI("Pid is %d\n",pid);

    //pid判断，确定maps文件
    if (pid < 0)
    {
        snprintf(szMapFilePath, sizeof(szMapFilePath), "/proc/self/maps");
    }
    else
    {
        snprintf(szMapFilePath, sizeof(szMapFilePath),  "/proc/%d/maps", pid);
    }

    pFileMaps = fopen(szMapFilePath, "r");
    if (NULL == pFileMaps)
    {
        return (void *)ulBaseValue;
    }
    LOGI("%d",pFileMaps);

    LOGI("Get map.\n");

    //循环遍历maps文件，找到相应模块，截取地址信息
    while (fgets(szFileLineBuffer, sizeof(szFileLineBuffer), pFileMaps) != NULL)
    {
        //LOGI("%s\n",szFileLineBuffer);
        //LOGI("%s\n",pszModuleName);
        if (strstr(szFileLineBuffer, pszModuleName))
        {
            LOGI("%s\n",szFileLineBuffer);
            char *pszModuleAddress = strtok(szFileLineBuffer, "-");
            if (pszModuleAddress)
            {
                ulBaseValue = strtoul(pszModuleAddress, NULL, 16);

                if (ulBaseValue == 0x8000)
                    ulBaseValue = 0;

                break;
            }
        }
    }
    fclose(pFileMaps);
    return (void *)ulBaseValue;
}

/**
 * arm下inline hook基础信息备份（备份原先的opcodes）
 * @param  pstInlineHook inlinehook信息
 * @return               初始化信息是否成功
 */
bool InitArmHookInfo(INLINE_HOOK_INFO* pstInlineHook)
{
    bool bRet = false;
    uint32_t *currentOpcode = pstInlineHook->pHookAddr;

    for(int i=0;i<BACKUP_CODE_NUM_MAX;i++){
        pstInlineHook->backUpFixLengthList[i] = -1;
    }
    LOGI("pstInlineHook->szbyBackupOpcodes is at %x",pstInlineHook->szbyBackupOpcodes);

    
    if(pstInlineHook == NULL)
    {
        LOGI("pstInlineHook is null");
        return bRet;
    }

    pstInlineHook->backUpLength = 24;
    
    memcpy(pstInlineHook->szbyBackupOpcodes, pstInlineHook->pHookAddr, pstInlineHook->backUpLength);

    for(int i=0;i<6;i++){
        //currentOpcode += i; //GToad BUG
        LOGI("Arm64 Opcode to fix %d : %x",i,*currentOpcode);
        LOGI("Fix length : %d",lengthFixArm32(*currentOpcode));
        pstInlineHook->backUpFixLengthList[i] = lengthFixArm64(*currentOpcode);
        currentOpcode += 1; //GToad BUG
    }
    
    return true;
}

/**
 * 利用ihookstub.s中的shellcode构造桩，跳转到pstInlineHook->onCallBack函数后，回调老函数
 * @param  pstInlineHook inlinehook信息
 * @return               inlinehook桩是否构造成功
 */
bool BuildStub(INLINE_HOOK_INFO* pstInlineHook)
{
    bool bRet = false;
    
    while(1)
    {
        if(pstInlineHook == NULL)
        {
            LOGI("pstInlineHook is null");
            break;
        }
        
        void *p_shellcode_start_s = &_shellcode_start_s;
        void *p_shellcode_end_s = &_shellcode_end_s;
        void *p_hookstub_function_addr_s = &_hookstub_function_addr_s;
        void *p_old_function_addr_s = &_old_function_addr_s;

        size_t sShellCodeLength = p_shellcode_end_s - p_shellcode_start_s;
        //malloc一段新的stub代码
        void *pNewShellCode = malloc(sShellCodeLength);
        if(pNewShellCode == NULL)
        {
            LOGI("shell code malloc fail.");
            break;
        }
        memcpy(pNewShellCode, p_shellcode_start_s, sShellCodeLength);
        //更改stub代码页属性，改成可读可写可执行
        if(ChangePageProperty(pNewShellCode, sShellCodeLength) == false)
        {
            LOGI("change shell code page property fail.");
            break;
        }

        //设置跳转到外部stub函数去
        LOGI("_hookstub_function_addr_s : %lx",p_hookstub_function_addr_s);
        void **ppHookStubFunctionAddr = pNewShellCode + (p_hookstub_function_addr_s - p_shellcode_start_s);
        *ppHookStubFunctionAddr = pstInlineHook->onCallBack;
        LOGI("ppHookStubFunctionAddr : %lx",ppHookStubFunctionAddr);
        LOGI("*ppHookStubFunctionAddr : %lx",*ppHookStubFunctionAddr);
        
        //备份外部stub函数运行完后跳转的函数地址指针，用于填充老函数的新地址
        pstInlineHook->ppOldFuncAddr  = pNewShellCode + (p_old_function_addr_s - p_shellcode_start_s);
            
        //填充shellcode地址到hookinfo中，用于构造hook点位置的跳转指令
        pstInlineHook->pStubShellCodeAddr = pNewShellCode;

        

        bRet = true;
        break;
    }
    
    return bRet;
}


/**
 * 构造并填充ARM下32的跳转指令，需要外部保证可读可写，且pCurAddress至少8个bytes大小
 * @param  pCurAddress      当前地址，要构造跳转指令的位置
 * @param  pJumpAddress     目的地址，要从当前位置跳过去的地址
 * @return                  跳转指令是否构造成功
 */
bool BuildArmJumpCode(void *pCurAddress , void *pJumpAddress)
{
    LOGI("LIVE4.3.1");
    bool bRet = false;
    while(1)
    {
        LOGI("LIVE4.3.2");
        if(pCurAddress == NULL || pJumpAddress == NULL)
        {
            LOGI("address null.");
            break;
        }    
        LOGI("LIVE4.3.3");    
        //LDR PC, [PC, #-4]
        //addr
        //LDR PC, [PC, #-4]对应的机器码为：0xE51FF004
        //addr为要跳转的地址。该跳转指令范围为32位，对于32位系统来说即为全地址跳转。
        //缓存构造好的跳转指令（ARM下32位，两条指令只需要8个bytes）
        //BYTE szLdrPCOpcodes[8] = {0x04, 0xF0, 0x1F, 0xE5};

        //STP X1, X0, [SP, #-0x10]
        //LDR X0, 8
        //BR X0
        //ADDR(64)
        //LDR X0, [SP, -0x8]
        BYTE szLdrPCOpcodes[24] = {0xe1, 0x03, 0x3f, 0xa9, 0x40, 0x00, 0x00, 0x58, 0x00, 0x00, 0x1f, 0xd6};
        //将目的地址拷贝到跳转指令缓存位置
        memcpy(szLdrPCOpcodes + 12, &pJumpAddress, 8);
        szLdrPCOpcodes[20] = 0xE0;
        szLdrPCOpcodes[21] = 0x83;
        szLdrPCOpcodes[22] = 0x5F;
        szLdrPCOpcodes[23] = 0xF8;
        LOGI("LIVE4.3.4");
        
        //将构造好的跳转指令刷进去
        memcpy(pCurAddress, szLdrPCOpcodes, 24);
        LOGI("LIVE4.3.5");
        //__flush_cache(*((uint32_t*)pCurAddress), 20);
        //__builtin___clear_cache (*((uint64_t*)pCurAddress), *((uint64_t*)(pCurAddress+20)));
        //cacheflush(*((uint32_t*)pCurAddress), 20, 0);
        LOGI("LIVE4.3.6");
        bRet = true;
        break;
    }
    LOGI("LIVE4.3.7");
    return bRet;
}


/**
 * 构造被inline hook的函数头，还原原函数头+增加跳转
 * 仅是拷贝跳转即可，同时填充stub shellcode中的oldfunction地址及hookinfo里面的old函数地址
 * 这个实现没有指令修复功能，即是HOOK的位置指令不能涉及PC等需要重定向指令
 * @param  pstInlineHook inlinehook信息
 * @return               原函数构造是否成功
 */
bool BuildOldFunction(INLINE_HOOK_INFO* pstInlineHook)
{
    bool bRet = false;

    void *fixOpcodes;
    int fixLength;
    LOGI("LIVE3.1");

    fixOpcodes = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
    LOGI("LIVE3.2");
    while(1)
    {
        if(pstInlineHook == NULL)
        {
            LOGI("pstInlineHook is null");
            break;
        }
        LOGI("LIVE3.3");
        
        //8个bytes存放原来的opcodes，另外8个bytes存放跳转回hook点下面的跳转指令
        void * pNewEntryForOldFunction = malloc(200);
        if(pNewEntryForOldFunction == NULL)
        {
            LOGI("new entry for old function malloc fail.");
            break;
        }
        LOGI("LIVE3.4");

        pstInlineHook->pNewEntryForOldFunction = pNewEntryForOldFunction;
        LOGI("%x",pNewEntryForOldFunction);
        
        if(ChangePageProperty(pNewEntryForOldFunction, 200) == false)
        {
            LOGI("change new entry page property fail.");
            break;
        }
        LOGI("LIVE3.5");
        
        fixLength = fixPCOpcodeArm(fixOpcodes, pstInlineHook); //把第三部分的起始地址传过去
        memcpy(pNewEntryForOldFunction, fixOpcodes, fixLength);
        LOGI("LIVE3.6");
        //memcpy(pNewEntryForOldFunction, pstInlineHook->szbyBackupOpcodes, 8);
        //填充跳转指令
        if(BuildArmJumpCode(pNewEntryForOldFunction + fixLength, pstInlineHook->pHookAddr + pstInlineHook->backUpLength - 4) == false)
        {
            LOGI("build jump opcodes for new entry fail.");
            break;
        }
        LOGI("LIVE3.7");
        //填充shellcode里stub的回调地址
        *(pstInlineHook->ppOldFuncAddr) = pNewEntryForOldFunction;
        LOGI("LIVE3.8");
        
        bRet = true;
        break;
    }
    LOGI("LIVE3.9");
    
    return bRet;
}


    
/**
 * 在要HOOK的位置，构造跳转，跳转到shellcode stub中
 * @param  pstInlineHook inlinehook信息
 * @return               原地跳转指令是否构造成功
 */
bool RebuildHookTarget(INLINE_HOOK_INFO* pstInlineHook)
{
    bool bRet = false;
    
    while(1)
    {
        LOGI("LIVE4.1");
        if(pstInlineHook == NULL)
        {
            LOGI("pstInlineHook is null");
            break;
        }
        LOGI("LIVE4.2");
        //修改原位置的页属性，保证可写
        if(ChangePageProperty(pstInlineHook->pHookAddr, 24) == false)
        {
            LOGI("change page property error.");
            break;
        }
        LOGI("LIVE4.3");
        //填充跳转指令
        if(BuildArmJumpCode(pstInlineHook->pHookAddr, pstInlineHook->pStubShellCodeAddr) == false)
        {
            LOGI("build jump opcodes for new entry fail.");
            break;
        }
        LOGI("LIVE4.4");
        bRet = true;
        break;
    }
    LOGI("LIVE4.5");
    
    return bRet;
}


/**
 * ARM下的inlinehook
 * @param  pstInlineHook inlinehook信息
 * @return               inlinehook是否设置成功
 */
bool HookArm(INLINE_HOOK_INFO* pstInlineHook)
{
    bool bRet = false;
    LOGI("HookArm()");
    
    while(1)
    {
        //LOGI("pstInlineHook is null 1.");
        if(pstInlineHook == NULL)
        {
            LOGI("pstInlineHook is null.");
            break;
        }
        LOGI("LIVE1");

        //LOGI("Init Arm HookInfo fail 1.");
        //第零步，设置ARM下inline hook的基础信息
        if(InitArmHookInfo(pstInlineHook) == false)
        {
            LOGI("Init Arm HookInfo fail.");
            break;
        }
        LOGI("LIVE2");
        
        //LOGI("BuildStub fail 1.");
        //第二步，构造stub，功能是保存寄存器状态，同时跳转到目标函数，然后跳转回原函数
        //需要目标地址，返回stub地址，同时还有old指针给后续填充 
        if(BuildStub(pstInlineHook) == false)
        {
            LOGI("BuildStub fail.");
            break;
        }
        LOGI("LIVE3");
        
        //LOGI("BuildOldFunction fail 1.");
        //第四步，负责重构原函数头，功能是修复指令，构造跳转回到原地址下
        //需要原函数地址
        
        if(BuildOldFunction(pstInlineHook) == false)
        {
            LOGI("BuildOldFunction fail.");
            break;
        }
        LOGI("LIVE4");
        
        //LOGI("RebuildHookAddress fail 1.");
        //第一步，负责重写原函数头，功能是实现inline hook的最后一步，改写跳转
        //需要cacheflush，防止崩溃
        if(RebuildHookTarget(pstInlineHook) == false)
        {
            LOGI("RebuildHookAddress fail.");
            break;
        }
        LOGI("LIVE5");
        
        bRet = true;
        break;
    }
    LOGI("LIVE6");

    return bRet;
}



```

`jni/InlineHook/Ihook.h`:

```h
#ifndef _IHOOK_H
#define _IHOOK_H

#include <stdio.h>
#include <Android/log.h>
#include <errno.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ptrace.h>
#include <stdbool.h>
//#include <cacheflush.h>


#ifndef BYTE
#define BYTE unsigned char
#endif

#define OPCODEMAXLEN 24      //inline hook所需要的opcodes最大长度,arm64为20
#define BACKUP_CODE_NUM_MAX 6  //尽管备份原程序6条arm64指令。

#define LOG_TAG "GToad"
#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, fmt, ##args);

#define PAGE_START(addr)	(~(PAGE_SIZE - 1) & (addr))
#define SET_BIT0(addr)		(addr | 1)
#define CLEAR_BIT0(addr)	(addr & 0xFFFFFFFE)
#define TEST_BIT0(addr)		(addr & 1)

#define ACTION_ENABLE	0
#define ACTION_DISABLE	1

//#define __flush_cache(c, n)        __builtin___clear_cache(reinterpret_cast<char *>(c), reinterpret_cast<char *>(c) + n)

extern unsigned long _shellcode_start_s;
extern unsigned long _shellcode_end_s;
extern unsigned long _hookstub_function_addr_s;
extern unsigned long _old_function_addr_s;


//hook点信息
typedef struct tagINLINEHOOKINFO{
    void *pHookAddr;                //hook的地址
    void *pStubShellCodeAddr;            //跳过去的shellcode stub的地址
    void (*onCallBack)(struct user_pt_regs *);       //回调函数，跳转过去的函数地址
    void ** ppOldFuncAddr;             //shellcode 中存放old function的地址
    BYTE szbyBackupOpcodes[OPCODEMAXLEN];    //原来的opcodes
    int backUpLength; //备份代码的长度，arm64模式下为20
    int backUpFixLengthList[BACKUP_CODE_NUM_MAX]; //保存
    uint64_t *pNewEntryForOldFunction;
} INLINE_HOOK_INFO;

bool ChangePageProperty(void *pAddress, size_t size);

extern void * GetModuleBaseAddr(pid_t pid, char* pszModuleName);

bool InitArmHookInfo(INLINE_HOOK_INFO* pstInlineHook);

bool BuildStub(INLINE_HOOK_INFO* pstInlineHook);

bool BuildArmJumpCode(void *pCurAddress , void *pJumpAddress);

bool BuildOldFunction(INLINE_HOOK_INFO* pstInlineHook);

bool RebuildHookTarget(INLINE_HOOK_INFO* pstInlineHook);

extern bool HookArm(INLINE_HOOK_INFO* pstInlineHook);

#endif


```

`jni/InlineHook/fixPCOpcode.c`:

```c
#include "fixPCOpcode.h"

//这里的代码建议看文章：《Android Inline Hook中的指令修复详解》（https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/）

enum INSTRUCTION_TYPE {


	// BLX <label>
	BLX_ARM,
	// BL <label>
	BL_ARM,
	// B <label>
	B_ARM,

    // <Add by GToad>
    // B <label>
	BEQ_ARM,
    // B <label>
	BNE_ARM,
    // B <label>
	BCS_ARM,
    // B <label>
	BCC_ARM,
    // B <label>
	BMI_ARM,
    // B <label>
	BPL_ARM,
    // B <label>
	BVS_ARM,
    // B <label>
	BVC_ARM,
    // B <label>
	BHI_ARM,
    // B <label>
	BLS_ARM,
    // B <label>
	BGE_ARM,
    // B <label>
	BLT_ARM,
    // B <label>
	BGT_ARM,
    // B <label>
	BLE_ARM,
    // </Add by GToad>

	// BX PC
	BX_ARM,
	// ADD Rd, PC, Rm (Rd != PC, Rm != PC) 在对ADD进行修正时，采用了替换PC为Rr的方法，当Rd也为PC时，由于之前更改了Rr的值，可能会影响跳转后的正常功能;实际汇编中没有发现Rm也为PC的情况，故未做处理。
	ADD_ARM,
	// ADR Rd, <label>
	ADR1_ARM,
	// ADR Rd, <label>
	ADR2_ARM,
	// MOV Rd, PC
	MOV_ARM,
	// LDR Rt, <label>
	LDR_ARM,


	ADR_ARM64,

	ADRP_ARM64,

	LDR_ARM64,

	B_ARM64,

	B_COND_ARM64,

	BR_ARM64,

	BL_ARM64,

	BLR_ARM64,

	CBNZ_ARM64,

	CBZ_ARM64,

	TBNZ_ARM64,

	TBZ_ARM64,

	LDR_ARM64_32,

	UNDEFINE,
};

int lengthFixArm64(uint32_t opcode)
{
    int type;
    type = getTypeInArm64(opcode);
    switch(type)
    {
        case B_COND_ARM64:return 32;break;
        case BNE_ARM:
        case BCS_ARM:
        case BCC_ARM:
        case BMI_ARM:
        case BPL_ARM:
        case BVS_ARM:
        case BVC_ARM:
        case BHI_ARM:
        case BLS_ARM:
        case BGE_ARM:
        case BLT_ARM:
        case BGT_ARM:
        case BLE_ARM:return 12;break;
        case BLX_ARM:
        case BL_ARM:return 12;break;
        case B_ARM:
        case BX_ARM:return 8;break;
        case ADD_ARM:return 24;break;
        case ADR1_ARM:
        case ADR2_ARM:
        case LDR_ARM:
        case MOV_ARM:return 12;break;
        case UNDEFINE:return 4;
    }    
}


int lengthFixArm32(uint32_t opcode)
{
    int type;
    type = getTypeInArm32(opcode);
    switch(type)
    {
        case BEQ_ARM:
        case BNE_ARM:
        case BCS_ARM:
        case BCC_ARM:
        case BMI_ARM:
        case BPL_ARM:
        case BVS_ARM:
        case BVC_ARM:
        case BHI_ARM:
        case BLS_ARM:
        case BGE_ARM:
        case BLT_ARM:
        case BGT_ARM:
        case BLE_ARM:return 12;break;
        case BLX_ARM:
        case BL_ARM:return 12;break;
        case B_ARM:
        case BX_ARM:return 8;break;
        case ADD_ARM:return 24;break;
        case ADR1_ARM:
        case ADR2_ARM:
        case LDR_ARM:
        case MOV_ARM:return 12;break;
        case UNDEFINE:return 4;
    }    
}



static int getTypeInArm64(uint32_t instruction)
{
    LOGI("getTypeInArm64 : %x", instruction);
	if ((instruction & 0x9F000000) == 0x10000000) {
		return ADR_ARM64;
	}
	if ((instruction & 0x9F000000) == 0x90000000) {
		return ADRP_ARM64;
	}
    if ((instruction & 0xFC000000) == 0x14000000) {
		return B_ARM64;
	}
    if ((instruction & 0xFF000010) == 0x54000010) {
		return B_COND_ARM64;
	}
    if ((instruction & 0xFC000000) == 0x94000000) {
		return BL_ARM64;
	}


    if ((instruction & 0xFF000000) == 0x58000000) {//LDR Lliteral need to learn
		return LDR_ARM64;
	}
	if ((instruction & 0x7F000000) == 0x35000000) {
		return CBNZ_ARM64;
	}
	if ((instruction & 0x7F000000) == 0x34000000) {
		return CBZ_ARM64;
	}
	if ((instruction & 0x7F000000) == 0x37000000) {
		return TBNZ_ARM64;
	}
	if ((instruction & 0x7F000000) == 0x36000000) {
		return TBZ_ARM64;
	}

	if ((instruction & 0xFF000000) == 0x18000000) {//LDR Lliteral 32 need to learn
		return LDR_ARM64_32;
	}
	
	return UNDEFINE;
}

static int getTypeInArm32(uint32_t instruction)
{
    LOGI("getTypeInArm : %x", instruction);
	if ((instruction & 0xFE000000) == 0xFA000000) {
		return BLX_ARM;
	}
	if ((instruction & 0xF000000) == 0xB000000) {
		return BL_ARM;
	}
	if ((instruction & 0xFE000000) == 0x0A000000) {
		return BEQ_ARM;
	}
    if ((instruction & 0xFE000000) == 0x1A000000) {
		return BNE_ARM;
	}
    if ((instruction & 0xFE000000) == 0x2A000000) {
		return BCS_ARM;
	}
    if ((instruction & 0xFE000000) == 0x3A000000) {
		return BCC_ARM;
	}
    if ((instruction & 0xFE000000) == 0x4A000000) {
		return BMI_ARM;
	}
    if ((instruction & 0xFE000000) == 0x5A000000) {
		return BPL_ARM;
	}
    if ((instruction & 0xFE000000) == 0x6A000000) {
		return BVS_ARM;
	}
    if ((instruction & 0xFE000000) == 0x7A000000) {
		return BVC_ARM;
	}
    if ((instruction & 0xFE000000) == 0x8A000000) {
		return BHI_ARM;
	}
    if ((instruction & 0xFE000000) == 0x9A000000) {
		return BLS_ARM;
	}
    if ((instruction & 0xFE000000) == 0xAA000000) {
		return BGE_ARM;
	}
    if ((instruction & 0xFE000000) == 0xBA000000) {
		return BLT_ARM;
	}
    if ((instruction & 0xFE000000) == 0xCA000000) {
		return BGT_ARM;
	}
    if ((instruction & 0xFE000000) == 0xDA000000) {
		return BLE_ARM;
	}
    if ((instruction & 0xFE000000) == 0xEA000000) {
		return B_ARM;
	}
    
    /*
    if ((instruction & 0xFF000000) == 0xFA000000) {
		return BLX_ARM;
	} *//*
    if ((instruction & 0xF000000) == 0xA000000) {
		return B_ARM;
	}*/
    
	if ((instruction & 0xFF000FF) == 0x120001F) {
		return BX_ARM;
	}
	if ((instruction & 0xFEF0010) == 0x8F0000) {
		return ADD_ARM;
	}
	if ((instruction & 0xFFF0000) == 0x28F0000) {
		return ADR1_ARM;
	}
	if ((instruction & 0xFFF0000) == 0x24F0000) {
		return ADR2_ARM;		
	}
	if ((instruction & 0xE5F0000) == 0x41F0000) {
		return LDR_ARM;
	}
	if ((instruction & 0xFE00FFF) == 0x1A0000F) {
		return MOV_ARM;
	}
	return UNDEFINE;
}



bool isTargetAddrInBackup(uint64_t target_addr, uint64_t hook_addr, int backup_length)
{
    if((target_addr<=hook_addr+backup_length)&&(target_addr>=hook_addr))
        return true;
    return false;
}

int fixPCOpcodeArm(void *fixOpcodes , INLINE_HOOK_INFO* pstInlineHook)
{
    uint64_t pc;
    uint64_t lr;
    int backUpPos = 0;
    int fixPos = 0;
    int offset = 0;
    //int isConditionBcode = 0;
    uint32_t *currentOpcode;
    uint32_t tmpFixOpcodes[40]; //对于每条PC命令的修复指令都将暂时保存在这里。
    //uint32_t tmpBcodeFix;
    //uint32_t tmpBcodeX = 0;
	//trampoline_instructions[trampoline_pos++] == 0xf85f83e0; // ldr x0, [sp, #-0x8] recover the x0 register

    LOGI("Fixing Arm !!!!!!!");

    currentOpcode = pstInlineHook->szbyBackupOpcodes + sizeof(uint8_t)*backUpPos;
    LOGI("sizeof(uint8_t) : %D", sizeof(uint8_t));

    pc = pstInlineHook->pHookAddr; //pc变量用于保存原本指令执行时的pc值
    lr = pstInlineHook->pHookAddr + pstInlineHook->backUpLength;

    if(pstInlineHook == NULL)
    {
        LOGI("pstInlineHook is null");
    }

	tmpFixOpcodes[0] = 0xf85f83e0; // ldr x0, [sp, #-0x8] recover the x0 register
	offset = 4;
	memcpy(fixOpcodes+fixPos, tmpFixOpcodes, offset);
	fixPos=+offset;

    while(1) // 在这个循环中，每次都处理一个arm64命令
    {
        //LOGI("-------------START----------------");
        LOGI("currentOpcode is %x",*currentOpcode);
        
        offset = fixPCOpcodeArm64(pc, lr, *currentOpcode, tmpFixOpcodes, pstInlineHook);
        //LOGI("isConditionBcode : %d", isConditionBcode);
        //LOGI("offset : %d", offset);
        memcpy(fixOpcodes+fixPos, tmpFixOpcodes, offset);
        /*
        if (isConditionBcode==1) { // the first code is B??
            if (backUpPos == 4) { // the second has just been processed
                LOGI("Fix the first b_code.");
                LOGI("offset : %d",offset);
                tmpBcodeFix += (offset/4 +1);
                memcpy(fixOpcodes, &tmpBcodeFix, 4);
                LOGI("Fix the first b_code 1.");

                tmpBcodeFix = 0xE51FF004;
                LOGI("Fix the first b_code 1.5");
                memcpy(fixOpcodes+fixPos+offset, &tmpBcodeFix, 4);
                LOGI("Fix the first b_code 2.");

                tmpBcodeFix = pstInlineHook->pHookAddr + 8;
                memcpy(fixOpcodes+fixPos+offset+4, &tmpBcodeFix, 4);
                LOGI("Fix the first b_code 3.");

                tmpBcodeFix = 0xE51FF004;
                memcpy(fixOpcodes+fixPos+offset+8, &tmpBcodeFix, 4);
                LOGI("Fix the first b_code 4.");

                tmpBcodeFix = tmpBcodeX;
                memcpy(fixOpcodes+fixPos+offset+12, &tmpBcodeFix, 4);
                LOGI("Fix the first b_code 5.");

                offset += 4*4;
            }
            else if (backUpPos == 0) { //save the first B code
                tmpBcodeFix = (*currentOpcode & 0xFE000000);
                tmpBcodeX = (*currentOpcode & 0xFFFFFF) << 2; // x*4
                LOGI("tmpBcodeX : %x", tmpBcodeX);
                tmpBcodeX = tmpBcodeX + 8 + pstInlineHook->pHookAddr;
            }
        }*/
        
        backUpPos += 4; //arm32的话下一次取后面4 byte偏移的指令
        pc += sizeof(uint32_t);

        fixPos += offset;
        //LOGI("fixPos : %d", fixPos);
        //LOGI("--------------END-----------------");

        if (backUpPos < pstInlineHook->backUpLength)
        {
			LOGI("ONE FINISH");
            currentOpcode = pstInlineHook->szbyBackupOpcodes + sizeof(uint8_t)*backUpPos;
        }
        else{
            LOGI("pstInlineHook->backUpLength : %d", pstInlineHook->backUpLength);
            LOGI("backUpPos : %d",backUpPos);
            LOGI("fixPos : %d", fixPos);
            LOGI("Fix finish !");
            return fixPos;
        }
    }

    LOGI("Something wrong in arm64 fixing...");

    return 0;
}

int fixBcond(uint64_t pc, uint64_t lr, uint32_t instruction, uint32_t *trampoline_instructions, INLINE_HOOK_INFO* pstInlineHook)
{
	
}

int fixPCOpcodeArm64(uint64_t pc, uint64_t lr, uint32_t instruction, uint32_t *trampoline_instructions, INLINE_HOOK_INFO* pstInlineHook)
{
    int type;
	//int offset;
    int trampoline_pos;
    uint32_t new_entry_addr = (uint32_t)pstInlineHook->pNewEntryForOldFunction;
    LOGI("new_entry_addr : %x",new_entry_addr);

    trampoline_pos = 0;
	//trampoline_instructions[trampoline_pos++] == 0xf85f83e0; // ldr x0, [sp, #-0x8] recover the x0 register
    LOGI("THE ARM64 OPCODE IS %x",instruction);
    type = getTypeInArm64(instruction);
    //type = getTypeInArm(instruction); //判断该arm指令的种类
	
	if (type == B_COND_ARM64) {
		//STP X_tmp1, X_tmp2, [SP, -0x10]
		//LDR X_tmp2, ?
		//[target instruction fix code] if you want
		//BR X_tmp2
		//B 8
		//PC+imm*4
        LOGI("B_COND_ARM64");
		uint32_t target_ins;
		uint32_t imm19;
		uint64_t value;

		imm19 = (instruction & 0xFFFFE0) >> 5;
		value = pc + imm19*4;
		if((imm19>>18)==1){
			value = pc - 4*(0x7ffff-imm19+1);
		}
		if(isTargetAddrInBackup(value, (uint64_t)pstInlineHook->pHookAddr, pstInlineHook->backUpLength)){
			//backup to backup
			//B.COND ???
			//B 28
			int target_idx = (int)((value - (uint64_t)pstInlineHook->pHookAddr)/4);
			int bc_ins_idx = (int)((pc - (uint64_t)pstInlineHook->pHookAddr)/4);
			int idx = 0;
			int gap = 0;
			for(idx=bc_ins_idx+1;idx<target_idx;idx++){
				gap += pstInlineHook->backUpFixLengthList[idx];
			}
			trampoline_instructions[trampoline_pos++] = (instruction & 0xff00000f) + ((gap+32)<<3); // B.XX 32+gap
			trampoline_instructions[trampoline_pos++] = 0x14000007; //B 28
		}
		else{
			//backup to outside
			target_ins = *((uint32_t *)value);
			trampoline_instructions[trampoline_pos++] = ((instruction & 0xff00000f) + (32<<3)) ^ 0x1; // B.anti_cond 32
			trampoline_instructions[trampoline_pos++] = target_ins; //target_ins (of cource the target ins maybe need to fix, do it by yourself if you need)
			trampoline_instructions[trampoline_pos++] = 0xa93f03e0; //STP X0, X0, [SP, -0x10] default
			trampoline_instructions[trampoline_pos++] = 0x58000080; //LDR X0, 12
			trampoline_instructions[trampoline_pos++] = 0xd61f0000; //BR X0
			trampoline_instructions[trampoline_pos++] = 0x14000002; //B 8
			trampoline_instructions[trampoline_pos++] = (uint32_t)(value >> 32);
			trampoline_instructions[trampoline_pos++] = (uint32_t)(value & 0xffffffff);
		}
		
        return 4*trampoline_pos;
    }
	if (type == ADR_ARM64) {
		//LDR Rn, 4
		//PC+imm*4
        LOGI("ADR_ARM64");
		uint32_t imm21;
		uint64_t value;
		uint32_t rd;
		imm21 = ((instruction & 0xFFFFE0)>>3) + ((instruction & 0x60000000)>>29);
		value = pc + 4*imm21;
		if((imm21 & 0x100000)==0x100000)
		{
			LOGI("NEG");
			value = pc - 4 * (0x1fffff - imm21 + 1);
		}
		LOGI("value : %x",value);
		
		rd = instruction & 0x1f;
		trampoline_instructions[trampoline_pos++] = 0x58000020+rd; // ldr rd, 4
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value >> 32);
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value & 0xffffffff);

        return 4*trampoline_pos;
    }
    if (type == ADRP_ARM64) {
		//LDR Rn, 8
		//B 12
		//PC+imm*4096
        LOGI("ADRP_ARM64");
		uint32_t imm21;
		uint64_t value;
		uint32_t rd;
		imm21 = ((instruction & 0xFFFFE0)>>3) + ((instruction & 0x60000000)>>29);
		value = (pc & 0xfffffffffffff000) + 4096*imm21;
		if((imm21 & 0x100000)==0x100000)
		{
			LOGI("NEG");
			value = (pc & 0xfff) - 4096 * (0x1fffff - imm21 + 1);
		}
		LOGI("pc    : %lx",pc);
		LOGI("imm21 : %x",imm21);
		LOGI("value : %lx",value);
		LOGI("valueh : %x",(uint32_t)(value >> 32));
		LOGI("valuel : %x",(uint32_t)(value & 0xffffffff));
		
		rd = instruction & 0x1f;
		trampoline_instructions[trampoline_pos++] = 0x58000040+rd; // ldr rd, 8
		trampoline_instructions[trampoline_pos++] = 0x14000003; // b 12
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value & 0xffffffff);
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value >> 32);
		

        return 4*trampoline_pos;
    }
    if (type == LDR_ARM64) {
		//STP Xt, Xn, [SP, #-0x10]
		//LDR Xn, 16
		//LDR Xt, [Xn, 0]
		//LDR Xn, [sp, #-0x8]
		//B 8
		//PC+imm*4
        LOGI("LDR_ARM64");
		uint32_t imm19;
		uint64_t value;
		uint32_t rt;
		uint32_t rn;
		rt = instruction & 0x1f;
		int i;
		for(i=0;i<31;i++)
		{
			if(i!=rt){
				rn = i;
				break;
			}
		}
		LOGI("Rn : %d",rn);
		imm19 = ((instruction & 0xFFFFE0)>>5);
		trampoline_instructions[trampoline_pos++] = 0xa93f03e0 + rt + (rn << 10); //STP Xt, Xn, [SP, #-0x10]
		trampoline_instructions[trampoline_pos++] = 0x58000080 + rn; //LDR Xn, 16
		trampoline_instructions[trampoline_pos++] = 0xf9400000 + (rn << 5); //LDR Xt, [Xn, 0]
		trampoline_instructions[trampoline_pos++] = 0xf85f83e0 + rn; //LDR Xn, [sp, #-0x8]
		trampoline_instructions[trampoline_pos++] = 0x14000002; //B 8

		value = pc + 4*imm19;
		if((imm19 & 0x40000)==0x40000){
			value = pc - 4*(0x7ffff-imm19+1);
		}
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value >> 32);
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value & 0xffffffff);

        return 4*trampoline_pos;
    }
	if (type == B_ARM64) {
		//STP X_tmp1, X_tmp2, [SP, -0x10]
		//LDR X_tmp2, ?
		//[target instruction fix code] if you want
		//BR X_tmp2
		//B 8
		//PC+imm*4
        LOGI("B_ARM64");
		uint32_t target_ins;
		uint32_t imm26;
		uint64_t value;

		imm26 = instruction & 0x3FFFFFF;
		value = pc + imm26*4;
		if((imm26>>25)==1){
			value = pc - 4*(0x3ffffff-imm26+1);
		}
		target_ins = *((uint32_t *)value);
		LOGI("target_ins : %x",target_ins);

		trampoline_instructions[trampoline_pos++] = 0xa93f03e0; //STP X0, X0, [SP, -0x10] default
		trampoline_instructions[trampoline_pos++] = 0x58000080; //LDR X0, 16
		trampoline_instructions[trampoline_pos++] = target_ins; //[target instruction fix code] if you want
		trampoline_instructions[trampoline_pos++] = 0xd61f0000; //BR X0
		trampoline_instructions[trampoline_pos++] = 0x14000002; //B 8
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value >> 32);
		trampoline_instructions[trampoline_pos++] = (uint32_t)(value & 0xffffffff);

        return 4*trampoline_pos;
    }
	else {
        LOGI("OTHER_ARM");
		trampoline_instructions[trampoline_pos++] = instruction;
        return 4*trampoline_pos;
	}
	//pc += sizeof(uint32_t);
	
	//trampoline_instructions[trampoline_pos++] = 0xe51ff004;	// LDR PC, [PC, #-4]
	//trampoline_instructions[trampoline_pos++] = lr;
    return 4*trampoline_pos;
}


```

`jni/InlineHook/fixPCOpcode.h`:

```h
#ifndef _FIXOPCODE_H
#define _FIXOPCODE_H

#include <stdio.h>
#include "Ihook.h"

#define ALIGN_PC(pc)	(pc & 0xFFFFFFFC)

bool isTargetAddrInBackup(uint64_t target_addr, uint64_t hook_addr, int backup_length);

int lengthFixArm64(uint32_t opcode);

static int getTypeInArm64(uint32_t instruction);
static int getTypeInArm32(uint32_t instruction);

int fixPCOpcodeArm(void *fixOpcodes , INLINE_HOOK_INFO* pstInlineHook);

int fixPCOpcodeArm64(uint64_t pc, uint64_t lr, uint32_t instruction, uint32_t *trampoline_instructions, INLINE_HOOK_INFO* pstInlineHook);


#endif
```

`jni/InlineHook/ihookstub.s`:

```s
.global _shellcode_start_s
.global _shellcode_end_s
.global _hookstub_function_addr_s
.global _old_function_addr_s

.data

_shellcode_start_s:

    sub     sp, sp, #0x20

    mrs     x0, NZCV
    str     x0, [sp, #0x10]
    str     x30, [sp]   
    add     x30, sp, #0x20
    str     x30, [sp, #0x8]    
    ldr     x0, [sp, #0x18]

    sub     sp, sp, #0xf0
    stp     X0, X1, [SP]
    stp     X2, X3, [SP,#0x10]
    stp     X4, X5, [SP,#0x20]
    stp     X6, X7, [SP,#0x30]
    stp     X8, X9, [SP,#0x40]
    stp     X10, X11, [SP,#0x50]
    stp     X12, X13, [SP,#0x60]
    stp     X14, X15, [SP,#0x70]
    stp     X16, X17, [SP,#0x80]
    stp     X18, X19, [SP,#0x90]
    stp     X20, X21, [SP,#0xa0]
    stp     X22, X23, [SP,#0xb0]
    stp     X24, X25, [SP,#0xc0]
    stp     X26, X27, [SP,#0xd0]
    stp     X28, X29, [SP,#0xe0]
          
    mov     x0, sp
    ldr     x3, 8
    b       12

_hookstub_function_addr_s:
.double 0xffffffffffffffff

    blr     x3
    ldr     x0, [sp, #0x100]
    msr     NZCV, x0

    ldp     X0, X1, [SP]
    ldp     X2, X3, [SP,#0x10]
    ldp     X4, X5, [SP,#0x20]
    ldp     X6, X7, [SP,#0x30]
    ldp     X8, X9, [SP,#0x40]
    ldp     X10, X11, [SP,#0x50]
    ldp     X12, X13, [SP,#0x60]
    ldp     X14, X15, [SP,#0x70]
    ldp     X16, X17, [SP,#0x80]
    ldp     X18, X19, [SP,#0x90]
    ldp     X20, X21, [SP,#0xa0]
    ldp     X22, X23, [SP,#0xb0]
    ldp     X24, X25, [SP,#0xc0]
    ldp     X26, X27, [SP,#0xd0]
    ldp     X28, X29, [SP,#0xe0]
    add     sp, sp, #0xf0
     
    ldr     x30, [sp]
    add     sp, sp, #0x20

    stp     X1, X0, [SP, #-0x10]
    ldr     x0, 8
    b       12

_old_function_addr_s:
.double 0xffffffffffffffff

    br      x0


    


_shellcode_end_s:

.end

```

`jni/Interface/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)  


include $(CLEAR_VARS)

LOCAL_CXXFLAGS +=  -g -O0
LOCAL_ARM_MODE := arm
LOCAL_MODULE    := InlineHook
LOCAL_STATIC_LIBRARIES:= IHook
LOCAL_C_INCLUDES := $(LOCAL_PATH)/../InlineHook
LOCAL_SRC_FILES := InlineHook.cpp
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog

include $(BUILD_SHARED_LIBRARY)
```

`jni/Interface/InlineHook.cpp`:

```cpp
#include <vector>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define PAGE_START(addr)	(~(PAGE_SIZE - 1) & (addr))
#define SET_BIT0(addr)		(addr | 1)
#define CLEAR_BIT0(addr)	(addr & 0xFFFFFFFE)
#define TEST_BIT0(addr)		(addr & 1)

#define ACTION_ENABLE	0
#define ACTION_DISABLE	1

extern "C"
{
    #include "Ihook.h"
}

void ModifyIBored() __attribute__((constructor));
void before_main() __attribute__((constructor));

typedef std::vector<INLINE_HOOK_INFO*> InlineHookInfoPVec;
static InlineHookInfoPVec gs_vecInlineHookInfo;     //管理HOOK点

void before_main() {
    LOGI("Hook is auto loaded!\n");
}

/**
 * 对外inline hook接口，负责管理inline hook信息
 * @param  pHookAddr     要hook的地址
 * @param  onCallBack    要插入的回调函数
 * @return               inlinehook是否设置成功（已经设置过，重复设置返回false）
 */
bool InlineHook(void *pHookAddr, void (*onCallBack)(struct user_pt_regs *))
{
    bool bRet = false;
    LOGI("InlineHook");

    if(pHookAddr == NULL || onCallBack == NULL)
    {
        return bRet;
    }

    INLINE_HOOK_INFO* pstInlineHook = new INLINE_HOOK_INFO();
    pstInlineHook->pHookAddr = pHookAddr;
    pstInlineHook->onCallBack = onCallBack;

    if(HookArm(pstInlineHook) == false)
    {
        LOGI("HookArm fail.");
        delete pstInlineHook;
        return bRet;
    }

    
    gs_vecInlineHookInfo.push_back(pstInlineHook);
    return true;
}

/**
 * 对外接口，用于取消inline hook
 * @param  pHookAddr 要取消inline hook的位置
 * @return           是否取消成功（不存在返回取消失败）
 */
bool UnInlineHook(void *pHookAddr)
{
    bool bRet = false;

    if(pHookAddr == NULL)
    {
        return bRet;
    }

    InlineHookInfoPVec::iterator itr = gs_vecInlineHookInfo.begin();
    InlineHookInfoPVec::iterator itrend = gs_vecInlineHookInfo.end();

    for (; itr != itrend; ++itr)
    {
        if (pHookAddr == (*itr)->pHookAddr)
        {
            INLINE_HOOK_INFO* pTargetInlineHookInfo = (*itr);

            gs_vecInlineHookInfo.erase(itr);
            if(pTargetInlineHookInfo->pStubShellCodeAddr != NULL)
            {
                delete pTargetInlineHookInfo->pStubShellCodeAddr;
            }
            if(pTargetInlineHookInfo->ppOldFuncAddr)
            {
                delete *(pTargetInlineHookInfo->ppOldFuncAddr);
            }
            delete pTargetInlineHookInfo;
            bRet = true;
        }
    }

    return bRet;
}

/**
 * 用户自定义的stub函数，嵌入在hook点中，可直接操作寄存器等改变游戏逻辑操作
 * 这里将R0寄存器锁定为0x333，一个远大于30的值
 * @param regs 寄存器结构，保存寄存器当前hook点的寄存器信息
 */
void EvilHookStubFunctionForIBored(user_pt_regs *regs) //参数regs就是指向栈上的一个数据结构，由第二部分的mov r0, sp所传递。
{
    LOGI("In Evil Hook Stub.");
    //regs->uregs[2] = 0x333; //regs->uregs[0]=0x333
    regs->regs[9]=0x333;
}

/**
 * 针对IBored应用，通过inline hook改变游戏逻辑的测试函数
 */
void ModifyIBored()
{
    LOGI("In IHook's ModifyIBored.");

    int target_offset = 0x600; //*想Hook的目标在目标so中的偏移*

    void* pModuleBaseAddr = GetModuleBaseAddr(-1, "libhellojni.so"); //目标so的名称

    if(pModuleBaseAddr == 0)
    {
        LOGI("get module base error.");
        return;
    }
    
    uint64_t uiHookAddr = (uint64_t)pModuleBaseAddr + target_offset; //真实Hook的内存地址

    
    InlineHook((void*)(uiHookAddr), EvilHookStubFunctionForIBored); //*第二个参数就是Hook想要插入的功能处理函数*
}
```

`obj/local/arm64-v8a/objs/IHook/IHook.o.d`:

```d
./obj/local/arm64-v8a/objs/IHook/IHook.o: jni/InlineHook/IHook.c \
  jni/InlineHook/Ihook.h jni/InlineHook/fixPCOpcode.h

jni/InlineHook/Ihook.h:

jni/InlineHook/fixPCOpcode.h:

```

`obj/local/arm64-v8a/objs/IHook/fixPCOpcode.o.d`:

```d
./obj/local/arm64-v8a/objs/IHook/fixPCOpcode.o: \
  jni/InlineHook/fixPCOpcode.c jni/InlineHook/fixPCOpcode.h \
  jni/InlineHook/Ihook.h

jni/InlineHook/fixPCOpcode.h:

jni/InlineHook/Ihook.h:

```

`obj/local/arm64-v8a/objs/InlineHook/InlineHook.o.d`:

```d
./obj/local/arm64-v8a/objs/InlineHook/InlineHook.o: \
  jni/Interface/InlineHook.cpp \
  C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector \
  jni/Interface/../InlineHook\Ihook.h

C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector:

jni/Interface/../InlineHook\Ihook.h:

```

`obj/local/armeabi-v7a/objs/IHook/IHook.o.d`:

```d
./obj/local/armeabi-v7a/objs/IHook/IHook.o: jni/InlineHook/IHook.c \
  jni/InlineHook/Ihook.h jni/InlineHook/fixPCOpcode.h

jni/InlineHook/Ihook.h:

jni/InlineHook/fixPCOpcode.h:

```

`obj/local/armeabi-v7a/objs/IHook/fixPCOpcode.o.d`:

```d
./obj/local/armeabi-v7a/objs/IHook/fixPCOpcode.o: \
  jni/InlineHook/fixPCOpcode.c jni/InlineHook/fixPCOpcode.h \
  jni/InlineHook/Ihook.h

jni/InlineHook/fixPCOpcode.h:

jni/InlineHook/Ihook.h:

```

`obj/local/armeabi-v7a/objs/InlineArmHook/InlineHook.o.d`:

```d
./obj/local/armeabi-v7a/objs/InlineArmHook/InlineHook.o: \
  jni/Interface/InlineHook.cpp \
  C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector \
  jni/Interface/../InlineHook\Ihook.h

C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector:

jni/Interface/../InlineHook\Ihook.h:

```

`obj/local/armeabi-v7a/objs/InlineHook/InlineHook.o.d`:

```d
./obj/local/armeabi-v7a/objs/InlineHook/InlineHook.o: \
  jni/Interface/InlineHook.cpp \
  C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector \
  jni/Interface/../InlineHook\Ihook.h

C:/Users/GToad/AppData/Local/Android/Sdk/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include\vector:

jni/Interface/../InlineHook\Ihook.h:

```