Project Path: arc_gmh5225_VMPUnpacker_bzs9ng03

Source Tree:

```txt
arc_gmh5225_VMPUnpacker_bzs9ng03
├── README.md
├── cpp
│   ├── lzma
│   │   ├── 7zTypes.h
│   │   ├── LzmaDecode.cpp
│   │   └── LzmaDecode.h
│   └── vmpunpacker.cpp
└── python
    └── vmpunpacker.py

```

`README.md`:

```md
# VMPUnpacker

* Static unpacker for VMProtect.
* No import fix.

```

`cpp/lzma/7zTypes.h`:

```h
/* 7zTypes.h -- Basic types
2013-11-12 : Igor Pavlov : Public domain */

#ifndef __7Z_TYPES_H
#define __7Z_TYPES_H

#ifdef _WIN32
/* #include <windows.h> */
#endif

#include <stddef.h>

#ifndef EXTERN_C_BEGIN
#ifdef __cplusplus
#define EXTERN_C_BEGIN extern "C" {
#define EXTERN_C_END }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif
#endif

EXTERN_C_BEGIN

#define SZ_OK 0

#define SZ_ERROR_DATA 1
#define SZ_ERROR_MEM 2
#define SZ_ERROR_CRC 3
#define SZ_ERROR_UNSUPPORTED 4
#define SZ_ERROR_PARAM 5
#define SZ_ERROR_INPUT_EOF 6
#define SZ_ERROR_OUTPUT_EOF 7
#define SZ_ERROR_READ 8
#define SZ_ERROR_WRITE 9
#define SZ_ERROR_PROGRESS 10
#define SZ_ERROR_FAIL 11
#define SZ_ERROR_THREAD 12

#define SZ_ERROR_ARCHIVE 16
#define SZ_ERROR_NO_ARCHIVE 17

typedef int SRes;

#ifdef _WIN32
/* typedef DWORD WRes; */
typedef unsigned WRes;
#else
typedef int WRes;
#endif

#ifndef RINOK
#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
#endif

typedef unsigned char Byte;
typedef short Int16;
typedef unsigned short UInt16;

#ifdef _LZMA_UINT32_IS_ULONG
typedef long Int32;
typedef unsigned long UInt32;
#else
typedef int Int32;
#ifndef __MACTYPES__
typedef unsigned int UInt32;
#endif
#endif

#ifdef _SZ_NO_INT_64

/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! */

typedef long Int64;
typedef unsigned long UInt64;

#else

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int64 Int64;
typedef unsigned __int64 UInt64;
#define UINT64_CONST(n) n
#else
typedef long long int Int64;
typedef unsigned long long int UInt64;
#define UINT64_CONST(n) n ## ULL
#endif

#endif

#ifdef _LZMA_NO_SYSTEM_SIZE_T
typedef UInt32 SizeT;
#else
typedef size_t SizeT;
#endif

typedef int Bool;
#define True 1
#define False 0


#ifdef _WIN32
#define MY_STD_CALL __stdcall
#else
#define MY_STD_CALL
#endif

#ifdef _MSC_VER

#if _MSC_VER >= 1300
#define MY_NO_INLINE __declspec(noinline)
#else
#define MY_NO_INLINE
#endif

#define MY_CDECL __cdecl
#define MY_FAST_CALL __fastcall

#else

#define MY_NO_INLINE
#define MY_CDECL
#define MY_FAST_CALL

#endif


/* The following interfaces use first parameter as pointer to structure */

typedef struct
{
  Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
} IByteIn;

typedef struct
{
  void (*Write)(void *p, Byte b);
} IByteOut;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed */
} ISeqInStream;

/* it can return SZ_ERROR_INPUT_EOF */
SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);

typedef struct
{
  size_t (*Write)(void *p, const void *buf, size_t size);
    /* Returns: result - the number of actually written bytes.
       (result < size) means error */
} ISeqOutStream;

typedef enum
{
  SZ_SEEK_SET = 0,
  SZ_SEEK_CUR = 1,
  SZ_SEEK_END = 2
} ESzSeek;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ISeekInStream;

typedef struct
{
  SRes (*Look)(void *p, const void **buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed */
  SRes (*Skip)(void *p, size_t offset);
    /* offset must be <= output(*size) of Look */

  SRes (*Read)(void *p, void *buf, size_t *size);
    /* reads directly (without buffer). It's same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ILookInStream;

SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);

/* reads via ILookInStream::Read */
SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);

#define LookToRead_BUF_SIZE (1 << 14)

typedef struct
{
  ILookInStream s;
  ISeekInStream *realStream;
  size_t pos;
  size_t size;
  Byte buf[LookToRead_BUF_SIZE];
} CLookToRead;

void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
void LookToRead_Init(CLookToRead *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToLook;

void SecToLook_CreateVTable(CSecToLook *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToRead;

void SecToRead_CreateVTable(CSecToRead *p);

typedef struct
{
  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
    /* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. */
} ICompressProgress;

typedef struct
{
  void *(*Alloc)(void *p, size_t size);
  void (*Free)(void *p, void *address); /* address can be 0 */
} ISzAlloc;

#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
#define IAlloc_Free(p, a) (p)->Free((p), a)

#ifdef _WIN32

#define CHAR_PATH_SEPARATOR '\\'
#define WCHAR_PATH_SEPARATOR L'\\'
#define STRING_PATH_SEPARATOR "\\"
#define WSTRING_PATH_SEPARATOR L"\\"

#else

#define CHAR_PATH_SEPARATOR '/'
#define WCHAR_PATH_SEPARATOR L'/'
#define STRING_PATH_SEPARATOR "/"
#define WSTRING_PATH_SEPARATOR L"/"

#endif

EXTERN_C_END

#endif

```

`cpp/lzma/LzmaDecode.cpp`:

```cpp
/*
  LzmaDecode.c
  LZMA Decoder (optimized for Speed version)

  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
  http://www.7-zip.org/

  LZMA SDK is licensed under two licenses:
  1) GNU Lesser General Public License (GNU LGPL)
  2) Common Public License (CPL)
  It means that you can select one of these two licenses and
  follow rules of that license.

  SPECIAL EXCEPTION:
  Igor Pavlov, as the author of this Code, expressly permits you to
  statically or dynamically link your Code (or bind by name) to the
  interfaces of this file without subjecting your linked Code to the
  terms of the CPL or GNU LGPL. Any modifications or additions
  to this file, however, are subject to the LGPL or CPL terms.
*/

#include "LzmaDecode.h"

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_READ_BYTE (*Buffer++)

#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}

#ifdef _LZMA_IN_CB

#define RC_TEST { if (Buffer == BufferLim) \
  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}

#define RC_INIT Buffer = BufferLim = 0; RC_INIT2

#else

#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }

#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2

#endif

#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }

#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;

#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
  { UpdateBit0(p); mi <<= 1; A0; } else \
  { UpdateBit1(p); mi = (mi + mi) + 1; A1; }

#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)

#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
  { int i = numLevels; res = 1; \
  do { CProb *pp = probs + res; RC_GET_BIT(pp, res) } while(--i != 0); \
  res -= (1 << numLevels); }


#define kNumPosBitsMax 4
#define kNumPosStatesMax (1 << kNumPosBitsMax)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define LenChoice 0
#define LenChoice2 (LenChoice + 1)
#define LenLow (LenChoice2 + 1)
#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
#define kNumLenProbs (LenHigh + kLenNumHighSymbols)


#define kNumStates 12
#define kNumLitStates 7

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#define kNumPosSlotBits 6
#define kNumLenToPosStates 4

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)

#define kMatchMinLen 2

#define IsMatch 0
#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
#define IsRepG0 (IsRep + kNumStates)
#define IsRepG1 (IsRepG0 + kNumStates)
#define IsRepG2 (IsRepG1 + kNumStates)
#define IsRep0Long (IsRepG2 + kNumStates)
#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
#define LenCoder (Align + kAlignTableSize)
#define RepLenCoder (LenCoder + kNumLenProbs)
#define Literal (RepLenCoder + kNumLenProbs)

#if Literal != LZMA_BASE_SIZE
StopCompilingDueBUG
#endif

int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
{
  unsigned char prop0;
  if (size < LZMA_PROPERTIES_SIZE)
    return LZMA_RESULT_DATA_ERROR;
  prop0 = propsData[0];
  if (prop0 >= (9 * 5 * 5))
    return LZMA_RESULT_DATA_ERROR;
  {
    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5)) { }
    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9) { }
    propsRes->lc = prop0;
    /*
    unsigned char remainder = (unsigned char)(prop0 / 9);
    propsRes->lc = prop0 % 9;
    propsRes->pb = remainder / 5;
    propsRes->lp = remainder % 5;
    */
  }

  #ifdef _LZMA_OUT_READ
  {
    int i;
    propsRes->DictionarySize = 0;
    for (i = 0; i < 4; i++)
      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
    if (propsRes->DictionarySize == 0)
      propsRes->DictionarySize = 1;
  }
  #endif
  return LZMA_RESULT_OK;
}

#define kLzmaStreamWasFinishedId (-1)

int LzmaDecode(CLzmaDecoderState *vs,
    #ifdef _LZMA_IN_CB
    ILzmaInCallback *InCallback,
    #else
    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
    #endif
    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
{
  CProb *p = vs->Probs;
  SizeT nowPos = 0;
  Byte previousByte = 0;
  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
  int lc = vs->Properties.lc;

  #ifdef _LZMA_OUT_READ

  UInt32 Range = vs->Range;
  UInt32 Code = vs->Code;
  #ifdef _LZMA_IN_CB
  const Byte *Buffer = vs->Buffer;
  const Byte *BufferLim = vs->BufferLim;
  #else
  const Byte *Buffer = inStream;
  const Byte *BufferLim = inStream + inSize;
  #endif
  int state = vs->State;
  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
  int len = vs->RemainLen;
  UInt32 globalPos = vs->GlobalPos;
  UInt32 distanceLimit = vs->DistanceLimit;

  Byte *dictionary = vs->Dictionary;
  UInt32 dictionarySize = vs->Properties.DictionarySize;
  UInt32 dictionaryPos = vs->DictionaryPos;

  Byte tempDictionary[4];

  #ifndef _LZMA_IN_CB
  *inSizeProcessed = 0;
  #endif
  *outSizeProcessed = 0;
  if (len == kLzmaStreamWasFinishedId)
    return LZMA_RESULT_OK;

  if (dictionarySize == 0)
  {
    dictionary = tempDictionary;
    dictionarySize = 1;
    tempDictionary[0] = vs->TempDictionary[0];
  }

  if (len == kLzmaNeedInitId)
  {
    {
      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
      UInt32 i;
      for (i = 0; i < numProbs; i++)
        p[i] = kBitModelTotal >> 1;
      rep0 = rep1 = rep2 = rep3 = 1;
      state = 0;
      globalPos = 0;
      distanceLimit = 0;
      dictionaryPos = 0;
      dictionary[dictionarySize - 1] = 0;
      #ifdef _LZMA_IN_CB
      RC_INIT;
      #else
      RC_INIT(inStream, inSize);
      #endif
    }
    len = 0;
  }
  while(len != 0 && nowPos < outSize)
  {
    UInt32 pos = dictionaryPos - rep0;
    if (pos >= dictionarySize)
      pos += dictionarySize;
    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
    if (++dictionaryPos == dictionarySize)
      dictionaryPos = 0;
    len--;
  }
  if (dictionaryPos == 0)
    previousByte = dictionary[dictionarySize - 1];
  else
    previousByte = dictionary[dictionaryPos - 1];

  #else /* if !_LZMA_OUT_READ */

  int state = 0;
  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
  int len = 0;
  const Byte *Buffer;
  const Byte *BufferLim;
  UInt32 Range;
  UInt32 Code;

  #ifndef _LZMA_IN_CB
  *inSizeProcessed = 0;
  #endif
  *outSizeProcessed = 0;

  {
    UInt32 i;
    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
    for (i = 0; i < numProbs; i++)
      p[i] = kBitModelTotal >> 1;
  }

  #ifdef _LZMA_IN_CB
  RC_INIT;
  #else
  RC_INIT(inStream, inSize);
  #endif

  #endif /* _LZMA_OUT_READ */

  while(nowPos < outSize)
  {
    CProb *prob;
    UInt32 bound;
    int posState = (int)(
        (nowPos
        #ifdef _LZMA_OUT_READ
        + globalPos
        #endif
        )
        & posStateMask);

    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
    IfBit0(prob)
    {
      int symbol = 1;
      UpdateBit0(prob)
      prob = p + Literal + (LZMA_LIT_SIZE *
        (((
        (nowPos
        #ifdef _LZMA_OUT_READ
        + globalPos
        #endif
        )
        & literalPosMask) << lc) + (previousByte >> (8 - lc))));

      if (state >= kNumLitStates)
      {
        int matchByte;
        #ifdef _LZMA_OUT_READ
        UInt32 pos = dictionaryPos - rep0;
        if (pos >= dictionarySize)
          pos += dictionarySize;
        matchByte = dictionary[pos];
        #else
        matchByte = outStream[nowPos - rep0];
        #endif
        do
        {
          int bit;
          CProb *probLit;
          matchByte <<= 1;
          bit = (matchByte & 0x100);
          probLit = prob + 0x100 + bit + symbol;
          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
        }
        while (symbol < 0x100);
      }
      while (symbol < 0x100)
      {
        CProb *probLit = prob + symbol;
        RC_GET_BIT(probLit, symbol)
      }
      previousByte = (Byte)symbol;

      outStream[nowPos++] = previousByte;
      #ifdef _LZMA_OUT_READ
      if (distanceLimit < dictionarySize)
        distanceLimit++;

      dictionary[dictionaryPos] = previousByte;
      if (++dictionaryPos == dictionarySize)
        dictionaryPos = 0;
      #endif
      if (state < 4) state = 0;
      else if (state < 10) state -= 3;
      else state -= 6;
    }
    else
    {
      UpdateBit1(prob);
      prob = p + IsRep + state;
      IfBit0(prob)
      {
        UpdateBit0(prob);
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;
        state = state < kNumLitStates ? 0 : 3;
        prob = p + LenCoder;
      }
      else
      {
        UpdateBit1(prob);
        prob = p + IsRepG0 + state;
        IfBit0(prob)
        {
          UpdateBit0(prob);
          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
          IfBit0(prob)
          {
            #ifdef _LZMA_OUT_READ
            UInt32 pos;
            #endif
            UpdateBit0(prob);

            #ifdef _LZMA_OUT_READ
            if (distanceLimit == 0)
            #else
            if (nowPos == 0)
            #endif
              return LZMA_RESULT_DATA_ERROR;

            state = state < kNumLitStates ? 9 : 11;
            #ifdef _LZMA_OUT_READ
            pos = dictionaryPos - rep0;
            if (pos >= dictionarySize)
              pos += dictionarySize;
            previousByte = dictionary[pos];
            dictionary[dictionaryPos] = previousByte;
            if (++dictionaryPos == dictionarySize)
              dictionaryPos = 0;
            #else
            previousByte = outStream[nowPos - rep0];
            #endif
            outStream[nowPos++] = previousByte;
            #ifdef _LZMA_OUT_READ
            if (distanceLimit < dictionarySize)
              distanceLimit++;
            #endif

            continue;
          }
          else
          {
            UpdateBit1(prob);
          }
        }
        else
        {
          UInt32 distance;
          UpdateBit1(prob);
          prob = p + IsRepG1 + state;
          IfBit0(prob)
          {
            UpdateBit0(prob);
            distance = rep1;
          }
          else
          {
            UpdateBit1(prob);
            prob = p + IsRepG2 + state;
            IfBit0(prob)
            {
              UpdateBit0(prob);
              distance = rep2;
            }
            else
            {
              UpdateBit1(prob);
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        state = state < kNumLitStates ? 8 : 11;
        prob = p + RepLenCoder;
      }
      {
        int numBits, offset;
        CProb *probLen = prob + LenChoice;
        IfBit0(probLen)
        {
          UpdateBit0(probLen);
          probLen = prob + LenLow + (posState << kLenNumLowBits);
          offset = 0;
          numBits = kLenNumLowBits;
        }
        else
        {
          UpdateBit1(probLen);
          probLen = prob + LenChoice2;
          IfBit0(probLen)
          {
            UpdateBit0(probLen);
            probLen = prob + LenMid + (posState << kLenNumMidBits);
            offset = kLenNumLowSymbols;
            numBits = kLenNumMidBits;
          }
          else
          {
            UpdateBit1(probLen);
            probLen = prob + LenHigh;
            offset = kLenNumLowSymbols + kLenNumMidSymbols;
            numBits = kLenNumHighBits;
          }
        }
        RangeDecoderBitTreeDecode(probLen, numBits, len);
        len += offset;
      }

      if (state < 4)
      {
        int posSlot;
        state += kNumLitStates;
        prob = p + PosSlot +
            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
            kNumPosSlotBits);
        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
        if (posSlot >= kStartPosModelIndex)
        {
          int numDirectBits = ((posSlot >> 1) - 1);
          rep0 = (2 | ((UInt32)posSlot & 1));
          if (posSlot < kEndPosModelIndex)
          {
            rep0 <<= numDirectBits;
            prob = p + SpecPos + rep0 - posSlot - 1;
          }
          else
          {
            numDirectBits -= kNumAlignBits;
            do
            {
              RC_NORMALIZE
              Range >>= 1;
              rep0 <<= 1;
              if (Code >= Range)
              {
                Code -= Range;
                rep0 |= 1;
              }
            }
            while (--numDirectBits != 0);
            prob = p + Align;
            rep0 <<= kNumAlignBits;
            numDirectBits = kNumAlignBits;
          }
          {
            int i = 1;
            int mi = 1;
            do
            {
              CProb *prob3 = prob + mi;
              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
              i <<= 1;
            }
            while(--numDirectBits != 0);
          }
        }
        else
          rep0 = posSlot;
        if (++rep0 == (UInt32)(0))
        {
#if defined(_LZMA_OUT_READ) || (defined(UPX_LZMA_COMPAT) && (UPX_LZMA_COMPAT+0))
          /* it's for stream version */
          len = kLzmaStreamWasFinishedId;
#endif
          break;
        }
      }

      len += kMatchMinLen;
      #ifdef _LZMA_OUT_READ
      if (rep0 > distanceLimit)
      #else
      if (rep0 > nowPos)
      #endif
        return LZMA_RESULT_DATA_ERROR;

      #ifdef _LZMA_OUT_READ
      if (dictionarySize - distanceLimit > (UInt32)len)
        distanceLimit += len;
      else
        distanceLimit = dictionarySize;
      #endif

      do
      {
        #ifdef _LZMA_OUT_READ
        UInt32 pos = dictionaryPos - rep0;
        if (pos >= dictionarySize)
          pos += dictionarySize;
        previousByte = dictionary[pos];
        dictionary[dictionaryPos] = previousByte;
        if (++dictionaryPos == dictionarySize)
          dictionaryPos = 0;
        #else
        previousByte = outStream[nowPos - rep0];
        #endif
        len--;
        outStream[nowPos++] = previousByte;
      }
      while(len != 0 && nowPos < outSize);
    }
  }
  RC_NORMALIZE;

  #ifdef _LZMA_OUT_READ
  vs->Range = Range;
  vs->Code = Code;
  vs->DictionaryPos = dictionaryPos;
  vs->GlobalPos = globalPos + (UInt32)nowPos;
  vs->DistanceLimit = distanceLimit;
  vs->Reps[0] = rep0;
  vs->Reps[1] = rep1;
  vs->Reps[2] = rep2;
  vs->Reps[3] = rep3;
  vs->State = state;
  vs->RemainLen = len;
  vs->TempDictionary[0] = tempDictionary[0];
  #endif

  #ifdef _LZMA_IN_CB
  vs->Buffer = Buffer;
  vs->BufferLim = BufferLim;
  #else
  *inSizeProcessed = (SizeT)(Buffer - inStream);
  #endif
  *outSizeProcessed = nowPos;
  return LZMA_RESULT_OK;
}

```

`cpp/lzma/LzmaDecode.h`:

```h
/*
  LzmaDecode.h
  LZMA Decoder interface

  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
  http://www.7-zip.org/

  LZMA SDK is licensed under two licenses:
  1) GNU Lesser General Public License (GNU LGPL)
  2) Common Public License (CPL)
  It means that you can select one of these two licenses and
  follow rules of that license.

  SPECIAL EXCEPTION:
  Igor Pavlov, as the author of this code, expressly permits you to
  statically or dynamically link your code (or bind by name) to the
  interfaces of this file without subjecting your linked code to the
  terms of the CPL or GNU LGPL. Any modifications or additions
  to this file, however, are subject to the LGPL or CPL terms.
*/

#ifndef __LZMADECODE_H
#define __LZMADECODE_H

#include "7zTypes.h"

/* #define _LZMA_IN_CB */
/* Use callback for input data */

/* #define _LZMA_OUT_READ */
/* Use read function for output data */

/* #define _LZMA_PROB32 */
/* It can increase speed on some 32-bit CPUs,
   but memory usage will be doubled in that case */

/* #define _LZMA_LOC_OPT */
/* Enable local speed optimizations inside code */

#ifdef _LZMA_PROB32
#define CProb UInt32
#else
#define CProb UInt16
#endif

#define LZMA_RESULT_OK 0
#define LZMA_RESULT_DATA_ERROR 1

#ifdef _LZMA_IN_CB
typedef struct _ILzmaInCallback
{
  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
} ILzmaInCallback;
#endif

#define LZMA_BASE_SIZE 1846
#define LZMA_LIT_SIZE 768

#define LZMA_PROPERTIES_SIZE 5

typedef struct _CLzmaProperties
{
  int lc;
  int lp;
  int pb;
  #ifdef _LZMA_OUT_READ
  UInt32 DictionarySize;
  #endif
}CLzmaProperties;

int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);

#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))

#define kLzmaNeedInitId (-2)

typedef struct _CLzmaDecoderState
{
  CLzmaProperties Properties;
  CProb *Probs;

  #ifdef _LZMA_IN_CB
  const unsigned char *Buffer;
  const unsigned char *BufferLim;
  #endif

  #ifdef _LZMA_OUT_READ
  unsigned char *Dictionary;
  UInt32 Range;
  UInt32 Code;
  UInt32 DictionaryPos;
  UInt32 GlobalPos;
  UInt32 DistanceLimit;
  UInt32 Reps[4];
  int State;
  int RemainLen;
  unsigned char TempDictionary[4];
  #endif
} CLzmaDecoderState;

#ifdef _LZMA_OUT_READ
#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
#endif

int LzmaDecode(CLzmaDecoderState *vs,
    #ifdef _LZMA_IN_CB
    ILzmaInCallback *inCallback,
    #else
    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
    #endif
    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);

#endif

```

`cpp/vmpunpacker.cpp`:

```cpp
// Build: g++ -o vmpunpacker.exe vmpunpacker.cpp lzma/LzmaDecode.cpp -I./lzma -std=c++17

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <vector>
#include <cstdint>
#include <stdexcept>
#include <algorithm> // For std::copy, std::fill
#include <cstring>   // For memcpy, memset, strnlen
#include <iostream>
#include <fstream>
#include <limits>
#include <string>
#include <sstream>   // For ostringstream in error messages
#include <memory>    // For std::unique_ptr

#include "LzmaDecode.h" // Assuming this provides CLzmaDecoderState, LzmaDecodeProperties, LzmaGetNumProbs, LzmaDecode, CProb, LZMA_PROPERTIES_SIZE, LZMA_RESULT_OK

// Define PACKER_INFO structure
struct PACKER_INFO {
    uint32_t Src;
    uint32_t Dst;
};

// Helper to convert values to hex string for error messages
template <typename T>
static std::string ToHexString(T val, bool prefix = true) {
    std::ostringstream oss;
    if (prefix) oss << "0x";
    oss << std::hex << val;
    return oss.str();
}

static DWORD RVAtoRawOffset(DWORD rva, const IMAGE_NT_HEADERS* nt_headers, const BYTE* file_buffer_start, size_t file_buffer_size, const char* context_info = "") {
    const IMAGE_SECTION_HEADER* section_header_array = IMAGE_FIRST_SECTION(nt_headers);
    WORD num_sections = nt_headers->FileHeader.NumberOfSections;

    if (rva < nt_headers->OptionalHeader.SizeOfHeaders) {
        if (rva >= file_buffer_size) {
            std::ostringstream err_oss;
            err_oss << "RVAtoRawOffset Error (" << context_info << "): Header RVA " << ToHexString(rva) 
                    << " is out of file buffer bounds (" << ToHexString(file_buffer_size) << ").";
            throw std::runtime_error(err_oss.str());
        }
        return rva;
    }

    for (WORD i = 0; i < num_sections; ++i) {
        const IMAGE_SECTION_HEADER& current_section = section_header_array[i];
        if (rva >= current_section.VirtualAddress &&
            rva < current_section.VirtualAddress + current_section.Misc.VirtualSize) {
            
            if (current_section.PointerToRawData != 0) {
                DWORD offset_in_section_virtual = rva - current_section.VirtualAddress;
                if (offset_in_section_virtual < current_section.SizeOfRawData) {
                    DWORD raw_offset = current_section.PointerToRawData + offset_in_section_virtual;
                    if (raw_offset >= file_buffer_size) {
                         std::ostringstream err_oss;
                         err_oss << "RVAtoRawOffset Error (" << context_info << "): Calculated raw offset " << ToHexString(raw_offset)
                                 << " for RVA " << ToHexString(rva) << " in section '" 
                                 << std::string(reinterpret_cast<const char*>(current_section.Name), strnlen(reinterpret_cast<const char*>(current_section.Name), 8))
                                 << "' is out of file buffer bounds (" << ToHexString(file_buffer_size) << ").";
                         throw std::runtime_error(err_oss.str());
                    }
                    return raw_offset;
                } else {
                    std::ostringstream err_oss;
                    err_oss << "RVAtoRawOffset Error (" << context_info << "): RVA " << ToHexString(rva) 
                            << " is in virtual-only part of section '" 
                            << std::string(reinterpret_cast<const char*>(current_section.Name), strnlen(reinterpret_cast<const char*>(current_section.Name), 8)) << "'.";
                    throw std::runtime_error(err_oss.str());
                }
            } else {
                std::ostringstream err_oss;
                err_oss << "RVAtoRawOffset Error (" << context_info << "): RVA " << ToHexString(rva) 
                        << " is in section '" 
                        << std::string(reinterpret_cast<const char*>(current_section.Name), strnlen(reinterpret_cast<const char*>(current_section.Name), 8))
                        << "' which has no raw data (PointerToRawData is 0).";
                throw std::runtime_error(err_oss.str());
            }
        }
    }

    std::ostringstream err_oss;
    err_oss << "RVAtoRawOffset Error (" << context_info << "): RVA " << ToHexString(rva) << " not found in PE headers or any section.";
    throw std::runtime_error(err_oss.str());
}

static const BYTE* FindPattern(const BYTE* data, size_t data_len, const BYTE* pattern, size_t pattern_len) {
    if (pattern_len == 0 || data_len < pattern_len) return nullptr;
    for (size_t i = 0; i <= data_len - pattern_len; ++i) {
        bool match = true;
        for (size_t j = 0; j < pattern_len; ++j) {
            if (pattern[j] != 0xFF && data[i + j] != pattern[j]) { // 0xFF as wildcard
                match = false;
                break;
            }
        }
        if (match) {
            return data + i;
        }
    }
    return nullptr;
}

std::vector<BYTE> UnpackPE(const BYTE* packed_pe_data_const, size_t packed_pe_size) {
    if (!packed_pe_data_const || packed_pe_size == 0) {
        throw std::runtime_error("Packed PE data is null or empty.");
    }

    // Create a mutable copy to work with for headers
    std::vector<BYTE> packed_pe_buffer(packed_pe_data_const, packed_pe_data_const + packed_pe_size);
    BYTE* packed_data = packed_pe_buffer.data(); // Non-const pointer to the buffer data

    IMAGE_DOS_HEADER* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(packed_data);
    if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
        throw std::runtime_error("Invalid DOS signature");
    }
    if (static_cast<size_t>(dos_header->e_lfanew) + sizeof(IMAGE_NT_HEADERS) > packed_pe_size) {
        throw std::runtime_error("NT headers offset out of bounds.");
    }
    IMAGE_NT_HEADERS* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS*>(packed_data + dos_header->e_lfanew);
    if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
        throw std::runtime_error("Invalid NT signature");
    }

    DWORD size_of_image = nt_headers->OptionalHeader.SizeOfImage;
    DWORD size_of_headers = nt_headers->OptionalHeader.SizeOfHeaders;
    WORD num_sections = nt_headers->FileHeader.NumberOfSections;

    if (size_of_headers > packed_pe_size || size_of_headers > size_of_image) {
        throw std::runtime_error("Invalid SizeOfHeaders.");
    }

    std::vector<BYTE> unpacked_image(size_of_image); // Automatically zero-initialized

    // Copy PE headers
    std::copy(packed_data, packed_data + size_of_headers, unpacked_image.begin());

    IMAGE_NT_HEADERS* nt_headers_unpacked = reinterpret_cast<IMAGE_NT_HEADERS*>(unpacked_image.data() + dos_header->e_lfanew);
    IMAGE_SECTION_HEADER* sections_unpacked = IMAGE_FIRST_SECTION(nt_headers_unpacked);
    const IMAGE_SECTION_HEADER* sections_original = IMAGE_FIRST_SECTION(nt_headers);

    // Collect RVA patterns to find PACKER_INFO array
    std::vector<uint64_t> rva_patterns_array;
    for (WORD i = 0; i < num_sections; ++i) {
        if (reinterpret_cast<const BYTE*>(&sections_original[i+1]) > packed_data + packed_pe_size) {
             throw std::runtime_error("Section header data out of bounds during RVA pattern collection.");
        }
        bool condition1 = (sections_original[i].SizeOfRawData == 0);
        bool condition2 = (sections_original[i].PointerToRawData == 0);
        bool condition3 = !(sections_original[i].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA);

        if (condition1 && condition2 && condition3) {
            rva_patterns_array.push_back((static_cast<uint64_t>(sections_original[i].VirtualAddress) << 32) | 0xFFFFFFFFULL);
        }
    }
    
    const BYTE* match_in_packed_pe_pattern_start = nullptr;
    size_t rva_patterns_bytes_len = rva_patterns_array.size() * sizeof(uint64_t);

    if (rva_patterns_bytes_len > 0) {
         match_in_packed_pe_pattern_start = FindPattern(packed_data, packed_pe_size, 
                                                        reinterpret_cast<const BYTE*>(rva_patterns_array.data()), 
                                                        rva_patterns_bytes_len);
    }

    PACKER_INFO* packer_info_array_ptr = nullptr;
    size_t num_packer_entries = 0;

    if (match_in_packed_pe_pattern_start) {
        // PACKER_INFO array is located just before the matched pattern sequence
        if (match_in_packed_pe_pattern_start < packed_data + sizeof(PACKER_INFO)) {
            throw std::runtime_error("Located RVA pattern is too close to the beginning of the file to precede PACKER_INFO[0].");
        }
        packer_info_array_ptr = reinterpret_cast<PACKER_INFO*>(const_cast<BYTE*>(match_in_packed_pe_pattern_start) - sizeof(PACKER_INFO));
        num_packer_entries = rva_patterns_array.size(); 

        // Validate that reading this array won't go out of bounds of the packed_pe_buffer
        if (num_packer_entries > 0) {
            const BYTE* end_of_packer_info_array = reinterpret_cast<const BYTE*>(packer_info_array_ptr) + num_packer_entries * sizeof(PACKER_INFO);
            if (end_of_packer_info_array > packed_data + packed_pe_size || reinterpret_cast<const BYTE*>(packer_info_array_ptr) < packed_data) {
                 throw std::runtime_error("Located PACKER_INFO array extends beyond packed PE buffer or has invalid start.");
            }
        }
    } else if (!rva_patterns_array.empty()) {
         throw std::runtime_error("RVA pattern sequence for PACKER_INFO not found in packed PE, but patterns were expected.");
    } else {
        std::cout << "Warning: RVA pattern array is empty. No PACKER_INFO entries to process for LZMA." << std::endl;
    }

    // Copy section data and update section headers in the unpacked image
    for (WORD i = 0; i < num_sections; ++i) {
        const IMAGE_SECTION_HEADER& original_sh = sections_original[i];
        IMAGE_SECTION_HEADER& unpacked_sh = sections_unpacked[i];
        
        unpacked_sh = original_sh; // Copy original section header

        if (original_sh.PointerToRawData != 0 && original_sh.SizeOfRawData > 0) {
             if (original_sh.PointerToRawData + original_sh.SizeOfRawData <= packed_pe_size &&
                 original_sh.VirtualAddress + original_sh.SizeOfRawData <= size_of_image) {
                std::copy(packed_data + original_sh.PointerToRawData,
                          packed_data + original_sh.PointerToRawData + original_sh.SizeOfRawData,
                          unpacked_image.begin() + original_sh.VirtualAddress);
            } else {
                 std::cerr << "Warning: Section " << std::string(reinterpret_cast<const char*>(original_sh.Name), strnlen(reinterpret_cast<const char*>(original_sh.Name), 8)) 
                           << " data out of bounds. RawOffset=" << ToHexString(original_sh.PointerToRawData) << ", RawSize=" << ToHexString(original_sh.SizeOfRawData)
                           << ", VA=" << ToHexString(original_sh.VirtualAddress) << ". Skipping copy." << std::endl;
            }
        }
        // Update PointerToRawData and SizeOfRawData for the unpacked file
        unpacked_sh.PointerToRawData = original_sh.VirtualAddress; // Common practice for unpacked files
        if (unpacked_sh.Misc.VirtualSize > 0) { // If VirtualSize is non-zero, use it for SizeOfRawData
             unpacked_sh.SizeOfRawData = unpacked_sh.Misc.VirtualSize;
        } else { // If VirtualSize is zero, SizeOfRawData should also be zero (or reflect actual copied data if any)
             unpacked_sh.SizeOfRawData = original_sh.SizeOfRawData; // Fallback or keep as original if no better logic
        }
    }
    
    if (packer_info_array_ptr && num_packer_entries > 0) {
        CLzmaDecoderState lzma_state = { 0 };
        std::unique_ptr<CProb[]> lzma_probs_holder; // RAII for lzma_state.Probs

        // Get LZMA properties from the first PACKER_INFO entry
        const PACKER_INFO& props_info = packer_info_array_ptr[0];
        DWORD props_raw_offset = RVAtoRawOffset(props_info.Src, nt_headers, packed_data, packed_pe_size, "LZMA Props");
        
        const BYTE* lzma_props_data_ptr = packed_data + props_raw_offset;
        unsigned int lzma_props_data_size = props_info.Dst; // Size of props from Dst

        if (props_raw_offset + lzma_props_data_size > packed_pe_size) {
            std::ostringstream err_oss;
            err_oss << "LZMA properties data (RVA " << ToHexString(props_info.Src) << " -> Raw " << ToHexString(props_raw_offset) 
                    << ", Size from Dst " << lzma_props_data_size << ") extends beyond packed PE size (" << ToHexString(packed_pe_size) << ").";
            throw std::runtime_error(err_oss.str());
        }
        
        if (lzma_props_data_size != LZMA_PROPERTIES_SIZE) {
             std::cout << "Warning: PACKER_INFO[0].Dst (LZMA props size) is " << lzma_props_data_size
                       << ". Standard is " << LZMA_PROPERTIES_SIZE << ". Using provided size." << std::endl;
        }

        if (LzmaDecodeProperties(&lzma_state.Properties, lzma_props_data_ptr, lzma_props_data_size) != LZMA_RESULT_OK) {
            std::ostringstream err_oss;
            err_oss << "LzmaDecodeProperties failed for props at RVA " << ToHexString(props_info.Src) 
                    << " (Raw " << ToHexString(props_raw_offset) << ") with size " << lzma_props_data_size << ".";
            throw std::runtime_error(err_oss.str());
        }

        size_t num_probs = LzmaGetNumProbs(&lzma_state.Properties);
        if (num_probs > 0) { // Allocate only if needed
            lzma_probs_holder = std::make_unique<CProb[]>(num_probs);
            lzma_state.Probs = lzma_probs_holder.get();
            // LzmaDec_Init(&lzma_state); // Often needed to initialize probs table, check LzmaDecode.h if it does this or expects pre-init
        }


        for (size_t block_idx = 1; block_idx <= num_packer_entries; ++block_idx) {
            const PACKER_INFO& current_block_info = packer_info_array_ptr[block_idx];
            
            uint32_t compressed_data_rva = current_block_info.Src;
            uint32_t uncompressed_target_rva = current_block_info.Dst;

            std::string context_str_stream = "Block " + std::to_string(block_idx) + " Compressed Data";
            DWORD compressed_block_raw_offset = RVAtoRawOffset(compressed_data_rva, nt_headers, packed_data, packed_pe_size, context_str_stream.c_str());

            const BYTE* compressed_stream_ptr = packed_data + compressed_block_raw_offset;
            
            if (uncompressed_target_rva >= size_of_image) {
                 std::ostringstream err_oss;
                 err_oss << "Block " << block_idx << ": PACKER_INFO.Dst (uncompressed target RVA " << ToHexString(uncompressed_target_rva) 
                         << ") is out of image bounds (" << ToHexString(size_of_image) << ").";
                 throw std::runtime_error(err_oss.str());
            }
            BYTE* uncomp_target_ptr_in_unpacked = unpacked_image.data() + uncompressed_target_rva;
            
            SizeT inProcessed = 0, outProcessed = 0;
            SizeT inSize = static_cast<SizeT>(-1); // LzmaDecode determines actual size
            SizeT outSizeLimit = static_cast<SizeT>(-1); // LzmaDecode determines actual size

            // Ensure the target buffer for decompression is valid and within bounds
            // Calculate max possible output based on remaining space in unpacked_image
            if (uncompressed_target_rva < size_of_image) {
                SizeT available_out_space = size_of_image - uncompressed_target_rva;
                // If outSizeLimit is -1, LzmaDecode might write past available_out_space if not careful.
                // The original C code implies LzmaDecode handles this, but it's safer to provide a limit if possible.
                // However, sticking to -1 as per original analysis of loader_part.cc
            } else {
                 std::ostringstream err_oss;
                 err_oss << "Block " << block_idx << ": Decompression target RVA " << ToHexString(uncompressed_target_rva) << " is invalid.";
                 throw std::runtime_error(err_oss.str());
            }
            
            // Calculate max possible input based on remaining space in packed_data
            SizeT available_in_space = packed_pe_size - compressed_block_raw_offset;
            // If inSize is -1, LzmaDecode reads until EOS or error.
            // Ensure compressed_stream_ptr is valid.

            int lzma_res = LzmaDecode(&lzma_state,
                                      compressed_stream_ptr,
                                      inSize, 
                                      &inProcessed,
                                      uncomp_target_ptr_in_unpacked,
                                      outSizeLimit,
                                      &outProcessed);

            if (lzma_res != LZMA_RESULT_OK) {
                std::ostringstream err_oss;
                err_oss << "LzmaDecode failed for block " << block_idx << " (SrcRVA " << ToHexString(compressed_data_rva) 
                        << " -> Raw " << ToHexString(compressed_block_raw_offset) << ", DstRVA " << ToHexString(uncompressed_target_rva) 
                        << ") with error " << lzma_res << ". InProcessed=" << inProcessed << ", OutProcessed=" << outProcessed;
                throw std::runtime_error(err_oss.str());
            }
            // std::cout << "Block " << block_idx << ": Decompressed. InProcessed=" << inProcessed << ", OutProcessed=" << outProcessed << std::endl;
        }
    }
    return unpacked_image;
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <packed_file> <unpacked_file>\n";
        return 1;
    }

    const char* packed_filepath = argv[1];
    const char* unpacked_filepath = argv[2];

    std::ifstream f_packed(packed_filepath, std::ios::binary | std::ios::ate);
    if (!f_packed) {
        std::cerr << "Error opening packed file: " << packed_filepath << std::endl;
        return 1;
    }

    std::streamsize packed_file_size_s = f_packed.tellg();
    if (packed_file_size_s <= 0) {
        std::cerr << "Packed file is empty or invalid size." << std::endl;
        return 1;
    }
    f_packed.seekg(0, std::ios::beg);
    
    size_t packed_file_len = static_cast<size_t>(packed_file_size_s);
    std::vector<BYTE> packed_buffer_vec(packed_file_len);

    if (!f_packed.read(reinterpret_cast<char*>(packed_buffer_vec.data()), packed_file_len)) {
        std::cerr << "Failed to read packed file." << std::endl;
        return 1;
    }
    f_packed.close();

    std::cout << "Packed file loaded: " << packed_filepath << ", Size: " << packed_file_len << " bytes\n";

    try {
        std::cout << "Unpacking...\n";
        std::vector<BYTE> unpacked_data_vec = UnpackPE(packed_buffer_vec.data(), packed_buffer_vec.size());

        if (!unpacked_data_vec.empty()) {
            std::cout << "Unpacker function finished. Unpacked size: " << unpacked_data_vec.size() << " bytes\n";
            std::ofstream f_unpacked(unpacked_filepath, std::ios::binary);
            if (!f_unpacked) {
                std::cerr << "Error opening output file for unpacked data: " << unpacked_filepath << std::endl;
                return 1;
            }
            f_unpacked.write(reinterpret_cast<const char*>(unpacked_data_vec.data()), unpacked_data_vec.size());
            std::cout << "Unpacked data written to: " << unpacked_filepath << std::endl;
        } else {
            std::cerr << "Unpacker function failed or produced empty output.\n";
            return 1;
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception during Unpacking: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

```

`python/vmpunpacker.py`:

```py
#!/usr/bin/env python3
import os
import sys
import struct
import lzma
import ctypes
from typing import List, Tuple, Optional
from dataclasses import dataclass
import io
import pefile  # Added pefile library import

# PE file format constants
IMAGE_DOS_SIGNATURE = 0x5A4D  # MZ
IMAGE_NT_SIGNATURE = 0x00004550  # PE\0\0
IMAGE_SIZEOF_SHORT_NAME = 8
IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080
LZMA_PROPERTIES_SIZE = 5  # Standard LZMA properties size

@dataclass
class PACKER_INFO:
    """Python implementation corresponding to C++ struct"""
    Src: int  # uint32
    Dst: int  # uint32

def to_hex_string(val, prefix=True):
    """Convert value to hexadecimal string for better error message display"""
    return f"0x{val:x}" if prefix else f"{val:x}"

def find_pattern(data: bytes, pattern: bytes) -> Optional[int]:
    """
    Find pattern in data, supporting 0xFF as wildcard
    Returns position where found, or None if not found
    """
    if not pattern or len(data) < len(pattern):
        return None
    
    for i in range(len(data) - len(pattern) + 1):
        match = True
        for j in range(len(pattern)):
            if pattern[j] != 0xFF and data[i + j] != pattern[j]:
                match = False
                break
        if match:
            return i
    return None

def unpack_pe(packed_pe_data: bytes) -> bytes:
    """
    Unpack a VMProtect protected PE file
    
    Args:
        packed_pe_data: Byte content of the packed PE file
        
    Returns:
        Unpacked PE file byte content
    """
    if not packed_pe_data:
        raise RuntimeError("Packed PE data is null or empty.")
    
    # Use pefile library to parse PE file
    try:
        pe = pefile.PE(data=packed_pe_data)
    except pefile.PEFormatError as e:
        raise RuntimeError(f"Invalid PE file format: {str(e)}")
    
    # Get basic PE information
    size_of_image = pe.OPTIONAL_HEADER.SizeOfImage
    size_of_headers = pe.OPTIONAL_HEADER.SizeOfHeaders
    number_of_sections = pe.FILE_HEADER.NumberOfSections
    
    # Create unpacked image
    unpacked_image = bytearray(size_of_image)
    
    # Copy PE headers
    unpacked_image[:size_of_headers] = packed_pe_data[:size_of_headers]
    
    # Collect RVA patterns to locate PACKER_INFO array
    rva_patterns_array = []
    for section in pe.sections:
        # Check conditions: no raw data but has virtual address, and not uninitialized data section
        condition1 = (section.SizeOfRawData == 0)
        condition2 = (section.PointerToRawData == 0)
        condition3 = not (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
        
        if condition1 and condition2 and condition3:
            # 64-bit mode: high 32 bits is VirtualAddress, low 32 bits is 0xFFFFFFFF (wildcard)
            pattern_value = ((section.VirtualAddress << 32) | 0xFFFFFFFF) & 0xFFFFFFFFFFFFFFFF
            pattern_bytes = struct.pack("<Q", pattern_value)
            rva_patterns_array.append(pattern_bytes)
    
    # Find PACKER_INFO array
    packer_info_array = []
    num_packer_entries = 0
    
    if rva_patterns_array:
        # Convert patterns to a single byte sequence
        pattern_bytes = b''.join(rva_patterns_array)
        
        # Search for pattern
        pattern_pos = find_pattern(packed_pe_data, pattern_bytes)
        
        if pattern_pos is not None:
            # PACKER_INFO array is located before the matching pattern sequence
            if pattern_pos < 8:  # sizeof(PACKER_INFO) = 8
                raise RuntimeError("Located RVA pattern is too close to the beginning of the file to precede PACKER_INFO[0].")
            
            packer_info_offset = pattern_pos - 8
            num_packer_entries = len(rva_patterns_array)
            
            # Verify reading this array won't go beyond packed_pe_data boundaries
            if num_packer_entries > 0:
                end_of_packer_info_array = packer_info_offset + (num_packer_entries + 1) * 8
                if end_of_packer_info_array > len(packed_pe_data) or packer_info_offset < 0:
                    raise RuntimeError("Located PACKER_INFO array extends beyond packed PE buffer or has invalid start.")
            
            # Extract PACKER_INFO array
            for j in range(num_packer_entries + 1):  # +1 because original code includes the first entry
                info_offset = packer_info_offset + j * 8
                src = struct.unpack("<I", packed_pe_data[info_offset:info_offset+4])[0]
                dst = struct.unpack("<I", packed_pe_data[info_offset+4:info_offset+8])[0]
                packer_info_array.append(PACKER_INFO(src, dst))
        
        elif rva_patterns_array:
            raise RuntimeError("RVA pattern sequence for PACKER_INFO not found in packed PE, but patterns were expected.")
    else:
        print("Warning: RVA pattern array is empty. No PACKER_INFO entries to process for LZMA.")
    
    # Copy section data and update section headers in unpacked image
    for i, section in enumerate(pe.sections):
        # Original section header
        virtual_address = section.VirtualAddress
        virtual_size = section.Misc_VirtualSize
        size_of_raw_data = section.SizeOfRawData
        pointer_to_raw_data = section.PointerToRawData
        section_name = section.Name.decode('ascii', errors='ignore').strip('\0')
        
        # Copy section data
        if pointer_to_raw_data != 0 and size_of_raw_data > 0:
            if pointer_to_raw_data + size_of_raw_data <= len(packed_pe_data) and virtual_address + size_of_raw_data <= size_of_image:
                section_data = packed_pe_data[pointer_to_raw_data:pointer_to_raw_data+size_of_raw_data]
                unpacked_image[virtual_address:virtual_address+len(section_data)] = section_data
            else:
                print(f"Warning: Section {section_name} data exceeds boundaries. RawOffset={to_hex_string(pointer_to_raw_data)}, "
                      f"RawSize={to_hex_string(size_of_raw_data)}, VA={to_hex_string(virtual_address)}. Skipping copy.")
        
        # Get section table offset in file
        section_offset = pe.OPTIONAL_HEADER.get_file_offset() + pe.FILE_HEADER.SizeOfOptionalHeader + i * 40
        
        # Update section header in unpacked image
        unpacked_section_offset = section_offset
        
        # Update PointerToRawData to VirtualAddress
        struct.pack_into("<I", unpacked_image, unpacked_section_offset+20, virtual_address)
        
        # If VirtualSize is non-zero, use it as SizeOfRawData
        if virtual_size > 0:
            struct.pack_into("<I", unpacked_image, unpacked_section_offset+16, virtual_size)
    
    # Handle LZMA decompression
    if packer_info_array and len(packer_info_array) > 1:
        # Get LZMA properties
        props_info = packer_info_array[0]
        # Use pefile's get_offset_from_rva method to convert RVA to file offset
        props_raw_offset = pe.get_offset_from_rva(props_info.Src)
        
        lzma_props_size = props_info.Dst
        lzma_props_data = packed_pe_data[props_raw_offset:props_raw_offset+lzma_props_size]
        
        if props_raw_offset + lzma_props_size > len(packed_pe_data):
            raise RuntimeError(f"LZMA properties data (RVA {to_hex_string(props_info.Src)} -> Raw {to_hex_string(props_raw_offset)}, "
                              f"Size from Dst {lzma_props_size}) extends beyond packed PE size ({to_hex_string(len(packed_pe_data))}).")
        
        # Standard LZMA properties size is 5 bytes
        if lzma_props_size != LZMA_PROPERTIES_SIZE:
            print(f"Warning: PACKER_INFO[0].Dst (LZMA properties size) is {lzma_props_size}. Standard is {LZMA_PROPERTIES_SIZE}. Using provided size.")
        
        try:
            # Process each LZMA block
            for block_idx in range(1, len(packer_info_array)):
                current_block_info = packer_info_array[block_idx]
                
                compressed_data_rva = current_block_info.Src
                uncompressed_target_rva = current_block_info.Dst
                
                # Use pefile to get file offset
                try:
                    compressed_block_raw_offset = pe.get_offset_from_rva(compressed_data_rva)
                except Exception as e:
                    raise RuntimeError(f"Block {block_idx}: Cannot convert RVA to file offset: {str(e)}")
                
                compressed_data = packed_pe_data[compressed_block_raw_offset:]
                
                if uncompressed_target_rva >= size_of_image:
                    raise RuntimeError(f"Block {block_idx}: PACKER_INFO.Dst (decompression target RVA {to_hex_string(uncompressed_target_rva)}) "
                                      f"exceeds image boundary ({to_hex_string(size_of_image)}).")
                
                # Use Python's lzma module to decompress data
                # Note: We need to construct a properly formatted LZMA stream
                lc = lzma_props_data[0] % 9
                lp = (lzma_props_data[0] // 9) % 5
                pb = lzma_props_data[0] // 45
                dict_size = int.from_bytes(lzma_props_data[1:5], byteorder='little')
                
                # Build LZMA compression filter
                filters = [
                    {
                        "id": lzma.FILTER_LZMA1,
                        "dict_size": dict_size,
                        "lc": lc,
                        "lp": lp,
                        "pb": pb
                    }
                ]
                
                # Create an LZMA decompressor
                decompressor = lzma.LZMADecompressor(format=lzma.FORMAT_RAW, filters=filters)
                
                # Decompress data
                try:
                    decompressed_data = decompressor.decompress(compressed_data)
                    
                    # Write decompressed data to target location
                    available_space = size_of_image - uncompressed_target_rva
                    if len(decompressed_data) <= available_space:
                        unpacked_image[uncompressed_target_rva:uncompressed_target_rva+len(decompressed_data)] = decompressed_data
                    else:
                        print(f"Warning: Block {block_idx}: Decompressed data size exceeds available space in image")
                        # Only write data that can fit
                        unpacked_image[uncompressed_target_rva:uncompressed_target_rva+available_space] = decompressed_data[:available_space]
                    
                    print(f"Block {block_idx}: Decompressed. Output size={len(decompressed_data)}")
                
                except lzma.LZMAError as e:
                    raise RuntimeError(f"LZMA decompression error: {str(e)}")
        
        except Exception as e:
            raise RuntimeError(f"Error processing LZMA data: {str(e)}")
    
    return bytes(unpacked_image)

def main():
    """Main function processes command line arguments and starts the unpacking process"""
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <packed file> <unpacked file>")
        return 1
    
    packed_filepath = sys.argv[1]
    unpacked_filepath = sys.argv[2]
    
    try:
        # Read packed file
        with open(packed_filepath, 'rb') as f:
            packed_data = f.read()
        
        print(f"Packed file loaded: {packed_filepath}, size: {len(packed_data)} bytes")
        
        # Perform unpacking
        print("Unpacking...")
        unpacked_data = unpack_pe(packed_data)
        
        if unpacked_data:
            print(f"Unpacking function completed. Unpacked size: {len(unpacked_data)} bytes")
            
            # Write unpacked file
            with open(unpacked_filepath, 'wb') as f:
                f.write(unpacked_data)
            
            print(f"Unpacked data written to: {unpacked_filepath}")
            return 0
        else:
            print("Unpacking function failed or produced empty output.")
            return 1
    
    except Exception as e:
        print(f"Exception occurred during unpacking: {str(e)}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
```