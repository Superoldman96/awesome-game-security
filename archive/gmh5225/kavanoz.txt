Project Path: arc_gmh5225_kavanoz_swhfpjdu

Source Tree:

```txt
arc_gmh5225_kavanoz_swhfpjdu
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚   â””â”€â”€ unpack.gif
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ src
â”‚   â””â”€â”€ kavanoz
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ core.py
â”‚       â”œâ”€â”€ debug_utils.py
â”‚       â”œâ”€â”€ loader
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ androidnativeemu
â”‚       â”‚   â”œâ”€â”€ appsealing.py
â”‚       â”‚   â”œâ”€â”€ coper.py
â”‚       â”‚   â”œâ”€â”€ moqhao.py
â”‚       â”‚   â”œâ”€â”€ multidex.py
â”‚       â”‚   â”œâ”€â”€ multidex_header.py
â”‚       â”‚   â”œâ”€â”€ old_rc4.py
â”‚       â”‚   â”œâ”€â”€ rc4.py
â”‚       â”‚   â”œâ”€â”€ sesdex.py
â”‚       â”‚   â”œâ”€â”€ simple.py
â”‚       â”‚   â”œâ”€â”€ simple_aes.py
â”‚       â”‚   â”œâ”€â”€ simple_xor.py
â”‚       â”‚   â”œâ”€â”€ simple_xor_zlib.py
â”‚       â”‚   â”œâ”€â”€ simply_xor2.py
â”‚       â”‚   â””â”€â”€ subapp.py
â”‚       â”œâ”€â”€ plugin_loader.py
â”‚       â”œâ”€â”€ smali_regexes.py
â”‚       â”œâ”€â”€ unpack_plugin.py
â”‚       â””â”€â”€ utils.py
â””â”€â”€ tests
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test.py

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2022 Ahmet Bilal Can

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`README.md`:

```md
# ðŸ«™ kavanoz ðŸ«™
Statically unpacking common android banker malware.

Ever wanted to get payload from packed malware without running android emulator ? Me neither.

![](assets/unpack.gif)

### Requirements

- arc4
- androguard
- lief
- unicorn
- androidemu
- pycryptodome


### :eyes: Installation

```
pip install -e . --user
```

### :zap: Usage

from cmdline
```bash
kavanoz /tmp/filepath
```

from python library
```py
from kavanoz.core import Kavanoz
k = Kavanoz(apk_path)
for plugin_result in k.get_plugin_results():
    if plugin_result['status'] = 'success':
        print('Unpacked')
        print(plugin_result)
```

### :snake: Scripts:

- [rc4.py](src/kavanoz/loader/rc4.py) Generic rc4 encrypted asset file. Script covers multiple versions.
- [old_rc4.py](src/kavanoz/loader/old_rc4.py) Another Generic rc4 encrypted asset file.
- [subapp.py](src/kavanozloader/subapp.py) Decryption of file with key derived from Manifest file ProtectKey variable
- [multidex.py](src/kavanoz/loader/multidex.py) Multidex like loader with inflated packed file. (zlib compression)
- [coper.py](src/kavanoz/loader/coper.py) Extract rc4 key from native lib with emulation (AndroidNativeEmu)
- [moqhao.py](src/kavanozloader/moqhao.py) Emulation for moqhau unpacking.
- [sesdex.py](src/kavanoz/loader/sesdex.py)
- [simple_aes.py](src/kavanoz/loader/simple_aes.py)
- [simple_xor.py](src/kavanoz/loader/simple_xor.py)
- [simple_xor2.py](src/kavanoz/loader/simple_xor2.py)
- [simple_xor_zlib.py](src/kavanoz/loader/simple_xor_zlib.py)
- [subapp.py](src/kavanoz/loader/subapp.py) Decrypt asset with package name

####  Note

Do not use cryptodome for rc4 decryption. It does not work with 2-4 key size.

### :gear: Development

To add new plugins just create new file in loader folder. Extend Unpacker class from unpack_plugin.py file. Define start_decrypt function with your implementation. 
```py
def start_decrypt(self, apk_object: APK, dvms: "list[DalvikVMFormat]"):
```

Add following function to make early exit from plugin. 
```py
def lazy_check(self,apk_object:APK, dvms: "list[DalvikVMFormat]"):
```

If extraction is succesful assign self.decrypted_payload_path with extracted file path.
You can use helper functions from unpacker class:
- get_array_data
- get_smali
- find_method(class_name,method_name,descriptor="")
- check_and_write_file(file_data) : checks file has dex, zip and zlib headers and writes unpacked dex with name : "external-{m[:8]}.dex"

### :book: Tips

- self.dvms hold dex dvm objects. You can get class with `dvm.get_class(smali_annotation_of_class)`.
- You can use get_smali function and give target method obj to get smali represantation of target method. Then apply some regex to get data from smali. There are lots of defined regexs in [smali_regexes.py](smali_regexes.py) file to lookup. 
- Most of the time packers use file from asset folder. You can get files with `self.apk_object.get_files()` 
- Most of the time packers use Application class to start unpacking sequence. Use `application = self.apk_object.get_attribute_value("application", "name")` to get application class defined in manifest file. 


```

`pyproject.toml`:

```toml
[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "kavanoz"
version = "0.0.1"
keywords = ["android","malware","unpacking","packer"]
license = {file="LICENSE"}
readme = "README.md"
description = "Unpacking framework for common android malware"
dynamic = ["dependencies"]
authors = [
  {email = "eybisii@gmail.com"},
  {name = "Ahmet Bilal Can"}
]
maintainers = [
  {name = "Ahmet Bilal Can", email = "eybisii@gmail.com"}
]
[tool.setuptools.dynamic]
dependencies = {file = ['requirements.txt']}
[project.scripts]
kavanoz = "kavanoz.core:cli"
[tool.setuptools.packages.find]
# All the following settings are optional:
where = ["src"]  # ["."] by default
include = ["*"]  # ["*"] by default
namespaces = true  # true by default

```

`requirements.txt`:

```txt
androguard==3.3.5
androidemu==0.0.2
arc4==0.3.0
androguard
halo==0.0.31
lief==0.12.3
loguru==0.6.0
pycryptodome==3.16.0

```

`src/kavanoz/core.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from kavanoz.unpack_plugin import Unpacker
from kavanoz import plugin_loader
from kavanoz.utils import InterceptHandler
from loguru import logger
import logging
import time
import kavanoz.loader
import click
import sys
from halo import Halo


class Kavanoz:
    def __init__(self, apk_path):
        s = time.time()
        self.apk_object = APK(apk_path)
        # load plugins
        self.plugins = [
            subplug
            for plugin in filter(None, plugin_loader.get_plugins())
            for subplug in plugin
        ]
        e = time.time()
        logger.info(f"Androguard took : {e-s} seconds")
        s = time.time()
        self.dvms = [DalvikVMFormat(dex) for dex in self.apk_object.get_all_dex()]
        e = time.time()
        logger.info(f"Androguard dvm took : {e-s} seconds")

    def get_plugin_results(self):
        for plugin in self.plugins:
            p = plugin(self.apk_object, self.dvms)
            yield p.main()

    def is_packed(self):
        p = Unpacker("test", "test", apk_object=self.apk_object, dvms=self.dvms)
        return p.is_packed()


@click.command()
@click.argument("filename", type=click.Path(exists=True))
@click.option("-v", "--verbose", count=True)
def cli(filename, verbose):

    logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)
    logger.disable("androguard")
    logger.remove()
    if verbose > 0:
        logger.add(sys.stderr, level=verbose)
    spinner = Halo(text="Extracting apk/dvm information", spinner="star")
    spinner.start()
    k = Kavanoz(filename)
    spinner.stop()
    spinner.text = f"Plugin {k.plugins[0]} is running"
    spinner.start()
    if not k.is_packed():
        spinner.warn("Sample is not packed")
    for res in k.get_plugin_results():
        spinner.text = f'Plugin {res["tag"]} is running'
        spinner.start()
        if res["status"] == "success":
            m = f"""Plugin tag : {res['tag']} 
Plugin description : {res['name']} 
Output file : {res['output_file']} """
            spinner.text_color = "green"
            spinner.stop_and_persist("âœ¨", "Unpacked succesfully!")
            print(m)
            break
    else:
        spinner.stop_and_persist("âŒ", "Cannot unpack")

```

`src/kavanoz/debug_utils.py`:

```py
import logging

from unicorn.arm_const import *

logger = logging.getLogger(__name__)


def hook_code(uc, address, size, user_data):
    instruction = uc.mem_read(address, size)
    instruction_str = ''.join('{:02x} '.format(x) for x in instruction)

    logger.debug('# Tracing instruction at 0x%x, instruction size = 0x%x, instruction = %s' % (address, size, instruction_str))

    if instruction == b"\x00\x00\x00\x00":
        logger.error("Uh oh, we messed up.")
        uc.emu_stop()


def hook_block(uc, address, size, user_data):
    instruction = uc.mem_read(address, size)
    instruction_str = ''.join('{:02x} '.format(x) for x in instruction)

    logger.debug('# Block at 0x%x, instruction size = 0x%x, instruction = %s' % (address, size, instruction_str))


def hook_unmapped(uc, access, address, length, value, context):
    pc = uc.reg_read(UC_ARM_REG_PC)

    logger.debug("mem unmapped: pc: %x access: %x address: %x length: %x value: %x" % (pc, access, address, length, value))
    uc.emu_stop()
    return True


def hook_mem_write(uc, access, address, size, value, user_data):
    pc = uc.reg_read(UC_ARM_REG_PC)
    logger.debug(">>> Memory WRITE at 0x%x, data size = %u, data value = 0x%x, pc: %x" % (address, size, value, pc))


def hook_mem_read(uc, access, address, size, value, user_data):
    pc = uc.reg_read(UC_ARM_REG_PC)
    data = uc.mem_read(address, size)
    logger.debug(">>> Memory READ at 0x%x, data size = %u, pc: %x, data value = 0x%s" % (address, size, pc, data.hex()))


def hook_interrupt(uc, intno, data):
    logger.debug(">>> Triggering interrupt %d" % intno)
    return

```

`src/kavanoz/loader/appsealing.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderAppsealing(Unpacker):
    def __init__(self, apk_obj: APK, dvms):
        super().__init__("loader.appsealing", "Appsealing unpacker", apk_obj, dvms)

    def lazy_check(self, apk_object, dvms):
        for f in self.apk_object.get_files():
            if "assets/AppSealing" in f:
                return True

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Not implemented yet")
        return

```

`src/kavanoz/loader/coper.py`:

```py
import sys
from androidemu.emulator import Emulator
from androidemu.utils.memory_helpers import read_utf8
from unicorn.unicorn_const import UC_HOOK_MEM_READ_UNMAPPED, UC_HOOK_MEM_UNMAPPED
import kavanoz.debug_utils

from unicorn import UC_HOOK_CODE
import unicorn
from unicorn.arm_const import *
import lief
from arc4 import ARC4
from kavanoz.unpack_plugin import Unpacker
import os


class LoaderCoper(Unpacker):
    def __init__(self, apk_obj, dvms):
        super().__init__("loader.coper", "Unpacker for coper", apk_obj, dvms)

    def start_decrypt(self, native_lib: str = ""):
        arm32_native_libs = [
            filename
            for filename in self.apk_object.get_files()
            if filename.startswith("lib/armeabi-v7a")
        ]
        if len(arm32_native_libs) == 0:
            self.logger.info("No native lib ðŸ˜”")
            return
        if len(arm32_native_libs) != 1:
            self.logger.info("Not sure this is copper but continue anyway")

        fname = arm32_native_libs[0].split("/")[-1]
        with open(fname, "wb") as fp:
            fp.write(self.apk_object.get_file(arm32_native_libs[0]))
        self.target_lib = fname
        # Show loaded modules.
        self.resolved_strings = []
        if not self.init_lib():
            return
        self.logger.info("Loaded modules:")
        if not self.setup_hook():
            return
        self.emulator.call_symbol(self.target_module, self.target_function.name)
        self.logger.info(f"Androidemu extracted rc4 key: {self.resolved_strings[0]}")
        self.decrypt_files(self.resolved_strings[0])
        os.remove(fname)

    def decrypt_files(self, rc4key: str):
        for filepath in self.apk_object.get_files():
            fd = self.apk_object.get_file(filepath)
            dede = ARC4(rc4key)
            dec = dede.decrypt(fd)
            if self.check_and_write_file(dec):
                return True
        return False

    def init_lib(self):
        target_ELF = lief.ELF.parse(self.target_lib)
        java_exports = [
            jf for jf in target_ELF.exported_functions if jf.name.startswith("Java_")
        ]
        if len(java_exports) == 0:
            return False
        if len(java_exports) > 1:
            self.logger.info("Not sure this is copper but continue anyway")

        self.target_function = java_exports[0]
        # Configure logging

        # Initialize emulator
        self.emulator = Emulator(vfp_inst_set=True)
        libc_path = os.path.join(os.path.dirname(__file__), "androidnativeemu/libc.so")
        self.emulator.load_library(libc_path, do_init=False)
        self.target_module = self.emulator.load_library(self.target_lib, do_init=False)
        return True

    def setup_hook(self):
        for module in self.emulator.modules:
            if module.filename == self.target_lib:
                self.logger.info("[0x%x] %s" % (module.base, module.filename))
                # emulator.mu.hook_add(
                # UC_HOOK_CODE,
                # hook_code,
                # begin=module.base + java_func_obj.address,
                # end=module.base + java_func_obj.address + (0x2198 - 0x1FC1),
                # )
                strncat = module.find_symbol("__strncat_chk")
                if strncat == None:
                    return False
                self.logger.debug(f"{hex(strncat.address)} strcat_chk addr")
                self.emulator.mu.hook_add(
                    UC_HOOK_CODE,
                    self.hook_strncat,
                    begin=strncat.address,
                    end=strncat.address + 1,
                )
                self.emulator.mu.hook_add(UC_HOOK_MEM_UNMAPPED, self.hook_mem_read)
                self.emulator.mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED, self.hook_mem_read)
                return True

    def hook_mem_read(self, uc, access, address, size, value, user_data):
        pc = uc.reg_read(UC_ARM_REG_PC)
        data = uc.mem_read(address, size)
        self.logger.debug(
            ">>> Memory READ at 0x%x, data size = %u, pc: %x, data value = 0x%s"
            % (address, size, pc, data.hex())
        )

    def hook_strncat(self, uc: unicorn.unicorn.Uc, address, size, user_data):
        # print(f"current strncat hook addr : {hex(address)}")
        r0 = uc.reg_read(UC_ARM_REG_R0)
        # print(f"current strncat hook r0 : {hex(r0)}")
        r1 = uc.reg_read(UC_ARM_REG_R1)
        max_size = uc.reg_read(UC_ARM_REG_R2)
        # print(f"current strncat hook r1 : {hex(r1)}")
        cur_key = read_utf8(uc, r0)
        added = read_utf8(uc, r1)
        final_str = cur_key + added
        if len(final_str) == max_size - 1:
            self.logger.debug(f"current strncat hook final_str : {final_str}")
            self.resolved_strings.append(final_str)
            if len(self.resolved_strings) > 10:
                self.emulator.mu.emu_stop()

    # def hook_code(self,uc: unicorn.unicorn.Uc, address, size, user_data):
    # global rc4_key
    # if address == coper_base + java_func_obj.address + (0x2198 - 0x1FC1):
    # sp = uc.reg_read(UC_ARM_REG_SP)
    # rc4_key = read_utf8(uc, sp + 0x46F)

    # print(
    # "# Tracing instruction at 0x%x, instruction size = 0x%x, instruction = %s"
    # % (address, size, instruction_str)
    # )
    # if instruction[0] == 0xA0 and instruction[1] == 0x47 and len(instruction) == 2:
    # r1 = uc.reg_read(UC_ARM_REG_R1)
    # print(r1)
    # print(uc.mem_read(r1, 1))

```

`src/kavanoz/loader/moqhao.py`:

```py
from androguard.core.bytecodes.apk import APK
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderMoqhao(Unpacker):
    """
    Read asset files. Try to decrypt with : file[11] is xor key to decrypt file[12:]
    """

    def __init__(self, apk_obj: APK, dvms):
        super().__init__("loader.moqhao", "Unpacker for moqhao", apk_obj, dvms)

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        self.brute_assets()

    def brute_assets(self):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            if "assets/" in filepath:
                f = self.apk_object.get_file(filepath)
                if self.solve_encryption(f):
                    self.logger.info(
                        f"Decryption finished! {self.decrypted_payload_path}"
                    )

    def lazy_check(self, apk_obj, dvms) -> bool:
        file_list = apk_obj.get_files()
        one_asset = any("assets/" in x for x in file_list)
        native_lib = any("lib/" in x for x in file_list)
        return one_asset and native_lib

    def solve_encryption(self, file_data):
        if len(file_data) < 12:
            return
        first_12 = file_data[:12]
        xor_key = first_12[11].to_bytes(1, "little")
        xord_data = xor(file_data[12:], xor_key)
        if self.check_and_write_file(xord_data):
            return True
        else:
            return False
        return False

```

`src/kavanoz/loader/multidex.py`:

```py
from androguard.core.bytecodes.apk import APK
import zlib
from androguard.core.bytecodes.dvm import DalvikVMFormat, EncodedMethod
import re
import ctypes
import string
from kavanoz.unpack_plugin import Unpacker


def unsigned_rshift(val, n):
    unsigned_integer = val % 0x100000000
    return unsigned_integer >> n


def unsigned_lshift(val, n):
    unsigned_integer = val % 0x100000000
    return unsigned_integer << n


class LoaderMultidex(Unpacker):
    ProtectKey = ""

    def __init__(self, apk_obj, dvms):
        super().__init__(
            "loader.multidex", "Unpacker for multidex variants", apk_obj, dvms
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        z = self.apk_object.get_android_manifest_xml()
        if z != None:
            f = z.find("application")
            childs = f.getchildren()
            self.ProtectKey = None
            for child in childs:
                if child.tag == "meta-data":
                    if (
                        child.attrib["{http://schemas.android.com/apk/res/android}name"]
                        == "ProtectKey"
                    ):
                        self.ProtectKey = child.attrib[
                            "{http://schemas.android.com/apk/res/android}value"
                        ]
            if self.ProtectKey != None:
                if self.find_decrypt_protect_arrays():
                    self.logger.info("Found key in manifest/xor")
                    return

        self.decrypted_payload_path = None
        zip_function = self.find_zip_function()
        if zip_function is not None:
            _function, dvm = zip_function
            variable = self.extract_variable_from_zip(_function, dvm)
            if variable is not None:
                key = self.find_clinit_target_variable(variable)
                if key is not None:
                    if self.brute_assets(key):
                        if self.is_really_unpacked():
                            self.logger.info("fully unpacked")
                        else:
                            self.logger.info("not fully unpacked")
                        return
        else:
            self.logger.info("Cannot find zip function")
            self.logger.info("Second plan for zipper")
            self.second_plan()

    def second_plan(self):
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            return None

        application_smali = "L" + application.replace(".", "/") + ";"
        target_method = self.find_method(application_smali, "<init>")
        if target_method == None:
            return None
        smali_str = self.get_smali(target_method)
        """
        sget-object v0, Lb;->f:Ljava/lang/String;
        invoke-static {v0}, Lc;->b(Ljava/lang/String;)Ljava/lang/String;
        move-result-object v0
        """
        match = re.findall(
            r"sget-object [vp]\d+, (L[^;]+;->[^ ]+) Ljava/lang/String;\s+"
            r"invoke-static {?[vp]\d+}?, L[^;]+;->[^\(]+\(Ljava/lang/String;\)Ljava/lang/String",
            smali_str,
        )
        # print(match)
        # self.for_fun(match[0])
        for matched_field in match:
            key = self.find_clinit_target_variable(matched_field)
            if key != None:
                xor_k = 0x6033
                tmp_key = "".join(chr(xor_k ^ ord(c)) for c in key)
                self.logger.info(f"Is this a key ??? {tmp_key}")
                if tmp_key is not None:
                    if all(c in string.printable for c in tmp_key):
                        asset_list = self.apk_object.get_files()
                        for filepath in asset_list:
                            f = self.apk_object.get_file(filepath)
                            if self.solve_encryption(
                                f, tmp_key
                            ) or self.solve_encryption2(f, tmp_key):
                                return True
                    else:
                        return False

        return target_method

    def find_zip_function(self):
        target_method = None
        for d in self.dvms:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Ljava/util/zip/ZipFile; Ljava/util/zip/ZipEntry; Ljava/io/File; Ljava/lang/String;)V"
                    ):
                        self.logger.info("Found method")
                        target_method = m
                        return target_method, d
        return None

    def find_decrypt_protect_arrays(self):
        for d in self.dvms:
            for c in d.get_classes():
                for m in c.get_methods():
                    if m.get_descriptor() == "(I)[C":
                        self.logger.info("Found decrypt protect arrays method")
                        smali_str = self.get_smali(m)
                        """
                        const/16 v6, 11
                        const/4 v5, 3
                        const/4 v4, 2
                        const/4 v3, 1
                        const/4 v2, 0
                        if-eqz v7, +1d6
                        if-eq v7, v3, +1c8
                        if-eq v7, v4, +1bd
                        if-eq v7, v5, +5
                        new-array v0, v2, [C
                        return-object v0
                        const/16 v0, 75
                        oto/16 -1b5
                        new-array v0, v3, [C
                        const/16 v1, 24627
                        int-to-char v1, v1
                        aput-char v1, v0, v2
                        goto/16 -1be
                        new-array v0, v4, [C
                        const/16 v1, 12293
                        aput-char v1, v0, v2
                        const/16 v1, 12294
                        aput-char v1, v0, v3
                        goto/16 -1ca
                    """
                        match = re.findall(
                            r"new-array [vp]\d+, [vp]\d+, \[C\s+"
                            r"const/16 [vp]\d+, (-?\d+)\s+"
                            r"int-to-char [vp]\d+, [vp]\d+\s+"
                            r"aput-char [vp]\d+, [vp]\d+, [vp]\d+\s+"
                            r"goto/16 -?[a-f0-9]+\s+",
                            smali_str,
                        )
                        for m in match:
                            try:
                                xor_k = int(m)
                            except:
                                self.logger.info("bad match", m)
                                continue
                            if self.ProtectKey != None:
                                tmp_key = "".join(
                                    chr(xor_k ^ ord(c)) for c in self.ProtectKey
                                )
                                if self.brute_assets(tmp_key):
                                    return True
                            else:
                                self.logger.info("no protect key found in manifest..")
                        else:
                            self.logger.info("Could not find with key size of 1")

    def extract_variable_from_zip(self, target_method: EncodedMethod, dvm):
        smali_str = self.get_smali(target_method)
        """
        5 invoke-virtual v3, v0, Ljava/util/zip/ZipOutputStream;->putNextEntry(Ljava/util/zip/ZipEntry;)V
        6 sget-object v0, Lcom/icecream/sandwich/c;->l Ljava/lang/String;
        7 new-instance v4, Ljava/util/zip/InflaterInputStream;
        """
        match = re.findall(
            r"invoke-virtual [vp]\d+, [vp]\d+, [vp]\d+, Ljava/util/zip/ZipEntry;->setTime\(J\)V\s+"
            r"invoke-virtual {?[vp]\d+, [vp]\d+}?, L[^;]+;->[^\(]+\(Ljava/util/zip/ZipEntry;\)V\s+"
            r"sget-object [vp]\d+, (L[^;]+;->[^\(]+) Ljava/lang/String;\s+",
            smali_str,
        )
        if len(match) == 0:
            self.logger.info(
                f"Unable to extract variable from {target_method.get_name()}"
            )
            self.logger.info("Exiting ...")
            return None
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
            method = self.find_method(target_method.class_name, "<clinit>")
            if method:
                smali_str = self.get_smali(method)
                key_variable = re.findall(
                    r"sget-object [vp]\d+, (L[^;]+;->[^\s]+) Ljava/lang/String;\s+"
                    f"sput-object v0, {match[0]} Ljava/lang/String;",
                    smali_str,
                )
                if len(key_variable) == 1:
                    self.logger.info(
                        f"Found key variable from zip class <clinit> {key_variable[0]}"
                    )
                    return key_variable[0]
                else:
                    self.logger.info("Not found key variable from clinit")
                    return None
        else:
            self.logger.info("Something is wrong .. ðŸ¤”")
            self.logger.info("Found multiple ?? : {match}")
            return None

    def for_fun(self, variable_string):
        variable_class, variable_field = variable_string.split("->")
        key_class = self.find_class_in_dvms(variable_class)
        if key_class == None:
            self.logger.info(f"No key class found {key_class}")
            return None

        self.logger.info(f"Key class found ! {key_class}")
        key_clinit = self.find_method(variable_class, "<clinit>")
        if key_clinit is not None:
            smali_str = self.get_smali(key_clinit)
            # self.logger.info(smali_str)
            match = re.findall(
                r"const-string [vp]\d+, '(.*)'\s+" rf"sput-object [vp]\d+, .*\s+",
                smali_str,
            )
            for m in match:
                xor_k = 0x6033
                tmp_key = "".join(chr(xor_k ^ ord(c)) for c in m)
                self.logger.info(f"zaa??? {tmp_key}")

    def find_clinit_target_variable(self, variable_string):
        variable_class, variable_field = variable_string.split("->")
        key_class = self.find_class_in_dvms(variable_class)
        if key_class == None:
            self.logger.info(f"No key class found {key_class}")
            return None

        self.logger.info(f"Key class found ! {key_class}")
        key_clinit = self.find_method(variable_class, "<clinit>")
        if key_clinit is not None:
            smali_str = self.get_smali(key_clinit)
            # self.logger.info(smali_str)
            match = re.findall(
                r"const-string [vp]\d+, '(.*)'\s+"
                rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                smali_str,
            )
            if len(match) == 0:
                self.logger.info(
                    f"Cannot find string definition in clinit for target variable {variable_string}"
                )
                # If its using apkprotecttor, we can try some other method
                match = re.findall(
                    r"const-string(?:/jumbo)? [vp]\d+, '(.*)'\s+"
                    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->[^\(]+\(Ljava\/lang\/String; I\)Ljava\/lang\/String;\s+"
                    r"move-result-object [vp]\d+\s+"
                    rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                    smali_str,
                )
                if len(match) == 0:
                    match = re.findall(
                        r"const-string(?:/jumbo)? [vp]\d+, '(.*)'\s+"
                        r"invoke-static [vp]\d+, L[^;]+;->[^\(]+\(Ljava\/lang\/String;\)Ljava\/lang\/String;\s+"
                        r"move-result-object [vp]\d+\s+"
                        rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                        smali_str,
                    )

                if len(match) == 1:
                    xor_k = 0x6033
                    tmp_key = "".join(chr(xor_k ^ ord(c)) for c in match[0])
                    self.logger.info(f"Is this a key ??? {tmp_key}")
                    return tmp_key
            if len(match) == 1:
                self.logger.info(f"Found key !  {match[0]}")
                return match[0]
            else:
                self.logger.info(f"Multiple key ? {match}")
        if key_clinit is None:
            self.logger.info(f"No clinit for {variable_class}")
        return None

    def brute_assets(self, key: str):
        self.logger.info(f"Starting brute-force inflate {key}")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key) or self.solve_encryption2(f, key):
                self.logger.info("Decryption finished!!")
                return self.decrypted_payload_path
        return None

    def solve_encryption2(self, file_data, key):
        if len(file_data) < 8 or len(key) < 12:
            return False

        if file_data[0] == 0x78 and file_data[1] == 0x9C:
            try:
                encrypted = zlib.decompress(file_data)
            except Exception as e:
                self.logger.error(e)
                return False
        else:
            encrypted = file_data

        iArr = []  # 2
        iArr2 = []  # 4
        iArr3 = [None] * 27  # 27
        iArr4 = []  # 3
        key = [ord(c) for c in key]
        iArr = [key[8] | (key[9] << 16), key[11] << 16 | key[10]]
        iArr2.extend(
            [
                key[0] | (key[1] << 16),
                key[2] | (key[3] << 16),
                key[4] | (key[5] << 16),
                key[6] | (key[7] << 16),
            ]
        )
        iArr3[0] = iArr2[0]
        iArr4.extend([iArr2[1], iArr2[2], iArr2[3]])
        i2 = iArr2[0]
        i = 0
        while i < 26:
            i3 = i % 3
            iArr4[i3] = (
                (
                    (unsigned_rshift(ctypes.c_int32(iArr4[i3]).value, 8))
                    | ctypes.c_int32((iArr4[i3]) << 24).value
                )
                + i2
            ) ^ i
            i2 = (
                ctypes.c_int32(i2 << 3).value
                | (unsigned_rshift(ctypes.c_int32(i2).value, 29))
            ) ^ ctypes.c_int32(iArr4[i3]).value
            i += 1
            iArr3[i] = i2

        decrypted_bytes = bytearray()
        z = 0
        for b in encrypted:
            if z % 8 == 0:
                h0 = iArr[0]
                h1 = iArr[1]
                for k in iArr3:
                    tmp0 = ((unsigned_rshift(h1, 8) | (h1 << 24) & 0xFFFFFFFF) + h0) ^ k
                    tmp1 = ((h0 << 3) & 0xFFFFFFFF | unsigned_rshift(h0, 29)) ^ tmp0
                    h0 = tmp1 & 0xFFFFFFFF
                    h1 = tmp0 & 0xFFFFFFFF
                iArr[0] = h0
                iArr[1] = h1
            b ^= iArr[int((z % 8) / 4)] >> (8 * (z % 4)) & 0xFF
            if (z == 0 and b != 0x78) or (z == 1 and b != 0x9C):
                return False
            z += 1
            decrypted_bytes.append(b)
        if self.check_and_write_file(decrypted_bytes):
            self.logger.info("Found in second algo finished")
            return True
        return False

    def solve_encryption(self, file_data: bytes, key: str):
        if len(file_data) < 8 or len(key) < 12:
            return False
        if file_data[0] == 0x78 and file_data[1] == 0x9C:
            try:
                encrypted = zlib.decompress(file_data)
            except Exception as e:
                self.logger.error(e)
                return False
        else:
            encrypted = file_data
        decrypted_bytes = bytearray()
        indexes = [0, 0, 0, 0, 1, 1, 1, 1]
        bits = [0, 8, 16, 24]
        c = [ord(x) for x in key]
        poolArr = [(c[9] << 16) | c[8], (c[11] << 16) | c[10]]
        check_0 = (poolArr[indexes[0]]) >> bits[0] & 0xFF ^ encrypted[0]
        check_1 = (poolArr[indexes[0]]) >> bits[0] & 0xFF ^ encrypted[1]
        if check_0 != 0x78 and check_1 != 0x9C:
            return False
        for i, b in enumerate(encrypted):
            b ^= (poolArr[indexes[i % 8]]) >> bits[i % 4] & 0xFF
            decrypted_bytes.append(b)

        if self.check_and_write_file(decrypted_bytes):
            self.logger.info("Found in first algo")
            return True
        else:
            return False

```

`src/kavanoz/loader/multidex_header.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from kavanoz.unpack_plugin import Unpacker
import struct


class LoaderMultidexHeader(Unpacker):
    def __init__(self, apk_obj: APK, dvms):
        super().__init__(
            "loader.multidex.header", "Unpacker for multidex", apk_obj, dvms
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        self.brute_assets()

    def brute_assets(self):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.read_size_append_dex(f):
                self.logger.info("Decryption finished! unpacked.dex")
                return self.decrypted_payload_path
        return None

    def read_size_append_dex(self, file_data):
        # dex_header_size_off = 0x20
        if len(file_data) <= 0x20 - 3 + 4:
            return
        size = struct.unpack("<I", file_data[0x20 - 3 : 0x20 - 3 + 4])[0]
        if len(file_data) + 3 != size:
            return
        file_data = b"dex" + file_data
        if self.check_and_write_file(file_data):
            return True
        return False

```

`src/kavanoz/loader/old_rc4.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
import re
from arc4 import ARC4
from kavanoz.unpack_plugin import Unpacker


class LoaderOldRc4(Unpacker):
    def __init__(self, apk_obj, dvms):
        super().__init__(
            "loader.rc4.v2", "Unpacker old rc4 based variants", apk_obj, dvms
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        application_oncreate = self.find_application_oncreate()
        if not application_oncreate:
            return
        rc4_caller = self.find_caller_rc4_init(application_oncreate)
        if not rc4_caller:
            return
        rc4_inits = self.get_rc4_init_from_caller(rc4_caller)
        for rc4_init in rc4_inits:
            rc4_keys = self.get_rc4_key(rc4_init)
            for rc4_key in rc4_keys:
                x = self.brute_assets(rc4_key)
                if x != None:
                    return

    def get_rc4_key(self, rc4_init_function):
        klass_name, method_name = rc4_init_function.split("->")
        m = self.find_method(klass_name, method_name, descriptor="()V")
        if m:
            self.logger.info(m.get_name())
            array_data = self.get_array_data(m)
            if len(array_data) > 1:
                self.logger.info("Found multiple array data, might be wrong function")
            return array_data
        return []

    def get_rc4_init_from_caller(self, class_func_str) -> list:
        klass_name, method_name = class_func_str.split("->")
        m = self.find_method(klass_name, method_name, "(Landroid/app/Application;)V")
        if m == None:
            return []
        self.logger.info("Found rc4 init method")
        """
        public void xVKoMuDKBel(Application application) {
            yQuzIA();

        invoke-direct v11, Lcom/tnmwagts/rmorecegr/MPqJcHURCv;->yQuzIA()V
        """
        smali_str = self.get_smali(m)
        # find functions without parameters.
        match = re.findall(r"invoke-direct [vp]\d+, (L[^;]+;->[^\s]+)\(\)V", smali_str)
        if len(match) == 0:
            self.logger.info("Unable to extract variable from target_method")
            self.logger.info("Exiting ...")
            return []
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
        else:
            self.logger.info("Found multiple functions to call rc4_init ðŸ¤”")
        return match
        return []

    def find_application_oncreate(self):
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            return None
        # self.logger.info(f"application android:name = {application}")
        application_smali = "L" + application.replace(".", "/") + ";"
        return self.find_method(application_smali, "onCreate")

    def find_caller_rc4_init(self, target_method):
        """
        invoke-virtual v2, v6, Lcom/tnmwagts/rmorecegr/MPqJcHURCv;->xVKoMuDKBel(Landroid/app/Application;)V
        """
        smali_str = self.get_smali(target_method)
        match = re.findall(
            r"invoke-virtual [vp]\d+, [vp]\d+, (L[^;]+;->[^\s]+)\(Landroid/app/Application;\)V\s+",
            smali_str,
        )
        if len(match) == 0:
            self.logger.info("Unable to extract variable from target_method")
            self.logger.info("Exiting ...")
            return None
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
            return match[0]
        else:
            self.logger.info("Something is wrong .. ðŸ¤”")
            self.logger.info("Found multiple ?? : {match}")
            return None

    def brute_assets(self, key: bytes):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key, filepath):
                self.logger.info(f"Decryption finished! {self.decrypted_payload_path}")
                return self.decrypted_payload_path
        self.logger.info(f"No valid file found for {key}")
        return None

    def solve_encryption(self, file_data, key: bytes, filepath: str):
        arc4 = ARC4(bytes(key))
        filesize = int.from_bytes(file_data[0:4], byteorder="little")
        if filesize > len(file_data):
            return False
        decrypted = arc4.decrypt(file_data[4:])
        decrypted = decrypted[:filesize]
        if self.check_and_write_file(decrypted):
            return True
        return False

```

`src/kavanoz/loader/rc4.py`:

```py
from datetime import datetime
from androguard.core.bytecodes.apk import APK
from arc4 import ARC4
from androguard.core.bytecodes.dvm import DalvikVMFormat
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
import string


class LoaderRc4(Unpacker):
    regex_class = Regexs()
    rc4_string_var = ""
    first_inner = []
    second_inner = []
    byte_array_data = []
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.rc4.v1", "Unpacker rc4 based variants", apk_object, dvms
        )

    def start_decrypt(self):
        self.second_inner_regex = self.regex_class.get_second_inner_regex()
        self.first_encryption_route = self.regex_class.get_encrytion_route_regex()
        self.key_class_regex = self.regex_class.get_key_class_regex()
        self.logger.info("Starting to decrypt")
        self.attach_class = self.find_attach_class()
        if self.attach_class is None:
            return
        all_possible_rc4_keys = self.find_rc4_keys_from_attach_class(self.attach_class)
        self.logger.info(f"all possible keys : {all_possible_rc4_keys}")
        if all_possible_rc4_keys:
            if self.decrypt_files(all_possible_rc4_keys):
                # More stages
                if not self.is_really_unpacked():
                    if self.bruteforce_all_strings():
                        self.logger.info("Multiple stage is decrypted")

    def bruteforce_all_strings(self):
        if not self.is_really_unpacked():
            all_possible_rc4_keys = self.find_all_strings(self.dvms[-1])
            if self.decrypt_files(all_possible_rc4_keys):
                return self.bruteforce_all_strings()
            else:
                return False
        else:
            return True

    def find_attach_class(self):
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            return None
        # self.logger.info(f"application android:name = {application}")
        application_smali = "L" + application.replace(".", "/") + ";"
        target_method = self.find_method(application_smali, "attachBaseContext")
        return target_method

    def find_rc4_keys_from_attach_class(self, target_method):
        smali_str = self.get_smali(target_method)
        match = self.first_encryption_route.findall(smali_str)
        if len(match) == 0:
            self.logger.info(f"Unable to extract variable from {target_method}")
            self.logger.info("Exiting ...")

        if len(match) == 1:
            # self.logger.info(f'HMM : {match[0]}')
            method = self.find_method(target_method.get_class_name(), match[0])
            if method == None:
                return
            smali_str = self.get_smali(method)
            # self.logger.info(smali_str)
            key_class = self.key_class_regex.findall(smali_str)
            if len(key_class) != 1:
                return
            self.logger.info(f"Key class : {key_class[0]}")
            klass = self.find_class_in_dvms(key_class[0][2])
            if klass == None:
                return
            return self.find_rc4_keys_from_klass_fields(klass)

    def find_all_strings(self, dvm: DalvikVMFormat) -> set:
        all_rc4_keys = set()
        for klass in dvm.get_classes():
            all_rc4_keys.update(self.find_rc4_keys_from_klass_fields(klass))
        return all_rc4_keys

    def find_rc4_keys_from_klass_fields(self, klass) -> set:
        all_possible_rc4_keys = set()
        for field in klass.get_fields():
            rc4_string_variable = None
            if field.get_descriptor() != "Ljava/lang/String;":
                continue
            if field.get_init_value() != None and field.get_init_value != "":
                self.logger.info(
                    f"Found static key : {field.get_init_value().get_value()}"
                )
                static_rc4_string = field.get_init_value().get_value()
                r = set()
                r.add(static_rc4_string)
                return r
            else:
                if (
                    "0x0" == field.get_access_flags_string()
                    or "protected final" == field.get_access_flags_string()
                    or "" == field.get_access_flags_string()
                ):
                    rc4_string_variable = field.get_name()
            if rc4_string_variable is not None:
                self.regex_class.set_first_inner_regex(rc4_string_variable)
                all_possible_rc4_keys.update(self.get_key_from_init(klass))
        return all_possible_rc4_keys

    def get_key_from_init(self, klass) -> set:
        """
        String field is calculated with two inner functions.
        Example :
            - String SAsDiYdEsXlNsTnXkKoYoSmZp = derivetrouble(new String[98]);
            - static String derivetrouble(String[] strArray) {
                return leaveangry();
              }
            - public static String leaveangry() {
                    byte[] bArr = {11, 63, 45, 21};
                    byte[] bArr2 = new byte[4];
                    byte[] bArr3 = {79};
                    while (i8 < 4) {
                        bArr2[i8] = (byte) (bArr[i8] ^ bArr3[i8 % 1]);
                        i8++;
                    }
                    return new String(bArr2);
                }
        We try to find second inner function that generates rc4 key
        """
        possible_rc4_keys = set()
        string_gen_0 = []
        klass_name = klass.get_name()
        init_method = self.find_method(klass_name, "<init>")
        if not init_method:
            return possible_rc4_keys
        smali_str = self.get_smali(init_method)
        for key, regex in self.regex_class.get_first_inner_regexs().items():
            string_gen_0 = regex.findall(smali_str)
            if string_gen_0:
                break
        if string_gen_0:
            self.logger.info(f"First inner function: {string_gen_0[0]}")
            string_gen_1 = []
            # Find function that uses first found function
            first_method = self.find_method(klass_name, string_gen_0[0])
            if not first_method:
                return possible_rc4_keys
            smali_str = self.get_smali(first_method)
            string_gen_1 = self.second_inner_regex.findall(smali_str)
            if not string_gen_1:
                self.logger.info(
                    f"Unable to extract second inner function from {first_method.get_name()}"
                )
                self.logger.info("Checking if we are already in the last function")
                rc4_keys = self.generate_rc4_keys_from_method(first_method)
                possible_rc4_keys.update(rc4_keys)

            else:
                self.logger.info(f"Second inner function: {string_gen_1[0]}")
                if string_gen_1:
                    second_method = self.find_method(klass_name, string_gen_1[0])
                    if second_method:
                        rc4_keys = self.generate_rc4_keys_from_method(second_method)
                        possible_rc4_keys.update(rc4_keys)
        else:
            self.logger.info("Unable to extract first inner function")

        return possible_rc4_keys

    def generate_rc4_keys_from_method(self, method) -> set:
        """
        Extract array data from target method. Generaly packer generates rc4 key from two array data.
        Or defines constant string.
        First regex captures string,
        """
        # self.logger.info(self.get_smali(method))
        smali = self.get_smali(method)
        match = re.findall(
            r"const-string [vp]\d+, \'(.*?)\'\s+" r"return-object [vp]\d+", smali
        )
        if len(match) == 1:
            self.logger.info(match)
            # self.decrypt_files([match[0]])
            r = set()
            k = match[0]
            if type(k) is bytes or type(k) is str:
                r.add(k)
                return r

        arrays_in_method = self.get_array_data(method)
        if len(arrays_in_method) < 2:
            return set()
        if len(arrays_in_method) > 2:
            self.logger.info(
                f"We have {len(self.byte_array_data)} byte arrays, so gonna brute force little bit"
            )
        if len(arrays_in_method) == 2:
            self.logger.info(
                f"RC4 key generators : {arrays_in_method[0]} - {arrays_in_method[1]}"
            )
        rc4_keys = self.get_all_rc4_keys(arrays_in_method)
        return rc4_keys

    def decrypt_files(self, rc4key):
        for filepath in self.apk_object.get_files():
            fd = self.apk_object.get_file(filepath)
            for rc4k in rc4key:
                dede = ARC4(rc4k)
                dec = dede.decrypt(fd[:8])
                if self.check_header(dec):
                    dede = ARC4(rc4k)
                    dec = dede.decrypt(fd)
                    if self.check_and_write_file(dec):
                        self.logger.info(
                            f"Decrypted dex is from {filepath} with key {rc4k}"
                        )
                        return True
        return False

    def get_all_rc4_keys(self, keys: list) -> set:
        rc4_key = set()
        if len(keys) > 2:
            # combinartion of keys
            comb = combinations(keys, 2)
            rc4_key = set()
            for k in comb:
                rc4_key.add(self.generate_rc4_key(k[0], k[1], True))
            for k in keys:
                rc4_key.add(bytes(k))
        else:
            rc4_key.add(self.generate_rc4_key(keys[0], keys[1]))
            rc4_key.add(self.generate_rc4_key(keys[0], keys[1], True))
        return rc4_key

    def generate_rc4_key(self, key0, key1, without_arrange=False):

        big_key = key0 if len(key0) > len(key1) else key1
        smol_key = key0 if len(key0) < len(key1) else key1
        rc4_key = bytearray()
        for i in range(len(big_key)):
            zz = big_key[i] ^ smol_key[i % len(smol_key)]
            rc4_key.append(zz)

        if without_arrange:
            rc4_key = bytearray()
            for i in range(len(key0)):
                rc4_key.append(key0[i] ^ key1[i % len(key1)])
            return bytes(rc4_key)
        return bytes(rc4_key)

```

`src/kavanoz/loader/sesdex.py`:

```py
from datetime import datetime
from androguard.core.bytecodes.apk import APK
from arc4 import ARC4
from androguard.core.bytecodes.dvm import DalvikVMFormat
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor


"""
invoke-virtual v8, v2, Ljava/io/InputStream;->read([B)I
const-string v5, 'bhMIAdCgBYYOymrlRp'
invoke-virtual v5, Ljava/lang/String;->getBytes()[B
move-result-object v5
invoke-static v2, v5, Lorvbreo/ycmgmee;->ZowuWxil([B [B)[B
move-result-object v2
invoke-virtual v8, Ljava/io/InputStream;->close()V
"""

find_xor_key = (
    r"invoke-virtual [vp]\d+, [vp]\d+, L[^;]+;->read\(\[B\)I\s+"
    r"const-string [vp]\d+, '(.*)'\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->([^\(]+)\(\[B \[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->close\(\)V\s+"
)

find_second_xor_key = (
    r"const-string [vp]\d+, '(.*)'\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->([^\(]+)\(\[B \[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, [vp]\d+, L[^;]+;->write\(\[B\)V\s+"
)


class LoaderSesdex(Unpacker):
    regex_class = Regexs()
    rc4_string_var = ""
    first_inner = []
    second_inner = []
    byte_array_data = []
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.sesdex", "Unpacker for unknown adware malware", apk_object, dvms
        )

    def start_decrypt(self):
        self.second_inner_regex = self.regex_class.get_second_inner_regex()
        self.first_encryption_route = self.regex_class.get_encrytion_route_regex()
        self.key_class_regex = self.regex_class.get_key_class_regex()
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

        for filepath in self.apk_object.get_files():
            second_xor_key = self.find_second_xor_key()
            if second_xor_key:
                self.decrypt_files(second_xor_key)

    def find_xor_key(self):
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            return None
        # self.logger.info(f"application android:name = {application}")
        application_smali = "L" + application.replace(".", "/") + ";"
        target_method = self.find_method_re(
            application_smali, ".*", "(Ljava/io/InputStream;)Ljava/io/File;"
        )
        if target_method == None:
            return
        sm = self.get_smali(target_method)
        if "ses.dex" not in sm:
            return
        m = re.findall(find_xor_key, sm)
        if len(m) == 1:
            return bytes(m[0][0].encode("utf-8"))
        else:
            return

    def find_second_xor_key(self):
        if self.decrypted_payload_path == None:
            return
        with open(self.decrypted_payload_path, "rb") as fp:
            d = fp.read()
            dvm = DalvikVMFormat(d)
            for c in dvm.get_classes():
                if c.get_superclassname() == "Landroid/app/Application;":
                    for m in c.get_methods():
                        if m.get_name() == "onCreate":
                            sm = self.get_smali(m)
                            matches = re.findall(find_second_xor_key, sm)
                            if matches:
                                return matches[0][0].encode("utf-8")

    def decrypt_files(self, xor_key):
        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderSimple(Unpacker):
    def __init__(self, apk_obj: APK, dvms):
        super().__init__("loader.simple", "Simple methods to unpack", apk_obj, dvms)

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        package_name = self.apk_object.get_package()
        self.decrypted_payload_path = None
        if package_name != None:
            if self.brute_assets(package_name):
                return

    def brute_assets(self, key: str):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.try_one_byte_xor(f):
                return self.decrypted_payload_path
        return None

    def try_one_byte_xor(self, file_data):
        for k in range(1, 256):
            xored_data = xor(file_data[:16], k.to_bytes(1, "little"))
            if not self.check_header(xored_data):
                continue
            self.logger.info(f"Found single byte xor key : {k}")
            xored_data = xor(file_data, k.to_bytes(1, "little"))
            if self.check_and_write_file(xored_data):
                return True
        return False

```

`src/kavanoz/loader/simple_aes.py`:

```py
from Crypto.Cipher import AES
import base64
from datetime import datetime
from androguard.core.bytecodes.apk import APK
from arc4 import ARC4
from androguard.core.bytecodes.dvm import DalvikVMFormat
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor


"""
invoke-direct v2, v0, v3, Ljava/io/File;-><init>(Ljava/io/File; Ljava/lang/String;)V
invoke-direct v7, v8, v1, v2, Lbtewtslyl/vmcdkpllfzrvt/u5a48eebb7c1d4;->a(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;)Z
new-instance v3, Ldalvik/system/DexClassLoader;
"""
find_aes_function = (
    r"invoke-direct [vp]\d+, [vp]\d+, [vp]\d+, Ljava/io/File;-><init>\(Ljava/io/File; Ljava/lang/String;\)V\s+"
    r"invoke-direct [vp]\d+, [vp]\d+, [vp]\d+, [vp]\d+, (L[^;]+;->[^\(]+)\(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;\)Z\s+"
    r"new-instance [vp]\d+, Ldalvik/system/DexClassLoader;"
)
"""
new-instance v2, Ljavax/crypto/CipherInputStream;
const-string v3, '7RHkUDPB5fGL4NLPDuehSRjnxYGr0I7KmsqAUwLT1sk='
invoke-direct v4, v3, Lbtewtslyl/vmcdkpllfzrvt/u5a48eebb7c1d4;->a(Ljava/lang/String;)Ljavax/crypto/Cipher;
move-result-object v3
"""

find_aes_key = (
    r"new-instance [vp]\d+, Ljavax/crypto/CipherInputStream;\s+"
    r"const-string [vp]\d+, '(.*)'\s+"
    r"invoke-direct [vp]\d+, [vp]\d+, L[^;]+;->[^\(]+\(Ljava/lang/String;\)Ljavax/crypto/Cipher;\s+"
    r"move-result-object [vp]\d+"
)


class LoaderSimpleAes(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.simpleaes",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.aes_key = self.find_aes_key()
        if self.aes_key is None:
            return
        self.decrypt_files(self.aes_key)

    def find_aes_key(self):
        asset_filenames = [
            x.replace("assets/", "")
            for x in self.apk_object.get_files()
            if x.startswith("assets/")
        ]
        for d in self.dvms:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor() == "(Landroid/content/Context;)V"
                        and m.get_name() == "<init>"
                    ):
                        m_smali = self.get_smali(m)
                        for fname in asset_filenames:
                            if fname in m_smali:
                                self.logger.info("Found method")
                                target_method = m
                                m = re.findall(find_aes_function, m_smali)
                                klass, method = m[0].split("->")
                                target_method = self.find_method(
                                    klass,
                                    method,
                                    "(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;)Z",
                                )
                                if target_method:
                                    aes_key = re.findall(
                                        find_aes_key, self.get_smali(target_method)
                                    )
                                    if aes_key:
                                        return aes_key[0]

        return None

    def decrypt_files(self, aes_key):
        try:
            kk = base64.b64decode(aes_key)
        except Exception as e:
            self.logger.error(e)
            return

        key = kk[:16]
        iv = kk[16:32]
        ai = AES.new(key, AES.MODE_CBC, iv)
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = ai.decrypt(fd)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple_xor.py`:

```py
import re
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor

"""
invoke-direct v10, v14, v15, Ljava/lang/Long;-><init>(J)V
const/4 v9, 0
array-length v13, v4
if-ge v9, v13, +3f
aget-byte v13, v4, v9
const-string v14, 'pAinaTuyPSZcNjEbewHmUaUiFLzjnb'
invoke-virtual v14, Ljava/lang/String;->getBytes()[B
move-result-object v14
invoke-virtual v10, Ljava/lang/Long;->longValue()J
move-result-wide v16
move-wide/from16 v0, v16
long-to-int v15, v0
aget-byte v14, v14, v15
xor-int/2addr v13, v14
int-to-byte v13, v13
aput-byte v13, v8, v9
"""

find_xor_key = (
    r"const/4 [vp]\d+, 0\s+"
    r"array-length [vp]\d+, [vp]\d+\s+"
    r"if-ge [vp]\d+, [vp]\d+, \+3f\s+"
    r"aget-byte [vp]\d+, [vp]\d+, [vp]\d+\s+"
    r"const-string [vp]\d+, '(.*)'\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->longValue\(\)J\s+"
)


class LoaderSimpleXor(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.simplexor",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

    def find_xor_key(self):
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            return None
        # self.logger.info(f"application android:name = {application}")
        application_smali = "L" + application.replace(".", "/") + ";"
        target_method = self.find_method(application_smali, "attachBaseContext")
        if target_method == None:
            return
        sm = self.get_smali(target_method)
        m = re.findall(find_xor_key, sm)
        if len(m) == 1:
            return bytes(m[0].encode("utf-8"))
        else:
            return

    def decrypt_files(self, xor_key):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple_xor_zlib.py`:

```py
import base64
import re
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor
import zlib


class LoaderSimpleXorZlib(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.simplexor",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.decrypt_files()

    def decrypt_files(self):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not filepath.startswith("assets"):
                continue
            fd = self.apk_object.get_file(filepath)
            if len(fd) < 8:
                return False
            if fd[4] == 0x78 and fd[5] == 0x9C:
                try:
                    dec = zlib.decompress(fd[4:])
                except Exception as e:
                    self.logger.error(e)
                    return False
            else:
                xor_k = fd[4]
                zlib_d = fd[5:]
                dec = xor(zlib_d, xor_k.to_bytes(1, "little"))
                if dec[:2] != b"\x78\x01":
                    return
                try:
                    dec = zlib.decompress(dec)
                except Exception as e:
                    self.logger.error(e)
                    return

            try:
                dec = base64.b64decode(dec)
            except Exception as e:
                self.logger.error(e)
                return
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simply_xor2.py`:

```py
from datetime import datetime
from androguard.core.bytecodes.apk import APK
from arc4 import ARC4
from androguard.core.bytecodes.dvm import DalvikVMFormat
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor

"""
array-length v0, v3
new-array v0, v0, [B
const/4 v1, 0
array-length v2, v3
if-ge v1, v2, +c
aget-byte v2, v3, v1
xor-int/lit8 v2, v2, -43
int-to-byte v2, v2
aput-byte v2, v0, v1
add-int/lit8 v1, v1, 1
goto -c
return-object v0
"""

find_xor_key = r"xor-int/lit8 [vp]\d+, [vp]\d+, (-?\d+)"
"""
invoke-virtual v0, v2, Ljava/io/InputStream;->read([B)I
invoke-virtual v0, Ljava/io/InputStream;->close()V
invoke-static v2, Lcom/squareup/leakcanary/gutG;->XdB([B)[B
move-result-object v0
invoke-virtual v6, v0, Ljava/io/FileOutputStream;->write([B)V
invoke-virtual v6, Ljava/io/FileOutputStream;->close()V
"""
find_xor_function = (
    r"invoke-virtual [vp]\d+, [vp]\d+, Ljava/io/InputStream;->read\(\[B\)I\s+"
    r"invoke-virtual [vp]\d+, Ljava/io/InputStream;->close\(\)V\s+"
    r"invoke-static [vp]\d+, (L[^;]+;->[^\(]+)\(\[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, [vp]\d+, Ljava/io/FileOutputStream;->write\(\[B\)V\s+"
)


class LoaderSimpleXor2(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms):
        super().__init__(
            "loader.simplexor2",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

    def find_xor_key(self):
        asset_filenames = [
            x.replace("assets/", "")
            for x in self.apk_object.get_files()
            if x.startswith("assets/")
        ]
        for d in self.dvms:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Landroid/content/Context;)Ljava/io/File;"
                    ):
                        m_smali = self.get_smali(m)
                        for fname in asset_filenames:
                            if fname in m_smali:
                                matches = re.findall("[a-f0-9]+\.dex", m_smali)
                                if len(matches) == 0:
                                    self.logger.info("no match")
                                    return
                                self.logger.info("Found method")
                                target_method = m
                                m = re.findall(find_xor_function, m_smali)
                                klass, method = m[0].split("->")
                                target_method = self.find_method(klass, method)
                                if target_method:
                                    xor_key = re.findall(
                                        find_xor_key, self.get_smali(target_method)
                                    )
                                    if xor_key:
                                        n = int(xor_key[0])
                                        n = n & 0xFF
                                        self.logger.info(f"Found single xor key : {n}")
                                        return n.to_bytes(1, "little")
        return None

    def decrypt_files(self, xor_key):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/subapp.py`:

```py
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderSubapp(Unpacker):
    def __init__(self, apk_obj: APK, dvms):
        super().__init__(
            "loader.subapp", "Unpacker for chinese packer1, Beingyi", apk_obj, dvms
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        package_name = self.apk_object.get_package()
        self.decrypted_payload_path = None
        if package_name != None:
            self.brute_assets(package_name)

    def brute_assets(self, key: str):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key):
                self.logger.info("Decryption finished! unpacked.dex")
                return self.decrypted_payload_path
        return None

    def solve_encryption(self, file_data, key):
        if len(key) < 3 or len(file_data) < 3:
            return False
        xored_h = file_data[0] ^ key[0].encode("utf-8")[0]
        xored_h2 = file_data[1] ^ key[1].encode("utf-8")[0]
        xored_h3 = file_data[2] ^ key[2].encode("utf-8")[0]
        if xored_h != ord("d") or xored_h2 != ord("e") or xored_h3 != ord("x"):
            return False
        xored_data = xor(file_data, key.encode("utf-8"))
        if self.check_and_write_file(xored_data):
            return True
        return False

```

`src/kavanoz/plugin_loader.py`:

```py
import sys
import pkgutil
import importlib
from pathlib import Path
from kavanoz.unpack_plugin import Unpacker

PLUGIN_DIRECTORY = Path(__file__).parent / "loader"
BLACKLISTED_KEYS = (
    "__name__",
    "__doc__",
    "__package__",
    "__loader__",
    "__spec__",
    "__file__",
    "__cached__",
    "__builtins__",
)


def dicover_plugins(path: Path):
    posix_path = PLUGIN_DIRECTORY.as_posix()
    if posix_path not in sys.path:
        sys.path.append(posix_path)

    iter_from = [posix_path]
    for finder, name, ispkg in pkgutil.iter_modules(iter_from):
        yield name


def import_plugin(module_name: str) -> list[Unpacker]:
    module = importlib.import_module(module_name)
    module_dict = module.__dict__

    check_in = None

    if "__all__" in module_dict:
        check_in = {
            key: module_dict[key]
            for key in module_dict["__all__"]
            if key in module_dict
        }
    else:
        check_in = {
            key: val for key, val in module_dict.items() if key not in BLACKLISTED_KEYS
        }

    valid_items = [
        mod
        for inner_module_name in check_in
        if (mod := module_dict[inner_module_name])
        and inner_module_name.startswith("Loader")
        and issubclass(mod, Unpacker)
    ]

    if not valid_items:
        del sys.modules[module_name]
        return None
    else:
        return valid_items


def get_plugins():
    for plugin in dicover_plugins(PLUGIN_DIRECTORY):
        yield import_plugin(plugin)

```

`src/kavanoz/smali_regexes.py`:

```py
import re
class Regexs:

    def __init__(self):
        self.first_inner_regex = {}

    def set_first_inner_regex(self, rc4_string_var: str):
        # invoke-static v0, Lcom/huge/dragon/DEdEoXwGgUxOmDnIdQiBhAeDwDbFbByQwQfQtYuWk;->meattool(B)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lcom/huge/dragon/DEdEoXwGgUxOmDnIdQiBhAeDwDbFbByQwQfQtYuWk;->XZkYqPfMoCcNtMzDiIpGaYlRuDjFeZfMtPcSq Ljava/lang/String;

        first_inner_first_variant = rf"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\w*\)+Ljava/lang/String;\s+" \
                                    "move-result-object [vp]\d+\s+" \
                                    f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"

        # invoke-static Lsquare/ivory/purchase/YKxOcNuRkOlYhOySzZjCsYqLcJkYuUlJdTfTqMeMgXuOnUzEjNiSs;->antiquehello()Ljava/lang/StringBuilder;
        # move-result-object v0
        # invoke-static v0, Ljava/lang/String;->valueOf(Ljava/lang/Object;)Ljava/lang/String;

        first_inner_second_variant = r"invoke-static L[^;]+;->([^\(]+)\(\w*\)+Ljava/lang/StringBuilder;\s+" \
                                     r"move-result-object [vp]\d+\s+" \
                                     r"invoke-static [vp]\d+, Ljava/lang/String;->valueOf\(Ljava/lang/Object;\)Ljava/lang/String;\s+" \
                                     r"move-result-object [vp]\d+\s+" \
                                     fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"

        first_inner_six_variant = r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\w*\)+Ljava/lang/StringBuilder;\s+" \
                                  r"move-result-object [vp]\d+\s+" \
                                  r"invoke-static [vp]\d+, Ljava/lang/String;->valueOf\(Ljava/lang/Object;\)Ljava/lang/String;\s+" \
                                  r"move-result-object [vp]\d+\s+" \
                                  fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        nine = r"invoke-static L[^;]+;->([^\(]+)\(\)+Ljava/lang/StringBuilder;\s+" \
               r"move-result-object [vp]\d+\s+" \
               r"invoke-virtual [vp]\d+, Ljava/lang/StringBuilder;->toString\(\)Ljava/lang/String;\s+" \
               r"move-result-object [vp]\d+\s+" \
               fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        # invoke-static Lcom/marine/build/NKlIyWrPrYoKzZyRtDsOnKnJtNkNcEoOePzLtNg;->dressraccoon()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lcom/marine/build/NKlIyWrPrYoKzZyRtDsOnKnJtNkNcEoOePzLtNg;->QFxOwNaMaJqTgNdOhOc Ljava/lang/String;

        first_inner_third_variant = "invoke-static L[^;]+;->([^\(]+)\(\w*\)Ljava\/lang\/String;\s+" \
                                    "move-result-object [vp]\d+\s+" \
                                    f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"

        first_inner_seven_variant = "invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/lang/String;\)Ljava\/lang\/String;\s+" \
                                    "move-result-object [vp]\d+\s+" \
                                    f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        ten_variant = r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\[I\)Ljava\/lang\/String;\s+" \
                                    "move-result-object [vp]\d+\s+" \
                                    f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"

        #invoke-static {v0}, Lcom/frog/assault/ZQwAlNnFmAdZiOe;->corespy([Ljava/lang/String;)Ljava/lang/String;
        #move-result-object v0
        #iput-object v0, p0, Lcom/frog/assault/ZQwAlNnFmAdZiOe;->OPxNlTsOuSiJtOg:Ljava/lang/String;
        eleven_variant = r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\[Ljava/lang/String;\)Ljava\/lang\/String;\s+" \
                                    r"move-result-object [vp]\d+\s+" \
                                    rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        # invoke-static v0, Ljknl/bgdfdntrwerlfwaxohrcyamosg/rathpswbuyyukhdihs/Qreunionscience;->symbolraise(Ljava/lang/Boolean;)Ljava/lang/StringBuffer;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuffer;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v4, Ljknl/bgdfdntrwerlfwaxohrcyamosg/rathpswbuyyukhdihs/Qreunionscience;->Salterrail Ljava/lang/String;
        first_inner_fourth_variant = r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/lang/Object\)Ljava/lang/StringBuffer;\s+" \
                                     r"move-result-object [vp]\d+\s+" \
                                     r"invoke-virtual [vp]\d+, Ljava/lang/StringBuffer;->toString\(\)Ljava/lang/String;\s+" \
                                     r"move-result-object [vp]\d+\s+" \
                                     fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"

        # invoke-static Lrecall/promote/hidden/IYmMtEjAhYyTpQz;->incomeagain()Ljava/lang/StringBuffer;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuffer;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lrecall/promote/hidden/IYmMtEjAhYyTpQz;->QOlUeNyKnHtWmHdEnUs Ljava/lang/String;

        first_inner_fifth_variant = r"invoke-static L[^;]+;->([^\(]+)\(\)Ljava/lang/StringBuffer;\s+" \
                                    r"move-result-object [vp]\d+\s+" \
                                    r"invoke-virtual [vp]\d+, Ljava/lang/StringBuffer;->toString\(\)Ljava/lang/String;\s+" \
                                    r"move-result-object [vp]\d+\s+" \
                                    fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        # invoke-static v0, Lpousozuqamiyngkkoczbahranxo/efcwgecwerpfesmilxxmkco/tpqbn/Pwrongmatch;->trialalert(Z)Ljava/lang/StringBuilder;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v4, Lpousozuqamiyngkkoczbahranxo/efcwgecwerpfesmilxxmkco/tpqbn/Pwrongmatch;->Qtwintattoo Ljava/lang/String;

        first_inner_eight_variant = r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Z\)Ljava/lang/StringBuilder;\s+" \
                                    r"move-result-object [vp]\d+\s+" \
                                    r"invoke-virtual [vp]\d+, Ljava/lang/StringBuilder;->toString\(\)Ljava/lang/String;\s+" \
                                    r"move-result-object [vp]\d+\s+" \
                                    fr"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        self.first_inner_regex["first_variant"] = re.compile(first_inner_first_variant)
        self.first_inner_regex["second_variant"] = re.compile(first_inner_second_variant)
        self.first_inner_regex["third_variant"] = re.compile(first_inner_third_variant)
        self.first_inner_regex["fourth_variant"] = re.compile(first_inner_fourth_variant)
        self.first_inner_regex["fifth_variant"] = re.compile(first_inner_fifth_variant)
        self.first_inner_regex["six_variant"] = re.compile(first_inner_six_variant)
        self.first_inner_regex["seven_variant"] = re.compile(first_inner_seven_variant)
        self.first_inner_regex["eight_variant"] = re.compile(first_inner_eight_variant)
        self.first_inner_regex["nine_variant"] = re.compile(nine)
        self.first_inner_regex["ten_variant"] = re.compile(ten_variant)
        self.first_inner_regex["eleven_variant"] = re.compile(eleven_variant)

    def get_first_inner_regexs(self) -> dict:
        return self.first_inner_regex

    @staticmethod
    def get_encrytion_route_regex() -> re:
        first_encrytion_route = "invoke-virtual [vp]\d+, [vp]\d+, L[^\s]+;->([^\s]+)\(Ljava/lang/String;\)Z"
        return re.compile(first_encrytion_route)

    @staticmethod
    def get_key_class_regex() -> re:
        '''
        iput-object v0, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->PTuCuGcNoJqKpAnWyFoNfHoSj Landroid/content/Context;
        iget-object v0, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->PTuCuGcNoJqKpAnWyFoNfHoSj Landroid/content/Context;
        iget-object v1, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->HLcJdEiQiGcGpHyIwXrTiXuQiLqIaRgGt Ljava/lang/String;
        invoke-static v5, v0, v1, Lsolve/expect/water/GKfMeQmSxLkSzNmFoUhBxJrOjAiRsAyGbThJnQhOkNiRuIxUf;->shrugbalcony(Ljava/lang/String; Landroid/content/Context; Ljava/lang/String;)Z
        move-result v5
        return v5
        '''
        key_class_regex = r"invoke-(virtual|static) ([vp]\d+, ){3,4}(L[^\(]+;)->[^\(]+\(Ljava/lang/String; Landroid/content/Context; Ljava/lang/String;\)Z\s+" \
                          r"move-result [vp]\d+\s+" \
                          r"return [vp]\d+"
        return re.compile(key_class_regex)

    @staticmethod
    def get_second_inner_regex():
        second_inner = "invoke-static L[^\(]+;->([^\(]+)\(\)Ljava/lang/String;"
        return re.compile(second_inner)
```

`src/kavanoz/unpack_plugin.py`:

```py
from androguard.core.bytecodes.apk import APK
import re
from androguard.core.bytecodes.dvm import DalvikVMFormat, EncodedMethod, ClassDefItem
import time
import io
import zipfile
import hashlib
import zlib
from kavanoz.utils import dex_headers, pkzip_headers, zlib_headers
from loguru import logger


class Unpacker:

    tag = "DefaultUnpackPlugin"
    name = "DefaultUnpackName"

    def __init__(
        self, tag: str, name: str, apk_object: APK, dvms: list[DalvikVMFormat]
    ):
        """Default unpacking plugin"""
        self.tag = tag
        self.name = name
        self.decrypted_payload_path = None
        self.logger = logger
        self.apk_object = apk_object
        self.dvms = list(filter(self.filter_dvms, dvms))

    @staticmethod
    def filter_dvms(dvm):
        if dvm.classes == None:
            return False
        return True

    def is_packed(self) -> bool:
        """Checks if apk is packed by checking components defined in AndroidManifest.xml is present in dex

        :returns ispacked: Is apk packed
        :rtype:bool
        """
        ispacked = False
        not_found_counter = 0
        act_serv_recv = (
            self.apk_object.get_activities()
            + self.apk_object.get_receivers()
            + self.apk_object.get_services()
        )
        for component in act_serv_recv:
            if component:
                for dex in self.dvms:
                    try:
                        dex_classes = dex.get_classes_names()
                    except Exception as e:
                        continue
                    clas_name = "L" + component.replace(".", "/") + ";"
                    if clas_name in dex_classes:
                        break
                else:
                    not_found_counter += 1

        score = not_found_counter / len(act_serv_recv)
        if score > 0.80:
            self.logger.info(f"Packed : Score : {score}")
            ispacked = True
        return ispacked

    def is_really_unpacked(self) -> bool:
        """Adds decrypted dex file as dvm and checks if its still packed or not"""
        if not self.decrypted_payload_path:
            return False
        # add last dvm
        with open(self.decrypted_payload_path, "rb") as fp:
            self.dvms.append(DalvikVMFormat(fp.read()))
        return not self.is_packed()

    def get_tag(self) -> str:
        return self.tag

    def get_name(self) -> str:
        return self.name

    def __str__(self):
        return f"Name: {self.name}\nTag: {self.tag}"

    @staticmethod
    def get_smali(target_method: EncodedMethod) -> str:
        """
        Get smali represantation of target_method
        """
        smali_str = ""
        for ins in target_method.get_instructions():
            smali_str += f"{ins.get_name()} {ins.get_output()}\n"
        return smali_str

    @staticmethod
    def get_array_data(target_method: EncodedMethod) -> list:
        """
        Get array data from target_method. This is done via parsing instructions
        """
        barrays = []
        for ins in target_method.get_instructions():
            if ins.get_name() == "fill-array-data-payload":
                # androguard bug
                # 00 03 01 00 07 00 00 00 5e 5a 6a 71 5e 6c 74 00
                # Following code has wrong data, it retusn 0c,00 instead of 0c 00 00
                # 00 03 01 00 02 00 00 00 0c 00
                # ins.get_data also return with \x00 appended, we dont need that
                raw_data = list(ins.get_raw())
                # print(ins.get_raw())
                # print(ins.get_hex())
                # print(ins.get_data())
                data_size = raw_data[4]
                barray = bytearray(raw_data[8 : 8 + data_size])
                barrays.append(barray)
        return barrays

    def find_method(
        self, klass_name: str, method_name: str, descriptor: str = ""
    ) -> EncodedMethod | None:
        """
        Find method in dvms via class name and method name. Descriptor is optional
        :returns EncodedMethod of found method
        """
        for dvm in self.dvms:
            c = dvm.get_class(klass_name)
            if c != None:
                methods = c.get_methods()
                for method in methods:
                    if method.get_name() == method_name:
                        if descriptor == "":
                            return method
                        else:
                            if method.get_descriptor() == descriptor:
                                return method
        return None

    def find_method_re(
        self, klass_name: str, method_name: str, descriptor: str = ""
    ) -> EncodedMethod | None:
        for dvm in self.dvms:
            c = dvm.get_class(klass_name)
            if c != None:
                methods = c.get_methods()
                for method in methods:
                    if len(re.findall(method_name, method.get_name())) > 1:
                        if descriptor == "":
                            return method
                        else:
                            if method.get_descriptor() == descriptor:
                                return method
        return None

    def find_class_in_dvms(self, klass_name: str) -> ClassDefItem | None:
        """Search class name in dvms and return first instance"""
        for dvm in self.dvms:
            c = dvm.get_class(klass_name)
            if c != None:
                return c
        return None

    @staticmethod
    def find_method_in_class_m(klass, method_name):
        """Find method in klass instance."""
        methods = klass.get_methods()
        for method in methods:
            if method.get_name() == method_name:
                return method
        return None

    def lazy_check(self, apk_object: APK, dvms: "list[DalvikVMFormat]") -> bool:
        """Check if this plugin should run. This method shouldn't be heavy."""
        return True

    def calculate_name(self, file_data) -> str:
        """Calculate external dex file name from file data by taking md5 hash of it"""
        m = hashlib.md5(file_data).hexdigest()
        return f"external-{m[:8]}.dex"

    def check_header(self, fd) -> bool:
        """Check if given data contains dex/pkzip/zlib headers"""
        if len(fd) > 7 and fd[:8] in dex_headers:
            return True
        elif len(fd) > 3 and fd[:4] in pkzip_headers:
            return True
        elif len(fd) > 1 and fd[:2] in zlib_headers:
            return True
        return False

    def check_and_write_file(self, dec) -> bool:
        """
        Check headers and write extracted dex to current path. ZIP/Zlib streams is decompressed and first instance of dex file is written.
        """
        if dec[:8] in dex_headers:
            self.decrypted_payload_path = self.calculate_name(dec)
            self.logger.success(
                f"Decryption succesfull! Output dex : {self.decrypted_payload_path}"
            )
            with open(self.decrypted_payload_path, "wb") as fp:
                fp.write(dec)
            return True
        elif dec[:4] in pkzip_headers:
            self.logger.success(f"Decryption succesfull!\t Found zip file")
            with zipfile.ZipFile(io.BytesIO(dec), "r") as drop:
                for file in drop.filelist:
                    with drop.open(file.filename) as f:
                        zip_files_ex = f.read(8)
                        f.seek(0)
                        if zip_files_ex in dex_headers:
                            self.logger.info(
                                f"Extracting dex from zip file. Output dex : {self.decrypted_payload_path}"
                            )
                            file_data = f.read()
                            self.decrypted_payload_path = self.calculate_name(file_data)
                            with open(self.decrypted_payload_path, "wb") as fp:
                                fp.write(file_data)
                            return True
        elif dec[:2] in zlib_headers:
            try:
                decrypted = zlib.decompress(dec)
            except Exception as e:
                self.logger.error(e)
                return False
            if decrypted[:8] in dex_headers:
                self.decrypted_payload_path = self.calculate_name(decrypted)
                self.logger.success(f"Decryption succesfull!\t Found zlib file")
                with open(self.decrypted_payload_path, "wb") as fp:
                    fp.write(decrypted)
                return True
        return False

    def main(self, native_lib: str = "") -> dict:
        """
        Starting point for each plugin. Calls lazy_check then starts start_decrypt. Returns dict of result that contains status, output_file, plugin name and plugin tag
        """
        start_time = time.time()

        result = {}
        result["name"] = self.get_name()
        result["tag"] = self.get_tag()
        if not self.lazy_check(self.apk_object, self.dvms):
            result["status"] = "success" if self.get_status() else "fail"
            return result
        # try:
        o = self.start_decrypt()
        # except Exception as e:
        #    result["error"] = str(e)
        #    result["status"] = "error"
        #    return result

        result["status"] = "success" if self.get_status() else "fail"
        if self.get_status():
            result["output_file"] = self.get_path()
        end_time = time.time()

        self.logger.info(f"total analysis time = {end_time-start_time}")
        return result

    def get_status(self) -> bool:
        """
        Get decryption status by checking decrypted_payload_path
        """
        return self.decrypted_payload_path != None

    def get_path(self) -> str | None:
        """
        Get decrypted_payload_path
        """
        return self.decrypted_payload_path

    def start_decrypt(self):
        """
        Start decryption routine. This should be overwritten
        """
        pass

```

`src/kavanoz/utils.py`:

```py
from itertools import cycle
from loguru import logger
import logging
import sys


def xor(var, key):
    return bytes(a ^ b for a, b in zip(var, cycle(key)))


dex_headers = [
    b"dex\n035\x00",
    b"dex\n036\x00",
    b"dex\n037\x00",
    b"dex\n038\x00",
    b"dex\n039\x00",
    b"dey\n035\x00",
    b"dey\n036\x00",
    b"dey\n037\x00",
    b"dey\n038\x00",
]

pkzip_headers = [
    b"PK\x03\x04",
    b"PK\x05\x06",
    b"PK\x07\x08",
]

zlib_headers = [
    b"\x78\x01",
    b"\x78\x9c",
    b"\x78\x5e",
    b"\x78\xda",
    b"\x78\x20",
    b"\x78\x7d",
    b"\x78\xbb",
    b"\x78\xf9",
]


class InterceptHandler(logging.Handler):
    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
            level = logger.level(record.levelname).name
        except ValueError:
            level = record.levelno

        # Find caller from where originated the logged message.
        frame, depth = sys._getframe(6), 6
        while frame and frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back
            depth += 1

        logger.opt(depth=depth, exception=record.exc_info).log(
            level, record.getMessage()
        )

```

`tests/test.py`:

```py
import unittest
import os
import logging
from loguru import logger
from kavanoz.utils import InterceptHandler

logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)
# logging.getLogger().setLevel(logging.INFO)
# logging.getLogger("androguard").setLevel(logging.CRITICAL)
logger.remove()


from kavanoz.loader.multidex import LoaderMultidex
from kavanoz.loader.old_rc4 import LoaderOldRc4
from kavanoz.loader.rc4 import LoaderRc4
from kavanoz.loader.subapp import LoaderSubapp
from kavanoz.loader.moqhao import LoaderMoqhao
from kavanoz.loader.coper import LoaderCoper
from kavanoz.loader.sesdex import LoaderSesdex
from kavanoz.loader.multidex_header import LoaderMultidexHeader
from kavanoz.loader.simple_xor import LoaderSimpleXor
from kavanoz.loader.simply_xor2 import LoaderSimpleXor2
from kavanoz.loader.simple_xor_zlib import LoaderSimpleXorZlib
from kavanoz.loader.simple_aes import LoaderSimpleAes
from kavanoz.loader.appsealing import LoaderAppsealing
from kavanoz.loader.simple import LoaderSimple
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat


class TestAllLoaders(unittest.TestCase):
    def test_rc4(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(
            os.path.dirname(__file__),
            "./test_apk/loader_rc4_static_key_in_key_class.apk",
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_second_key_0.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_key_0.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms)
        res = rc4.main()
        res = rc4.main()
        assert res["status"] == "success"

        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_multiple_stage.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"

    def test_inflate(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/inflate.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"

    def test_inflate_second(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(
            os.path.dirname(__file__),
            "./test_apk/protect_key_chines_manifest_without_zlib.apk",
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"

    def test_subapp(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/subapp.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderSubapp(apk_object, dvms)
        res = rc4.main()
        assert res["status"] == "success"

    def test_moqhao(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/moqhao.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        moqhao = LoaderMoqhao(apk_object, dvms)
        res = moqhao.main()
        assert res["status"] == "success"

    def test_coper(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/coper.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        coper = LoaderCoper(apk_object, dvms)
        res = coper.main()
        assert res["status"] == "success"

    def test_sesdex(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/sesdex.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        sesdex = LoaderSesdex(apk_object, dvms)
        res = sesdex.main()
        assert res["status"] == "success"

    def test_multidex_header(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/multidex_without_header.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        mwheader = LoaderMultidexHeader(apk_object, dvms)
        res = mwheader.main()
        assert res["status"] == "success"

    def test_simple_xor(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simplexor.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXor(apk_object, dvms)
        res = sxorzlib.main()
        assert res["status"] == "success"

    def test_simple_xor2(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simple_xor2.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        sxor2 = LoaderSimpleXor2(apk_object, dvms)
        res = sxor2.main()
        assert res["status"] == "success"

    def test_simple_xor_zlib(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/simple_xor_zlib_base64.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXorZlib(apk_object, dvms)
        res = sxorzlib.main()
        assert res["status"] == "success"
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/simple_skip4_zlib_base64.apk"
        )
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXorZlib(apk_object, dvms)
        res = sxorzlib.main()
        assert res["status"] == "success"

    def test_simple_aes(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simpleaes.apk")
        apk_object = APK(filename)
        dvms = [DalvikVMFormat(dex) for dex in apk_object.get_all_dex()]
        saes = LoaderSimpleAes(apk_object, dvms)
        res = saes.main()
        assert res["status"] == "success"


if __name__ == "__main__":
    unittest.main()

```