Project Path: arc_gmh5225_OHack_j1425mi8

Source Tree:

```txt
arc_gmh5225_OHack_j1425mi8
├── ClimbHack.cpp
├── Commands.cpp
├── Entry.cpp
├── Fail.Containers.List.hpp
├── Fail.Dialog.hpp
├── Fail.Exception.hpp
├── Fail.Handle.hpp
├── Fail.Loops.hpp
├── Fail.Memory.Local.hpp
├── Fail.Object.cpp
├── Fail.Object.hpp
├── Fail.Types.hpp
├── Fail.UI.Controls.Button.hpp
├── Fail.UI.Controls.CheckBox.hpp
├── Fail.UI.Controls.EditBox.hpp
├── Fail.UI.Controls.Marquee.hpp
├── Fail.UI.Controls.Text.hpp
├── Fail.UI.View.hpp
├── Fail.UI.cpp
├── Fail.UI.hpp
├── Fly.cpp
├── Hacks.cpp
├── Hover.cpp
├── Misc.cpp
├── Morph.cpp
├── Movement.cpp
├── NoCollision.cpp
├── NoWater.cpp
├── OHack.hpp
├── OHack.vcxproj
├── Offsets.hpp
├── README
├── Tracking.cpp
├── UI.cpp
├── WaterWalk.cpp
└── WoW.cpp

```

`ClimbHack.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::SetClimbHack (bool State)
{
	if(State == true)
	{
		Write<byte>(WoWBase + DoMovementStuff1 + 0x67D, static_cast<byte>(0xEB));

		const byte ClimbHack[] = {0x90, 0x90};
		Write(WoWBase + DoMovementStuff2 + 0x8D8, ClimbHack, 2);

		UI::ClimbHack->SetChecked(GetClimbHack());
	}
	else
	{
		Write<byte>(WoWBase + DoMovementStuff1 + 0x67D, static_cast<byte>(0x74));

		const byte ClimbHack[] = {0x75, 0x0C};
		Write(WoWBase + DoMovementStuff2 + 0x8D8, ClimbHack, 2);

		UI::ClimbHack->SetChecked(GetClimbHack());
	}

	return;
}

bool Hacks::GetClimbHack ()
{
	return Read<byte>(WoWBase + DoMovementStuff1 + 0x67D) == 0xEB;
}
```

`Commands.cpp`:

```cpp
#include "OHack.hpp"

#pragma warning (disable : 4996)

char* Command = nullptr;

bool HandleCommand ()
{
	try
	{
		if(strcmpi(Command, ".nowater") == 0)
		{
			if(UI::NoWater->IsChecked() == false)
			{
				Hacks::SetNoWater(true);
				WoW::AddChatMessage("No Water hack enabled.");
			}
			else
			{
				Hacks::SetNoWater(false);
				WoW::AddChatMessage("No Water hack disabled.");
			}
		}
		else if(strcmpi(Command, ".climb") == 0)
		{
			if(UI::ClimbHack->IsChecked() == false)
			{
				Hacks::SetClimbHack(true);
				WoW::AddChatMessage("Climb hack enabled.");
			}
			else
			{
				Hacks::SetClimbHack(false);
				WoW::AddChatMessage("Climb hack disabled.");
			}
		}
		else if(strcmpi(Command, ".hover") == 0)
		{
			if(UI::HoverHack->IsChecked() == false)
			{
				Hacks::SetHover(true);
				if(Hacks::GetHover() == true)
				{
					WoW::AddChatMessage("Hover hack enabled.");
				}
				else
				{
					WoW::AddChatMessage("The hover hack can't be enabled while flying or swimming.");
				}
			}
			else
			{
				Hacks::SetHover(false);
				WoW::AddChatMessage("Hover hack disabled.");
			}
		}
		else if(strcmpi(Command, ".fly") == 0)
		{
			if(UI::FlyHack->IsChecked() == false)
			{
				Hacks::SetFly(true);
				if(Hacks::GetFly() == true)
				{
					WoW::AddChatMessage("Fly hack enabled.");
				}
				else
				{
					WoW::AddChatMessage("The fly hack can't be enabled while flying, hovering, or swimming.");
				}
			}
			else
			{
				Hacks::SetFly(false);
				WoW::AddChatMessage("Fly hack disabled.");
			}
		}
		else if(strcmpi(Command, ".nocollision") == 0 || strcmpi(Command, ".noclip") == 0)
		{
			if(UI::NoCollision->IsChecked() == false)
			{
				Hacks::SetNoCollision(true);
				WoW::AddChatMessage("No Collision hack enabled.");
			}
			else
			{
				Hacks::SetNoCollision(false);
				WoW::AddChatMessage("No Collision hack disabled.");
			}
		}
		else if(strcmpi(Command, ".waterwalk") == 0)
		{
			if(UI::WaterWalk->IsChecked() == false)
			{
				Hacks::SetWaterWalk(true);
				WoW::AddChatMessage("Water Walk hack enabled.");
			}
			else
			{
				Hacks::SetWaterWalk(false);
				WoW::AddChatMessage("Water Walk hack disabled.");
			}
		}
		else if(strcmpi(Command, ".stopfall") == 0)
		{
			Hacks::StopFall();
		}
		else if(strcmpi(".morph", std::string(Command).substr(0, 6).c_str()) == 0)
		{
			const char* Previous = UI::MorphBox->GetText();
			char* ModelID = new char[6];
			ZeroMemory(ModelID, 6);
			memcpy(ModelID, &Command[7], 5);
			UI::MorphBox->SetText(ModelID);
		
			char* String = new char[100];
			sprintf(String, "%s morphed to display ID: %s", WoW::GetTarget() == 0 ? "Player" : "Target", ModelID);
			WoW::AddChatMessage(String);
			delete[] String;

			delete[] ModelID;
			Hacks::Morph();
			UI::MorphBox->SetText(Previous);
		}
		else if(strcmpi(".scale", std::string(Command).substr(0, 6).c_str()) == 0)
		{
			const char* Previous = UI::ScaleBox->GetText();
			char* Scale = new char[6];
			ZeroMemory(Scale, 6);
			memcpy(Scale, &Command[7], 5);
			UI::ScaleBox->SetText(Scale);

			char* String = new char[100];
			sprintf(String, "%s scale set to: %s", WoW::GetTarget() == 0 ? "Player" : "Target", Scale);
			WoW::AddChatMessage(String);
			delete[] String;

			delete[] Scale;
			Hacks::Morph();
			UI::ScaleBox->SetText(Previous);
		}
		else if(strcmpi(".loadmap", std::string(Command).substr(0, 8).c_str()) == 0)//find(".loadmap") != std::string::npos)
		{
			const char* Previous = UI::MapBox->GetText();
			char* Map = new char[6];
			ZeroMemory(Map, 6);
			memcpy(Map, &Command[9], 5);
			UI::MapBox->SetText(Map);

			char* String = new char[100];
			sprintf(String, "Loaded map: %s", Map);
			WoW::AddChatMessage(String);
			delete[] String;

			delete[] Map;
			Hacks::LoadMap();
			UI::MapBox->SetText(Previous);
		}
		else if(strcmpi(".track", std::string(Command).substr(0, 6).c_str()) == 0)
		{
			Hacks::Tracking(&Command[7]);
		}
		else if(Command[0] != '.')
		{
			return false;
		}
	}
	catch(exception Exception)
	{
		WoW::AddChatMessage(Exception.GetException());
	}
	catch(...)
	{
		WoW::AddChatMessage("Exception occured.");
	}

	return true;
}

unsigned int Address = 0;
__declspec(naked) void CommandHook ()
{
	__asm
	{
		pushad
		mov Command, eax
	}

	if(HandleCommand() == true)
	{
		__asm
		{
			popad
			add esp, 0xC
			pop edi
			pop esi
			pop ebx
			mov esp, ebp
			pop ebp
			retn
		}
	}

	__asm
	{
		popad
		mov eax, Command
		mov ebx, eax
		push 2
		mov edi, 1
		jmp Address
	}
}

void Misc::SetCommandHook ()
{
	byte JumpHook[] = {0xE9, 0x0, 0x0, 0x0, 0x0};
	*reinterpret_cast<unsigned int*>(&JumpHook[1]) = reinterpret_cast<unsigned int>(CommandHook) - (WoWBase + Script_SendChatMessage + 0x64 + 0x5);
	Write(WoWBase + Script_SendChatMessage + 0x64, JumpHook, 5);
	Address = WoWBase + Script_SendChatMessage + 0x6D;
	return;
}
```

`Entry.cpp`:

```cpp
#include "OHack.hpp"

unsigned int WoWBase = 0;

int __stdcall DllMain (HMODULE Module, unsigned long Reason, void*)
{
	if(Reason != DLL_PROCESS_ATTACH)
	{
		return 0;
	}

	WoWBase = GetMainModule();

	if(Read<byte>(WoWBase + CGGameUI__CanPerformAction) != 0x55)
	{
		Notification(nullptr, "This hack only supports WoW 4.3.3 (15354) x86.", "Unsupported");
		return 0;
	}

	UI::Module = Module;
	UI::MainThread = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(UI::Create), nullptr, 0, nullptr);
	Misc::KillSwitchThread = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(Misc::LoopKillswitch), nullptr, 0, nullptr);
	if(UI::MainThread == nullptr || Misc::KillSwitchThread == nullptr)
	{
		Notification(nullptr, "Unable to create threads.", "Error");
		return 0;
	}

	return 1;
}
```

`Fail.Containers.List.hpp`:

```hpp
#pragma once

#include <deque>

#include "Fail.Object.hpp"

namespace Fail
{
	// Container classes
	namespace Containers
	{
		template <typename T>
		class List : public object
		{
		public:
			// Default constructor
			inline List ()
			{
				return;
			}

			// Add an object to the back of the list
			inline void Add (T Object)
			{
				this->Deque.push_back(Object);
				return;
			}

			// Add an object to the front of the list
			inline void AddBack (T Object)
			{
				this->Deque.push_front(Object);
				return;
			}

			// Remove the object at the front of the list
			inline void RemoveFront ()
			{
				this->Deque.pop_front();
				return;
			}

			// Remove the object at the back of the list
			inline void RemoveBack ()
			{
				this->Deque.pop_back();
				return;
			}

			// Get and remove the object at the front of the list
			T GetAndRemoveFront ()
			{
				T Object;
				memcpy(&Object, &this->Deque.front(), sizeof(T));
				this->RemoveFront();
				return Object;
			}

			// Get and remove the object at the back of the list
			T GetAndRemoveBack ()
			{
				T Object;
				memcpy(&Object, &this->Deque.back(), sizeof(T));
				this->RemoveBack();
				return Object;
			}

			// Find an object in the list and return its position. -1 if not found.
			int Find (T& Object)
			{
				unsigned int i = 0;
				while(i < this->Deque.size())
				{
					if(this->Deque[i] == Object)
					{
						return i;
					}
					i++;
				}

				return -1;
			}

			// Clear the list
			inline void Clear ()
			{
				this->Deque.clear();
				return;
			}

			// Check if the list is empty
			inline bool Empty () const
			{
				return this->Deque.empty;
			}

			// Insert an object into the list
			inline void Insert (T Object, unsigned int Position)
			{
				this->Deque.insert(Position, Object);
				return;
			}

			// Swap 2 objects in the list
			inline void Swap (unsigned int FirstObject, unsigned int SecondObject)
			{
				T* Object = new T;
				*Object = this->Deque[FirstObject];
				this->Deque[FirstObject] = this->Deque[SecondObject];
				this->Deque[SecondObject] = *Object;
				delete Object;
				return;
			}

			// Get the number of objects in the list
			inline unsigned int Size () const
			{
				return this->Deque.size();
			}

			// Get the list member at i
			T& At (unsigned int i)
			{
				if(i >= this->Deque.size() || i < 0)
				{
					throw std::exception("Unable to get List member: Out of range.");
				}

				return this->Deque[i];
			}

			// Array access operator
			inline T& operator [] (unsigned int i)
			{
				return this->At(i);
			}

			// Copy operator
			List<T>& operator = (const List<T>& Other)
			{
				unsigned int i = 0;
				while(i < Other.Size())
				{
					this->At[i] = const_cast<List<T>>(Other)[i];
					i++;
				}

				return *this;
			}

			// Equality operator
			bool operator == (const List<T>& Other)
			{
				if(this->ObjectSize != Other.ObjectSize)
				{
					return false;
				}

				unsigned int i = 0;
				while(i < Other.Size())
				{
					if(this->At(i) != const_cast<List<T>>(Other)[i])
					{
						return false;
					}
					i++;
				}
				return true;
			}

			// Inequality operator
			inline bool operator != (const List<T>& Other)
			{
				return !this->operator ==(Other);
			}

			// Add an object to the back of the list
			inline void operator += (T Object)
			{
				this->AddBack(Object);
				return;
			}

		protected:
			// Deque object
			std::deque<T> Deque;
		};
	}
}
```

`Fail.Dialog.hpp`:

```hpp
#pragma once

#include <Windows.h>

namespace Fail
{
	// Dialog functions and classes
	namespace Dialog
	{
		// A dialog box with an OK button.
		inline void Notification (HWND Parent, const char* Text, const char* Title = "")
		{
			MessageBox(Parent, Text, Title, MB_OK | MB_ICONINFORMATION);
			return;
		}

		// A dialog box with a Yes and a No button. Returns true if Yes is clicked, or false if No is clicked.
		inline bool Question (HWND Parent, const char* Text, const char* Title = "")
		{
			return MessageBox(Parent, Text, Title, MB_YESNO | MB_ICONQUESTION) == IDYES;
		}

		// A dialog box with an OK and a Cancel button. Returns true if OK is clicked, or false if Cancel is clicked.
		inline bool Confirmation (HWND Parent, const char* Text, const char* Title = "")
		{
			return MessageBox(Parent, Text, Title, MB_OKCANCEL | MB_ICONWARNING) == IDOK;
		}

		// A dialog box with a Retry and a Cancel button. Returns true if Retry is click, or false if Cancel is clicked.
		inline bool Retry (HWND Parent, const char* Text, const char* Title = "")
		{
			return MessageBox(Parent, Text, Title, MB_RETRYCANCEL | MB_ICONQUESTION) == IDRETRY;
		}
	}
}
```

`Fail.Exception.hpp`:

```hpp
#pragma once

#pragma warning (push)
#pragma warning (disable : 4996)

#include <Windows.h>

#include <cstdio>

namespace Fail
{
	// Exception class
	class exception
	{
	public:
		// Default constructor
		inline exception ()
		{
			register unsigned int Length = strlen("Exception occurred.") + 1;
			this->String = new char[Length];
			ZeroMemory(this->String, Length);
			strcpy(this->String, "Exception occurred.");
			return;
		}

		// Message constructor
		inline exception (const char* Message)
		{
			register unsigned int Length = strlen(Message) + 13;
			this->String = new char[Length];
			ZeroMemory(this->String, Length);
			sprintf(this->String, "Exception: %s.", Message);
			return;
		}

		// Message and function constructor
		inline exception (const char* Message, const char* Function)
		{
			register unsigned int Length = strlen(Message) + strlen(Function) + strlen("Exception occurred in function: %s.\n%s") - 3;
			this->String = new char[Length];
			ZeroMemory(this->String, Length);
			sprintf(this->String, "Exception occurred in function: %s.\n%s", Function, Message);
			return;
		}

		// Exception destructor
		inline ~exception ()
		{
			delete[] this->String;
			return;
		}

		// Get the formatted exception string
		inline const char* GetException () const
		{
			return this->String;
		}

	protected:
		char* String;
	};
}

#pragma warning (pop)
```

`Fail.Handle.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include "Fail.Object.hpp"

namespace Fail
{
	// Closing handle
	class handle : public Fail::object
	{
	public:
		// Default constructor
		inline handle ()
		{
			this->Handle = nullptr;
			return;
		}

		// Handle constructor
		inline handle (void* Handle)
		{
			this->Handle = Handle;
			return;
		}

		// Handle destructor
		inline ~handle ()
		{
			CloseHandle(this->Handle);
			return;
		}

		// Close the handle
		inline void Close ()
		{
			this->~handle();
			return;
		}

		// Void* operator
		inline operator void* ()
		{
			return this->Handle;
		}

		// Copy operator
		inline handle& operator = (handle Other)
		{
			DuplicateHandle(GetCurrentProcess(), Other, GetCurrentProcess(), &this->Handle, 0, false, DUPLICATE_SAME_ACCESS);
			return *this;
		}

		// Get the handle's value
		inline void* GetHandle () const
		{
			return this->Handle;
		}

	protected:
		// Handle value
		void* Handle;
	};
}
```

`Fail.Loops.hpp`:

```hpp
#pragma once

#include <Windows.h>

#define every(Milliseconds) while(reinterpret_cast<bool (__stdcall*)(unsigned int)>(Sleep)(Milliseconds) || true)
#define everywhile(Milliseconds, Condition) while(reinterpret_cast<bool (__stdcall*)(unsigned int)>(Sleep)(Milliseconds) || Condition)
#define dotimes(Times) for(unsigned int i = 0; i++; i < Times)
```

`Fail.Memory.Local.hpp`:

```hpp
#pragma once

#pragma warning (push)
#pragma warning (disable : 4482)

#include <Windows.h>
#include <TlHelp32.h>

#include "Fail.Exception.hpp"
#include "Fail.Loops.hpp"
#include "Fail.Types.hpp"

namespace Fail
{
	namespace Memory
	{
		// Memory Protection
		enum Protection : unsigned int
		{
			NoAccess = 0x1,
			Read = 0x2,
			ReadWrite = 0x4,
			WriteCopy = 0x8,
			Execute = 0x10,
			ExecuteRead = 0x20,
			ExecuteReadWrite = 0x40,
			ExecuteWriteCopy = 0x80
		};

		// Functions for local process memory editing
		namespace Local
		{
			// Get an object and return by reference
			template <typename Type>
			inline Type& get (uint Address)
			{
				return *reinterpret_cast<Type*>(Address.AsPointer());
			}

			// Get a pointer to the main module
			inline uint GetMainModule ()
			{
				return GetModuleHandle(nullptr);
			}

			// Get a pointer to a module
			inline uint GetModule (const char* Module)
			{
				return GetModuleHandle(Module);
			}

			// Get a handle to the main thread
			inline void* GetMainThread ()
			{
				THREADENTRY32 Thread;
				ZeroMemory(&Thread, sizeof(Thread));
				Thread.dwSize = sizeof(Thread);
				void* Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
				Thread32Next(Snapshot, &Thread);
				if(Thread.th32OwnerProcessID != GetCurrentProcessId())
				{
					throw exception("Unable to get main thread.");
				}

				CloseHandle(Snapshot);
				return OpenThread(THREAD_ALL_ACCESS, false, Thread.th32ThreadID);
			}

			// Protect memory and return the old protection
			inline Protection Protect (uint Address, uint Size, Protection NewProtection)
			{
				unsigned long OldProtection = 0;
				if(VirtualProtect(Address.AsPointer(), Size, NewProtection, &OldProtection) == 0)
				{
					throw exception("Unable to change memory protection: VirtualProtect failed.");
				}

				return Protection(OldProtection);
			}

			// Read a copy of an object from memory
			template <typename Type>
			Type& ReadCopy (uint Address)
			{
				Type Object;
				Protection OldProtection = Protect(Address, sizeof(Object), Protection::WriteCopy);
				memcpy(&Object, Address.AsPointer(), sizeof(Object));
				Protect(Address, sizeof(Object), OldProtection);
				return Object;
			}

			// Read an object from memory. The memory must be readable already.
			template <typename Type>
			inline Type& Read (uint Address)
			{
				return *reinterpret_cast<Type*>(Address.AsPointer());
			}

			// Write an object into memory
			template <typename Type>
			void Write (uint Address, const Type& Object)
			{
				Protection OldProtection = Protect(Address, sizeof(Object), Protection::ReadWrite);

				memcpy(Address.AsPointer(), &Object, sizeof(Object));
				if(*reinterpret_cast<const unsigned char*>(Address.AsPointer()) != *reinterpret_cast<const unsigned char*>(&Object))
				{
					throw exception("Memory write failed.");
				}

				Protect(Address, sizeof(Object), OldProtection);
				FlushInstructionCache(GetCurrentProcess(), Address.AsPointer(), sizeof(Object));
				return;
			}

			// Write an array of bytes into memory
			inline void Write (uint Address, const unsigned char* Bytes, uint Size)
			{
				Protection OldProtection = Protect(Address, Size, Protection::ReadWrite);

				memcpy(Address.AsPointer(), Bytes, Size);
				if(*reinterpret_cast<unsigned char*>(Address.AsPointer()) != Bytes[0])
				{
					throw exception("Memory write failed.");
				}

				Protect(Address, Size, OldProtection);
				FlushInstructionCache(GetCurrentProcess(), Address.AsPointer(), Size);
				return;
			}
		}
	}
}

#pragma warning (pop)
```

`Fail.Object.cpp`:

```cpp
#include "Fail.Object.hpp"

bool Fail::object::operator == (const object& Other) const
{
	unsigned int i = 0;
	while(i < sizeof(*this))
	{
		if(reinterpret_cast<unsigned char*>(const_cast<object*>(this))[i] != reinterpret_cast<unsigned char*>(const_cast<object*>(&Other))[i])
		{
			return false;
		}
	}

	return true;
}

bool Fail::object::operator != (const object& Other) const
{
	return !this->operator==(Other);
}

Fail::object& Fail::object::operator = (const object& Other)
{
	if(sizeof(*this) != sizeof(Other))
	{
		throw Fail::exception("Attempt to copy an object to an object of an incompatible type.", __FUNCTION__);
	}

	unsigned int i = 0;
	if(sizeof(*this) % 4 != 0)
	{
		// Use bytes so that only the object is copied
		while(i < sizeof(*this))
		{
			reinterpret_cast<unsigned char*>(this)[i] = reinterpret_cast<unsigned char*>(const_cast<object*>(&Other))[i];
			i++;
		}
	}
	else
	{
		// Use 4-byte integers if possible for faster copy speed
		while(i < sizeof(*this) / 4)
		{
			reinterpret_cast<unsigned int*>(this)[i] = reinterpret_cast<unsigned int*>(const_cast<object*>(&Other))[i];
			i++;
		}
	}

	return *this;
}

unsigned int Fail::object::Type() const
{
	return typeid(*this).hash_code();
}

const char* Fail::object::TypeName() const
{
	return typeid(*this).name();
}

void Fail::object::Zero ()
{
	memset(this, 0, sizeof(*this));
	return;
}

bool Fail::object::IsNullOrEmpty () const
{
	unsigned int i = 0;
	while(i < sizeof(*this))
	{
		if(*reinterpret_cast<unsigned char*>(const_cast<object*>(this)) != 0)
		{
			return false;
		}
		i++;
	}

	return true;
}
```

`Fail.Object.hpp`:

```hpp
#pragma once

#include <typeinfo>

#include "Fail.Exception.hpp"

namespace Fail
{
	// Base object class
	class object
	{
	public:
		// Object constructor
		inline object ()
		{
			return;
		}

		// Equality operator
		virtual bool operator == (const object& Other) const;

		// Inequality operator
		virtual bool operator != (const object& Other) const;

		// Copy operator
		virtual object& operator = (const object& Other);

		// Get if the object is null or empty.
		virtual bool IsNullOrEmpty () const;

		// Type of this object. Only comparable to other object types.
		unsigned int Type () const;

		// Name of this object's type.
		const char* TypeName () const;

		// Zero the object's memory
		void Zero ();
	};
}
```

`Fail.Types.hpp`:

```hpp
#pragma once

#pragma warning (push)
#pragma warning(disable : 4996)

#include <cmath>
#include <cstdlib>

namespace Fail
{
	class byte
	{
	public:
		// Default constructor
		inline byte ()
		{
			this->Value = 0;
			return;
		}

		// Byte constructor
		inline byte (unsigned char Byte)
		{
			this->Value = Byte;
			return;
		}

		// Return the byte as a string.
		inline const char* AsString (bool Hex = false) const
		{
			char* String = new char[Hex ? 3 : 4];
			itoa(this->Value, String, Hex ? 16 : 10);
			return String;
		}

		// Unsigned char operator
		inline operator unsigned char ()
		{
			return this->Value;
		}

		// Const unsigned char operator
		inline operator const unsigned char () const
		{
			return this->Value;
		}
		
	protected:
		// Byte value
		unsigned char Value;
	};

	// Unsigned integer class
	class uint
	{
	public:
		// Default constructor
		inline uint ()
		{
			this->Value = 0;
			return;
		}

		// Unsigned int constructor
		inline uint (unsigned int UInt)
		{
			this->Value = UInt;
			return;
		}

		// Void* constructor
		inline uint (void* Pointer)
		{
			this->Value = reinterpret_cast<unsigned int>(Pointer);
			return;
		}

		// Unsigned int operator
		inline operator unsigned int ()
		{
			return this->Value;
		}

		// Const unsigned int operator
		inline operator const unsigned int () const
		{
			return this->Value;
		}

		// Void* operator
		inline operator void* ()
		{
			return this->AsPointer();
		}

		// Return the object as a pointer
		inline void* AsPointer () const
		{
			return reinterpret_cast<void*>(this->Value);
		}

		// Return the object as a string
		inline const char* AsString (bool Hex = false) const
		{
			char* String = new char[Hex ? 9 : 10];
			itoa(this->Value, String, Hex ? 16 : 10);
			return String;
		}

	protected:
		// Unsigned int value
		unsigned int Value;
	};

	// Signed integer class
	class sint
	{
	public:
		// Default constructor
		inline sint ()
		{
			this->Value = 0;
			return;
		}

		// Int constructor
		inline sint (signed int Int)
		{
			this->Value = Int;
			return;
		}

		// Int operator
		inline operator signed int ()
		{
			return this->Value;
		}

		// Get the value of the sint
		inline signed int Get () const
		{
			return this->Value;
		}

		// Return the object as a string
		inline const char* AsString (bool Hex = false)
		{
			char* String = new char[Hex ? 10 : 11];
			itoa(this->Value, String, Hex ? 16 : 10);
			return String;
		}

	private:
		// Signed int value
		int Value;
	};
}

#pragma warning (pop)
```

`Fail.UI.Controls.Button.hpp`:

```hpp
#pragma once

#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		namespace Controls
		{
			// Button control
			class Button : public Control
			{
			public:
				// Button constructor
				inline Button (const char* Text, unsigned int X, unsigned int Y, unsigned Width, unsigned int Height, HWND Parent, unsigned int Command, HINSTANCE Instance)
				{
					this->Handle = CreateWindowEx(0, "button", Text, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, X, Y, Width, Height, Parent, reinterpret_cast<HMENU>(Command), Instance, nullptr);
					SendMessage(this->Handle, WM_SETFONT, reinterpret_cast<WPARAM>(GetStockObject(DEFAULT_GUI_FONT)), 0);
					return;
				}

				// Push the button
				inline void Push () const
				{
					SendMessage(this->Handle, BM_CLICK, 0, 0);
					return;
				}
			};
		}
	}
}
```

`Fail.UI.Controls.CheckBox.hpp`:

```hpp
#pragma once

#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		namespace Controls
		{
			// Check box control
			class CheckBox : public Control
			{
			public:
				// CheckBox constructor
				inline CheckBox (const char* Text, unsigned int X, unsigned int Y, unsigned Width, unsigned int Height, HWND Parent, unsigned int Command, bool Checked, HINSTANCE Instance)
				{
					this->Handle = CreateWindowEx(0, "button", Text, WS_VISIBLE | WS_CHILD | BS_CHECKBOX, X, Y, Width, Height, Parent,reinterpret_cast<HMENU>(Command), Instance, nullptr);
					SendMessage(this->Handle, WM_SETFONT, reinterpret_cast<WPARAM>(GetStockObject(DEFAULT_GUI_FONT)), 0);
					return;
				}

				// Return true if the check box is checked, otherwise false
				inline bool IsChecked () const
				{
					return SendMessage(this->Handle, BM_GETCHECK, 0, 0) == BST_CHECKED;
				}

				// Set whether the check box is checked
				inline void SetChecked (bool State) const
				{
					SendMessage(this->Handle, BM_SETCHECK, State == true ? BST_CHECKED : BST_UNCHECKED, 0);
					return;
				}
			};
		}
	}
}
```

`Fail.UI.Controls.EditBox.hpp`:

```hpp
#pragma once

#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		namespace Controls
		{
			class EditBox : public Control
			{
			public:
				// EditBox constructor
				inline EditBox (const char* Text, unsigned int Style, unsigned int X, unsigned int Y, unsigned Width, unsigned int Height, HWND Parent, unsigned int Command, HINSTANCE Instance)
				{
					this->Handle = CreateWindowEx(0, "edit", Text, WS_CHILD | WS_VISIBLE | Style, X, Y, Width, Height, Parent, reinterpret_cast<HMENU>(Command), Instance, nullptr);
					SendMessage(this->Handle, WM_SETFONT, reinterpret_cast<WPARAM>(GetStockObject(DEFAULT_GUI_FONT)), 0);
					return;
				}

				// Limit the number of characters in the edit box
				inline void LimitCharacters (unsigned int Characters)
				{
					SendMessage(this->Handle, EM_SETLIMITTEXT, Characters, 0);
					return;
				}
			};
		}
	}
}
```

`Fail.UI.Controls.Marquee.hpp`:

```hpp
#pragma once

#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		namespace Controls
		{
			class Marquee : public Control
			{
			public:
				// Marquee constructor
				inline Marquee (unsigned int X, unsigned int Y, unsigned Width, unsigned int Height, HWND Parent, HINSTANCE Instance, unsigned int Speed = 30)
				{
					InitCommonControls();
					this->Handle = CreateWindowEx(0, PROGRESS_CLASS, nullptr, WS_CHILD | WS_VISIBLE | PBS_MARQUEE, X, Y, Width, Height, Parent, nullptr, Instance, nullptr);
					SendMessage(this->Handle, PBM_SETMARQUEE, 1, Speed);
					return;
				}
			};
		}
	}
}
```

`Fail.UI.Controls.Text.hpp`:

```hpp
#pragma once

#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		namespace Controls
		{
			class Text : public Control
			{
			public:
				inline Text (const char* Text, unsigned int X, unsigned int Y, unsigned Width, unsigned int Height, HWND Parent, HINSTANCE Instance)
				{
					this->Handle = CreateWindowEx(0, "static", Text, WS_CHILD | WS_VISIBLE | SS_CENTER, X, Y, Width, Height, Parent, nullptr, Instance, nullptr);
					SendMessage(this->Handle, WM_SETFONT, reinterpret_cast<WPARAM>(GetStockObject(DEFAULT_GUI_FONT)), 0);
					return;
				}
			};
		}
	}
}
```

`Fail.UI.View.hpp`:

```hpp
#pragma once

#pragma warning (push)
#pragma warning (disable : 4996)

#include "Fail.Containers.List.hpp"
#include "Fail.UI.hpp"

namespace Fail
{
	namespace UI
	{
		// View class
		class View : public object
		{
		private:
			// Window enumeration callback
			static unsigned int __stdcall WindowEnumCallback (HWND Window, LPARAM)
			{
				ShowWindow(Window, SW_HIDE);
				return 1;
			}

		protected:
			// Parent window
			HWND Window;

			// Window Size
			unsigned int Width;
			unsigned int Height;

			// Controls list
			Containers::List<HWND> Controls;

			char* Title;

		public:
			// View constructor
			inline View (HWND Parent, unsigned int Width, unsigned int Height, const char* Title)
			{
				this->Window = Parent;
				this->Width = Width;
				this->Height = Height;
				this->Title = new char[strlen(Title) + 2];
				strcpy(this->Title, Title);
				this->Title[strlen(Title) + 1] = 0;
				return;
			}

			// View destructor
			inline ~View ()
			{
				delete[] this->Title;
				return;
			}

			// Add a control to the view
			inline void AddControl (HWND Control)
			{
				this->Controls.AddBack(Control);
				return;
			}

			// Activate the view
			inline void Activate ()
			{
				EnumChildWindows(this->Window, reinterpret_cast<WNDENUMPROC>(WindowEnumCallback), 0);

				unsigned int i = 0;
				while(i < this->Controls.Size())
				{
					ShowWindow(this->Controls[i], SW_SHOW);
					i++;
				}

				SetWindowPos(this->Window, nullptr, 0, 0, this->Width, this->Height, SWP_NOMOVE | SWP_NOZORDER);
				SetWindowText(this->Window, Title);
				return;
			}
		};
	}
}

#pragma warning (pop)
```

`Fail.UI.cpp`:

```cpp
#include "Fail.UI.hpp"

void Fail::UI::CreateWindowClass (unsigned long Style, WNDPROC MessageHandler, const char* ClassName, HINSTANCE Instance, unsigned int BackgroundColor, HCURSOR Cursor, HICON Icon, HICON SmallIcon)
{
	WNDCLASSEX WindowClass;
	ZeroMemory(&WindowClass, sizeof(WindowClass));

	WindowClass.cbSize = sizeof(WindowClass);
	WindowClass.hbrBackground = reinterpret_cast<HBRUSH>(BackgroundColor);
	WindowClass.hCursor = Cursor;
	WindowClass.hIcon = Icon;
	WindowClass.hIconSm = SmallIcon;
	WindowClass.hInstance = Instance;
	WindowClass.lpfnWndProc = MessageHandler;
	WindowClass.lpszClassName = ClassName;
	WindowClass.style = Style;

	if(RegisterClassEx(&WindowClass) == 0)
	{
		throw Fail::exception("Window class registration failed.");
	}
	return;
}

Fail::UI::Window::Window (const char* ClassName, const char* WindowName, unsigned long ExStyle, unsigned long Style, unsigned int X, unsigned int Y, unsigned int Width, unsigned int Height, HINSTANCE Instance, HWND Parent)
{
	this->Handle = CreateWindowEx(ExStyle, ClassName, WindowName, Style, X, Y, Width, Height, Parent, nullptr, Instance, nullptr);
	if(this->Handle == nullptr)
	{
		throw Fail::exception("Window creation failed.");
	}

	this->Update();
	this->Show(true);
	return;
}

void Fail::UI::Window::Focus (bool Focus) const
{
	if(Focus == true)
	{
		SwitchToThisWindow(this->Handle, 0);
	}
	else
	{
		SwitchToThisWindow(0, 0);
	}

	return;
}

const char* Fail::UI::Window::GetTitle () const
{
	unsigned int Length = GetWindowTextLength(this->Handle);
	char* Title = new char[Length];
	GetWindowText(this->Handle, Title, Length);
	return Title;
}

Fail::UI::Window::Location& Fail::UI::Window::GetPosition () const
{
	RECT Rect;
	GetWindowRect(this->Handle, &Rect);
	Window::Location* Location = new Window::Location;
	Location->X = Rect.left;
	Location->Y = Rect.top;
	return *Location;
}

Fail::UI::Window::Size& Fail::UI::Window::GetSize () const
{
	RECT Rect;
	GetWindowRect(this->Handle, &Rect);
	Size* WindowSize = new Size; 
	WindowSize->X = Rect.right - Rect.left;
	WindowSize->Y = Rect.bottom - Rect.top;
	return *WindowSize;
}

const char* Fail::UI::Controls::Control::GetText () const
{
	unsigned int Length = GetWindowTextLength(this->Handle);
	char* Text = new char[Length + 2];
	GetWindowText(this->Handle, Text, Length + 1);
	return Text;
}
```

`Fail.UI.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <CommCtrl.h>

#include <map>
#include <typeinfo>

#include "Fail.Exception.hpp"
#include "Fail.Object.hpp"

#pragma comment (lib, "ComCtl32.lib")

namespace Fail
{
	// User interface classes and functions
	namespace UI
	{
		// Control classes and functions
		namespace Controls
		{
			// Control parent class. Internal; don't use.
			class Control : public object
			{
			protected:
				// Control handle
				HWND Handle;

			public:
				// Default constructor
				inline Control ()
				{
					return;
				}

				// Control destructor
				inline ~Control ()
				{
					DestroyWindow(this->Handle);
					return;
				}

				// Get a handle to the control
				inline HWND GetHandle () const
				{
					return this->Handle;
				}

				// Change whether the control is visible or not
				inline void SetVisible (bool Visible) const
				{
					ShowWindow(this->Handle, Visible ? SW_SHOW : SW_HIDE);
					return;
				}

				// Set the control's text. Not all controls are supported.
				inline void SetText (const char* Text) const
				{
					SetWindowText(this->Handle, Text);
					return;
				}

				// Get the control's text. Not all controls are supported.
				const char* GetText () const;
			};
		}

		// Window object
		class Window : public object
		{
		public:
			// Window location
			class Location
			{
			public:
				Location ()
				{
					this->X = 0;
					this->Y = 0;
					return;
				}

				unsigned int X;
				unsigned int Y;
			};

			// Window size
			class Size
			{
			public:
				Size ()
				{
					this->X = 0;
					this->Y = 0;
					return;
				}

				unsigned int X;
				unsigned int Y;
			};

			// Create a window and construct the object
			Window (const char* ClassName, const char* WindowName, unsigned long ExStyle, unsigned long Style, unsigned int X, unsigned int Y, unsigned int Width, unsigned int Height, HINSTANCE Instance, HWND Parent = nullptr);

			// Construct the object with an already existing window
			inline Window (HWND Window)
			{
				this->Handle = Window;
				return;
			}

			// Update the window
			inline void Update () const
			{
				UpdateWindow(this->Handle);
				return;
			}

			// Show or hide the window
			inline void Show (bool Show) const
			{
				ShowWindow(this->Handle, Show ? SW_SHOW : SW_HIDE);
				return;
			}

			// Close the window
			inline void Close () const
			{
				CloseWindow(this->Handle);
				return;
			}

			// Destroy the window
			inline void Destroy () const
			{
				DestroyWindow(this->Handle);
				return;
			}

			// Get the window handle
			inline HWND GetHandle () const
			{
				return this->Handle;
			}

			// Focus or unfocus the window
			void Focus (bool Focus = true) const;

			// Get if the window is focused
			inline bool IsFocused () const
			{
				return GetForegroundWindow() == this->Handle;
			}

			// Get if the window is visible
			inline bool IsVisible () const
			{
				return IsWindowVisible(this->Handle) != 0;
			}

			// Set if the window is visible
			inline void SetVisible (bool Show) const
			{
				ShowWindow(this->Handle, Show ? SW_SHOW : SW_HIDE);
				return;
			}

			// Set the window's title
			inline void SetTitle (const char* Title) const
			{
				SetWindowText(this->Handle, Title);
				return;
			}
			
			// Get the window's title
			const char* GetTitle () const;

			// Set the window's position
			inline void SetPosition (unsigned int X, unsigned int Y) const
			{
				SetWindowPos(this->Handle, nullptr, X, Y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
				return;
			}

			// Get the window's position
			Location& GetPosition () const;

			// Set the window's size
			inline void SetSize (unsigned int X, unsigned int Y) const
			{
				SetWindowPos(this->Handle, nullptr, 0, 0, X, Y, SWP_NOMOVE | SWP_NOZORDER);
				return;
			}

			// Get the window's size
			Size& GetSize () const;

			// Enter the message loop. Does not return until the window exits. Must be called from the same thread that created the window.
			inline void EnterMessageLoop () const
			{
				MSG Msg;
				while(GetMessage(&Msg, nullptr, 0, 0) > 0)
				{
					TranslateMessage(&Msg);
					DispatchMessage(&Msg);
				}

				return;
			}

			// Assignment operator
			void operator = (const Window& Other)
			{
				this->Handle = Other.Handle;
				return;
			}

			// Equality operator
			bool operator == (const Window& Other) const
			{
				return this->Handle == Other.Handle;
			}

			// Inequality operator
			bool operator != (const Window& Other) const
			{
				return this->Handle != Other.Handle;
			}

		protected:
			// Window handle
			HWND Handle;
		};

		// Create and register a new window class
		void CreateWindowClass (unsigned long Style, WNDPROC MessageHandler, const char* ClassName, HINSTANCE Instance, unsigned int BackgroundColor = COLOR_WINDOW, HCURSOR Cursor = nullptr, HICON Icon = nullptr, HICON SmallIcon = nullptr);
	}
}
```

`Fly.cpp`:

```cpp
#include "OHack.hpp"

__declspec(naked) void __fastcall CalcDirectionHook ()
{
	static unsigned int This = 0;
	__asm
	{
		mov This, ecx
	}

	get<unsigned int>(get<unsigned int>(WoW::GetPlayer() + CMovement) + 0x38) |= MovementFlags::Flying;
	reinterpret_cast<void (__thiscall*)(unsigned int)>(WoWBase + CMovement__CalcDirection)(This);
	get<unsigned int>(get<unsigned int>(WoW::GetPlayer() + CMovement) + 0x38) &= ~MovementFlags::Flying;

	__asm
	{
		retn
	}
}

void Hacks::SetFly (bool State)
{
	if(WoW::IsInGame() == false || WoW::GetPlayer() == 0)
	{
		return;
	}

	if(State == true)
	{
		if(*reinterpret_cast<unsigned int*>(*reinterpret_cast<unsigned int*>(WoW::GetPlayer() + CMovement) + 0x38) & (MovementFlags::Flying | MovementFlags::Swimming) || GetHover() == true)
		{
			return;
		}

		StopFall();

		const byte NOPs[] = {0x90, 0x90, 0x90, 0x83, 0xC4, 0x4};
		Write(WoWBase + CanFlyOrSwim + 0x63, NOPs, 3);

		const byte NoSwim[] = {0x90, 0xE9};
		Write(WoWBase + CGUnit_C__UpdateSwimmingStatus + 0x3C, NoSwim, 2);

		const byte NoJump[] = {0x90, 0x90, 0x83, 0xC4, 0x4};
		Write(WoWBase + Script_JumpOrAscendStart + 0x15D, NoJump, 5);

		Write<signed int>(WoWBase + CMovementShared__CalcDirection + 0x1A, reinterpret_cast<unsigned int>(CalcDirectionHook) - (WoWBase + CMovementShared__CalcDirection + 0x1E));

		UI::FlyHack->SetChecked(GetFly());
	}
	else
	{
		const byte Fly1[] = {0x33, 0xC0, 0xC3};
		Write(WoWBase + CanFlyOrSwim + 0x63, Fly1, 3);

		const byte NoSwim[] = {0x0F, 0x85};
		Write(WoWBase + CGUnit_C__UpdateSwimmingStatus + 0x3C, NoSwim, 2);

		byte NoJump[] = {0xE8, 0x0, 0x0, 0x0, 0x0};
		get<unsigned int>(&NoJump[1]) = (WoWBase + SendJump) - (WoWBase + Script_JumpOrAscendStart + 0x15E + 0x4);
		Write(WoWBase + Script_JumpOrAscendStart + 0x15D, NoJump, 5);

		Write<signed int>(WoWBase + CMovementShared__CalcDirection + 0x1A, (WoWBase + CMovement__CalcDirection) - (WoWBase + CMovementShared__CalcDirection + 0x1E));

		UI::FlyHack->SetChecked(GetFly());
	}

	return;
}

bool Hacks::GetFly ()
{
	return Read<signed int>(WoWBase + CMovementShared__CalcDirection + 0x1A) == (reinterpret_cast<unsigned int>(CalcDirectionHook) - (WoWBase + CMovementShared__CalcDirection + 0x1E));
}
```

`Hacks.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::Init ()
{
	// Hook CGWorldFrame::Render to run code in the main thread every frame. This can be hooked instead of EndScene or Present, and is not DirectX-dependent.
	WoW::Render = reinterpret_cast<bool (__thiscall*)(unsigned int)>(DetourFunction(reinterpret_cast<byte*>(WoWBase + CGWorldFrame__Render), reinterpret_cast<byte*>(WoW::FrameHook)));
	Misc::SetCommandHook();

	// Unlock Lua
	const byte LuaUnlock[] = {0x8B, 0xE5, 0x5D, 0xC3};
	Write(WoWBase + SomeLuaFunction + 0x21D, LuaUnlock, 4);

	// To stop those damn pop-ups
	const byte NoPopups[] = {0x90, 0xE9};
	Write(WoWBase + CGGameUI__ShowBlockedActionFeedback + 0x10, NoPopups, 2);

	// Zoom Hack
	Write<byte>(WoWBase + CGCamera__UpdateMotion_ulong_ + 0x238, static_cast<byte>(0xF0));

	// Show all levels hack
	Write<byte>(WoWBase + Script_UnitLevel + 0xB6, 0xEB);

	// No Away hack
	const byte NOPs[] = {0x90, 0x90, 0x90, 0x90, 0x90};
	Write(WoWBase + CGGameUI__Idle + 0x151, NOPs, 5);
	
	// Language hack
	const byte LanguageHack[] = {0xB8, 0x1, 0x0, 0x0, 0x0, 0xC2, 0x08, 0x0};
	Write(WoWBase + IsKnownLanguage, LanguageHack, 8);

	// Understanding all languages didn't work for some people. This should fix that.
	Write<byte>(WoWBase + ObfuscateLanguage + 0x75, 0x3A);
	
	// Follow any hack
	Write(WoWBase + CGUnit_C__SetTrackingTarget + 0x86, NOPs, 5);

	WoW::AddChatMessage("OHack loaded.");
	return;
}
```

`Hover.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::SetHover (bool State)
{
	if(WoW::IsInGame() == false || WoW::GetPlayer() == 0)
	{
		return;
	}

	if(State == true)
	{
		if(*reinterpret_cast<unsigned int*>(*reinterpret_cast<unsigned int*>(WoW::GetPlayer() + CMovement) + 0x38) & (MovementFlags::Flying | MovementFlags::Swimming))
		{
			return;
		}

		StopFall();

		const byte NOPs[] = {0x90, 0x90, 0x90, 0x83, 0xC4, 0x4};
		Write(WoWBase + CanFlyOrSwim + 0x63, NOPs, 3);

		const byte NoSwim1[] = {0x90, 0x90};
		Write(WoWBase + CGUnit__CanSwim + 0x1A, NoSwim1, 2);
		Write<byte>(WoWBase + CGUnit__CanSwim + 0x26, static_cast<byte>(0xEB));

		Write(WoWBase + Script_JumpOrAscendStart + 0x15D, &NOPs[1], 5);

		UI::HoverHack->SetChecked(GetHover());
	}
	else
	{
		const byte Hover[] = {0x33, 0xC0, 0xC3};
		Write(WoWBase + CanFlyOrSwim + 0x63, Hover, 3);

		const byte NoSwim1[] = {0x75, 0x27};
		Write(WoWBase + CGUnit__CanSwim + 0x1A, NoSwim1, 2);
		Write<byte>(WoWBase + CGUnit__CanSwim + 0x26, static_cast<byte>(0x75));

		const byte NoJump[] = {0xE8, 0xE, 0x32, 0x18, 0x0};
		Write(WoWBase + Script_JumpOrAscendStart + 0x15D, NoJump, 5);

		UI::HoverHack->SetChecked(GetHover());
	}

	return;
}

bool Hacks::GetHover ()
{
	return Read<byte>(WoWBase + CanFlyOrSwim + 0x63) == 0x90;
}
```

`Misc.cpp`:

```cpp
#include "OHack.hpp"

handle Misc::KillSwitchThread;
bool HasChecked = false;

void Misc::LoopKillswitch ()
{
	CheckKillswitch();
	Hacks::Init();
	UI::MainView->Activate();
	delete UI::ProgressBar;
	delete UI::LoadingView;
	HasChecked = true;

	while(true)
	{
		Sleep(30000);
		CheckKillswitch();
	}

	return;
}

void Misc::CheckKillswitch ()
{
	try
	{
		char* Path = new char[261];
		ZeroMemory(Path, 261);

		if(URLDownloadToCacheFile(nullptr, "http://dl.dropbox.com/u/15777331/OHack/KillSwitch.txt", Path, 260, 0, nullptr) != S_OK && HasChecked == false)
		{
			throw exception("Unable to check killswitch: File download failed.");
		}

		std::fstream* KillSwitch = new std::fstream(Path, std::ios::in);
		if(KillSwitch->is_open() == false && HasChecked == false)
		{
			throw exception("Unable to check killswitch: Failed to open file.");
		}

		std::string* Contents = new std::string[2];
		std::getline(*KillSwitch, Contents[0]);
		std::getline(*KillSwitch, Contents[1]);
		KillSwitch->close();
		delete KillSwitch;
		DeleteFile(Path);
		delete[] Path;

		if(Contents->find("Enabled") == Contents->npos)
		{
			if(HasChecked == false)
			{
				Notification(UI::MainWindow->GetHandle(), Contents->c_str(), "Message");
			}

			exit(0);
		}

		static unsigned int Version = ThisVersion;
		unsigned int NewVersion = atoi(Contents[1].c_str());
		if(NewVersion > Version)
		{ 
			if(Question(UI::MainWindow->GetHandle(), "A new version of OHack is available. Open the download page?" , "New Version") == true)
			{
				ShellExecute(nullptr, "open", "http://dl.dropbox.com/u/15777331/OHack/Redirect.html", nullptr, nullptr, 0);
			}

			Version = NewVersion;
		}

		delete Contents;
	}
	catch(exception Exception)
	{
		Notification(UI::MainWindow->GetHandle(), Exception.GetException(), "Exception");
		exit(0);
	}

	return;
}
```

`Morph.cpp`:

```cpp
#include "OHack.hpp"

int Hacks::MapID = -1;

void Hacks::Morph ()
{
	if(WoW::IsInGame() == false || WoW::GetPlayer() == 0)
	{
		return;
	}

	unsigned int Unit = WoW::GetTarget() ? WoW::GetTarget() : WoW::GetPlayer();

	if(strlen(UI::MorphBox->GetText()) != 0)
	{
		*reinterpret_cast<unsigned int*>(*reinterpret_cast<unsigned int*>(Unit + Descriptors) + DisplayID) = (atoi(UI::MorphBox->GetText()) == 0 ? *reinterpret_cast<unsigned int*>(*reinterpret_cast<unsigned int*>(Unit + Descriptors) + OriginalDisplayID) : atoi(UI::MorphBox->GetText()));
	}

	if(strlen(UI::ScaleBox->GetText()) != 0 && atof(UI::ScaleBox->GetText()) != 0)
	{
		*reinterpret_cast<float*>(*reinterpret_cast<unsigned int*>(Unit + Descriptors) + ObjectScale) = static_cast<float>(atof(UI::ScaleBox->GetText()));
	}
	
	reinterpret_cast<void (__thiscall*)(unsigned int, unsigned int)>(WoWBase + CGUnit_C__UpdateDisplayInfo)(Unit, 1);
	return;
}

void Hacks::LoadMap ()
{
	if(WoW::IsInGame() == false || strlen(UI::MapBox->GetText()) == 0)
	{
		return;
	}

	MapID = atoi(UI::MapBox->GetText());
	return;
}
```

`Movement.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::StopFall ()
{
	if(WoW::IsInGame() == false || WoW::GetPlayer() == 0)
	{
		return;
	}

	reinterpret_cast<void (__thiscall*)(unsigned int)>(WoWBase + CMovement_C__Halt)(*reinterpret_cast<unsigned int*>(WoW::GetPlayer() + CMovement));
	reinterpret_cast<void (__thiscall*)(unsigned int, unsigned int, unsigned int, unsigned int)>(WoWBase + CGUnit_C__OnCollideFallLandNotify)(WoW::GetPlayer(), *reinterpret_cast<unsigned int*>(reinterpret_cast<unsigned int (__cdecl*)()>(WoWBase + MovementGetGlobals)() + TimestampOffset), *reinterpret_cast<unsigned int*>(WoW::GetPlayer() + CMovement), 1);
	return;
}
```

`NoCollision.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::SetNoCollision (bool State)
{
	if(State == true)
	{
		const byte NoCollision[] = {0x83, 0xC4, 0x10, 0x90, 0x90};
		Write(WoWBase + DoMovementStuff3 + 0x10, NoCollision, 5);
		Write(WoWBase + DoMovementStuff4 + 0xCE, NoCollision, 5);
		Write(WoWBase + DoMovementStuff4 + 0x154, NoCollision, 5);
		UI::NoCollision->SetChecked(GetNoCollision());
	}
	else
	{
		const byte NoCollision1[] = {0xE8, 0x3B, 0xFD, 0xFF, 0xFF};
		const byte NoCollision2[] = {0xE8, 0x1D, 0xBD, 0x0, 0x0};
		const byte NoCollision3[] = {0xE8, 0x97, 0xBC, 0x0, 0x0};
		Write(WoWBase + DoMovementStuff3 + 0x10, NoCollision1, 5);
		Write(WoWBase + DoMovementStuff4 + 0xCE, NoCollision2, 5);
		Write(WoWBase + DoMovementStuff4 + 0x154, NoCollision3, 5);
		UI::NoCollision->SetChecked(GetNoCollision());
	}

	return;
}

bool Hacks::GetNoCollision ()
{
	return Read<byte>(WoWBase + DoMovementStuff3 + 0x10) == 0x83;
}
```

`NoWater.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::SetNoWater (bool State)
{
	if(State == true)
	{
		Write<byte>(WoWBase + CM2Lighting__SetupGxFog_void_ + 0x22, static_cast<byte>(0xEB));
		const byte NoWater[] = {0x90, 0xE9};
		Write(WoWBase + CWorldView__UpdateViewerLiquid_void_+ 0x19D, NoWater, 2);

		const byte NOPs[] = {0x90, 0x90};
		Write(WoWBase + CGUnit_C__UpdateSwimmingStatus + 0x70, NOPs, 2);

		UI::NoWater->SetChecked(GetNoWater());
	}
	else
	{
		Write<byte>(WoWBase + CM2Lighting__SetupGxFog_void_ + 0x22, static_cast<byte>(0x74));
		const byte NoWater[] = {0x0F, 0x84};
		Write(WoWBase + CWorldView__UpdateViewerLiquid_void_ + 0x19D, NoWater, 2);

		const byte NoSwim[] = {0x75, 0x67};
		Write(WoWBase + CGUnit_C__UpdateSwimmingStatus + 0x70, NoSwim, 2);

		UI::NoWater->SetChecked(GetNoWater());
	}

	return;
}

bool Hacks::GetNoWater ()
{
	return Read<byte>(WoWBase + CM2Lighting__SetupGxFog_void_ + 0x22) == 0xEB;
}
```

`OHack.hpp`:

```hpp
#pragma once

#define ThisVersion 10

#include <Windows.h>
#include <UrlMon.h>
#include <Psapi.h>

#include <fstream>
#include <string>

#include <detours.h>

#include "Fail.Dialog.hpp"
#include "Fail.Exception.hpp"
#include "Fail.Handle.hpp"
#include "Fail.Loops.hpp"
#include "Fail.Memory.Local.hpp"
#include "Fail.Object.hpp"
#include "Fail.UI.hpp"
#include "Fail.UI.View.hpp"
#include "Fail.UI.Controls.Button.hpp"
#include "Fail.UI.Controls.CheckBox.hpp"
#include "Fail.UI.Controls.EditBox.hpp"
#include "Fail.UI.Controls.Marquee.hpp"
#include "Fail.UI.Controls.Text.hpp"

#include "Offsets.hpp"

#pragma comment (lib, "UrlMon.lib")
#pragma comment (lib, "Psapi.lib")

using namespace Fail::Dialog;
using namespace Fail::Memory::Local;
using namespace Fail::UI;
using namespace Fail::UI::Controls;
using Fail::exception;
using Fail::handle;

typedef unsigned char byte;

extern unsigned int WoWBase;

namespace UI
{
	extern handle MainThread;

	extern HMODULE Module;

	extern Window* MainWindow;

	extern View* LoadingView;
	extern View* MainView;

	extern Marquee* ProgressBar;

	extern CheckBox* NoWater;
	extern CheckBox* WaterWalk;
	extern CheckBox* ClimbHack;
	extern CheckBox* NoCollision;
	extern CheckBox* HoverHack;
	extern CheckBox* FlyHack;

	extern EditBox* MorphBox;
	extern EditBox* ScaleBox;
	extern Button* MorphButton;

	extern EditBox* MapBox;
	extern Button* MapButton;

	void Create ();
	long __stdcall UICallback (HWND Window, unsigned int Message, WPARAM wParam, LPARAM lParam);
	void CommandHandler (unsigned int Command, WPARAM wParam);
}

namespace Hacks
{
	extern int SetFlyOnFrame;
	extern int SetHoverOnFrame;
	extern int MapID;

	void Init ();

	void StopFall ();
	void Tracking (const char* Track);

	void Morph ();
	void LoadMap ();

	void SetNoWater (bool State);
	bool GetNoWater ();

	void SetWaterWalk (bool State);
	bool GetWaterWalk ();

	void SetClimbHack (bool State);
	bool GetClimbHack ();

	void SetNoCollision (bool State);
	bool GetNoCollision ();

	void SetHover (bool State);
	bool GetHover ();

	void SetFly (bool State);
	bool GetFly ();
}

namespace Misc
{
	extern handle KillSwitchThread;

	void LoopKillswitch ();
	void CheckKillswitch ();
	void SetCommandHook ();
}

namespace WoW
{
	extern bool (__thiscall* Render)(unsigned int);
	bool __fastcall FrameHook (unsigned int This);

	bool IsInGame ();
	void AddChatMessage (const char* Message);
	unsigned int GetPlayer ();
	unsigned int GetTarget ();
	void DoString (const char* String);
}

namespace Warden
{
	extern bool HasEnabled;

	void Enable ();
}
```

`OHack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F64543B7-A7A0-431A-816D-9F524ED95D55}</ProjectGuid>
    <RootNamespace>WoWHack</RootNamespace>
    <ProjectName>OHack</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>OHack</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Fail.Containers.List.hpp" />
    <ClInclude Include="Fail.Dialog.hpp" />
    <ClInclude Include="Fail.Exception.hpp" />
    <ClInclude Include="Fail.Handle.hpp" />
    <ClInclude Include="Fail.Loops.hpp" />
    <ClInclude Include="Fail.Memory.Local.hpp" />
    <ClInclude Include="Fail.Object.hpp" />
    <ClInclude Include="Fail.Types.hpp" />
    <ClInclude Include="Fail.UI.Controls.Button.hpp" />
    <ClInclude Include="Fail.UI.Controls.CheckBox.hpp" />
    <ClInclude Include="Fail.UI.Controls.EditBox.hpp" />
    <ClInclude Include="Fail.UI.Controls.Marquee.hpp" />
    <ClInclude Include="Fail.UI.Controls.Text.hpp" />
    <ClInclude Include="Fail.UI.hpp" />
    <ClInclude Include="Fail.UI.View.hpp" />
    <ClInclude Include="OHack.hpp" />
    <ClInclude Include="Offsets.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ClimbHack.cpp" />
    <ClCompile Include="Commands.cpp" />
    <ClCompile Include="Fly.cpp" />
    <ClCompile Include="Hacks.cpp" />
    <ClCompile Include="Hover.cpp" />
    <ClCompile Include="Misc.cpp" />
    <ClCompile Include="Entry.cpp" />
    <ClCompile Include="Fail.Object.cpp" />
    <ClCompile Include="Fail.UI.cpp" />
    <ClCompile Include="Morph.cpp" />
    <ClCompile Include="Movement.cpp" />
    <ClCompile Include="NoCollision.cpp" />
    <ClCompile Include="NoWater.cpp" />
    <ClCompile Include="Tracking.cpp" />
    <ClCompile Include="UI.cpp" />
    <ClCompile Include="WaterWalk.cpp" />
    <ClCompile Include="WoW.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Offsets.hpp`:

```hpp
#pragma once

#define CGGameUI__CanPerformAction 0x4D0B80
#define Script_UnitLevel 0x054420
#define CM2Lighting__SetupGxFog_void_ 0x319E80
#define CGUnit__CanSwim 0x6258F0
#define CWorldView__UpdateViewerLiquid_void_ 0x353BF0
#define DoMovementStuff1 0x208FD0
#define DoMovementStuff2 0x2096E0
#define DoMovementStuff3 0x331290
#define DoMovementStuff4 0x3251F0
#define CMovement__SetMovementFlags 0x204D50
#define CGUnit_C__OnCollideFallLandNotify 0x1B8140
#define GetUnitFromName 0x050B20
#define IsKnownLanguage 0x165B70
#define CGGameUI__Idle 0x4DCC30
#define CGUnit_C__SetTrackingTarget 0x1C85B0
#define CGGameUI__EnterWorld 0x4D7900
#define CGUnit_C__UpdateDisplayInfo 0x1D9650
#define World__LoadMap 0x323B30
#define World__UnloadMap 0x324EA0
#define CGWorldFrame__Render 0x4E3400
#define CanFlyOrSwim 0x205A10
#define CMovementShared__StopFalling 0x61F8D0
#define MovementGetGlobals 0x1E65E0
#define Script_SendChatMessage 0x4F8140
#define ChatFrame__AddMessage 0x004F4A70
#define Script_JumpOrAscendStart 0x04A390
#define CMovement_C__GetMoveStatus 0x171610
#define CGUnit_C__UpdateSwimmingStatus 0x1D9990
#define CMovement_C__Halt 0x171C00
#define Script_GuildInvite 0x4D29C0
#define CGGameUI__ShowBlockedActionFeedback 0x4C9640
#define CGCamera__UpdateMotion_ulong_ 0x03DBF0
#define FrameScript_ExecuteBuffer 0x43A810
#define CGUnit_C__UnitReaction 0x1BE660
#define TrackingEnumCallback 0x5D1550
#define CGPlayer_C__CanTrackUnit 0x161A40
#define CGPlayer_C__CanTrackObject 0x161AD0
#define CMovementShared__CalcDirection 0x61F1A0
#define CMovement__CalcDirection 0x61DB60
#define SendJump 0x1CD2D0
#define ObfuscateLanguage 0x4EB7D0
#define CGUnit_C__GetCreatureRank 0x1AF990
#define SomeLuaFunction 0x02B170

#define Descriptors 0xC
#define DisplayID 0xF4
#define OriginalDisplayID 0xF8
#define ObjectScale 0x18
#define CMovement 0x100
#define Type 0x14

#define TimestampOffset 0x128

enum MovementFlags
{
	StunnedOrRooted = 0x400,
	Falling = 0x800,
	FallingFar = 0x1000,
	Swimming = 0x100000,
	Flying = 0x1000000,
	Mounted = 0x10000000,
};

enum ObjectTypes
{
	Object = 0,
	Item = 1,
	Container = 2,
	Unit = 3,
	Player = 4,
	GameObject = 5,
	DynamicObject = 6,
	Corpse = 7,
	AiGroup = 8,
	AreaTrigger = 9,
};
```

`README`:

```
OHack - An open source hack for World of Warcraft

You need Detours 1.5 to build it, and it probably won't build with anything other than Visual Studio.

You may reuse any of my code in this hack, as long as you don't sell it, and you must give credit to me (l0l1dk/Fail46).

Make sure that you build it as a DLL.
```

`Tracking.cpp`:

```cpp
#include "OHack.hpp"

bool TrackAll = false;
bool TrackObjects = false;
bool TrackPlayers = false;
bool TrackEnemyPlayers = false;
bool TrackEnemies = false;
bool TrackFriendPlayers = false;;
bool TrackFriends = false;
bool TrackNeutral = false;
bool TrackRares = false;

bool __fastcall CanTrackUnit (unsigned int This, unsigned int, unsigned int ThisObject)
{
	if(TrackAll == true)
	{
		return true;
	}

	if(*reinterpret_cast<unsigned int*>(ThisObject + Type) != ObjectTypes::Unit && *reinterpret_cast<unsigned int*>(ThisObject + Type) != ObjectTypes::Player)
	{
		return false;
	}

	unsigned int Reaction = reinterpret_cast<unsigned int (__thiscall*)(unsigned int, unsigned int)>(WoWBase + CGUnit_C__UnitReaction)(ThisObject, WoW::GetPlayer());
	if(*reinterpret_cast<unsigned int*>(ThisObject + Type) == ObjectTypes::Player)
	{
		if(TrackPlayers == true)
		{
			return true;
		}

		if(Reaction <= 4 && TrackEnemyPlayers == true)
		{
			return true;
		}
		
		if(Reaction >= 5 && TrackFriendPlayers == true)
		{
			return true;
		}
	}

	if(*reinterpret_cast<unsigned int*>(ThisObject + Type) == ObjectTypes::Unit)
	{
		if(Reaction <= 2 && TrackEnemies == true)
		{
			return true;
		}

		if((Reaction == 3 || Reaction == 4) && TrackNeutral == true)
		{
			return true;
		}

		if(Reaction >= 5 && TrackFriends == true)
		{
			return true;
		}

		register unsigned int Classification = reinterpret_cast<unsigned int (__thiscall*)(unsigned int)>(WoWBase + CGUnit_C__GetCreatureRank)(ThisObject);
		if(Classification == 2 || Classification == 4)
		{
			return true;
		}
	}

	return reinterpret_cast<bool (__thiscall*)(unsigned int, unsigned int)>(WoWBase + CGPlayer_C__CanTrackUnit)(This, ThisObject);
}

bool __fastcall CanTrackObject (unsigned int This, unsigned int, unsigned int ThisObject)
{
	if(TrackObjects == true)
	{
		return true;
	}

	return reinterpret_cast<bool (__thiscall*)(unsigned int, unsigned int)>(WoWBase + CGPlayer_C__CanTrackObject)(This, ThisObject);
}

void Hacks::Tracking (const char* Track)
{
	if(Read<unsigned int>(WoWBase + TrackingEnumCallback + 0x44C) != reinterpret_cast<unsigned int>(CanTrackUnit) - (WoWBase + TrackingEnumCallback + 0x44C + 0x4))
	{
		Write<unsigned int>(WoWBase + TrackingEnumCallback + 0x44C, reinterpret_cast<unsigned int>(CanTrackUnit) - (WoWBase + TrackingEnumCallback + 0x44C + 0x4));
		Write<unsigned int>(WoWBase + TrackingEnumCallback + 0x44C, reinterpret_cast<unsigned int>(CanTrackUnit) - (WoWBase + TrackingEnumCallback + 0x44C + 0x4));
	}

	static char Message[256];
	ZeroMemory(Message, 256);

	if(_strcmpi(Track, "players") == 0)
	{
		TrackPlayers = !TrackPlayers;
		sprintf_s(Message, "Player tracking %s.", TrackPlayers ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "enemyplayers") == 0)
	{
		TrackEnemyPlayers = !TrackEnemyPlayers;
		sprintf_s(Message, "Enemy player tracking %s.", TrackEnemyPlayers ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "friendlyplayers") == 0)
	{
		TrackFriendPlayers = !TrackFriendPlayers;
		sprintf_s(Message, "Friendly player tracking %s.", TrackFriendPlayers ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "enemies") == 0)
	{
		TrackEnemies = !TrackEnemies;
		sprintf_s(Message, "Enemy unit tracking %s.", TrackEnemies ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "friendly") == 0)
	{
		TrackFriends = !TrackFriends;
		sprintf_s(Message, "Friendly unit tracking %s.", TrackFriends ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "neutral") == 0)
	{
		TrackNeutral = !TrackNeutral;
		sprintf_s(Message, "Neutral unit tracking %s.", TrackNeutral ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "objects") == 0)
	{
		TrackObjects = !TrackObjects;
		sprintf_s(Message, "Object tracking %s.", TrackObjects ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "rares") == 0)
	{
		TrackRares = !TrackRares;
		sprintf_s(Message, "Rare tracking %s.", TrackRares ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "all") == 0)
	{
		TrackAll = !TrackAll;
		sprintf_s(Message, "Tracking all %s.", TrackAll ? "enabled" : "disabled");
		WoW::AddChatMessage(Message);
		return;
	}

	if(_strcmpi(Track, "off") == 0)
	{
		TrackAll = false;
		TrackObjects = false;
		TrackPlayers = false;
		TrackEnemyPlayers = false;
		TrackFriendPlayers = false;
		TrackEnemies = false;
		TrackFriends = false;
		TrackNeutral = false;
		WoW::AddChatMessage("Tracking disabled.");
		return;
	}

	return;
}
```

`UI.cpp`:

```cpp
#include "OHack.hpp"

handle UI::MainThread;

HMODULE UI::Module;
Window* UI::MainWindow;

View* UI::LoadingView;
View* UI::MainView;

Marquee* UI::ProgressBar;

CheckBox* UI::NoWater;
CheckBox* UI::WaterWalk;
CheckBox* UI::ClimbHack;
CheckBox* UI::NoCollision;
CheckBox* UI::HoverHack;
CheckBox* UI::FlyHack;

EditBox* UI::MorphBox;
EditBox* UI::ScaleBox;
Button* UI::MorphButton;

EditBox* UI::MapBox;
Button* UI::MapButton;

void UI::Create ()
{
	try
	{
		CreateWindowClass(0, UI::UICallback, "OHack", Module);
		MainWindow = new Window ("OHack", "OHack", WS_EX_CLIENTEDGE | WS_EX_DLGMODALFRAME, WS_SYSMENU | WS_MINIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, 300, 100, Module);
		MainWindow->EnterMessageLoop();
	}
	catch(exception Exception)
	{
		Notification(MainWindow->GetHandle(), Exception.GetException(), "Exception");
	}

	exit(0);
	return;
}

long __stdcall UI::UICallback (HWND WindowHandle, unsigned int Message, WPARAM wParam, LPARAM lParam)
{
	try
	{
		static Window* ThisWindow = new Window (WindowHandle);
	
		switch(Message)
		{
		case WM_CREATE:
		{
			ProgressBar = new Marquee (5, 5, 282, 25, ThisWindow->GetHandle(), Module);
		
			NoWater = new CheckBox ("No Water", 10, 5, 80, 20, ThisWindow->GetHandle(), 1, Hacks::GetNoWater(), Module);
			WaterWalk = new CheckBox ("Water Walk", 105, 5, 80, 20, ThisWindow->GetHandle(), 2, Hacks::GetWaterWalk(), Module);
			ClimbHack = new CheckBox ("Climb Hack", 10, 30, 80, 20, ThisWindow->GetHandle(), 3, Hacks::GetClimbHack(), Module);
			NoCollision = new CheckBox ("No Collision", 105, 30, 80, 20, ThisWindow->GetHandle(), 6, Hacks::GetNoCollision(), Module);
			HoverHack = new CheckBox ("Hover Hack", 10, 55, 80, 20, ThisWindow->GetHandle(), 7, Hacks::GetHover(), Module);
			FlyHack = new CheckBox ("Fly Hack", 105, 55, 80, 20, ThisWindow->GetHandle(), 8, Hacks::GetFly(), Module);
			
			Text* MorphLabel = new Text ("Model ID:", 0, 100, 55, 15, ThisWindow->GetHandle(), Module);
			Text* ScaleLabel = new Text ("Scale:", 0, 120, 55, 15, ThisWindow->GetHandle(), Module);
			Text* MapLabel = new Text ("Map ID:", 0, 150, 55, 15, ThisWindow->GetHandle(), Module);

			MorphBox = new EditBox (nullptr, ES_NUMBER | ES_CENTER, 55, 100, 80, 15, ThisWindow->GetHandle(), 0, Module);
			ScaleBox = new EditBox (nullptr, ES_CENTER, 55, 120, 80, 15, ThisWindow->GetHandle(), 0, Module);
			MorphBox->LimitCharacters(5);
			ScaleBox->LimitCharacters(5);
			MorphButton = new Button ("Morph", 140, 98, 50, 40, ThisWindow->GetHandle(), 4, Module);

			MapBox = new EditBox (nullptr, ES_NUMBER | ES_CENTER, 55, 150, 80, 15, ThisWindow->GetHandle(), 0, Module);
			MapButton = new Button ("Load", 140, 147, 50, 24, ThisWindow->GetHandle(), 5, Module);

			LoadingView = new View (ThisWindow->GetHandle(), 300, 65, "OHack");
			MainView = new View (ThisWindow->GetHandle(), 200, 205, "OHack");

			LoadingView->AddControl(ProgressBar->GetHandle());

			MainView->AddControl(NoWater->GetHandle());
			MainView->AddControl(WaterWalk->GetHandle());
			MainView->AddControl(ClimbHack->GetHandle());
			MainView->AddControl(MorphBox->GetHandle());
			MainView->AddControl(ScaleBox->GetHandle());
			MainView->AddControl(MorphButton->GetHandle());
			MainView->AddControl(MorphLabel->GetHandle());
			MainView->AddControl(ScaleLabel->GetHandle());
			MainView->AddControl(MapLabel->GetHandle());
			MainView->AddControl(MapBox->GetHandle());
			MainView->AddControl(MapButton->GetHandle());
			MainView->AddControl(NoCollision->GetHandle());
			MainView->AddControl(HoverHack->GetHandle());
			MainView->AddControl(FlyHack->GetHandle());

			LoadingView->Activate();
			return 0;
		}
		case WM_COMMAND:
			CommandHandler(LOWORD(wParam), wParam);
			return 0;

		case WM_CLOSE:
		case WM_DESTROY:
			Notification(ThisWindow->GetHandle(), "You must restart World of Warcraft to unload OHack.");
			return 0;

		default:
			return DefWindowProc(WindowHandle, Message, wParam, lParam);
		}
	}
	catch(exception Exception)
	{
		Notification(MainWindow->GetHandle(), Exception.GetException(), "Exception");
	}

	return 0;
}

void UI::CommandHandler (unsigned int Command, WPARAM wParam)
{
	switch(Command)
	{
	case 1:
		Hacks::SetNoWater(!NoWater->IsChecked());
		break;

	case 2:
		Hacks::SetWaterWalk(!WaterWalk->IsChecked());
		break;

	case 3:
		Hacks::SetClimbHack(!ClimbHack->IsChecked());
		break;

	case 4:
		Hacks::Morph();
		break;

	case 5:
		Hacks::LoadMap();
		break;

	case 6:
		Hacks::SetNoCollision(!NoCollision->IsChecked());
		break;

	case 7:
		Hacks::SetHoverOnFrame = HoverHack->IsChecked() ? 0 : 1;
		break;

	case 8:
		Hacks::SetFlyOnFrame = FlyHack->IsChecked() ? 0 : 1;
		break;
	}

	return;
}
```

`WaterWalk.cpp`:

```cpp
#include "OHack.hpp"

void Hacks::SetWaterWalk (bool State)
{
	if(State == true)
	{
		Write<byte>(WoWBase + CMovement__SetMovementFlags + 0xD, static_cast<byte>(0x11));
		UI::WaterWalk->SetChecked(GetWaterWalk());
	}
	else
	{
		Write<byte>(WoWBase + CMovement__SetMovementFlags + 0xD, static_cast<byte>(0x10));
		UI::WaterWalk->SetChecked(GetWaterWalk());
	}

	return;
}

bool Hacks::GetWaterWalk ()
{
	return Read<byte>(WoWBase + CMovement__SetMovementFlags + 0xD) == 0x11;
}
```

`WoW.cpp`:

```cpp
#include "OHack.hpp"

int Hacks::SetFlyOnFrame = -1;
int Hacks::SetHoverOnFrame = -1;
unsigned int PlayerAddress = 0;
unsigned int TargetAddress = 0;

bool (__thiscall* WoW::Render)(unsigned int);
bool __fastcall WoW::FrameHook (unsigned int This)
{
	if(Hacks::MapID != -1)
	{
		reinterpret_cast<void (__cdecl*)()>(WoWBase + World__UnloadMap)();
		int Unknown = 0;
		reinterpret_cast<int (__cdecl*)(int, int*)>(WoWBase + World__LoadMap)(atoi(UI::MapBox->GetText()), &Unknown);
		Hacks::MapID = -1;
	}

	// Can only toggle the fly and hover hack correctly from the main thread.
	if(Hacks::SetFlyOnFrame != -1)
	{
		Hacks::SetFly(Hacks::SetFlyOnFrame == 1);
		Hacks::SetFlyOnFrame = -1;
	}

	if(Hacks::SetHoverOnFrame != -1)
	{
		Hacks::SetHover(Hacks::SetHoverOnFrame == 1);
		Hacks::SetHoverOnFrame = -1;
	}

	// Have to do this because these functions use TLS, and therefore only work from the main thread.
	PlayerAddress = reinterpret_cast<unsigned int (__cdecl*)(const char*)>(WoWBase + GetUnitFromName)("Player");
	TargetAddress = reinterpret_cast<unsigned int (__cdecl*)(const char*)>(WoWBase + GetUnitFromName)("Target");
	return Render(This);
}

bool WoW::IsInGame ()
{
	return **reinterpret_cast<byte**>(WoWBase + CGGameUI__EnterWorld + 0xB) == 1;
}

void WoW::AddChatMessage (const char* Message)
{
	reinterpret_cast<void (__cdecl*)(const char*, unsigned int, unsigned int)>(WoWBase + ChatFrame__AddMessage)(Message, 0x25, 0);
	return;
}

unsigned int WoW::GetPlayer ()
{
	return PlayerAddress;
}

unsigned int WoW::GetTarget ()
{
	return TargetAddress;
}

void WoW::DoString (const char* String)
{
	reinterpret_cast<void (__cdecl*)(const char*, const char*, unsigned int)>(WoWBase + FrameScript_ExecuteBuffer)(String, String, 1);
	return;
}
```