Project Path: arc_gmh5225_VACKeyRetrieval_v17omz_w

Source Tree:

```txt
arc_gmh5225_VACKeyRetrieval_v17omz_w
├── LCGSeedRetrieval
│   ├── LCGSeedRetrieval.cpp
│   ├── LCGSeedRetrieval.vcxproj
│   └── LCGSeedRetrieval.vcxproj.filters
├── LCGSeedRetrieval.sln
└── README.md

```

`LCGSeedRetrieval.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LCGSeedRetrieval", "LCGSeedRetrieval\LCGSeedRetrieval.vcxproj", "{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Debug|x64.ActiveCfg = Debug|x64
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Debug|x64.Build.0 = Debug|x64
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Debug|x86.ActiveCfg = Debug|Win32
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Debug|x86.Build.0 = Debug|Win32
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Release|x64.ActiveCfg = Release|x64
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Release|x64.Build.0 = Release|x64
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Release|x86.ActiveCfg = Release|Win32
		{82970F8E-C68E-4E66-8C1F-93AB7EBB1173}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {352F2BE5-572C-42C8-B7C6-216D97472E98}
	EndGlobalSection
EndGlobal

```

`LCGSeedRetrieval/LCGSeedRetrieval.cpp`:

```cpp
#include <iostream>
#include <intrin.h>
#include <stdlib.h>
#include <list>
#include <vector>
#include <map>

#pragma intrinsic(__rdtsc)

#define MODULUS 2147483647
#define MULTIPLIER 16807

int VAClcg_orig(int seed[100])
{
	int seed0; // esi
	int seed1; // ebx
	int* v4; // ebp
	int i; // ebx
	int something; // ecx
	int some_other_thing; // edx
	int seed0_1; // esi
	int result; // eax

	seed0 = *seed;
	if (*seed <= 0 || (seed1 = seed[1]) == 0)
	{
		// this is first run
		seed0 = -seed0;
		v4 = seed + 41;
		if (seed0 < 1)
			seed0 = 1;
		for (i = 39; i >= 0; --i)
		{
			something = 16807 * seed0 - 0x7FFFFFFF * (seed0 / 127773);
			seed0 = something + 0x7FFFFFFF;
			if (something >= 0)
				seed0 = something;
			if (i < 32)
				*v4 = seed0;
			--v4;
		}
		seed1 = seed[2];
		seed[1] = seed1;
	}
	// https://en.wikipedia.org/wiki/Lehmer_random_number_generator#Schrage's_method
	// https://chromium.googlesource.com/native_client/nacl-newlib/+/master/newlib/libc/stdlib/rand_r.c
	// https://dl.acm.org/doi/10.1145/63039.63042
	// https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/random.tcc#L43C30-L43C30
	some_other_thing = 16807 * seed0 - 0x7FFFFFFF * (seed0 / 127773);
	seed0_1 = some_other_thing + 0x7FFFFFFF;
	if (some_other_thing >= 0)
		seed0_1 = some_other_thing;
	// long long test = (16807 * (long long)seed0) % 2147483647; // need long long because of potential overflow from 16807 * seed0
	// std::cout << (test == seed0_1) << std::endl;
	// int test2 = (16807 * (seed0 % 127773)) - 2836 * (seed0 / 127773); // this works! (Schrage's method, avoids overflow)

	int result_index = seed1 / 0x4000000 + 2; // this is based on last result
	seed[1] = seed[result_index]; // this is some previous seed, we need to find out which one
	seed[result_index] = seed0_1;
	result = seed[1];
	*seed = seed0_1;
	return result;
}

// A naive method to find modular
// multiplicative inverse of 'A'
// under modulo 'M'
long long modInverse(long long A, int M)
{
	for (int X = 1; X < M; X++)
		if (((A % M) * (X % M)) % M == 1)
			return X;
}

// https://math.stackexchange.com/questions/3846942/reversing-an-lcg
// this gets the previous seed from the input seed
int reverseOne(long long next) {
	int modInversed = 0x53e77248; // modInverse(MULTIPLIER, MODULUS);
	long long reversed = (next * modInversed) % MODULUS;
	return reversed;
}

void retrieve_key(int sentVals[100], int ret_buff_out_size) {
	std::map<int, int> result_index_map;
	bool dupeIndex = false;

	int seed0;
	int seed0Index;

	for (int i = 0; i < 0x22; i++) {
		if (dupeIndex) {
			// this is a dupe result, so the return value is a seed generated on a known index
			seed0 = sentVals[i];
			std::cout << "seed0: " << std::hex << seed0 << std::endl;
			break;
		}

		int next_result_index = (sentVals[i] / 0x4000000) + 2; // the result index of the next run
		auto it = result_index_map.find(next_result_index);
		if (it != result_index_map.end()) {
			// already contains this result index
			// this means that when we do result = seed[result_index]; the returned value will be a previous seed
			// because on the last run with the same result index: seed[result_index] = seed0;
			// if we know on what iteration that happened (i) we can reverse the original seed using reverseOne();
			// this will happen for sure because we run more times than array size: (actually not sure about that since VAC modules send less, but seems to work)
			// arrSize = 0x22 - 2 (indexes 0, 1 which aren't used as result index), we run 0x22 times.

			seed0Index = it->second + 1;
			std::cout << "list already contains index!!!!: " << next_result_index << " i: " << seed0Index << std::endl;
			dupeIndex = true;
		}
		// add result index to map
		result_index_map[next_result_index] = i + 1;
	}

	// use reverseOne to reverse the original seed
	int reversed = seed0;
	// this is just for calculating how many values were generated before the values sent to the server,
	// we use this to know how many reverseOne() calls we need until we get the original seed.
	int moduleConst = 0x422 - (ret_buff_out_size / 4) + 26;
	for (int j = 0; j < seed0Index + 0x1f + moduleConst; j++)
	{
		reversed = reverseOne(reversed);
		// std::cout << std::hex << -reversed << std::endl;
	}
	// on the first VAClcg() the original seed is negated so we negate it back to get the original
	reversed = -reversed;
	std::cout << "Retrieved initial seed: " << reversed << std::endl;

	// use original seed to retrieve key, by generating it
	int retrievedSeed[100] = { 0 };
	retrievedSeed[0] = reversed;
	// first call
	int res = VAClcg_orig(retrievedSeed);
	for (int i = 0; i <= 2; i++) {
		res = VAClcg_orig(retrievedSeed);
		if (i == 1 || i == 2) { // key is 3rd and 4th random calls
			std::cout << "retrieved key: " << std::hex << res << std::endl;
		}
	}
	// the key is char[8], we print it in two parts (could be easily converted to int64_t etc...)
}

int main()
{
	// simulate what the VAC module does (generate key from seed, and generate sentVals)
	//int seed[100] = { 0 };
	//*seed = 0x94079E2E; // VAC does: -std::abs(__rdtsc());

	//std::cout << "init seed: " << std::hex << *seed << std::endl;
	//int res0 = VAClcg_orig(seed);
	//std::cout << "after first run seed: " << std::hex << *seed << std::endl;
	//for (int i = 0; i < 0x1f; i++) {
	//	res0 = VAClcg_orig(seed);
	//	if (i == 1 || i == 2) { // key is 3rd and 4th random calls
	//		std::cout << "key: " << std::hex << res0 << std::endl;
	//	}

	//	// std::cout << "result= " << res0 << std::endl;
	//	// std::cout << "old seed prediction: " << std::hex << reverseOne(*seed) << std::endl;
	//	// std::cout << "new seed:            " << std::hex << *seed << std::endl;
	//}

	//int sentVals[100] = { 0 };
	//// generate sent to server
	//for (int i = 0; i < 0x22; i++) {
	//	int res = VAClcg_orig(seed);
	//	sentVals[i] = res;
	//	std::cout << "sent to server: " << std::hex << res << std::endl;
	//}

	// this is module_return_buffer[1043] until end,
	// these are the random values than the module sends to the server for it to retrieve the encryption key.
	int sentVals[100] =
		{ 0x1755E699,0x6AEF761E, 0x0A2C7BE3, 0x0F33E26B, 0x7F04C3B3, 0x2B4DE1E5, 0x4127D259, 0x4B1D36A8,0x89652C7, 0x4374FDD7, 0x5B0B2623, 0x24E18B42, 0x39E67DAB, 0x5175FEB3, 0x45148B38 };
	
	// retrive key from sentVals
	int ret_buff_out_size = 0xC00; // this is a const for module B330ABA9 (first one that runs when game is launched), most modules use 0x1000
	retrieve_key(sentVals, ret_buff_out_size);

	return 0;
}

```

`LCGSeedRetrieval/LCGSeedRetrieval.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{82970f8e-c68e-4e66-8c1f-93ab7ebb1173}</ProjectGuid>
    <RootNamespace>LCGSeedRetrieval</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="LCGSeedRetrieval.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`LCGSeedRetrieval/LCGSeedRetrieval.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LCGSeedRetrieval.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# VACKeyRetrieval
Retrieves VAC module <a href="https://en.wikipedia.org/wiki/ICE_(cipher)"> Ice </a> encryption key by reversing the LCG seed that it was generated with.
<br>
VAC modules generate the output Ice encryption key using the LCG algorithm, it then sends some generated values.
<br>
We can get the initial LCG seed and thus the Ice key from those values because the LCG algorithm is weak. (probably what they do server-side)

<h1> How It Works </h1>
The VAC module does something like this (not exactly, just pseudocode):

``` c++
int seed_arr[34] = {0};
seed_arr[0] = __rdtsc(); // https://c9x.me/x86/html/file_module_x86_id_278.html
int output_arr[0x20];
for (int i = 0; i < 0x20; i++)
    output_arr[i++] = random(seed_arr);

uint64_t ice_key = *((uint64_t *)&output_arr[2]); // ice_key is output_arr[2], output_arr[3]

for (int i = 0; i < 0x10; ++i )
      output_buffer[0x1000 + i] = random(seed_arr);
```
What this basically means is, the module generates the Ice key using the random() function with the array seed_arr, it then proceeds to generate some more values using the same seed_arr and send the to the output buffer (which goes to server after).
<br>
Obviously, the server is able to decrypt the output so it is possible using only the return buffer, but how can it be done?

<h2> Reversing LCGs </h2>
<br>
<a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"> Learn what an LCG is. </a>
<br>
<a href="https://math.stackexchange.com/questions/3846942/reversing-an-lcg"> Learn how to reverse an lcg </a>
<br>
<br>

<h2> Specifics </h2>
Let's now look at VACs "custom" LCG generator:

```c++
int VAClcg_orig(int seed_arr[100])
{
	if (*seed_arr <= 0 || (seed[1] = seed_arr[1]) == 0)
	{
		// this is first run
		seed_arr[0] = -seed_arr[0];
		v4 = seed_arr + 41;
		if (seed_arr[0] < 1)
			seed_arr[0] = 1;
		for (i = 39; i >= 0; --i)
		{
			int num = 16807 * seed_arr[0] - 0x7FFFFFFF * (seed_arr[0] / 127773);
			seed_arr[0] = num + 0x7FFFFFFF;
			if (num >= 0)
				seed_arr[0] = num;
			if (i < 32)
				*v4 = seed_arr[0];
			--v4;
		}
		seed_arr[1] = seed_arr[2];
	}
	// https://en.wikipedia.org/wiki/Lehmer_random_number_generator#Schrage's_method
	// this is the same as (16807 * (long long)seed[0]) % 2147483647
	// this avoids overflow in 16807 * seed0
	int num = 16807 * seed_arr[0] - 0x7FFFFFFF * (seed_arr[0] / 127773);
	seed_arr[0] = num + 0x7FFFFFFF;
	if (num >= 0)
		seed_arr[0] = num;

    // this is based on last result
	int result_index = seed_arr[1] / 0x4000000 + 2; 
    // this is some previous seed, we need to find out which one
	seed_arr[1] = seed_arr[result_index]; 
	seed_arr[result_index] = seed[0];
	return seed_arr[1];
}
```

The if part is only on the first run, let's focus on the last part: <br>
The algorithm generates a number using an LCG algorithm, with seed_arr[0] used as the seed, we know how to reverse this operation (look above). 
<br> 
After that, the algorithm calculates some index result_index, and returns the current value of seed_arr[result_index] (which was generated in some iteration earlier), it also sets seed_arr[result_index] to be the number which we have generated this iteration.
<br>
In other words the algorithm scrambles the generated numbers "randomly" in the array.
<br>
<h2> The Problem </h2>
<br>
Because we know how to reverse the LCG generation process, one could think that we could just take the values the module stores in the output buffer, and reverse until the initial seed, but how would we know how many "generation" we need to go back to get to the initial seed?
<br>
If not for the array scrambling part of the algorithm, we would easily know how many "generation"s happened before the numbers sent in the output buffer were generated, and go back from there.
<br>
But how can we know how many "generation"s happened before the numbers in the output buffer, considering that the outputs were actually generated some number of generations earlier?
<br>
<h2> The Solution </h2>
<br>
First, let's observe that we can know the result_index value of the next iteration of the algorithm (by doing (result - 2) * 0x4000000), so we know where the next generated value will be stored.
<br>
We also have multiple generated numbers, which were generated one after another (look pseudocode above), so how could we use that?
<br>
If two "generation"s store in the same result_index (which we know how to calculate), the second one returns the generated value of the first one, but we also know in which iteration that value was generated, because we know when the first iteration was called.
<br>
So when two iterations use the same result_index, we have all we need to know, we have a value that we know on which iteration it was generated, we can "go back" from this value (using LCG reversal) the needed amount to get the original seed (look in retrieve_key function for better understanding).
<br>
Now that we have the initial seed, we can easily generate the Ice key ourselves, <b> Profit! </b> 
<br>
<b>Note: </b> duplicate result_indexes always happen.

```