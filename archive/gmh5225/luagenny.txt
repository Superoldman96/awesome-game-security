Project Path: arc_gmh5225_luagenny_dlq0v5u_

Source Tree:

```txt
arc_gmh5225_luagenny_dlq0v5u_
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── src
│   ├── LuaGenny.cpp
│   └── LuaGenny.hpp
├── test
│   └── Main.cpp
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Regenerate CMakeLists.txt automatically in the root project
set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()


project(sdkgenny-lua)

if(CMKR_ROOT_PROJECT AND NOT CMKR_DISABLE_VCPKG)
	include(FetchContent)
	message(STATUS "Fetching vcpkg (2022.05.10)...")
	FetchContent_Declare(vcpkg URL "https://github.com/microsoft/vcpkg/archive/refs/tags/2022.05.10.tar.gz")
	FetchContent_GetProperties(vcpkg)
	if(NOT vcpkg_POPULATED)
		FetchContent_Populate(vcpkg)
		include("${vcpkg_SOURCE_DIR}/scripts/buildsystems/vcpkg.cmake")
	endif()
endif()

include(FetchContent)

message(STATUS "Fetching sdkgenny (f03026eaced3bd033e201bc7d1c9d9d348054113)...")
FetchContent_Declare(sdkgenny
	GIT_REPOSITORY
		"https://github.com/cursey/sdkgenny.git"
	GIT_TAG
		f03026eaced3bd033e201bc7d1c9d9d348054113
)
FetchContent_MakeAvailable(sdkgenny)

# Packages
find_package(pegtl REQUIRED)

find_package(lua)

find_package(sol2)

# Target sdkgenny-lua
set(CMKR_TARGET sdkgenny-lua)
set(sdkgenny-lua_SOURCES "")

list(APPEND sdkgenny-lua_SOURCES
	"src/LuaGenny.cpp"
	"src/LuaGenny.hpp"
)

list(APPEND sdkgenny-lua_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${sdkgenny-lua_SOURCES})
add_library(sdkgenny-lua STATIC)

if(sdkgenny-lua_SOURCES)
	target_sources(sdkgenny-lua PRIVATE ${sdkgenny-lua_SOURCES})
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${sdkgenny-lua_SOURCES})

target_compile_features(sdkgenny-lua PUBLIC
	cxx_std_17
)

target_compile_options(sdkgenny-lua PUBLIC
	"/bigobj"
)

target_link_libraries(sdkgenny-lua PUBLIC
	lua
	sol2::sol2
	sdkgenny
)

if(${VCPKG_TARGET_TRIPLET} MATCHES ".+static") # static
	set_target_properties(sdkgenny-lua PROPERTIES
		MSVC_RUNTIME_LIBRARY
			"MultiThreaded$<$<CONFIG:Debug>:Debug>"
	)
endif()

unset(CMKR_TARGET)
unset(CMKR_SOURCES)

# Target test
set(CMKR_TARGET test)
set(test_SOURCES "")

list(APPEND test_SOURCES
	"test/Main.cpp"
)

list(APPEND test_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${test_SOURCES})
add_executable(test)

if(test_SOURCES)
	target_sources(test PRIVATE ${test_SOURCES})
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT test)
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${test_SOURCES})

target_compile_features(test PRIVATE
	cxx_std_17
)

target_include_directories(test PRIVATE
	src
)

target_link_libraries(test PRIVATE
	lua
	sol2::sol2
	sdkgenny-lua
	sdkgenny
)

if(${VCPKG_TARGET_TRIPLET} MATCHES ".+static") # static
	set_target_properties(test PROPERTIES
		MSVC_RUNTIME_LIBRARY
			"MultiThreaded$<$<CONFIG:Debug>:Debug>"
	)
endif()

unset(CMKR_TARGET)
unset(CMKR_SOURCES)


```

`LICENSE`:

```
MIT License

Copyright (c) 2022 praydog

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# sdkgenny-lua
Lua bindings for [sdkgenny](https://github.com/cursey/sdkgenny)

## Examples
```
PS F:\Programming\projects\sdkgenny-lua\build\Debug> .\test.exe
0x223aa80d010
> baz = sdkgenny.StructOverlay.new(0x223aa80d010, parsed:global_ns():struct("Baz")) 
> print(tostring(baz.things:address()))
2352207548688
> print(tostring(baz.things[0]))        
sol.luagenny::api::StructOverlay: 00000223AA7D8338
> print(tostring(baz.things[0].abc)) 
0
> print(tostring(baz.things[1].abc))
2
> print(tostring(baz.things[2].abc))
4
> print(tostring(baz.hello))
Hello, world!
> print(tostring(baz.im_true))
true
> print(tostring(baz.im_false))
false
> print(tostring(baz.im_also_true))
true
> print(tostring(baz.ta.hours))     
40
```

gennyfile used
```cpp
constexpr auto gennyfile = R"(
type int 4 [[i32]]
type float 4 [[f32]]
type ushort 2 [[u16]]
type str 8 [[utf8*]]
type wstr 8 [[utf16*]]
type bool 1 [[bool]]
type uintptr_t 8 [[u64]]
type char 1
type wchar_t 2

struct RTTITest{}

enum Place {
    EARTH = 1,
    MOON = 2,
    MARS = 3,
}

struct Date {
    ushort nWeekDay : 3
    ushort nMonthDay : 6
    ushort nMonth : 5
    ushort nYear : 8
}

struct Foo {
    int a
    int b
    float c
    Place p
    Place bf1 : 4
    Place bf2 : 2
}

struct Bar {
    int d
    Foo* foo
    int[4][3] m
    Date date
}

struct Thing {
    int abc
}

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}

struct Baz : Bar 0x100 {
	TA ta
    int e
    int thing
    int* f
    Foo g
    Thing* things
    char* hello [[utf8*]]
    //wchar_t* wide_hello [[utf16*]]
    //char[32] intrusive_hello [[utf8*]]
    bool im_true +40
    bool im_false
    bool im_also_true
	//RTTITest* test + 5
}

struct RTTITest 0x100 {
	uintptr_t** vtable
}
)";
```

```

`cmake.toml`:

```toml
[project]
name = "sdkgenny-lua"
cmake-before = """
"""

[vcpkg]
version = "2022.05.10"
packages = [
    "pegtl",
    "lua",
    "sol2"
]

[fetch-content.sdkgenny]
git = "https://github.com/cursey/sdkgenny.git"
tag = "f03026eaced3bd033e201bc7d1c9d9d348054113" 


[find-package]
pegtl = {}
lua = { required = false }
sol2 = { required = false }

[conditions]
static = "${VCPKG_TARGET_TRIPLET} MATCHES \".+static\""

[target.sdkgenny-lua]
type = "static"
sources = [
    "src/**.cpp",
    "src/**.hpp",
]
link-libraries = [
    "lua",
    "sol2::sol2",
    "sdkgenny"
]
compile-features = ["cxx_std_17"]
compile-options = ["/bigobj"]

[target.sdkgenny-lua.properties]
static.MSVC_RUNTIME_LIBRARY = "MultiThreaded$<$<CONFIG:Debug>:Debug>"

[target.test]
type = "executable"
sources = ["test/Main.cpp"]
include-directories = [
    "src",
]
link-libraries = [
    "lua",
    "sol2::sol2",
    "sdkgenny-lua",
    "sdkgenny"
]
compile-features = ["cxx_std_17"]

[target.test.properties]
static.MSVC_RUNTIME_LIBRARY = "MultiThreaded$<$<CONFIG:Debug>:Debug>"
```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.14" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`src/LuaGenny.cpp`:

```cpp
#include <vector>
#include <fstream>

extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#include <sol/sol.hpp>

#include <Genny.hpp>
#include <GennyParser.hpp>

#include "LuaGenny.hpp"

namespace luagenny {
static constexpr auto hash(std::string_view data) {
    size_t result = 0xcbf29ce484222325;

    for (char c : data) {
        result ^= c;
        result *= (size_t)1099511628211;
    }

    return result;
}

constexpr auto operator "" _fnv(const char* s, size_t) {
    return hash(s);
}

namespace api {
sol::object standalone_parse(sol::this_state s, uintptr_t address, genny::Type* t, genny::Variable* v = nullptr);

template<typename T>
class Overlay {
public:
    Overlay(uintptr_t address, T* t) 
        : m_address(address),
        m_type{t}
    {
    }

    virtual sol::object index(sol::this_state s, sol::object key) = 0;

    sol::object type_(sol::this_state s) const {
        return sol::make_object(s, m_type);
    }

    sol::object address(sol::this_state s) const {
        return sol::make_object(s, m_address);
    }

protected:
    uintptr_t m_address{};
    T* m_type{};
};

class StructOverlay : public Overlay<genny::Struct> {
public:
    StructOverlay(uintptr_t address, genny::Struct* s) 
        : Overlay(address, s)
    {
    }

    sol::object index(sol::this_state s, sol::object key) override {
        if (key.is<int>()) {
            // Pretend it's an inlined array
            return sol::make_object(s, StructOverlay{m_address + (key.as<int>() * m_type->size()), m_type});
        }

        if (!key.is<std::string>()) {
            return sol::make_object(s, sol::nil);
        }

        const auto name = key.as<std::string>();
        const auto v = m_type->find<genny::Variable>(name);

        if (v == nullptr || v->type() == nullptr) {
            return sol::make_object(s, sol::nil);
        }

        const auto value = parse_and_read(s, v);

        return sol::make_object(s, value);
    }

protected:
    sol::object parse_and_read(sol::this_state s, genny::Variable* v) {
        const auto offset = v->offset();

        if (offset > m_type->size()) {
            throw std::runtime_error("offset out of bounds");
            return sol::make_object(s, sol::nil);
        }

        const auto address = m_address + offset;

        return sol::make_object(s, standalone_parse(s, address, v->type(), v));
    }
};

sol::object standalone_parse(sol::this_state s, uintptr_t address, genny::Type* t, genny::Variable* v) {
    if (t == nullptr) {
        return sol::make_object(s, address);
    }

    if (t->is_a<genny::Struct>()) {
        return sol::make_object(s, StructOverlay{address, dynamic_cast<genny::Struct*>(t)});
    }

    const auto is_pointer = t->is_a<genny::Pointer>();
    genny::Type* pointer_t = nullptr;

    auto metadata = t->metadata();

    if (metadata.empty() && v != nullptr) {
        metadata = v->metadata();
    }

    if (is_pointer) {
        address = *reinterpret_cast<uintptr_t*>(address);

        if (address == 0) {
            return sol::make_object(s, sol::nil);
        }

        pointer_t = dynamic_cast<genny::Pointer*>(t)->to();

        if (pointer_t->is_a<genny::Pointer>()) {
            return standalone_parse(s, address, pointer_t);
        }

        if (pointer_t->is_a<genny::Struct>()) {
            return sol::make_object(s, StructOverlay{address, dynamic_cast<genny::Struct*>(pointer_t)});
        }

        //metadata = pointer_t->metadata();
    }


    if (metadata.empty()){
        throw std::runtime_error("No metadata for type");
        return sol::make_object(s, sol::nil);
    }

    for (auto&& md : metadata) {
        switch (hash(md)) {
            case "bool"_fnv:
                return sol::make_object(s, *(bool*)address);
            case "u8"_fnv:
                return sol::make_object(s, *(uint8_t*)address);
            case "u16"_fnv:
                return sol::make_object(s, *(uint16_t*)address);
            case "u32"_fnv:
                return sol::make_object(s, *(uint32_t*)address);
            case "u64"_fnv:
                return sol::make_object(s, *(uint64_t*)address);
            case "i8"_fnv:
                return sol::make_object(s, *(int8_t*)address);
            case "i16"_fnv:
                return sol::make_object(s, *(int16_t*)address);
            case "i32"_fnv:
                return sol::make_object(s, *(int32_t*)address);
            case "i64"_fnv:
                return sol::make_object(s, *(int64_t*)address);
            case "f32"_fnv:
                return sol::make_object(s, *(float*)address);
            case "f64"_fnv:
                return sol::make_object(s, *(double*)address);
            case "utf8*"_fnv:
                return sol::make_object(s, (const char*)address);
            default:
                continue;
        }
    }

    return sol::make_object(s, sol::nil);
}

sol::object parse(sol::this_state s, std::string data) {
    auto sdk = std::make_unique<genny::Sdk>();

    genny::parser::State state{};
    state.parents.push_back(sdk->global_ns());

    tao::pegtl::memory_input in{data, "text"};
    tao::pegtl::parse<genny::parser::Grammar, genny::parser::Action>(in, state);

    return sol::make_object(s, std::move(sdk));
}

sol::object parse_file(sol::this_state s, std::string filename) {
    std::ifstream file{filename};
    std::string data{(std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>()};
    return parse(s, data);
}
}

#define GENNY_OBJECT_GEN(luaname, cppname) \
    "is_" #luaname, [](genny::Object& o) { return o.is_a<cppname>(); }, \
    "as_" #luaname, [](genny::Object& o) -> cppname* { return o.is_a<cppname>() ? dynamic_cast<cppname*>(&o) : nullptr; }, \
    "has_any_" #luaname, [](genny::Object& o) { return o.has_any<cppname>(); }, \
    "has_any_" #luaname "_in_children", [](genny::Object& o) { return o.has_any_in_children<cppname>(); }, \
    #luaname "_owners", [](genny::Object& o) { return o.owners<cppname>(); }, \
    "get_all_" #luaname, [](genny::Object& o) { return o.get_all<cppname>(); }, \
    "is_child_of_" #luaname, [](genny::Object& o, cppname* obj) { return o.is_child_of<cppname>(obj); }, \
    "find_" #luaname, [](genny::Object& o, std::string name) { return o.find<cppname>(name); }, \
    "find_" #luaname "_in_owners", [](genny::Object& o, std::string name, bool include_self) { return o.find_in_owners<cppname>(name, include_self); }
    

#define MULTIFUNCTION(parent_type, name, possible_type) \
    #name, [](sol::this_state s, parent_type& f, sol::object param) -> sol::object { \
        if (param.is<sol::nil_t>()) { \
            return sol::make_object(s, f.name()); \
        } \
        return sol::make_object(s, f.name(param.as<possible_type>())); \
    }

#define FUNCTION(parent_type, name) \
    #name, [](sol::this_state s, parent_type& f) -> sol::object { \
        return sol::make_object(s, f.name()); \
    }

#define PARAMFUNCTION(parent_type, name, t) \
    #name, [](sol::this_state s, parent_type& f, sol::object param) -> sol::object { \
        return sol::make_object(s, f.name(param.as<t>())); \
    }

int open(lua_State* l) {
    sol::state_view lua{l};

    auto sdkgenny = lua.create_table();

    sdkgenny["parse"] = &api::parse;
    sdkgenny["parse_file"] = &api::parse_file;

    sdkgenny.new_usertype<api::StructOverlay>("StructOverlay",
    sol::meta_function::construct, sol::constructors<api::StructOverlay(uintptr_t, genny::Struct*)>(),
        "type", &api::StructOverlay::type_,
        "address", &api::StructOverlay::address,
        sol::meta_function::index, &api::StructOverlay::index
    );

    auto sdk = sdkgenny.new_usertype<genny::Sdk>("Sdk",
        "global_ns", &genny::Sdk::global_ns,
        "preamble", &genny::Sdk::preamble,
        "postamble", &genny::Sdk::postamble,
        "include", &genny::Sdk::include,
        "include_local", &genny::Sdk::include_local,
        "generate", [](genny::Sdk& sdk, std::string p) {
            return sdk.generate(p);
        },
        MULTIFUNCTION(genny::Sdk, header_extension, std::string),
        MULTIFUNCTION(genny::Sdk, source_extension, std::string),
        MULTIFUNCTION(genny::Sdk, generate_namespaces, bool)
    );

    sdkgenny.new_usertype<genny::Object>("Object",
        "metadata", [](sol::this_state s, genny::Object& o) -> std::vector<std::string>& {
            return o.metadata();
        },
        MULTIFUNCTION(genny::Object, name, std::string),
        GENNY_OBJECT_GEN(typename, genny::Typename),
        GENNY_OBJECT_GEN(type, genny::Type),
        GENNY_OBJECT_GEN(generic_type, genny::GenericType),
        GENNY_OBJECT_GEN(struct, genny::Struct),
        GENNY_OBJECT_GEN(class, genny::Class),
        GENNY_OBJECT_GEN(enum, genny::Enum),
        GENNY_OBJECT_GEN(enum_class, genny::EnumClass),
        GENNY_OBJECT_GEN(namespace, genny::Namespace),
        GENNY_OBJECT_GEN(reference, genny::Reference),
        GENNY_OBJECT_GEN(pointer, genny::Pointer),
        GENNY_OBJECT_GEN(variable, genny::Variable),
        GENNY_OBJECT_GEN(function, genny::Function),
        GENNY_OBJECT_GEN(virtual_function, genny::VirtualFunction),
        GENNY_OBJECT_GEN(static_function, genny::StaticFunction),
        GENNY_OBJECT_GEN(array, genny::Array),
        GENNY_OBJECT_GEN(parameter, genny::Parameter),
        GENNY_OBJECT_GEN(constant, genny::Constant)
    );

    #define GENNY_TYPENAME_BASES genny::Typename, genny::Object
    sdkgenny.new_usertype<genny::Typename>("Typename",
        sol::base_classes, sol::bases<genny::Object>(),
        MULTIFUNCTION(genny::Typename, simple_typename_generation, bool)
    );

    #define GENNY_TYPE_BASES genny::Type, genny::Typename, genny::Object
    sdkgenny.new_usertype<genny::Type>("Type",
        sol::base_classes, sol::bases<GENNY_TYPENAME_BASES>(),
        MULTIFUNCTION(genny::Type, size, int),
        "ref", &genny::Type::ref,
        "ptr", &genny::Type::ptr,
        "array", &genny::Type::array_
    );

    sdkgenny.new_usertype<genny::GenericType>("GenericType",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>()
    );

    sdkgenny.new_usertype<genny::Struct>("Struct",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(genny::Struct, size, int),
        "variable", &genny::Struct::variable,
        "constant", &genny::Struct::constant,
        "struct", &genny::Struct::struct_,
        "class", &genny::Struct::class_,
        "enum", &genny::Struct::enum_,
        "enum_class", &genny::Struct::enum_class,
        "function", &genny::Struct::function,
        "virtual_function", &genny::Struct::virtual_function,
        "static_function", &genny::Struct::static_function,
        "bitfield", &genny::Struct::bitfield
    );

    sdkgenny.new_usertype<genny::Class>("Class",
        sol::base_classes, sol::bases<genny::Struct, GENNY_TYPE_BASES>()
    );

    sdkgenny.new_usertype<genny::Enum>("Enum",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        "value", [] (genny::Enum& e, std::string name, uint64_t value) {
            e.value(name, value);
        },
        "values", [] (genny::Enum& e) -> std::vector<std::tuple<std::string, uint64_t>> {
            return e.values();
        },
        MULTIFUNCTION(genny::Enum, type, genny::Type*)
    );

    sdkgenny.new_usertype<genny::EnumClass>("EnumClass",
        sol::base_classes, sol::bases<genny::Enum, GENNY_TYPE_BASES>()
    );

    sdkgenny.new_usertype<genny::Namespace>("Namespace",
        sol::base_classes, sol::bases<GENNY_TYPENAME_BASES>(),
        "type", &genny::Namespace::type,
        "generic_type", &genny::Namespace::generic_type,
        "struct", &genny::Namespace::struct_,
        "enum", &genny::Namespace::enum_,
        "enum_class", &genny::Namespace::enum_class,
        "namespace", &genny::Namespace::namespace_
    );

    #define GENNY_REFERENCE_BASES genny::Reference, GENNY_TYPE_BASES
    sdkgenny.new_usertype<genny::Reference>("Reference",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(genny::Reference, to, genny::Type*)
    );

    sdkgenny.new_usertype<genny::Pointer>("Pointer",
        sol::base_classes, sol::bases<GENNY_REFERENCE_BASES>()
    );

    sdkgenny.new_usertype<genny::Variable>("Variable",
        sol::base_classes, sol::bases<genny::Object>(),
        MULTIFUNCTION(genny::Variable, type, genny::Type*),
        PARAMFUNCTION(genny::Variable, type, std::string),
        MULTIFUNCTION(genny::Variable, offset, int),
        "append", &genny::Variable::append,
        "end", &genny::Variable::end,

        MULTIFUNCTION(genny::Variable, bit_size, size_t),
        MULTIFUNCTION(genny::Variable, bit_offset, size_t),
        "is_bitfield", &genny::Variable::is_bitfield,
        "bit_append", &genny::Variable::bit_append
    );

    sdkgenny.new_usertype<genny::Function>("Function",
        sol::base_classes, sol::bases<genny::Object>(),
        MULTIFUNCTION(genny::Function, returns, genny::Type*),
        MULTIFUNCTION(genny::Function, procedure, std::string),
        "dependencies", &genny::Function::dependencies,
        PARAMFUNCTION(genny::Function, depends_on, genny::Type*),
        MULTIFUNCTION(genny::Function, defined, bool)
    );

    sdkgenny.new_usertype<genny::VirtualFunction>("VirtualFunction",
        sol::base_classes, sol::bases<genny::Function, genny::Object>(),
        MULTIFUNCTION(genny::VirtualFunction, vtable_index, int)
    );

    sdkgenny.new_usertype<genny::StaticFunction>("StaticFunction",
        sol::base_classes, sol::bases<genny::Function, genny::Object>()
    );

    sdkgenny.new_usertype<genny::Array>("Array",
        sol::base_classes, sol::bases<GENNY_TYPE_BASES>(),
        MULTIFUNCTION(genny::Array, of, genny::Type*),
        MULTIFUNCTION(genny::Array, count, int)
    );

    sdkgenny.new_usertype<genny::Parameter>("Parameter",
        sol::base_classes, sol::bases<genny::Object>(),
        MULTIFUNCTION(genny::Parameter, type, genny::Type*)
    );

    sdkgenny.new_usertype<genny::Constant>("Constant",
        sol::base_classes, sol::bases<genny::Object>(),
        MULTIFUNCTION(genny::Constant, type, genny::Type*),
        PARAMFUNCTION(genny::Constant, type, std::string),
        MULTIFUNCTION(genny::Constant, value, std::string),
        "string", &genny::Constant::string
    );

    sdkgenny.push(l);
    return 1;
} // namespace sdkgennylua
}
```

`src/LuaGenny.hpp`:

```hpp
#pragma once

struct lua_State;

namespace luagenny {
int open(lua_State* l);
} // namespace luagenny
```

`test/Main.cpp`:

```cpp
#include <iostream>
#include <memory>

extern "C" {
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
}
#include <sol/sol.hpp>

#include <LuaGenny.hpp>

#include "GennyParser.hpp"

#pragma pack(push,1)
enum Place { EARTH = 1, MOON = 2, MARS = 3 };

struct Date {
    unsigned short nWeekDay : 3;
    unsigned short nMonthDay : 6;
    unsigned short nMonth : 5;
    unsigned short nYear : 8;
};

struct Foo {
    int a{};
    int b{};
    float c{};
    Place p{};
    int bf1 : 4;
    Place bf2 : 2;
    int rest : 26;
};

struct Bar {
    int d{};
    Foo* foo{};
    int m[4][3];
    union {
        Date date;
        unsigned int date_int{};
    };
};

struct Thing {
    int abc{};
};

struct RTTITest {
    virtual ~RTTITest(){};
};

struct A {
    virtual ~A() {}
};

struct B : A {
    virtual ~B() {}
};

struct C : B {
    virtual ~C() {}
};

struct D {
    virtual ~D() {}
};

struct E : C, D {
    virtual ~E() {}
};

struct Person {
    int age{20};
};

struct Student : Person {
    float gpa{3.9};
};

struct Faculty : Person {
    int wage{30000};
};

struct TA : Student, Faculty {
    int hours{40};
};

struct Baz : Bar {
    TA ta{};
    int e{};
    int thing{};
    int* f{};
    Foo g{};
    Thing* things{};
    char* hello{};
    wchar_t* wide_hello{};
    char intrusive_hello[32]{"hello, intrusive world!"};
    bool im_true{true};
    bool im_false{false};
    char im_also_true{7};
    __declspec(align(sizeof(void*))) RTTITest* rtti{};
    E* e_ptr{};
};
#pragma pack(pop)

constexpr auto gennyfile = R"(
type int 4 [[i32]]
type float 4 [[f32]]
type ushort 2 [[u16]]
type str 8 [[utf8*]]
type wstr 8 [[utf16*]]
type bool 1 [[bool]]
type uintptr_t 8 [[u64]]
type char 1
type wchar_t 2

struct RTTITest{}

enum Place {
    EARTH = 1,
    MOON = 2,
    MARS = 3,
}

struct Date {
    ushort nWeekDay : 3
    ushort nMonthDay : 6
    ushort nMonth : 5
    ushort nYear : 8
}

struct Foo {
    int a
    int b
    float c
    Place p
    Place bf1 : 4
    Place bf2 : 2
}

struct Bar {
    int d
    Foo* foo
    int[4][3] m
    Date date
}

struct Thing {
    int abc
}

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}

struct Baz : Bar 0x100 {
	TA ta
    int e
    int thing
    int* f
    Foo g
    Thing* things
    char* hello [[utf8*]]
    //wchar_t* wide_hello [[utf16*]]
    //char[32] intrusive_hello [[utf8*]]
    bool im_true +40
    bool im_false
    bool im_also_true
	//RTTITest* test + 5
}

struct RTTITest 0x100 {
	uintptr_t** vtable
}
)";

std::unique_ptr<genny::Sdk> parse_gennyfile() {
    auto sdk = std::make_unique<genny::Sdk>();

    genny::parser::State s{};
    s.parents.push_back(sdk->global_ns());

    tao::pegtl::memory_input in{gennyfile, "text"};

    try {
        if (tao::pegtl::parse<genny::parser::Grammar, genny::parser::Action>(in, s)) {
        }
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
    } catch (...) {
        std::cout << "unknown error" << std::endl;
    }
    
    return sdk;
}

int main() {
    // Create a Lua state
    sol::state lua{};

    lua.open_libraries(sol::lib::base, sol::lib::package, sol::lib::string, sol::lib::math, sol::lib::table, sol::lib::bit32,
    sol::lib::utf8, sol::lib::os, sol::lib::coroutine);

    // Add the sdkgenny bindings
    luagenny::open(lua);
    sol::table sdkgenny = sol::stack::pop<sol::table>(lua);
    lua["sdkgenny"] = sdkgenny;

    auto sdk = parse_gennyfile();

    auto foo = new Foo{};
    foo->a = 42;
    foo->b = 1337;
    foo->c = 77.7f;
    foo->p = Place::MARS;
    foo->bf1 = Place::MOON;
    foo->bf2 = Place::MARS;
    foo->rest = 12345678;

    auto baz = new Baz{};
    baz->d = 123;
    baz->foo = foo;
    for (auto i = 0; i < 4; ++i) {
        for (auto j = 0; j < 3; ++j) {
            baz->m[i][j] = i + j;
        }
    }
    baz->date.nWeekDay = 1;
    baz->date.nMonthDay = 2;
    baz->date.nMonth = 3;
    baz->date.nYear = 4;
    baz->e = 666;
    baz->f = new int[10];
    for (auto i = 0; i < 10; ++i) {
        baz->f[i] = i;
    }
    baz->g = *foo;
    ++baz->g.a;
    ++baz->g.b;
    ++baz->g.c;
    baz->g.p = Place::MOON;
    baz->things = new Thing[10];
    for (auto i = 0; i < 10; ++i) {
        baz->things[i].abc = i * 2;
    }
    baz->hello = (char*)"Hello, world!";
    baz->wide_hello = (wchar_t*)L"Hello, wide world!";

    auto rtti = new RTTITest{};
    baz->rtti = rtti;
    baz->e_ptr = new E{};

    lua["parsed"] = sdk.get();

    std::cout << "0x" << std::hex << (uintptr_t)baz << std::endl;
    std::string input{};

    while (true) {
        std::cout << "> ";
        std::getline(std::cin, input);

        const auto command = input.c_str();

        if (input == "quit") {
            break;
        } else {
            auto result = luaL_loadbuffer(lua, command, strlen(command), nullptr);

            if (result == LUA_OK) {
                result = lua_pcall(lua, 0, LUA_MULTRET, 0);

                if (result != LUA_OK) {
                    std::cout << "ERROR: " << luaL_checkstring(lua, -1) << std::endl;
                }
            } else {
                std::cout << "ERROR: " << luaL_checkstring(lua, -1) << std::endl;
            }
        }
    }

    std::cout << "Press ENTER to exit.";
    std::cin.get();

    return 0;
}
```

`vcpkg.json`:

```json
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    "pegtl",
    "lua",
    "sol2"
  ],
  "description": "",
  "name": "sdkgenny-lua",
  "version-string": ""
}

```