Project Path: arc_gmh5225_binja_kc_lv3ofrtl

Source Tree:

```txt
arc_gmh5225_binja_kc_lv3ofrtl
├── CMakeLists.txt
├── LICENSE
├── README.md
├── common
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       ├── macho
│   │       │   └── macho.h
│   │       ├── types
│   │       │   ├── errors.h
│   │       │   └── uuid.h
│   │       └── utils
│   │           ├── binary_view.h
│   │           ├── debug.h
│   │           ├── log.h
│   │           ├── span_reader.h
│   │           └── strconv.h
│   └── src
│       ├── macho
│       │   └── macho.cpp
│       └── utils
│           ├── binary_view.cpp
│           ├── span_reader.cpp
│           └── strconv.cpp
├── debuginfo
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       └── debuginfo
│   │           ├── debug.h
│   │           ├── dsym.h
│   │           ├── dwarf.h
│   │           ├── dwarf_task.h
│   │           ├── errors.h
│   │           ├── function.h
│   │           ├── macho_task.h
│   │           ├── name_index.h
│   │           ├── plugin_dsym.h
│   │           ├── plugin_macho.h
│   │           ├── slider.h
│   │           ├── source_finder.h
│   │           ├── types.h
│   │           └── variable.h
│   ├── src
│   │   ├── dsym.cpp
│   │   ├── dwarf.cpp
│   │   ├── dwarf_task.cpp
│   │   ├── function.cpp
│   │   ├── macho_task.cpp
│   │   ├── name_index.cpp
│   │   ├── plugin_dsym.cpp
│   │   ├── plugin_macho.cpp
│   │   ├── slider.cpp
│   │   ├── source_finder.cpp
│   │   ├── types.cpp
│   │   └── variable.cpp
│   └── test
│       ├── CMakeLists.txt
│       └── main.cpp
├── external
│   ├── CMakeLists.txt
│   ├── boost
│   ├── fmtlib
│   ├── llvm-project
│   ├── range-v3
│   └── taskflow
├── kcview
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       └── kcview
│   │           ├── errors.h
│   │           ├── lib.h
│   │           └── range.h
│   ├── src
│   │   └── lib.cpp
│   └── test
│       ├── CMakeLists.txt
│       └── main.cpp
├── main.cpp
└── resources
    └── screenshot.png

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

include(CheckCXXCompilerFlag)

project(binja_kc)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

add_compile_options(-Wall
        -Werror=return-type
        -Werror=switch
        -Wno-deprecated-declarations
        -Wno-unused-local-typedef
        -Wno-deprecated-enum-enum-conversion
        -Wno-deprecated-anon-enum-enum-conversion)
check_cxx_compiler_flag(-Wdeprecated-builtins COMPILER_HAS_DEPRECATED_BUILTINS)
if (${COMPILER_HAS_DEPRECATED_BUILTINS})
    add_compile_options(-Wno-deprecated-builtins)
endif ()

add_library(${PROJECT_NAME} SHARED main.cpp)

find_path(
        BN_API_PATH
        NAMES binaryninjaapi.h
        HINTS $ENV{BN_API_PATH}
        REQUIRED)
add_subdirectory(${BN_API_PATH} api)

add_subdirectory(external)
add_subdirectory(common)
add_subdirectory(debuginfo)
add_subdirectory(kcview)

target_link_libraries(${PROJECT_NAME} PRIVATE dwarf_debuginfo kcview)

set_target_properties(${PROJECT_NAME} PROPERTIES
        CXX_VISIBILITY_PRESET hidden
        CXX_STANDARD_REQUIRED ON
        VISIBILITY_INLINES_HIDDEN ON
        POSITION_INDEPENDENT_CODE ON
        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/out/bin)

get_target_property(BN_API_SOURCE_DIR binaryninjaapi SOURCE_DIR)
list(APPEND CMAKE_MODULE_PATH "${BN_API_SOURCE_DIR}/cmake")
find_package(BinaryNinjaCore REQUIRED)
add_custom_target(install_binja_kc
        COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:binja_kc> ${BinaryNinjaCore_USER_PLUGINS_DIR}
        DEPENDS binja_kc
        COMMENT "Installing binja_kc to ${BinaryNinjaCore_USER_PLUGINS_DIR}")

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 skr0x1c0

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# BinjaKC

A plugin for loading Mach-O kernelcache and dSYM files into Binary Ninja.

<img align="center" src="./resources/screenshot.png">

This plugin can load symbols and type information from multiple dSYM files contained in the KDK to the corresponding kernelcache opened in Binary Ninja. It will automatically handle sliding of symbol address, merging of duplicate types and renaming of different types with same name. It can also import function and data symbol names from Mach-O kernel extensions contained in the KDK to the corresponding kernelcache.

## Installation

### Prerequisites

#### Setup Binary Ninja API

1. Clone the Binary Ninja API repository along with its submodules

```bash
git clone --recursive https://github.com/Vector35/binaryninja-api.git
```

2. Set the environment variable `BN_API_PATH` to the path of directory containing the cloned Binary Ninja API source code 

```bash
export BN_API_PATH="$PWD/binaryninja-api"
```

3. If the Binary Ninja app is in a non-standard installation location (`/Applications` for macOS), set the environment variable `BN_INSTALL_DIR` to path of the Binary Ninja installation

```bash
export BN_INSTALL_DIR="<path-to-binary-ninja-application>"
```

4. If you are using the stable version of Binary Ninja app, checkout the `master` branch of the Binary Ninja API repository

```bash
pushd "$BN_API_PATH"
git checkout master
popd
```

### Building and installation

1. Clone the BinjaKC repository along with its submodules

```bash
git clone --recursive https://github.com/skr0x1c0/binja_kc
```

2. Use `cmake` to build the plugin

```bash
cd binja_kc
mkdir build
cd build
cmake .. -DCMAKE_RELEASE_TYPE=RelWithDebInfo
make -j$(nproc) install_binja_kc
```

If everything goes well, the plugin will be installed on the plugins folder in the Binary Ninja user directory. You can verify this by opening the Binary Ninja application. The message `[Core] Loaded native plugin binja_kc` will be displayed on the log.

## Usage

### For loading kernelcache with symbols from KDK

NOTE: The kernelcache should be a Mach-O file

1. Place the kernelcache in a directory of your choice

```bash
mkdir kc
cd kc
cp /private/var/db/KernelExtensionManagement/KernelCollections/BootKernelCollection.kc ./kernelcache
```

2. Copy the respective KDK to the same directory with name `<name-of-kernel-cache>.symbols`

```bash
cp -R /Library/Developer/KDKs/KDK_13.0_22A5331f.kdk ./kernelcache.symbols
```

3. Now you can directly open the kernelcache in Binary Ninja application. The symbols and type information from the KDK will be loaded automatically.

### For loading normal Mach-O files with symbols from dSYM

Place the dSYM file in the same directory as that of Mach-O binary with name `<name-of-binary>.dSYM` and open the binary as usual using Binary Ninja application. The symbols and type information will be automatically loaded.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details

```

`common/CMakeLists.txt`:

```txt
set(LIBRARY_NAME binja_kc_common)

set(BINJA_KC_COMMON_HEADERS
        include/binja/utils/binary_view.h
        include/binja/macho/macho.h
        include/binja/types/errors.h
        include/binja/types/uuid.h
        include/binja/utils/debug.h
        include/binja/utils/log.h
        include/binja/utils/span_reader.h
        include/binja/utils/strconv.h)

set(BINJA_KC_COMMON_SOURCES
        src/utils/binary_view.cpp
        src/macho/macho.cpp
        src/utils/span_reader.cpp
        src/utils/strconv.cpp)

add_library(${LIBRARY_NAME} STATIC ${BINJA_KC_COMMON_HEADERS} ${BINJA_KC_COMMON_SOURCES})
target_include_directories(${LIBRARY_NAME} PUBLIC include)
target_include_directories(${LIBRARY_NAME} PRIVATE include/binja)

target_link_libraries(${LIBRARY_NAME} PRIVATE LLVMSupport LLVMObject)
get_property(LLVM_INCLUDE_DIRECTORIES GLOBAL PROPERTY EXTERNAL_LLVM_INCLUDE_DIRECTORIES)
target_include_directories(${LIBRARY_NAME} PUBLIC ${LLVM_INCLUDE_DIRECTORIES})

target_link_libraries(${LIBRARY_NAME} PUBLIC binaryninjaapi fmt::fmt Boost::uuid)
```

`common/include/binja/macho/macho.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include "../types/errors.h"
#include "../types/uuid.h"
#include "../utils/binary_view.h"

namespace Binja::MachO {

class MachHeaderDecodeError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

struct Fileset {
    std::string name;
    uint64_t vmAddr;
    uint64_t fileOffset;
};

struct Section {
    std::string name;
    uint64_t vaStart;
    uint64_t vaLength;
    BNSectionSemantics semantics;
};

struct Segment {
    std::string name;
    uint64_t vaStart;
    uint64_t vaLength;
    uint64_t dataStart;
    uint64_t dataLength;
    uint32_t flags;
    std::vector<Section> sections;
};

class MachHeaderParser {
public:
    MachHeaderParser(BinaryNinja::BinaryView &binaryView, uint64_t machHeaderOffset)
        : binaryView_{binaryView}, machHeaderOffset_{machHeaderOffset} {
        VerifyHeader();
    }

    std::vector<Fileset> DecodeFilesets();
    std::vector<Segment> DecodeSegments();
    std::optional<uint64_t> DecodeEntryPoint();
    std::optional<Types::UUID> DecodeUUID();

private:
    void VerifyHeader();

    static Fileset DecodeFileset(Utils::BinaryViewDataReader &reader);
    static Segment DecodeSegment(Utils::BinaryViewDataReader &reader);
    static std::vector<Section> DecodeSections(Utils::BinaryViewDataReader &reader);

private:
    BinaryNinja::BinaryView &binaryView_;
    uint64_t machHeaderOffset_;
};


class MachBinaryView {
public:
    MachBinaryView(BinaryNinja::BinaryView &binaryView) : binaryView_{binaryView} {}
    std::map<Types::UUID, std::vector<Segment>> ReadMachOHeaders();
    std::vector<uint64_t> ReadMachOHeaderOffsets();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::MachO

```

`common/include/binja/types/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <exception>
#include <fmt/format.h>

namespace Binja::Types {

class GenericException : public std::exception {
public:
    template<typename... T>
    explicit GenericException(fmt::format_string<T...> fmt, T &&...args)
        : msg_{fmt::format(fmt, std::forward<T>(args)...)} {}
    [[nodiscard]] const char *what() const noexcept override { return msg_.c_str(); }

private:
    std::string msg_;
};

class FatalError : public GenericException {
    using GenericException::GenericException;
};

class DecodeError : public GenericException {
    using GenericException::GenericException;
};

}// namespace Binja::Types

```

`common/include/binja/types/uuid.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <boost/lexical_cast.hpp>
#include <boost/uuid/random_generator.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <fmt/format.h>

namespace Binja::Types {

using UUID = boost::uuids::uuid;

inline UUID RandomUUID() {
    return boost::uuids::random_generator()();
}

}// namespace Binja::Types

namespace fmt {

template<>
struct formatter<Binja::Types::UUID> : formatter<string_view> {
    template<typename FormatContext>
    auto format(const Binja::Types::UUID &p, FormatContext &ctx) const -> decltype(ctx.out()) {
        return fmt::format_to(ctx.out(), "{}", boost::lexical_cast<std::string>(p));
    }
};

}// namespace fmt
```

`common/include/binja/utils/binary_view.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include "../types/errors.h"
#include "../utils/debug.h"

namespace Binja::Utils {

class BinaryViewReaderError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

class BinaryViewDataReader {
public:
    BinaryViewDataReader(BinaryNinja::BinaryView *base, uint64_t offset)
        : base_{base}, offset_{offset} {}

    template<class T>
    T Read() {
        T result = Peek<T>();
        offset_ += sizeof(T);
        return result;
    }

    template<class T>
    T Peek() {
        T result;
        auto size = sizeof(T);
        auto read = base_->Read(&result, offset_, size);
        if (read != size) {
            throw BinaryViewReaderError{"Failed to read data of size {} at offset {}, read only {} bytes", size, offset_, read};
        }
        return result;
    }

    std::string ReadString(size_t maxLength = 1024) {
        size_t length = FindStringLength(maxLength);
        std::string result;
        result.resize(length);
        auto read = base_->Read(result.data(), offset_, length);
        BDVerify(read == length);
        offset_ += length;
        return result;
    }

    void Seek(size_t length) {
        offset_ += length;
        if (offset_ > base_->GetStart() + base_->GetLength()) {
            throw BinaryViewReaderError{"Attempt to seek to position {} past EOF, file size: {}", offset_, base_->GetLength()};
        }
    }

private:
    size_t FindStringLength(size_t maxLength) {
        char buffer[32];
        for (size_t cursor = 0; cursor < maxLength; cursor += sizeof(buffer)) {
            size_t read = base_->Read(buffer, offset_ + cursor, sizeof(buffer));
            for (size_t i = 0; i < read; ++i) {
                if (buffer[i] == '\0') {
                    return cursor + i;
                }
            }
            if (read != sizeof(buffer)) {
                throw BinaryViewReaderError{"Failed to read string at offset {}, reached EOF at {}", offset_, cursor + read};
            }
        }
        throw BinaryViewReaderError{"Failed to read string at offset {}, string exceeds max length {}", offset_, maxLength};
    }

private:
    BinaryNinja::BinaryView *base_;
    uint64_t offset_;
};

BinaryNinja::Ref<BinaryNinja::BinaryView> OpenBinaryView(
    const std::string &path, bool updateAnalysis = true,
    BinaryNinja::Ref<BinaryNinja::BinaryViewType> viewType = nullptr,
    std::function<bool(size_t, size_t)> progress = nullptr,
    Json::Value options = Json::Value{});

BinaryNinja::Ref<BinaryNinja::BinaryView> OpenBinaryView(
    BinaryNinja::Ref<BinaryNinja::BinaryView> view, bool updateAnalysis = true,
    BinaryNinja::Ref<BinaryNinja::BinaryViewType> requestedViewType = nullptr,
    std::function<bool(size_t, size_t)> progress = nullptr,
    Json::Value options = Json::Value{}, bool isDatabase = false);

}// namespace Binja::Utils
```

`common/include/binja/utils/debug.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#pragma once

#include "../types/errors.h"

#define BDVerify(CONDITION)                                                                                    \
    if (!(CONDITION)) {                                                                                        \
        throw Binja::Types::FatalError{"verify condition {} failed at {}:{}", #CONDITION, __FILE__, __LINE__}; \
    }                                                                                                          \
    0
```

`common/include/binja/utils/log.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>
#include <fmt/format.h>

#define BDLogDebug(...)                                                                  \
    do {                                                                                 \
        auto msg = fmt::format(__VA_ARGS__);                                             \
        BinaryNinja::LogDebug("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogWarn(...)                                                                  \
    do {                                                                                \
        auto msg = fmt::format(__VA_ARGS__);                                            \
        BinaryNinja::LogWarn("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogInfo(...)                                                                  \
    do {                                                                                \
        auto msg = fmt::format(__VA_ARGS__);                                            \
        BinaryNinja::LogInfo("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogError(...)                                                                  \
    do {                                                                                 \
        auto msg = fmt::format(__VA_ARGS__);                                             \
        BinaryNinja::LogError("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

```

`common/include/binja/utils/span_reader.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <span>

#include "../types/errors.h"

namespace Binja::Utils {

class SpanReader {
public:
    class ReadError : public Types::DecodeError {
        using Types::DecodeError::DecodeError;
    };

public:
    explicit SpanReader(const std::span<const char> &data)
        : image_{data} {}

    template<class T> const T *Read();
    std::string ReadString();
    template<class T> const T *Peek(size_t offset = 0);
    std::string PeekString(size_t offset = 0);
    SpanReader &Skip(size_t size);
    SpanReader Sub(size_t size);

private:
    void VerifyAvailable(uint64_t size);

private:
    const std::span<const char> image_;
    size_t offset_ = 0;
};

template<class T>
inline const T *SpanReader::Read() {
    const T *result = Peek<T>();
    offset_ += sizeof(T);
    return result;
}

template<class T>
inline const T *SpanReader::Peek(size_t offset) {
    VerifyAvailable(offset + sizeof(T));
    const T *result = reinterpret_cast<const T *>(&image_.data()[offset_ + offset]);
    return result;
}

}// namespace Binja::Utils
```

`common/include/binja/utils/strconv.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>

#include <fmt/format.h>

namespace Binja::Utils {

uint64_t Strtoull(const std::string &str, int base = 0);

}// namespace Binja::Utils
```

`common/src/macho/macho.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/Object/MachO.h>

#include "macho/macho.h"
#include "utils/log.h"

using namespace Binja;
using namespace MachO;
using namespace llvm::MachO;

using Utils::BinaryViewDataReader;

namespace {

#define LC_FILESET_ENTRY (0x35 | LC_REQ_DYLD)

/*
 * A variable length string in a load command is represented by an lc_str
 * union.  The strings are stored just after the load command structure and
 * the offset is from the start of the load command structure.  The size
 * of the string is reflected in the cmdsize field of the load command.
 * Once again any padded bytes to bring the cmdsize field to a multiple
 * of 4 bytes must be zero.
 */
union lc_str {
    uint32_t offset; /* offset to the string */
#ifndef __LP64__
    char *ptr; /* pointer to the string */
#endif
};

/*
 * LC_FILESET_ENTRY commands describe constituent Mach-O files that are part
 * of a fileset. In one implementation, entries are dylibs with individual
 * mach headers and repositionable text and data segments. Each entry is
 * further described by its own mach header.
 */
struct fileset_entry_command {
    uint32_t cmd;          /* LC_FILESET_ENTRY */
    uint32_t cmdsize;      /* includes entry_id string */
    uint64_t vmaddr;       /* memory address of the entry */
    uint64_t fileoff;      /* file offset of the entry */
    union lc_str entry_id; /* contained entry id */
    uint32_t reserved;     /* reserved */
};

struct arm_unified_thread_state {
    arm_state_hdr_t ash;
    union {
        arm_thread_state32_t ts_32;
        arm_thread_state64_t ts_64;
    } uts;
};

int32_t FixupSegmentMaxProt(const segment_command_64 &cmd) {
    if (std::string(cmd.segname) != "__DATA_CONST") {
        return cmd.maxprot;
    }
    return cmd.maxprot & (~VM_PROT_WRITE);
}

}// namespace

/// Macho header parser

void MachO::MachHeaderParser::VerifyHeader() {
    BinaryViewDataReader reader{&binaryView_, machHeaderOffset_};
    auto cmd = reader.Read<mach_header_64>();
    if (cmd.magic != MH_MAGIC_64 && cmd.magic != MH_CIGAM_64) {
        throw MachHeaderDecodeError{"unsupported mach header magic {} at offset {} for binary {}", cmd.magic, machHeaderOffset_,
                                    binaryView_.GetFile()->GetOriginalFilename()};
    }
}

Fileset MachHeaderParser::DecodeFileset(BinaryViewDataReader &reader) {
    auto cmd = reader.Peek<fileset_entry_command>();
    reader.Seek(cmd.entry_id.offset);
    std::string name = reader.ReadString();
    return Fileset{
        .name = name,
        .vmAddr = cmd.vmaddr,
        .fileOffset = cmd.fileoff,
    };
}

std::vector<Fileset> MachHeaderParser::DecodeFilesets() {
    BinaryViewDataReader reader{&binaryView_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    std::vector<Fileset> result;
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd == LC_FILESET_ENTRY) {
            BinaryViewDataReader sub{reader};
            result.push_back(DecodeFileset(sub));
        }
        reader.Seek(cmd.cmdsize);
    }
    return result;
}

std::vector<Section> MachHeaderParser::DecodeSections(BinaryViewDataReader &reader) {
    auto segment = reader.Read<segment_command_64>();

    auto decodeSectionSemantics = [](const segment_command_64 &segment, const section_64 &section) {
        auto maxProt = FixupSegmentMaxProt(segment);
        if (maxProt & VM_PROT_EXECUTE) {
            return BNSectionSemantics::ReadOnlyCodeSectionSemantics;
        }
        if (!(maxProt & VM_PROT_WRITE)) {
            return BNSectionSemantics::ReadOnlyDataSectionSemantics;
        }
        assert(maxProt & VM_PROT_READ);
        return BNSectionSemantics::ReadWriteDataSectionSemantics;
    };

    std::vector<Section> result;
    result.reserve(segment.nsects);
    for (int i = 0; i < segment.nsects; ++i) {
        auto section = reader.Read<section_64>();
        result.push_back(Section{
            .name = section.sectname,
            .vaStart = section.addr,
            .vaLength = section.size,
            .semantics = decodeSectionSemantics(segment, section),
        });
    }
    return result;
}

Segment MachHeaderParser::DecodeSegment(BinaryViewDataReader &reader) {
    auto decodeSegmentFlags = [](const segment_command_64 &cmd) {
        uint32_t flags = 0;
        auto maxProt = FixupSegmentMaxProt(cmd);
        if (maxProt & VM_PROT_EXECUTE) {
            flags |= BNSegmentFlag::SegmentContainsCode;
            flags |= BNSegmentFlag::SegmentExecutable;
            flags |= BNSegmentFlag::SegmentDenyWrite;
        }
        if (maxProt & VM_PROT_READ) {
            flags |= BNSegmentFlag::SegmentReadable;
        }
        if ((maxProt & VM_PROT_WRITE)) {
            flags |= BNSegmentFlag::SegmentWritable;
            flags |= BNSegmentFlag::SegmentDenyExecute;
        }
        return flags;
    };

    auto cmd = reader.Peek<segment_command_64>();
    Segment result{
        .name = cmd.segname,
        .vaStart = cmd.vmaddr,
        .vaLength = cmd.vmsize,
        .dataStart = cmd.fileoff,
        .dataLength = cmd.filesize,
        .flags = decodeSegmentFlags(cmd),
    };
    result.sections = DecodeSections(reader);
    return result;
}

std::vector<Segment> MachHeaderParser::DecodeSegments() {
    BinaryViewDataReader reader{&binaryView_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    std::vector<Segment> result;
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd == LC_SEGMENT_64) {
            BinaryViewDataReader sub{reader};
            result.push_back(DecodeSegment(sub));
        }
        reader.Seek(cmd.cmdsize);
    }
    return result;
}

std::optional<uint64_t> MachHeaderParser::DecodeEntryPoint() {
    BinaryViewDataReader reader{&binaryView_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd != LC_UNIXTHREAD) {
            reader.Seek(cmd.cmdsize);
            continue;
        }
        auto sub = BinaryViewDataReader{reader};
        sub.Seek(sizeof(thread_command));
        auto flavor = sub.Peek<uint32_t>();
        if (flavor != ARM_THREAD_STATE64) {
            throw MachHeaderDecodeError{"unsupported LC_UNIXTHREAD flavor {}", flavor};
        }
        auto state = sub.Read<arm_unified_thread_state>();
        return state.uts.ts_64.pc;
    }
    return std::nullopt;
}

std::optional<Types::UUID> MachHeaderParser::DecodeUUID() {
    BinaryViewDataReader reader{&binaryView_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd != LC_UUID) {
            reader.Seek(cmd.cmdsize);
            continue;
        }
        auto uuid = reader.Peek<uuid_command>();
        Types::UUID result;
        static_assert(sizeof(result.data) == sizeof(uuid.uuid));
        memcpy(result.data, uuid.uuid, sizeof(result.data));
        return result;
    }
    return std::nullopt;
}


/// Mach binary view

std::vector<uint64_t> MachBinaryView::ReadMachOHeaderOffsets() {
    uint64_t start = binaryView_.GetStart();
    std::vector<uint64_t> result{start};
    MachHeaderParser header{binaryView_, start};
    for (const auto &fileset: header.DecodeFilesets()) {
        if (binaryView_.GetTypeName() == "Raw") {
            result.push_back(fileset.fileOffset + binaryView_.GetStart());
        } else {
            result.push_back(fileset.vmAddr);
        }
    }
    return result;
}

std::map<Types::UUID, std::vector<Segment>> MachBinaryView::ReadMachOHeaders() {
    std::map<Types::UUID, std::vector<Segment>> result;
    for (const auto offset: ReadMachOHeaderOffsets()) {
        if (!binaryView_.IsValidOffset(offset)) {
            continue;
        }
        MachHeaderParser parser{binaryView_, offset};
        auto uuid = parser.DecodeUUID();
        if (!uuid) {
            BDLogWarn("mach header at {:#016x} does not have LC_UUID command, "
                      "symbols won't be loaded this segments in this header",
                      offset);
            continue;
        }
        result[*uuid] = parser.DecodeSegments();
    }
    return result;
}

```

`common/src/utils/binary_view.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/binary_view.h"

using namespace Binja;
using namespace Utils;
using namespace BinaryNinja;

Ref<BinaryView> Utils::OpenBinaryView(const std::string &filename, bool updateAnalysis, Ref<BinaryViewType> viewType,
                                      std::function<bool(size_t, size_t)> progress, Json::Value options) {
    if (!progress)
        progress = [](size_t, size_t) { return true; };

    // Loading will surely fail if the file does not exist, so exit early
    if (!BNPathExists(filename.c_str()))
        return nullptr;

    // Detect bndb
    bool isDatabase = false;
    Ref<BinaryView> view = nullptr;

    if (filename.size() > 6 && filename.substr(filename.size() - 5) == ".bndb") {
        // Open database, read raw view contents from it
        static const std::string sqlite_header = "SQLite format 3";

        FILE *f = fopen(filename.c_str(), "rb");
        // Unable to open file
        if (f == nullptr)
            return nullptr;

        char header[0x20];
        fread(header, 1, sqlite_header.size(), f);
        fclose(f);
        header[sqlite_header.size()] = 0;

        // File is not a valid sqlite db
        if (sqlite_header != header)
            return nullptr;

        Ref<FileMetadata> file = new FileMetadata(filename);
        view = file->OpenDatabaseForConfiguration(filename);
        isDatabase = true;
    } else {
        // Open file, read raw contents
        Ref<FileMetadata> file = new FileMetadata(filename);
        view = new BinaryData(file, filename);
    }

    if (!view)
        return nullptr;
    return Utils::OpenBinaryView(view, updateAnalysis, viewType, progress, options, isDatabase);
}

BinaryNinja::Ref<BinaryNinja::BinaryView> Utils::OpenBinaryView(
    BinaryNinja::Ref<BinaryNinja::BinaryView> view, bool updateAnalysis, Ref<BinaryViewType> requestedViewType,
    std::function<bool(size_t, size_t)> progress, Json::Value options, bool isDatabase) {
    Ref<BinaryViewType> bvt = requestedViewType;
    Ref<BinaryViewType> universalBvt;
    std::vector<Ref<BinaryViewType>> availableViewTypes = BinaryViewType::GetViewTypesForData(view);
    for (auto it = availableViewTypes.rbegin(), end = availableViewTypes.rend(); it != end; ++it) {
        Ref<BinaryViewType> available = *it;
        if (available->GetName() == "Universal") {
            universalBvt = available;
            continue;
        }
        if (!bvt && available->GetName() != "Raw") {
            bvt = available;
        }
    }

    // No available views: Load as Mapped
    if (!bvt)
        bvt = BinaryViewType::GetByName("Mapped");

    Ref<Settings> defaultSettings = Settings::Instance(bvt->GetName() + "_settings");
    defaultSettings->DeserializeSchema(Settings::Instance()->SerializeSchema());
    defaultSettings->SetResourceId(bvt->GetName());

    Ref<Settings> loadSettings;
    if (isDatabase) {
        loadSettings = view->GetLoadSettings(bvt->GetName());
    }
    if (!loadSettings) {
        if (universalBvt && options.isMember("files.universal.architecturePreference")) {
            // Load universal architecture
            loadSettings = universalBvt->GetLoadSettingsForData(view);
            if (!loadSettings) {
                LogError("Could not load entry from Universal image. No load settings!");
                return nullptr;
            }
            std::string architectures = loadSettings->Get<std::string>("loader.universal.architectures");

            std::unique_ptr<Json::CharReader> reader(Json::CharReaderBuilder().newCharReader());
            Json::Value archList;
            std::string errors;
            if (!reader->parse((const char *) architectures.data(), (const char *) architectures.data() + architectures.size(), &archList, &errors)) {
                BinaryNinja::LogError("Error parsing architecture list: %s", errors.data());
                return nullptr;
            }

            Json::Value archEntry;
            for (auto archPref: options["files.universal.architecturePreference"]) {
                for (auto entry: archList) {
                    if (entry["architecture"].asString() == archPref.asString()) {
                        archEntry = entry;
                        break;
                    }
                }
                if (!archEntry.isNull())
                    break;
            }
            if (archEntry.isNull()) {
                std::string error = "Could not load any of:";
                for (auto archPref: options["files.universal.architecturePreference"]) {
                    error += std::string(" ") + archPref.asString();
                }
                error += " from Universal image. Entry not found! Available entries:";
                for (auto entry: archList) {
                    error += std::string(" ") + entry["architecture"].asString();
                }
                LogError("%s", error.c_str());
                return nullptr;
            }

            loadSettings = Settings::Instance(GetUniqueIdentifierString());
            loadSettings->DeserializeSchema(archEntry["loadSchema"].asString());
        } else {
            // Load non-universal architecture
            loadSettings = bvt->GetLoadSettingsForData(view);
        }
    }

    if (!loadSettings) {
        LogError("Could not get load settings for binary view of type '%s'", bvt->GetName().c_str());
        return nullptr;
    }

    loadSettings->SetResourceId(bvt->GetName());
    view->SetLoadSettings(bvt->GetName(), loadSettings);

    for (auto key: options.getMemberNames()) {
        auto value = options[key];
        if (loadSettings->Contains(key)) {
            Json::StreamWriterBuilder builder;
            builder["indentation"] = "";
            std::string json = Json::writeString(builder, value);

            if (!loadSettings->SetJson(key, json, view)) {
                LogError("Setting: %s set operation failed!", key.c_str());
                return nullptr;
            }
        } else if (defaultSettings->Contains(key)) {
            Json::StreamWriterBuilder builder;
            builder["indentation"] = "";
            std::string json = Json::writeString(builder, value);

            if (!defaultSettings->SetJson(key, json, view)) {
                LogError("Setting: %s set operation failed!", key.c_str());
                return nullptr;
            }
        } else {
            LogError("Setting: %s not available!", key.c_str());
            return nullptr;
        }
    }

    Ref<BinaryView> bv;
    if (isDatabase) {
        view = view->GetFile()->OpenExistingDatabase(view->GetFile()->GetFilename(), progress);
        if (!view) {
            LogError("Unable to open existing database with filename %s", view->GetFile()->GetFilename().c_str());
            return nullptr;
        }
        bv = view->GetFile()->GetViewOfType(bvt->GetName());
    } else {
        bv = bvt->Create(view);
    }

    if (!bv) {
        return view;
    }
    if (updateAnalysis) {
        bv->UpdateAnalysisAndWait();
    }
    return bv;
}
```

`common/src/utils/span_reader.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/span_reader.h"

using namespace Binja;
using namespace Utils;

std::string SpanReader::ReadString() {
    std::string result;
    while (true) {
        char c = *Read<char>();
        if (c == '\0') {
            break;
        }
        result += c;
    }
    return result;
}

std::string SpanReader::PeekString(size_t offset) {
    std::string result;
    while (true) {
        char c = *Peek<char>(offset++);
        if (c == '\0') {
            break;
        }
        result += c;
    }
    return result;
}

SpanReader &SpanReader::Skip(size_t size) {
    VerifyAvailable(size);
    offset_ += size;
    return *this;
}

SpanReader SpanReader::Sub(size_t size) {
    VerifyAvailable(size);
    SpanReader reader{image_.subspan(offset_, size)};
    offset_ += size;
    return reader;
}

void SpanReader::VerifyAvailable(uint64_t size) {
    if (offset_ + size > image_.size()) {
        throw ReadError{"Required data of size {} is not available at offset {}", size, offset_};
    }
}
```

`common/src/utils/strconv.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/strconv.h"

using namespace Binja;
using namespace Utils;

uint64_t Utils::Strtoull(const std::string &str, int base) {
    char *endp = nullptr;
    uint64_t value = std::strtoull(str.data(), &endp, base);
    if (endp - str.data() != str.size()) {
        throw std::invalid_argument(fmt::format(
            "value {} cannot be converted to uint64 with base {}", str, base));
    }
    return value;
}

```

`debuginfo/CMakeLists.txt`:

```txt
set(LIBRARY_NAME dwarf_debuginfo)

set(DWARF_LOADER_HEADERS
        include/binja/debuginfo/errors.h
        include/binja/debuginfo/debug.h
        include/binja/debuginfo/dwarf.h
        include/binja/debuginfo/dwarf_task.h
        include/binja/debuginfo/function.h
        include/binja/debuginfo/macho_task.h
        include/binja/debuginfo/name_index.h
        include/binja/debuginfo/plugin_dsym.h
        include/binja/debuginfo/plugin_macho.h
        include/binja/debuginfo/source_finder.h
        include/binja/debuginfo/slider.h
        include/binja/debuginfo/types.h
        include/binja/debuginfo/variable.h)

set(DWARF_LOADER_SOURCES
        src/dsym.cpp
        src/dwarf.cpp
        src/dwarf_task.cpp
        src/function.cpp
        src/macho_task.cpp
        src/name_index.cpp
        src/plugin_dsym.cpp
        src/plugin_macho.cpp
        src/types.cpp
        src/slider.cpp
        src/source_finder.cpp
        src/variable.cpp)

add_library(${LIBRARY_NAME} STATIC ${DWARF_LOADER_SOURCES} ${DWARF_LOADER_HEADERS})
target_include_directories(${LIBRARY_NAME} PUBLIC include/binja)

target_link_libraries(${LIBRARY_NAME} PRIVATE LLVMSupport LLVMDebugInfoDWARF LLVMObject)
get_property(LLVM_INCLUDE_DIRECTORIES GLOBAL PROPERTY EXTERNAL_LLVM_INCLUDE_DIRECTORIES)
target_include_directories(${LIBRARY_NAME} PUBLIC ${LLVM_INCLUDE_DIRECTORIES})
target_include_directories(${LIBRARY_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)
target_include_directories(${LIBRARY_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/binja/debuginfo)

target_link_libraries(${LIBRARY_NAME} PUBLIC binja_kc_common)
target_link_libraries(${LIBRARY_NAME} PUBLIC binaryninjaapi fmt::fmt Boost::container_hash
        Boost::icl Boost::iostreams range-v3::range-v3 Taskflow)

add_subdirectory(test)
```

`debuginfo/include/binja/debuginfo/debug.h`:

```h


// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include "dwarf.h"
#include "errors.h"

#define DWARF_DEBUG_BUILD 1

#define VerifyNotReachable() \
    throw Binja::DebugInfo::FatalError { "VerifyNotReachable failed at {}:{}", __FILE__, __LINE__ }

#define Verify(Condition, ErrorType)                               \
    if (!(Condition)) {                                            \
        throw ErrorType{"Verify condition {} failed", #Condition}; \
    }                                                              \
    0

#if DWARF_DEBUG_BUILD
#define DebugVerify(Condition, ErrorType)                            \
    if (!(Condition)) {                                              \
        throw ErrorType{"Debug verify condition {} failed at {}:{}", \
                        #Condition, __FILE_NAME__, __LINE__};        \
    }                                                                \
    0
#else
#define DebugVerify(Condition, ErrorType) \
    do {                                  \
    } while (0)
#endif

#define Todo() \
    throw Binja::Dwarf::FatalError { "todo at {}:{}", __FILE__, __LINE__ }

#define VerifyDumpDie(Condition, Die)                                                        \
    if (!(Condition)) {                                                                      \
        throw Binja::DebugInfo::DwarfError{"Verify condition {} failed at {}:{} for DIE {}", \
                                           #Condition, __FILE_NAME__, __LINE__,              \
                                           Binja::DebugInfo::DieReader{Die}.Dump()};         \
    }                                                                                        \
    0

#if DWARF_DEBUG_BUILD
#define VerifyDebugDumpDie(Condition, Die)                                                         \
    if (!(Condition)) {                                                                            \
        throw Binja::DebugInfo::DwarfError{"Debug verify condition {} failed at {}:{} for DIE {}", \
                                           #Condition, __FILE_NAME__, __LINE__,                    \
                                           Binja::DebugInfo::DieReader{Die}.Dump()};               \
    }                                                                                              \
    0
#else
#define VerifyDebugDumpDie(Condition, Die)                           \
    if (!(Condition)) {                                              \
        Binja::Dwarf::AttributeReader reader{Die};                   \
        throw LogWarn{"Debug verify condition {} failed for DIE {}", \
                      #Condition, reader.DebugInfo()};               \
    }
#endif
```

`debuginfo/include/binja/debuginfo/dsym.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <string>
#include <vector>

#include <binja/macho/macho.h>
#include <binja/types/uuid.h>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/Object/MachO.h>

namespace Binja::DebugInfo {

class DwarfObjectFile {
public:
    explicit DwarfObjectFile(const std::filesystem::path &objectPath);
    llvm::DWARFContext &GetDWARFContext() { return *dwarfContext_; }

    static std::vector<std::filesystem::path> DsymFindObjects(
        const std::filesystem::path &symbolsPath);

    std::optional<Types::UUID> DecodeUUID() const;
    std::vector<MachO::Segment> DecodeSegments() const;

private:
    std::unique_ptr<llvm::MemoryBuffer> buffer_;
    std::unique_ptr<llvm::object::Binary> binaryObject_;
    std::unique_ptr<llvm::DWARFContext> dwarfContext_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/dwarf.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <functional>
#include <optional>

#include <fmt/format.h>
#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include <binja/utils/debug.h>

#include "debug.h"
#include "dsym.h"
#include "errors.h"
#include "slider.h"

namespace Binja::DebugInfo {

struct DwarfOffset {
    uint64_t
        binaryId : 16,
        offset : 48;
    auto operator<=>(const DwarfOffset &oth) const = default;
};

class DwarfDieWrapper;
class DwarfDebugInfoEntryWrapper;
class DwarfUnitWrapper;

}// namespace Binja::DebugInfo

namespace Binja::DebugInfo::Detail {

class DwarfDieWrapperIterator;

}


namespace std {

template<>
struct hash<Binja::DebugInfo::DwarfOffset> {
    std::size_t operator()(Binja::DebugInfo::DwarfOffset const &s) const noexcept {
        static_assert(sizeof(s) == sizeof(uint64_t));
        auto v = *reinterpret_cast<const uint64_t *>(&s);
        return hash<uint64_t>{}(v);
    }
};

}// namespace std


namespace Binja::DebugInfo {

using BinaryId = uint16_t;

class DwarfDebugInfoEntryWrapper {
public:
    DwarfDebugInfoEntryWrapper(llvm::DWARFDebugInfoEntry entry, BinaryId binaryId)
        : entry_{entry}, binaryId_{binaryId} {}

    [[nodiscard]] DwarfOffset GetOffset() const { return DwarfOffset{binaryId_, entry_.getOffset()}; }

private:
    llvm::DWARFDebugInfoEntry entry_;
    BinaryId binaryId_;
};

class DwarfUnitWrapper {
public:
    DwarfUnitWrapper(llvm::DWARFUnit &unit, BinaryId binaryId)
        : unit_{unit}, binaryId_{binaryId} {}

    [[nodiscard]] uint8_t GetAddressByteSize() const;
    [[nodiscard]] std::vector<DwarfDebugInfoEntryWrapper> Dies() const;
    [[nodiscard]] const llvm::dwarf::FormParams GetFormParams();

private:
    llvm::DWARFUnit &unit_;
    BinaryId binaryId_;
};

class DwarfDieWrapper {
private:
    using Tag = llvm::dwarf::Tag;
    using Attribute = llvm::dwarf::Attribute;
    using DWARFFormValue = llvm::DWARFFormValue;
    using IteratorTransform = std::function<DwarfDieWrapper(const llvm::DWARFDie &)>;
    using Iterator = llvm::iterator_range<Detail::DwarfDieWrapperIterator>;
    template<class T> using Optional = llvm::Optional<T>;

public:
    DwarfDieWrapper(llvm::DWARFDie die, BinaryId binaryId)
        : die_{die}, offset_{binaryId, 0} {
        if (die.isValid()) {
            offset_.offset = die_.getOffset();
        }
    }

    DwarfDieWrapper()
        : die_{}, offset_{std::numeric_limits<BinaryId>::max()} {}

    [[nodiscard]] Tag GetTag() const { return die_.getTag(); }
    [[nodiscard]] DwarfOffset GetOffset() const { return offset_; }
    [[nodiscard]] Optional<DWARFFormValue> Find(Attribute attr) const { return die_.find(attr); }
    [[nodiscard]] Optional<DWARFFormValue> FindRecursively(Attribute attr) const { return die_.findRecursively(attr); }
    [[nodiscard]] bool IsValid() { return die_.isValid(); }
    [[nodiscard]] bool operator==(const DwarfDieWrapper &oth) const;

    [[nodiscard]] Optional<DwarfDieWrapper> GetAttributeValueAsReferencedDie(const llvm::DWARFFormValue &value) const;
    [[nodiscard]] DwarfUnitWrapper GetDwarfUnit() const;
    [[nodiscard]] DwarfDieWrapper GetParent() const;
    [[nodiscard]] DwarfDieWrapper GetSibling();
    [[nodiscard]] DwarfDieWrapper GetPreviousSibling();
    [[nodiscard]] DwarfDieWrapper GetFirstChild();
    [[nodiscard]] DwarfDieWrapper GetLastChild();
    [[nodiscard]] Iterator Children();
    [[nodiscard]] llvm::Expected<llvm::DWARFAddressRangesVector> GetAddressRanges();
    [[nodiscard]] llvm::Expected<llvm::DWARFLocationExpressionsVector> GetLocations(llvm::dwarf::Attribute attr);
    void Dump(llvm::raw_ostream &ss, uint32_t indent = 0, llvm::DIDumpOptions opts = llvm::DIDumpOptions{});

private:
    llvm::DWARFDie die_;
    DwarfOffset offset_;
};

class DwarfContextWrapper {
public:
    struct Entry {
        DwarfObjectFile object;
        AddressSlider slider;
    };

public:
    explicit DwarfContextWrapper(std::vector<Entry> entries)
        : entries_{std::move(entries)} {
        BDVerify(entries_.size() <= std::numeric_limits<BinaryId>::max());
    }

    [[nodiscard]] DwarfDieWrapper GetDIEForOffset(DwarfOffset offset);
    [[nodiscard]] std::vector<DwarfUnitWrapper> GetNormalUnitsVector();
    [[nodiscard]] std::optional<uint64_t> GetSlidAddress(DwarfOffset offset, uint64_t source);
    [[nodiscard]] size_t GetDwarfObjectCount() const { return entries_.size(); }

private:
    std::vector<Entry> entries_;
};

class AttributeReader {
public:
    explicit AttributeReader(DwarfDieWrapper &die) : die_{die} {}
    [[nodiscard]] std::optional<uint64_t> ReadUInt(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::optional<uint64_t> ReadInt(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::string ReadString(llvm::dwarf::Attribute attribute, const char *defaultValue = "", bool recursive = false) const;
    [[nodiscard]] std::string ReadName(const char *defaultName = "", bool recursive = false) const;
    [[nodiscard]] std::optional<DwarfDieWrapper> ReadReference(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] bool HasAttribute(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::string ReadLinkageName(const char *defaultName = "", bool recursive = false) const;
    [[nodiscard]] std::optional<llvm::DWARFFormValue> FindAttribute(llvm::dwarf::Attribute attr, bool recursive) const;
    [[nodiscard]] std::optional<uint64_t> ReadLocationAddress() const;

private:
    DwarfDieWrapper &die_;
};

class DieReader {
public:
    explicit DieReader(DwarfDieWrapper &die) : die_{die}, attrReader_{die} {}
    const AttributeReader &AttrReader() const { return attrReader_; }
    std::vector<std::string> ReadQualifiedName() const;
    uint8_t ReadAddressSize() const;
    [[nodiscard]] std::string Dump() const;

private:
    DwarfDieWrapper &die_;
    AttributeReader attrReader_;
};

}// namespace Binja::DebugInfo


namespace Binja::DebugInfo::Detail {

class DwarfDieWrapperIterator
    : public llvm::iterator_facade_base<DwarfDieWrapperIterator, std::bidirectional_iterator_tag,
                                        const DwarfDieWrapperIterator> {

    friend std::reverse_iterator<llvm::DWARFDie::iterator>;
    friend bool operator==(const DwarfDieWrapperIterator &lhs,
                           const DwarfDieWrapperIterator &rhs);

public:
    DwarfDieWrapperIterator() = default;

    explicit DwarfDieWrapperIterator(DwarfDieWrapper die) : die_(die) {}

    DwarfDieWrapperIterator &operator++() {
        die_ = die_.GetSibling();
        return *this;
    }

    DwarfDieWrapperIterator &operator--() {
        die_ = die_.GetPreviousSibling();
        return *this;
    }

    const DwarfDieWrapper &operator*() const { return die_; }

private:
    DwarfDieWrapper die_;
};

inline bool operator==(const DwarfDieWrapperIterator &v1,
                       const DwarfDieWrapperIterator &v2) {
    return v1.die_ == v2.die_;
}

}// namespace Binja::DebugInfo::Detail

namespace fmt {

template<>
struct formatter<Binja::DebugInfo::DwarfOffset> : formatter<string_view> {
    template<typename FormatContext>
    auto format(const Binja::DebugInfo::DwarfOffset &p, FormatContext &ctx) const -> decltype(ctx.out()) {
        return fmt::format_to(ctx.out(), "b{}o{}", p.binaryId, p.offset);
    }
};

}// namespace fmt
```

`debuginfo/include/binja/debuginfo/dwarf_task.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <llvm/DebugInfo/DWARF/DWARFContext.h>

#include "dwarf.h"

namespace Binja::DebugInfo {

struct ImportOptions {
    bool importTypes;
    bool importFunctions;
    bool importGlobals;
};

enum class DwarfImportPhase : int {
    Min = -1,
    IndexingQualifiedNames,
    DecodingTypes,
    AddingTypesToBinaryView,
    ImportingFunctionsAndGlobals,
    Max
};

struct DwarfImportProgressMonitor {
    virtual bool operator()(DwarfImportPhase phase, size_t total, size_t done) = 0;
};

class DwarfImportTask {
public:
    DwarfImportTask(const std::vector<std::filesystem::path> &dwarfObjects,
                    BinaryNinja::BinaryView &binaryView,
                    BinaryNinja::DebugInfo &debugInfo,
                    ImportOptions options,
                    DwarfImportProgressMonitor &monitor)
        : dwarfObjects_{dwarfObjects},
          binaryView_{binaryView},
          debugInfo_{debugInfo},
          options_{options},
          monitor_{monitor} {}

    const ImportOptions &GetImportOptions() { return options_; }
    void Import();
    static bool IsNamedTypeTag(llvm::dwarf::Tag tag);

private:
    DwarfContextWrapper BuildDwarfContext();

private:
    const std::vector<std::filesystem::path> &dwarfObjects_;
    BinaryNinja::BinaryView &binaryView_;
    BinaryNinja::DebugInfo &debugInfo_;
    ImportOptions options_;
    DwarfImportProgressMonitor &monitor_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <exception>
#include <fmt/format.h>

namespace Binja::DebugInfo {

class GenericException : public std::exception {
public:
    template<typename... T>
    explicit GenericException(fmt::format_string<T...> fmt, T &&...args)
        : msg_{fmt::format(fmt, std::forward<T>(args)...)} {}
    [[nodiscard]] const char *what() const noexcept override { return msg_.c_str(); }

private:
    std::string msg_;
};

class FatalError : public GenericException {
    using GenericException::GenericException;
};

class DwarfError : public GenericException {
    using GenericException::GenericException;
};

void test(const std::string &path);
}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/function.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include "dwarf.h"
#include "types.h"

namespace Binja::DebugInfo {

struct DwarfFunctionInfo {
    BinaryNinja::Ref<BinaryNinja::Type> type;
    BinaryNinja::QualifiedName qualifiedName;
    uint64_t entryPoint;
    bool isNoReturn;
};

class FunctionDecoder {
public:
    FunctionDecoder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die_} {}

    std::optional<DwarfFunctionInfo> Decode();

private:
    std::optional<uint64_t> DecodeEntryPoint();
    bool DecodeIsNoReturn();

private:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper &die_;
    DieReader dieReader_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/macho_task.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <vector>

#include <binaryninjaapi.h>

#include <binja/macho/macho.h>
#include <binja/types/uuid.h>

#include "slider.h"

namespace Binja::DebugInfo {

struct MachOImportProgressMonitor {
    virtual bool operator()(size_t total, size_t done) = 0;
};

class MachOImportTask {
public:
    MachOImportTask(std::vector<std::filesystem::path> sources,
                    BinaryNinja::BinaryView &binaryView, BinaryNinja::DebugInfo &debugInfo,
                    MachOImportProgressMonitor &monitor);
    void Import();

private:
    BinaryNinja::Ref<BinaryNinja::BinaryView> OpenMachO(const std::filesystem::path &path);
    bool AddSymbol(const BinaryNinja::Symbol &symbol, AddressSlider &slider);

private:
    BinaryNinja::BinaryView &binaryView_;
    BinaryNinja::DebugInfo &debugInfo_;
    std::vector<std::filesystem::path> sources_;
    std::map<uint64_t, std::string> registeredSymbols_;
    MachOImportProgressMonitor &monitor_;
    std::map<Types::UUID, std::vector<MachO::Segment>> targetSegments_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/name_index.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <limits>
#include <unordered_map>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include "dwarf.h"
#include "types.h"

namespace Binja::DebugInfo {

class NameIndex {
private:
    struct Node;

    using QualfiedName = BinaryNinja::QualifiedName;
    using NodeInfoVectorIndex = size_t;
    using NodeEntryMap = std::map<std::string, Node>;

    struct Node {
        NodeInfoVectorIndex info;
        NodeEntryMap children;
    };

    struct NodeInfo {
        std::string name;
        DwarfOffset baseDie;
        int forkIndex = 0;
    };

    enum class NodeMergeStrategy {
        fork,
        replace,
        alias
    };

    using NodeInfoVector = std::vector<NodeInfo>;
    using AliasMap = std::unordered_map<DwarfOffset, NodeInfoVectorIndex>;

private:
    const NodeInfoVectorIndex kRootNodeIndex_ = std::numeric_limits<NodeInfoVectorIndex>::max();

public:
    NameIndex(DwarfContextWrapper &dwarfContext) : dwarfContext_{dwarfContext} {}
    void IndexDie(DwarfDieWrapper &die);
    QualfiedName DecodeQualifiedName(DwarfDieWrapper &die);
    DwarfDieWrapper ResolveDieOffset(DwarfOffset offset);
    void VisitEntries(std::function<void(const std::vector<std::string> &, DwarfOffset)> cb);
    size_t NumEntries() const { return nodeCount_; }
    std::vector<DwarfOffset> DecodeHierarchy(DwarfOffset offset);

private:
    void InsertHierarchy(const std::vector<DwarfOffset> &hierarchy);
    NodeMergeStrategy EvaluateMergeStrategy(DwarfOffset currentDieOffset, DwarfOffset newDieOffset);
    NameIndex::Node *MergeNode(Node &parentNode, std::string name, DwarfOffset newDieOffset);
    NameIndex::Node *InsertNode(Node &parent, std::string name, DwarfOffset dieOffset);
    const NameIndex::Node *FindChild(const Node &parent, DwarfOffset dieOffset);

    static const char *GetAnonymousNameSuffix(llvm::dwarf::Tag tag);
    static std::string GetAnonymousName(DwarfDieWrapper &die);

private:
    DwarfContextWrapper &dwarfContext_;
    Node root_{kRootNodeIndex_};
    NodeInfoVector nodeInfoVector_;
    AliasMap aliasMap_;
    size_t nodeCount_ = 0;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/plugin_dsym.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>

#include <binaryninjaapi.h>

#include "dsym.h"
#include "dwarf_task.h"

namespace Binja::DebugInfo {

class PluginDSYM {
public:
    static constexpr auto kPluginName = "dsym_debug_info";

public:
    PluginDSYM(BinaryNinja::BinaryView &binaryView)
        : binaryView_{binaryView} {}

    void Load(BinaryNinja::DebugInfo &debugInfo, DwarfImportProgressMonitor &monitor);

    static void RegisterPlugin();
    std::optional<std::filesystem::path> GetSymbolSource();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/plugin_macho.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>

#include <binaryninjaapi.h>

#include "dsym.h"
#include "macho_task.h"

namespace Binja::DebugInfo {

class PluginMacho {
public:
    static constexpr auto kPluginName = "macho_debug_info";

public:
    PluginMacho(BinaryNinja::BinaryView &binaryView)
        : binaryView_{binaryView} {}

    void Load(BinaryNinja::DebugInfo &debugInfo, MachOImportProgressMonitor &monitor);

    static void RegisterPlugin();
    std::optional<std::filesystem::path> GetSymbolSource();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/slider.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <boost/icl/interval_map.hpp>

#include <binja/macho/macho.h>

namespace Binja::DebugInfo {

class AddressSlider {
private:
    using Interval = boost::icl::discrete_interval<uint64_t>;

public:
    void Map(Interval from, Interval to);
    std::optional<uint64_t> SlideAddress(uint64_t address);

    static AddressSlider CreateFromMachOSegments(const std::vector<MachO::Segment> &from,
                                                 const std::vector<MachO::Segment> &to);

private:
    boost::icl::interval_map<uint64_t, uint64_t> s1map_;
    boost::icl::interval_map<uint64_t, uint64_t> s2map_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/source_finder.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <map>
#include <set>

#include <binaryninjaapi.h>

#include <binja/types/errors.h>
#include <binja/types/uuid.h>

#include "./dwarf.h"

namespace Binja::DebugInfo {

class KDKError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

class SymbolSourceFinder {
public:
    explicit SymbolSourceFinder(std::filesystem::path path) : path_{std::move(path)} { VerifyKDK(); }
    std::set<std::filesystem::path> FindAllDSYMObjects();
    std::set<std::filesystem::path> FindAllMachoObjects();
    std::set<std::filesystem::path> FindAllKernelExtensions();

private:
    void VerifyKDK();

private:
    std::filesystem::path path_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/types.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <binaryninjaapi.h>

#include "dwarf.h"

namespace Binja::DebugInfo {

class TypeBuilderContext {
public:
    using Type = BinaryNinja::Type;
    using TypeRef = BinaryNinja::Ref<Type>;
    using QualifiedName = BinaryNinja::QualifiedName;

public:
    TypeBuilderContext(DwarfContextWrapper &dwarfContext) : dwarfContext_{dwarfContext} {}
    virtual ~TypeBuilderContext() = default;
    virtual BinaryNinja::QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) = 0;
    virtual DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) = 0;
    virtual bool TagDieAsProcessing(DwarfDieWrapper &die);
    virtual void UntagDieAsProcessing(DwarfDieWrapper &die);
    virtual std::optional<uint64_t> SlideAddress(DwarfOffset die, uint64_t address);

protected:
    DwarfContextWrapper &dwarfContext_;
    std::unordered_set<DwarfOffset> workingSet_;
};

class TypeBuilder {
public:
    TypeBuilder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die}, attributeReader_{die} {}

    virtual BinaryNinja::Ref<BinaryNinja::Type> Build() = 0;

    static bool IsTypeTag(llvm::dwarf::Tag tag);

protected:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper &die_;
    DieReader dieReader_;
    AttributeReader attributeReader_;
};

class GenericTypeBuilder : public TypeBuilder {
public:
    GenericTypeBuilder(TypeBuilderContext &ctx, DwarfDieWrapper &die, bool decodeNamedTypes = false)
        : TypeBuilder{ctx, die}, decodeNamedTypes_{decodeNamedTypes},
          resolvedDie_{ctx.ResolveDie(die)}, resolvedDieReader_{resolvedDie_} {}
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    BinaryNinja::Ref<BinaryNinja::Type> DoBuild();

private:
    bool decodeNamedTypes_;
    DwarfDieWrapper resolvedDie_;
    DieReader resolvedDieReader_;
};

class BaseTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    BinaryNinja::Ref<BinaryNinja::Type> MapBNType(uint64_t size, uint64_t encoding);
};

class TypeModifierBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static bool IsTypeModifierTag(llvm::dwarf::Tag tag);
};

class TypedefBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static std::optional<DwarfDieWrapper> Resolve(DwarfDieWrapper &die);
};

class ArrayTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    BinaryNinja::Ref<BinaryNinja::Type> BuildDynamic();
    BinaryNinja::Ref<BinaryNinja::Type> BuildStatic();
    std::optional<size_t> DecodeCountFromSubrange(DwarfDieWrapper &die);
    size_t GetDefaultLowerBound();
};

class FunctionTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    struct DecodeParametersResult {
        bool hasVarArg;
        std::vector<BinaryNinja::FunctionParameter> parameters;
    };

private:
    BinaryNinja::Ref<BinaryNinja::Type> DecodeReturnType();
    BinaryNinja::Ref<BinaryNinja::CallingConvention> DecodeCallingConvention();
    DecodeParametersResult DecodeParameters();
    BinaryNinja::Ref<BinaryNinja::Type> DecodeParameterType(DwarfDieWrapper &die);
    BinaryNinja::Ref<BinaryNinja::Type> ApplyParameterTypeModifiers(BinaryNinja::Ref<BinaryNinja::Type> type, DwarfDieWrapper &die);
};

class EnumTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    std::optional<DwarfDieWrapper> ResolveBaseType();
};

class CompositeTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static bool IsCompositeTypeTag(llvm::dwarf::Tag tag);


private:
    BNStructureVariant DecodeVariant();
    BNMemberAccess GetDefaultMemberAccess();
    bool IsPacked();
    uint8_t DecodeAlignment();
    size_t DecodeWidth();

private:
    struct DecodeMemberResult {
        BinaryNinja::Ref<BinaryNinja::Type> type;
        std::string name;
        uint64_t offset;
        BNMemberAccess access;
    };

    struct DecodeVariableResult {
        BinaryNinja::Ref<BinaryNinja::Type> type;
        std::string name;
        BNMemberAccess access;
    };

private:
    std::optional<DecodeMemberResult> DecodeMember(DwarfDieWrapper &die);
    BNMemberAccess DecodeMemberAccess(std::optional<uint64_t> accessibility);
    std::optional<DecodeVariableResult> DecodeVariable(DwarfDieWrapper &die);
    void ProcessBitfields(BinaryNinja::StructureBuilder &builder);
    std::optional<DwarfDieWrapper> ProcessBitfield(BinaryNinja::StructureBuilder &builder, DwarfDieWrapper &start);
};

class PointerToMemberTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
};

class NamedTypeReferenceBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    BNNamedTypeReferenceClass DecodeTypeClass();
};

class TypeSizeDecoder {
public:
    TypeSizeDecoder(DwarfDieWrapper die) : die_{die} {}
    std::optional<uint64_t> Decode();

private:
    static std::optional<DwarfDieWrapper> ResolveType(DwarfDieWrapper &die);

private:
    DwarfDieWrapper die_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/variable.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include "./dwarf.h"
#include "./types.h"

namespace Binja::DebugInfo {

struct DwarfVariableInfo {
    BinaryNinja::Ref<BinaryNinja::Type> type;
    BinaryNinja::QualifiedName qualifiedName;
    uint64_t location;
};

class VariableDecoder {
public:
    VariableDecoder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die_} {}

    std::optional<DwarfVariableInfo> Decode();

private:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper die_;
    DieReader dieReader_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/src/dsym.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/Object/MachO.h>
#include <llvm/Object/MachOUniversal.h>
#include <llvm/Support/Error.h>

#include <binja/types/errors.h>
#include <binja/utils/debug.h>

#include "debug.h"
#include "dsym.h"


using namespace Binja;
using namespace DebugInfo;
using namespace llvm;

namespace fs = std::filesystem;

/// LLVM error utility methods

namespace {

std::string LLVMErrorToString(llvm::Error error) {
    std::string out;
    llvm::raw_string_ostream ss{out};
    logAllUnhandledErrors(std::move(error), ss, "");
    return out;
}

std::string LLVMErrorToString(std::error_code ec) {
    llvm::Error error = llvm::errorCodeToError(ec);
    return LLVMErrorToString(std::move(error));
}

}// namespace


/// Dwarf object file

DwarfObjectFile::DwarfObjectFile(const std::filesystem::path &objectPath) {
    {
        ErrorOr<std::unique_ptr<MemoryBuffer>> buff = MemoryBuffer::getFileOrSTDIN(objectPath.string());
        if (!buff) {
            throw DwarfError{"failed to open file {}, error: {}", objectPath.string(),
                             LLVMErrorToString(buff.getError())};
        }
        buffer_ = std::move(buff.get());
    }

    {
        Expected<std::unique_ptr<object::Binary>> binary = object::createBinary(*buffer_);
        if (!binary) {
            throw DwarfError{"invalid dwarf symbol file {}, error: {}", objectPath.string(),
                             LLVMErrorToString(binary.takeError())};
        }
        binaryObject_ = std::move(binary.get());
    }

    if (auto *obj = llvm::dyn_cast<object::ObjectFile>(&*binaryObject_)) {
        dwarfContext_ = DWARFContext::create(*obj, DWARFContext::ProcessDebugRelocations::Process);
        Verify(dwarfContext_, FatalError);
        return;
    }

    if (auto *fat = dyn_cast<object::MachOUniversalBinary>(&*binaryObject_)) {
        for (auto &obj: fat->objects()) {
            if (auto mach = obj.getAsObjectFile()) {
                std::unique_ptr<object::MachOObjectFile> machObj = std::move(*mach);
                if (machObj->getArch() == llvm::Triple::aarch64) {
                    dwarfContext_ = DWARFContext::create(*machObj, DWARFContext::ProcessDebugRelocations::Process);
                    binaryObject_ = std::move(machObj);
                    Verify(dwarfContext_, FatalError);
                    return;
                }
            } else {
                throw DwarfError{"failed to open universal macho, err: {}", LLVMErrorToString(mach.takeError())};
            }
        }
        throw DwarfError{"dwarf object file does not have symbols for aarch64 architecture"};
    }
    throw DwarfError{"invalid dwarf object file"};
}

std::vector<fs::path> DwarfObjectFile::DsymFindObjects(const fs::path &symbolsPath) {
    std::vector<fs::path> objectPaths;
    if (auto objects = object::MachOObjectFile::findDsymObjectMembers(symbolsPath.string())) {
        if (objects->empty()) {
            objectPaths.push_back(symbolsPath);
        } else {
            for (const auto &object: *objects) {
                auto result = object::createBinary(object);
                if (result) {
                    objectPaths.push_back(object);
                } else if (llvm::errorToErrorCode(result.takeError()) != object::object_error::invalid_file_type) {
                    throw FatalError{"unexpected error: {}", LLVMErrorToString(result.takeError())};
                }
            }
        }
    } else {
        throw DwarfError{"invalid symbols file {}, error: {}", symbolsPath.string(),
                         LLVMErrorToString(objects.takeError())};
    }
    return objectPaths;
}

std::optional<Types::UUID> DwarfObjectFile::DecodeUUID() const {
    auto *macho = llvm::dyn_cast<llvm::object::MachOObjectFile>(dwarfContext_->getDWARFObj().getFile());
    BDVerify(macho);
    for (auto lc: macho->load_commands()) {
        if (lc.C.cmd != llvm::MachO::LC_UUID) {
            continue;
        }
        Types::UUID result;
        if (lc.C.cmdsize < sizeof(lc.C) + sizeof(result.data)) {
            throw Types::DecodeError{"too small LC_UUID command size: {}", lc.C.cmdsize};
        }
        memcpy(&result.data, lc.Ptr + sizeof(lc.C), sizeof(result.data));
        return result;
    }
    return std::nullopt;
}

std::vector<Binja::MachO::Segment> DwarfObjectFile::DecodeSegments() const {
    auto *macho = llvm::dyn_cast<llvm::object::MachOObjectFile>(dwarfContext_->getDWARFObj().getFile());
    BDVerify(macho);
    std::vector<Binja::MachO::Segment> result;
    for (auto lc: macho->load_commands()) {
        if (lc.C.cmd != llvm::MachO::LC_SEGMENT_64) {
            continue;
        }
        const auto *cmd = reinterpret_cast<const llvm::MachO::segment_command_64 *>(lc.Ptr);
        MachO::Segment segment;
        segment.name = cmd->segname;
        segment.vaStart = cmd->vmaddr;
        segment.vaLength = cmd->vmsize;
        segment.dataStart = cmd->fileoff;
        segment.dataLength = cmd->filesize;
        // TODO: decode sections and flags
        result.push_back(segment);
    }
    return result;
}

```

`debuginfo/src/dwarf.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/DebugInfo/DWARF/DWARFExpression.h>
#include <llvm/DebugInfo/DWARF/DWARFUnit.h>

#include <fmt/format.h>
#include <range/v3/view/transform.hpp>

#include <binja/utils/log.h>

#include "debug.h"
#include "dwarf.h"

using namespace llvm;
using namespace Binja;
using namespace DebugInfo;

using dwarf::Attribute;


/// LLVM error utility methods

namespace {

std::string LLVMErrorToString(llvm::Error error) {
    std::string out;
    llvm::raw_string_ostream ss{out};
    logAllUnhandledErrors(std::move(error), ss, "");
    return out;
}

std::string LLVMFormValueToString(const Optional<DWARFFormValue> &value, const char *defaultValue) {
    if (value) {
        Expected<const char *> cstr = value->getAsCString();
        if (cstr) {
            return std::string(cstr.get());
        }
        LLVMErrorToString(cstr.takeError());
    }
    return std::string(defaultValue);
}

}// namespace


/// Dwarf unit wrapper

std::vector<DwarfDebugInfoEntryWrapper> DwarfUnitWrapper::Dies() const {
    std::vector<DwarfDebugInfoEntryWrapper> entries;
    for (const auto &die: unit_.dies()) {
        entries.push_back(DwarfDebugInfoEntryWrapper{die, binaryId_});
    }
    return entries;
}

uint8_t DwarfUnitWrapper::GetAddressByteSize() const {
    return unit_.getAddressByteSize();
}

const dwarf::FormParams DwarfUnitWrapper::GetFormParams() {
    return unit_.getFormParams();
}


/// Dwarf die wrapper

Optional<DwarfDieWrapper> DwarfDieWrapper::GetAttributeValueAsReferencedDie(const llvm::DWARFFormValue &value) const {
    if (auto ref = die_.getAttributeValueAsReferencedDie(value)) {
        return DwarfDieWrapper{ref, (BinaryId) offset_.binaryId};
    }
    return llvm::None;
}

DwarfUnitWrapper DwarfDieWrapper::GetDwarfUnit() const {
    return DwarfUnitWrapper{*die_.getDwarfUnit(), (BinaryId) offset_.binaryId};
}

void DwarfDieWrapper::Dump(raw_ostream &ostream, uint32_t indent, llvm::DIDumpOptions opts) {
    die_.dump(ostream, indent, opts);
}

DwarfDieWrapper DwarfDieWrapper::GetParent() const {
    return DwarfDieWrapper{die_.getParent(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetSibling() {
    return DwarfDieWrapper{die_.getSibling(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetPreviousSibling() {
    return DwarfDieWrapper{die_.getPreviousSibling(), (BinaryId) offset_.binaryId};
}

bool DwarfDieWrapper::operator==(const DwarfDieWrapper &oth) const {
    return die_ == oth.die_ && offset_.binaryId == oth.offset_.binaryId;
}

DwarfDieWrapper::Iterator DwarfDieWrapper::Children() {
    return llvm::iterator_range<Detail::DwarfDieWrapperIterator>(
        Detail::DwarfDieWrapperIterator{GetFirstChild()},
        Detail::DwarfDieWrapperIterator{GetLastChild()});
}

DwarfDieWrapper DwarfDieWrapper::GetFirstChild() {
    return DwarfDieWrapper{die_.getFirstChild(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetLastChild() {
    return DwarfDieWrapper{die_.getLastChild(), (BinaryId) offset_.binaryId};
}

Expected<DWARFAddressRangesVector> DwarfDieWrapper::GetAddressRanges() {
    return die_.getAddressRanges();
}

Expected<DWARFLocationExpressionsVector> DwarfDieWrapper::GetLocations(llvm::dwarf::Attribute attr) {
    return die_.getLocations(attr);
}


/// Dwarf context wrapper

DwarfDieWrapper DwarfContextWrapper::GetDIEForOffset(DwarfOffset offset) {
    DWARFDie die = entries_[offset.binaryId].object.GetDWARFContext().getDIEForOffset(offset.offset);
    return DwarfDieWrapper{die, (BinaryId) offset.binaryId};
}

std::vector<DwarfUnitWrapper> DwarfContextWrapper::GetNormalUnitsVector() {
    std::vector<DwarfUnitWrapper> result;
    for (size_t i = 0; i < entries_.size(); ++i) {
        llvm::DWARFContext &ctx = entries_[i].object.GetDWARFContext();
        for (const auto &unit: ctx.getNormalUnitsVector()) {
            result.push_back(DwarfUnitWrapper{*unit, (BinaryId) i});
        }
    }
    return result;
}

std::optional<uint64_t> DwarfContextWrapper::GetSlidAddress(DwarfOffset offset, uint64_t address) {
    if (auto value = entries_[offset.binaryId].slider.SlideAddress(address)) {
        return value;
    }
    return std::nullopt;
}


/// Attribute reader

std::optional<uint64_t> AttributeReader::ReadUInt(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        if (auto value = ref->getAsUnsignedConstant()) {
            return *value;
        }
    }
    return std::nullopt;
}

std::optional<uint64_t> AttributeReader::ReadInt(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        if (auto value = ref->getAsSignedConstant()) {
            return *value;
        }
    }
    return std::nullopt;
}

std::string AttributeReader::ReadString(Attribute attribute, const char *defaultValue, bool recursive) const {
    if (recursive) {
        return LLVMFormValueToString(die_.FindRecursively(attribute), defaultValue);
    }
    return LLVMFormValueToString(die_.Find(attribute), defaultValue);
}

std::optional<DwarfDieWrapper> AttributeReader::ReadReference(Attribute attribute, bool recursive) const {
    if (auto attr = FindAttribute(attribute, recursive)) {
        return die_.GetAttributeValueAsReferencedDie(*attr).getValue();
    }
    return std::nullopt;
}

std::string AttributeReader::ReadName(const char *defaultName, bool recursive) const {
    return ReadString(llvm::dwarf::DW_AT_name, defaultName, recursive);
}

bool AttributeReader::HasAttribute(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        return true;
    }
    return false;
}

std::string AttributeReader::ReadLinkageName(const char *defaultName, bool recursive) const {
    return ReadString(dwarf::DW_AT_linkage_name, defaultName, recursive);
}

std::optional<llvm::DWARFFormValue> AttributeReader::FindAttribute(
    llvm::dwarf::Attribute attr, bool recursive) const {
    if (recursive) {
        if (auto v = die_.FindRecursively(attr)) {
            return *v;
        }
    } else {
        if (auto v = die_.Find(attr)) {
            return *v;
        }
    }
    return std::nullopt;
}

std::optional<uint64_t> AttributeReader::ReadLocationAddress() const {
    auto formValue = die_.Find(dwarf::DW_AT_location);
    if (!formValue) {
        return std::nullopt;
    }

    auto block = formValue->getAsBlock();
    if (!block) {
        return std::nullopt;
    }

    auto unit = die_.GetDwarfUnit();

    // TODO: hardcoded endian
    DataExtractor data(StringRef((const char *) block->data(), block->size()), true, 0);
    DWARFExpression expression{data, unit.GetAddressByteSize(), unit.GetFormParams().Format};
    if (expression.begin() == expression.end()) {
        return std::nullopt;
    }

    auto operation = *expression.begin();
    if (operation.getCode() != dwarf::DW_OP_addr) {
        return std::nullopt;
    }
    return operation.getRawOperand(0);
}

/// DIE reader


std::string DieReader::Dump() const {
    auto addressSize = die_.GetDwarfUnit().GetAddressByteSize();
    std::string out;
    llvm::raw_string_ostream ss{out};
    llvm::DIDumpOptions opts{.AddrSize = addressSize};
    ss << "\n";
    ss << "=========================\n"
          "PARENTS: \n"
          "=========================\n";
    opts.ShowParents = true;
    opts.ShowAddresses = true;
    opts.ShowForm = true;
    die_.Dump(ss, 0, opts);
    ss << "\n";
    ss << "=========================\n"
          "CHILDREN: \n"
          "=========================\n";
    opts.ShowParents = false;
    opts.ShowChildren = true;
    die_.Dump(ss, 0, opts);
    return out;
}

namespace {

class QualifiedNameBuilder {
public:
    explicit QualifiedNameBuilder(DwarfDieWrapper &die) : die_{die} {}

    std::vector<std::string> Build() {
        using namespace dwarf;
        auto tag = die_.GetTag();
        AttributeReader reader{die_};
        switch (tag) {
            case DW_TAG_variable:
            case DW_TAG_array_type:
            case DW_TAG_base_type:
            case DW_TAG_subroutine_type:
            case DW_TAG_unspecified_type: {
                auto name = reader.ReadString(DW_AT_name);
                if (name.empty()) {
                    name = GetAnonymousName(die_);
                }
                qf_.push_back(name);
                DwarfDieWrapper parent = die_.GetParent();
                ScanContainer(parent);
                break;
            }
            default: {
                ScanContainer(die_);
                break;
            }
        }
        std::reverse(qf_.begin(), qf_.end());
        return std::move(qf_);
    }

private:
    void ScanContainer(DwarfDieWrapper &die) {
        using namespace dwarf;

        if (!die.IsValid()) {
            return;
        }

        auto tag = die.GetTag();
        AttributeReader reader{die};
        std::string name = reader.ReadString(DW_AT_name, "", true);

        switch (tag) {
            case llvm::dwarf::DW_TAG_compile_unit:
                return;
            case DW_TAG_namespace: {
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            case DW_TAG_lexical_block: {
                name = GetAnonymousName(die);
                qf_.push_back(name);
                break;
            }
            case DW_TAG_enumeration_type: {
                if (!reader.HasAttribute(DW_AT_enum_class)) {
                    break;
                }
                // fallthrough
            }
            case DW_TAG_base_type:
            case DW_TAG_typedef:
            case DW_TAG_template_alias: {
                VerifyDebugDumpDie(!name.empty(), die);
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            case DW_TAG_class_type: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    ScanContainer(*base);
                    return;
                }
                // fallthrough
            }
            case DW_TAG_structure_type:
            case DW_TAG_union_type: {
                if (!reader.HasAttribute(DW_AT_export_symbols)) {
                    if (name.empty()) {
                        name = GetAnonymousName(die);
                    }
                    qf_.push_back(name);
                }
                break;
            }
            case DW_TAG_inlined_subroutine: {
                auto base = reader.ReadReference(DW_AT_abstract_origin);
                VerifyDumpDie(base, die);
                ScanContainer(*base);
                break;
            }
            case DW_TAG_subprogram: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    ScanContainer(*base);
                    return;
                }
                if (auto base = reader.ReadReference(DW_AT_abstract_origin)) {
                    ScanContainer(*base);
                    return;
                }
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            default: {
                throw DwarfError{"unexpected container type {}, DIE: {}",
                                 TagString(tag), DieReader{die}.Dump()};
            }
        }

        DwarfDieWrapper parent = die.GetParent();
        ScanContainer(parent);
    }

    static const char *GetAnonymousNameSuffix(dwarf::Tag tag) {
        switch (tag) {
            case dwarf::DW_TAG_namespace:
                return "ns";
            case dwarf::DW_TAG_structure_type:
                return "struct";
            case dwarf::DW_TAG_class_type:
                return "class";
            case dwarf::DW_TAG_union_type:
                return "union";
            case dwarf::DW_TAG_subprogram:
            case dwarf::DW_TAG_inlined_subroutine:
                return "function";
            case dwarf::DW_TAG_subroutine_type:
                return "functor";
            case dwarf::DW_TAG_enumeration_type:
                return "enum";
            case dwarf::DW_TAG_lexical_block:
                return "block";
            default:
                throw FatalError{"unexpected dwarf tag {}", dwarf::TagString(tag)};
        }
    }

    static std::string GetAnonymousName(DwarfDieWrapper &die) {
        return fmt::format("__anon_{}_{:#04x}_{:#08x}", GetAnonymousNameSuffix(die.GetTag()),
                           die.GetOffset().binaryId, die.GetOffset().offset);
    }

private:
    DwarfDieWrapper &die_;
    std::vector<std::string> qf_;
};

}// namespace

std::vector<std::string> DieReader::ReadQualifiedName() const {
    return QualifiedNameBuilder{die_}.Build();
}

uint8_t DieReader::ReadAddressSize() const {
    return die_.GetDwarfUnit().GetAddressByteSize();
}

```

`debuginfo/src/dwarf_task.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <boost/functional/hash.hpp>
#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "debug.h"
#include "dwarf_task.h"
#include "function.h"
#include "name_index.h"
#include "types.h"
#include "variable.h"

using namespace Binja;
using namespace DebugInfo;
using namespace llvm;
using namespace BinaryNinja;

namespace {

class OrderedTypeBuilderContext : public TypeBuilderContext {
public:
    OrderedTypeBuilderContext(DwarfContextWrapper &dwarfContext, NameIndex &index)
        : TypeBuilderContext{dwarfContext}, index_{index} {}

    QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) {
        return index_.DecodeQualifiedName(die);
    }

    DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) {
        return index_.ResolveDieOffset(die.GetOffset());
    }

private:
    NameIndex index_;
};

}// namespace

void DwarfImportTask::Import() {
    DwarfContextWrapper dwarfContext = BuildDwarfContext();
    BDLogInfo("importing symbols from {} dwarf objects",
              dwarfContext.GetDwarfObjectCount());

    NameIndex nameIndex{dwarfContext};

    // phase 1
    {
        const auto &units = dwarfContext.GetNormalUnitsVector();
        size_t numUnits = units.size();
        BDLogInfo("indexing types from {} units", numUnits);

        for (size_t i = 0; i < numUnits; ++i) {
            for (const auto &dieInfo: units[i].Dies()) {
                DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieInfo.GetOffset());
                if (!IsNamedTypeTag(die.GetTag())) {
                    continue;
                }
                if (AttributeReader{die}.ReadName("", true).empty()) {
                    continue;
                }
                nameIndex.IndexDie(die);
            }
            monitor_(DwarfImportPhase::IndexingQualifiedNames, i, numUnits);
        }
    }

    {
        // phase 2
        size_t numNamedNodes = nameIndex.NumEntries();
        OrderedTypeBuilderContext context{dwarfContext, nameIndex};
        BDLogInfo("indexed {} named entities", numNamedNodes);
        size_t index = 0;
        nameIndex.VisitEntries([&](const std::vector<std::string> &qualifiedName, DwarfOffset dieOffset) {
            DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieOffset);
            if (IsNamedTypeTag(die.GetTag()) && !AttributeReader{die}.ReadName("", true).empty()) {
                auto type = GenericTypeBuilder{context, die, true}.Build();
                auto name = QualifiedName{qualifiedName};
                debugInfo_.AddType(name.GetString(), type);
            }
            monitor_(DwarfImportPhase::DecodingTypes, ++index, ++numNamedNodes);
        });
        BDLogInfo("imported {} named types to binary view", numNamedNodes);
    }

    // phase 4
    {
        const auto &units = dwarfContext.GetNormalUnitsVector();
        size_t numUnits = units.size();
        BDLogInfo("importing functions and globals from {} units", numUnits);

        OrderedTypeBuilderContext context{dwarfContext, nameIndex};
        std::set<uint64_t> importedFunctions;
        std::set<uint64_t> importedGlobals;
        for (size_t i = 0; i < numUnits; ++i) {
            for (const auto &dieInfo: units[i].Dies()) {
                DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieInfo.GetOffset());
                switch (die.GetTag()) {
                    case dwarf::DW_TAG_subprogram: {
                        auto info = FunctionDecoder{context, die}.Decode();
                        if (!info) {
                            break;
                        }
                        auto [_, ok] = importedFunctions.insert(info->entryPoint);
                        if (!ok) {
                            continue;
                        }

                        QualifiedName name = nameIndex.DecodeQualifiedName(die);
                        DebugFunctionInfo symbol{
                            name.back(),
                            name.GetString(),
                            fmt::format("sub_{:#016x}", info->entryPoint),
                            info->entryPoint,
                            info->type,
                            binaryView_.GetDefaultPlatform()};
                        symbol.type = info->type;

                        debugInfo_.AddFunction(symbol);
                        break;
                    }
                    case dwarf::DW_TAG_constant:
                    case dwarf::DW_TAG_variable: {
                        auto info = VariableDecoder{context, die}.Decode();
                        if (!info) {
                            break;
                        }

                        auto [_, ok] = importedGlobals.insert(info->location);
                        if (!ok) {
                            continue;
                        }

                        Ref<Symbol> symbol = new Symbol{
                            BNSymbolType::DataSymbol,
                            info->qualifiedName.back(),
                            info->qualifiedName.GetString(),
                            fmt::format("data_{:#016x}", info->location),
                            info->location,
                        };
                        debugInfo_.AddDataVariable(info->location, info->type, info->qualifiedName.GetString());
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }
            monitor_(DwarfImportPhase::ImportingFunctionsAndGlobals, i, numUnits);
        }

        BDLogInfo("imported {} functions", importedFunctions.size());
        BDLogInfo("imported {} globals", importedGlobals.size());
    }
}

bool DwarfImportTask::IsNamedTypeTag(dwarf::Tag tag) {
    switch (tag) {
        case dwarf::DW_TAG_typedef:
        case dwarf::DW_TAG_array_type:
        case dwarf::DW_TAG_enumeration_type:
        case dwarf::DW_TAG_subroutine_type:
        case dwarf::DW_TAG_structure_type:
        case dwarf::DW_TAG_union_type:
        case dwarf::DW_TAG_class_type:
        case dwarf::DW_TAG_ptr_to_member_type:
        case dwarf::DW_TAG_unspecified_type:
            return true;
        default:
            return false;
    }
}

DwarfContextWrapper DwarfImportTask::BuildDwarfContext() {
    auto targetObjects = MachO::MachBinaryView{binaryView_}.ReadMachOHeaders();
    std::vector<DwarfContextWrapper::Entry> entries;
    for (const auto &sourceObject: dwarfObjects_) {
        DwarfObjectFile object{sourceObject};
        auto uuid = object.DecodeUUID();
        BDVerify(uuid);
        BDVerify(targetObjects.contains(*uuid));
        auto symbolSegments = object.DecodeSegments();
        entries.emplace_back(DwarfContextWrapper::Entry{
            .object = std::move(object),
            .slider = AddressSlider::CreateFromMachOSegments(
                symbolSegments, targetObjects[*uuid])});
    }
    return DwarfContextWrapper{std::move(entries)};
}

```

`debuginfo/src/function.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <binja/utils/log.h>

#include "function.h"

using namespace Binja;
using namespace DebugInfo;

using namespace BinaryNinja;
namespace DW = llvm::dwarf;

std::optional<DwarfFunctionInfo> FunctionDecoder::Decode() {
    DwarfFunctionInfo info;
    if (auto entry = DecodeEntryPoint()) {
        info.entryPoint = *entry;
    } else {
        return std::nullopt;
    }

    if (auto slidAddress = ctx_.SlideAddress(die_.GetOffset(), info.entryPoint)) {
        info.entryPoint = *slidAddress;
    } else {
        BDLogWarn("cannot slide address {:#016x} using binary {}",
                  info.entryPoint, die_.GetOffset().binaryId);
        return std::nullopt;
    }

    info.qualifiedName = ctx_.DecodeQualifiedName(die_);
    info.type = FunctionTypeBuilder{ctx_, die_}.Build();
    info.isNoReturn = DecodeIsNoReturn();

    return info;
}

std::optional<uint64_t> FunctionDecoder::DecodeEntryPoint() {
    const AttributeReader &attributeReader = dieReader_.AttrReader();
    if (auto value = attributeReader.ReadUInt(DW::DW_AT_low_pc)) {
        return value;
    }
    if (auto ranges = die_.GetAddressRanges()) {
        if (ranges->size() != 0) {
            return ranges.get().begin()->LowPC;
        }
    }
    if (auto value = attributeReader.ReadUInt(DW::DW_AT_entry_pc)) {
        return value;
    }
    return std::nullopt;
}

bool FunctionDecoder::DecodeIsNoReturn() {
    return dieReader_.AttrReader().HasAttribute(DW::DW_AT_noreturn, true);
}

```

`debuginfo/src/macho_task.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>
#include <mutex>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <taskflow/taskflow.hpp>

#include <binja/utils/binary_view.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "macho_task.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
namespace fs = std::filesystem;


/// MachO import task

MachOImportTask::MachOImportTask(std::vector<fs::path> sources, BinaryView &binaryView,
                                 BinaryNinja::DebugInfo &debugInfo, MachOImportProgressMonitor &monitor)
    : binaryView_{binaryView}, debugInfo_{debugInfo}, sources_{sources}, monitor_{monitor},
      targetSegments_{MachO::MachBinaryView{binaryView}.ReadMachOHeaders()} {
    for (const auto &symbol: binaryView.GetSymbols()) {
        registeredSymbols_[symbol->GetAddress()] = symbol->GetFullName();
    }
}

void MachOImportTask::Import() {
    tf::Taskflow taskflow;
    tf::Executor executor;

    std::mutex mtx;
    size_t numAdded = 0;
    std::atomic<size_t> completed;
    taskflow.for_each(sources_.begin(), sources_.end(), [&](const auto &source) {
        auto binary = OpenMachO(source);
        completed++;
        if (!binary) {
            return;
        }

        BDLogDebug("importing symbols from macho {}", binary->GetFile()->GetOriginalFilename());
        auto uuid = MachO::MachHeaderParser{*binary, binary->GetStart()}.DecodeUUID();
        BDVerify(uuid);
        auto targetSegments = targetSegments_[*uuid];

        AddressSlider slider = AddressSlider::CreateFromMachOSegments(
            MachO::MachHeaderParser{*binary, binary->GetStart()}.DecodeSegments(),
            targetSegments);

        std::vector<Ref<Symbol>> symbols = binary->GetSymbols();
        std::lock_guard lock{mtx};
        monitor_(completed, sources_.size());

        for (Ref<Symbol> symbol: symbols) {
            if (AddSymbol(*symbol, slider)) {
                numAdded++;
            }
        }
    });

    executor.run(taskflow).wait();
    BDLogInfo("Imported {} symbols from {} macho sources", numAdded, sources_.size());
}

Ref<BinaryView> MachOImportTask::OpenMachO(const fs::path &path) {
    Json::Value options;
    Json::Value preferredArchs;
    preferredArchs.append("arm64e");
    preferredArchs.append("arm64");
    options["files.universal.architecturePreference"] = preferredArchs;// TODO: dynamic
    options["analysis.debugInfo.internal"] = false;
    auto bv = Utils::OpenBinaryView(path, false, nullptr, nullptr, options);
    if (!bv->HasSymbols()) {
        BDLogWarn("ignoring macho image {} with no symbols", path.string());
        return nullptr;
    }
    auto uuid = MachO::MachHeaderParser{*bv, bv->GetStart()}.DecodeUUID();
    if (!uuid) {
        BDLogWarn("ignoring macho image {} with no LC_UUID", path.string());
        return nullptr;
    }
    if (!targetSegments_.contains(*uuid)) {
        BDLogDebug("ignoring macho image {} with uuid {} since its uuid does not match with any "
                   "segment in binary view",
                   path.string(), *uuid);
        return nullptr;
    }
    return bv;
}

bool MachOImportTask::AddSymbol(const Symbol &symbol, AddressSlider &slider) {
    std::string qualifiedName = symbol.GetFullName();
    uint64_t address = symbol.GetAddress();

    if (symbol.GetType() != BNSymbolType::FunctionSymbol && symbol.GetType() != BNSymbolType::DataSymbol) {
        BDLogDebug("ignoring external symbol {} at {}",
                   symbol.GetFullName(), symbol.GetAddress());
        return false;
    }

    if (auto slidAddress = slider.SlideAddress(address)) {
        address = *slidAddress;
    } else {
        BDLogWarn("failed to slide address {}", address);
        return false;
    }

    if (registeredSymbols_.contains(address)) {
        BDLogWarn("skipping symbol {} since another symbol {} already exist at address {:#016x}",
                  qualifiedName, registeredSymbols_[address], address);
        return false;
    }

    Ref<Symbol> newSymbol = new Symbol{
        symbol.GetType(),
        qualifiedName,
        address,
        symbol.GetBinding(),
        symbol.GetNameSpace()};

    registeredSymbols_[address] = qualifiedName;

    switch (symbol.GetType()) {
        case FunctionSymbol: {
            DebugFunctionInfo info{
                symbol.GetShortName(),
                symbol.GetFullName(),
                symbol.GetRawName(),
                address,
                nullptr,
                binaryView_.GetDefaultPlatform(),
            };
            debugInfo_.AddFunction(info);
            break;
        }
        case DataSymbol: {
            debugInfo_.AddDataVariable(address, Type::VoidType(), symbol.GetFullName());
            break;
        }
        case ImportAddressSymbol:
        case ImportedFunctionSymbol:
        case ImportedDataSymbol:
        case ExternalSymbol:
        case LibraryFunctionSymbol:
            BDVerify(false);
    }
    return true;
}

```

`debuginfo/src/name_index.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include "debug.h"
#include "name_index.h"
#include "types.h"

using namespace Binja;
using namespace DebugInfo;

namespace DW = llvm::dwarf;

using BinaryNinja::QualifiedName;
using llvm::DWARFDie;

using Type = BinaryNinja::Type;
using TypeRef = BinaryNinja::Ref<Type>;


/// Type builder context

namespace {

class BasicTypeBuilderContext : public TypeBuilderContext {
public:
    BasicTypeBuilderContext(DwarfContextWrapper &dwarfContext)
        : TypeBuilderContext{dwarfContext} {}

    QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) {
        return QualifiedName{DieReader{die}.ReadQualifiedName()};
    }

    DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) {
        return die;
    }
};

}// namespace


/// Name index

void NameIndex::IndexDie(DwarfDieWrapper &die) {
    auto tag = die.GetTag();
    Verify(TypeBuilder::IsTypeTag(tag), FatalError);

    AttributeReader attributeReader{die};
    Verify(!attributeReader.ReadName("", true).empty(), FatalError);

    std::vector<DwarfOffset> hierarchy = DecodeHierarchy(die.GetOffset());
    InsertHierarchy(hierarchy);
}

void NameIndex::InsertHierarchy(const std::vector<DwarfOffset> &hierarchy) {
    Node *node = &root_;
    for (DwarfOffset newDieOffset: hierarchy) {
        DwarfDieWrapper newDie = ResolveDieOffset(newDieOffset);

        std::string name = AttributeReader{newDie}.ReadName("", true);
        if (name.empty()) {
            name = GetAnonymousName(newDie);
        }

        auto it = node->children.find(name);
        if (it != node->children.end()) {
            if (nodeInfoVector_[it->second.info].baseDie != newDie.GetOffset()) {
                node = MergeNode(*node, name, newDieOffset);
            } else {
                node = &it->second;
            }
        } else {
            node = InsertNode(*node, name, newDie.GetOffset());
        }
    }
}

std::vector<DwarfOffset> NameIndex::DecodeHierarchy(DwarfOffset offset) {
    using namespace llvm::dwarf;
    DwarfDieWrapper die = ResolveDieOffset(offset);
    std::vector<DwarfOffset> result;

    std::function<void(DwarfDieWrapper &)> scanContainer = [&](DwarfDieWrapper &die) {
        auto tag = die.GetTag();
        AttributeReader reader{die};
        std::string name = reader.ReadString(DW_AT_name, "", true);

        switch (tag) {
            case DW_TAG_compile_unit:
                return;
            case DW_TAG_namespace:
            case DW_TAG_lexical_block: {
                result.push_back(die.GetOffset());
                break;
            }
            case DW_TAG_enumeration_type:
            case DW_TAG_base_type:
            case DW_TAG_typedef:
            case DW_TAG_template_alias: {
                VerifyDebugDumpDie(!name.empty(), die);
                result.push_back(die.GetOffset());
                break;
            }
            case DW_TAG_class_type: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    scanContainer(*base);
                    return;
                }
                // fallthrough
            }
            case DW_TAG_structure_type:
            case DW_TAG_union_type: {
                if (!reader.HasAttribute(DW_AT_export_symbols)) {
                    result.push_back(die.GetOffset());
                }
                break;
            }
            case DW_TAG_inlined_subroutine: {
                auto base = reader.ReadReference(DW_AT_abstract_origin);
                VerifyDumpDie(base, die);
                scanContainer(*base);
                break;
            }
            case DW_TAG_subprogram: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    scanContainer(*base);
                    return;
                }
                if (auto base = reader.ReadReference(DW_AT_abstract_origin)) {
                    scanContainer(*base);
                    return;
                }
                result.push_back(die.GetOffset());
                break;
            }
            default: {
                throw DwarfError{"unexpected container type {}, DIE: {}",
                                 TagString(tag), DieReader{die}.Dump()};
            }
        }

        DwarfDieWrapper parent = die.GetParent();
        scanContainer(parent);
    };

    switch (die.GetTag()) {
        case DW_TAG_unspecified_type:
        case DW_TAG_variable:
        case DW_TAG_array_type:
        case DW_TAG_base_type:
        case DW_TAG_subroutine_type: {
            result.push_back(offset);
            break;
        }
        default: {
            scanContainer(die);
            break;
        }
    }

    std::reverse(result.begin(), result.end());
    BDVerify(!result.empty());
    return result;
}

NameIndex::Node *NameIndex::MergeNode(Node &parentNode, std::string name, DwarfOffset newDieOffset) {
    Node &baseNode = parentNode.children.find(name)->second;
    NodeInfo &baseNodeInfo = nodeInfoVector_[baseNode.info];
    for (int i = 0; i <= baseNodeInfo.forkIndex; ++i) {
        std::string childName;
        if (i != 0) {
            childName = fmt::format("{}__{}", name, i);
        } else {
            childName = name;
        }

        Node &child = parentNode.children.find(childName)->second;
        NodeInfo &childInfo = nodeInfoVector_[child.info];

        if (childInfo.baseDie == newDieOffset) {
            return &child;
        }

        switch (EvaluateMergeStrategy(childInfo.baseDie, newDieOffset)) {
            case NodeMergeStrategy::replace: {
                aliasMap_.insert({childInfo.baseDie, child.info});
                childInfo.baseDie = newDieOffset;
                return &child;
            }
            case NodeMergeStrategy::alias: {
                aliasMap_.insert({newDieOffset, child.info});
                return &child;
            }
            case NodeMergeStrategy::fork: {
                break;
            }
        }
    }

    std::string newName = fmt::format("{}__{}", name, ++baseNodeInfo.forkIndex);
    return InsertNode(parentNode, newName, newDieOffset);
}

DwarfDieWrapper NameIndex::ResolveDieOffset(DwarfOffset offset) {
    auto it = aliasMap_.find(offset);
    if (it != aliasMap_.end()) {
        return dwarfContext_.GetDIEForOffset(nodeInfoVector_[it->second].baseDie);
    }
    return dwarfContext_.GetDIEForOffset(offset);
}

namespace {

bool IsSameType(const Type &lhs, const Type &rhs);

bool IsSameStructureType(const BinaryNinja::Structure &lhs, const BinaryNinja::Structure &rhs) {
    if (lhs.GetWidth() != rhs.GetWidth()) {
        return false;
    }

    auto lhsMembers = lhs.GetMembers();
    auto rhsMembers = rhs.GetMembers();
    if (lhsMembers.size() != rhsMembers.size()) {
        return false;
    }

    for (size_t i = 0; i < lhsMembers.size(); ++i) {
        const auto &m1 = lhsMembers[i];
        const auto &m2 = rhsMembers[i];
        if (m1.name != m2.name || m1.offset != m2.offset || m1.access != m2.access || m1.scope != m2.scope) {
            return false;
        }
        if (m1.type && m2.type) {
            if (!IsSameType(*m1.type, *m2.type)) {
                return false;
            }
        } else if (m1.type || m2.type) {
            return false;
        }
    }

    return true;
}

bool IsSameType(const Type &lhs, const Type &rhs) {
    if (lhs.IsStructure() && rhs.IsStructure()) {
        auto s1 = lhs.GetStructure();
        auto s2 = rhs.GetStructure();
        return IsSameStructureType(*s1, *s2);
    }
    if (lhs.IsPointer() && rhs.IsPointer()) {
        auto b1 = lhs.GetChildType();
        auto b2 = rhs.GetChildType();
        return IsSameType(*b1, *b2);
    }
    if (lhs.IsNamedTypeRefer() && rhs.IsNamedTypeRefer()) {
        auto n1 = lhs.GetNamedTypeReference();
        auto n2 = rhs.GetNamedTypeReference();
        return n1->GetName() == n2->GetName();
    }
    return BNTypesEqual(lhs.GetObject(), rhs.GetObject());
}

}// namespace

NameIndex::NodeMergeStrategy NameIndex::EvaluateMergeStrategy(DwarfOffset currentDieOffset, DwarfOffset newDieOffset) {
    using namespace DW;
    Verify(currentDieOffset != newDieOffset, FatalError);

    DwarfDieWrapper currentDie = ResolveDieOffset(currentDieOffset);
    auto currentTag = currentDie.GetTag();
    bool currentIsType = TypeBuilder::IsTypeTag(currentTag);

    DwarfDieWrapper newDie = ResolveDieOffset(newDieOffset);
    auto newTag = newDie.GetTag();
    bool newIsType = TypeBuilder::IsTypeTag(newTag);

    if (currentIsType != newIsType) {
        return NameIndex::NodeMergeStrategy::fork;
    }

    if (currentIsType) {
        DwarfDieWrapper resolvedCurrentDie = currentDie;
        if (currentTag == DW_TAG_typedef) {
            if (auto resolved = TypedefBuilder::Resolve(currentDie)) {
                resolvedCurrentDie = ResolveDieOffset(resolved->GetOffset());
            }
        }
        DwarfDieWrapper resolvedNewDie = newDie;
        if (currentTag == DW_TAG_typedef) {
            if (auto resolved = TypedefBuilder::Resolve(newDie)) {
                resolvedNewDie = ResolveDieOffset(resolved->GetOffset());
            }
        }

        if (resolvedNewDie.GetOffset() == resolvedCurrentDie.GetOffset()) {
            return NodeMergeStrategy::alias;
        }

        BasicTypeBuilderContext ctx{dwarfContext_};
        TypeRef currentType = GenericTypeBuilder{ctx, resolvedCurrentDie, true}.Build();
        TypeRef newType = GenericTypeBuilder{ctx, resolvedNewDie, true}.Build();
        if (currentType && newType) {
            if (IsSameType(*currentType, *newType)) {
                return NodeMergeStrategy::alias;
            }
        }
    }

    if ((CompositeTypeBuilder::IsCompositeTypeTag(currentTag) || currentTag == DW_TAG_enumeration_type) && (CompositeTypeBuilder::IsCompositeTypeTag(newTag) || newTag == DW_TAG_enumeration_type)) {
        auto isForwardDeclaration = [](DwarfDieWrapper &die) {
            AttributeReader attributeReader{die};
            return attributeReader.HasAttribute(DW_AT_declaration);
        };
        bool currentIsDecl = isForwardDeclaration(currentDie);
        bool newIsDecl = isForwardDeclaration(newDie);
        if (currentIsDecl && !newIsDecl) {
            return NodeMergeStrategy::replace;
        }
        if (newIsDecl) {
            return NodeMergeStrategy::alias;
        }
    }

    return NodeMergeStrategy::fork;
}

const char *NameIndex::GetAnonymousNameSuffix(DW::Tag tag) {
    using namespace DW;
    switch (tag) {
        case DW_TAG_namespace:
            return "ns";
        case DW_TAG_structure_type:
            return "struct";
        case DW_TAG_class_type:
            return "class";
        case DW_TAG_union_type:
            return "union";
        case DW_TAG_subprogram:
        case DW_TAG_inlined_subroutine:
            return "function";
        case DW_TAG_subroutine_type:
            return "functor";
        case DW_TAG_enumeration_type:
            return "enum";
        case DW_TAG_lexical_block:
            return "block";
        case DW_TAG_unspecified_type:
            return "unknown";
        default:
            throw FatalError{"unexpected dwarf tag {}", TagString(tag)};
    }
}

std::string NameIndex::GetAnonymousName(DwarfDieWrapper &die) {
    return fmt::format("__anon_{}_{:#04x}_{:#08x}", GetAnonymousNameSuffix(die.GetTag()), die.GetOffset().binaryId, die.GetOffset().offset);
}

QualifiedName NameIndex::DecodeQualifiedName(DwarfDieWrapper &die) {
    std::vector<DwarfOffset> hierarchy = DecodeHierarchy(die.GetOffset());
    BDVerify(hierarchy.size() > 0);
    QualifiedName qualifiedName;
    const Node *node = &root_;
    for (DwarfOffset offset: hierarchy) {
        node = node ? FindChild(*node, offset) : nullptr;
        if (node) {
            const auto &info = nodeInfoVector_[node->info];
            qualifiedName.push_back(info.name);
        } else {
            auto child = ResolveDieOffset(offset);
            auto name = AttributeReader{child}.ReadName("", true);
            if (name.empty()) {
                name = GetAnonymousName(child);
            }
            qualifiedName.push_back(name);
        }
    }
    return qualifiedName;
}

const NameIndex::Node *NameIndex::FindChild(const NameIndex::Node &parent, DwarfOffset dieOffset) {
    auto die = ResolveDieOffset(dieOffset);
    std::string name = AttributeReader{die}.ReadName("", true);
    if (name.empty()) {
        name = GetAnonymousName(die);
    }

    auto it = parent.children.find(name);
    if (it == parent.children.end()) {
        return nullptr;
    }

    if (nodeInfoVector_[it->second.info].baseDie == die.GetOffset()) {
        return &it->second;
    }

    for (int i = 0; i <= nodeInfoVector_[it->second.info].forkIndex; i++) {
        std::string forkName = i == 0 ? name : fmt::format("{}__{}", name, i);
        auto forkIt = parent.children.find(forkName);
        const auto &info = nodeInfoVector_[forkIt->second.info];
        if (info.baseDie == dieOffset) {
            return &forkIt->second;
        }
    }

    return nullptr;
}

NameIndex::Node *NameIndex::InsertNode(NameIndex::Node &parent, std::string name, DwarfOffset dieOffset) {
    NodeInfoVectorIndex newEntryInfoIndex = nodeInfoVector_.size();
    NodeInfo newEntryInfo{name, dieOffset, 0};
    nodeInfoVector_.push_back(newEntryInfo);
    auto [it, ok] = parent.children.insert({std::move(name), Node{newEntryInfoIndex, {}}});
    Verify(ok, FatalError);
    ++nodeCount_;
    return &it->second;
}

void NameIndex::VisitEntries(std::function<void(const std::vector<std::string> &, DwarfOffset)> cb) {
    std::vector<std::string> name;
    std::function<void(const Node &)> iterateNode = [&](const Node &node) {
        for (const auto &child: node.children) {
            name.push_back(child.first);
            cb(name, nodeInfoVector_[child.second.info].baseDie);
            iterateNode(child.second);
            name.pop_back();
        }
    };
    iterateNode(root_);
}

```

`debuginfo/src/plugin_dsym.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include <binja/macho/macho.h>
#include <binja/utils/log.h>

#include "debug.h"
#include "dsym.h"
#include "dwarf_task.h"
#include "plugin_dsym.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
using namespace llvm;

namespace fs = std::filesystem;


void PluginDSYM::Load(BinaryNinja::DebugInfo &debugInfo, DwarfImportProgressMonitor &monitor) {
    auto source = GetSymbolSource();
    if (!source) {
        BDLogDebug("skipping dwarf symbols importing since no "
                   "dwarf source can be found");
        return;
    }

    SymbolSourceFinder sourceFinder{*source};

    std::vector<fs::path> dwarfObjects;
    for (const auto &dSYMFile: sourceFinder.FindAllDSYMObjects()) {
        try {
            auto objects = DwarfObjectFile::DsymFindObjects(dSYMFile);
            dwarfObjects.insert(dwarfObjects.end(), objects.begin(), objects.end());
        } catch (const DwarfError &e) {
            BDLogError("failed to open symbols file {}, error: {}",
                       dSYMFile.string(), e.what());
            return;
        }
    }

    auto targetObjects = MachO::MachBinaryView{binaryView_}.ReadMachOHeaders();
    std::vector<fs::path> sourceObjects;

    for (const auto &dwarfObject: dwarfObjects) {
        DwarfObjectFile objectFile{dwarfObject};
        auto uuid = objectFile.DecodeUUID();
        if (!uuid) {
            BDLogWarn("ignoring dwarf object {} since it does not have LC_UUID",
                      dwarfObject.string());
            continue;
        }

        if (!targetObjects.contains(*uuid)) {
            BDLogWarn("ignoring dwarf object {} since its uuid does not match with "
                      "any macho headers in binary view",
                      dwarfObject.string());
            continue;
        }

        sourceObjects.push_back(dwarfObject);
    }

    BDLogInfo("found {} dwarf symbols sources at {}", dwarfObjects.size(), source->string());
    try {
        ImportOptions options{
            .importTypes = true,
            .importFunctions = true,
            .importGlobals = true,
        };
        DwarfImportTask task{sourceObjects, binaryView_, debugInfo, options, monitor};
        task.Import();
    } catch (const Types::DecodeError &e) {
        BDLogError("Failed to load symbols, error: {}", e.what());
    }
}

std::optional<fs::path> PluginDSYM::GetSymbolSource() {
    fs::path binarySource = binaryView_.GetFile()->GetOriginalFilename();

    fs::path symbolsDirectory = fmt::format("{}.symbols", binarySource.string());
    if (fs::exists(symbolsDirectory)) {
        return symbolsDirectory;
    }
    BDLogInfo("no symbols source directory found at {}", symbolsDirectory.string());

    fs::path dsym = fmt::format("{}.dSYM", binarySource.string());

    if (fs::exists(dsym)) {
        return dsym;
    }
    BDLogInfo("no dSYM found at {}", dsym.string());

    return std::nullopt;
}

/// Progress monitor

namespace {

class ImportProgressMonitor : public DwarfImportProgressMonitor {
private:
    using Callback = bool (*)(void *, size_t, size_t);

public:
    explicit ImportProgressMonitor(Callback cb, void *pctx) : cb_{cb}, pctx_{pctx} {}

    bool operator()(DwarfImportPhase phase, size_t done, size_t total) override {
        return cb_(pctx_, done, total);
    }

private:
    Callback cb_;
    void *pctx_;
};

}// namespace


/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    PluginDSYM plugin{bv};
    if (plugin.GetSymbolSource()) {
        return true;
    }

    BDLogInfo("skipping dsym debug info import since no valid symbol source found");
    return false;
}

bool DoParseDebugInfo(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, bool(progress)(void *, size_t, size_t), void *pctx) {
    BinaryNinja::DebugInfo debugInfo{debugInfoHandle};
    BinaryNinja::BinaryView binaryView{binaryViewHandle};

    ImportProgressMonitor monitor{progress, pctx};
    PluginDSYM plugin{binaryView};
    plugin.Load(debugInfo, monitor);
    return true;
}

}// namespace

void PluginDSYM::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo, nullptr);
}

```

`debuginfo/src/plugin_macho.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include <binja/utils/log.h>

#include "macho_task.h"
#include "plugin_macho.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
using namespace llvm;

namespace fs = std::filesystem;


void PluginMacho::Load(BinaryNinja::DebugInfo &debugInfo, MachOImportProgressMonitor &monitor) {
    auto source = GetSymbolSource();
    if (!source) {
        BDLogDebug("skipping macho symbols import since valid source cannot be found");
        return;
    }
    auto machoObjects = SymbolSourceFinder{*source}.FindAllMachoObjects();
    BDLogInfo("found {} macho symbol sources at {}", machoObjects.size(), source->string());
    MachOImportTask task{std::vector<fs::path>{machoObjects.begin(), machoObjects.end()},
                         binaryView_, debugInfo, monitor};
    task.Import();
}

std::optional<fs::path> PluginMacho::GetSymbolSource() {
    fs::path binarySource = binaryView_.GetFile()->GetOriginalFilename();

    fs::path symbolsDirectory = fmt::format("{}.symbols", binarySource.string());

    if (fs::exists(symbolsDirectory)) {
        return symbolsDirectory;
    }
    BDLogInfo("no symbols source directory found at {}", symbolsDirectory.string());
    return std::nullopt;
}


/// Progress monitor

namespace {

class ImportProgressMonitor : public MachOImportProgressMonitor {
private:
    using Callback = bool (*)(void *, size_t, size_t);

public:
    ImportProgressMonitor(Callback cb, void *pctx) : cb_{cb}, pctx_{pctx} {}

    bool operator()(size_t done, size_t total) override {
        return cb_(pctx_, done, total);
    }

private:
    Callback cb_;
    void *pctx_;
};

}// namespace


/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    PluginMacho plugin{bv};
    if (plugin.GetSymbolSource()) {
        return true;
    }

    BDLogInfo("skipping import since no valid symbol source found");
    return false;
}

bool DoParseDebugInfo(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, bool(progress)(void *, size_t, size_t), void *pctx) {
    BinaryNinja::DebugInfo debugInfo{debugInfoHandle};
    BinaryNinja::BinaryView binaryView{binaryViewHandle};

    PluginMacho plugin{binaryView};
    ImportProgressMonitor monitor{progress, pctx};
    plugin.Load(debugInfo, monitor);
    return true;
}

}// namespace

void PluginMacho::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo, nullptr);
}

```

`debuginfo/src/slider.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "slider.h"

using namespace Binja;
using namespace DebugInfo;

void AddressSlider::Map(AddressSlider::Interval from, AddressSlider::Interval to) {
    BDVerify(from.upper() - from.lower() == to.upper() - to.lower());
    BDVerify(from.upper() - from.lower() > 0);
    BDVerify(s1map_.find(from) == s1map_.end());
    BDVerify(s2map_.find(to) == s2map_.end());
    s1map_.set({from, to.lower()});
    s2map_.set({to, from.lower()});
}

std::optional<uint64_t> AddressSlider::SlideAddress(uint64_t address) {
    auto it = s1map_.find(address);
    if (it == s1map_.end()) {
        return std::nullopt;
    }
    return it->second + address - it->first.lower();
}

AddressSlider AddressSlider::CreateFromMachOSegments(const std::vector<MachO::Segment> &from,
                                                     const std::vector<MachO::Segment> &to) {
    AddressSlider slider;
    for (const auto &targetSegment: to) {
        if (!targetSegment.vaLength) {
            BDLogDebug("skipping binary segment {} with no VA", targetSegment.name);
            continue;
        }
        auto sourceSegmentIt = std::find_if(from.begin(), from.end(), [&targetSegment](const auto &sourceSegment) {
            return sourceSegment.name == targetSegment.name;
        });
        if (sourceSegmentIt == from.end()) {
            BDLogDebug("binary segment {} did not match with any segment in symbol",
                       targetSegment.name);
            continue;
        }
        if (!sourceSegmentIt->vaLength) {
            BDLogDebug("symbol segment {} had zero VA length", targetSegment.name);
            continue;
        }
        size_t vaLength = std::min(sourceSegmentIt->vaLength, targetSegment.vaLength);
        AddressSlider::Interval sourceAddressRange{
            sourceSegmentIt->vaStart, sourceSegmentIt->vaStart + vaLength};
        AddressSlider::Interval destAddressRange{
            targetSegment.vaStart, targetSegment.vaStart + vaLength};
        if (sourceSegmentIt->vaLength != targetSegment.vaLength) {
            BDLogWarn("va range trimmed due to length mismatch at segment {} [{:#016x}, {:#016x})->[{:#016x}, {:#016x})",
                      targetSegment.name, sourceAddressRange.lower(), sourceAddressRange.upper(),
                      destAddressRange.lower(), destAddressRange.upper());
        }
        BDLogDebug("mapping segment {}", targetSegment.name);
        slider.Map(sourceAddressRange, destAddressRange);
    }
    return slider;
}

```

`debuginfo/src/source_finder.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <arpa/inet.h>
#include <fstream>

#include <boost/iostreams/device/mapped_file.hpp>
#include <llvm/Object/MachO.h>

#include <binja/macho/macho.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>
#include <binja/utils/span_reader.h>

#include "dsym.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;

namespace fs = std::filesystem;

/// KDK

namespace {

static const std::set<uint32_t> kMachOMagics{
    llvm::MachO::MH_MAGIC_64,
    llvm::MachO::MH_CIGAM_64,
};

static const std::set<uint32_t> kFileTypes{
    llvm::MachO::MH_KEXT_BUNDLE,
    llvm::MachO::MH_EXECUTE,

};

static const std::set<uint32_t> kFATMagics{
    llvm::MachO::FAT_MAGIC_64,
    llvm::MachO::FAT_CIGAM_64,
    llvm::MachO::FAT_CIGAM,
    llvm::MachO::FAT_MAGIC,
};

static const std::set<uint32_t> kCPUTypes{
    llvm::MachO::CPU_TYPE_ARM64};

static bool IsSupportedMachO(std::span<const char> data) {
    const auto *header = Utils::SpanReader{data}.Read<llvm::MachO::mach_header_64>();

    if (!kMachOMagics.contains(header->magic)) {
        return false;
    }

    if (!kFileTypes.contains(header->filetype)) {
        return false;
    }

    if (!kCPUTypes.contains(header->cputype)) {
        return false;
    }

    if ((header->flags & llvm::MachO::MH_INCRLINK) != 0) {
        return false;
    }

    return true;
}

static bool IsSupportedFat(std::span<const char> data) {
    Utils::SpanReader reader{data};
    const auto *header = reader.Read<llvm::MachO::fat_header>();

    if (!kFATMagics.contains(header->magic)) {
        return false;
    }

    std::vector<llvm::MachO::fat_arch> supportedArchs;
    for (uint32_t i = 0; i < ntohl(header->nfat_arch); ++i) {
        const auto *arch = reader.Read<llvm::MachO::fat_arch>();
        if (!kCPUTypes.contains(ntohl(arch->cputype))) {
            continue;
        }
        auto size = ntohl(arch->size);
        auto offset = ntohl(arch->offset);
        if (offset + size > data.size()) {
            continue;
        }
        if (IsSupportedMachO(data.subspan(offset, size))) {
            return true;
        }
    }

    return false;
}

}// namespace

void SymbolSourceFinder::VerifyKDK() {
    if (!fs::exists(path_)) {
        throw KDKError{"path {} does not exist", path_.string()};
    }
    if (!fs::is_directory(path_)) {
        throw KDKError{"KDK at path {} is not a directory", path_.string()};
    }
}

std::set<fs::path> SymbolSourceFinder::FindAllDSYMObjects() {
    std::set<fs::path> result;
    if (fs::is_directory(path_) && path_.extension() == ".dSYM") {
        result.insert(path_);
    } else {
        for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
            if (dirent.is_directory() && dirent.path().extension() == ".dSYM") {
                auto [_, ok] = result.insert(dirent.path());
                BDVerify(ok);
            }
        }
    }
    BDLogDebug("found {} dSYM files {}", result.size(), path_.string());
    return result;
}

std::set<fs::path> SymbolSourceFinder::FindAllMachoObjects() {
    std::set<fs::path> result;
    for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
        if (dirent.is_directory()) {
            continue;
        }

        boost::iostreams::mapped_file_source file{dirent.path()};
        std::span<const char> data{file.data(), file.size()};
        Utils::SpanReader reader{data};

        auto magic = *reader.Read<uint32_t>();

        bool isFat = kFATMagics.contains(magic);
        bool isMacho = kMachOMagics.contains(magic);
        if (!isFat && !isMacho) {
            continue;
        }

        try {
            if (isFat && !IsSupportedFat(data)) {
                continue;
            }
            if (isMacho && !IsSupportedMachO(data)) {
                continue;
            }
        } catch (const Utils::SpanReader::ReadError &e) {
            BDLogWarn("failed to verify file at path {}, error: {}", dirent.path().string(), e.what());
            continue;
        }

        auto [_, ok] = result.insert(dirent.path());
        BDVerify(ok);
    }
    return result;
}

std::set<fs::path> SymbolSourceFinder::FindAllKernelExtensions() {
    std::set<fs::path> result;
    for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
        if (dirent.is_directory() && dirent.path().extension() == "kext") {
            auto [_, ok] = result.insert(dirent.path());
            BDVerify(ok);
        }
    }
    return result;
}

```

`debuginfo/src/types.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <unordered_set>

#include <boost/functional/hash.hpp>
#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/DebugInfo/DWARF/DWARFUnit.h>

#include <binja/utils/log.h>

#include "debug.h"
#include "types.h"

namespace BN = BinaryNinja;
namespace DW = llvm::dwarf;
using namespace Binja;
using namespace DebugInfo;

using BN::Type;
using TypeRef = BN::Ref<Type>;
using BN::QualifiedName;

const DW::Tag DW_TAG_APPLE_ptrauth_type = (DW::Tag) 0x4300;// NOLINT(readability-identifier-naming)


/// Type builder

bool TypeBuilder::IsTypeTag(DW::Tag tag) {
    static const std::unordered_set<DW::Tag> kDwarfTypeTags{
        DW::DW_TAG_array_type,
        DW::DW_TAG_class_type,
        DW::DW_TAG_enumeration_type,
        DW::DW_TAG_pointer_type,
        DW::DW_TAG_reference_type,
        DW::DW_TAG_string_type,
        DW::DW_TAG_structure_type,
        DW::DW_TAG_subroutine_type,
        DW::DW_TAG_typedef,
        DW::DW_TAG_union_type,
        DW::DW_TAG_ptr_to_member_type,
        DW::DW_TAG_set_type,
        DW::DW_TAG_subrange_type,
        DW::DW_TAG_base_type,
        DW::DW_TAG_const_type,
        DW::DW_TAG_file_type,
        DW::DW_TAG_packed_type,
        DW::DW_TAG_thrown_type,
        DW::DW_TAG_volatile_type,
        DW::DW_TAG_restrict_type,
        DW::DW_TAG_interface_type,
        DW::DW_TAG_unspecified_type,
        DW::DW_TAG_shared_type,
        DW::DW_TAG_rvalue_reference_type,
        DW::DW_TAG_coarray_type,
        DW::DW_TAG_dynamic_type,
        DW::DW_TAG_atomic_type,
        DW::DW_TAG_immutable_type,
        DW_TAG_APPLE_ptrauth_type,
    };
    return kDwarfTypeTags.contains(tag);
}

/// Base type builder

BN::Ref<BinaryNinja::Type> BaseTypeBuilder::Build() {
    DebugVerify(die_.GetTag() == DW::DW_TAG_base_type, FatalError);

    std::optional<uint64_t> encoding = attributeReader_.ReadUInt(DW::DW_AT_encoding);
    VerifyDumpDie(encoding, die_);

    std::optional<uint64_t> size = attributeReader_.ReadUInt(DW::DW_AT_byte_size);
    VerifyDumpDie(size, die_);

    std::vector<std::string> qualifiedName = dieReader_.ReadQualifiedName();
    VerifyDumpDie(qualifiedName.size() == 1, die_);
    return MapBNType(*size, *encoding);
}

BinaryNinja::Ref<BinaryNinja::Type> BaseTypeBuilder::MapBNType(uint64_t size, uint64_t encoding) {
    switch (encoding) {
        case DW::DW_ATE_boolean:
            return Type::BoolType();
        case DW::DW_ATE_address:
            return Type::PointerType(size, Type::VoidType());
        case DW::DW_ATE_signed:
        case DW::DW_ATE_signed_char:
            return Type::IntegerType(size, true);
        case DW::DW_ATE_unsigned:
        case DW::DW_ATE_unsigned_char:
            return Type::IntegerType(size, false);
        case DW::DW_ATE_UTF: {
            switch (size) {
                case 1:
                    return Type::IntegerType(1, true);
                case 2:
                    return Type::WideCharType(2, "char16_t");
                default:
                    return Type::WideCharType(size);
            }
            case DW::DW_ATE_float:
            case DW::DW_ATE_decimal_float:
                return Type::FloatType(size);
            case DW::DW_ATE_ASCII:
            case DW::DW_ATE_UCS:
            case DW::DW_ATE_signed_fixed:
            case DW::DW_ATE_unsigned_fixed:
            case DW::DW_ATE_complex_float:
            case DW::DW_ATE_imaginary_float:
            case DW::DW_ATE_packed_decimal:
            case DW::DW_ATE_numeric_string:
            case DW::DW_ATE_edited:
                throw DwarfError{"base type encoding {} not supported for DIE {}",
                                 encoding, dieReader_.Dump()};
            default:
                throw DwarfError{"invalid base type encoding {} for DIE {}",
                                 encoding, dieReader_.Dump()};
        }
    }
}


/// Type modifier builder

BinaryNinja::Ref<BinaryNinja::Type> TypeModifierBuilder::Build() {
    auto tag = die_.GetTag();
    Verify(IsTypeModifierTag(tag), FatalError);

    auto base = attributeReader_.ReadReference(DW::DW_AT_type);

    BN::Ref<Type> baseType;
    if (base) {
        baseType = GenericTypeBuilder{ctx_, *base}.Build();
    } else {
        baseType = Type::VoidType();
    }

    BN::TypeBuilder builder{baseType};

    switch (tag) {
        case DW::DW_TAG_const_type:
            builder.SetConst(true);
            break;
        case DW::DW_TAG_volatile_type:
            builder.SetVolatile(true);
            break;
        case DW::DW_TAG_pointer_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType);
        case DW::DW_TAG_reference_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType,
                                     false, false, BNReferenceType::ReferenceReferenceType);
        case DW::DW_TAG_rvalue_reference_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType,
                                     false, false, BNReferenceType::ReferenceReferenceType);
        case DW::DW_TAG_packed_type:
            if (baseType->IsStructure()) {
                BN::StructureBuilder structureBuilder{baseType->GetStructure()};
                structureBuilder.SetPacked(true);
                return Type::StructureType(structureBuilder.Finalize());
            }
            BDLogWarn("attempt to apply packed modifier on non struct type {}, DIE: {}",
                      baseType->GetTypeName().GetString(), dieReader_.Dump());
            return baseType;
        case DW_TAG_APPLE_ptrauth_type:
            return baseType;
        case DW::DW_TAG_atomic_type:
        case DW::DW_TAG_immutable_type:
        case DW::DW_TAG_restrict_type:
        case DW::DW_TAG_shared_type:
            BDLogWarn("encountered unsupported type modifier tag {}", DW::TagString(tag));
            return baseType;
        default:
            BDLogWarn("encountered unknown type modifier tag {}", DW::TagString(tag));
            return baseType;
    }

    return builder.Finalize();
}


bool TypeModifierBuilder::IsTypeModifierTag(DW::Tag tag) {
    static const std::unordered_set<DW::Tag> kTypeModifierTags{
        DW::DW_TAG_const_type,
        DW::DW_TAG_volatile_type,
        DW::DW_TAG_pointer_type,
        DW::DW_TAG_reference_type,
        DW::DW_TAG_rvalue_reference_type,
        DW::DW_TAG_atomic_type,
        DW::DW_TAG_immutable_type,
        DW::DW_TAG_packed_type,
        DW::DW_TAG_restrict_type,
        DW::DW_TAG_shared_type,
        DW_TAG_APPLE_ptrauth_type,
    };
    return kTypeModifierTags.contains(tag);
}


/// Typedef builder

BinaryNinja::Ref<BinaryNinja::Type> TypedefBuilder::Build() {
    auto base = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!base) {
        BDLogWarn("typedef without DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    auto name = attributeReader_.ReadName();
    if (name.empty()) {
        BDLogWarn("typedef without DW_AT_name attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    BN::Ref<Type> baseType = GenericTypeBuilder{ctx_, *base}.Build();
    return baseType;
}

std::optional<DwarfDieWrapper> TypedefBuilder::Resolve(DwarfDieWrapper &die) {
    auto type = AttributeReader{die}.ReadReference(DW::DW_AT_type);
    while (type) {
        if (type->GetTag() != DW::DW_TAG_typedef) {
            return *type;
        }
        type = AttributeReader{*type}.ReadReference(DW::DW_AT_type);
    }
    return std::nullopt;
}


/// Array type builder

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::Build() {
    auto name = attributeReader_.ReadName();
    if (!name.empty()) {
        BDLogWarn("ignoring array with DW_AT_name not implemented, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    auto elementType = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!elementType) {
        BDLogWarn("ignoring array with no DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    if (attributeReader_.HasAttribute(DW::DW_AT_rank)) {
        return BuildDynamic();
    }

    return BuildStatic();
}

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::BuildDynamic() {
    auto rank = attributeReader_.ReadUInt(DW::DW_AT_rank);
    if (!rank) {
        BDLogWarn("ignoring array having DW_AT_rank value as DWARF expression, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    if (*rank == 0) {
        BDLogWarn("ignoring array having DW_AT_rank value 0, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    auto elementType = *attributeReader_.ReadReference(DW::DW_AT_type);

    BN::Ref<Type> result = GenericTypeBuilder{ctx_, elementType}.Build();
    for (int i = 0; i < *rank; ++i) {
        result = Type::PointerType(dieReader_.ReadAddressSize(), result);
    }

    return result;
}

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::BuildStatic() {
    std::vector<size_t> dimensions;
    for (auto &child: die_.Children()) {
        if (auto dim = DecodeCountFromSubrange(const_cast<DwarfDieWrapper &>(child))) {
            dimensions.push_back(*dim);
        } else {
            dimensions.push_back(0);
        }
    }

    auto elementType = *attributeReader_.ReadReference(DW::DW_AT_type);
    BN::Ref<Type> result = GenericTypeBuilder{ctx_, elementType}.Build();

    for (auto it = dimensions.rbegin(), end = dimensions.rend(); it != end; ++it) {
        if (*it != 0) {
            result = Type::ArrayType(result, *it);
        } else {
            result = Type::PointerType(dieReader_.ReadAddressSize(), result);
        }
    }

    return result;
}


std::optional<size_t> ArrayTypeBuilder::DecodeCountFromSubrange(DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    if (auto count = attributeReader.ReadUInt(DW::DW_AT_count)) {
        return count;
    }

    if (auto ub = attributeReader.ReadUInt(DW::DW_AT_upper_bound)) {
        size_t lb;
        if (auto value = attributeReader.ReadUInt(DW::DW_AT_lower_bound)) {
            lb = *value;
        } else {
            lb = GetDefaultLowerBound();
        }
        if (*ub <= lb) {
            BDLogWarn("ignoring array index with ub <= lb, die: {}", dieReader_.Dump());
            return std::nullopt;
        }
        return *ub - lb;
    }

    return std::nullopt;
}

size_t ArrayTypeBuilder::GetDefaultLowerBound() {
    // TODO: language dependent???
    return 0;
}


/// Function type builder

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::Build() {
    auto returnType = DecodeReturnType();
    auto parameters = DecodeParameters();
    return Type::FunctionType(returnType, DecodeCallingConvention(),
                              parameters.parameters, parameters.hasVarArg);
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::DecodeReturnType() {
    auto returnType = attributeReader_.ReadReference(DW::DW_AT_type, true);
    if (!returnType) {
        return Type::VoidType();
    }
    return GenericTypeBuilder{ctx_, *returnType}.Build();
}

BinaryNinja::Ref<BinaryNinja::CallingConvention> FunctionTypeBuilder::DecodeCallingConvention() {
    // TODO??
    return nullptr;
}

FunctionTypeBuilder::DecodeParametersResult FunctionTypeBuilder::DecodeParameters() {
    DecodeParametersResult result{.hasVarArg = false};
    for (auto &entry: die_.Children()) {
        auto tag = entry.GetTag();
        auto &child = const_cast<DwarfDieWrapper &>(entry);
        AttributeReader attributeReader{child};
        switch (tag) {
            case DW::DW_TAG_formal_parameter: {
                if (result.hasVarArg) {
                    BDLogWarn("encountered function with formal parameter "
                              "after vararg, DIE: {}",
                              dieReader_.Dump());
                }

                BN::FunctionParameter functionParameter;
                functionParameter.type = ApplyParameterTypeModifiers(DecodeParameterType(child), child);
                functionParameter.name = attributeReader.ReadName("", true);
                functionParameter.defaultLocation = true;
                result.parameters.push_back(std::move(functionParameter));
                break;
            }
            case DW::DW_TAG_unspecified_parameters: {
                result.hasVarArg = true;
                break;
            }
            default: {
                break;
            }
        }
    }
    return result;
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::DecodeParameterType(DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    auto type = attributeReader.ReadReference(DW::DW_AT_type, true);
    if (!type) {
        BDLogWarn("encountered function formal parameter with no DW_AT_type "
                  "attribute, DIE: {}",
                  DieReader{die}.Dump());
        return Type::VoidType();
    }
    return GenericTypeBuilder{ctx_, *type}.Build();
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::ApplyParameterTypeModifiers(
    BinaryNinja::Ref<BinaryNinja::Type> type, DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    DieReader dieReader{die};
    bool isReferenceType = attributeReader.HasAttribute(DW::DW_AT_reference, true);
    bool isRValueReferenceType = attributeReader.HasAttribute(DW::DW_AT_rvalue_reference, true);
    if (isRValueReferenceType && isReferenceType) {
        BDLogWarn("function parameter have both DW_AT_reference and DW_AT_rvalue_reference "
                  "tags, DIE: {}",
                  DieReader{die}.Dump());
        return type;
    }
    if (isRValueReferenceType) {
        return Type::PointerType(dieReader.ReadAddressSize(), type, false, false,
                                 BNReferenceType::RValueReferenceType);
    }
    if (isReferenceType) {
        return Type::PointerType(dieReader.ReadAddressSize(), type, false, false,
                                 BNReferenceType::ReferenceReferenceType);
    }
    return type;
}


/// Enum type builder

BinaryNinja::Ref<BinaryNinja::Type> EnumTypeBuilder::Build() {
    auto type = ResolveBaseType();
    if (!type) {
        BDLogWarn("ignoring enum with no / invalid DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    if (type->GetTag() != DW::DW_TAG_base_type) {
        BDLogWarn("ignoring enum having base type with tag != DW_TAG_base_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    BN::Ref<Type> baseType = GenericTypeBuilder{ctx_, *type}.Build();
    auto size = attributeReader_.ReadUInt(DW::DW_AT_byte_size);
    if (!size) {
        size = baseType->GetWidth();
    }

    auto isClass = attributeReader_.HasAttribute(DW::DW_AT_enum_class);
    if (isClass) {
        BDLogDebug("encountered class enum {}", dieReader_.Dump());
    }

    BN::EnumerationBuilder builder{};
    for (auto &child: die_.Children()) {
        auto tag = child.GetTag();
        if (tag == DW::DW_TAG_enumerator) {
            auto &enumerator = const_cast<DwarfDieWrapper &>(child);
            AttributeReader attributeReader{enumerator};
            std::string name = attributeReader.ReadName();
            if (name.empty()) {
                BDLogWarn("ignoring enum entry with no name, DIE: {}", DieReader{enumerator}.Dump());
                continue;
            }
            if (baseType->IsSigned()) {
                auto value = attributeReader.ReadInt(DW::DW_AT_const_value);
                if (!value) {
                    BDLogWarn("ignoring enum entry with no value, DIE: {}", DieReader{enumerator}.Dump());
                    continue;
                }
                builder.AddMemberWithValue(name, *value);
            } else {
                auto value = attributeReader.ReadUInt(DW::DW_AT_const_value);
                if (!value) {
                    BDLogWarn("ignoring enum entry with no value, DIE: {}", DieReader{enumerator}.Dump());
                    continue;
                }
                builder.AddMemberWithValue(name, *value);
            }
        } else {
            BDLogWarn("ignoring unexpected tag {} inside enum, DIE: {}",
                      DW::TagString(tag), dieReader_.Dump());
        }
    }

    return Type::EnumerationType(builder.Finalize(), *size, baseType->IsSigned());
}

std::optional<DwarfDieWrapper> EnumTypeBuilder::ResolveBaseType() {
    auto type = attributeReader_.ReadReference(DW::DW_AT_type);
    while (type) {
        if (type->GetTag() == DW::DW_TAG_base_type) {
            return *type;
        }
        type = AttributeReader{*type}.ReadReference(DW::DW_AT_type);
    }
    return std::nullopt;
}


/// Composite type builder

BinaryNinja::Ref<BinaryNinja::Type> CompositeTypeBuilder::Build() {
    BN::StructureBuilder builder{};
    builder.SetStructureType(DecodeVariant());
    builder.SetPacked(IsPacked());
    builder.SetAlignment(DecodeAlignment());
    builder.SetWidth(DecodeWidth());

    for (auto &child: die_.Children()) {
        switch (child.GetTag()) {
            case DW::DW_TAG_inheritance:
            case DW::DW_TAG_member:
                if (auto result = DecodeMember(const_cast<DwarfDieWrapper &>(child))) {
                    builder.AddMemberAtOffset(result->type, result->name,
                                              result->offset, false, result->access);
                }
                break;
            case DW::DW_TAG_variable:
                if (auto result = DecodeVariable(const_cast<DwarfDieWrapper &>(child))) {
                    builder.AddMember(result->type, result->name, result->access,
                                      BNMemberScope::StaticScope);
                }
                break;
            case DW::DW_TAG_subprogram:
                // TODO: should we add entry in container???
                break;
            case DW::DW_TAG_template_value_parameter:
            case DW::DW_TAG_template_type_parameter:
                break;
            case DW::DW_TAG_structure_type:
            case DW::DW_TAG_union_type:
            case DW::DW_TAG_class_type:
            case DW::DW_TAG_enumeration_type:
            case DW::DW_TAG_typedef:
                // Already handled in member access / index DB iteration
                break;
            default: {
                BDLogInfo("Ignoring unexpected tag {} of DIE {}", DW::TagString(child.GetTag()),
                          DieReader{const_cast<DwarfDieWrapper &>(child)}.Dump());
                break;
            }
        }
    }

    ProcessBitfields(builder);
    return Type::StructureType(builder.Finalize());
}

bool CompositeTypeBuilder::IsCompositeTypeTag(DW::Tag tag) {
    switch (tag) {
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
        case DW::DW_TAG_class_type:
            return true;
        default:
            return false;
    }
}

BNStructureVariant CompositeTypeBuilder::DecodeVariant() {
    switch (die_.GetTag()) {
        case DW::DW_TAG_structure_type:
            return BNStructureVariant::StructStructureType;
        case DW::DW_TAG_union_type:
            return BNStructureVariant::UnionStructureType;
        case DW::DW_TAG_class_type:
            return BNStructureVariant::ClassStructureType;
        default:
            VerifyNotReachable();
    }
}

bool CompositeTypeBuilder::IsPacked() {
    return false;
}

uint8_t CompositeTypeBuilder::DecodeAlignment() {
    return 1;
}

size_t CompositeTypeBuilder::DecodeWidth() {
    if (auto size = attributeReader_.ReadUInt(DW::DW_AT_byte_size)) {
        return *size;
    }
    auto isDeclaration = attributeReader_.HasAttribute(DW::DW_AT_declaration);
    if (!isDeclaration) {
        BDLogWarn("Container does not have DW_AT_byte_size attribute, DIE: {}", dieReader_.Dump());
    }
    return 0;
}

BNMemberAccess CompositeTypeBuilder::GetDefaultMemberAccess() {
    switch (die_.GetTag()) {
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
            return BNMemberAccess::PublicAccess;
        case DW::DW_TAG_class_type:
            return BNMemberAccess::PrivateAccess;
        default:
            VerifyNotReachable();
    }
}

std::optional<CompositeTypeBuilder::DecodeMemberResult> CompositeTypeBuilder::DecodeMember(DwarfDieWrapper &die) {
    DieReader dieReader{die};
    const auto &attributeReader = dieReader.AttrReader();

    if (attributeReader.HasAttribute(DW::DW_AT_data_bit_offset)) {
        return std::nullopt;
    }

    auto type = attributeReader.ReadReference(DW::DW_AT_type);
    if (!type) {
        BDLogInfo("Skipping member DIE without DW_AT_type attribute, "
                  "DIE: {}",
                  dieReader.Dump());
        return std::nullopt;
    }

    auto isExternal = attributeReader.HasAttribute(DW::DW_AT_external);
    if (isExternal) {
        // TODO: static members
        return std::nullopt;
    }

    auto offset = attributeReader.ReadUInt(DW::DW_AT_data_member_location);
    if (!offset) {
        BDLogWarn("composite type member without DW_AT_data_member_location, DIE: {}",
                  DieReader{die}.Dump());
        return std::nullopt;
    }

    std::string name = attributeReader.ReadName("", true);
    bool isAnonymous = name.empty();
    bool isInheritance = die.GetTag() == DW::DW_TAG_inheritance;

    AttributeReader typeAttributeReader{*type};

    if ((isAnonymous && !isInheritance) && !typeAttributeReader.HasAttribute(DW::DW_AT_export_symbols) && !typeAttributeReader.ReadName("").empty()) {
        BDLogDebug("Anonymous member of container does not have DW_AT_export_symbols "
                   "attribute and member type has name, DIE: {}",
                   dieReader.Dump());
    }

    DecodeMemberResult result;
    result.access = DecodeMemberAccess(attributeReader.ReadUInt(DW::DW_AT_accessibility));
    result.name = std::move(name);
    result.offset = *offset;
    result.type = GenericTypeBuilder{ctx_, *type}.Build();

    return result;
}

std::optional<CompositeTypeBuilder::DecodeVariableResult> CompositeTypeBuilder::DecodeVariable(DwarfDieWrapper &die) {
    DieReader dieReader{die};
    const auto &attributeReader = dieReader.AttrReader();

    auto type = attributeReader.ReadReference(DW::DW_AT_type);
    VerifyDebugDumpDie(type, die);

    std::string name = attributeReader.ReadName("", true);
    VerifyDebugDumpDie(!name.empty(), die);

    DecodeVariableResult result;
    result.access = DecodeMemberAccess(attributeReader.ReadUInt(DW::DW_AT_accessibility));
    result.name = std::move(name);
    result.type = GenericTypeBuilder{ctx_, *type}.Build();
    return result;
}


BNMemberAccess CompositeTypeBuilder::DecodeMemberAccess(std::optional<uint64_t> accessibility) {
    if (!accessibility) {
        return GetDefaultMemberAccess();
    }
    switch (*accessibility) {
        case DW::DW_ACCESS_private:
            return BNMemberAccess::PrivateAccess;
        case DW::DW_ACCESS_protected:
            return BNMemberAccess::ProtectedAccess;
        case DW::DW_ACCESS_public:
            return BNMemberAccess::PublicAccess;
    }
    BDLogWarn("encountered struct having member invalid DW_AT_accessibility "
              "value, DIE: {}",
              dieReader_.Dump());
    return NoAccess;
}


void CompositeTypeBuilder::ProcessBitfields(BN::StructureBuilder &builder) {
    auto child = die_.GetFirstChild();
    while (child.IsValid()) {
        if (child.GetTag() == DW::DW_TAG_member) {
            AttributeReader attributeReader{child};
            if (attributeReader.HasAttribute(DW::DW_AT_bit_size)) {
                if (auto next = ProcessBitfield(builder, child)) {
                    child = *next;
                } else {
                    BDLogWarn("failed processing of bitfields in DIE {}", dieReader_.Dump());
                    return;
                }
                continue;
            }
        }
        child = child.GetSibling();
    }
}


std::optional<DwarfDieWrapper> CompositeTypeBuilder::ProcessBitfield(
    BinaryNinja::StructureBuilder &builder, DwarfDieWrapper &start) {
    const int kMaxBitSize = 64;

    int startBit = 0;
    if (auto bit = AttributeReader{start}.ReadUInt(DW::DW_AT_bit_offset)) {
        startBit = *bit;
    }

    if (startBit % 8 != 0) {
        BDLogWarn("unexpected alignment of start bit in DIE offset: {}", start.GetOffset());
        return std::nullopt;
    }

    int bitsUsed = 0;
    DwarfDieWrapper end = start.GetSibling();
    for (int previousMaxBit = startBit; end.IsValid();) {
        if (end.GetTag() != DW::DW_TAG_member) {
            break;
        }

        AttributeReader attributeReader{end};
        auto bitSize = attributeReader.ReadUInt(DW::DW_AT_bit_size);
        if (!bitSize) {
            break;
        }

        auto bitOffset = attributeReader.ReadUInt(DW::DW_AT_data_bit_offset);
        if (!bitOffset) {
            bitOffset = 0;
        }

        int maxBit = *bitOffset + *bitSize;
        if (maxBit < previousMaxBit) {
            BDLogWarn("unexpected order of bitfields in DIE offset: {}", end.GetOffset());
            return std::nullopt;
        }

        if (maxBit - startBit > kMaxBitSize) {
            break;
        }

        bitsUsed = maxBit - startBit;
        end = end.GetSibling();
    }

    BN::EnumerationBuilder enumerationBuilder{};
    int enumSize = bitsUsed <= 8 ? 1 : bitsUsed <= 16 ? 2
                                   : bitsUsed <= 32   ? 4
                                                      : 8;

    for (DwarfDieWrapper die = start; die != end; die = die.GetSibling()) {
        AttributeReader bitfieldAttributeReader{die};

        auto bitSize = *bitfieldAttributeReader.ReadUInt(DW::DW_AT_bit_size);
        auto bitOffset = bitfieldAttributeReader.ReadUInt(DW::DW_AT_data_bit_offset);
        bitOffset = bitOffset ? bitOffset : 0;

        auto name = bitfieldAttributeReader.ReadName();
        if (name.empty()) {
            name = fmt::format("__bitfield_noname_{}", *bitOffset);
        }

        enumerationBuilder.AddMemberWithValue(fmt::format("{}_bit_offset", name), *bitOffset);
        enumerationBuilder.AddMemberWithValue(fmt::format("{}_bit_size", name), bitSize);
    }

    BN::Ref<Type> enumeration = Type::EnumerationType(enumerationBuilder.Finalize(), enumSize, false);
    builder.AddMemberAtOffset(enumeration, "", bitsUsed / 8);
    return end;
}

/// Pointer to member type builder

BinaryNinja::Ref<BinaryNinja::Type> PointerToMemberTypeBuilder::Build() {
    auto memberType = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!memberType) {
        BDLogWarn("encountered pointer to member type with no DW_AT_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    auto containerType = attributeReader_.ReadReference(DW::DW_AT_containing_type);
    if (!containerType) {
        BDLogWarn("encountered pointer to member type with no DW_AT_containing_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    BN::StructureBuilder builder;
    auto memberTypeRef = GenericTypeBuilder{ctx_, *memberType}.Build();
    if (!memberTypeRef) {
        return nullptr;
    }

    builder.AddMemberAtOffset(Type::PointerType(dieReader_.ReadAddressSize(), memberTypeRef), "ptr", 0);
    return Type::StructureType(builder.Finalize());
}


/// Generic type builder

BinaryNinja::Ref<BinaryNinja::Type> GenericTypeBuilder::Build() {
    auto tag = resolvedDie_.GetTag();
    VerifyDumpDie(IsTypeTag(tag), resolvedDie_);

    if (tag == DW::DW_TAG_base_type) {
        return BaseTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (TypeModifierBuilder::IsTypeModifierTag(tag)) {
        return TypeModifierBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_unspecified_type) {
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    if (!ctx_.TagDieAsProcessing(resolvedDie_)) {
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    bool isAnonymous = resolvedDieReader_.AttrReader().ReadName("", true).empty();
    if (!isAnonymous && !decodeNamedTypes_) {
        ctx_.UntagDieAsProcessing(resolvedDie_);
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    auto type = DoBuild();
    if (!type) {
        BinaryNinja::NamedTypeReference ref{
            BNNamedTypeReferenceClass::TypedefNamedTypeClass,
            "", QualifiedName{"__dwarf_bad_type"}};
        type = Type::NamedType(&ref);
    }

    ctx_.UntagDieAsProcessing(resolvedDie_);
    return type;
}

BinaryNinja::Ref<BinaryNinja::Type> GenericTypeBuilder::DoBuild() {
    auto tag = resolvedDie_.GetTag();
    VerifyDumpDie(IsTypeTag(tag), resolvedDie_);

    if (tag == DW::DW_TAG_typedef) {
        return TypedefBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_array_type) {
        return ArrayTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_enumeration_type) {
        return EnumTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_subroutine_type) {
        return FunctionTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (CompositeTypeBuilder::IsCompositeTypeTag(tag)) {
        return CompositeTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_ptr_to_member_type) {
        return PointerToMemberTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    BDLogWarn("encountered type die with unknown tag, DIE: {}", resolvedDieReader_.Dump());
    return nullptr;
}


/// Abstract type builder context

bool TypeBuilderContext::TagDieAsProcessing(DwarfDieWrapper &die) {
    auto [_, inserted] = workingSet_.insert(die.GetOffset());
    return inserted;
}

void TypeBuilderContext::UntagDieAsProcessing(DwarfDieWrapper &die) {
    bool ok = workingSet_.erase(die.GetOffset());
    Verify(ok, FatalError);
}

std::optional<uint64_t> TypeBuilderContext::SlideAddress(DwarfOffset offset, uint64_t address) {
    return dwarfContext_.GetSlidAddress(offset, address);
}


/// Named type reference builder

BinaryNinja::Ref<BinaryNinja::Type> NamedTypeReferenceBuilder::Build() {
    BN::QualifiedName qualifiedName{ctx_.DecodeQualifiedName(die_)};
    BN::NamedTypeReference reference{DecodeTypeClass(), "", qualifiedName};
    auto size = TypeSizeDecoder{die_}.Decode();
    return Type::NamedType(&reference, size ? *size : 0);
}

BNNamedTypeReferenceClass NamedTypeReferenceBuilder::DecodeTypeClass() {
    auto tag = die_.GetTag();
    switch (tag) {
        case DW::DW_TAG_typedef:
            return BNNamedTypeReferenceClass::TypedefNamedTypeClass;
        case DW::DW_TAG_enumeration_type:
            return BNNamedTypeReferenceClass::EnumNamedTypeClass;
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_class_type:
            return BNNamedTypeReferenceClass::StructNamedTypeClass;
        case DW::DW_TAG_union_type:
            return BNNamedTypeReferenceClass::UnionNamedTypeClass;
        default:
            BDLogWarn("encountered die with unexpected tag, DIE: {}", dieReader_.Dump());
            return BNNamedTypeReferenceClass::UnknownNamedTypeClass;
    }
}

/// Type size decoder

std::optional<DwarfDieWrapper> TypeSizeDecoder::ResolveType(DwarfDieWrapper &die) {
    if (!die.IsValid()) {
        return std::nullopt;
    }

    switch (die.GetTag()) {
        case DW::DW_TAG_enumeration_type:
        case DW::DW_TAG_typedef:
        case DW::DW_TAG_const_type:
        case DW::DW_TAG_volatile_type:
        case DW::DW_TAG_atomic_type:
        case DW::DW_TAG_immutable_type:
        case DW::DW_TAG_packed_type:// TODO: verify all
        case DW::DW_TAG_restrict_type:
        case DW::DW_TAG_shared_type:
        case DW_TAG_APPLE_ptrauth_type: {
            auto base = AttributeReader{die}.ReadReference(DW::DW_AT_type);
            if (!base) {
                return die;
            }
            return ResolveType(*base);
        }
        default:
            return die;
    }
}

std::optional<uint64_t> TypeSizeDecoder::Decode() {
    auto die = ResolveType(die_);
    if (!die) {
        return std::nullopt;
    }

    switch (die->GetTag()) {
        case DW::DW_TAG_subroutine_type:
        case DW::DW_TAG_pointer_type:
        case DW::DW_TAG_reference_type:
        case DW::DW_TAG_rvalue_reference_type:
            return die->GetDwarfUnit().GetAddressByteSize();
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
        case DW::DW_TAG_class_type:
        case DW::DW_TAG_base_type:
            return AttributeReader{*die}.ReadUInt(DW::DW_AT_byte_size, true);
        case DW::DW_TAG_array_type:

        default:
            return std::nullopt;
    }
}

```

`debuginfo/src/variable.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>

#include <binja/utils/log.h>

#include "variable.h"

using namespace Binja;
using namespace DebugInfo;

namespace DW = llvm::dwarf;
namespace BN = BinaryNinja;

std::optional<DwarfVariableInfo> VariableDecoder::Decode() {
    auto &attributeReader = dieReader_.AttrReader();
    DwarfVariableInfo info;

    if (auto location = attributeReader.ReadLocationAddress()) {
        info.location = *location;
    } else {
        return std::nullopt;
    }

    if (auto slidLocation = ctx_.SlideAddress(die_.GetOffset(), info.location)) {
        info.location = *slidLocation;
    } else {
        BDLogDebug("cannot slide data symbol address {}", info.location);
        return std::nullopt;
    }

    std::string name = attributeReader.ReadName("", true);
    if (name.empty()) {
        BDLogDebug("ignoring variable with no name, DIE: {}", dieReader_.Dump());
        return std::nullopt;
    }
    info.qualifiedName = ctx_.DecodeQualifiedName(die_);

    auto valueType = attributeReader.ReadReference(DW::DW_AT_type);
    if (valueType) {
        info.type = GenericTypeBuilder{ctx_, *valueType}.Build();
    } else {
        BDLogWarn("encountered variable with no type, DIE: {}", dieReader_.Dump());
        info.type = BN::Type::VoidType();
    }
    return info;
}
```

`debuginfo/test/CMakeLists.txt`:

```txt
add_executable(dwarf_debuginfo_test main.cpp)

target_link_libraries(dwarf_debuginfo_test PRIVATE dwarf_debuginfo kcview)
```

`debuginfo/test/main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <iostream>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <binja/debuginfo/plugin_dsym.h>
#include <binja/debuginfo/plugin_macho.h>
#include <binja/kcview/lib.h>
#include <binja/utils/binary_view.h>

using namespace Binja;
using BinaryNinja::BinaryView;
using BinaryNinja::BinaryViewType;
using BinaryNinja::Ref;
namespace BN = BinaryNinja;

int main(int argc, const char **argv) {
    if (argc != 2) {
        std::cerr << "Invalid arguments\n";
        return 1;
    }
    std::string binaryPath = argv[1];

    BN::SetBundledPluginDirectory(BNGetBundledPluginDirectory());
    BN::InitPlugins(true);
    DebugInfo::PluginDSYM::RegisterPlugin();
    DebugInfo::PluginMacho::RegisterPlugin();
    KCView::CorePluginInit();

    BNLogToStdout(BNLogLevel::InfoLog);

    Ref<BinaryView> bv = Utils::OpenBinaryView(binaryPath, false, nullptr, nullptr);
    bv->UpdateAnalysisAndWait();
    return 0;
}
```

`external/CMakeLists.txt`:

```txt
add_subdirectory(fmtlib)
add_subdirectory(boost)

add_subdirectory(llvm-project/llvm)
set(EXTERNAL_LLVM_INCLUDE_DIRECTORIES
        ${CMAKE_CURRENT_SOURCE_DIR}/llvm-project/llvm/include
        ${PROJECT_BINARY_DIR}/external/llvm-project/llvm/include)
set_property(GLOBAL PROPERTY EXTERNAL_LLVM_INCLUDE_DIRECTORIES "${EXTERNAL_LLVM_INCLUDE_DIRECTORIES}")

add_subdirectory(range-v3)
add_subdirectory(taskflow)


```

`kcview/CMakeLists.txt`:

```txt
set(LIBRARY_NAME kcview)

set(KERNCACHE_HEADERS
        include/binja/kcview/errors.h
        include/binja/kcview/lib.h
        include/binja/kcview/range.h)

set(KERNCACHE_SOURCES
        src/lib.cpp)

add_library(${LIBRARY_NAME} STATIC ${KERNCACHE_SOURCES} ${KERNCACHE_HEADERS})
target_include_directories(${LIBRARY_NAME} PUBLIC include)
target_include_directories(${LIBRARY_NAME} PRIVATE include/binja/kcview)
target_link_libraries(${LIBRARY_NAME} PUBLIC binja_kc_common)
target_link_libraries(${LIBRARY_NAME} PUBLIC Boost::icl Taskflow fmt::fmt binaryninjaapi)

add_subdirectory(test)
```

`kcview/include/binja/kcview/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

#include <binja/types/errors.h>

namespace Binja::KCView {

class MachoDecodeError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

}// namespace Binja::KCView

```

`kcview/include/binja/kcview/lib.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

namespace Binja::KCView {

void CorePluginInit();

}// namespace Binja::KCView
```

`kcview/include/binja/kcview/range.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

#include <binja/utils/debug.h>
#include <boost/icl/interval_map.hpp>

namespace Binja::KCView {

template<class K, class V>
class RangeMap {
public:
    void Insert(boost::icl::discrete_interval<K> key, V value) {
        auto it = index_.find(key);
        BDVerify(it == index_.end());
        auto idx = values_.size();
        values_.push_back(value);
        index_.set({key, idx});
    }

    const V *Query(K key) {
        return QueryInternal(key);
    }

    const V *Query(boost::icl::discrete_interval<K> key) {
        return QueryInternal(key);
    }

    K FindNextValid(K key) {
        BDVerify(Query(key) == nullptr);
        for (auto it = index_.begin(), end = index_.end(); it != end; ++it) {
            if (it->first.lower() > key) {
                return it->first.lower();
            }
        }
        return 0;
    }

    const std::vector<V> &Values() {
        return values_;
    }

private:
    template<class T>
    const V *QueryInternal(T key) {
        auto it = index_.find(key);
        if (it == index_.end()) {
            return nullptr;
        }
        return &values_[it->second];
    }

    boost::icl::interval_map<K, size_t> index_;
    std::vector<V> values_;
};

}// namespace Binja::KCView
```

`kcview/src/lib.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#include <iostream>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <boost/icl/interval_map.hpp>
#include <fmt/format.h>
#include <llvm/Object/MachO.h>
#include <taskflow/taskflow.hpp>

#include <binja/macho/macho.h>
#include <binja/utils/binary_view.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "errors.h"
#include "lib.h"
#include "range.h"

using namespace Binja;
using namespace llvm::MachO;

using Binja::Utils::BinaryViewDataReader;
using KCView::MachoDecodeError;
using KCView::RangeMap;
using MachO::Fileset;
using MachO::MachHeaderParser;
using MachO::Section;
using MachO::Segment;

using BinaryNinja::Architecture;
using BinaryNinja::BinaryView;
using BinaryNinja::BinaryViewType;
using BinaryNinja::FileAccessor;
using BinaryNinja::NamedTypeReference;
using BinaryNinja::Platform;
using BinaryNinja::QualifiedName;
using BinaryNinja::Ref;
using BinaryNinja::Settings;
using BinaryNinja::Symbol;
using BinaryNinja::Type;

using boost::icl::interval;
using boost::icl::interval_map;

namespace {

constexpr auto *kBinaryType = "MachO-KC";
constexpr auto *kStripPACSchema = R"(
{
    "loader": {
        "group": "loader",
        "source": "core",
        "title": "Load Options",
        "settings": {
            "stripPAC": {
                "default": true,
                "group": "loader",
                "key": "loader.stripPAC",
                "name": "stripPAC",
                "readOnly": false,
                "title": "Strip PAC",
                "description": "Strip PAC signed pointers",
                "type": "boolean"
            },
            "ignoredFilesets": {
                "default": "[com.apple.driver.FairPlayIOKit]",
                "group": "loader",
                "key": "loader.ignoredFilesets",
                "name": "ignoredFilesets",
                "readOnly": false,
                "title": "Ignored Filesets",
                "description": "Filesets to ignore",
                "type": "string"
            }
        }
    }
}
)";

class CustomBinaryView : public BinaryView {
public:
    explicit CustomBinaryView(BinaryView *parent)
        : BinaryView{kBinaryType, parent->GetFile(), parent} {
        base_ = GetParentView();
        ignoredFilesets_ = {"com.apple.driver.FairPlayIOKit"};// TODO: dynamic
    }

    bool Init() override {
        ProcessKC();
        return true;
    }

    void Parse() {}

    size_t PerformRead(void *dest, uint64_t offset, size_t len) override {
        const auto *segment = va2RawMap_.Query(offset);
        if (!segment) {
            return 0;
        }
        return base_->Read(dest, offset - segment->vaStart + segment->dataStart, len);
    }

    size_t PerformWrite(uint64_t offset, const void *data, size_t len) override {
        BDLogError("PerformWrite not supported");
        return 0;
    }

    size_t PerformInsert(uint64_t offset, const void *data, size_t len) override {
        BDLogError("PerformInsert not supported");
        return 0;
    }

    size_t PerformRemove(uint64_t offset, uint64_t len) override {
        BDLogError("PerformRemove not supported");
        return 0;
    }

    BNModificationStatus PerformGetModification(uint64_t offset) override {
        return BNModificationStatus::Original;
    }

    bool PerformIsValidOffset(uint64_t offset) override {
        return va2RawMap_.Query(offset) != nullptr;
    }

    bool PerformIsOffsetReadable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentReadable;
        } else {
            return false;
        }
    }

    bool PerformIsOffsetWritable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentWritable;
        } else {
            return false;
        }
    }

    bool PerformIsOffsetExecutable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentExecutable;
        } else {
            return false;
        }
    }

    bool PerformIsOffsetBackedByFile(uint64_t offset) override {
        return va2RawMap_.Query(offset + vaStart_) != nullptr;
    }

    uint64_t PerformGetNextValidOffset(uint64_t offset) override {
        return va2RawMap_.FindNextValid(offset);
    }

    uint64_t PerformGetStart() const override {
        return vaStart_;
    }

    uint64_t PerformGetLength() const override {
        return vaLength_;
    }

    uint64_t PerformGetEntryPoint() const override {
        return entryPoint_;
    }

    bool PerformSave(FileAccessor *file) override {
        return base_->Save(file);
    }

    bool PerformIsExecutable() const override { return true; }
    BNEndianness PerformGetDefaultEndianness() const override { return BNEndianness::LittleEndian; }
    bool PerformIsRelocatable() const override { return false; }
    size_t PerformGetAddressSize() const override { return 8; }

private:
    void ProcessKC() {
        VerifyKC();
        FindVAStart();
        ProcessBaseSegments();
        auto filesets = DecodeFilesets();
        for (const auto &fileset: filesets) {
            ProcessFileset(fileset);
        }
        FindVALength();
        FindEntryPoint();

        Ref<Settings> settings = base_->GetLoadSettings(kBinaryType);
        if (!settings || settings->Get<bool>("loader.stripPAC")) {
            StripPAC();
        }
        DefineKallocTypeSymbols();
    }

    void VerifyKC() {
        BinaryViewDataReader reader{base_, 0};
        auto header = reader.Read<mach_header_64>();
        BDVerify(header.magic == MH_MAGIC_64 || header.magic == MH_CIGAM_64);
        BDVerify(header.cputype == CPU_TYPE_ARM64);
        BDVerify(header.cpusubtype == CPU_SUBTYPE_ARM64E);
        SetDefaultArchitecture(Architecture::GetByName("aarch64"));
        SetDefaultPlatform(Platform::GetByName("mac-aarch64"));
    }

    void FindVAStart() {
        auto segments = DecodeSegments(0);
        for (const auto &segment: segments) {
            if (segment.vaStart > 0) {
                vaStart_ = segment.vaStart;
                return;
            }
        }
        throw MachoDecodeError{"Image does not have segment with non zero VA"};
    }

    void FindVALength() {
        uint64_t maxVA = vaStart_;
        for (const auto &segment: va2RawMap_.Values()) {
            maxVA = std::max(segment.vaStart + segment.vaLength, maxVA);
        }
        vaLength_ = maxVA - vaStart_;
    }

    void FindEntryPoint() {
        if (auto entry = MachHeaderParser{*base_, 0}.DecodeEntryPoint()) {
            entryPoint_ = *entry;
        } else {
            throw MachoDecodeError{"binary does not have LC_UNIXTHREAD command"};
        }
    }

    bool ShouldSkipSegment(const Fileset &fileset, const Segment &segment) {
        if (ignoredFilesets_.contains(fileset.name)) {
            return true;
        }
        if (segment.name == "__LINKEDIT" || segment.name == "__LINKINFO") {
            return true;
        }
        if (segment.vaLength == 0) {
            return true;
        }
        return false;
    }

    void ProcessBaseSegments() {
        MachHeaderParser parser{*base_, 0};
        std::set<std::string> shouldMap{"__TEXT", "__LINKEDIT"};
        for (const auto &segment: parser.DecodeSegments()) {
            if (!shouldMap.contains(segment.name)) {
                BDLogDebug("skipping base segment {}", segment.name);
                continue;
            }
            if (segment.vaLength == 0) {
                BDLogWarn("base segment {} has no VA", segment.name);
            }
            BDLogDebug("adding base segment {}", segment.name);
            InsertSegment(segment);
        }
    }

    void ProcessFileset(const Fileset &fileset) {
        BDLogInfo("Adding fileset {}", fileset.name.c_str());
        auto segments = DecodeSegments(fileset.fileOffset);
        for (const auto &segment: segments) {
            if (ShouldSkipSegment(fileset, segment)) {
                BDLogDebug("Skipping segment {}", segment.name.c_str());
                continue;
            }
            InsertSegment(segment, fileset.name.c_str());
        }
        AddFilesetDataVariables(fileset);
    }

    void InsertSegment(const Segment &segment, const char *prefix = "") {
        BDVerify(segment.vaStart >= vaStart_);
        auto va = boost::icl::discrete_interval{segment.vaStart, segment.vaStart + segment.vaLength};
        if (const Segment *entry = va2RawMap_.Query(va)) {
            throw MachoDecodeError{"VA overlap between [{:#016x}-{:#016x}) and [{:#016x}-{:#016x}) while trying to add segment {}",
                                   va.lower(), va.upper(),
                                   entry->vaStart, entry->vaStart + entry->vaLength, segment.name};
        }
        va2RawMap_.Insert(va, segment);
        AddAutoSegment(segment.vaStart, segment.vaLength, segment.dataStart, segment.dataLength, segment.flags);
        for (const auto &section: segment.sections) {
            BDLogDebug("Adding section {}", section.name.c_str());
            AddAutoSection(
                fmt::format("{}::{}::{}", prefix, segment.name, section.name),
                section.vaStart,
                section.vaLength,
                section.semantics);
        }
    }

    void AddFilesetDataVariables(const Fileset &fileset) {
        NamedTypeReference ref{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "", QualifiedName{"mach_header_64"}};
        DefineDataVariable(fileset.vmAddr, Type::NamedType(&ref));
        Ref<BinaryNinja::Symbol> symbol = new BinaryNinja::Symbol{
            BNSymbolType::DataSymbol,
            "__mach_header", "__mach_header", "__mach_header", fileset.vmAddr};
        DefineAutoSymbol(symbol);
    }

    void StripPAC() {
        tf::Executor executor;
        tf::Taskflow taskflow;

        std::atomic<size_t> totalXPACs = 0;
        const auto &segments = va2RawMap_.Values();

        taskflow.for_each(segments.begin(), segments.end(), [&](const auto &segment) {
            if (segment.flags & BNSegmentFlag::SegmentExecutable) {
                return;
            }
            if (segment.flags & BNSegmentFlag::SegmentContainsCode) {
                return;
            }

            std::vector<uint64_t> data{};
            data.resize(segment.dataLength / 8);
            size_t dataSize = data.size() * 8;
            auto read = base_->Read(data.data(), segment.dataStart, dataSize);
            if (read < dataSize) {
                data.resize(read / 8);
                dataSize = data.size() * 8;
            }

            size_t numXPAC = 0;
            for (auto it = data.begin(), end = data.end(); it != end; ++it) {
                uint64_t value = *it;
                uint32_t signature = value >> 44;
                if (signature == 0 || signature == 0xfffff) {
                    continue;
                }
                uint8_t checkField = (value >> 40) & 0xf;
                if (checkField != 0xe) {
                    continue;
                }
                uint64_t address = value | 0xfffff00000000000ULL;
                if (address < vaStart_ || address >= vaStart_ + vaLength_ || va2RawMap_.Query(address) == nullptr) {
                    continue;
                }
                *it = address;
                ++numXPAC;
            }

            BDLogInfo("XPACed {} pointer from segment {}", numXPAC, segment.name);
            if (numXPAC) {
                size_t wrote = base_->Write(segment.dataStart, data.data(), dataSize);
                BDVerify(wrote == dataSize);
                totalXPACs += numXPAC;
            }
        });

        executor.run(taskflow).wait();
        BDLogInfo("XPACed total {} pointers", totalXPACs);
    }

    void DefineKallocTypeSymbols() {
        const auto &segments = va2RawMap_.Values();

        NamedTypeReference kallocTypeRef{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "",
            QualifiedName{"kalloc_type_view"}};
        Ref<Type> kallocType = Type::NamedType(&kallocTypeRef, 64);

        NamedTypeReference kallocVarRef{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "",
            QualifiedName{"kalloc_type_var_view"}};
        Ref<Type> kallocVarType = Type::NamedType(&kallocVarRef, 80);

        BeginBulkModifySymbols();
        size_t totalSymbols = 0;
        for (const auto &segment: segments) {
            for (const auto &section: segment.sections) {
                bool isVar;
                if (section.name.ends_with("__kalloc_var")) {
                    isVar = true;
                } else if (section.name.ends_with("__kalloc_type")) {
                    isVar = false;
                } else {
                    continue;
                }
                size_t size = isVar ? 80 : 64;
                Ref<Type> type = isVar ? kallocVarType : kallocType;
                for (size_t cursor = section.vaStart;
                     (cursor + size) <= section.vaStart + section.vaLength;
                     cursor += size) {
                    Ref<Symbol> symbol = new Symbol{
                        BNSymbolType::DataSymbol,
                        isVar ? "kalloc_type_var_view" : "kalloc_type_view",
                        cursor};
                    DefineAutoSymbolAndVariableOrFunction(GetDefaultPlatform(), symbol, type);
                    ++totalSymbols;
                }
            }
        }
        EndBulkModifySymbols();
        BDLogInfo("defined {} kalloc type (var) view symbols", totalSymbols);
    }

    std::vector<Fileset> DecodeFilesets() {
        return MachHeaderParser{*base_, 0}.DecodeFilesets();
    }

    std::vector<Segment> DecodeSegments(uint64_t fileoff) {
        return MachHeaderParser{*base_, fileoff}.DecodeSegments();
    }

private:
    uint64_t vaStart_;
    uint64_t vaLength_;
    uint64_t entryPoint_;
    RangeMap<uint64_t, Segment> va2RawMap_;
    Ref<BinaryView> base_;
    std::set<std::string> ignoredFilesets_;
};

class CustomBinaryType : public BinaryViewType {
public:
    CustomBinaryType() : BinaryViewType{kBinaryType, "MachO Kernel Cache"} {}

    bool IsDeprecated() override { return false; }

    BinaryView *Create(BinaryView *data) override {
        try {
            return new CustomBinaryView{data};
        } catch (const Types::DecodeError &e) {
            BDLogError("Failed to decode MachO Kernel Cache, error: {}", e.what());
            return nullptr;
        }
    }

    BinaryView *Parse(BinaryView *data) override {
        try {
            auto *bv = dynamic_cast<CustomBinaryView *>(data);
            bv->Parse();
            return bv;
        } catch (const Types::DecodeError &e) {
            BDLogError("Failed to parse MachO Kernel Cache, error: {}", e.what());
            return nullptr;
        }
    }

    bool IsTypeValidForData(BinaryView *data) override {
        if (data->GetLength() < sizeof(mach_header_64)) {
            return false;
        }

        BinaryViewDataReader reader{data, 0};
        auto header = reader.Read<mach_header_64>();
        if (header.magic != MH_CIGAM_64 && header.magic != MH_MAGIC_64) {
            return false;
        }
        if (header.filetype != 0xc /* MH_FILESET */) {
            return false;
        }
        BDLogDebug("Matched Kernel Cache");
        return true;
    }

    Ref<Settings> GetLoadSettingsForData(BinaryView *data) override {
        BNSettings *settingsObject = BNGetBinaryViewDefaultLoadSettingsForData(m_object, data->GetObject());
        if (!settingsObject)
            return nullptr;
        Ref<Settings> settings = new Settings(settingsObject);
        settings->DeserializeSchema(kStripPACSchema);
        return settings;
    }
};

}// namespace


void KCView::CorePluginInit() {
    BinaryViewType::Register(new CustomBinaryType{});
}

```

`kcview/test/CMakeLists.txt`:

```txt
add_executable(kcview_test main.cpp)
target_link_libraries(kcview_test PRIVATE kcview)

```

`kcview/test/main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#include <sys/stat.h>

#include <cstdlib>
#include <iostream>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <lowlevelilinstruction.h>

#include <binja/kcview/lib.h>
#include <binja/utils/binary_view.h>

using namespace BinaryNinja;
using namespace std;
using namespace Binja;

bool is_file(char *fname) {
    struct stat buf;
    if (stat(fname, &buf) == 0 && (buf.st_mode & S_IFREG) == S_IFREG)
        return true;

    return false;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        cerr << "USAGE: " << argv[0] << " <file_name>" << endl;
        exit(-1);
    }

    char *fname = argv[1];
    if (!is_file(fname)) {
        cerr << "Error: " << fname << " is not a regular file" << endl;
        exit(-1);
    }

    SetBundledPluginDirectory(BNGetBundledPluginDirectory());
    InitPlugins(true);

    KCView::CorePluginInit();
    LogToStdout(BNLogLevel::DebugLog);

    Json::Value opts;
    opts["loader.stripPAC"] = true;
    Ref<BinaryView> bv = Binja::Utils::OpenBinaryView(fname, false, nullptr, nullptr, opts);
    bv->UpdateAnalysisAndWait();

    cout << "Target:   " << fname << endl
         << endl;
    cout << "TYPE:     " << bv->GetTypeName() << endl;
    cout << "START:    0x" << hex << bv->GetStart() << endl;
    cout << "ENTRY:    0x" << hex << bv->GetEntryPoint() << endl;
    cout << "PLATFORM: " << bv->GetDefaultPlatform()->GetName() << endl;
    cout << endl;

    cout << "---------- 10 Functions ----------" << endl;
    int x = 0;
    for (auto func: bv->GetAnalysisFunctionList()) {
        cout << hex << func->GetStart() << " " << func->GetSymbol()->GetFullName() << endl;
        if (++x >= 10)
            break;
    }
    cout << endl;

    cout << "---------- 10 Strings ----------" << endl;
    x = 0;
    for (auto str_ref: bv->GetStrings()) {
        char *str = (char *) malloc(str_ref.length + 1);
        bv->Read(str, str_ref.start, str_ref.length);
        str[str_ref.length] = 0;

        cout << hex << str_ref.start << " (" << dec << str_ref.length << ") " << str << endl;
        free(str);

        if (++x >= 10)
            break;
    }

    // Shutting down is required to allow for clean exit of the core
    BNShutdown();

    return 0;
}

```

`main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjacore.h>

#include <binja/debuginfo/plugin_dsym.h>
#include <binja/debuginfo/plugin_macho.h>
#include <binja/kcview/lib.h>

using namespace Binja;

extern "C" {
BN_DECLARE_CORE_ABI_VERSION

BINARYNINJAPLUGIN bool CorePluginInit() {
    DebugInfo::PluginDSYM::RegisterPlugin();
    DebugInfo::PluginMacho::RegisterPlugin();
    KCView::CorePluginInit();
    return true;
}
}
```