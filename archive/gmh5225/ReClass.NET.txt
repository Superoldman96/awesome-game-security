Project Path: arc_gmh5225_ReClass.NET_f30xa2vd

Source Tree:

```txt
arc_gmh5225_ReClass.NET_f30xa2vd
├── Dependencies
│   ├── ColorCode.dll
│   ├── Dia2Lib.dll
│   ├── Microsoft.ExceptionMessageBox.dll
│   └── nuget.exe
├── LICENSE
├── Makefile
├── NativeCore
│   ├── Dependencies
│   │   └── distorm
│   │       ├── COPYING.txt
│   │       ├── include
│   │       │   ├── distorm.h
│   │       │   └── mnemonics.h
│   │       └── src
│   │           ├── config.h
│   │           ├── decoder.c
│   │           ├── decoder.h
│   │           ├── distorm.c
│   │           ├── instructions.c
│   │           ├── instructions.h
│   │           ├── insts.c
│   │           ├── insts.h
│   │           ├── mnemonics.c
│   │           ├── operands.c
│   │           ├── operands.h
│   │           ├── prefix.c
│   │           ├── prefix.h
│   │           ├── textdefs.c
│   │           ├── textdefs.h
│   │           ├── wstring.c
│   │           ├── wstring.h
│   │           └── x86defs.h
│   ├── ReClassNET_Plugin.hpp
│   ├── Shared
│   │   ├── DistormHelper.cpp
│   │   ├── DistormHelper.hpp
│   │   └── Keys.hpp
│   ├── Unix
│   │   ├── CloseRemoteProcess.cpp
│   │   ├── ControlRemoteProcess.cpp
│   │   ├── Debugger.cpp
│   │   ├── DisassembleCode.cpp
│   │   ├── EnumerateProcesses.cpp
│   │   ├── EnumerateRemoteSectionsAndModules.cpp
│   │   ├── Input.cpp
│   │   ├── IsProcessValid.cpp
│   │   ├── Makefile
│   │   ├── NativeCore.Unix.vcxproj
│   │   ├── NativeCore.Unix.vcxproj.filters
│   │   ├── NativeCore.hpp
│   │   ├── OpenRemoteProcess.cpp
│   │   ├── ReadRemoteMemory.cpp
│   │   └── WriteRemoteMemory.cpp
│   └── Windows
│       ├── CloseRemoteProcess.cpp
│       ├── ControlRemoteProcess.cpp
│       ├── Debugger.cpp
│       ├── DisassembleCode.cpp
│       ├── EnumerateProcesses.cpp
│       ├── EnumerateRemoteSectionsAndModules.cpp
│       ├── Input.cpp
│       ├── IsProcessValid.cpp
│       ├── NativeCore.hpp
│       ├── NativeCore.vcxproj
│       ├── NativeCore.vcxproj.filters
│       ├── OpenRemoteProcess.cpp
│       ├── ReadRemoteMemory.cpp
│       ├── WriteRemoteMemory.cpp
│       └── exports.def
├── README.md
├── ReClass.NET
│   ├── AddressParser
│   │   ├── AstBuilder.cs
│   │   ├── DynamicCompiler.cs
│   │   ├── Expressions.cs
│   │   ├── IExecutor.cs
│   │   ├── ITokenizer.cs
│   │   ├── Interpreter.cs
│   │   ├── Operations.cs
│   │   ├── ParseException.cs
│   │   ├── Parser.cs
│   │   ├── Token.cs
│   │   └── Tokenizer.cs
│   ├── App.config
│   ├── CodeGenerator
│   │   ├── CSharpCodeGenerator.cs
│   │   ├── CppCodeGenerator.cs
│   │   ├── ICodeGenerator.cs
│   │   └── Language.cs
│   ├── Constants.cs
│   ├── Controls
│   │   ├── BannerBox.cs
│   │   ├── ColorBox.Designer.cs
│   │   ├── ColorBox.cs
│   │   ├── ColorBox.resx
│   │   ├── CustomToolStripItems.cs
│   │   ├── DrawContext.cs
│   │   ├── DrawContextRequestEventArgs.cs
│   │   ├── DualValueBox.Designer.cs
│   │   ├── DualValueBox.cs
│   │   ├── DualValueBox.resx
│   │   ├── EnumComboBox.cs
│   │   ├── EnumDescriptionDisplay.cs
│   │   ├── HotSpotTextBox.cs
│   │   ├── HotkeyBox.Designer.cs
│   │   ├── HotkeyBox.cs
│   │   ├── HotkeyBox.resx
│   │   ├── IconButton.cs
│   │   ├── MemoryPreviewPopUp.cs
│   │   ├── MemoryRecordList.Designer.cs
│   │   ├── MemoryRecordList.cs
│   │   ├── MemoryRecordList.resx
│   │   ├── MemoryViewControl.Designer.cs
│   │   ├── MemoryViewControl.cs
│   │   ├── MemoryViewControl.resx
│   │   ├── NodeClickEventArgs.cs
│   │   ├── PlaceholderTextBox.cs
│   │   ├── ProjectView.Designer.cs
│   │   ├── ProjectView.cs
│   │   └── ProjectView.resx
│   ├── Core
│   │   ├── CoreFunctionsManager.cs
│   │   ├── DataExchange.cs
│   │   ├── ICoreProcessFunctions.cs
│   │   ├── IInternalCoreFunctions.cs
│   │   ├── InternalCoreFunctions.cs
│   │   └── NativeCoreWrapper.cs
│   ├── DataExchange
│   │   ├── ReClass
│   │   │   ├── CustomNodeSerializer.cs
│   │   │   ├── IReClassExport.cs
│   │   │   ├── IReClassImport.cs
│   │   │   ├── Legacy
│   │   │   │   ├── BaseClassArrayNode.cs
│   │   │   │   ├── ClassInstanceArrayNode.cs
│   │   │   │   ├── ClassPointerArrayNode.cs
│   │   │   │   ├── ClassPointerNode.cs
│   │   │   │   └── CustomNode.cs
│   │   │   ├── ReClassClipboard.cs
│   │   │   ├── ReClassFile.cs
│   │   │   ├── ReClassNetFile.Constants.cs
│   │   │   ├── ReClassNetFile.Read.cs
│   │   │   ├── ReClassNetFile.Write.cs
│   │   │   ├── ReClassNetFile.cs
│   │   │   └── ReClassQtFile.cs
│   │   └── Scanner
│   │       ├── CheatEngineFile.cs
│   │       ├── CrySearchFile.cs
│   │       ├── IScannerExport.cs
│   │       ├── IScannerImport.cs
│   │       └── ReClassScanFile.cs
│   ├── Debugger
│   │   ├── BreakpointAlreadySetException.cs
│   │   ├── DataExchange.cs
│   │   ├── HardwareBreakpoint.cs
│   │   ├── IBreakpoint.cs
│   │   ├── NoHardwareBreakpointAvailableException.cs
│   │   ├── RemoteDebugger.Extensions.cs
│   │   ├── RemoteDebugger.Handler.cs
│   │   ├── RemoteDebugger.Thread.cs
│   │   ├── RemoteDebugger.cs
│   │   └── SoftwareBreakpoint.cs
│   ├── Extensions
│   │   ├── BinaryReaderWriterExtensions.cs
│   │   ├── ByteExtension.cs
│   │   ├── ColorExtensions.cs
│   │   ├── DataGridViewExtensions.cs
│   │   ├── DictionaryExtensions.cs
│   │   ├── EncodingExtensions.cs
│   │   ├── EnumerableExtension.cs
│   │   ├── FloatingPointExtensions.cs
│   │   ├── GraphicsExtensions.cs
│   │   ├── IRemoteMemoryReaderExtension.cs
│   │   ├── IRemoteMemoryWriterExtension.cs
│   │   ├── IntPtrExtensions.cs
│   │   ├── ListExtension.cs
│   │   ├── PointExtension.cs
│   │   ├── RichTextBoxExtensions.cs
│   │   ├── StringBuilderExtensions.cs
│   │   ├── StringExtensions.cs
│   │   ├── StringReaderExtensions.cs
│   │   └── XAttributeExtensions.cs
│   ├── Forms
│   │   ├── AboutForm.Designer.cs
│   │   ├── AboutForm.cs
│   │   ├── AboutForm.resx
│   │   ├── ClassSelectionForm.Designer.cs
│   │   ├── ClassSelectionForm.cs
│   │   ├── ClassSelectionForm.resx
│   │   ├── CodeForm.Designer.cs
│   │   ├── CodeForm.cs
│   │   ├── CodeForm.resx
│   │   ├── EnumEditorForm.Designer.cs
│   │   ├── EnumEditorForm.cs
│   │   ├── EnumEditorForm.resx
│   │   ├── EnumListForm.Designer.cs
│   │   ├── EnumListForm.cs
│   │   ├── EnumListForm.resx
│   │   ├── EnumSelectionForm.Designer.cs
│   │   ├── EnumSelectionForm.cs
│   │   ├── EnumSelectionForm.resx
│   │   ├── FoundCodeForm.Designer.cs
│   │   ├── FoundCodeForm.cs
│   │   ├── FoundCodeForm.resx
│   │   ├── IconForm.cs
│   │   ├── InputBytesForm.Designer.cs
│   │   ├── InputBytesForm.cs
│   │   ├── InputBytesForm.resx
│   │   ├── InputCorrelatorForm.Designer.cs
│   │   ├── InputCorrelatorForm.cs
│   │   ├── InputCorrelatorForm.resx
│   │   ├── LogForm.Designer.cs
│   │   ├── LogForm.cs
│   │   ├── LogForm.resx
│   │   ├── MainForm.Designer.cs
│   │   ├── MainForm.Functions.cs
│   │   ├── MainForm.cs
│   │   ├── MainForm.resx
│   │   ├── NamedAddressesForm.Designer.cs
│   │   ├── NamedAddressesForm.cs
│   │   ├── NamedAddressesForm.resx
│   │   ├── PluginForm.Designer.cs
│   │   ├── PluginForm.cs
│   │   ├── PluginForm.resx
│   │   ├── ProcessBrowserForm.Designer.cs
│   │   ├── ProcessBrowserForm.cs
│   │   ├── ProcessBrowserForm.resx
│   │   ├── ProcessInfoForm.Designer.cs
│   │   ├── ProcessInfoForm.cs
│   │   ├── ProcessInfoForm.resx
│   │   ├── ProcessMemoryViewForm.Designer.cs
│   │   ├── ProcessMemoryViewForm.cs
│   │   ├── ProcessMemoryViewForm.resx
│   │   ├── ScannerForm.Designer.cs
│   │   ├── ScannerForm.cs
│   │   ├── ScannerForm.resx
│   │   ├── SettingsForm.Designer.cs
│   │   ├── SettingsForm.cs
│   │   └── SettingsForm.resx
│   ├── Input
│   │   ├── KeyboardHotkey.cs
│   │   └── KeyboardInput.cs
│   ├── Logger
│   │   ├── BaseLogger.cs
│   │   ├── GuiLogger.cs
│   │   ├── ILogger.cs
│   │   ├── LogLevel.cs
│   │   └── NullLogger.cs
│   ├── Makefile
│   ├── Memory
│   │   ├── Disassembler.cs
│   │   ├── Dumper.cs
│   │   ├── IProcessReader.cs
│   │   ├── IRemoteMemoryReader.cs
│   │   ├── IRemoteMemoryWriter.cs
│   │   ├── MemoryBuffer.cs
│   │   ├── Module.cs
│   │   ├── NodeDissector.cs
│   │   ├── ProcessInfo.cs
│   │   ├── RemoteProcess.cs
│   │   ├── Section.cs
│   │   ├── SimplePeHeader.cs
│   │   └── UnionDataType.cs
│   ├── MemoryScanner
│   │   ├── BytePattern.cs
│   │   ├── Comparer
│   │   │   ├── ArrayOfBytesMemoryComparer.cs
│   │   │   ├── ByteMemoryComparer.cs
│   │   │   ├── DoubleMemoryComparer.cs
│   │   │   ├── FloatMemoryComparer.cs
│   │   │   ├── IComplexScanComparer.cs
│   │   │   ├── IScanComparer.cs
│   │   │   ├── ISimpleScanComparer.cs
│   │   │   ├── IntegerMemoryComparer.cs
│   │   │   ├── InvalidCompareTypeException.cs
│   │   │   ├── LongMemoryComparer.cs
│   │   │   ├── RegexStringMemoryComparer.cs
│   │   │   ├── ShortMemoryComparer.cs
│   │   │   └── StringMemoryComparer.cs
│   │   ├── ComplexScannerWorker.cs
│   │   ├── IScannerWorker.cs
│   │   ├── InputCorrelatedScanner.cs
│   │   ├── MemoryRecord.cs
│   │   ├── PatternScanner.cs
│   │   ├── ScanCompareType.cs
│   │   ├── ScanResult.cs
│   │   ├── ScanResultBlock.cs
│   │   ├── ScanResultStore.cs
│   │   ├── ScanRoundMode.cs
│   │   ├── ScanSettings.cs
│   │   ├── ScanValueType.cs
│   │   ├── Scanner.cs
│   │   ├── ScannerContext.cs
│   │   └── SimpleScannerWorker.cs
│   ├── Native
│   │   ├── INativeMethods.cs
│   │   ├── NativeMethods.Unix.cs
│   │   ├── NativeMethods.Windows.cs
│   │   └── NativeMethods.cs
│   ├── Nodes
│   │   ├── ArrayNode.cs
│   │   ├── BaseClassWrapperNode.cs
│   │   ├── BaseContainerNode.cs
│   │   ├── BaseFunctionNode.cs
│   │   ├── BaseFunctionPtrNode.cs
│   │   ├── BaseHexCommentNode.cs
│   │   ├── BaseHexNode.cs
│   │   ├── BaseMatrixNode.cs
│   │   ├── BaseNode.cs
│   │   ├── BaseNumericNode.cs
│   │   ├── BaseTextNode.cs
│   │   ├── BaseTextPtrNode.cs
│   │   ├── BaseWrapperArrayNode.cs
│   │   ├── BaseWrapperNode.cs
│   │   ├── BitFieldNode.cs
│   │   ├── BoolNode.cs
│   │   ├── ClassInstanceArrayNode.cs
│   │   ├── ClassInstanceNode.cs
│   │   ├── ClassNode.cs
│   │   ├── ClassUtil.cs
│   │   ├── DoubleNode.cs
│   │   ├── EnumNode.cs
│   │   ├── FloatNode.cs
│   │   ├── FunctionNode.Tokenizer.cs
│   │   ├── FunctionNode.cs
│   │   ├── FunctionPtrNode.cs
│   │   ├── Hex16Node.cs
│   │   ├── Hex32Node.cs
│   │   ├── Hex64Node.cs
│   │   ├── Hex8Node.cs
│   │   ├── INodeInfoReader.cs
│   │   ├── Int16Node.cs
│   │   ├── Int32Node.cs
│   │   ├── Int64Node.cs
│   │   ├── Int8Node.cs
│   │   ├── Matrix3x3Node.cs
│   │   ├── Matrix3x4Node.cs
│   │   ├── Matrix4x4Node.cs
│   │   ├── NIntNode.cs
│   │   ├── NUIntNode.cs
│   │   ├── PointerNode.cs
│   │   ├── UInt16Node.cs
│   │   ├── UInt32Node.cs
│   │   ├── UInt64Node.cs
│   │   ├── UInt8Node.cs
│   │   ├── UTF16TextNode.cs
│   │   ├── UTF16TextPtrNode.cs
│   │   ├── UTF32TextNode.cs
│   │   ├── UTF32TextPtrNode.cs
│   │   ├── UTF8TextNode.cs
│   │   ├── UTF8TextPtrNode.cs
│   │   ├── UnionNode.cs
│   │   ├── Vector2Node.cs
│   │   ├── Vector3Node.cs
│   │   ├── Vector4Node.cs
│   │   ├── VirtualMethodNode.cs
│   │   └── VirtualMethodTableNode.cs
│   ├── Plugins
│   │   ├── DefaultPluginHost.cs
│   │   ├── IPluginHost.cs
│   │   ├── Plugin.cs
│   │   ├── PluginInfo.cs
│   │   └── PluginManager.cs
│   ├── Program.cs
│   ├── Project
│   │   ├── CppTypeMapping.cs
│   │   ├── EnumDescription.cs
│   │   └── ReClassNetProject.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── ReClass.NET.csproj
│   ├── Resources
│   │   ├── Icon
│   │   │   ├── ReClassNet.ico
│   │   │   ├── icon.pdn
│   │   │   ├── icon_128.png
│   │   │   ├── icon_16.png
│   │   │   ├── icon_256.png
│   │   │   ├── icon_32.png
│   │   │   ├── icon_48.png
│   │   │   ├── icon_64.png
│   │   │   └── icon_96.png
│   │   └── Images
│   │       ├── B16x16_Accept.png
│   │       ├── B16x16_Array_Type.png
│   │       ├── B16x16_Arrow_Refresh.png
│   │       ├── B16x16_Button_Add.png
│   │       ├── B16x16_Button_Add_Bytes_1024.png
│   │       ├── B16x16_Button_Add_Bytes_2048.png
│   │       ├── B16x16_Button_Add_Bytes_256.png
│   │       ├── B16x16_Button_Add_Bytes_4.png
│   │       ├── B16x16_Button_Add_Bytes_4096.png
│   │       ├── B16x16_Button_Add_Bytes_64.png
│   │       ├── B16x16_Button_Add_Bytes_8.png
│   │       ├── B16x16_Button_Add_Bytes_X.png
│   │       ├── B16x16_Button_Array.png
│   │       ├── B16x16_Button_Bits.png
│   │       ├── B16x16_Button_Bool.png
│   │       ├── B16x16_Button_Class_Add.png
│   │       ├── B16x16_Button_Class_Instance.png
│   │       ├── B16x16_Button_Class_Pointer.png
│   │       ├── B16x16_Button_Class_Remove.png
│   │       ├── B16x16_Button_Delete.png
│   │       ├── B16x16_Button_Double.png
│   │       ├── B16x16_Button_Drop_Down.png
│   │       ├── B16x16_Button_Enum.png
│   │       ├── B16x16_Button_Float.png
│   │       ├── B16x16_Button_Function.png
│   │       ├── B16x16_Button_Function_Pointer.png
│   │       ├── B16x16_Button_Hex_16.png
│   │       ├── B16x16_Button_Hex_32.png
│   │       ├── B16x16_Button_Hex_64.png
│   │       ├── B16x16_Button_Hex_8.png
│   │       ├── B16x16_Button_Insert_Bytes_1024.png
│   │       ├── B16x16_Button_Insert_Bytes_2048.png
│   │       ├── B16x16_Button_Insert_Bytes_256.png
│   │       ├── B16x16_Button_Insert_Bytes_4.png
│   │       ├── B16x16_Button_Insert_Bytes_4096.png
│   │       ├── B16x16_Button_Insert_Bytes_64.png
│   │       ├── B16x16_Button_Insert_Bytes_8.png
│   │       ├── B16x16_Button_Insert_Bytes_X.png
│   │       ├── B16x16_Button_Int_16.png
│   │       ├── B16x16_Button_Int_32.png
│   │       ├── B16x16_Button_Int_64.png
│   │       ├── B16x16_Button_Int_8.png
│   │       ├── B16x16_Button_Matrix_3x3.png
│   │       ├── B16x16_Button_Matrix_3x4.png
│   │       ├── B16x16_Button_Matrix_4x4.png
│   │       ├── B16x16_Button_NInt.png
│   │       ├── B16x16_Button_NUInt.png
│   │       ├── B16x16_Button_Pointer.png
│   │       ├── B16x16_Button_Pointer_Array.png
│   │       ├── B16x16_Button_Remove.png
│   │       ├── B16x16_Button_Text.png
│   │       ├── B16x16_Button_Text_Pointer.png
│   │       ├── B16x16_Button_UInt_16.png
│   │       ├── B16x16_Button_UInt_32.png
│   │       ├── B16x16_Button_UInt_64.png
│   │       ├── B16x16_Button_UInt_8.png
│   │       ├── B16x16_Button_UText.png
│   │       ├── B16x16_Button_UText_Pointer.png
│   │       ├── B16x16_Button_Union.png
│   │       ├── B16x16_Button_VTable.png
│   │       ├── B16x16_Button_Vector_2.png
│   │       ├── B16x16_Button_Vector_3.png
│   │       ├── B16x16_Button_Vector_4.png
│   │       ├── B16x16_Camera.png
│   │       ├── B16x16_Canvas_Size.png
│   │       ├── B16x16_Category.png
│   │       ├── B16x16_Chart_Delete.png
│   │       ├── B16x16_Class_Type.png
│   │       ├── B16x16_Closed_Icon.png
│   │       ├── B16x16_Cogs.png
│   │       ├── B16x16_Color_Wheel.png
│   │       ├── B16x16_Control_Pause.png
│   │       ├── B16x16_Control_Play.png
│   │       ├── B16x16_Control_Stop.png
│   │       ├── B16x16_Custom_Type.png
│   │       ├── B16x16_Double_Type.png
│   │       ├── B16x16_Drive_Go.png
│   │       ├── B16x16_Enum_Type.png
│   │       ├── B16x16_Error.png
│   │       ├── B16x16_Exchange_Button.png
│   │       ├── B16x16_Eye.png
│   │       ├── B16x16_Find_Access.png
│   │       ├── B16x16_Find_Write.png
│   │       ├── B16x16_Float_Type.png
│   │       ├── B16x16_Folder.png
│   │       ├── B16x16_Folder_Add.png
│   │       ├── B16x16_Function_Type.png
│   │       ├── B16x16_Gear.png
│   │       ├── B16x16_Help.png
│   │       ├── B16x16_Information.png
│   │       ├── B16x16_Interface_Type.png
│   │       ├── B16x16_Left_Button.png
│   │       ├── B16x16_Magnifier.png
│   │       ├── B16x16_Magnifier_Arrow.png
│   │       ├── B16x16_Magnifier_Remove.png
│   │       ├── B16x16_Matrix_Type.png
│   │       ├── B16x16_Open_Icon.png
│   │       ├── B16x16_Page_Code.png
│   │       ├── B16x16_Page_Code_Add.png
│   │       ├── B16x16_Page_Code_Cpp.png
│   │       ├── B16x16_Page_Code_Csharp.png
│   │       ├── B16x16_Page_Copy.png
│   │       ├── B16x16_Page_Paste.png
│   │       ├── B16x16_Page_White_Stack.png
│   │       ├── B16x16_Pdb.png
│   │       ├── B16x16_Plugin.png
│   │       ├── B16x16_Pointer_Type.png
│   │       ├── B16x16_Quit.png
│   │       ├── B16x16_Redo.png
│   │       ├── B16x16_Right_Button.png
│   │       ├── B16x16_Save.png
│   │       ├── B16x16_Save_As.png
│   │       ├── B16x16_Settings_Edit.png
│   │       ├── B16x16_Signed_Type.png
│   │       ├── B16x16_Table_Gear.png
│   │       ├── B16x16_Text_List_Bullets.png
│   │       ├── B16x16_Text_Type.png
│   │       ├── B16x16_Textfield_Rename.png
│   │       ├── B16x16_Tree_Collapse.png
│   │       ├── B16x16_Tree_Expand.png
│   │       ├── B16x16_Undo.png
│   │       ├── B16x16_Unsigned_Type.png
│   │       ├── B16x16_Vector_Type.png
│   │       ├── B16x16_Warning.png
│   │       ├── B32x32_3D_Glasses.png
│   │       ├── B32x32_Bug.png
│   │       ├── B32x32_Canvas_Size.png
│   │       ├── B32x32_Cogs.png
│   │       ├── B32x32_Eye.png
│   │       ├── B32x32_Magnifier.png
│   │       ├── B32x32_Page_Code.png
│   │       └── B32x32_Plugin.png
│   ├── Settings.cs
│   ├── Symbols
│   │   ├── ComDisposableWrapper.cs
│   │   ├── SymbolReader.cs
│   │   └── SymbolStore.cs
│   ├── UI
│   │   ├── BannerFactory.cs
│   │   ├── BindingDisplayWrapper.cs
│   │   ├── CustomToolStripProfessionalRenderer.cs
│   │   ├── DpiUtil.cs
│   │   ├── FontEx.cs
│   │   ├── GlobalWindowManager.cs
│   │   ├── HotSpot.cs
│   │   ├── IconProvider.cs
│   │   ├── LinkedWindowFeatures.cs
│   │   └── NodeTypesBuilder.cs
│   └── Util
│       ├── BitString.cs
│       ├── CircularBuffer.cs
│       ├── CommandLineArgs.cs
│       ├── Conversion
│       │   ├── BigEndianBitConverter.cs
│       │   ├── EndianBitConverter.cs
│       │   └── LittleEndianBitConverter.cs
│       ├── CustomDataMap.cs
│       ├── DirectedGraph.cs
│       ├── GrowingList.cs
│       ├── HexadecimalFormatter.cs
│       ├── IntPtrComparer.cs
│       ├── NumberFormat.cs
│       ├── PathUtil.cs
│       ├── Rtf
│       │   ├── RtfBuilder.RtfFormatWrapper.cs
│       │   ├── RtfBuilder.cs
│       │   └── RtfFont.cs
│       ├── SettingsSerializer.cs
│       ├── Util.cs
│       ├── ValueTypeWrapper.cs
│       ├── WinUtil.cs
│       └── XElementSerializer.cs
├── ReClass.NET.sln
├── ReClass.NET_Launcher
│   ├── App.config
│   ├── DataExchange
│   │   └── ReClass
│   │       └── ReClassNetFile.cs
│   ├── Makefile
│   ├── Native
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── ReClass.NET_Launcher.csproj
│   ├── ReClassNet.ico
│   └── Util
└── ReClass.NET_Tests
    ├── AddressParser
    │   ├── DynamicCompilerTest.cs
    │   ├── ExecutorTest.cs
    │   ├── InterpreterTest.cs
    │   ├── ParserTest.cs
    │   └── TokenizerTest.cs
    ├── Extensions
    │   ├── ByteExtensionTest.cs
    │   ├── ColorExtensionTest.cs
    │   ├── DictionaryExtensionTest.cs
    │   ├── EncodingExtensionTest.cs
    │   ├── EnumerableExtensionTests.cs
    │   ├── FloatingPointExtensionTest.cs
    │   ├── IntPtrExtensionTest.cs
    │   ├── ListExtensionTest.cs
    │   ├── PointExtensionTest.cs
    │   ├── StringBuilderExtensionTest.cs
    │   ├── StringExtensionTest.cs
    │   └── StringReaderExtensionTest.cs
    ├── Memory
    │   └── MemoryBufferTest.cs
    ├── MemoryScanner
    │   ├── BytePatternTest.cs
    │   └── Comparer
    │       ├── ByteMemoryComparerTest.cs
    │       ├── FloatMemoryComparerTest.cs
    │       ├── IntegerMemoryComparerTest.cs
    │       ├── LongMemoryComparerTest.cs
    │       └── ShortMemoryComparerTest.cs
    ├── Properties
    │   └── AssemblyInfo.cs
    ├── ReClass.NET_Tests.csproj
    ├── UI
    │   └── DpiUtilTest.cs
    └── Util
        ├── BitStringTest.cs
        ├── CircularBufferTest.cs
        ├── CommandLineArgsTest.cs
        ├── Conversion
        │   ├── BigEndianBitConverterTest.cs
        │   ├── EndianBitConverterTest.cs
        │   └── LittleEndianBitConverterTest.cs
        ├── CustomDataMapTest.cs
        ├── DirectedGraphTest.cs
        ├── GrowingListTest.cs
        ├── HexadecimalFormatterTest.cs
        ├── IntPtrComparerTest.cs
        ├── NumberFormatTest.cs
        ├── PathUtilTest.cs
        └── XElementSerializerTest.cs

```

`LICENSE`:

```
MIT License

Copyright (c) 2016 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
.PHONY: all clean debug clean_debug release clean_release update docker_all docker_debug docker_release podman_all podman_debug podman_release dist

all: debug release dist

clean: clean_debug clean_release

debug:
	cd ReClass.NET_Launcher && make debug
	cd ReClass.NET && make debug
	cd NativeCore/Unix && make debug

clean_debug:
	cd ReClass.NET_Launcher && make clean_debug
	cd ReClass.NET && make clean_debug
	cd NativeCore/Unix && make clean_debug
	rm -rf build/Debug

release:
	cd ReClass.NET_Launcher && make release
	cd ReClass.NET && make release
	cd NativeCore/Unix && make release

clean_release:
	cd ReClass.NET_Launcher && make clean_release
	cd ReClass.NET && make clean_release
	cd NativeCore/Unix && make clean_release
	rm -rf build/Release

update:
	cd ReClass.NET && make update

docker_all:
	make docker_debug
	make docker_release
	make dist

docker_debug:
	cd ReClass.NET_Launcher && make docker_debug
	cd ReClass.NET && make docker_debug
	docker container run --rm -v ${PWD}:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) gcc:latest bash -c "cd NativeCore/Unix && make debug"

docker_release:
	cd ReClass.NET_Launcher && make docker_release
	cd ReClass.NET && make docker_release
	docker container run --rm -v ${PWD}:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) gcc:latest bash -c "cd NativeCore/Unix && make release"

podman_all:
	make podman_debug
	make podman_release
	make dist

podman_debug:
	cd ReClass.NET_Launcher && make podman_debug
	cd ReClass.NET && make podman_debug
	podman container run --rm -v ${PWD}:/build:z -w /build gcc:latest bash -c "cd NativeCore/Unix && make debug"

podman_release:
	cd ReClass.NET_Launcher && make podman_release
	cd ReClass.NET && make podman_release
	podman container run --rm -v ${PWD}:/build:z -w /build gcc:latest bash -c "cd NativeCore/Unix && make release"

dist:
	test -d build || mkdir -p build
	cp -r ReClass.NET/bin/* build/
	cp -r ReClass.NET_Launcher/bin/* build/
	cp NativeCore/Unix/build/debug/NativeCore.so build/Debug/x64
	cp NativeCore/Unix/build/release/NativeCore.so build/Release/x64
	test -d build/Debug/x86/Plugins || mkdir build/Debug/x86/Plugins
	test -d build/Debug/x64/Plugins || mkdir build/Debug/x64/Plugins
	test -d build/Release/x86/Plugins || mkdir build/Release/x86/Plugins
	test -d build/Release/x64/Plugins || mkdir build/Release/x64/Plugins
	test -d build/Debug/x86 && cp -r Dependencies/x86/* build/Debug/x86
	test -d build/Debug/x64 && cp -r Dependencies/x64/* build/Debug/x64
	test -d build/Release/x86 && cp -r Dependencies/x86/* build/Release/x86
	test -d build/Release/x64 && cp -r Dependencies/x64/* build/Release/x64

```

`NativeCore/Dependencies/distorm/COPYING.txt`:

```txt
:[diStorm3}:
The ultimate disassembler library.
Copyright (c) 2003-2016, Gil Dabah
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Gil Dabah nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL GIL DABAH BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`NativeCore/Dependencies/distorm/include/distorm.h`:

```h
/* diStorm 3.5.2 */

/*
distorm.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DISTORM_H
#define DISTORM_H

/*
 * 64 bit offsets support:
 * If the diStorm library you use was compiled with 64 bits offsets,
 * make sure you compile your own code with the following macro set:
 * SUPPORT_64BIT_OFFSET
 * Otherwise comment it out, or you will get a linker error of an unresolved symbol...
 * Turned on by default!
 */

#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))
	/* Define this macro for outer projects by default. */
	#define SUPPORT_64BIT_OFFSET
#endif

/* TINYC has a problem with some 64bits library functions, so ignore 64 bit offsets. */
#ifdef __TINYC__
	#undef SUPPORT_64BIT_OFFSET
#endif

#ifndef _MSC_VER
#include <stdint.h>
#else
/* Since MSVC < 2010 isn't shipped with stdint.h,
 * here are those from MSVC 2017, which also match
 * those in tinycc/libc. */
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
#endif

#ifdef SUPPORT_64BIT_OFFSET
#define OFFSET_INTEGER uint64_t
#else
/* 32 bit offsets are used. */
#define OFFSET_INTEGER uint32_t
#endif

/* Support C++ compilers */
#ifdef __cplusplus
 extern "C" {
#endif


/* ***  Helper Macros  *** */

/* Get the ISC of the instruction, used with the definitions below. */
#define META_GET_ISC(meta) (((meta) >> 8) & 0x1f)
#define META_SET_ISC(di, isc) (((di)->meta) |= ((isc) << 8))
/* Get the flow control flags of the instruction, see 'features for decompose' below. */
#define META_GET_FC(meta) ((meta) & 0xf)

/* Get the target address of a branching instruction. O_PC operand type. */
#define INSTRUCTION_GET_TARGET(di) ((_OffsetType)(((di)->addr + (di)->imm.addr + (di)->size)))
/* Get the target address of a RIP-relative memory indirection. */
#define INSTRUCTION_GET_RIP_TARGET(di) ((_OffsetType)(((di)->addr + (di)->disp + (di)->size)))

/*
 * Operand Size or Adderss size are stored inside the flags:
 * 00 - 16 bits
 * 01 - 32 bits
 * 10 - 64 bits
 * 11 - reserved
 *
 * If you call these set-macros more than once, you will have to clean the bits before doing so.
 */
#define FLAG_SET_OPSIZE(di, size) ((di->flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) (((unsigned int)((int16_t)flags)) & 7)
/* Indicates whether the instruction is privileged. */
#define FLAG_GET_PRIVILEGED(flags) (((flags) & FLAG_PRIVILEGED_INSTRUCTION) != 0)

/*
 * Macros to extract segment registers from 'segment':
 */
#define SEGMENT_DEFAULT 0x80
#define SEGMENT_GET(segment) (((segment) == R_NONE) ? R_NONE : ((segment) & 0x7f))
#define SEGMENT_GET_UNSAFE(segment) ((segment) & 0x7f)
#define SEGMENT_IS_DEFAULT(segment) (((int8_t)segment) < -1) /* Quick check it's a negative number that isn't -1, so it's (0x80 | SEGREG). */
#define SEGMENT_IS_DEFAULT_OR_NONE(segment) (((uint8_t)(segment)) > 0x80)

/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum { Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2 } _DecodeType;

typedef OFFSET_INTEGER _OffsetType;

typedef struct {
	_OffsetType codeOffset, addrMask;
	_OffsetType nextOffset; /* nextOffset is OUT only. */
	const uint8_t* code;
	int codeLen; /* Using signed integer makes it easier to detect an underflow. */
	_DecodeType dt;
	unsigned int features;
} _CodeInfo;

typedef enum { O_NONE, O_REG, O_IMM, O_IMM1, O_IMM2, O_DISP, O_SMEM, O_MEM, O_PC, O_PTR } _OperandType;

typedef union {
	/* Used by O_IMM: */
	int8_t sbyte;
	uint8_t byte;
	int16_t sword;
	uint16_t word;
	int32_t sdword;
	uint32_t dword;
	int64_t sqword; /* All immediates are SIGN-EXTENDED to 64 bits! */
	uint64_t qword;

	/* Used by O_PC: (Use GET_TARGET_ADDR).*/
	_OffsetType addr; /* It's a relative offset as for now. */

	/* Used by O_PTR: */
	struct {
		uint16_t seg;
		/* Can be 16 or 32 bits, size is in ops[n].size. */
		uint32_t off;
	} ptr;

	/* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
	struct {
		uint32_t i1;
		uint32_t i2;
	} ex;
} _Value;

typedef struct {
	/* Type of operand:
		O_NONE: operand is to be ignored.
		O_REG: index holds global register index.
		O_IMM: instruction.imm.
		O_IMM1: instruction.imm.ex.i1.
		O_IMM2: instruction.imm.ex.i2.
		O_DISP: memory dereference with displacement only, instruction.disp.
		O_SMEM: simple memory dereference with optional displacement (a single register memory dereference).
		O_MEM: complex memory dereference (optional fields: s/i/b/disp).
		O_PC: the relative address of a branch instruction (instruction.imm.addr).
		O_PTR: the absolute target address of a far branch instruction (instruction.imm.ptr.seg/off).
	*/
	uint8_t type; /* _OperandType */

	/* Index of:
		O_REG: holds global register index
		O_SMEM: holds the 'base' register. E.G: [ECX], [EBX+0x1234] are both in operand.index.
		O_MEM: holds the 'index' register. E.G: [EAX*4] is in operand.index.
	*/
	uint8_t index;

	/* Size in bits of:
		O_REG: register
		O_IMM: instruction.imm
		O_IMM1: instruction.imm.ex.i1
		O_IMM2: instruction.imm.ex.i2
		O_DISP: instruction.disp
		O_SMEM: size of indirection.
		O_MEM: size of indirection.
		O_PC: size of the relative offset
		O_PTR: size of instruction.imm.ptr.off (16 or 32)
	*/
	uint16_t size;
} _Operand;

#define OPCODE_ID_NONE 0
/* Instruction could not be disassembled. */
#define FLAG_NOT_DECODABLE ((uint16_t)-1)
/* The instruction locks memory access. */
#define FLAG_LOCK (1 << 0)
/* The instruction is prefixed with a REPNZ. */
#define FLAG_REPNZ (1 << 1)
/* The instruction is prefixed with a REP, this can be a REPZ, it depends on the specific instruction. */
#define FLAG_REP (1 << 2)
/* Indicates there is a hint taken for Jcc instructions only. */
#define FLAG_HINT_TAKEN (1 << 3)
/* Indicates there is a hint non-taken for Jcc instructions only. */
#define FLAG_HINT_NOT_TAKEN (1 << 4)
/* The Imm value is signed extended (E.G in 64 bit decoding mode, a 32 bit imm is usually sign extended into 64 bit imm). */
#define FLAG_IMM_SIGNED (1 << 5)
/* The destination operand is writable. */
#define FLAG_DST_WR (1 << 6)
/* The instruction uses RIP-relative indirection. */
#define FLAG_RIP_RELATIVE (1 << 7)

/* See flag FLAG_GET_XXX macros above. */

/* The instruction is privileged and can only be used from Ring0. */
#define FLAG_PRIVILEGED_INSTRUCTION (1 << 15)

/* No register was defined. */
#define R_NONE ((uint8_t)-1)

#define REGS64_BASE 0
#define REGS32_BASE 16
#define REGS16_BASE 32
#define REGS8_BASE 48
#define REGS8_REX_BASE 64
#define SREGS_BASE 68
#define FPUREGS_BASE 75
#define MMXREGS_BASE 83
#define SSEREGS_BASE 91
#define AVXREGS_BASE 107
#define CREGS_BASE 123
#define DREGS_BASE 132

#define OPERANDS_NO (4)

typedef struct {
	/* Used by ops[n].type == O_IMM/O_IMM1&O_IMM2/O_PTR/O_PC. Its size is ops[n].size. */
	_Value imm;
	/* Used by ops[n].type == O_SMEM/O_MEM/O_DISP. Its size is dispSize. */
	uint64_t disp;
	/* Virtual address of first byte of instruction. */
	_OffsetType addr;
	/* General flags of instruction, holds prefixes and more, if FLAG_NOT_DECODABLE, instruction is invalid. */
	uint16_t flags;
	/* Unused prefixes mask, for each bit that is set that prefix is not used (LSB is byte [addr + 0]). */
	uint16_t unusedPrefixesMask;
	/* Mask of registers that were used in the operands, only used for quick look up, in order to know *some* operand uses that register class. */
	uint32_t usedRegistersMask;
	/* ID of opcode in the global opcode table. Use for mnemonic look up. */
	uint16_t opcode;
	/* Up to four operands per instruction, ignored if ops[n].type == O_NONE. */
	_Operand ops[OPERANDS_NO];
	/* Number of valid ops entries. */
	uint8_t opsNo;
	/* Size of the whole instruction in bytes. */
	uint8_t size;
	/* Segment information of memory indirection, default segment, or overriden one, can be -1. Use SEGMENT macros. */
	uint8_t segment;
	/* Used by ops[n].type == O_MEM. Base global register index (might be R_NONE), scale size (2/4/8), ignored for 0 or 1. */
	uint8_t base, scale;
	uint8_t dispSize;
	/* Meta defines the instruction set class, and the flow control flags. Use META macros. */
	uint16_t meta;
	/* The CPU flags that the instruction operates upon, set only with DF_FILL_EFLAGS enabled, otherwise 0. */
	uint16_t modifiedFlagsMask, testedFlagsMask, undefinedFlagsMask;
} _DInst;

#ifndef DISTORM_LIGHT

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)
typedef struct {
	unsigned int length;
	unsigned char p[MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */
typedef struct {
	_OffsetType offset; /* Start offset of the decoded instruction. */
	unsigned int size; /* Size of decoded instruction in bytes. */
	_WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
	_WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
	_WString instructionHex; /* Hex dump - little endian, including prefixes. */
} _DecodedInst;

#endif /* DISTORM_LIGHT */

/* Register masks for quick look up, each mask indicates one of a register-class that is being used in some operand. */
#define RM_AX 1     /* AL, AH, AX, EAX, RAX */
#define RM_CX 2     /* CL, CH, CX, ECX, RCX */
#define RM_DX 4     /* DL, DH, DX, EDX, RDX */
#define RM_BX 8     /* BL, BH, BX, EBX, RBX */
#define RM_SP 0x10  /* SPL, SP, ESP, RSP */
#define RM_BP 0x20  /* BPL, BP, EBP, RBP */
#define RM_SI 0x40  /* SIL, SI, ESI, RSI */
#define RM_DI 0x80  /* DIL, DI, EDI, RDI */
#define RM_FPU 0x100 /* ST(0) - ST(7) */
#define RM_MMX 0x200 /* MM0 - MM7 */
#define RM_SSE 0x400 /* XMM0 - XMM15 */
#define RM_AVX 0x800 /* YMM0 - YMM15 */
#define RM_CR 0x1000 /* CR0, CR2, CR3, CR4, CR8 */
#define RM_DR 0x2000 /* DR0, DR1, DR2, DR3, DR6, DR7 */
#define RM_R8 0x4000 /* R8B, R8W, R8D, R8 */
#define RM_R9 0x8000 /* R9B, R9W, R9D, R9 */
#define RM_R10 0x10000 /* R10B, R10W, R10D, R10 */
#define RM_R11 0x20000 /* R11B, R11W, R11D, R11 */
#define RM_R12 0x40000 /* R12B, R12W, R12D, R12 */
#define RM_R13 0x80000 /* R13B, R13W, R13D, R13 */
#define RM_R14 0x100000 /* R14B, R14W, R14D, R14 */
#define RM_R15 0x200000 /* R15B, R15W, R15D, R15 */
#define RM_SEG 0x400000 /* CS, SS, DS, ES, FS, GS */

/* RIP should be checked using the 'flags' field and FLAG_RIP_RELATIVE.
 * Segments should be checked using the segment macros.
 * For now R8 - R15 are not supported and non general purpose registers map into same RM.
 */

/* CPU flags that instructions modify, test or undefine (are EFLAGS compatible!). */
#define D_CF 1		/* Carry */
#define D_PF 4		/* Parity */
#define D_AF 0x10	/* Auxiliary */
#define D_ZF 0x40	/* Zero */
#define D_SF 0x80	/* Sign */
#define D_IF 0x200	/* Interrupt */
#define D_DF 0x400	/* Direction */
#define D_OF 0x800	/* Overflow */

/*
 * Instructions Set classes:
 * if you want a better understanding of the available classes, look at disOps project, file: x86sets.py.
 */
/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL 19

/* Features for decompose: */
#define DF_NONE 0
/* The decoder will limit addresses to a maximum of 16 bits. */
#define DF_MAXIMUM_ADDR16 1
/* The decoder will limit addresses to a maximum of 32 bits. */
#define DF_MAXIMUM_ADDR32 2
/* The decoder will return only flow control instructions (and filter the others internally). */
#define DF_RETURN_FC_ONLY 4
/* The decoder will stop and return to the caller when the instruction 'CALL' (near and far) was decoded. */
#define DF_STOP_ON_CALL 8
/* The decoder will stop and return to the caller when the instruction 'RET' (near and far) was decoded. */
#define DF_STOP_ON_RET 0x10
/* The decoder will stop and return to the caller when the instruction system-call/ret was decoded. */
#define DF_STOP_ON_SYS 0x20
/* The decoder will stop and return to the caller when any of the branch 'JMP', (near and far) instructions were decoded. */
#define DF_STOP_ON_UNC_BRANCH 0x40
/* The decoder will stop and return to the caller when any of the conditional branch instruction were decoded. */
#define DF_STOP_ON_CND_BRANCH 0x80
/* The decoder will stop and return to the caller when the instruction 'INT' (INT, INT1, INTO, INT 3) was decoded. */
#define DF_STOP_ON_INT 0x100
/* The decoder will stop and return to the caller when any of the 'CMOVxx' instruction was decoded. */
#define DF_STOP_ON_CMOV 0x200
/* The decoder will stop and return to the caller when it encounters the HLT instruction. */
#define DF_STOP_ON_HLT 0x400
/* The decoder will stop and return to the caller when it encounters a privileged instruction. */
#define DF_STOP_ON_PRIVILEGED 0x800
/* The decoder will stop and return to the caller when an instruction couldn't be decoded. */
#define DF_STOP_ON_UNDECODEABLE 0x1000
/* The decoder will not synchronize to the next byte after the previosuly decoded instruction, instead it will start decoding at the next byte. */
#define DF_SINGLE_BYTE_STEP 0x2000
/* The decoder will fill in the eflags fields for the decoded instruction. */
#define DF_FILL_EFLAGS 0x4000
/* The decoder will use the addrMask in CodeInfo structure instead of DF_MAXIMUM_ADDR16/32. */
#define DF_USE_ADDR_MASK 0x8000

/* The decoder will stop and return to the caller when any flow control instruction was decoded. */
#define DF_STOP_ON_FLOW_CONTROL (DF_STOP_ON_CALL | DF_STOP_ON_RET | DF_STOP_ON_SYS | DF_STOP_ON_UNC_BRANCH | DF_STOP_ON_CND_BRANCH | DF_STOP_ON_INT | DF_STOP_ON_CMOV | DF_STOP_ON_HLT)

/* Indicates the instruction is not a flow-control instruction. */
#define FC_NONE 0
/* Indicates the instruction is one of: CALL, CALL FAR. */
#define FC_CALL 1
/* Indicates the instruction is one of: RET, IRET, RETF. */
#define FC_RET 2
/* Indicates the instruction is one of: SYSCALL, SYSRET, SYSENTER, SYSEXIT. */
#define FC_SYS 3
/* Indicates the instruction is one of: JMP, JMP FAR. */
#define FC_UNC_BRANCH 4
/*
 * Indicates the instruction is one of:
 * JCXZ, JO, JNO, JB, JAE, JZ, JNZ, JBE, JA, JS, JNS, JP, JNP, JL, JGE, JLE, JG, LOOP, LOOPZ, LOOPNZ.
 */
#define FC_CND_BRANCH 5
/* Indiciates the instruction is one of: INT, INT1, INT 3, INTO, UD2. */
#define FC_INT 6
/* Indicates the instruction is one of: CMOVxx. */
#define FC_CMOV 7
/* Indicates the instruction is HLT. */
#define FC_HLT 8

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR } _DecodeResult;

/* Define the following interface functions only for outer projects. */
#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))

/* distorm_decode
 * Input:
 *         offset - Origin of the given code (virtual address that is), NOT an offset in code.
 *         code - Pointer to the code buffer to be disassembled.
 *         length - Amount of bytes that should be decoded from the code buffer.
 *         dt - Decoding mode, 16 bits (Decode16Bits), 32 bits (Decode32Bits) or AMD64 (Decode64Bits).
 *         result - Array of type _DecodeInst which will be used by this function in order to return the disassembled instructions.
 *         maxInstructions - The maximum number of entries in the result array that you pass to this function, so it won't exceed its bound.
 *         usedInstructionsCount - Number of the instruction that successfully were disassembled and written to the result array.
 * Output: usedInstructionsCount will hold the number of entries used in the result array
 *         and the result array itself will be filled with the disassembled instructions.
 * Return: DECRES_SUCCESS on success (no more to disassemble), DECRES_INPUTERR on input error (null code buffer, invalid decoding mode, etc...),
 *         DECRES_MEMORYERR when there are not enough entries to use in the result array, BUT YOU STILL have to check for usedInstructionsCount!
 * Side-Effects: Even if the return code is DECRES_MEMORYERR, there might STILL be data in the
 *               array you passed, this function will try to use as much entries as possible!
 * Notes:  1)The minimal size of maxInstructions is 15.
 *         2)You will have to synchronize the offset,code and length by yourself if you pass code fragments and not a complete code block!
 */

/* distorm_decompose
 * See more documentation online at the GitHub project's wiki.
 *
 */
#ifdef SUPPORT_64BIT_OFFSET

	_DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose64

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode64
	#define distorm_format distorm_format64
#endif /*DISTORM_LIGHT*/

#else /*SUPPORT_64BIT_OFFSET*/

	_DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose32

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode32
	#define distorm_format distorm_format32
#endif /*DISTORM_LIGHT*/

#endif

/*
 * distorm_version
 * Input:
 *        none
 *
 * Output: unsigned int - version of compiled library.
 */
unsigned int distorm_version(void);

#endif /* DISTORM_STATIC */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORM_H */

```

`NativeCore/Dependencies/distorm/include/mnemonics.h`:

```h
/*
mnemonics.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef MNEMONICS_H
#define MNEMONICS_H

#ifdef __cplusplus
 extern "C" {
#endif

#ifndef DISTORM_LIGHT

typedef struct WMnemonic {
	unsigned char length;
	unsigned char p[1]; /* p is a null terminated string, which contains 'length' characters. */
} _WMnemonic;

typedef struct WRegister {
	unsigned int length;
	unsigned char p[6]; /* p is a null terminated string. */
} _WRegister;

extern const unsigned char _MNEMONICS[];
extern const _WRegister _REGISTERS[];

#endif /* DISTORM_LIGHT */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#define GET_REGISTER_NAME(r) (unsigned char*)_REGISTERS[(r)].p
#define GET_MNEMONIC_NAME(m) ((_WMnemonic*)&_MNEMONICS[(m)])->p

 typedef enum {
	I_UNDEFINED = 0, I_AAA = 66, I_AAD = 389, I_AAM = 384, I_AAS = 76, I_ADC = 31, I_ADD = 11, I_ADDPD = 3144,
	I_ADDPS = 3137, I_ADDSD = 3158, I_ADDSS = 3151, I_ADDSUBPD = 6428, I_ADDSUBPS = 6438,
	I_AESDEC = 9243, I_AESDECLAST = 9260, I_AESENC = 9201, I_AESENCLAST = 9218,
	I_AESIMC = 9184, I_AESKEYGENASSIST = 9829, I_AND = 41, I_ANDNPD = 3055, I_ANDNPS = 3047,
	I_ANDPD = 3024, I_ANDPS = 3017, I_ARPL = 111, I_BLENDPD = 9406, I_BLENDPS = 9387,
	I_BLENDVPD = 7653, I_BLENDVPS = 7643, I_BOUND = 104, I_BSF = 4380, I_BSR = 4392,
	I_BSWAP = 960, I_BT = 872, I_BTC = 934, I_BTR = 912, I_BTS = 887, I_CALL = 456,
	I_CALL_FAR = 260, I_CBW = 228, I_CDQ = 250, I_CDQE = 239, I_CLAC = 1787, I_CLC = 492,
	I_CLD = 512, I_CLFLUSH = 4363, I_CLGI = 1867, I_CLI = 502, I_CLTS = 541, I_CMC = 487,
	I_CMOVA = 694, I_CMOVAE = 663, I_CMOVB = 656, I_CMOVBE = 686, I_CMOVG = 754,
	I_CMOVGE = 738, I_CMOVL = 731, I_CMOVLE = 746, I_CMOVNO = 648, I_CMOVNP = 723,
	I_CMOVNS = 708, I_CMOVNZ = 678, I_CMOVO = 641, I_CMOVP = 716, I_CMOVS = 701,
	I_CMOVZ = 671, I_CMP = 71, I_CMPEQPD = 4483, I_CMPEQPS = 4404, I_CMPEQSD = 4641,
	I_CMPEQSS = 4562, I_CMPLEPD = 4501, I_CMPLEPS = 4422, I_CMPLESD = 4659, I_CMPLESS = 4580,
	I_CMPLTPD = 4492, I_CMPLTPS = 4413, I_CMPLTSD = 4650, I_CMPLTSS = 4571, I_CMPNEQPD = 4522,
	I_CMPNEQPS = 4443, I_CMPNEQSD = 4680, I_CMPNEQSS = 4601, I_CMPNLEPD = 4542,
	I_CMPNLEPS = 4463, I_CMPNLESD = 4700, I_CMPNLESS = 4621, I_CMPNLTPD = 4532,
	I_CMPNLTPS = 4453, I_CMPNLTSD = 4690, I_CMPNLTSS = 4611, I_CMPORDPD = 4552,
	I_CMPORDPS = 4473, I_CMPORDSD = 4710, I_CMPORDSS = 4631, I_CMPS = 301, I_CMPUNORDPD = 4510,
	I_CMPUNORDPS = 4431, I_CMPUNORDSD = 4668, I_CMPUNORDSS = 4589, I_CMPXCHG = 898,
	I_CMPXCHG16B = 6407, I_CMPXCHG8B = 6396, I_COMISD = 2813, I_COMISS = 2805,
	I_CPUID = 865, I_CQO = 255, I_CRC32 = 9292, I_CVTDQ2PD = 6821, I_CVTDQ2PS = 3341,
	I_CVTPD2DQ = 6831, I_CVTPD2PI = 2715, I_CVTPD2PS = 3267, I_CVTPH2PS = 4195,
	I_CVTPI2PD = 2529, I_CVTPI2PS = 2519, I_CVTPS2DQ = 3351, I_CVTPS2PD = 3257,
	I_CVTPS2PH = 4205, I_CVTPS2PI = 2705, I_CVTSD2SI = 2735, I_CVTSD2SS = 3287,
	I_CVTSI2SD = 2549, I_CVTSI2SS = 2539, I_CVTSS2SD = 3277, I_CVTSS2SI = 2725,
	I_CVTTPD2DQ = 6810, I_CVTTPD2PI = 2648, I_CVTTPS2DQ = 3361, I_CVTTPS2PI = 2637,
	I_CVTTSD2SI = 2670, I_CVTTSS2SI = 2659, I_CWD = 245, I_CWDE = 233, I_DAA = 46,
	I_DAS = 56, I_DEC = 86, I_DIV = 1646, I_DIVPD = 3533, I_DIVPS = 3526, I_DIVSD = 3547,
	I_DIVSS = 3540, I_DPPD = 9649, I_DPPS = 9636, I_EMMS = 4134, I_ENTER = 340,
	I_EXTRACTPS = 9514, I_EXTRQ = 4170, I_F2XM1 = 1192, I_FABS = 1123, I_FADD = 1023,
	I_FADDP = 1549, I_FBLD = 1601, I_FBSTP = 1607, I_FCHS = 1117, I_FCLEX = 7323,
	I_FCMOVB = 1376, I_FCMOVBE = 1392, I_FCMOVE = 1384, I_FCMOVNB = 1445, I_FCMOVNBE = 1463,
	I_FCMOVNE = 1454, I_FCMOVNU = 1473, I_FCMOVU = 1401, I_FCOM = 1035, I_FCOMI = 1512,
	I_FCOMIP = 1623, I_FCOMP = 1041, I_FCOMPP = 1563, I_FCOS = 1311, I_FDECSTP = 1238,
	I_FDIV = 1061, I_FDIVP = 1594, I_FDIVR = 1067, I_FDIVRP = 1586, I_FEDISI = 1488,
	I_FEMMS = 574, I_FENI = 1482, I_FFREE = 1527, I_FIADD = 1317, I_FICOM = 1331,
	I_FICOMP = 1338, I_FIDIV = 1361, I_FIDIVR = 1368, I_FILD = 1418, I_FIMUL = 1324,
	I_FINCSTP = 1247, I_FINIT = 7338, I_FIST = 1432, I_FISTP = 1438, I_FISTTP = 1424,
	I_FISUB = 1346, I_FISUBR = 1353, I_FLD = 1074, I_FLD1 = 1141, I_FLDCW = 1098,
	I_FLDENV = 1090, I_FLDL2E = 1155, I_FLDL2T = 1147, I_FLDLG2 = 1170, I_FLDLN2 = 1178,
	I_FLDPI = 1163, I_FLDZ = 1186, I_FMUL = 1029, I_FMULP = 1556, I_FNCLEX = 7315,
	I_FNINIT = 7330, I_FNOP = 1111, I_FNSAVE = 7345, I_FNSTCW = 7300, I_FNSTENV = 7283,
	I_FNSTSW = 7360, I_FPATAN = 1213, I_FPREM = 1256, I_FPREM1 = 1230, I_FPTAN = 1206,
	I_FRNDINT = 1288, I_FRSTOR = 1519, I_FSAVE = 7353, I_FSCALE = 1297, I_FSETPM = 1496,
	I_FSIN = 1305, I_FSINCOS = 1279, I_FSQRT = 1272, I_FST = 1079, I_FSTCW = 7308,
	I_FSTENV = 7292, I_FSTP = 1084, I_FSTSW = 7368, I_FSUB = 1048, I_FSUBP = 1579,
	I_FSUBR = 1054, I_FSUBRP = 1571, I_FTST = 1129, I_FUCOM = 1534, I_FUCOMI = 1504,
	I_FUCOMIP = 1614, I_FUCOMP = 1541, I_FUCOMPP = 1409, I_FXAM = 1135, I_FXCH = 1105,
	I_FXRSTOR = 9926, I_FXRSTOR64 = 9935, I_FXSAVE = 9898, I_FXSAVE64 = 9906,
	I_FXTRACT = 1221, I_FYL2X = 1199, I_FYL2XP1 = 1263, I_GETSEC = 633, I_HADDPD = 4215,
	I_HADDPS = 4223, I_HLT = 482, I_HSUBPD = 4249, I_HSUBPS = 4257, I_IDIV = 1651,
	I_IMUL = 117, I_IN = 447, I_INC = 81, I_INS = 123, I_INSERTPS = 9581, I_INSERTQ = 4177,
	I_INT = 367, I_INT_3 = 360, I_INT1 = 476, I_INTO = 372, I_INVD = 555, I_INVEPT = 8318,
	I_INVLPG = 1727, I_INVLPGA = 1881, I_INVPCID = 8335, I_INVVPID = 8326, I_IRET = 378,
	I_JA = 166, I_JAE = 147, I_JB = 143, I_JBE = 161, I_JCXZ = 427, I_JECXZ = 433,
	I_JG = 202, I_JGE = 192, I_JL = 188, I_JLE = 197, I_JMP = 462, I_JMP_FAR = 467,
	I_JNO = 138, I_JNP = 183, I_JNS = 174, I_JNZ = 156, I_JO = 134, I_JP = 179,
	I_JRCXZ = 440, I_JS = 170, I_JZ = 152, I_LAHF = 289, I_LAR = 522, I_LDDQU = 7028,
	I_LDMXCSR = 9956, I_LDS = 335, I_LEA = 223, I_LEAVE = 347, I_LES = 330, I_LFENCE = 4299,
	I_LFS = 917, I_LGDT = 1703, I_LGS = 922, I_LIDT = 1709, I_LLDT = 1668, I_LMSW = 1721,
	I_LODS = 313, I_LOOP = 421, I_LOOPNZ = 406, I_LOOPZ = 414, I_LSL = 527, I_LSS = 907,
	I_LTR = 1674, I_LZCNT = 4397, I_MASKMOVDQU = 7153, I_MASKMOVQ = 7143, I_MAXPD = 3593,
	I_MAXPS = 3586, I_MAXSD = 3607, I_MAXSS = 3600, I_MFENCE = 4325, I_MINPD = 3473,
	I_MINPS = 3466, I_MINSD = 3487, I_MINSS = 3480, I_MONITOR = 1771, I_MOV = 218,
	I_MOVAPD = 2493, I_MOVAPS = 2485, I_MOVBE = 9285, I_MOVD = 3954, I_MOVDDUP = 2220,
	I_MOVDQ2Q = 6556, I_MOVDQA = 3980, I_MOVDQU = 3988, I_MOVHLPS = 2185, I_MOVHPD = 2379,
	I_MOVHPS = 2371, I_MOVLHPS = 2362, I_MOVLPD = 2202, I_MOVLPS = 2194, I_MOVMSKPD = 2849,
	I_MOVMSKPS = 2839, I_MOVNTDQ = 6883, I_MOVNTDQA = 7929, I_MOVNTI = 952, I_MOVNTPD = 2590,
	I_MOVNTPS = 2581, I_MOVNTQ = 6875, I_MOVNTSD = 2608, I_MOVNTSS = 2599, I_MOVQ = 3960,
	I_MOVQ2DQ = 6547, I_MOVS = 295, I_MOVSD = 2144, I_MOVSHDUP = 2387, I_MOVSLDUP = 2210,
	I_MOVSS = 2137, I_MOVSX = 939, I_MOVSXD = 10039, I_MOVUPD = 2129, I_MOVUPS = 2121,
	I_MOVZX = 927, I_MPSADBW = 9662, I_MUL = 1641, I_MULPD = 3204, I_MULPS = 3197,
	I_MULSD = 3218, I_MULSS = 3211, I_MWAIT = 1780, I_NEG = 1636, I_NOP = 581,
	I_NOT = 1631, I_OR = 27, I_ORPD = 3087, I_ORPS = 3081, I_OUT = 451, I_OUTS = 128,
	I_PABSB = 7722, I_PABSD = 7752, I_PABSW = 7737, I_PACKSSDW = 3883, I_PACKSSWB = 3715,
	I_PACKUSDW = 7950, I_PACKUSWB = 3793, I_PADDB = 7238, I_PADDD = 7268, I_PADDQ = 6515,
	I_PADDSB = 6964, I_PADDSW = 6981, I_PADDUSB = 6654, I_PADDUSW = 6673, I_PADDW = 7253,
	I_PALIGNR = 9444, I_PAND = 6641, I_PANDN = 6699, I_PAUSE = 10047, I_PAVGB = 6714,
	I_PAVGUSB = 2112, I_PAVGW = 6759, I_PBLENDVB = 7633, I_PBLENDW = 9425, I_PCLMULQDQ = 9681,
	I_PCMPEQB = 4077, I_PCMPEQD = 4115, I_PCMPEQQ = 7910, I_PCMPEQW = 4096, I_PCMPESTRI = 9760,
	I_PCMPESTRM = 9737, I_PCMPGTB = 3736, I_PCMPGTD = 3774, I_PCMPGTQ = 8121,
	I_PCMPGTW = 3755, I_PCMPISTRI = 9806, I_PCMPISTRM = 9783, I_PEXTRB = 9463,
	I_PEXTRD = 9480, I_PEXTRQ = 9488, I_PEXTRW = 6345, I_PF2ID = 1948, I_PF2IW = 1941,
	I_PFACC = 2062, I_PFADD = 2011, I_PFCMPEQ = 2069, I_PFCMPGE = 1972, I_PFCMPGT = 2018,
	I_PFMAX = 2027, I_PFMIN = 1981, I_PFMUL = 2078, I_PFNACC = 1955, I_PFPNACC = 1963,
	I_PFRCP = 1988, I_PFRCPIT1 = 2034, I_PFRCPIT2 = 2085, I_PFRSQIT1 = 2044, I_PFRSQRT = 1995,
	I_PFSUB = 2004, I_PFSUBR = 2054, I_PHADDD = 7409, I_PHADDSW = 7426, I_PHADDW = 7392,
	I_PHMINPOSUW = 8293, I_PHSUBD = 7485, I_PHSUBSW = 7502, I_PHSUBW = 7468, I_PI2FD = 1934,
	I_PI2FW = 1927, I_PINSRB = 9564, I_PINSRD = 9602, I_PINSRQ = 9610, I_PINSRW = 6328,
	I_PMADDUBSW = 7445, I_PMADDWD = 7107, I_PMAXSB = 8208, I_PMAXSD = 8225, I_PMAXSW = 6998,
	I_PMAXUB = 6682, I_PMAXUD = 8259, I_PMAXUW = 8242, I_PMINSB = 8140, I_PMINSD = 8157,
	I_PMINSW = 6936, I_PMINUB = 6624, I_PMINUD = 8191, I_PMINUW = 8174, I_PMOVMSKB = 6565,
	I_PMOVSXBD = 7788, I_PMOVSXBQ = 7809, I_PMOVSXBW = 7767, I_PMOVSXDQ = 7872,
	I_PMOVSXWD = 7830, I_PMOVSXWQ = 7851, I_PMOVZXBD = 8016, I_PMOVZXBQ = 8037,
	I_PMOVZXBW = 7995, I_PMOVZXDQ = 8100, I_PMOVZXWD = 8058, I_PMOVZXWQ = 8079,
	I_PMULDQ = 7893, I_PMULHRSW = 7572, I_PMULHRW = 2095, I_PMULHUW = 6774, I_PMULHW = 6793,
	I_PMULLD = 8276, I_PMULLW = 6530, I_PMULUDQ = 7088, I_POP = 22, I_POPA = 98,
	I_POPCNT = 4372, I_POPF = 277, I_POR = 6953, I_PREFETCH = 1906, I_PREFETCHNTA = 2436,
	I_PREFETCHT0 = 2449, I_PREFETCHT1 = 2461, I_PREFETCHT2 = 2473, I_PREFETCHW = 1916,
	I_PSADBW = 7126, I_PSHUFB = 7375, I_PSHUFD = 4022, I_PSHUFHW = 4030, I_PSHUFLW = 4039,
	I_PSHUFW = 4014, I_PSIGNB = 7521, I_PSIGND = 7555, I_PSIGNW = 7538, I_PSLLD = 7058,
	I_PSLLDQ = 9881, I_PSLLQ = 7073, I_PSLLW = 7043, I_PSRAD = 6744, I_PSRAW = 6729,
	I_PSRLD = 6485, I_PSRLDQ = 9864, I_PSRLQ = 6500, I_PSRLW = 6470, I_PSUBB = 7178,
	I_PSUBD = 7208, I_PSUBQ = 7223, I_PSUBSB = 6902, I_PSUBSW = 6919, I_PSUBUSB = 6586,
	I_PSUBUSW = 6605, I_PSUBW = 7193, I_PSWAPD = 2104, I_PTEST = 7663, I_PUNPCKHBW = 3814,
	I_PUNPCKHDQ = 3860, I_PUNPCKHQDQ = 3929, I_PUNPCKHWD = 3837, I_PUNPCKLBW = 3646,
	I_PUNPCKLDQ = 3692, I_PUNPCKLQDQ = 3904, I_PUNPCKLWD = 3669, I_PUSH = 16,
	I_PUSHA = 91, I_PUSHF = 270, I_PXOR = 7015, I_RCL = 977, I_RCPPS = 2987, I_RCPSS = 2994,
	I_RCR = 982, I_RDFSBASE = 9916, I_RDGSBASE = 9946, I_RDMSR = 600, I_RDPMC = 607,
	I_RDRAND = 10060, I_RDTSC = 593, I_RDTSCP = 1898, I_RET = 325, I_RETF = 354,
	I_ROL = 967, I_ROR = 972, I_ROUNDPD = 9330, I_ROUNDPS = 9311, I_ROUNDSD = 9368,
	I_ROUNDSS = 9349, I_RSM = 882, I_RSQRTPS = 2949, I_RSQRTSS = 2958, I_SAHF = 283,
	I_SAL = 997, I_SALC = 394, I_SAR = 1002, I_SBB = 36, I_SCAS = 319, I_SETA = 807,
	I_SETAE = 780, I_SETB = 774, I_SETBE = 800, I_SETG = 859, I_SETGE = 845, I_SETL = 839,
	I_SETLE = 852, I_SETNO = 767, I_SETNP = 832, I_SETNS = 819, I_SETNZ = 793,
	I_SETO = 761, I_SETP = 826, I_SETS = 813, I_SETZ = 787, I_SFENCE = 4355, I_SGDT = 1691,
	I_SHL = 987, I_SHLD = 876, I_SHR = 992, I_SHRD = 892, I_SHUFPD = 6370, I_SHUFPS = 6362,
	I_SIDT = 1697, I_SKINIT = 1873, I_SLDT = 1657, I_SMSW = 1715, I_SQRTPD = 2889,
	I_SQRTPS = 2881, I_SQRTSD = 2905, I_SQRTSS = 2897, I_STAC = 1793, I_STC = 497,
	I_STD = 517, I_STGI = 1861, I_STI = 507, I_STMXCSR = 9985, I_STOS = 307, I_STR = 1663,
	I_SUB = 51, I_SUBPD = 3413, I_SUBPS = 3406, I_SUBSD = 3427, I_SUBSS = 3420,
	I_SWAPGS = 1890, I_SYSCALL = 532, I_SYSENTER = 614, I_SYSEXIT = 624, I_SYSRET = 547,
	I_TEST = 206, I_TZCNT = 4385, I_UCOMISD = 2776, I_UCOMISS = 2767, I_UD2 = 569,
	I_UNPCKHPD = 2330, I_UNPCKHPS = 2320, I_UNPCKLPD = 2288, I_UNPCKLPS = 2278,
	I_VADDPD = 3173, I_VADDPS = 3165, I_VADDSD = 3189, I_VADDSS = 3181, I_VADDSUBPD = 6448,
	I_VADDSUBPS = 6459, I_VAESDEC = 9251, I_VAESDECLAST = 9272, I_VAESENC = 9209,
	I_VAESENCLAST = 9230, I_VAESIMC = 9192, I_VAESKEYGENASSIST = 9846, I_VANDNPD = 3072,
	I_VANDNPS = 3063, I_VANDPD = 3039, I_VANDPS = 3031, I_VBLENDPD = 9415, I_VBLENDPS = 9396,
	I_VBLENDVPD = 9715, I_VBLENDVPS = 9704, I_VBROADCASTF128 = 7706, I_VBROADCASTSD = 7692,
	I_VBROADCASTSS = 7678, I_VCMPEQPD = 5122, I_VCMPEQPS = 4720, I_VCMPEQSD = 5926,
	I_VCMPEQSS = 5524, I_VCMPEQ_OSPD = 5303, I_VCMPEQ_OSPS = 4901, I_VCMPEQ_OSSD = 6107,
	I_VCMPEQ_OSSS = 5705, I_VCMPEQ_UQPD = 5209, I_VCMPEQ_UQPS = 4807, I_VCMPEQ_UQSD = 6013,
	I_VCMPEQ_UQSS = 5611, I_VCMPEQ_USPD = 5412, I_VCMPEQ_USPS = 5010, I_VCMPEQ_USSD = 6216,
	I_VCMPEQ_USSS = 5814, I_VCMPFALSEPD = 5244, I_VCMPFALSEPS = 4842, I_VCMPFALSESD = 6048,
	I_VCMPFALSESS = 5646, I_VCMPFALSE_OSPD = 5453, I_VCMPFALSE_OSPS = 5051, I_VCMPFALSE_OSSD = 6257,
	I_VCMPFALSE_OSSS = 5855, I_VCMPGEPD = 5271, I_VCMPGEPS = 4869, I_VCMPGESD = 6075,
	I_VCMPGESS = 5673, I_VCMPGE_OQPD = 5483, I_VCMPGE_OQPS = 5081, I_VCMPGE_OQSD = 6287,
	I_VCMPGE_OQSS = 5885, I_VCMPGTPD = 5281, I_VCMPGTPS = 4879, I_VCMPGTSD = 6085,
	I_VCMPGTSS = 5683, I_VCMPGT_OQPD = 5496, I_VCMPGT_OQPS = 5094, I_VCMPGT_OQSD = 6300,
	I_VCMPGT_OQSS = 5898, I_VCMPLEPD = 5142, I_VCMPLEPS = 4740, I_VCMPLESD = 5946,
	I_VCMPLESS = 5544, I_VCMPLE_OQPD = 5329, I_VCMPLE_OQPS = 4927, I_VCMPLE_OQSD = 6133,
	I_VCMPLE_OQSS = 5731, I_VCMPLTPD = 5132, I_VCMPLTPS = 4730, I_VCMPLTSD = 5936,
	I_VCMPLTSS = 5534, I_VCMPLT_OQPD = 5316, I_VCMPLT_OQPS = 4914, I_VCMPLT_OQSD = 6120,
	I_VCMPLT_OQSS = 5718, I_VCMPNEQPD = 5165, I_VCMPNEQPS = 4763, I_VCMPNEQSD = 5969,
	I_VCMPNEQSS = 5567, I_VCMPNEQ_OQPD = 5257, I_VCMPNEQ_OQPS = 4855, I_VCMPNEQ_OQSD = 6061,
	I_VCMPNEQ_OQSS = 5659, I_VCMPNEQ_OSPD = 5469, I_VCMPNEQ_OSPS = 5067, I_VCMPNEQ_OSSD = 6273,
	I_VCMPNEQ_OSSS = 5871, I_VCMPNEQ_USPD = 5357, I_VCMPNEQ_USPS = 4955, I_VCMPNEQ_USSD = 6161,
	I_VCMPNEQ_USSS = 5759, I_VCMPNGEPD = 5222, I_VCMPNGEPS = 4820, I_VCMPNGESD = 6026,
	I_VCMPNGESS = 5624, I_VCMPNGE_UQPD = 5425, I_VCMPNGE_UQPS = 5023, I_VCMPNGE_UQSD = 6229,
	I_VCMPNGE_UQSS = 5827, I_VCMPNGTPD = 5233, I_VCMPNGTPS = 4831, I_VCMPNGTSD = 6037,
	I_VCMPNGTSS = 5635, I_VCMPNGT_UQPD = 5439, I_VCMPNGT_UQPS = 5037, I_VCMPNGT_UQSD = 6243,
	I_VCMPNGT_UQSS = 5841, I_VCMPNLEPD = 5187, I_VCMPNLEPS = 4785, I_VCMPNLESD = 5991,
	I_VCMPNLESS = 5589, I_VCMPNLE_UQPD = 5385, I_VCMPNLE_UQPS = 4983, I_VCMPNLE_UQSD = 6189,
	I_VCMPNLE_UQSS = 5787, I_VCMPNLTPD = 5176, I_VCMPNLTPS = 4774, I_VCMPNLTSD = 5980,
	I_VCMPNLTSS = 5578, I_VCMPNLT_UQPD = 5371, I_VCMPNLT_UQPS = 4969, I_VCMPNLT_UQSD = 6175,
	I_VCMPNLT_UQSS = 5773, I_VCMPORDPD = 5198, I_VCMPORDPS = 4796, I_VCMPORDSD = 6002,
	I_VCMPORDSS = 5600, I_VCMPORD_SPD = 5399, I_VCMPORD_SPS = 4997, I_VCMPORD_SSD = 6203,
	I_VCMPORD_SSS = 5801, I_VCMPTRUEPD = 5291, I_VCMPTRUEPS = 4889, I_VCMPTRUESD = 6095,
	I_VCMPTRUESS = 5693, I_VCMPTRUE_USPD = 5509, I_VCMPTRUE_USPS = 5107, I_VCMPTRUE_USSD = 6313,
	I_VCMPTRUE_USSS = 5911, I_VCMPUNORDPD = 5152, I_VCMPUNORDPS = 4750, I_VCMPUNORDSD = 5956,
	I_VCMPUNORDSS = 5554, I_VCMPUNORD_SPD = 5342, I_VCMPUNORD_SPS = 4940, I_VCMPUNORD_SSD = 6146,
	I_VCMPUNORD_SSS = 5744, I_VCOMISD = 2830, I_VCOMISS = 2821, I_VCVTDQ2PD = 6853,
	I_VCVTDQ2PS = 3372, I_VCVTPD2DQ = 6864, I_VCVTPD2PS = 3308, I_VCVTPS2DQ = 3383,
	I_VCVTPS2PD = 3297, I_VCVTSD2SI = 2756, I_VCVTSD2SS = 3330, I_VCVTSI2SD = 2570,
	I_VCVTSI2SS = 2559, I_VCVTSS2SD = 3319, I_VCVTSS2SI = 2745, I_VCVTTPD2DQ = 6841,
	I_VCVTTPS2DQ = 3394, I_VCVTTSD2SI = 2693, I_VCVTTSS2SI = 2681, I_VDIVPD = 3562,
	I_VDIVPS = 3554, I_VDIVSD = 3578, I_VDIVSS = 3570, I_VDPPD = 9655, I_VDPPS = 9642,
	I_VERR = 1679, I_VERW = 1685, I_VEXTRACTF128 = 9550, I_VEXTRACTPS = 9525,
	I_VFMADD132PD = 8421, I_VFMADD132PS = 8408, I_VFMADD132SD = 8447, I_VFMADD132SS = 8434,
	I_VFMADD213PD = 8701, I_VFMADD213PS = 8688, I_VFMADD213SD = 8727, I_VFMADD213SS = 8714,
	I_VFMADD231PD = 8981, I_VFMADD231PS = 8968, I_VFMADD231SD = 9007, I_VFMADD231SS = 8994,
	I_VFMADDSUB132PD = 8360, I_VFMADDSUB132PS = 8344, I_VFMADDSUB213PD = 8640,
	I_VFMADDSUB213PS = 8624, I_VFMADDSUB231PD = 8920, I_VFMADDSUB231PS = 8904,
	I_VFMSUB132PD = 8473, I_VFMSUB132PS = 8460, I_VFMSUB132SD = 8499, I_VFMSUB132SS = 8486,
	I_VFMSUB213PD = 8753, I_VFMSUB213PS = 8740, I_VFMSUB213SD = 8779, I_VFMSUB213SS = 8766,
	I_VFMSUB231PD = 9033, I_VFMSUB231PS = 9020, I_VFMSUB231SD = 9059, I_VFMSUB231SS = 9046,
	I_VFMSUBADD132PD = 8392, I_VFMSUBADD132PS = 8376, I_VFMSUBADD213PD = 8672,
	I_VFMSUBADD213PS = 8656, I_VFMSUBADD231PD = 8952, I_VFMSUBADD231PS = 8936,
	I_VFNMADD132PD = 8526, I_VFNMADD132PS = 8512, I_VFNMADD132SD = 8554, I_VFNMADD132SS = 8540,
	I_VFNMADD213PD = 8806, I_VFNMADD213PS = 8792, I_VFNMADD213SD = 8834, I_VFNMADD213SS = 8820,
	I_VFNMADD231PD = 9086, I_VFNMADD231PS = 9072, I_VFNMADD231SD = 9114, I_VFNMADD231SS = 9100,
	I_VFNMSUB132PD = 8582, I_VFNMSUB132PS = 8568, I_VFNMSUB132SD = 8610, I_VFNMSUB132SS = 8596,
	I_VFNMSUB213PD = 8862, I_VFNMSUB213PS = 8848, I_VFNMSUB213SD = 8890, I_VFNMSUB213SS = 8876,
	I_VFNMSUB231PD = 9142, I_VFNMSUB231PS = 9128, I_VFNMSUB231SD = 9170, I_VFNMSUB231SS = 9156,
	I_VHADDPD = 4231, I_VHADDPS = 4240, I_VHSUBPD = 4265, I_VHSUBPS = 4274, I_VINSERTF128 = 9537,
	I_VINSERTPS = 9591, I_VLDDQU = 7035, I_VLDMXCSR = 9975, I_VMASKMOVDQU = 7165,
	I_VMASKMOVPD = 7983, I_VMASKMOVPS = 7971, I_VMAXPD = 3622, I_VMAXPS = 3614,
	I_VMAXSD = 3638, I_VMAXSS = 3630, I_VMCALL = 1735, I_VMCLEAR = 10023, I_VMFUNC = 1815,
	I_VMINPD = 3502, I_VMINPS = 3494, I_VMINSD = 3518, I_VMINSS = 3510, I_VMLAUNCH = 1743,
	I_VMLOAD = 1845, I_VMMCALL = 1836, I_VMOVAPD = 2510, I_VMOVAPS = 2501, I_VMOVD = 3966,
	I_VMOVDDUP = 2268, I_VMOVDQA = 3996, I_VMOVDQU = 4005, I_VMOVHLPS = 2229,
	I_VMOVHPD = 2416, I_VMOVHPS = 2407, I_VMOVLHPS = 2397, I_VMOVLPD = 2248, I_VMOVLPS = 2239,
	I_VMOVMSKPD = 2870, I_VMOVMSKPS = 2859, I_VMOVNTDQ = 6892, I_VMOVNTDQA = 7939,
	I_VMOVNTPD = 2627, I_VMOVNTPS = 2617, I_VMOVQ = 3973, I_VMOVSD = 2177, I_VMOVSHDUP = 2425,
	I_VMOVSLDUP = 2257, I_VMOVSS = 2169, I_VMOVUPD = 2160, I_VMOVUPS = 2151, I_VMPSADBW = 9671,
	I_VMPTRLD = 10014, I_VMPTRST = 6419, I_VMREAD = 4162, I_VMRESUME = 1753, I_VMRUN = 1829,
	I_VMSAVE = 1853, I_VMULPD = 3233, I_VMULPS = 3225, I_VMULSD = 3249, I_VMULSS = 3241,
	I_VMWRITE = 4186, I_VMXOFF = 1763, I_VMXON = 10032, I_VORPD = 3100, I_VORPS = 3093,
	I_VPABSB = 7729, I_VPABSD = 7759, I_VPABSW = 7744, I_VPACKSSDW = 3893, I_VPACKSSWB = 3725,
	I_VPACKUSDW = 7960, I_VPACKUSWB = 3803, I_VPADDB = 7245, I_VPADDD = 7275,
	I_VPADDQ = 6522, I_VPADDSB = 6972, I_VPADDSW = 6989, I_VPADDUSW = 6663, I_VPADDW = 7260,
	I_VPALIGNR = 9453, I_VPAND = 6647, I_VPANDN = 6706, I_VPAVGB = 6721, I_VPAVGW = 6766,
	I_VPBLENDVB = 9726, I_VPBLENDW = 9434, I_VPCLMULQDQ = 9692, I_VPCMPEQB = 4086,
	I_VPCMPEQD = 4124, I_VPCMPEQQ = 7919, I_VPCMPEQW = 4105, I_VPCMPESTRI = 9771,
	I_VPCMPESTRM = 9748, I_VPCMPGTB = 3745, I_VPCMPGTD = 3783, I_VPCMPGTQ = 8130,
	I_VPCMPGTW = 3764, I_VPCMPISTRI = 9817, I_VPCMPISTRM = 9794, I_VPERM2F128 = 9299,
	I_VPERMILPD = 7604, I_VPERMILPS = 7593, I_VPEXTRB = 9471, I_VPEXTRD = 9496,
	I_VPEXTRQ = 9505, I_VPEXTRW = 6353, I_VPHADDD = 7417, I_VPHADDSW = 7435, I_VPHADDW = 7400,
	I_VPHMINPOSUW = 8305, I_VPHSUBD = 7493, I_VPHSUBSW = 7511, I_VPHSUBW = 7476,
	I_VPINSRB = 9572, I_VPINSRD = 9618, I_VPINSRQ = 9627, I_VPINSRW = 6336, I_VPMADDUBSW = 7456,
	I_VPMADDWD = 7116, I_VPMAXSB = 8216, I_VPMAXSD = 8233, I_VPMAXSW = 7006, I_VPMAXUB = 6690,
	I_VPMAXUD = 8267, I_VPMAXUW = 8250, I_VPMINSB = 8148, I_VPMINSD = 8165, I_VPMINSW = 6944,
	I_VPMINUB = 6632, I_VPMINUD = 8199, I_VPMINUW = 8182, I_VPMOVMSKB = 6575,
	I_VPMOVSXBD = 7798, I_VPMOVSXBQ = 7819, I_VPMOVSXBW = 7777, I_VPMOVSXDQ = 7882,
	I_VPMOVSXWD = 7840, I_VPMOVSXWQ = 7861, I_VPMOVZXBD = 8026, I_VPMOVZXBQ = 8047,
	I_VPMOVZXBW = 8005, I_VPMOVZXDQ = 8110, I_VPMOVZXWD = 8068, I_VPMOVZXWQ = 8089,
	I_VPMULDQ = 7901, I_VPMULHRSW = 7582, I_VPMULHUW = 6783, I_VPMULHW = 6801,
	I_VPMULLD = 8284, I_VPMULLW = 6538, I_VPMULUDQ = 7097, I_VPOR = 6958, I_VPSADBW = 7134,
	I_VPSHUFB = 7383, I_VPSHUFD = 4048, I_VPSHUFHW = 4057, I_VPSHUFLW = 4067,
	I_VPSIGNB = 7529, I_VPSIGND = 7563, I_VPSIGNW = 7546, I_VPSLLD = 7065, I_VPSLLDQ = 9889,
	I_VPSLLQ = 7080, I_VPSLLW = 7050, I_VPSRAD = 6751, I_VPSRAW = 6736, I_VPSRLD = 6492,
	I_VPSRLDQ = 9872, I_VPSRLQ = 6507, I_VPSRLW = 6477, I_VPSUBB = 7185, I_VPSUBD = 7215,
	I_VPSUBQ = 7230, I_VPSUBSB = 6910, I_VPSUBSW = 6927, I_VPSUBUSB = 6595, I_VPSUBUSW = 6614,
	I_VPSUBW = 7200, I_VPTEST = 7670, I_VPUNPCKHBW = 3825, I_VPUNPCKHDQ = 3871,
	I_VPUNPCKHQDQ = 3941, I_VPUNPCKHWD = 3848, I_VPUNPCKLBW = 3657, I_VPUNPCKLDQ = 3703,
	I_VPUNPCKLQDQ = 3916, I_VPUNPCKLWD = 3680, I_VPXOR = 7021, I_VRCPPS = 3001,
	I_VRCPSS = 3009, I_VROUNDPD = 9339, I_VROUNDPS = 9320, I_VROUNDSD = 9377,
	I_VROUNDSS = 9358, I_VRSQRTPS = 2967, I_VRSQRTSS = 2977, I_VSHUFPD = 6387,
	I_VSHUFPS = 6378, I_VSQRTPD = 2922, I_VSQRTPS = 2913, I_VSQRTSD = 2940, I_VSQRTSS = 2931,
	I_VSTMXCSR = 10004, I_VSUBPD = 3442, I_VSUBPS = 3434, I_VSUBSD = 3458, I_VSUBSS = 3450,
	I_VTESTPD = 7624, I_VTESTPS = 7615, I_VUCOMISD = 2795, I_VUCOMISS = 2785,
	I_VUNPCKHPD = 2351, I_VUNPCKHPS = 2340, I_VUNPCKLPD = 2309, I_VUNPCKLPS = 2298,
	I_VXORPD = 3129, I_VXORPS = 3121, I_VZEROALL = 4152, I_VZEROUPPER = 4140,
	I_WAIT = 10054, I_WBINVD = 561, I_WRFSBASE = 9965, I_WRGSBASE = 9994, I_WRMSR = 586,
	I_XABORT = 1007, I_XADD = 946, I_XBEGIN = 1015, I_XCHG = 212, I_XEND = 1823,
	I_XGETBV = 1799, I_XLAT = 400, I_XOR = 61, I_XORPD = 3114, I_XORPS = 3107,
	I_XRSTOR = 4307, I_XRSTOR64 = 4315, I_XSAVE = 4283, I_XSAVE64 = 4290, I_XSAVEOPT = 4333,
	I_XSAVEOPT64 = 4343, I_XSETBV = 1807, I__3DNOW = 10068
} _InstructionType;

typedef enum {
	R_RAX, R_RCX, R_RDX, R_RBX, R_RSP, R_RBP, R_RSI, R_RDI, R_R8, R_R9, R_R10, R_R11, R_R12, R_R13, R_R14, R_R15,
	R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI, R_R8D, R_R9D, R_R10D, R_R11D, R_R12D, R_R13D, R_R14D, R_R15D,
	R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI, R_R8W, R_R9W, R_R10W, R_R11W, R_R12W, R_R13W, R_R14W, R_R15W,
	R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH, R_R8B, R_R9B, R_R10B, R_R11B, R_R12B, R_R13B, R_R14B, R_R15B,
	R_SPL, R_BPL, R_SIL, R_DIL,
	R_ES, R_CS, R_SS, R_DS, R_FS, R_GS,
	R_RIP,
	R_ST0, R_ST1, R_ST2, R_ST3, R_ST4, R_ST5, R_ST6, R_ST7,
	R_MM0, R_MM1, R_MM2, R_MM3, R_MM4, R_MM5, R_MM6, R_MM7,
	R_XMM0, R_XMM1, R_XMM2, R_XMM3, R_XMM4, R_XMM5, R_XMM6, R_XMM7, R_XMM8, R_XMM9, R_XMM10, R_XMM11, R_XMM12, R_XMM13, R_XMM14, R_XMM15,
	R_YMM0, R_YMM1, R_YMM2, R_YMM3, R_YMM4, R_YMM5, R_YMM6, R_YMM7, R_YMM8, R_YMM9, R_YMM10, R_YMM11, R_YMM12, R_YMM13, R_YMM14, R_YMM15,
	R_CR0, R_UNUSED0, R_CR2, R_CR3, R_CR4, R_UNUSED1, R_UNUSED2, R_UNUSED3, R_CR8,
	R_DR0, R_DR1, R_DR2, R_DR3, R_UNUSED4, R_UNUSED5, R_DR6, R_DR7
} _RegisterType;

#endif /* MNEMONICS_H */

```

`NativeCore/Dependencies/distorm/src/config.h`:

```h
/*
config.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef CONFIG_H
#define CONFIG_H

/* diStorm version number. */
#define __DISTORMV__ 0x030502

#include <string.h> /* memset, memcpy - can be easily self implemented for libc independency. */

#include "../include/distorm.h"


/*
 * 64 bit offsets support:
 * This macro should be defined from compiler command line flags, e.g: -DSUPPORT_64BIT_OFFSET
 * Note: make sure that the caller (library user) defines it too!
 */
/* #define SUPPORT_64BIT_OFFSET */

/*
 * If you compile diStorm as a dynamic library (.dll or .so) file, make sure you uncomment the next line.
 * So the interface functions will be exported, otherwise they are useable only for static library.
 * For example, this macro is being set for compiling diStorm as a .dll for Python with CTypes.
 */
/* #define DISTORM_DYNAMIC */

/*
 * If DISTORM_LIGHT is defined, everything involved in formatting the instructions
 * as text will be excluded from compilation.
 * distorm_decode(..) and distorm_format(..) will not be available.
 * This will decrease the size of the executable and leave you with decomposition functionality only.
 *
 * Note: it should be either set in the preprocessor definitions manually or in command line -D switch.
 * #define DISTORM_LIGHT
 */

/*
 * diStorm now supports little/big endian CPU's.
 * It should detect the endianness according to predefined macro's of the compiler.
 * If you don't use GCC/MSVC you will have to define it on your own.
 */

/* These macros are used in order to make the code portable. */
#ifdef __GNUC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
/* Keep inline as static (arrrrg) as it would break linux on some flavors otherwise. */
#define _INLINE_ static
/* GCC ignores this directive... */
/*#define _FASTCALL_ __attribute__((__fastcall__))*/

/* Set endianity (supposed to be LE though): */
#ifdef __BIG_ENDIAN__
	#define BE_SYSTEM
#endif

/* End of __GCC__ */

#elif __WATCOMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __WATCOMC__ */

#elif __DMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __DMC__ */

#elif __TINYC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ static

/* End of __TINYC__ */

#elif _MSC_VER

/* stdint alternative is defined in distorm.h */

#define _DLLEXPORT_ __declspec(dllexport)
#define _FASTCALL_ __fastcall
#define _INLINE_ __inline

/* Set endianity (supposed to be LE though): */
#if !defined(_M_IX86) && !defined(_M_X64)
	#define BE_SYSTEM
#endif

#endif /* #elif _MSC_VER */

/* If the library isn't compiled as a dynamic library don't export any functions. */
#ifndef DISTORM_DYNAMIC
#undef _DLLEXPORT_
#define _DLLEXPORT_
#endif

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

/* Define stream read functions for big endian systems. */
#ifdef BE_SYSTEM

/* Avoid defining 'static static' for GCC. */
#ifndef __GNUC__
#define STATIC_INLINE static _INLINE_
#else
#define STATIC_INLINE static
#endif

/*
 * Assumption: These functions can read from the stream safely!
 * Swap endianity of input to little endian.
 */
STATIC_INLINE int16_t RSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
STATIC_INLINE uint16_t RUSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
STATIC_INLINE int32_t RLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
STATIC_INLINE uint32_t RULONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
STATIC_INLINE int64_t RLLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
STATIC_INLINE uint64_t RULLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}

#undef STATIC_INLINE

#else
/* Little endian macro's will just make the cast. */
#define RSHORT(x) *(int16_t *)x
#define RUSHORT(x) *(uint16_t *)x
#define RLONG(x) *(int32_t *)x
#define RULONG(x) *(uint32_t *)x
#define RLLONG(x) *(int64_t *)x
#define RULLONG(x) *(uint64_t *)x
#endif

#endif /* CONFIG_H */

```

`NativeCore/Dependencies/distorm/src/decoder.c`:

```c
/*
decoder.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "decoder.h"
#include "instructions.h"
#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "operands.h"
#include "insts.h"
#include "../include/mnemonics.h"


/* Instruction Prefixes - Opcode - ModR/M - SIB - Displacement - Immediate */

static _DecodeType decode_get_effective_addr_size(_DecodeType dt, _iflags decodedPrefixes)
{
	/*
	 * Map from the current decoding mode to an effective address size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode32
	 */

	/* Switch to non default mode if prefix exists, only for ADDRESS SIZE. */
	if (decodedPrefixes & INST_PRE_ADDR_SIZE) {
		if (dt == Decode32Bits) return Decode16Bits;
		return Decode32Bits;
	}
	return dt;
}

static _DecodeType decode_get_effective_op_size(_DecodeType dt, _iflags decodedPrefixes, unsigned int rex, _iflags instFlags)
{
	/*
	 * Map from the current decoding mode to an effective operand size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode16
	 * Not that in 64bits it's a bit more complicated, because of REX and promoted instructions.
	 */

	if (decodedPrefixes & INST_PRE_OP_SIZE) {
		if (dt == Decode16Bits) return Decode32Bits;
		return Decode16Bits;
	}

	if (dt == Decode64Bits) {
		/*
		 * REX Prefix toggles data size to 64 bits.
		 * Operand size prefix toggles data size to 16.
		 * Default data size is 32 bits.
		 * Promoted instructions are 64 bits if they don't require a REX perfix.
		 * Non promoted instructions are 64 bits if the REX prefix exists.
		 */
		/* Automatically promoted instructions have only INST_64BITS SET! */
		if (((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS) ||
		/* Other instructions in 64 bits can be promoted only with a REX prefix. */
			((decodedPrefixes & INST_PRE_REX) && (rex & PREFIX_EX_W))) return Decode64Bits;
		return Decode32Bits; /* Default. */
	}

	return dt;
}

/*
 * A helper macro to convert from diStorm's CPU flags to EFLAGS.
 * Copy eflags from compact version (8 bits) to eflags compatible (16 bits).
 * From D_COMPACT_IF to D_IF, bit index 1 to 9.
 * From D_COMPACT_DF to D_DF, bit index 3 to 10.
 * From D_COMPACT_OF to D_OF, bit index 5 to 11.
 */
#define CONVERT_FLAGS_TO_EFLAGS(dst, src, field) dst->field = ((src->field & D_COMPACT_SAME_FLAGS) | \
	((src->field & D_COMPACT_IF) << (9 - 1)) | \
	((src->field & D_COMPACT_DF) << (10 - 3)) | \
	((src->field & D_COMPACT_OF) << (11 - 5)));

/* If DECRES_SUCCESS is returned, CI is in sync, otherwise it loses sync. */
/* Important note: CI is keeping track only for code and codeLen, in case of a failure caller has to restart on their own. */
static _DecodeResult decode_inst(_CodeInfo* ci, _PrefixState* ps, const uint8_t* startCode, _DInst* di)
{
	/* Holds the info about the current found instruction. */
	_InstInfo* ii;
	_InstSharedInfo* isi;

	/* Calculate (and cache) effective-operand-size and effective-address-size only once. */
	_DecodeType effOpSz, effAdrSz;
	_iflags instFlags;

	/* The ModR/M byte of the current instruction. */
	unsigned int modrm = 0;
	int isPrefixed = 0;

	ii = inst_lookup(ci, ps, &isPrefixed);
	if (ii == NULL) goto _Undecodable;

	isi = &InstSharedInfoTable[ii->sharedIndex];
	instFlags = FlagsTable[isi->flagsIndex];

	/* Cache the effective operand-size and address-size. */
	if (isPrefixed) {

		/*
		* If both REX and OpSize are available we will have to disable the OpSize, because REX has precedence.
		* However, only if REX.W is set!
		* We had to wait with this test, since the operand size may be a mandatory prefix,
		* and we know it only after fetching opcode.
		*/
		if ((ps->decodedPrefixes & INST_PRE_OP_SIZE) &&
			(ps->prefixExtType == PET_REX) &&
			(ps->vrex & PREFIX_EX_W) &&
			(!ps->isOpSizeMandatory)) {
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
			prefixes_ignore(ps, PFXIDX_OP_SIZE);
		}

		effAdrSz = decode_get_effective_addr_size(ci->dt, ps->decodedPrefixes);
		effOpSz = decode_get_effective_op_size(ci->dt, ps->decodedPrefixes, ps->vrex, instFlags);
	}
	else
	{
		effAdrSz = ci->dt; /* Default is current decoding type since there's no prefix. */
		effOpSz = decode_get_effective_op_size(ci->dt, 0, 0, instFlags);
	}

	/*
	 * In this point we know the instruction we are about to decode and its operands (unless, it's an invalid one!),
	 * so it makes it the right time for decoding-type suitability testing.
	 * Which practically means, don't allow 32 bits instructions in 16 bits decoding mode, but do allow
	 * 16 bits instructions in 32 bits decoding mode, of course...

	 * NOTE: Make sure the instruction set for 32 bits has explicitly this specific flag set.
	 * NOTE2: Make sure the instruction set for 64 bits has explicitly this specific flag set.

	 * If this is the case, drop what we've got and restart all over after DB'ing that byte.

	 * Though, don't drop an instruction which is also supported in 16 and 32 bits.
	 */

	 /* ! ! ! DISABLED UNTIL FURTHER NOTICE ! ! ! Decode16Bits CAN NOW DECODE 32 BITS INSTRUCTIONS ! ! !*/
	 /* if (ii && (dt == Decode16Bits) && (instFlags & INST_32BITS) && (~instFlags & INST_16BITS)) ii = NULL; */

	memset(di, 0, sizeof(_DInst));

	if (instFlags & INST_MODRM_REQUIRED) {
		/* If the ModRM byte is not part of the opcode, skip the last byte code, so code points now to ModRM. */
		if (!(instFlags & INST_MODRM_INCLUDED)) {
			ci->code++;
			if (--ci->codeLen < 0) goto _Undecodable;
		}
		modrm = *ci->code;
	}

	ci->code++; /* Skip the last byte we just read (either last opcode's byte code or a ModRM). */

	di->addr = ci->codeOffset & ci->addrMask;
	di->opcode = ii->opcodeId;
	di->flags = isi->meta & META_INST_PRIVILEGED;

	/*
	 * Store the address size inside the flags.
	 * This is necessary for the caller to know the size of rSP when using PUSHA for example.
	 */
	di->base = R_NONE;
	di->segment = R_NONE;

	FLAG_SET_ADDRSIZE(di, effAdrSz);

	/* Try to extract the next operand only if the latter exists. */
	if (isi->d != OT_NONE) {
		unsigned int opsNo = 1;
		_Operand* op = &di->ops[0];
		if (instFlags & (INST_MODRR_REQUIRED | INST_FORCE_REG0)) {
			/* Some instructions enforce that mod=11, so validate that. */
			if ((modrm < INST_DIVIDED_MODRM) && (instFlags & INST_MODRR_REQUIRED)) goto _Undecodable;
			/* Some instructions enforce that reg=000, so validate that. (Specifically EXTRQ). */
			if ((instFlags & INST_FORCE_REG0) && (((modrm >> 3) & 7) != 0)) goto _Undecodable;
		}
		if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->d, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;

		if (isi->s != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->s, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
			opsNo++;
			/* Use third operand, only if the flags says this InstInfo requires it. */
			if (instFlags & INST_USE_OP3) {
				if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op3, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
				opsNo++;
				/* Support for a fourth operand is added for (e.g:) INSERTQ instruction. */
				if (instFlags & INST_USE_OP4) {
					if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op4, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
					opsNo++;
				}
			}
		}

		/* Copy DST_WR flag. */
		di->flags |= (instFlags & INST_DST_WR) >> (31 - 6); /* Copy bit from INST_DST_WR (bit 31) to FLAG_DST_WR (bit 6). */
		/* operands_extract may touched it for FPU operands, so add on top. */
		di->opsNo += (uint8_t)opsNo;
	}

	if (instFlags & (INST_3DNOW_FETCH |
		INST_PSEUDO_OPCODE |
		INST_NATIVE |
		INST_PRE_REPNZ |
		INST_PRE_REP |
		INST_PRE_ADDR_SIZE |
		INST_INVALID_64BITS |
		INST_64BITS_FETCH)) { /* 8 for 1! */

		/* If it's a native instruction copy OpSize Prefix. */
		if (ps && instFlags & INST_NATIVE) ps->usedPrefixes |= (ps->decodedPrefixes & INST_PRE_OP_SIZE);

		if (ci->dt != Decode64Bits) {
			/* If it's only a 64 bits instruction drop it in other decoding modes. */
			if (instFlags & INST_64BITS_FETCH) goto _Undecodable;
		}
		else {
			/* Drop instructions which are invalid in 64 bits. */
			if (instFlags & INST_INVALID_64BITS) goto _Undecodable;
		}

		/* If it were a 3DNow! instruction, we will have to find the instruction itself now that we got its operands extracted. */
		if (instFlags & INST_3DNOW_FETCH) {
			ii = inst_lookup_3dnow(ci);
			if (ii == NULL) goto _Undecodable;
			isi = &InstSharedInfoTable[ii->sharedIndex];
			instFlags = FlagsTable[isi->flagsIndex];
			di->opcode = ii->opcodeId;
		}

		/* Check whether pseudo opcode is needed, only for CMP instructions: */
		if (instFlags & INST_PSEUDO_OPCODE) {
			/* Used only for special CMP instructions which have pseudo opcodes suffix. */
			unsigned int cmpType;

			if (--ci->codeLen < 0) goto _Undecodable;
			cmpType = *ci->code;
			ci->code++;

			/*
			 * The opcodeId is the offset to the FIRST pseudo compare mnemonic,
			 * we will have to fix it so it offsets into the corrected mnemonic.
			 * Therefore, we use another table to fix the offset.
			 */
			if (instFlags & INST_PRE_VEX) {
				/* AVX Comparison type must be between 0 to 32, otherwise Reserved. */
				if (cmpType >= INST_VCMP_MAX_RANGE) goto _Undecodable;

				/* Use the AVX pseudo compare mnemonics table. */
				di->opcode = ii->opcodeId + VCmpMnemonicOffsets[cmpType];
			}
			else {
				/* SSE Comparison type must be between 0 to 8, otherwise Reserved. */
				if (cmpType >= INST_CMP_MAX_RANGE) goto _Undecodable;
				di->opcode = ii->opcodeId + CmpMnemonicOffsets[cmpType];
			}

			goto _SkipOpcoding;
		}

		/* Start with prefix REP/N/Z. */
		if (isPrefixed && (instFlags & (INST_PRE_REPNZ | INST_PRE_REP))) {
			if ((instFlags & INST_PRE_REPNZ) && (ps->decodedPrefixes & INST_PRE_REPNZ)) {
				ps->usedPrefixes |= INST_PRE_REPNZ;
				di->flags |= FLAG_REPNZ;
			}
			else if ((instFlags & INST_PRE_REP) && (ps->decodedPrefixes & INST_PRE_REP)) {
				ps->usedPrefixes |= INST_PRE_REP;
				di->flags |= FLAG_REP;
			}
		}

		if (instFlags & INST_PRE_ADDR_SIZE) {
			/* If it's JeCXZ the ADDR_SIZE prefix affects them. */
			if (instFlags & INST_USE_EXMNEMONIC) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				if (effAdrSz == Decode16Bits) di->opcode = ii->opcodeId;
				else if (effAdrSz == Decode32Bits) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
				/* Ignore REX.W in 64bits, JECXZ is promoted. */
				else /* Decode64Bits */ di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			}

			/* LOOPxx instructions are also native instruction, but they are special case ones, ADDR_SIZE prefix affects them. */
			else if (instFlags & INST_NATIVE) {
				di->opcode = ii->opcodeId;

				/* If LOOPxx gets here from 64bits, it must be Decode32Bits because Address Size prefix is set. */
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
			}

			goto _SkipOpcoding;
		}
	}

	/*
	 * If we reached here the instruction was fully decoded, we located the instruction in the DB and extracted operands.
	 * Use the correct mnemonic according to the DT.
	 * If we are in 32 bits decoding mode it doesn't necessarily mean we will choose mnemonic2, alas,
	 * it means that if there is a mnemonic2, it will be used.
	 * Note:
	 * If the instruction is prefixed by operand size we will format it in the non-default decoding mode!
	 * So there might be a situation that an instruction of 32 bit gets formatted in 16 bits decoding mode.
	 * Both ways should end up with a correct and expected formatting of the text.
	 */
	if (effOpSz == Decode32Bits) { /* Decode32Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode32Bits);

		/* Give a chance for special mnemonic instruction in 32 bits decoding. */
		if (instFlags & INST_USE_EXMNEMONIC) {
			/* Is it a special instruction which has another mnemonic for mod=11 ? */
			if (instFlags & INST_MNEMONIC_MODRM_BASED) {
				if (modrm < INST_DIVIDED_MODRM) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			}
			else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
		}
	}
	else if (effOpSz == Decode64Bits) { /* Decode64Bits, note that some instructions might be decoded in Decode32Bits above. */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode64Bits);

		if (instFlags & (INST_USE_EXMNEMONIC | INST_USE_EXMNEMONIC2)) {
			/*
			 * We shouldn't be here for MODRM based mnemonics with a MOD=11,
			 * because they must not use REX (otherwise it will get to the wrong instruction which share same opcode).
			 * See XRSTOR and XSAVEOPT.
			 */
			if ((modrm >= INST_DIVIDED_MODRM) && (instFlags & INST_MNEMONIC_MODRM_BASED)) goto _Undecodable;

			/* Use third mnemonic, for 64 bits. */
			if ((instFlags & INST_USE_EXMNEMONIC2) && (ps->vrex & PREFIX_EX_W)) {
				ps->usedPrefixes |= INST_PRE_REX;
				di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			}
			else di->opcode = ((_InstInfoEx*)ii)->opcodeId2; /* Use second mnemonic. */
		}
	}
	else { /* Decode16Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode16Bits);

		/*
		 * If it's a special instruction which has two mnemonics, then use the 16 bits one + update usedPrefixes.
		 * Note: use 16 bits mnemonic if that instruction supports 32 bit or 64 bit explicitly.
		 */
		if ((instFlags & (INST_USE_EXMNEMONIC | INST_32BITS | INST_64BITS)) == INST_USE_EXMNEMONIC) ps->usedPrefixes |= INST_PRE_OP_SIZE;
	}

_SkipOpcoding:

	/* Check VEX mnemonics: */
	if (isPrefixed && (instFlags & INST_PRE_VEX) &&
		(((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXW_BASED) && (ps->vrex & PREFIX_EX_W)) ||
			((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXL_BASED) && (ps->vrex & PREFIX_EX_L)))) {
		di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
	}

	/* Instruction's size should include prefixes too if exist. */
	di->size = (uint8_t)(ci->code - startCode);
	/*
	 * There's a limit of 15 bytes on instruction length. The only way to violate
	 * this limit is by putting redundant prefixes before an instruction.
	 * start points to first prefix if any, otherwise it points to instruction first byte.
	 */
	if (di->size > INST_MAXIMUM_SIZE) goto _Undecodable;

	/* Set the unused prefixes mask, if any prefixes (not) used at all. */
	if (isPrefixed) di->unusedPrefixesMask = prefixes_set_unused_mask(ps);

	/* Copy instruction meta. */
	di->meta = isi->meta;

	if (ci->features & DF_FILL_EFLAGS) {
		/* Copy CPU affected flags. */
		if (isi->testedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, testedFlagsMask);
		if (isi->modifiedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, modifiedFlagsMask);
		if (isi->undefinedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, undefinedFlagsMask);
	}

	/*
	 * Instruction can still be invalid if it's total length is over 15 bytes with prefixes.
	 * Up to the caller to check that.
	 */
	return DECRES_SUCCESS;

_Undecodable: /* If the instruction couldn't be decoded for some reason, fail. */
	/* Special case for WAIT instruction: If it's dropped as a prefix, we have to return a valid instruction! */
	if (*startCode == INST_WAIT_INDEX) {
		int delta;
		memset(di, 0, sizeof(_DInst));
		di->addr = ci->codeOffset & ci->addrMask;
		di->imm.byte = INST_WAIT_INDEX;
		di->segment = R_NONE;
		di->base = R_NONE;
		di->size = 1;
		di->opcode = I_WAIT;
		META_SET_ISC(di, ISC_INTEGER);

		/* Fix ci because WAIT could be a prefix that failed, and ci->code is now out of sync. */
		delta = (int)(ci->code - startCode); /* How many bytes we read so far. */
		ci->codeLen += delta - 1;
		ci->code = startCode + 1;
		/* codeOffset is fixed outside. */

		return DECRES_SUCCESS;
	}

	/* Mark that we didn't manage to decode the instruction well, caller will drop it. */
	return DECRES_INPUTERR;
}

/*
 * decode_internal
 *
 * supportOldIntr - Since now we work with new structure instead of the old _DecodedInst, we are still interested in backward compatibility.
 *                  So although, the array is now of type _DInst, we want to read it in jumps of the old array element's size.
 *                  This is in order to save memory allocation for conversion between the new and the old structures.
 *                  It really means we can do the conversion in-place now.
 */
_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount)
{
	_CodeInfo ci = *_ci; /* A working copy, we don't touch user's _ci except OUT params. */
	_PrefixState ps;
	/* Bookkeep these from ci below, as it makes things way simpler. */
	const uint8_t* code;
	int codeLen;
	_OffsetType codeOffset;

	_DecodeResult ret = DECRES_SUCCESS;

	/* Current working decoded instruction in results. */
	_DInst* pdi = (_DInst*)&result[0]; /* There's always a room for at least one slot, checked earlier. */
	_DInst* maxResultAddr;

	unsigned int features = ci.features;

	unsigned int diStructSize;
	/* Use next entry. */
#ifndef DISTORM_LIGHT
	if (supportOldIntr) {
		diStructSize = sizeof(_DecodedInst);
		maxResultAddr = (_DInst*)((size_t)&result[0] + (maxResultCount * sizeof(_DecodedInst)));
	}
	else
#endif /* DISTORM_LIGHT */
	{
		diStructSize = sizeof(_DInst);
		maxResultAddr = &result[maxResultCount];
	}

	ci.addrMask = (_OffsetType)-1;

#ifdef DISTORM_LIGHT
	supportOldIntr; /* Unreferenced. */

	/*
	 * Only truncate address if we are using the decompose interface.
	 * Otherwise, we use the textual interface which needs full addresses for formatting bytes output.
	 * So distorm_format will truncate later.
	 */
	if (features & DF_MAXIMUM_ADDR32) ci.addrMask = 0xffffffff;
	else if (features & DF_MAXIMUM_ADDR16) ci.addrMask = 0xffff;
#endif

	ps.count = 1; /* Force zero'ing ps below. */

	/* Decode instructions as long as we have what to decode/enough room in entries. */
	while (ci.codeLen > 0) {
		code = ci.code;
		codeLen = ci.codeLen;
		codeOffset = ci.codeOffset;

		if (ps.count) memset(&ps, 0, sizeof(ps));

		/**** INSTRUCTION DECODING NEXT: ****/

		/* Make sure we didn't run out of output entries. */
		if (pdi >= maxResultAddr) {
			ret = DECRES_MEMORYERR;
			break;
		}

		ret = decode_inst(&ci, &ps, code, pdi);
		/* decode_inst keeps track (only if successful!) for code and codeLen but ignores codeOffset, fix it here. */
		ci.codeOffset += pdi->size;

		if (ret == DECRES_SUCCESS) {

			if (features & (DF_SINGLE_BYTE_STEP | DF_RETURN_FC_ONLY | DF_STOP_ON_PRIVILEGED | DF_STOP_ON_FLOW_CONTROL)) {

				/* Sync codeinfo, remember that currently it points to beginning of the instruction and prefixes if any. */
				if (features & DF_SINGLE_BYTE_STEP) {
					ci.code = code + 1;
					ci.codeLen = codeLen - 1;
					ci.codeOffset = codeOffset + 1;
				}

				/* See if we need to filter this instruction. */
				if ((features & DF_RETURN_FC_ONLY) && (META_GET_FC(pdi->meta) == FC_NONE)) {
					continue;
				}

				/* Check whether we need to stop on any feature. */
				if ((features & DF_STOP_ON_PRIVILEGED) && (FLAG_GET_PRIVILEGED(pdi->flags))) {
					pdi = (_DInst*)((char*)pdi + diStructSize);
					break; /* ret = DECRES_SUCCESS; */
				}

				if (features & DF_STOP_ON_FLOW_CONTROL) {
					unsigned int mfc = META_GET_FC(pdi->meta);
					if (mfc && (((features & DF_STOP_ON_CALL) && (mfc == FC_CALL)) ||
						((features & DF_STOP_ON_RET) && (mfc == FC_RET)) ||
						((features & DF_STOP_ON_SYS) && (mfc == FC_SYS)) ||
						((features & DF_STOP_ON_UNC_BRANCH) && (mfc == FC_UNC_BRANCH)) ||
						((features & DF_STOP_ON_CND_BRANCH) && (mfc == FC_CND_BRANCH)) ||
						((features & DF_STOP_ON_INT) && (mfc == FC_INT)) ||
						((features & DF_STOP_ON_CMOV) && (mfc == FC_CMOV)) ||
						((features & DF_STOP_ON_HLT) && (mfc == FC_HLT)))) {
						pdi = (_DInst*)((char*)pdi + diStructSize);
						break; /* ret = DECRES_SUCCESS; */
					}
				}
			}

			/* Allocate at least one more entry to use, for the next instruction. */
			pdi = (_DInst*)((char*)pdi + diStructSize);
		}
		else { /* ret == DECRES_INPUTERR */

			/* Handle failure of decoding last instruction. */
			if ((!(features & DF_RETURN_FC_ONLY))) {
				memset(pdi, 0, sizeof(_DInst));
				pdi->flags = FLAG_NOT_DECODABLE;
				pdi->imm.byte = *code;
				pdi->size = 1;
				pdi->addr = codeOffset & ci.addrMask;
				pdi = (_DInst*)((char*)pdi + diStructSize);

				/* If an instruction wasn't decoded then stop on undecodeable if set. */
				if (features & DF_STOP_ON_UNDECODEABLE) {
					ret = DECRES_SUCCESS;
					break;
				}
			}

			/* Skip a single byte in case of a failure and retry instruction. */
			ci.code = code + 1;
			ci.codeLen = codeLen - 1;
			ci.codeOffset = codeOffset + 1;

			/* Reset return value. */
			ret = DECRES_SUCCESS;
		}
	}

	/* Set OUT params. */
	*usedInstructionsCount = (unsigned int)(((size_t)pdi - (size_t)result) / (size_t)diStructSize);
	_ci->nextOffset = ci.codeOffset;

	return ret;
}

```

`NativeCore/Dependencies/distorm/src/decoder.h`:

```h
/*
decoder.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DECODER_H
#define DECODER_H

#include "config.h"

typedef unsigned int _iflags;

_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount);

#endif /* DECODER_H */

```

`NativeCore/Dependencies/distorm/src/distorm.c`:

```c
/*
distorm.c

diStorm3 C Library Interface
diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "../include/distorm.h"
#include "config.h"
#include "decoder.h"
#include "x86defs.h"
#include "textdefs.h"
#include "wstring.h"
#include "../include/mnemonics.h"

/* C DLL EXPORTS */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	if (usedInstructionsCount == NULL) {
		return DECRES_SUCCESS;
	}

	if ((ci == NULL) ||
		(ci->codeLen < 0) ||
		((unsigned)ci->dt > (unsigned)Decode64Bits) ||
		(ci->code == NULL) ||
		(result == NULL) ||
		(maxInstructions == 0) ||
		((ci->features & (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)) == (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)))
	{
		return DECRES_INPUTERR;
	}

	return decode_internal(ci, FALSE, result, maxInstructions, usedInstructionsCount);
}

#ifndef DISTORM_LIGHT

/* Helper function to concatenate an explicit size when it's unknown from the operands. */
static void distorm_format_size(unsigned char** str, const _DInst* di, int opNum)
{
	int isSizingRequired = 0;
	/*
	 * We only have to output the size explicitly if it's not clear from the operands.
	 * For example:
	 * mov al, [0x1234] -> The size is 8, we know it from the AL register operand.
	 * mov [0x1234], 0x11 -> Now we don't know the size. Pam pam pam
	 *
	 * If given operand number is higher than 2, then output the size anyways.
	 */
	isSizingRequired = ((opNum >= 2) || ((opNum == 0) && (di->ops[0].type != O_REG) && (di->ops[1].type != O_REG)));

	/* Still not sure? Try some special instructions. */
	if (!isSizingRequired) {
		/*
		 * INS/OUTS are exception, because DX is a port specifier and not a real src/dst register.
		 * A few exceptions that always requires sizing:
		 * MOVZX, MOVSX, MOVSXD.
		 * ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR.
		 * SHLD, SHRD.
		 * CVTSI2SS is also an exception.
		 */
		switch (di->opcode)
		{
			case I_INS:
			case I_OUTS:
			case I_MOVZX:
			case I_MOVSX:
			case I_MOVSXD:
			case I_ROL:
			case I_ROR:
			case I_RCL:
			case I_RCR:
			case I_SHL:
			case I_SHR:
			case I_SAL:
			case I_SAR:
			case I_SHLD:
			case I_SHRD:
			case I_CVTSI2SS:
				isSizingRequired = 1;
			break;
			default: /* Instruction doesn't require sizing. */ break;
		}
	}

	if (isSizingRequired)
	{
		/*case 0: break; OT_MEM's unknown size. */
		switch (di->ops[opNum].size / 8)
		{
			case 1: strcat_WS(*str,  "BYTE    ", 8, 5); break;
			case 2: strcat_WS(*str,  "WORD    ", 8, 5); break;
			case 4: strcat_WS(*str,  "DWORD   ", 8, 6); break;
			case 8: strcat_WS(*str,  "QWORD   ", 8, 6); break;
			case 10: strcat_WS(*str, "TBYTE   ", 8, 6); break;
			case 16: strcat_WS(*str, "DQWORD  ", 8, 7); break;
			case 32: strcat_WS(*str, "YWORD   ", 8, 6); break;
		}
	}
}

static void distorm_format_signed_disp(unsigned char** str, const _DInst* di, uint64_t addrMask)
{
	int64_t tmpDisp64;

	if (di->dispSize) {
		if (((int64_t)di->disp < 0)) {
			chrcat_WS(*str, MINUS_DISP_CHR);
			tmpDisp64 = -(int64_t)di->disp;
			tmpDisp64 &= addrMask; /* Verify only for neg numbers. */
		}
		else {
			chrcat_WS(*str, PLUS_DISP_CHR);
			tmpDisp64 = di->disp;
		}
		str_int(str, tmpDisp64);
	}
}

static uint8_t prefixTable[6][8] = { "", "LOCK ", "REPNZ ", "REPNZ ", "REP ", "REPZ " };
static unsigned int prefixSizesTable[6] = { 0, 5, 6, 6, 4, 5 };
static uint8_t suffixTable[10] = { 0, 'B', 'W', 0, 'D', 0, 0, 0, 'Q' };

/* WARNING: This function is written carefully to be able to work with same input and output buffer in-place! */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#else
	_DLLEXPORT_ void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#endif
{
	unsigned char* str;
	int64_t tmpDisp64;
	uint64_t addrMask = (uint64_t)-1;
	const _WMnemonic* mnemonic;
	int suffixSize = -1;
	unsigned int i;

	/* Set address mask, when default is for 64bits addresses. */
	if (ci->features & DF_USE_ADDR_MASK) addrMask = ci->addrMask;
	else {
		if (ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
		else if (ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;
	}

	/* Gotta have full address for (di->addr - ci->codeOffset) to work in all modes. */
	str_hex(&result->instructionHex, (const uint8_t*)&ci->code[(unsigned int)(di->addr - ci->codeOffset)], di->size);

	if ((int)((int16_t)di->flags) == -1) {
		/* In-place considerations: DI is RESULT. Deref fields first. */
		unsigned int size = di->size;
		unsigned int byte = di->imm.byte;
		_OffsetType offset = di->addr & addrMask;

		result->offset = offset;
		result->size = size;
		str = (unsigned char*)&result->mnemonic.p;
		strcat_WS(str, "DB  ", 4, 3);
		str_int(&str, byte);
		strfinalize_WS(result->mnemonic, str);
		*(uint64_t*)&result->operands = 0; /* Clears length and the string at once. */
		return; /* Skip to next instruction. */
	}

	str = (unsigned char*)&result->operands.p;

	/* Special treatment for String (movs, cmps, stos, lods, scas) instructions. */
	if ((di->opcode >= I_MOVS) && (di->opcode <= I_SCAS)) {
		/*
		 * No operands are needed if the address size is the default one,
		 * and no segment is overridden, so add the suffix letter,
		 * to indicate size of operation and continue to next instruction.
		 */
		if ((SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) && (FLAG_GET_ADDRSIZE(di->flags) == ci->dt)) {
			suffixSize = di->ops[0].size / 8;
			goto skipOperands;
		}
		suffixSize = 0; /* Marks it's a string instruction. */
	}

	for (i = 0; i < di->opsNo; i++) {
		unsigned int type = di->ops[i].type;
		if (i > 0) strcat_WS(str, ", ", 2, 2);
		if (type == O_REG) {
			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);
		}
		else if (type == O_IMM) {
			/* If the instruction is 'push', show explicit size (except byte imm). */
			if ((di->opcode == I_PUSH) && (di->ops[i].size != 8)) distorm_format_size(&str, di, i);
			/* Special fix for negative sign extended immediates. */
			if ((di->flags & FLAG_IMM_SIGNED) && (di->ops[i].size == 8) && (di->imm.sbyte < 0)) {
				chrcat_WS(str, MINUS_DISP_CHR);
				tmpDisp64 = -di->imm.sbyte;
				str_int(&str, tmpDisp64);
			}
			else {
				/* Notice signedness and size of the immediate. */
				if (di->ops[i].size == 0x20) str_int(&str, di->imm.dword);
				else str_int(&str, di->imm.qword);
			}
		}
		else if (type == O_PC) {
#ifdef SUPPORT_64BIT_OFFSET
			str_int(&str, (di->size + di->imm.sqword + di->addr) & addrMask);
#else
			tmpDisp64 = ((_OffsetType)di->imm.sdword + di->addr + di->size) & (uint32_t)addrMask;
			str_int(&str, tmpDisp64);
#endif
		}
		else if (type == O_DISP) {
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);
			if (!SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) {
				strcat_WSR(&str, &_REGISTERS[SEGMENT_GET_UNSAFE(di->segment)]);
				chrcat_WS(str, SEG_OFF_CHR);
			}
			tmpDisp64 = di->disp & addrMask;
			str_int(&str, tmpDisp64);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_SMEM) {
			int isDefault;
			int segment;
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);

			segment = SEGMENT_GET(di->segment);
			isDefault = SEGMENT_IS_DEFAULT(di->segment);

			/*
			 * This is where we need to take special care for String instructions.
			 * If we got here, it means we need to explicitly show their operands.
			 * The problem with CMPS and MOVS is that they have two(!) memory operands.
			 * So we have to complement(!) them ourselves, since the isntruction structure supplies only the segment that can be overridden.
			 * And make the rest of the String operations explicit.
			 * We ignore default ES/DS in 64 bits.
			 * ["MOVS"], [OPT.REGI_EDI, OPT.REGI_ESI] -- DS can be overridden.
			 * ["CMPS"], [OPT.REGI_ESI, OPT.REGI_EDI] -- DS can be overriden.
			 *
			 * suffixSize == 0 was set above for string opcode already.
			 */
			if (suffixSize == 0) {
				if (((di->opcode == I_MOVS) && (i == 0)) || ((di->opcode == I_CMPS) && (i == 1))) {
					if (ci->dt != Decode64Bits) {
						segment = R_ES;
						isDefault = FALSE;
					}
					else isDefault = TRUE;
				}
				else if (isDefault && ((di->opcode == I_MOVS) || (di->opcode == I_CMPS))) {
					if (ci->dt != Decode64Bits) {
						segment = R_DS;
						isDefault = FALSE;
					}
				}
			}
			if (!isDefault && (segment != R_NONE)) {
				strcat_WSR(&str, &_REGISTERS[segment]);
				chrcat_WS(str, SEG_OFF_CHR);
			}

			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);

			distorm_format_signed_disp(&str, di, addrMask);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_MEM) {
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);
			if (!SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) {
				strcat_WSR(&str, &_REGISTERS[SEGMENT_GET_UNSAFE(di->segment)]);
				chrcat_WS(str, SEG_OFF_CHR);
			}
			if (di->base != R_NONE) {
				strcat_WSR(&str, &_REGISTERS[di->base]);
				chrcat_WS(str, PLUS_DISP_CHR);
			}
			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);
			if (di->scale != 0) {
				switch (di->scale)
				{
					case 2: strcat_WS(str, "*2", 2, 2); break;
					case 4: strcat_WS(str, "*4", 2, 2); break;
					case 8: strcat_WS(str, "*8", 2, 2); break;
				}
			}
			distorm_format_signed_disp(&str, di, addrMask);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_PTR) {
			str_int(&str, di->imm.ptr.seg);
			chrcat_WS(str, SEG_OFF_CHR);
			str_int(&str, di->imm.ptr.off);
		}
		else if (type == O_IMM1) {
			str_int(&str, di->imm.ex.i1);
		}
		else if (type == O_IMM2) {
			str_int(&str, di->imm.ex.i2);
		}
	}

skipOperands:

	/* Finalize the operands string. */
	strfinalize_WS(result->operands, str);

	/* Not used anymore.
	if (di->flags & FLAG_HINT_TAKEN) strcat_WSN(str, " ;TAKEN");
	else if (di->flags & FLAG_HINT_NOT_TAKEN) strcat_WSN(str, " ;NOT TAKEN");
	*/
	{
		/* In-place considerations: DI is RESULT. Deref fields first. */
		unsigned int opcode = di->opcode;
		unsigned int prefix = FLAG_GET_PREFIX(di->flags);
		unsigned int size = di->size;
		_OffsetType offset = di->addr & addrMask;
		str = (unsigned char*)&result->mnemonic.p;
		mnemonic = (const _WMnemonic*)&_MNEMONICS[opcode];

		if (prefix) {
			/* REP prefix for CMPS and SCAS is really a REPZ. */
			prefix += (opcode == I_CMPS);
			prefix += (opcode == I_SCAS);
			memcpy(str, &prefixTable[prefix][0], 8);
			str += prefixSizesTable[prefix];
		}

		/*
		 * Always copy 16 bytes from the mnemonic, we have a sentinel padding so we can read past.
		 * This helps the compiler to remove the call to memcpy and therefore makes this copying much faster.
		 * The longest instruction is exactly 16 chars long, so we null terminate the string below.
		 */
		memcpy((int8_t*)str, mnemonic->p, 16);
		str += mnemonic->length;

		if (suffixSize > 0) {
			*str++ = suffixTable[suffixSize];
		}
		strfinalize_WS(result->mnemonic, str);

		result->offset = offset;
		result->size = size;
	}
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	_DecodeResult res;
	_CodeInfo ci;
	unsigned int i, instsCount;

	*usedInstructionsCount = 0;

	/* I use codeLen as a signed variable in order to ease detection of underflow... and besides - */
	if (codeLen < 0) {
		return DECRES_INPUTERR;
	}

	if ((unsigned)dt > (unsigned)Decode64Bits) {
		return DECRES_INPUTERR;
	}

	/* Make sure there's at least one instruction in the result buffer. */
	if ((code == NULL) || (result == NULL) || (maxInstructions == 0)) {
		return DECRES_INPUTERR;
	}

	/*
	 * We have to format the result into text. But the interal decoder works with the new structure of _DInst.
	 * Therefore, we will pass the result array(!) from the caller and the interal decoder will fill it in with _DInst's.
	 * Then we will copy each result to a temporary structure, and use it to reformat that specific result.
	 *
	 * This is all done to save memory allocation and to work on the same result array in-place!!!
	 * It's a bit ugly, I have to admit, but worth it.
	 */

	ci.codeOffset = codeOffset;
	ci.code = code;
	ci.codeLen = codeLen;
	ci.dt = dt;
	ci.features = DF_USE_ADDR_MASK;
	if (dt == Decode16Bits) ci.addrMask = 0xffff;
	else if (dt == Decode32Bits) ci.addrMask = 0xffffffff;
	else ci.addrMask = (_OffsetType)-1;

	res = decode_internal(&ci, TRUE, (_DInst*)result, maxInstructions, usedInstructionsCount);
	instsCount = *usedInstructionsCount;
	for (i = 0; i < instsCount; i++) {
		/* distorm_format is optimized and can work with same input/output buffer in-place. */
#ifdef SUPPORT_64BIT_OFFSET
		distorm_format64(&ci, (_DInst*)&result[i], &result[i]);
#else
		distorm_format32(&ci, (_DInst*)&result[i], &result[i]);
#endif
	}

	return res;
}

#endif /* DISTORM_LIGHT */

_DLLEXPORT_ unsigned int distorm_version(void)
{
	return __DISTORMV__;
}

```

`NativeCore/Dependencies/distorm/src/instructions.c`:

```c
/*
instructions.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "instructions.h"

#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "../include/mnemonics.h"


/* Helper macros to extract the type or index from an inst-node value. */
#define INST_NODE_INDEX(n) ((n) & 0x1fff)
#define INST_NODE_TYPE(n) ((n) >> 13)

/* Helper macro to read the actual flags that are associated with an inst-info. */
#define INST_INFO_FLAGS(ii) (FlagsTable[InstSharedInfoTable[(ii)->sharedIndex].flagsIndex])

/*
I use the trie data structure as I found it most fitting to a disassembler mechanism.
When you read a byte and have to decide if it's enough or you should read more bytes, 'till you get to the instruction information.
It's really fast because you POP the instruction info in top 3 iterates on the DB, because an instruction can be formed from two bytes + 3 bits reg from the ModR/M byte.
For a simple explanation, check this out:
http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/
Further reading: http://en.wikipedia.org/wiki/Trie

The first GATE (array you read off a trie data structure), as I call them, is statically allocated by the compiler.
The second and third gates if used are being allocated dynamically by the instructions-insertion functionality.

How would such a thing look in memory, say we support 4 instructions with 3 bytes top (means 2 dynamically allocated gates).

->
|-------|                                0,
|0|     -------------------------------> |-------|
|1|RET  |      1,                        |0|AND  |
|2|     -----> |-------|                 |1|XOR  |
|3|INT3 |      |0|PUSH |                 |2|OR   |         0,3,
|-------|      |1|POP  |                 |3|     --------->|-------|
               |2|PUSHF|                 |-------|         |0|ROR  |
               |3|POPF |                                   |1|ROL  |
               |-------|                                   |2|SHR  |
                                                           |3|SHL  |
                                                           |-------|

Of course, this is NOT how Intel instructions set looks!!!
but I just wanted to give a small demonstration.
Now the instructions you get from such a trie DB goes like this:

0, 0 - AND
0, 1 - XOR
0, 2 - OR
0, 3, 0, ROR
0, 3, 1, ROL
0, 3, 2, SHR
0, 3, 3, SHL
1 - RET
2, 0 - PUSH
2, 1 - POP
2, 2 - PUSHF
2, 3 - POPF
3 - INT3

I guess it's clear by now.
So now, if you read 0, you know that you have to enter the second gate(list) with the second byte specifying the index.
But if you read 1, you know that you go to an instruction (in this case, a RET).
That's why there's an Instruction-Node structure, it tells you whether you got to an instruction or another list
so you should keep on reading byte).

In Intel, you could go through 4 gates at top, because there are instructions which are built from 2 bytes and another smaller list
for the REG part, or newest SSE4 instructions which use 4 bytes for opcode.
Therefore, Intel's first gate is 256 long, and other gates are 256 (/72) or 8 long, yes, it costs pretty much a lot of memory
for non-used defined instructions, but I think that it still rocks.
*/

/*
 * A helper function to look up the correct inst-info structure.
 * It does one fetch from the index-table, and then another to get the inst-info.
 * Note that it takes care about basic inst-info or inst-info-ex.
 * The caller should worry about boundary checks and whether it accesses a last-level table.
 */
static _InstInfo* inst_get_info(_InstNode in, int index)
{
	int instIndex = 0;

	in = InstructionsTree[INST_NODE_INDEX(in) + index];
	if (in == INT_NOTEXISTS) return NULL;

	instIndex = INST_NODE_INDEX(in);
	return INST_NODE_TYPE(in) == INT_INFO ? &InstInfos[instIndex] : (_InstInfo*)&InstInfosEx[instIndex];
}

/*
 * This function is responsible to return the instruction information of the first found in code.
 * It returns the _InstInfo of the found instruction, otherwise NULL.
 * code should point to the ModR/M byte upon exit (if used), or after the instruction binary code itself.
 * This function is NOT decoding-type dependant, it is up to the caller to see whether the instruction is valid.
 * Get the instruction info, using a Trie data structure.
 *
 * Sometimes normal prefixes become mandatory prefixes, which means they are now part of the instruction opcode bytes.

 * This is a bit tricky now,
 * if the first byte is a REP (F3) prefix, we will have to give a chance to an SSE instruction.
 * If an instruction doesn't exist, we will make it as a prefix and re-locateinst.
 * A case such that a REP prefix is being changed into an instruction byte and also an SSE instruction will not be found can't happen,
 * simply because there are no collisions between string instruction and SSE instructions (they are escaped).

 * As for S/SSE2/3, check for F2 and 66 as well.

 * In 64 bits, we have to make sure that we will skip the REX prefix, if it exists.
 * There's a specific case, where a 66 is mandatory but it was dropped because REG.W was used,
 * but it doesn't behave as an operand size prefix but as a mandatory, so we will have to take it into account.

 * For example (64 bits decoding mode):
 * 66 98 CBW
 * 48 98 CDQE
 * 66 48 98: db 0x66; CDQE
 * Shows that operand size is dropped.

 * Now, it's a mandatory prefix and NOT an operand size one.
 * 66480f2dc0 db 0x48; CVTPD2PI XMM0, XMM0
 * Although this instruction doesn't require a REX.W, it just shows, that even if it did - it doesn't matter.
 * REX.W is dropped because it's not required, but the decode function disabled the operand size even so.
 */
static _InstInfo* inst_lookup_prefixed(_InstNode in, _PrefixState* ps)
{
	int checkOpSize = FALSE;
	int index = 0;
	_InstInfo* ii = NULL;

	/* Check prefixes of current decoded instruction (None, 0x66, 0xf3, 0xf2). */
	switch (ps->decodedPrefixes & (INST_PRE_OP_SIZE | INST_PRE_REPS))
	{
		case 0:
			/* Non-prefixed, index = 0. */
			index = 0;
		break;
		case INST_PRE_OP_SIZE:
			/* 0x66, index = 1. */
			index = 1;
			/* Mark that we used it as a mandatory prefix. */
			ps->isOpSizeMandatory = TRUE;
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		break;
		case INST_PRE_REP:
			/* 0xf3, index = 2. */
			index = 2;
			ps->decodedPrefixes &= ~INST_PRE_REP;
		break;
		case INST_PRE_REPNZ:
			/* 0xf2, index = 3. */
			index = 3;
			ps->decodedPrefixes &= ~INST_PRE_REPNZ;
		break;
		default:
			/*
			 * Now we got a problem, since there are a few mandatory prefixes at once.
			 * There is only one case when it's ok, when the operand size prefix is for real (not mandatory).
			 * Otherwise we will have to return NULL, since the instruction is illegal.
			 * Therefore we will start with REPNZ and REP prefixes,
			 * try to get the instruction and only then check for the operand size prefix.
			 */

			 /* If both REPNZ and REP are together, it's illegal for sure. */
			if ((ps->decodedPrefixes & INST_PRE_REPS) == INST_PRE_REPS) return NULL;

			/* Now we know it's either REPNZ+OPSIZE or REP+OPSIZE, so examine the instruction. */
			if (ps->decodedPrefixes & INST_PRE_REPNZ) {
				index = 3;
				ps->decodedPrefixes &= ~INST_PRE_REPNZ;
			}
			else if (ps->decodedPrefixes & INST_PRE_REP) {
				index = 2;
				ps->decodedPrefixes &= ~INST_PRE_REP;
			}
			/* Mark to verify the operand-size prefix of the fetched instruction below. */
			checkOpSize = TRUE;
		break;
	}

	/* Fetch the inst-info from the index. */
	ii = inst_get_info(in, index);

	if (checkOpSize) {
		/* If the instruction doesn't support operand size prefix, then it's illegal. */
		if ((ii == NULL) || (~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE)) return NULL;
	}

	/* If there was a prefix, but the instruction wasn't found. Try to fall back to use the normal instruction. */
	if (ii == NULL) ii = inst_get_info(in, 0);
	return ii;
}

/* A helper function to look up special VEX instructions.
 * See if it's a MOD based instruction and fix index if required.
 * Only after a first lookup (that was done by caller), we can tell if we need to fix the index.
 * Because these are coupled instructions
 * (which means that the base instruction hints about the other instruction).
 * Note that caller should check if it's a MOD dependent instruction before getting in here.
 */
static _InstInfo* inst_vex_mod_lookup(_CodeInfo* ci, _InstNode in, _InstInfo* ii, unsigned int index)
{
	/* Advance to read the MOD from ModRM byte. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	if (*ci->code < INST_DIVIDED_MODRM) {
		/* MOD is not 11, therefore change the index to 8 - 12 range in the prefixed table. */
		index += 4;
		/* Make a second lookup for this special instruction. */
		return inst_get_info(in, index);
	}
	/* Return the original one, in case we didn't find a suited instruction. */
	return ii;
}

static _InstInfo* inst_vex_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	_InstNode in = 0;
	unsigned int pp = 0, start = 0;
	unsigned int index = 4; /* VEX instructions start at index 4 in the Prefixed table. */
	uint8_t vex = *ps->vexPos, vex2 = 0, v = 0;
	int instType = 0, instIndex = 0;

	/* The VEX instruction will #ud if any of 66, f0, f2, f3, REX prefixes precede. */
	_iflags illegal = (INST_PRE_OP_SIZE | INST_PRE_LOCK | INST_PRE_REP | INST_PRE_REPNZ | INST_PRE_REX);
	if ((ps->decodedPrefixes & illegal) != 0) return NULL;

	/* Read the some fields from the VEX prefix we need to extract the instruction. */
	if (ps->prefixExtType == PET_VEX2BYTES) {
		ps->vexV = v = (~vex >> 3) & 0xf;
		pp = vex & 3;
		/* Implied leading 0x0f byte by default for 2 bytes VEX prefix. */
		start = 1;
	}
	else { /* PET_VEX3BYTES */
		start = vex & 0x1f;
		vex2 = *(ps->vexPos + 1);
		ps->vexV = v = (~vex2 >> 3) & 0xf;
		pp = vex2 & 3;
	}

	/* start can be either 1 (0x0f), 2 (0x0f, 0x038) or 3 (0x0f, 0x3a), otherwise it's illegal. */
	switch (start)
	{
		case 1: in = Table_0F; break;
		case 2: in = Table_0F_38; break;
		case 3: in = Table_0F_3A; break;
		default: return NULL;
	}

	/* pp is actually the implied mandatory prefix, apply it to the index. */
	index += pp; /* (None, 0x66, 0xf3, 0xf2) */

	/* Read a byte from the stream. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	in = InstructionsTree[INST_NODE_INDEX(in) + *ci->code];
	if (in == INT_NOTEXISTS) return NULL;

	instType = INST_NODE_TYPE(in);
	instIndex = INST_NODE_INDEX(in);

	/*
	 * If we started with 0f38 or 0f3a so it's a prefixed table,
	 * therefore it's surely a VEXed instruction (because of a high index).
	 * However, starting with 0f, could also lead immediately to a prefixed table for some bytes.
	 * it might return NULL, if the index is invalid.
	 */
	if (instType == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/*
	 * If we reached here, obviously we started with 0f. VEXed instructions must be nodes of a prefixed table.
	 * But since we found an instruction (or divided one), just return NULL.
	 * They cannot lead to a VEXed instruction.
	 */
	if ((instType == INT_INFO) || (instType == INT_INFOEX) || (instType == INT_LIST_DIVIDED)) return NULL;

	/* Now we are left with handling either GROUP or FULL tables, therefore we will read another byte from the stream. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[instIndex + ((*ci->code >> 3) & 7)];
		/* Continue below to check prefixed table. */
	}
	else if (instType == INT_LIST_FULL) {
		in = InstructionsTree[instIndex + *ci->code];
		/* Continue below to check prefixed table. */
	}

	/* Now that we got to the last table in the trie, check for a prefixed table. */
	if (INST_NODE_TYPE(in) == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/* No VEXed instruction was found. */
	return NULL;
}

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps, int* isPrefixed)
{
	unsigned int tmpIndex0, tmpIndex1, tmpIndex2;
	int instType;
	_InstNode in;
	_InstInfo* ii = NULL;
	int isWaitIncluded = FALSE;

	/* Always safe to read first byte codeLen > 0. */
	tmpIndex0 = *ci->code;

	if (prefixes_is_valid((unsigned char)tmpIndex0, ci->dt)) {
		*isPrefixed = TRUE;
		prefixes_decode(ci, ps);
		if (ci->codeLen < 1) return NULL; /* No more bytes for opcode, halt. */
		tmpIndex0 = *ci->code; /* Reload. */

		/* If there are too many prefixes, it will be checked later in decode_inst. */

		/* See whether we have to handle a VEX prefixed instruction. */
		if (ps->decodedPrefixes & INST_PRE_VEX) {
			ii = inst_vex_lookup(ci, ps);
			if (ii != NULL) {
				/* Make sure that VEX.L exists when forced. */
				if ((((_InstInfoEx*)ii)->flagsEx & INST_FORCE_VEXL) && (~ps->vrex & PREFIX_EX_L)) return NULL;
				/* If the instruction doesn't use VEX.vvvv it must be zero. */
				if ((((_InstInfoEx*)ii)->flagsEx & INST_VEX_V_UNUSED) && ps->vexV) return NULL;
			}
			return ii;
		}
	}

	/* Account first byte, we know it's safe to read. */
	ci->codeLen -= 1;

	/* Check for special 0x9b, WAIT instruction, which can be part of some instructions(x87). */
	if (tmpIndex0 == INST_WAIT_INDEX) {
		/* Only OCST_1dBYTES get a chance to include this byte as part of the opcode. */
		isWaitIncluded = TRUE;

		/* Ignore all prefixes, since they are useless and operate on the WAIT instruction itself. */
		prefixes_ignore_all(ps);

		/* Move to next code byte as a new whole instruction. */
		ci->code += 1;
		ci->codeLen -= 1;
		if (ci->codeLen < 0) return NULL; /* Faster to return NULL, it will be detected as WAIT later anyway. */
		/* Since we got a WAIT prefix, we re-read the first byte. */
		tmpIndex0 = *ci->code;
	}

	/* Walk first byte in InstructionsTree root. */
	in = InstructionsTree[tmpIndex0];
	if ((uint32_t)in == INT_NOTEXISTS) return NULL;
	instType = INST_NODE_TYPE(in);

	/* Single byte instruction (OCST_1BYTE). */
	if ((instType < INT_INFOS) && (!isWaitIncluded)) {
		/* Some single byte instructions need extra treatment. */
		if (instType == INT_INFO_TREAT) {
			if (tmpIndex0 == INST_NOP_INDEX) { /* Nopnopnop */
				/* Check for Pause, since it's prefixed with 0xf3, which is not a real mandatory prefix. */
				if (ps->decodedPrefixes & INST_PRE_REP) {
					/* Flag this prefix as used. */
					ps->usedPrefixes |= INST_PRE_REP;
					return &II_PAUSE;
				}

				/*
				 * Treat NOP/XCHG specially.
				 * If we're not in 64bits restore XCHG to NOP, since in the DB it's XCHG.
				 * Else if we're in 64bits examine REX, if exists, and decide which instruction should go to output.
				 * 48 90 XCHG RAX, RAX is a true NOP (eat REX in this case because it's valid).
				 * 90 XCHG EAX, EAX is a true NOP (and not high dword of RAX = 0 although it should be a 32 bits operation).
				 * Note that if the REX.B is used, then the register is not RAX anymore but R8, which means it's not a NOP.
				 */
				if (ps->vrex & PREFIX_EX_W) ps->usedPrefixes |= INST_PRE_REX;
				if ((ci->dt != Decode64Bits) || (~ps->vrex & PREFIX_EX_B)) return &II_NOP;
			}
			else if (tmpIndex0 == INST_LEA_INDEX) {
				/* Ignore segment override prefixes for LEA instruction. */
				ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
				/* Update unused mask for ignoring segment prefix. */
				prefixes_ignore(ps, PFXIDX_SEG);
			}
			else if (tmpIndex0 == INST_ARPL_INDEX) {
					/*
					 * ARPL/MOVSXD share the same opcode, and both have different operands and mnemonics, of course.
					 * Practically, I couldn't come up with a comfortable way to merge the operands' types of ARPL/MOVSXD.
					 * And since the DB can't be patched dynamically, because the DB has to be multi-threaded compliant,
					 * I have no choice but to check for ARPL/MOVSXD right here - "right about now, the funk soul brother, check it out now, the funk soul brother...", fatboy slim
					 */
					if (ci->dt == Decode64Bits) {
						return &II_MOVSXD;
					} /* else ARPL will be returned because its defined in the DB already. */
			}
		}
		/*
		 * Return the 1 byte instruction we found.
		 * We can have three node types here: infoex, info_treat and info.
		 * The latter two are really the same basic structure.
		 */
		return instType == INT_INFOEX ? (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)] : &InstInfos[INST_NODE_INDEX(in)];
	}

	/* Read second byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex1 = *ci->code;

	/* Try single byte instruction + reg bits (OCST_13BYTES). */
	if ((instType == INT_LIST_GROUP) && (!isWaitIncluded)) return inst_get_info(in, (tmpIndex1 >> 3) & 7);

	/* Try single byte instruction + reg byte OR one whole byte (OCST_1dBYTES). */
	if (instType == INT_LIST_DIVIDED) {

		/* Checking for inst by REG bits is higher priority if it's found not to be divided instruction. */
		{
			_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex1 >> 3) & 7)];
			/*
			 * Do NOT check for NULL here, since we do a bit of a guess work,
			 * hence we don't override 'in', cause we might still need it.
			 */
			instType = INST_NODE_TYPE(in2);

			if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
			else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];
			if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
			/* ii is reset below. */
		}

		/* Continue normally because of wait prefix. */
		if (tmpIndex1 < INST_DIVIDED_MODRM) {
			/* An instruction which requires a ModR/M byte. Thus it's 1.3 bytes long instruction. */
			tmpIndex1 = (tmpIndex1 >> 3) & 7; /* Isolate the 3 REG/OPCODE bits. */
		}
		else { /* Normal 2 bytes instruction. */
		 /*
		  * Divided instructions can't be in the range of 0x8-0xc0.
		  * That's because 0-8 are used for 3 bits group.
		  * And 0xc0-0xff are used for not-divided instruction.
		  * So the in between range is omitted, thus saving some more place in the tables.
		  */
			tmpIndex1 -= INST_DIVIDED_MODRM - 8;
		}

		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS) {
			/* If the instruction doesn't support the wait (marked as opsize) as part of the opcode, it's illegal. */
			ii = instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
			if ((~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE) && (isWaitIncluded)) return NULL;
			return ii;
		}
		/*
		 * If we got here the instruction can support the wait prefix, so see if it was part of the stream.
		 * Examine prefixed table, specially used for 0x9b, since it's optional.
		 * No Wait: index = 0.
		 * Wait Exists, index = 1.
		 */
		return inst_get_info(in, isWaitIncluded);
	}

	/* Don't allow to continue if WAIT is part of the opcode, because there are no instructions that include it. */
	if (isWaitIncluded) return NULL;

	/* Try 2 bytes long instruction (doesn't include ModRM byte). */
	if (instType == INT_LIST_FULL) {
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		/* This is where we check if we just read two escape bytes in a row, which means it is a 3DNow! instruction. */
		if ((tmpIndex0 == _3DNOW_ESCAPE_BYTE) && (tmpIndex1 == _3DNOW_ESCAPE_BYTE)) return &II_3DNOW;

		/* 2 bytes instruction (OCST_2BYTES). */
		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/*
		 * 2 bytes + mandatory prefix.
		 * Mandatory prefixes can be anywhere in the prefixes.
		 * There cannot be more than one mandatory prefix, unless it's a normal operand size prefix.
		 */
		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Read third byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex2 = *ci->code;

	/* Try 2 bytes + reg instruction (OCST_23BYTES). */
	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/* It has to be a prefixed table then. */
		ii = inst_lookup_prefixed(in, ps);
		/* RDRAND and VMPTRLD share same 2.3 bytes opcode, and alternate on the MOD bits. See insts.h for more info. */
		if ((ii != NULL) && (ii->opcodeId == I_VMPTRLD) && (tmpIndex1 >= INST_DIVIDED_MODRM)) return &II_RDRAND;
		return ii;
	}

	/* Try 2 bytes + divided range (OCST_2dBYTES). */
	if (instType == INT_LIST_DIVIDED) {
		_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		/*
		 * Do NOT check for NULL here, since we do a bit of a guess work,
		 * hence we don't override 'in', cause we might still need it.
		 */
		instType = INST_NODE_TYPE(in2);

		if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
		else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];

		/*
		 * OCST_2dBYTES is complex, because there are a few instructions which are not divided in some special cases.
		 * If the instruction wasn't divided (but still it must be a 2.3 because we are in divided category)
		 * or it was an official 2.3 (because its index was less than 0xc0) -
		 * Then it means the instruction should be using the REG bits, otherwise give a chance to range 0xc0-0xff.
		 */
		 /* If we found an instruction only by its REG bits, AND it is not divided, then return it. */
		if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
		/* Otherwise, if the range is above 0xc0, try the special divided range (range 0x8-0xc0 is omitted). */
		if (tmpIndex2 >= INST_DIVIDED_MODRM) return inst_get_info(in, tmpIndex2 - INST_DIVIDED_MODRM + 8);

		/* It might be that we got here without touching ii in the above if statements, then it becomes an invalid instruction prolly. */
		return ii;
	}

	/* Try 3 full bytes (OCST_3BYTES - no ModRM byte). */
	if (instType == INT_LIST_FULL) {
		/* OCST_3BYTES. */
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex2];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Kahtchinggg, damn. */
	return NULL;
}

/*
* 3DNow! instruction handling:

* This is used when we encounter a 3DNow! instruction.
* We can't really locate a 3DNow! instruction before we see two escaped bytes,
* 0x0f, 0x0f. Then we have to extract operands which are, dest=mmx register, src=mmx register or quadword indirection.
* When we are finished with the extraction of operands we can resume to locate the instruction by reading another byte
* which tells us which 3DNow instruction we really tracked down...
* So in order to tell the extract operands function which operands the 3DNow! instruction require, we need to set up some
* generic instruction info for 3DNow! instructions.

* In the inst_lookup itself, when we read an OCST_3BYTES which the two first bytes are 0x0f and 0x0f.
* we will return this special generic II for the specific operands we are interested in (MM, MM64).
* Then after extracting the operand, we'll call a completion routine for locating the instruction
* which will be called only for 3DNow! instructions, distinguished by a flag, and it will read the last byte of the 3 bytes.
*
* The id of this opcode should not be used, the following function should change it anyway.
*/
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci)
{
	/* Start off from the two escape bytes gates... which is 3DNow! table.*/
	_InstNode in = Table_0F_0F;

	int index;

	/* Make sure we can read a byte off the stream. */
	if (ci->codeLen < 1) return NULL;

	index = *ci->code;

	ci->codeLen -= 1;
	ci->code += 1;
	return inst_get_info(in, index);
}

```

`NativeCore/Dependencies/distorm/src/instructions.h`:

```h
/*
instructions.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTRUCTIONS_H
#define INSTRUCTIONS_H

#include "config.h"
#include "prefix.h"


/*
 * Operand type possibilities:
 * Note "_FULL" suffix indicates to decode the operand as 16 bits or 32 bits depends on DecodeType -
 * actually, it depends on the decoding mode, unless there's an operand/address size prefix.
 * For example, the code: 33 c0 could be decoded/executed as XOR AX, AX or XOR EAX, EAX.
 */

typedef enum OpType {
	/* No operand is set */
	OT_NONE = 0,

	/* Read a byte(8 bits) immediate */
	OT_IMM8,
	/* Force a read of a word(16 bits) immediate, used by ret only */
	OT_IMM16,
	/* Read a word/dword immediate */
	OT_IMM_FULL,
	/* Read a double-word(32 bits) immediate */
	OT_IMM32,

	/* Read a signed extended byte(8 bits) immediate */
	OT_SEIMM8,

	/* Use a 8bit register */
	OT_REG8,
	/* Use a 16bit register */
	OT_REG16,
	/* Use a 16/32/64bit register */
	OT_REG_FULL,
	/* Use a 32bit register */
	OT_REG32,
	/*
	 * If used with REX the reg operand size becomes 64 bits, otherwise 32 bits.
	 * VMX instructions are promoted automatically without a REX prefix.
	 */
	OT_REG32_64,

	/* Use AL */
	OT_ACC8,
	/* Use AX (FSTSW) */
	OT_ACC16,
	/* Use AX/EAX/RAX */
	OT_ACC_FULL,
	/* Use AX/EAX, no REX is possible for RAX, used only with IN/OUT which don't support 64 bit registers */
	OT_ACC_FULL_NOT64,

	/* Read a byte(8 bits) immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELCB,
	/* Read a word/dword immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELC_FULL,

	/*
	 * Instruction-Block for one byte long instructions, used by INC/DEC/PUSH/POP/XCHG,
	 * REG is extracted from the value of opcode
	 * Use a 8bit register
	 */
	OT_IB_RB,
	/* Use a 16/32/64bit register */
	OT_IB_R_FULL,

	/* Read an immediate as an absolute address, size is known by instruction, used by MOV (memory offset) only */
	OT_MOFFS8,
	OT_MOFFS_FULL,
	/* Use [(r)SI] as INDIRECTION, for repeatable instructions */
	OT_REGI_ESI,
	/* Use [(r)DI] as INDIRECTION, for repeatable instructions */
	OT_REGI_EDI,
	/* Use [(r)BX + AL] as INDIRECTIOM, used by XLAT only */
	OT_REGI_EBXAL,
	/* Use [(r)AX] as INDIRECTION, used by AMD's SVM instructions */
	OT_REGI_EAX,
	/* Use DX, as for OUTS DX, BYTE [SI] */
	OT_REGDX,
	/* Use ECX in INVLPGA instruction */
	OT_REGECX,

	/* FPU registers: */
	OT_FPU_SI, /* ST(i) */
	OT_FPU_SSI, /* ST(0), ST(i) */
	OT_FPU_SIS, /* ST(i), ST(0) */

	/* SSE registers: */
	OT_XMM,
	/* Extract the SSE register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_XMM_RM,
	/* Implied XMM0 register as operand, used in SSE4. */
	OT_REGXMM0,
	/* Reg32/Reg 64 depends on prefix width only. */
	OT_WREG32_64,

	/* XMM is encoded in VEX.VVVV. */
	OT_VXMM,
	/* XMM is encoded in the high nibble of an immediate byte. */
	OT_XMM_IMM,
	/* YMM/XMM is dependent on VEX.L. */
	OT_YXMM,
	/* YMM/XMM (depends on prefix length) is encoded in the high nibble of an immediate byte. */
	OT_YXMM_IMM,
	/* YMM is encoded in reg. */
	OT_YMM,
	/* YMM is encoded in VEX.VVVV. */
	OT_VYMM,
	/* YMM/XMM is dependent on VEX.L, and encoded in VEX.VVVV. */
	OT_VYXMM,

	/* Use an immediate of 1, as for SHR R/M, 1 */
	OT_CONST1,
	/* Use CL, as for SHR R/M, CL */
	OT_REGCL,

	/* Use a control register */
	OT_CREG,
	/* Use a debug register */
	OT_DREG,
	/* Use a segment register */
	OT_SREG,
	/*
	 * SEG is encoded in the flags of the opcode itself!
	 * This is used for specific "push SS" where SS is a segment where
	 * each "push SS" has an absolutely different opcode byte.
	 * We need this to detect whether an operand size prefix is used.
	 */
	OT_SEG,

	/*
	 * Special immediates for instructions which have more than one immediate,
	 * which is an exception from standard instruction format.
	 * As to version v1.0: ENTER, INSERTQ, EXTRQ are the only problematic ones.
	 */
	 /* 16 bits immediate using the first imm-slot */
	OT_IMM16_1,
	/* 8 bits immediate using the first imm-slot */
	OT_IMM8_1,
	/* 8 bits immediate using the second imm-slot */
	OT_IMM8_2,

	/* Read one word (seg) and a word/dword/qword (depends on operand size), usually SEG:OFF, JMP 1234:1234 */
	OT_PTR16_FULL,

	/* Used only by MOV CR/DR(n). Promoted with REX onlly. */
	OT_FREG32_64_RM,

	/* MMX registers: */
	OT_MM,
	/* Extract the MMX register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_MM_RM,


	/**** MEMORY only operands: ****/

	/* Use general memory indirection, with varying sizes: */
	OT_MEM,
	OT_MEM32,
	/* Memory dereference for MOVNTI, either 32 or 64 bits (with REX). */
	OT_MEM32_64,
	OT_MEM64,
	/* Used for cmpxchg8b/16b. */
	OT_MEM64_128,
	OT_MEM128,
	/*
	 * Read one word (seg), and a word/dword/qword (depends on operand size) from memory.
	 * JMP FAR [EBX] means EBX point to 16:32 ptr.
	 */
	OT_MEM16_FULL,
	/* Read one word (limit) and a dword/qword (limit) (depends on operand size), used by SGDT, SIDT, LGDT, LIDT. */
	OT_MEM16_3264,
	/* Used when a memory indirection is required, but if the mod field is 11, this operand will be ignored. */
	OT_MEM_OPT,

	/* Same as OT_RMXX but POINTS to 16 bits [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM16,
	/* Same as OT_RMXX but POINTS to 32 bits (single precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM32,
	/* Same as OT_RMXX but POINTS to 64 bits (double precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM64,
	/* Same as OT_RMXX but POINTS to 80 bits (extended precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM80,

	/* Mem128/Mem256 is dependent on VEX.L. */
	OT_LMEM128_256,


	/**** MEMORY & REGISTER only operands: ****/

	/* Use or read (indirection) a 8bit register or immediate byte */
	OT_RM8,
	/* Some instructions force 16 bits (mov sreg, rm16) */
	OT_RM16,
	/* ModR/M for 32 bits. */
	OT_RM32,
	/*
	 * Special operand type for MOV reg16/32/64/mem16, segReg 8C /r. and SMSW.
	 * It supports all decoding modes, but if used as a memory indirection it's a 16 bit ModR/M indirection.
	 */
	OT_RFULL_M16,
	/* Use or read a 16/32/64bit register or immediate word/dword/qword */
	OT_RM_FULL,

	/* RM32/RM64 depends on prefix width only. */
	OT_WRM32_64,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 8 bits memory indirection operand.
	 */
	OT_R32_64_M8,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 16 bits memory indirection operand.
	 */
	OT_R32_64_M16,

	/*
	 * 32 or 64 bits (with REX) operand size indirection memory operand.
	 * Some instructions are promoted automatically without a REX prefix.
	 */
	OT_RM32_64,
	/* 16 or 32 bits RM. This is used only with MOVZXD instruction in 64bits. */
	OT_RM16_32,

	/*
	 * Special operand type for SSE4 where the ModR/M might
	 * be a 32 bits register or 8 bits memory indirection operand.
	 */
	OT_R32_M8,
	/*
	 * Special ModR/M for PINSRW, which need a 16 bits memory operand or 32 bits register.
	 * In 16 bits decoding mode R32 becomes R16, operand size cannot affect this.
	 */
	OT_R32_M16,
	/* Reg32/Reg64 (prefix width) or Mem8. */
	OT_REG32_64_M8,
	/* Reg32/Reg64 (prefix width) or Mem16. */
	OT_REG32_64_M16,

	/* ModR/M points to 32 bits MMX variable */
	OT_MM32,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM64,

	/* ModR/M points to 16 bits SSE variable */
	OT_XMM16,
	/* ModR/M points to 32 bits SSE variable */
	OT_XMM32,
	/* ModR/M points to 64 bits SSE variable */
	OT_XMM64,
	/* ModR/M points to 128 bits SSE variable */
	OT_XMM128,

	/* AVX operands: */
	/* XMM or Mem32/Mem64 depends on perfix width only. */
	OT_WXMM32_64,
	/* YMM or Mem256. */
	OT_YMM256,
	/* YMM/XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_YXMM64_256,
	/* YMM/XMM or Mem128/Mem256 is dependent on VEX.L. */
	OT_YXMM128_256,
	/* XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_LXMM64_128
} _OpType;

/* Flags for instruction: */

/* Empty flags indicator: */
#define INST_FLAGS_NONE (0)
/* The instruction we are going to decode requires ModR/M encoding. */
#define INST_MODRM_REQUIRED (1)
/* Special treatment for instructions which are in the divided-category but still needs the whole byte for ModR/M... */
#define INST_NOT_DIVIDED (1 << 1)
/*
 * Used explicitly in repeatable instructions,
 * which needs a suffix letter in their mnemonic to specify operation-size (depend on operands).
 */
#define INST_16BITS (1 << 2)
/* If the opcode is supported by 80286 and upper models (16/32 bits). */
#define INST_32BITS (1 << 3)
/*
 * Prefix flags (6 types: lock/rep, seg override, addr-size, oper-size, REX, VEX)
 * There are several specific instructions that can follow LOCK prefix,
 * note that they must be using a memory operand form, otherwise they generate an exception.
 */
#define INST_PRE_LOCK (1 << 4)
/* REPNZ prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REPNZ (1 << 5)
/* REP prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REP (1 << 6)
/* CS override prefix. */
#define INST_PRE_CS (1 << 7)
/* SS override prefix. */
#define INST_PRE_SS (1 << 8)
/* DS override prefix. */
#define INST_PRE_DS (1 << 9)
/* ES override prefix. */
#define INST_PRE_ES (1 << 10)
/* FS override prefix. Funky Segment :) */
#define INST_PRE_FS (1 << 11)
/* GS override prefix. Groovy Segment, of course not, duh ! */
#define INST_PRE_GS (1 << 12)
/* Switch operand size from 32 to 16 and vice versa. */
#define INST_PRE_OP_SIZE (1 << 13)
/* Switch address size from 32 to 16 and vice versa. */
#define INST_PRE_ADDR_SIZE (1 << 14)
/* Native instructions which needs suffix letter to indicate their operation-size (and don't depend on operands). */
#define INST_NATIVE (1 << 15)
/* Use extended mnemonic, means it's an _InstInfoEx structure, which contains another mnemonic for 32 bits specifically. */
#define INST_USE_EXMNEMONIC (1 << 16)
/* Use third operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP3 (1 << 17)
/* Use fourth operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP4 (1 << 18)
/* The instruction's mnemonic depends on the mod value of the ModR/M byte (mod=11, mod!=11). */
#define INST_MNEMONIC_MODRM_BASED (1 << 19)
/* The instruction uses a ModR/M byte which the MOD must be 11 (for registers operands only). */
#define INST_MODRR_REQUIRED (1 << 20)
/* The way of 3DNow! instructions are built, we have to handle their locating specially. Suffix imm8 tells which instruction it is. */
#define INST_3DNOW_FETCH (1 << 21)
/* The instruction needs two suffixes, one for the comparison type (imm8) and the second for its operation size indication (second mnemonic). */
#define INST_PSEUDO_OPCODE (1 << 22)
/* Invalid instruction at 64 bits decoding mode. */
#define INST_INVALID_64BITS (1 << 23)
/* Specific instruction can be promoted to 64 bits (without REX, it is promoted automatically). */
#define INST_64BITS (1 << 24)
/* Indicates the instruction must be REX prefixed in order to use 64 bits operands. */
#define INST_PRE_REX (1 << 25)
/* Third mnemonic is set. */
#define INST_USE_EXMNEMONIC2 (1 << 26)
/* Instruction is only valid in 64 bits decoding mode. */
#define INST_64BITS_FETCH (1 << 27)
/* Forces that the ModRM-REG/Opcode field will be 0. (For EXTRQ). */
#define INST_FORCE_REG0 (1 << 28)
/* Indicates that instruction is encoded with a VEX prefix. */
#define INST_PRE_VEX (1 << 29)
/* Indicates that the instruction is encoded with a ModRM byte (REG field specifically). */
#define INST_MODRM_INCLUDED (1 << 30)
/* Indicates that the first (/destination) operand of the instruction is writable. */
#define INST_DST_WR (1 << 31)

#define INST_PRE_REPS (INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_LOKREP_MASK (INST_PRE_LOCK | INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_SEGOVRD_MASK32 (INST_PRE_CS | INST_PRE_SS | INST_PRE_DS | INST_PRE_ES)
#define INST_PRE_SEGOVRD_MASK64 (INST_PRE_FS | INST_PRE_GS)
#define INST_PRE_SEGOVRD_MASK (INST_PRE_SEGOVRD_MASK32 | INST_PRE_SEGOVRD_MASK64)

/* Extended flags for VEX: */
/* Indicates that the instruction might have VEX.L encoded. */
#define INST_VEX_L (1)
/* Indicates that the instruction might have VEX.W encoded. */
#define INST_VEX_W (1 << 1)
/* Indicates that the mnemonic of the instruction is based on the VEX.W bit. */
#define INST_MNEMONIC_VEXW_BASED (1 << 2)
/* Indicates that the mnemonic of the instruction is based on the VEX.L bit. */
#define INST_MNEMONIC_VEXL_BASED (1 << 3)
/* Forces the instruction to be encoded with VEX.L, otherwise it's undefined. */
#define INST_FORCE_VEXL (1 << 4)
/*
 * Indicates that the instruction is based on the MOD field of the ModRM byte.
 * (MOD==11: got the right instruction, else skip +4 in prefixed table for the correct instruction).
 */
#define INST_MODRR_BASED (1 << 5)
/* Indicates that the instruction doesn't use the VVVV field of the VEX prefix, if it does then it's undecodable. */
#define INST_VEX_V_UNUSED (1 << 6)

/* Indication that the instruction is privileged (Ring 0), this should be checked on the opcodeId field. */
#define META_INST_PRIVILEGED ((uint16_t)0x8000)

/*
 * Indicates which operand is being decoded.
 * Destination (1st), Source (2nd), op3 (3rd), op4 (4th).
 * Used to set the operands' fields in the _DInst structure!
 */
typedef enum {ONT_NONE = -1, ONT_1 = 0, ONT_2 = 1, ONT_3 = 2, ONT_4 = 3} _OperandNumberType;

/* CPU Flags that instructions modify, test or undefine, in compacted form (CF,PF,AF,ZF,SF are 1:1 map to EFLAGS). */
#define D_COMPACT_CF 1		/* Carry */
#define D_COMPACT_PF 4		/* Parity */
#define D_COMPACT_AF 0x10	/* Auxiliary */
#define D_COMPACT_ZF 0x40	/* Zero */
#define D_COMPACT_SF 0x80	/* Sign */
/* The following flags have to be translated to EFLAGS. */
#define D_COMPACT_IF 2		/* Interrupt */
#define D_COMPACT_DF 8		/* Direction */
#define D_COMPACT_OF 0x20	/* Overflow */

/* The mask of flags that are already compatible with EFLAGS. */
#define D_COMPACT_SAME_FLAGS (D_COMPACT_CF | D_COMPACT_PF | D_COMPACT_AF | D_COMPACT_ZF | D_COMPACT_SF)

/*
 * In order to save more space for storing the DB statically,
 * I came up with another level of shared info.
 * Because I saw that most of the information that instructions use repeats itself.
 *
 * Info about the instruction, source/dest types, meta and flags.
 * _InstInfo points to a table of _InstSharedInfo.
 */
typedef struct {
	uint8_t flagsIndex; /* An index into FlagsTables */
	uint8_t s, d; /* OpType. */
	/*
	 * The following are CPU flag masks that the instruction changes.
	 * The flags are compacted so 8 bits representation is enough.
	 * They will be expanded in runtime to be compatible to EFLAGS.
	 */
	uint8_t modifiedFlagsMask;
	uint8_t testedFlagsMask;
	uint8_t undefinedFlagsMask;
	uint16_t meta; /* High byte = Instruction set class | Low byte = flow control flags. */
} _InstSharedInfo;

/*
 * This structure is used for the instructions DB and NOT for the disassembled result code!
 * This is the BASE structure, there are extensions to this structure below.
 */
typedef struct {
	uint16_t sharedIndex; /* An index into the SharedInfoTable. */
	uint16_t opcodeId; /* The opcodeId is really a byte-offset into the mnemonics table. MSB is a privileged indication. */
} _InstInfo;

/*
 * There are merely few instructions which need a second mnemonic for 32 bits.
 * Or a third for 64 bits. Therefore sometimes the second mnemonic is empty but not the third.
 * In all decoding modes the first mnemonic is the default.
 * A flag will indicate it uses another mnemonic.
 *
 * There are a couple of (SSE4) instructions in the whole DB which need both op3 and 3rd mnemonic for 64bits,
 * therefore, I decided to make the extended structure contain all extra info in the same structure.
 * There are a few instructions (SHLD/SHRD/IMUL and SSE too) which use third operand (or a fourth).
 * A flag will indicate it uses a third/fourth operand.
 */
typedef struct {
	/* Base structure (doesn't get accessed directly from code). */
	_InstInfo BASE;

	/* Extended starts here. */
	uint8_t flagsEx; /* 8 bits are enough, in the future we might make it a bigger integer. */
	uint8_t op3, op4; /* OpType. */
	uint16_t opcodeId2, opcodeId3;
} _InstInfoEx;

/* Trie data structure node type: */
typedef enum {
	INT_NOTEXISTS = 0, /* Not exists. */
	INT_INFO = 1, /* It's an instruction info. */
	INT_INFOEX,
	INT_INFO_TREAT, /* Extra intervention is required by inst_lookup. */
	INT_LIST_GROUP,
	INT_LIST_FULL,
	INT_LIST_DIVIDED,
	INT_LIST_PREFIXED
} _InstNodeType;

/* Used to check instType < INT_INFOS, means we got an inst-info. Cause it has to be only one of them. */
#define INT_INFOS (INT_LIST_GROUP)

/* Instruction node is treated as { int index:13;  int type:3; } */
typedef uint16_t _InstNode;

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps, int* isPrefixed);
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci);

#endif /* INSTRUCTIONS_H */


```

`NativeCore/Dependencies/distorm/src/insts.c`:

```c
/*
insts.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "insts.h"
#include "instructions.h"


/*
 * GENERATED BY disOps at Sat Apr  3 17:52:58 2021
 */

_InstInfo II_MOVSXD =	/*II*/ {0x1d7, 10039};
_InstInfo II_NOP =	/*II*/ {0x53, 581};
_InstInfo II_PAUSE =	/*II*/ {0x91, 10047};
_InstInfo II_WAIT =	/*II*/ {0x53, 10054};
_InstInfo II_RDRAND =	/*II*/ {0x1d8, 10060};
_InstInfo II_3DNOW =	/*II*/ {0x1d9, 10068};

_iflags FlagsTable[101] = {
0x80000011,
0x80000000,
0x800400,
0x80800400,
0x800080,
0x800100,
0x80800100,
0x800200,
0x80800200,
0x800000,
0x1,
0x0,
0x80800000,
0x1000000,
0x81000000,
0x808000,
0x800001,
0x80020001,
0x1002000,
0x60,
0x64,
0x80000001,
0x4010000,
0x1008000,
0x80000060,
0x83000064,
0x3000064,
0x83000000,
0x3008000,
0x200,
0xc000,
0x4014000,
0x8,
0x81000009,
0x80000009,
0x1000808,
0x81000808,
0x80020009,
0x1001008,
0x81001008,
0x80000019,
0x3000009,
0x83000009,
0x83000008,
0xc0000011,
0x40000001,
0xc0800011,
0x40800001,
0xc0000019,
0xc1000001,
0xc0000001,
0xc0000003,
0x41000000,
0x40000000,
0x40000008,
0x40000009,
0x41000001,
0x43000001,
0x40000003,
0x48000000,
0x200009,
0x20000009,
0x60020009,
0x60000009,
0x80090009,
0x200b0009,
0x20020009,
0x9,
0x80100009,
0x21100009,
0x87000009,
0x20009,
0x20000008,
0x1000009,
0x10020009,
0x160009,
0x100009,
0x47000009,
0x47090009,
0x40090009,
0x80002009,
0xc0000009,
0x2001,
0x80002001,
0x410009,
0x20420009,
0x20060009,
0x120009,
0x21020009,
0xc7000019,
0x20100009,
0xc0002009,
0x40002008,
0xc0000000,
0xc0002008,
0x4020009,
0x40100009,
0x60120009,
0x41000009,
0x83000001,
0x200001
};

_InstNode Table_0F = 256;
_InstNode Table_0F_0F = 1440;
_InstNode Table_0F_38 = 1896;
_InstNode Table_0F_3A = 2152;

_InstInfo InstInfos[1248] = {
	/*II_00*/ {0x0, 11},
	/*II_01*/ {0x1, 11},
	/*II_02*/ {0x2, 11},
	/*II_03*/ {0x3, 11},
	/*II_04*/ {0x4, 11},
	/*II_05*/ {0x5, 11},
	/*II_06*/ {0x6, 16},
	/*II_07*/ {0x7, 22},
	/*II_08*/ {0x8, 27},
	/*II_09*/ {0x9, 27},
	/*II_0A*/ {0xa, 27},
	/*II_0B*/ {0xb, 27},
	/*II_0C*/ {0xc, 27},
	/*II_0D*/ {0xd, 27},
	/*II_0E*/ {0xe, 16},
	/*II_10*/ {0xf, 31},
	/*II_11*/ {0x10, 31},
	/*II_12*/ {0x11, 31},
	/*II_13*/ {0x12, 31},
	/*II_14*/ {0x13, 31},
	/*II_15*/ {0x14, 31},
	/*II_16*/ {0x15, 16},
	/*II_17*/ {0x16, 22},
	/*II_18*/ {0xf, 36},
	/*II_19*/ {0x10, 36},
	/*II_1A*/ {0x11, 36},
	/*II_1B*/ {0x12, 36},
	/*II_1C*/ {0x13, 36},
	/*II_1D*/ {0x14, 36},
	/*II_1E*/ {0x17, 16},
	/*II_1F*/ {0x18, 22},
	/*II_20*/ {0x19, 41},
	/*II_21*/ {0x1a, 41},
	/*II_22*/ {0x1b, 41},
	/*II_23*/ {0x1c, 41},
	/*II_24*/ {0x1d, 41},
	/*II_25*/ {0x1e, 41},
	/*II_27*/ {0x1f, 46},
	/*II_28*/ {0x0, 51},
	/*II_29*/ {0x1, 51},
	/*II_2A*/ {0x2, 51},
	/*II_2B*/ {0x3, 51},
	/*II_2C*/ {0x4, 51},
	/*II_2D*/ {0x5, 51},
	/*II_2F*/ {0x1f, 56},
	/*II_30*/ {0x20, 61},
	/*II_31*/ {0x21, 61},
	/*II_32*/ {0x22, 61},
	/*II_33*/ {0x23, 61},
	/*II_34*/ {0x24, 61},
	/*II_35*/ {0x25, 61},
	/*II_37*/ {0x26, 66},
	/*II_38*/ {0x27, 71},
	/*II_39*/ {0x28, 71},
	/*II_3A*/ {0x29, 71},
	/*II_3B*/ {0x2a, 71},
	/*II_3C*/ {0x2b, 71},
	/*II_3D*/ {0x2c, 71},
	/*II_3F*/ {0x26, 76},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_60*/ {0x30, 91},
	/*II_61*/ {0x30, 98},
	/*II_62*/ {0x31, 104},
	/*II_63*/ {0x32, 111},
	/*II_68*/ {0x33, 16},
	/*II_6A*/ {0x35, 16},
	/*II_6C*/ {0x36, 123},
	/*II_6D*/ {0x37, 123},
	/*II_6E*/ {0x38, 128},
	/*II_6F*/ {0x39, 128},
	/*II_70*/ {0x3a, 134},
	/*II_71*/ {0x3a, 138},
	/*II_72*/ {0x3b, 143},
	/*II_73*/ {0x3b, 147},
	/*II_74*/ {0x3c, 152},
	/*II_75*/ {0x3c, 156},
	/*II_76*/ {0x3d, 161},
	/*II_77*/ {0x3d, 166},
	/*II_78*/ {0x3e, 170},
	/*II_79*/ {0x3e, 174},
	/*II_7A*/ {0x3f, 179},
	/*II_7B*/ {0x3f, 183},
	/*II_7C*/ {0x40, 188},
	/*II_7D*/ {0x40, 192},
	/*II_7E*/ {0x41, 197},
	/*II_7F*/ {0x41, 202},
	/*II_84*/ {0x42, 206},
	/*II_85*/ {0x43, 206},
	/*II_86*/ {0x44, 212},
	/*II_87*/ {0x45, 212},
	/*II_88*/ {0x46, 218},
	/*II_89*/ {0x47, 218},
	/*II_8A*/ {0x48, 218},
	/*II_8B*/ {0x49, 218},
	/*II_8C*/ {0x4a, 218},
	/*II_8D*/ {0x4b, 223},
	/*II_8E*/ {0x4c, 218},
	/*II_90*/ {0x4d, 212},
	/*II_91*/ {0x4d, 212},
	/*II_92*/ {0x4d, 212},
	/*II_93*/ {0x4d, 212},
	/*II_94*/ {0x4d, 212},
	/*II_95*/ {0x4d, 212},
	/*II_96*/ {0x4d, 212},
	/*II_97*/ {0x4d, 212},
	/*II_9A*/ {0x4f, 260},
	/*II_9C*/ {0x50, 270},
	/*II_9D*/ {0x51, 277},
	/*II_9E*/ {0x52, 283},
	/*II_9F*/ {0x53, 289},
	/*II_A0*/ {0x54, 218},
	/*II_A1*/ {0x55, 218},
	/*II_A2*/ {0x56, 218},
	/*II_A3*/ {0x57, 218},
	/*II_A4*/ {0x58, 295},
	/*II_A5*/ {0x59, 295},
	/*II_A6*/ {0x5a, 301},
	/*II_A7*/ {0x5b, 301},
	/*II_A8*/ {0x5c, 206},
	/*II_A9*/ {0x5d, 206},
	/*II_AA*/ {0x5e, 307},
	/*II_AB*/ {0x5f, 307},
	/*II_AC*/ {0x60, 313},
	/*II_AD*/ {0x61, 313},
	/*II_AE*/ {0x62, 319},
	/*II_AF*/ {0x63, 319},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_C2*/ {0x66, 325},
	/*II_C3*/ {0x67, 325},
	/*II_C4*/ {0x68, 330},
	/*II_C5*/ {0x68, 335},
	/*II_C8*/ {0x69, 340},
	/*II_C9*/ {0x6a, 347},
	/*II_CA*/ {0x6b, 354},
	/*II_CB*/ {0x6c, 354},
	/*II_CC*/ {0x6d, 360},
	/*II_CD*/ {0x6e, 367},
	/*II_CE*/ {0x6f, 372},
	/*II_CF*/ {0x70, 378},
	/*II_D4*/ {0x71, 384},
	/*II_D5*/ {0x71, 389},
	/*II_D6*/ {0x72, 394},
	/*II_D7*/ {0x73, 400},
	/*II_E0*/ {0x74, 406},
	/*II_E1*/ {0x74, 414},
	/*II_E2*/ {0x75, 421},
	/*II_E4*/ {0x77, 447},
	/*II_E5*/ {0x78, 447},
	/*II_E6*/ {0x79, 451},
	/*II_E7*/ {0x7a, 451},
	/*II_E8*/ {0x7b, 456},
	/*II_E9*/ {0x7c, 462},
	/*II_EA*/ {0x7d, 467},
	/*II_EB*/ {0x7e, 462},
	/*II_EC*/ {0x7f, 447},
	/*II_ED*/ {0x80, 447},
	/*II_EE*/ {0x81, 451},
	/*II_EF*/ {0x82, 451},
	/*II_F1*/ {0x6d, 476},
	/*II_F4*/ {0x83, 482},
	/*II_F5*/ {0x84, 487},
	/*II_F8*/ {0x84, 492},
	/*II_F9*/ {0x84, 497},
	/*II_FA*/ {0x85, 502},
	/*II_FB*/ {0x85, 507},
	/*II_FC*/ {0x86, 512},
	/*II_FD*/ {0x86, 517},
	/*II_0F_02*/ {0x87, 522},
	/*II_0F_03*/ {0x87, 527},
	/*II_0F_05*/ {0x88, 532},
	/*II_0F_06*/ {0x89, 541},
	/*II_0F_07*/ {0x88, 547},
	/*II_0F_08*/ {0x89, 555},
	/*II_0F_09*/ {0x89, 561},
	/*II_0F_0B*/ {0x8a, 569},
	/*II_0F_0E*/ {0x8b, 574},
	/*II_0F_1F*/ {0x8c, 581},
	/*II_0F_20*/ {0x8d, 218},
	/*II_0F_21*/ {0x8e, 218},
	/*II_0F_22*/ {0x8f, 218},
	/*II_0F_23*/ {0x90, 218},
	/*II_0F_30*/ {0x89, 586},
	/*II_0F_31*/ {0x89, 593},
	/*II_0F_32*/ {0x89, 600},
	/*II_0F_33*/ {0x89, 607},
	/*II_0F_34*/ {0x88, 614},
	/*II_0F_35*/ {0x88, 624},
	/*II_0F_37*/ {0x91, 633},
	/*II_0F_40*/ {0x92, 641},
	/*II_0F_41*/ {0x92, 648},
	/*II_0F_42*/ {0x93, 656},
	/*II_0F_43*/ {0x93, 663},
	/*II_0F_44*/ {0x94, 671},
	/*II_0F_45*/ {0x94, 678},
	/*II_0F_46*/ {0x95, 686},
	/*II_0F_47*/ {0x95, 694},
	/*II_0F_48*/ {0x96, 701},
	/*II_0F_49*/ {0x96, 708},
	/*II_0F_4A*/ {0x97, 716},
	/*II_0F_4B*/ {0x97, 723},
	/*II_0F_4C*/ {0x98, 731},
	/*II_0F_4D*/ {0x98, 738},
	/*II_0F_4E*/ {0x99, 746},
	/*II_0F_4F*/ {0x99, 754},
	/*II_0F_80*/ {0x9a, 134},
	/*II_0F_81*/ {0x9a, 138},
	/*II_0F_82*/ {0x9b, 143},
	/*II_0F_83*/ {0x9b, 147},
	/*II_0F_84*/ {0x9c, 152},
	/*II_0F_85*/ {0x9c, 156},
	/*II_0F_86*/ {0x9d, 161},
	/*II_0F_87*/ {0x9d, 166},
	/*II_0F_88*/ {0x9e, 170},
	/*II_0F_89*/ {0x9e, 174},
	/*II_0F_8A*/ {0x9f, 179},
	/*II_0F_8B*/ {0x9f, 183},
	/*II_0F_8C*/ {0xa0, 188},
	/*II_0F_8D*/ {0xa0, 192},
	/*II_0F_8E*/ {0xa1, 197},
	/*II_0F_8F*/ {0xa1, 202},
	/*II_0F_90*/ {0xa2, 761},
	/*II_0F_91*/ {0xa2, 767},
	/*II_0F_92*/ {0xa3, 774},
	/*II_0F_93*/ {0xa3, 780},
	/*II_0F_94*/ {0xa4, 787},
	/*II_0F_95*/ {0xa4, 793},
	/*II_0F_96*/ {0xa5, 800},
	/*II_0F_97*/ {0xa5, 807},
	/*II_0F_98*/ {0xa6, 813},
	/*II_0F_99*/ {0xa6, 819},
	/*II_0F_9A*/ {0xa7, 826},
	/*II_0F_9B*/ {0xa7, 832},
	/*II_0F_9C*/ {0xa8, 839},
	/*II_0F_9D*/ {0xa8, 845},
	/*II_0F_9E*/ {0xa9, 852},
	/*II_0F_9F*/ {0xa9, 859},
	/*II_0F_A0*/ {0xaa, 16},
	/*II_0F_A1*/ {0xab, 22},
	/*II_0F_A2*/ {0x91, 865},
	/*II_0F_A3*/ {0xac, 872},
	/*II_0F_A8*/ {0xae, 16},
	/*II_0F_A9*/ {0xaf, 22},
	/*II_0F_AA*/ {0xb0, 882},
	/*II_0F_AB*/ {0xb1, 887},
	/*II_0F_AF*/ {0xb2, 117},
	/*II_0F_B0*/ {0xb3, 898},
	/*II_0F_B1*/ {0xb4, 898},
	/*II_0F_B2*/ {0xb5, 907},
	/*II_0F_B3*/ {0xb1, 912},
	/*II_0F_B4*/ {0xb5, 917},
	/*II_0F_B5*/ {0xb5, 922},
	/*II_0F_B6*/ {0xb6, 927},
	/*II_0F_B7*/ {0xb7, 927},
	/*II_0F_B9*/ {0x8a, 569},
	/*II_0F_BB*/ {0xb1, 934},
	/*II_0F_BE*/ {0xb6, 939},
	/*II_0F_BF*/ {0xb7, 939},
	/*II_0F_C0*/ {0xb3, 946},
	/*II_0F_C1*/ {0xb4, 946},
	/*II_0F_C3*/ {0xb8, 952},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_0F_C8*/ {0xb9, 960},
	/*II_80_00*/ {0xba, 11},
	/*II_80_01*/ {0xbb, 27},
	/*II_80_02*/ {0xbc, 31},
	/*II_80_03*/ {0xbc, 36},
	/*II_80_04*/ {0xbd, 41},
	/*II_80_05*/ {0xba, 51},
	/*II_80_06*/ {0xbe, 61},
	/*II_80_07*/ {0xbf, 71},
	/*II_81_00*/ {0xc0, 11},
	/*II_81_01*/ {0xc1, 27},
	/*II_81_02*/ {0xc2, 31},
	/*II_81_03*/ {0xc2, 36},
	/*II_81_04*/ {0xc3, 41},
	/*II_81_05*/ {0xc0, 51},
	/*II_81_06*/ {0xc4, 61},
	/*II_81_07*/ {0xc5, 71},
	/*II_82_00*/ {0xc6, 11},
	/*II_82_01*/ {0xc7, 27},
	/*II_82_02*/ {0xc8, 31},
	/*II_82_03*/ {0xc8, 36},
	/*II_82_04*/ {0xc9, 41},
	/*II_82_05*/ {0xc6, 51},
	/*II_82_06*/ {0xca, 61},
	/*II_82_07*/ {0xcb, 71},
	/*II_83_00*/ {0xcc, 11},
	/*II_83_01*/ {0xcd, 27},
	/*II_83_02*/ {0xce, 31},
	/*II_83_03*/ {0xce, 36},
	/*II_83_04*/ {0xcf, 41},
	/*II_83_05*/ {0xcc, 51},
	/*II_83_06*/ {0xd0, 61},
	/*II_83_07*/ {0xd1, 71},
	/*II_8F_00*/ {0xd2, 22},
	/*II_C0_00*/ {0xd3, 967},
	/*II_C0_01*/ {0xd3, 972},
	/*II_C0_02*/ {0xd4, 977},
	/*II_C0_03*/ {0xd4, 982},
	/*II_C0_04*/ {0xd5, 987},
	/*II_C0_05*/ {0xd5, 992},
	/*II_C0_06*/ {0xd5, 997},
	/*II_C0_07*/ {0xd5, 1002},
	/*II_C1_00*/ {0xd6, 967},
	/*II_C1_01*/ {0xd6, 972},
	/*II_C1_02*/ {0xd7, 977},
	/*II_C1_03*/ {0xd7, 982},
	/*II_C1_04*/ {0xd8, 987},
	/*II_C1_05*/ {0xd8, 992},
	/*II_C1_06*/ {0xd8, 997},
	/*II_C1_07*/ {0xd8, 1002},
	/*II_C6_00*/ {0xd9, 218},
	/*II_C6_F8*/ {0xda, 1007},
	/*II_C7_00*/ {0xdb, 218},
	/*II_C7_F8*/ {0xdc, 1015},
	/*II_D0_00*/ {0xdd, 967},
	/*II_D0_01*/ {0xdd, 972},
	/*II_D0_02*/ {0xde, 977},
	/*II_D0_03*/ {0xde, 982},
	/*II_D0_04*/ {0xdf, 987},
	/*II_D0_05*/ {0xdf, 992},
	/*II_D0_06*/ {0xdf, 997},
	/*II_D0_07*/ {0xdf, 1002},
	/*II_D1_00*/ {0xe0, 967},
	/*II_D1_01*/ {0xe0, 972},
	/*II_D1_02*/ {0xe1, 977},
	/*II_D1_03*/ {0xe1, 982},
	/*II_D1_04*/ {0xe2, 987},
	/*II_D1_05*/ {0xe2, 992},
	/*II_D1_06*/ {0xe2, 997},
	/*II_D1_07*/ {0xe2, 1002},
	/*II_D2_00*/ {0xe3, 967},
	/*II_D2_01*/ {0xe3, 972},
	/*II_D2_02*/ {0xe4, 977},
	/*II_D2_03*/ {0xe4, 982},
	/*II_D2_04*/ {0xe5, 987},
	/*II_D2_05*/ {0xe5, 992},
	/*II_D2_06*/ {0xe5, 997},
	/*II_D2_07*/ {0xe5, 1002},
	/*II_D3_00*/ {0xe6, 967},
	/*II_D3_01*/ {0xe6, 972},
	/*II_D3_02*/ {0xe7, 977},
	/*II_D3_03*/ {0xe7, 982},
	/*II_D3_04*/ {0xe8, 987},
	/*II_D3_05*/ {0xe8, 992},
	/*II_D3_06*/ {0xe8, 997},
	/*II_D3_07*/ {0xe8, 1002},
	/*II_D8_00*/ {0xe9, 1023},
	/*II_D8_01*/ {0xe9, 1029},
	/*II_D8_02*/ {0xe9, 1035},
	/*II_D8_03*/ {0xe9, 1041},
	/*II_D8_04*/ {0xe9, 1048},
	/*II_D8_05*/ {0xe9, 1054},
	/*II_D8_06*/ {0xe9, 1061},
	/*II_D8_07*/ {0xe9, 1067},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C0*/ {0xea, 1023},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_C8*/ {0xea, 1029},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D0*/ {0xeb, 1035},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D9*/ {0xec, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_D8*/ {0xeb, 1041},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E0*/ {0xea, 1048},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_E8*/ {0xea, 1054},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F0*/ {0xea, 1061},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D8_F8*/ {0xea, 1067},
	/*II_D9_00*/ {0xe9, 1074},
	/*II_D9_02*/ {0xed, 1079},
	/*II_D9_03*/ {0xed, 1084},
	/*II_D9_04*/ {0xee, 1090},
	/*II_D9_05*/ {0xef, 1098},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C0*/ {0xeb, 1074},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C9*/ {0xec, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_C8*/ {0xeb, 1105},
	/*II_D9_D0*/ {0xec, 1111},
	/*II_D9_E0*/ {0xec, 1117},
	/*II_D9_E1*/ {0xec, 1123},
	/*II_D9_E4*/ {0xec, 1129},
	/*II_D9_E5*/ {0xec, 1135},
	/*II_D9_E8*/ {0xec, 1141},
	/*II_D9_E9*/ {0xec, 1147},
	/*II_D9_EA*/ {0xec, 1155},
	/*II_D9_EB*/ {0xec, 1163},
	/*II_D9_EC*/ {0xec, 1170},
	/*II_D9_ED*/ {0xec, 1178},
	/*II_D9_EE*/ {0xec, 1186},
	/*II_D9_F0*/ {0xec, 1192},
	/*II_D9_F1*/ {0xec, 1199},
	/*II_D9_F2*/ {0xec, 1206},
	/*II_D9_F3*/ {0xec, 1213},
	/*II_D9_F4*/ {0xec, 1221},
	/*II_D9_F5*/ {0xec, 1230},
	/*II_D9_F6*/ {0xec, 1238},
	/*II_D9_F7*/ {0xec, 1247},
	/*II_D9_F8*/ {0xec, 1256},
	/*II_D9_F9*/ {0xec, 1263},
	/*II_D9_FA*/ {0xec, 1272},
	/*II_D9_FB*/ {0xec, 1279},
	/*II_D9_FC*/ {0xec, 1288},
	/*II_D9_FD*/ {0xec, 1297},
	/*II_D9_FE*/ {0xec, 1305},
	/*II_D9_FF*/ {0xec, 1311},
	/*II_DA_00*/ {0xe9, 1317},
	/*II_DA_01*/ {0xe9, 1324},
	/*II_DA_02*/ {0xe9, 1331},
	/*II_DA_03*/ {0xe9, 1338},
	/*II_DA_04*/ {0xe9, 1346},
	/*II_DA_05*/ {0xe9, 1353},
	/*II_DA_06*/ {0xe9, 1361},
	/*II_DA_07*/ {0xe9, 1368},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C0*/ {0xf0, 1376},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_C8*/ {0xf1, 1384},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D0*/ {0xf2, 1392},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_D8*/ {0xf3, 1401},
	/*II_DA_E9*/ {0xec, 1409},
	/*II_DB_00*/ {0xe9, 1418},
	/*II_DB_01*/ {0xf4, 1424},
	/*II_DB_02*/ {0xed, 1432},
	/*II_DB_03*/ {0xed, 1438},
	/*II_DB_05*/ {0xf5, 1074},
	/*II_DB_07*/ {0xf6, 1084},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C0*/ {0xf0, 1445},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_C8*/ {0xf1, 1454},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D0*/ {0xf2, 1463},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_D8*/ {0xf3, 1473},
	/*II_DB_E0*/ {0xec, 1482},
	/*II_DB_E1*/ {0xec, 1488},
	/*II_DB_E4*/ {0xec, 1496},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_E8*/ {0xf7, 1504},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DB_F0*/ {0xf8, 1512},
	/*II_DC_00*/ {0xf9, 1023},
	/*II_DC_01*/ {0xf9, 1029},
	/*II_DC_02*/ {0xf9, 1035},
	/*II_DC_03*/ {0xf9, 1041},
	/*II_DC_04*/ {0xf9, 1048},
	/*II_DC_05*/ {0xf9, 1054},
	/*II_DC_06*/ {0xf9, 1061},
	/*II_DC_07*/ {0xf9, 1067},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C0*/ {0xfa, 1023},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_C8*/ {0xfa, 1029},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E0*/ {0xfa, 1054},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_E8*/ {0xfa, 1048},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F0*/ {0xfa, 1067},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DC_F8*/ {0xfa, 1061},
	/*II_DD_00*/ {0xf9, 1074},
	/*II_DD_01*/ {0xfb, 1424},
	/*II_DD_02*/ {0xfc, 1079},
	/*II_DD_03*/ {0xfc, 1084},
	/*II_DD_04*/ {0xee, 1519},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_C0*/ {0xeb, 1527},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D0*/ {0xeb, 1079},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_D8*/ {0xeb, 1084},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E1*/ {0xec, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E0*/ {0xfa, 1534},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E9*/ {0xec, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DD_E8*/ {0xeb, 1541},
	/*II_DE_00*/ {0xef, 1317},
	/*II_DE_01*/ {0xef, 1324},
	/*II_DE_02*/ {0xef, 1331},
	/*II_DE_03*/ {0xef, 1338},
	/*II_DE_04*/ {0xef, 1346},
	/*II_DE_05*/ {0xef, 1353},
	/*II_DE_06*/ {0xef, 1361},
	/*II_DE_07*/ {0xef, 1368},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C1*/ {0xec, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C0*/ {0xfa, 1549},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C9*/ {0xec, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_C8*/ {0xfa, 1556},
	/*II_DE_D9*/ {0xec, 1563},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E1*/ {0xec, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E0*/ {0xfa, 1571},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E9*/ {0xec, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_E8*/ {0xfa, 1579},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F1*/ {0xec, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F0*/ {0xfa, 1586},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F9*/ {0xec, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DE_F8*/ {0xfa, 1594},
	/*II_DF_00*/ {0xef, 1418},
	/*II_DF_01*/ {0xfd, 1424},
	/*II_DF_02*/ {0xfe, 1432},
	/*II_DF_03*/ {0xfe, 1438},
	/*II_DF_04*/ {0xf5, 1601},
	/*II_DF_05*/ {0xf9, 1418},
	/*II_DF_06*/ {0xf6, 1607},
	/*II_DF_07*/ {0xfc, 1438},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_E8*/ {0xf7, 1614},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_DF_F0*/ {0xf7, 1623},
	/*II_F6_00*/ {0xff, 206},
	/*II_F6_02*/ {0x100, 1631},
	/*II_F6_03*/ {0x101, 1636},
	/*II_F6_04*/ {0x102, 1641},
	/*II_F6_05*/ {0x102, 117},
	/*II_F6_06*/ {0x103, 1646},
	/*II_F6_07*/ {0x103, 1651},
	/*II_F7_00*/ {0x104, 206},
	/*II_F7_02*/ {0x105, 1631},
	/*II_F7_03*/ {0x106, 1636},
	/*II_F7_04*/ {0x107, 1641},
	/*II_F7_05*/ {0x107, 117},
	/*II_F7_06*/ {0x108, 1646},
	/*II_F7_07*/ {0x108, 1651},
	/*II_FE_00*/ {0x109, 81},
	/*II_FE_01*/ {0x109, 86},
	/*II_FF_00*/ {0x10a, 81},
	/*II_FF_01*/ {0x10a, 86},
	/*II_FF_02*/ {0x10b, 456},
	/*II_FF_03*/ {0x10c, 260},
	/*II_FF_04*/ {0x10d, 462},
	/*II_FF_05*/ {0x10e, 467},
	/*II_FF_06*/ {0x10f, 16},
	/*II_0F_00_00*/ {0x110, 1657},
	/*II_0F_00_01*/ {0x111, 1663},
	/*II_0F_00_02*/ {0x112, 1668},
	/*II_0F_00_03*/ {0x113, 1674},
	/*II_0F_00_04*/ {0x114, 1679},
	/*II_0F_00_05*/ {0x114, 1685},
	/*II_0F_01_00*/ {0x115, 1691},
	/*II_0F_01_01*/ {0x115, 1697},
	/*II_0F_01_02*/ {0x116, 1703},
	/*II_0F_01_03*/ {0x116, 1709},
	/*II_0F_01_04*/ {0x117, 1715},
	/*II_0F_01_06*/ {0x118, 1721},
	/*II_0F_01_07*/ {0x119, 1727},
	/*II_0F_01_C1*/ {0x11a, 1735},
	/*II_0F_01_C2*/ {0x11a, 1743},
	/*II_0F_01_C3*/ {0x11a, 1753},
	/*II_0F_01_C4*/ {0x11a, 1763},
	/*II_0F_01_C8*/ {0x11b, 1771},
	/*II_0F_01_C9*/ {0x11b, 1780},
	/*II_0F_01_CA*/ {0x11b, 1787},
	/*II_0F_01_CB*/ {0x11b, 1793},
	/*II_0F_01_D0*/ {0x91, 1799},
	/*II_0F_01_D1*/ {0x91, 1807},
	/*II_0F_01_D4*/ {0x11a, 1815},
	/*II_0F_01_D5*/ {0x11c, 1823},
	/*II_0F_01_D8*/ {0x11d, 1829},
	/*II_0F_01_D9*/ {0x11e, 1836},
	/*II_0F_01_DA*/ {0x11f, 1845},
	/*II_0F_01_DB*/ {0x11f, 1853},
	/*II_0F_01_DC*/ {0x11e, 1861},
	/*II_0F_01_DD*/ {0x11e, 1867},
	/*II_0F_01_DE*/ {0x11f, 1873},
	/*II_0F_01_DF*/ {0x120, 1881},
	/*II_0F_01_F8*/ {0x121, 1890},
	/*II_0F_01_F9*/ {0x121, 1898},
	/*II_0F_0D_00*/ {0x122, 1906},
	/*II_0F_0D_01*/ {0x122, 1916},
	/*II_0F_0F_0C*/ {0x123, 1927},
	/*II_0F_0F_0D*/ {0x124, 1934},
	/*II_0F_0F_1C*/ {0x123, 1941},
	/*II_0F_0F_1D*/ {0x124, 1948},
	/*II_0F_0F_8A*/ {0x123, 1955},
	/*II_0F_0F_8E*/ {0x123, 1963},
	/*II_0F_0F_90*/ {0x124, 1972},
	/*II_0F_0F_94*/ {0x124, 1981},
	/*II_0F_0F_96*/ {0x124, 1988},
	/*II_0F_0F_97*/ {0x124, 1995},
	/*II_0F_0F_9A*/ {0x124, 2004},
	/*II_0F_0F_9E*/ {0x124, 2011},
	/*II_0F_0F_A0*/ {0x124, 2018},
	/*II_0F_0F_A4*/ {0x124, 2027},
	/*II_0F_0F_A6*/ {0x124, 2034},
	/*II_0F_0F_A7*/ {0x124, 2044},
	/*II_0F_0F_AA*/ {0x124, 2054},
	/*II_0F_0F_AE*/ {0x124, 2062},
	/*II_0F_0F_B0*/ {0x124, 2069},
	/*II_0F_0F_B4*/ {0x124, 2078},
	/*II_0F_0F_B6*/ {0x124, 2085},
	/*II_0F_0F_B7*/ {0x124, 2095},
	/*II_0F_0F_BB*/ {0x123, 2104},
	/*II_0F_0F_BF*/ {0x124, 2112},
	/*II_0F_10*/ {0x125, 2121},
	/*II_66_0F_10*/ {0x126, 2129},
	/*II_F3_0F_10*/ {0x127, 2137},
	/*II_F2_0F_10*/ {0x128, 2144},
	/*II_0F_11*/ {0x12d, 2121},
	/*II_66_0F_11*/ {0x12e, 2129},
	/*II_F3_0F_11*/ {0x12f, 2137},
	/*II_F2_0F_11*/ {0x130, 2144},
	/*II_66_0F_12*/ {0x135, 2202},
	/*II_F3_0F_12*/ {0x136, 2210},
	/*II_F2_0F_12*/ {0x136, 2220},
	/*II_0F_13*/ {0x13a, 2194},
	/*II_66_0F_13*/ {0x13b, 2202},
	/*II_0F_14*/ {0x13d, 2278},
	/*II_66_0F_14*/ {0x13e, 2288},
	/*II_0F_15*/ {0x13d, 2320},
	/*II_66_0F_15*/ {0x13e, 2330},
	/*II_66_0F_16*/ {0x135, 2379},
	/*II_F3_0F_16*/ {0x140, 2387},
	/*II_0F_17*/ {0x13a, 2371},
	/*II_66_0F_17*/ {0x13b, 2379},
	/*II_0F_18_00*/ {0x141, 2436},
	/*II_0F_18_01*/ {0x141, 2449},
	/*II_0F_18_02*/ {0x141, 2461},
	/*II_0F_18_03*/ {0x141, 2473},
	/*II_0F_28*/ {0x125, 2485},
	/*II_66_0F_28*/ {0x126, 2493},
	/*II_0F_29*/ {0x12d, 2485},
	/*II_66_0F_29*/ {0x12e, 2493},
	/*II_0F_2A*/ {0x142, 2519},
	/*II_66_0F_2A*/ {0x143, 2529},
	/*II_F3_0F_2A*/ {0x144, 2539},
	/*II_F2_0F_2A*/ {0x145, 2549},
	/*II_0F_2B*/ {0x146, 2581},
	/*II_66_0F_2B*/ {0x147, 2590},
	/*II_F3_0F_2B*/ {0x148, 2599},
	/*II_F2_0F_2B*/ {0x149, 2608},
	/*II_0F_2C*/ {0x14b, 2637},
	/*II_66_0F_2C*/ {0x14c, 2648},
	/*II_F3_0F_2C*/ {0x14d, 2659},
	/*II_F2_0F_2C*/ {0x14e, 2670},
	/*II_0F_2D*/ {0x14b, 2705},
	/*II_66_0F_2D*/ {0x13e, 2715},
	/*II_F3_0F_2D*/ {0x14d, 2725},
	/*II_F2_0F_2D*/ {0x14e, 2735},
	/*II_0F_2E*/ {0x150, 2767},
	/*II_66_0F_2E*/ {0x151, 2776},
	/*II_0F_2F*/ {0x150, 2805},
	/*II_66_0F_2F*/ {0x151, 2813},
	/*II_0F_50*/ {0x154, 2839},
	/*II_66_0F_50*/ {0x155, 2849},
	/*II_0F_51*/ {0x13d, 2881},
	/*II_66_0F_51*/ {0x13e, 2889},
	/*II_F3_0F_51*/ {0x157, 2897},
	/*II_F2_0F_51*/ {0x151, 2905},
	/*II_0F_52*/ {0x13d, 2949},
	/*II_F3_0F_52*/ {0x157, 2958},
	/*II_0F_53*/ {0x13d, 2987},
	/*II_F3_0F_53*/ {0x157, 2994},
	/*II_0F_54*/ {0x13d, 3017},
	/*II_66_0F_54*/ {0x13e, 3024},
	/*II_0F_55*/ {0x13d, 3047},
	/*II_66_0F_55*/ {0x13e, 3055},
	/*II_0F_56*/ {0x13d, 3081},
	/*II_66_0F_56*/ {0x13e, 3087},
	/*II_0F_57*/ {0x13d, 3107},
	/*II_66_0F_57*/ {0x13e, 3114},
	/*II_0F_58*/ {0x13d, 3137},
	/*II_66_0F_58*/ {0x13e, 3144},
	/*II_F3_0F_58*/ {0x157, 3151},
	/*II_F2_0F_58*/ {0x151, 3158},
	/*II_0F_59*/ {0x13d, 3197},
	/*II_66_0F_59*/ {0x13e, 3204},
	/*II_F3_0F_59*/ {0x157, 3211},
	/*II_F2_0F_59*/ {0x151, 3218},
	/*II_0F_5A*/ {0x151, 3257},
	/*II_66_0F_5A*/ {0x13e, 3267},
	/*II_F3_0F_5A*/ {0x158, 3277},
	/*II_F2_0F_5A*/ {0x151, 3287},
	/*II_0F_5B*/ {0x13e, 3341},
	/*II_66_0F_5B*/ {0x13e, 3351},
	/*II_F3_0F_5B*/ {0x13e, 3361},
	/*II_0F_5C*/ {0x13d, 3406},
	/*II_66_0F_5C*/ {0x13e, 3413},
	/*II_F3_0F_5C*/ {0x157, 3420},
	/*II_F2_0F_5C*/ {0x151, 3427},
	/*II_0F_5D*/ {0x13d, 3466},
	/*II_66_0F_5D*/ {0x13e, 3473},
	/*II_F3_0F_5D*/ {0x157, 3480},
	/*II_F2_0F_5D*/ {0x151, 3487},
	/*II_0F_5E*/ {0x13d, 3526},
	/*II_66_0F_5E*/ {0x13e, 3533},
	/*II_F3_0F_5E*/ {0x157, 3540},
	/*II_F2_0F_5E*/ {0x151, 3547},
	/*II_0F_5F*/ {0x13d, 3586},
	/*II_66_0F_5F*/ {0x13e, 3593},
	/*II_F3_0F_5F*/ {0x157, 3600},
	/*II_F2_0F_5F*/ {0x151, 3607},
	/*II_0F_60*/ {0x15b, 3646},
	/*II_66_0F_60*/ {0x13e, 3646},
	/*II_0F_61*/ {0x15b, 3669},
	/*II_66_0F_61*/ {0x13e, 3669},
	/*II_0F_62*/ {0x15b, 3692},
	/*II_66_0F_62*/ {0x13e, 3692},
	/*II_0F_63*/ {0x15c, 3715},
	/*II_66_0F_63*/ {0x13e, 3715},
	/*II_0F_64*/ {0x15c, 3736},
	/*II_66_0F_64*/ {0x13e, 3736},
	/*II_0F_65*/ {0x15c, 3755},
	/*II_66_0F_65*/ {0x13e, 3755},
	/*II_0F_66*/ {0x15c, 3774},
	/*II_66_0F_66*/ {0x13e, 3774},
	/*II_0F_67*/ {0x15c, 3793},
	/*II_66_0F_67*/ {0x13e, 3793},
	/*II_0F_68*/ {0x15c, 3814},
	/*II_66_0F_68*/ {0x13e, 3814},
	/*II_0F_69*/ {0x15c, 3837},
	/*II_66_0F_69*/ {0x13e, 3837},
	/*II_0F_6A*/ {0x15c, 3860},
	/*II_66_0F_6A*/ {0x13e, 3860},
	/*II_0F_6B*/ {0x15c, 3883},
	/*II_66_0F_6B*/ {0x13e, 3883},
	/*II_66_0F_6C*/ {0x13e, 3904},
	/*II_66_0F_6D*/ {0x13e, 3929},
	/*II_0F_6F*/ {0x160, 3960},
	/*II_66_0F_6F*/ {0x126, 3980},
	/*II_F3_0F_6F*/ {0x126, 3988},
	/*II_0F_74*/ {0x15c, 4077},
	/*II_66_0F_74*/ {0x13e, 4077},
	/*II_0F_75*/ {0x15c, 4096},
	/*II_66_0F_75*/ {0x13e, 4096},
	/*II_0F_76*/ {0x15c, 4115},
	/*II_66_0F_76*/ {0x13e, 4115},
	/*II_0F_77*/ {0x164, 4134},
	/*II_0F_78*/ {0x166, 4162},
	/*II_0F_79*/ {0x169, 4186},
	/*II_66_0F_79*/ {0x16a, 4170},
	/*II_F2_0F_79*/ {0x16b, 4177},
	/*II_0F_7A_30*/ {0x16c, 4195},
	/*II_0F_7A_31*/ {0x16d, 4205},
	/*II_66_0F_7C*/ {0x16e, 4215},
	/*II_F2_0F_7C*/ {0x16e, 4223},
	/*II_66_0F_7D*/ {0x16e, 4249},
	/*II_F2_0F_7D*/ {0x16e, 4257},
	/*II_F3_0F_7E*/ {0x128, 3960},
	/*II_0F_7F*/ {0x172, 3960},
	/*II_66_0F_7F*/ {0x12e, 3980},
	/*II_F3_0F_7F*/ {0x12e, 3988},
	/*II_F3_0F_B8*/ {0x176, 4372},
	/*II_0F_BA_04*/ {0x177, 872},
	/*II_0F_BA_05*/ {0x178, 887},
	/*II_0F_BA_06*/ {0x178, 912},
	/*II_0F_BA_07*/ {0x178, 934},
	/*II_0F_BC*/ {0x179, 4380},
	/*II_F3_0F_BC*/ {0x17a, 4385},
	/*II_0F_BD*/ {0x179, 4392},
	/*II_F3_0F_BD*/ {0x17b, 4397},
	/*II_0F_C7_07*/ {0x18b, 6419},
	/*II_66_0F_D0*/ {0x16e, 6428},
	/*II_F2_0F_D0*/ {0x16e, 6438},
	/*II_0F_D1*/ {0x15c, 6470},
	/*II_66_0F_D1*/ {0x13e, 6470},
	/*II_0F_D2*/ {0x15c, 6485},
	/*II_66_0F_D2*/ {0x13e, 6485},
	/*II_0F_D3*/ {0x15c, 6500},
	/*II_66_0F_D3*/ {0x13e, 6500},
	/*II_0F_D4*/ {0x151, 6515},
	/*II_66_0F_D4*/ {0x13e, 6515},
	/*II_0F_D5*/ {0x15c, 6530},
	/*II_66_0F_D5*/ {0x13e, 6530},
	/*II_66_0F_D6*/ {0x130, 3960},
	/*II_F3_0F_D6*/ {0x18c, 6547},
	/*II_F2_0F_D6*/ {0x18d, 6556},
	/*II_0F_D7*/ {0x18f, 6565},
	/*II_66_0F_D7*/ {0x190, 6565},
	/*II_0F_D8*/ {0x15c, 6586},
	/*II_66_0F_D8*/ {0x13e, 6586},
	/*II_0F_D9*/ {0x15c, 6605},
	/*II_66_0F_D9*/ {0x13e, 6605},
	/*II_0F_DA*/ {0x192, 6624},
	/*II_66_0F_DA*/ {0x13e, 6624},
	/*II_0F_DB*/ {0x15c, 6641},
	/*II_66_0F_DB*/ {0x13e, 6641},
	/*II_0F_DC*/ {0x15c, 6654},
	/*II_66_0F_DC*/ {0x13e, 6654},
	/*II_0F_DD*/ {0x15c, 6673},
	/*II_66_0F_DD*/ {0x13e, 6673},
	/*II_0F_DE*/ {0x192, 6682},
	/*II_66_0F_DE*/ {0x13e, 6682},
	/*II_0F_DF*/ {0x15c, 6699},
	/*II_66_0F_DF*/ {0x13e, 6699},
	/*II_0F_E0*/ {0x192, 6714},
	/*II_66_0F_E0*/ {0x13e, 6714},
	/*II_0F_E1*/ {0x15c, 6729},
	/*II_66_0F_E1*/ {0x13e, 6729},
	/*II_0F_E2*/ {0x15c, 6744},
	/*II_66_0F_E2*/ {0x13e, 6744},
	/*II_0F_E3*/ {0x192, 6759},
	/*II_66_0F_E3*/ {0x13e, 6759},
	/*II_0F_E4*/ {0x192, 6774},
	/*II_66_0F_E4*/ {0x13e, 6774},
	/*II_0F_E5*/ {0x15c, 6793},
	/*II_66_0F_E5*/ {0x13e, 6793},
	/*II_66_0F_E6*/ {0x13e, 6810},
	/*II_F3_0F_E6*/ {0x151, 6821},
	/*II_F2_0F_E6*/ {0x13e, 6831},
	/*II_0F_E7*/ {0x193, 6875},
	/*II_66_0F_E7*/ {0x147, 6883},
	/*II_0F_E8*/ {0x15c, 6902},
	/*II_66_0F_E8*/ {0x13e, 6902},
	/*II_0F_E9*/ {0x15c, 6919},
	/*II_66_0F_E9*/ {0x13e, 6919},
	/*II_0F_EA*/ {0x192, 6936},
	/*II_66_0F_EA*/ {0x13e, 6936},
	/*II_0F_EB*/ {0x15c, 6953},
	/*II_66_0F_EB*/ {0x13e, 6953},
	/*II_0F_EC*/ {0x15c, 6964},
	/*II_66_0F_EC*/ {0x13e, 6964},
	/*II_0F_ED*/ {0x15c, 6981},
	/*II_66_0F_ED*/ {0x13e, 6981},
	/*II_0F_EE*/ {0x192, 6998},
	/*II_66_0F_EE*/ {0x13e, 6998},
	/*II_0F_EF*/ {0x15c, 7015},
	/*II_66_0F_EF*/ {0x13e, 7015},
	/*II_F2_0F_F0*/ {0x194, 7028},
	/*II_0F_F1*/ {0x15c, 7043},
	/*II_66_0F_F1*/ {0x13e, 7043},
	/*II_0F_F2*/ {0x15c, 7058},
	/*II_66_0F_F2*/ {0x13e, 7058},
	/*II_0F_F3*/ {0x15c, 7073},
	/*II_66_0F_F3*/ {0x13e, 7073},
	/*II_0F_F4*/ {0x196, 7088},
	/*II_66_0F_F4*/ {0x13e, 7088},
	/*II_0F_F5*/ {0x15c, 7107},
	/*II_66_0F_F5*/ {0x13e, 7107},
	/*II_0F_F6*/ {0x192, 7126},
	/*II_66_0F_F6*/ {0x13e, 7126},
	/*II_0F_F7*/ {0x197, 7143},
	/*II_66_0F_F7*/ {0x198, 7153},
	/*II_0F_F8*/ {0x15c, 7178},
	/*II_66_0F_F8*/ {0x13e, 7178},
	/*II_0F_F9*/ {0x15c, 7193},
	/*II_66_0F_F9*/ {0x13e, 7193},
	/*II_0F_FA*/ {0x15c, 7208},
	/*II_66_0F_FA*/ {0x13e, 7208},
	/*II_0F_FB*/ {0x196, 7223},
	/*II_66_0F_FB*/ {0x13e, 7223},
	/*II_0F_FC*/ {0x15c, 7238},
	/*II_66_0F_FC*/ {0x13e, 7238},
	/*II_0F_FD*/ {0x15c, 7253},
	/*II_66_0F_FD*/ {0x13e, 7253},
	/*II_0F_FE*/ {0x15c, 7268},
	/*II_66_0F_FE*/ {0x13e, 7268},
	/*II_D9_06*/ {0x19a, 7283},
	/*II_9B_D9_06*/ {0x19b, 7292},
	/*II_D9_07*/ {0xfe, 7300},
	/*II_9B_D9_07*/ {0x19c, 7308},
	/*II_DB_E2*/ {0xec, 7315},
	/*II_9B_DB_E2*/ {0x19d, 7323},
	/*II_DB_E3*/ {0xec, 7330},
	/*II_9B_DB_E3*/ {0x19d, 7338},
	/*II_DD_06*/ {0x19a, 7345},
	/*II_9B_DD_06*/ {0x19b, 7353},
	/*II_DD_07*/ {0xfe, 7360},
	/*II_9B_DD_07*/ {0x19c, 7368},
	/*II_DF_E0*/ {0x19e, 7360},
	/*II_9B_DF_E0*/ {0x19f, 7368},
	/*II_0F_38_00*/ {0x1a0, 7375},
	/*II_66_0F_38_00*/ {0x1a1, 7375},
	/*II_0F_38_01*/ {0x1a0, 7392},
	/*II_66_0F_38_01*/ {0x1a1, 7392},
	/*II_0F_38_02*/ {0x1a0, 7409},
	/*II_66_0F_38_02*/ {0x1a1, 7409},
	/*II_0F_38_03*/ {0x1a0, 7426},
	/*II_66_0F_38_03*/ {0x1a1, 7426},
	/*II_0F_38_04*/ {0x1a0, 7445},
	/*II_66_0F_38_04*/ {0x1a1, 7445},
	/*II_0F_38_05*/ {0x1a0, 7468},
	/*II_66_0F_38_05*/ {0x1a1, 7468},
	/*II_0F_38_06*/ {0x1a0, 7485},
	/*II_66_0F_38_06*/ {0x1a1, 7485},
	/*II_0F_38_07*/ {0x1a0, 7502},
	/*II_66_0F_38_07*/ {0x1a1, 7502},
	/*II_0F_38_08*/ {0x1a0, 7521},
	/*II_66_0F_38_08*/ {0x1a1, 7521},
	/*II_0F_38_09*/ {0x1a0, 7538},
	/*II_66_0F_38_09*/ {0x1a1, 7538},
	/*II_0F_38_0A*/ {0x1a0, 7555},
	/*II_66_0F_38_0A*/ {0x1a1, 7555},
	/*II_0F_38_0B*/ {0x1a0, 7572},
	/*II_66_0F_38_0B*/ {0x1a1, 7572},
	/*II_66_0F_38_17*/ {0x1a3, 7663},
	/*II_0F_38_1C*/ {0x1a0, 7722},
	/*II_66_0F_38_1C*/ {0x1a1, 7722},
	/*II_0F_38_1D*/ {0x1a0, 7737},
	/*II_66_0F_38_1D*/ {0x1a1, 7737},
	/*II_0F_38_1E*/ {0x1a0, 7752},
	/*II_66_0F_38_1E*/ {0x1a1, 7752},
	/*II_66_0F_38_20*/ {0x1a8, 7767},
	/*II_66_0F_38_21*/ {0x1a9, 7788},
	/*II_66_0F_38_22*/ {0x1aa, 7809},
	/*II_66_0F_38_23*/ {0x1a8, 7830},
	/*II_66_0F_38_24*/ {0x1a9, 7851},
	/*II_66_0F_38_25*/ {0x1a8, 7872},
	/*II_66_0F_38_28*/ {0x1ac, 7893},
	/*II_66_0F_38_29*/ {0x1ac, 7910},
	/*II_66_0F_38_2A*/ {0x1ad, 7929},
	/*II_66_0F_38_2B*/ {0x1ac, 7950},
	/*II_66_0F_38_30*/ {0x1a8, 7995},
	/*II_66_0F_38_31*/ {0x1a9, 8016},
	/*II_66_0F_38_32*/ {0x1aa, 8037},
	/*II_66_0F_38_33*/ {0x1a8, 8058},
	/*II_66_0F_38_34*/ {0x1a9, 8079},
	/*II_66_0F_38_35*/ {0x1a8, 8100},
	/*II_66_0F_38_37*/ {0x1a3, 8121},
	/*II_66_0F_38_38*/ {0x1ac, 8140},
	/*II_66_0F_38_39*/ {0x1ac, 8157},
	/*II_66_0F_38_3A*/ {0x1ac, 8174},
	/*II_66_0F_38_3B*/ {0x1ac, 8191},
	/*II_66_0F_38_3C*/ {0x1ac, 8208},
	/*II_66_0F_38_3D*/ {0x1ac, 8225},
	/*II_66_0F_38_3E*/ {0x1ac, 8242},
	/*II_66_0F_38_3F*/ {0x1ac, 8259},
	/*II_66_0F_38_40*/ {0x1ac, 8276},
	/*II_66_0F_38_41*/ {0x1ac, 8293},
	/*II_66_0F_38_80*/ {0x1b0, 8318},
	/*II_66_0F_38_81*/ {0x1b0, 8326},
	/*II_66_0F_38_82*/ {0x1b0, 8335},
	/*II_66_0F_38_DB*/ {0x1b3, 9184},
	/*II_66_0F_38_DC*/ {0x1b3, 9201},
	/*II_66_0F_38_DD*/ {0x1b3, 9218},
	/*II_66_0F_38_DE*/ {0x1b3, 9243},
	/*II_66_0F_38_DF*/ {0x1b3, 9260},
	/*II_0F_38_F0*/ {0x1b6, 9285},
	/*II_F2_0F_38_F0*/ {0x1b7, 9292},
	/*II_0F_38_F1*/ {0x1b8, 9285},
	/*II_F2_0F_38_F1*/ {0x1b9, 9292},
	/*II_0F_71_02*/ {0x1d0, 6470},
	/*II_66_0F_71_02*/ {0x1d1, 6470},
	/*II_0F_71_04*/ {0x1d0, 6729},
	/*II_66_0F_71_04*/ {0x1d1, 6729},
	/*II_0F_71_06*/ {0x1d0, 7043},
	/*II_66_0F_71_06*/ {0x1d1, 7043},
	/*II_0F_72_02*/ {0x1d0, 6485},
	/*II_66_0F_72_02*/ {0x1d1, 6485},
	/*II_0F_72_04*/ {0x1d0, 6744},
	/*II_66_0F_72_04*/ {0x1d1, 6744},
	/*II_0F_72_06*/ {0x1d0, 7058},
	/*II_66_0F_72_06*/ {0x1d1, 7058},
	/*II_0F_73_02*/ {0x1d0, 6500},
	/*II_66_0F_73_02*/ {0x1d1, 6500},
	/*II_66_0F_73_03*/ {0x1d1, 9864},
	/*II_0F_73_06*/ {0x1d0, 7073},
	/*II_66_0F_73_06*/ {0x1d1, 7073},
	/*II_66_0F_73_07*/ {0x1d1, 9881},
	/*II_F3_0F_AE_00*/ {0x1d3, 9916},
	/*II_F3_0F_AE_01*/ {0x1d3, 9946},
	/*II_0F_AE_02*/ {0x1d4, 9956},
	/*II_F3_0F_AE_02*/ {0x1d3, 9965},
	/*II_0F_AE_03*/ {0x1d4, 9985},
	/*II_F3_0F_AE_03*/ {0x1d3, 9994},
	/*II_0F_C7_06*/ {0x1d6, 10014},
	/*II_66_0F_C7_06*/ {0x18b, 10023},
	/*II_F3_0F_C7_06*/ {0x18b, 10032}
};

_InstInfoEx InstInfosEx[381] = {
	/*II_69*/ {{0x34, 117}, 0x0, 3, 0, 0, 0},
	/*II_6B*/ {{0x34, 117}, 0x0, 5, 0, 0, 0},
	/*II_98*/ {{0x4e, 228}, 0x0, 0, 0, 233, 239},
	/*II_99*/ {{0x4e, 245}, 0x0, 0, 0, 250, 255},
	/*II_E3*/ {{0x76, 427}, 0x0, 0, 0, 433, 440},
	/*II_0F_A4*/ {{0xad, 876}, 0x0, 1, 0, 0, 0},
	/*II_0F_A5*/ {{0xad, 876}, 0x0, 42, 0, 0, 0},
	/*II_0F_AC*/ {{0xad, 892}, 0x0, 1, 0, 0, 0},
	/*II_0F_AD*/ {{0xad, 892}, 0x0, 42, 0, 0, 0},
	/*II_V_0F_10*/ {{0x129, 2151}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_10*/ {{0x129, 2160}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_10*/ {{0x12a, 2169}, 0x20, 31, 0, 0, 0},
	/*II_V_F2_0F_10*/ {{0x12a, 2177}, 0x20, 31, 0, 0, 0},
	/*II_VRR_F3_0F_10*/ {{0x12b, 2169}, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_10*/ {{0x12c, 2177}, 0x60, 0, 0, 0, 0},
	/*II_V_0F_11*/ {{0x131, 2151}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_11*/ {{0x131, 2160}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_11*/ {{0x12a, 2169}, 0x20, 31, 0, 0, 0},
	/*II_V_F2_0F_11*/ {{0x12a, 2177}, 0x20, 31, 0, 0, 0},
	/*II_VRR_F3_0F_11*/ {{0x132, 2169}, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_11*/ {{0x133, 2177}, 0x60, 0, 0, 0, 0},
	/*II_0F_12*/ {{0x134, 2185}, 0x0, 0, 0, 2194, 0},
	/*II_V_0F_12*/ {{0x137, 2229}, 0x0, 86, 0, 2239, 0},
	/*II_V_66_0F_12*/ {{0x138, 2248}, 0x0, 57, 0, 0, 0},
	/*II_V_F3_0F_12*/ {{0x129, 2257}, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_12*/ {{0x139, 2268}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_13*/ {{0x13c, 2239}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_13*/ {{0x13c, 2248}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_14*/ {{0x13f, 2298}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_14*/ {{0x13f, 2309}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_15*/ {{0x13f, 2340}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_15*/ {{0x13f, 2351}, 0x1, 91, 0, 0, 0},
	/*II_0F_16*/ {{0x134, 2362}, 0x0, 0, 0, 2371, 0},
	/*II_V_0F_16*/ {{0x137, 2397}, 0x0, 86, 0, 2407, 0},
	/*II_V_66_0F_16*/ {{0x138, 2416}, 0x0, 57, 0, 0, 0},
	/*II_V_F3_0F_16*/ {{0x129, 2425}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_17*/ {{0x13c, 2407}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_17*/ {{0x13c, 2416}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_28*/ {{0x129, 2501}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_28*/ {{0x129, 2510}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_29*/ {{0x131, 2501}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_29*/ {{0x131, 2510}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2A*/ {{0x138, 2559}, 0x2, 73, 0, 0, 0},
	/*II_V_F2_0F_2A*/ {{0x138, 2570}, 0x2, 73, 0, 0, 0},
	/*II_V_0F_2B*/ {{0x14a, 2617}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_2B*/ {{0x14a, 2627}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2C*/ {{0x14f, 2681}, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2C*/ {{0x14f, 2693}, 0x42, 0, 0, 0, 0},
	/*II_V_F3_0F_2D*/ {{0x14f, 2745}, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2D*/ {{0x14f, 2756}, 0x42, 0, 0, 0, 0},
	/*II_V_0F_2E*/ {{0x152, 2785}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2E*/ {{0x153, 2795}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_2F*/ {{0x152, 2821}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2F*/ {{0x153, 2830}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_50*/ {{0x156, 2859}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_50*/ {{0x156, 2870}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_51*/ {{0x129, 2913}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_51*/ {{0x129, 2922}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_51*/ {{0x138, 2931}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_51*/ {{0x138, 2940}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_52*/ {{0x129, 2967}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_52*/ {{0x138, 2977}, 0x0, 85, 0, 0, 0},
	/*II_V_0F_53*/ {{0x129, 3001}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_53*/ {{0x138, 3009}, 0x0, 85, 0, 0, 0},
	/*II_V_0F_54*/ {{0x13f, 3031}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_54*/ {{0x13f, 3039}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_55*/ {{0x13f, 3063}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_55*/ {{0x13f, 3072}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_56*/ {{0x13f, 3093}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_56*/ {{0x13f, 3100}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_57*/ {{0x13f, 3121}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_57*/ {{0x13f, 3129}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_58*/ {{0x13f, 3165}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_58*/ {{0x13f, 3173}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_58*/ {{0x138, 3181}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_58*/ {{0x138, 3189}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_59*/ {{0x13f, 3225}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_59*/ {{0x13f, 3233}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_59*/ {{0x138, 3241}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_59*/ {{0x138, 3249}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5A*/ {{0x159, 3297}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5A*/ {{0x15a, 3308}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5A*/ {{0x138, 3319}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5A*/ {{0x138, 3330}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5B*/ {{0x129, 3372}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5B*/ {{0x129, 3383}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5B*/ {{0x129, 3394}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_5C*/ {{0x13f, 3434}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5C*/ {{0x13f, 3442}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5C*/ {{0x138, 3450}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5C*/ {{0x138, 3458}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5D*/ {{0x13f, 3494}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5D*/ {{0x13f, 3502}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5D*/ {{0x138, 3510}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5D*/ {{0x138, 3518}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5E*/ {{0x13f, 3554}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5E*/ {{0x13f, 3562}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5E*/ {{0x138, 3570}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5E*/ {{0x138, 3578}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5F*/ {{0x13f, 3614}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5F*/ {{0x13f, 3622}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5F*/ {{0x138, 3630}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5F*/ {{0x138, 3638}, 0x0, 86, 0, 0, 0},
	/*II_V_66_0F_60*/ {{0x138, 3657}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_61*/ {{0x138, 3680}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_62*/ {{0x138, 3703}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_63*/ {{0x138, 3725}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_64*/ {{0x138, 3745}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_65*/ {{0x138, 3764}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_66*/ {{0x138, 3783}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_67*/ {{0x138, 3803}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_68*/ {{0x138, 3825}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_69*/ {{0x138, 3848}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6A*/ {{0x138, 3871}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6B*/ {{0x138, 3893}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6C*/ {{0x138, 3916}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6D*/ {{0x138, 3941}, 0x0, 87, 0, 0, 0},
	/*II_0F_6E*/ {{0x15d, 3954}, 0x0, 0, 0, 0, 3960},
	/*II_66_0F_6E*/ {{0x15e, 3954}, 0x0, 0, 0, 0, 3960},
	/*II_V_66_0F_6E*/ {{0x15f, 3966}, 0x46, 0, 0, 3973, 0},
	/*II_V_66_0F_6F*/ {{0x129, 3996}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_6F*/ {{0x129, 4005}, 0x41, 0, 0, 0, 0},
	/*II_0F_70*/ {{0x161, 4014}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_70*/ {{0x162, 4022}, 0x0, 1, 0, 0, 0},
	/*II_F3_0F_70*/ {{0x162, 4030}, 0x0, 1, 0, 0, 0},
	/*II_F2_0F_70*/ {{0x162, 4039}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_70*/ {{0x163, 4048}, 0x40, 1, 0, 0, 0},
	/*II_V_F3_0F_70*/ {{0x163, 4057}, 0x40, 1, 0, 0, 0},
	/*II_V_F2_0F_70*/ {{0x163, 4067}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_74*/ {{0x138, 4086}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_75*/ {{0x138, 4105}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_76*/ {{0x138, 4124}, 0x0, 87, 0, 0, 0},
	/*II_V_0F_77*/ {{0x165, 4140}, 0x49, 0, 0, 4152, 0},
	/*II_66_0F_78*/ {{0x167, 4170}, 0x0, 49, 0, 0, 0},
	/*II_F2_0F_78*/ {{0x168, 4177}, 0x0, 48, 49, 0, 0},
	/*II_V_66_0F_7C*/ {{0x13f, 4231}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_7C*/ {{0x13f, 4240}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_7D*/ {{0x13f, 4265}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_7D*/ {{0x13f, 4274}, 0x1, 91, 0, 0, 0},
	/*II_0F_7E*/ {{0x16f, 3954}, 0x0, 0, 0, 0, 3960},
	/*II_66_0F_7E*/ {{0x170, 3954}, 0x0, 0, 0, 0, 3960},
	/*II_V_66_0F_7E*/ {{0x171, 3966}, 0x46, 0, 0, 3973, 0},
	/*II_V_F3_0F_7E*/ {{0x153, 3973}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_7F*/ {{0x131, 3996}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_7F*/ {{0x131, 4005}, 0x41, 0, 0, 0, 0},
	/*II_0F_AE_04*/ {{0x173, 4283}, 0x0, 0, 0, 0, 4290},
	/*II_0F_AE_05*/ {{0x174, 4299}, 0x0, 0, 0, 4307, 4315},
	/*II_0F_AE_06*/ {{0x174, 4325}, 0x0, 0, 0, 4333, 4343},
	/*II_0F_AE_07*/ {{0x175, 4355}, 0x0, 0, 0, 4363, 0},
	/*II_0F_C2*/ {{0x17c, 4404}, 0x0, 0, 0, 4413, 4422},
	/*II_66_0F_C2*/ {{0x17d, 4483}, 0x0, 0, 0, 4492, 4501},
	/*II_F3_0F_C2*/ {{0x17e, 4562}, 0x0, 0, 0, 4571, 4580},
	/*II_F2_0F_C2*/ {{0x17f, 4641}, 0x0, 0, 0, 4650, 4659},
	/*II_V_0F_C2*/ {{0x180, 4720}, 0x1, 91, 0, 4730, 4740},
	/*II_V_66_0F_C2*/ {{0x180, 5122}, 0x1, 91, 0, 5132, 5142},
	/*II_V_F3_0F_C2*/ {{0x181, 5524}, 0x0, 85, 0, 5534, 5544},
	/*II_V_F2_0F_C2*/ {{0x181, 5926}, 0x0, 86, 0, 5936, 5946},
	/*II_0F_C4*/ {{0x182, 6328}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C4*/ {{0x183, 6328}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C4*/ {{0x184, 6336}, 0x0, 79, 1, 0, 0},
	/*II_0F_C5*/ {{0x185, 6345}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C5*/ {{0x186, 6345}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C5*/ {{0x187, 6353}, 0x40, 1, 0, 0, 0},
	/*II_0F_C6*/ {{0x188, 6362}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C6*/ {{0x162, 6370}, 0x0, 1, 0, 0, 0},
	/*II_V_0F_C6*/ {{0x189, 6378}, 0x1, 91, 1, 0, 0},
	/*II_V_66_0F_C6*/ {{0x189, 6387}, 0x1, 91, 1, 0, 0},
	/*II_0F_C7_01*/ {{0x18a, 6396}, 0x0, 0, 0, 0, 6407},
	/*II_V_66_0F_D0*/ {{0x13f, 6448}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_D0*/ {{0x13f, 6459}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_D1*/ {{0x138, 6477}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D2*/ {{0x138, 6492}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D3*/ {{0x138, 6507}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D4*/ {{0x138, 6522}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D5*/ {{0x138, 6538}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D6*/ {{0x18e, 3973}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D7*/ {{0x191, 6575}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D8*/ {{0x138, 6595}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D9*/ {{0x138, 6614}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DA*/ {{0x138, 6632}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DB*/ {{0x138, 6647}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DC*/ {{0x138, 6663}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DD*/ {{0x138, 6663}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DE*/ {{0x138, 6690}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DF*/ {{0x138, 6706}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E0*/ {{0x138, 6721}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E1*/ {{0x138, 6736}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E2*/ {{0x138, 6751}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E3*/ {{0x138, 6766}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E4*/ {{0x138, 6783}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E5*/ {{0x138, 6801}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E6*/ {{0x15a, 6841}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_E6*/ {{0x159, 6853}, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_E6*/ {{0x15a, 6864}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E7*/ {{0x14a, 6892}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E8*/ {{0x138, 6910}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E9*/ {{0x138, 6927}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EA*/ {{0x138, 6944}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EB*/ {{0x138, 6958}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EC*/ {{0x138, 6972}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_ED*/ {{0x138, 6989}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EE*/ {{0x138, 7006}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EF*/ {{0x138, 7021}, 0x0, 87, 0, 0, 0},
	/*II_V_F2_0F_F0*/ {{0x195, 7035}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_F1*/ {{0x138, 7050}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F2*/ {{0x138, 7065}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F3*/ {{0x138, 7080}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F4*/ {{0x138, 7097}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F5*/ {{0x138, 7116}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F6*/ {{0x138, 7134}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F7*/ {{0x199, 7165}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_F8*/ {{0x138, 7185}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F9*/ {{0x138, 7200}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FA*/ {{0x138, 7215}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FB*/ {{0x138, 7230}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FC*/ {{0x138, 7245}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FD*/ {{0x138, 7260}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FE*/ {{0x138, 7275}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_00*/ {{0x138, 7383}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_01*/ {{0x138, 7400}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_02*/ {{0x138, 7417}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_03*/ {{0x138, 7435}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_04*/ {{0x138, 7456}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_05*/ {{0x138, 7476}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_06*/ {{0x138, 7493}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_07*/ {{0x138, 7511}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_08*/ {{0x138, 7529}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_09*/ {{0x138, 7546}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0A*/ {{0x138, 7563}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0B*/ {{0x138, 7582}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0C*/ {{0x13f, 7593}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_38_0D*/ {{0x13f, 7604}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_38_0E*/ {{0x129, 7615}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_0F*/ {{0x129, 7624}, 0x41, 0, 0, 0, 0},
	/*II_66_0F_38_10*/ {{0x1a2, 7633}, 0x0, 32, 0, 0, 0},
	/*II_66_0F_38_14*/ {{0x1a2, 7643}, 0x0, 32, 0, 0, 0},
	/*II_66_0F_38_15*/ {{0x1a2, 7653}, 0x0, 32, 0, 0, 0},
	/*II_V_66_0F_38_17*/ {{0x129, 7670}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_18*/ {{0x1a4, 7678}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_19*/ {{0x1a5, 7692}, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1A*/ {{0x1a6, 7706}, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1C*/ {{0x1a7, 7729}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1D*/ {{0x1a7, 7744}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1E*/ {{0x1a7, 7759}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_20*/ {{0x153, 7777}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_21*/ {{0x152, 7798}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_22*/ {{0x1ab, 7819}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_23*/ {{0x153, 7840}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_24*/ {{0x152, 7861}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_25*/ {{0x153, 7882}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_28*/ {{0x138, 7901}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_29*/ {{0x138, 7919}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_2A*/ {{0x1ae, 7939}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_2B*/ {{0x138, 7960}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_2C*/ {{0x13f, 7971}, 0x1, 67, 0, 0, 0},
	/*II_V_66_0F_38_2D*/ {{0x13f, 7983}, 0x1, 67, 0, 0, 0},
	/*II_V_66_0F_38_2E*/ {{0x1af, 7971}, 0x1, 36, 0, 0, 0},
	/*II_V_66_0F_38_2F*/ {{0x1af, 7983}, 0x1, 36, 0, 0, 0},
	/*II_V_66_0F_38_30*/ {{0x153, 8005}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_31*/ {{0x152, 8026}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_32*/ {{0x1ab, 8047}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_33*/ {{0x153, 8068}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_34*/ {{0x152, 8089}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_35*/ {{0x153, 8110}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_37*/ {{0x138, 8130}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_38*/ {{0x138, 8148}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_39*/ {{0x138, 8165}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3A*/ {{0x138, 8182}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3B*/ {{0x138, 8199}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3C*/ {{0x138, 8216}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3D*/ {{0x138, 8233}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3E*/ {{0x138, 8250}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3F*/ {{0x138, 8267}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_40*/ {{0x138, 8284}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_41*/ {{0x1a7, 8305}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_96*/ {{0x1b1, 8344}, 0x7, 91, 0, 8360, 0},
	/*II_V_66_0F_38_97*/ {{0x1b1, 8376}, 0x7, 91, 0, 8392, 0},
	/*II_V_66_0F_38_98*/ {{0x1b1, 8408}, 0x7, 91, 0, 8421, 0},
	/*II_V_66_0F_38_99*/ {{0x1b2, 8434}, 0x6, 88, 0, 8447, 0},
	/*II_V_66_0F_38_9A*/ {{0x1b1, 8460}, 0x7, 91, 0, 8473, 0},
	/*II_V_66_0F_38_9B*/ {{0x1b2, 8486}, 0x6, 88, 0, 8499, 0},
	/*II_V_66_0F_38_9C*/ {{0x1b1, 8512}, 0x7, 91, 0, 8526, 0},
	/*II_V_66_0F_38_9D*/ {{0x1b2, 8540}, 0x6, 88, 0, 8554, 0},
	/*II_V_66_0F_38_9E*/ {{0x1b1, 8568}, 0x7, 91, 0, 8582, 0},
	/*II_V_66_0F_38_9F*/ {{0x1b2, 8596}, 0x6, 88, 0, 8610, 0},
	/*II_V_66_0F_38_A6*/ {{0x1b1, 8624}, 0x7, 91, 0, 8640, 0},
	/*II_V_66_0F_38_A7*/ {{0x1b1, 8656}, 0x7, 91, 0, 8672, 0},
	/*II_V_66_0F_38_A8*/ {{0x1b1, 8688}, 0x7, 91, 0, 8701, 0},
	/*II_V_66_0F_38_A9*/ {{0x1b2, 8714}, 0x6, 88, 0, 8727, 0},
	/*II_V_66_0F_38_AA*/ {{0x1b1, 8740}, 0x7, 91, 0, 8753, 0},
	/*II_V_66_0F_38_AB*/ {{0x1b2, 8766}, 0x6, 88, 0, 8779, 0},
	/*II_V_66_0F_38_AC*/ {{0x1b1, 8792}, 0x7, 91, 0, 8806, 0},
	/*II_V_66_0F_38_AD*/ {{0x1b2, 8820}, 0x6, 88, 0, 8834, 0},
	/*II_V_66_0F_38_AE*/ {{0x1b1, 8848}, 0x7, 91, 0, 8862, 0},
	/*II_V_66_0F_38_AF*/ {{0x1b2, 8876}, 0x6, 88, 0, 8890, 0},
	/*II_V_66_0F_38_B6*/ {{0x1b1, 8904}, 0x7, 91, 0, 8920, 0},
	/*II_V_66_0F_38_B7*/ {{0x1b1, 8936}, 0x7, 91, 0, 8952, 0},
	/*II_V_66_0F_38_B8*/ {{0x1b1, 8968}, 0x7, 91, 0, 8981, 0},
	/*II_V_66_0F_38_B9*/ {{0x1b2, 8994}, 0x6, 88, 0, 9007, 0},
	/*II_V_66_0F_38_BA*/ {{0x1b1, 9020}, 0x7, 91, 0, 9033, 0},
	/*II_V_66_0F_38_BB*/ {{0x1b2, 9046}, 0x6, 88, 0, 9059, 0},
	/*II_V_66_0F_38_BC*/ {{0x1b1, 9072}, 0x7, 91, 0, 9086, 0},
	/*II_V_66_0F_38_BD*/ {{0x1b2, 9100}, 0x6, 88, 0, 9114, 0},
	/*II_V_66_0F_38_BE*/ {{0x1b1, 9128}, 0x7, 91, 0, 9142, 0},
	/*II_V_66_0F_38_BF*/ {{0x1b2, 9156}, 0x6, 88, 0, 9170, 0},
	/*II_V_66_0F_38_DB*/ {{0x1b4, 9192}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_DC*/ {{0x1b5, 9209}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DD*/ {{0x1b5, 9230}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DE*/ {{0x1b5, 9251}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DF*/ {{0x1b5, 9272}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_3A_04*/ {{0x1ba, 7593}, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_05*/ {{0x1ba, 7604}, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_06*/ {{0x1bb, 9299}, 0x10, 89, 1, 0, 0},
	/*II_66_0F_3A_08*/ {{0x1a2, 9311}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_08*/ {{0x1ba, 9320}, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_09*/ {{0x1a2, 9330}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_09*/ {{0x1ba, 9339}, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_0A*/ {{0x1bc, 9349}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0A*/ {{0x184, 9358}, 0x0, 85, 1, 0, 0},
	/*II_66_0F_3A_0B*/ {{0x1bd, 9368}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0B*/ {{0x184, 9377}, 0x0, 86, 1, 0, 0},
	/*II_66_0F_3A_0C*/ {{0x1a2, 9387}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0C*/ {{0x189, 9396}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_0D*/ {{0x1a2, 9406}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0D*/ {{0x189, 9415}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_0E*/ {{0x1a2, 9425}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0E*/ {{0x184, 9434}, 0x0, 87, 1, 0, 0},
	/*II_0F_3A_0F*/ {{0x1be, 9444}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_3A_0F*/ {{0x1bf, 9444}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0F*/ {{0x184, 9453}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_14*/ {{0x1c0, 9463}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_14*/ {{0x1c1, 9471}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_15*/ {{0x1c2, 6345}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_15*/ {{0x1c3, 6353}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_16*/ {{0x1c4, 9480}, 0x0, 1, 0, 0, 9488},
	/*II_V_66_0F_3A_16*/ {{0x1c5, 9496}, 0x46, 1, 0, 9505, 0},
	/*II_66_0F_3A_17*/ {{0x1c6, 9514}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_17*/ {{0x1c7, 9525}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_3A_18*/ {{0x1bb, 9537}, 0x10, 87, 1, 0, 0},
	/*II_V_66_0F_3A_19*/ {{0x1c8, 9550}, 0x50, 1, 0, 0, 0},
	/*II_66_0F_3A_20*/ {{0x1c9, 9564}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_20*/ {{0x184, 9572}, 0x0, 80, 1, 0, 0},
	/*II_66_0F_3A_21*/ {{0x1bc, 9581}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_21*/ {{0x184, 9591}, 0x0, 85, 1, 0, 0},
	/*II_66_0F_3A_22*/ {{0x1ca, 9602}, 0x0, 1, 0, 0, 9610},
	/*II_V_66_0F_3A_22*/ {{0x184, 9618}, 0x6, 73, 1, 9627, 0},
	/*II_66_0F_3A_40*/ {{0x1a2, 9636}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_40*/ {{0x189, 9642}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_41*/ {{0x1a2, 9649}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_41*/ {{0x184, 9655}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_42*/ {{0x1a2, 9662}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_42*/ {{0x184, 9671}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_44*/ {{0x1cb, 9681}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_44*/ {{0x1cc, 9692}, 0x0, 87, 1, 0, 0},
	/*II_V_66_0F_3A_4A*/ {{0x189, 9704}, 0x1, 91, 37, 0, 0},
	/*II_V_66_0F_3A_4B*/ {{0x189, 9715}, 0x1, 91, 37, 0, 0},
	/*II_V_66_0F_3A_4C*/ {{0x184, 9726}, 0x0, 87, 35, 0, 0},
	/*II_66_0F_3A_60*/ {{0x1cd, 9737}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_60*/ {{0x163, 9748}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_61*/ {{0x1cd, 9760}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_61*/ {{0x163, 9771}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_62*/ {{0x1cd, 9783}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_62*/ {{0x163, 9794}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_63*/ {{0x1cd, 9806}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_63*/ {{0x163, 9817}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_DF*/ {{0x1ce, 9829}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_DF*/ {{0x1cf, 9846}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_71_02*/ {{0x1d2, 6477}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_04*/ {{0x1d2, 6736}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_06*/ {{0x1d2, 7050}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_02*/ {{0x1d2, 6492}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_04*/ {{0x1d2, 6751}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_06*/ {{0x1d2, 7065}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_02*/ {{0x1d2, 6507}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_03*/ {{0x1d2, 9872}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_06*/ {{0x1d2, 7080}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_07*/ {{0x1d2, 9889}, 0x0, 1, 0, 0, 0},
	/*II_0F_AE_00*/ {{0x173, 9898}, 0x0, 0, 0, 0, 9906},
	/*II_0F_AE_01*/ {{0x173, 9926}, 0x0, 0, 0, 0, 9935},
	/*II_V_0F_AE_02*/ {{0x1d5, 9975}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_AE_03*/ {{0x1d5, 10004}, 0x40, 0, 0, 0, 0}
};

_InstNode InstructionsTree[5688] = {
/* 0 - _00 */  0x2000,
/* 1 - _01 */  0x2001,
/* 2 - _02 */  0x2002,
/* 3 - _03 */  0x2003,
/* 4 - _04 */  0x2004,
/* 5 - _05 */  0x2005,
/* 6 - _06 */  0x2006,
/* 7 - _07 */  0x2007,
/* 8 - _08 */  0x2008,
/* 9 - _09 */  0x2009,
/* a - _0A */  0x200a,
/* b - _0B */  0x200b,
/* c - _0C */  0x200c,
/* d - _0D */  0x200d,
/* e - _0E */  0x200e,
/* f - _0F */  0xa100,
/* 10 - _10 */  0x200f,
/* 11 - _11 */  0x2010,
/* 12 - _12 */  0x2011,
/* 13 - _13 */  0x2012,
/* 14 - _14 */  0x2013,
/* 15 - _15 */  0x2014,
/* 16 - _16 */  0x2015,
/* 17 - _17 */  0x2016,
/* 18 - _18 */  0x2017,
/* 19 - _19 */  0x2018,
/* 1a - _1A */  0x2019,
/* 1b - _1B */  0x201a,
/* 1c - _1C */  0x201b,
/* 1d - _1D */  0x201c,
/* 1e - _1E */  0x201d,
/* 1f - _1F */  0x201e,
/* 20 - _20 */  0x201f,
/* 21 - _21 */  0x2020,
/* 22 - _22 */  0x2021,
/* 23 - _23 */  0x2022,
/* 24 - _24 */  0x2023,
/* 25 - _25 */  0x2024,
/* 26 -  */  0,
/* 27 - _27 */  0x2025,
/* 28 - _28 */  0x2026,
/* 29 - _29 */  0x2027,
/* 2a - _2A */  0x2028,
/* 2b - _2B */  0x2029,
/* 2c - _2C */  0x202a,
/* 2d - _2D */  0x202b,
/* 2e -  */  0,
/* 2f - _2F */  0x202c,
/* 30 - _30 */  0x202d,
/* 31 - _31 */  0x202e,
/* 32 - _32 */  0x202f,
/* 33 - _33 */  0x2030,
/* 34 - _34 */  0x2031,
/* 35 - _35 */  0x2032,
/* 36 -  */  0,
/* 37 - _37 */  0x2033,
/* 38 - _38 */  0x2034,
/* 39 - _39 */  0x2035,
/* 3a - _3A */  0x2036,
/* 3b - _3B */  0x2037,
/* 3c - _3C */  0x2038,
/* 3d - _3D */  0x2039,
/* 3e -  */  0,
/* 3f - _3F */  0x203a,
/* 40 - _40 */  0x203b,
/* 41 - _40 */  0x203c,
/* 42 - _40 */  0x203d,
/* 43 - _40 */  0x203e,
/* 44 - _40 */  0x203f,
/* 45 - _40 */  0x2040,
/* 46 - _40 */  0x2041,
/* 47 - _40 */  0x2042,
/* 48 - _48 */  0x2043,
/* 49 - _48 */  0x2044,
/* 4a - _48 */  0x2045,
/* 4b - _48 */  0x2046,
/* 4c - _48 */  0x2047,
/* 4d - _48 */  0x2048,
/* 4e - _48 */  0x2049,
/* 4f - _48 */  0x204a,
/* 50 - _50 */  0x204b,
/* 51 - _50 */  0x204c,
/* 52 - _50 */  0x204d,
/* 53 - _50 */  0x204e,
/* 54 - _50 */  0x204f,
/* 55 - _50 */  0x2050,
/* 56 - _50 */  0x2051,
/* 57 - _50 */  0x2052,
/* 58 - _58 */  0x2053,
/* 59 - _58 */  0x2054,
/* 5a - _58 */  0x2055,
/* 5b - _58 */  0x2056,
/* 5c - _58 */  0x2057,
/* 5d - _58 */  0x2058,
/* 5e - _58 */  0x2059,
/* 5f - _58 */  0x205a,
/* 60 - _60 */  0x205b,
/* 61 - _61 */  0x205c,
/* 62 - _62 */  0x205d,
/* 63 - _63 */  0x605e,
/* 64 -  */  0,
/* 65 -  */  0,
/* 66 -  */  0,
/* 67 -  */  0,
/* 68 - _68 */  0x205f,
/* 69 - _69 */  0x4000,
/* 6a - _6A */  0x2060,
/* 6b - _6B */  0x4001,
/* 6c - _6C */  0x2061,
/* 6d - _6D */  0x2062,
/* 6e - _6E */  0x2063,
/* 6f - _6F */  0x2064,
/* 70 - _70 */  0x2065,
/* 71 - _71 */  0x2066,
/* 72 - _72 */  0x2067,
/* 73 - _73 */  0x2068,
/* 74 - _74 */  0x2069,
/* 75 - _75 */  0x206a,
/* 76 - _76 */  0x206b,
/* 77 - _77 */  0x206c,
/* 78 - _78 */  0x206d,
/* 79 - _79 */  0x206e,
/* 7a - _7A */  0x206f,
/* 7b - _7B */  0x2070,
/* 7c - _7C */  0x2071,
/* 7d - _7D */  0x2072,
/* 7e - _7E */  0x2073,
/* 7f - _7F */  0x2074,
/* 80 - _80 */  0x8200,
/* 81 - _81 */  0x8208,
/* 82 - _82 */  0x8210,
/* 83 - _83 */  0x8218,
/* 84 - _84 */  0x2075,
/* 85 - _85 */  0x2076,
/* 86 - _86 */  0x2077,
/* 87 - _87 */  0x2078,
/* 88 - _88 */  0x2079,
/* 89 - _89 */  0x207a,
/* 8a - _8A */  0x207b,
/* 8b - _8B */  0x207c,
/* 8c - _8C */  0x207d,
/* 8d - _8D */  0x607e,
/* 8e - _8E */  0x207f,
/* 8f - _8F */  0x8220,
/* 90 - _90 */  0x6080,
/* 91 - _91 */  0x2081,
/* 92 - _92 */  0x2082,
/* 93 - _93 */  0x2083,
/* 94 - _94 */  0x2084,
/* 95 - _95 */  0x2085,
/* 96 - _96 */  0x2086,
/* 97 - _97 */  0x2087,
/* 98 - _98 */  0x4002,
/* 99 - _99 */  0x4003,
/* 9a - _9A */  0x2088,
/* 9b -  */  0,
/* 9c - _9C */  0x2089,
/* 9d - _9D */  0x208a,
/* 9e - _9E */  0x208b,
/* 9f - _9F */  0x208c,
/* a0 - _A0 */  0x208d,
/* a1 - _A1 */  0x208e,
/* a2 - _A2 */  0x208f,
/* a3 - _A3 */  0x2090,
/* a4 - _A4 */  0x2091,
/* a5 - _A5 */  0x2092,
/* a6 - _A6 */  0x2093,
/* a7 - _A7 */  0x2094,
/* a8 - _A8 */  0x2095,
/* a9 - _A9 */  0x2096,
/* aa - _AA */  0x2097,
/* ab - _AB */  0x2098,
/* ac - _AC */  0x2099,
/* ad - _AD */  0x209a,
/* ae - _AE */  0x209b,
/* af - _AF */  0x209c,
/* b0 - _B0 */  0x209d,
/* b1 - _B0 */  0x209e,
/* b2 - _B0 */  0x209f,
/* b3 - _B0 */  0x20a0,
/* b4 - _B0 */  0x20a1,
/* b5 - _B0 */  0x20a2,
/* b6 - _B0 */  0x20a3,
/* b7 - _B0 */  0x20a4,
/* b8 - _B8 */  0x20a5,
/* b9 - _B8 */  0x20a6,
/* ba - _B8 */  0x20a7,
/* bb - _B8 */  0x20a8,
/* bc - _B8 */  0x20a9,
/* bd - _B8 */  0x20aa,
/* be - _B8 */  0x20ab,
/* bf - _B8 */  0x20ac,
/* c0 - _C0 */  0x8228,
/* c1 - _C1 */  0x8230,
/* c2 - _C2 */  0x20ad,
/* c3 - _C3 */  0x20ae,
/* c4 - _C4 */  0x20af,
/* c5 - _C5 */  0x20b0,
/* c6 - _C6 */  0xc238,
/* c7 - _C7 */  0xc280,
/* c8 - _C8 */  0x20b1,
/* c9 - _C9 */  0x20b2,
/* ca - _CA */  0x20b3,
/* cb - _CB */  0x20b4,
/* cc - _CC */  0x20b5,
/* cd - _CD */  0x20b6,
/* ce - _CE */  0x20b7,
/* cf - _CF */  0x20b8,
/* d0 - _D0 */  0x82c8,
/* d1 - _D1 */  0x82d0,
/* d2 - _D2 */  0x82d8,
/* d3 - _D3 */  0x82e0,
/* d4 - _D4 */  0x20b9,
/* d5 - _D5 */  0x20ba,
/* d6 - _D6 */  0x20bb,
/* d7 - _D7 */  0x20bc,
/* d8 - _D8 */  0xc2e8,
/* d9 - _D9 */  0xc330,
/* da - _DA */  0xc378,
/* db - _DB */  0xc3c0,
/* dc - _DC */  0xc408,
/* dd - _DD */  0xc450,
/* de - _DE */  0xc498,
/* df - _DF */  0xc4e0,
/* e0 - _E0 */  0x20bd,
/* e1 - _E1 */  0x20be,
/* e2 - _E2 */  0x20bf,
/* e3 - _E3 */  0x4004,
/* e4 - _E4 */  0x20c0,
/* e5 - _E5 */  0x20c1,
/* e6 - _E6 */  0x20c2,
/* e7 - _E7 */  0x20c3,
/* e8 - _E8 */  0x20c4,
/* e9 - _E9 */  0x20c5,
/* ea - _EA */  0x20c6,
/* eb - _EB */  0x20c7,
/* ec - _EC */  0x20c8,
/* ed - _ED */  0x20c9,
/* ee - _EE */  0x20ca,
/* ef - _EF */  0x20cb,
/* f0 -  */  0,
/* f1 - _F1 */  0x20cc,
/* f2 -  */  0,
/* f3 -  */  0,
/* f4 - _F4 */  0x20cd,
/* f5 - _F5 */  0x20ce,
/* f6 - _F6 */  0x8528,
/* f7 - _F7 */  0x8530,
/* f8 - _F8 */  0x20cf,
/* f9 - _F9 */  0x20d0,
/* fa - _FA */  0x20d1,
/* fb - _FB */  0x20d2,
/* fc - _FC */  0x20d3,
/* fd - _FD */  0x20d4,
/* fe - _FE */  0x8538,
/* ff - _FF */  0x8540,
/* 100 - _0F_00 */  0x8548,
/* 101 - _0F_01 */  0xc550,
/* 102 - _0F_02 */  0x20d5,
/* 103 - _0F_03 */  0x20d6,
/* 104 -  */  0,
/* 105 - _0F_05 */  0x20d7,
/* 106 - _0F_06 */  0x20d8,
/* 107 - _0F_07 */  0x20d9,
/* 108 - _0F_08 */  0x20da,
/* 109 - _0F_09 */  0x20db,
/* 10a -  */  0,
/* 10b - _0F_0B */  0x20dc,
/* 10c -  */  0,
/* 10d - _0F_0D */  0x8598,
/* 10e - _0F_0E */  0x20dd,
/* 10f - _0F_0F */  0xa5a0,
/* 110 - _0F_10 */  0xe6a0,
/* 111 - _0F_11 */  0xe6ac,
/* 112 - _0F_12 */  0xe6b8,
/* 113 - _0F_13 */  0xe6c4,
/* 114 - _0F_14 */  0xe6d0,
/* 115 - _0F_15 */  0xe6dc,
/* 116 - _0F_16 */  0xe6e8,
/* 117 - _0F_17 */  0xe6f4,
/* 118 - _0F_18 */  0x8700,
/* 119 -  */  0,
/* 11a -  */  0,
/* 11b -  */  0,
/* 11c -  */  0,
/* 11d -  */  0,
/* 11e -  */  0,
/* 11f - _0F_1F */  0x20de,
/* 120 - _0F_20 */  0x20df,
/* 121 - _0F_21 */  0x20e0,
/* 122 - _0F_22 */  0x20e1,
/* 123 - _0F_23 */  0x20e2,
/* 124 -  */  0,
/* 125 -  */  0,
/* 126 -  */  0,
/* 127 -  */  0,
/* 128 - _0F_28 */  0xe708,
/* 129 - _0F_29 */  0xe714,
/* 12a - _0F_2A */  0xe720,
/* 12b - _0F_2B */  0xe72c,
/* 12c - _0F_2C */  0xe738,
/* 12d - _0F_2D */  0xe744,
/* 12e - _0F_2E */  0xe750,
/* 12f - _0F_2F */  0xe75c,
/* 130 - _0F_30 */  0x20e3,
/* 131 - _0F_31 */  0x20e4,
/* 132 - _0F_32 */  0x20e5,
/* 133 - _0F_33 */  0x20e6,
/* 134 - _0F_34 */  0x20e7,
/* 135 - _0F_35 */  0x20e8,
/* 136 -  */  0,
/* 137 - _0F_37 */  0x20e9,
/* 138 - _0F_38 */  0xa768,
/* 139 -  */  0,
/* 13a - _0F_3A */  0xa868,
/* 13b -  */  0,
/* 13c -  */  0,
/* 13d -  */  0,
/* 13e -  */  0,
/* 13f -  */  0,
/* 140 - _0F_40 */  0x20ea,
/* 141 - _0F_41 */  0x20eb,
/* 142 - _0F_42 */  0x20ec,
/* 143 - _0F_43 */  0x20ed,
/* 144 - _0F_44 */  0x20ee,
/* 145 - _0F_45 */  0x20ef,
/* 146 - _0F_46 */  0x20f0,
/* 147 - _0F_47 */  0x20f1,
/* 148 - _0F_48 */  0x20f2,
/* 149 - _0F_49 */  0x20f3,
/* 14a - _0F_4A */  0x20f4,
/* 14b - _0F_4B */  0x20f5,
/* 14c - _0F_4C */  0x20f6,
/* 14d - _0F_4D */  0x20f7,
/* 14e - _0F_4E */  0x20f8,
/* 14f - _0F_4F */  0x20f9,
/* 150 - _0F_50 */  0xe968,
/* 151 - _0F_51 */  0xe974,
/* 152 - _0F_52 */  0xe980,
/* 153 - _0F_53 */  0xe98c,
/* 154 - _0F_54 */  0xe998,
/* 155 - _0F_55 */  0xe9a4,
/* 156 - _0F_56 */  0xe9b0,
/* 157 - _0F_57 */  0xe9bc,
/* 158 - _0F_58 */  0xe9c8,
/* 159 - _0F_59 */  0xe9d4,
/* 15a - _0F_5A */  0xe9e0,
/* 15b - _0F_5B */  0xe9ec,
/* 15c - _0F_5C */  0xe9f8,
/* 15d - _0F_5D */  0xea04,
/* 15e - _0F_5E */  0xea10,
/* 15f - _0F_5F */  0xea1c,
/* 160 - _0F_60 */  0xea28,
/* 161 - _0F_61 */  0xea34,
/* 162 - _0F_62 */  0xea40,
/* 163 - _0F_63 */  0xea4c,
/* 164 - _0F_64 */  0xea58,
/* 165 - _0F_65 */  0xea64,
/* 166 - _0F_66 */  0xea70,
/* 167 - _0F_67 */  0xea7c,
/* 168 - _0F_68 */  0xea88,
/* 169 - _0F_69 */  0xea94,
/* 16a - _0F_6A */  0xeaa0,
/* 16b - _0F_6B */  0xeaac,
/* 16c - _0F_6C */  0xeab8,
/* 16d - _0F_6D */  0xeac4,
/* 16e - _0F_6E */  0xead0,
/* 16f - _0F_6F */  0xeadc,
/* 170 - _0F_70 */  0xeae8,
/* 171 - _0F_71 */  0x8af4,
/* 172 - _0F_72 */  0x8afc,
/* 173 - _0F_73 */  0x8b04,
/* 174 - _0F_74 */  0xeb0c,
/* 175 - _0F_75 */  0xeb18,
/* 176 - _0F_76 */  0xeb24,
/* 177 - _0F_77 */  0xeb30,
/* 178 - _0F_78 */  0xeb3c,
/* 179 - _0F_79 */  0xeb48,
/* 17a - _0F_7A */  0xab54,
/* 17b -  */  0,
/* 17c - _0F_7C */  0xec54,
/* 17d - _0F_7D */  0xec60,
/* 17e - _0F_7E */  0xec6c,
/* 17f - _0F_7F */  0xec78,
/* 180 - _0F_80 */  0x20fa,
/* 181 - _0F_81 */  0x20fb,
/* 182 - _0F_82 */  0x20fc,
/* 183 - _0F_83 */  0x20fd,
/* 184 - _0F_84 */  0x20fe,
/* 185 - _0F_85 */  0x20ff,
/* 186 - _0F_86 */  0x2100,
/* 187 - _0F_87 */  0x2101,
/* 188 - _0F_88 */  0x2102,
/* 189 - _0F_89 */  0x2103,
/* 18a - _0F_8A */  0x2104,
/* 18b - _0F_8B */  0x2105,
/* 18c - _0F_8C */  0x2106,
/* 18d - _0F_8D */  0x2107,
/* 18e - _0F_8E */  0x2108,
/* 18f - _0F_8F */  0x2109,
/* 190 - _0F_90 */  0x210a,
/* 191 - _0F_91 */  0x210b,
/* 192 - _0F_92 */  0x210c,
/* 193 - _0F_93 */  0x210d,
/* 194 - _0F_94 */  0x210e,
/* 195 - _0F_95 */  0x210f,
/* 196 - _0F_96 */  0x2110,
/* 197 - _0F_97 */  0x2111,
/* 198 - _0F_98 */  0x2112,
/* 199 - _0F_99 */  0x2113,
/* 19a - _0F_9A */  0x2114,
/* 19b - _0F_9B */  0x2115,
/* 19c - _0F_9C */  0x2116,
/* 19d - _0F_9D */  0x2117,
/* 19e - _0F_9E */  0x2118,
/* 19f - _0F_9F */  0x2119,
/* 1a0 - _0F_A0 */  0x211a,
/* 1a1 - _0F_A1 */  0x211b,
/* 1a2 - _0F_A2 */  0x211c,
/* 1a3 - _0F_A3 */  0x211d,
/* 1a4 - _0F_A4 */  0x4005,
/* 1a5 - _0F_A5 */  0x4006,
/* 1a6 -  */  0,
/* 1a7 -  */  0,
/* 1a8 - _0F_A8 */  0x211e,
/* 1a9 - _0F_A9 */  0x211f,
/* 1aa - _0F_AA */  0x2120,
/* 1ab - _0F_AB */  0x2121,
/* 1ac - _0F_AC */  0x4007,
/* 1ad - _0F_AD */  0x4008,
/* 1ae - _0F_AE */  0x8c84,
/* 1af - _0F_AF */  0x2122,
/* 1b0 - _0F_B0 */  0x2123,
/* 1b1 - _0F_B1 */  0x2124,
/* 1b2 - _0F_B2 */  0x2125,
/* 1b3 - _0F_B3 */  0x2126,
/* 1b4 - _0F_B4 */  0x2127,
/* 1b5 - _0F_B5 */  0x2128,
/* 1b6 - _0F_B6 */  0x2129,
/* 1b7 - _0F_B7 */  0x212a,
/* 1b8 - _0F_B8 */  0xec8c,
/* 1b9 - _0F_B9 */  0x212b,
/* 1ba - _0F_BA */  0x8c98,
/* 1bb - _0F_BB */  0x212c,
/* 1bc - _0F_BC */  0xeca0,
/* 1bd - _0F_BD */  0xecac,
/* 1be - _0F_BE */  0x212d,
/* 1bf - _0F_BF */  0x212e,
/* 1c0 - _0F_C0 */  0x212f,
/* 1c1 - _0F_C1 */  0x2130,
/* 1c2 - _0F_C2 */  0xecb8,
/* 1c3 - _0F_C3 */  0x2131,
/* 1c4 - _0F_C4 */  0xecc4,
/* 1c5 - _0F_C5 */  0xecd0,
/* 1c6 - _0F_C6 */  0xecdc,
/* 1c7 - _0F_C7 */  0x8ce8,
/* 1c8 - _0F_C8 */  0x2132,
/* 1c9 - _0F_C8 */  0x2133,
/* 1ca - _0F_C8 */  0x2134,
/* 1cb - _0F_C8 */  0x2135,
/* 1cc - _0F_C8 */  0x2136,
/* 1cd - _0F_C8 */  0x2137,
/* 1ce - _0F_C8 */  0x2138,
/* 1cf - _0F_C8 */  0x2139,
/* 1d0 - _0F_D0 */  0xecf0,
/* 1d1 - _0F_D1 */  0xecfc,
/* 1d2 - _0F_D2 */  0xed08,
/* 1d3 - _0F_D3 */  0xed14,
/* 1d4 - _0F_D4 */  0xed20,
/* 1d5 - _0F_D5 */  0xed2c,
/* 1d6 - _0F_D6 */  0xed38,
/* 1d7 - _0F_D7 */  0xed44,
/* 1d8 - _0F_D8 */  0xed50,
/* 1d9 - _0F_D9 */  0xed5c,
/* 1da - _0F_DA */  0xed68,
/* 1db - _0F_DB */  0xed74,
/* 1dc - _0F_DC */  0xed80,
/* 1dd - _0F_DD */  0xed8c,
/* 1de - _0F_DE */  0xed98,
/* 1df - _0F_DF */  0xeda4,
/* 1e0 - _0F_E0 */  0xedb0,
/* 1e1 - _0F_E1 */  0xedbc,
/* 1e2 - _0F_E2 */  0xedc8,
/* 1e3 - _0F_E3 */  0xedd4,
/* 1e4 - _0F_E4 */  0xede0,
/* 1e5 - _0F_E5 */  0xedec,
/* 1e6 - _0F_E6 */  0xedf8,
/* 1e7 - _0F_E7 */  0xee04,
/* 1e8 - _0F_E8 */  0xee10,
/* 1e9 - _0F_E9 */  0xee1c,
/* 1ea - _0F_EA */  0xee28,
/* 1eb - _0F_EB */  0xee34,
/* 1ec - _0F_EC */  0xee40,
/* 1ed - _0F_ED */  0xee4c,
/* 1ee - _0F_EE */  0xee58,
/* 1ef - _0F_EF */  0xee64,
/* 1f0 - _0F_F0 */  0xee70,
/* 1f1 - _0F_F1 */  0xee7c,
/* 1f2 - _0F_F2 */  0xee88,
/* 1f3 - _0F_F3 */  0xee94,
/* 1f4 - _0F_F4 */  0xeea0,
/* 1f5 - _0F_F5 */  0xeeac,
/* 1f6 - _0F_F6 */  0xeeb8,
/* 1f7 - _0F_F7 */  0xeec4,
/* 1f8 - _0F_F8 */  0xeed0,
/* 1f9 - _0F_F9 */  0xeedc,
/* 1fa - _0F_FA */  0xeee8,
/* 1fb - _0F_FB */  0xeef4,
/* 1fc - _0F_FC */  0xef00,
/* 1fd - _0F_FD */  0xef0c,
/* 1fe - _0F_FE */  0xef18,
/* 1ff -  */  0,
/* 200 - _80_00 */  0x213a,
/* 201 - _80_01 */  0x213b,
/* 202 - _80_02 */  0x213c,
/* 203 - _80_03 */  0x213d,
/* 204 - _80_04 */  0x213e,
/* 205 - _80_05 */  0x213f,
/* 206 - _80_06 */  0x2140,
/* 207 - _80_07 */  0x2141,
/* 208 - _81_00 */  0x2142,
/* 209 - _81_01 */  0x2143,
/* 20a - _81_02 */  0x2144,
/* 20b - _81_03 */  0x2145,
/* 20c - _81_04 */  0x2146,
/* 20d - _81_05 */  0x2147,
/* 20e - _81_06 */  0x2148,
/* 20f - _81_07 */  0x2149,
/* 210 - _82_00 */  0x214a,
/* 211 - _82_01 */  0x214b,
/* 212 - _82_02 */  0x214c,
/* 213 - _82_03 */  0x214d,
/* 214 - _82_04 */  0x214e,
/* 215 - _82_05 */  0x214f,
/* 216 - _82_06 */  0x2150,
/* 217 - _82_07 */  0x2151,
/* 218 - _83_00 */  0x2152,
/* 219 - _83_01 */  0x2153,
/* 21a - _83_02 */  0x2154,
/* 21b - _83_03 */  0x2155,
/* 21c - _83_04 */  0x2156,
/* 21d - _83_05 */  0x2157,
/* 21e - _83_06 */  0x2158,
/* 21f - _83_07 */  0x2159,
/* 220 - _8F_00 */  0x215a,
/* 221 -  */  0,
/* 222 -  */  0,
/* 223 -  */  0,
/* 224 -  */  0,
/* 225 -  */  0,
/* 226 -  */  0,
/* 227 -  */  0,
/* 228 - _C0_00 */  0x215b,
/* 229 - _C0_01 */  0x215c,
/* 22a - _C0_02 */  0x215d,
/* 22b - _C0_03 */  0x215e,
/* 22c - _C0_04 */  0x215f,
/* 22d - _C0_05 */  0x2160,
/* 22e - _C0_06 */  0x2161,
/* 22f - _C0_07 */  0x2162,
/* 230 - _C1_00 */  0x2163,
/* 231 - _C1_01 */  0x2164,
/* 232 - _C1_02 */  0x2165,
/* 233 - _C1_03 */  0x2166,
/* 234 - _C1_04 */  0x2167,
/* 235 - _C1_05 */  0x2168,
/* 236 - _C1_06 */  0x2169,
/* 237 - _C1_07 */  0x216a,
/* 238 - _C6_00 */  0x216b,
/* 239 -  */  0,
/* 23a -  */  0,
/* 23b -  */  0,
/* 23c -  */  0,
/* 23d -  */  0,
/* 23e -  */  0,
/* 23f -  */  0,
/* 240 -  */  0,
/* 241 -  */  0,
/* 242 -  */  0,
/* 243 -  */  0,
/* 244 -  */  0,
/* 245 -  */  0,
/* 246 -  */  0,
/* 247 -  */  0,
/* 248 -  */  0,
/* 249 -  */  0,
/* 24a -  */  0,
/* 24b -  */  0,
/* 24c -  */  0,
/* 24d -  */  0,
/* 24e -  */  0,
/* 24f -  */  0,
/* 250 -  */  0,
/* 251 -  */  0,
/* 252 -  */  0,
/* 253 -  */  0,
/* 254 -  */  0,
/* 255 -  */  0,
/* 256 -  */  0,
/* 257 -  */  0,
/* 258 -  */  0,
/* 259 -  */  0,
/* 25a -  */  0,
/* 25b -  */  0,
/* 25c -  */  0,
/* 25d -  */  0,
/* 25e -  */  0,
/* 25f -  */  0,
/* 260 -  */  0,
/* 261 -  */  0,
/* 262 -  */  0,
/* 263 -  */  0,
/* 264 -  */  0,
/* 265 -  */  0,
/* 266 -  */  0,
/* 267 -  */  0,
/* 268 -  */  0,
/* 269 -  */  0,
/* 26a -  */  0,
/* 26b -  */  0,
/* 26c -  */  0,
/* 26d -  */  0,
/* 26e -  */  0,
/* 26f -  */  0,
/* 270 -  */  0,
/* 271 -  */  0,
/* 272 -  */  0,
/* 273 -  */  0,
/* 274 -  */  0,
/* 275 -  */  0,
/* 276 -  */  0,
/* 277 -  */  0,
/* 278 - _C6_F8 */  0x216c,
/* 279 -  */  0,
/* 27a -  */  0,
/* 27b -  */  0,
/* 27c -  */  0,
/* 27d -  */  0,
/* 27e -  */  0,
/* 27f -  */  0,
/* 280 - _C7_00 */  0x216d,
/* 281 -  */  0,
/* 282 -  */  0,
/* 283 -  */  0,
/* 284 -  */  0,
/* 285 -  */  0,
/* 286 -  */  0,
/* 287 -  */  0,
/* 288 -  */  0,
/* 289 -  */  0,
/* 28a -  */  0,
/* 28b -  */  0,
/* 28c -  */  0,
/* 28d -  */  0,
/* 28e -  */  0,
/* 28f -  */  0,
/* 290 -  */  0,
/* 291 -  */  0,
/* 292 -  */  0,
/* 293 -  */  0,
/* 294 -  */  0,
/* 295 -  */  0,
/* 296 -  */  0,
/* 297 -  */  0,
/* 298 -  */  0,
/* 299 -  */  0,
/* 29a -  */  0,
/* 29b -  */  0,
/* 29c -  */  0,
/* 29d -  */  0,
/* 29e -  */  0,
/* 29f -  */  0,
/* 2a0 -  */  0,
/* 2a1 -  */  0,
/* 2a2 -  */  0,
/* 2a3 -  */  0,
/* 2a4 -  */  0,
/* 2a5 -  */  0,
/* 2a6 -  */  0,
/* 2a7 -  */  0,
/* 2a8 -  */  0,
/* 2a9 -  */  0,
/* 2aa -  */  0,
/* 2ab -  */  0,
/* 2ac -  */  0,
/* 2ad -  */  0,
/* 2ae -  */  0,
/* 2af -  */  0,
/* 2b0 -  */  0,
/* 2b1 -  */  0,
/* 2b2 -  */  0,
/* 2b3 -  */  0,
/* 2b4 -  */  0,
/* 2b5 -  */  0,
/* 2b6 -  */  0,
/* 2b7 -  */  0,
/* 2b8 -  */  0,
/* 2b9 -  */  0,
/* 2ba -  */  0,
/* 2bb -  */  0,
/* 2bc -  */  0,
/* 2bd -  */  0,
/* 2be -  */  0,
/* 2bf -  */  0,
/* 2c0 - _C7_F8 */  0x216e,
/* 2c1 -  */  0,
/* 2c2 -  */  0,
/* 2c3 -  */  0,
/* 2c4 -  */  0,
/* 2c5 -  */  0,
/* 2c6 -  */  0,
/* 2c7 -  */  0,
/* 2c8 - _D0_00 */  0x216f,
/* 2c9 - _D0_01 */  0x2170,
/* 2ca - _D0_02 */  0x2171,
/* 2cb - _D0_03 */  0x2172,
/* 2cc - _D0_04 */  0x2173,
/* 2cd - _D0_05 */  0x2174,
/* 2ce - _D0_06 */  0x2175,
/* 2cf - _D0_07 */  0x2176,
/* 2d0 - _D1_00 */  0x2177,
/* 2d1 - _D1_01 */  0x2178,
/* 2d2 - _D1_02 */  0x2179,
/* 2d3 - _D1_03 */  0x217a,
/* 2d4 - _D1_04 */  0x217b,
/* 2d5 - _D1_05 */  0x217c,
/* 2d6 - _D1_06 */  0x217d,
/* 2d7 - _D1_07 */  0x217e,
/* 2d8 - _D2_00 */  0x217f,
/* 2d9 - _D2_01 */  0x2180,
/* 2da - _D2_02 */  0x2181,
/* 2db - _D2_03 */  0x2182,
/* 2dc - _D2_04 */  0x2183,
/* 2dd - _D2_05 */  0x2184,
/* 2de - _D2_06 */  0x2185,
/* 2df - _D2_07 */  0x2186,
/* 2e0 - _D3_00 */  0x2187,
/* 2e1 - _D3_01 */  0x2188,
/* 2e2 - _D3_02 */  0x2189,
/* 2e3 - _D3_03 */  0x218a,
/* 2e4 - _D3_04 */  0x218b,
/* 2e5 - _D3_05 */  0x218c,
/* 2e6 - _D3_06 */  0x218d,
/* 2e7 - _D3_07 */  0x218e,
/* 2e8 - _D8_00 */  0x218f,
/* 2e9 - _D8_01 */  0x2190,
/* 2ea - _D8_02 */  0x2191,
/* 2eb - _D8_03 */  0x2192,
/* 2ec - _D8_04 */  0x2193,
/* 2ed - _D8_05 */  0x2194,
/* 2ee - _D8_06 */  0x2195,
/* 2ef - _D8_07 */  0x2196,
/* 2f0 - _D8_C0 */  0x2197,
/* 2f1 - _D8_C0 */  0x2198,
/* 2f2 - _D8_C0 */  0x2199,
/* 2f3 - _D8_C0 */  0x219a,
/* 2f4 - _D8_C0 */  0x219b,
/* 2f5 - _D8_C0 */  0x219c,
/* 2f6 - _D8_C0 */  0x219d,
/* 2f7 - _D8_C0 */  0x219e,
/* 2f8 - _D8_C8 */  0x219f,
/* 2f9 - _D8_C8 */  0x21a0,
/* 2fa - _D8_C8 */  0x21a1,
/* 2fb - _D8_C8 */  0x21a2,
/* 2fc - _D8_C8 */  0x21a3,
/* 2fd - _D8_C8 */  0x21a4,
/* 2fe - _D8_C8 */  0x21a5,
/* 2ff - _D8_C8 */  0x21a6,
/* 300 - _D8_D0 */  0x21a7,
/* 301 - _D8_D0 */  0x21a8,
/* 302 - _D8_D0 */  0x21a9,
/* 303 - _D8_D0 */  0x21aa,
/* 304 - _D8_D0 */  0x21ab,
/* 305 - _D8_D0 */  0x21ac,
/* 306 - _D8_D0 */  0x21ad,
/* 307 - _D8_D0 */  0x21ae,
/* 308 - _D8_D8 */  0x21af,
/* 309 - _D8_D9 */  0x21b0,
/* 30a - _D8_D8 */  0x21b1,
/* 30b - _D8_D8 */  0x21b2,
/* 30c - _D8_D8 */  0x21b3,
/* 30d - _D8_D8 */  0x21b4,
/* 30e - _D8_D8 */  0x21b5,
/* 30f - _D8_D8 */  0x21b6,
/* 310 - _D8_E0 */  0x21b7,
/* 311 - _D8_E0 */  0x21b8,
/* 312 - _D8_E0 */  0x21b9,
/* 313 - _D8_E0 */  0x21ba,
/* 314 - _D8_E0 */  0x21bb,
/* 315 - _D8_E0 */  0x21bc,
/* 316 - _D8_E0 */  0x21bd,
/* 317 - _D8_E0 */  0x21be,
/* 318 - _D8_E8 */  0x21bf,
/* 319 - _D8_E8 */  0x21c0,
/* 31a - _D8_E8 */  0x21c1,
/* 31b - _D8_E8 */  0x21c2,
/* 31c - _D8_E8 */  0x21c3,
/* 31d - _D8_E8 */  0x21c4,
/* 31e - _D8_E8 */  0x21c5,
/* 31f - _D8_E8 */  0x21c6,
/* 320 - _D8_F0 */  0x21c7,
/* 321 - _D8_F0 */  0x21c8,
/* 322 - _D8_F0 */  0x21c9,
/* 323 - _D8_F0 */  0x21ca,
/* 324 - _D8_F0 */  0x21cb,
/* 325 - _D8_F0 */  0x21cc,
/* 326 - _D8_F0 */  0x21cd,
/* 327 - _D8_F0 */  0x21ce,
/* 328 - _D8_F8 */  0x21cf,
/* 329 - _D8_F8 */  0x21d0,
/* 32a - _D8_F8 */  0x21d1,
/* 32b - _D8_F8 */  0x21d2,
/* 32c - _D8_F8 */  0x21d3,
/* 32d - _D8_F8 */  0x21d4,
/* 32e - _D8_F8 */  0x21d5,
/* 32f - _D8_F8 */  0x21d6,
/* 330 - _D9_00 */  0x21d7,
/* 331 -  */  0,
/* 332 - _D9_02 */  0x21d8,
/* 333 - _D9_03 */  0x21d9,
/* 334 - _D9_04 */  0x21da,
/* 335 - _D9_05 */  0x21db,
/* 336 - _D9_06 */  0xef24,
/* 337 - _D9_07 */  0xef30,
/* 338 - _D9_C0 */  0x21dc,
/* 339 - _D9_C0 */  0x21dd,
/* 33a - _D9_C0 */  0x21de,
/* 33b - _D9_C0 */  0x21df,
/* 33c - _D9_C0 */  0x21e0,
/* 33d - _D9_C0 */  0x21e1,
/* 33e - _D9_C0 */  0x21e2,
/* 33f - _D9_C0 */  0x21e3,
/* 340 - _D9_C8 */  0x21e4,
/* 341 - _D9_C9 */  0x21e5,
/* 342 - _D9_C8 */  0x21e6,
/* 343 - _D9_C8 */  0x21e7,
/* 344 - _D9_C8 */  0x21e8,
/* 345 - _D9_C8 */  0x21e9,
/* 346 - _D9_C8 */  0x21ea,
/* 347 - _D9_C8 */  0x21eb,
/* 348 - _D9_D0 */  0x21ec,
/* 349 -  */  0,
/* 34a -  */  0,
/* 34b -  */  0,
/* 34c -  */  0,
/* 34d -  */  0,
/* 34e -  */  0,
/* 34f -  */  0,
/* 350 -  */  0,
/* 351 -  */  0,
/* 352 -  */  0,
/* 353 -  */  0,
/* 354 -  */  0,
/* 355 -  */  0,
/* 356 -  */  0,
/* 357 -  */  0,
/* 358 - _D9_E0 */  0x21ed,
/* 359 - _D9_E1 */  0x21ee,
/* 35a -  */  0,
/* 35b -  */  0,
/* 35c - _D9_E4 */  0x21ef,
/* 35d - _D9_E5 */  0x21f0,
/* 35e -  */  0,
/* 35f -  */  0,
/* 360 - _D9_E8 */  0x21f1,
/* 361 - _D9_E9 */  0x21f2,
/* 362 - _D9_EA */  0x21f3,
/* 363 - _D9_EB */  0x21f4,
/* 364 - _D9_EC */  0x21f5,
/* 365 - _D9_ED */  0x21f6,
/* 366 - _D9_EE */  0x21f7,
/* 367 -  */  0,
/* 368 - _D9_F0 */  0x21f8,
/* 369 - _D9_F1 */  0x21f9,
/* 36a - _D9_F2 */  0x21fa,
/* 36b - _D9_F3 */  0x21fb,
/* 36c - _D9_F4 */  0x21fc,
/* 36d - _D9_F5 */  0x21fd,
/* 36e - _D9_F6 */  0x21fe,
/* 36f - _D9_F7 */  0x21ff,
/* 370 - _D9_F8 */  0x2200,
/* 371 - _D9_F9 */  0x2201,
/* 372 - _D9_FA */  0x2202,
/* 373 - _D9_FB */  0x2203,
/* 374 - _D9_FC */  0x2204,
/* 375 - _D9_FD */  0x2205,
/* 376 - _D9_FE */  0x2206,
/* 377 - _D9_FF */  0x2207,
/* 378 - _DA_00 */  0x2208,
/* 379 - _DA_01 */  0x2209,
/* 37a - _DA_02 */  0x220a,
/* 37b - _DA_03 */  0x220b,
/* 37c - _DA_04 */  0x220c,
/* 37d - _DA_05 */  0x220d,
/* 37e - _DA_06 */  0x220e,
/* 37f - _DA_07 */  0x220f,
/* 380 - _DA_C0 */  0x2210,
/* 381 - _DA_C0 */  0x2211,
/* 382 - _DA_C0 */  0x2212,
/* 383 - _DA_C0 */  0x2213,
/* 384 - _DA_C0 */  0x2214,
/* 385 - _DA_C0 */  0x2215,
/* 386 - _DA_C0 */  0x2216,
/* 387 - _DA_C0 */  0x2217,
/* 388 - _DA_C8 */  0x2218,
/* 389 - _DA_C8 */  0x2219,
/* 38a - _DA_C8 */  0x221a,
/* 38b - _DA_C8 */  0x221b,
/* 38c - _DA_C8 */  0x221c,
/* 38d - _DA_C8 */  0x221d,
/* 38e - _DA_C8 */  0x221e,
/* 38f - _DA_C8 */  0x221f,
/* 390 - _DA_D0 */  0x2220,
/* 391 - _DA_D0 */  0x2221,
/* 392 - _DA_D0 */  0x2222,
/* 393 - _DA_D0 */  0x2223,
/* 394 - _DA_D0 */  0x2224,
/* 395 - _DA_D0 */  0x2225,
/* 396 - _DA_D0 */  0x2226,
/* 397 - _DA_D0 */  0x2227,
/* 398 - _DA_D8 */  0x2228,
/* 399 - _DA_D8 */  0x2229,
/* 39a - _DA_D8 */  0x222a,
/* 39b - _DA_D8 */  0x222b,
/* 39c - _DA_D8 */  0x222c,
/* 39d - _DA_D8 */  0x222d,
/* 39e - _DA_D8 */  0x222e,
/* 39f - _DA_D8 */  0x222f,
/* 3a0 -  */  0,
/* 3a1 -  */  0,
/* 3a2 -  */  0,
/* 3a3 -  */  0,
/* 3a4 -  */  0,
/* 3a5 -  */  0,
/* 3a6 -  */  0,
/* 3a7 -  */  0,
/* 3a8 -  */  0,
/* 3a9 - _DA_E9 */  0x2230,
/* 3aa -  */  0,
/* 3ab -  */  0,
/* 3ac -  */  0,
/* 3ad -  */  0,
/* 3ae -  */  0,
/* 3af -  */  0,
/* 3b0 -  */  0,
/* 3b1 -  */  0,
/* 3b2 -  */  0,
/* 3b3 -  */  0,
/* 3b4 -  */  0,
/* 3b5 -  */  0,
/* 3b6 -  */  0,
/* 3b7 -  */  0,
/* 3b8 -  */  0,
/* 3b9 -  */  0,
/* 3ba -  */  0,
/* 3bb -  */  0,
/* 3bc -  */  0,
/* 3bd -  */  0,
/* 3be -  */  0,
/* 3bf -  */  0,
/* 3c0 - _DB_00 */  0x2231,
/* 3c1 - _DB_01 */  0x2232,
/* 3c2 - _DB_02 */  0x2233,
/* 3c3 - _DB_03 */  0x2234,
/* 3c4 -  */  0,
/* 3c5 - _DB_05 */  0x2235,
/* 3c6 -  */  0,
/* 3c7 - _DB_07 */  0x2236,
/* 3c8 - _DB_C0 */  0x2237,
/* 3c9 - _DB_C0 */  0x2238,
/* 3ca - _DB_C0 */  0x2239,
/* 3cb - _DB_C0 */  0x223a,
/* 3cc - _DB_C0 */  0x223b,
/* 3cd - _DB_C0 */  0x223c,
/* 3ce - _DB_C0 */  0x223d,
/* 3cf - _DB_C0 */  0x223e,
/* 3d0 - _DB_C8 */  0x223f,
/* 3d1 - _DB_C8 */  0x2240,
/* 3d2 - _DB_C8 */  0x2241,
/* 3d3 - _DB_C8 */  0x2242,
/* 3d4 - _DB_C8 */  0x2243,
/* 3d5 - _DB_C8 */  0x2244,
/* 3d6 - _DB_C8 */  0x2245,
/* 3d7 - _DB_C8 */  0x2246,
/* 3d8 - _DB_D0 */  0x2247,
/* 3d9 - _DB_D0 */  0x2248,
/* 3da - _DB_D0 */  0x2249,
/* 3db - _DB_D0 */  0x224a,
/* 3dc - _DB_D0 */  0x224b,
/* 3dd - _DB_D0 */  0x224c,
/* 3de - _DB_D0 */  0x224d,
/* 3df - _DB_D0 */  0x224e,
/* 3e0 - _DB_D8 */  0x224f,
/* 3e1 - _DB_D8 */  0x2250,
/* 3e2 - _DB_D8 */  0x2251,
/* 3e3 - _DB_D8 */  0x2252,
/* 3e4 - _DB_D8 */  0x2253,
/* 3e5 - _DB_D8 */  0x2254,
/* 3e6 - _DB_D8 */  0x2255,
/* 3e7 - _DB_D8 */  0x2256,
/* 3e8 - _DB_E0 */  0x2257,
/* 3e9 - _DB_E1 */  0x2258,
/* 3ea - _DB_E2 */  0xef3c,
/* 3eb - _DB_E3 */  0xef48,
/* 3ec - _DB_E4 */  0x2259,
/* 3ed -  */  0,
/* 3ee -  */  0,
/* 3ef -  */  0,
/* 3f0 - _DB_E8 */  0x225a,
/* 3f1 - _DB_E8 */  0x225b,
/* 3f2 - _DB_E8 */  0x225c,
/* 3f3 - _DB_E8 */  0x225d,
/* 3f4 - _DB_E8 */  0x225e,
/* 3f5 - _DB_E8 */  0x225f,
/* 3f6 - _DB_E8 */  0x2260,
/* 3f7 - _DB_E8 */  0x2261,
/* 3f8 - _DB_F0 */  0x2262,
/* 3f9 - _DB_F0 */  0x2263,
/* 3fa - _DB_F0 */  0x2264,
/* 3fb - _DB_F0 */  0x2265,
/* 3fc - _DB_F0 */  0x2266,
/* 3fd - _DB_F0 */  0x2267,
/* 3fe - _DB_F0 */  0x2268,
/* 3ff - _DB_F0 */  0x2269,
/* 400 -  */  0,
/* 401 -  */  0,
/* 402 -  */  0,
/* 403 -  */  0,
/* 404 -  */  0,
/* 405 -  */  0,
/* 406 -  */  0,
/* 407 -  */  0,
/* 408 - _DC_00 */  0x226a,
/* 409 - _DC_01 */  0x226b,
/* 40a - _DC_02 */  0x226c,
/* 40b - _DC_03 */  0x226d,
/* 40c - _DC_04 */  0x226e,
/* 40d - _DC_05 */  0x226f,
/* 40e - _DC_06 */  0x2270,
/* 40f - _DC_07 */  0x2271,
/* 410 - _DC_C0 */  0x2272,
/* 411 - _DC_C0 */  0x2273,
/* 412 - _DC_C0 */  0x2274,
/* 413 - _DC_C0 */  0x2275,
/* 414 - _DC_C0 */  0x2276,
/* 415 - _DC_C0 */  0x2277,
/* 416 - _DC_C0 */  0x2278,
/* 417 - _DC_C0 */  0x2279,
/* 418 - _DC_C8 */  0x227a,
/* 419 - _DC_C8 */  0x227b,
/* 41a - _DC_C8 */  0x227c,
/* 41b - _DC_C8 */  0x227d,
/* 41c - _DC_C8 */  0x227e,
/* 41d - _DC_C8 */  0x227f,
/* 41e - _DC_C8 */  0x2280,
/* 41f - _DC_C8 */  0x2281,
/* 420 -  */  0,
/* 421 -  */  0,
/* 422 -  */  0,
/* 423 -  */  0,
/* 424 -  */  0,
/* 425 -  */  0,
/* 426 -  */  0,
/* 427 -  */  0,
/* 428 -  */  0,
/* 429 -  */  0,
/* 42a -  */  0,
/* 42b -  */  0,
/* 42c -  */  0,
/* 42d -  */  0,
/* 42e -  */  0,
/* 42f -  */  0,
/* 430 - _DC_E0 */  0x2282,
/* 431 - _DC_E0 */  0x2283,
/* 432 - _DC_E0 */  0x2284,
/* 433 - _DC_E0 */  0x2285,
/* 434 - _DC_E0 */  0x2286,
/* 435 - _DC_E0 */  0x2287,
/* 436 - _DC_E0 */  0x2288,
/* 437 - _DC_E0 */  0x2289,
/* 438 - _DC_E8 */  0x228a,
/* 439 - _DC_E8 */  0x228b,
/* 43a - _DC_E8 */  0x228c,
/* 43b - _DC_E8 */  0x228d,
/* 43c - _DC_E8 */  0x228e,
/* 43d - _DC_E8 */  0x228f,
/* 43e - _DC_E8 */  0x2290,
/* 43f - _DC_E8 */  0x2291,
/* 440 - _DC_F0 */  0x2292,
/* 441 - _DC_F0 */  0x2293,
/* 442 - _DC_F0 */  0x2294,
/* 443 - _DC_F0 */  0x2295,
/* 444 - _DC_F0 */  0x2296,
/* 445 - _DC_F0 */  0x2297,
/* 446 - _DC_F0 */  0x2298,
/* 447 - _DC_F0 */  0x2299,
/* 448 - _DC_F8 */  0x229a,
/* 449 - _DC_F8 */  0x229b,
/* 44a - _DC_F8 */  0x229c,
/* 44b - _DC_F8 */  0x229d,
/* 44c - _DC_F8 */  0x229e,
/* 44d - _DC_F8 */  0x229f,
/* 44e - _DC_F8 */  0x22a0,
/* 44f - _DC_F8 */  0x22a1,
/* 450 - _DD_00 */  0x22a2,
/* 451 - _DD_01 */  0x22a3,
/* 452 - _DD_02 */  0x22a4,
/* 453 - _DD_03 */  0x22a5,
/* 454 - _DD_04 */  0x22a6,
/* 455 -  */  0,
/* 456 - _DD_06 */  0xef54,
/* 457 - _DD_07 */  0xef60,
/* 458 - _DD_C0 */  0x22a7,
/* 459 - _DD_C0 */  0x22a8,
/* 45a - _DD_C0 */  0x22a9,
/* 45b - _DD_C0 */  0x22aa,
/* 45c - _DD_C0 */  0x22ab,
/* 45d - _DD_C0 */  0x22ac,
/* 45e - _DD_C0 */  0x22ad,
/* 45f - _DD_C0 */  0x22ae,
/* 460 -  */  0,
/* 461 -  */  0,
/* 462 -  */  0,
/* 463 -  */  0,
/* 464 -  */  0,
/* 465 -  */  0,
/* 466 -  */  0,
/* 467 -  */  0,
/* 468 - _DD_D0 */  0x22af,
/* 469 - _DD_D0 */  0x22b0,
/* 46a - _DD_D0 */  0x22b1,
/* 46b - _DD_D0 */  0x22b2,
/* 46c - _DD_D0 */  0x22b3,
/* 46d - _DD_D0 */  0x22b4,
/* 46e - _DD_D0 */  0x22b5,
/* 46f - _DD_D0 */  0x22b6,
/* 470 - _DD_D8 */  0x22b7,
/* 471 - _DD_D8 */  0x22b8,
/* 472 - _DD_D8 */  0x22b9,
/* 473 - _DD_D8 */  0x22ba,
/* 474 - _DD_D8 */  0x22bb,
/* 475 - _DD_D8 */  0x22bc,
/* 476 - _DD_D8 */  0x22bd,
/* 477 - _DD_D8 */  0x22be,
/* 478 - _DD_E0 */  0x22bf,
/* 479 - _DD_E1 */  0x22c0,
/* 47a - _DD_E0 */  0x22c1,
/* 47b - _DD_E0 */  0x22c2,
/* 47c - _DD_E0 */  0x22c3,
/* 47d - _DD_E0 */  0x22c4,
/* 47e - _DD_E0 */  0x22c5,
/* 47f - _DD_E0 */  0x22c6,
/* 480 - _DD_E8 */  0x22c7,
/* 481 - _DD_E9 */  0x22c8,
/* 482 - _DD_E8 */  0x22c9,
/* 483 - _DD_E8 */  0x22ca,
/* 484 - _DD_E8 */  0x22cb,
/* 485 - _DD_E8 */  0x22cc,
/* 486 - _DD_E8 */  0x22cd,
/* 487 - _DD_E8 */  0x22ce,
/* 488 -  */  0,
/* 489 -  */  0,
/* 48a -  */  0,
/* 48b -  */  0,
/* 48c -  */  0,
/* 48d -  */  0,
/* 48e -  */  0,
/* 48f -  */  0,
/* 490 -  */  0,
/* 491 -  */  0,
/* 492 -  */  0,
/* 493 -  */  0,
/* 494 -  */  0,
/* 495 -  */  0,
/* 496 -  */  0,
/* 497 -  */  0,
/* 498 - _DE_00 */  0x22cf,
/* 499 - _DE_01 */  0x22d0,
/* 49a - _DE_02 */  0x22d1,
/* 49b - _DE_03 */  0x22d2,
/* 49c - _DE_04 */  0x22d3,
/* 49d - _DE_05 */  0x22d4,
/* 49e - _DE_06 */  0x22d5,
/* 49f - _DE_07 */  0x22d6,
/* 4a0 - _DE_C0 */  0x22d7,
/* 4a1 - _DE_C1 */  0x22d8,
/* 4a2 - _DE_C0 */  0x22d9,
/* 4a3 - _DE_C0 */  0x22da,
/* 4a4 - _DE_C0 */  0x22db,
/* 4a5 - _DE_C0 */  0x22dc,
/* 4a6 - _DE_C0 */  0x22dd,
/* 4a7 - _DE_C0 */  0x22de,
/* 4a8 - _DE_C8 */  0x22df,
/* 4a9 - _DE_C9 */  0x22e0,
/* 4aa - _DE_C8 */  0x22e1,
/* 4ab - _DE_C8 */  0x22e2,
/* 4ac - _DE_C8 */  0x22e3,
/* 4ad - _DE_C8 */  0x22e4,
/* 4ae - _DE_C8 */  0x22e5,
/* 4af - _DE_C8 */  0x22e6,
/* 4b0 -  */  0,
/* 4b1 -  */  0,
/* 4b2 -  */  0,
/* 4b3 -  */  0,
/* 4b4 -  */  0,
/* 4b5 -  */  0,
/* 4b6 -  */  0,
/* 4b7 -  */  0,
/* 4b8 -  */  0,
/* 4b9 - _DE_D9 */  0x22e7,
/* 4ba -  */  0,
/* 4bb -  */  0,
/* 4bc -  */  0,
/* 4bd -  */  0,
/* 4be -  */  0,
/* 4bf -  */  0,
/* 4c0 - _DE_E0 */  0x22e8,
/* 4c1 - _DE_E1 */  0x22e9,
/* 4c2 - _DE_E0 */  0x22ea,
/* 4c3 - _DE_E0 */  0x22eb,
/* 4c4 - _DE_E0 */  0x22ec,
/* 4c5 - _DE_E0 */  0x22ed,
/* 4c6 - _DE_E0 */  0x22ee,
/* 4c7 - _DE_E0 */  0x22ef,
/* 4c8 - _DE_E8 */  0x22f0,
/* 4c9 - _DE_E9 */  0x22f1,
/* 4ca - _DE_E8 */  0x22f2,
/* 4cb - _DE_E8 */  0x22f3,
/* 4cc - _DE_E8 */  0x22f4,
/* 4cd - _DE_E8 */  0x22f5,
/* 4ce - _DE_E8 */  0x22f6,
/* 4cf - _DE_E8 */  0x22f7,
/* 4d0 - _DE_F0 */  0x22f8,
/* 4d1 - _DE_F1 */  0x22f9,
/* 4d2 - _DE_F0 */  0x22fa,
/* 4d3 - _DE_F0 */  0x22fb,
/* 4d4 - _DE_F0 */  0x22fc,
/* 4d5 - _DE_F0 */  0x22fd,
/* 4d6 - _DE_F0 */  0x22fe,
/* 4d7 - _DE_F0 */  0x22ff,
/* 4d8 - _DE_F8 */  0x2300,
/* 4d9 - _DE_F9 */  0x2301,
/* 4da - _DE_F8 */  0x2302,
/* 4db - _DE_F8 */  0x2303,
/* 4dc - _DE_F8 */  0x2304,
/* 4dd - _DE_F8 */  0x2305,
/* 4de - _DE_F8 */  0x2306,
/* 4df - _DE_F8 */  0x2307,
/* 4e0 - _DF_00 */  0x2308,
/* 4e1 - _DF_01 */  0x2309,
/* 4e2 - _DF_02 */  0x230a,
/* 4e3 - _DF_03 */  0x230b,
/* 4e4 - _DF_04 */  0x230c,
/* 4e5 - _DF_05 */  0x230d,
/* 4e6 - _DF_06 */  0x230e,
/* 4e7 - _DF_07 */  0x230f,
/* 4e8 -  */  0,
/* 4e9 -  */  0,
/* 4ea -  */  0,
/* 4eb -  */  0,
/* 4ec -  */  0,
/* 4ed -  */  0,
/* 4ee -  */  0,
/* 4ef -  */  0,
/* 4f0 -  */  0,
/* 4f1 -  */  0,
/* 4f2 -  */  0,
/* 4f3 -  */  0,
/* 4f4 -  */  0,
/* 4f5 -  */  0,
/* 4f6 -  */  0,
/* 4f7 -  */  0,
/* 4f8 -  */  0,
/* 4f9 -  */  0,
/* 4fa -  */  0,
/* 4fb -  */  0,
/* 4fc -  */  0,
/* 4fd -  */  0,
/* 4fe -  */  0,
/* 4ff -  */  0,
/* 500 -  */  0,
/* 501 -  */  0,
/* 502 -  */  0,
/* 503 -  */  0,
/* 504 -  */  0,
/* 505 -  */  0,
/* 506 -  */  0,
/* 507 -  */  0,
/* 508 - _DF_E0 */  0xef6c,
/* 509 -  */  0,
/* 50a -  */  0,
/* 50b -  */  0,
/* 50c -  */  0,
/* 50d -  */  0,
/* 50e -  */  0,
/* 50f -  */  0,
/* 510 - _DF_E8 */  0x2310,
/* 511 - _DF_E8 */  0x2311,
/* 512 - _DF_E8 */  0x2312,
/* 513 - _DF_E8 */  0x2313,
/* 514 - _DF_E8 */  0x2314,
/* 515 - _DF_E8 */  0x2315,
/* 516 - _DF_E8 */  0x2316,
/* 517 - _DF_E8 */  0x2317,
/* 518 - _DF_F0 */  0x2318,
/* 519 - _DF_F0 */  0x2319,
/* 51a - _DF_F0 */  0x231a,
/* 51b - _DF_F0 */  0x231b,
/* 51c - _DF_F0 */  0x231c,
/* 51d - _DF_F0 */  0x231d,
/* 51e - _DF_F0 */  0x231e,
/* 51f - _DF_F0 */  0x231f,
/* 520 -  */  0,
/* 521 -  */  0,
/* 522 -  */  0,
/* 523 -  */  0,
/* 524 -  */  0,
/* 525 -  */  0,
/* 526 -  */  0,
/* 527 -  */  0,
/* 528 - _F6_00 */  0x2320,
/* 529 -  */  0,
/* 52a - _F6_02 */  0x2321,
/* 52b - _F6_03 */  0x2322,
/* 52c - _F6_04 */  0x2323,
/* 52d - _F6_05 */  0x2324,
/* 52e - _F6_06 */  0x2325,
/* 52f - _F6_07 */  0x2326,
/* 530 - _F7_00 */  0x2327,
/* 531 -  */  0,
/* 532 - _F7_02 */  0x2328,
/* 533 - _F7_03 */  0x2329,
/* 534 - _F7_04 */  0x232a,
/* 535 - _F7_05 */  0x232b,
/* 536 - _F7_06 */  0x232c,
/* 537 - _F7_07 */  0x232d,
/* 538 - _FE_00 */  0x232e,
/* 539 - _FE_01 */  0x232f,
/* 53a -  */  0,
/* 53b -  */  0,
/* 53c -  */  0,
/* 53d -  */  0,
/* 53e -  */  0,
/* 53f -  */  0,
/* 540 - _FF_00 */  0x2330,
/* 541 - _FF_01 */  0x2331,
/* 542 - _FF_02 */  0x2332,
/* 543 - _FF_03 */  0x2333,
/* 544 - _FF_04 */  0x2334,
/* 545 - _FF_05 */  0x2335,
/* 546 - _FF_06 */  0x2336,
/* 547 -  */  0,
/* 548 - _0F_00_00 */  0x2337,
/* 549 - _0F_00_01 */  0x2338,
/* 54a - _0F_00_02 */  0x2339,
/* 54b - _0F_00_03 */  0x233a,
/* 54c - _0F_00_04 */  0x233b,
/* 54d - _0F_00_05 */  0x233c,
/* 54e -  */  0,
/* 54f -  */  0,
/* 550 - _0F_01_00 */  0x233d,
/* 551 - _0F_01_01 */  0x233e,
/* 552 - _0F_01_02 */  0x233f,
/* 553 - _0F_01_03 */  0x2340,
/* 554 - _0F_01_04 */  0x2341,
/* 555 -  */  0,
/* 556 - _0F_01_06 */  0x2342,
/* 557 - _0F_01_07 */  0x2343,
/* 558 -  */  0,
/* 559 - _0F_01_C1 */  0x2344,
/* 55a - _0F_01_C2 */  0x2345,
/* 55b - _0F_01_C3 */  0x2346,
/* 55c - _0F_01_C4 */  0x2347,
/* 55d -  */  0,
/* 55e -  */  0,
/* 55f -  */  0,
/* 560 - _0F_01_C8 */  0x2348,
/* 561 - _0F_01_C9 */  0x2349,
/* 562 - _0F_01_CA */  0x234a,
/* 563 - _0F_01_CB */  0x234b,
/* 564 -  */  0,
/* 565 -  */  0,
/* 566 -  */  0,
/* 567 -  */  0,
/* 568 - _0F_01_D0 */  0x234c,
/* 569 - _0F_01_D1 */  0x234d,
/* 56a -  */  0,
/* 56b -  */  0,
/* 56c - _0F_01_D4 */  0x234e,
/* 56d - _0F_01_D5 */  0x234f,
/* 56e -  */  0,
/* 56f -  */  0,
/* 570 - _0F_01_D8 */  0x2350,
/* 571 - _0F_01_D9 */  0x2351,
/* 572 - _0F_01_DA */  0x2352,
/* 573 - _0F_01_DB */  0x2353,
/* 574 - _0F_01_DC */  0x2354,
/* 575 - _0F_01_DD */  0x2355,
/* 576 - _0F_01_DE */  0x2356,
/* 577 - _0F_01_DF */  0x2357,
/* 578 -  */  0,
/* 579 -  */  0,
/* 57a -  */  0,
/* 57b -  */  0,
/* 57c -  */  0,
/* 57d -  */  0,
/* 57e -  */  0,
/* 57f -  */  0,
/* 580 -  */  0,
/* 581 -  */  0,
/* 582 -  */  0,
/* 583 -  */  0,
/* 584 -  */  0,
/* 585 -  */  0,
/* 586 -  */  0,
/* 587 -  */  0,
/* 588 -  */  0,
/* 589 -  */  0,
/* 58a -  */  0,
/* 58b -  */  0,
/* 58c -  */  0,
/* 58d -  */  0,
/* 58e -  */  0,
/* 58f -  */  0,
/* 590 - _0F_01_F8 */  0x2358,
/* 591 - _0F_01_F9 */  0x2359,
/* 592 -  */  0,
/* 593 -  */  0,
/* 594 -  */  0,
/* 595 -  */  0,
/* 596 -  */  0,
/* 597 -  */  0,
/* 598 - _0F_0D_00 */  0x235a,
/* 599 - _0F_0D_01 */  0x235b,
/* 59a -  */  0,
/* 59b -  */  0,
/* 59c -  */  0,
/* 59d -  */  0,
/* 59e -  */  0,
/* 59f -  */  0,
/* 5a0 -  */  0,
/* 5a1 -  */  0,
/* 5a2 -  */  0,
/* 5a3 -  */  0,
/* 5a4 -  */  0,
/* 5a5 -  */  0,
/* 5a6 -  */  0,
/* 5a7 -  */  0,
/* 5a8 -  */  0,
/* 5a9 -  */  0,
/* 5aa -  */  0,
/* 5ab -  */  0,
/* 5ac - _0F_0F_0C */  0x235c,
/* 5ad - _0F_0F_0D */  0x235d,
/* 5ae -  */  0,
/* 5af -  */  0,
/* 5b0 -  */  0,
/* 5b1 -  */  0,
/* 5b2 -  */  0,
/* 5b3 -  */  0,
/* 5b4 -  */  0,
/* 5b5 -  */  0,
/* 5b6 -  */  0,
/* 5b7 -  */  0,
/* 5b8 -  */  0,
/* 5b9 -  */  0,
/* 5ba -  */  0,
/* 5bb -  */  0,
/* 5bc - _0F_0F_1C */  0x235e,
/* 5bd - _0F_0F_1D */  0x235f,
/* 5be -  */  0,
/* 5bf -  */  0,
/* 5c0 -  */  0,
/* 5c1 -  */  0,
/* 5c2 -  */  0,
/* 5c3 -  */  0,
/* 5c4 -  */  0,
/* 5c5 -  */  0,
/* 5c6 -  */  0,
/* 5c7 -  */  0,
/* 5c8 -  */  0,
/* 5c9 -  */  0,
/* 5ca -  */  0,
/* 5cb -  */  0,
/* 5cc -  */  0,
/* 5cd -  */  0,
/* 5ce -  */  0,
/* 5cf -  */  0,
/* 5d0 -  */  0,
/* 5d1 -  */  0,
/* 5d2 -  */  0,
/* 5d3 -  */  0,
/* 5d4 -  */  0,
/* 5d5 -  */  0,
/* 5d6 -  */  0,
/* 5d7 -  */  0,
/* 5d8 -  */  0,
/* 5d9 -  */  0,
/* 5da -  */  0,
/* 5db -  */  0,
/* 5dc -  */  0,
/* 5dd -  */  0,
/* 5de -  */  0,
/* 5df -  */  0,
/* 5e0 -  */  0,
/* 5e1 -  */  0,
/* 5e2 -  */  0,
/* 5e3 -  */  0,
/* 5e4 -  */  0,
/* 5e5 -  */  0,
/* 5e6 -  */  0,
/* 5e7 -  */  0,
/* 5e8 -  */  0,
/* 5e9 -  */  0,
/* 5ea -  */  0,
/* 5eb -  */  0,
/* 5ec -  */  0,
/* 5ed -  */  0,
/* 5ee -  */  0,
/* 5ef -  */  0,
/* 5f0 -  */  0,
/* 5f1 -  */  0,
/* 5f2 -  */  0,
/* 5f3 -  */  0,
/* 5f4 -  */  0,
/* 5f5 -  */  0,
/* 5f6 -  */  0,
/* 5f7 -  */  0,
/* 5f8 -  */  0,
/* 5f9 -  */  0,
/* 5fa -  */  0,
/* 5fb -  */  0,
/* 5fc -  */  0,
/* 5fd -  */  0,
/* 5fe -  */  0,
/* 5ff -  */  0,
/* 600 -  */  0,
/* 601 -  */  0,
/* 602 -  */  0,
/* 603 -  */  0,
/* 604 -  */  0,
/* 605 -  */  0,
/* 606 -  */  0,
/* 607 -  */  0,
/* 608 -  */  0,
/* 609 -  */  0,
/* 60a -  */  0,
/* 60b -  */  0,
/* 60c -  */  0,
/* 60d -  */  0,
/* 60e -  */  0,
/* 60f -  */  0,
/* 610 -  */  0,
/* 611 -  */  0,
/* 612 -  */  0,
/* 613 -  */  0,
/* 614 -  */  0,
/* 615 -  */  0,
/* 616 -  */  0,
/* 617 -  */  0,
/* 618 -  */  0,
/* 619 -  */  0,
/* 61a -  */  0,
/* 61b -  */  0,
/* 61c -  */  0,
/* 61d -  */  0,
/* 61e -  */  0,
/* 61f -  */  0,
/* 620 -  */  0,
/* 621 -  */  0,
/* 622 -  */  0,
/* 623 -  */  0,
/* 624 -  */  0,
/* 625 -  */  0,
/* 626 -  */  0,
/* 627 -  */  0,
/* 628 -  */  0,
/* 629 -  */  0,
/* 62a - _0F_0F_8A */  0x2360,
/* 62b -  */  0,
/* 62c -  */  0,
/* 62d -  */  0,
/* 62e - _0F_0F_8E */  0x2361,
/* 62f -  */  0,
/* 630 - _0F_0F_90 */  0x2362,
/* 631 -  */  0,
/* 632 -  */  0,
/* 633 -  */  0,
/* 634 - _0F_0F_94 */  0x2363,
/* 635 -  */  0,
/* 636 - _0F_0F_96 */  0x2364,
/* 637 - _0F_0F_97 */  0x2365,
/* 638 -  */  0,
/* 639 -  */  0,
/* 63a - _0F_0F_9A */  0x2366,
/* 63b -  */  0,
/* 63c -  */  0,
/* 63d -  */  0,
/* 63e - _0F_0F_9E */  0x2367,
/* 63f -  */  0,
/* 640 - _0F_0F_A0 */  0x2368,
/* 641 -  */  0,
/* 642 -  */  0,
/* 643 -  */  0,
/* 644 - _0F_0F_A4 */  0x2369,
/* 645 -  */  0,
/* 646 - _0F_0F_A6 */  0x236a,
/* 647 - _0F_0F_A7 */  0x236b,
/* 648 -  */  0,
/* 649 -  */  0,
/* 64a - _0F_0F_AA */  0x236c,
/* 64b -  */  0,
/* 64c -  */  0,
/* 64d -  */  0,
/* 64e - _0F_0F_AE */  0x236d,
/* 64f -  */  0,
/* 650 - _0F_0F_B0 */  0x236e,
/* 651 -  */  0,
/* 652 -  */  0,
/* 653 -  */  0,
/* 654 - _0F_0F_B4 */  0x236f,
/* 655 -  */  0,
/* 656 - _0F_0F_B6 */  0x2370,
/* 657 - _0F_0F_B7 */  0x2371,
/* 658 -  */  0,
/* 659 -  */  0,
/* 65a -  */  0,
/* 65b - _0F_0F_BB */  0x2372,
/* 65c -  */  0,
/* 65d -  */  0,
/* 65e -  */  0,
/* 65f - _0F_0F_BF */  0x2373,
/* 660 -  */  0,
/* 661 -  */  0,
/* 662 -  */  0,
/* 663 -  */  0,
/* 664 -  */  0,
/* 665 -  */  0,
/* 666 -  */  0,
/* 667 -  */  0,
/* 668 -  */  0,
/* 669 -  */  0,
/* 66a -  */  0,
/* 66b -  */  0,
/* 66c -  */  0,
/* 66d -  */  0,
/* 66e -  */  0,
/* 66f -  */  0,
/* 670 -  */  0,
/* 671 -  */  0,
/* 672 -  */  0,
/* 673 -  */  0,
/* 674 -  */  0,
/* 675 -  */  0,
/* 676 -  */  0,
/* 677 -  */  0,
/* 678 -  */  0,
/* 679 -  */  0,
/* 67a -  */  0,
/* 67b -  */  0,
/* 67c -  */  0,
/* 67d -  */  0,
/* 67e -  */  0,
/* 67f -  */  0,
/* 680 -  */  0,
/* 681 -  */  0,
/* 682 -  */  0,
/* 683 -  */  0,
/* 684 -  */  0,
/* 685 -  */  0,
/* 686 -  */  0,
/* 687 -  */  0,
/* 688 -  */  0,
/* 689 -  */  0,
/* 68a -  */  0,
/* 68b -  */  0,
/* 68c -  */  0,
/* 68d -  */  0,
/* 68e -  */  0,
/* 68f -  */  0,
/* 690 -  */  0,
/* 691 -  */  0,
/* 692 -  */  0,
/* 693 -  */  0,
/* 694 -  */  0,
/* 695 -  */  0,
/* 696 -  */  0,
/* 697 -  */  0,
/* 698 -  */  0,
/* 699 -  */  0,
/* 69a -  */  0,
/* 69b -  */  0,
/* 69c -  */  0,
/* 69d -  */  0,
/* 69e -  */  0,
/* 69f -  */  0,
/* 6a0 - _0F_10 */  0x2374,
/* 6a1 - _66_0F_10 */  0x2375,
/* 6a2 - _F3_0F_10 */  0x2376,
/* 6a3 - _F2_0F_10 */  0x2377,
/* 6a4 - _V_0F_10 */  0x4009,
/* 6a5 - _V_66_0F_10 */  0x400a,
/* 6a6 - _V_F3_0F_10 */  0x400b,
/* 6a7 - _V_F2_0F_10 */  0x400c,
/* 6a8 -  */  0,
/* 6a9 -  */  0,
/* 6aa - _VRR_F3_0F_10 */  0x400d,
/* 6ab - _VRR_F2_0F_10 */  0x400e,
/* 6ac - _0F_11 */  0x2378,
/* 6ad - _66_0F_11 */  0x2379,
/* 6ae - _F3_0F_11 */  0x237a,
/* 6af - _F2_0F_11 */  0x237b,
/* 6b0 - _V_0F_11 */  0x400f,
/* 6b1 - _V_66_0F_11 */  0x4010,
/* 6b2 - _V_F3_0F_11 */  0x4011,
/* 6b3 - _V_F2_0F_11 */  0x4012,
/* 6b4 -  */  0,
/* 6b5 -  */  0,
/* 6b6 - _VRR_F3_0F_11 */  0x4013,
/* 6b7 - _VRR_F2_0F_11 */  0x4014,
/* 6b8 - _0F_12 */  0x4015,
/* 6b9 - _66_0F_12 */  0x237c,
/* 6ba - _F3_0F_12 */  0x237d,
/* 6bb - _F2_0F_12 */  0x237e,
/* 6bc - _V_0F_12 */  0x4016,
/* 6bd - _V_66_0F_12 */  0x4017,
/* 6be - _V_F3_0F_12 */  0x4018,
/* 6bf - _V_F2_0F_12 */  0x4019,
/* 6c0 -  */  0,
/* 6c1 -  */  0,
/* 6c2 -  */  0,
/* 6c3 -  */  0,
/* 6c4 - _0F_13 */  0x237f,
/* 6c5 - _66_0F_13 */  0x2380,
/* 6c6 -  */  0,
/* 6c7 -  */  0,
/* 6c8 - _V_0F_13 */  0x401a,
/* 6c9 - _V_66_0F_13 */  0x401b,
/* 6ca -  */  0,
/* 6cb -  */  0,
/* 6cc -  */  0,
/* 6cd -  */  0,
/* 6ce -  */  0,
/* 6cf -  */  0,
/* 6d0 - _0F_14 */  0x2381,
/* 6d1 - _66_0F_14 */  0x2382,
/* 6d2 -  */  0,
/* 6d3 -  */  0,
/* 6d4 - _V_0F_14 */  0x401c,
/* 6d5 - _V_66_0F_14 */  0x401d,
/* 6d6 -  */  0,
/* 6d7 -  */  0,
/* 6d8 -  */  0,
/* 6d9 -  */  0,
/* 6da -  */  0,
/* 6db -  */  0,
/* 6dc - _0F_15 */  0x2383,
/* 6dd - _66_0F_15 */  0x2384,
/* 6de -  */  0,
/* 6df -  */  0,
/* 6e0 - _V_0F_15 */  0x401e,
/* 6e1 - _V_66_0F_15 */  0x401f,
/* 6e2 -  */  0,
/* 6e3 -  */  0,
/* 6e4 -  */  0,
/* 6e5 -  */  0,
/* 6e6 -  */  0,
/* 6e7 -  */  0,
/* 6e8 - _0F_16 */  0x4020,
/* 6e9 - _66_0F_16 */  0x2385,
/* 6ea - _F3_0F_16 */  0x2386,
/* 6eb -  */  0,
/* 6ec - _V_0F_16 */  0x4021,
/* 6ed - _V_66_0F_16 */  0x4022,
/* 6ee - _V_F3_0F_16 */  0x4023,
/* 6ef -  */  0,
/* 6f0 -  */  0,
/* 6f1 -  */  0,
/* 6f2 -  */  0,
/* 6f3 -  */  0,
/* 6f4 - _0F_17 */  0x2387,
/* 6f5 - _66_0F_17 */  0x2388,
/* 6f6 -  */  0,
/* 6f7 -  */  0,
/* 6f8 - _V_0F_17 */  0x4024,
/* 6f9 - _V_66_0F_17 */  0x4025,
/* 6fa -  */  0,
/* 6fb -  */  0,
/* 6fc -  */  0,
/* 6fd -  */  0,
/* 6fe -  */  0,
/* 6ff -  */  0,
/* 700 - _0F_18_00 */  0x2389,
/* 701 - _0F_18_01 */  0x238a,
/* 702 - _0F_18_02 */  0x238b,
/* 703 - _0F_18_03 */  0x238c,
/* 704 -  */  0,
/* 705 -  */  0,
/* 706 -  */  0,
/* 707 -  */  0,
/* 708 - _0F_28 */  0x238d,
/* 709 - _66_0F_28 */  0x238e,
/* 70a -  */  0,
/* 70b -  */  0,
/* 70c - _V_0F_28 */  0x4026,
/* 70d - _V_66_0F_28 */  0x4027,
/* 70e -  */  0,
/* 70f -  */  0,
/* 710 -  */  0,
/* 711 -  */  0,
/* 712 -  */  0,
/* 713 -  */  0,
/* 714 - _0F_29 */  0x238f,
/* 715 - _66_0F_29 */  0x2390,
/* 716 -  */  0,
/* 717 -  */  0,
/* 718 - _V_0F_29 */  0x4028,
/* 719 - _V_66_0F_29 */  0x4029,
/* 71a -  */  0,
/* 71b -  */  0,
/* 71c -  */  0,
/* 71d -  */  0,
/* 71e -  */  0,
/* 71f -  */  0,
/* 720 - _0F_2A */  0x2391,
/* 721 - _66_0F_2A */  0x2392,
/* 722 - _F3_0F_2A */  0x2393,
/* 723 - _F2_0F_2A */  0x2394,
/* 724 -  */  0,
/* 725 -  */  0,
/* 726 - _V_F3_0F_2A */  0x402a,
/* 727 - _V_F2_0F_2A */  0x402b,
/* 728 -  */  0,
/* 729 -  */  0,
/* 72a -  */  0,
/* 72b -  */  0,
/* 72c - _0F_2B */  0x2395,
/* 72d - _66_0F_2B */  0x2396,
/* 72e - _F3_0F_2B */  0x2397,
/* 72f - _F2_0F_2B */  0x2398,
/* 730 - _V_0F_2B */  0x402c,
/* 731 - _V_66_0F_2B */  0x402d,
/* 732 -  */  0,
/* 733 -  */  0,
/* 734 -  */  0,
/* 735 -  */  0,
/* 736 -  */  0,
/* 737 -  */  0,
/* 738 - _0F_2C */  0x2399,
/* 739 - _66_0F_2C */  0x239a,
/* 73a - _F3_0F_2C */  0x239b,
/* 73b - _F2_0F_2C */  0x239c,
/* 73c -  */  0,
/* 73d -  */  0,
/* 73e - _V_F3_0F_2C */  0x402e,
/* 73f - _V_F2_0F_2C */  0x402f,
/* 740 -  */  0,
/* 741 -  */  0,
/* 742 -  */  0,
/* 743 -  */  0,
/* 744 - _0F_2D */  0x239d,
/* 745 - _66_0F_2D */  0x239e,
/* 746 - _F3_0F_2D */  0x239f,
/* 747 - _F2_0F_2D */  0x23a0,
/* 748 -  */  0,
/* 749 -  */  0,
/* 74a - _V_F3_0F_2D */  0x4030,
/* 74b - _V_F2_0F_2D */  0x4031,
/* 74c -  */  0,
/* 74d -  */  0,
/* 74e -  */  0,
/* 74f -  */  0,
/* 750 - _0F_2E */  0x23a1,
/* 751 - _66_0F_2E */  0x23a2,
/* 752 -  */  0,
/* 753 -  */  0,
/* 754 - _V_0F_2E */  0x4032,
/* 755 - _V_66_0F_2E */  0x4033,
/* 756 -  */  0,
/* 757 -  */  0,
/* 758 -  */  0,
/* 759 -  */  0,
/* 75a -  */  0,
/* 75b -  */  0,
/* 75c - _0F_2F */  0x23a3,
/* 75d - _66_0F_2F */  0x23a4,
/* 75e -  */  0,
/* 75f -  */  0,
/* 760 - _V_0F_2F */  0x4034,
/* 761 - _V_66_0F_2F */  0x4035,
/* 762 -  */  0,
/* 763 -  */  0,
/* 764 -  */  0,
/* 765 -  */  0,
/* 766 -  */  0,
/* 767 -  */  0,
/* 768 - _0F_38_00 */  0xef78,
/* 769 - _0F_38_01 */  0xef84,
/* 76a - _0F_38_02 */  0xef90,
/* 76b - _0F_38_03 */  0xef9c,
/* 76c - _0F_38_04 */  0xefa8,
/* 76d - _0F_38_05 */  0xefb4,
/* 76e - _0F_38_06 */  0xefc0,
/* 76f - _0F_38_07 */  0xefcc,
/* 770 - _0F_38_08 */  0xefd8,
/* 771 - _0F_38_09 */  0xefe4,
/* 772 - _0F_38_0A */  0xeff0,
/* 773 - _0F_38_0B */  0xeffc,
/* 774 - _0F_38_0C */  0xf008,
/* 775 - _0F_38_0D */  0xf014,
/* 776 - _0F_38_0E */  0xf020,
/* 777 - _0F_38_0F */  0xf02c,
/* 778 - _0F_38_10 */  0xf038,
/* 779 -  */  0,
/* 77a -  */  0,
/* 77b -  */  0,
/* 77c - _0F_38_14 */  0xf044,
/* 77d - _0F_38_15 */  0xf050,
/* 77e -  */  0,
/* 77f - _0F_38_17 */  0xf05c,
/* 780 - _0F_38_18 */  0xf068,
/* 781 - _0F_38_19 */  0xf074,
/* 782 - _0F_38_1A */  0xf080,
/* 783 -  */  0,
/* 784 - _0F_38_1C */  0xf08c,
/* 785 - _0F_38_1D */  0xf098,
/* 786 - _0F_38_1E */  0xf0a4,
/* 787 -  */  0,
/* 788 - _0F_38_20 */  0xf0b0,
/* 789 - _0F_38_21 */  0xf0bc,
/* 78a - _0F_38_22 */  0xf0c8,
/* 78b - _0F_38_23 */  0xf0d4,
/* 78c - _0F_38_24 */  0xf0e0,
/* 78d - _0F_38_25 */  0xf0ec,
/* 78e -  */  0,
/* 78f -  */  0,
/* 790 - _0F_38_28 */  0xf0f8,
/* 791 - _0F_38_29 */  0xf104,
/* 792 - _0F_38_2A */  0xf110,
/* 793 - _0F_38_2B */  0xf11c,
/* 794 - _0F_38_2C */  0xf128,
/* 795 - _0F_38_2D */  0xf134,
/* 796 - _0F_38_2E */  0xf140,
/* 797 - _0F_38_2F */  0xf14c,
/* 798 - _0F_38_30 */  0xf158,
/* 799 - _0F_38_31 */  0xf164,
/* 79a - _0F_38_32 */  0xf170,
/* 79b - _0F_38_33 */  0xf17c,
/* 79c - _0F_38_34 */  0xf188,
/* 79d - _0F_38_35 */  0xf194,
/* 79e -  */  0,
/* 79f - _0F_38_37 */  0xf1a0,
/* 7a0 - _0F_38_38 */  0xf1ac,
/* 7a1 - _0F_38_39 */  0xf1b8,
/* 7a2 - _0F_38_3A */  0xf1c4,
/* 7a3 - _0F_38_3B */  0xf1d0,
/* 7a4 - _0F_38_3C */  0xf1dc,
/* 7a5 - _0F_38_3D */  0xf1e8,
/* 7a6 - _0F_38_3E */  0xf1f4,
/* 7a7 - _0F_38_3F */  0xf200,
/* 7a8 - _0F_38_40 */  0xf20c,
/* 7a9 - _0F_38_41 */  0xf218,
/* 7aa -  */  0,
/* 7ab -  */  0,
/* 7ac -  */  0,
/* 7ad -  */  0,
/* 7ae -  */  0,
/* 7af -  */  0,
/* 7b0 -  */  0,
/* 7b1 -  */  0,
/* 7b2 -  */  0,
/* 7b3 -  */  0,
/* 7b4 -  */  0,
/* 7b5 -  */  0,
/* 7b6 -  */  0,
/* 7b7 -  */  0,
/* 7b8 -  */  0,
/* 7b9 -  */  0,
/* 7ba -  */  0,
/* 7bb -  */  0,
/* 7bc -  */  0,
/* 7bd -  */  0,
/* 7be -  */  0,
/* 7bf -  */  0,
/* 7c0 -  */  0,
/* 7c1 -  */  0,
/* 7c2 -  */  0,
/* 7c3 -  */  0,
/* 7c4 -  */  0,
/* 7c5 -  */  0,
/* 7c6 -  */  0,
/* 7c7 -  */  0,
/* 7c8 -  */  0,
/* 7c9 -  */  0,
/* 7ca -  */  0,
/* 7cb -  */  0,
/* 7cc -  */  0,
/* 7cd -  */  0,
/* 7ce -  */  0,
/* 7cf -  */  0,
/* 7d0 -  */  0,
/* 7d1 -  */  0,
/* 7d2 -  */  0,
/* 7d3 -  */  0,
/* 7d4 -  */  0,
/* 7d5 -  */  0,
/* 7d6 -  */  0,
/* 7d7 -  */  0,
/* 7d8 -  */  0,
/* 7d9 -  */  0,
/* 7da -  */  0,
/* 7db -  */  0,
/* 7dc -  */  0,
/* 7dd -  */  0,
/* 7de -  */  0,
/* 7df -  */  0,
/* 7e0 -  */  0,
/* 7e1 -  */  0,
/* 7e2 -  */  0,
/* 7e3 -  */  0,
/* 7e4 -  */  0,
/* 7e5 -  */  0,
/* 7e6 -  */  0,
/* 7e7 -  */  0,
/* 7e8 - _0F_38_80 */  0xf224,
/* 7e9 - _0F_38_81 */  0xf230,
/* 7ea - _0F_38_82 */  0xf23c,
/* 7eb -  */  0,
/* 7ec -  */  0,
/* 7ed -  */  0,
/* 7ee -  */  0,
/* 7ef -  */  0,
/* 7f0 -  */  0,
/* 7f1 -  */  0,
/* 7f2 -  */  0,
/* 7f3 -  */  0,
/* 7f4 -  */  0,
/* 7f5 -  */  0,
/* 7f6 -  */  0,
/* 7f7 -  */  0,
/* 7f8 -  */  0,
/* 7f9 -  */  0,
/* 7fa -  */  0,
/* 7fb -  */  0,
/* 7fc -  */  0,
/* 7fd -  */  0,
/* 7fe - _0F_38_96 */  0xf248,
/* 7ff - _0F_38_97 */  0xf254,
/* 800 - _0F_38_98 */  0xf260,
/* 801 - _0F_38_99 */  0xf26c,
/* 802 - _0F_38_9A */  0xf278,
/* 803 - _0F_38_9B */  0xf284,
/* 804 - _0F_38_9C */  0xf290,
/* 805 - _0F_38_9D */  0xf29c,
/* 806 - _0F_38_9E */  0xf2a8,
/* 807 - _0F_38_9F */  0xf2b4,
/* 808 -  */  0,
/* 809 -  */  0,
/* 80a -  */  0,
/* 80b -  */  0,
/* 80c -  */  0,
/* 80d -  */  0,
/* 80e - _0F_38_A6 */  0xf2c0,
/* 80f - _0F_38_A7 */  0xf2cc,
/* 810 - _0F_38_A8 */  0xf2d8,
/* 811 - _0F_38_A9 */  0xf2e4,
/* 812 - _0F_38_AA */  0xf2f0,
/* 813 - _0F_38_AB */  0xf2fc,
/* 814 - _0F_38_AC */  0xf308,
/* 815 - _0F_38_AD */  0xf314,
/* 816 - _0F_38_AE */  0xf320,
/* 817 - _0F_38_AF */  0xf32c,
/* 818 -  */  0,
/* 819 -  */  0,
/* 81a -  */  0,
/* 81b -  */  0,
/* 81c -  */  0,
/* 81d -  */  0,
/* 81e - _0F_38_B6 */  0xf338,
/* 81f - _0F_38_B7 */  0xf344,
/* 820 - _0F_38_B8 */  0xf350,
/* 821 - _0F_38_B9 */  0xf35c,
/* 822 - _0F_38_BA */  0xf368,
/* 823 - _0F_38_BB */  0xf374,
/* 824 - _0F_38_BC */  0xf380,
/* 825 - _0F_38_BD */  0xf38c,
/* 826 - _0F_38_BE */  0xf398,
/* 827 - _0F_38_BF */  0xf3a4,
/* 828 -  */  0,
/* 829 -  */  0,
/* 82a -  */  0,
/* 82b -  */  0,
/* 82c -  */  0,
/* 82d -  */  0,
/* 82e -  */  0,
/* 82f -  */  0,
/* 830 -  */  0,
/* 831 -  */  0,
/* 832 -  */  0,
/* 833 -  */  0,
/* 834 -  */  0,
/* 835 -  */  0,
/* 836 -  */  0,
/* 837 -  */  0,
/* 838 -  */  0,
/* 839 -  */  0,
/* 83a -  */  0,
/* 83b -  */  0,
/* 83c -  */  0,
/* 83d -  */  0,
/* 83e -  */  0,
/* 83f -  */  0,
/* 840 -  */  0,
/* 841 -  */  0,
/* 842 -  */  0,
/* 843 - _0F_38_DB */  0xf3b0,
/* 844 - _0F_38_DC */  0xf3bc,
/* 845 - _0F_38_DD */  0xf3c8,
/* 846 - _0F_38_DE */  0xf3d4,
/* 847 - _0F_38_DF */  0xf3e0,
/* 848 -  */  0,
/* 849 -  */  0,
/* 84a -  */  0,
/* 84b -  */  0,
/* 84c -  */  0,
/* 84d -  */  0,
/* 84e -  */  0,
/* 84f -  */  0,
/* 850 -  */  0,
/* 851 -  */  0,
/* 852 -  */  0,
/* 853 -  */  0,
/* 854 -  */  0,
/* 855 -  */  0,
/* 856 -  */  0,
/* 857 -  */  0,
/* 858 - _0F_38_F0 */  0xf3ec,
/* 859 - _0F_38_F1 */  0xf3f8,
/* 85a -  */  0,
/* 85b -  */  0,
/* 85c -  */  0,
/* 85d -  */  0,
/* 85e -  */  0,
/* 85f -  */  0,
/* 860 -  */  0,
/* 861 -  */  0,
/* 862 -  */  0,
/* 863 -  */  0,
/* 864 -  */  0,
/* 865 -  */  0,
/* 866 -  */  0,
/* 867 -  */  0,
/* 868 -  */  0,
/* 869 -  */  0,
/* 86a -  */  0,
/* 86b -  */  0,
/* 86c - _0F_3A_04 */  0xf404,
/* 86d - _0F_3A_05 */  0xf410,
/* 86e - _0F_3A_06 */  0xf41c,
/* 86f -  */  0,
/* 870 - _0F_3A_08 */  0xf428,
/* 871 - _0F_3A_09 */  0xf434,
/* 872 - _0F_3A_0A */  0xf440,
/* 873 - _0F_3A_0B */  0xf44c,
/* 874 - _0F_3A_0C */  0xf458,
/* 875 - _0F_3A_0D */  0xf464,
/* 876 - _0F_3A_0E */  0xf470,
/* 877 - _0F_3A_0F */  0xf47c,
/* 878 -  */  0,
/* 879 -  */  0,
/* 87a -  */  0,
/* 87b -  */  0,
/* 87c - _0F_3A_14 */  0xf488,
/* 87d - _0F_3A_15 */  0xf494,
/* 87e - _0F_3A_16 */  0xf4a0,
/* 87f - _0F_3A_17 */  0xf4ac,
/* 880 - _0F_3A_18 */  0xf4b8,
/* 881 - _0F_3A_19 */  0xf4c4,
/* 882 -  */  0,
/* 883 -  */  0,
/* 884 -  */  0,
/* 885 -  */  0,
/* 886 -  */  0,
/* 887 -  */  0,
/* 888 - _0F_3A_20 */  0xf4d0,
/* 889 - _0F_3A_21 */  0xf4dc,
/* 88a - _0F_3A_22 */  0xf4e8,
/* 88b -  */  0,
/* 88c -  */  0,
/* 88d -  */  0,
/* 88e -  */  0,
/* 88f -  */  0,
/* 890 -  */  0,
/* 891 -  */  0,
/* 892 -  */  0,
/* 893 -  */  0,
/* 894 -  */  0,
/* 895 -  */  0,
/* 896 -  */  0,
/* 897 -  */  0,
/* 898 -  */  0,
/* 899 -  */  0,
/* 89a -  */  0,
/* 89b -  */  0,
/* 89c -  */  0,
/* 89d -  */  0,
/* 89e -  */  0,
/* 89f -  */  0,
/* 8a0 -  */  0,
/* 8a1 -  */  0,
/* 8a2 -  */  0,
/* 8a3 -  */  0,
/* 8a4 -  */  0,
/* 8a5 -  */  0,
/* 8a6 -  */  0,
/* 8a7 -  */  0,
/* 8a8 - _0F_3A_40 */  0xf4f4,
/* 8a9 - _0F_3A_41 */  0xf500,
/* 8aa - _0F_3A_42 */  0xf50c,
/* 8ab -  */  0,
/* 8ac - _0F_3A_44 */  0xf518,
/* 8ad -  */  0,
/* 8ae -  */  0,
/* 8af -  */  0,
/* 8b0 -  */  0,
/* 8b1 -  */  0,
/* 8b2 - _0F_3A_4A */  0xf524,
/* 8b3 - _0F_3A_4B */  0xf530,
/* 8b4 - _0F_3A_4C */  0xf53c,
/* 8b5 -  */  0,
/* 8b6 -  */  0,
/* 8b7 -  */  0,
/* 8b8 -  */  0,
/* 8b9 -  */  0,
/* 8ba -  */  0,
/* 8bb -  */  0,
/* 8bc -  */  0,
/* 8bd -  */  0,
/* 8be -  */  0,
/* 8bf -  */  0,
/* 8c0 -  */  0,
/* 8c1 -  */  0,
/* 8c2 -  */  0,
/* 8c3 -  */  0,
/* 8c4 -  */  0,
/* 8c5 -  */  0,
/* 8c6 -  */  0,
/* 8c7 -  */  0,
/* 8c8 - _0F_3A_60 */  0xf548,
/* 8c9 - _0F_3A_61 */  0xf554,
/* 8ca - _0F_3A_62 */  0xf560,
/* 8cb - _0F_3A_63 */  0xf56c,
/* 8cc -  */  0,
/* 8cd -  */  0,
/* 8ce -  */  0,
/* 8cf -  */  0,
/* 8d0 -  */  0,
/* 8d1 -  */  0,
/* 8d2 -  */  0,
/* 8d3 -  */  0,
/* 8d4 -  */  0,
/* 8d5 -  */  0,
/* 8d6 -  */  0,
/* 8d7 -  */  0,
/* 8d8 -  */  0,
/* 8d9 -  */  0,
/* 8da -  */  0,
/* 8db -  */  0,
/* 8dc -  */  0,
/* 8dd -  */  0,
/* 8de -  */  0,
/* 8df -  */  0,
/* 8e0 -  */  0,
/* 8e1 -  */  0,
/* 8e2 -  */  0,
/* 8e3 -  */  0,
/* 8e4 -  */  0,
/* 8e5 -  */  0,
/* 8e6 -  */  0,
/* 8e7 -  */  0,
/* 8e8 -  */  0,
/* 8e9 -  */  0,
/* 8ea -  */  0,
/* 8eb -  */  0,
/* 8ec -  */  0,
/* 8ed -  */  0,
/* 8ee -  */  0,
/* 8ef -  */  0,
/* 8f0 -  */  0,
/* 8f1 -  */  0,
/* 8f2 -  */  0,
/* 8f3 -  */  0,
/* 8f4 -  */  0,
/* 8f5 -  */  0,
/* 8f6 -  */  0,
/* 8f7 -  */  0,
/* 8f8 -  */  0,
/* 8f9 -  */  0,
/* 8fa -  */  0,
/* 8fb -  */  0,
/* 8fc -  */  0,
/* 8fd -  */  0,
/* 8fe -  */  0,
/* 8ff -  */  0,
/* 900 -  */  0,
/* 901 -  */  0,
/* 902 -  */  0,
/* 903 -  */  0,
/* 904 -  */  0,
/* 905 -  */  0,
/* 906 -  */  0,
/* 907 -  */  0,
/* 908 -  */  0,
/* 909 -  */  0,
/* 90a -  */  0,
/* 90b -  */  0,
/* 90c -  */  0,
/* 90d -  */  0,
/* 90e -  */  0,
/* 90f -  */  0,
/* 910 -  */  0,
/* 911 -  */  0,
/* 912 -  */  0,
/* 913 -  */  0,
/* 914 -  */  0,
/* 915 -  */  0,
/* 916 -  */  0,
/* 917 -  */  0,
/* 918 -  */  0,
/* 919 -  */  0,
/* 91a -  */  0,
/* 91b -  */  0,
/* 91c -  */  0,
/* 91d -  */  0,
/* 91e -  */  0,
/* 91f -  */  0,
/* 920 -  */  0,
/* 921 -  */  0,
/* 922 -  */  0,
/* 923 -  */  0,
/* 924 -  */  0,
/* 925 -  */  0,
/* 926 -  */  0,
/* 927 -  */  0,
/* 928 -  */  0,
/* 929 -  */  0,
/* 92a -  */  0,
/* 92b -  */  0,
/* 92c -  */  0,
/* 92d -  */  0,
/* 92e -  */  0,
/* 92f -  */  0,
/* 930 -  */  0,
/* 931 -  */  0,
/* 932 -  */  0,
/* 933 -  */  0,
/* 934 -  */  0,
/* 935 -  */  0,
/* 936 -  */  0,
/* 937 -  */  0,
/* 938 -  */  0,
/* 939 -  */  0,
/* 93a -  */  0,
/* 93b -  */  0,
/* 93c -  */  0,
/* 93d -  */  0,
/* 93e -  */  0,
/* 93f -  */  0,
/* 940 -  */  0,
/* 941 -  */  0,
/* 942 -  */  0,
/* 943 -  */  0,
/* 944 -  */  0,
/* 945 -  */  0,
/* 946 -  */  0,
/* 947 - _0F_3A_DF */  0xf578,
/* 948 -  */  0,
/* 949 -  */  0,
/* 94a -  */  0,
/* 94b -  */  0,
/* 94c -  */  0,
/* 94d -  */  0,
/* 94e -  */  0,
/* 94f -  */  0,
/* 950 -  */  0,
/* 951 -  */  0,
/* 952 -  */  0,
/* 953 -  */  0,
/* 954 -  */  0,
/* 955 -  */  0,
/* 956 -  */  0,
/* 957 -  */  0,
/* 958 -  */  0,
/* 959 -  */  0,
/* 95a -  */  0,
/* 95b -  */  0,
/* 95c -  */  0,
/* 95d -  */  0,
/* 95e -  */  0,
/* 95f -  */  0,
/* 960 -  */  0,
/* 961 -  */  0,
/* 962 -  */  0,
/* 963 -  */  0,
/* 964 -  */  0,
/* 965 -  */  0,
/* 966 -  */  0,
/* 967 -  */  0,
/* 968 - _0F_50 */  0x23a5,
/* 969 - _66_0F_50 */  0x23a6,
/* 96a -  */  0,
/* 96b -  */  0,
/* 96c - _V_0F_50 */  0x4036,
/* 96d - _V_66_0F_50 */  0x4037,
/* 96e -  */  0,
/* 96f -  */  0,
/* 970 -  */  0,
/* 971 -  */  0,
/* 972 -  */  0,
/* 973 -  */  0,
/* 974 - _0F_51 */  0x23a7,
/* 975 - _66_0F_51 */  0x23a8,
/* 976 - _F3_0F_51 */  0x23a9,
/* 977 - _F2_0F_51 */  0x23aa,
/* 978 - _V_0F_51 */  0x4038,
/* 979 - _V_66_0F_51 */  0x4039,
/* 97a - _V_F3_0F_51 */  0x403a,
/* 97b - _V_F2_0F_51 */  0x403b,
/* 97c -  */  0,
/* 97d -  */  0,
/* 97e -  */  0,
/* 97f -  */  0,
/* 980 - _0F_52 */  0x23ab,
/* 981 -  */  0,
/* 982 - _F3_0F_52 */  0x23ac,
/* 983 -  */  0,
/* 984 - _V_0F_52 */  0x403c,
/* 985 -  */  0,
/* 986 - _V_F3_0F_52 */  0x403d,
/* 987 -  */  0,
/* 988 -  */  0,
/* 989 -  */  0,
/* 98a -  */  0,
/* 98b -  */  0,
/* 98c - _0F_53 */  0x23ad,
/* 98d -  */  0,
/* 98e - _F3_0F_53 */  0x23ae,
/* 98f -  */  0,
/* 990 - _V_0F_53 */  0x403e,
/* 991 -  */  0,
/* 992 - _V_F3_0F_53 */  0x403f,
/* 993 -  */  0,
/* 994 -  */  0,
/* 995 -  */  0,
/* 996 -  */  0,
/* 997 -  */  0,
/* 998 - _0F_54 */  0x23af,
/* 999 - _66_0F_54 */  0x23b0,
/* 99a -  */  0,
/* 99b -  */  0,
/* 99c - _V_0F_54 */  0x4040,
/* 99d - _V_66_0F_54 */  0x4041,
/* 99e -  */  0,
/* 99f -  */  0,
/* 9a0 -  */  0,
/* 9a1 -  */  0,
/* 9a2 -  */  0,
/* 9a3 -  */  0,
/* 9a4 - _0F_55 */  0x23b1,
/* 9a5 - _66_0F_55 */  0x23b2,
/* 9a6 -  */  0,
/* 9a7 -  */  0,
/* 9a8 - _V_0F_55 */  0x4042,
/* 9a9 - _V_66_0F_55 */  0x4043,
/* 9aa -  */  0,
/* 9ab -  */  0,
/* 9ac -  */  0,
/* 9ad -  */  0,
/* 9ae -  */  0,
/* 9af -  */  0,
/* 9b0 - _0F_56 */  0x23b3,
/* 9b1 - _66_0F_56 */  0x23b4,
/* 9b2 -  */  0,
/* 9b3 -  */  0,
/* 9b4 - _V_0F_56 */  0x4044,
/* 9b5 - _V_66_0F_56 */  0x4045,
/* 9b6 -  */  0,
/* 9b7 -  */  0,
/* 9b8 -  */  0,
/* 9b9 -  */  0,
/* 9ba -  */  0,
/* 9bb -  */  0,
/* 9bc - _0F_57 */  0x23b5,
/* 9bd - _66_0F_57 */  0x23b6,
/* 9be -  */  0,
/* 9bf -  */  0,
/* 9c0 - _V_0F_57 */  0x4046,
/* 9c1 - _V_66_0F_57 */  0x4047,
/* 9c2 -  */  0,
/* 9c3 -  */  0,
/* 9c4 -  */  0,
/* 9c5 -  */  0,
/* 9c6 -  */  0,
/* 9c7 -  */  0,
/* 9c8 - _0F_58 */  0x23b7,
/* 9c9 - _66_0F_58 */  0x23b8,
/* 9ca - _F3_0F_58 */  0x23b9,
/* 9cb - _F2_0F_58 */  0x23ba,
/* 9cc - _V_0F_58 */  0x4048,
/* 9cd - _V_66_0F_58 */  0x4049,
/* 9ce - _V_F3_0F_58 */  0x404a,
/* 9cf - _V_F2_0F_58 */  0x404b,
/* 9d0 -  */  0,
/* 9d1 -  */  0,
/* 9d2 -  */  0,
/* 9d3 -  */  0,
/* 9d4 - _0F_59 */  0x23bb,
/* 9d5 - _66_0F_59 */  0x23bc,
/* 9d6 - _F3_0F_59 */  0x23bd,
/* 9d7 - _F2_0F_59 */  0x23be,
/* 9d8 - _V_0F_59 */  0x404c,
/* 9d9 - _V_66_0F_59 */  0x404d,
/* 9da - _V_F3_0F_59 */  0x404e,
/* 9db - _V_F2_0F_59 */  0x404f,
/* 9dc -  */  0,
/* 9dd -  */  0,
/* 9de -  */  0,
/* 9df -  */  0,
/* 9e0 - _0F_5A */  0x23bf,
/* 9e1 - _66_0F_5A */  0x23c0,
/* 9e2 - _F3_0F_5A */  0x23c1,
/* 9e3 - _F2_0F_5A */  0x23c2,
/* 9e4 - _V_0F_5A */  0x4050,
/* 9e5 - _V_66_0F_5A */  0x4051,
/* 9e6 - _V_F3_0F_5A */  0x4052,
/* 9e7 - _V_F2_0F_5A */  0x4053,
/* 9e8 -  */  0,
/* 9e9 -  */  0,
/* 9ea -  */  0,
/* 9eb -  */  0,
/* 9ec - _0F_5B */  0x23c3,
/* 9ed - _66_0F_5B */  0x23c4,
/* 9ee - _F3_0F_5B */  0x23c5,
/* 9ef -  */  0,
/* 9f0 - _V_0F_5B */  0x4054,
/* 9f1 - _V_66_0F_5B */  0x4055,
/* 9f2 - _V_F3_0F_5B */  0x4056,
/* 9f3 -  */  0,
/* 9f4 -  */  0,
/* 9f5 -  */  0,
/* 9f6 -  */  0,
/* 9f7 -  */  0,
/* 9f8 - _0F_5C */  0x23c6,
/* 9f9 - _66_0F_5C */  0x23c7,
/* 9fa - _F3_0F_5C */  0x23c8,
/* 9fb - _F2_0F_5C */  0x23c9,
/* 9fc - _V_0F_5C */  0x4057,
/* 9fd - _V_66_0F_5C */  0x4058,
/* 9fe - _V_F3_0F_5C */  0x4059,
/* 9ff - _V_F2_0F_5C */  0x405a,
/* a00 -  */  0,
/* a01 -  */  0,
/* a02 -  */  0,
/* a03 -  */  0,
/* a04 - _0F_5D */  0x23ca,
/* a05 - _66_0F_5D */  0x23cb,
/* a06 - _F3_0F_5D */  0x23cc,
/* a07 - _F2_0F_5D */  0x23cd,
/* a08 - _V_0F_5D */  0x405b,
/* a09 - _V_66_0F_5D */  0x405c,
/* a0a - _V_F3_0F_5D */  0x405d,
/* a0b - _V_F2_0F_5D */  0x405e,
/* a0c -  */  0,
/* a0d -  */  0,
/* a0e -  */  0,
/* a0f -  */  0,
/* a10 - _0F_5E */  0x23ce,
/* a11 - _66_0F_5E */  0x23cf,
/* a12 - _F3_0F_5E */  0x23d0,
/* a13 - _F2_0F_5E */  0x23d1,
/* a14 - _V_0F_5E */  0x405f,
/* a15 - _V_66_0F_5E */  0x4060,
/* a16 - _V_F3_0F_5E */  0x4061,
/* a17 - _V_F2_0F_5E */  0x4062,
/* a18 -  */  0,
/* a19 -  */  0,
/* a1a -  */  0,
/* a1b -  */  0,
/* a1c - _0F_5F */  0x23d2,
/* a1d - _66_0F_5F */  0x23d3,
/* a1e - _F3_0F_5F */  0x23d4,
/* a1f - _F2_0F_5F */  0x23d5,
/* a20 - _V_0F_5F */  0x4063,
/* a21 - _V_66_0F_5F */  0x4064,
/* a22 - _V_F3_0F_5F */  0x4065,
/* a23 - _V_F2_0F_5F */  0x4066,
/* a24 -  */  0,
/* a25 -  */  0,
/* a26 -  */  0,
/* a27 -  */  0,
/* a28 - _0F_60 */  0x23d6,
/* a29 - _66_0F_60 */  0x23d7,
/* a2a -  */  0,
/* a2b -  */  0,
/* a2c -  */  0,
/* a2d - _V_66_0F_60 */  0x4067,
/* a2e -  */  0,
/* a2f -  */  0,
/* a30 -  */  0,
/* a31 -  */  0,
/* a32 -  */  0,
/* a33 -  */  0,
/* a34 - _0F_61 */  0x23d8,
/* a35 - _66_0F_61 */  0x23d9,
/* a36 -  */  0,
/* a37 -  */  0,
/* a38 -  */  0,
/* a39 - _V_66_0F_61 */  0x4068,
/* a3a -  */  0,
/* a3b -  */  0,
/* a3c -  */  0,
/* a3d -  */  0,
/* a3e -  */  0,
/* a3f -  */  0,
/* a40 - _0F_62 */  0x23da,
/* a41 - _66_0F_62 */  0x23db,
/* a42 -  */  0,
/* a43 -  */  0,
/* a44 -  */  0,
/* a45 - _V_66_0F_62 */  0x4069,
/* a46 -  */  0,
/* a47 -  */  0,
/* a48 -  */  0,
/* a49 -  */  0,
/* a4a -  */  0,
/* a4b -  */  0,
/* a4c - _0F_63 */  0x23dc,
/* a4d - _66_0F_63 */  0x23dd,
/* a4e -  */  0,
/* a4f -  */  0,
/* a50 -  */  0,
/* a51 - _V_66_0F_63 */  0x406a,
/* a52 -  */  0,
/* a53 -  */  0,
/* a54 -  */  0,
/* a55 -  */  0,
/* a56 -  */  0,
/* a57 -  */  0,
/* a58 - _0F_64 */  0x23de,
/* a59 - _66_0F_64 */  0x23df,
/* a5a -  */  0,
/* a5b -  */  0,
/* a5c -  */  0,
/* a5d - _V_66_0F_64 */  0x406b,
/* a5e -  */  0,
/* a5f -  */  0,
/* a60 -  */  0,
/* a61 -  */  0,
/* a62 -  */  0,
/* a63 -  */  0,
/* a64 - _0F_65 */  0x23e0,
/* a65 - _66_0F_65 */  0x23e1,
/* a66 -  */  0,
/* a67 -  */  0,
/* a68 -  */  0,
/* a69 - _V_66_0F_65 */  0x406c,
/* a6a -  */  0,
/* a6b -  */  0,
/* a6c -  */  0,
/* a6d -  */  0,
/* a6e -  */  0,
/* a6f -  */  0,
/* a70 - _0F_66 */  0x23e2,
/* a71 - _66_0F_66 */  0x23e3,
/* a72 -  */  0,
/* a73 -  */  0,
/* a74 -  */  0,
/* a75 - _V_66_0F_66 */  0x406d,
/* a76 -  */  0,
/* a77 -  */  0,
/* a78 -  */  0,
/* a79 -  */  0,
/* a7a -  */  0,
/* a7b -  */  0,
/* a7c - _0F_67 */  0x23e4,
/* a7d - _66_0F_67 */  0x23e5,
/* a7e -  */  0,
/* a7f -  */  0,
/* a80 -  */  0,
/* a81 - _V_66_0F_67 */  0x406e,
/* a82 -  */  0,
/* a83 -  */  0,
/* a84 -  */  0,
/* a85 -  */  0,
/* a86 -  */  0,
/* a87 -  */  0,
/* a88 - _0F_68 */  0x23e6,
/* a89 - _66_0F_68 */  0x23e7,
/* a8a -  */  0,
/* a8b -  */  0,
/* a8c -  */  0,
/* a8d - _V_66_0F_68 */  0x406f,
/* a8e -  */  0,
/* a8f -  */  0,
/* a90 -  */  0,
/* a91 -  */  0,
/* a92 -  */  0,
/* a93 -  */  0,
/* a94 - _0F_69 */  0x23e8,
/* a95 - _66_0F_69 */  0x23e9,
/* a96 -  */  0,
/* a97 -  */  0,
/* a98 -  */  0,
/* a99 - _V_66_0F_69 */  0x4070,
/* a9a -  */  0,
/* a9b -  */  0,
/* a9c -  */  0,
/* a9d -  */  0,
/* a9e -  */  0,
/* a9f -  */  0,
/* aa0 - _0F_6A */  0x23ea,
/* aa1 - _66_0F_6A */  0x23eb,
/* aa2 -  */  0,
/* aa3 -  */  0,
/* aa4 -  */  0,
/* aa5 - _V_66_0F_6A */  0x4071,
/* aa6 -  */  0,
/* aa7 -  */  0,
/* aa8 -  */  0,
/* aa9 -  */  0,
/* aaa -  */  0,
/* aab -  */  0,
/* aac - _0F_6B */  0x23ec,
/* aad - _66_0F_6B */  0x23ed,
/* aae -  */  0,
/* aaf -  */  0,
/* ab0 -  */  0,
/* ab1 - _V_66_0F_6B */  0x4072,
/* ab2 -  */  0,
/* ab3 -  */  0,
/* ab4 -  */  0,
/* ab5 -  */  0,
/* ab6 -  */  0,
/* ab7 -  */  0,
/* ab8 -  */  0,
/* ab9 - _66_0F_6C */  0x23ee,
/* aba -  */  0,
/* abb -  */  0,
/* abc -  */  0,
/* abd - _V_66_0F_6C */  0x4073,
/* abe -  */  0,
/* abf -  */  0,
/* ac0 -  */  0,
/* ac1 -  */  0,
/* ac2 -  */  0,
/* ac3 -  */  0,
/* ac4 -  */  0,
/* ac5 - _66_0F_6D */  0x23ef,
/* ac6 -  */  0,
/* ac7 -  */  0,
/* ac8 -  */  0,
/* ac9 - _V_66_0F_6D */  0x4074,
/* aca -  */  0,
/* acb -  */  0,
/* acc -  */  0,
/* acd -  */  0,
/* ace -  */  0,
/* acf -  */  0,
/* ad0 - _0F_6E */  0x4075,
/* ad1 - _66_0F_6E */  0x4076,
/* ad2 -  */  0,
/* ad3 -  */  0,
/* ad4 -  */  0,
/* ad5 - _V_66_0F_6E */  0x4077,
/* ad6 -  */  0,
/* ad7 -  */  0,
/* ad8 -  */  0,
/* ad9 -  */  0,
/* ada -  */  0,
/* adb -  */  0,
/* adc - _0F_6F */  0x23f0,
/* add - _66_0F_6F */  0x23f1,
/* ade - _F3_0F_6F */  0x23f2,
/* adf -  */  0,
/* ae0 -  */  0,
/* ae1 - _V_66_0F_6F */  0x4078,
/* ae2 - _V_F3_0F_6F */  0x4079,
/* ae3 -  */  0,
/* ae4 -  */  0,
/* ae5 -  */  0,
/* ae6 -  */  0,
/* ae7 -  */  0,
/* ae8 - _0F_70 */  0x407a,
/* ae9 - _66_0F_70 */  0x407b,
/* aea - _F3_0F_70 */  0x407c,
/* aeb - _F2_0F_70 */  0x407d,
/* aec -  */  0,
/* aed - _V_66_0F_70 */  0x407e,
/* aee - _V_F3_0F_70 */  0x407f,
/* aef - _V_F2_0F_70 */  0x4080,
/* af0 -  */  0,
/* af1 -  */  0,
/* af2 -  */  0,
/* af3 -  */  0,
/* af4 -  */  0,
/* af5 -  */  0,
/* af6 - _0F_71_02 */  0xf584,
/* af7 -  */  0,
/* af8 - _0F_71_04 */  0xf590,
/* af9 -  */  0,
/* afa - _0F_71_06 */  0xf59c,
/* afb -  */  0,
/* afc -  */  0,
/* afd -  */  0,
/* afe - _0F_72_02 */  0xf5a8,
/* aff -  */  0,
/* b00 - _0F_72_04 */  0xf5b4,
/* b01 -  */  0,
/* b02 - _0F_72_06 */  0xf5c0,
/* b03 -  */  0,
/* b04 -  */  0,
/* b05 -  */  0,
/* b06 - _0F_73_02 */  0xf5cc,
/* b07 - _0F_73_03 */  0xf5d8,
/* b08 -  */  0,
/* b09 -  */  0,
/* b0a - _0F_73_06 */  0xf5e4,
/* b0b - _0F_73_07 */  0xf5f0,
/* b0c - _0F_74 */  0x23f3,
/* b0d - _66_0F_74 */  0x23f4,
/* b0e -  */  0,
/* b0f -  */  0,
/* b10 -  */  0,
/* b11 - _V_66_0F_74 */  0x4081,
/* b12 -  */  0,
/* b13 -  */  0,
/* b14 -  */  0,
/* b15 -  */  0,
/* b16 -  */  0,
/* b17 -  */  0,
/* b18 - _0F_75 */  0x23f5,
/* b19 - _66_0F_75 */  0x23f6,
/* b1a -  */  0,
/* b1b -  */  0,
/* b1c -  */  0,
/* b1d - _V_66_0F_75 */  0x4082,
/* b1e -  */  0,
/* b1f -  */  0,
/* b20 -  */  0,
/* b21 -  */  0,
/* b22 -  */  0,
/* b23 -  */  0,
/* b24 - _0F_76 */  0x23f7,
/* b25 - _66_0F_76 */  0x23f8,
/* b26 -  */  0,
/* b27 -  */  0,
/* b28 -  */  0,
/* b29 - _V_66_0F_76 */  0x4083,
/* b2a -  */  0,
/* b2b -  */  0,
/* b2c -  */  0,
/* b2d -  */  0,
/* b2e -  */  0,
/* b2f -  */  0,
/* b30 - _0F_77 */  0x23f9,
/* b31 -  */  0,
/* b32 -  */  0,
/* b33 -  */  0,
/* b34 - _V_0F_77 */  0x4084,
/* b35 -  */  0,
/* b36 -  */  0,
/* b37 -  */  0,
/* b38 -  */  0,
/* b39 -  */  0,
/* b3a -  */  0,
/* b3b -  */  0,
/* b3c - _0F_78 */  0x23fa,
/* b3d - _66_0F_78 */  0x4085,
/* b3e -  */  0,
/* b3f - _F2_0F_78 */  0x4086,
/* b40 -  */  0,
/* b41 -  */  0,
/* b42 -  */  0,
/* b43 -  */  0,
/* b44 -  */  0,
/* b45 -  */  0,
/* b46 -  */  0,
/* b47 -  */  0,
/* b48 - _0F_79 */  0x23fb,
/* b49 - _66_0F_79 */  0x23fc,
/* b4a -  */  0,
/* b4b - _F2_0F_79 */  0x23fd,
/* b4c -  */  0,
/* b4d -  */  0,
/* b4e -  */  0,
/* b4f -  */  0,
/* b50 -  */  0,
/* b51 -  */  0,
/* b52 -  */  0,
/* b53 -  */  0,
/* b54 -  */  0,
/* b55 -  */  0,
/* b56 -  */  0,
/* b57 -  */  0,
/* b58 -  */  0,
/* b59 -  */  0,
/* b5a -  */  0,
/* b5b -  */  0,
/* b5c -  */  0,
/* b5d -  */  0,
/* b5e -  */  0,
/* b5f -  */  0,
/* b60 -  */  0,
/* b61 -  */  0,
/* b62 -  */  0,
/* b63 -  */  0,
/* b64 -  */  0,
/* b65 -  */  0,
/* b66 -  */  0,
/* b67 -  */  0,
/* b68 -  */  0,
/* b69 -  */  0,
/* b6a -  */  0,
/* b6b -  */  0,
/* b6c -  */  0,
/* b6d -  */  0,
/* b6e -  */  0,
/* b6f -  */  0,
/* b70 -  */  0,
/* b71 -  */  0,
/* b72 -  */  0,
/* b73 -  */  0,
/* b74 -  */  0,
/* b75 -  */  0,
/* b76 -  */  0,
/* b77 -  */  0,
/* b78 -  */  0,
/* b79 -  */  0,
/* b7a -  */  0,
/* b7b -  */  0,
/* b7c -  */  0,
/* b7d -  */  0,
/* b7e -  */  0,
/* b7f -  */  0,
/* b80 -  */  0,
/* b81 -  */  0,
/* b82 -  */  0,
/* b83 -  */  0,
/* b84 - _0F_7A_30 */  0x23fe,
/* b85 - _0F_7A_31 */  0x23ff,
/* b86 -  */  0,
/* b87 -  */  0,
/* b88 -  */  0,
/* b89 -  */  0,
/* b8a -  */  0,
/* b8b -  */  0,
/* b8c -  */  0,
/* b8d -  */  0,
/* b8e -  */  0,
/* b8f -  */  0,
/* b90 -  */  0,
/* b91 -  */  0,
/* b92 -  */  0,
/* b93 -  */  0,
/* b94 -  */  0,
/* b95 -  */  0,
/* b96 -  */  0,
/* b97 -  */  0,
/* b98 -  */  0,
/* b99 -  */  0,
/* b9a -  */  0,
/* b9b -  */  0,
/* b9c -  */  0,
/* b9d -  */  0,
/* b9e -  */  0,
/* b9f -  */  0,
/* ba0 -  */  0,
/* ba1 -  */  0,
/* ba2 -  */  0,
/* ba3 -  */  0,
/* ba4 -  */  0,
/* ba5 -  */  0,
/* ba6 -  */  0,
/* ba7 -  */  0,
/* ba8 -  */  0,
/* ba9 -  */  0,
/* baa -  */  0,
/* bab -  */  0,
/* bac -  */  0,
/* bad -  */  0,
/* bae -  */  0,
/* baf -  */  0,
/* bb0 -  */  0,
/* bb1 -  */  0,
/* bb2 -  */  0,
/* bb3 -  */  0,
/* bb4 -  */  0,
/* bb5 -  */  0,
/* bb6 -  */  0,
/* bb7 -  */  0,
/* bb8 -  */  0,
/* bb9 -  */  0,
/* bba -  */  0,
/* bbb -  */  0,
/* bbc -  */  0,
/* bbd -  */  0,
/* bbe -  */  0,
/* bbf -  */  0,
/* bc0 -  */  0,
/* bc1 -  */  0,
/* bc2 -  */  0,
/* bc3 -  */  0,
/* bc4 -  */  0,
/* bc5 -  */  0,
/* bc6 -  */  0,
/* bc7 -  */  0,
/* bc8 -  */  0,
/* bc9 -  */  0,
/* bca -  */  0,
/* bcb -  */  0,
/* bcc -  */  0,
/* bcd -  */  0,
/* bce -  */  0,
/* bcf -  */  0,
/* bd0 -  */  0,
/* bd1 -  */  0,
/* bd2 -  */  0,
/* bd3 -  */  0,
/* bd4 -  */  0,
/* bd5 -  */  0,
/* bd6 -  */  0,
/* bd7 -  */  0,
/* bd8 -  */  0,
/* bd9 -  */  0,
/* bda -  */  0,
/* bdb -  */  0,
/* bdc -  */  0,
/* bdd -  */  0,
/* bde -  */  0,
/* bdf -  */  0,
/* be0 -  */  0,
/* be1 -  */  0,
/* be2 -  */  0,
/* be3 -  */  0,
/* be4 -  */  0,
/* be5 -  */  0,
/* be6 -  */  0,
/* be7 -  */  0,
/* be8 -  */  0,
/* be9 -  */  0,
/* bea -  */  0,
/* beb -  */  0,
/* bec -  */  0,
/* bed -  */  0,
/* bee -  */  0,
/* bef -  */  0,
/* bf0 -  */  0,
/* bf1 -  */  0,
/* bf2 -  */  0,
/* bf3 -  */  0,
/* bf4 -  */  0,
/* bf5 -  */  0,
/* bf6 -  */  0,
/* bf7 -  */  0,
/* bf8 -  */  0,
/* bf9 -  */  0,
/* bfa -  */  0,
/* bfb -  */  0,
/* bfc -  */  0,
/* bfd -  */  0,
/* bfe -  */  0,
/* bff -  */  0,
/* c00 -  */  0,
/* c01 -  */  0,
/* c02 -  */  0,
/* c03 -  */  0,
/* c04 -  */  0,
/* c05 -  */  0,
/* c06 -  */  0,
/* c07 -  */  0,
/* c08 -  */  0,
/* c09 -  */  0,
/* c0a -  */  0,
/* c0b -  */  0,
/* c0c -  */  0,
/* c0d -  */  0,
/* c0e -  */  0,
/* c0f -  */  0,
/* c10 -  */  0,
/* c11 -  */  0,
/* c12 -  */  0,
/* c13 -  */  0,
/* c14 -  */  0,
/* c15 -  */  0,
/* c16 -  */  0,
/* c17 -  */  0,
/* c18 -  */  0,
/* c19 -  */  0,
/* c1a -  */  0,
/* c1b -  */  0,
/* c1c -  */  0,
/* c1d -  */  0,
/* c1e -  */  0,
/* c1f -  */  0,
/* c20 -  */  0,
/* c21 -  */  0,
/* c22 -  */  0,
/* c23 -  */  0,
/* c24 -  */  0,
/* c25 -  */  0,
/* c26 -  */  0,
/* c27 -  */  0,
/* c28 -  */  0,
/* c29 -  */  0,
/* c2a -  */  0,
/* c2b -  */  0,
/* c2c -  */  0,
/* c2d -  */  0,
/* c2e -  */  0,
/* c2f -  */  0,
/* c30 -  */  0,
/* c31 -  */  0,
/* c32 -  */  0,
/* c33 -  */  0,
/* c34 -  */  0,
/* c35 -  */  0,
/* c36 -  */  0,
/* c37 -  */  0,
/* c38 -  */  0,
/* c39 -  */  0,
/* c3a -  */  0,
/* c3b -  */  0,
/* c3c -  */  0,
/* c3d -  */  0,
/* c3e -  */  0,
/* c3f -  */  0,
/* c40 -  */  0,
/* c41 -  */  0,
/* c42 -  */  0,
/* c43 -  */  0,
/* c44 -  */  0,
/* c45 -  */  0,
/* c46 -  */  0,
/* c47 -  */  0,
/* c48 -  */  0,
/* c49 -  */  0,
/* c4a -  */  0,
/* c4b -  */  0,
/* c4c -  */  0,
/* c4d -  */  0,
/* c4e -  */  0,
/* c4f -  */  0,
/* c50 -  */  0,
/* c51 -  */  0,
/* c52 -  */  0,
/* c53 -  */  0,
/* c54 -  */  0,
/* c55 - _66_0F_7C */  0x2400,
/* c56 -  */  0,
/* c57 - _F2_0F_7C */  0x2401,
/* c58 -  */  0,
/* c59 - _V_66_0F_7C */  0x4087,
/* c5a -  */  0,
/* c5b - _V_F2_0F_7C */  0x4088,
/* c5c -  */  0,
/* c5d -  */  0,
/* c5e -  */  0,
/* c5f -  */  0,
/* c60 -  */  0,
/* c61 - _66_0F_7D */  0x2402,
/* c62 -  */  0,
/* c63 - _F2_0F_7D */  0x2403,
/* c64 -  */  0,
/* c65 - _V_66_0F_7D */  0x4089,
/* c66 -  */  0,
/* c67 - _V_F2_0F_7D */  0x408a,
/* c68 -  */  0,
/* c69 -  */  0,
/* c6a -  */  0,
/* c6b -  */  0,
/* c6c - _0F_7E */  0x408b,
/* c6d - _66_0F_7E */  0x408c,
/* c6e - _F3_0F_7E */  0x2404,
/* c6f -  */  0,
/* c70 -  */  0,
/* c71 - _V_66_0F_7E */  0x408d,
/* c72 - _V_F3_0F_7E */  0x408e,
/* c73 -  */  0,
/* c74 -  */  0,
/* c75 -  */  0,
/* c76 -  */  0,
/* c77 -  */  0,
/* c78 - _0F_7F */  0x2405,
/* c79 - _66_0F_7F */  0x2406,
/* c7a - _F3_0F_7F */  0x2407,
/* c7b -  */  0,
/* c7c -  */  0,
/* c7d - _V_66_0F_7F */  0x408f,
/* c7e - _V_F3_0F_7F */  0x4090,
/* c7f -  */  0,
/* c80 -  */  0,
/* c81 -  */  0,
/* c82 -  */  0,
/* c83 -  */  0,
/* c84 - _0F_AE_00 */  0xf5fc,
/* c85 - _0F_AE_01 */  0xf608,
/* c86 - _0F_AE_02 */  0xf614,
/* c87 - _0F_AE_03 */  0xf620,
/* c88 - _0F_AE_04 */  0x4091,
/* c89 - _0F_AE_05 */  0x4092,
/* c8a - _0F_AE_06 */  0x4093,
/* c8b - _0F_AE_07 */  0x4094,
/* c8c -  */  0,
/* c8d -  */  0,
/* c8e - _F3_0F_B8 */  0x2408,
/* c8f -  */  0,
/* c90 -  */  0,
/* c91 -  */  0,
/* c92 -  */  0,
/* c93 -  */  0,
/* c94 -  */  0,
/* c95 -  */  0,
/* c96 -  */  0,
/* c97 -  */  0,
/* c98 -  */  0,
/* c99 -  */  0,
/* c9a -  */  0,
/* c9b -  */  0,
/* c9c - _0F_BA_04 */  0x2409,
/* c9d - _0F_BA_05 */  0x240a,
/* c9e - _0F_BA_06 */  0x240b,
/* c9f - _0F_BA_07 */  0x240c,
/* ca0 - _0F_BC */  0x240d,
/* ca1 -  */  0,
/* ca2 - _F3_0F_BC */  0x240e,
/* ca3 -  */  0,
/* ca4 -  */  0,
/* ca5 -  */  0,
/* ca6 -  */  0,
/* ca7 -  */  0,
/* ca8 -  */  0,
/* ca9 -  */  0,
/* caa -  */  0,
/* cab -  */  0,
/* cac - _0F_BD */  0x240f,
/* cad -  */  0,
/* cae - _F3_0F_BD */  0x2410,
/* caf -  */  0,
/* cb0 -  */  0,
/* cb1 -  */  0,
/* cb2 -  */  0,
/* cb3 -  */  0,
/* cb4 -  */  0,
/* cb5 -  */  0,
/* cb6 -  */  0,
/* cb7 -  */  0,
/* cb8 - _0F_C2 */  0x4095,
/* cb9 - _66_0F_C2 */  0x4096,
/* cba - _F3_0F_C2 */  0x4097,
/* cbb - _F2_0F_C2 */  0x4098,
/* cbc - _V_0F_C2 */  0x4099,
/* cbd - _V_66_0F_C2 */  0x409a,
/* cbe - _V_F3_0F_C2 */  0x409b,
/* cbf - _V_F2_0F_C2 */  0x409c,
/* cc0 -  */  0,
/* cc1 -  */  0,
/* cc2 -  */  0,
/* cc3 -  */  0,
/* cc4 - _0F_C4 */  0x409d,
/* cc5 - _66_0F_C4 */  0x409e,
/* cc6 -  */  0,
/* cc7 -  */  0,
/* cc8 -  */  0,
/* cc9 - _V_66_0F_C4 */  0x409f,
/* cca -  */  0,
/* ccb -  */  0,
/* ccc -  */  0,
/* ccd -  */  0,
/* cce -  */  0,
/* ccf -  */  0,
/* cd0 - _0F_C5 */  0x40a0,
/* cd1 - _66_0F_C5 */  0x40a1,
/* cd2 -  */  0,
/* cd3 -  */  0,
/* cd4 -  */  0,
/* cd5 - _V_66_0F_C5 */  0x40a2,
/* cd6 -  */  0,
/* cd7 -  */  0,
/* cd8 -  */  0,
/* cd9 -  */  0,
/* cda -  */  0,
/* cdb -  */  0,
/* cdc - _0F_C6 */  0x40a3,
/* cdd - _66_0F_C6 */  0x40a4,
/* cde -  */  0,
/* cdf -  */  0,
/* ce0 - _V_0F_C6 */  0x40a5,
/* ce1 - _V_66_0F_C6 */  0x40a6,
/* ce2 -  */  0,
/* ce3 -  */  0,
/* ce4 -  */  0,
/* ce5 -  */  0,
/* ce6 -  */  0,
/* ce7 -  */  0,
/* ce8 -  */  0,
/* ce9 - _0F_C7_01 */  0x40a7,
/* cea -  */  0,
/* ceb -  */  0,
/* cec -  */  0,
/* ced -  */  0,
/* cee - _0F_C7_06 */  0xf62c,
/* cef - _0F_C7_07 */  0x2411,
/* cf0 -  */  0,
/* cf1 - _66_0F_D0 */  0x2412,
/* cf2 -  */  0,
/* cf3 - _F2_0F_D0 */  0x2413,
/* cf4 -  */  0,
/* cf5 - _V_66_0F_D0 */  0x40a8,
/* cf6 -  */  0,
/* cf7 - _V_F2_0F_D0 */  0x40a9,
/* cf8 -  */  0,
/* cf9 -  */  0,
/* cfa -  */  0,
/* cfb -  */  0,
/* cfc - _0F_D1 */  0x2414,
/* cfd - _66_0F_D1 */  0x2415,
/* cfe -  */  0,
/* cff -  */  0,
/* d00 -  */  0,
/* d01 - _V_66_0F_D1 */  0x40aa,
/* d02 -  */  0,
/* d03 -  */  0,
/* d04 -  */  0,
/* d05 -  */  0,
/* d06 -  */  0,
/* d07 -  */  0,
/* d08 - _0F_D2 */  0x2416,
/* d09 - _66_0F_D2 */  0x2417,
/* d0a -  */  0,
/* d0b -  */  0,
/* d0c -  */  0,
/* d0d - _V_66_0F_D2 */  0x40ab,
/* d0e -  */  0,
/* d0f -  */  0,
/* d10 -  */  0,
/* d11 -  */  0,
/* d12 -  */  0,
/* d13 -  */  0,
/* d14 - _0F_D3 */  0x2418,
/* d15 - _66_0F_D3 */  0x2419,
/* d16 -  */  0,
/* d17 -  */  0,
/* d18 -  */  0,
/* d19 - _V_66_0F_D3 */  0x40ac,
/* d1a -  */  0,
/* d1b -  */  0,
/* d1c -  */  0,
/* d1d -  */  0,
/* d1e -  */  0,
/* d1f -  */  0,
/* d20 - _0F_D4 */  0x241a,
/* d21 - _66_0F_D4 */  0x241b,
/* d22 -  */  0,
/* d23 -  */  0,
/* d24 -  */  0,
/* d25 - _V_66_0F_D4 */  0x40ad,
/* d26 -  */  0,
/* d27 -  */  0,
/* d28 -  */  0,
/* d29 -  */  0,
/* d2a -  */  0,
/* d2b -  */  0,
/* d2c - _0F_D5 */  0x241c,
/* d2d - _66_0F_D5 */  0x241d,
/* d2e -  */  0,
/* d2f -  */  0,
/* d30 -  */  0,
/* d31 - _V_66_0F_D5 */  0x40ae,
/* d32 -  */  0,
/* d33 -  */  0,
/* d34 -  */  0,
/* d35 -  */  0,
/* d36 -  */  0,
/* d37 -  */  0,
/* d38 -  */  0,
/* d39 - _66_0F_D6 */  0x241e,
/* d3a - _F3_0F_D6 */  0x241f,
/* d3b - _F2_0F_D6 */  0x2420,
/* d3c -  */  0,
/* d3d - _V_66_0F_D6 */  0x40af,
/* d3e -  */  0,
/* d3f -  */  0,
/* d40 -  */  0,
/* d41 -  */  0,
/* d42 -  */  0,
/* d43 -  */  0,
/* d44 - _0F_D7 */  0x2421,
/* d45 - _66_0F_D7 */  0x2422,
/* d46 -  */  0,
/* d47 -  */  0,
/* d48 -  */  0,
/* d49 - _V_66_0F_D7 */  0x40b0,
/* d4a -  */  0,
/* d4b -  */  0,
/* d4c -  */  0,
/* d4d -  */  0,
/* d4e -  */  0,
/* d4f -  */  0,
/* d50 - _0F_D8 */  0x2423,
/* d51 - _66_0F_D8 */  0x2424,
/* d52 -  */  0,
/* d53 -  */  0,
/* d54 -  */  0,
/* d55 - _V_66_0F_D8 */  0x40b1,
/* d56 -  */  0,
/* d57 -  */  0,
/* d58 -  */  0,
/* d59 -  */  0,
/* d5a -  */  0,
/* d5b -  */  0,
/* d5c - _0F_D9 */  0x2425,
/* d5d - _66_0F_D9 */  0x2426,
/* d5e -  */  0,
/* d5f -  */  0,
/* d60 -  */  0,
/* d61 - _V_66_0F_D9 */  0x40b2,
/* d62 -  */  0,
/* d63 -  */  0,
/* d64 -  */  0,
/* d65 -  */  0,
/* d66 -  */  0,
/* d67 -  */  0,
/* d68 - _0F_DA */  0x2427,
/* d69 - _66_0F_DA */  0x2428,
/* d6a -  */  0,
/* d6b -  */  0,
/* d6c -  */  0,
/* d6d - _V_66_0F_DA */  0x40b3,
/* d6e -  */  0,
/* d6f -  */  0,
/* d70 -  */  0,
/* d71 -  */  0,
/* d72 -  */  0,
/* d73 -  */  0,
/* d74 - _0F_DB */  0x2429,
/* d75 - _66_0F_DB */  0x242a,
/* d76 -  */  0,
/* d77 -  */  0,
/* d78 -  */  0,
/* d79 - _V_66_0F_DB */  0x40b4,
/* d7a -  */  0,
/* d7b -  */  0,
/* d7c -  */  0,
/* d7d -  */  0,
/* d7e -  */  0,
/* d7f -  */  0,
/* d80 - _0F_DC */  0x242b,
/* d81 - _66_0F_DC */  0x242c,
/* d82 -  */  0,
/* d83 -  */  0,
/* d84 -  */  0,
/* d85 - _V_66_0F_DC */  0x40b5,
/* d86 -  */  0,
/* d87 -  */  0,
/* d88 -  */  0,
/* d89 -  */  0,
/* d8a -  */  0,
/* d8b -  */  0,
/* d8c - _0F_DD */  0x242d,
/* d8d - _66_0F_DD */  0x242e,
/* d8e -  */  0,
/* d8f -  */  0,
/* d90 -  */  0,
/* d91 - _V_66_0F_DD */  0x40b6,
/* d92 -  */  0,
/* d93 -  */  0,
/* d94 -  */  0,
/* d95 -  */  0,
/* d96 -  */  0,
/* d97 -  */  0,
/* d98 - _0F_DE */  0x242f,
/* d99 - _66_0F_DE */  0x2430,
/* d9a -  */  0,
/* d9b -  */  0,
/* d9c -  */  0,
/* d9d - _V_66_0F_DE */  0x40b7,
/* d9e -  */  0,
/* d9f -  */  0,
/* da0 -  */  0,
/* da1 -  */  0,
/* da2 -  */  0,
/* da3 -  */  0,
/* da4 - _0F_DF */  0x2431,
/* da5 - _66_0F_DF */  0x2432,
/* da6 -  */  0,
/* da7 -  */  0,
/* da8 -  */  0,
/* da9 - _V_66_0F_DF */  0x40b8,
/* daa -  */  0,
/* dab -  */  0,
/* dac -  */  0,
/* dad -  */  0,
/* dae -  */  0,
/* daf -  */  0,
/* db0 - _0F_E0 */  0x2433,
/* db1 - _66_0F_E0 */  0x2434,
/* db2 -  */  0,
/* db3 -  */  0,
/* db4 -  */  0,
/* db5 - _V_66_0F_E0 */  0x40b9,
/* db6 -  */  0,
/* db7 -  */  0,
/* db8 -  */  0,
/* db9 -  */  0,
/* dba -  */  0,
/* dbb -  */  0,
/* dbc - _0F_E1 */  0x2435,
/* dbd - _66_0F_E1 */  0x2436,
/* dbe -  */  0,
/* dbf -  */  0,
/* dc0 -  */  0,
/* dc1 - _V_66_0F_E1 */  0x40ba,
/* dc2 -  */  0,
/* dc3 -  */  0,
/* dc4 -  */  0,
/* dc5 -  */  0,
/* dc6 -  */  0,
/* dc7 -  */  0,
/* dc8 - _0F_E2 */  0x2437,
/* dc9 - _66_0F_E2 */  0x2438,
/* dca -  */  0,
/* dcb -  */  0,
/* dcc -  */  0,
/* dcd - _V_66_0F_E2 */  0x40bb,
/* dce -  */  0,
/* dcf -  */  0,
/* dd0 -  */  0,
/* dd1 -  */  0,
/* dd2 -  */  0,
/* dd3 -  */  0,
/* dd4 - _0F_E3 */  0x2439,
/* dd5 - _66_0F_E3 */  0x243a,
/* dd6 -  */  0,
/* dd7 -  */  0,
/* dd8 -  */  0,
/* dd9 - _V_66_0F_E3 */  0x40bc,
/* dda -  */  0,
/* ddb -  */  0,
/* ddc -  */  0,
/* ddd -  */  0,
/* dde -  */  0,
/* ddf -  */  0,
/* de0 - _0F_E4 */  0x243b,
/* de1 - _66_0F_E4 */  0x243c,
/* de2 -  */  0,
/* de3 -  */  0,
/* de4 -  */  0,
/* de5 - _V_66_0F_E4 */  0x40bd,
/* de6 -  */  0,
/* de7 -  */  0,
/* de8 -  */  0,
/* de9 -  */  0,
/* dea -  */  0,
/* deb -  */  0,
/* dec - _0F_E5 */  0x243d,
/* ded - _66_0F_E5 */  0x243e,
/* dee -  */  0,
/* def -  */  0,
/* df0 -  */  0,
/* df1 - _V_66_0F_E5 */  0x40be,
/* df2 -  */  0,
/* df3 -  */  0,
/* df4 -  */  0,
/* df5 -  */  0,
/* df6 -  */  0,
/* df7 -  */  0,
/* df8 -  */  0,
/* df9 - _66_0F_E6 */  0x243f,
/* dfa - _F3_0F_E6 */  0x2440,
/* dfb - _F2_0F_E6 */  0x2441,
/* dfc -  */  0,
/* dfd - _V_66_0F_E6 */  0x40bf,
/* dfe - _V_F3_0F_E6 */  0x40c0,
/* dff - _V_F2_0F_E6 */  0x40c1,
/* e00 -  */  0,
/* e01 -  */  0,
/* e02 -  */  0,
/* e03 -  */  0,
/* e04 - _0F_E7 */  0x2442,
/* e05 - _66_0F_E7 */  0x2443,
/* e06 -  */  0,
/* e07 -  */  0,
/* e08 -  */  0,
/* e09 - _V_66_0F_E7 */  0x40c2,
/* e0a -  */  0,
/* e0b -  */  0,
/* e0c -  */  0,
/* e0d -  */  0,
/* e0e -  */  0,
/* e0f -  */  0,
/* e10 - _0F_E8 */  0x2444,
/* e11 - _66_0F_E8 */  0x2445,
/* e12 -  */  0,
/* e13 -  */  0,
/* e14 -  */  0,
/* e15 - _V_66_0F_E8 */  0x40c3,
/* e16 -  */  0,
/* e17 -  */  0,
/* e18 -  */  0,
/* e19 -  */  0,
/* e1a -  */  0,
/* e1b -  */  0,
/* e1c - _0F_E9 */  0x2446,
/* e1d - _66_0F_E9 */  0x2447,
/* e1e -  */  0,
/* e1f -  */  0,
/* e20 -  */  0,
/* e21 - _V_66_0F_E9 */  0x40c4,
/* e22 -  */  0,
/* e23 -  */  0,
/* e24 -  */  0,
/* e25 -  */  0,
/* e26 -  */  0,
/* e27 -  */  0,
/* e28 - _0F_EA */  0x2448,
/* e29 - _66_0F_EA */  0x2449,
/* e2a -  */  0,
/* e2b -  */  0,
/* e2c -  */  0,
/* e2d - _V_66_0F_EA */  0x40c5,
/* e2e -  */  0,
/* e2f -  */  0,
/* e30 -  */  0,
/* e31 -  */  0,
/* e32 -  */  0,
/* e33 -  */  0,
/* e34 - _0F_EB */  0x244a,
/* e35 - _66_0F_EB */  0x244b,
/* e36 -  */  0,
/* e37 -  */  0,
/* e38 -  */  0,
/* e39 - _V_66_0F_EB */  0x40c6,
/* e3a -  */  0,
/* e3b -  */  0,
/* e3c -  */  0,
/* e3d -  */  0,
/* e3e -  */  0,
/* e3f -  */  0,
/* e40 - _0F_EC */  0x244c,
/* e41 - _66_0F_EC */  0x244d,
/* e42 -  */  0,
/* e43 -  */  0,
/* e44 -  */  0,
/* e45 - _V_66_0F_EC */  0x40c7,
/* e46 -  */  0,
/* e47 -  */  0,
/* e48 -  */  0,
/* e49 -  */  0,
/* e4a -  */  0,
/* e4b -  */  0,
/* e4c - _0F_ED */  0x244e,
/* e4d - _66_0F_ED */  0x244f,
/* e4e -  */  0,
/* e4f -  */  0,
/* e50 -  */  0,
/* e51 - _V_66_0F_ED */  0x40c8,
/* e52 -  */  0,
/* e53 -  */  0,
/* e54 -  */  0,
/* e55 -  */  0,
/* e56 -  */  0,
/* e57 -  */  0,
/* e58 - _0F_EE */  0x2450,
/* e59 - _66_0F_EE */  0x2451,
/* e5a -  */  0,
/* e5b -  */  0,
/* e5c -  */  0,
/* e5d - _V_66_0F_EE */  0x40c9,
/* e5e -  */  0,
/* e5f -  */  0,
/* e60 -  */  0,
/* e61 -  */  0,
/* e62 -  */  0,
/* e63 -  */  0,
/* e64 - _0F_EF */  0x2452,
/* e65 - _66_0F_EF */  0x2453,
/* e66 -  */  0,
/* e67 -  */  0,
/* e68 -  */  0,
/* e69 - _V_66_0F_EF */  0x40ca,
/* e6a -  */  0,
/* e6b -  */  0,
/* e6c -  */  0,
/* e6d -  */  0,
/* e6e -  */  0,
/* e6f -  */  0,
/* e70 -  */  0,
/* e71 -  */  0,
/* e72 -  */  0,
/* e73 - _F2_0F_F0 */  0x2454,
/* e74 -  */  0,
/* e75 -  */  0,
/* e76 -  */  0,
/* e77 - _V_F2_0F_F0 */  0x40cb,
/* e78 -  */  0,
/* e79 -  */  0,
/* e7a -  */  0,
/* e7b -  */  0,
/* e7c - _0F_F1 */  0x2455,
/* e7d - _66_0F_F1 */  0x2456,
/* e7e -  */  0,
/* e7f -  */  0,
/* e80 -  */  0,
/* e81 - _V_66_0F_F1 */  0x40cc,
/* e82 -  */  0,
/* e83 -  */  0,
/* e84 -  */  0,
/* e85 -  */  0,
/* e86 -  */  0,
/* e87 -  */  0,
/* e88 - _0F_F2 */  0x2457,
/* e89 - _66_0F_F2 */  0x2458,
/* e8a -  */  0,
/* e8b -  */  0,
/* e8c -  */  0,
/* e8d - _V_66_0F_F2 */  0x40cd,
/* e8e -  */  0,
/* e8f -  */  0,
/* e90 -  */  0,
/* e91 -  */  0,
/* e92 -  */  0,
/* e93 -  */  0,
/* e94 - _0F_F3 */  0x2459,
/* e95 - _66_0F_F3 */  0x245a,
/* e96 -  */  0,
/* e97 -  */  0,
/* e98 -  */  0,
/* e99 - _V_66_0F_F3 */  0x40ce,
/* e9a -  */  0,
/* e9b -  */  0,
/* e9c -  */  0,
/* e9d -  */  0,
/* e9e -  */  0,
/* e9f -  */  0,
/* ea0 - _0F_F4 */  0x245b,
/* ea1 - _66_0F_F4 */  0x245c,
/* ea2 -  */  0,
/* ea3 -  */  0,
/* ea4 -  */  0,
/* ea5 - _V_66_0F_F4 */  0x40cf,
/* ea6 -  */  0,
/* ea7 -  */  0,
/* ea8 -  */  0,
/* ea9 -  */  0,
/* eaa -  */  0,
/* eab -  */  0,
/* eac - _0F_F5 */  0x245d,
/* ead - _66_0F_F5 */  0x245e,
/* eae -  */  0,
/* eaf -  */  0,
/* eb0 -  */  0,
/* eb1 - _V_66_0F_F5 */  0x40d0,
/* eb2 -  */  0,
/* eb3 -  */  0,
/* eb4 -  */  0,
/* eb5 -  */  0,
/* eb6 -  */  0,
/* eb7 -  */  0,
/* eb8 - _0F_F6 */  0x245f,
/* eb9 - _66_0F_F6 */  0x2460,
/* eba -  */  0,
/* ebb -  */  0,
/* ebc -  */  0,
/* ebd - _V_66_0F_F6 */  0x40d1,
/* ebe -  */  0,
/* ebf -  */  0,
/* ec0 -  */  0,
/* ec1 -  */  0,
/* ec2 -  */  0,
/* ec3 -  */  0,
/* ec4 - _0F_F7 */  0x2461,
/* ec5 - _66_0F_F7 */  0x2462,
/* ec6 -  */  0,
/* ec7 -  */  0,
/* ec8 -  */  0,
/* ec9 - _V_66_0F_F7 */  0x40d2,
/* eca -  */  0,
/* ecb -  */  0,
/* ecc -  */  0,
/* ecd -  */  0,
/* ece -  */  0,
/* ecf -  */  0,
/* ed0 - _0F_F8 */  0x2463,
/* ed1 - _66_0F_F8 */  0x2464,
/* ed2 -  */  0,
/* ed3 -  */  0,
/* ed4 -  */  0,
/* ed5 - _V_66_0F_F8 */  0x40d3,
/* ed6 -  */  0,
/* ed7 -  */  0,
/* ed8 -  */  0,
/* ed9 -  */  0,
/* eda -  */  0,
/* edb -  */  0,
/* edc - _0F_F9 */  0x2465,
/* edd - _66_0F_F9 */  0x2466,
/* ede -  */  0,
/* edf -  */  0,
/* ee0 -  */  0,
/* ee1 - _V_66_0F_F9 */  0x40d4,
/* ee2 -  */  0,
/* ee3 -  */  0,
/* ee4 -  */  0,
/* ee5 -  */  0,
/* ee6 -  */  0,
/* ee7 -  */  0,
/* ee8 - _0F_FA */  0x2467,
/* ee9 - _66_0F_FA */  0x2468,
/* eea -  */  0,
/* eeb -  */  0,
/* eec -  */  0,
/* eed - _V_66_0F_FA */  0x40d5,
/* eee -  */  0,
/* eef -  */  0,
/* ef0 -  */  0,
/* ef1 -  */  0,
/* ef2 -  */  0,
/* ef3 -  */  0,
/* ef4 - _0F_FB */  0x2469,
/* ef5 - _66_0F_FB */  0x246a,
/* ef6 -  */  0,
/* ef7 -  */  0,
/* ef8 -  */  0,
/* ef9 - _V_66_0F_FB */  0x40d6,
/* efa -  */  0,
/* efb -  */  0,
/* efc -  */  0,
/* efd -  */  0,
/* efe -  */  0,
/* eff -  */  0,
/* f00 - _0F_FC */  0x246b,
/* f01 - _66_0F_FC */  0x246c,
/* f02 -  */  0,
/* f03 -  */  0,
/* f04 -  */  0,
/* f05 - _V_66_0F_FC */  0x40d7,
/* f06 -  */  0,
/* f07 -  */  0,
/* f08 -  */  0,
/* f09 -  */  0,
/* f0a -  */  0,
/* f0b -  */  0,
/* f0c - _0F_FD */  0x246d,
/* f0d - _66_0F_FD */  0x246e,
/* f0e -  */  0,
/* f0f -  */  0,
/* f10 -  */  0,
/* f11 - _V_66_0F_FD */  0x40d8,
/* f12 -  */  0,
/* f13 -  */  0,
/* f14 -  */  0,
/* f15 -  */  0,
/* f16 -  */  0,
/* f17 -  */  0,
/* f18 - _0F_FE */  0x246f,
/* f19 - _66_0F_FE */  0x2470,
/* f1a -  */  0,
/* f1b -  */  0,
/* f1c -  */  0,
/* f1d - _V_66_0F_FE */  0x40d9,
/* f1e -  */  0,
/* f1f -  */  0,
/* f20 -  */  0,
/* f21 -  */  0,
/* f22 -  */  0,
/* f23 -  */  0,
/* f24 - _D9_06 */  0x2471,
/* f25 - _9B_D9_06 */  0x2472,
/* f26 -  */  0,
/* f27 -  */  0,
/* f28 -  */  0,
/* f29 -  */  0,
/* f2a -  */  0,
/* f2b -  */  0,
/* f2c -  */  0,
/* f2d -  */  0,
/* f2e -  */  0,
/* f2f -  */  0,
/* f30 - _D9_07 */  0x2473,
/* f31 - _9B_D9_07 */  0x2474,
/* f32 -  */  0,
/* f33 -  */  0,
/* f34 -  */  0,
/* f35 -  */  0,
/* f36 -  */  0,
/* f37 -  */  0,
/* f38 -  */  0,
/* f39 -  */  0,
/* f3a -  */  0,
/* f3b -  */  0,
/* f3c - _DB_E2 */  0x2475,
/* f3d - _9B_DB_E2 */  0x2476,
/* f3e -  */  0,
/* f3f -  */  0,
/* f40 -  */  0,
/* f41 -  */  0,
/* f42 -  */  0,
/* f43 -  */  0,
/* f44 -  */  0,
/* f45 -  */  0,
/* f46 -  */  0,
/* f47 -  */  0,
/* f48 - _DB_E3 */  0x2477,
/* f49 - _9B_DB_E3 */  0x2478,
/* f4a -  */  0,
/* f4b -  */  0,
/* f4c -  */  0,
/* f4d -  */  0,
/* f4e -  */  0,
/* f4f -  */  0,
/* f50 -  */  0,
/* f51 -  */  0,
/* f52 -  */  0,
/* f53 -  */  0,
/* f54 - _DD_06 */  0x2479,
/* f55 - _9B_DD_06 */  0x247a,
/* f56 -  */  0,
/* f57 -  */  0,
/* f58 -  */  0,
/* f59 -  */  0,
/* f5a -  */  0,
/* f5b -  */  0,
/* f5c -  */  0,
/* f5d -  */  0,
/* f5e -  */  0,
/* f5f -  */  0,
/* f60 - _DD_07 */  0x247b,
/* f61 - _9B_DD_07 */  0x247c,
/* f62 -  */  0,
/* f63 -  */  0,
/* f64 -  */  0,
/* f65 -  */  0,
/* f66 -  */  0,
/* f67 -  */  0,
/* f68 -  */  0,
/* f69 -  */  0,
/* f6a -  */  0,
/* f6b -  */  0,
/* f6c - _DF_E0 */  0x247d,
/* f6d - _9B_DF_E0 */  0x247e,
/* f6e -  */  0,
/* f6f -  */  0,
/* f70 -  */  0,
/* f71 -  */  0,
/* f72 -  */  0,
/* f73 -  */  0,
/* f74 -  */  0,
/* f75 -  */  0,
/* f76 -  */  0,
/* f77 -  */  0,
/* f78 - _0F_38_00 */  0x247f,
/* f79 - _66_0F_38_00 */  0x2480,
/* f7a -  */  0,
/* f7b -  */  0,
/* f7c -  */  0,
/* f7d - _V_66_0F_38_00 */  0x40da,
/* f7e -  */  0,
/* f7f -  */  0,
/* f80 -  */  0,
/* f81 -  */  0,
/* f82 -  */  0,
/* f83 -  */  0,
/* f84 - _0F_38_01 */  0x2481,
/* f85 - _66_0F_38_01 */  0x2482,
/* f86 -  */  0,
/* f87 -  */  0,
/* f88 -  */  0,
/* f89 - _V_66_0F_38_01 */  0x40db,
/* f8a -  */  0,
/* f8b -  */  0,
/* f8c -  */  0,
/* f8d -  */  0,
/* f8e -  */  0,
/* f8f -  */  0,
/* f90 - _0F_38_02 */  0x2483,
/* f91 - _66_0F_38_02 */  0x2484,
/* f92 -  */  0,
/* f93 -  */  0,
/* f94 -  */  0,
/* f95 - _V_66_0F_38_02 */  0x40dc,
/* f96 -  */  0,
/* f97 -  */  0,
/* f98 -  */  0,
/* f99 -  */  0,
/* f9a -  */  0,
/* f9b -  */  0,
/* f9c - _0F_38_03 */  0x2485,
/* f9d - _66_0F_38_03 */  0x2486,
/* f9e -  */  0,
/* f9f -  */  0,
/* fa0 -  */  0,
/* fa1 - _V_66_0F_38_03 */  0x40dd,
/* fa2 -  */  0,
/* fa3 -  */  0,
/* fa4 -  */  0,
/* fa5 -  */  0,
/* fa6 -  */  0,
/* fa7 -  */  0,
/* fa8 - _0F_38_04 */  0x2487,
/* fa9 - _66_0F_38_04 */  0x2488,
/* faa -  */  0,
/* fab -  */  0,
/* fac -  */  0,
/* fad - _V_66_0F_38_04 */  0x40de,
/* fae -  */  0,
/* faf -  */  0,
/* fb0 -  */  0,
/* fb1 -  */  0,
/* fb2 -  */  0,
/* fb3 -  */  0,
/* fb4 - _0F_38_05 */  0x2489,
/* fb5 - _66_0F_38_05 */  0x248a,
/* fb6 -  */  0,
/* fb7 -  */  0,
/* fb8 -  */  0,
/* fb9 - _V_66_0F_38_05 */  0x40df,
/* fba -  */  0,
/* fbb -  */  0,
/* fbc -  */  0,
/* fbd -  */  0,
/* fbe -  */  0,
/* fbf -  */  0,
/* fc0 - _0F_38_06 */  0x248b,
/* fc1 - _66_0F_38_06 */  0x248c,
/* fc2 -  */  0,
/* fc3 -  */  0,
/* fc4 -  */  0,
/* fc5 - _V_66_0F_38_06 */  0x40e0,
/* fc6 -  */  0,
/* fc7 -  */  0,
/* fc8 -  */  0,
/* fc9 -  */  0,
/* fca -  */  0,
/* fcb -  */  0,
/* fcc - _0F_38_07 */  0x248d,
/* fcd - _66_0F_38_07 */  0x248e,
/* fce -  */  0,
/* fcf -  */  0,
/* fd0 -  */  0,
/* fd1 - _V_66_0F_38_07 */  0x40e1,
/* fd2 -  */  0,
/* fd3 -  */  0,
/* fd4 -  */  0,
/* fd5 -  */  0,
/* fd6 -  */  0,
/* fd7 -  */  0,
/* fd8 - _0F_38_08 */  0x248f,
/* fd9 - _66_0F_38_08 */  0x2490,
/* fda -  */  0,
/* fdb -  */  0,
/* fdc -  */  0,
/* fdd - _V_66_0F_38_08 */  0x40e2,
/* fde -  */  0,
/* fdf -  */  0,
/* fe0 -  */  0,
/* fe1 -  */  0,
/* fe2 -  */  0,
/* fe3 -  */  0,
/* fe4 - _0F_38_09 */  0x2491,
/* fe5 - _66_0F_38_09 */  0x2492,
/* fe6 -  */  0,
/* fe7 -  */  0,
/* fe8 -  */  0,
/* fe9 - _V_66_0F_38_09 */  0x40e3,
/* fea -  */  0,
/* feb -  */  0,
/* fec -  */  0,
/* fed -  */  0,
/* fee -  */  0,
/* fef -  */  0,
/* ff0 - _0F_38_0A */  0x2493,
/* ff1 - _66_0F_38_0A */  0x2494,
/* ff2 -  */  0,
/* ff3 -  */  0,
/* ff4 -  */  0,
/* ff5 - _V_66_0F_38_0A */  0x40e4,
/* ff6 -  */  0,
/* ff7 -  */  0,
/* ff8 -  */  0,
/* ff9 -  */  0,
/* ffa -  */  0,
/* ffb -  */  0,
/* ffc - _0F_38_0B */  0x2495,
/* ffd - _66_0F_38_0B */  0x2496,
/* ffe -  */  0,
/* fff -  */  0,
/* 1000 -  */  0,
/* 1001 - _V_66_0F_38_0B */  0x40e5,
/* 1002 -  */  0,
/* 1003 -  */  0,
/* 1004 -  */  0,
/* 1005 -  */  0,
/* 1006 -  */  0,
/* 1007 -  */  0,
/* 1008 -  */  0,
/* 1009 -  */  0,
/* 100a -  */  0,
/* 100b -  */  0,
/* 100c -  */  0,
/* 100d - _V_66_0F_38_0C */  0x40e6,
/* 100e -  */  0,
/* 100f -  */  0,
/* 1010 -  */  0,
/* 1011 -  */  0,
/* 1012 -  */  0,
/* 1013 -  */  0,
/* 1014 -  */  0,
/* 1015 -  */  0,
/* 1016 -  */  0,
/* 1017 -  */  0,
/* 1018 -  */  0,
/* 1019 - _V_66_0F_38_0D */  0x40e7,
/* 101a -  */  0,
/* 101b -  */  0,
/* 101c -  */  0,
/* 101d -  */  0,
/* 101e -  */  0,
/* 101f -  */  0,
/* 1020 -  */  0,
/* 1021 -  */  0,
/* 1022 -  */  0,
/* 1023 -  */  0,
/* 1024 -  */  0,
/* 1025 - _V_66_0F_38_0E */  0x40e8,
/* 1026 -  */  0,
/* 1027 -  */  0,
/* 1028 -  */  0,
/* 1029 -  */  0,
/* 102a -  */  0,
/* 102b -  */  0,
/* 102c -  */  0,
/* 102d -  */  0,
/* 102e -  */  0,
/* 102f -  */  0,
/* 1030 -  */  0,
/* 1031 - _V_66_0F_38_0F */  0x40e9,
/* 1032 -  */  0,
/* 1033 -  */  0,
/* 1034 -  */  0,
/* 1035 -  */  0,
/* 1036 -  */  0,
/* 1037 -  */  0,
/* 1038 -  */  0,
/* 1039 - _66_0F_38_10 */  0x40ea,
/* 103a -  */  0,
/* 103b -  */  0,
/* 103c -  */  0,
/* 103d -  */  0,
/* 103e -  */  0,
/* 103f -  */  0,
/* 1040 -  */  0,
/* 1041 -  */  0,
/* 1042 -  */  0,
/* 1043 -  */  0,
/* 1044 -  */  0,
/* 1045 - _66_0F_38_14 */  0x40eb,
/* 1046 -  */  0,
/* 1047 -  */  0,
/* 1048 -  */  0,
/* 1049 -  */  0,
/* 104a -  */  0,
/* 104b -  */  0,
/* 104c -  */  0,
/* 104d -  */  0,
/* 104e -  */  0,
/* 104f -  */  0,
/* 1050 -  */  0,
/* 1051 - _66_0F_38_15 */  0x40ec,
/* 1052 -  */  0,
/* 1053 -  */  0,
/* 1054 -  */  0,
/* 1055 -  */  0,
/* 1056 -  */  0,
/* 1057 -  */  0,
/* 1058 -  */  0,
/* 1059 -  */  0,
/* 105a -  */  0,
/* 105b -  */  0,
/* 105c -  */  0,
/* 105d - _66_0F_38_17 */  0x2497,
/* 105e -  */  0,
/* 105f -  */  0,
/* 1060 -  */  0,
/* 1061 - _V_66_0F_38_17 */  0x40ed,
/* 1062 -  */  0,
/* 1063 -  */  0,
/* 1064 -  */  0,
/* 1065 -  */  0,
/* 1066 -  */  0,
/* 1067 -  */  0,
/* 1068 -  */  0,
/* 1069 -  */  0,
/* 106a -  */  0,
/* 106b -  */  0,
/* 106c -  */  0,
/* 106d - _V_66_0F_38_18 */  0x40ee,
/* 106e -  */  0,
/* 106f -  */  0,
/* 1070 -  */  0,
/* 1071 -  */  0,
/* 1072 -  */  0,
/* 1073 -  */  0,
/* 1074 -  */  0,
/* 1075 -  */  0,
/* 1076 -  */  0,
/* 1077 -  */  0,
/* 1078 -  */  0,
/* 1079 - _V_66_0F_38_19 */  0x40ef,
/* 107a -  */  0,
/* 107b -  */  0,
/* 107c -  */  0,
/* 107d -  */  0,
/* 107e -  */  0,
/* 107f -  */  0,
/* 1080 -  */  0,
/* 1081 -  */  0,
/* 1082 -  */  0,
/* 1083 -  */  0,
/* 1084 -  */  0,
/* 1085 - _V_66_0F_38_1A */  0x40f0,
/* 1086 -  */  0,
/* 1087 -  */  0,
/* 1088 -  */  0,
/* 1089 -  */  0,
/* 108a -  */  0,
/* 108b -  */  0,
/* 108c - _0F_38_1C */  0x2498,
/* 108d - _66_0F_38_1C */  0x2499,
/* 108e -  */  0,
/* 108f -  */  0,
/* 1090 -  */  0,
/* 1091 - _V_66_0F_38_1C */  0x40f1,
/* 1092 -  */  0,
/* 1093 -  */  0,
/* 1094 -  */  0,
/* 1095 -  */  0,
/* 1096 -  */  0,
/* 1097 -  */  0,
/* 1098 - _0F_38_1D */  0x249a,
/* 1099 - _66_0F_38_1D */  0x249b,
/* 109a -  */  0,
/* 109b -  */  0,
/* 109c -  */  0,
/* 109d - _V_66_0F_38_1D */  0x40f2,
/* 109e -  */  0,
/* 109f -  */  0,
/* 10a0 -  */  0,
/* 10a1 -  */  0,
/* 10a2 -  */  0,
/* 10a3 -  */  0,
/* 10a4 - _0F_38_1E */  0x249c,
/* 10a5 - _66_0F_38_1E */  0x249d,
/* 10a6 -  */  0,
/* 10a7 -  */  0,
/* 10a8 -  */  0,
/* 10a9 - _V_66_0F_38_1E */  0x40f3,
/* 10aa -  */  0,
/* 10ab -  */  0,
/* 10ac -  */  0,
/* 10ad -  */  0,
/* 10ae -  */  0,
/* 10af -  */  0,
/* 10b0 -  */  0,
/* 10b1 - _66_0F_38_20 */  0x249e,
/* 10b2 -  */  0,
/* 10b3 -  */  0,
/* 10b4 -  */  0,
/* 10b5 - _V_66_0F_38_20 */  0x40f4,
/* 10b6 -  */  0,
/* 10b7 -  */  0,
/* 10b8 -  */  0,
/* 10b9 -  */  0,
/* 10ba -  */  0,
/* 10bb -  */  0,
/* 10bc -  */  0,
/* 10bd - _66_0F_38_21 */  0x249f,
/* 10be -  */  0,
/* 10bf -  */  0,
/* 10c0 -  */  0,
/* 10c1 - _V_66_0F_38_21 */  0x40f5,
/* 10c2 -  */  0,
/* 10c3 -  */  0,
/* 10c4 -  */  0,
/* 10c5 -  */  0,
/* 10c6 -  */  0,
/* 10c7 -  */  0,
/* 10c8 -  */  0,
/* 10c9 - _66_0F_38_22 */  0x24a0,
/* 10ca -  */  0,
/* 10cb -  */  0,
/* 10cc -  */  0,
/* 10cd - _V_66_0F_38_22 */  0x40f6,
/* 10ce -  */  0,
/* 10cf -  */  0,
/* 10d0 -  */  0,
/* 10d1 -  */  0,
/* 10d2 -  */  0,
/* 10d3 -  */  0,
/* 10d4 -  */  0,
/* 10d5 - _66_0F_38_23 */  0x24a1,
/* 10d6 -  */  0,
/* 10d7 -  */  0,
/* 10d8 -  */  0,
/* 10d9 - _V_66_0F_38_23 */  0x40f7,
/* 10da -  */  0,
/* 10db -  */  0,
/* 10dc -  */  0,
/* 10dd -  */  0,
/* 10de -  */  0,
/* 10df -  */  0,
/* 10e0 -  */  0,
/* 10e1 - _66_0F_38_24 */  0x24a2,
/* 10e2 -  */  0,
/* 10e3 -  */  0,
/* 10e4 -  */  0,
/* 10e5 - _V_66_0F_38_24 */  0x40f8,
/* 10e6 -  */  0,
/* 10e7 -  */  0,
/* 10e8 -  */  0,
/* 10e9 -  */  0,
/* 10ea -  */  0,
/* 10eb -  */  0,
/* 10ec -  */  0,
/* 10ed - _66_0F_38_25 */  0x24a3,
/* 10ee -  */  0,
/* 10ef -  */  0,
/* 10f0 -  */  0,
/* 10f1 - _V_66_0F_38_25 */  0x40f9,
/* 10f2 -  */  0,
/* 10f3 -  */  0,
/* 10f4 -  */  0,
/* 10f5 -  */  0,
/* 10f6 -  */  0,
/* 10f7 -  */  0,
/* 10f8 -  */  0,
/* 10f9 - _66_0F_38_28 */  0x24a4,
/* 10fa -  */  0,
/* 10fb -  */  0,
/* 10fc -  */  0,
/* 10fd - _V_66_0F_38_28 */  0x40fa,
/* 10fe -  */  0,
/* 10ff -  */  0,
/* 1100 -  */  0,
/* 1101 -  */  0,
/* 1102 -  */  0,
/* 1103 -  */  0,
/* 1104 -  */  0,
/* 1105 - _66_0F_38_29 */  0x24a5,
/* 1106 -  */  0,
/* 1107 -  */  0,
/* 1108 -  */  0,
/* 1109 - _V_66_0F_38_29 */  0x40fb,
/* 110a -  */  0,
/* 110b -  */  0,
/* 110c -  */  0,
/* 110d -  */  0,
/* 110e -  */  0,
/* 110f -  */  0,
/* 1110 -  */  0,
/* 1111 - _66_0F_38_2A */  0x24a6,
/* 1112 -  */  0,
/* 1113 -  */  0,
/* 1114 -  */  0,
/* 1115 - _V_66_0F_38_2A */  0x40fc,
/* 1116 -  */  0,
/* 1117 -  */  0,
/* 1118 -  */  0,
/* 1119 -  */  0,
/* 111a -  */  0,
/* 111b -  */  0,
/* 111c -  */  0,
/* 111d - _66_0F_38_2B */  0x24a7,
/* 111e -  */  0,
/* 111f -  */  0,
/* 1120 -  */  0,
/* 1121 - _V_66_0F_38_2B */  0x40fd,
/* 1122 -  */  0,
/* 1123 -  */  0,
/* 1124 -  */  0,
/* 1125 -  */  0,
/* 1126 -  */  0,
/* 1127 -  */  0,
/* 1128 -  */  0,
/* 1129 -  */  0,
/* 112a -  */  0,
/* 112b -  */  0,
/* 112c -  */  0,
/* 112d - _V_66_0F_38_2C */  0x40fe,
/* 112e -  */  0,
/* 112f -  */  0,
/* 1130 -  */  0,
/* 1131 -  */  0,
/* 1132 -  */  0,
/* 1133 -  */  0,
/* 1134 -  */  0,
/* 1135 -  */  0,
/* 1136 -  */  0,
/* 1137 -  */  0,
/* 1138 -  */  0,
/* 1139 - _V_66_0F_38_2D */  0x40ff,
/* 113a -  */  0,
/* 113b -  */  0,
/* 113c -  */  0,
/* 113d -  */  0,
/* 113e -  */  0,
/* 113f -  */  0,
/* 1140 -  */  0,
/* 1141 -  */  0,
/* 1142 -  */  0,
/* 1143 -  */  0,
/* 1144 -  */  0,
/* 1145 - _V_66_0F_38_2E */  0x4100,
/* 1146 -  */  0,
/* 1147 -  */  0,
/* 1148 -  */  0,
/* 1149 -  */  0,
/* 114a -  */  0,
/* 114b -  */  0,
/* 114c -  */  0,
/* 114d -  */  0,
/* 114e -  */  0,
/* 114f -  */  0,
/* 1150 -  */  0,
/* 1151 - _V_66_0F_38_2F */  0x4101,
/* 1152 -  */  0,
/* 1153 -  */  0,
/* 1154 -  */  0,
/* 1155 -  */  0,
/* 1156 -  */  0,
/* 1157 -  */  0,
/* 1158 -  */  0,
/* 1159 - _66_0F_38_30 */  0x24a8,
/* 115a -  */  0,
/* 115b -  */  0,
/* 115c -  */  0,
/* 115d - _V_66_0F_38_30 */  0x4102,
/* 115e -  */  0,
/* 115f -  */  0,
/* 1160 -  */  0,
/* 1161 -  */  0,
/* 1162 -  */  0,
/* 1163 -  */  0,
/* 1164 -  */  0,
/* 1165 - _66_0F_38_31 */  0x24a9,
/* 1166 -  */  0,
/* 1167 -  */  0,
/* 1168 -  */  0,
/* 1169 - _V_66_0F_38_31 */  0x4103,
/* 116a -  */  0,
/* 116b -  */  0,
/* 116c -  */  0,
/* 116d -  */  0,
/* 116e -  */  0,
/* 116f -  */  0,
/* 1170 -  */  0,
/* 1171 - _66_0F_38_32 */  0x24aa,
/* 1172 -  */  0,
/* 1173 -  */  0,
/* 1174 -  */  0,
/* 1175 - _V_66_0F_38_32 */  0x4104,
/* 1176 -  */  0,
/* 1177 -  */  0,
/* 1178 -  */  0,
/* 1179 -  */  0,
/* 117a -  */  0,
/* 117b -  */  0,
/* 117c -  */  0,
/* 117d - _66_0F_38_33 */  0x24ab,
/* 117e -  */  0,
/* 117f -  */  0,
/* 1180 -  */  0,
/* 1181 - _V_66_0F_38_33 */  0x4105,
/* 1182 -  */  0,
/* 1183 -  */  0,
/* 1184 -  */  0,
/* 1185 -  */  0,
/* 1186 -  */  0,
/* 1187 -  */  0,
/* 1188 -  */  0,
/* 1189 - _66_0F_38_34 */  0x24ac,
/* 118a -  */  0,
/* 118b -  */  0,
/* 118c -  */  0,
/* 118d - _V_66_0F_38_34 */  0x4106,
/* 118e -  */  0,
/* 118f -  */  0,
/* 1190 -  */  0,
/* 1191 -  */  0,
/* 1192 -  */  0,
/* 1193 -  */  0,
/* 1194 -  */  0,
/* 1195 - _66_0F_38_35 */  0x24ad,
/* 1196 -  */  0,
/* 1197 -  */  0,
/* 1198 -  */  0,
/* 1199 - _V_66_0F_38_35 */  0x4107,
/* 119a -  */  0,
/* 119b -  */  0,
/* 119c -  */  0,
/* 119d -  */  0,
/* 119e -  */  0,
/* 119f -  */  0,
/* 11a0 -  */  0,
/* 11a1 - _66_0F_38_37 */  0x24ae,
/* 11a2 -  */  0,
/* 11a3 -  */  0,
/* 11a4 -  */  0,
/* 11a5 - _V_66_0F_38_37 */  0x4108,
/* 11a6 -  */  0,
/* 11a7 -  */  0,
/* 11a8 -  */  0,
/* 11a9 -  */  0,
/* 11aa -  */  0,
/* 11ab -  */  0,
/* 11ac -  */  0,
/* 11ad - _66_0F_38_38 */  0x24af,
/* 11ae -  */  0,
/* 11af -  */  0,
/* 11b0 -  */  0,
/* 11b1 - _V_66_0F_38_38 */  0x4109,
/* 11b2 -  */  0,
/* 11b3 -  */  0,
/* 11b4 -  */  0,
/* 11b5 -  */  0,
/* 11b6 -  */  0,
/* 11b7 -  */  0,
/* 11b8 -  */  0,
/* 11b9 - _66_0F_38_39 */  0x24b0,
/* 11ba -  */  0,
/* 11bb -  */  0,
/* 11bc -  */  0,
/* 11bd - _V_66_0F_38_39 */  0x410a,
/* 11be -  */  0,
/* 11bf -  */  0,
/* 11c0 -  */  0,
/* 11c1 -  */  0,
/* 11c2 -  */  0,
/* 11c3 -  */  0,
/* 11c4 -  */  0,
/* 11c5 - _66_0F_38_3A */  0x24b1,
/* 11c6 -  */  0,
/* 11c7 -  */  0,
/* 11c8 -  */  0,
/* 11c9 - _V_66_0F_38_3A */  0x410b,
/* 11ca -  */  0,
/* 11cb -  */  0,
/* 11cc -  */  0,
/* 11cd -  */  0,
/* 11ce -  */  0,
/* 11cf -  */  0,
/* 11d0 -  */  0,
/* 11d1 - _66_0F_38_3B */  0x24b2,
/* 11d2 -  */  0,
/* 11d3 -  */  0,
/* 11d4 -  */  0,
/* 11d5 - _V_66_0F_38_3B */  0x410c,
/* 11d6 -  */  0,
/* 11d7 -  */  0,
/* 11d8 -  */  0,
/* 11d9 -  */  0,
/* 11da -  */  0,
/* 11db -  */  0,
/* 11dc -  */  0,
/* 11dd - _66_0F_38_3C */  0x24b3,
/* 11de -  */  0,
/* 11df -  */  0,
/* 11e0 -  */  0,
/* 11e1 - _V_66_0F_38_3C */  0x410d,
/* 11e2 -  */  0,
/* 11e3 -  */  0,
/* 11e4 -  */  0,
/* 11e5 -  */  0,
/* 11e6 -  */  0,
/* 11e7 -  */  0,
/* 11e8 -  */  0,
/* 11e9 - _66_0F_38_3D */  0x24b4,
/* 11ea -  */  0,
/* 11eb -  */  0,
/* 11ec -  */  0,
/* 11ed - _V_66_0F_38_3D */  0x410e,
/* 11ee -  */  0,
/* 11ef -  */  0,
/* 11f0 -  */  0,
/* 11f1 -  */  0,
/* 11f2 -  */  0,
/* 11f3 -  */  0,
/* 11f4 -  */  0,
/* 11f5 - _66_0F_38_3E */  0x24b5,
/* 11f6 -  */  0,
/* 11f7 -  */  0,
/* 11f8 -  */  0,
/* 11f9 - _V_66_0F_38_3E */  0x410f,
/* 11fa -  */  0,
/* 11fb -  */  0,
/* 11fc -  */  0,
/* 11fd -  */  0,
/* 11fe -  */  0,
/* 11ff -  */  0,
/* 1200 -  */  0,
/* 1201 - _66_0F_38_3F */  0x24b6,
/* 1202 -  */  0,
/* 1203 -  */  0,
/* 1204 -  */  0,
/* 1205 - _V_66_0F_38_3F */  0x4110,
/* 1206 -  */  0,
/* 1207 -  */  0,
/* 1208 -  */  0,
/* 1209 -  */  0,
/* 120a -  */  0,
/* 120b -  */  0,
/* 120c -  */  0,
/* 120d - _66_0F_38_40 */  0x24b7,
/* 120e -  */  0,
/* 120f -  */  0,
/* 1210 -  */  0,
/* 1211 - _V_66_0F_38_40 */  0x4111,
/* 1212 -  */  0,
/* 1213 -  */  0,
/* 1214 -  */  0,
/* 1215 -  */  0,
/* 1216 -  */  0,
/* 1217 -  */  0,
/* 1218 -  */  0,
/* 1219 - _66_0F_38_41 */  0x24b8,
/* 121a -  */  0,
/* 121b -  */  0,
/* 121c -  */  0,
/* 121d - _V_66_0F_38_41 */  0x4112,
/* 121e -  */  0,
/* 121f -  */  0,
/* 1220 -  */  0,
/* 1221 -  */  0,
/* 1222 -  */  0,
/* 1223 -  */  0,
/* 1224 -  */  0,
/* 1225 - _66_0F_38_80 */  0x24b9,
/* 1226 -  */  0,
/* 1227 -  */  0,
/* 1228 -  */  0,
/* 1229 -  */  0,
/* 122a -  */  0,
/* 122b -  */  0,
/* 122c -  */  0,
/* 122d -  */  0,
/* 122e -  */  0,
/* 122f -  */  0,
/* 1230 -  */  0,
/* 1231 - _66_0F_38_81 */  0x24ba,
/* 1232 -  */  0,
/* 1233 -  */  0,
/* 1234 -  */  0,
/* 1235 -  */  0,
/* 1236 -  */  0,
/* 1237 -  */  0,
/* 1238 -  */  0,
/* 1239 -  */  0,
/* 123a -  */  0,
/* 123b -  */  0,
/* 123c -  */  0,
/* 123d - _66_0F_38_82 */  0x24bb,
/* 123e -  */  0,
/* 123f -  */  0,
/* 1240 -  */  0,
/* 1241 -  */  0,
/* 1242 -  */  0,
/* 1243 -  */  0,
/* 1244 -  */  0,
/* 1245 -  */  0,
/* 1246 -  */  0,
/* 1247 -  */  0,
/* 1248 -  */  0,
/* 1249 -  */  0,
/* 124a -  */  0,
/* 124b -  */  0,
/* 124c -  */  0,
/* 124d - _V_66_0F_38_96 */  0x4113,
/* 124e -  */  0,
/* 124f -  */  0,
/* 1250 -  */  0,
/* 1251 -  */  0,
/* 1252 -  */  0,
/* 1253 -  */  0,
/* 1254 -  */  0,
/* 1255 -  */  0,
/* 1256 -  */  0,
/* 1257 -  */  0,
/* 1258 -  */  0,
/* 1259 - _V_66_0F_38_97 */  0x4114,
/* 125a -  */  0,
/* 125b -  */  0,
/* 125c -  */  0,
/* 125d -  */  0,
/* 125e -  */  0,
/* 125f -  */  0,
/* 1260 -  */  0,
/* 1261 -  */  0,
/* 1262 -  */  0,
/* 1263 -  */  0,
/* 1264 -  */  0,
/* 1265 - _V_66_0F_38_98 */  0x4115,
/* 1266 -  */  0,
/* 1267 -  */  0,
/* 1268 -  */  0,
/* 1269 -  */  0,
/* 126a -  */  0,
/* 126b -  */  0,
/* 126c -  */  0,
/* 126d -  */  0,
/* 126e -  */  0,
/* 126f -  */  0,
/* 1270 -  */  0,
/* 1271 - _V_66_0F_38_99 */  0x4116,
/* 1272 -  */  0,
/* 1273 -  */  0,
/* 1274 -  */  0,
/* 1275 -  */  0,
/* 1276 -  */  0,
/* 1277 -  */  0,
/* 1278 -  */  0,
/* 1279 -  */  0,
/* 127a -  */  0,
/* 127b -  */  0,
/* 127c -  */  0,
/* 127d - _V_66_0F_38_9A */  0x4117,
/* 127e -  */  0,
/* 127f -  */  0,
/* 1280 -  */  0,
/* 1281 -  */  0,
/* 1282 -  */  0,
/* 1283 -  */  0,
/* 1284 -  */  0,
/* 1285 -  */  0,
/* 1286 -  */  0,
/* 1287 -  */  0,
/* 1288 -  */  0,
/* 1289 - _V_66_0F_38_9B */  0x4118,
/* 128a -  */  0,
/* 128b -  */  0,
/* 128c -  */  0,
/* 128d -  */  0,
/* 128e -  */  0,
/* 128f -  */  0,
/* 1290 -  */  0,
/* 1291 -  */  0,
/* 1292 -  */  0,
/* 1293 -  */  0,
/* 1294 -  */  0,
/* 1295 - _V_66_0F_38_9C */  0x4119,
/* 1296 -  */  0,
/* 1297 -  */  0,
/* 1298 -  */  0,
/* 1299 -  */  0,
/* 129a -  */  0,
/* 129b -  */  0,
/* 129c -  */  0,
/* 129d -  */  0,
/* 129e -  */  0,
/* 129f -  */  0,
/* 12a0 -  */  0,
/* 12a1 - _V_66_0F_38_9D */  0x411a,
/* 12a2 -  */  0,
/* 12a3 -  */  0,
/* 12a4 -  */  0,
/* 12a5 -  */  0,
/* 12a6 -  */  0,
/* 12a7 -  */  0,
/* 12a8 -  */  0,
/* 12a9 -  */  0,
/* 12aa -  */  0,
/* 12ab -  */  0,
/* 12ac -  */  0,
/* 12ad - _V_66_0F_38_9E */  0x411b,
/* 12ae -  */  0,
/* 12af -  */  0,
/* 12b0 -  */  0,
/* 12b1 -  */  0,
/* 12b2 -  */  0,
/* 12b3 -  */  0,
/* 12b4 -  */  0,
/* 12b5 -  */  0,
/* 12b6 -  */  0,
/* 12b7 -  */  0,
/* 12b8 -  */  0,
/* 12b9 - _V_66_0F_38_9F */  0x411c,
/* 12ba -  */  0,
/* 12bb -  */  0,
/* 12bc -  */  0,
/* 12bd -  */  0,
/* 12be -  */  0,
/* 12bf -  */  0,
/* 12c0 -  */  0,
/* 12c1 -  */  0,
/* 12c2 -  */  0,
/* 12c3 -  */  0,
/* 12c4 -  */  0,
/* 12c5 - _V_66_0F_38_A6 */  0x411d,
/* 12c6 -  */  0,
/* 12c7 -  */  0,
/* 12c8 -  */  0,
/* 12c9 -  */  0,
/* 12ca -  */  0,
/* 12cb -  */  0,
/* 12cc -  */  0,
/* 12cd -  */  0,
/* 12ce -  */  0,
/* 12cf -  */  0,
/* 12d0 -  */  0,
/* 12d1 - _V_66_0F_38_A7 */  0x411e,
/* 12d2 -  */  0,
/* 12d3 -  */  0,
/* 12d4 -  */  0,
/* 12d5 -  */  0,
/* 12d6 -  */  0,
/* 12d7 -  */  0,
/* 12d8 -  */  0,
/* 12d9 -  */  0,
/* 12da -  */  0,
/* 12db -  */  0,
/* 12dc -  */  0,
/* 12dd - _V_66_0F_38_A8 */  0x411f,
/* 12de -  */  0,
/* 12df -  */  0,
/* 12e0 -  */  0,
/* 12e1 -  */  0,
/* 12e2 -  */  0,
/* 12e3 -  */  0,
/* 12e4 -  */  0,
/* 12e5 -  */  0,
/* 12e6 -  */  0,
/* 12e7 -  */  0,
/* 12e8 -  */  0,
/* 12e9 - _V_66_0F_38_A9 */  0x4120,
/* 12ea -  */  0,
/* 12eb -  */  0,
/* 12ec -  */  0,
/* 12ed -  */  0,
/* 12ee -  */  0,
/* 12ef -  */  0,
/* 12f0 -  */  0,
/* 12f1 -  */  0,
/* 12f2 -  */  0,
/* 12f3 -  */  0,
/* 12f4 -  */  0,
/* 12f5 - _V_66_0F_38_AA */  0x4121,
/* 12f6 -  */  0,
/* 12f7 -  */  0,
/* 12f8 -  */  0,
/* 12f9 -  */  0,
/* 12fa -  */  0,
/* 12fb -  */  0,
/* 12fc -  */  0,
/* 12fd -  */  0,
/* 12fe -  */  0,
/* 12ff -  */  0,
/* 1300 -  */  0,
/* 1301 - _V_66_0F_38_AB */  0x4122,
/* 1302 -  */  0,
/* 1303 -  */  0,
/* 1304 -  */  0,
/* 1305 -  */  0,
/* 1306 -  */  0,
/* 1307 -  */  0,
/* 1308 -  */  0,
/* 1309 -  */  0,
/* 130a -  */  0,
/* 130b -  */  0,
/* 130c -  */  0,
/* 130d - _V_66_0F_38_AC */  0x4123,
/* 130e -  */  0,
/* 130f -  */  0,
/* 1310 -  */  0,
/* 1311 -  */  0,
/* 1312 -  */  0,
/* 1313 -  */  0,
/* 1314 -  */  0,
/* 1315 -  */  0,
/* 1316 -  */  0,
/* 1317 -  */  0,
/* 1318 -  */  0,
/* 1319 - _V_66_0F_38_AD */  0x4124,
/* 131a -  */  0,
/* 131b -  */  0,
/* 131c -  */  0,
/* 131d -  */  0,
/* 131e -  */  0,
/* 131f -  */  0,
/* 1320 -  */  0,
/* 1321 -  */  0,
/* 1322 -  */  0,
/* 1323 -  */  0,
/* 1324 -  */  0,
/* 1325 - _V_66_0F_38_AE */  0x4125,
/* 1326 -  */  0,
/* 1327 -  */  0,
/* 1328 -  */  0,
/* 1329 -  */  0,
/* 132a -  */  0,
/* 132b -  */  0,
/* 132c -  */  0,
/* 132d -  */  0,
/* 132e -  */  0,
/* 132f -  */  0,
/* 1330 -  */  0,
/* 1331 - _V_66_0F_38_AF */  0x4126,
/* 1332 -  */  0,
/* 1333 -  */  0,
/* 1334 -  */  0,
/* 1335 -  */  0,
/* 1336 -  */  0,
/* 1337 -  */  0,
/* 1338 -  */  0,
/* 1339 -  */  0,
/* 133a -  */  0,
/* 133b -  */  0,
/* 133c -  */  0,
/* 133d - _V_66_0F_38_B6 */  0x4127,
/* 133e -  */  0,
/* 133f -  */  0,
/* 1340 -  */  0,
/* 1341 -  */  0,
/* 1342 -  */  0,
/* 1343 -  */  0,
/* 1344 -  */  0,
/* 1345 -  */  0,
/* 1346 -  */  0,
/* 1347 -  */  0,
/* 1348 -  */  0,
/* 1349 - _V_66_0F_38_B7 */  0x4128,
/* 134a -  */  0,
/* 134b -  */  0,
/* 134c -  */  0,
/* 134d -  */  0,
/* 134e -  */  0,
/* 134f -  */  0,
/* 1350 -  */  0,
/* 1351 -  */  0,
/* 1352 -  */  0,
/* 1353 -  */  0,
/* 1354 -  */  0,
/* 1355 - _V_66_0F_38_B8 */  0x4129,
/* 1356 -  */  0,
/* 1357 -  */  0,
/* 1358 -  */  0,
/* 1359 -  */  0,
/* 135a -  */  0,
/* 135b -  */  0,
/* 135c -  */  0,
/* 135d -  */  0,
/* 135e -  */  0,
/* 135f -  */  0,
/* 1360 -  */  0,
/* 1361 - _V_66_0F_38_B9 */  0x412a,
/* 1362 -  */  0,
/* 1363 -  */  0,
/* 1364 -  */  0,
/* 1365 -  */  0,
/* 1366 -  */  0,
/* 1367 -  */  0,
/* 1368 -  */  0,
/* 1369 -  */  0,
/* 136a -  */  0,
/* 136b -  */  0,
/* 136c -  */  0,
/* 136d - _V_66_0F_38_BA */  0x412b,
/* 136e -  */  0,
/* 136f -  */  0,
/* 1370 -  */  0,
/* 1371 -  */  0,
/* 1372 -  */  0,
/* 1373 -  */  0,
/* 1374 -  */  0,
/* 1375 -  */  0,
/* 1376 -  */  0,
/* 1377 -  */  0,
/* 1378 -  */  0,
/* 1379 - _V_66_0F_38_BB */  0x412c,
/* 137a -  */  0,
/* 137b -  */  0,
/* 137c -  */  0,
/* 137d -  */  0,
/* 137e -  */  0,
/* 137f -  */  0,
/* 1380 -  */  0,
/* 1381 -  */  0,
/* 1382 -  */  0,
/* 1383 -  */  0,
/* 1384 -  */  0,
/* 1385 - _V_66_0F_38_BC */  0x412d,
/* 1386 -  */  0,
/* 1387 -  */  0,
/* 1388 -  */  0,
/* 1389 -  */  0,
/* 138a -  */  0,
/* 138b -  */  0,
/* 138c -  */  0,
/* 138d -  */  0,
/* 138e -  */  0,
/* 138f -  */  0,
/* 1390 -  */  0,
/* 1391 - _V_66_0F_38_BD */  0x412e,
/* 1392 -  */  0,
/* 1393 -  */  0,
/* 1394 -  */  0,
/* 1395 -  */  0,
/* 1396 -  */  0,
/* 1397 -  */  0,
/* 1398 -  */  0,
/* 1399 -  */  0,
/* 139a -  */  0,
/* 139b -  */  0,
/* 139c -  */  0,
/* 139d - _V_66_0F_38_BE */  0x412f,
/* 139e -  */  0,
/* 139f -  */  0,
/* 13a0 -  */  0,
/* 13a1 -  */  0,
/* 13a2 -  */  0,
/* 13a3 -  */  0,
/* 13a4 -  */  0,
/* 13a5 -  */  0,
/* 13a6 -  */  0,
/* 13a7 -  */  0,
/* 13a8 -  */  0,
/* 13a9 - _V_66_0F_38_BF */  0x4130,
/* 13aa -  */  0,
/* 13ab -  */  0,
/* 13ac -  */  0,
/* 13ad -  */  0,
/* 13ae -  */  0,
/* 13af -  */  0,
/* 13b0 -  */  0,
/* 13b1 - _66_0F_38_DB */  0x24bc,
/* 13b2 -  */  0,
/* 13b3 -  */  0,
/* 13b4 -  */  0,
/* 13b5 - _V_66_0F_38_DB */  0x4131,
/* 13b6 -  */  0,
/* 13b7 -  */  0,
/* 13b8 -  */  0,
/* 13b9 -  */  0,
/* 13ba -  */  0,
/* 13bb -  */  0,
/* 13bc -  */  0,
/* 13bd - _66_0F_38_DC */  0x24bd,
/* 13be -  */  0,
/* 13bf -  */  0,
/* 13c0 -  */  0,
/* 13c1 - _V_66_0F_38_DC */  0x4132,
/* 13c2 -  */  0,
/* 13c3 -  */  0,
/* 13c4 -  */  0,
/* 13c5 -  */  0,
/* 13c6 -  */  0,
/* 13c7 -  */  0,
/* 13c8 -  */  0,
/* 13c9 - _66_0F_38_DD */  0x24be,
/* 13ca -  */  0,
/* 13cb -  */  0,
/* 13cc -  */  0,
/* 13cd - _V_66_0F_38_DD */  0x4133,
/* 13ce -  */  0,
/* 13cf -  */  0,
/* 13d0 -  */  0,
/* 13d1 -  */  0,
/* 13d2 -  */  0,
/* 13d3 -  */  0,
/* 13d4 -  */  0,
/* 13d5 - _66_0F_38_DE */  0x24bf,
/* 13d6 -  */  0,
/* 13d7 -  */  0,
/* 13d8 -  */  0,
/* 13d9 - _V_66_0F_38_DE */  0x4134,
/* 13da -  */  0,
/* 13db -  */  0,
/* 13dc -  */  0,
/* 13dd -  */  0,
/* 13de -  */  0,
/* 13df -  */  0,
/* 13e0 -  */  0,
/* 13e1 - _66_0F_38_DF */  0x24c0,
/* 13e2 -  */  0,
/* 13e3 -  */  0,
/* 13e4 -  */  0,
/* 13e5 - _V_66_0F_38_DF */  0x4135,
/* 13e6 -  */  0,
/* 13e7 -  */  0,
/* 13e8 -  */  0,
/* 13e9 -  */  0,
/* 13ea -  */  0,
/* 13eb -  */  0,
/* 13ec - _0F_38_F0 */  0x24c1,
/* 13ed -  */  0,
/* 13ee -  */  0,
/* 13ef - _F2_0F_38_F0 */  0x24c2,
/* 13f0 -  */  0,
/* 13f1 -  */  0,
/* 13f2 -  */  0,
/* 13f3 -  */  0,
/* 13f4 -  */  0,
/* 13f5 -  */  0,
/* 13f6 -  */  0,
/* 13f7 -  */  0,
/* 13f8 - _0F_38_F1 */  0x24c3,
/* 13f9 -  */  0,
/* 13fa -  */  0,
/* 13fb - _F2_0F_38_F1 */  0x24c4,
/* 13fc -  */  0,
/* 13fd -  */  0,
/* 13fe -  */  0,
/* 13ff -  */  0,
/* 1400 -  */  0,
/* 1401 -  */  0,
/* 1402 -  */  0,
/* 1403 -  */  0,
/* 1404 -  */  0,
/* 1405 -  */  0,
/* 1406 -  */  0,
/* 1407 -  */  0,
/* 1408 -  */  0,
/* 1409 - _V_66_0F_3A_04 */  0x4136,
/* 140a -  */  0,
/* 140b -  */  0,
/* 140c -  */  0,
/* 140d -  */  0,
/* 140e -  */  0,
/* 140f -  */  0,
/* 1410 -  */  0,
/* 1411 -  */  0,
/* 1412 -  */  0,
/* 1413 -  */  0,
/* 1414 -  */  0,
/* 1415 - _V_66_0F_3A_05 */  0x4137,
/* 1416 -  */  0,
/* 1417 -  */  0,
/* 1418 -  */  0,
/* 1419 -  */  0,
/* 141a -  */  0,
/* 141b -  */  0,
/* 141c -  */  0,
/* 141d -  */  0,
/* 141e -  */  0,
/* 141f -  */  0,
/* 1420 -  */  0,
/* 1421 - _V_66_0F_3A_06 */  0x4138,
/* 1422 -  */  0,
/* 1423 -  */  0,
/* 1424 -  */  0,
/* 1425 -  */  0,
/* 1426 -  */  0,
/* 1427 -  */  0,
/* 1428 -  */  0,
/* 1429 - _66_0F_3A_08 */  0x4139,
/* 142a -  */  0,
/* 142b -  */  0,
/* 142c -  */  0,
/* 142d - _V_66_0F_3A_08 */  0x413a,
/* 142e -  */  0,
/* 142f -  */  0,
/* 1430 -  */  0,
/* 1431 -  */  0,
/* 1432 -  */  0,
/* 1433 -  */  0,
/* 1434 -  */  0,
/* 1435 - _66_0F_3A_09 */  0x413b,
/* 1436 -  */  0,
/* 1437 -  */  0,
/* 1438 -  */  0,
/* 1439 - _V_66_0F_3A_09 */  0x413c,
/* 143a -  */  0,
/* 143b -  */  0,
/* 143c -  */  0,
/* 143d -  */  0,
/* 143e -  */  0,
/* 143f -  */  0,
/* 1440 -  */  0,
/* 1441 - _66_0F_3A_0A */  0x413d,
/* 1442 -  */  0,
/* 1443 -  */  0,
/* 1444 -  */  0,
/* 1445 - _V_66_0F_3A_0A */  0x413e,
/* 1446 -  */  0,
/* 1447 -  */  0,
/* 1448 -  */  0,
/* 1449 -  */  0,
/* 144a -  */  0,
/* 144b -  */  0,
/* 144c -  */  0,
/* 144d - _66_0F_3A_0B */  0x413f,
/* 144e -  */  0,
/* 144f -  */  0,
/* 1450 -  */  0,
/* 1451 - _V_66_0F_3A_0B */  0x4140,
/* 1452 -  */  0,
/* 1453 -  */  0,
/* 1454 -  */  0,
/* 1455 -  */  0,
/* 1456 -  */  0,
/* 1457 -  */  0,
/* 1458 -  */  0,
/* 1459 - _66_0F_3A_0C */  0x4141,
/* 145a -  */  0,
/* 145b -  */  0,
/* 145c -  */  0,
/* 145d - _V_66_0F_3A_0C */  0x4142,
/* 145e -  */  0,
/* 145f -  */  0,
/* 1460 -  */  0,
/* 1461 -  */  0,
/* 1462 -  */  0,
/* 1463 -  */  0,
/* 1464 -  */  0,
/* 1465 - _66_0F_3A_0D */  0x4143,
/* 1466 -  */  0,
/* 1467 -  */  0,
/* 1468 -  */  0,
/* 1469 - _V_66_0F_3A_0D */  0x4144,
/* 146a -  */  0,
/* 146b -  */  0,
/* 146c -  */  0,
/* 146d -  */  0,
/* 146e -  */  0,
/* 146f -  */  0,
/* 1470 -  */  0,
/* 1471 - _66_0F_3A_0E */  0x4145,
/* 1472 -  */  0,
/* 1473 -  */  0,
/* 1474 -  */  0,
/* 1475 - _V_66_0F_3A_0E */  0x4146,
/* 1476 -  */  0,
/* 1477 -  */  0,
/* 1478 -  */  0,
/* 1479 -  */  0,
/* 147a -  */  0,
/* 147b -  */  0,
/* 147c - _0F_3A_0F */  0x4147,
/* 147d - _66_0F_3A_0F */  0x4148,
/* 147e -  */  0,
/* 147f -  */  0,
/* 1480 -  */  0,
/* 1481 - _V_66_0F_3A_0F */  0x4149,
/* 1482 -  */  0,
/* 1483 -  */  0,
/* 1484 -  */  0,
/* 1485 -  */  0,
/* 1486 -  */  0,
/* 1487 -  */  0,
/* 1488 -  */  0,
/* 1489 - _66_0F_3A_14 */  0x414a,
/* 148a -  */  0,
/* 148b -  */  0,
/* 148c -  */  0,
/* 148d - _V_66_0F_3A_14 */  0x414b,
/* 148e -  */  0,
/* 148f -  */  0,
/* 1490 -  */  0,
/* 1491 -  */  0,
/* 1492 -  */  0,
/* 1493 -  */  0,
/* 1494 -  */  0,
/* 1495 - _66_0F_3A_15 */  0x414c,
/* 1496 -  */  0,
/* 1497 -  */  0,
/* 1498 -  */  0,
/* 1499 - _V_66_0F_3A_15 */  0x414d,
/* 149a -  */  0,
/* 149b -  */  0,
/* 149c -  */  0,
/* 149d -  */  0,
/* 149e -  */  0,
/* 149f -  */  0,
/* 14a0 -  */  0,
/* 14a1 - _66_0F_3A_16 */  0x414e,
/* 14a2 -  */  0,
/* 14a3 -  */  0,
/* 14a4 -  */  0,
/* 14a5 - _V_66_0F_3A_16 */  0x414f,
/* 14a6 -  */  0,
/* 14a7 -  */  0,
/* 14a8 -  */  0,
/* 14a9 -  */  0,
/* 14aa -  */  0,
/* 14ab -  */  0,
/* 14ac -  */  0,
/* 14ad - _66_0F_3A_17 */  0x4150,
/* 14ae -  */  0,
/* 14af -  */  0,
/* 14b0 -  */  0,
/* 14b1 - _V_66_0F_3A_17 */  0x4151,
/* 14b2 -  */  0,
/* 14b3 -  */  0,
/* 14b4 -  */  0,
/* 14b5 -  */  0,
/* 14b6 -  */  0,
/* 14b7 -  */  0,
/* 14b8 -  */  0,
/* 14b9 -  */  0,
/* 14ba -  */  0,
/* 14bb -  */  0,
/* 14bc -  */  0,
/* 14bd - _V_66_0F_3A_18 */  0x4152,
/* 14be -  */  0,
/* 14bf -  */  0,
/* 14c0 -  */  0,
/* 14c1 -  */  0,
/* 14c2 -  */  0,
/* 14c3 -  */  0,
/* 14c4 -  */  0,
/* 14c5 -  */  0,
/* 14c6 -  */  0,
/* 14c7 -  */  0,
/* 14c8 -  */  0,
/* 14c9 - _V_66_0F_3A_19 */  0x4153,
/* 14ca -  */  0,
/* 14cb -  */  0,
/* 14cc -  */  0,
/* 14cd -  */  0,
/* 14ce -  */  0,
/* 14cf -  */  0,
/* 14d0 -  */  0,
/* 14d1 - _66_0F_3A_20 */  0x4154,
/* 14d2 -  */  0,
/* 14d3 -  */  0,
/* 14d4 -  */  0,
/* 14d5 - _V_66_0F_3A_20 */  0x4155,
/* 14d6 -  */  0,
/* 14d7 -  */  0,
/* 14d8 -  */  0,
/* 14d9 -  */  0,
/* 14da -  */  0,
/* 14db -  */  0,
/* 14dc -  */  0,
/* 14dd - _66_0F_3A_21 */  0x4156,
/* 14de -  */  0,
/* 14df -  */  0,
/* 14e0 -  */  0,
/* 14e1 - _V_66_0F_3A_21 */  0x4157,
/* 14e2 -  */  0,
/* 14e3 -  */  0,
/* 14e4 -  */  0,
/* 14e5 -  */  0,
/* 14e6 -  */  0,
/* 14e7 -  */  0,
/* 14e8 -  */  0,
/* 14e9 - _66_0F_3A_22 */  0x4158,
/* 14ea -  */  0,
/* 14eb -  */  0,
/* 14ec -  */  0,
/* 14ed - _V_66_0F_3A_22 */  0x4159,
/* 14ee -  */  0,
/* 14ef -  */  0,
/* 14f0 -  */  0,
/* 14f1 -  */  0,
/* 14f2 -  */  0,
/* 14f3 -  */  0,
/* 14f4 -  */  0,
/* 14f5 - _66_0F_3A_40 */  0x415a,
/* 14f6 -  */  0,
/* 14f7 -  */  0,
/* 14f8 -  */  0,
/* 14f9 - _V_66_0F_3A_40 */  0x415b,
/* 14fa -  */  0,
/* 14fb -  */  0,
/* 14fc -  */  0,
/* 14fd -  */  0,
/* 14fe -  */  0,
/* 14ff -  */  0,
/* 1500 -  */  0,
/* 1501 - _66_0F_3A_41 */  0x415c,
/* 1502 -  */  0,
/* 1503 -  */  0,
/* 1504 -  */  0,
/* 1505 - _V_66_0F_3A_41 */  0x415d,
/* 1506 -  */  0,
/* 1507 -  */  0,
/* 1508 -  */  0,
/* 1509 -  */  0,
/* 150a -  */  0,
/* 150b -  */  0,
/* 150c -  */  0,
/* 150d - _66_0F_3A_42 */  0x415e,
/* 150e -  */  0,
/* 150f -  */  0,
/* 1510 -  */  0,
/* 1511 - _V_66_0F_3A_42 */  0x415f,
/* 1512 -  */  0,
/* 1513 -  */  0,
/* 1514 -  */  0,
/* 1515 -  */  0,
/* 1516 -  */  0,
/* 1517 -  */  0,
/* 1518 -  */  0,
/* 1519 - _66_0F_3A_44 */  0x4160,
/* 151a -  */  0,
/* 151b -  */  0,
/* 151c -  */  0,
/* 151d - _V_66_0F_3A_44 */  0x4161,
/* 151e -  */  0,
/* 151f -  */  0,
/* 1520 -  */  0,
/* 1521 -  */  0,
/* 1522 -  */  0,
/* 1523 -  */  0,
/* 1524 -  */  0,
/* 1525 -  */  0,
/* 1526 -  */  0,
/* 1527 -  */  0,
/* 1528 -  */  0,
/* 1529 - _V_66_0F_3A_4A */  0x4162,
/* 152a -  */  0,
/* 152b -  */  0,
/* 152c -  */  0,
/* 152d -  */  0,
/* 152e -  */  0,
/* 152f -  */  0,
/* 1530 -  */  0,
/* 1531 -  */  0,
/* 1532 -  */  0,
/* 1533 -  */  0,
/* 1534 -  */  0,
/* 1535 - _V_66_0F_3A_4B */  0x4163,
/* 1536 -  */  0,
/* 1537 -  */  0,
/* 1538 -  */  0,
/* 1539 -  */  0,
/* 153a -  */  0,
/* 153b -  */  0,
/* 153c -  */  0,
/* 153d -  */  0,
/* 153e -  */  0,
/* 153f -  */  0,
/* 1540 -  */  0,
/* 1541 - _V_66_0F_3A_4C */  0x4164,
/* 1542 -  */  0,
/* 1543 -  */  0,
/* 1544 -  */  0,
/* 1545 -  */  0,
/* 1546 -  */  0,
/* 1547 -  */  0,
/* 1548 -  */  0,
/* 1549 - _66_0F_3A_60 */  0x4165,
/* 154a -  */  0,
/* 154b -  */  0,
/* 154c -  */  0,
/* 154d - _V_66_0F_3A_60 */  0x4166,
/* 154e -  */  0,
/* 154f -  */  0,
/* 1550 -  */  0,
/* 1551 -  */  0,
/* 1552 -  */  0,
/* 1553 -  */  0,
/* 1554 -  */  0,
/* 1555 - _66_0F_3A_61 */  0x4167,
/* 1556 -  */  0,
/* 1557 -  */  0,
/* 1558 -  */  0,
/* 1559 - _V_66_0F_3A_61 */  0x4168,
/* 155a -  */  0,
/* 155b -  */  0,
/* 155c -  */  0,
/* 155d -  */  0,
/* 155e -  */  0,
/* 155f -  */  0,
/* 1560 -  */  0,
/* 1561 - _66_0F_3A_62 */  0x4169,
/* 1562 -  */  0,
/* 1563 -  */  0,
/* 1564 -  */  0,
/* 1565 - _V_66_0F_3A_62 */  0x416a,
/* 1566 -  */  0,
/* 1567 -  */  0,
/* 1568 -  */  0,
/* 1569 -  */  0,
/* 156a -  */  0,
/* 156b -  */  0,
/* 156c -  */  0,
/* 156d - _66_0F_3A_63 */  0x416b,
/* 156e -  */  0,
/* 156f -  */  0,
/* 1570 -  */  0,
/* 1571 - _V_66_0F_3A_63 */  0x416c,
/* 1572 -  */  0,
/* 1573 -  */  0,
/* 1574 -  */  0,
/* 1575 -  */  0,
/* 1576 -  */  0,
/* 1577 -  */  0,
/* 1578 -  */  0,
/* 1579 - _66_0F_3A_DF */  0x416d,
/* 157a -  */  0,
/* 157b -  */  0,
/* 157c -  */  0,
/* 157d - _V_66_0F_3A_DF */  0x416e,
/* 157e -  */  0,
/* 157f -  */  0,
/* 1580 -  */  0,
/* 1581 -  */  0,
/* 1582 -  */  0,
/* 1583 -  */  0,
/* 1584 - _0F_71_02 */  0x24c5,
/* 1585 - _66_0F_71_02 */  0x24c6,
/* 1586 -  */  0,
/* 1587 -  */  0,
/* 1588 -  */  0,
/* 1589 - _V_66_0F_71_02 */  0x416f,
/* 158a -  */  0,
/* 158b -  */  0,
/* 158c -  */  0,
/* 158d -  */  0,
/* 158e -  */  0,
/* 158f -  */  0,
/* 1590 - _0F_71_04 */  0x24c7,
/* 1591 - _66_0F_71_04 */  0x24c8,
/* 1592 -  */  0,
/* 1593 -  */  0,
/* 1594 -  */  0,
/* 1595 - _V_66_0F_71_04 */  0x4170,
/* 1596 -  */  0,
/* 1597 -  */  0,
/* 1598 -  */  0,
/* 1599 -  */  0,
/* 159a -  */  0,
/* 159b -  */  0,
/* 159c - _0F_71_06 */  0x24c9,
/* 159d - _66_0F_71_06 */  0x24ca,
/* 159e -  */  0,
/* 159f -  */  0,
/* 15a0 -  */  0,
/* 15a1 - _V_66_0F_71_06 */  0x4171,
/* 15a2 -  */  0,
/* 15a3 -  */  0,
/* 15a4 -  */  0,
/* 15a5 -  */  0,
/* 15a6 -  */  0,
/* 15a7 -  */  0,
/* 15a8 - _0F_72_02 */  0x24cb,
/* 15a9 - _66_0F_72_02 */  0x24cc,
/* 15aa -  */  0,
/* 15ab -  */  0,
/* 15ac -  */  0,
/* 15ad - _V_66_0F_72_02 */  0x4172,
/* 15ae -  */  0,
/* 15af -  */  0,
/* 15b0 -  */  0,
/* 15b1 -  */  0,
/* 15b2 -  */  0,
/* 15b3 -  */  0,
/* 15b4 - _0F_72_04 */  0x24cd,
/* 15b5 - _66_0F_72_04 */  0x24ce,
/* 15b6 -  */  0,
/* 15b7 -  */  0,
/* 15b8 -  */  0,
/* 15b9 - _V_66_0F_72_04 */  0x4173,
/* 15ba -  */  0,
/* 15bb -  */  0,
/* 15bc -  */  0,
/* 15bd -  */  0,
/* 15be -  */  0,
/* 15bf -  */  0,
/* 15c0 - _0F_72_06 */  0x24cf,
/* 15c1 - _66_0F_72_06 */  0x24d0,
/* 15c2 -  */  0,
/* 15c3 -  */  0,
/* 15c4 -  */  0,
/* 15c5 - _V_66_0F_72_06 */  0x4174,
/* 15c6 -  */  0,
/* 15c7 -  */  0,
/* 15c8 -  */  0,
/* 15c9 -  */  0,
/* 15ca -  */  0,
/* 15cb -  */  0,
/* 15cc - _0F_73_02 */  0x24d1,
/* 15cd - _66_0F_73_02 */  0x24d2,
/* 15ce -  */  0,
/* 15cf -  */  0,
/* 15d0 -  */  0,
/* 15d1 - _V_66_0F_73_02 */  0x4175,
/* 15d2 -  */  0,
/* 15d3 -  */  0,
/* 15d4 -  */  0,
/* 15d5 -  */  0,
/* 15d6 -  */  0,
/* 15d7 -  */  0,
/* 15d8 -  */  0,
/* 15d9 - _66_0F_73_03 */  0x24d3,
/* 15da -  */  0,
/* 15db -  */  0,
/* 15dc -  */  0,
/* 15dd - _V_66_0F_73_03 */  0x4176,
/* 15de -  */  0,
/* 15df -  */  0,
/* 15e0 -  */  0,
/* 15e1 -  */  0,
/* 15e2 -  */  0,
/* 15e3 -  */  0,
/* 15e4 - _0F_73_06 */  0x24d4,
/* 15e5 - _66_0F_73_06 */  0x24d5,
/* 15e6 -  */  0,
/* 15e7 -  */  0,
/* 15e8 -  */  0,
/* 15e9 - _V_66_0F_73_06 */  0x4177,
/* 15ea -  */  0,
/* 15eb -  */  0,
/* 15ec -  */  0,
/* 15ed -  */  0,
/* 15ee -  */  0,
/* 15ef -  */  0,
/* 15f0 -  */  0,
/* 15f1 - _66_0F_73_07 */  0x24d6,
/* 15f2 -  */  0,
/* 15f3 -  */  0,
/* 15f4 -  */  0,
/* 15f5 - _V_66_0F_73_07 */  0x4178,
/* 15f6 -  */  0,
/* 15f7 -  */  0,
/* 15f8 -  */  0,
/* 15f9 -  */  0,
/* 15fa -  */  0,
/* 15fb -  */  0,
/* 15fc - _0F_AE_00 */  0x4179,
/* 15fd -  */  0,
/* 15fe - _F3_0F_AE_00 */  0x24d7,
/* 15ff -  */  0,
/* 1600 -  */  0,
/* 1601 -  */  0,
/* 1602 -  */  0,
/* 1603 -  */  0,
/* 1604 -  */  0,
/* 1605 -  */  0,
/* 1606 -  */  0,
/* 1607 -  */  0,
/* 1608 - _0F_AE_01 */  0x417a,
/* 1609 -  */  0,
/* 160a - _F3_0F_AE_01 */  0x24d8,
/* 160b -  */  0,
/* 160c -  */  0,
/* 160d -  */  0,
/* 160e -  */  0,
/* 160f -  */  0,
/* 1610 -  */  0,
/* 1611 -  */  0,
/* 1612 -  */  0,
/* 1613 -  */  0,
/* 1614 - _0F_AE_02 */  0x24d9,
/* 1615 -  */  0,
/* 1616 - _F3_0F_AE_02 */  0x24da,
/* 1617 -  */  0,
/* 1618 - _V_0F_AE_02 */  0x417b,
/* 1619 -  */  0,
/* 161a -  */  0,
/* 161b -  */  0,
/* 161c -  */  0,
/* 161d -  */  0,
/* 161e -  */  0,
/* 161f -  */  0,
/* 1620 - _0F_AE_03 */  0x24db,
/* 1621 -  */  0,
/* 1622 - _F3_0F_AE_03 */  0x24dc,
/* 1623 -  */  0,
/* 1624 - _V_0F_AE_03 */  0x417c,
/* 1625 -  */  0,
/* 1626 -  */  0,
/* 1627 -  */  0,
/* 1628 -  */  0,
/* 1629 -  */  0,
/* 162a -  */  0,
/* 162b -  */  0,
/* 162c - _0F_C7_06 */  0x24dd,
/* 162d - _66_0F_C7_06 */  0x24de,
/* 162e - _F3_0F_C7_06 */  0x24df,
/* 162f -  */  0,
/* 1630 -  */  0,
/* 1631 -  */  0,
/* 1632 -  */  0,
/* 1633 -  */  0,
/* 1634 -  */  0,
/* 1635 -  */  0,
/* 1636 -  */  0,
/* 1637 -  */  0
};

_InstSharedInfo InstSharedInfoTable[474] = {
{0, 6, 68, 245, 0, 0, 256},
{0, 8, 72, 245, 0, 0, 256},
{0, 68, 6, 245, 0, 0, 256},
{0, 72, 8, 245, 0, 0, 256},
{1, 1, 11, 245, 0, 0, 256},
{1, 3, 13, 245, 0, 0, 256},
{2, 0, 46, 0, 0, 0, 256},
{3, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 196, 16, 0, 256},
{0, 8, 72, 196, 16, 0, 256},
{0, 68, 6, 196, 16, 0, 256},
{0, 72, 8, 196, 16, 0, 256},
{1, 1, 11, 196, 16, 0, 256},
{1, 3, 13, 196, 16, 0, 256},
{4, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 245, 1, 0, 256},
{0, 8, 72, 245, 1, 0, 256},
{0, 68, 6, 245, 1, 0, 256},
{0, 72, 8, 245, 1, 0, 256},
{1, 1, 11, 245, 1, 0, 256},
{1, 3, 13, 245, 1, 0, 256},
{5, 0, 46, 0, 0, 0, 256},
{6, 0, 46, 0, 0, 0, 256},
{7, 0, 46, 0, 0, 0, 256},
{8, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 229, 0, 16, 256},
{0, 8, 72, 229, 0, 16, 256},
{0, 68, 6, 229, 0, 16, 256},
{0, 72, 8, 229, 0, 16, 256},
{1, 1, 11, 229, 0, 16, 256},
{1, 3, 13, 229, 0, 16, 256},
{9, 0, 0, 213, 17, 32, 256},
{0, 6, 68, 196, 0, 16, 256},
{0, 8, 72, 196, 0, 16, 256},
{0, 68, 6, 196, 0, 16, 256},
{0, 72, 8, 196, 0, 16, 256},
{1, 1, 11, 196, 0, 16, 256},
{1, 3, 13, 196, 0, 16, 256},
{9, 0, 0, 17, 16, 228, 256},
{10, 6, 68, 245, 0, 0, 256},
{10, 8, 72, 245, 0, 0, 256},
{10, 68, 6, 245, 0, 0, 256},
{10, 72, 8, 245, 0, 0, 256},
{11, 1, 11, 245, 0, 0, 256},
{11, 3, 13, 245, 0, 0, 256},
{12, 0, 18, 244, 0, 0, 256},
{13, 0, 18, 0, 0, 0, 256},
{14, 0, 18, 0, 0, 0, 256},
{15, 0, 0, 0, 0, 0, 256},
{16, 54, 8, 0, 0, 0, 256},
{10, 7, 69, 64, 0, 0, 256},
{13, 0, 3, 0, 0, 0, 256},
{17, 72, 8, 33, 0, 212, 256},
{18, 0, 5, 0, 0, 0, 256},
{19, 25, 22, 0, 8, 0, 33024},
{20, 25, 22, 0, 8, 0, 33024},
{19, 21, 25, 0, 8, 0, 33024},
{20, 21, 25, 0, 8, 0, 33024},
{13, 0, 15, 0, 32, 0, 261},
{13, 0, 15, 0, 1, 0, 261},
{13, 0, 15, 0, 64, 0, 261},
{13, 0, 15, 0, 65, 0, 261},
{13, 0, 15, 0, 128, 0, 261},
{13, 0, 15, 0, 4, 0, 261},
{13, 0, 15, 0, 160, 0, 261},
{13, 0, 15, 0, 224, 0, 261},
{10, 6, 68, 196, 0, 16, 256},
{10, 8, 72, 196, 0, 16, 256},
{0, 6, 68, 0, 0, 0, 256},
{0, 8, 72, 0, 0, 0, 256},
{21, 6, 68, 0, 0, 0, 256},
{21, 8, 72, 0, 0, 0, 256},
{21, 68, 6, 0, 0, 0, 256},
{21, 72, 8, 0, 0, 0, 256},
{21, 45, 71, 0, 0, 0, 256},
{21, 54, 8, 0, 0, 0, 256},
{21, 71, 45, 0, 0, 0, 256},
{1, 13, 18, 0, 0, 0, 256},
{22, 0, 0, 0, 0, 0, 256},
{9, 0, 50, 0, 0, 0, 257},
{23, 0, 0, 0, 0, 0, 256},
{23, 0, 0, 255, 0, 0, 256},
{11, 0, 0, 213, 0, 0, 256},
{11, 0, 0, 0, 0, 0, 256},
{1, 19, 11, 0, 0, 0, 256},
{1, 20, 13, 0, 0, 0, 256},
{1, 11, 19, 0, 0, 0, 256},
{1, 13, 20, 0, 0, 0, 256},
{24, 21, 22, 0, 8, 0, 256},
{25, 21, 22, 0, 8, 0, 256},
{19, 22, 21, 245, 8, 0, 256},
{26, 22, 21, 245, 8, 0, 256},
{11, 1, 11, 196, 0, 16, 256},
{11, 3, 13, 196, 0, 16, 256},
{19, 11, 22, 0, 8, 0, 256},
{26, 13, 22, 0, 8, 0, 256},
{19, 21, 11, 0, 8, 0, 256},
{26, 21, 13, 0, 8, 0, 256},
{19, 11, 22, 245, 8, 0, 256},
{26, 13, 22, 245, 8, 0, 256},
{1, 1, 17, 0, 0, 0, 256},
{27, 3, 18, 0, 0, 0, 256},
{13, 0, 2, 0, 0, 0, 258},
{13, 0, 0, 0, 0, 0, 258},
{16, 60, 8, 0, 0, 0, 256},
{13, 49, 47, 0, 0, 0, 256},
{13, 0, 0, 0, 0, 0, 256},
{28, 0, 2, 0, 0, 0, 258},
{28, 0, 0, 0, 0, 0, 258},
{11, 0, 0, 0, 0, 0, 262},
{11, 0, 1, 0, 0, 0, 262},
{9, 0, 0, 0, 0, 0, 262},
{28, 0, 0, 255, 0, 0, 33026},
{9, 0, 1, 196, 0, 49, 256},
{9, 0, 0, 0, 0, 0, 256},
{29, 0, 23, 0, 0, 0, 256},
{30, 0, 15, 0, 64, 0, 261},
{30, 0, 15, 0, 0, 0, 261},
{31, 0, 15, 0, 0, 0, 261},
{1, 1, 11, 0, 0, 0, 33024},
{1, 1, 14, 0, 0, 0, 33024},
{11, 11, 1, 0, 0, 0, 33024},
{11, 14, 1, 0, 0, 0, 33024},
{13, 0, 16, 0, 0, 0, 257},
{13, 0, 16, 0, 0, 0, 260},
{9, 0, 50, 0, 0, 0, 260},
{13, 0, 15, 0, 0, 0, 260},
{1, 25, 11, 0, 0, 0, 33024},
{1, 25, 14, 0, 0, 0, 33024},
{11, 11, 25, 0, 0, 0, 33024},
{11, 14, 25, 0, 0, 0, 33024},
{11, 0, 0, 0, 0, 0, 33032},
{11, 0, 0, 1, 0, 0, 256},
{11, 0, 0, 2, 0, 0, 33024},
{11, 0, 0, 8, 0, 0, 256},
{10, 69, 8, 64, 0, 0, 256},
{32, 0, 0, 0, 0, 0, 771},
{32, 0, 0, 0, 0, 0, 33024},
{32, 0, 0, 0, 0, 0, 262},
{11, 0, 0, 0, 0, 0, 3072},
{10, 0, 72, 0, 0, 0, 256},
{33, 43, 51, 0, 0, 0, 33024},
{33, 44, 51, 0, 0, 0, 33024},
{33, 51, 43, 0, 0, 0, 33024},
{33, 51, 44, 0, 0, 0, 33024},
{32, 0, 0, 0, 0, 0, 256},
{34, 72, 8, 0, 32, 0, 775},
{34, 72, 8, 0, 1, 0, 775},
{34, 72, 8, 0, 64, 0, 775},
{34, 72, 8, 0, 65, 0, 775},
{34, 72, 8, 0, 128, 0, 775},
{34, 72, 8, 0, 4, 0, 775},
{34, 72, 8, 0, 160, 0, 775},
{34, 72, 8, 0, 224, 0, 775},
{32, 0, 16, 0, 32, 0, 261},
{32, 0, 16, 0, 1, 0, 261},
{32, 0, 16, 0, 64, 0, 261},
{32, 0, 16, 0, 65, 0, 261},
{32, 0, 16, 0, 128, 0, 261},
{32, 0, 16, 0, 4, 0, 261},
{32, 0, 16, 0, 160, 0, 261},
{32, 0, 16, 0, 224, 0, 261},
{34, 0, 68, 0, 32, 0, 256},
{34, 0, 68, 0, 1, 0, 256},
{34, 0, 68, 0, 64, 0, 256},
{34, 0, 68, 0, 65, 0, 256},
{34, 0, 68, 0, 128, 0, 256},
{34, 0, 68, 0, 4, 0, 256},
{34, 0, 68, 0, 160, 0, 256},
{34, 0, 68, 0, 224, 0, 256},
{35, 0, 46, 0, 0, 0, 256},
{36, 0, 46, 0, 0, 0, 256},
{34, 8, 72, 1, 0, 244, 256},
{37, 8, 72, 197, 0, 48, 256},
{38, 0, 46, 0, 0, 0, 256},
{39, 0, 46, 0, 0, 0, 256},
{32, 0, 0, 255, 0, 0, 256},
{40, 8, 72, 1, 0, 244, 256},
{34, 72, 8, 33, 0, 212, 256},
{40, 6, 68, 245, 0, 0, 256},
{40, 8, 72, 245, 0, 0, 256},
{41, 60, 8, 0, 0, 0, 256},
{34, 68, 8, 0, 0, 0, 256},
{42, 69, 8, 0, 0, 0, 256},
{42, 10, 56, 0, 0, 0, 1536},
{43, 0, 18, 0, 0, 0, 256},
{44, 1, 68, 245, 0, 0, 256},
{44, 1, 68, 196, 16, 0, 256},
{44, 1, 68, 245, 1, 0, 256},
{44, 1, 68, 229, 0, 16, 256},
{44, 1, 68, 196, 0, 16, 256},
{45, 1, 68, 245, 0, 0, 256},
{44, 3, 72, 245, 0, 0, 256},
{44, 3, 72, 196, 16, 0, 256},
{44, 3, 72, 245, 1, 0, 256},
{44, 3, 72, 229, 0, 16, 256},
{44, 3, 72, 196, 0, 16, 256},
{45, 3, 72, 245, 0, 0, 256},
{46, 1, 68, 245, 0, 0, 256},
{46, 1, 68, 196, 16, 0, 256},
{46, 1, 68, 245, 1, 0, 256},
{46, 1, 68, 229, 0, 16, 256},
{46, 1, 68, 196, 0, 16, 256},
{47, 1, 68, 245, 0, 0, 256},
{44, 5, 72, 245, 0, 0, 256},
{48, 5, 72, 196, 16, 0, 256},
{44, 5, 72, 245, 1, 0, 256},
{48, 5, 72, 229, 0, 16, 256},
{48, 5, 72, 196, 0, 16, 256},
{45, 5, 72, 245, 0, 0, 256},
{49, 0, 72, 0, 0, 0, 256},
{50, 1, 68, 1, 0, 32, 256},
{50, 1, 68, 1, 1, 32, 256},
{50, 1, 68, 197, 0, 48, 256},
{50, 1, 72, 1, 0, 32, 256},
{50, 1, 72, 1, 1, 32, 256},
{50, 1, 72, 197, 0, 48, 256},
{51, 1, 68, 0, 0, 0, 256},
{52, 0, 1, 0, 0, 0, 768},
{51, 3, 72, 0, 0, 0, 256},
{52, 0, 16, 0, 0, 0, 768},
{50, 41, 68, 33, 0, 0, 256},
{50, 41, 68, 33, 1, 0, 256},
{50, 41, 68, 229, 0, 16, 256},
{50, 41, 72, 33, 0, 0, 256},
{50, 41, 72, 33, 1, 0, 256},
{50, 41, 72, 229, 0, 16, 256},
{50, 42, 68, 1, 0, 32, 256},
{50, 42, 68, 1, 1, 32, 256},
{50, 42, 68, 197, 0, 48, 256},
{50, 42, 72, 1, 0, 32, 256},
{50, 42, 72, 1, 1, 32, 256},
{50, 42, 72, 197, 0, 48, 256},
{45, 0, 64, 0, 0, 0, 512},
{53, 0, 28, 0, 0, 0, 512},
{53, 0, 27, 0, 0, 0, 512},
{53, 0, 0, 0, 0, 0, 512},
{50, 0, 64, 0, 0, 0, 512},
{45, 0, 54, 0, 0, 0, 512},
{45, 0, 63, 0, 0, 0, 512},
{54, 0, 28, 0, 1, 0, 768},
{54, 0, 28, 0, 64, 0, 768},
{54, 0, 28, 0, 65, 0, 768},
{54, 0, 28, 0, 4, 0, 768},
{55, 0, 64, 0, 0, 0, 1792},
{45, 0, 66, 0, 0, 0, 512},
{50, 0, 66, 0, 0, 0, 512},
{54, 0, 28, 69, 0, 0, 512},
{54, 0, 28, 69, 0, 0, 768},
{45, 0, 65, 0, 0, 0, 512},
{53, 0, 29, 0, 0, 0, 512},
{55, 0, 65, 0, 0, 0, 1792},
{50, 0, 65, 0, 0, 0, 512},
{55, 0, 63, 0, 0, 0, 1792},
{50, 0, 63, 0, 0, 0, 512},
{45, 1, 68, 196, 0, 16, 256},
{44, 0, 68, 0, 0, 0, 256},
{44, 0, 68, 245, 0, 0, 256},
{50, 0, 68, 33, 0, 212, 256},
{50, 0, 68, 0, 0, 245, 256},
{45, 3, 72, 196, 0, 16, 256},
{44, 0, 72, 0, 0, 0, 256},
{44, 0, 72, 245, 0, 0, 256},
{50, 0, 72, 33, 0, 212, 256},
{50, 0, 72, 0, 0, 245, 256},
{44, 0, 68, 244, 0, 0, 256},
{44, 0, 72, 244, 0, 0, 256},
{56, 0, 72, 0, 0, 0, 257},
{57, 0, 60, 0, 0, 0, 257},
{56, 0, 72, 0, 0, 0, 260},
{57, 0, 60, 0, 0, 0, 260},
{56, 0, 72, 0, 0, 0, 256},
{45, 0, 72, 0, 0, 0, 256},
{45, 0, 69, 0, 0, 0, 256},
{45, 0, 69, 0, 0, 0, 33024},
{55, 0, 69, 0, 0, 0, 33024},
{45, 0, 69, 64, 0, 0, 256},
{56, 0, 61, 0, 0, 0, 256},
{56, 0, 61, 0, 0, 0, 33024},
{51, 0, 71, 0, 0, 0, 256},
{58, 0, 69, 0, 0, 0, 33024},
{55, 0, 54, 0, 0, 0, 33024},
{54, 0, 0, 0, 0, 0, 3584},
{54, 0, 0, 0, 0, 0, 256},
{13, 0, 0, 0, 0, 0, 768},
{55, 0, 24, 0, 0, 0, 3840},
{54, 0, 0, 0, 0, 0, 3840},
{54, 0, 24, 0, 0, 0, 3840},
{54, 26, 24, 0, 0, 0, 3840},
{59, 0, 0, 0, 0, 0, 256},
{55, 0, 54, 0, 0, 0, 3072},
{60, 83, 52, 0, 0, 0, 3328},
{60, 83, 52, 0, 0, 0, 3072},
{34, 87, 30, 0, 0, 0, 1280},
{34, 87, 30, 0, 0, 0, 1536},
{34, 85, 30, 0, 0, 0, 1280},
{34, 86, 30, 0, 0, 0, 1536},
{61, 91, 36, 0, 0, 0, 4096},
{62, 34, 30, 0, 0, 0, 4096},
{63, 55, 30, 0, 0, 0, 4096},
{63, 57, 30, 0, 0, 0, 4096},
{34, 30, 87, 0, 0, 0, 1280},
{34, 30, 87, 0, 0, 0, 1536},
{34, 30, 85, 0, 0, 0, 1280},
{34, 30, 86, 0, 0, 0, 1536},
{61, 36, 91, 0, 0, 0, 4096},
{63, 30, 55, 0, 0, 0, 4096},
{63, 30, 57, 0, 0, 0, 4096},
{64, 86, 30, 0, 0, 0, 1280},
{34, 57, 30, 0, 0, 0, 1536},
{34, 86, 30, 0, 0, 0, 1792},
{65, 34, 30, 0, 0, 0, 4096},
{66, 34, 30, 0, 0, 0, 4096},
{61, 90, 36, 0, 0, 0, 4096},
{34, 30, 57, 0, 0, 0, 1280},
{34, 30, 57, 0, 0, 0, 1536},
{61, 30, 57, 0, 0, 0, 4096},
{67, 87, 30, 0, 0, 0, 1280},
{67, 87, 30, 0, 0, 0, 1536},
{66, 40, 36, 0, 0, 0, 4096},
{34, 87, 30, 0, 0, 0, 1792},
{55, 0, 54, 0, 0, 0, 1280},
{67, 83, 30, 0, 0, 0, 1280},
{67, 83, 30, 0, 0, 0, 1536},
{41, 76, 30, 0, 0, 0, 1280},
{41, 76, 30, 0, 0, 0, 1536},
{34, 30, 59, 0, 0, 0, 1280},
{34, 30, 59, 0, 0, 0, 1536},
{34, 30, 55, 0, 0, 0, 2816},
{34, 30, 57, 0, 0, 0, 2816},
{61, 36, 67, 0, 0, 0, 4096},
{67, 86, 52, 0, 0, 0, 1280},
{67, 87, 52, 0, 0, 0, 1536},
{41, 85, 10, 0, 0, 0, 1280},
{41, 86, 10, 0, 0, 0, 1536},
{61, 88, 33, 0, 0, 0, 4096},
{67, 85, 30, 69, 0, 0, 1280},
{67, 86, 30, 0, 0, 0, 1536},
{61, 85, 30, 0, 0, 0, 4096},
{61, 86, 30, 0, 0, 0, 4096},
{68, 31, 9, 0, 0, 0, 1280},
{68, 31, 9, 0, 0, 0, 1536},
{69, 36, 10, 0, 0, 0, 4096},
{67, 85, 30, 0, 0, 0, 1280},
{67, 85, 30, 0, 0, 0, 1536},
{61, 92, 36, 0, 0, 0, 4096},
{61, 91, 30, 0, 0, 0, 4096},
{67, 82, 52, 0, 0, 0, 1024},
{67, 83, 52, 0, 0, 0, 1024},
{70, 76, 52, 0, 0, 0, 1024},
{70, 76, 30, 0, 0, 0, 1536},
{61, 73, 30, 0, 0, 0, 4096},
{34, 83, 52, 0, 0, 0, 1024},
{71, 83, 52, 0, 0, 0, 1280},
{71, 87, 30, 0, 0, 0, 1536},
{66, 87, 30, 0, 0, 0, 4096},
{32, 0, 0, 0, 0, 0, 1024},
{72, 0, 0, 0, 0, 0, 4096},
{73, 10, 76, 0, 0, 0, 3584},
{74, 48, 31, 0, 0, 0, 2816},
{75, 31, 30, 0, 0, 0, 2816},
{73, 76, 10, 0, 0, 0, 3584},
{67, 31, 30, 0, 0, 0, 2816},
{76, 31, 30, 0, 0, 0, 2816},
{32, 86, 30, 0, 0, 0, 3584},
{32, 30, 86, 0, 0, 0, 3584},
{67, 87, 30, 0, 0, 0, 1792},
{70, 52, 76, 0, 0, 0, 1024},
{70, 30, 76, 0, 0, 0, 1536},
{61, 30, 73, 0, 0, 0, 4096},
{34, 52, 83, 0, 0, 0, 1024},
{77, 0, 54, 0, 0, 0, 256},
{78, 0, 62, 0, 0, 0, 256},
{79, 0, 62, 0, 0, 0, 256},
{80, 72, 8, 64, 0, 0, 2560},
{81, 1, 72, 1, 0, 244, 256},
{48, 1, 72, 1, 0, 244, 256},
{67, 72, 8, 64, 0, 245, 256},
{82, 72, 8, 0, 0, 0, 3584},
{83, 72, 8, 65, 0, 180, 256},
{84, 87, 30, 0, 0, 0, 1280},
{84, 87, 30, 0, 0, 0, 1536},
{84, 85, 30, 0, 0, 0, 1280},
{84, 86, 30, 0, 0, 0, 1536},
{85, 40, 36, 0, 0, 0, 4096},
{85, 34, 30, 0, 0, 0, 4096},
{71, 79, 52, 0, 0, 0, 1280},
{71, 79, 30, 0, 0, 0, 1536},
{86, 34, 30, 0, 0, 0, 4096},
{87, 53, 9, 0, 0, 0, 1280},
{71, 31, 9, 0, 0, 0, 1536},
{88, 30, 10, 0, 0, 0, 4096},
{71, 87, 30, 0, 0, 0, 1280},
{86, 40, 36, 0, 0, 0, 4096},
{89, 0, 58, 64, 0, 0, 256},
{55, 0, 57, 0, 0, 0, 3584},
{68, 53, 30, 0, 0, 0, 1536},
{68, 31, 52, 0, 0, 0, 1536},
{61, 30, 86, 0, 0, 0, 4096},
{76, 53, 9, 0, 0, 0, 1280},
{76, 31, 9, 0, 0, 0, 1536},
{69, 30, 10, 0, 0, 0, 4096},
{67, 83, 52, 0, 0, 0, 1280},
{34, 52, 57, 0, 0, 0, 1280},
{67, 54, 30, 0, 0, 0, 1792},
{61, 67, 36, 0, 0, 0, 4096},
{67, 83, 52, 0, 0, 0, 1536},
{76, 53, 52, 0, 0, 0, 1280},
{76, 31, 30, 0, 0, 0, 1536},
{90, 31, 30, 0, 0, 0, 4096},
{50, 0, 54, 0, 0, 0, 512},
{91, 0, 54, 0, 0, 0, 512},
{91, 0, 63, 0, 0, 0, 512},
{92, 0, 0, 0, 0, 0, 512},
{93, 0, 12, 0, 0, 0, 512},
{94, 0, 12, 0, 0, 0, 512},
{67, 83, 52, 0, 0, 0, 2048},
{67, 87, 30, 0, 0, 0, 2048},
{71, 87, 30, 0, 0, 0, 2304},
{67, 87, 30, 0, 0, 0, 2560},
{61, 55, 36, 0, 0, 0, 4096},
{61, 57, 38, 0, 0, 0, 4096},
{61, 59, 38, 0, 0, 0, 4096},
{61, 87, 30, 0, 0, 0, 4096},
{67, 86, 30, 0, 0, 0, 2304},
{67, 85, 30, 0, 0, 0, 2304},
{67, 84, 30, 0, 0, 0, 2304},
{61, 84, 30, 0, 0, 0, 4096},
{67, 87, 30, 0, 0, 0, 2304},
{34, 59, 30, 0, 0, 0, 2304},
{61, 59, 30, 0, 0, 0, 4096},
{66, 40, 67, 0, 0, 0, 4096},
{73, 59, 10, 0, 0, 0, 3584},
{66, 40, 36, 0, 0, 0, 4352},
{66, 34, 30, 0, 0, 0, 4352},
{67, 87, 30, 0, 0, 0, 4864},
{61, 87, 30, 0, 0, 0, 4864},
{66, 34, 30, 0, 0, 0, 4864},
{34, 72, 8, 0, 0, 0, 256},
{34, 68, 10, 0, 0, 0, 2560},
{34, 8, 72, 0, 0, 0, 256},
{34, 72, 10, 0, 0, 0, 2560},
{66, 91, 36, 0, 0, 0, 4096},
{86, 39, 38, 0, 0, 0, 4096},
{71, 85, 30, 0, 0, 0, 2304},
{71, 86, 30, 0, 0, 0, 2304},
{71, 83, 52, 0, 0, 0, 2048},
{71, 87, 30, 0, 0, 0, 2048},
{71, 30, 74, 0, 0, 0, 2304},
{88, 30, 80, 0, 0, 0, 4096},
{71, 30, 75, 0, 0, 0, 2304},
{88, 30, 81, 0, 0, 0, 4096},
{95, 30, 76, 0, 0, 0, 2304},
{66, 30, 73, 0, 0, 0, 4096},
{71, 30, 76, 0, 0, 0, 2304},
{66, 30, 70, 0, 0, 0, 4096},
{66, 38, 87, 0, 0, 0, 4096},
{71, 78, 30, 0, 0, 0, 2304},
{95, 76, 30, 0, 0, 0, 2304},
{71, 87, 30, 0, 0, 0, 4608},
{86, 34, 30, 0, 0, 0, 4608},
{71, 87, 30, 0, 0, 0, 2560},
{71, 87, 30, 0, 0, 0, 4864},
{66, 87, 30, 0, 0, 0, 4864},
{96, 1, 53, 0, 0, 0, 1024},
{55, 1, 31, 0, 0, 0, 1536},
{97, 31, 34, 0, 0, 0, 4096},
{98, 0, 10, 0, 0, 0, 3584},
{55, 0, 55, 0, 0, 0, 256},
{63, 0, 55, 0, 0, 0, 4096},
{55, 0, 54, 0, 0, 0, 3584},
{99, 70, 10, 0, 0, 0, 256},
{98, 0, 72, 0, 0, 0, 256},
{100, 83, 52, 0, 0, 0, 3072}
};

uint16_t CmpMnemonicOffsets[8] = {
0, 9, 18, 27, 39, 49, 59, 69
};
uint16_t VCmpMnemonicOffsets[32] = {
0, 10, 20, 30, 43, 54, 65, 76, 87, 100, 111, 122, 135, 149, 159, 169, 181, 194, 207, 220, 235, 249, 263, 277, 290, 303, 317, 331, 347, 361, 374, 387
};
```

`NativeCore/Dependencies/distorm/src/insts.h`:

```h
/*
insts.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTS_H
#define INSTS_H

#include "instructions.h"


/* Flags Table */
extern _iflags FlagsTable[];

/* Root Trie DB */
extern _InstSharedInfo InstSharedInfoTable[];
extern _InstInfo InstInfos[];
extern _InstInfoEx InstInfosEx[];
extern _InstNode InstructionsTree[];

/* 3DNow! Trie DB */
extern _InstNode Table_0F_0F;
/* AVX related: */
extern _InstNode Table_0F, Table_0F_38, Table_0F_3A;

/*
 * The inst_lookup will return on of these two instructions according to the specified decoding mode.
 * ARPL or MOVSXD on 64 bits is one byte instruction at index 0x63.
 */
extern _InstInfo II_MOVSXD;

/*
 * The NOP instruction can be prefixed by REX in 64bits, therefore we have to decide in runtime whether it's an XCHG or NOP instruction.
 * If 0x90 is prefixed by a usable REX it will become XCHG, otherwise it will become a NOP.
 * Also note that if it's prefixed by 0xf3, it becomes a Pause.
 */
extern _InstInfo II_NOP;
extern _InstInfo II_PAUSE;

/*
 * RDRAND and VMPTRLD share same 2.3 bytes opcode, and then alternates on the MOD bits,
 * RDRAND is OT_FULL_REG while VMPTRLD is OT_MEM, and there's no such mixed type.
 * So a hack into the inst_lookup was added for this decision, the DB isn't flexible enough. :(
 */
extern _InstInfo II_RDRAND;

/*
 * Used for letting the extract operand know the type of operands without knowing the
 * instruction itself yet, because of the way those instructions work.
 * See function instructions.c!inst_lookup_3dnow.
 */
extern _InstInfo II_3DNOW;

/* Helper tables for pseudo compare mnemonics. */
extern uint16_t CmpMnemonicOffsets[8]; /* SSE */
extern uint16_t VCmpMnemonicOffsets[32]; /* AVX */

#endif /* INSTS_H */

```

`NativeCore/Dependencies/distorm/src/mnemonics.c`:

```c
/*
mnemonics.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "../include/mnemonics.h"

#ifndef DISTORM_LIGHT

const unsigned char _MNEMONICS[] =
"\x09" "undefined\0" "\x03" "add\0" "\x04" "push\0" "\x03" "pop\0" \
"\x02" "or\0" "\x03" "adc\0" "\x03" "sbb\0" "\x03" "and\0" "\x03" "daa\0" \
"\x03" "sub\0" "\x03" "das\0" "\x03" "xor\0" "\x03" "aaa\0" "\x03" "cmp\0" \
"\x03" "aas\0" "\x03" "inc\0" "\x03" "dec\0" "\x05" "pusha\0" "\x04" "popa\0" \
"\x05" "bound\0" "\x04" "arpl\0" "\x04" "imul\0" "\x03" "ins\0" "\x04" "outs\0" \
"\x02" "jo\0" "\x03" "jno\0" "\x02" "jb\0" "\x03" "jae\0" "\x02" "jz\0" \
"\x03" "jnz\0" "\x03" "jbe\0" "\x02" "ja\0" "\x02" "js\0" "\x03" "jns\0" \
"\x02" "jp\0" "\x03" "jnp\0" "\x02" "jl\0" "\x03" "jge\0" "\x03" "jle\0" \
"\x02" "jg\0" "\x04" "test\0" "\x04" "xchg\0" "\x03" "mov\0" "\x03" "lea\0" \
"\x03" "cbw\0" "\x04" "cwde\0" "\x04" "cdqe\0" "\x03" "cwd\0" "\x03" "cdq\0" \
"\x03" "cqo\0" "\x08" "call far\0" "\x05" "pushf\0" "\x04" "popf\0" \
"\x04" "sahf\0" "\x04" "lahf\0" "\x04" "movs\0" "\x04" "cmps\0" "\x04" "stos\0" \
"\x04" "lods\0" "\x04" "scas\0" "\x03" "ret\0" "\x03" "les\0" "\x03" "lds\0" \
"\x05" "enter\0" "\x05" "leave\0" "\x04" "retf\0" "\x05" "int 3\0" \
"\x03" "int\0" "\x04" "into\0" "\x04" "iret\0" "\x03" "aam\0" "\x03" "aad\0" \
"\x04" "salc\0" "\x04" "xlat\0" "\x06" "loopnz\0" "\x05" "loopz\0" \
"\x04" "loop\0" "\x04" "jcxz\0" "\x05" "jecxz\0" "\x05" "jrcxz\0" "\x02" "in\0" \
"\x03" "out\0" "\x04" "call\0" "\x03" "jmp\0" "\x07" "jmp far\0" "\x04" "int1\0" \
"\x03" "hlt\0" "\x03" "cmc\0" "\x03" "clc\0" "\x03" "stc\0" "\x03" "cli\0" \
"\x03" "sti\0" "\x03" "cld\0" "\x03" "std\0" "\x03" "lar\0" "\x03" "lsl\0" \
"\x07" "syscall\0" "\x04" "clts\0" "\x06" "sysret\0" "\x04" "invd\0" \
"\x06" "wbinvd\0" "\x03" "ud2\0" "\x05" "femms\0" "\x03" "nop\0" "\x05" "wrmsr\0" \
"\x05" "rdtsc\0" "\x05" "rdmsr\0" "\x05" "rdpmc\0" "\x08" "sysenter\0" \
"\x07" "sysexit\0" "\x06" "getsec\0" "\x05" "cmovo\0" "\x06" "cmovno\0" \
"\x05" "cmovb\0" "\x06" "cmovae\0" "\x05" "cmovz\0" "\x06" "cmovnz\0" \
"\x06" "cmovbe\0" "\x05" "cmova\0" "\x05" "cmovs\0" "\x06" "cmovns\0" \
"\x05" "cmovp\0" "\x06" "cmovnp\0" "\x05" "cmovl\0" "\x06" "cmovge\0" \
"\x06" "cmovle\0" "\x05" "cmovg\0" "\x04" "seto\0" "\x05" "setno\0" \
"\x04" "setb\0" "\x05" "setae\0" "\x04" "setz\0" "\x05" "setnz\0" "\x05" "setbe\0" \
"\x04" "seta\0" "\x04" "sets\0" "\x05" "setns\0" "\x04" "setp\0" "\x05" "setnp\0" \
"\x04" "setl\0" "\x05" "setge\0" "\x05" "setle\0" "\x04" "setg\0" "\x05" "cpuid\0" \
"\x02" "bt\0" "\x04" "shld\0" "\x03" "rsm\0" "\x03" "bts\0" "\x04" "shrd\0" \
"\x07" "cmpxchg\0" "\x03" "lss\0" "\x03" "btr\0" "\x03" "lfs\0" "\x03" "lgs\0" \
"\x05" "movzx\0" "\x03" "btc\0" "\x05" "movsx\0" "\x04" "xadd\0" "\x06" "movnti\0" \
"\x05" "bswap\0" "\x03" "rol\0" "\x03" "ror\0" "\x03" "rcl\0" "\x03" "rcr\0" \
"\x03" "shl\0" "\x03" "shr\0" "\x03" "sal\0" "\x03" "sar\0" "\x06" "xabort\0" \
"\x06" "xbegin\0" "\x04" "fadd\0" "\x04" "fmul\0" "\x04" "fcom\0" "\x05" "fcomp\0" \
"\x04" "fsub\0" "\x05" "fsubr\0" "\x04" "fdiv\0" "\x05" "fdivr\0" "\x03" "fld\0" \
"\x03" "fst\0" "\x04" "fstp\0" "\x06" "fldenv\0" "\x05" "fldcw\0" "\x04" "fxch\0" \
"\x04" "fnop\0" "\x04" "fchs\0" "\x04" "fabs\0" "\x04" "ftst\0" "\x04" "fxam\0" \
"\x04" "fld1\0" "\x06" "fldl2t\0" "\x06" "fldl2e\0" "\x05" "fldpi\0" \
"\x06" "fldlg2\0" "\x06" "fldln2\0" "\x04" "fldz\0" "\x05" "f2xm1\0" \
"\x05" "fyl2x\0" "\x05" "fptan\0" "\x06" "fpatan\0" "\x07" "fxtract\0" \
"\x06" "fprem1\0" "\x07" "fdecstp\0" "\x07" "fincstp\0" "\x05" "fprem\0" \
"\x07" "fyl2xp1\0" "\x05" "fsqrt\0" "\x07" "fsincos\0" "\x07" "frndint\0" \
"\x06" "fscale\0" "\x04" "fsin\0" "\x04" "fcos\0" "\x05" "fiadd\0" \
"\x05" "fimul\0" "\x05" "ficom\0" "\x06" "ficomp\0" "\x05" "fisub\0" \
"\x06" "fisubr\0" "\x05" "fidiv\0" "\x06" "fidivr\0" "\x06" "fcmovb\0" \
"\x06" "fcmove\0" "\x07" "fcmovbe\0" "\x06" "fcmovu\0" "\x07" "fucompp\0" \
"\x04" "fild\0" "\x06" "fisttp\0" "\x04" "fist\0" "\x05" "fistp\0" \
"\x07" "fcmovnb\0" "\x07" "fcmovne\0" "\x08" "fcmovnbe\0" "\x07" "fcmovnu\0" \
"\x04" "feni\0" "\x06" "fedisi\0" "\x06" "fsetpm\0" "\x06" "fucomi\0" \
"\x05" "fcomi\0" "\x06" "frstor\0" "\x05" "ffree\0" "\x05" "fucom\0" \
"\x06" "fucomp\0" "\x05" "faddp\0" "\x05" "fmulp\0" "\x06" "fcompp\0" \
"\x06" "fsubrp\0" "\x05" "fsubp\0" "\x06" "fdivrp\0" "\x05" "fdivp\0" \
"\x04" "fbld\0" "\x05" "fbstp\0" "\x07" "fucomip\0" "\x06" "fcomip\0" \
"\x03" "not\0" "\x03" "neg\0" "\x03" "mul\0" "\x03" "div\0" "\x04" "idiv\0" \
"\x04" "sldt\0" "\x03" "str\0" "\x04" "lldt\0" "\x03" "ltr\0" "\x04" "verr\0" \
"\x04" "verw\0" "\x04" "sgdt\0" "\x04" "sidt\0" "\x04" "lgdt\0" "\x04" "lidt\0" \
"\x04" "smsw\0" "\x04" "lmsw\0" "\x06" "invlpg\0" "\x06" "vmcall\0" \
"\x08" "vmlaunch\0" "\x08" "vmresume\0" "\x06" "vmxoff\0" "\x07" "monitor\0" \
"\x05" "mwait\0" "\x04" "clac\0" "\x04" "stac\0" "\x06" "xgetbv\0" \
"\x06" "xsetbv\0" "\x06" "vmfunc\0" "\x04" "xend\0" "\x05" "vmrun\0" \
"\x07" "vmmcall\0" "\x06" "vmload\0" "\x06" "vmsave\0" "\x04" "stgi\0" \
"\x04" "clgi\0" "\x06" "skinit\0" "\x07" "invlpga\0" "\x06" "swapgs\0" \
"\x06" "rdtscp\0" "\x08" "prefetch\0" "\x09" "prefetchw\0" "\x05" "pi2fw\0" \
"\x05" "pi2fd\0" "\x05" "pf2iw\0" "\x05" "pf2id\0" "\x06" "pfnacc\0" \
"\x07" "pfpnacc\0" "\x07" "pfcmpge\0" "\x05" "pfmin\0" "\x05" "pfrcp\0" \
"\x07" "pfrsqrt\0" "\x05" "pfsub\0" "\x05" "pfadd\0" "\x07" "pfcmpgt\0" \
"\x05" "pfmax\0" "\x08" "pfrcpit1\0" "\x08" "pfrsqit1\0" "\x06" "pfsubr\0" \
"\x05" "pfacc\0" "\x07" "pfcmpeq\0" "\x05" "pfmul\0" "\x08" "pfrcpit2\0" \
"\x07" "pmulhrw\0" "\x06" "pswapd\0" "\x07" "pavgusb\0" "\x06" "movups\0" \
"\x06" "movupd\0" "\x05" "movss\0" "\x05" "movsd\0" "\x07" "vmovups\0" \
"\x07" "vmovupd\0" "\x06" "vmovss\0" "\x06" "vmovsd\0" "\x07" "movhlps\0" \
"\x06" "movlps\0" "\x06" "movlpd\0" "\x08" "movsldup\0" "\x07" "movddup\0" \
"\x08" "vmovhlps\0" "\x07" "vmovlps\0" "\x07" "vmovlpd\0" "\x09" "vmovsldup\0" \
"\x08" "vmovddup\0" "\x08" "unpcklps\0" "\x08" "unpcklpd\0" "\x09" "vunpcklps\0" \
"\x09" "vunpcklpd\0" "\x08" "unpckhps\0" "\x08" "unpckhpd\0" "\x09" "vunpckhps\0" \
"\x09" "vunpckhpd\0" "\x07" "movlhps\0" "\x06" "movhps\0" "\x06" "movhpd\0" \
"\x08" "movshdup\0" "\x08" "vmovlhps\0" "\x07" "vmovhps\0" "\x07" "vmovhpd\0" \
"\x09" "vmovshdup\0" "\x0b" "prefetchnta\0" "\x0a" "prefetcht0\0" "\x0a" "prefetcht1\0" \
"\x0a" "prefetcht2\0" "\x06" "movaps\0" "\x06" "movapd\0" "\x07" "vmovaps\0" \
"\x07" "vmovapd\0" "\x08" "cvtpi2ps\0" "\x08" "cvtpi2pd\0" "\x08" "cvtsi2ss\0" \
"\x08" "cvtsi2sd\0" "\x09" "vcvtsi2ss\0" "\x09" "vcvtsi2sd\0" "\x07" "movntps\0" \
"\x07" "movntpd\0" "\x07" "movntss\0" "\x07" "movntsd\0" "\x08" "vmovntps\0" \
"\x08" "vmovntpd\0" "\x09" "cvttps2pi\0" "\x09" "cvttpd2pi\0" "\x09" "cvttss2si\0" \
"\x09" "cvttsd2si\0" "\x0a" "vcvttss2si\0" "\x0a" "vcvttsd2si\0" "\x08" "cvtps2pi\0" \
"\x08" "cvtpd2pi\0" "\x08" "cvtss2si\0" "\x08" "cvtsd2si\0" "\x09" "vcvtss2si\0" \
"\x09" "vcvtsd2si\0" "\x07" "ucomiss\0" "\x07" "ucomisd\0" "\x08" "vucomiss\0" \
"\x08" "vucomisd\0" "\x06" "comiss\0" "\x06" "comisd\0" "\x07" "vcomiss\0" \
"\x07" "vcomisd\0" "\x08" "movmskps\0" "\x08" "movmskpd\0" "\x09" "vmovmskps\0" \
"\x09" "vmovmskpd\0" "\x06" "sqrtps\0" "\x06" "sqrtpd\0" "\x06" "sqrtss\0" \
"\x06" "sqrtsd\0" "\x07" "vsqrtps\0" "\x07" "vsqrtpd\0" "\x07" "vsqrtss\0" \
"\x07" "vsqrtsd\0" "\x07" "rsqrtps\0" "\x07" "rsqrtss\0" "\x08" "vrsqrtps\0" \
"\x08" "vrsqrtss\0" "\x05" "rcpps\0" "\x05" "rcpss\0" "\x06" "vrcpps\0" \
"\x06" "vrcpss\0" "\x05" "andps\0" "\x05" "andpd\0" "\x06" "vandps\0" \
"\x06" "vandpd\0" "\x06" "andnps\0" "\x06" "andnpd\0" "\x07" "vandnps\0" \
"\x07" "vandnpd\0" "\x04" "orps\0" "\x04" "orpd\0" "\x05" "vorps\0" \
"\x05" "vorpd\0" "\x05" "xorps\0" "\x05" "xorpd\0" "\x06" "vxorps\0" \
"\x06" "vxorpd\0" "\x05" "addps\0" "\x05" "addpd\0" "\x05" "addss\0" \
"\x05" "addsd\0" "\x06" "vaddps\0" "\x06" "vaddpd\0" "\x06" "vaddss\0" \
"\x06" "vaddsd\0" "\x05" "mulps\0" "\x05" "mulpd\0" "\x05" "mulss\0" \
"\x05" "mulsd\0" "\x06" "vmulps\0" "\x06" "vmulpd\0" "\x06" "vmulss\0" \
"\x06" "vmulsd\0" "\x08" "cvtps2pd\0" "\x08" "cvtpd2ps\0" "\x08" "cvtss2sd\0" \
"\x08" "cvtsd2ss\0" "\x09" "vcvtps2pd\0" "\x09" "vcvtpd2ps\0" "\x09" "vcvtss2sd\0" \
"\x09" "vcvtsd2ss\0" "\x08" "cvtdq2ps\0" "\x08" "cvtps2dq\0" "\x09" "cvttps2dq\0" \
"\x09" "vcvtdq2ps\0" "\x09" "vcvtps2dq\0" "\x0a" "vcvttps2dq\0" "\x05" "subps\0" \
"\x05" "subpd\0" "\x05" "subss\0" "\x05" "subsd\0" "\x06" "vsubps\0" \
"\x06" "vsubpd\0" "\x06" "vsubss\0" "\x06" "vsubsd\0" "\x05" "minps\0" \
"\x05" "minpd\0" "\x05" "minss\0" "\x05" "minsd\0" "\x06" "vminps\0" \
"\x06" "vminpd\0" "\x06" "vminss\0" "\x06" "vminsd\0" "\x05" "divps\0" \
"\x05" "divpd\0" "\x05" "divss\0" "\x05" "divsd\0" "\x06" "vdivps\0" \
"\x06" "vdivpd\0" "\x06" "vdivss\0" "\x06" "vdivsd\0" "\x05" "maxps\0" \
"\x05" "maxpd\0" "\x05" "maxss\0" "\x05" "maxsd\0" "\x06" "vmaxps\0" \
"\x06" "vmaxpd\0" "\x06" "vmaxss\0" "\x06" "vmaxsd\0" "\x09" "punpcklbw\0" \
"\x0a" "vpunpcklbw\0" "\x09" "punpcklwd\0" "\x0a" "vpunpcklwd\0" "\x09" "punpckldq\0" \
"\x0a" "vpunpckldq\0" "\x08" "packsswb\0" "\x09" "vpacksswb\0" "\x07" "pcmpgtb\0" \
"\x08" "vpcmpgtb\0" "\x07" "pcmpgtw\0" "\x08" "vpcmpgtw\0" "\x07" "pcmpgtd\0" \
"\x08" "vpcmpgtd\0" "\x08" "packuswb\0" "\x09" "vpackuswb\0" "\x09" "punpckhbw\0" \
"\x0a" "vpunpckhbw\0" "\x09" "punpckhwd\0" "\x0a" "vpunpckhwd\0" "\x09" "punpckhdq\0" \
"\x0a" "vpunpckhdq\0" "\x08" "packssdw\0" "\x09" "vpackssdw\0" "\x0a" "punpcklqdq\0" \
"\x0b" "vpunpcklqdq\0" "\x0a" "punpckhqdq\0" "\x0b" "vpunpckhqdq\0" "\x04" "movd\0" \
"\x04" "movq\0" "\x05" "vmovd\0" "\x05" "vmovq\0" "\x06" "movdqa\0" \
"\x06" "movdqu\0" "\x07" "vmovdqa\0" "\x07" "vmovdqu\0" "\x06" "pshufw\0" \
"\x06" "pshufd\0" "\x07" "pshufhw\0" "\x07" "pshuflw\0" "\x07" "vpshufd\0" \
"\x08" "vpshufhw\0" "\x08" "vpshuflw\0" "\x07" "pcmpeqb\0" "\x08" "vpcmpeqb\0" \
"\x07" "pcmpeqw\0" "\x08" "vpcmpeqw\0" "\x07" "pcmpeqd\0" "\x08" "vpcmpeqd\0" \
"\x04" "emms\0" "\x0a" "vzeroupper\0" "\x08" "vzeroall\0" "\x06" "vmread\0" \
"\x05" "extrq\0" "\x07" "insertq\0" "\x07" "vmwrite\0" "\x08" "cvtph2ps\0" \
"\x08" "cvtps2ph\0" "\x06" "haddpd\0" "\x06" "haddps\0" "\x07" "vhaddpd\0" \
"\x07" "vhaddps\0" "\x06" "hsubpd\0" "\x06" "hsubps\0" "\x07" "vhsubpd\0" \
"\x07" "vhsubps\0" "\x05" "xsave\0" "\x07" "xsave64\0" "\x06" "lfence\0" \
"\x06" "xrstor\0" "\x08" "xrstor64\0" "\x06" "mfence\0" "\x08" "xsaveopt\0" \
"\x0a" "xsaveopt64\0" "\x06" "sfence\0" "\x07" "clflush\0" "\x06" "popcnt\0" \
"\x03" "bsf\0" "\x05" "tzcnt\0" "\x03" "bsr\0" "\x05" "lzcnt\0" "\x07" "cmpeqps\0" \
"\x07" "cmpltps\0" "\x07" "cmpleps\0" "\x0a" "cmpunordps\0" "\x08" "cmpneqps\0" \
"\x08" "cmpnltps\0" "\x08" "cmpnleps\0" "\x08" "cmpordps\0" "\x07" "cmpeqpd\0" \
"\x07" "cmpltpd\0" "\x07" "cmplepd\0" "\x0a" "cmpunordpd\0" "\x08" "cmpneqpd\0" \
"\x08" "cmpnltpd\0" "\x08" "cmpnlepd\0" "\x08" "cmpordpd\0" "\x07" "cmpeqss\0" \
"\x07" "cmpltss\0" "\x07" "cmpless\0" "\x0a" "cmpunordss\0" "\x08" "cmpneqss\0" \
"\x08" "cmpnltss\0" "\x08" "cmpnless\0" "\x08" "cmpordss\0" "\x07" "cmpeqsd\0" \
"\x07" "cmpltsd\0" "\x07" "cmplesd\0" "\x0a" "cmpunordsd\0" "\x08" "cmpneqsd\0" \
"\x08" "cmpnltsd\0" "\x08" "cmpnlesd\0" "\x08" "cmpordsd\0" "\x08" "vcmpeqps\0" \
"\x08" "vcmpltps\0" "\x08" "vcmpleps\0" "\x0b" "vcmpunordps\0" "\x09" "vcmpneqps\0" \
"\x09" "vcmpnltps\0" "\x09" "vcmpnleps\0" "\x09" "vcmpordps\0" "\x0b" "vcmpeq_uqps\0" \
"\x09" "vcmpngeps\0" "\x09" "vcmpngtps\0" "\x0b" "vcmpfalseps\0" "\x0c" "vcmpneq_oqps\0" \
"\x08" "vcmpgeps\0" "\x08" "vcmpgtps\0" "\x0a" "vcmptrueps\0" "\x0b" "vcmpeq_osps\0" \
"\x0b" "vcmplt_oqps\0" "\x0b" "vcmple_oqps\0" "\x0d" "vcmpunord_sps\0" \
"\x0c" "vcmpneq_usps\0" "\x0c" "vcmpnlt_uqps\0" "\x0c" "vcmpnle_uqps\0" \
"\x0b" "vcmpord_sps\0" "\x0b" "vcmpeq_usps\0" "\x0c" "vcmpnge_uqps\0" \
"\x0c" "vcmpngt_uqps\0" "\x0e" "vcmpfalse_osps\0" "\x0c" "vcmpneq_osps\0" \
"\x0b" "vcmpge_oqps\0" "\x0b" "vcmpgt_oqps\0" "\x0d" "vcmptrue_usps\0" \
"\x08" "vcmpeqpd\0" "\x08" "vcmpltpd\0" "\x08" "vcmplepd\0" "\x0b" "vcmpunordpd\0" \
"\x09" "vcmpneqpd\0" "\x09" "vcmpnltpd\0" "\x09" "vcmpnlepd\0" "\x09" "vcmpordpd\0" \
"\x0b" "vcmpeq_uqpd\0" "\x09" "vcmpngepd\0" "\x09" "vcmpngtpd\0" "\x0b" "vcmpfalsepd\0" \
"\x0c" "vcmpneq_oqpd\0" "\x08" "vcmpgepd\0" "\x08" "vcmpgtpd\0" "\x0a" "vcmptruepd\0" \
"\x0b" "vcmpeq_ospd\0" "\x0b" "vcmplt_oqpd\0" "\x0b" "vcmple_oqpd\0" \
"\x0d" "vcmpunord_spd\0" "\x0c" "vcmpneq_uspd\0" "\x0c" "vcmpnlt_uqpd\0" \
"\x0c" "vcmpnle_uqpd\0" "\x0b" "vcmpord_spd\0" "\x0b" "vcmpeq_uspd\0" \
"\x0c" "vcmpnge_uqpd\0" "\x0c" "vcmpngt_uqpd\0" "\x0e" "vcmpfalse_ospd\0" \
"\x0c" "vcmpneq_ospd\0" "\x0b" "vcmpge_oqpd\0" "\x0b" "vcmpgt_oqpd\0" \
"\x0d" "vcmptrue_uspd\0" "\x08" "vcmpeqss\0" "\x08" "vcmpltss\0" "\x08" "vcmpless\0" \
"\x0b" "vcmpunordss\0" "\x09" "vcmpneqss\0" "\x09" "vcmpnltss\0" "\x09" "vcmpnless\0" \
"\x09" "vcmpordss\0" "\x0b" "vcmpeq_uqss\0" "\x09" "vcmpngess\0" "\x09" "vcmpngtss\0" \
"\x0b" "vcmpfalsess\0" "\x0c" "vcmpneq_oqss\0" "\x08" "vcmpgess\0" "\x08" "vcmpgtss\0" \
"\x0a" "vcmptruess\0" "\x0b" "vcmpeq_osss\0" "\x0b" "vcmplt_oqss\0" "\x0b" "vcmple_oqss\0" \
"\x0d" "vcmpunord_sss\0" "\x0c" "vcmpneq_usss\0" "\x0c" "vcmpnlt_uqss\0" \
"\x0c" "vcmpnle_uqss\0" "\x0b" "vcmpord_sss\0" "\x0b" "vcmpeq_usss\0" \
"\x0c" "vcmpnge_uqss\0" "\x0c" "vcmpngt_uqss\0" "\x0e" "vcmpfalse_osss\0" \
"\x0c" "vcmpneq_osss\0" "\x0b" "vcmpge_oqss\0" "\x0b" "vcmpgt_oqss\0" \
"\x0d" "vcmptrue_usss\0" "\x08" "vcmpeqsd\0" "\x08" "vcmpltsd\0" "\x08" "vcmplesd\0" \
"\x0b" "vcmpunordsd\0" "\x09" "vcmpneqsd\0" "\x09" "vcmpnltsd\0" "\x09" "vcmpnlesd\0" \
"\x09" "vcmpordsd\0" "\x0b" "vcmpeq_uqsd\0" "\x09" "vcmpngesd\0" "\x09" "vcmpngtsd\0" \
"\x0b" "vcmpfalsesd\0" "\x0c" "vcmpneq_oqsd\0" "\x08" "vcmpgesd\0" "\x08" "vcmpgtsd\0" \
"\x0a" "vcmptruesd\0" "\x0b" "vcmpeq_ossd\0" "\x0b" "vcmplt_oqsd\0" "\x0b" "vcmple_oqsd\0" \
"\x0d" "vcmpunord_ssd\0" "\x0c" "vcmpneq_ussd\0" "\x0c" "vcmpnlt_uqsd\0" \
"\x0c" "vcmpnle_uqsd\0" "\x0b" "vcmpord_ssd\0" "\x0b" "vcmpeq_ussd\0" \
"\x0c" "vcmpnge_uqsd\0" "\x0c" "vcmpngt_uqsd\0" "\x0e" "vcmpfalse_ossd\0" \
"\x0c" "vcmpneq_ossd\0" "\x0b" "vcmpge_oqsd\0" "\x0b" "vcmpgt_oqsd\0" \
"\x0d" "vcmptrue_ussd\0" "\x06" "pinsrw\0" "\x07" "vpinsrw\0" "\x06" "pextrw\0" \
"\x07" "vpextrw\0" "\x06" "shufps\0" "\x06" "shufpd\0" "\x07" "vshufps\0" \
"\x07" "vshufpd\0" "\x09" "cmpxchg8b\0" "\x0a" "cmpxchg16b\0" "\x07" "vmptrst\0" \
"\x08" "addsubpd\0" "\x08" "addsubps\0" "\x09" "vaddsubpd\0" "\x09" "vaddsubps\0" \
"\x05" "psrlw\0" "\x06" "vpsrlw\0" "\x05" "psrld\0" "\x06" "vpsrld\0" \
"\x05" "psrlq\0" "\x06" "vpsrlq\0" "\x05" "paddq\0" "\x06" "vpaddq\0" \
"\x06" "pmullw\0" "\x07" "vpmullw\0" "\x07" "movq2dq\0" "\x07" "movdq2q\0" \
"\x08" "pmovmskb\0" "\x09" "vpmovmskb\0" "\x07" "psubusb\0" "\x08" "vpsubusb\0" \
"\x07" "psubusw\0" "\x08" "vpsubusw\0" "\x06" "pminub\0" "\x07" "vpminub\0" \
"\x04" "pand\0" "\x05" "vpand\0" "\x07" "paddusb\0" "\x08" "vpaddusw\0" \
"\x07" "paddusw\0" "\x06" "pmaxub\0" "\x07" "vpmaxub\0" "\x05" "pandn\0" \
"\x06" "vpandn\0" "\x05" "pavgb\0" "\x06" "vpavgb\0" "\x05" "psraw\0" \
"\x06" "vpsraw\0" "\x05" "psrad\0" "\x06" "vpsrad\0" "\x05" "pavgw\0" \
"\x06" "vpavgw\0" "\x07" "pmulhuw\0" "\x08" "vpmulhuw\0" "\x06" "pmulhw\0" \
"\x07" "vpmulhw\0" "\x09" "cvttpd2dq\0" "\x08" "cvtdq2pd\0" "\x08" "cvtpd2dq\0" \
"\x0a" "vcvttpd2dq\0" "\x09" "vcvtdq2pd\0" "\x09" "vcvtpd2dq\0" "\x06" "movntq\0" \
"\x07" "movntdq\0" "\x08" "vmovntdq\0" "\x06" "psubsb\0" "\x07" "vpsubsb\0" \
"\x06" "psubsw\0" "\x07" "vpsubsw\0" "\x06" "pminsw\0" "\x07" "vpminsw\0" \
"\x03" "por\0" "\x04" "vpor\0" "\x06" "paddsb\0" "\x07" "vpaddsb\0" \
"\x06" "paddsw\0" "\x07" "vpaddsw\0" "\x06" "pmaxsw\0" "\x07" "vpmaxsw\0" \
"\x04" "pxor\0" "\x05" "vpxor\0" "\x05" "lddqu\0" "\x06" "vlddqu\0" \
"\x05" "psllw\0" "\x06" "vpsllw\0" "\x05" "pslld\0" "\x06" "vpslld\0" \
"\x05" "psllq\0" "\x06" "vpsllq\0" "\x07" "pmuludq\0" "\x08" "vpmuludq\0" \
"\x07" "pmaddwd\0" "\x08" "vpmaddwd\0" "\x06" "psadbw\0" "\x07" "vpsadbw\0" \
"\x08" "maskmovq\0" "\x0a" "maskmovdqu\0" "\x0b" "vmaskmovdqu\0" "\x05" "psubb\0" \
"\x06" "vpsubb\0" "\x05" "psubw\0" "\x06" "vpsubw\0" "\x05" "psubd\0" \
"\x06" "vpsubd\0" "\x05" "psubq\0" "\x06" "vpsubq\0" "\x05" "paddb\0" \
"\x06" "vpaddb\0" "\x05" "paddw\0" "\x06" "vpaddw\0" "\x05" "paddd\0" \
"\x06" "vpaddd\0" "\x07" "fnstenv\0" "\x06" "fstenv\0" "\x06" "fnstcw\0" \
"\x05" "fstcw\0" "\x06" "fnclex\0" "\x05" "fclex\0" "\x06" "fninit\0" \
"\x05" "finit\0" "\x06" "fnsave\0" "\x05" "fsave\0" "\x06" "fnstsw\0" \
"\x05" "fstsw\0" "\x06" "pshufb\0" "\x07" "vpshufb\0" "\x06" "phaddw\0" \
"\x07" "vphaddw\0" "\x06" "phaddd\0" "\x07" "vphaddd\0" "\x07" "phaddsw\0" \
"\x08" "vphaddsw\0" "\x09" "pmaddubsw\0" "\x0a" "vpmaddubsw\0" "\x06" "phsubw\0" \
"\x07" "vphsubw\0" "\x06" "phsubd\0" "\x07" "vphsubd\0" "\x07" "phsubsw\0" \
"\x08" "vphsubsw\0" "\x06" "psignb\0" "\x07" "vpsignb\0" "\x06" "psignw\0" \
"\x07" "vpsignw\0" "\x06" "psignd\0" "\x07" "vpsignd\0" "\x08" "pmulhrsw\0" \
"\x09" "vpmulhrsw\0" "\x09" "vpermilps\0" "\x09" "vpermilpd\0" "\x07" "vtestps\0" \
"\x07" "vtestpd\0" "\x08" "pblendvb\0" "\x08" "blendvps\0" "\x08" "blendvpd\0" \
"\x05" "ptest\0" "\x06" "vptest\0" "\x0c" "vbroadcastss\0" "\x0c" "vbroadcastsd\0" \
"\x0e" "vbroadcastf128\0" "\x05" "pabsb\0" "\x06" "vpabsb\0" "\x05" "pabsw\0" \
"\x06" "vpabsw\0" "\x05" "pabsd\0" "\x06" "vpabsd\0" "\x08" "pmovsxbw\0" \
"\x09" "vpmovsxbw\0" "\x08" "pmovsxbd\0" "\x09" "vpmovsxbd\0" "\x08" "pmovsxbq\0" \
"\x09" "vpmovsxbq\0" "\x08" "pmovsxwd\0" "\x09" "vpmovsxwd\0" "\x08" "pmovsxwq\0" \
"\x09" "vpmovsxwq\0" "\x08" "pmovsxdq\0" "\x09" "vpmovsxdq\0" "\x06" "pmuldq\0" \
"\x07" "vpmuldq\0" "\x07" "pcmpeqq\0" "\x08" "vpcmpeqq\0" "\x08" "movntdqa\0" \
"\x09" "vmovntdqa\0" "\x08" "packusdw\0" "\x09" "vpackusdw\0" "\x0a" "vmaskmovps\0" \
"\x0a" "vmaskmovpd\0" "\x08" "pmovzxbw\0" "\x09" "vpmovzxbw\0" "\x08" "pmovzxbd\0" \
"\x09" "vpmovzxbd\0" "\x08" "pmovzxbq\0" "\x09" "vpmovzxbq\0" "\x08" "pmovzxwd\0" \
"\x09" "vpmovzxwd\0" "\x08" "pmovzxwq\0" "\x09" "vpmovzxwq\0" "\x08" "pmovzxdq\0" \
"\x09" "vpmovzxdq\0" "\x07" "pcmpgtq\0" "\x08" "vpcmpgtq\0" "\x06" "pminsb\0" \
"\x07" "vpminsb\0" "\x06" "pminsd\0" "\x07" "vpminsd\0" "\x06" "pminuw\0" \
"\x07" "vpminuw\0" "\x06" "pminud\0" "\x07" "vpminud\0" "\x06" "pmaxsb\0" \
"\x07" "vpmaxsb\0" "\x06" "pmaxsd\0" "\x07" "vpmaxsd\0" "\x06" "pmaxuw\0" \
"\x07" "vpmaxuw\0" "\x06" "pmaxud\0" "\x07" "vpmaxud\0" "\x06" "pmulld\0" \
"\x07" "vpmulld\0" "\x0a" "phminposuw\0" "\x0b" "vphminposuw\0" "\x06" "invept\0" \
"\x07" "invvpid\0" "\x07" "invpcid\0" "\x0e" "vfmaddsub132ps\0" "\x0e" "vfmaddsub132pd\0" \
"\x0e" "vfmsubadd132ps\0" "\x0e" "vfmsubadd132pd\0" "\x0b" "vfmadd132ps\0" \
"\x0b" "vfmadd132pd\0" "\x0b" "vfmadd132ss\0" "\x0b" "vfmadd132sd\0" \
"\x0b" "vfmsub132ps\0" "\x0b" "vfmsub132pd\0" "\x0b" "vfmsub132ss\0" \
"\x0b" "vfmsub132sd\0" "\x0c" "vfnmadd132ps\0" "\x0c" "vfnmadd132pd\0" \
"\x0c" "vfnmadd132ss\0" "\x0c" "vfnmadd132sd\0" "\x0c" "vfnmsub132ps\0" \
"\x0c" "vfnmsub132pd\0" "\x0c" "vfnmsub132ss\0" "\x0c" "vfnmsub132sd\0" \
"\x0e" "vfmaddsub213ps\0" "\x0e" "vfmaddsub213pd\0" "\x0e" "vfmsubadd213ps\0" \
"\x0e" "vfmsubadd213pd\0" "\x0b" "vfmadd213ps\0" "\x0b" "vfmadd213pd\0" \
"\x0b" "vfmadd213ss\0" "\x0b" "vfmadd213sd\0" "\x0b" "vfmsub213ps\0" \
"\x0b" "vfmsub213pd\0" "\x0b" "vfmsub213ss\0" "\x0b" "vfmsub213sd\0" \
"\x0c" "vfnmadd213ps\0" "\x0c" "vfnmadd213pd\0" "\x0c" "vfnmadd213ss\0" \
"\x0c" "vfnmadd213sd\0" "\x0c" "vfnmsub213ps\0" "\x0c" "vfnmsub213pd\0" \
"\x0c" "vfnmsub213ss\0" "\x0c" "vfnmsub213sd\0" "\x0e" "vfmaddsub231ps\0" \
"\x0e" "vfmaddsub231pd\0" "\x0e" "vfmsubadd231ps\0" "\x0e" "vfmsubadd231pd\0" \
"\x0b" "vfmadd231ps\0" "\x0b" "vfmadd231pd\0" "\x0b" "vfmadd231ss\0" \
"\x0b" "vfmadd231sd\0" "\x0b" "vfmsub231ps\0" "\x0b" "vfmsub231pd\0" \
"\x0b" "vfmsub231ss\0" "\x0b" "vfmsub231sd\0" "\x0c" "vfnmadd231ps\0" \
"\x0c" "vfnmadd231pd\0" "\x0c" "vfnmadd231ss\0" "\x0c" "vfnmadd231sd\0" \
"\x0c" "vfnmsub231ps\0" "\x0c" "vfnmsub231pd\0" "\x0c" "vfnmsub231ss\0" \
"\x0c" "vfnmsub231sd\0" "\x06" "aesimc\0" "\x07" "vaesimc\0" "\x06" "aesenc\0" \
"\x07" "vaesenc\0" "\x0a" "aesenclast\0" "\x0b" "vaesenclast\0" "\x06" "aesdec\0" \
"\x07" "vaesdec\0" "\x0a" "aesdeclast\0" "\x0b" "vaesdeclast\0" "\x05" "movbe\0" \
"\x05" "crc32\0" "\x0a" "vperm2f128\0" "\x07" "roundps\0" "\x08" "vroundps\0" \
"\x07" "roundpd\0" "\x08" "vroundpd\0" "\x07" "roundss\0" "\x08" "vroundss\0" \
"\x07" "roundsd\0" "\x08" "vroundsd\0" "\x07" "blendps\0" "\x08" "vblendps\0" \
"\x07" "blendpd\0" "\x08" "vblendpd\0" "\x07" "pblendw\0" "\x08" "vpblendw\0" \
"\x07" "palignr\0" "\x08" "vpalignr\0" "\x06" "pextrb\0" "\x07" "vpextrb\0" \
"\x06" "pextrd\0" "\x06" "pextrq\0" "\x07" "vpextrd\0" "\x07" "vpextrq\0" \
"\x09" "extractps\0" "\x0a" "vextractps\0" "\x0b" "vinsertf128\0" "\x0c" "vextractf128\0" \
"\x06" "pinsrb\0" "\x07" "vpinsrb\0" "\x08" "insertps\0" "\x09" "vinsertps\0" \
"\x06" "pinsrd\0" "\x06" "pinsrq\0" "\x07" "vpinsrd\0" "\x07" "vpinsrq\0" \
"\x04" "dpps\0" "\x05" "vdpps\0" "\x04" "dppd\0" "\x05" "vdppd\0" "\x07" "mpsadbw\0" \
"\x08" "vmpsadbw\0" "\x09" "pclmulqdq\0" "\x0a" "vpclmulqdq\0" "\x09" "vblendvps\0" \
"\x09" "vblendvpd\0" "\x09" "vpblendvb\0" "\x09" "pcmpestrm\0" "\x0a" "vpcmpestrm\0" \
"\x09" "pcmpestri\0" "\x0a" "vpcmpestri\0" "\x09" "pcmpistrm\0" "\x0a" "vpcmpistrm\0" \
"\x09" "pcmpistri\0" "\x0a" "vpcmpistri\0" "\x0f" "aeskeygenassist\0" \
"\x10" "vaeskeygenassist\0" "\x06" "psrldq\0" "\x07" "vpsrldq\0" "\x06" "pslldq\0" \
"\x07" "vpslldq\0" "\x06" "fxsave\0" "\x08" "fxsave64\0" "\x08" "rdfsbase\0" \
"\x07" "fxrstor\0" "\x09" "fxrstor64\0" "\x08" "rdgsbase\0" "\x07" "ldmxcsr\0" \
"\x08" "wrfsbase\0" "\x08" "vldmxcsr\0" "\x07" "stmxcsr\0" "\x08" "wrgsbase\0" \
"\x08" "vstmxcsr\0" "\x07" "vmptrld\0" "\x07" "vmclear\0" "\x05" "vmxon\0" \
"\x06" "movsxd\0" "\x05" "pause\0" "\x04" "wait\0" "\x06" "rdrand\0" \
"\x06" "_3dnow\0" \
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"; /* Sentinel mnemonic. */

const _WRegister _REGISTERS[] = {
	{3, "rax"}, {3, "rcx"}, {3, "rdx"}, {3, "rbx"}, {3, "rsp"}, {3, "rbp"}, {3, "rsi"}, {3, "rdi"}, {2, "r8"}, {2, "r9"}, {3, "r10"}, {3, "r11"}, {3, "r12"}, {3, "r13"}, {3, "r14"}, {3, "r15"},
	{3, "eax"}, {3, "ecx"}, {3, "edx"}, {3, "ebx"}, {3, "esp"}, {3, "ebp"}, {3, "esi"}, {3, "edi"}, {3, "r8d"}, {3, "r9d"}, {4, "r10d"}, {4, "r11d"}, {4, "r12d"}, {4, "r13d"}, {4, "r14d"}, {4, "r15d"},
	{2, "ax"}, {2, "cx"}, {2, "dx"}, {2, "bx"}, {2, "sp"}, {2, "bp"}, {2, "si"}, {2, "di"}, {3, "r8w"}, {3, "r9w"}, {4, "r10w"}, {4, "r11w"}, {4, "r12w"}, {4, "r13w"}, {4, "r14w"}, {4, "r15w"},
	{2, "al"}, {2, "cl"}, {2, "dl"}, {2, "bl"}, {2, "ah"}, {2, "ch"}, {2, "dh"}, {2, "bh"}, {3, "r8b"}, {3, "r9b"}, {4, "r10b"}, {4, "r11b"}, {4, "r12b"}, {4, "r13b"}, {4, "r14b"}, {4, "r15b"},
	{3, "spl"}, {3, "bpl"}, {3, "sil"}, {3, "dil"},
	{2, "es"}, {2, "cs"}, {2, "ss"}, {2, "ds"}, {2, "fs"}, {2, "gs"},
	{3, "rip"},
	{3, "st0"}, {3, "st1"}, {3, "st2"}, {3, "st3"}, {3, "st4"}, {3, "st5"}, {3, "st6"}, {3, "st7"},
	{3, "mm0"}, {3, "mm1"}, {3, "mm2"}, {3, "mm3"}, {3, "mm4"}, {3, "mm5"}, {3, "mm6"}, {3, "mm7"},
	{4, "xmm0"}, {4, "xmm1"}, {4, "xmm2"}, {4, "xmm3"}, {4, "xmm4"}, {4, "xmm5"}, {4, "xmm6"}, {4, "xmm7"}, {4, "xmm8"}, {4, "xmm9"}, {5, "xmm10"}, {5, "xmm11"}, {5, "xmm12"}, {5, "xmm13"}, {5, "xmm14"}, {5, "xmm15"},
	{4, "ymm0"}, {4, "ymm1"}, {4, "ymm2"}, {4, "ymm3"}, {4, "ymm4"}, {4, "ymm5"}, {4, "ymm6"}, {4, "ymm7"}, {4, "ymm8"}, {4, "ymm9"}, {5, "ymm10"}, {5, "ymm11"}, {5, "ymm12"}, {5, "ymm13"}, {5, "ymm14"}, {5, "ymm15"},
	{3, "cr0"}, {0, ""}, {3, "cr2"}, {3, "cr3"}, {3, "cr4"}, {0, ""}, {0, ""}, {0, ""}, {3, "cr8"},
	{3, "dr0"}, {3, "dr1"}, {3, "dr2"}, {3, "dr3"}, {0, ""}, {0, ""}, {3, "dr6"}, {3, "dr7"},
	{0, ""} /* There must be an empty last reg, see strcat_WSR. */
};

#endif /* DISTORM_LIGHT */

```

`NativeCore/Dependencies/distorm/src/operands.c`:

```c
/*
operands.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "operands.h"
#include "x86defs.h"
#include "insts.h"
#include "../include/mnemonics.h"


/* Maps a register to its register-class mask. */
uint32_t _REGISTERTORCLASS[] = /* Based on _RegisterType enumeration! */
{RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_AX, RM_CX, RM_DX, RM_BX, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_SP, RM_BP, RM_SI, RM_DI,
 RM_SEG, RM_SEG, RM_SEG, RM_SEG, RM_SEG, RM_SEG,
 0,
 RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU,
 RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX,
 RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE,
 RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX,
 RM_CR, 0, RM_CR, RM_CR, RM_CR, 0, 0, 0, RM_CR,
 RM_DR, RM_DR, RM_DR, RM_DR, 0, 0, RM_DR, RM_DR
};

/* A helper function to fix the 8 bits register if REX is used (to support SIL, DIL, etc). */
_INLINE_ unsigned int _FASTCALL_ operands_fix_8bit_rex_base(unsigned int reg)
{
	if ((reg >= 4) && (reg < 8)) return reg + REGS8_REX_BASE - 4;
	return reg + REGS8_BASE;
}

/* A helper function to set operand's type and size. */
_INLINE_ void operands_set_ts(_Operand* op, _OperandType type, uint16_t size)
{
	op->type = type;
	op->size = size;
}

/* A helper function to set operand's type, size and index. */
_INLINE_ void operands_set_tsi(_DInst* di, _Operand* op, _OperandType type, uint16_t size, unsigned int index)
{
	op->type = type;
	op->index = (uint8_t)index;
	op->size = size;
	di->usedRegistersMask |= _REGISTERTORCLASS[index];
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint8(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return FALSE;
	*(uint8_t*)result = *(uint8_t*)ci->code;
	ci->code += 1;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint16(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 2;
	if (ci->codeLen < 0) return FALSE;
	*(uint16_t*)result = RUSHORT(ci->code);
	ci->code += 2;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint32(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 4;
	if (ci->codeLen < 0) return FALSE;
	*(uint32_t*)result = RULONG(ci->code);
	ci->code += 4;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint64(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 8;
	if (ci->codeLen < 0) return FALSE;
	*(uint64_t*)result = RULLONG(ci->code);
	ci->code += 8;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint8(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return FALSE;
	*result = *(int8_t*)ci->code;
	ci->code += 1;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint16(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 2;
	if (ci->codeLen < 0) return FALSE;
	*result = RSHORT(ci->code);
	ci->code += 2;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint32(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 4;
	if (ci->codeLen < 0) return FALSE;
	*result = RLONG(ci->code);
	ci->code += 4;
	return TRUE;
}

/*
 * SIB decoding is the most confusing part when decoding IA-32 instructions.
 * This explanation should clear up some stuff.
 *
 * ! When base == 5, use EBP as the base register !
 * if (rm == 4) {
 *	if mod == 01, decode SIB byte and ALSO read a 8 bits displacement.
 *	if mod == 10, decode SIB byte and ALSO read a 32 bits displacement.
 *	if mod == 11 <-- EXCEPTION, this is a general-purpose register and mustn't lead to SIB decoding!
 *	; So far so good, now the confusing part comes in with mod == 0 and base=5, but no worry.
 *	if (mod == 00) {
 *	 decode SIB byte WITHOUT any displacement.
 *	 EXCEPTION!!! when base == 5, read a 32 bits displacement, but this time DO NOT use (EBP) BASE at all!
 *	}
 *
 *	NOTE: base could specify None (no base register) if base==5 and mod==0, but then you also need DISP32.
 * }
 */
static void operands_extract_sib(_DInst* di,
                                 _PrefixState* ps, _DecodeType effAdrSz,
                                 unsigned int sib, unsigned int mod, _Operand* op)
{
	unsigned char scale, index, base;
	unsigned int vrex = ps->vrex;
	uint8_t* pIndex = NULL;

	/*
	 * SIB bits:
	 * |7---6-5----3-2---0|
	 * |SCALE| INDEX| BASE|
	 * |------------------|
	 */
	index = (sib >> 3) & 7;
	base = sib & 7;

	/*
	 * The following fields: base/index/scale/disp8/32 are ALL optional by specific rules!
	 * The idea here is to keep the indirection as a simple-memory type.
	 * Because the base is optional, and we might be left with only one index.
	 * So even if there's a base but no index, or vice versa, we end up with one index register.
	 */

	/* In 64 bits the REX prefix might affect the index of the SIB byte. */
	if (vrex & PREFIX_EX_X) {
		ps->usedPrefixes |= INST_PRE_REX;
		index += EX_GPR_BASE;
	}

	if (index == 4) { /* No index is used. Use SMEM. */
		op->type = O_SMEM;
		pIndex = &op->index;
	} else {
		op->type = O_MEM;
		pIndex = &di->base;
		/* No base, unless it is updated below. E.G: [EAX*4] has no base reg. */
	}

	if (base != 5) {
		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		*pIndex = effAdrSz == Decode64Bits ? REGS64_BASE : REGS32_BASE;
		*pIndex += (uint8_t)(base + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));

		if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
	} else if (mod != 0) {
		/*
		 * if base == 5 then you have to decode according to MOD.
		 * mod(00) - disp32.
		 * mod(01) - disp8 + rBP
		 * mod(10) - disp32 + rBP
		 * mod(11) - not possible, it's a general-purpose register.
		 */

		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		if (effAdrSz == Decode64Bits) *pIndex = REGS64_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
		else *pIndex = REGS32_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);

		if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
	} else if (index == 4) {
		 /* 32bits displacement only. */
		op->type = O_DISP;
		return;
	}

	if (index != 4) { /* In 64 bits decoding mode, if index == R12, it's valid! */
		scale = (sib >> 6) & 3;
		if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + index);
		else op->index = (uint8_t)(REGS32_BASE + index);
		di->scale = scale != 0 ? (1 << scale) : 0;
	}
}

/*
 * This seems to be the hardest part in decoding the operands.
 * If you take a look carefully at Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte,
 * you will understand it's easy to decode the operands.

 * First we check the DT, so we can decide according to which Table in the documentation we are supposed to decode.
 * Then we follow the specific table whether it's 16 bits or 32/64 bits.

 * Don't forget that Operand Size AND Address Size prefixes may change the decoding!

 * Some instructions force the use of RM16 or other specific types, so take it into account.
 */
static int operands_extract_modrm(_CodeInfo* ci, _PrefixState* ps, _DInst* di,
                                  _DecodeType effAdrSz, unsigned int mod, unsigned int rm,
                                  _iflags instFlags, _Operand* op)
{
	unsigned char sib = 0, base = 0;

	/* Memory indirection decoding ahead:) */

	ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	if ((instFlags & INST_PRE_LOCK) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
		ps->usedPrefixes |= INST_PRE_LOCK;
		di->flags |= FLAG_LOCK;
	}

	if (effAdrSz != Decode16Bits) { /* Decode32Bits or Decode64Bits! */
		/* Remember that from a 32/64 bits ModR/M byte a SIB byte could follow! */
		if ((rm == 5) && (mod == 0)) {
			/* 5 is a special case - only 32 bits displacement, or RIP relative. */
			di->dispSize = 32;
			if (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;

			/* Absolute address: */
			op->type = O_DISP;

			if (ci->dt == Decode64Bits) {
				/* In 64 bits decoding mode depsite of the address size, a RIP-relative address it is. */
				op->type = O_SMEM;
				op->index = R_RIP;
				di->flags |= FLAG_RIP_RELATIVE;
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
		else {
			if (rm == 4) {
				/* 4 is a special case - SIB byte + disp8/32 follows! */
				/* Read SIB byte. */
				if (!read_stream_safe_uint8(ci, &sib)) return FALSE;
				operands_extract_sib(di, ps, effAdrSz, sib, mod, op);
			}
			else {
				op->type = O_SMEM;
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}

				if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + rm);
				else op->index = (uint8_t)(REGS32_BASE + rm);
			}

			if (mod == 1) {
				di->dispSize = 8;
				if (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;
			}
			else if ((mod == 2) || ((sib & 7) == 5)) { /* If there is no BASE, read DISP32! */
				di->dispSize = 32;
				if (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;
			}

			/* Get the base register. */
			base = op->index;
			if (di->base != R_NONE) base = di->base;
			else if (di->scale >= 2) base = 0; /* If it's only an index but got scale, it's still DS. */
			/* Default for EBP/ESP is SS segment. 64 bits mode ignores DS anyway. */
			if ((base == R_EBP) || (base == R_ESP)) prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
			else prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	}
	else { /* Decode16Bits */
		/* Decoding according to Table 2-1. (16 bits) */
		if ((mod == 0) && (rm == 6)) {
			/* 6 is a special case - only 16 bits displacement. */
			op->type = O_DISP;
			di->dispSize = 16;
			if (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;
		}
		else {
			/*
			 * Create the O_MEM for 16 bits indirection that requires 2 registers, E.G: [BS+SI].
			 * or create O_SMEM for a single register indirection, E.G: [BP].
			 */
			static uint8_t MODS[] = { R_BX, R_BX, R_BP, R_BP, R_SI, R_DI, R_BP, R_BX };
			static uint8_t MODS2[] = { R_SI, R_DI, R_SI, R_DI };
			if (rm < 4) {
				op->type = O_MEM;
				di->base = MODS[rm];
				di->usedRegistersMask |= _REGISTERTORCLASS[MODS[rm]];
				op->index = MODS2[rm];
			}
			else {
				op->type = O_SMEM;
				op->index = MODS[rm];
			}

			if (mod == 1) { /* 8 bits displacement + indirection */
				di->dispSize = 8;
				if (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;
			}
			else if (mod == 2) { /* 16 bits displacement + indirection */
				di->dispSize = 16;
				if (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;
			}
		}

		if ((rm == 2) || (rm == 3) || ((rm == 6) && (mod != 0))) {
			/* BP's default segment is SS, so ignore it. */
			prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		}
		else {
			/* Ignore default DS segment. */
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	}

	return TRUE;
}


/*
 * This function is reponsible to textually format a required operand according to its type.
 * It is vital to understand that there are other operands than what the ModR/M byte specifies.

 * Only by decoding the operands of an instruction which got a LOCK prefix, we could tell whether it may use the LOCK prefix.
 * According to Intel, LOCK prefix must precede some specific instructions AND in their memory destination operand form (which means first operand).
 * LOCK INC EAX, would generate an exception, but LOCK INC [EAX] is alright.
 * Also LOCK ADD BX, [BP] would generate an exception.

 * Return code:
 * TRUE - continue parsing the instruction and its operands, everything went right 'till now.
 * FALSE - not enough bytes, or invalid operands.
 */

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, _Operand* op)
{
	int ret = 0;
	unsigned int mod, reg, rm;
	unsigned int size = 0;

	/*
	 * ModRM bits:
	 * |7-6-5--------3-2-0|
	 * |MOD|REG/OPCODE|RM |
	 * |------------------|
	 */
	/* mod = (modrm >> 6) & 3; */ /* Mode(register-indirection, disp8+reg+indirection, disp16+reg+indirection, general-purpose register) */
	/* reg = (modrm >> 3) & 7; */ /* Register(could be part of the opcode itself or general-purpose register) */
	/* rm = modrm & 7; */ /* Specifies which general-purpose register or disp+reg to use. */

	/* -- Memory Indirection Operands (that cannot be a general purpose register) -- */
	if ((type >= OT_MEM) && (type <= OT_LMEM128_256)) {
		/* All of the above types can't use a general-purpose register (a MOD of 3)!. */
		mod = (modrm >> 6) & 3;

		if (mod == 3) {
			if (type == OT_MEM_OPT) {
				/* Since the MEM is optional, only when mod != 3, then return true as if the operand was alright. */
				return TRUE;
			}
			return FALSE;
		}

		switch (type)
		{
			case OT_MEM64_128: /* Used only by CMPXCHG8/16B. */
				if (effOpSz == Decode64Bits) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 128;
				}
				else size = 64;
			break;
			case OT_MEM32: size = 32; break;
			case OT_MEM32_64:
				/* Used by MOVNTI. Default size is 32bits, 64bits with REX. */
				if (effOpSz == Decode64Bits) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
				}
				else size = 32;
			break;
			case OT_MEM64: size = 64; break;
			case OT_MEM128: size = 128; break;
			case OT_MEM16_FULL: /* The size indicates about the second item of the pair. */
				switch (effOpSz)
				{
					case Decode16Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						size = 16;
					break;
					case Decode32Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						size = 32;
					break;
					case Decode64Bits:
						/* Mark usage of REX only if it was required. */
						if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) ps->usedPrefixes |= INST_PRE_REX;
						size = 64;
					break;
				}
			break;
			case OT_MEM16_3264: /* The size indicates about the second item of the pair. */
				if (ci->dt == Decode64Bits) size = 64;
				else size = 32;
			break;
			case OT_FPUM16: size = 16; break;
			case OT_FPUM32: size = 32; break;
			case OT_FPUM64: size = 64; break;
			case OT_FPUM80: size = 80; break;
			case OT_LMEM128_256:
				if (ps->vrex & PREFIX_EX_L) size = 256;
				else size = 128;
			break;
			case OT_MEM_OPT: /* Here we know it's not optional. */
			case OT_MEM: size = 0; /* Size is unknown, but still handled. */ break;
			default: return FALSE;
		}
		rm = modrm & 7;
		ret = operands_extract_modrm(ci, ps, di, effAdrSz, mod, rm, instFlags, op);
		op->size = (uint16_t)size;
		if ((op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* -- Memory Indirection Operands (that can be a register) -- */
	if ((type >= OT_RM8) && (type <= OT_LXMM64_128)) {
		mod = (modrm >> 6) & 3;
		if (mod != 3) {
			switch (type)
			{
				case OT_RM_FULL:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					/* PUSH/JMP/CALL are automatically promoted to 64 bits! */
					if (effOpSz == Decode32Bits) {
						size = 32;
						break;
					}
					else if (effOpSz == Decode64Bits) {
						/* Mark usage of REX only if it was required. */
						if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
						size = 64;
						break;
					}
					/* FALL THROUGH BECAUSE dt==Decoded16Bits @-<----*/
				case OT_RM16:
					/* If we got here not from OT_RM16, then the prefix was used. */
					if (type != OT_RM16) ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
				break;
				case OT_RM32_64:
					/* The default size is 32, which can be 64 with a REX only. */
					if (effOpSz == Decode64Bits) {
						size = 64;
						/* Mark REX prefix as used if non-promoted instruction. */
						if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) {
							ps->usedPrefixes |= INST_PRE_REX;
						}
					}
					else size = 32;
				break;
				case OT_RM16_32:
					/* Ignore REX, it's either 32 or 16 bits RM. */
					if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						/* Assume: We are in 64bits when we have this operand used. */
						size = 16;
					}
					else size = 32;
				break;
				case OT_WXMM32_64:
				case OT_WRM32_64:
					if (ps->vrex & PREFIX_EX_W) size = 64;
					else size = 32;
				break;
				case OT_YXMM64_256:
					if (ps->vrex & PREFIX_EX_L) size = 256;
					else size = 64;
				break;
				case OT_YXMM128_256:
					if (ps->vrex & PREFIX_EX_L) size = 256;
					else size = 128;
				break;
				case OT_LXMM64_128:
					if (ps->vrex & PREFIX_EX_L) size = 128;
					else size = 64;
				break;
				case OT_RFULL_M16:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
				break;

				case OT_RM8:
				case OT_R32_M8:
				case OT_R32_64_M8:
				case OT_REG32_64_M8:
					size = 8;
				break;

				case OT_XMM16:
				case OT_R32_M16:
				case OT_R32_64_M16:
				case OT_REG32_64_M16:
					size = 16;
				break;

				case OT_RM32:
				case OT_MM32:
				case OT_XMM32:
					size = 32;
				break;

				case OT_MM64:
				case OT_XMM64:
					size = 64;
				break;

				case OT_XMM128: size = 128; break;
				case OT_YMM256: size = 256; break;
				default: return FALSE;
			}
			/* Fill size of memory dereference for operand. */
			rm = modrm & 7;
			ret = operands_extract_modrm(ci, ps, di, effAdrSz, mod, rm, instFlags, op);
			op->size = (uint16_t)size;
			if ((op->type == O_SMEM) || (op->type == O_MEM)) {
				di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
			}
			return ret;
		}
		else {
			/*
			 * General-purpose register is handled the same way in 16/32/64 bits decoding modes.
			 * NOTE!! that we have to override the size of the register, since it was set earlier as Memory and not Register!
			 */
			rm = modrm & 7;
			size = 0;
			switch (type)
			{
			case OT_RFULL_M16:
			case OT_RM_FULL:
				switch (effOpSz)
				{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 16;
					rm += REGS16_BASE;
					break;
				case Decode32Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 32;
					rm += REGS32_BASE;
					break;
				case Decode64Bits:
					/* A fix for SMSW RAX which use the REX prefix. */
					if (type == OT_RFULL_M16) ps->usedPrefixes |= INST_PRE_REX;
					/* CALL NEAR/PUSH/POP defaults to 64 bits. --> INST_64BITS, REX isn't required, thus ignored anyways. */
					if (instFlags & INST_PRE_REX) ps->usedPrefixes |= INST_PRE_REX;
					/* Mark usage of REX only if it was required. */
					if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
					/* Include REX if used for REX.B. */
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				break;
			case OT_R32_64_M8:
				/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_R32_64_M16:
				/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_RM32_64: /* Take care specifically in MOVNTI/MOVD/CVT's instructions, making it _REG64 with REX or if they are promoted. */
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
				if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
				if (ps->vrex & PREFIX_EX_W) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
					rm += REGS64_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;
			case OT_RM16_32: /* Used only with MOVZXD instruction to support 16 bits operand. */
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it 16 bits operand size? */
				if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
					rm += REGS16_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;
			case OT_RM16:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				rm += REGS16_BASE;
				size = 16;
				break;
			case OT_RM8:
				if (ps->prefixExtType == PET_REX) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm = operands_fix_8bit_rex_base(rm + ((ps->vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
				}
				else rm += REGS8_BASE;
				size = 8;
				break;
			case OT_MM32:
			case OT_MM64:
				/* MMX doesn't support extended registers. */
				size = 64;
				rm += MMXREGS_BASE;
				break;

			case OT_XMM16:
			case OT_XMM32:
			case OT_XMM64:
			case OT_XMM128:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 128;
				rm += SSEREGS_BASE;
				break;

			case OT_RM32:
			case OT_R32_M8:
			case OT_R32_M16:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 32;
				rm += REGS32_BASE;
				break;

			case OT_YMM256:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				rm += AVXREGS_BASE;
				size = 256;
				break;
			case OT_YXMM64_256:
			case OT_YXMM128_256:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (ps->vrex & PREFIX_EX_L) {
					size = 256;
					rm += AVXREGS_BASE;
				}
				else {
					size = 128;
					rm += SSEREGS_BASE;
				}
				break;
			case OT_WXMM32_64:
			case OT_LXMM64_128:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				size = 128;
				rm += SSEREGS_BASE;
				break;

			case OT_WRM32_64:
			case OT_REG32_64_M8:
			case OT_REG32_64_M16:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (ps->vrex & PREFIX_EX_W) {
					size = 64;
					rm += REGS64_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;

			default: return FALSE;
			}
			op->size = (uint16_t)size;
			op->index = (uint8_t)rm;
			op->type = O_REG;
			di->usedRegistersMask |= _REGISTERTORCLASS[rm];
			return TRUE;
		}
	}

	/* Simple operand type (ModRM reg). */
	reg = (modrm >> 3) & 7;
	switch (type)
	{
		case OT_IMM8:
			operands_set_ts(op, O_IMM, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.byte)) return FALSE;
		break;
		case OT_IMM_FULL: /* 16, 32 or 64, depends on prefixes. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* FALL THROUGH */
		case OT_IMM16: /* Force 16 bits imm. */
			operands_set_ts(op, O_IMM, 16);
			if (!read_stream_safe_uint16(ci, &di->imm.word)) return FALSE;
		break;
			/*
			 * Extension: MOV imm64, requires REX.
			 * Make sure it needs the REX.
			 * REX must be present because op size function takes it into consideration.
			 */
			} else if ((effOpSz == Decode64Bits) &&
				        ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX))) {
				ps->usedPrefixes |= INST_PRE_REX;

				operands_set_ts(op, O_IMM, 64);
				if (!read_stream_safe_uint64(ci, &di->imm.qword)) return FALSE;
				break;
			} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* FALL THROUGH BECAUSE dt==Decoded32Bits @-<----*/
		case OT_IMM32:
			op->type = O_IMM;
			if (ci->dt == Decode64Bits) {
				/*
				 * Imm32 is sign extended to 64 bits!
				 * Originally the op size was 64, but later was changed to reflect real size of imm.
				 */
				op->size = 32;
				/* Use this as an indicator that it should be signed extended. */
				di->flags |= FLAG_IMM_SIGNED;
				if (!read_stream_safe_sint32(ci, &di->imm.sqword)) return FALSE;
			} else {
				op->size = 32;
				if (!read_stream_safe_uint32(ci, &di->imm.dword)) return FALSE;
			}
		break;
		case OT_SEIMM8: /* Sign extended immediate. */
			/*
			 * PUSH SEIMM8 can be prefixed by operand size:
			 * Input stream: 66, 6a, 55
			 * 64bits DT: push small 55
			 * 32bits DT: push small 55
			 * 16bits DT: push large 55
			 * small/large indicates the size of the eSP pointer advancement.
			 * Check the instFlags (ii->flags) if it can be operand-size-prefixed and if the prefix exists.
			 */
			op->type = O_IMM;
			if ((instFlags & INST_PRE_OP_SIZE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				switch (ci->dt)
				{
					case Decode16Bits: op->size = 32; break;
					case Decode32Bits:
					case Decode64Bits:
						op->size = 16;
					break;
				}
			} else op->size = 8;
			di->flags |= FLAG_IMM_SIGNED;
			if (!read_stream_safe_sint8(ci, &di->imm.sqword)) return FALSE;
		break;
		case OT_IMM16_1:
			operands_set_ts(op, O_IMM1, 16);
			if (!read_stream_safe_uint16(ci, &di->imm.ex.i1)) return FALSE;
		break;
		case OT_IMM8_1:
			operands_set_ts(op, O_IMM1, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.ex.i1)) return FALSE;
		break;
		case OT_IMM8_2:
			operands_set_ts(op, O_IMM2, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.ex.i2)) return FALSE;
		break;
		case OT_REG8:
			operands_set_ts(op, O_REG, 8);
			if (ps->prefixExtType) {
				/*
				 * If REX prefix is valid then we will have to use low bytes.
				 * This is a PASSIVE behavior changer of REX prefix, it affects operands even if its value is 0x40 !
				 */
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + ((ps->vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
			} else op->index = (uint8_t)(REGS8_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_REG16:
			operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
		break;
		case OT_REG_FULL:
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (ps->vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits: /* rex must be presented. */
					ps->usedPrefixes |= INST_PRE_REX;
					operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg + ((ps->vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
				break;
			}
		break;
		case OT_REG32:
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_REG32_64: /* Handle CVT's, MOVxX and MOVNTI instructions which could be extended to 64 bits registers with REX. */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}

			/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
			if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
				operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
			/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
			if (ps->vrex & PREFIX_EX_W) {
				ps->usedPrefixes |= INST_PRE_REX;
				operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
			} else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_FREG32_64_RM: /* Force decoding mode. Used for MOV CR(n)/DR(n) which defaults to 64 bits operand size in 64 bits. */
			rm = modrm & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}

			if (ci->dt == Decode64Bits) operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + rm);
			else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + rm);
		break;
		case OT_MM: /* MMX register */
			operands_set_tsi(di, op, O_REG, 64, MMXREGS_BASE + reg);
		break;
		case OT_MM_RM: /* MMX register, this time from the RM field */
			rm = modrm & 7;
			operands_set_tsi(di, op, O_REG, 64, MMXREGS_BASE + rm);
		break;
		case OT_REGXMM0: /* Implicit XMM0 operand. */
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + 0);
			break;
		case OT_XMM: /* SSE register */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_XMM_RM: /* SSE register, this time from the RM field */
			rm = modrm & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + rm);
		break;
		case OT_CREG:
			/*
			 * Don't parse if the reg exceeds the bounds of the array.
			 * Most of the CR's are not implemented, so if there's no matching string, the operand is invalid.
			 */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			} else if ((ci->dt == Decode32Bits) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
				/*
				 * NOTE: In 32 bits decoding mode,
				 * if the lock prefix is set before MOV CR(n) it will become the 4th bit of the REG field like REX.R in 64 bits.
				 */
				reg += EX_GPR_BASE;
				ps->usedPrefixes |= INST_PRE_LOCK;
			}
			/* Ignore some registers which do not exist. */
			if ((reg >= CREGS_MAX) || (reg == 1) || ((reg >= 5) && (reg <= 7))) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(CREGS_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_DREG:
			/*
			 * In 64 bits there are 16 debug registers.
			 * but accessing any of dr8-15 which aren't implemented will cause an #ud.
			 */
			if ((reg == 4) || (reg == 5) || (ps->vrex & PREFIX_EX_R)) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(DREGS_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_SREG: /* Works with REG16 only! */
			if ((&di->ops[0] == op) && (reg == 1)) return FALSE; /* Can't MOV CS, <REG>. */
			/*Don't parse if the reg exceeds the bounds of the array. */
			if (reg <= SEG_REGS_MAX - 1) operands_set_tsi(di, op, O_REG, 16, SREGS_BASE + reg);
			else return FALSE;
		break;
		case OT_SEG:
			op->type = O_REG;
			/* Size of reg is always 16, it's up to caller to zero extend it to operand size. */
			op->size = 16;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/*
			 * Extract the SEG from ii->flags this time!!!
			 * Check whether an operand size prefix is used.
			 */
			switch (instFlags & INST_PRE_SEGOVRD_MASK)
			{
				case INST_PRE_ES: op->index = R_ES; break;
				case INST_PRE_CS: op->index = R_CS; break;
				case INST_PRE_SS: op->index = R_SS; break;
				case INST_PRE_DS: op->index = R_DS; break;
				case INST_PRE_FS: op->index = R_FS; break;
				case INST_PRE_GS: op->index = R_GS; break;
			}
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_ACC8:
			operands_set_tsi(di, op, O_REG, 8, R_AL);
		break;
		case OT_ACC16:
			operands_set_tsi(di, op, O_REG, 16, R_AX);
		break;
		case OT_ACC_FULL_NOT64:
			/* No REX.W support for IN/OUT. */
			/* FALL THROUGH */
		case OT_ACC_FULL:
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(di, op, O_REG, 16, R_AX);
			} else if ((effOpSz == Decode32Bits) || (type == OT_ACC_FULL_NOT64)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(di, op, O_REG, 32, R_EAX);
			} else { /* Decode64Bits */
				/* Only non-promoted instructions need REX in order to decode in 64 bits. */
				/* MEM-OFFSET MOV's are NOT automatically promoted to 64 bits. */
				if (!(instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
				operands_set_tsi(di, op, O_REG, 64, R_RAX);
			}
		break;
		case OT_PTR16_FULL:
			/* ptr16:full - full is size of operand size to read, therefore Operand Size Prefix affects this. So we need to handle it. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int16_t)*2;
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 16);
				di->imm.ptr.off = RUSHORT(ci->code); /* Read offset first. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int16_t))); /* And read segment. */

				ci->code += sizeof(int16_t)*2;
			} else { /* Decode32Bits, for Decode64Bits this instruction is invalid. */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int32_t) + sizeof(int16_t);
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 32);
				di->imm.ptr.off = RULONG(ci->code); /* Read 32bits offset this time. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int32_t))); /* And read segment, 16 bits. */
				
				ci->code += sizeof(int32_t) + sizeof(int16_t);
			}
		break;
		case OT_RELCB:
		case OT_RELC_FULL:

			if (type == OT_RELCB) {
				operands_set_ts(op, O_PC, 8);
				if (!read_stream_safe_sint8(ci, &di->imm.sqword)) return FALSE;
			} else { /* OT_RELC_FULL */

				/* Yep, operand size prefix affects relc also.  */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				if (effOpSz == Decode16Bits) {
					operands_set_ts(op, O_PC, 16);
					if (!read_stream_safe_sint16(ci, &di->imm.sqword)) return FALSE;
				} else { /* Decode32Bits or Decode64Bits = for now they are the same */
					operands_set_ts(op, O_PC, 32);
					if (!read_stream_safe_sint32(ci, &di->imm.sqword)) return FALSE;
				}
			}

			/* Support for hint, see if there's a segment override. */
			if ((ii->opcodeId >= I_JO) && (ii->opcodeId <= I_JG)) {
				if (ps->decodedPrefixes & INST_PRE_CS) {
					ps->usedPrefixes |= INST_PRE_CS;
					di->flags |= FLAG_HINT_NOT_TAKEN;
				} else if (ps->decodedPrefixes & INST_PRE_DS) {
					ps->usedPrefixes |= INST_PRE_DS;
					di->flags |= FLAG_HINT_TAKEN;
				}
			}
		break;
		case OT_MOFFS8:
			op->size = 8;
			/* FALL THROUGH, size won't be changed. */
		case OT_MOFFS_FULL:
			op->type = O_DISP;
			if (op->size == 0) {
				/* Calculate size of operand (same as ACC size). */
				switch (effOpSz)
				{
					case Decode16Bits: op->size = 16; break;
					case Decode32Bits: op->size = 32; break;
					case Decode64Bits: op->size = 64; break;
				}
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/*
			 * Just a pointer to a BYTE, WORD, DWORD, QWORD. Works only with ACC8/16/32/64 respectively. 
			 * MOV [0x1234], AL ; MOV AX, [0x1234] ; MOV EAX, [0x1234], note that R/E/AX will be chosen by OT_ACC_FULL.
			 */
			if (effAdrSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 16;
				if (!read_stream_safe_uint16(ci, &di->disp)) return FALSE;
			} else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 32;
				if (!read_stream_safe_uint32(ci, &di->disp)) return FALSE;
			} else { /* Decode64Bits */
				di->dispSize = 64;
				if (!read_stream_safe_uint64(ci, &di->disp)) return FALSE;
			}
		break;
		case OT_CONST1:
			operands_set_ts(op, O_IMM, 8);
			di->imm.byte = 1;
		break;
		case OT_REGCL:
			operands_set_tsi(di, op, O_REG, 8, R_CL);
		break;

		case OT_FPU_SI:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_tsi(di, op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SSI:
			operands_set_tsi(di, op, O_REG, 32, R_ST0);
			operands_set_tsi(di, op + 1, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			di->opsNo++;
		break;
		case OT_FPU_SIS:
			operands_set_tsi(di, op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			operands_set_tsi(di, op + 1, O_REG, 32, R_ST0);
			di->opsNo++;
		break;

		/*
		 * Special treatment for Instructions-Block:
		 * INC/DEC (only 16/32 bits) /PUSH/POP/XCHG instructions, which get their REG from their own binary code.

		 * Notice these instructions are 1 or 2 byte long,
		 * code points after the byte which represents the instruction itself,
		 * thus, even if the instructions are 2 bytes long it will read its last byte which contains the REG info.
		 */
		case OT_IB_RB:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_ts(op, O_REG, 8);
			reg = *(ci->code-1) & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + EX_GPR_BASE);
			} else if (ps->prefixExtType == PET_REX) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg);
			} else op->index = (uint8_t)(REGS8_BASE + reg);

			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_IB_R_FULL:
			reg = *(ci->code-1) & 7;
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits:
					/*
					 * Automatically promoted instruction can drop REX prefix if not required.
					 * PUSH/POP defaults to 64 bits. --> INST_64BITS
					 * MOV imm64 / BSWAP requires REX.W to be 64 bits --> INST_64BITS | INST_PRE_REX
					 */
					if ((instFlags & INST_64BITS) && ((instFlags & INST_PRE_REX) == 0)) {
						if (ps->vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							reg += EX_GPR_BASE;
						}
					} else {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += (ps->vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0;
					}
					operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
		break;

		/*
		 * Special treatment for repeatable instructions.

		 * We want the following output:
		 * If there's only the REP/NZ prefix, we won't output anything (All operands are implicit).
		 * If there's an operand size prefix, we will change the suffix letter of the mnemonic, which specifies the size of operand to the required one.
		 * If there's a segment override prefix, we will output the segment and the used index register (EDI/ESI).
		 * If there's an address size prefix, we will output the (segment if needed and) the used and inverted index register (DI/SI).

		 * Example:
		 * :: Decoding in 16 bits mode! ::
		 * AD ~ LODSW
		 * 66 AD ~ LODSD
		 * F3 AC ~ REP LODSB
		 * F3 66 AD ~ REP LODSD
		 * F3 3E AC ~ REP LODS BYTE DS:[SI]
		 * F3 67 AD ~ REP LODS WORD [ESI]

		 * The basic form of a repeatable instruction has its operands hidden and has a suffix letter
		 * which implies on the size of operation being done.
		 * Therefore, we cannot change the mnemonic here when we encounter another prefix and its not the decoder's responsibility to do so.
		 * That's why the caller is responsible to add the suffix letter if no other prefixes are used.
		 * And all we are doing here is formatting the operand correctly.
		 */
		case OT_REGI_ESI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16, 32 or 64 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/*
			 * Clear segment in case OT_REGI_EDI was parsed earlier,
			 * DS can be overridden and therefore has precedence.
			 */
			di->segment = R_NONE;
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			if (effAdrSz == Decode16Bits) op->index = R_SI;
			else if (effAdrSz == Decode32Bits) op->index = R_ESI;
			else op->index = R_RSI;
			
			di->usedRegistersMask |= _REGISTERTORCLASS[R_RSI]; /* Maps to RM_SI. */
		break;
		case OT_REGI_EDI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16 or 32 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/* Note: The [rDI] operand can't be prefixed by a segment override, therefore we don't set usedPrefixes. */
			if ((di->segment == R_NONE) && (ci->dt != Decode64Bits)) di->segment = R_ES | SEGMENT_DEFAULT; /* No ES in 64 bits mode. */

			if (effAdrSz == Decode16Bits) op->index = R_DI;
			else if (effAdrSz == Decode32Bits) op->index = R_EDI;
			else op->index = R_RDI;

			di->usedRegistersMask |= _REGISTERTORCLASS[R_RDI]; /* Maps to RM_DI. */
		break;

		/* Used for In/Out instructions varying forms. */
		case OT_REGDX:
			/* Simple single IN/OUT instruction. */
			operands_set_tsi(di, op, O_REG, 16, R_DX);
		break;

			/* Used for INVLPGA instruction. */
		case OT_REGECX:
			operands_set_tsi(di, op, O_REG, 32, R_ECX);
		break;
		case OT_REGI_EBXAL:
			/* XLAT BYTE [rBX + AL] */
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/* Size of deref is always 8 for xlat. */
			operands_set_tsi(di, op, O_MEM, 8, R_AL);

			if (effAdrSz == Decode16Bits) di->base = R_BX;
			else if (effAdrSz == Decode32Bits) di->base = R_EBX;
			else {
				ps->usedPrefixes |= INST_PRE_REX;
				di->base = R_RBX;
			}

			di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
		break;
		case OT_REGI_EAX:
			/*
			 * Implicit rAX as memory indirection operand. Used by AMD's SVM instructions.
			 * Since this is a memory indirection, the default address size in 64bits decoding mode is 64.
			 */

			if (effAdrSz == Decode64Bits) operands_set_tsi(di, op, O_SMEM, 64, R_RAX);
			else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(di, op, O_SMEM, 32, R_EAX);
			}
			else {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(di, op, O_SMEM, 16, R_AX);
			}
		break;
		case OT_VXMM:
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + ps->vexV);
		break;
		case OT_XMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YXMM:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_YXMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;

			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YMM:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
		break;
		case OT_VYMM:
			operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + ps->vexV);
		break;
		case OT_VYXMM:
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + ps->vexV);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + ps->vexV);
		break;
		case OT_WREG32_64:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_W) operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		default: return FALSE;
	}
	return TRUE;
}

```

`NativeCore/Dependencies/distorm/src/operands.h`:

```h
/*
operands.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef OPERANDS_H
#define OPERANDS_H

#include "config.h"
#include "decoder.h"
#include "prefix.h"
#include "instructions.h"

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, _Operand* op);

#endif /* OPERANDS_H */

```

`NativeCore/Dependencies/distorm/src/prefix.c`:

```c
/*
prefix.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "prefix.h"

#include "x86defs.h"
#include "instructions.h"
#include "../include/mnemonics.h"


/*
 * The main purpose of this module is to keep track of all kind of prefixes a single instruction may have.
 * The problem is that a single instruction may have up to six different prefix-types.
 * That's why I have to detect such cases and drop those excess prefixes.
 */


int PrefixTables[256 * 2] = {
	/* Decode 16/32 Bits */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, /* ES (0x26) CS (0x2e) */
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, /* DS (0x3e) SS (0x36) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, /* FS(0x64) GS(0x65) OP_SIZE(0x66) ADDR_SIZE(0x67) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* VEX2b (0xc5) VEX3b (0xc4) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* LOCK (0xf0) REPNZ (0xf2) REP (0xf3) */
	/* Decode64Bits */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* REX: 0x40 - 0x4f */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* Ignore all prefix. */
void prefixes_ignore_all(_PrefixState* ps)
{
	int i;
	for (i = 0; i < PFXIDX_MAX; i++)
		prefixes_ignore(ps, i);
}

/* Calculates which prefixes weren't used and accordingly sets the bits in the unusedPrefixesMask. */
uint16_t prefixes_set_unused_mask(_PrefixState* ps)
{
	/*
	 * The decodedPrefixes represents the prefixes that were *read* from the binary stream for the instruction.
	 * The usedPrefixes represents the prefixes that were actually used by the instruction in the *decode* phase.
	 * Xoring between the two will result in a 'diff' which returns the prefixes that were read
	 * from the stream *and* that were never used in the actual decoding.
	 *
	 * Only one prefix per type can be set in decodedPrefixes from the stream.
	 * Therefore it's enough to check each type once and set the flag accordingly.
	 * That's why we had to book-keep each prefix type and its position.
	 * So now we know which bits we need to set exactly in the mask.
	 */
	_iflags unusedPrefixesDiff = ps->decodedPrefixes ^ ps->usedPrefixes;
	uint16_t unusedPrefixesMask = ps->unusedPrefixesMask;

	/* Examine unused prefixes by type: */
	/*
	 * About REX: it might be set in the diff although it was never in the stream itself.
	 * This is because the vrex is shared between VEX and REX and some places flag it as REX usage, while
	 * we were really decoding an AVX instruction.
	 * It's not a big problem, because the prefixes_ignore func will ignore it anyway,
	 * since it wasn't seen earlier. But it's important to know this.
	 */
	if (unusedPrefixesDiff) {
		if (unusedPrefixesDiff & INST_PRE_REX) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_REX];
		if (unusedPrefixesDiff & INST_PRE_SEGOVRD_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_SEG];
		if (unusedPrefixesDiff & INST_PRE_LOKREP_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_LOREP];
		if (unusedPrefixesDiff & INST_PRE_OP_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_OP_SIZE];
		if (unusedPrefixesDiff & INST_PRE_ADDR_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_ADRS];
		/* If a VEX instruction was found, its prefix is considered as used, therefore no point for checking for it. */
	}

	return unusedPrefixesMask;
}

/*
 * Mark a prefix as unused, and bookkeep where we last saw this same type,
 * because in the future we might want to disable it too.
 */
_INLINE_ void prefixes_track_unused(_PrefixState* ps, int index, _PrefixIndexer pi)
{
	/* Mark the previously used prefix (if exists) in the unused mask. */
	prefixes_ignore(ps, pi);
	/* Book-keep the current index for this type. */
	ps->pfxIndexer[pi] = 1 << index;
}

/*
 * Read as many prefixes as possible, up to 15 bytes, and halt when we encounter non-prefix byte.
 * This algorithm tries to imitate a real processor, where the same prefix can appear a few times, etc.
 * The tiny complexity is that we want to know when a prefix was superfluous and mark any copy of it as unused.
 * Note that the last prefix of its type will be considered as used, and all the others (of same type) before it as unused.
 */
void prefixes_decode(_CodeInfo* ci, _PrefixState* ps)
{
	const uint8_t* rexPos = NULL;
	const uint8_t* start = ci->code;
	uint8_t byte, vex;
	unsigned int index;
	/*
	 * First thing to do, scan for prefixes, there are six types of prefixes.
	 * There may be up to six prefixes before a single instruction, not the same type, no special order,
	 * except REX/VEX must precede immediately the first opcode byte.
	 * BTW - This is the reason why I didn't make the REP prefixes part of the instructions (STOS/SCAS/etc).
	 *
	 * Another thing, the instruction maximum size is 15 bytes, thus if we read more than 15 bytes, we will halt.
	 *
	 * We attach all prefixes to the next instruction, there might be two or more occurrences from the same prefix.
	 * Also, since VEX can be allowed only once we will test it separately.
	 */
	for (index = 0;
		(ci->codeLen > 0) && (index < INST_MAXIMUM_SIZE);
		ci->code++, ci->codeLen--, index++) {
		/*
		NOTE: AMD treat lock/rep as two different groups... But I am based on Intel.

			- Lock and Repeat:
				- 0xF0 — LOCK
				- 0xF2 — REPNE/REPNZ
				- 0xF3 - REP/REPE/REPZ
			- Segment Override:
				- 0x2E - CS
				- 0x36 - SS
				- 0x3E - DS
				- 0x26 - ES
				- 0x64 - FS
				- 0x65 - GS
			- Operand-Size Override: 0x66, switching default size.
			- Address-Size Override: 0x67, switching default size.

		64 Bits:
			- REX: 0x40 - 0x4f, extends register access.
			- 2 Bytes VEX: 0xc4
			- 3 Bytes VEX: 0xc5
		32 Bits:
			- 2 Bytes VEX: 0xc4 11xx-xxxx
			- 3 Bytes VEX: 0xc5 11xx-xxxx
		*/

		/* Examine what type of prefix we got. */
		byte = *ci->code;
		switch (byte)
		{
		case PREFIX_OP_SIZE: {/* Op Size type: */
			ps->decodedPrefixes |= INST_PRE_OP_SIZE;
			prefixes_track_unused(ps, index, PFXIDX_OP_SIZE);
		} break;
			/* Look for both common arch prefixes. */
		case PREFIX_LOCK: {
			/* LOCK and REPx type: */
			ps->decodedPrefixes |= INST_PRE_LOCK;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_REPNZ: {
			ps->decodedPrefixes |= INST_PRE_REPNZ;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_REP: {
			ps->decodedPrefixes |= INST_PRE_REP;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_CS: {
			/* Seg Overide type: */
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_CS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_SS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_SS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_DS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_DS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_ES: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_ES;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_FS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_FS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_GS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_GS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_ADDR_SIZE: {
			/* Addr Size type: */
			ps->decodedPrefixes |= INST_PRE_ADDR_SIZE;
			prefixes_track_unused(ps, index, PFXIDX_ADRS);
		} break;
		default:
			if (ci->dt == Decode64Bits) {
				/* REX type, 64 bits decoding mode only: */
				if ((byte & 0xf0) == 0x40) {
					ps->decodedPrefixes |= INST_PRE_REX;
					rexPos = ci->code;
					ps->vrex = byte & 0xf; /* Keep only BXRW. */
					ps->prefixExtType = PET_REX;
					prefixes_track_unused(ps, index, PFXIDX_REX);
					continue;
				}
			}
			goto _Break2;
		}
	}
_Break2:

	/* 2 Bytes VEX: */
	if ((ci->codeLen >= 2) &&
		(*ci->code == PREFIX_VEX2b) &&
		((ci->code - start) <= INST_MAXIMUM_SIZE - 2)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LDS instruction.
		 */
		if ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = ci->code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX2BYTES;

			/*
			 * VEX 1 byte bits:
			 * |7-6--3-2-10|
			 * |R|vvvv|L|pp|
			 * |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			if (!(vex & 0x80) && (ci->dt == Decode64Bits)) ps->vrex |= PREFIX_EX_R; /* Convert VEX.R. */
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */

			ci->code += 2;
			ci->codeLen -= 2;
		}
	}

	/* 3 Bytes VEX: */
	if ((ci->codeLen >= 3) &&
		(*ci->code == PREFIX_VEX3b) &&
		((ci->code - start) <= INST_MAXIMUM_SIZE - 3) &&
		(!(ps->decodedPrefixes & INST_PRE_VEX))) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LES instruction.
		 * And we don't care now about the 3rd byte.
		 */
		if ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = ci->code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX3BYTES;

			/*
			 * VEX first and second bytes:
			 * |7-6-5-4----0|  |7-6--3-2-10|
			 * |R|X|B|m-mmmm|  |W|vvvv|L|pp|
			 * |------------|  |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			ps->vrex |= ((~vex >> 5) & 0x7); /* Shift and invert VEX.R/X/B to their place */
			vex = *(ps->vexPos + 1);
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */
			if (vex & 0x80) ps->vrex |= PREFIX_EX_W; /* Convert VEX.W. */

			/* Clear some flags if the mode isn't 64 bits. */
			if (ci->dt != Decode64Bits) ps->vrex &= ~(PREFIX_EX_B | PREFIX_EX_X | PREFIX_EX_R | PREFIX_EX_W);

			ci->code += 3;
			ci->codeLen -= 3;
		}
	}

	if (ci->dt == Decode64Bits) {
		if (ps->decodedPrefixes & INST_PRE_REX) {
			/* REX prefix must precede first byte of instruction. */
			if (rexPos != (ci->code - 1)) {
				ps->decodedPrefixes &= ~INST_PRE_REX;
				if (ps->prefixExtType == PET_REX) ps->prefixExtType = PET_NONE; /* It might be a VEX by now, keep it that way. */
				prefixes_ignore(ps, PFXIDX_REX);
			}
			/*
			 * We will disable operand size prefix,
			 * if it exists only after decoding the instruction, since it might be a mandatory prefix.
			 * This will be done after calling inst_lookup in decode_inst.
			 */
		}
		/* In 64 bits, segment overrides of CS, DS, ES and SS are ignored. So don't take'em into account. */
		if (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK32) {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK32;
			prefixes_ignore(ps, PFXIDX_SEG);
		}
	}

	/* Store number of prefixes scanned. */
	ps->count = (uint8_t)(ci->code - start);
}

/*
 * For every memory-indirection operand we want to set a used segment.
 * If the segment is being overrided with a prefix, we will need to check if it's a default.
 * Defaults don't use their prefix, e.g "mov [rsp]" can ignore a given SS: prefix,
 * but still set the used segment as SS.
 * This function is called only with SS and DS as defaults.
 * If there's a segment prefix used, it will override the default one.
 * And If the prefix is a default seg in 64 bits, it will be ignored.
 */
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di)
{
	/* Extract given segment prefix from the decoded prefixes. */
	_iflags flags;

	if (dt == Decode64Bits) {
		if (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK64) { /* Either GS or FS. */
			di->segment = ps->decodedPrefixes & INST_PRE_GS ? R_GS : R_FS;
		}

		return;
	}

	flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK;

	/* Use the given prefix only if it's not the default. */
	if (flags && (flags != defaultSeg)) {
		ps->usedPrefixes |= flags;

		switch (flags >> 7) /* INST_PRE_CS is 1 << 7. And the rest of the prefixes follow as bit fields. */
		{
			case 1: di->segment = R_CS; break;
			case 2: di->segment = R_SS; break;
			case 4: di->segment = R_DS; break;
			case 8: di->segment = R_ES; break;
			case 0x10: di->segment = R_FS; break;
			case 0x20: di->segment = R_GS; break;
		}
	}
	else {
		if (defaultSeg == INST_PRE_SS) di->segment = SEGMENT_DEFAULT | R_SS;
		else di->segment = SEGMENT_DEFAULT | R_DS;
	}
}

```

`NativeCore/Dependencies/distorm/src/prefix.h`:

```h
/*
prefix.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef PREFIX_H
#define PREFIX_H

#include "config.h"
#include "decoder.h"


/* Specifies the type of the extension prefix, such as: REX, 2 bytes VEX, 3 bytes VEX. */
typedef enum {PET_NONE = 0, PET_REX, PET_VEX2BYTES, PET_VEX3BYTES} _PrefixExtType;

/* Specifies an index into a table of prefixes by their type. */
typedef enum {PFXIDX_NONE = -1, PFXIDX_REX, PFXIDX_LOREP, PFXIDX_SEG, PFXIDX_OP_SIZE, PFXIDX_ADRS, PFXIDX_MAX} _PrefixIndexer;

/*
* This holds the prefixes state for the current instruction we decode.
* decodedPrefixes includes all specific prefixes that the instruction got.
* start is a pointer to the first prefix to take into account.
* last is a pointer to the last byte we scanned.
* Other pointers are used to keep track of prefixes positions and help us know if they appeared already and where.
*/
typedef struct {
	_iflags decodedPrefixes, usedPrefixes;
	/* Number of prefixes scanned for current instruction, including VEX! */
	unsigned int count;
	uint16_t unusedPrefixesMask;
	/* Holds the offset to the prefix byte by its type. */
	uint16_t pfxIndexer[PFXIDX_MAX];
	_PrefixExtType prefixExtType;
	/* Indicates whether the operand size prefix (0x66) was used as a mandatory prefix. */
	int isOpSizeMandatory;
	/* If VEX prefix is used, store the VEX.vvvv field. */
	unsigned int vexV;
	/* The fields B/X/R/W/L of REX and VEX are stored together in this byte. */
	unsigned int vrex;
	const uint8_t* vexPos;
} _PrefixState;

/*
* Intel supports 6 types of prefixes, whereas AMD supports 5 types (lock is seperated from rep/nz).
* REX is the fifth prefix type, this time I'm based on AMD64.
* VEX is the 6th, though it can't be repeated.
*/
#define MAX_PREFIXES (5)

extern int PrefixTables[256 * 2];

_INLINE_ int prefixes_is_valid(unsigned char ch, _DecodeType dt)
{
	/* The predicate selects (branchlessly) second half table for 64 bits otherwise selects first half. */
	return PrefixTables[ch + ((dt >> 1) << 8)];
}

/* Ignore a specific prefix type. */
_INLINE_ void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi)
{
	/*
	 * If that type of prefix appeared already, set the bit of that *former* prefix.
	 * Anyway, set the new index of that prefix type to the current index, so next time we know its position.
	 */
	ps->unusedPrefixesMask |= ps->pfxIndexer[pi];
}

void prefixes_ignore_all(_PrefixState* ps);
uint16_t prefixes_set_unused_mask(_PrefixState* ps);
void prefixes_decode(_CodeInfo* ci, _PrefixState* ps);
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di);

#endif /* PREFIX_H */

```

`NativeCore/Dependencies/distorm/src/textdefs.c`:

```c
/*
textdefs.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "textdefs.h"

#ifndef DISTORM_LIGHT

static uint8_t Nibble2ChrTable[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
#define NIBBLE_TO_CHR Nibble2ChrTable[t]

void str_hex(_WString* s, const uint8_t* buf, unsigned int len)
{
	/* 256 * 2 : 2 chars per byte value. */
	static const char* TextBTable =
		"000102030405060708090a0b0c0d0e0f" \
		"101112131415161718191a1b1c1d1e1f" \
		"202122232425262728292a2b2c2d2e2f" \
		"303132333435363738393a3b3c3d3e3f" \
		"404142434445464748494a4b4c4d4e4f" \
		"505152535455565758595a5b5c5d5e5f" \
		"606162636465666768696a6b6c6d6e6f" \
		"707172737475767778797a7b7c7d7e7f" \
		"808182838485868788898a8b8c8d8e8f" \
		"909192939495969798999a9b9c9d9e9f" \
		"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf" \
		"b0b1b2b3b4b5b6b7b8b9babbbcbdbebf" \
		"c0c1c2c3c4c5c6c7c8c9cacbcccdcecf" \
		"d0d1d2d3d4d5d6d7d8d9dadbdcdddedf" \
		"e0e1e2e3e4e5e6e7e8e9eaebecedeeef" \
		"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
	
	unsigned int i = 0;
	/* Length is at least 1, enter loop. */
	s->length = len * 2;
	s->p[len * 2] = 0;
	do {
		RSHORT(&s->p[i]) = RSHORT(&TextBTable[(*buf) * 2]);
		buf++;
		i += 2;
	} while (i < len * 2);
}

#ifdef SUPPORT_64BIT_OFFSET

void str_int_impl(unsigned char** s, uint64_t x)
{
	int8_t* buf;
	int shift = 0;
	OFFSET_INTEGER t = x;

	buf = (int8_t*)*s;

	*buf++ = '0';
	*buf++ = 'x';

	if (x == 0) {
		*buf = '0';
		*s += 3;
		return;
	}

	do {
		t >>= 4;
		shift += 4;
	} while (t);

	do {
		shift -= 4;
		t = (x >> shift) & 0xf;
		*buf++ = NIBBLE_TO_CHR;
	} while (shift > 0);

	*s = (unsigned char*)buf;
}

#else

void str_int_impl(unsigned char** s, uint8_t src[8])
{
	int8_t* buf;
	int i = 0, shift = 0;
	uint32_t x = RULONG(&src[sizeof(int32_t)]);
	int t;

	buf = (int8_t*)*s;
	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != -4; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}

	x = RULONG(src);
	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	*s += (size_t)(i + 2);
}

#endif /* SUPPORT_64BIT_OFFSET */

#endif /* DISTORM_LIGHT */

```

`NativeCore/Dependencies/distorm/src/textdefs.h`:

```h
/*
textdefs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef TEXTDEFS_H
#define TEXTDEFS_H

#include "config.h"
#include "wstring.h"

#ifndef DISTORM_LIGHT

#define PLUS_DISP_CHR '+'
#define MINUS_DISP_CHR '-'
#define OPEN_CHR '['
#define CLOSE_CHR ']'
#define SP_CHR ' '
#define SEG_OFF_CHR ':'

/*
Naming Convention:

* get - returns a pointer to a string.
* str - concatenates to string.

* hex - means the function is used for hex dump (number is padded to required size) - Little Endian output.
* code - means the function is used for disassembled instruction - Big Endian output.
* off - means the function is used for 64bit offset - Big Endian output.

* h - '0x' in front of the string.

* b - byte
* dw - double word (can be used for word also)
* qw - quad word

* all numbers are in HEX.
*/

void str_hex(_WString* s, const uint8_t* buf, unsigned int len);

#ifdef SUPPORT_64BIT_OFFSET
#define str_int(s, x) str_int_impl((s), (x))
void str_int_impl(unsigned char** s, uint64_t x);
#else
#define str_int(s, x) str_int_impl((s), (uint8_t*)&(x))
void str_int_impl(unsigned char** s, uint8_t src[8]);
#endif

#endif /* DISTORM_LIGHT */

#endif /* TEXTDEFS_H */

```

`NativeCore/Dependencies/distorm/src/wstring.c`:

```c
/*
wstring.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2018 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "wstring.h"

#ifndef DISTORM_LIGHT

void strclear_WS(_WString* s)
{
	s->p[0] = '\0';
	s->length = 0;
}

void chrcat_WS(_WString* s, uint8_t ch)
{
	s->p[s->length] = ch;
	s->p[s->length + 1] = '\0';
	s->length += 1;
}

void strcpylen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	s->length = len;
	memcpy((int8_t*)s->p, buf, len + 1);
}

void strcatlen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	memcpy((int8_t*)&s->p[s->length], buf, len + 1);
	s->length += len;
}

void strcat_WS(_WString* s, const _WString* s2)
{
	memcpy((int8_t*)&s->p[s->length], s2->p, s2->length + 1);
	s->length += s2->length;
}

#endif /* DISTORM_LIGHT */

```

`NativeCore/Dependencies/distorm/src/wstring.h`:

```h
/*
wstring.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef WSTRING_H
#define WSTRING_H

#include "config.h"
#include "../include/mnemonics.h"

#ifndef DISTORM_LIGHT

_INLINE_ void strcat_WSR(unsigned char** str, const _WRegister* reg)
{
	/*
	 * Longest register name is YMM15 - 5 characters,
	 * Copy 8 so compiler can do a QWORD move.
	 * We copy nul termination and fix the length, so it's okay to copy more to the output buffer.
	 * There's a sentinel register to make sure we don't read past the end of the registers table.
	 */
	memcpy((int8_t*)*str, (const int8_t*)reg->p, 8);
	*str += reg->length;
}

#define strfinalize_WS(s, end) do { *end = 0; s.length = (unsigned int)((size_t)end - (size_t)s.p); } while (0)
#define chrcat_WS(s, ch) do { *s = ch; s += 1; } while (0)
#define strcat_WS(s, buf, copylen, advancelen) do { memcpy((int8_t*)s, buf, copylen); s += advancelen; } while(0)

#endif /* DISTORM_LIGHT */

#endif /* WSTRING_H */

```

`NativeCore/Dependencies/distorm/src/x86defs.h`:

```h
/*
x86defs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef X86DEFS_H
#define X86DEFS_H


#define SEG_REGS_MAX (6)
#define CREGS_MAX (9)
#define DREGS_MAX (8)

/* Maximum instruction size, including prefixes */
#define INST_MAXIMUM_SIZE (15)

/* Maximum range of imm8 (comparison type) of special SSE CMP instructions. */
#define INST_CMP_MAX_RANGE (8)

/* Maximum range of imm8 (comparison type) of special AVX VCMP instructions. */
#define INST_VCMP_MAX_RANGE (32)

/* Wait instruction byte code. */
#define INST_WAIT_INDEX (0x9b)

/* Lea instruction byte code. */
#define INST_LEA_INDEX (0x8d)

/* NOP/XCHG instruction byte code. */
#define INST_NOP_INDEX (0x90)

/* ARPL/MOVSXD instruction byte code. */
#define INST_ARPL_INDEX (0x63)

/*
 * Minimal MODR/M value of divided instructions.
 * It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
 */
#define INST_DIVIDED_MODRM (0xc0)

/* This is the escape byte value used for 3DNow! instructions. */
#define _3DNOW_ESCAPE_BYTE (0x0f)

#define PREFIX_LOCK (0xf0)
#define PREFIX_REPNZ (0xf2)
#define PREFIX_REP (0xf3)
#define PREFIX_CS (0x2e)
#define PREFIX_SS (0x36)
#define PREFIX_DS (0x3e)
#define PREFIX_ES (0x26)
#define PREFIX_FS (0x64)
#define PREFIX_GS (0x65)
#define PREFIX_OP_SIZE (0x66)
#define PREFIX_ADDR_SIZE (0x67)
#define PREFIX_VEX2b (0xc5)
#define PREFIX_VEX3b (0xc4)

/* REX prefix value range, 64 bits mode decoding only. */
#define PREFIX_REX_LOW (0x40)
#define PREFIX_REX_HI (0x4f)
/* In order to use the extended GPR's we have to add 8 to the Modr/M info values. */
#define EX_GPR_BASE (8)

/* Mask for REX and VEX features: */
/* Base */
#define PREFIX_EX_B (1)
/* Index */
#define PREFIX_EX_X (2)
/* Register */
#define PREFIX_EX_R (4)
/* Operand Width */
#define PREFIX_EX_W (8)
/* Vector Lengh */
#define PREFIX_EX_L (0x10)

#endif /* X86DEFS_H */

```

`NativeCore/ReClassNET_Plugin.hpp`:

```hpp
#pragma once

#include <type_traits>
#include <algorithm>
#include <cstdint>
#include <codecvt>
#include <locale>
#include <cstring>

// OS Specific

#ifdef __linux__
	#define RC_CallConv
#elif _WIN32
	#define RC_CallConv __stdcall
#else
	static_assert(false, "Missing RC_CallConv specification");
#endif

// Types

using RC_Pointer = void*;
using RC_Size = size_t;
using RC_UnicodeChar = char16_t;

// Constants

const int PATH_MAXIMUM_LENGTH = 260;

// Enumerations

enum class ProcessAccess
{
	Read,
	Write,
	Full
};

enum class SectionProtection
{
	NoAccess = 0,

	Read = 1,
	Write = 2,
	CopyOnWrite = 4,
	Execute = 8,

	Guard = 16
};

inline SectionProtection operator|(SectionProtection lhs, SectionProtection rhs)
{
	using T = std::underlying_type_t<SectionProtection>;

	return static_cast<SectionProtection>(static_cast<T>(lhs) | static_cast<T>(rhs));
}

inline SectionProtection& operator|=(SectionProtection& lhs, SectionProtection rhs)
{
	using T = std::underlying_type_t<SectionProtection>;

	lhs = static_cast<SectionProtection>(static_cast<T>(lhs) | static_cast<T>(rhs));

	return lhs;
}

enum class SectionType
{
	Unknown,

	Private,
	Mapped,
	Image
};

enum class SectionCategory
{
	Unknown,
	CODE,
	DATA,
	HEAP
};

enum class ControlRemoteProcessAction
{
	Suspend,
	Resume,
	Terminate
};

enum class DebugContinueStatus
{
	Handled,
	NotHandled
};

enum class HardwareBreakpointRegister
{
	InvalidRegister,

	Dr0,
	Dr1,
	Dr2,
	Dr3
};

enum class HardwareBreakpointTrigger
{
	Execute,
	Access,
	Write,
};

enum class HardwareBreakpointSize
{
	Size1 = 1,
	Size2 = 2,
	Size4 = 4,
	Size8 = 8
};

// Structures

#pragma pack(push, 1)

struct EnumerateProcessData
{
	RC_Size Id;
	RC_UnicodeChar Name[PATH_MAXIMUM_LENGTH];
	RC_UnicodeChar Path[PATH_MAXIMUM_LENGTH];
};

struct InstructionData
{
	RC_Pointer Address;
	int Length;
	uint8_t Data[15];
	int StaticInstructionBytes;
	RC_UnicodeChar Instruction[64];
};

struct EnumerateRemoteSectionData
{
	RC_Pointer BaseAddress;
	RC_Size Size;
	SectionType Type;
	SectionCategory Category;
	SectionProtection Protection;
	RC_UnicodeChar Name[16];
	RC_UnicodeChar ModulePath[PATH_MAXIMUM_LENGTH];
};

struct EnumerateRemoteModuleData
{
	RC_Pointer BaseAddress;
	RC_Size Size;
	RC_UnicodeChar Path[PATH_MAXIMUM_LENGTH];
};

struct ExceptionDebugInfo
{
	RC_Size ExceptionCode;
	RC_Size ExceptionFlags;
	RC_Pointer ExceptionAddress;

	HardwareBreakpointRegister CausedBy;

	struct RegisterInfo
	{
#ifdef RECLASSNET64
		RC_Pointer Rax;
		RC_Pointer Rbx;
		RC_Pointer Rcx;
		RC_Pointer Rdx;
		RC_Pointer Rdi;
		RC_Pointer Rsi;
		RC_Pointer Rsp;
		RC_Pointer Rbp;
		RC_Pointer Rip;

		RC_Pointer R8;
		RC_Pointer R9;
		RC_Pointer R10;
		RC_Pointer R11;
		RC_Pointer R12;
		RC_Pointer R13;
		RC_Pointer R14;
		RC_Pointer R15;
#else
		RC_Pointer Eax;
		RC_Pointer Ebx;
		RC_Pointer Ecx;
		RC_Pointer Edx;
		RC_Pointer Edi;
		RC_Pointer Esi;
		RC_Pointer Esp;
		RC_Pointer Ebp;
		RC_Pointer Eip;
#endif
	};
	RegisterInfo Registers;
};

struct DebugEvent
{
	DebugContinueStatus ContinueStatus;

	RC_Pointer ProcessId;
	RC_Pointer ThreadId;

	ExceptionDebugInfo ExceptionInfo;
};

struct DebugRegister6
{
	union
	{
		uintptr_t Value;
		struct
		{
			unsigned DR0 : 1;
			unsigned DR1 : 1;
			unsigned DR2 : 1;
			unsigned DR3 : 1;
			unsigned Reserved : 9;
			unsigned BD : 1;
			unsigned BS : 1;
			unsigned BT : 1;
		};
	};
};

struct DebugRegister7
{
	union
	{
		uintptr_t Value;
		struct
		{
			unsigned G0 : 1;
			unsigned L0 : 1;
			unsigned G1 : 1;
			unsigned L1 : 1;
			unsigned G2 : 1;
			unsigned L2 : 1;
			unsigned G3 : 1;
			unsigned L3 : 1;
			unsigned GE : 1;
			unsigned LE : 1;
			unsigned Reserved : 6;
			unsigned RW0 : 2;
			unsigned Len0 : 2;
			unsigned RW1 : 2;
			unsigned Len1 : 2;
			unsigned RW2 : 2;
			unsigned Len2 : 2;
			unsigned RW3 : 2;
			unsigned Len3 : 2;
		};
	};
};

#pragma pack(pop)

typedef void(RC_CallConv EnumerateProcessCallback)(EnumerateProcessData* data);

typedef void(RC_CallConv EnumerateRemoteSectionsCallback)(EnumerateRemoteSectionData* data);
typedef void(RC_CallConv EnumerateRemoteModulesCallback)(EnumerateRemoteModuleData* data);

// Helpers

inline void MultiByteToUnicode(const char* src, const int srcOffset, RC_UnicodeChar* dst, const int dstOffset, const int size)
{
#if _MSC_VER >= 1900
	// VS Bug: https://connect.microsoft.com/VisualStudio/feedback/details/1348277/link-error-when-using-std-codecvt-utf8-utf16-char16-t

	using converter = std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>;
#else
	using converter = std::wstring_convert<std::codecvt_utf8_utf16<RC_UnicodeChar>, RC_UnicodeChar>;
#endif

	const auto temp = converter{}.from_bytes(src + srcOffset);

	std::memcpy(dst + dstOffset, temp.c_str(), std::min<int>(static_cast<int>(temp.length()), size) * sizeof(RC_UnicodeChar));
}

inline void MultiByteToUnicode(const char* src, RC_UnicodeChar* dst, const int size)
{
	MultiByteToUnicode(src, 0, dst, 0, size);
}

inline char16_t* str16cpy(char16_t* destination, const char16_t* source, size_t n)
{
	char16_t* temp = destination;
	while (n > 0 && *source != 0)
	{
		*temp++ = *source++;
		--n;
	}
	while (n > 0)
	{
		*temp++ = 0;
		--n;
	}
	return destination;
}

```

`NativeCore/Shared/DistormHelper.cpp`:

```cpp
#include "DistormHelper.hpp"

#include <distorm.h>
#include <mnemonics.h>
extern "C"
{
#include <../src/instructions.h>
}

bool AreOperandsStatic(const _DInst &instruction, const int prefixLength)
{
	const auto fc = META_GET_FC(instruction.meta);
	if (fc == FC_UNC_BRANCH || fc == FC_CND_BRANCH)
	{
		if (instruction.size - prefixLength < 5)
		{
			return true;
		}
	}

	const auto ops = instruction.ops;
	for (auto i = 0; i < OPERANDS_NO; i++)
	{
		switch (ops[i].type)
		{
		case O_NONE:
		case O_REG:
		case O_IMM1:
		case O_IMM2:
			continue;
		case O_IMM:
			if (ops[i].size < 32)
			{
				continue;
			}
			return false;
		case O_DISP:
		case O_SMEM:
		case O_MEM:
			if (instruction.dispSize < 32)
			{
				continue;
			}

#ifdef RECLASSNET64
			if (ops[i].index == R_RIP)
			{
				continue;
			}
#endif
			return false;
		case O_PC:
		case O_PTR:
			return false;
		}
	}

	return true;
}

_CodeInfo CreateCodeInfo(const uint8_t* address, int length, const _OffsetType virtualAddress)
{
	_CodeInfo info = {};
	info.codeOffset = virtualAddress;
	info.code = address;
	info.codeLen = length;
	info.features = DF_NONE;

#ifdef RECLASSNET32
	info.dt = Decode32Bits;
#else
	info.dt = Decode64Bits;
#endif

	return info;
}


int GetStaticInstructionBytes(const _DInst &instruction, const uint8_t *data)
{
	auto info = CreateCodeInfo(data, instruction.size, reinterpret_cast<_OffsetType>(data));

	_PrefixState ps = {};
	int isPrefixed;
	inst_lookup(&info, &ps, &isPrefixed);

	if (AreOperandsStatic(instruction, ps.count))
	{
		return instruction.size;
	}

	return instruction.size - info.codeLen - ps.count;
}

void FillInstructionData(const _CodeInfo& info, const RC_Pointer address, const _DInst& instruction, const bool determineStaticInstructionBytes, InstructionData* data)
{
	data->Address = reinterpret_cast<RC_Pointer>(instruction.addr);
	data->Length = instruction.size;
	std::memcpy(data->Data, address, instruction.size);
	data->StaticInstructionBytes = -1;

	if (instruction.flags == FLAG_NOT_DECODABLE)
	{
		std::memcpy(data->Instruction, L"???", sizeof(RC_UnicodeChar) * 3);
	}
	else
	{
		_DecodedInst instructionInfo = {};
		distorm_format(&info, &instruction, &instructionInfo);
		
		MultiByteToUnicode(
			reinterpret_cast<const char*>(instructionInfo.mnemonic.p),
			data->Instruction,
			instructionInfo.mnemonic.length
		);
		if (instructionInfo.operands.length != 0)
		{
			data->Instruction[instructionInfo.mnemonic.length] = ' ';

			MultiByteToUnicode(
				reinterpret_cast<const char*>(instructionInfo.operands.p),
				0,
				data->Instruction,
				instructionInfo.mnemonic.length + 1,
				std::min<int>(64 - 1 - instructionInfo.mnemonic.length, instructionInfo.operands.length)
			);
		}

		if (determineStaticInstructionBytes)
		{
			data->StaticInstructionBytes = GetStaticInstructionBytes(
				instruction,
				reinterpret_cast<const uint8_t*>(address)
			);
		}
	}
}

bool DisassembleInstructionsImpl(const RC_Pointer address, const RC_Size length, const RC_Pointer virtualAddress, const bool determineStaticInstructionBytes, EnumerateInstructionCallback callback)
{
	auto info = CreateCodeInfo(static_cast<const uint8_t*>(address), static_cast<int>(length), reinterpret_cast<_OffsetType>(virtualAddress));

	const unsigned MaxInstructions = 50;

	_DInst decodedInstructions[MaxInstructions] = {};
	unsigned count = 0;

	auto instructionAddress = static_cast<uint8_t*>(address);

	while (true)
	{
		const auto res = distorm_decompose(&info, decodedInstructions, MaxInstructions, &count);
		if (res == DECRES_INPUTERR)
		{
			return false;
		}

		for (auto i = 0u; i < count; ++i)
		{
			const auto& instruction = decodedInstructions[i];

			InstructionData data = {};
			FillInstructionData(info, instructionAddress, instruction, determineStaticInstructionBytes, &data);

			if (callback(&data) == false)
			{
				return true;
			}

			instructionAddress += instruction.size;
		}

		if (res == DECRES_SUCCESS || count == 0)
		{
			return true;
		}

		const auto offset = static_cast<unsigned>(decodedInstructions[count - 1].addr + decodedInstructions[count - 1].size - info.codeOffset);

		info.codeOffset += offset;
		info.code += offset;
		info.codeLen -= offset;
	}
}

```

`NativeCore/Shared/DistormHelper.hpp`:

```hpp
#pragma once

#include "../ReClassNET_Plugin.hpp"

typedef bool(RC_CallConv EnumerateInstructionCallback)(InstructionData* data);

bool DisassembleInstructionsImpl(const RC_Pointer address, const RC_Size length, const RC_Pointer virtualAddress, const bool determineStaticInstructionBytes, EnumerateInstructionCallback callback);
```

`NativeCore/Shared/Keys.hpp`:

```hpp
#pragma once

enum class Keys : int32_t
{
	None = 0,
	LButton = 1,
	RButton = 2,
	Cancel = 3,
	MButton = 4,
	XButton1 = 5,
	XButton2 = 6,
	Back = 8,
	Tab = 9,
	LineFeed = 10,
	Clear = 12,
	Return = 13,
	Enter = 13,
	ShiftKey = 16,
	ControlKey = 17,
	Menu = 18,
	Pause = 19,
	Capital = 20,
	CapsLock = 20,
	KanaMode = 21,
	HanguelMode = 21,
	HangulMode = 21,
	JunjaMode = 23,
	FinalMode = 24,
	HanjaMode = 25,
	KanjiMode = 25,
	Escape = 27,
	IMEConvert = 28,
	IMENonconvert = 29,
	IMEAccept = 30,
	IMEAceept = 30,
	IMEModeChange = 31,
	Space = 32,
	Prior = 33,
	PageUp = 33,
	Next = 34,
	PageDown = 34,
	End = 35,
	Home = 36,
	Left = 37,
	Up = 38,
	Right = 39,
	Down = 40,
	Select = 41,
	Print = 42,
	Execute = 43,
	Snapshot = 44,
	PrintScreen = 44,
	Insert = 45,
	Delete = 46,
	Help = 47,
	D0 = 48,
	D1 = 49,
	D2 = 50,
	D3 = 51,
	D4 = 52,
	D5 = 53,
	D6 = 54,
	D7 = 55,
	D8 = 56,
	D9 = 57,
	A = 65,
	B = 66,
	C = 67,
	D = 68,
	E = 69,
	F = 70,
	G = 71,
	H = 72,
	I = 73,
	J = 74,
	K = 75,
	L = 76,
	M = 77,
	N = 78,
	O = 79,
	P = 80,
	Q = 81,
	R = 82,
	S = 83,
	T = 84,
	U = 85,
	V = 86,
	W = 87,
	X = 88,
	Y = 89,
	Z = 90,
	LWin = 91,
	RWin = 92,
	Apps = 93,
	Sleep = 95,
	NumPad0 = 96,
	NumPad1 = 97,
	NumPad2 = 98,
	NumPad3 = 99,
	NumPad4 = 100,
	NumPad5 = 101,
	NumPad6 = 102,
	NumPad7 = 103,
	NumPad8 = 104,
	NumPad9 = 105,
	Multiply = 106,
	Add = 107,
	Separator = 108,
	Subtract = 109,
	Decimal = 110,
	Divide = 111,
	F1 = 112,
	F2 = 113,
	F3 = 114,
	F4 = 115,
	F5 = 116,
	F6 = 117,
	F7 = 118,
	F8 = 119,
	F9 = 120,
	F10 = 121,
	F11 = 122,
	F12 = 123,
	F13 = 124,
	F14 = 125,
	F15 = 126,
	F16 = 127,
	F17 = 128,
	F18 = 129,
	F19 = 130,
	F20 = 131,
	F21 = 132,
	F22 = 133,
	F23 = 134,
	F24 = 135,
	NumLock = 144,
	Scroll = 145,
	LShiftKey = 160,
	RShiftKey = 161,
	LControlKey = 162,
	RControlKey = 163,
	LMenu = 164,
	RMenu = 165,
	BrowserBack = 166,
	BrowserForward = 167,
	BrowserRefresh = 168,
	BrowserStop = 169,
	BrowserSearch = 170,
	BrowserFavorites = 171,
	BrowserHome = 172,
	VolumeMute = 173,
	VolumeDown = 174,
	VolumeUp = 175,
	MediaNextTrack = 176,
	MediaPreviousTrack = 177,
	MediaStop = 178,
	MediaPlayPause = 179,
	LaunchMail = 180,
	SelectMedia = 181,
	LaunchApplication1 = 182,
	LaunchApplication2 = 183,
	OemSemicolon = 186,
	Oem1 = 186,
	OemPlus = 187,
	OemComma = 188,
	OemMinus = 189,
	OemPeriod = 190,
	OemQuestion = 191,
	Oem2 = 191,
	Oemtilde = 192,
	Oem3 = 192,
	OemOpenBrackets = 219,
	Oem4 = 219,
	OemPipe = 220,
	Oem5 = 220,
	OemCloseBrackets = 221,
	Oem6 = 221,
	OemQuotes = 222,
	Oem7 = 222,
	Oem8 = 223,
	OemBackslash = 226,
	Oem102 = 226,
	ProcessKey = 229,
	Packet = 231,
	Attn = 246,
	Crsel = 247,
	Exsel = 248,
	EraseEof = 249,
	Play = 250,
	Zoom = 251,
	NoName = 252,
	Pa1 = 253,
	OemClear = 254,

	KeyCode = 65535,
	Shift = 65536,
	Control = 131072,
	Alt = 262144,

	Modifiers = -65536
};

inline Keys& operator|=(Keys& lhs, Keys rhs)
{
	using T = std::underlying_type_t<Keys>;

	lhs = static_cast<Keys>(static_cast<T>(lhs) | static_cast<T>(rhs));

	return lhs;
}
```

`NativeCore/Unix/CloseRemoteProcess.cpp`:

```cpp
#include "NativeCore.hpp"

extern "C" void RC_CallConv CloseRemoteProcess(RC_Pointer handle)
{
	
}

```

`NativeCore/Unix/ControlRemoteProcess.cpp`:

```cpp
//#include <sys/types.h>
#include <csignal>

#include "NativeCore.hpp"

extern "C" void RC_CallConv ControlRemoteProcess(RC_Pointer handle, ControlRemoteProcessAction action)
{
	int signal = SIGKILL;
	if (action == ControlRemoteProcessAction::Suspend)
	{
		signal = SIGSTOP;
	}
	else if (action == ControlRemoteProcessAction::Resume)
	{
		signal = SIGCONT;
	}

	kill(static_cast<pid_t>(reinterpret_cast<intptr_t>(handle)), signal);
}

```

`NativeCore/Unix/Debugger.cpp`:

```cpp
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/user.h>
#include <experimental/filesystem>
#include <cstddef>

#include "NativeCore.hpp"

namespace fs = std::experimental::filesystem;

int ualarm(unsigned int milliseconds)
{
	struct itimerval nval = { 0 };
	nval.it_value.tv_sec = milliseconds / 1000;
	nval.it_value.tv_usec = static_cast<long int>(milliseconds % 1000) * 1000;
	struct itimerval oval;
	if (setitimer(ITIMER_REAL, &nval, &oval) < 0)
		return 0;
	else
		return oval.it_value.tv_sec;
}

pid_t waitpid_timeout(pid_t pid, int* status, int options, int timeoutInMilliseconds, bool& timedOut)
{
	struct sigaction sig = {};
	sig.sa_flags = 0;
	sig.sa_handler = [](int) {};
	sigfillset(&sig.sa_mask);
	sigaction(SIGALRM, &sig, nullptr);

	ualarm(timeoutInMilliseconds);

	auto res = waitpid(pid, status, options);
	if (res == -1 && errno == EINTR)
	{
		timedOut = true;
	}
	else
	{
		ualarm(0); // Cancel the alarm.

		timedOut = false;
	}
	return res;
}

pid_t waitpid_timeout(int* status, int timeoutInMilliseconds, bool& timedOut)
{
	return waitpid_timeout(-1, status, 0, timeoutInMilliseconds, timedOut);
}

extern "C" bool RC_CallConv AttachDebuggerToProcess(RC_Pointer id)
{
	//TODO: Attach to all threads.

	ptrace(PTRACE_ATTACH, static_cast<pid_t>(reinterpret_cast<intptr_t>(id)), nullptr, nullptr);
	
	waitpid(-1, nullptr, 0);

	ptrace(PTRACE_CONT, static_cast<pid_t>(reinterpret_cast<intptr_t>(id)), nullptr, nullptr);

	return false;
}

extern "C" void RC_CallConv DetachDebuggerFromProcess(RC_Pointer id)
{
	//TODO: Detach to all threads.

	ptrace(PTRACE_DETACH, static_cast<pid_t>(reinterpret_cast<intptr_t>(id)), nullptr, nullptr);
}

extern "C" bool RC_CallConv AwaitDebugEvent(DebugEvent* evt, int timeoutInMilliseconds)
{
	int status;
	bool timedOut;

	auto tid = waitpid_timeout(&status, timeoutInMilliseconds, timedOut);

	if (timedOut)
	{
		return false;
	}

	auto result = false;

	if (tid > 0)
	{
		evt->ThreadId = reinterpret_cast<RC_Pointer>(static_cast<intptr_t>(tid));

		siginfo_t si;
		if (ptrace(PTRACE_GETSIGINFO, tid, nullptr, &si) == 0)
		{
			if (si.si_signo == SIGTRAP)
			{
				struct user_regs_struct regs;
				if (ptrace(PTRACE_GETREGS, tid, nullptr, &regs) == 0)
				{
					DebugRegister6 dr6;
					dr6.Value = ptrace(PTRACE_PEEKUSER, tid, offsetof(struct user, u_debugreg[6]), nullptr);

					// Check if breakpoint was a hardware breakpoint.
					if (dr6.DR0)
					{
						evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr0;
					}
					else if (dr6.DR1)
					{
						evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr1;
					}
					else if (dr6.DR2)
					{
						evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr2;
					}
					else if (dr6.DR3)
					{
						evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr3;
					}
					else
					{
						evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::InvalidRegister;
					}

					// Copy registers.
					auto& reg = evt->ExceptionInfo.Registers;
#ifdef RECLASSNET64
					reg.Rax = reinterpret_cast<RC_Pointer>(regs.rax);
					reg.Rbx = reinterpret_cast<RC_Pointer>(regs.rbx);
					reg.Rcx = reinterpret_cast<RC_Pointer>(regs.rcx);
					reg.Rdx = reinterpret_cast<RC_Pointer>(regs.rdx);
					reg.Rdi = reinterpret_cast<RC_Pointer>(regs.rdi);
					reg.Rsi = reinterpret_cast<RC_Pointer>(regs.rsi);
					reg.Rsp = reinterpret_cast<RC_Pointer>(regs.rsp);
					reg.Rbp = reinterpret_cast<RC_Pointer>(regs.rbp);
					reg.Rip = reinterpret_cast<RC_Pointer>(regs.rip);

					reg.R8 = reinterpret_cast<RC_Pointer>(regs.r8);
					reg.R9 = reinterpret_cast<RC_Pointer>(regs.r9);
					reg.R10 = reinterpret_cast<RC_Pointer>(regs.r10);
					reg.R11 = reinterpret_cast<RC_Pointer>(regs.r11);
					reg.R12 = reinterpret_cast<RC_Pointer>(regs.r12);
					reg.R13 = reinterpret_cast<RC_Pointer>(regs.r13);
					reg.R14 = reinterpret_cast<RC_Pointer>(regs.r14);
					reg.R15 = reinterpret_cast<RC_Pointer>(regs.r15);
#else
					reg.Eax = reinterpret_cast<RC_Pointer>(regs.eax);
					reg.Ebx = reinterpret_cast<RC_Pointer>(regs.ebx);
					reg.Ecx = reinterpret_cast<RC_Pointer>(regs.ecx);
					reg.Edx = reinterpret_cast<RC_Pointer>(regs.edx);
					reg.Edi = reinterpret_cast<RC_Pointer>(regs.edi);
					reg.Esi = reinterpret_cast<RC_Pointer>(regs.esi);
					reg.Esp = reinterpret_cast<RC_Pointer>(regs.esp);
					reg.Ebp = reinterpret_cast<RC_Pointer>(regs.ebp);
					reg.Eip = reinterpret_cast<RC_Pointer>(regs.eip);
#endif

					result = true;
				}
			}

			if (result == false)
			{
				ptrace(PTRACE_CONT, tid, nullptr, si.si_signo);
			}
		}
	}

	return result;
}

extern "C" void RC_CallConv HandleDebugEvent(DebugEvent* evt)
{
	auto tid = static_cast<pid_t>(reinterpret_cast<intptr_t>(evt->ThreadId));

	siginfo_t si;
	if (ptrace(PTRACE_GETSIGINFO, tid, 0, &si) == 0)
	{
		auto signal = 0;
		switch (evt->ContinueStatus)
		{
		case DebugContinueStatus::Handled:
			signal = 0;
			break;
		case DebugContinueStatus::NotHandled:
			signal = si.si_signo;
			break;
		}

		if (signal == SIGSTOP)
		{
			signal = 0;
		}

		ptrace(PTRACE_CONT, tid, nullptr, signal);
	}
}

extern "C" bool RC_CallConv SetHardwareBreakpoint(RC_Pointer id, RC_Pointer address, HardwareBreakpointRegister reg, HardwareBreakpointTrigger type, HardwareBreakpointSize size, bool set)
{
	if (reg == HardwareBreakpointRegister::InvalidRegister)
	{
		return false;
	}

	intptr_t addressValue = 0;
	auto accessValue = 0;
	auto lengthValue = 0;

	if (set)
	{
		addressValue = reinterpret_cast<intptr_t>(address);

		if (type == HardwareBreakpointTrigger::Execute)
			accessValue = 0;
		else if (type == HardwareBreakpointTrigger::Access)
			accessValue = 3;
		else if (type == HardwareBreakpointTrigger::Write)
			accessValue = 1;

		if (size == HardwareBreakpointSize::Size1)
			lengthValue = 0;
		else if (size == HardwareBreakpointSize::Size2)
			lengthValue = 1;
		else if (size == HardwareBreakpointSize::Size4)
			lengthValue = 3;
		else if (size == HardwareBreakpointSize::Size8)
			lengthValue = 2;
	}

	auto tasksPath = fs::path("/proc") / std::to_string(reinterpret_cast<intptr_t>(id)) / "task";
	if (fs::is_directory(tasksPath))
	{
		for (auto& d : fs::directory_iterator(tasksPath))
		{
			if (fs::is_directory(d))
			{
				auto taskPath = d.path();

				auto name = taskPath.filename().string();
				if (is_number(name))
				{
					auto tid = parse_type<size_t>(name);

					// Stop the thread. TODO: Check if the thread was already paused.
					for (int i = 0; i < 10; ++i)
					{
						kill(tid, SIGSTOP);

						bool timedOut;
						waitpid_timeout(tid, nullptr, 0, 100, timedOut);
						if (!timedOut)
						{
							break;
						}
					}

					DebugRegister7 dr7;
					dr7.Value = ptrace(PTRACE_PEEKUSER, tid, offsetof(struct user, u_debugreg[7]), nullptr);

					intptr_t registerAddress;
					switch (reg)
					{
					case HardwareBreakpointRegister::Dr0:
						registerAddress = offsetof(struct user, u_debugreg[0]);
						dr7.G0 = true;
						dr7.RW0 = accessValue;
						dr7.Len0 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr1:
						registerAddress = offsetof(struct user, u_debugreg[1]);
						dr7.G1 = true;
						dr7.RW1 = accessValue;
						dr7.Len1 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr2:
						registerAddress = offsetof(struct user, u_debugreg[2]);
						dr7.G2 = true;
						dr7.RW2 = accessValue;
						dr7.Len2 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr3:
						registerAddress = offsetof(struct user, u_debugreg[3]);
						dr7.G3 = true;
						dr7.RW3 = accessValue;
						dr7.Len3 = lengthValue;
						break;
					}

					ptrace(PTRACE_POKEUSER, tid, registerAddress, addressValue);
					ptrace(PTRACE_POKEUSER, tid, offsetof(struct user, u_debugreg[7]), dr7.Value);

					ptrace(PTRACE_CONT, tid, nullptr, nullptr);
				}
			}
		}
	}

	return true;
}

```

`NativeCore/Unix/DisassembleCode.cpp`:

```cpp
#include "../Shared/DistormHelper.hpp"

extern "C" bool RC_CallConv DisassembleCode(RC_Pointer address, RC_Size length, RC_Pointer virtualAddress, bool determineStaticInstructionBytes, EnumerateInstructionCallback callback)
{
	return DisassembleInstructionsImpl(address, length, virtualAddress, determineStaticInstructionBytes, callback);
}

```

`NativeCore/Unix/EnumerateProcesses.cpp`:

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <experimental/filesystem>

#include "NativeCore.hpp"

namespace fs = std::experimental::filesystem;

// std::filesystem library doesn't work @Ubuntu 16.10, read_symlink() always fails.
#define USE_CUSTOM_READ_SYMLINK

#ifdef USE_CUSTOM_READ_SYMLINK
#include <unistd.h>

fs::path my_read_symlink(const fs::path& p, std::error_code& ec)
{
	fs::path symlink_path;

	std::string temp(64, '\0');
	for (;; temp.resize(temp.size() * 2))
	{
		ssize_t result;
		if ((result = ::readlink(p.c_str(), /*temp.data()*/ &temp[0], temp.size())) == -1)
		{
			ec.assign(errno, std::system_category());
			break;
		}
		else
		{
			if (result != static_cast<ssize_t>(temp.size()))
			{
				symlink_path = fs::path(std::string(temp.begin(), temp.begin() + result));

				ec.clear();

				break;
			}
		}
	}

	return symlink_path;
}

#endif

enum class Platform
{
	Unknown,
	X86,
	X64
};

Platform GetProcessPlatform(const std::string& auxvPath)
{
	auto platform = Platform::Unknown;

	std::ifstream file(auxvPath);
	if (file)
	{
		char buffer[16];
		while (true)
		{
			file.read(buffer, 16);

			if (!file)
			{
				return Platform::X64;
			}

			if (buffer[4] != 0 || buffer[5] != 0 || buffer[6] != 0 || buffer[7] != 0)
			{
				return Platform::X86;
			}
		}
	}

	return platform;
}

extern "C" void RC_CallConv EnumerateProcesses(EnumerateProcessCallback callbackProcess)
{
	if (callbackProcess == nullptr)
	{
		return;
	}

	fs::path procPath("/proc");
	if (fs::is_directory(procPath))
	{
		for (auto& d : fs::directory_iterator(procPath))
		{
			if (fs::is_directory(d))
			{
				auto processPath = d.path();

				auto name = processPath.filename().string();
				if (is_number(name))
				{
					auto exeSymLink = processPath / "exe";
					if (fs::is_symlink(fs::symlink_status(exeSymLink)))
					{
						std::error_code ec;
						auto linkPath = 
#ifdef USE_CUSTOM_READ_SYMLINK
							my_read_symlink
#else
							read_symlink
#endif
							(exeSymLink, ec).string();
						if (!ec)
						{
							auto auxvPath = processPath / "auxv";

							auto platform = GetProcessPlatform(auxvPath.string());
#ifdef RECLASSNET64
							if (platform == Platform::X64)
#else
							if (platform == Platform::X86)
#endif
							{
								EnumerateProcessData data = {};
								data.Id = parse_type<size_t>(name);
								MultiByteToUnicode(linkPath.c_str(), data.Path, PATH_MAXIMUM_LENGTH);
								const auto name = fs::path(data.Path).filename().u16string();
								str16cpy(data.Name, name.c_str(), std::min<int>(name.length(), PATH_MAXIMUM_LENGTH - 1));

								callbackProcess(&data);
							}
						}
					}
				}
			}
		}
	}
}

```

`NativeCore/Unix/EnumerateRemoteSectionsAndModules.cpp`:

```cpp
#include <fstream>
#include <sstream>
#include <unordered_map>

#include "NativeCore.hpp"

inline bool operator&(SectionProtection& lhs, SectionProtection rhs)
{
	using T = std::underlying_type_t<SectionProtection>;

	return (static_cast<T>(lhs) & static_cast<T>(rhs)) == static_cast<T>(rhs);
}

template<typename T>
inline std::istream& skip(std::istream& s)
{
	auto f = s.flags();
	s >> std::noskipws;

	T t;
	s >> t;

	s.flags(f);

	return s;
}

std::istream& operator >> (std::istream& s, SectionProtection& protection)
{
	protection = SectionProtection::NoAccess;

	if (s.get() == 'r') protection |= SectionProtection::Read;
	if (s.get() == 'w') protection |= SectionProtection::Write;
	if (s.get() == 'x') protection |= SectionProtection::Execute;

	return s;
}

extern "C" void RC_CallConv EnumerateRemoteSectionsAndModules(RC_Pointer handle, EnumerateRemoteSectionsCallback callbackSection, EnumerateRemoteModulesCallback callbackModule)
{
	if (callbackSection == nullptr && callbackModule == nullptr)
	{
		return;
	}

	struct ModuleInfo
	{
		intptr_t Start = 0;
		intptr_t End = 0;
		RC_UnicodeChar Path[PATH_MAXIMUM_LENGTH] = {};
	};

	std::ifstream input((std::stringstream() << "/proc/" << reinterpret_cast<intptr_t>(handle) << "/maps").str());

	std::unordered_map<int, ModuleInfo> modules;

	std::string line;
	while (std::getline(input, line))
	{
		std::stringstream ss(line);

		intptr_t start;
		intptr_t end;
		SectionProtection protection;
		intptr_t offset;
		int dev1, dev2;
		int inode;
		std::string path;
		ss >> std::hex >> start >> skip<char> >> end >> skip<char> >> protection >> skip<char> >> offset >> dev1 >> skip<char> >> dev2 >> std::dec >> inode >> std::skipws >> path;

		EnumerateRemoteSectionData section = {};
		section.BaseAddress = reinterpret_cast<RC_Pointer>(start);
		section.Size = end - start;
		section.Protection = protection;

		section.Category = SectionCategory::Unknown;
		section.Type = SectionType::Unknown;
		if (inode != 0)
		{
			section.Type = SectionType::Image;

			if (protection & SectionProtection::Read && protection & SectionProtection::Execute)
			{
				section.Category = SectionCategory::CODE;
			}
			else if (protection & SectionProtection::Read && protection & SectionProtection::Write)
			{
				section.Category = SectionCategory::DATA;
			}

			MultiByteToUnicode(path.c_str(), section.ModulePath, PATH_MAXIMUM_LENGTH);

			auto& module = modules[inode];
			module.Start = module.Start != 0 ? std::min(module.Start, start) : start;
			module.End = module.End != 0 ? std::max(module.End, end) : end;
			if (module.Path[0] == 0)
			{
				std::memcpy(module.Path, section.ModulePath, PATH_MAXIMUM_LENGTH);
			}
		}
		else
		{
			section.Type = SectionType::Mapped;

			if (protection & SectionProtection::Read || protection & SectionProtection::Write)
			{
				section.Category = SectionCategory::HEAP;
			}
		}

		if (callbackSection != nullptr)
		{
			callbackSection(&section);
		}
	}

	if (callbackModule != nullptr)
	{
		for (auto&& kv : modules)
		{
			EnumerateRemoteModuleData module = {};
			module.BaseAddress = reinterpret_cast<RC_Pointer>(kv.second.Start);
			module.Size = kv.second.End - kv.second.Start;
			std::memcpy(module.Path, kv.second.Path, PATH_MAXIMUM_LENGTH);

			callbackModule(&module);
		}
	}
}

```

`NativeCore/Unix/Input.cpp`:

```cpp
#include "NativeCore.hpp"
#include "../Shared/Keys.hpp"

RC_Pointer RC_CallConv InitializeInput()
{
	return nullptr;
}

bool RC_CallConv GetPressedKeys(RC_Pointer handle, Keys* state[], int* count)
{
	return false;
}

void RC_CallConv ReleaseInput(RC_Pointer handle)
{

}

```

`NativeCore/Unix/IsProcessValid.cpp`:

```cpp
#include <sys/types.h>
#include <signal.h>

#include "NativeCore.hpp"

extern "C" bool RC_CallConv IsProcessValid(RC_Pointer handle)
{
	return kill(static_cast<pid_t>(reinterpret_cast<intptr_t>(handle)), 0) == 0;
}

```

`NativeCore/Unix/Makefile`:

```
WORKDIR = `pwd`

CC = gcc
CXX = gcc
AR = ar
LD = g++
WINDRES = windres

INC = -I../Dependencies/distorm/include
CFLAGS = -Wall -fPIC -DRECLASSNET64=1
RESINC =
LIBDIR =
LIB = -lstdc++fs -lstdc++
LDFLAGS = -shared -Wl,--no-undefined

INC_DEBUG = $(INC)
CFLAGS_DEBUG = $(CFLAGS) -g
RESINC_DEBUG = $(RESINC)
RCFLAGS_DEBUG = $(RCFLAGS)
LIBDIR_DEBUG = $(LIBDIR)
LIB_DEBUG = $(LIB)
LDFLAGS_DEBUG = $(LDFLAGS)
OBJDIR_DEBUG = obj/debug
DEP_DEBUG =
OUT_DEBUG = build/debug/NativeCore.so

INC_RELEASE = $(INC)
CFLAGS_RELEASE = $(CFLAGS) -O2
RESINC_RELEASE = $(RESINC)
RCFLAGS_RELEASE = $(RCFLAGS)
LIBDIR_RELEASE = $(LIBDIR)
LIB_RELEASE = $(LIB)
LDFLAGS_RELEASE = $(LDFLAGS) -s
OBJDIR_RELEASE = obj/release
DEP_RELEASE =
OUT_RELEASE = build/release/NativeCore.so

OBJ_DEBUG = $(OBJDIR_DEBUG)/WriteRemoteMemory.o $(OBJDIR_DEBUG)/ReadRemoteMemory.o $(OBJDIR_DEBUG)/OpenRemoteProcess.o $(OBJDIR_DEBUG)/IsProcessValid.o $(OBJDIR_DEBUG)/Input.o $(OBJDIR_DEBUG)/EnumerateRemoteSectionsAndModules.o $(OBJDIR_DEBUG)/EnumerateProcesses.o $(OBJDIR_DEBUG)/DisassembleCode.o $(OBJDIR_DEBUG)/DistormHelper.o  $(OBJDIR_DEBUG)/Debugger.o $(OBJDIR_DEBUG)/ControlRemoteProcess.o $(OBJDIR_DEBUG)/CloseRemoteProcess.o $(OBJDIR_DEBUG)/decoder.o $(OBJDIR_DEBUG)/distorm.o $(OBJDIR_DEBUG)/instructions.o $(OBJDIR_DEBUG)/insts.o $(OBJDIR_DEBUG)/mnemonics.o $(OBJDIR_DEBUG)/operands.o $(OBJDIR_DEBUG)/prefix.o $(OBJDIR_DEBUG)/textdefs.o

OBJ_RELEASE = $(OBJDIR_RELEASE)/WriteRemoteMemory.o $(OBJDIR_RELEASE)/ReadRemoteMemory.o $(OBJDIR_RELEASE)/OpenRemoteProcess.o $(OBJDIR_RELEASE)/IsProcessValid.o $(OBJDIR_RELEASE)/Input.o $(OBJDIR_RELEASE)/EnumerateRemoteSectionsAndModules.o $(OBJDIR_RELEASE)/EnumerateProcesses.o $(OBJDIR_RELEASE)/DisassembleCode.o $(OBJDIR_RELEASE)/DistormHelper.o $(OBJDIR_RELEASE)/Debugger.o $(OBJDIR_RELEASE)/ControlRemoteProcess.o $(OBJDIR_RELEASE)/CloseRemoteProcess.o $(OBJDIR_RELEASE)/decoder.o $(OBJDIR_RELEASE)/distorm.o $(OBJDIR_RELEASE)/instructions.o $(OBJDIR_RELEASE)/insts.o $(OBJDIR_RELEASE)/mnemonics.o $(OBJDIR_RELEASE)/operands.o $(OBJDIR_RELEASE)/prefix.o $(OBJDIR_RELEASE)/textdefs.o

all: debug release

clean: clean_debug clean_release

before_debug:
	test -d build/debug || mkdir -p build/debug
	test -d $(OBJDIR_DEBUG) || mkdir -p $(OBJDIR_DEBUG)

after_debug:

debug: before_debug out_debug after_debug

out_debug: before_debug $(OBJ_DEBUG) $(DEP_DEBUG)
	$(CXX) $(LIBDIR_DEBUG) -o $(OUT_DEBUG) $(OBJ_DEBUG)  $(LDFLAGS_DEBUG) $(LIB_DEBUG)

$(OBJDIR_DEBUG)/WriteRemoteMemory.o: WriteRemoteMemory.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c WriteRemoteMemory.cpp -o $(OBJDIR_DEBUG)/WriteRemoteMemory.o

$(OBJDIR_DEBUG)/ReadRemoteMemory.o: ReadRemoteMemory.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ReadRemoteMemory.cpp -o $(OBJDIR_DEBUG)/ReadRemoteMemory.o

$(OBJDIR_DEBUG)/OpenRemoteProcess.o: OpenRemoteProcess.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c OpenRemoteProcess.cpp -o $(OBJDIR_DEBUG)/OpenRemoteProcess.o

$(OBJDIR_DEBUG)/IsProcessValid.o: IsProcessValid.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c IsProcessValid.cpp -o $(OBJDIR_DEBUG)/IsProcessValid.o

$(OBJDIR_DEBUG)/Input.o: Input.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c Input.cpp -o $(OBJDIR_DEBUG)/Input.o

$(OBJDIR_DEBUG)/EnumerateRemoteSectionsAndModules.o: EnumerateRemoteSectionsAndModules.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c EnumerateRemoteSectionsAndModules.cpp -o $(OBJDIR_DEBUG)/EnumerateRemoteSectionsAndModules.o

$(OBJDIR_DEBUG)/EnumerateProcesses.o: EnumerateProcesses.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c EnumerateProcesses.cpp -o $(OBJDIR_DEBUG)/EnumerateProcesses.o

$(OBJDIR_DEBUG)/DisassembleCode.o: DisassembleCode.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c DisassembleCode.cpp -o $(OBJDIR_DEBUG)/DisassembleCode.o

$(OBJDIR_DEBUG)/DistormHelper.o: ../Shared/DistormHelper.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Shared/DistormHelper.cpp -o $(OBJDIR_DEBUG)/DistormHelper.o

$(OBJDIR_DEBUG)/Debugger.o: Debugger.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c Debugger.cpp -o $(OBJDIR_DEBUG)/Debugger.o

$(OBJDIR_DEBUG)/ControlRemoteProcess.o: ControlRemoteProcess.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ControlRemoteProcess.cpp -o $(OBJDIR_DEBUG)/ControlRemoteProcess.o

$(OBJDIR_DEBUG)/CloseRemoteProcess.o: CloseRemoteProcess.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c CloseRemoteProcess.cpp -o $(OBJDIR_DEBUG)/CloseRemoteProcess.o

$(OBJDIR_DEBUG)/decoder.o: ../Dependencies/distorm/src/decoder.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/decoder.c -o $(OBJDIR_DEBUG)/decoder.o

$(OBJDIR_DEBUG)/distorm.o: ../Dependencies/distorm/src/distorm.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/distorm.c -o $(OBJDIR_DEBUG)/distorm.o

$(OBJDIR_DEBUG)/instructions.o: ../Dependencies/distorm/src/instructions.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/instructions.c -o $(OBJDIR_DEBUG)/instructions.o

$(OBJDIR_DEBUG)/insts.o: ../Dependencies/distorm/src/insts.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/insts.c -o $(OBJDIR_DEBUG)/insts.o

$(OBJDIR_DEBUG)/mnemonics.o: ../Dependencies/distorm/src/mnemonics.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/mnemonics.c -o $(OBJDIR_DEBUG)/mnemonics.o

$(OBJDIR_DEBUG)/operands.o: ../Dependencies/distorm/src/operands.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/operands.c -o $(OBJDIR_DEBUG)/operands.o

$(OBJDIR_DEBUG)/prefix.o: ../Dependencies/distorm/src/prefix.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/prefix.c -o $(OBJDIR_DEBUG)/prefix.o

$(OBJDIR_DEBUG)/textdefs.o: ../Dependencies/distorm/src/textdefs.c
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c ../Dependencies/distorm/src/textdefs.c -o $(OBJDIR_DEBUG)/textdefs.o

clean_debug:
	rm -f $(OBJ_DEBUG) $(OUT_DEBUG)
	rm -rf build/debug
	rm -rf $(OBJDIR_DEBUG)

before_release:
	test -d build/release || mkdir -p build/release
	test -d $(OBJDIR_RELEASE) || mkdir -p $(OBJDIR_RELEASE)

after_release:

release: before_release out_release after_release

out_release: before_release $(OBJ_RELEASE) $(DEP_RELEASE)
	$(LD) $(LIBDIR_RELEASE) -o $(OUT_RELEASE) $(OBJ_RELEASE)  $(LDFLAGS_RELEASE) $(LIB_RELEASE)

$(OBJDIR_RELEASE)/WriteRemoteMemory.o: WriteRemoteMemory.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c WriteRemoteMemory.cpp -o $(OBJDIR_RELEASE)/WriteRemoteMemory.o

$(OBJDIR_RELEASE)/ReadRemoteMemory.o: ReadRemoteMemory.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ReadRemoteMemory.cpp -o $(OBJDIR_RELEASE)/ReadRemoteMemory.o

$(OBJDIR_RELEASE)/OpenRemoteProcess.o: OpenRemoteProcess.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c OpenRemoteProcess.cpp -o $(OBJDIR_RELEASE)/OpenRemoteProcess.o

$(OBJDIR_RELEASE)/IsProcessValid.o: IsProcessValid.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c IsProcessValid.cpp -o $(OBJDIR_RELEASE)/IsProcessValid.o

$(OBJDIR_RELEASE)/Input.o: Input.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c Input.cpp -o $(OBJDIR_RELEASE)/Input.o

$(OBJDIR_RELEASE)/EnumerateRemoteSectionsAndModules.o: EnumerateRemoteSectionsAndModules.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c EnumerateRemoteSectionsAndModules.cpp -o $(OBJDIR_RELEASE)/EnumerateRemoteSectionsAndModules.o

$(OBJDIR_RELEASE)/EnumerateProcesses.o: EnumerateProcesses.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c EnumerateProcesses.cpp -o $(OBJDIR_RELEASE)/EnumerateProcesses.o

$(OBJDIR_RELEASE)/DisassembleCode.o: DisassembleCode.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c DisassembleCode.cpp -o $(OBJDIR_RELEASE)/DisassembleCode.o

$(OBJDIR_RELEASE)/DistormHelper.o: ../Shared/DistormHelper.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Shared/DistormHelper.cpp -o $(OBJDIR_RELEASE)/DistormHelper.o

$(OBJDIR_RELEASE)/Debugger.o: Debugger.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c Debugger.cpp -o $(OBJDIR_RELEASE)/Debugger.o

$(OBJDIR_RELEASE)/ControlRemoteProcess.o: ControlRemoteProcess.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ControlRemoteProcess.cpp -o $(OBJDIR_RELEASE)/ControlRemoteProcess.o

$(OBJDIR_RELEASE)/CloseRemoteProcess.o: CloseRemoteProcess.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c CloseRemoteProcess.cpp -o $(OBJDIR_RELEASE)/CloseRemoteProcess.o

$(OBJDIR_RELEASE)/decoder.o: ../Dependencies/distorm/src/decoder.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/decoder.c -o $(OBJDIR_RELEASE)/decoder.o

$(OBJDIR_RELEASE)/distorm.o: ../Dependencies/distorm/src/distorm.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/distorm.c -o $(OBJDIR_RELEASE)/distorm.o

$(OBJDIR_RELEASE)/instructions.o: ../Dependencies/distorm/src/instructions.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/instructions.c -o $(OBJDIR_RELEASE)/instructions.o

$(OBJDIR_RELEASE)/insts.o: ../Dependencies/distorm/src/insts.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/insts.c -o $(OBJDIR_RELEASE)/insts.o

$(OBJDIR_RELEASE)/mnemonics.o: ../Dependencies/distorm/src/mnemonics.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/mnemonics.c -o $(OBJDIR_RELEASE)/mnemonics.o

$(OBJDIR_RELEASE)/operands.o: ../Dependencies/distorm/src/operands.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/operands.c -o $(OBJDIR_RELEASE)/operands.o

$(OBJDIR_RELEASE)/prefix.o: ../Dependencies/distorm/src/prefix.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/prefix.c -o $(OBJDIR_RELEASE)/prefix.o

$(OBJDIR_RELEASE)/textdefs.o: ../Dependencies/distorm/src/textdefs.c
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c ../Dependencies/distorm/src/textdefs.c -o $(OBJDIR_RELEASE)/textdefs.o

clean_release:
	rm -f $(OBJ_RELEASE) $(OUT_RELEASE)
	rm -rf build/release
	rm -rf $(OBJDIR_RELEASE)

.PHONY: before_debug after_debug clean_debug before_release after_release clean_release

```

`NativeCore/Unix/NativeCore.Unix.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x86">
      <Configuration>Debug</Configuration>
      <Platform>x86</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x86">
      <Configuration>Release</Configuration>
      <Platform>x86</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{48c5258a-fa49-4173-aee5-0fca5190dff2}</ProjectGuid>
    <Keyword>Linux</Keyword>
    <RootNamespace>NativeCore</RootNamespace>
    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
    <ApplicationType>Linux</ApplicationType>
    <ApplicationTypeRevision>1.0</ApplicationTypeRevision>
    <TargetLinuxPlatform>Generic</TargetLinuxPlatform>
    <LinuxProjectType>{D51BCBC9-82E9-4017-911E-C93873C4EA2B}</LinuxProjectType>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared" />
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>NativeCore</TargetName>
    <TargetExt>.so</TargetExt>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>NativeCore</TargetName>
    <TargetExt>.so</TargetExt>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <TargetName>NativeCore</TargetName>
    <TargetExt>.so</TargetExt>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <TargetName>NativeCore</TargetName>
    <TargetExt>.so</TargetExt>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
  </PropertyGroup>
  <ItemGroup>
    <ClCompile Include="..\Dependencies\distorm\src\decoder.c" />
    <ClCompile Include="..\Dependencies\distorm\src\distorm.c" />
    <ClCompile Include="..\Dependencies\distorm\src\instructions.c" />
    <ClCompile Include="..\Dependencies\distorm\src\insts.c" />
    <ClCompile Include="..\Dependencies\distorm\src\mnemonics.c" />
    <ClCompile Include="..\Dependencies\distorm\src\operands.c" />
    <ClCompile Include="..\Dependencies\distorm\src\prefix.c" />
    <ClCompile Include="..\Dependencies\distorm\src\textdefs.c" />
    <ClCompile Include="..\Shared\DistormHelper.cpp" />
    <ClCompile Include="CloseRemoteProcess.cpp" />
    <ClCompile Include="ControlRemoteProcess.cpp" />
    <ClCompile Include="Debugger.cpp" />
    <ClCompile Include="DisassembleCode.cpp" />
    <ClCompile Include="EnumerateProcesses.cpp" />
    <ClCompile Include="EnumerateRemoteSectionsAndModules.cpp" />
    <ClCompile Include="Input.cpp" />
    <ClCompile Include="IsProcessValid.cpp" />
    <ClCompile Include="OpenRemoteProcess.cpp" />
    <ClCompile Include="ReadRemoteMemory.cpp" />
    <ClCompile Include="WriteRemoteMemory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Dependencies\distorm\include\distorm.h" />
    <ClInclude Include="..\Dependencies\distorm\include\mnemonics.h" />
    <ClInclude Include="..\Dependencies\distorm\src\config.h" />
    <ClInclude Include="..\Dependencies\distorm\src\decoder.h" />
    <ClInclude Include="..\Dependencies\distorm\src\instructions.h" />
    <ClInclude Include="..\Dependencies\distorm\src\insts.h" />
    <ClInclude Include="..\Dependencies\distorm\src\operands.h" />
    <ClInclude Include="..\Dependencies\distorm\src\prefix.h" />
    <ClInclude Include="..\Dependencies\distorm\src\textdefs.h" />
    <ClInclude Include="..\Dependencies\distorm\src\wstring.h" />
    <ClInclude Include="..\Dependencies\distorm\src\x86defs.h" />
    <ClInclude Include="..\ReClassNET_Plugin.hpp" />
    <ClInclude Include="..\Shared\DistormHelper.hpp" />
    <ClInclude Include="..\Shared\Keys.hpp" />
    <ClInclude Include="NativeCore.hpp" />
  </ItemGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PositionIndependentCode>true</PositionIndependentCode>
      <CppLanguageStandard>c++1y</CppLanguageStandard>
      <AdditionalIncludeDirectories>../Dependencies/distorm/include;$(Sysroot)\usr\include;$(StlIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>RECLASSNET64</PreprocessorDefinitions>
      <AdditionalOptions>-m64 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalOptions>-m64 %(AdditionalOptions)</AdditionalOptions>
      <LibraryDependencies>stdc++fs</LibraryDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PositionIndependentCode>true</PositionIndependentCode>
      <CppLanguageStandard>c++1y</CppLanguageStandard>
      <AdditionalIncludeDirectories>../Dependencies/distorm/include;$(Sysroot)\usr\include;$(StlIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>RECLASSNET64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>-m64 %(AdditionalOptions)</AdditionalOptions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <LinkTimeOptimization>true</LinkTimeOptimization>
      <ExceptionHandling>Disabled</ExceptionHandling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <LibraryDependencies>stdc++fs</LibraryDependencies>
      <AdditionalOptions>-m64 %(AdditionalOptions)</AdditionalOptions>
      <DebuggerSymbolInformation>OmitAllSymbolInformation</DebuggerSymbolInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <ClCompile>
      <PositionIndependentCode>true</PositionIndependentCode>
      <CppLanguageStandard>c++1y</CppLanguageStandard>
      <AdditionalIncludeDirectories>../Dependencies/distorm/include;$(Sysroot)\usr\include;$(StlIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions>-m32 %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>RECLASSNET32</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalOptions>-m32 %(AdditionalOptions)</AdditionalOptions>
      <LibraryDependencies>stdc++fs</LibraryDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <ClCompile>
      <PositionIndependentCode>true</PositionIndependentCode>
      <CppLanguageStandard>c++1y</CppLanguageStandard>
      <AdditionalIncludeDirectories>../Dependencies/distorm/include;$(Sysroot)\usr\include;$(StlIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions>-m32 %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>RECLASSNET32;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <LinkTimeOptimization>true</LinkTimeOptimization>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ExceptionHandling>Disabled</ExceptionHandling>
    </ClCompile>
    <Link>
      <AdditionalOptions>-m32 %(AdditionalOptions)</AdditionalOptions>
      <LibraryDependencies>stdc++fs</LibraryDependencies>
      <DebuggerSymbolInformation>OmitAllSymbolInformation</DebuggerSymbolInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`NativeCore/Unix/NativeCore.Unix.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Functions">
      <UniqueIdentifier>{32941fcb-69a5-43e7-86ba-38eb1ece3de9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Dependencies">
      <UniqueIdentifier>{eaf85ecc-eda1-49c6-a3be-14f2f8f4002c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Dependencies\distorm">
      <UniqueIdentifier>{5b0453e9-b429-4dfd-bcbb-f3756d073e60}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shared">
      <UniqueIdentifier>{976c6ca6-4172-4080-8162-a7913375df1a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CloseRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="ControlRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="Debugger.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="DisassembleCode.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="EnumerateProcesses.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="EnumerateRemoteSectionsAndModules.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="IsProcessValid.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="OpenRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="ReadRemoteMemory.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="WriteRemoteMemory.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="Input.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\decoder.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\distorm.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\instructions.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\insts.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\mnemonics.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\operands.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\prefix.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\textdefs.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\DistormHelper.cpp">
      <Filter>Shared</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NativeCore.hpp" />
    <ClInclude Include="..\ReClassNET_Plugin.hpp" />
    <ClInclude Include="..\Dependencies\distorm\include\distorm.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\include\mnemonics.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\DistormHelper.hpp">
      <Filter>Shared</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Keys.hpp">
      <Filter>Shared</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\config.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\decoder.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\instructions.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\insts.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\operands.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\prefix.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\textdefs.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\x86defs.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NativeCore/Unix/NativeCore.hpp`:

```hpp
#pragma once

#include <string>
#include <sstream>

#include "../ReClassNET_Plugin.hpp"
#include "../Shared/Keys.hpp"

extern "C"
{
	void EnumerateProcesses(EnumerateProcessCallback callbackProcess);
	void EnumerateRemoteSectionsAndModules(RC_Pointer handle, EnumerateRemoteSectionsCallback callbackSection, EnumerateRemoteModulesCallback callbackModule);

	RC_Pointer OpenRemoteProcess(RC_Pointer id, ProcessAccess desiredAccess);
	bool IsProcessValid(RC_Pointer handle);
	void CloseRemoteProcess(RC_Pointer handle);

	bool ReadRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size);
	bool WriteRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size);

	void ControlRemoteProcess(RC_Pointer handle, ControlRemoteProcessAction action);

	bool AttachDebuggerToProcess(RC_Pointer id);
	void DetachDebuggerFromProcess(RC_Pointer id);
	bool AwaitDebugEvent(DebugEvent* evt, int timeoutInMilliseconds);
	void HandleDebugEvent(DebugEvent* evt);
	bool SetHardwareBreakpoint(RC_Pointer id, RC_Pointer address, HardwareBreakpointRegister reg, HardwareBreakpointTrigger type, HardwareBreakpointSize size, bool set);

	RC_Pointer InitializeInput();
	bool GetPressedKeys(RC_Pointer handle, Keys* state[], int* count);
	void ReleaseInput(RC_Pointer handle);
}

inline bool is_number(const std::string& s)
{
	auto it = s.begin();
	for (; it != s.end() && std::isdigit(*it); ++it);
	return !s.empty() && it == s.end();
}

template<typename T>
inline T parse_type(const std::string& s)
{
	std::stringstream ss(s);

	T val;
	ss >> val;
	return val;
}

```

`NativeCore/Unix/OpenRemoteProcess.cpp`:

```cpp
#include "NativeCore.hpp"

extern "C" RC_Pointer RC_CallConv OpenRemoteProcess(RC_Pointer id, ProcessAccess desiredAccess)
{
	return id;
}

```

`NativeCore/Unix/ReadRemoteMemory.cpp`:

```cpp
#include <sys/uio.h>

#include "NativeCore.hpp"

extern "C" bool RC_CallConv ReadRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	iovec local[1];
	iovec remote[1];

	local[0].iov_base = (static_cast<uint8_t*>(buffer) + offset);
	local[0].iov_len = size;
	remote[0].iov_base = address;
	remote[0].iov_len = size;

	if (process_vm_readv(static_cast<pid_t>(reinterpret_cast<intptr_t>(handle)), local, 1, remote, 1, 0) != size)
	{
		return false;
	}
	
	return true;
}

```

`NativeCore/Unix/WriteRemoteMemory.cpp`:

```cpp
#include <sys/uio.h>

#include "NativeCore.hpp"

extern "C" bool RC_CallConv WriteRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	iovec local[1];
	iovec remote[1];

	local[0].iov_base = (static_cast<uint8_t*>(buffer) + offset);
	local[0].iov_len = size;
	remote[0].iov_base = address;
	remote[0].iov_len = size;

	if (process_vm_writev(static_cast<pid_t>(reinterpret_cast<intptr_t>(handle)), local, 1, remote, 1, 0) != size)
	{
		return false;
	}

	return true;
}

```

`NativeCore/Windows/CloseRemoteProcess.cpp`:

```cpp
#include <windows.h>

#include "NativeCore.hpp"

void RC_CallConv CloseRemoteProcess(RC_Pointer handle)
{
	if (handle == nullptr)
	{
		return;
	}

	CloseHandle(handle);
}

```

`NativeCore/Windows/ControlRemoteProcess.cpp`:

```cpp
#include <windows.h>
#include <tlhelp32.h>

#include "NativeCore.hpp"

void RC_CallConv ControlRemoteProcess(RC_Pointer handle, ControlRemoteProcessAction action)
{
	if (action == ControlRemoteProcessAction::Suspend || action == ControlRemoteProcessAction::Resume)
	{
		const auto processId = GetProcessId(handle);
		if (processId != 0)
		{
			const auto snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
			if (snapshotHandle != INVALID_HANDLE_VALUE)
			{
				const auto fn = action == ControlRemoteProcessAction::Suspend ? SuspendThread : ResumeThread;

				THREADENTRY32 te32 = {};
				te32.dwSize = sizeof(THREADENTRY32);
				if (Thread32First(snapshotHandle, &te32))
				{
					do
					{
						if (te32.th32OwnerProcessID == processId)
						{
							const auto threadHandle = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
							if (threadHandle)
							{
								fn(threadHandle);

								CloseHandle(threadHandle);
							}
						}
					} while (Thread32Next(snapshotHandle, &te32));
				}

				CloseHandle(snapshotHandle);
			}
		}
	}
	else if (action == ControlRemoteProcessAction::Terminate)
	{
		TerminateProcess(handle, 0);
	}
}

```

`NativeCore/Windows/Debugger.cpp`:

```cpp
#include <windows.h>
#include <tlhelp32.h>

#include "NativeCore.hpp"

bool RC_CallConv AttachDebuggerToProcess(RC_Pointer id)
{
	if (!DebugActiveProcess(static_cast<DWORD>(reinterpret_cast<size_t>(id))))
	{
		return false;
	}

	DebugSetProcessKillOnExit(FALSE);

	return true;
}

void RC_CallConv DetachDebuggerFromProcess(RC_Pointer id)
{
	DebugActiveProcessStop(static_cast<DWORD>(reinterpret_cast<size_t>(id)));
}

bool RC_CallConv AwaitDebugEvent(DebugEvent* evt, int timeoutInMilliseconds)
{
	DEBUG_EVENT _evt = { };
	if (!WaitForDebugEvent(&_evt, timeoutInMilliseconds))
	{
		return false;
	}

	auto result = false;

	evt->ProcessId = reinterpret_cast<RC_Pointer>(static_cast<size_t>(_evt.dwProcessId));
	evt->ThreadId = reinterpret_cast<RC_Pointer>(static_cast<size_t>(_evt.dwThreadId));

	switch (_evt.dwDebugEventCode)
	{
	case CREATE_PROCESS_DEBUG_EVENT:
		CloseHandle(_evt.u.CreateProcessInfo.hFile);
		break;
	case LOAD_DLL_DEBUG_EVENT:
		CloseHandle(_evt.u.LoadDll.hFile);
		break;
	case EXCEPTION_DEBUG_EVENT:
		auto& exception = _evt.u.Exception;

		// Copy basic informations.
		evt->ExceptionInfo.ExceptionAddress = exception.ExceptionRecord.ExceptionAddress;
		evt->ExceptionInfo.ExceptionCode = exception.ExceptionRecord.ExceptionCode;
		evt->ExceptionInfo.ExceptionFlags = exception.ExceptionRecord.ExceptionFlags;

		const auto handle = OpenThread(THREAD_GET_CONTEXT, FALSE, _evt.dwThreadId);

		CONTEXT ctx = { };
		ctx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_DEBUG_REGISTERS;
		GetThreadContext(handle, &ctx);

		DebugRegister6 dr6;
		dr6.Value = ctx.Dr6;

		// Check if breakpoint was a hardware breakpoint.
		if (dr6.DR0)
		{
			evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr0;
		}
		else if (dr6.DR1)
		{
			evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr1;
		}
		else if (dr6.DR2)
		{
			evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr2;
		}
		else if (dr6.DR3)
		{
			evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::Dr3;
		}
		else
		{
			evt->ExceptionInfo.CausedBy = HardwareBreakpointRegister::InvalidRegister;
		}

		// Copy registers.
		auto& reg = evt->ExceptionInfo.Registers;
#ifdef RECLASSNET64
		reg.Rax = reinterpret_cast<RC_Pointer>(ctx.Rax);
		reg.Rbx = reinterpret_cast<RC_Pointer>(ctx.Rbx);
		reg.Rcx = reinterpret_cast<RC_Pointer>(ctx.Rcx);
		reg.Rdx = reinterpret_cast<RC_Pointer>(ctx.Rdx);
		reg.Rdi = reinterpret_cast<RC_Pointer>(ctx.Rdi);
		reg.Rsi = reinterpret_cast<RC_Pointer>(ctx.Rsi);
		reg.Rsp = reinterpret_cast<RC_Pointer>(ctx.Rsp);
		reg.Rbp = reinterpret_cast<RC_Pointer>(ctx.Rbp);
		reg.Rip = reinterpret_cast<RC_Pointer>(ctx.Rip);

		reg.R8 = reinterpret_cast<RC_Pointer>(ctx.R8);
		reg.R9 = reinterpret_cast<RC_Pointer>(ctx.R9);
		reg.R10 = reinterpret_cast<RC_Pointer>(ctx.R10);
		reg.R11 = reinterpret_cast<RC_Pointer>(ctx.R11);
		reg.R12 = reinterpret_cast<RC_Pointer>(ctx.R12);
		reg.R13 = reinterpret_cast<RC_Pointer>(ctx.R13);
		reg.R14 = reinterpret_cast<RC_Pointer>(ctx.R14);
		reg.R15 = reinterpret_cast<RC_Pointer>(ctx.R15);
#else
		reg.Eax = reinterpret_cast<RC_Pointer>(ctx.Eax);
		reg.Ebx = reinterpret_cast<RC_Pointer>(ctx.Ebx);
		reg.Ecx = reinterpret_cast<RC_Pointer>(ctx.Ecx);
		reg.Edx = reinterpret_cast<RC_Pointer>(ctx.Edx);
		reg.Edi = reinterpret_cast<RC_Pointer>(ctx.Edi);
		reg.Esi = reinterpret_cast<RC_Pointer>(ctx.Esi);
		reg.Esp = reinterpret_cast<RC_Pointer>(ctx.Esp);
		reg.Ebp = reinterpret_cast<RC_Pointer>(ctx.Ebp);
		reg.Eip = reinterpret_cast<RC_Pointer>(ctx.Eip);
#endif

		CloseHandle(handle);

		result = true;
		break;
	}

	if (result == false)
	{
		ContinueDebugEvent(_evt.dwProcessId, _evt.dwThreadId, DBG_CONTINUE);
	}

	return result;
}

void RC_CallConv HandleDebugEvent(DebugEvent* evt)
{
	DWORD continueStatus = 0;
	switch (evt->ContinueStatus)
	{
	case DebugContinueStatus::Handled:
		continueStatus = DBG_CONTINUE;
		break;
	case DebugContinueStatus::NotHandled:
		continueStatus = DBG_EXCEPTION_NOT_HANDLED;
		break;
	}

	ContinueDebugEvent(static_cast<DWORD>(reinterpret_cast<size_t>(evt->ProcessId)), static_cast<DWORD>(reinterpret_cast<size_t>(evt->ThreadId)), continueStatus);
}

bool RC_CallConv SetHardwareBreakpoint(RC_Pointer id, RC_Pointer address, HardwareBreakpointRegister reg, HardwareBreakpointTrigger type, HardwareBreakpointSize size, bool set)
{
	if (reg == HardwareBreakpointRegister::InvalidRegister)
	{
		return false;
	}

	decltype(CONTEXT::Dr0) addressValue = 0;
	int accessValue = 0;
	int lengthValue = 0;

	if (set)
	{
		addressValue = reinterpret_cast<decltype(CONTEXT::Dr0)>(address);

		if (type == HardwareBreakpointTrigger::Execute)
			accessValue = 0;
		else if (type == HardwareBreakpointTrigger::Access)
			accessValue = 3;
		else if (type == HardwareBreakpointTrigger::Write)
			accessValue = 1;

		if (size == HardwareBreakpointSize::Size1)
			lengthValue = 0;
		else if (size == HardwareBreakpointSize::Size2)
			lengthValue = 1;
		else if (size == HardwareBreakpointSize::Size4)
			lengthValue = 3;
		else if (size == HardwareBreakpointSize::Size8)
			lengthValue = 2;
	}

	const auto snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (snapshotHandle != INVALID_HANDLE_VALUE)
	{
		THREADENTRY32 te32 = {};
		te32.dwSize = sizeof(THREADENTRY32);
		if (Thread32First(snapshotHandle, &te32))
		{
			do
			{
				if (te32.th32OwnerProcessID == static_cast<DWORD>(reinterpret_cast<size_t>(id)))
				{
					const auto threadHandle = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);

					SuspendThread(threadHandle);

					CONTEXT ctx = { 0 };
					ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
					GetThreadContext(threadHandle, &ctx);

					DebugRegister7 dr7;
					dr7.Value = ctx.Dr7;

					switch (reg)
					{
					case HardwareBreakpointRegister::Dr0:
						ctx.Dr0 = addressValue;
						dr7.G0 = true;
						dr7.RW0 = accessValue;
						dr7.Len0 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr1:
						ctx.Dr1 = addressValue;
						dr7.G1 = true;
						dr7.RW1 = accessValue;
						dr7.Len1 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr2:
						ctx.Dr2 = addressValue;
						dr7.G2 = true;
						dr7.RW2 = accessValue;
						dr7.Len2 = lengthValue;
						break;
					case HardwareBreakpointRegister::Dr3:
						ctx.Dr3 = addressValue;
						dr7.G3 = true;
						dr7.RW3 = accessValue;
						dr7.Len3 = lengthValue;
						break;
					}

					ctx.Dr7 = dr7.Value;

					SetThreadContext(threadHandle, &ctx);

					ResumeThread(threadHandle);

					CloseHandle(threadHandle);
				}
			} while (Thread32Next(snapshotHandle, &te32));
		}

		CloseHandle(snapshotHandle);
	}

	return true;
}

```

`NativeCore/Windows/DisassembleCode.cpp`:

```cpp
#include "../Shared/DistormHelper.hpp"

bool RC_CallConv DisassembleCode(RC_Pointer address, RC_Size length, RC_Pointer virtualAddress, bool determineStaticInstructionBytes, EnumerateInstructionCallback callback)
{
	return DisassembleInstructionsImpl(address, length, virtualAddress, determineStaticInstructionBytes, callback);
}

```

`NativeCore/Windows/EnumerateProcesses.cpp`:

```cpp
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <filesystem>

#include "NativeCore.hpp"

enum class Platform
{
	Unknown,
	X86,
	X64
};

Platform GetProcessPlatform(HANDLE process)
{
	static USHORT processorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
	if (processorArchitecture == PROCESSOR_ARCHITECTURE_UNKNOWN)
	{
		SYSTEM_INFO info = {};
		GetNativeSystemInfo(&info);

		processorArchitecture = info.wProcessorArchitecture;
	}

	switch (processorArchitecture)
	{
		case PROCESSOR_ARCHITECTURE_INTEL:
			return Platform::X86;
		case PROCESSOR_ARCHITECTURE_AMD64:
			auto isWow64 = FALSE;
			if (IsWow64Process(process, &isWow64))
			{
				return isWow64 ? Platform::X86 : Platform::X64;
			}

#ifdef RECLASSNET64
			return Platform::X64;
#else
			return Platform::X86;
#endif
	}
	return Platform::Unknown;
}

void RC_CallConv EnumerateProcesses(EnumerateProcessCallback callbackProcess)
{
	if (callbackProcess == nullptr)
	{
		return;
	}

	const auto handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (handle != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32W pe32 = {};
		pe32.dwSize = sizeof(PROCESSENTRY32W);
		if (Process32FirstW(handle, &pe32))
		{
			do
			{
				const auto process = OpenRemoteProcess(reinterpret_cast<RC_Pointer>(static_cast<size_t>(pe32.th32ProcessID)), ProcessAccess::Read);
				if (IsProcessValid(process))
				{
					const auto platform = GetProcessPlatform(process);
#ifdef RECLASSNET64
					if (platform == Platform::X64)
#else
					if (platform == Platform::X86)
#endif
					{
						EnumerateProcessData data = { };
						data.Id = pe32.th32ProcessID;
						GetModuleFileNameExW(process, nullptr, reinterpret_cast<LPWSTR>(data.Path), PATH_MAXIMUM_LENGTH);
						const auto name = std::filesystem::path(data.Path).filename().u16string();
						str16cpy(data.Name, name.c_str(), std::min<size_t>(name.length(), PATH_MAXIMUM_LENGTH - 1));

						callbackProcess(&data);
					}

				}
				
				CloseRemoteProcess(process);
				
			} while (Process32NextW(handle, &pe32));
		}

		CloseHandle(handle);
	}
}

```

`NativeCore/Windows/EnumerateRemoteSectionsAndModules.cpp`:

```cpp
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <vector>
#include <algorithm>
#include <functional>

#include "NativeCore.hpp"

PPEB GetRemotePeb(const HANDLE process)
{
	static auto* const ntdll = GetModuleHandle(TEXT("ntdll"));
	if (!ntdll)
	{
		return nullptr;
	}

	using tNtQueryInformationProcess = NTSTATUS (NTAPI*)(_In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength);

	static const auto pNtQueryInformationProcess = tNtQueryInformationProcess(GetProcAddress(ntdll, "NtQueryInformationProcess"));
	if (!pNtQueryInformationProcess)
	{
		return nullptr;
	}

	PROCESS_BASIC_INFORMATION pbi;
	if (!NT_SUCCESS(pNtQueryInformationProcess(process, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), nullptr)))
	{
		return nullptr;
	}

	return pbi.PebBaseAddress;
}

using InternalEnumerateRemoteModulesCallback = std::function<void(EnumerateRemoteModuleData&)>;

bool EnumerateRemoteModulesNative(const RC_Pointer process, const InternalEnumerateRemoteModulesCallback& callback)
{
	auto* const ppeb = GetRemotePeb(process);
	if (ppeb == nullptr)
	{
		return false;
	}
	
	PPEB_LDR_DATA ldr;
	if (!ReadRemoteMemory(process, &ppeb->Ldr, &ldr, 0, sizeof(PPEB_LDR_DATA)))
	{
		return false;
	}

	auto* const head = &ldr->InMemoryOrderModuleList;
	PLIST_ENTRY current;
	if (!ReadRemoteMemory(process, &head->Flink, &current, 0, sizeof(PLIST_ENTRY)))
	{
		return false;
	}
	
	while (current != head)
	{
		LDR_DATA_TABLE_ENTRY entry;
		if (!ReadRemoteMemory(process, CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks), &entry, 0, sizeof(entry)))
		{
			break;
		}

		EnumerateRemoteModuleData data = {};
		data.BaseAddress = entry.DllBase;
		data.Size = *reinterpret_cast<ULONG*>(&entry.Reserved3[1]); // instead of undocced member could read ImageSize from headers

		const auto length = std::min<int>(sizeof(RC_UnicodeChar) * (PATH_MAXIMUM_LENGTH - 1), entry.FullDllName.Length);
		if (!ReadRemoteMemory(process, entry.FullDllName.Buffer, data.Path, 0, length))
		{
			break;
		}
		data.Path[length / 2] = 0;
		
		callback(data);
		
		current = entry.InMemoryOrderLinks.Flink;
	}
	
	return true;
}

bool EnumerateRemoteModulesWinapi(const RC_Pointer process, const InternalEnumerateRemoteModulesCallback& callback)
{
	auto* const handle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetProcessId(process));
	if (handle == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	
	MODULEENTRY32W me32 = {};
	me32.dwSize = sizeof(MODULEENTRY32W);
	if (Module32FirstW(handle, &me32))
	{
		do
		{
			EnumerateRemoteModuleData data = {};
			data.BaseAddress = me32.modBaseAddr;
			data.Size = me32.modBaseSize;
			std::memcpy(data.Path, me32.szExePath, std::min(MAX_PATH, PATH_MAXIMUM_LENGTH));

			callback(data);
		} while (Module32NextW(handle, &me32));
	}

	CloseHandle(handle);

	return true;
}

void RC_CallConv EnumerateRemoteSectionsAndModules(RC_Pointer process, EnumerateRemoteSectionsCallback callbackSection, EnumerateRemoteModulesCallback callbackModule)
{
	if (callbackSection == nullptr && callbackModule == nullptr)
	{
		return;
	}

	std::vector<EnumerateRemoteSectionData> sections;

	MEMORY_BASIC_INFORMATION memory = { };
	memory.RegionSize = 0x1000;
	size_t address = 0;
	while (VirtualQueryEx(process, reinterpret_cast<LPCVOID>(address), &memory, sizeof(MEMORY_BASIC_INFORMATION)) != 0 && address + memory.RegionSize > address)
	{
		if (memory.State == MEM_COMMIT)
		{
			EnumerateRemoteSectionData section = {};
			section.BaseAddress = memory.BaseAddress;
			section.Size = memory.RegionSize;
			
			section.Protection = SectionProtection::NoAccess;
			if ((memory.Protect & PAGE_EXECUTE) == PAGE_EXECUTE) section.Protection |= SectionProtection::Execute;
			if ((memory.Protect & PAGE_EXECUTE_READ) == PAGE_EXECUTE_READ) section.Protection |= SectionProtection::Execute | SectionProtection::Read;
			if ((memory.Protect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::Write;
			if ((memory.Protect & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::CopyOnWrite;
			if ((memory.Protect & PAGE_READONLY) == PAGE_READONLY) section.Protection |= SectionProtection::Read;
			if ((memory.Protect & PAGE_READWRITE) == PAGE_READWRITE) section.Protection |= SectionProtection::Read | SectionProtection::Write;
			if ((memory.Protect & PAGE_WRITECOPY) == PAGE_WRITECOPY) section.Protection |= SectionProtection::Read | SectionProtection::CopyOnWrite;
			if ((memory.Protect & PAGE_GUARD) == PAGE_GUARD) section.Protection |= SectionProtection::Guard;
			
			switch (memory.Type)
			{
			case MEM_IMAGE:
				section.Type = SectionType::Image;
				break;
			case MEM_MAPPED:
				section.Type = SectionType::Mapped;
				break;
			case MEM_PRIVATE:
				section.Type = SectionType::Private;
				break;
			}

			section.Category = section.Type == SectionType::Private ? SectionCategory::HEAP : SectionCategory::Unknown;

			sections.push_back(section);
		}
		address = reinterpret_cast<size_t>(memory.BaseAddress) + memory.RegionSize;
	}

	const auto moduleEnumerator = [&](EnumerateRemoteModuleData& data)
	{
		if (callbackModule != nullptr)
		{
			callbackModule(&data);
		}

		if (callbackSection != nullptr)
		{
			auto it = std::lower_bound(std::begin(sections), std::end(sections), static_cast<LPVOID>(data.BaseAddress), [&sections](const auto& lhs, const LPVOID& rhs)
			{
				return lhs.BaseAddress < rhs;
			});

			IMAGE_DOS_HEADER imageDosHeader = {};
			IMAGE_NT_HEADERS imageNtHeaders = {};

			if (!ReadRemoteMemory(process, data.BaseAddress, &imageDosHeader, 0, sizeof(IMAGE_DOS_HEADER))
				|| !ReadRemoteMemory(process, PUCHAR(data.BaseAddress) + imageDosHeader.e_lfanew, &imageNtHeaders, 0, sizeof(IMAGE_NT_HEADERS)))
			{
				return;
			}

			std::vector<IMAGE_SECTION_HEADER> sectionHeaders(imageNtHeaders.FileHeader.NumberOfSections);
			ReadRemoteMemory(process, PUCHAR(data.BaseAddress) + imageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS), sectionHeaders.data(), 0, imageNtHeaders.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
			for (auto&& sectionHeader : sectionHeaders)
			{
				const auto sectionAddress = reinterpret_cast<size_t>(data.BaseAddress) + sectionHeader.VirtualAddress;

				for (; it != std::end(sections); ++it)
				{
					auto&& section = *it;
					
					if (sectionAddress >= reinterpret_cast<size_t>(section.BaseAddress) 
						&& sectionAddress < reinterpret_cast<size_t>(section.BaseAddress) + static_cast<size_t>(section.Size)
						&& sectionHeader.VirtualAddress + sectionHeader.Misc.VirtualSize <= data.Size)
					{
						if ((sectionHeader.Characteristics & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE)
						{
							section.Category = SectionCategory::CODE;
						}
						else if (sectionHeader.Characteristics & (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA))
						{
							section.Category = SectionCategory::DATA;
						}

						try
						{
							// Copy the name because it is not null padded.
							char buffer[IMAGE_SIZEOF_SHORT_NAME + 1] = { 0 };
							std::memcpy(buffer, sectionHeader.Name, IMAGE_SIZEOF_SHORT_NAME);
							MultiByteToUnicode(buffer, section.Name, IMAGE_SIZEOF_SHORT_NAME);
						}
						catch (std::range_error &)
						{
							std::memset(section.Name, 0, sizeof(section.Name));
						}
						std::memcpy(section.ModulePath, data.Path, std::min(MAX_PATH, PATH_MAXIMUM_LENGTH));

						break;
					}
				}
			}
		}
	};
	
	if (!EnumerateRemoteModulesNative(process, moduleEnumerator))
	{
		EnumerateRemoteModulesWinapi(process, moduleEnumerator);
	}

	if (callbackSection != nullptr)
	{
		for (auto&& section : sections)
		{
			callbackSection(&section);
		}
	}
}

```

`NativeCore/Windows/Input.cpp`:

```cpp
#define DIRECTINPUT_VERSION 0x0800

#include <dinput.h>
#include <vector>

#include "NativeCore.hpp"
#include "../Shared/Keys.hpp"

Keys mapping[];

class DirectInput
{
public:
	DirectInput() = default;

	DirectInput(const DirectInput&) = delete;
	DirectInput(const DirectInput&&) = delete;
	DirectInput& operator=(DirectInput const&) = delete;
	DirectInput& operator=(DirectInput const&&) = delete;

	~DirectInput()
	{
		if (keyboardDevice)
		{
			keyboardDevice->Unacquire();
			keyboardDevice->Release();
			keyboardDevice = nullptr;
		}
		if (directInputInterface)
		{
			directInputInterface->Release();
			directInputInterface = nullptr;
		}
	}

	bool Initialize()
	{
		if (DirectInput8Create(GetModuleHandle(nullptr), DIRECTINPUT_VERSION, IID_IDirectInput8W, reinterpret_cast<void**>(&directInputInterface), nullptr) != DI_OK)
		{
			return false;
		}

		if (directInputInterface->CreateDevice(GUID_SysKeyboard, &keyboardDevice, nullptr) != DI_OK
			|| keyboardDevice->SetDataFormat(&c_dfDIKeyboard) != DI_OK)
		{
			return false;
		}

		return true;
	}

	bool ReadKeyboardState(Keys* keys[], int* count)
	{
		const int STATE_PRESSED = 0x80;

		currentState.clear();

		BYTE keyBuffer[256] = {};
		const auto result = keyboardDevice->GetDeviceState(sizeof(keyBuffer), &keyBuffer);
		if (result != DI_OK)
		{
			if (result == DIERR_NOTACQUIRED || result == DIERR_INPUTLOST)
			{
				keyboardDevice->Acquire();
			}
			return false;
		}

		auto modifier = Keys::None;
		if (keyBuffer[DIK_LSHIFT] & STATE_PRESSED || keyBuffer[DIK_RSHIFT] & STATE_PRESSED)
		{
			modifier |= Keys::Shift;
		}
		if (keyBuffer[DIK_LCONTROL] & STATE_PRESSED || keyBuffer[DIK_RCONTROL] & STATE_PRESSED)
		{
			modifier |= Keys::Control;
		}
		if (keyBuffer[DIK_LMENU] & STATE_PRESSED)
		{
			modifier |= Keys::Alt;
		}
		if (keyBuffer[DIK_RMENU] & STATE_PRESSED)
		{
			modifier |= Keys::Alt;
			modifier |= Keys::Control;
		}

		for (auto i = 0u; i < 0xEF; ++i)
		{
			if (keyBuffer[i] & STATE_PRESSED)
			{
				auto currentKey = mapping[i];
				if (currentKey != Keys::None)
				{
					switch (currentKey)
					{
					case Keys::LControlKey:
					case Keys::RControlKey:
						currentKey = Keys::ControlKey;
						break;
					case Keys::LShiftKey:
					case Keys::RShiftKey:
						currentKey = Keys::ControlKey;
						break;
					case Keys::LMenu:
					case Keys::RMenu:
						currentKey = Keys::Menu;
						break;
					}

					currentKey |= modifier;

					currentState.push_back(currentKey);
				}
			}
		}

		*keys = currentState.data();
		*count = static_cast<int>(currentState.size());

		return true;
	}

private:
	IDirectInput8W* directInputInterface = nullptr;
	IDirectInputDevice8W* keyboardDevice = nullptr;
	std::vector<Keys> currentState;
};

RC_Pointer RC_CallConv InitializeInput()
{
	auto input = new DirectInput();
	if (!input->Initialize())
	{
		delete input;

		return nullptr;
	}
	return static_cast<RC_Pointer>(input);
}

bool RC_CallConv GetPressedKeys(RC_Pointer handle, Keys* keys[], int* count)
{
	return static_cast<DirectInput*>(handle)->ReadKeyboardState(keys, count);
}

void RC_CallConv ReleaseInput(RC_Pointer handle)
{
	delete static_cast<DirectInput*>(handle);
}

Keys mapping[] =
{
	Keys::None, /*0x00*/
	Keys::Escape, /* DIK_ESCAPE */ /*0x01*/
	Keys::D1, /* DIK_1 */ /*0x02*/
	Keys::D2, /* DIK_2 */ /*0x03*/
	Keys::D3, /* DIK_3 */ /*0x04*/
	Keys::D4, /* DIK_4 */ /*0x05*/
	Keys::D5, /* DIK_5 */ /*0x06*/
	Keys::D6, /* DIK_6 */ /*0x07*/
	Keys::D7, /* DIK_7 */ /*0x08*/
	Keys::D8, /* DIK_8 */ /*0x09*/
	Keys::D9, /* DIK_9 */ /*0x0A*/
	Keys::D0, /* DIK_0 */ /*0x0B*/
	Keys::OemMinus, /* DIK_MINUS */ /*0x0C*/
	Keys::OemPlus, /* DIK_EQUALS */ /*0x0D*/
	Keys::Back, /* DIK_BACK */ /*0x0E*/
	Keys::Tab, /* DIK_TAB */ /*0x0F*/
	Keys::Q, /* DIK_Q */ /*0x10*/
	Keys::W, /* DIK_W */ /*0x11*/
	Keys::E, /* DIK_E */ /*0x12*/
	Keys::R, /* DIK_R */ /*0x13*/
	Keys::T, /* DIK_T */ /*0x14*/
	Keys::Z, /* DIK_Y */ /*0x15*/
	Keys::U, /* DIK_U */ /*0x16*/
	Keys::I, /* DIK_I */ /*0x17*/
	Keys::O, /* DIK_O */ /*0x18*/
	Keys::P, /* DIK_P */ /*0x19*/
	Keys::Oem4, /* DIK_LBRACKET */ /*0x1A*/
	Keys::Oem6, /* DIK_RBRACKET */ /*0x1B*/
	Keys::Return, /* DIK_RETURN */ /*0x1C*/
	Keys::LControlKey, /* DIK_LControl */ /*0x1D*/
	Keys::A, /* DIK_A */ /*0x1E*/
	Keys::S, /* DIK_S */ /*0x1F*/
	Keys::D, /* DIK_D */ /*0x20*/
	Keys::F, /* DIK_F */ /*0x21*/
	Keys::G, /* DIK_G */ /*0x22*/
	Keys::H, /* DIK_H */ /*0x23*/
	Keys::J, /* DIK_J */ /*0x24*/
	Keys::K, /* DIK_K */ /*0x25*/
	Keys::L, /* DIK_L */ /*0x26*/
	Keys::Oem1, /* DIK_SEMICOLON */ /*0x27*/
	Keys::Oem7, /* DIK_APOSTROPHE */ /*0x28*/
	Keys::Oem3, /* DIK_GRAVE */ /*0x29*/
	Keys::LShiftKey, /* DIK_LSHIFT */ /*0x2A*/
	Keys::OemBackslash, /* DIK_BACKSLASH */ /*0x2B*/
	Keys::Y, /* DIK_Z */ /*0x2C*/
	Keys::X, /* DIK_X */ /*0x2D*/
	Keys::C, /* DIK_C */ /*0x2E*/
	Keys::V, /* DIK_V */ /*0x2F*/
	Keys::B, /* DIK_B */ /*0x30*/
	Keys::N, /* DIK_N */ /*0x31*/
	Keys::M, /* DIK_M */ /*0x32*/
	Keys::OemComma, /* DIK_COMMA */ /*0x33*/
	Keys::OemPeriod, /* DIK_PERIOD */ /*0x34*/
	Keys::Oem2, /* DIK_SLASH */ /*0x35*/
	Keys::RShiftKey, /* DIK_RSHIFT */ /*0x36*/
	Keys::Multiply, /* DIK_MULTIPLY */ /*0x37*/
	Keys::LMenu, /* DIK_LMENU */ /*0x38*/
	Keys::Space, /* DIK_SPACE */ /*0x39*/
	Keys::CapsLock, /* DIK_CAPITAL */ /*0x3A*/
	Keys::F1, /* DIK_F1 */ /*0x3B*/
	Keys::F2, /* DIK_F2 */ /*0x3C*/
	Keys::F3, /* DIK_F3 */ /*0x3D*/
	Keys::F4, /* DIK_F4 */ /*0x3E*/
	Keys::F5, /* DIK_F5 */ /*0x3F*/
	Keys::F6, /* DIK_F6 */ /*0x40*/
	Keys::F7, /* DIK_F7 */ /*0x41*/
	Keys::F8, /* DIK_F8 */ /*0x42*/
	Keys::F9, /* DIK_F9 */ /*0x43*/
	Keys::F10, /* DIK_F10 */ /*0x44*/
	Keys::NumLock, /* DIK_NUMLOCK */ /*0x45*/
	Keys::Scroll, /* DIK_SCROLL */ /*0x46*/
	Keys::NumPad7, /* DIK_NUMPAD7 */ /*0x47*/
	Keys::NumPad8, /* DIK_NUMPAD8 */ /*0x48*/
	Keys::NumPad9, /* DIK_NUMPAD9 */ /*0x49*/
	Keys::Subtract, /* DIK_SUBSTRACT */ /*0x4A*/
	Keys::NumPad4, /* DIK_NUMPAD4 */ /*0x4B*/
	Keys::NumPad5, /* DIK_NUMPAD5 */ /*0x4C*/
	Keys::NumPad6, /* DIK_NUMPAD6 */ /*0x4D*/
	Keys::Add, /* DIK_ADD */ /*0x4E*/
	Keys::NumPad1, /* DIK_NUMPAD1 */ /*0x4F*/
	Keys::NumPad2, /* DIK_NUMPAD2 */ /*0x50*/
	Keys::NumPad3, /* DIK_NUMPAD3 */ /*0x51*/
	Keys::NumPad0, /* DIK_NUMPAD0 */ /*0x52*/
	Keys::Decimal,  /* DIK_DECIMAL */ /*0x53*/
	Keys::None, /*0x54*/
	Keys::None, /*0x55*/
	Keys::Oem102, /* DIK_OEM_102 */ /*0x56*/
	Keys::F11, /* DIK_F11 */ /*0x57*/
	Keys::F12, /* DIK_F12 */ /*0x58*/
	Keys::None, /*0x59*/
	Keys::None, /*0x5A*/
	Keys::None, /*0x5B*/
	Keys::None, /*0x5C*/
	Keys::None, /*0x5D*/
	Keys::None, /*0x5E*/
	Keys::None, /*0x5F*/
	Keys::None, /*0x60*/
	Keys::None, /*0x61*/
	Keys::None, /*0x62*/
	Keys::None, /*0x63*/
	Keys::F13, /* DIK_F13 */ /*0x64*/
	Keys::F14, /* DIK_F14 */ /*0x65*/
	Keys::F15, /* DIK_F15 */ /*0x66*/
	Keys::None, /*0x67*/
	Keys::None, /*0x68*/
	Keys::None, /*0x69*/
	Keys::None, /*0x6A*/
	Keys::None, /*0x6B*/
	Keys::None, /*0x6C*/
	Keys::None, /*0x6D*/
	Keys::None, /*0x6E*/
	Keys::None, /*0x6F*/
	Keys::None, /* DIK_KANA */ /*0x70*/
	Keys::None, /*0x71*/
	Keys::None, /*0x72*/
	Keys::None, /* DIK_ABNT_C1 */ /*0x73*/
	Keys::None, /*0x74*/
	Keys::None, /*0x75*/
	Keys::None, /*0x76*/
	Keys::None, /*0x77*/
	Keys::None, /*0x78*/
	Keys::IMEConvert, /* DIK_CONVERT */ /*0x79*/
	Keys::None, /*0x7A*/
	Keys::IMENonconvert, /* DIK_NOCONVERT */ /*0x7B*/
	Keys::None, /*0x7C*/
	Keys::None, /* DIK_YEN */ /*0x7D*/
	Keys::None, /* DIK_ABNT_C2 */ /*0x7E*/
	Keys::None, /*0x7F*/
	Keys::None, /*0x80*/
	Keys::None, /*0x81*/
	Keys::None, /*0x82*/
	Keys::None, /*0x83*/
	Keys::None, /*0x84*/
	Keys::None, /*0x85*/
	Keys::None, /*0x86*/
	Keys::None, /*0x87*/
	Keys::None, /*0x88*/
	Keys::None, /*0x89*/
	Keys::None, /*0x8A*/
	Keys::None, /*0x8B*/
	Keys::None, /*0x8C*/
	Keys::None, /* DIK_NUMPADEQUALS */ /*0x8D*/
	Keys::None, /*0x8E*/
	Keys::None, /*0x8F*/
	Keys::MediaPreviousTrack, /* DIK_CIRCUMFLEX */ /*0x90*/
	Keys::None, /* DIK_AT */ /*0x91*/
	Keys::None, /* DIK_COLON */ /*0x92*/
	Keys::None, /* DIK_UNDERLINE */ /*0x93*/
	Keys::None, /* DIK_KANJI */ /*0x94*/
	Keys::None, /* DIK_STOP */ /*0x95*/
	Keys::None, /* DIK_AX */ /*0x96*/
	Keys::None, /* DIK_UNLABELED */ /*0x97*/
	Keys::None, /*0x98*/
	Keys::MediaNextTrack, /* DIK_NEXTTRACK */ /*0x99*/
	Keys::None, /*0x9A*/
	Keys::None, /*0x9B*/
	Keys::Return, /* DIK_NUMPADENTER */ /*0x9C*/
	Keys::RControlKey, /* DIK_RCONTROL */ /*0x9D*/
	Keys::None, /*0x9E*/
	Keys::None, /*0x9F*/
	Keys::VolumeMute, /* DIK_MUTE */ /*0xA0*/
	Keys::None, /* DIK_CALCULATOR */ /*0xA1*/
	Keys::MediaPlayPause, /* DIK_PLAYPAUSE */ /*0xA2*/
	Keys::None, /*0xA3*/
	Keys::MediaStop, /* DIK_MEDIASTOP */ /*0xA4*/
	Keys::None, /*0xA5*/
	Keys::None, /*0xA6*/
	Keys::None, /*0xA7*/
	Keys::None, /*0xA8*/
	Keys::None, /*0xA9*/
	Keys::None, /*0xAA*/
	Keys::None, /*0xAB*/
	Keys::None, /*0xAC*/
	Keys::None, /*0xAD*/
	Keys::VolumeDown, /* DIK_VOLUMEDOWN */ /*0xAE*/
	Keys::None, /*0xAF*/
	Keys::VolumeUp, /* DIK_VOLUMEUP */ /*0xB0*/
	Keys::None, /*0xB1*/
	Keys::BrowserHome, /* DIK_WEBHOME */ /*0xB2*/
	Keys::None, /* DIK_NUMPADCOMMA */ /*0xB3*/
	Keys::None, /*0xB4*/
	Keys::Divide, /* DIK_DIVIDE */ /*0xB5*/
	Keys::None, /*0xB6*/
	Keys::None, /* DIK_SYSRQ */ /*0xB7*/
	Keys::RMenu, /* DIK_RMENU */ /*0xB8*/
	Keys::None, /*0xB9*/
	Keys::None, /*0xBA*/
	Keys::None, /*0xBB*/
	Keys::None, /*0xBC*/
	Keys::None, /*0xBD*/
	Keys::None, /*0xBE*/
	Keys::None, /*0xBF*/
	Keys::None, /*0xC0*/
	Keys::None, /*0xC1*/
	Keys::None, /*0xC2*/
	Keys::None, /*0xC3*/
	Keys::None, /*0xC4*/
	Keys::Pause, /* DIK_PAUSE */ /*0xC5*/
	Keys::None, /*0xC6*/
	Keys::Home, /* DIK_HOME */ /*0xC7*/
	Keys::Up, /* DIK_UP */ /*0xC8*/
	Keys::Prior, /* DIK_PRIOR */ /*0xC9*/
	Keys::None, /*0xCA*/
	Keys::Left, /* DIK_LEFT */ /*0xCB*/
	Keys::None, /*0xCC*/
	Keys::Right, /* DIK_RIGHT */ /*0xCD*/
	Keys::None, /*0xCE*/
	Keys::End, /* DIK_END */ /*0xCF*/
	Keys::Down, /* DIK_DOWN */ /*0xD0*/
	Keys::Next, /* DIK_NEXT */ /*0xD1*/
	Keys::Insert, /* DIK_INSERT */ /*0xD2*/
	Keys::Delete, /* DIK_DELETE */ /*0xD3*/
	Keys::None, /*0xD4*/
	Keys::None, /*0xD5*/
	Keys::None, /*0xD6*/
	Keys::None, /*0xD7*/
	Keys::None, /*0xD8*/
	Keys::None, /*0xD9*/
	Keys::None, /*0xDA*/
	Keys::LWin, /* DIK_LWIN */ /*0xDB*/
	Keys::RWin, /* DIK_RWIN */ /*0xDC*/
	Keys::None, /* DIK_APPS */ /*0xDD*/
	Keys::None, /* DIK_POWER */ /*0xDE*/
	Keys::Sleep, /* DIK_SLEEP */ /*0xDF*/
	Keys::None, /*0xE0*/
	Keys::None, /*0xE1*/
	Keys::None, /*0xE2*/
	Keys::None, /* DIK_WAKE */ /*0xE3*/
	Keys::None, /*0xE4*/
	Keys::BrowserSearch, /* DIK_WEBSEARCH */ /*0xE5*/
	Keys::BrowserFavorites, /* DIK_WEBFAVORITES */ /*0xE6*/
	Keys::BrowserRefresh, /* DIK_WEBREFRESH */ /*0xE7*/
	Keys::BrowserStop, /* DIK_WEBSTOP */ /*0xE8*/
	Keys::BrowserForward, /* DIK_WEBFORWARD */ /*0xE9*/
	Keys::BrowserBack, /* DIK_WEBBACK */ /*0xEA*/
	Keys::None, /* DIK_MYCOMPUTER */ /*0xEB*/
	Keys::LaunchMail, /* DIK_MAIL */ /*0xEC*/
	Keys::SelectMedia, /* DIK_MEDIASELECT */ /*0xED*/
};
```

`NativeCore/Windows/IsProcessValid.cpp`:

```cpp
#include <windows.h>

#include "NativeCore.hpp"

bool RC_CallConv IsProcessValid(RC_Pointer handle)
{
	if (handle == nullptr)
	{
		return false;
	}

	const auto retn = WaitForSingleObject(handle, 0);
	if (retn == WAIT_FAILED)
	{
		return false;
	}

	return retn == WAIT_TIMEOUT;
}

```

`NativeCore/Windows/NativeCore.hpp`:

```hpp
#pragma once

#include "../ReClassNET_Plugin.hpp"
#include "../Shared/Keys.hpp"

void RC_CallConv EnumerateProcesses(EnumerateProcessCallback callbackProcess);
void RC_CallConv EnumerateRemoteSectionsAndModules(RC_Pointer handle, EnumerateRemoteSectionsCallback callbackSection, EnumerateRemoteModulesCallback callbackModule);

RC_Pointer RC_CallConv OpenRemoteProcess(RC_Pointer id, ProcessAccess desiredAccess);
bool RC_CallConv IsProcessValid(RC_Pointer handle);
void RC_CallConv CloseRemoteProcess(RC_Pointer handle);

bool RC_CallConv ReadRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size);
bool RC_CallConv WriteRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size);

void RC_CallConv ControlRemoteProcess(RC_Pointer handle, ControlRemoteProcessAction action);

bool RC_CallConv AttachDebuggerToProcess(RC_Pointer id);
void RC_CallConv DetachDebuggerFromProcess(RC_Pointer id);
bool RC_CallConv AwaitDebugEvent(DebugEvent* evt, int timeoutInMilliseconds);
void RC_CallConv HandleDebugEvent(DebugEvent* evt);
bool RC_CallConv SetHardwareBreakpoint(RC_Pointer id, RC_Pointer address, HardwareBreakpointRegister reg, HardwareBreakpointTrigger type, HardwareBreakpointSize size, bool set);

RC_Pointer RC_CallConv InitializeInput();
bool RC_CallConv GetPressedKeys(RC_Pointer handle, Keys* state[], int* count);
void RC_CallConv ReleaseInput(RC_Pointer handle);
```

`NativeCore/Windows/NativeCore.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NativeCore</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
    <IncludePath>..\Dependencies\distorm\include;..\Dependencies\beaengine\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
    <IncludePath>..\Dependencies\distorm\include;..\Dependencies\beaengine\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
    <IncludePath>..\Dependencies\distorm\include;..\Dependencies\beaengine\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(SolutionDir)obj\$(Configuration)\$(PlatformTarget)\$(MSBuildProjectName)\</IntDir>
    <IncludePath>..\Dependencies\distorm\include;..\Dependencies\beaengine\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;NATIVECORE_EXPORTS;_CRT_SECURE_NO_WARNINGS;NOMINMAX;RECLASSNET32;_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <AdditionalDependencies>dinput8.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;NATIVECORE_EXPORTS;_CRT_SECURE_NO_WARNINGS;NOMINMAX;RECLASSNET64;_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <AdditionalDependencies>dinput8.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;NATIVECORE_EXPORTS;_CRT_SECURE_NO_WARNINGS;NOMINMAX;RECLASSNET32;_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <AdditionalDependencies>dinput8.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;NATIVECORE_EXPORTS;_CRT_SECURE_NO_WARNINGS;NOMINMAX;RECLASSNET64;_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <AdditionalDependencies>dinput8.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Dependencies\distorm\src\decoder.c" />
    <ClCompile Include="..\Dependencies\distorm\src\distorm.c" />
    <ClCompile Include="..\Dependencies\distorm\src\instructions.c" />
    <ClCompile Include="..\Dependencies\distorm\src\insts.c" />
    <ClCompile Include="..\Dependencies\distorm\src\mnemonics.c" />
    <ClCompile Include="..\Dependencies\distorm\src\operands.c" />
    <ClCompile Include="..\Dependencies\distorm\src\prefix.c" />
    <ClCompile Include="..\Dependencies\distorm\src\textdefs.c" />
    <ClCompile Include="..\Shared\DistormHelper.cpp" />
    <ClCompile Include="CloseRemoteProcess.cpp" />
    <ClCompile Include="ControlRemoteProcess.cpp" />
    <ClCompile Include="Debugger.cpp" />
    <ClCompile Include="DisassembleCode.cpp" />
    <ClCompile Include="EnumerateProcesses.cpp" />
    <ClCompile Include="EnumerateRemoteSectionsAndModules.cpp" />
    <ClCompile Include="IsProcessValid.cpp" />
    <ClCompile Include="Input.cpp" />
    <ClCompile Include="OpenRemoteProcess.cpp" />
    <ClCompile Include="ReadRemoteMemory.cpp" />
    <ClCompile Include="WriteRemoteMemory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Dependencies\distorm\include\distorm.h" />
    <ClInclude Include="..\Dependencies\distorm\include\mnemonics.h" />
    <ClInclude Include="..\Dependencies\distorm\src\config.h" />
    <ClInclude Include="..\Dependencies\distorm\src\decoder.h" />
    <ClInclude Include="..\Dependencies\distorm\src\instructions.h" />
    <ClInclude Include="..\Dependencies\distorm\src\insts.h" />
    <ClInclude Include="..\Dependencies\distorm\src\operands.h" />
    <ClInclude Include="..\Dependencies\distorm\src\prefix.h" />
    <ClInclude Include="..\Dependencies\distorm\src\textdefs.h" />
    <ClInclude Include="..\Dependencies\distorm\src\wstring.h" />
    <ClInclude Include="..\Dependencies\distorm\src\x86defs.h" />
    <ClInclude Include="..\ReClassNET_Plugin.hpp" />
    <ClInclude Include="..\Shared\DistormHelper.hpp" />
    <ClInclude Include="..\Shared\Keys.hpp" />
    <ClInclude Include="NativeCore.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NativeCore/Windows/NativeCore.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="CloseRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="ControlRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="DisassembleCode.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="EnumerateProcesses.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="EnumerateRemoteSectionsAndModules.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="IsProcessValid.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="OpenRemoteProcess.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="ReadRemoteMemory.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="WriteRemoteMemory.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="Debugger.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="Input.cpp">
      <Filter>Functions</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\decoder.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\distorm.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\instructions.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\insts.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\mnemonics.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\operands.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\prefix.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Dependencies\distorm\src\textdefs.c">
      <Filter>Dependencies\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\DistormHelper.cpp">
      <Filter>Shared</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Dependencies">
      <UniqueIdentifier>{9285bf7e-f1bc-42eb-b760-942eeefb0133}</UniqueIdentifier>
    </Filter>
    <Filter Include="Functions">
      <UniqueIdentifier>{b74771cf-fe41-431f-b0fe-91f421240d53}</UniqueIdentifier>
    </Filter>
    <Filter Include="Dependencies\distorm">
      <UniqueIdentifier>{4b8b2ee0-6a06-4e69-bce3-ff446bfa6b82}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shared">
      <UniqueIdentifier>{faf06b55-02ad-4707-a65d-37e1c0d13640}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NativeCore.hpp" />
    <ClInclude Include="..\ReClassNET_Plugin.hpp" />
    <ClInclude Include="..\Shared\DistormHelper.hpp">
      <Filter>Shared</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Keys.hpp">
      <Filter>Shared</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\include\distorm.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\include\mnemonics.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\config.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\decoder.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\instructions.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\insts.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\operands.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\prefix.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\textdefs.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\wstring.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\Dependencies\distorm\src\x86defs.h">
      <Filter>Dependencies\distorm</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NativeCore/Windows/OpenRemoteProcess.cpp`:

```cpp
#include <windows.h>

#include "NativeCore.hpp"

RC_Pointer RC_CallConv OpenRemoteProcess(RC_Pointer id, ProcessAccess desiredAccess)
{
	DWORD access = STANDARD_RIGHTS_REQUIRED | PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | SYNCHRONIZE;
	switch (desiredAccess)
	{
		case ProcessAccess::Read:
			access |= PROCESS_VM_READ;
			break;
		case ProcessAccess::Write:
			access |= PROCESS_VM_OPERATION | PROCESS_VM_WRITE;
			break;
		case ProcessAccess::Full:
			access |= PROCESS_VM_READ | PROCESS_VM_OPERATION | PROCESS_VM_WRITE;
			break;
	}

	const auto handle = OpenProcess(access, FALSE, static_cast<DWORD>(reinterpret_cast<size_t>(id)));

	if (handle == nullptr || handle == INVALID_HANDLE_VALUE)
	{
		return nullptr;
	}

	return handle;
}

```

`NativeCore/Windows/ReadRemoteMemory.cpp`:

```cpp
#include <windows.h>

#include "NativeCore.hpp"

bool RC_CallConv ReadRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	buffer = reinterpret_cast<RC_Pointer>(reinterpret_cast<uintptr_t>(buffer) + offset);

	SIZE_T numberOfBytesRead;
	if (ReadProcessMemory(handle, address, buffer, size, &numberOfBytesRead) && size == numberOfBytesRead)
	{
		return true;
	}

	return false;
}

```

`NativeCore/Windows/WriteRemoteMemory.cpp`:

```cpp
#include <windows.h>

#include "NativeCore.hpp"

bool RC_CallConv WriteRemoteMemory(RC_Pointer handle, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	buffer = reinterpret_cast<RC_Pointer>(reinterpret_cast<uintptr_t>(buffer) + offset);

	DWORD oldProtect;
	if (VirtualProtectEx(handle, address, size, PAGE_EXECUTE_READWRITE, &oldProtect))
	{
		SIZE_T numberOfBytesWritten;
		if (WriteProcessMemory(handle, address, buffer, size, &numberOfBytesWritten))
		{
			VirtualProtectEx(handle, address, size, oldProtect, nullptr);

			if (size == numberOfBytesWritten)
			{
				return true;
			}
		}
	}

	return false;
}

```

`NativeCore/Windows/exports.def`:

```def
LIBRARY
EXPORTS
	IsProcessValid
	OpenRemoteProcess
	CloseRemoteProcess
	ReadRemoteMemory
	WriteRemoteMemory
	EnumerateProcesses
	EnumerateRemoteSectionsAndModules
	DisassembleCode
	ControlRemoteProcess
	AttachDebuggerToProcess
	DetachDebuggerFromProcess
	AwaitDebugEvent
	HandleDebugEvent
	SetHardwareBreakpoint
	InitializeInput
	GetPressedKeys
	ReleaseInput

```

`README.md`:

```md
# ReClass.NET
This is a port of ReClass to the .NET platform with lots of additional features.

![](https://abload.de/img/main4hsbj.jpg)

## Features
- Support for x86 / x64
- File import from ReClass 2007-2016 and ReClass QT
- Memory Nodes
  - Arrays and Pointers to every other node types
  - Hex 8 / 16 / 32 / 64
  - Int 8 / 16 / 32 / 64
  - UInt 8 / 16 / 32 / 64
  - Bool
  - Bits ![](https://abload.de/img/bitsnhlql.jpg)
  - Enumerations
  - Float / Double
  - Vector 2 / 3 / 4
  - Matrix 3x3 / 3x4 / 4x4
  - UTF8 / UTF16 / UTF32 Text and pointer to text
  - Virtual Tables
  - Function
  - Function Pointer
  - Unions
- Automatic Node Dissection
- Highlight changed memory
- Pointer Preview
- Copy / Paste Support across ReClass.NET instances
- Display types from Debug Symbols (*.pdb)
- Display Runtime Type Informations (RTTI)
- Control the remote process: start / stop / kill
- Process Selection Dialog with filtering
- Memory Viewer
- Memory Scanner
  - Import files from Cheat Engine and CrySearch
  - Scan for values correlated to your input
- Class address calculator
- Code Generator (C++ / C#)
- Module / Section Dumper
- Linux Support (tested on Ubuntu 18.04)
- Debugger with "Find out what writes/accesses this address" support
- Plugin Support
  - Plugins can be written in different languages (example: C++, C++/CLI, C#)
  - Plugins can provide custom methods to access an other process (example: use a driver)
  - Plugins can interact with the ReClass.NET windows
  - Plugins can provide node infos which will be displayed (example: class informations for Frostbite games)
  - Plugins can implement custom nodes with load/save and code generation support

## Plugins
- [Sample Plugins](https://github.com/ReClassNET/ReClass.NET-SamplePlugin)
- [Frostbite Plugin](https://github.com/ReClassNET/ReClass.NET-FrostbitePlugin)
- [MemoryPipe Plugin](https://github.com/ReClassNET/ReClass.NET-MemoryPipePlugin)
- [LoadBinary Plugin](https://github.com/ReClassNET/ReClass.NET-LoadBinaryPlugin)
- [Handle Abuser Plugin](https://github.com/ReClassNET/ReClass.NET-HandleAbuser)
- Unreal Plugin (not available anymore) (by [DrP3pp3r](https://github.com/DrP3pp3r))
- [DriverReader](https://github.com/niemand-sec/ReClass.NET-DriverReader) (by [Niemand](https://github.com/niemand-sec))

To install a plugin just copy it in the "Plugins" folder.
If you want to develop your own plugin just learn from the code of the [Sample Plugins](https://github.com/ReClassNET/ReClass.NET-SamplePlugin) and [Frostbite Plugin](https://github.com/ReClassNET/ReClass.NET-FrostbitePlugin) repositories. If you have developed a nice plugin, leave me a message and I will add it to the list above.

## Installation
Just download the [latest version](https://github.com/ReClassNET/ReClass.NET/releases) and start the x86 / x64 version or let the launcher decide.

## Tips
- Lots of elements have a context menu. Just right-click it and see what you can do there.
- The node window can be controlled with the keyboard too. Arrow keys can select other keys, combined with the shift key the nodes get selected. The menu key opens the context menu which itself can be controlled with the keyboard.
- The memory address field of a class can contain a real formula not just a fixed address.  
  
  **\<Program.exe> + 0x123** will use the base address of Program.exe and add 0x123 to it.  
  **[0x4012ABDE]** will read the integer (4 byte on x86 / 8 byte on x64) from the address 0x4012ABDE and use this value as class address.  
  **[\<Program.exe> + 0xDE] - AB** will use the base address of Program.exe, add 0xDE to it, read the value from this address and finally sub 0xAB from it.  
  **[\<Program.exe> + offset + [\<Program.exe> + offset2]]** Nested operations are supported too.  
  
  Valid operations are read ([..]), add (+), sub (-), mul (*) and div (/). Please note that all operations are integer calculations.

## Compiling
If you want to compile ReClass.NET just fork the repository and open the ReClass.NET.sln file with Visual Studio 2019.
Compile the project and copy the dependencies to the output folder.

## Videos

[Youtube Playlist](https://www.youtube.com/playlist?list=PLO246BmtoITanq3ygMCL8_w0eov4D8hjk)

## Screenshots
Process Selection  
![](https://abload.de/img/processgya2k.jpg)

Memory Viewer  
![](https://abload.de/img/memoryviewerb4y1s.jpg)

Memory Scanner  
![](https://abload.de/img/scannerytub1.jpg)

Pointer Preview  
![](https://abload.de/img/memorypreview2gsfp.jpg)

Code Generator  
![](https://abload.de/img/codegeneratorqdat2.jpg)
![](https://abload.de/img/codegenerator24qzce.jpg)

Plugins  
![](https://abload.de/img/plugin1mda4r.jpg)
![](https://abload.de/img/plugin25dxk1.jpg)

Settings  
![](https://abload.de/img/settings8sz4b.jpg)

## Authors / Special Thanks
- [KN4CK3R](https://github.com/KN4CK3R)
- DrUnKeN ChEeTaH
- P47R!CK
- DogMatt
- [ajkhoury](https://github.com/ajkhoury)
- [IChooseYou](https://github.com/IChooseYou)
- [stevemk14ebr](https://github.com/stevemk14ebr)
- [Timboy67678](https://github.com/Timboy67678)
- [DarthTon](https://github.com/DarthTon)
- [ReUnioN](https://github.com/ReUnioN)
- leveln
- [buddyfavors](https://github.com/buddyfavors)
- [DrP3pp3r](https://github.com/DrP3pp3r)
- [ko1N](https://github.com/ko1N)
- [Niemand](https://github.com/niemand-sec) (see his talk at [BlackHat Europe 2019 (London) "Unveiling the underground world of Anti-Cheats"](https://www.blackhat.com/eu-19/briefings/schedule/index.html#unveiling-the-underground-world-of-anti-cheats-17358))
```

`ReClass.NET.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28803.156
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ReClass.NET", "ReClass.NET\ReClass.NET.csproj", "{BFB8917D-E9B4-463F-A6E8-612C35728C78}"
	ProjectSection(ProjectDependencies) = postProject
		{16591D29-2370-428A-BA11-87E38D0F3551} = {16591D29-2370-428A-BA11-87E38D0F3551}
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F} = {22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NativeCore", "NativeCore\Windows\NativeCore.vcxproj", "{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NativeCore.Unix", "NativeCore\Unix\NativeCore.Unix.vcxproj", "{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ReClass.NET_Launcher", "ReClass.NET_Launcher\ReClass.NET_Launcher.csproj", "{16591D29-2370-428A-BA11-87E38D0F3551}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{19CF2B0F-2722-4108-8308-B628D91F7A1E}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		README.md = README.md
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ReClass.NET_Tests", "ReClass.NET_Tests\ReClass.NET_Tests.csproj", "{E2D0424D-738F-41C3-9935-1B282624600F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|Any CPU.ActiveCfg = Debug|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x64.ActiveCfg = Debug|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x64.Build.0 = Debug|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x86.ActiveCfg = Debug|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x86.Build.0 = Debug|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|Any CPU.ActiveCfg = Release|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x64.ActiveCfg = Release|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x64.Build.0 = Release|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x86.ActiveCfg = Release|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x86.Build.0 = Release|x86
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x64.ActiveCfg = Debug|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x64.Build.0 = Debug|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x86.ActiveCfg = Debug|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x86.Build.0 = Debug|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|Any CPU.ActiveCfg = Release|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x64.ActiveCfg = Release|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x64.Build.0 = Release|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x86.ActiveCfg = Release|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x86.Build.0 = Release|Win32
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Debug|Any CPU.ActiveCfg = Debug|x86
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Debug|x64.ActiveCfg = Debug|x64
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Debug|x64.Build.0 = Debug|x64
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Debug|x86.ActiveCfg = Debug|x86
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Debug|x86.Build.0 = Debug|x86
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Release|Any CPU.ActiveCfg = Release|x86
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Release|x64.ActiveCfg = Release|x64
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Release|x64.Build.0 = Release|x64
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Release|x86.ActiveCfg = Release|x86
		{48C5258A-FA49-4173-AEE5-0FCA5190DFF2}.Release|x86.Build.0 = Release|x86
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|x64.ActiveCfg = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|x64.Build.0 = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|x86.ActiveCfg = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Debug|x86.Build.0 = Debug|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|Any CPU.Build.0 = Release|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|x64.ActiveCfg = Release|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|x64.Build.0 = Release|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|x86.ActiveCfg = Release|Any CPU
		{16591D29-2370-428A-BA11-87E38D0F3551}.Release|x86.Build.0 = Release|Any CPU
		{E2D0424D-738F-41C3-9935-1B282624600F}.Debug|Any CPU.ActiveCfg = Debug|x86
		{E2D0424D-738F-41C3-9935-1B282624600F}.Debug|x64.ActiveCfg = Debug|x64
		{E2D0424D-738F-41C3-9935-1B282624600F}.Debug|x64.Build.0 = Debug|x64
		{E2D0424D-738F-41C3-9935-1B282624600F}.Debug|x86.ActiveCfg = Debug|x86
		{E2D0424D-738F-41C3-9935-1B282624600F}.Debug|x86.Build.0 = Debug|x86
		{E2D0424D-738F-41C3-9935-1B282624600F}.Release|Any CPU.ActiveCfg = Release|x86
		{E2D0424D-738F-41C3-9935-1B282624600F}.Release|x64.ActiveCfg = Release|x64
		{E2D0424D-738F-41C3-9935-1B282624600F}.Release|x64.Build.0 = Release|x64
		{E2D0424D-738F-41C3-9935-1B282624600F}.Release|x86.ActiveCfg = Release|x86
		{E2D0424D-738F-41C3-9935-1B282624600F}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BDFC9557-8E89-44A1-97D7-A830F2A52938}
	EndGlobalSection
EndGlobal

```

`ReClass.NET/AddressParser/AstBuilder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;

namespace ReClassNET.AddressParser
{
	public class AstBuilder
	{
		private readonly Dictionary<char, int> operationPrecedence;

		private readonly Stack<IOperation> resultStack = new Stack<IOperation>();
		private readonly Stack<Token> operatorStack = new Stack<Token>();

		public AstBuilder()
		{
			Contract.Ensures(operationPrecedence != null);

			operationPrecedence = new Dictionary<char, int>
			{
				['\r'] = 0,
				['['] = 1,
				['+'] = 2,
				['-'] = 2,
				['*'] = 3,
				['/'] = 3,
			};
		}

		public IOperation Build(IEnumerable<Token> tokens)
		{
			Contract.Requires(tokens != null);
			Contract.Ensures(Contract.ForAll(tokens, t => t != null));

			resultStack.Clear();
			operatorStack.Clear();

			foreach (var token in tokens)
			{
				switch (token.TokenType)
				{
					case TokenType.Offset:
						resultStack.Push(new OffsetOperation((IntPtr)token.Value));
						break;
					case TokenType.ModuleOffset:
						resultStack.Push(new ModuleOffsetOperation(((string)token.Value).ToLowerInvariant()));
						break;
					case TokenType.LeftBracket:
						operatorStack.Push(token);
						break;
					case TokenType.RightBracket:
						PopOperations(true);
						break;
					case TokenType.Operation:
						var operation1 = (char)token.Value;

						while (operatorStack.Count > 0 && (operatorStack.Peek().TokenType == TokenType.Operation || operatorStack.Peek().TokenType == TokenType.ModuleOffset))
						{
							var other = operatorStack.Peek();

							var operation2 = (char)other.Value;

							if ((IsLeftAssociativeOperation(operation1) && operationPrecedence[operation1] <= operationPrecedence[operation2])
								|| operationPrecedence[operation1] < operationPrecedence[operation2])
							{
								operatorStack.Pop();

								resultStack.Push(ConvertOperation(other));
							}
							else
							{
								break;
							}
						}

						operatorStack.Push(token);
						break;
				}
			}

			PopOperations(false);

			VerifyResultStack();

			return resultStack.FirstOrDefault();
		}

		private void PopOperations(bool untillLeftBracket)
		{
			while (operatorStack.Count > 0 && operatorStack.Peek().TokenType != TokenType.LeftBracket)
			{
				var token = operatorStack.Pop();

				var lastOperation = ConvertOperation(token);

				resultStack.Push(lastOperation);
			}

			if (untillLeftBracket)
			{
				if (operatorStack.Count > 0 && operatorStack.Peek().TokenType == TokenType.LeftBracket)
				{
					operatorStack.Pop();
					resultStack.Push(ConvertOperation(new Token(TokenType.ReadPointer, '\r')));
				}
				else
				{
					throw new ParseException("No matching left bracket found for the right bracket.");
				}
			}
			else
			{
				if (operatorStack.Count > 0 && operatorStack.Peek().TokenType == TokenType.LeftBracket)
				{
					throw new ParseException("No matching right bracket found for the left bracket.");
				}
			}
		}

		private IOperation ConvertOperation(Token operationToken)
		{
			Contract.Requires(operationToken != null);

			try
			{
				IOperation argument1;
				IOperation argument2;

				switch ((char)operationToken.Value)
				{
					case '+':
						argument2 = resultStack.Pop();
						argument1 = resultStack.Pop();
						return new AdditionOperation(argument1, argument2);
					case '-':
						argument2 = resultStack.Pop();
						argument1 = resultStack.Pop();
						return new SubtractionOperation(argument1, argument2);
					case '*':
						argument2 = resultStack.Pop();
						argument1 = resultStack.Pop();
						return new MultiplicationOperation(argument1, argument2);
					case '/':
						argument2 = resultStack.Pop();
						argument1 = resultStack.Pop();
						return new DivisionOperation(argument1, argument2);
					case '\r':
						argument1 = resultStack.Pop();
						return new ReadPointerOperation(argument1);
					default:
						throw new ArgumentException($"Unknown operation '{operationToken.Value}'.");
				}
			}
			catch (InvalidOperationException)
			{
				throw new ParseException($"There is a syntax issue for the operation '{operationToken.Value}'.");
			}
		}

		private void VerifyResultStack()
		{
			if (resultStack.Count > 1)
			{
				if (resultStack.Skip(1).FirstOrDefault(o => o is OffsetOperation) is OffsetOperation offset)
				{
					throw new ParseException($"Unexpected offset '{offset.Value}' found.");
				}

				throw new ParseException("The syntax of the provided formula is not valid.");
			}
		}

		private bool IsLeftAssociativeOperation(char character)
		{
			return character == '+' || character == '-' || character == '*' || character == '/';
		}
	}
}

```

`ReClass.NET/AddressParser/DynamicCompiler.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Reflection;
using ReClassNET.Extensions;
using ReClassNET.Memory;

namespace ReClassNET.AddressParser
{
	public class DynamicCompiler : IExecutor
	{
		public IntPtr Execute(IExpression expression, IProcessReader processReader)
		{
			Contract.Requires(expression != null);
			Contract.Requires(processReader != null);

			return CompileExpression(expression)(processReader);
		}

		public static Func<IProcessReader, IntPtr> CompileExpression(IExpression expression)
		{
			Contract.Requires(expression != null);

			var processParameter = Expression.Parameter(typeof(IProcessReader));

			return Expression.Lambda<Func<IProcessReader, IntPtr>>(
				GenerateMethodBody(expression, processParameter),
				processParameter
			).Compile();
		}

		private static Expression GenerateMethodBody(IExpression expression, Expression processParameter)
		{
			Contract.Requires(expression != null);
			Contract.Requires(processParameter != null);

			static MethodInfo GetIntPtrExtension(string name) => typeof(IntPtrExtension).GetRuntimeMethod(name, new[] { typeof(IntPtr), typeof(IntPtr) });

			switch (expression)
			{
				case ConstantExpression constantExpression:
					{
						var convertFn = typeof(IntPtrExtension).GetRuntimeMethod(nameof(IntPtrExtension.From), new[] { typeof(long) });

						return Expression.Call(null, convertFn, Expression.Constant(constantExpression.Value));
					}
				case NegateExpression negateExpression:
					{
						var argument = GenerateMethodBody(negateExpression.Expression, processParameter);

						var negateFn = typeof(IntPtrExtension).GetRuntimeMethod(nameof(IntPtrExtension.Negate), new[] { typeof(IntPtr) });

						return Expression.Call(null, negateFn, argument);
					}
				case AddExpression addExpression:
					{
						var argument1 = GenerateMethodBody(addExpression.Lhs, processParameter);
						var argument2 = GenerateMethodBody(addExpression.Rhs, processParameter);

						return Expression.Call(null, GetIntPtrExtension(nameof(IntPtrExtension.Add)), argument1, argument2);
					}
				case SubtractExpression subtractExpression:
					{
						var argument1 = GenerateMethodBody(subtractExpression.Lhs, processParameter);
						var argument2 = GenerateMethodBody(subtractExpression.Rhs, processParameter);

						return Expression.Call(null, GetIntPtrExtension(nameof(IntPtrExtension.Sub)), argument1, argument2);
					}
				case MultiplyExpression multiplyExpression:
					{
						var argument1 = GenerateMethodBody(multiplyExpression.Lhs, processParameter);
						var argument2 = GenerateMethodBody(multiplyExpression.Rhs, processParameter);

						return Expression.Call(null, GetIntPtrExtension(nameof(IntPtrExtension.Mul)), argument1, argument2);
					}
				case DivideExpression divideExpression:
					{
						var argument1 = GenerateMethodBody(divideExpression.Lhs, processParameter);
						var argument2 = GenerateMethodBody(divideExpression.Rhs, processParameter);

						return Expression.Call(null, GetIntPtrExtension(nameof(IntPtrExtension.Div)), argument1, argument2);
					}
				case ModuleExpression moduleExpression:
					{
						var getModuleByNameFunc = typeof(IProcessReader).GetRuntimeMethod(nameof(IProcessReader.GetModuleByName), new[] { typeof(string) });
						var moduleNameConstant = Expression.Constant(moduleExpression.Name);

						var moduleVariable = Expression.Variable(typeof(Memory.Module));
						var assignExpression = Expression.Assign(moduleVariable, Expression.Call(processParameter, getModuleByNameFunc, moduleNameConstant));

						return Expression.Block(
							new[] { moduleVariable },
							assignExpression,
							Expression.Condition(
								Expression.Equal(moduleVariable, Expression.Constant(null)),
								Expression.Constant(IntPtr.Zero),
								Expression.MakeMemberAccess(moduleVariable, typeof(Memory.Module).GetProperty(nameof(Memory.Module.Start))!)
							)
						);
					}
				case ReadMemoryExpression readMemoryExpression:
					{
						var addressParameter = GenerateMethodBody(readMemoryExpression.Expression, processParameter);

						var functionName = readMemoryExpression.ByteCount == 4 ? nameof(IRemoteMemoryReaderExtension.ReadRemoteInt32) : nameof(IRemoteMemoryReaderExtension.ReadRemoteInt64);
						var readRemoteIntPtrFn = typeof(IRemoteMemoryReaderExtension).GetRuntimeMethod(functionName, new[] { typeof(IRemoteMemoryReader), typeof(IntPtr) });

						var callExpression = Expression.Call(null, readRemoteIntPtrFn, processParameter, addressParameter);

						var paramType = readMemoryExpression.ByteCount == 4 ? typeof(int) : typeof(long);
						var convertFn = typeof(IntPtrExtension).GetRuntimeMethod(nameof(IntPtrExtension.From), new[] { paramType });

						return Expression.Call(null, convertFn, callExpression);
					}
			}

			throw new ArgumentException($"Unsupported operation '{expression.GetType().FullName}'.");
		}
	}
}

```

`ReClass.NET/AddressParser/Expressions.cs`:

```cs
namespace ReClassNET.AddressParser
{
	public interface IExpression
	{
	}

	public abstract class BinaryExpression : IExpression
	{
		public IExpression Lhs { get; }
		public IExpression Rhs { get; }

		protected BinaryExpression(IExpression lhs, IExpression rhs)
		{
			Lhs = lhs;
			Rhs = rhs;
		}
	}

	public class AddExpression : BinaryExpression
	{
		public AddExpression(IExpression lhs, IExpression rhs)
			: base(lhs, rhs)
		{
		}
	}

	public class SubtractExpression : BinaryExpression
	{
		public SubtractExpression(IExpression lhs, IExpression rhs)
			: base(lhs, rhs)
		{
		}
	}

	public class MultiplyExpression : BinaryExpression
	{
		public MultiplyExpression(IExpression lhs, IExpression rhs)
			: base(lhs, rhs)
		{
		}
	}

	public class DivideExpression : BinaryExpression
	{
		public DivideExpression(IExpression lhs, IExpression rhs)
			: base(lhs, rhs)
		{
		}
	}

	public class ConstantExpression : IExpression
	{
		public long Value { get; }

		public ConstantExpression(long value)
		{
			Value = value;
		}
	}

	public abstract class UnaryExpression : IExpression
	{
		public IExpression Expression { get; }

		protected UnaryExpression(IExpression expression)
		{
			Expression = expression;
		}
	}

	public class NegateExpression : UnaryExpression
	{
		public NegateExpression(IExpression expression)
			: base(expression)
		{
		}
	}

	public class ReadMemoryExpression : UnaryExpression
	{
		public int ByteCount { get; }

		public ReadMemoryExpression(IExpression expression, int byteCount)
			: base(expression)
		{
			ByteCount = byteCount;
		}
	}

	public class ModuleExpression : IExpression
	{
		public string Name { get; }

		public ModuleExpression(string name)
		{
			Name = name;
		}
	}
}

```

`ReClass.NET/AddressParser/IExecutor.cs`:

```cs
using System;
using ReClassNET.Memory;

namespace ReClassNET.AddressParser
{
	public interface IExecutor
	{
		IntPtr Execute(IExpression expression, IProcessReader processReader);
	}
}

```

`ReClass.NET/AddressParser/ITokenizer.cs`:

```cs
namespace ReClassNET.AddressParser
{
	public interface ITokenizer
	{
		/// <summary>
		/// The current token. It is set to <see cref="Token.None"/> if no more tokens are avaiable.
		/// </summary>
		Token Token { get; }

		/// <summary>
		/// The current identifier.
		/// </summary>
		string Identifier { get; }

		/// <summary>
		/// The current number.
		/// </summary>
		long Number { get; }

		/// <summary>
		/// Reads the next token.
		/// </summary>
		void ReadNextToken();
	}
}

```

`ReClass.NET/AddressParser/Interpreter.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using ReClassNET.Extensions;
using ReClassNET.Memory;

namespace ReClassNET.AddressParser
{
	public class Interpreter : IExecutor
	{
		public IntPtr Execute(IExpression expression, IProcessReader processReader)
		{
			Contract.Requires(expression != null);
			Contract.Requires(processReader != null);

			switch (expression)
			{
				case ConstantExpression constantExpression:
					return IntPtrExtension.From(constantExpression.Value);
				case NegateExpression negateExpression:
					return Execute(negateExpression.Expression, processReader).Negate();
				case ModuleExpression moduleExpression:
				{
					var module = processReader.GetModuleByName(moduleExpression.Name);
					if (module != null)
					{
						return module.Start;
					}

					return IntPtr.Zero;
				}
				case AddExpression addExpression:
					return Execute(addExpression.Lhs, processReader).Add(Execute(addExpression.Rhs, processReader));
				case SubtractExpression subtractExpression:
					return Execute(subtractExpression.Lhs, processReader).Sub(Execute(subtractExpression.Rhs, processReader));
				case MultiplyExpression multiplyExpression:
					return Execute(multiplyExpression.Lhs, processReader).Mul(Execute(multiplyExpression.Rhs, processReader));
				case DivideExpression divideExpression:
					return Execute(divideExpression.Lhs, processReader).Div(Execute(divideExpression.Rhs, processReader));
				case ReadMemoryExpression readMemoryExpression:
					var readFromAddress = Execute(readMemoryExpression.Expression, processReader);
					if (readMemoryExpression.ByteCount == 4)
					{
						return IntPtrExtension.From(processReader.ReadRemoteInt32(readFromAddress));
					}
					else
					{
						return IntPtrExtension.From(processReader.ReadRemoteInt64(readFromAddress));
					}
				default:
					throw new ArgumentException($"Unsupported operation '{expression.GetType().FullName}'.");
			}
		}
	}
}

```

`ReClass.NET/AddressParser/Operations.cs`:

```cs
using System;
using System.Diagnostics.Contracts;

namespace ReClassNET.AddressParser
{
	public interface IOperation
	{

	}

	public class OffsetOperation : IOperation
	{
		public OffsetOperation(IntPtr value)
		{
			Value = value;
		}

		public IntPtr Value { get; }

		public override bool Equals(object obj)
		{
			if (obj is OffsetOperation other)
			{
				return Value.Equals(other.Value);
			}
			else
			{
				return false;
			}
		}

		public override int GetHashCode()
		{
			return Value.GetHashCode();
		}
	}

	public class ReadPointerOperation : IOperation
	{
		public ReadPointerOperation(IOperation argument)
		{
			Contract.Requires(argument != null);

			Argument = argument;
		}

		public IOperation Argument { get; }
	}

	public class AdditionOperation : IOperation
	{
		public AdditionOperation(IOperation argument1, IOperation argument2)
		{
			Contract.Requires(argument1 != null);
			Contract.Requires(argument2 != null);

			Argument1 = argument1;
			Argument2 = argument2;
		}

		public IOperation Argument1 { get; }
		public IOperation Argument2 { get; }
	}

	public class SubtractionOperation : IOperation
	{
		public SubtractionOperation(IOperation argument1, IOperation argument2)
		{
			Contract.Requires(argument1 != null);
			Contract.Requires(argument2 != null);

			Argument1 = argument1;
			Argument2 = argument2;
		}

		public IOperation Argument1 { get; }
		public IOperation Argument2 { get; }
	}

	public class DivisionOperation : IOperation
	{
		public DivisionOperation(IOperation dividend, IOperation divisor)
		{
			Contract.Requires(dividend != null);
			Contract.Requires(divisor != null);

			Dividend = dividend;
			Divisor = divisor;
		}

		public IOperation Dividend { get; }
		public IOperation Divisor { get; }
	}

	public class MultiplicationOperation : IOperation
	{
		public MultiplicationOperation(IOperation argument1, IOperation argument2)
		{
			Contract.Requires(argument1 != null);
			Contract.Requires(argument2 != null);

			Argument1 = argument1;
			Argument2 = argument2;
		}

		public IOperation Argument1 { get; }
		public IOperation Argument2 { get; }
	}

	public class ModuleOffsetOperation : IOperation
	{
		public ModuleOffsetOperation(string name)
		{
			Contract.Requires(name != null);

			Name = name;
		}

		public string Name { get; }

		public override bool Equals(object obj)
		{
			if (obj is ModuleOffsetOperation other)
			{
				return Name.Equals(other.Name);
			}
			else
			{
				return false;
			}
		}

		public override int GetHashCode()
		{
			return Name.GetHashCode();
		}
	}
}

```

`ReClass.NET/AddressParser/ParseException.cs`:

```cs
using System;

namespace ReClassNET.AddressParser
{
	public class ParseException : Exception
	{
		public ParseException(string message)
			: base(message)
		{

		}
	}
}

```

`ReClass.NET/AddressParser/Parser.cs`:

```cs
using System;
using System.IO;

namespace ReClassNET.AddressParser
{
	public class Parser
	{
		private readonly ITokenizer tokenizer;

		public Parser(ITokenizer tokenizer)
		{
			this.tokenizer = tokenizer;
		}

		public IExpression ParseExpression()
		{
			var expr = ParseAddSubtract();

			if (tokenizer.Token != Token.None)
			{
				throw new ParseException("Unexpected characters at end of expression");
			}

			return expr;
		}

		private IExpression ParseAddSubtract()
		{
			var lhs = ParseMultiplyDivide();

			while (true)
			{
				if (tokenizer.Token == Token.Add || tokenizer.Token == Token.Subtract)
				{
					var token = tokenizer.Token;

					tokenizer.ReadNextToken();

					var rhs = ParseMultiplyDivide();

					if (token == Token.Add)
					{
						lhs = new AddExpression(lhs, rhs);
					}
					else
					{
						lhs = new SubtractExpression(lhs, rhs);
					}
				}
				else
				{
					return lhs;
				}
			}
		}

		private IExpression ParseMultiplyDivide()
		{
			var lhs = ParseUnary();

			while (true)
			{
				if (tokenizer.Token == Token.Multiply || tokenizer.Token == Token.Divide)
				{
					var token = tokenizer.Token;

					tokenizer.ReadNextToken();

					var rhs = ParseUnary();

					if (token == Token.Multiply)
					{
						lhs = new MultiplyExpression(lhs, rhs);
					}
					else
					{
						lhs = new DivideExpression(lhs, rhs);
					}
				}
				else
				{
					return lhs;
				}
			}
		}

		private IExpression ParseUnary()
		{
			while (true)
			{
				if (tokenizer.Token == Token.Add)
				{
					tokenizer.ReadNextToken();

					continue;
				}

				if (tokenizer.Token == Token.Subtract)
				{
					tokenizer.ReadNextToken();

					var rhs = ParseUnary();

					return new NegateExpression(rhs);
				}

				return ParseLeaf();
			}
		}

		private IExpression ParseLeaf()
		{
			switch (tokenizer.Token)
			{
				case Token.Number:
					{
						var node = new ConstantExpression(tokenizer.Number);

						tokenizer.ReadNextToken();

						return node;
					}
				case Token.OpenParenthesis:
					{
						tokenizer.ReadNextToken();

						var node = ParseAddSubtract();

						if (tokenizer.Token != Token.CloseParenthesis)
						{
							throw new ParseException("Missing close parenthesis");
						}

						tokenizer.ReadNextToken();

						return node;
					}
				case Token.OpenBrackets:
					{
						tokenizer.ReadNextToken();

						var node = ParseAddSubtract();

						var byteCount = IntPtr.Size;
						if (tokenizer.Token == Token.Comma)
						{
							tokenizer.ReadNextToken();

							if (tokenizer.Token != Token.Number)
							{
								throw new ParseException("Missing read byte count");
							}

							if (tokenizer.Number != 4 && tokenizer.Number != 8)
							{
								throw new ParseException("The byte count must be 4 or 8.");
							}

							byteCount = (int)tokenizer.Number;

							tokenizer.ReadNextToken();
						}

						if (tokenizer.Token != Token.CloseBrackets)
						{
							throw new ParseException("Missing close bracket");
						}

						tokenizer.ReadNextToken();

						return new ReadMemoryExpression(node, byteCount);
					}
				case Token.Identifier:
					{
						var node = new ModuleExpression(tokenizer.Identifier);

						tokenizer.ReadNextToken();

						return node;
					}
				default:
					throw new ParseException($"Unexpect token: {tokenizer.Token}");
			}
		}

		public static IExpression Parse(string str)
		{
			using var sr = new StringReader(str);

			return Parse(new Tokenizer(sr));
		}

		private static IExpression Parse(ITokenizer tokenizer)
		{
			var parser = new Parser(tokenizer);
			return parser.ParseExpression();
		}
	}
}

```

`ReClass.NET/AddressParser/Token.cs`:

```cs
namespace ReClassNET.AddressParser
{
	public enum Token
	{
		None,
		Add,
		Subtract,
		Multiply,
		Divide,
		OpenParenthesis,
		CloseParenthesis,
		OpenBrackets,
		CloseBrackets,
		Comma,
		Number,
		Identifier
	}
}

```

`ReClass.NET/AddressParser/Tokenizer.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;
using System.Text;

namespace ReClassNET.AddressParser
{
	/// <summary>
	/// Parses the given text and reads individual tokens from it.
	/// </summary>
	public class Tokenizer : ITokenizer
	{
		private readonly TextReader reader;

		private char currentCharacter;

		public Token Token { get; private set; }

		public string Identifier { get; private set; }

		public long Number { get; private set; }

		public Tokenizer(TextReader reader)
		{
			Contract.Requires(reader != null);

			this.reader = reader;

			ReadNextCharacter();
			ReadNextToken();
		}

		public void ReadNextToken()
		{
			SkipWhitespaces();

			if (currentCharacter == '\0')
			{
				Token = Token.None;
				Identifier = null;
				Number = 0;

				return;
			}

			if (TryReadSimpleToken())
			{
				ReadNextCharacter();

				return;
			}

			if (TryReadNumberToken())
			{
				return;
			}

			if (TryReadIdentifierToken())
			{
				return;
			}

			throw new ParseException($"Invalid character '{currentCharacter}'.");
		}

		private void ReadNextCharacter()
		{
			var c = reader.Read();
			currentCharacter = c < 0 ? '\0' : (char)c;
		}

		private void SkipWhitespaces()
		{
			while (char.IsWhiteSpace(currentCharacter))
			{
				ReadNextCharacter();
			}
		}

		private bool TryReadSimpleToken()
		{
			switch (currentCharacter)
			{
				case '+':
					Token = Token.Add;
					return true;
				case '-':
					Token = Token.Subtract;
					return true;
				case '*':
					Token = Token.Multiply;
					return true;
				case '/':
					Token = Token.Divide;
					return true;
				case '(':
					Token = Token.OpenParenthesis;
					return true;
				case ')':
					Token = Token.CloseParenthesis;
					return true;
				case '[':
					Token = Token.OpenBrackets;
					return true;
				case ']':
					Token = Token.CloseBrackets;
					return true;
				case ',':
					Token = Token.Comma;
					return true;
			}

			return false;
		}

		private bool TryReadNumberToken()
		{
			bool IsHexadecimalDigit(char c) => char.IsDigit(c) || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F';
			bool IsHexadecimalIdentifier(char c) => c == 'x' || c == 'X';

			if (IsHexadecimalDigit(currentCharacter))
			{
				var sb = new StringBuilder();
				var hasHexadecimalIdentifier = false;

				while (IsHexadecimalDigit(currentCharacter)
					|| IsHexadecimalIdentifier(currentCharacter) && !hasHexadecimalIdentifier && sb.Length == 1 && sb[0] == '0')
				{
					sb.Append(currentCharacter);

					if (!hasHexadecimalIdentifier)
					{
						hasHexadecimalIdentifier = IsHexadecimalIdentifier(currentCharacter);
					}

					ReadNextCharacter();
				}

				if (hasHexadecimalIdentifier)
				{
					sb.Remove(0, 2);
				}

				if (!long.TryParse(sb.ToString(), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var number))
				{
					throw new ParseException($"Could not parse '{sb}' as number.");
				}
				Number = number;

				Token = Token.Number;

				return true;
			}

			return false;
		}

		private bool TryReadIdentifierToken()
		{
			if (currentCharacter == '<')
			{
				ReadNextCharacter();

				var sb = new StringBuilder();

				while (currentCharacter != '\0' && currentCharacter != '>')
				{
					sb.Append(currentCharacter);

					ReadNextCharacter();
				}

				if (currentCharacter != '>')
				{
					throw new ParseException("Invalid identifier, missing '>'.");
				}

				ReadNextCharacter();

				Identifier = sb.ToString();
				Token = Token.Identifier;

				return true;
			}

			return false;
		}
	}
}
```

`ReClass.NET/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
  </startup>
  <appSettings>
    <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />
  </appSettings>
</configuration>
```

`ReClass.NET/CodeGenerator/CSharpCodeGenerator.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.CodeGenerator
{
	public class CSharpCodeGenerator : ICodeGenerator
	{
		private static readonly Dictionary<Type, string> nodeTypeToTypeDefinationMap = new Dictionary<Type, string>
		{
			[typeof(DoubleNode)] = "double",
			[typeof(FloatNode)] = "float",
			[typeof(BoolNode)] = "bool",
			[typeof(Int8Node)] = "sbyte",
			[typeof(Int16Node)] = "short",
			[typeof(Int32Node)] = "int",
			[typeof(Int64Node)] = "long",
			[typeof(NIntNode)] = "IntPtr",
			[typeof(UInt8Node)] = "byte",
			[typeof(UInt16Node)] = "ushort",
			[typeof(UInt32Node)] = "uint",
			[typeof(UInt64Node)] = "ulong",
			[typeof(NUIntNode)] = "UIntPtr",

			[typeof(FunctionPtrNode)] = "IntPtr",
			[typeof(Utf8TextPtrNode)] = "IntPtr",
			[typeof(Utf16TextPtrNode)] = "IntPtr",
			[typeof(Utf32TextPtrNode)] = "IntPtr",
			[typeof(PointerNode)] = "IntPtr",
			[typeof(VirtualMethodTableNode)] = "IntPtr",

			[typeof(Vector2Node)] = "Vector2",
			[typeof(Vector3Node)] = "Vector3",
			[typeof(Vector4Node)] = "Vector4"
		};

		public Language Language => Language.CSharp;

		public string GenerateCode(IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ILogger logger)
		{
			using var sw = new StringWriter();
			using var iw = new IndentedTextWriter(sw, "\t");

			iw.WriteLine($"// Created with {Constants.ApplicationName} {Constants.ApplicationVersion} by {Constants.Author}");
			iw.WriteLine();
			iw.WriteLine("// Warning: The C# code generator doesn't support all node types!");
			iw.WriteLine();
			iw.WriteLine("using System.Runtime.InteropServices;");

			iw.WriteLine("// optional namespace, only for vectors");
			iw.WriteLine("using System.Numerics;");
			iw.WriteLine();

			using (var en = enums.GetEnumerator())
			{
				if (en.MoveNext())
				{
					WriteEnum(iw, en.Current);

					while (en.MoveNext())
					{
						iw.WriteLine();

						WriteEnum(iw, en.Current);
					}

					iw.WriteLine();
				}
			}

			var classesToWrite = classes
				.Where(c => c.Nodes.None(n => n is FunctionNode)) // Skip class which contains FunctionNodes because these are not data classes.
				.Distinct();

			var unicodeStringClassLengthsToGenerate = new HashSet<int>();

			using (var en = classesToWrite.GetEnumerator())
			{
				if (en.MoveNext())
				{
					void FindUnicodeStringClasses(IEnumerable<BaseNode> nodes)
					{
						unicodeStringClassLengthsToGenerate.UnionWith(nodes.OfType<Utf16TextNode>().Select(n => n.Length));
					}

					FindUnicodeStringClasses(en.Current!.Nodes);

					WriteClass(iw, en.Current, logger);

					while (en.MoveNext())
					{
						iw.WriteLine();

						FindUnicodeStringClasses(en.Current!.Nodes);

						WriteClass(iw, en.Current, logger);
					}
				}
			}

			if (unicodeStringClassLengthsToGenerate.Any())
			{
				foreach (var length in unicodeStringClassLengthsToGenerate)
				{
					iw.WriteLine();

					WriteUnicodeStringClass(iw, length);
				}
			}

			return sw.ToString();
		}

		/// <summary>
		/// Outputs the C# code for the given enum to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="enum">The enum to output.</param>
		private static void WriteEnum(IndentedTextWriter writer, EnumDescription @enum)
		{
			Contract.Requires(writer != null);
			Contract.Requires(@enum != null);

			writer.Write($"enum {@enum.Name} : ");
			switch (@enum.Size)
			{
				case EnumDescription.UnderlyingTypeSize.OneByte:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int8Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.TwoBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int16Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.FourBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int32Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.EightBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int64Node)]);
					break;
			}
			writer.WriteLine("{");
			writer.Indent++;
			for (var j = 0; j < @enum.Values.Count; ++j)
			{
				var kv = @enum.Values[j];

				writer.Write(kv.Key);
				writer.Write(" = ");
				writer.Write(kv.Value);
				if (j < @enum.Values.Count - 1)
				{
					writer.Write(",");
				}
				writer.WriteLine();
			}
			writer.Indent--;
			writer.WriteLine("};");
		}

		/// <summary>
		/// Outputs the C# code for the given class to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="class">The class to output.</param>
		/// <param name="logger">The logger.</param>
		private static void WriteClass(IndentedTextWriter writer, ClassNode @class, ILogger logger)
		{
			Contract.Requires(writer != null);
			Contract.Requires(@class != null);
			Contract.Requires(logger != null);

			writer.WriteLine("[StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]");
			writer.Write("public struct ");
			writer.Write(@class.Name);

			if (!string.IsNullOrEmpty(@class.Comment))
			{
				writer.Write(" // ");
				writer.Write(@class.Comment);
			}

			writer.WriteLine();

			writer.WriteLine("{");
			writer.Indent++;

			var nodes = @class.Nodes
				.WhereNot(n => n is FunctionNode || n is BaseHexNode);
			foreach (var node in nodes)
			{
				var (type, attribute) = GetTypeDefinition(node);
				if (type != null)
				{
					if (attribute != null)
					{
						writer.WriteLine(attribute);
					}

					writer.WriteLine($"[FieldOffset(0x{node.Offset:X})]");
					writer.Write($"public readonly {type} {node.Name};");
					if (!string.IsNullOrEmpty(node.Comment))
					{
						writer.Write(" //");
						writer.Write(node.Comment);
					}
					writer.WriteLine();
				}
				else
				{
					logger.Log(LogLevel.Warning, $"Skipping node with unhandled type: {node.GetType()}");
				}
			}

			writer.Indent--;
			writer.WriteLine("}");
		}

		/// <summary>
		/// Gets the type definition for the given node. If the node is not expressible <c>null</c> as typename is returned.
		/// </summary>
		/// <param name="node">The target node.</param>
		/// <returns>The type definition for the node or null as typename if the node is not expressible.</returns>
		private static (string typeName, string attribute) GetTypeDefinition(BaseNode node)
		{
			Contract.Requires(node != null);

			if (node is BitFieldNode bitFieldNode)
			{
				var underlayingNode = bitFieldNode.GetUnderlayingNode();
				underlayingNode.CopyFromNode(node);
				node = underlayingNode;
			}

			if (nodeTypeToTypeDefinationMap.TryGetValue(node.GetType(), out var type))
			{
				return (type, null);
			}

			return node switch
			{
				EnumNode enumNode => (enumNode.Enum.Name, null),
				Utf8TextNode utf8TextNode => ("string", $"[MarshalAs(UnmanagedType.ByValTStr, SizeConst = {utf8TextNode.Length})]"),
				Utf16TextNode utf16TextNode => (GetUnicodeStringClassName(utf16TextNode.Length), "[MarshalAs(UnmanagedType.Struct)]"),
				_ => (null, null)
			};
		}

		private static string GetUnicodeStringClassName(int length) => $"__UnicodeString{length}";

		/// <summary>
		/// Writes a helper class for unicode strings with the specific length.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="length">The string length for this class.</param>
		private static void WriteUnicodeStringClass(IndentedTextWriter writer, int length)
		{
			var className = GetUnicodeStringClassName(length);

			writer.WriteLine("[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]");
			writer.WriteLine($"public struct {className}");
			writer.WriteLine("{");
			writer.Indent++;
			writer.WriteLine($"[MarshalAs(UnmanagedType.ByValTStr, SizeConst = {length})]");
			writer.WriteLine("public string Value;");
			writer.WriteLine();
			writer.WriteLine($"public static implicit operator string({className} value) => value.Value;");
			writer.Indent--;
			writer.WriteLine("}");
		}
	}
}

```

`ReClass.NET/CodeGenerator/CppCodeGenerator.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.CodeGenerator
{
	public delegate void WriteNodeFunc(IndentedTextWriter writer, BaseNode node, ILogger logger);

	public delegate string GetTypeDefinitionFunc(BaseNode node, ILogger logger);

	public delegate string ResolveWrappedTypeFunc(BaseNode node, bool isAnonymousExpression, ILogger logger);

	/// <summary>
	/// A C++ code generator for custom nodes.
	/// </summary>
	public abstract class CustomCppCodeGenerator
	{
		/// <summary>
		/// Returns <c>true</c> if the code generator can handle the given node.
		/// </summary>
		/// <param name="node">The node to check.</param>
		/// <returns>True if the code generator can handle the given node, false otherwise.</returns>
		public abstract bool CanHandle(BaseNode node);

		/// <summary>
		/// Outputs the C++ code for the node to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="node">The node to output.</param>
		/// <param name="defaultWriteNodeFunc">The default implementation of <see cref="CppCodeGenerator.WriteNode"/>.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>True if the code generator has processed the node, false otherwise. If this method returns false, the default implementation is used.</returns>
		public virtual bool WriteNode(IndentedTextWriter writer, BaseNode node, WriteNodeFunc defaultWriteNodeFunc, ILogger logger)
		{
			return false;
		}

		/// <summary>
		/// Transforms the given node if necessary.
		/// </summary>
		/// <param name="node">The node to transform.</param>
		/// <returns>The transformed node.</returns>
		public virtual BaseNode TransformNode(BaseNode node)
		{
			return node;
		}

		/// <summary>
		/// Gets the type definition for the node. If the node is not a simple node <c>null</c> is returned.
		/// </summary>
		/// <param name="node">The node.</param>
		/// <param name="defaultGetTypeDefinitionFunc">The default implementation of <see cref="CppCodeGenerator.GetTypeDefinition"/>.</param>
		/// <param name="defaultResolveWrappedTypeFunc">The default implementation of <see cref="CppCodeGenerator.ResolveWrappedType"/>.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>The type definition for the node or null if no simple type is available.</returns>
		public virtual string GetTypeDefinition(BaseNode node, GetTypeDefinitionFunc defaultGetTypeDefinitionFunc, ResolveWrappedTypeFunc defaultResolveWrappedTypeFunc, ILogger logger)
		{
			return null;
		}
	}

	public class CppCodeGenerator : ICodeGenerator
	{
		#region Custom Code Generators

		private static readonly ISet<CustomCppCodeGenerator> customGenerators = new HashSet<CustomCppCodeGenerator>();

		public static void Add(CustomCppCodeGenerator generator)
		{
			customGenerators.Add(generator);
		}

		public static void Remove(CustomCppCodeGenerator generator)
		{
			customGenerators.Remove(generator);
		}

		private static CustomCppCodeGenerator GetCustomCodeGeneratorForNode(BaseNode node)
		{
			return customGenerators.FirstOrDefault(g => g.CanHandle(node));
		}

		#endregion

		private readonly Dictionary<Type, string> nodeTypeToTypeDefinationMap;

		#region HelperNodes

		private class Utf8CharacterNode : BaseNode
		{
			public override int MemorySize => throw new NotImplementedException();
			public override void GetUserInterfaceInfo(out string name, out Image icon) => throw new NotImplementedException();
			public override Size Draw(DrawContext context, int x, int y) => throw new NotImplementedException();
			public override int CalculateDrawnHeight(DrawContext context) => throw new NotImplementedException();
		}

		private class Utf16CharacterNode : BaseNode
		{
			public override int MemorySize => throw new NotImplementedException();
			public override void GetUserInterfaceInfo(out string name, out Image icon) => throw new NotImplementedException();
			public override Size Draw(DrawContext context, int x, int y) => throw new NotImplementedException();
			public override int CalculateDrawnHeight(DrawContext context) => throw new NotImplementedException();
		}

		private class Utf32CharacterNode : BaseNode
		{
			public override int MemorySize => throw new NotImplementedException();
			public override void GetUserInterfaceInfo(out string name, out Image icon) => throw new NotImplementedException();
			public override Size Draw(DrawContext context, int x, int y) => throw new NotImplementedException();
			public override int CalculateDrawnHeight(DrawContext context) => throw new NotImplementedException();
		}

		#endregion

		public Language Language => Language.Cpp;

		public CppCodeGenerator(CppTypeMapping typeMapping)
		{
			nodeTypeToTypeDefinationMap = new Dictionary<Type, string>
			{
				[typeof(BoolNode)] = typeMapping.TypeBool,
				[typeof(DoubleNode)] = typeMapping.TypeDouble,
				[typeof(FloatNode)] = typeMapping.TypeFloat,
				[typeof(FunctionPtrNode)] = typeMapping.TypeFunctionPtr,
				[typeof(Int8Node)] = typeMapping.TypeInt8,
				[typeof(Int16Node)] = typeMapping.TypeInt16,
				[typeof(Int32Node)] = typeMapping.TypeInt32,
				[typeof(Int64Node)] = typeMapping.TypeInt64,
				[typeof(NIntNode)] = typeMapping.TypeNInt,
				[typeof(Matrix3x3Node)] = typeMapping.TypeMatrix3x3,
				[typeof(Matrix3x4Node)] = typeMapping.TypeMatrix3x4,
				[typeof(Matrix4x4Node)] = typeMapping.TypeMatrix4x4,
				[typeof(UInt8Node)] = typeMapping.TypeUInt8,
				[typeof(UInt16Node)] = typeMapping.TypeUInt16,
				[typeof(UInt32Node)] = typeMapping.TypeUInt32,
				[typeof(UInt64Node)] = typeMapping.TypeUInt64,
				[typeof(NUIntNode)] = typeMapping.TypeNUInt,
				[typeof(Utf8CharacterNode)] = typeMapping.TypeUtf8Text,
				[typeof(Utf16CharacterNode)] = typeMapping.TypeUtf16Text,
				[typeof(Utf32CharacterNode)] = typeMapping.TypeUtf32Text,
				[typeof(Vector2Node)] = typeMapping.TypeVector2,
				[typeof(Vector3Node)] = typeMapping.TypeVector3,
				[typeof(Vector4Node)] = typeMapping.TypeVector4
			};
		}

		public string GenerateCode(IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ILogger logger)
		{
			using var sw = new StringWriter();
			using var iw = new IndentedTextWriter(sw, "\t");

			iw.WriteLine($"// Created with {Constants.ApplicationName} {Constants.ApplicationVersion} by {Constants.Author}");
			iw.WriteLine();

			using (var en = enums.GetEnumerator())
			{
				if (en.MoveNext())
				{
					WriteEnum(iw, en.Current);

					while (en.MoveNext())
					{
						iw.WriteLine();

						WriteEnum(iw, en.Current);
					}

					iw.WriteLine();
				}
			}

			var alreadySeen = new HashSet<ClassNode>();

			IEnumerable<ClassNode> GetReversedClassHierarchy(ClassNode node)
			{
				Contract.Requires(node != null);
				Contract.Ensures(Contract.Result<IEnumerable<ClassNode>>() != null);

				if (!alreadySeen.Add(node))
				{
					return Enumerable.Empty<ClassNode>();
				}

				var classNodes = node.Nodes
					.OfType<BaseWrapperNode>()
					.Where(w => !w.IsNodePresentInChain<PointerNode>()) // Pointers are forward declared
					.Select(w => w.ResolveMostInnerNode() as ClassNode)
					.Where(n => n != null);

				return classNodes
					.SelectMany(GetReversedClassHierarchy)
					.Append(node);
			}

			var classesToWrite = classes
				.Where(c => c.Nodes.None(n => n is FunctionNode)) // Skip class which contains FunctionNodes because these are not data classes.
				.SelectMany(GetReversedClassHierarchy) // Order the classes by their use hierarchy.
				.Distinct();

			using (var en = classesToWrite.GetEnumerator())
			{
				if (en.MoveNext())
				{
					WriteClass(iw, en.Current, classes, logger);

					while (en.MoveNext())
					{
						iw.WriteLine();

						WriteClass(iw, en.Current, classes, logger);
					}
				}
			}

			return sw.ToString();
		}

		/// <summary>
		/// Outputs the C++ code for the given enum to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="enum">The enum to output.</param>
		private void WriteEnum(IndentedTextWriter writer, EnumDescription @enum)
		{
			Contract.Requires(writer != null);
			Contract.Requires(@enum != null);

			writer.Write($"enum class {@enum.Name} : ");
			switch (@enum.Size)
			{
				case EnumDescription.UnderlyingTypeSize.OneByte:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int8Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.TwoBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int16Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.FourBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int32Node)]);
					break;
				case EnumDescription.UnderlyingTypeSize.EightBytes:
					writer.WriteLine(nodeTypeToTypeDefinationMap[typeof(Int64Node)]);
					break;
			}
			writer.WriteLine("{");
			writer.Indent++;
			for (var j = 0; j < @enum.Values.Count; ++j)
			{
				var kv = @enum.Values[j];

				writer.Write(kv.Key);
				writer.Write(" = ");
				writer.Write(kv.Value);
				if (j < @enum.Values.Count - 1)
				{
					writer.Write(",");
				}
				writer.WriteLine();
			}
			writer.Indent--;
			writer.WriteLine("};");
		}

		/// <summary>
		/// Outputs the C++ code for the given class to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="class">The class to output.</param>
		/// <param name="classes">The list of all available classes.</param>
		/// <param name="logger">The logger.</param>
		private void WriteClass(IndentedTextWriter writer, ClassNode @class, IEnumerable<ClassNode> classes, ILogger logger)
		{
			Contract.Requires(writer != null);
			Contract.Requires(@class != null);
			Contract.Requires(classes != null);

			writer.Write("class ");
			writer.Write(@class.Name);

			var skipFirstMember = false;
			if (@class.Nodes.FirstOrDefault() is ClassInstanceNode inheritedFromNode)
			{
				skipFirstMember = true;

				writer.Write(" : public ");
				writer.Write(inheritedFromNode.InnerNode.Name);
			}

			if (!string.IsNullOrEmpty(@class.Comment))
			{
				writer.Write(" // ");
				writer.Write(@class.Comment);
			}

			writer.WriteLine();
			
			writer.WriteLine("{");
			writer.WriteLine("public:");
			writer.Indent++;

			var nodes = @class.Nodes
				.Skip(skipFirstMember ? 1 : 0)
				.WhereNot(n => n is FunctionNode);
			WriteNodes(writer, nodes, logger);

			var vTableNodes = @class.Nodes.OfType<VirtualMethodTableNode>().ToList();
			if (vTableNodes.Any())
			{
				writer.WriteLine();

				var virtualMethodNodes = vTableNodes
					.SelectMany(vt => vt.Nodes)
					.OfType<VirtualMethodNode>();
				foreach (var node in virtualMethodNodes)
				{
					writer.Write("virtual void ");
					writer.Write(node.MethodName);
					writer.WriteLine("();");
				}
			}

			var functionNodes = classes
				.SelectMany(c2 => c2.Nodes)
				.OfType<FunctionNode>()
				.Where(f => f.BelongsToClass == @class)
				.ToList();
			if (functionNodes.Any())
			{
				writer.WriteLine();

				foreach (var node in functionNodes)
				{
					writer.Write(node.Signature);
					writer.WriteLine("{ }");
				}
			}

			writer.Indent--;
			writer.Write("}; //Size: 0x");
			writer.WriteLine($"{@class.MemorySize:X04}");

			writer.WriteLine($"static_assert(sizeof({@class.Name}) == 0x{@class.MemorySize:X});");
		}

		/// <summary>
		/// Outputs the C++ code for the given nodes to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="nodes">The nodes to output.</param>
		/// <param name="logger">The logger.</param>
		private void WriteNodes(IndentedTextWriter writer, IEnumerable<BaseNode> nodes, ILogger logger)
		{
			Contract.Requires(writer != null);
			Contract.Requires(nodes != null);

			var fill = 0;
			var fillStart = 0;

			static BaseNode CreatePaddingMember(int offset, int count)
			{
				var node = new ArrayNode
				{
					Offset = offset,
					Count = count,
					Name = $"pad_{offset:X04}"
				};

				node.ChangeInnerNode(new Utf8CharacterNode());

				return node;
			}

			foreach (var member in nodes.WhereNot(m => m is VirtualMethodTableNode))
			{
				if (member is BaseHexNode)
				{
					if (fill == 0)
					{
						fillStart = member.Offset;
					}
					fill += member.MemorySize;

					continue;
				}

				if (fill != 0)
				{
					WriteNode(writer, CreatePaddingMember(fillStart, fill), logger);

					fill = 0;
				}

				WriteNode(writer, member, logger);
			}

			if (fill != 0)
			{
				WriteNode(writer, CreatePaddingMember(fillStart, fill), logger);
			}
		}

		/// <summary>
		/// Outputs the C++ code for the given node to the <see cref="TextWriter"/> instance.
		/// </summary>
		/// <param name="writer">The writer to output to.</param>
		/// <param name="node">The node to output.</param>
		/// <param name="logger">The logger.</param>
		private void WriteNode(IndentedTextWriter writer, BaseNode node, ILogger logger)
		{
			Contract.Requires(writer != null);
			Contract.Requires(node != null);

			var custom = GetCustomCodeGeneratorForNode(node);
			if (custom != null)
			{
				if (custom.WriteNode(writer, node, WriteNode, logger))
				{
					return;
				}
			}

			node = TransformNode(node);

			var simpleType = GetTypeDefinition(node, logger);
			if (simpleType != null)
			{
				//$"{type} {node.Name}; //0x{node.Offset.ToInt32():X04} {node.Comment}".Trim();
				writer.Write(simpleType);
				writer.Write(" ");
				writer.Write(node.Name);
				writer.Write("; //0x");
				writer.Write($"{node.Offset:X04}");
				if (!string.IsNullOrEmpty(node.Comment))
				{
					writer.Write(" ");
					writer.Write(node.Comment);
				}
				writer.WriteLine();
			}
			else if (node is BaseWrapperNode)
			{
				writer.Write(ResolveWrappedType(node, false, logger));
				writer.Write("; //0x");
				writer.Write($"{node.Offset:X04}");
				if (!string.IsNullOrEmpty(node.Comment))
				{
					writer.Write(" ");
					writer.Write(node.Comment);
				}
				writer.WriteLine();
			}
			else if (node is UnionNode unionNode)
			{
				writer.Write("union //0x");
				writer.Write($"{node.Offset:X04}");
				if (!string.IsNullOrEmpty(node.Comment))
				{
					writer.Write(" ");
					writer.Write(node.Comment);
				}
				writer.WriteLine();
				writer.WriteLine("{");
				writer.Indent++;

				WriteNodes(writer, unionNode.Nodes, logger);

				writer.Indent--;
				writer.WriteLine("};");
			}
			else
			{
				logger.Log(LogLevel.Error, $"Skipping node with unhandled type: {node.GetType()}");
			}
		}

		/// <summary>
		/// Transforms the given node into some other node if necessary.
		/// </summary>
		/// <param name="node">The node to transform.</param>
		/// <returns>The transformed node.</returns>
		private static BaseNode TransformNode(BaseNode node)
		{
			var custom = GetCustomCodeGeneratorForNode(node);
			if (custom != null)
			{
				return custom.TransformNode(node);
			}

			static BaseNode GetCharacterNodeForEncoding(Encoding encoding)
			{
				if (encoding.IsSameCodePage(Encoding.Unicode))
				{
					return new Utf16CharacterNode();
				}
				if (encoding.IsSameCodePage(Encoding.UTF32))
				{
					return new Utf32CharacterNode();
				}
				return new Utf8CharacterNode();
			}

			switch (node)
			{
				case BaseTextNode textNode:
				{
					var arrayNode = new ArrayNode { Count = textNode.Length };
					arrayNode.CopyFromNode(node);
					arrayNode.ChangeInnerNode(GetCharacterNodeForEncoding(textNode.Encoding));
					return arrayNode;
				}
				case BaseTextPtrNode textPtrNode:
				{
					var pointerNode = new PointerNode();
					pointerNode.CopyFromNode(node);
					pointerNode.ChangeInnerNode(GetCharacterNodeForEncoding(textPtrNode.Encoding));
					return pointerNode;
				}
				case BitFieldNode bitFieldNode:
				{
					var underlayingNode = bitFieldNode.GetUnderlayingNode();
					underlayingNode.CopyFromNode(node);
					return underlayingNode;
				}
				case BaseHexNode hexNode:
				{
					var arrayNode = new ArrayNode { Count = hexNode.MemorySize };
					arrayNode.CopyFromNode(node);
					arrayNode.ChangeInnerNode(new Utf8CharacterNode());
					return arrayNode;
				}
			}

			return node;
		}

		/// <summary>
		/// Gets the type definition for the given node. If the node is not a simple node <c>null</c> is returned.
		/// </summary>
		/// <param name="node">The target node.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>The type definition for the node or null if no simple type is available.</returns>
		private string GetTypeDefinition(BaseNode node, ILogger logger)
		{
			Contract.Requires(node != null);

			var custom = GetCustomCodeGeneratorForNode(node);
			if (custom != null)
			{
				return custom.GetTypeDefinition(node, GetTypeDefinition, ResolveWrappedType, logger);
			}

			if (nodeTypeToTypeDefinationMap.TryGetValue(node.GetType(), out var type))
			{
				return type;
			}

			switch (node)
			{
				case ClassInstanceNode classInstanceNode:
					return $"class {classInstanceNode.InnerNode.Name}";
				case EnumNode enumNode:
					return enumNode.Enum.Name;
			}

			return null;
		}

		/// <summary>
		/// Resolves the type of a <see cref="BaseWrapperNode"/> node (<see cref="PointerNode"/> and <see cref="ArrayNode"/>).
		/// </summary>
		/// <param name="node">The node to resolve.</param>
		/// <param name="isAnonymousExpression">Specify if the expression should be anonymous.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>The resolved type of the node.</returns>
		private string ResolveWrappedType(BaseNode node, bool isAnonymousExpression, ILogger logger)
		{
			Contract.Requires(node != null);

			var sb = new StringBuilder();
			if (!isAnonymousExpression)
			{
				sb.Append(node.Name);
			}

			BaseNode lastWrapperNode = null;
			var currentNode = node;

			while (true)
			{
				currentNode = TransformNode(currentNode);

				if (currentNode is PointerNode pointerNode)
				{
					sb.Prepend('*');

					if (pointerNode.InnerNode == null) // void*
					{
						if (!isAnonymousExpression)
						{
							sb.Prepend(' ');
						}
						sb.Prepend("void");
						break;
					}

					lastWrapperNode = pointerNode;
					currentNode = pointerNode.InnerNode;
				}
				else if (currentNode is ArrayNode arrayNode)
				{
					if (lastWrapperNode is PointerNode)
					{
						sb.Prepend('(');
						sb.Append(')');
					}

					sb.Append($"[{arrayNode.Count}]");

					lastWrapperNode = arrayNode;
					currentNode = arrayNode.InnerNode;
				}
				else
				{
					var simpleType = GetTypeDefinition(currentNode, logger);

					if (!isAnonymousExpression)
					{
						sb.Prepend(' ');
					}

					sb.Prepend(simpleType);
					break;
				}
			}

			return sb.ToString().Trim();
		}
	}
}

```

`ReClass.NET/CodeGenerator/ICodeGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.CodeGenerator
{
	[ContractClass(typeof(CodeGeneratorContract))]
	public interface ICodeGenerator
	{
		/// <summary>The language this generator produces.</summary>
		Language Language { get; }

		/// <summary>Generates code for the classes.</summary>
		/// <param name="classes">The classes to generate code from.</param>
		/// <param name="logger">The logger used to output messages.</param>
		/// <returns>The code for the classes.</returns>
		string GenerateCode(IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ILogger logger);
	}

	[ContractClassFor(typeof(ICodeGenerator))]
	internal abstract class CodeGeneratorContract : ICodeGenerator
	{
		public Language Language => throw new NotImplementedException();

		public string GenerateCode(IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ILogger logger)
		{
			Contract.Requires(classes != null);
			Contract.Requires(Contract.ForAll(classes, c => c != null));
			Contract.Requires(logger != null);

			Contract.Ensures(Contract.Result<string>() != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/CodeGenerator/Language.cs`:

```cs
namespace ReClassNET.CodeGenerator
{
	public enum Language
	{
		Cpp,
		CSharp
	}
}

```

`ReClass.NET/Constants.cs`:

```cs
namespace ReClassNET
{
	public class Constants
	{
		public const string ApplicationName = "ReClass.NET";

		public const string ApplicationExecutableName = ApplicationName + ".exe";

		public const string ApplicationVersion = "1.2";

		public const string LauncherExecutableName = ApplicationName + "_Launcher.exe";

		public const string Author = "KN4CK3R";

		public const string HomepageUrl = "https://github.com/ReClassNET/ReClass.NET";

		public const string HelpUrl = "https://github.com/ReClassNET/ReClass.NET/issues";

		public const string PluginUrl = "https://github.com/ReClassNET/ReClass.NET#plugins";

#if RECLASSNET64
		public const string Platform = "x64";

		public const string AddressHexFormat = "X016";
#else
		public const string Platform = "x86";

		public const string AddressHexFormat = "X08";
#endif

		public const string SettingsFile = "settings.xml";

		public const string PluginsFolder = "Plugins";

		public static class CommandLineOptions
		{
			public const string AttachTo = "attachto";

			public const string FileExtRegister = "registerfileext";
			public const string FileExtUnregister = "unregisterfileext";
		}
	}
}

```

`ReClass.NET/Controls/BannerBox.cs`:

```cs
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	public class BannerBox : Control, ISupportInitialize
	{
		public const int DefaultBannerHeight = 48;

		private bool inInitialize;

		private Image icon;
		private string title;
		private string text;

		private Image image;

		public Image Icon { get => icon; set { icon = value; UpdateBanner(); } }

		public string Title { get => title; set { title = value ?? string.Empty; UpdateBanner(); } }

		public override string Text { get => text; set { text = value ?? string.Empty; UpdateBanner(); } }

		public BannerBox()
		{
			title = string.Empty;
			text = string.Empty;
		}

		protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
		{
			int oldWidth = Width;

			base.SetBoundsCore(x, y, width, DpiUtil.ScaleIntY(DefaultBannerHeight), specified);

			if (oldWidth != width && width > 0)
			{
				UpdateBanner();
			}
		}

		protected override void OnPaint(PaintEventArgs e)
		{
			if (image != null)
			{
				e.Graphics.DrawImage(image, ClientRectangle);
			}
		}

		public void BeginInit()
		{
			inInitialize = true;
		}

		public void EndInit()
		{
			inInitialize = false;

			UpdateBanner();
		}

		private void UpdateBanner()
		{
			if (inInitialize)
			{
				return;
			}

			try
			{
				var oldImage = image;

				image = BannerFactory.CreateBanner(Width, Height, icon, title, text, true);

				oldImage?.Dispose();

				Invalidate();
			}
			catch
			{
				// ignored
			}
		}
	}
}

```

`ReClass.NET/Controls/ColorBox.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class ColorBox
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.valueTextBox = new System.Windows.Forms.TextBox();
			this.colorPanel = new System.Windows.Forms.Panel();
			this.SuspendLayout();
			// 
			// valueTextBox
			// 
			this.valueTextBox.Location = new System.Drawing.Point(37, 0);
			this.valueTextBox.Name = "valueTextBox";
			this.valueTextBox.Size = new System.Drawing.Size(86, 20);
			this.valueTextBox.TabIndex = 0;
			this.valueTextBox.TextChanged += new System.EventHandler(this.OnTextChanged);
			// 
			// colorPanel
			// 
			this.colorPanel.Location = new System.Drawing.Point(0, 0);
			this.colorPanel.Name = "colorPanel";
			this.colorPanel.Size = new System.Drawing.Size(30, 20);
			this.colorPanel.TabIndex = 1;
			this.colorPanel.Click += new System.EventHandler(this.OnPanelClick);
			this.colorPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.OnPanelPaint);
			// 
			// ColorBox
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.colorPanel);
			this.Controls.Add(this.valueTextBox);
			this.Name = "ColorBox";
			this.Size = new System.Drawing.Size(123, 20);
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.TextBox valueTextBox;
		private System.Windows.Forms.Panel colorPanel;
	}
}

```

`ReClass.NET/Controls/ColorBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Windows.Forms;

namespace ReClassNET.Controls
{
	[DefaultEvent(nameof(ColorChanged))]
	[DefaultBindingProperty(nameof(Color))]
	public partial class ColorBox : UserControl
	{
		private const int DefaultWidth = 123;
		private const int DefaultHeight = 20;

		private bool updateTextBox = true;

		public event EventHandler ColorChanged;

		private Color color;
		public Color Color
		{
			get => color;
			set
			{
				// Normalize the color because Color.Red != Color.FromArgb(255, 0, 0)
				value = Color.FromArgb(value.ToArgb());
				if (color != value)
				{
					color = value;

					colorPanel.BackColor = value;
					if (updateTextBox)
					{
						valueTextBox.Text = ColorTranslator.ToHtml(value);
					}

					OnColorChanged(EventArgs.Empty);
				}

				updateTextBox = true;
			}
		}

		protected virtual void OnColorChanged(EventArgs e)
		{
			Contract.Requires(e != null);

			var eh = ColorChanged;
			eh?.Invoke(this, e);
		}

		public ColorBox()
		{
			InitializeComponent();
		}

		protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
		{
			base.SetBoundsCore(x, y, DefaultWidth, DefaultHeight, specified);
		}

		private void OnTextChanged(object sender, EventArgs e)
		{
			try
			{
				var str = valueTextBox.Text;
				if (!str.StartsWith("#"))
				{
					str = "#" + str;
				}

				var newColor = ColorTranslator.FromHtml(str);

				updateTextBox = false;
				Color = newColor;
			}
			catch
			{
				// ignored
			}
		}

		private void OnPanelClick(object sender, EventArgs e)
		{
			using var cd = new ColorDialog
			{
				FullOpen = true,
				Color = Color
			};

			if (cd.ShowDialog() == DialogResult.OK)
			{
				Color = cd.Color;
			}
		}

		private void OnPanelPaint(object sender, PaintEventArgs e)
		{
			var rect = colorPanel.ClientRectangle;
			rect.Width--;
			rect.Height--;
			e.Graphics.DrawRectangle(Pens.Black, rect);
		}
	}
}

```

`ReClass.NET/Controls/ColorBox.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Controls/CustomToolStripItems.cs`:

```cs
using System;
using System.Windows.Forms;
using System.Windows.Forms.Design;

namespace ReClassNET.Controls
{
	[ToolStripItemDesignerAvailability(ToolStripItemDesignerAvailability.All)]
	public class IntegerToolStripMenuItem : ToolStripMenuItem
	{
		public int Value { get; set; }
	}

	[ToolStripItemDesignerAvailability(ToolStripItemDesignerAvailability.All)]
	public class TypeToolStripMenuItem : ToolStripMenuItem
	{
		public Type Value { get; set; }
	}

	[ToolStripItemDesignerAvailability(ToolStripItemDesignerAvailability.All)]
	public class TypeToolStripButton : ToolStripButton
	{
		public Type Value { get; set; }
	}
}

```

`ReClass.NET/Controls/DrawContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	public class DrawContext
	{
		public Settings Settings { get; set; }

		public Graphics Graphics { get; set; }
		public FontEx Font { get; set; }
		public IconProvider IconProvider { get; set; }

		public RemoteProcess Process { get; set; }
		public MemoryBuffer Memory { get; set; }

		public DateTime CurrentTime { get; set; }

		public Rectangle ClientArea { get; set; }
		public List<HotSpot> HotSpots { get; set; }
		public IntPtr Address { get; set; }
		public int Level { get; set; }
		public bool MultipleNodesSelected { get; set; }

		public DrawContext Clone()
		{
			return new DrawContext
			{
				Settings = Settings,
				Graphics = Graphics,
				Font = Font,
				IconProvider = IconProvider,
				Process = Process,
				Memory = Memory,
				CurrentTime = CurrentTime,
				ClientArea = ClientArea,
				HotSpots = HotSpots,
				Address = Address,
				Level = Level,
				MultipleNodesSelected = MultipleNodesSelected
			};
		}
	}
}

```

`ReClass.NET/Controls/DrawContextRequestEventArgs.cs`:

```cs
using System;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	public class DrawContextRequestEventArgs : EventArgs
	{
		public DateTime CurrentTime { get; set; } = DateTime.UtcNow;

		public Settings Settings { get; set; }

		public IconProvider IconProvider { get; set; }

		public RemoteProcess Process { get; set; }

		public MemoryBuffer Memory { get; set; }

		public BaseNode Node { get; set; }

		public IntPtr BaseAddress { get; set; }
	}

	public delegate void DrawContextRequestEventHandler(object sender, DrawContextRequestEventArgs args);
}

```

`ReClass.NET/Controls/DualValueBox.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class DualValueBox
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.value1TextBox = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.value2TextBox = new System.Windows.Forms.TextBox();
			this.tableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.tableLayoutPanel.SuspendLayout();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(0, 0);
			this.label1.Margin = new System.Windows.Forms.Padding(0);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(37, 13);
			this.label1.TabIndex = 0;
			this.label1.Text = "Value:";
			// 
			// value1TextBox
			// 
			this.value1TextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.value1TextBox.Location = new System.Drawing.Point(0, 13);
			this.value1TextBox.Margin = new System.Windows.Forms.Padding(0);
			this.value1TextBox.Name = "value1TextBox";
			this.value1TextBox.Size = new System.Drawing.Size(255, 20);
			this.value1TextBox.TabIndex = 1;
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(255, 0);
			this.label2.Margin = new System.Windows.Forms.Padding(0);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(1, 13);
			this.label2.TabIndex = 2;
			this.label2.Text = "Value 2:";
			// 
			// value2TextBox
			// 
			this.value2TextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.value2TextBox.Location = new System.Drawing.Point(255, 13);
			this.value2TextBox.Margin = new System.Windows.Forms.Padding(1, 0, 0, 0);
			this.value2TextBox.Name = "value2TextBox";
			this.value2TextBox.Size = new System.Drawing.Size(1, 20);
			this.value2TextBox.TabIndex = 3;
			// 
			// tableLayoutPanel
			// 
			this.tableLayoutPanel.ColumnCount = 2;
			this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
			this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 0F));
			this.tableLayoutPanel.Controls.Add(this.label1, 0, 0);
			this.tableLayoutPanel.Controls.Add(this.value2TextBox, 1, 1);
			this.tableLayoutPanel.Controls.Add(this.value1TextBox, 0, 1);
			this.tableLayoutPanel.Controls.Add(this.label2, 1, 0);
			this.tableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			this.tableLayoutPanel.Location = new System.Drawing.Point(0, 0);
			this.tableLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.tableLayoutPanel.Name = "tableLayoutPanel";
			this.tableLayoutPanel.RowCount = 2;
			this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.tableLayoutPanel.Size = new System.Drawing.Size(255, 34);
			this.tableLayoutPanel.TabIndex = 4;
			// 
			// DualValueBox
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.tableLayoutPanel);
			this.Name = "DualValueBox";
			this.Size = new System.Drawing.Size(255, 34);
			this.tableLayoutPanel.ResumeLayout(false);
			this.tableLayoutPanel.PerformLayout();
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox value1TextBox;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox value2TextBox;
		private System.Windows.Forms.TableLayoutPanel tableLayoutPanel;
	}
}

```

`ReClass.NET/Controls/DualValueBox.cs`:

```cs
using System.ComponentModel;
using System.Windows.Forms;
using System.Windows.Forms.Design;

namespace ReClassNET.Controls
{
	[Designer(typeof(DualValueControlDesigner))]
	public partial class DualValueBox : UserControl
	{
		public bool ShowSecondInputField
		{
			get => tableLayoutPanel.ColumnStyles[0].Width <= 99;
			set
			{
				if (value)
				{
					tableLayoutPanel.ColumnStyles[1].SizeType = SizeType.Percent;
					tableLayoutPanel.ColumnStyles[1].Width = 50;
					tableLayoutPanel.ColumnStyles[0].Width = 50;
					value1TextBox.Margin = new Padding(0, 0, 1, 0);
				}
				else
				{
					tableLayoutPanel.ColumnStyles[1].SizeType = SizeType.Absolute;
					tableLayoutPanel.ColumnStyles[1].Width = 0;
					tableLayoutPanel.ColumnStyles[0].Width = 100;
					value1TextBox.Margin = new Padding(0);
					value2TextBox.Text = null;
				}
			}
		}

		public string Value1
		{
			get => value1TextBox.Text;
			set => value1TextBox.Text = value;
		}

		public string Value2
		{
			get => value2TextBox.Text;
			set => value2TextBox.Text = value;
		}

		public DualValueBox()
		{
			InitializeComponent();
		}

		protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
		{
			base.SetBoundsCore(x, y, width, 34, specified);
		}

		public void Clear() => Clear(true, true);

		public void Clear(bool clearValue1, bool clearValue2)
		{
			if (clearValue1)
			{
				value1TextBox.Clear();
			}
			if (clearValue2)
			{
				value2TextBox.Clear();
			}
		}
	}

	internal class DualValueControlDesigner : ControlDesigner
	{
		DualValueControlDesigner()
		{
			AutoResizeHandles = true;
		}

		public override SelectionRules SelectionRules => SelectionRules.LeftSizeable | SelectionRules.RightSizeable | SelectionRules.Moveable;
	}
}

```

`ReClass.NET/Controls/DualValueBox.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Controls/EnumComboBox.cs`:

```cs
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;

namespace ReClassNET.Controls
{
	public class EnumComboBox<TEnum> : ComboBox where TEnum : struct
	{
		#region Properties

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new ObjectCollection Items => new ObjectCollection(this);

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new AutoCompleteMode AutoCompleteMode { get => AutoCompleteMode.None; set { } }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new ComboBoxStyle DropDownStyle { get => ComboBoxStyle.DropDownList; set { } }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new string DisplayMember { get; set; }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new bool FormattingEnabled { get; set; }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new string ValueMember { get; set; }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new object DataSource { get; set; }

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new TEnum SelectedValue
		{
			get => ((EnumDescriptionDisplay<TEnum>)base.SelectedItem)?.Value ?? default;
			set => base.SelectedItem = base.Items.Cast<EnumDescriptionDisplay<TEnum>>().PredicateOrFirst(e => e.Value.Equals(value));
		}

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new TEnum SelectedItem
		{
			get => SelectedValue;
			set => SelectedValue = value;
		}

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new string SelectedText
		{
			get => ((EnumDescriptionDisplay<TEnum>)base.SelectedItem).Description;
			set => base.SelectedItem = base.Items.Cast<EnumDescriptionDisplay<TEnum>>().PredicateOrFirst(e => e.Description.Equals(value));
		}

		#endregion

		public EnumComboBox()
		{
			base.AutoCompleteMode = AutoCompleteMode.None;
			base.DropDownStyle = ComboBoxStyle.DropDownList;
			base.FormattingEnabled = false;
			base.DisplayMember = nameof(EnumDescriptionDisplay<TEnum>.Description);
			base.ValueMember = nameof(EnumDescriptionDisplay<TEnum>.Value);

			SetValues(EnumDescriptionDisplay<TEnum>.Create());
			if (base.Items.Count != 0)
			{
				SelectedIndex = 0;
			}
		}

		public void SetAvailableValues(TEnum item1, params TEnum[] items)
		{
			SetAvailableValues(items.Prepend(item1));
		}

		public void SetAvailableValues(IEnumerable<TEnum> values)
		{
			Contract.Requires(values != null);

			SetValues(EnumDescriptionDisplay<TEnum>.CreateExact(values));
		}

		public void SetAvailableValuesExclude(TEnum item1, params TEnum[] items)
		{
			SetAvailableValuesExclude(items.Prepend(item1));
		}

		public void SetAvailableValuesExclude(IEnumerable<TEnum> values)
		{
			Contract.Requires(values != null);

			SetValues(EnumDescriptionDisplay<TEnum>.CreateExclude(values));
		}

		private void SetValues(List<EnumDescriptionDisplay<TEnum>> values)
		{
			Contract.Requires(values != null);

			base.Items.Clear();
			base.Items.AddRange(values.ToArray());
		}
	}
}

```

`ReClass.NET/Controls/EnumDescriptionDisplay.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;

namespace ReClassNET.Controls
{
	public class EnumDescriptionDisplay<TEnum> where TEnum : struct
	{
		public TEnum Value { get; internal set; }
		public string Description { get; internal set; }

		public static List<EnumDescriptionDisplay<TEnum>> Create()
		{
			Contract.Ensures(Contract.Result<List<EnumDescriptionDisplay<TEnum>>>() != null);

			return CreateExact(Enum.GetValues(typeof(TEnum)).Cast<TEnum>());
		}

		public static List<EnumDescriptionDisplay<TEnum>> CreateExact(IEnumerable<TEnum> include)
		{
			Contract.Requires(include != null);
			Contract.Ensures(Contract.Result<List<EnumDescriptionDisplay<TEnum>>>() != null);

			return include
				.Select(value => new EnumDescriptionDisplay<TEnum>
				{
					Description = GetDescription(value),
					Value = value
				})
				.OrderBy(item => item.Value)
				.ToList();
		}

		public static List<EnumDescriptionDisplay<TEnum>> CreateExclude(IEnumerable<TEnum> exclude)
		{
			Contract.Requires(exclude != null);
			Contract.Ensures(Contract.Result<List<EnumDescriptionDisplay<TEnum>>>() != null);

			return Enum.GetValues(typeof(TEnum))
				.Cast<TEnum>()
				.Except(exclude)
				.Select(value => new EnumDescriptionDisplay<TEnum>
				{
					Description = GetDescription(value),
					Value = value
				})
				.OrderBy(item => item.Value)
				.ToList();
		}

		private static string GetDescription(TEnum value)
		{
			Contract.Ensures(Contract.Result<string>() != null);

			return value.GetType().GetField(value.ToString()).GetCustomAttribute<DescriptionAttribute>()?.Description ?? value.ToString();
		}
	}
}

```

`ReClass.NET/Controls/HotSpotTextBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	public class HotSpotTextBox : TextBox
	{
		private HotSpot currentHotSpot;

		private FontEx font;
		private int minimumWidth;

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public new FontEx Font
		{
			get => font;
			set
			{
				if (font != value)
				{
					font = value;

					base.Font = font.Font;
				}
			}
		}

		public event HotSpotTextBoxCommitEventHandler Committed;

		public HotSpotTextBox()
		{
			BorderStyle = BorderStyle.None;
		}

		#region Events

		protected override void OnVisibleChanged(EventArgs e)
		{
			base.OnVisibleChanged(e);

			if (Visible)
			{
				BackColor = Program.Settings.BackgroundColor;

				if (currentHotSpot != null)
				{
					Focus();
					Select(0, TextLength);
				}
			}
		}

		protected override void OnKeyDown(KeyEventArgs e)
		{
			if (e.KeyCode == Keys.Enter)
			{
				OnCommit();

				e.Handled = true;
				e.SuppressKeyPress = true;
			}

			base.OnKeyDown(e);
		}

		protected override void OnTextChanged(EventArgs e)
		{
			base.OnTextChanged(e);

			var w = (TextLength + 1) * font.Width;
			if (w > minimumWidth)
			{
				Width = w;
			}
		}

		private void OnCommit()
		{
			Visible = false;

			currentHotSpot.Text = Text.Trim();

			Committed?.Invoke(this, new HotSpotTextBoxCommitEventArgs(currentHotSpot));
		}

		#endregion

		public void ShowOnHotSpot(HotSpot hotSpot)
		{
			currentHotSpot = hotSpot;

			if (hotSpot == null)
			{
				Visible = false;

				return;
			}

			AlignToRect(hotSpot.Rect);

			Text = hotSpot.Text.Trim();
			ReadOnly = hotSpot.Id == HotSpot.ReadOnlyId;

			Visible = true;
		}

		private void AlignToRect(Rectangle rect)
		{
			SetBounds(rect.Left + 2, rect.Top, rect.Width, rect.Height);

			minimumWidth = rect.Width;
		}
	}

	public delegate void HotSpotTextBoxCommitEventHandler(object sender, HotSpotTextBoxCommitEventArgs e);

	public class HotSpotTextBoxCommitEventArgs : EventArgs
	{
		public HotSpot HotSpot { get; set; }

		public HotSpotTextBoxCommitEventArgs(HotSpot hotSpot)
		{
			HotSpot = hotSpot;
		}
	}
}

```

`ReClass.NET/Controls/HotkeyBox.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class HotkeyBox
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.timer = new System.Windows.Forms.Timer(this.components);
			this.textBox = new System.Windows.Forms.TextBox();
			this.clearButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// timer
			// 
			this.timer.Enabled = true;
			this.timer.Interval = 50;
			this.timer.Tick += new System.EventHandler(this.timer_Tick);
			// 
			// textBox
			// 
			this.textBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
			this.textBox.Enabled = false;
			this.textBox.Location = new System.Drawing.Point(0, 0);
			this.textBox.Name = "textBox";
			this.textBox.Size = new System.Drawing.Size(140, 20);
			this.textBox.TabIndex = 0;
			this.textBox.Enter += new System.EventHandler(this.textBox_Enter);
			this.textBox.Leave += new System.EventHandler(this.textBox_Leave);
			// 
			// clearButton
			// 
			this.clearButton.Anchor = System.Windows.Forms.AnchorStyles.Right;
			this.clearButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Delete;
			this.clearButton.Location = new System.Drawing.Point(142, 0);
			this.clearButton.Name = "clearButton";
			this.clearButton.Size = new System.Drawing.Size(20, 20);
			this.clearButton.TabIndex = 1;
			this.clearButton.UseVisualStyleBackColor = true;
			this.clearButton.Click += new System.EventHandler(this.clearButton_Click);
			// 
			// HotkeyBox
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.clearButton);
			this.Controls.Add(this.textBox);
			this.Name = "HotkeyBox";
			this.Size = new System.Drawing.Size(162, 20);
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.Timer timer;
		private System.Windows.Forms.TextBox textBox;
		private System.Windows.Forms.Button clearButton;
	}
}

```

`ReClass.NET/Controls/HotkeyBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Linq;
using System.Windows.Forms;
using System.Windows.Forms.Design;
using ReClassNET.Input;

namespace ReClassNET.Controls
{
	[Designer(typeof(HotkeyBoxDesigner))]
	public partial class HotkeyBox : UserControl
	{
		public KeyboardInput Input { get; set; }

		public KeyboardHotkey Hotkey { get; } = new KeyboardHotkey();

		public HotkeyBox()
		{
			InitializeComponent();

			DisplayHotkey();
		}

		protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
		{
			base.SetBoundsCore(x, y, width, 20, specified);
		}

		private void textBox_Enter(object sender, EventArgs e)
		{
			timer.Enabled = true;
		}

		private void textBox_Leave(object sender, EventArgs e)
		{
			timer.Enabled = false;
		}

		private void timer_Tick(object sender, EventArgs e)
		{
			if (Input == null)
			{
				return;
			}

			var keys = Input.GetPressedKeys();
			if (keys.Length != 0)
			{
				foreach (var key in keys.Select(k => k & Keys.KeyCode).Where(k => k != Keys.None))
				{
					Hotkey.AddKey(key);
				}
				DisplayHotkey();
			}
		}

		private void clearButton_Click(object sender, EventArgs e)
		{
			Clear();
		}

		private void DisplayHotkey()
		{
			textBox.Text = Hotkey.ToString();
		}

		public void Clear()
		{
			Hotkey.Clear();

			DisplayHotkey();
		}
	}

	internal class HotkeyBoxDesigner : ControlDesigner
	{
		private HotkeyBoxDesigner()
		{
			AutoResizeHandles = true;
		}

		public override SelectionRules SelectionRules => SelectionRules.LeftSizeable | SelectionRules.RightSizeable | SelectionRules.Moveable;
	}
}

```

`ReClass.NET/Controls/HotkeyBox.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="timer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`ReClass.NET/Controls/IconButton.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using System.Windows.Forms.Design;

namespace ReClassNET.Controls
{
	/// <summary>
	/// Based on <see cref="ToolStripButton" />.
	/// </summary>
	[DefaultEvent("Click")]
	public class IconButton : Panel
	{
		public bool Pressed { get; set; }
		public bool Selected { get; set; }

		public Image Image { get; set; }
		public Rectangle ImageRectangle { get; } = new Rectangle(3, 3, 16, 16);

		private readonly ProfessionalColorTable colorTable = new ProfessionalColorTable();

		public IconButton()
		{
			DoubleBuffered = true;
		}

		protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
		{
			base.SetBoundsCore(x, y, 23, 22, specified);
		}

		protected override void Select(bool directed, bool forward)
		{
			base.Select(directed, forward);

			Selected = true;
		}

		protected override void OnMouseDown(MouseEventArgs e)
		{
			base.OnMouseDown(e);

			Pressed = true;

			Invalidate();
		}

		protected override void OnMouseUp(MouseEventArgs e)
		{
			base.OnMouseUp(e);

			Pressed = false;

			Invalidate();
		}

		protected override void OnMouseEnter(EventArgs e)
		{
			base.OnMouseEnter(e);

			Selected = true;

			Invalidate();
		}

		protected override void OnMouseLeave(EventArgs e)
		{
			base.OnMouseLeave(e);

			Selected = false;
			Pressed = false;

			Invalidate();
		}

		protected override void OnPaint(PaintEventArgs e)
		{
			RenderButtonBackground(e.Graphics);
			RenderImage(e.Graphics);
		}

		private void RenderButtonBackground(Graphics g)
		{
			Contract.Requires(g != null);

			var bounds = new Rectangle(Point.Empty, Size);
			var drawHotBorder = true;

			if (Pressed)
			{
				RenderPressedButtonFill(g, bounds);
			}
			else if (Selected)
			{
				RenderSelectedButtonFill(g, bounds);
			}
			else
			{
				drawHotBorder = false;
				using var brush = new SolidBrush(BackColor);

				g.FillRectangle(brush, bounds);
			}

			if (drawHotBorder)
			{
				using var pen = new Pen(colorTable.ButtonSelectedBorder);

				g.DrawRectangle(pen, bounds.X, bounds.Y, bounds.Width - 1, bounds.Height - 1);
			}
		}

		private void RenderPressedButtonFill(Graphics g, Rectangle bounds)
		{
			Contract.Requires(g != null);

			if (bounds.Width == 0 || bounds.Height == 0)
			{
				return;
			}

			using var brush = new LinearGradientBrush(bounds, colorTable.ButtonPressedGradientBegin, colorTable.ButtonPressedGradientEnd, LinearGradientMode.Vertical);

			g.FillRectangle(brush, bounds);
		}

		private void RenderSelectedButtonFill(Graphics g, Rectangle bounds)
		{
			Contract.Requires(g != null);

			if (bounds.Width == 0 || bounds.Height == 0)
			{
				return;
			}

			using var brush = new LinearGradientBrush(bounds, colorTable.ButtonSelectedGradientBegin, colorTable.ButtonSelectedGradientEnd, LinearGradientMode.Vertical);

			g.FillRectangle(brush, bounds);
		}

		private void RenderImage(Graphics g)
		{
			Contract.Requires(g != null);

			var image = Image;
			if (image == null)
			{
				return;
			}

			var imageRect = ImageRectangle;

			if (!Enabled)
			{
				var disposeImage = false;
				if (Pressed)
				{
					imageRect.X += 1;
				}
				if (!Enabled)
				{
					image = ToolStripRenderer.CreateDisabledImage(image);
					disposeImage = true;
				}

				g.DrawImage(image, imageRect);

				if (disposeImage)
				{
					image.Dispose();
				}
				return;
			}

			g.DrawImage(image, imageRect);
		}
	}

	internal class IconButtonDesigner : ControlDesigner
	{
		private IconButtonDesigner()
		{
			AutoResizeHandles = true;
		}

		public override SelectionRules SelectionRules => SelectionRules.Moveable;
	}
}

```

`ReClass.NET/Controls/MemoryPreviewPopUp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	[ToolboxItem(false)]
	public class MemoryPreviewPopUp : ToolStripDropDown
	{
		private const int ToolTipWidth = 1000 + ToolTipPadding;
		private const int ToolTipPadding = 4;

		/// <summary>Panel for the memory preview.</summary>
		private class MemoryPreviewPanel : Panel
		{
			private const int MinNodeCount = 10;

			public DrawContext DrawContext { get; }

			private readonly List<BaseHexNode> nodes;

			public MemoryPreviewPanel(FontEx font)
			{
				Contract.Requires(font != null);

				DoubleBuffered = true;

				nodes = new List<BaseHexNode>();

				DrawContext = new DrawContext
				{
					Font = font,
					IconProvider = new IconProvider(), // TODO use single instance

					Memory = new MemoryBuffer(),

					HotSpots = new List<HotSpot>()
				};

				SetNodeCount(MinNodeCount);

				CalculateSize();
			}

			/// <summary>Sets the absolute number of nodes and resizes the underlaying memory buffer.</summary>
			/// <param name="count">Number of nodes.</param>
			private void SetNodeCount(int count)
			{
				BaseHexNode CreateNode(int index)
				{
					return new
#if RECLASSNET64
					Hex64Node
#else
					Hex32Node
#endif
					{
						Offset = index * IntPtr.Size
					};
				}

				if (nodes.Count < count)
				{
					nodes.AddRange(Enumerable.Range(nodes.Count, count - nodes.Count).Select(CreateNode));
				}
				else if (nodes.Count > count && count >= MinNodeCount)
				{
					nodes.RemoveRange(count, nodes.Count - count);
				}

				DrawContext.Memory.Size = nodes.Select(n => n.MemorySize).Sum();
			}

			/// <summary>Changes the number of nodes with the provided delta.</summary>
			/// <param name="delta">The change delta.</param>
			public void ChangeNodeCount(int delta)
			{
				SetNodeCount(nodes.Count + delta);

				CalculateSize();
			}

			/// <summary>Resets the settings of the panel to the defaults.</summary>
			public void Reset()
			{
				SetNodeCount(MinNodeCount);

				CalculateSize();
			}

			/// <summary>Calculates the size of the panel.</summary>
			private void CalculateSize()
			{
				var size = new Size(
					ToolTipWidth,
					nodes.Sum(n => n.CalculateDrawnHeight(DrawContext)) + ToolTipPadding
				);

				DrawContext.ClientArea = new Rectangle(ToolTipPadding / 2, ToolTipPadding / 2, size.Width - ToolTipPadding, size.Height - ToolTipPadding);

				Size = MinimumSize = MaximumSize = size;
			}

			protected override void OnPaint(PaintEventArgs e)
			{
				DrawContext.HotSpots.Clear();

				// Some settings are not usefull for the preview.
				DrawContext.Settings = Program.Settings.Clone();
				DrawContext.Settings.ShowNodeAddress = false;

				DrawContext.Graphics = e.Graphics;

				using (var brush = new SolidBrush(DrawContext.Settings.BackgroundColor))
				{
					e.Graphics.FillRectangle(brush, ClientRectangle);
				}
				using (var pen = new Pen(DrawContext.Settings.BackgroundColor.Invert(), 1))
				{
					e.Graphics.DrawRectangle(pen, new Rectangle(Bounds.X, Bounds.Y, Bounds.Width - 1, Bounds.Height - 1));
				}

				int x = -24;
				int y = 2;
				foreach (var node in nodes)
				{
					y += node.Draw(DrawContext, x, y).Height;
				}
			}
		}

		private readonly MemoryPreviewPanel panel;

		private IntPtr memoryAddress;

		protected override CreateParams CreateParams
		{
			get
			{
				const int WS_EX_NOACTIVATE = 0x08000000;

				var cp = base.CreateParams;
				cp.ExStyle |= WS_EX_NOACTIVATE;
				return cp;
			}
		}

		public MemoryPreviewPopUp(FontEx font)
		{
			Contract.Requires(font != null);

			AutoSize = false;
			AutoClose = false;
			DoubleBuffered = true;
			ResizeRedraw = true;
			TabStop = false;

			panel = new MemoryPreviewPanel(font)
			{
				Location = Point.Empty
			};

			var host = new ToolStripControlHost(panel);
			Padding = Margin = host.Padding = host.Margin = Padding.Empty;
			MinimumSize = panel.MinimumSize;
			panel.MinimumSize = panel.Size;
			MaximumSize = panel.MaximumSize;
			panel.MaximumSize = panel.Size;
			Size = panel.Size;

			panel.SizeChanged += (s, e) => Size = MinimumSize = MaximumSize = panel.Size;

			Items.Add(host);
		}

		protected override void OnClosed(ToolStripDropDownClosedEventArgs e)
		{
			panel.Reset();

			base.OnClosed(e);
		}

		internal void HandleMouseWheelEvent(MouseEventArgs e)
		{
			if (e.Delta != 0)
			{
				panel.ChangeNodeCount(e.Delta < 0 ? 1 : -1);

				UpdateMemory();

				Invalidate();

				if (e is HandledMouseEventArgs he)
				{
					he.Handled = true;
				}
			}
		}

		/// <summary>Initializes the memory buffer.</summary>
		/// <param name="process">The process to use.</param>
		/// <param name="address">The address to read from.</param>
		public void InitializeMemory(RemoteProcess process, IntPtr address)
		{
			Contract.Requires(process != null);

			memoryAddress = address;

			panel.DrawContext.Process = process;

			panel.DrawContext.Memory.UpdateFrom(process, address);
		}

		/// <summary>Updates the memory buffer to get current data.</summary>
		public void UpdateMemory()
		{
			panel.DrawContext.Memory.UpdateFrom(panel.DrawContext.Process, memoryAddress);

			panel.Invalidate();
		}
	}
}

```

`ReClass.NET/Controls/MemoryRecordList.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class MemoryRecordList
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.resultDataGridView = new System.Windows.Forms.DataGridView();
			this.descriptionColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.addressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.valueTypeColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.valueColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.previousValueColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			((System.ComponentModel.ISupportInitialize)(this.resultDataGridView)).BeginInit();
			this.SuspendLayout();
			// 
			// resultDataGridView
			// 
			this.resultDataGridView.AllowUserToAddRows = false;
			this.resultDataGridView.AllowUserToDeleteRows = false;
			this.resultDataGridView.AllowUserToResizeRows = false;
			this.resultDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
			this.resultDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleVertical;
			this.resultDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.resultDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.descriptionColumn,
            this.addressColumn,
            this.valueTypeColumn,
            this.valueColumn,
            this.previousValueColumn});
			this.resultDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.resultDataGridView.Location = new System.Drawing.Point(0, 0);
			this.resultDataGridView.Name = "resultDataGridView";
			this.resultDataGridView.ReadOnly = true;
			this.resultDataGridView.RowHeadersVisible = false;
			this.resultDataGridView.RowTemplate.Height = 19;
			this.resultDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.resultDataGridView.Size = new System.Drawing.Size(290, 327);
			this.resultDataGridView.TabIndex = 15;
			this.resultDataGridView.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.resultDataGridView_CellDoubleClick);
			this.resultDataGridView.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.resultDataGridView_CellFormatting);
			this.resultDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.resultDataGridView_CellMouseDown);
			this.resultDataGridView.RowContextMenuStripNeeded += new System.Windows.Forms.DataGridViewRowContextMenuStripNeededEventHandler(this.resultDataGridView_RowContextMenuStripNeeded);
			// 
			// descriptionColumn
			// 
			this.descriptionColumn.DataPropertyName = "Description";
			this.descriptionColumn.HeaderText = "Description";
			this.descriptionColumn.Name = "descriptionColumn";
			this.descriptionColumn.ReadOnly = true;
			// 
			// addressColumn
			// 
			this.addressColumn.DataPropertyName = "AddressStr";
			this.addressColumn.HeaderText = "Address";
			this.addressColumn.MinimumWidth = 70;
			this.addressColumn.Name = "addressColumn";
			this.addressColumn.ReadOnly = true;
			// 
			// valueTypeColumn
			// 
			this.valueTypeColumn.DataPropertyName = "ValueType";
			this.valueTypeColumn.HeaderText = "Value Type";
			this.valueTypeColumn.Name = "valueTypeColumn";
			this.valueTypeColumn.ReadOnly = true;
			// 
			// valueColumn
			// 
			this.valueColumn.DataPropertyName = "ValueStr";
			this.valueColumn.HeaderText = "Value";
			this.valueColumn.Name = "valueColumn";
			this.valueColumn.ReadOnly = true;
			// 
			// previousValueColumn
			// 
			this.previousValueColumn.DataPropertyName = "PreviousValueStr";
			this.previousValueColumn.HeaderText = "Previous";
			this.previousValueColumn.Name = "previousValueColumn";
			this.previousValueColumn.ReadOnly = true;
			// 
			// MemoryRecordList
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.resultDataGridView);
			this.Name = "MemoryRecordList";
			this.Size = new System.Drawing.Size(290, 327);
			((System.ComponentModel.ISupportInitialize)(this.resultDataGridView)).EndInit();
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.DataGridView resultDataGridView;
		private System.Windows.Forms.DataGridViewTextBoxColumn descriptionColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn addressColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn valueTypeColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn valueColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn previousValueColumn;
	}
}

```

`ReClass.NET/Controls/MemoryRecordList.cs`:

```cs
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner;
using ReClassNET.UI;

namespace ReClassNET.Controls
{
	public delegate void MemorySearchResultControlResultDoubleClickEventHandler(object sender, MemoryRecord record);

	public partial class MemoryRecordList : UserControl
	{
		public bool ShowDescriptionColumn
		{
			get => descriptionColumn.Visible;
			set => descriptionColumn.Visible = value;
		}

		public bool ShowAddressColumn
		{
			get => addressColumn.Visible;
			set => addressColumn.Visible = value;
		}

		public bool ShowValueTypeColumn
		{
			get => valueTypeColumn.Visible;
			set => valueTypeColumn.Visible = value;
		}

		public bool ShowValueColumn
		{
			get => valueColumn.Visible;
			set => valueColumn.Visible = value;
		}

		public bool ShowPreviousValueColumn
		{
			get => previousValueColumn.Visible;
			set => previousValueColumn.Visible = value;
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public IList<MemoryRecord> Records => bindings;

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public MemoryRecord SelectedRecord => GetSelectedRecords().FirstOrDefault();

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public IList<MemoryRecord> SelectedRecords => GetSelectedRecords().ToList();

		public override ContextMenuStrip ContextMenuStrip
		{
			get;
			set;
		}

		public event MemorySearchResultControlResultDoubleClickEventHandler RecordDoubleClick;

		private readonly BindingList<MemoryRecord> bindings;

		public MemoryRecordList()
		{
			InitializeComponent();

			if (Program.DesignMode)
			{
				return;
			}

			bindings = new BindingList<MemoryRecord>
			{
				AllowNew = true,
				AllowEdit = true,
				RaiseListChangedEvents = true
			};

			resultDataGridView.AutoGenerateColumns = false;
			resultDataGridView.DefaultCellStyle.Font = new Font(
				Program.MonoSpaceFont.Font.FontFamily,
				DpiUtil.ScaleIntX(11),
				GraphicsUnit.Pixel
			);
			resultDataGridView.DataSource = bindings;
		}

		#region Event Handler

		private void resultDataGridView_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
		{
			OnRecordDoubleClick((MemoryRecord)resultDataGridView.Rows[e.RowIndex].DataBoundItem);
		}

		private void resultDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
		{
			if (e.ColumnIndex == 1) // Address
			{
				var record = (MemoryRecord)resultDataGridView.Rows[e.RowIndex].DataBoundItem;
				if (record.IsRelativeAddress)
				{
					e.CellStyle.ForeColor = Color.ForestGreen;
					e.FormattingApplied = true;
				}
			}
			else if (e.ColumnIndex == 3) // Value
			{
				var record = (MemoryRecord)resultDataGridView.Rows[e.RowIndex].DataBoundItem;
				e.CellStyle.ForeColor = record.HasChangedValue ? Color.Red : Color.Black;
				e.FormattingApplied = true;
			}
		}

		private void resultDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
		{
			if (e.Button == MouseButtons.Right)
			{
				if (e.RowIndex != -1)
				{
					var row = resultDataGridView.Rows[e.RowIndex];
					if (!row.Selected && !(ModifierKeys == Keys.Shift || ModifierKeys == Keys.Control))
					{
						resultDataGridView.ClearSelection();
					}
					row.Selected = true;
				}
			}
		}

		private void resultDataGridView_RowContextMenuStripNeeded(object sender, DataGridViewRowContextMenuStripNeededEventArgs e)
		{
			e.ContextMenuStrip = ContextMenuStrip;
		}

		#endregion

		private IEnumerable<MemoryRecord> GetSelectedRecords() => resultDataGridView.SelectedRows.Cast<DataGridViewRow>().Select(r => (MemoryRecord)r.DataBoundItem);

		/// <summary>
		/// Sets the records to display.
		/// </summary>
		/// <param name="records">The records.</param>
		public void SetRecords(IEnumerable<MemoryRecord> records)
		{
			Contract.Requires(records != null);

			bindings.Clear();

			bindings.RaiseListChangedEvents = false;

			foreach (var record in records)
			{
				bindings.Add(record);
			}

			bindings.RaiseListChangedEvents = true;
			bindings.ResetBindings();
		}

		/// <summary>
		/// Removes all records.
		/// </summary>
		public void Clear()
		{
			bindings.Clear();
		}

		/// <summary>
		/// Refreshes the data of all displayed records.
		/// </summary>
		/// <param name="process">The process.</param>
		public void RefreshValues(RemoteProcess process)
		{
			Contract.Requires(process != null);

			foreach (var record in resultDataGridView.GetVisibleRows().Select(r => (MemoryRecord)r.DataBoundItem))
			{
				record.RefreshValue(process);
			}
		}

		private void OnRecordDoubleClick(MemoryRecord record)
		{
			var evt = RecordDoubleClick;
			evt?.Invoke(this, record);
		}
	}
}

```

`ReClass.NET/Controls/MemoryRecordList.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="descriptionColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="addressColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="valueTypeColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="valueColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="previousValueColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Controls/MemoryViewControl.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class MemoryViewControl
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
            this.components = new System.ComponentModel.Container();
            this.repaintTimer = new System.Windows.Forms.Timer(this.components);
            this.hotSpotEditBox = new HotSpotTextBox();
            this.nodeInfoToolTip = new System.Windows.Forms.ToolTip(this.components);
            this.SuspendLayout();
            // 
            // repaintTimer
            // 
            this.repaintTimer.Enabled = true;
            this.repaintTimer.Interval = 250;
            this.repaintTimer.Tick += new System.EventHandler(this.repaintTimer_Tick);
            // 
            // hotSpotEditBox
            // 
            this.hotSpotEditBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.hotSpotEditBox.Location = new System.Drawing.Point(0, 0);
            this.hotSpotEditBox.Name = "hotSpotEditBox";
            this.hotSpotEditBox.Size = new System.Drawing.Size(100, 13);
            this.hotSpotEditBox.TabIndex = 1;
            this.hotSpotEditBox.TabStop = false;
            this.hotSpotEditBox.Visible = false;
            this.hotSpotEditBox.Committed += new HotSpotTextBoxCommitEventHandler(this.editBox_Committed);
            // 
            // nodeInfoToolTip
            // 
            this.nodeInfoToolTip.ShowAlways = true;
            // 
            // MemoryViewControl
            // 
            this.Controls.Add(this.hotSpotEditBox);
            this.DoubleBuffered = true;
            this.Name = "MemoryViewControl";
            this.Size = new System.Drawing.Size(150, 162);
            this.ResumeLayout(false);
            this.PerformLayout();

		}

		#endregion
		private System.Windows.Forms.Timer repaintTimer;
		private HotSpotTextBox hotSpotEditBox;
		private System.Windows.Forms.ToolTip nodeInfoToolTip;
	}
}

```

`ReClass.NET/Controls/MemoryViewControl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Controls
{
	public partial class MemoryViewControl : UserControl
	{
		/// <summary>
		/// Contains informations about a selected node.
		/// </summary>
		public class SelectedNodeInfo
		{
			/// <summary>
			/// The selected node.
			/// </summary>
			public BaseNode Node { get; }

			public RemoteProcess Process { get; }

			/// <summary>
			/// The memory this node uses.
			/// </summary>
			public MemoryBuffer Memory { get; }

			/// <summary>
			/// The address of the node in the remote process.
			/// </summary>
			public IntPtr Address { get; }

			public int Level { get; }

			public SelectedNodeInfo(BaseNode node, RemoteProcess process, MemoryBuffer memory, IntPtr address, int level)
			{
				Contract.Requires(node != null);
				Contract.Requires(process != null);
				Contract.Requires(memory != null);

				Node = node;
				Process = process;
				Memory = memory;
				Address = address;
				Level = level;
			}
		}

		private readonly List<HotSpot> hotSpots = new List<HotSpot>();
		private readonly List<HotSpot> selectedNodes = new List<HotSpot>();

		private HotSpot selectionCaret;
		private HotSpot selectionAnchor;

		private readonly FontEx font;

		public ContextMenuStrip NodeContextMenuStrip { get; set; }

		public event DrawContextRequestEventHandler DrawContextRequested;
		public event EventHandler SelectionChanged;
		public event NodeClickEventHandler ChangeClassTypeClick;
		public event NodeClickEventHandler ChangeWrappedTypeClick;
		public event NodeClickEventHandler ChangeEnumTypeClick;

		private readonly MemoryPreviewPopUp memoryPreviewPopUp;

		public MemoryViewControl()
		{
			InitializeComponent();

			if (Program.DesignMode)
			{
				return;
			}

			AutoScroll = true;

			font = Program.MonoSpaceFont;

			hotSpotEditBox.Font = font;

			memoryPreviewPopUp = new MemoryPreviewPopUp(font);
		}

		protected override void OnPaint(PaintEventArgs e)
		{
			base.OnPaint(e);

			if (DesignMode)
			{
				e.Graphics.FillRectangle(Brushes.White, ClientRectangle);

				return;
			}

			var args = new DrawContextRequestEventArgs();

			var requestHandler = DrawContextRequested;
			requestHandler?.Invoke(this, args);

			hotSpots.Clear();

			using (var brush = new SolidBrush(Program.Settings.BackgroundColor))
			{
				e.Graphics.FillRectangle(brush, ClientRectangle);
			}

			if (args.Process == null || args.Memory == null || args.Node == null)
			{
				return;
			}

			if (memoryPreviewPopUp.Visible)
			{
				memoryPreviewPopUp.UpdateMemory();
			}

			var view = new DrawContext
			{
				Settings = args.Settings,
				Graphics = e.Graphics,
				Font = font,
				IconProvider = args.IconProvider,
				Process = args.Process,
				Memory = args.Memory,
				CurrentTime = args.CurrentTime,
				ClientArea = ClientRectangle,
				HotSpots = hotSpots,
				Address = args.BaseAddress,
				Level = 0,
				MultipleNodesSelected = selectedNodes.Count > 1
			};

			var scrollPosition = AutoScrollPosition;

			var drawnSize = args.Node.Draw(
				view,
				scrollPosition.X,
				scrollPosition.Y
			);
			drawnSize.Width += 10;

			/*foreach (var spot in hotSpots.Where(h => h.Type == HotSpotType.Select))
			{
				e.Graphics.DrawRectangle(new Pen(new SolidBrush(Color.FromArgb(150, 255, 0, 0)), 1), spot.Rect);
			}*/

			AutoScrollMinSize = new Size(Math.Max(drawnSize.Width, ClientSize.Width), Math.Max(drawnSize.Height, ClientSize.Height));

			// Sometimes setting AutoScrollMinSize resets AutoScrollPosition. This restores the original position.
			AutoScrollPosition = new Point(-scrollPosition.X, -scrollPosition.Y);
		}

		private void OnSelectionChanged()
		{
			SelectionChanged?.Invoke(this, EventArgs.Empty);
		}

		#region Process Input

		protected override void OnMouseClick(MouseEventArgs e)
		{
			Contract.Requires(e != null);

			hotSpotEditBox.Hide();

			var invalidate = false;

			foreach (var hotSpot in hotSpots)
			{
				if (hotSpot.Rect.Contains(e.Location))
				{
					var hitObject = hotSpot.Node;

					if (hotSpot.Type == HotSpotType.OpenClose)
					{
						hitObject.ToggleLevelOpen(hotSpot.Level);

						invalidate = true;

						break;
					}
					if (hotSpot.Type == HotSpotType.Click)
					{
						hitObject.Update(hotSpot);

						invalidate = true;

						break;
					}
					if (hotSpot.Type == HotSpotType.Select)
					{
						if (e.Button == MouseButtons.Left)
						{
							if (ModifierKeys == Keys.None)
							{
								ClearSelection();

								hitObject.IsSelected = true;

								selectedNodes.Add(hotSpot);

								OnSelectionChanged();

								selectionAnchor = selectionCaret = hotSpot;
							}
							else if (ModifierKeys == Keys.Control)
							{
								hitObject.IsSelected = !hitObject.IsSelected;

								if (hitObject.IsSelected)
								{
									selectedNodes.Add(hotSpot);
								}
								else
								{
									selectedNodes.Remove(selectedNodes.FirstOrDefault(c => c.Node == hitObject));
								}

								OnSelectionChanged();
							}
							else if (ModifierKeys == Keys.Shift)
							{
								if (selectedNodes.Count > 0)
								{
									var selectedNode = selectedNodes[0].Node;
									if (hitObject.GetParentContainer() != null && selectedNode.GetParentContainer() != hitObject.GetParentContainer())
									{
										continue;
									}

									if (hotSpot.Node is BaseContainerNode)
									{
										continue;
									}

									var first = Utils.Min(selectedNodes[0], hotSpot, h => h.Node.Offset);
									var last = first == hotSpot ? selectedNodes[0] : hotSpot;

									ClearSelection();

									var containerNode = selectedNode.GetParentContainer();
									foreach (var spot in containerNode.Nodes
										.SkipWhile(n => n != first.Node)
										.TakeWhileInclusive(n => n != last.Node)
										.Select(n => new HotSpot
										{
											Address = (IntPtr)(containerNode.Offset + n.Offset),
											Node = n,
											Process = first.Process,
											Memory = first.Memory,
											Level = first.Level
										}))
									{
										spot.Node.IsSelected = true;
										selectedNodes.Add(spot);
									}

									OnSelectionChanged();

									selectionAnchor = first;
									selectionCaret = last;
								}
							}
						}
						else if (e.Button == MouseButtons.Right)
						{
							// If there is only one selected node, select the node the user clicked at.
							if (selectedNodes.Count <= 1)
							{
								ClearSelection();

								hitObject.IsSelected = true;

								selectedNodes.Add(hotSpot);

								OnSelectionChanged();

								selectionAnchor = selectionCaret = hotSpot;
							}

							ShowNodeContextMenu(e.Location);
						}

						invalidate = true;
					}
					else if (hotSpot.Type == HotSpotType.Context)
					{
						ShowNodeContextMenu(e.Location);

						break;
					}
					else if (hotSpot.Type == HotSpotType.Delete)
					{
						hotSpot.Node.GetParentContainer().RemoveNode(hotSpot.Node);

						invalidate = true;

						break;
					}
					else if (hotSpot.Type == HotSpotType.ChangeClassType || hotSpot.Type == HotSpotType.ChangeWrappedType || hotSpot.Type == HotSpotType.ChangeEnumType)
					{
						var handler = hotSpot.Type switch
						{
							HotSpotType.ChangeClassType => ChangeClassTypeClick,
							HotSpotType.ChangeWrappedType => ChangeWrappedTypeClick,
							HotSpotType.ChangeEnumType => ChangeEnumTypeClick
						};

						handler?.Invoke(this, new NodeClickEventArgs(hitObject, hotSpot.Address, hotSpot.Memory, e.Button, e.Location));

						break;
					}
				}
			}

			if (invalidate)
			{
				Invalidate();
			}

			base.OnMouseClick(e);
		}

		protected override void OnMouseDoubleClick(MouseEventArgs e)
		{
			Contract.Requires(e != null);

			hotSpotEditBox.Hide();

			var invalidate = false;

			// Order the hotspots: 1. DoubleClick 2. Click 3. Edit 4. Select
			var spots = hotSpots.Where(h => h.Type == HotSpotType.DoubleClick)
				.Concat(hotSpots.Where(h => h.Type == HotSpotType.Click))
				.Concat(hotSpots.Where(h => h.Type == HotSpotType.Edit))
				.Concat(hotSpots.Where(h => h.Type == HotSpotType.Select));

			foreach (var hotSpot in spots)
			{
				if (hotSpot.Rect.Contains(e.Location))
				{
					if (hotSpot.Type == HotSpotType.DoubleClick || hotSpot.Type == HotSpotType.Click)
					{
						hotSpot.Node.Update(hotSpot);

						invalidate = true;

						break;
					}
					if (hotSpot.Type == HotSpotType.Edit)
					{
						hotSpotEditBox.ShowOnHotSpot(hotSpot);

						break;
					}
					if (hotSpot.Type == HotSpotType.Select)
					{
						hotSpot.Node.ToggleLevelOpen(hotSpot.Level);

						invalidate = true;

						break;
					}
				}
			}

			if (invalidate)
			{
				Invalidate();
			}

			base.OnMouseDoubleClick(e);
		}

		private Point toolTipPosition;
		protected override void OnMouseHover(EventArgs e)
		{
			Contract.Requires(e != null);

			base.OnMouseHover(e);

			if (selectedNodes.Count > 1)
			{
				var memorySize = selectedNodes.Sum(h => h.Node.MemorySize);
				nodeInfoToolTip.Show($"{selectedNodes.Count} Nodes selected, {memorySize} bytes", this, toolTipPosition.Relocate(16, 16));
			}
			else
			{
				foreach (var spot in hotSpots.Where(h => h.Type == HotSpotType.Select))
				{
					if (spot.Rect.Contains(toolTipPosition))
					{
						if (spot.Node.UseMemoryPreviewToolTip(spot, out var previewAddress))
						{
							memoryPreviewPopUp.InitializeMemory(spot.Process, previewAddress);

							memoryPreviewPopUp.Show(this, toolTipPosition.Relocate(16, 16));
						}
						else
						{
							var text = spot.Node.GetToolTipText(spot);
							if (!string.IsNullOrEmpty(text))
							{
								nodeInfoToolTip.Show(text, this, toolTipPosition.Relocate(16, 16));
							}
						}

						return;
					}
				}
			}
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			Contract.Requires(e != null);

			base.OnMouseMove(e);

			if (e.Location != toolTipPosition)
			{
				toolTipPosition = e.Location;

				nodeInfoToolTip.Hide(this);

				if (memoryPreviewPopUp.Visible)
				{
					memoryPreviewPopUp.Close();

					Invalidate();
				}

				ResetMouseEventArgs();
			}
		}

		protected override void OnMouseWheel(MouseEventArgs e)
		{
			hotSpotEditBox.Hide();

			if (memoryPreviewPopUp.Visible)
			{
				memoryPreviewPopUp.HandleMouseWheelEvent(e);
			}
			else
			{
				base.OnMouseWheel(e);
			}
		}

		protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
		{
			if (hotSpotEditBox.Visible == false) // Only process keys if the edit field is not visible.
			{
				var key = keyData & Keys.KeyCode;
				var modifier = keyData & Keys.Modifiers;

				if (selectedNodes.Count > 0)
				{
					if (key == Keys.Menu)
					{
						ShowNodeContextMenu(new Point(10, 10));

						return true;
					}
					if ((key == Keys.Down || key == Keys.Up) && selectionCaret != null && selectionAnchor != null)
					{
						HotSpot toSelect;
						bool isAtEnd;

						var query = hotSpots
							.Where(h => h.Type == HotSpotType.Select)
							.Where(h => h.Node.GetParentContainer() == selectionCaret.Node.GetParentContainer());

						if (key == Keys.Down)
						{
							var temp = query
								.SkipWhile(h => h.Node != selectionCaret.Node)
								.Skip(1)
								.ToList();

							toSelect = temp.FirstOrDefault();
							isAtEnd = toSelect != null && toSelect == temp.LastOrDefault();
						}
						else
						{
							var temp = query
								.TakeWhile(h => h.Node != selectionCaret.Node)
								.ToList();

							toSelect = temp.LastOrDefault();
							isAtEnd = toSelect != null && toSelect == temp.FirstOrDefault();
						}

						if (toSelect != null && !(toSelect.Node is ClassNode))
						{
							if (modifier != Keys.Shift)
							{
								selectionAnchor = selectionCaret = toSelect;
							}
							else
							{
								selectionCaret = toSelect;
							}

							var first = Utils.Min(selectionAnchor, selectionCaret, h => h.Node.Offset);
							var last = first == selectionAnchor ? selectionCaret : selectionAnchor;

							selectedNodes.ForEach(h => h.Node.ClearSelection());
							selectedNodes.Clear();

							var containerNode = toSelect.Node.GetParentContainer();
							foreach (var spot in containerNode.Nodes
								.SkipWhile(n => n != first.Node)
								.TakeWhileInclusive(n => n != last.Node)
								.Select(n => new HotSpot
								{
									Address = (IntPtr)(containerNode.Offset + n.Offset),
									Node = n,
									Process = toSelect.Process,
									Memory = toSelect.Memory,
									Level = toSelect.Level
								}))
							{
								spot.Node.IsSelected = true;
								selectedNodes.Add(spot);
							}

							OnSelectionChanged();

							if (isAtEnd)
							{
								const int ScrollAmount = 3;

								var position = AutoScrollPosition;
								AutoScrollPosition = new Point(-position.X, -position.Y + (key == Keys.Down ? ScrollAmount : -ScrollAmount) * font.Height);
							}

							Invalidate();

							return true;
						}
					}
					else if (key == Keys.Left || key == Keys.Right)
					{
						if (selectedNodes.Count == 1)
						{
							var selected = selectedNodes[0];

							selected.Node.SetLevelOpen(selected.Level, key == Keys.Right);
						}
					}
				}
				else if (key == Keys.Down || key == Keys.Up)
				{
					// If no node is selected, try to select the first one.
					var selection = hotSpots
						.Where(h => h.Type == HotSpotType.Select)
						.WhereNot(h => h.Node is ClassNode)
						.FirstOrDefault();
					if (selection != null)
					{
						selectionAnchor = selectionCaret = selection;

						selection.Node.IsSelected = true;

						selectedNodes.Add(selection);

						OnSelectionChanged();

						return true;
					}
				}
			}

			return base.ProcessCmdKey(ref msg, keyData);
		}

		#endregion

		#region Event Handler

		protected override void OnSizeChanged(EventArgs e)
		{
			base.OnSizeChanged(e);

			Invalidate();
		}

		private void repaintTimer_Tick(object sender, EventArgs e)
		{
			if (DesignMode)
			{
				return;
			}

			Invalidate(false);
		}

		private void editBox_Committed(object sender, HotSpotTextBoxCommitEventArgs e)
		{
			var hotSpot = e.HotSpot;
			if (hotSpot != null)
			{
				try
				{
					hotSpot.Node.Update(hotSpot);
				}
				catch (Exception ex)
				{
					Program.Logger.Log(ex);
				}

				Invalidate();
			}

			Focus();
		}

		#endregion

		/// <summary>
		/// Gets informations about all selected nodes.
		/// </summary>
		/// <returns>A list with informations about all selected nodes.</returns>
		public IReadOnlyList<SelectedNodeInfo> GetSelectedNodes()
		{
			return selectedNodes
				.Select(h => new SelectedNodeInfo(h.Node, h.Process, h.Memory, h.Address, h.Level))
				.ToList();
		}

		/// <summary>
		/// Selects the given nodes.
		/// </summary>
		/// <param name="nodes"></param>
		public void SetSelectedNodes(IEnumerable<SelectedNodeInfo> nodes)
		{
			selectedNodes.ForEach(h => h.Node.ClearSelection());

			selectedNodes.Clear();

			selectedNodes.AddRange(nodes.Select(i => new HotSpot { Type = HotSpotType.Select, Node = i.Node, Process = i.Process, Memory = i.Memory, Address = i.Address, Level = i.Level }));
			selectedNodes.ForEach(h => h.Node.IsSelected = true);

			OnSelectionChanged();
		}

		/// <summary>
		/// Shows the context menu at the given point.
		/// </summary>
		/// <param name="location">The location where the context menu should be shown.</param>
		private void ShowNodeContextMenu(Point location)
		{
			NodeContextMenuStrip?.Show(this, location);
		}

		public void ShowNodeNameEditBox(BaseNode node)
		{
			if (node == null || node is BaseHexNode)
			{
				return;
			}

			var hotSpot = hotSpots
				.FirstOrDefault(s => s.Node == node && s.Type == HotSpotType.Edit && s.Id == HotSpot.NameId);
			if (hotSpot != null)
			{
				hotSpotEditBox.ShowOnHotSpot(hotSpot);
			}
		}

		/// <summary>
		/// Resets the selection state of all selected nodes.
		/// </summary>
		public void ClearSelection()
		{
			selectionAnchor = selectionCaret = null;

			selectedNodes.ForEach(h => h.Node.ClearSelection());

			selectedNodes.Clear();

			OnSelectionChanged();

			//Invalidate();
		}

		/// <summary>
		/// Resets the control to the initial state.
		/// </summary>
		public void Reset()
		{
			ClearSelection();

			hotSpotEditBox.Hide();

			VerticalScroll.Value = VerticalScroll.Minimum;
		}
	}
}

```

`ReClass.NET/Controls/MemoryViewControl.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="repaintTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>243, 17</value>
  </metadata>
  <metadata name="nodeInfoToolTip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>364, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>65</value>
  </metadata>
</root>
```

`ReClass.NET/Controls/NodeClickEventArgs.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Windows.Forms;
using ReClassNET.Memory;
using ReClassNET.Nodes;

namespace ReClassNET.Controls
{
	public class NodeClickEventArgs : EventArgs
	{
		public BaseNode Node { get; }

		public IntPtr Address { get; }

		public MemoryBuffer Memory { get; }

		public MouseButtons Button { get; }

		public Point Location { get; }

		public NodeClickEventArgs(BaseNode node, IntPtr address, MemoryBuffer memory, MouseButtons button, Point location)
		{
			Contract.Requires(node != null);
			Contract.Requires(memory != null);

			Node = node;
			Address = address;
			Memory = memory;
			Button = button;
			Location = location;
		}
	}

	public delegate void NodeClickEventHandler(object sender, NodeClickEventArgs args);
}

```

`ReClass.NET/Controls/PlaceholderTextBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;

namespace ReClassNET.Controls
{
	public class PlaceholderTextBox : TextBox
	{
		private Font fontBackup;
		private Color foreColorBackup;
		private Color backColorBackup;

		/// <summary>
		/// The color of the placeholder text.
		/// </summary>
		[DefaultValue(typeof(Color), "ControlDarkDark")]
		public Color PlaceholderColor { get; set; } = SystemColors.ControlDarkDark;

		/// <summary>
		/// The placeholder text.
		/// </summary>
		[DefaultValue("")]
		public string PlaceholderText { get; set; }

		public PlaceholderTextBox()
		{
			fontBackup = Font;
			foreColorBackup = ForeColor;
			backColorBackup = BackColor;

			SetStyle(ControlStyles.UserPaint, true);
		}

		protected override void OnTextChanged(EventArgs e)
		{
			base.OnTextChanged(e);

			if (string.IsNullOrEmpty(Text))
			{
				if (!GetStyle(ControlStyles.UserPaint))
				{
					fontBackup = Font;
					foreColorBackup = ForeColor;
					backColorBackup = BackColor;

					SetStyle(ControlStyles.UserPaint, true);
				}
			}
			else
			{
				if (GetStyle(ControlStyles.UserPaint))
				{
					SetStyle(ControlStyles.UserPaint, false);

					Font = fontBackup;
					ForeColor = foreColorBackup;
					BackColor = backColorBackup;
				}
			}
		}

		protected override void OnPaint(PaintEventArgs e)
		{
			base.OnPaint(e);

			if (string.IsNullOrEmpty(Text) && Focused == false)
			{
				using var brush = new SolidBrush(PlaceholderColor);

				e.Graphics.DrawString(PlaceholderText ?? string.Empty, Font, brush, new PointF(-1.0f, 1.0f));
			}
		}
	}
}

```

`ReClass.NET/Controls/ProjectView.Designer.cs`:

```cs
namespace ReClassNET.Controls
{
	partial class ProjectView
	{
		/// <summary> 
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Komponenten-Designer generierter Code

		/// <summary> 
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.projectTreeView = new System.Windows.Forms.TreeView();
			this.SuspendLayout();
			// 
			// projectTreeView
			// 
			this.projectTreeView.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.projectTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.projectTreeView.HideSelection = false;
			this.projectTreeView.LabelEdit = true;
			this.projectTreeView.Location = new System.Drawing.Point(0, 0);
			this.projectTreeView.Name = "projectTreeView";
			this.projectTreeView.ShowRootLines = false;
			this.projectTreeView.Size = new System.Drawing.Size(150, 150);
			this.projectTreeView.TabIndex = 0;
			this.projectTreeView.BeforeLabelEdit += new System.Windows.Forms.NodeLabelEditEventHandler(this.projectTreeView_BeforeLabelEdit);
			this.projectTreeView.AfterLabelEdit += new System.Windows.Forms.NodeLabelEditEventHandler(this.projectTreeView_AfterLabelEdit);
			this.projectTreeView.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.projectTreeView_AfterSelect);
			this.projectTreeView.MouseUp += new System.Windows.Forms.MouseEventHandler(this.projectTreeView_MouseUp);
			// 
			// ClassNodeView
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.projectTreeView);
			this.Name = "ClassNodeView";
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.TreeView projectTreeView;
	}
}

```

`ReClass.NET/Controls/ProjectView.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.Controls
{
	public partial class ProjectView : UserControl
	{
		/// <summary>A custom tree node for class nodes with hierarchical structure.</summary>
		private class ClassTreeNode : TreeNode
		{
			private readonly ProjectView control;

			public ClassNode ClassNode { get; }

			/// <summary>Constructor of the class.</summary>
			/// <param name="node">The class node.</param>
			/// <param name="control">The <see cref="ProjectView"/> instance this node should belong to.</param>
			public ClassTreeNode(ClassNode node, ProjectView control)
				: this(node, control, null)
			{
				Contract.Requires(node != null);
				Contract.Requires(control != null);
			}

			private ClassTreeNode(ClassNode node, ProjectView control, HashSet<ClassNode> seen)
			{
				Contract.Requires(node != null);
				Contract.Requires(control != null);

				ClassNode = node;

				this.control = control;

				Text = node.Name;

				ImageIndex = 1;
				SelectedImageIndex = 1;

				RebuildClassHierarchy(seen ?? new HashSet<ClassNode> { ClassNode });
			}

			public void Update()
			{
				Text = ClassNode.Name;

				RebuildClassHierarchy(new HashSet<ClassNode> { ClassNode });
			}

			/// <summary>Rebuilds the class hierarchy.</summary>
			/// <param name="seen">The already seen classes.</param>
			private void RebuildClassHierarchy(HashSet<ClassNode> seen)
			{
				Contract.Requires(seen != null);

				if (!control.EnableClassHierarchyView)
				{
					return;
				}

				var distinctClasses = ClassNode.Nodes
					.OfType<BaseWrapperNode>()
					.Select(w => w.ResolveMostInnerNode())
					.OfType<ClassNode>()
					.Distinct()
					.ToList();

				if (distinctClasses.IsEquivalentTo(Nodes.Cast<ClassTreeNode>().Select(t => t.ClassNode)))
				{
					return;
				}

				Nodes.Clear();

				foreach (var child in distinctClasses)
				{
					var childSeen = new HashSet<ClassNode>(seen);
					if (childSeen.Add(child))
					{
						Nodes.Add(new ClassTreeNode(child, control, childSeen));
					}
				}

				if (control.AutoExpandClassNodes)
				{
					Expand();
				}
			}
		}

		public class EnumTreeNode : TreeNode
		{
			public EnumDescription Enum { get; }

			public EnumTreeNode(EnumDescription @enum)
			{
				Contract.Requires(@enum != null);

				Enum = @enum;

				ImageIndex = 3;
				SelectedImageIndex = 3;

				Update();
			}

			public void Update()
			{
				Text = Enum.Name;
			}
		}

		private class NodeSorter : IComparer
		{
			public int Compare(object x, object y)
			{
				var compare = Application.CurrentCulture.CompareInfo;

				if (x is ClassTreeNode cn1 && y is ClassTreeNode cn2)
				{
					return compare.Compare(cn1.Text, cn2.Text);
				}
				if (x is EnumTreeNode en1 && y is EnumTreeNode en2)
				{
					return compare.Compare(en1.Text, en2.Text);
				}
				if (x is TreeNode tn1 && tn1.Parent == null && y is TreeNode tn2 && tn2.Parent == null)
				{
					return (int)tn1.Tag - (int)tn2.Tag;
				}

				return 0;
			}
		}

		private readonly TreeNode enumsRootNode;
		private readonly TreeNode classesRootNode;

		private ClassNode selectedClass;

		private bool autoExpandClassNodes;
		private bool enableClassHierarchyView;

		public delegate void SelectionChangedEvent(object sender, ClassNode node);
		public event SelectionChangedEvent SelectionChanged;

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public ClassNode SelectedClass
		{
			get => selectedClass;
			set
			{
				if (selectedClass != value)
				{
					selectedClass = value;
					if (selectedClass != null)
					{
						projectTreeView.SelectedNode = FindMainClassTreeNode(selectedClass);
					}

					SelectionChanged?.Invoke(this, selectedClass);
				}
			}
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public EnumDescription SelectedEnum { get; private set; }

		[DefaultValue(false)]
		public bool AutoExpandClassNodes
		{
			get => autoExpandClassNodes;
			set
			{
				if (autoExpandClassNodes != value)
				{
					autoExpandClassNodes = value;

					if (autoExpandClassNodes)
					{
						ExpandAllClassNodes();
					}
				}
			}
		}

		[DefaultValue(false)]
		public bool EnableClassHierarchyView
		{
			get => enableClassHierarchyView;
			set
			{
				if (enableClassHierarchyView != value)
				{
					enableClassHierarchyView = value;

					var classes = classesRootNode.Nodes.Cast<ClassTreeNode>().Select(t => t.ClassNode).ToList();

					classesRootNode.Nodes.Clear();

					AddClasses(classes);
				}
			}
		}

		public ContextMenuStrip ClassesContextMenuStrip { get; set; }

		public ContextMenuStrip ClassContextMenuStrip { get; set; }

		public ContextMenuStrip EnumsContextMenuStrip { get; set; }

		public ContextMenuStrip EnumContextMenuStrip { get; set; }

		public ProjectView()
		{
			Contract.Ensures(classesRootNode != null);
			Contract.Ensures(enumsRootNode != null);

			InitializeComponent();

			DoubleBuffered = true;

			projectTreeView.TreeViewNodeSorter = new NodeSorter();
			projectTreeView.ImageList = new ImageList();
			projectTreeView.ImageList.Images.Add(Properties.Resources.B16x16_Text_List_Bullets);
			projectTreeView.ImageList.Images.Add(Properties.Resources.B16x16_Class_Type);
			projectTreeView.ImageList.Images.Add(Properties.Resources.B16x16_Category);
			projectTreeView.ImageList.Images.Add(Properties.Resources.B16x16_Enum_Type);

			classesRootNode = new TreeNode
			{
				Text = "Classes",
				ImageIndex = 0,
				SelectedImageIndex = 0,
				Tag = 0
			};

			projectTreeView.Nodes.Add(classesRootNode);

			enumsRootNode = new TreeNode
			{
				Text = "Enums",
				ImageIndex = 2,
				SelectedImageIndex = 2,
				Tag = 1
			};

			projectTreeView.Nodes.Add(enumsRootNode);
		}

		#region Event Handler

		private void projectTreeView_AfterSelect(object sender, TreeViewEventArgs e)
		{
			if (e.Node.Level == 0)
			{
				return;
			}

			if (e.Node is ClassTreeNode classTreeNode)
			{
				if (selectedClass != classTreeNode.ClassNode)
				{
					SelectedClass = classTreeNode.ClassNode;
				}
			}
			else if (e.Node is EnumTreeNode enumTreeNode)
			{
				SelectedEnum = enumTreeNode.Enum;
			}
		}

		private void projectTreeView_MouseUp(object sender, MouseEventArgs e)
		{
			if (e.Button != MouseButtons.Right)
			{
				return;
			}

			var node = projectTreeView.GetNodeAt(e.X, e.Y);
			if (node == null)
			{
				return;
			}

			ContextMenuStrip cms = null;
			if (node == classesRootNode)
			{
				cms = ClassesContextMenuStrip;
			}
			else if (node is ClassTreeNode)
			{
				cms = ClassContextMenuStrip;

				projectTreeView.SelectedNode = node;
			}
			else if (node == enumsRootNode)
			{
				cms = EnumsContextMenuStrip;
			}
			else if (node is EnumTreeNode)
			{
				cms = EnumContextMenuStrip;

				projectTreeView.SelectedNode = node;
			}
			cms?.Show(projectTreeView, e.Location);
		}

		private void projectTreeView_BeforeLabelEdit(object sender, NodeLabelEditEventArgs e)
		{
			var isClassTreeNode = e.Node is ClassTreeNode;
			var isEnumTreeNode = e.Node is EnumTreeNode;
			e.CancelEdit = !isClassTreeNode && !isEnumTreeNode;
		}

		private void projectTreeView_AfterLabelEdit(object sender, NodeLabelEditEventArgs e)
		{
			if (!string.IsNullOrEmpty(e.Label))
			{
				if (e.Node is ClassTreeNode classTreeNode)
				{
					classTreeNode.ClassNode.Name = e.Label;
				}
				else if (e.Node is EnumTreeNode enumTreeNode)
				{
					enumTreeNode.Enum.Name = e.Label;
				}
			}
		}

		#endregion

		public void ExpandAllClassNodes()
		{
			classesRootNode.ExpandAll();
		}

		public void CollapseAllClassNodes()
		{
			foreach (var tn in classesRootNode.Nodes.Cast<TreeNode>())
			{
				tn.Collapse();
			}
		}

		/// <summary>
		/// Clears all displayed nodes.
		/// </summary>
		public void Clear()
		{
			Clear(true, true);
		}

		/// <summary>
		/// Clears the selected nodes.
		/// </summary>
		/// <param name="clearClasses">Clears the classes if set.</param>
		/// <param name="clearEnums">Clears the enums if set.</param>
		public void Clear(bool clearClasses, bool clearEnums)
		{
			if (clearClasses)
			{
				classesRootNode.Nodes.Clear();
			}

			if (clearEnums)
			{
				enumsRootNode.Nodes.Clear();
			}
		}

		/// <summary>Adds the class to the view.</summary>
		/// <param name="class">The class to add.</param>
		public void AddClass(ClassNode @class)
		{
			Contract.Requires(@class != null);

			AddClasses(new[] { @class });
		}

		/// <summary>
		/// Adds all classes to the view.
		/// </summary>
		/// <param name="classes">The classes to add.</param>
		public void AddClasses(IEnumerable<ClassNode> classes)
		{
			Contract.Requires(classes != null);

			projectTreeView.BeginUpdate();

			foreach (var @class in classes)
			{
				classesRootNode.Nodes.Add(new ClassTreeNode(@class, this));
			}

			classesRootNode.Expand();

			projectTreeView.Sort();

			projectTreeView.EndUpdate();
		}

		/// <summary>Removes the class from the view.</summary>
		/// <param name="node">The class to remove.</param>
		public void RemoveClass(ClassNode node)
		{
			Contract.Requires(node != null);

			foreach (var tn in FindClassTreeNodes(node))
			{
				tn.Remove();
			}

			if (selectedClass == node)
			{
				if (classesRootNode.Nodes.Count > 0)
				{
					projectTreeView.SelectedNode = classesRootNode.Nodes[0];
				}
				else
				{
					SelectedClass = null;
				}
			}
		}

		/// <summary>Searches for the <see cref="ClassTreeNode"/> which represents the class.</summary>
		/// <param name="node">The class to search.</param>
		/// <returns>The found class tree node.</returns>
		private ClassTreeNode FindMainClassTreeNode(ClassNode node)
		{
			Contract.Requires(node != null);

			return classesRootNode.Nodes
				.Cast<ClassTreeNode>()
				.FirstOrDefault(t => t.ClassNode == node);
		}

		/// <summary>Searches for the ClassTreeNode which represents the class.</summary>
		/// <param name="node">The class to search.</param>
		/// <returns>The found class tree node.</returns>
		private IEnumerable<ClassTreeNode> FindClassTreeNodes(ClassNode node)
		{
			Contract.Requires(node != null);

			return classesRootNode.Nodes
				.Cast<ClassTreeNode>()
				.Traverse(t => t.Nodes.Cast<ClassTreeNode>())
				.Where(n => n.ClassNode == node);
		}

		/// <summary>
		/// Updates the display for the given class.
		/// </summary>
		/// <param name="class">The class to update.</param>
		public void UpdateClassNode(ClassNode @class)
		{
			Contract.Requires(@class != null);

			projectTreeView.BeginUpdate();

			foreach (var tn in FindClassTreeNodes(@class))
			{
				tn.Update();
			}

			projectTreeView.Sort();

			projectTreeView.EndUpdate();
		}

		/// <summary>Adds the enum to the view.</summary>
		/// <param name="enum">The enum to add.</param>
		public void AddEnum(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			AddEnums(new[] { @enum });
		}

		/// <summary>Adds the enums to the view.</summary>
		/// <param name="enums">The enums to add.</param>
		public void AddEnums(IEnumerable<EnumDescription> enums)
		{
			Contract.Requires(enums != null);

			projectTreeView.BeginUpdate();

			foreach (var @enum in enums)
			{
				enumsRootNode.Nodes.Add(new EnumTreeNode(@enum));
			}

			enumsRootNode.ExpandAll();

			projectTreeView.Sort();

			projectTreeView.EndUpdate();
		}

		/// <summary>
		/// Updates the display for the given enum.
		/// </summary>
		/// <param name="enum">The enum to update.</param>
		public void UpdateEnumNode(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			projectTreeView.BeginUpdate();

			var node = enumsRootNode.Nodes
				.Cast<EnumTreeNode>()
				.FirstOrDefault(n => n.Enum == @enum);

			if (node != null)
			{
				node.Update();
			}
			else
			{
				AddEnum(@enum);
			}

			projectTreeView.Sort();

			projectTreeView.EndUpdate();
		}
	}
}

```

`ReClass.NET/Controls/ProjectView.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Core/CoreFunctionsManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Debugger;
using ReClassNET.Extensions;
using ReClassNET.Memory;

namespace ReClassNET.Core
{
	public class CoreFunctionsManager : IDisposable
	{
		private readonly Dictionary<string, ICoreProcessFunctions> functionsRegistry = new Dictionary<string, ICoreProcessFunctions>();

		private readonly InternalCoreFunctions internalCoreFunctions;

		private ICoreProcessFunctions currentFunctions;

		public IEnumerable<string> FunctionProviders => functionsRegistry.Keys;

		public ICoreProcessFunctions CurrentFunctions => currentFunctions;

		public string CurrentFunctionsProvider => functionsRegistry
			.Where(kv => kv.Value == currentFunctions)
			.Select(kv => kv.Key)
			.FirstOrDefault();

		public CoreFunctionsManager()
		{
			internalCoreFunctions = InternalCoreFunctions.Create();

			RegisterFunctions("Default", internalCoreFunctions);

			currentFunctions = internalCoreFunctions;
		}

		#region IDisposable Support

		public void Dispose()
		{
			internalCoreFunctions.Dispose();
		}

		#endregion

		public void RegisterFunctions(string provider, ICoreProcessFunctions functions)
		{
			Contract.Requires(provider != null);
			Contract.Requires(functions != null);

			functionsRegistry.Add(provider, functions);
		}

		public void SetActiveFunctionsProvider(string provider)
		{
			if (!functionsRegistry.TryGetValue(provider, out var functions))
			{
				throw new ArgumentException();
			}

			currentFunctions = functions;
		}

		#region Plugin Functions

		public void EnumerateProcesses(Action<ProcessInfo> callbackProcess)
		{
			var c = callbackProcess == null ? null : (EnumerateProcessCallback)delegate (ref EnumerateProcessData data)
			{
				callbackProcess(new ProcessInfo(data.Id, data.Name, data.Path));
			};

			currentFunctions.EnumerateProcesses(c);
		}

		public IList<ProcessInfo> EnumerateProcesses()
		{
			var processes = new List<ProcessInfo>();
			EnumerateProcesses(processes.Add);
			return processes;
		}

		public void EnumerateRemoteSectionsAndModules(IntPtr process, Action<Section> callbackSection, Action<Module> callbackModule)
		{
			var c1 = callbackSection == null ? null : (EnumerateRemoteSectionCallback)delegate (ref EnumerateRemoteSectionData data)
			{
				callbackSection(new Section
				{
					Start = data.BaseAddress,
					End = data.BaseAddress.Add(data.Size),
					Size = data.Size,
					Name = data.Name,
					Protection = data.Protection,
					Type = data.Type,
					ModulePath = data.ModulePath,
					ModuleName = Path.GetFileName(data.ModulePath),
					Category = data.Category
				});
			};

			var c2 = callbackModule == null ? null : (EnumerateRemoteModuleCallback)delegate (ref EnumerateRemoteModuleData data)
			{
				callbackModule(new Module
				{
					Start = data.BaseAddress,
					End = data.BaseAddress.Add(data.Size),
					Size = data.Size,
					Path = data.Path,
					Name = Path.GetFileName(data.Path)
				});
			};

			currentFunctions.EnumerateRemoteSectionsAndModules(process, c1, c2);
		}

		public void EnumerateRemoteSectionsAndModules(IntPtr process, out List<Section> sections, out List<Module> modules)
		{
			sections = new List<Section>();
			modules = new List<Module>();

			EnumerateRemoteSectionsAndModules(process, sections.Add, modules.Add);
		}

		public IntPtr OpenRemoteProcess(IntPtr pid, ProcessAccess desiredAccess)
		{
			return currentFunctions.OpenRemoteProcess(pid, desiredAccess);
		}

		public bool IsProcessValid(IntPtr process)
		{
			return currentFunctions.IsProcessValid(process);
		}

		public void CloseRemoteProcess(IntPtr process)
		{
			currentFunctions.CloseRemoteProcess(process);
		}

		public bool ReadRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size)
		{
			return currentFunctions.ReadRemoteMemory(process, address, ref buffer, offset, size);
		}

		public bool WriteRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size)
		{
			return currentFunctions.WriteRemoteMemory(process, address, ref buffer, offset, size);
		}

		public void ControlRemoteProcess(IntPtr process, ControlRemoteProcessAction action)
		{
			currentFunctions.ControlRemoteProcess(process, action);
		}

		public bool AttachDebuggerToProcess(IntPtr id)
		{
			return currentFunctions.AttachDebuggerToProcess(id);
		}

		public void DetachDebuggerFromProcess(IntPtr id)
		{
			currentFunctions.DetachDebuggerFromProcess(id);
		}

		public void HandleDebugEvent(ref DebugEvent evt)
		{
			currentFunctions.HandleDebugEvent(ref evt);
		}

		public bool AwaitDebugEvent(ref DebugEvent evt, int timeoutInMilliseconds)
		{
			return currentFunctions.AwaitDebugEvent(ref evt, timeoutInMilliseconds);
		}

		public bool SetHardwareBreakpoint(IntPtr id, IntPtr address, HardwareBreakpointRegister register, HardwareBreakpointTrigger trigger, HardwareBreakpointSize size, bool set)
		{
			return currentFunctions.SetHardwareBreakpoint(id, address, register, trigger, size, set);
		}

		#endregion

		#region Internal Core Functions

		public bool DisassembleCode(IntPtr address, int length, IntPtr virtualAddress, bool determineStaticInstructionBytes, EnumerateInstructionCallback callback)
		{
			return internalCoreFunctions.DisassembleCode(address, length, virtualAddress, determineStaticInstructionBytes, callback);
		}

		public IntPtr InitializeInput()
		{
			return internalCoreFunctions.InitializeInput();
		}

		public Keys[] GetPressedKeys(IntPtr handle)
		{
			return internalCoreFunctions.GetPressedKeys(handle);
		}

		public void ReleaseInput(IntPtr handle)
		{
			internalCoreFunctions.ReleaseInput(handle);
		}

		#endregion
	}
}

```

`ReClass.NET/Core/DataExchange.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using ReClassNET.Memory;

namespace ReClassNET.Core
{
	public enum ProcessAccess
	{
		Read,
		Write,
		Full
	};

	public enum ControlRemoteProcessAction
	{
		Suspend,
		Resume,
		Terminate
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
	public struct EnumerateProcessData
	{
		public IntPtr Id;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
		public string Name;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
		public string Path;
	};

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
	public struct EnumerateRemoteSectionData
	{
		public IntPtr BaseAddress;

		public IntPtr Size;

		public SectionType Type;

		public SectionCategory Category;

		public SectionProtection Protection;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
		public string Name;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
		public string ModulePath;
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
	public struct EnumerateRemoteModuleData
	{
		public IntPtr BaseAddress;

		public IntPtr Size;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
		public string Path;
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
	public struct InstructionData
	{
		public IntPtr Address;

		public int Length;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 15)]
		public byte[] Data;

		public int StaticInstructionBytes;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
		public string Instruction;
	};
}

```

`ReClass.NET/Core/ICoreProcessFunctions.cs`:

```cs
using System;
using ReClassNET.Debugger;

namespace ReClassNET.Core
{
	public delegate void EnumerateProcessCallback(ref EnumerateProcessData data);
	public delegate void EnumerateRemoteSectionCallback(ref EnumerateRemoteSectionData data);
	public delegate void EnumerateRemoteModuleCallback(ref EnumerateRemoteModuleData data);

	public interface ICoreProcessFunctions
	{
		void EnumerateProcesses(EnumerateProcessCallback callbackProcess);

		void EnumerateRemoteSectionsAndModules(IntPtr process, EnumerateRemoteSectionCallback callbackSection, EnumerateRemoteModuleCallback callbackModule);

		IntPtr OpenRemoteProcess(IntPtr pid, ProcessAccess desiredAccess);

		bool IsProcessValid(IntPtr process);

		void CloseRemoteProcess(IntPtr process);

		bool ReadRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size);

		bool WriteRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size);

		void ControlRemoteProcess(IntPtr process, ControlRemoteProcessAction action);

		bool AttachDebuggerToProcess(IntPtr id);

		void DetachDebuggerFromProcess(IntPtr id);

		bool AwaitDebugEvent(ref DebugEvent evt, int timeoutInMilliseconds);

		void HandleDebugEvent(ref DebugEvent evt);

		bool SetHardwareBreakpoint(IntPtr id, IntPtr address, HardwareBreakpointRegister register, HardwareBreakpointTrigger trigger, HardwareBreakpointSize size, bool set);
	}
}

```

`ReClass.NET/Core/IInternalCoreFunctions.cs`:

```cs
using System;
using System.Windows.Forms;

namespace ReClassNET.Core
{
	public interface IInternalCoreFunctions
	{
		bool DisassembleCode(IntPtr address, int length, IntPtr virtualAddress, bool determineStaticInstructionBytes, EnumerateInstructionCallback callback);

		IntPtr InitializeInput();

		Keys[] GetPressedKeys(IntPtr handle);

		void ReleaseInput(IntPtr handle);
	}
}

```

`ReClass.NET/Core/InternalCoreFunctions.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Native;
using ReClassNET.Util;

namespace ReClassNET.Core
{
	public delegate bool EnumerateInstructionCallback(ref InstructionData data);

	internal class InternalCoreFunctions : NativeCoreWrapper, IInternalCoreFunctions, IDisposable
	{
		private const string CoreFunctionsModuleWindows = "NativeCore.dll";
		private const string CoreFunctionsModuleUnix = "NativeCore.so";

		private readonly IntPtr handle;

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool DisassembleCodeDelegate(IntPtr address, IntPtr length, IntPtr virtualAddress, [MarshalAs(UnmanagedType.I1)] bool determineStaticInstructionBytes, [MarshalAs(UnmanagedType.FunctionPtr)] EnumerateInstructionCallback callback);

		private delegate IntPtr InitializeInputDelegate();

		private delegate bool GetPressedKeysDelegate(IntPtr handle, out IntPtr pressedKeysArrayPtr, out int length);

		private delegate void ReleaseInputDelegate(IntPtr handle);

		private readonly DisassembleCodeDelegate disassembleCodeDelegate;

		private readonly InitializeInputDelegate initializeInputDelegate;
		private readonly GetPressedKeysDelegate getPressedKeysDelegate;
		private readonly ReleaseInputDelegate releaseInputDelegate;

		private InternalCoreFunctions(IntPtr handle)
			: base(handle)
		{
			this.handle = handle;

			disassembleCodeDelegate = GetFunctionDelegate<DisassembleCodeDelegate>(handle, "DisassembleCode");

			initializeInputDelegate = GetFunctionDelegate<InitializeInputDelegate>(handle, "InitializeInput");
			getPressedKeysDelegate = GetFunctionDelegate<GetPressedKeysDelegate>(handle, "GetPressedKeys");
			releaseInputDelegate = GetFunctionDelegate<ReleaseInputDelegate>(handle, "ReleaseInput");
		}

		public static InternalCoreFunctions Create()
		{
			var libraryName = NativeMethods.IsUnix() ? CoreFunctionsModuleUnix : CoreFunctionsModuleWindows;
			var libraryPath = Path.Combine(PathUtil.ExecutableFolderPath, libraryName);

			var handle = NativeMethods.LoadLibrary(libraryPath);
			if (handle.IsNull())
			{
				throw new FileNotFoundException($"Failed to load native core functions! Couldnt find at location {libraryPath}");
			}

			return new InternalCoreFunctions(handle);
		}

		#region IDisposable Support

		~InternalCoreFunctions()
		{
			ReleaseUnmanagedResources();
		}

		private void ReleaseUnmanagedResources()
		{
			NativeMethods.FreeLibrary(handle);
		}

		public void Dispose()
		{
			ReleaseUnmanagedResources();

			GC.SuppressFinalize(this);
		}

		#endregion

		public bool DisassembleCode(IntPtr address, int length, IntPtr virtualAddress, bool determineStaticInstructionBytes, EnumerateInstructionCallback callback)
		{
			return disassembleCodeDelegate(address, (IntPtr)length, virtualAddress, determineStaticInstructionBytes, callback);
		}

		public IntPtr InitializeInput()
		{
			return initializeInputDelegate();
		}

		private static readonly Keys[] empty = new Keys[0];

		public Keys[] GetPressedKeys(IntPtr handle)
		{
			if (!getPressedKeysDelegate(handle, out var buffer, out var length) || length == 0)
			{
				return empty;
			}

			var keys = new int[length];
			Marshal.Copy(buffer, keys, 0, length);
			return (Keys[])(object)keys; // Yes, it's legal...
			//return Array.ConvertAll(keys, k => (Keys)k);
		}

		public void ReleaseInput(IntPtr handle)
		{
			releaseInputDelegate(handle);
		}
	}
}

```

`ReClass.NET/Core/NativeCoreWrapper.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using ReClassNET.Debugger;
using ReClassNET.Extensions;
using ReClassNET.Native;

namespace ReClassNET.Core
{
	public class NativeCoreWrapper : ICoreProcessFunctions
	{
		#region Native Delegates

		private delegate void EnumerateProcessesDelegate([MarshalAs(UnmanagedType.FunctionPtr)] EnumerateProcessCallback callbackProcess);

		private delegate void EnumerateRemoteSectionsAndModulesDelegate(IntPtr process, [MarshalAs(UnmanagedType.FunctionPtr)] EnumerateRemoteSectionCallback callbackSection, [MarshalAs(UnmanagedType.FunctionPtr)] EnumerateRemoteModuleCallback callbackModule);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool IsProcessValidDelegate(IntPtr process);

		private delegate IntPtr OpenRemoteProcessDelegate(IntPtr pid, ProcessAccess desiredAccess);

		private delegate void CloseRemoteProcessDelegate(IntPtr process);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool ReadRemoteMemoryDelegate(IntPtr process, IntPtr address, [Out] byte[] buffer, int offset, int size);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool WriteRemoteMemoryDelegate(IntPtr process, IntPtr address, [In] byte[] buffer, int offset, int size);

		private delegate void ControlRemoteProcessDelegate(IntPtr process, ControlRemoteProcessAction action);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool AttachDebuggerToProcessDelegate(IntPtr id);

		private delegate void DetachDebuggerFromProcessDelegate(IntPtr id);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool AwaitDebugEventDelegate([In, Out] ref DebugEvent evt, int timeoutInMilliseconds);

		private delegate void HandleDebugEventDelegate([In, Out] ref DebugEvent evt);

		[return: MarshalAs(UnmanagedType.I1)]
		private delegate bool SetHardwareBreakpointDelegate(IntPtr id, IntPtr address, HardwareBreakpointRegister register, HardwareBreakpointTrigger trigger, HardwareBreakpointSize size, [param: MarshalAs(UnmanagedType.I1)] bool set);

		private readonly EnumerateProcessesDelegate enumerateProcessesDelegate;
		private readonly EnumerateRemoteSectionsAndModulesDelegate enumerateRemoteSectionsAndModulesDelegate;
		private readonly OpenRemoteProcessDelegate openRemoteProcessDelegate;
		private readonly IsProcessValidDelegate isProcessValidDelegate;
		private readonly CloseRemoteProcessDelegate closeRemoteProcessDelegate;
		private readonly ReadRemoteMemoryDelegate readRemoteMemoryDelegate;
		private readonly WriteRemoteMemoryDelegate writeRemoteMemoryDelegate;
		private readonly ControlRemoteProcessDelegate controlRemoteProcessDelegate;
		private readonly AttachDebuggerToProcessDelegate attachDebuggerToProcessDelegate;
		private readonly DetachDebuggerFromProcessDelegate detachDebuggerFromProcessDelegate;
		private readonly AwaitDebugEventDelegate awaitDebugEventDelegate;
		private readonly HandleDebugEventDelegate handleDebugEventDelegate;
		private readonly SetHardwareBreakpointDelegate setHardwareBreakpointDelegate;

		#endregion

		public NativeCoreWrapper(IntPtr handle)
		{
			if (handle.IsNull())
			{
				throw new ArgumentNullException();
			}

			enumerateProcessesDelegate = GetFunctionDelegate<EnumerateProcessesDelegate>(handle, "EnumerateProcesses");
			enumerateRemoteSectionsAndModulesDelegate = GetFunctionDelegate<EnumerateRemoteSectionsAndModulesDelegate>(handle, "EnumerateRemoteSectionsAndModules");
			openRemoteProcessDelegate = GetFunctionDelegate<OpenRemoteProcessDelegate>(handle, "OpenRemoteProcess");
			isProcessValidDelegate = GetFunctionDelegate<IsProcessValidDelegate>(handle, "IsProcessValid");
			closeRemoteProcessDelegate = GetFunctionDelegate<CloseRemoteProcessDelegate>(handle, "CloseRemoteProcess");
			readRemoteMemoryDelegate = GetFunctionDelegate<ReadRemoteMemoryDelegate>(handle, "ReadRemoteMemory");
			writeRemoteMemoryDelegate = GetFunctionDelegate<WriteRemoteMemoryDelegate>(handle, "WriteRemoteMemory");
			controlRemoteProcessDelegate = GetFunctionDelegate<ControlRemoteProcessDelegate>(handle, "ControlRemoteProcess");
			attachDebuggerToProcessDelegate = GetFunctionDelegate<AttachDebuggerToProcessDelegate>(handle, "AttachDebuggerToProcess");
			detachDebuggerFromProcessDelegate = GetFunctionDelegate<DetachDebuggerFromProcessDelegate>(handle, "DetachDebuggerFromProcess");
			awaitDebugEventDelegate = GetFunctionDelegate<AwaitDebugEventDelegate>(handle, "AwaitDebugEvent");
			handleDebugEventDelegate = GetFunctionDelegate<HandleDebugEventDelegate>(handle, "HandleDebugEvent");
			setHardwareBreakpointDelegate = GetFunctionDelegate<SetHardwareBreakpointDelegate>(handle, "SetHardwareBreakpoint");
		}

		protected static TDelegate GetFunctionDelegate<TDelegate>(IntPtr handle, string function)
		{
			var address = NativeMethods.GetProcAddress(handle, function);
			if (address.IsNull())
			{
				throw new Exception($"Function '{function}' not found.");
			}
			return Marshal.GetDelegateForFunctionPointer<TDelegate>(address);
		}

		public void EnumerateProcesses(EnumerateProcessCallback callbackProcess)
		{
			enumerateProcessesDelegate(callbackProcess);
		}

		public void EnumerateRemoteSectionsAndModules(IntPtr process, EnumerateRemoteSectionCallback callbackSection, EnumerateRemoteModuleCallback callbackModule)
		{
			enumerateRemoteSectionsAndModulesDelegate(process, callbackSection, callbackModule);
		}

		public IntPtr OpenRemoteProcess(IntPtr pid, ProcessAccess desiredAccess)
		{
			return openRemoteProcessDelegate(pid, desiredAccess);
		}

		public bool IsProcessValid(IntPtr process)
		{
			return isProcessValidDelegate(process);
		}

		public void CloseRemoteProcess(IntPtr process)
		{
			closeRemoteProcessDelegate(process);
		}

		public bool ReadRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size)
		{
			return readRemoteMemoryDelegate(process, address, buffer, offset, size);
		}

		public bool WriteRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size)
		{
			return writeRemoteMemoryDelegate(process, address, buffer, offset, size);
		}

		public void ControlRemoteProcess(IntPtr process, ControlRemoteProcessAction action)
		{
			controlRemoteProcessDelegate(process, action);
		}

		public bool AttachDebuggerToProcess(IntPtr id)
		{
			return attachDebuggerToProcessDelegate(id);
		}

		public void DetachDebuggerFromProcess(IntPtr id)
		{
			detachDebuggerFromProcessDelegate(id);
		}

		public bool AwaitDebugEvent(ref DebugEvent evt, int timeoutInMilliseconds)
		{
			return awaitDebugEventDelegate(ref evt, timeoutInMilliseconds);
		}

		public void HandleDebugEvent(ref DebugEvent evt)
		{
			handleDebugEventDelegate(ref evt);
		}

		public bool SetHardwareBreakpoint(IntPtr id, IntPtr address, HardwareBreakpointRegister register, HardwareBreakpointTrigger trigger, HardwareBreakpointSize size, bool set)
		{
			return setHardwareBreakpointDelegate(id, address, register, trigger, size, set);
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/CustomNodeSerializer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.Logger;
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass
{
	public delegate BaseNode CreateNodeFromElementHandler(XElement element, BaseNode parent, ILogger logger);
	public delegate XElement CreateElementFromNodeHandler(BaseNode node, ILogger logger);

	[ContractClass(typeof(CustomNodeSerializerContract))]
	public interface ICustomNodeSerializer
	{
		/// <summary>Determine if the instance can handle the xml element.</summary>
		/// <param name="element">The xml element to check.</param>
		/// <returns>True if the instance can handle the element, false if not.</returns>
		bool CanHandleElement(XElement element);

		/// <summary>Determine if the instance can handle the node.</summary>
		/// <param name="node">The node to check.</param>
		/// <returns>True if the instance can handle the node, false if not.</returns>
		bool CanHandleNode(BaseNode node);

		/// <summary>Creates a node from the xml element. This method gets only called if <see cref="CanHandleElement(XElement)"/> returned true.</summary>
		/// <param name="element">The element to create the node from.</param>
		/// <param name="parent">The parent of the node.</param>
		/// <param name="classes">The list of classes which correspond to the node.</param>
		/// <param name="logger">The logger used to output messages.</param>
		/// <param name="defaultHandler">The default method which creates a node from an element. Should be called to resolve nodes for wrapped inner nodes.</param>
		/// <returns>The node for the xml element.</returns>
		BaseNode CreateNodeFromElement(XElement element, BaseNode parent, IEnumerable<ClassNode> classes, ILogger logger, CreateNodeFromElementHandler defaultHandler);

		/// <summary>Creates a xml element from the node. This method gets only called if <see cref="CanHandleNode(BaseNode)"/> returned true.</summary>
		/// <param name="node">The node to create the xml element from.</param>
		/// <param name="logger">The logger used to output messages.</param>
		/// <param name="defaultHandler">The default method which creates an element for a node. Should be called to resolve elements for wrapped inner nodes.</param>
		/// <returns>The xml element for the node.</returns>
		XElement CreateElementFromNode(BaseNode node, ILogger logger, CreateElementFromNodeHandler defaultHandler);
	}

	[ContractClassFor(typeof(ICustomNodeSerializer))]
	internal abstract class CustomNodeSerializerContract : ICustomNodeSerializer
	{
		public bool CanHandleElement(XElement element)
		{
			Contract.Requires(element != null);

			throw new NotImplementedException();
		}

		public bool CanHandleNode(BaseNode node)
		{
			Contract.Requires(node != null);

			throw new NotImplementedException();
		}

		public BaseNode CreateNodeFromElement(XElement element, BaseNode parent, IEnumerable<ClassNode> classes, ILogger logger, CreateNodeFromElementHandler defaultHandler)
		{
			Contract.Requires(element != null);
			Contract.Requires(CanHandleElement(element));
			Contract.Requires(parent != null);
			Contract.Requires(classes != null);
			Contract.Requires(Contract.ForAll(classes, c => c != null));
			Contract.Requires(logger != null);
			Contract.Requires(defaultHandler != null);

			throw new NotImplementedException();
		}

		public XElement CreateElementFromNode(BaseNode node, ILogger logger, CreateElementFromNodeHandler defaultHandler)
		{
			Contract.Requires(node != null);
			Contract.Requires(CanHandleNode(node));
			Contract.Requires(logger != null);
			Contract.Requires(defaultHandler != null);
			Contract.Ensures(Contract.Result<XElement>() != null);

			throw new NotImplementedException();
		}
	}

	internal class CustomNodeSerializer
	{
		private static readonly List<ICustomNodeSerializer> converters = new List<ICustomNodeSerializer>();

		public static void Add(ICustomNodeSerializer serializer)
		{
			Contract.Requires(serializer != null);

			converters.Add(serializer);
		}

		public static void Remove(ICustomNodeSerializer serializer)
		{
			Contract.Requires(serializer != null);

			converters.Remove(serializer);
		}

		public static ICustomNodeSerializer GetReadConverter(XElement element)
		{
			Contract.Requires(element != null);

			return converters.FirstOrDefault(c => c.CanHandleElement(element));
		}

		public static ICustomNodeSerializer GetWriteConverter(BaseNode node)
		{
			Contract.Requires(node != null);

			return converters.FirstOrDefault(c => c.CanHandleNode(node));
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/IReClassExport.cs`:

```cs
using System.Diagnostics.Contracts;
using System.IO;
using ReClassNET.Logger;

namespace ReClassNET.DataExchange.ReClass
{
	[ContractClass(typeof(ReClassExportContract))]
	public interface IReClassExport
	{
		void Save(string filePath, ILogger logger);

		void Save(Stream output, ILogger logger);
	}

	[ContractClassFor(typeof(IReClassExport))]
	internal abstract class ReClassExportContract : IReClassExport
	{
		public void Save(string filePath, ILogger logger)
		{
			Contract.Requires(filePath != null);
			Contract.Requires(logger != null);
		}

		public void Save(Stream output, ILogger logger)
		{
			Contract.Requires(output != null);
			Contract.Requires(logger != null);
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/IReClassImport.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using ReClassNET.Logger;

namespace ReClassNET.DataExchange.ReClass
{
	[ContractClass(typeof(ReClassImportContract))]
	public interface IReClassImport
	{
		void Load(string filePath, ILogger logger);
	}

	[ContractClassFor(typeof(IReClassImport))]
	internal abstract class ReClassImportContract : IReClassImport
	{
		public void Load(string filePath, ILogger logger)
		{
			Contract.Requires(filePath != null);
			Contract.Requires(logger != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/Legacy/BaseClassArrayNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass.Legacy
{
	public abstract class BaseClassArrayNode : BaseWrapperNode
	{
		public override int MemorySize => throw new NotImplementedException();

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			throw new NotImplementedException();
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			throw new NotImplementedException();
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			throw new NotImplementedException();
		}

		public override bool CanChangeInnerNodeTo(BaseNode node)
		{
			return node is ClassNode;
		}

		public abstract BaseNode GetEquivalentNode(int count, ClassNode classNode);
	}
}

```

`ReClass.NET/DataExchange/ReClass/Legacy/ClassInstanceArrayNode.cs`:

```cs
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass.Legacy
{
	public class ClassInstanceArrayNode : BaseClassArrayNode
	{
		protected override bool PerformCycleCheck => true;

		public override BaseNode GetEquivalentNode(int count, ClassNode classNode)
		{
			var classInstanceNode = new ClassInstanceNode();
			classInstanceNode.ChangeInnerNode(classNode);

			var arrayNode = new ArrayNode { Count = count };
			arrayNode.ChangeInnerNode(classInstanceNode);
			arrayNode.CopyFromNode(this);

			return arrayNode;
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/Legacy/ClassPointerArrayNode.cs`:

```cs
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass.Legacy
{
	public class ClassPointerArrayNode : BaseClassArrayNode
	{
		protected override bool PerformCycleCheck => false;

		public override BaseNode GetEquivalentNode(int count, ClassNode classNode)
		{
			var classInstanceNode = new ClassInstanceNode();
			classInstanceNode.ChangeInnerNode(classNode);

			var pointerNode = new PointerNode();
			pointerNode.ChangeInnerNode(classInstanceNode);

			var arrayNode = new ArrayNode { Count = count };
			arrayNode.ChangeInnerNode(pointerNode);
			arrayNode.CopyFromNode(this);

			return arrayNode;
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/Legacy/ClassPointerNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass.Legacy
{
	public class ClassPointerNode : BaseWrapperNode
	{
		public override int MemorySize => throw new NotImplementedException();

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			throw new NotImplementedException();
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			throw new NotImplementedException();
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			throw new NotImplementedException();
		}

		protected override bool PerformCycleCheck => false;

		public override bool CanChangeInnerNodeTo(BaseNode node)
		{
			return node is ClassNode;
		}

		public BaseNode GetEquivalentNode(ClassNode classNode)
		{
			var classInstanceNode = new ClassInstanceNode();
			classInstanceNode.ChangeInnerNode(classNode);

			var pointerNode = new PointerNode();
			pointerNode.ChangeInnerNode(classInstanceNode);
			pointerNode.CopyFromNode(this);

			return pointerNode;
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/Legacy/CustomNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Nodes;

namespace ReClassNET.DataExchange.ReClass.Legacy
{
	public class CustomNode : BaseNode
	{
		public override int MemorySize => throw new NotImplementedException();

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			throw new NotImplementedException();
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			throw new NotImplementedException();
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			throw new NotImplementedException();
		}

		public IEnumerable<BaseNode> GetEquivalentNodes(int size)
		{
			while (size != 0)
			{
				BaseNode paddingNode;
#if RECLASSNET64
				if (size >= 8)
				{
					paddingNode = new Hex64Node();
				}
				else
#endif
				if (size >= 4)
				{
					paddingNode = new Hex32Node();
				}
				else if (size >= 2)
				{
					paddingNode = new Hex16Node();
				}
				else
				{
					paddingNode = new Hex8Node();
				}

				paddingNode.Comment = Comment;

				size -= paddingNode.MemorySize;

				yield return paddingNode;
			}
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassClipboard.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Windows.Forms;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public class ReClassClipboard
	{
		/// <summary>The clipboard format string.</summary>
		private const string ClipboardFormat = "ReClass.NET::Nodes";

		/// <summary>Checks if ReClass.NET nodes are present in the clipboard.</summary>
		public static bool ContainsNodes => Clipboard.ContainsData(ClipboardFormat);

		/// <summary>Copies the nodes to the clipboard.</summary>
		/// <param name="nodes">The nodes to copy.</param>
		/// <param name="logger">The logger.</param>
		public static void Copy(IEnumerable<BaseNode> nodes, ILogger logger)
		{
			Contract.Requires(nodes != null);
			Contract.Requires(logger != null);

			using var ms = new MemoryStream();

			ReClassNetFile.SerializeNodesToStream(ms, nodes, logger);

			Clipboard.SetData(ClipboardFormat, ms.ToArray());
		}

		/// <summary>Pastes nodes from the clipboard.</summary>
		/// <param name="templateProject">The project to resolve class references.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>A list of <see cref="ClassNode"/> and <see cref="BaseNode"/>. If no data was present, both lists are empty.</returns>
		public static Tuple<List<ClassNode>, List<BaseNode>> Paste(ReClassNetProject templateProject, ILogger logger)
		{
			Contract.Requires(templateProject != null);
			Contract.Requires(logger != null);
			Contract.Ensures(Contract.Result<Tuple<List<ClassNode>, List<BaseNode>>>() != null);

			if (ContainsNodes && Clipboard.GetData(ClipboardFormat) is byte[] data)
			{
				using var ms = new MemoryStream(data);

				return ReClassNetFile.DeserializeNodesFromStream(ms, templateProject, logger);
			}

			return Tuple.Create(new List<ClassNode>(), new List<BaseNode>());
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.DataExchange.ReClass.Legacy;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public class ReClassFile : IReClassImport
	{
		public const string FormatName = "ReClass File";
		public const string FileExtension = ".reclass";

		private readonly ReClassNetProject project;

		public ReClassFile(ReClassNetProject project)
		{
			Contract.Requires(project != null);

			this.project = project;
		}

		public void Load(string filePath, ILogger logger)
		{
			var document = XDocument.Load(filePath);
			if (document.Root == null)
			{
				return;
			}

			Type[] typeMap = null;

			if (document.Root.FirstNode is XComment versionComment)
			{
				switch (versionComment.Value.Substring(0, 12).ToLower())
				{
					case "reclass 2011":
					case "reclass 2013":
						typeMap = typeMap2013;
						break;
					case "reclass 2015":
					case "reclass 2016":
						typeMap = typeMap2016;
						break;
					default:
						logger.Log(LogLevel.Warning, $"Unknown file version: {versionComment.Value}");
						logger.Log(LogLevel.Warning, "Defaulting to ReClass 2016.");

						typeMap = typeMap2016;
						break;
				}
			}

			var classes = new List<Tuple<XElement, ClassNode>>();

			foreach (var element in document.Root
				.Elements("Class")
				.DistinctBy(e => e.Attribute("Name")?.Value))
			{
				var node = new ClassNode(false)
				{
					Name = element.Attribute("Name")?.Value ?? string.Empty,
					AddressFormula = TransformAddressString(element.Attribute("strOffset")?.Value ?? string.Empty)
				};

				project.AddClass(node);

				classes.Add(Tuple.Create(element, node));
			}

			var classMap = classes.ToDictionary(t => t.Item2.Name, t => t.Item2);
			foreach (var (classElement, classNode) in classes)
			{
				ReadNodeElements(
					classElement.Elements("Node"),
					classNode,
					classMap,
					typeMap,
					logger
				).ForEach(classNode.AddNode);
			}
		}

		/// <summary>Parse ReClass address string and transform it into a ReClass.NET formula.</summary>
		/// <param name="address">The address string.</param>
		/// <returns>A string.</returns>
		private static string TransformAddressString(string address)
		{
			Contract.Requires(address != null);

			var parts = address.Split('+')
				.Select(s => s.Trim().ToLower().Replace("\"", string.Empty))
				.Where(s => s != string.Empty)
				.ToArray();

			for (var i = 0; i < parts.Length; ++i)
			{
				var part = parts[i];

				var isModule = part.Contains(".exe") || part.Contains(".dll");

				var isPointer = false;
				if (part.StartsWith("*"))
				{
					isPointer = true;
					part = part.Substring(1);
				}

				if (isModule)
				{
					part = $"<{part}>";
				}
				if (isPointer)
				{
					part = $"[{part}]";
				}

				parts[i] = part;
			}

			return string.Join(" + ", parts);
		}

		private IEnumerable<BaseNode> ReadNodeElements(IEnumerable<XElement> elements, ClassNode parent, IReadOnlyDictionary<string, ClassNode> classes, Type[] typeMap, ILogger logger)
		{
			Contract.Requires(elements != null);
			Contract.Requires(parent != null);
			Contract.Requires(classes != null);
			Contract.Requires(typeMap != null);
			Contract.Requires(logger != null);

			foreach (var element in elements)
			{
				Type nodeType = null;

				if (int.TryParse(element.Attribute("Type")?.Value, out var typeVal))
				{
					if (typeVal >= 0 && typeVal < typeMap.Length)
					{
						nodeType = typeMap[typeVal];
					}
				}

				if (nodeType == null)
				{
					logger.Log(LogLevel.Error, $"Skipping node with unknown type: {element.Attribute("Type")?.Value}");
					logger.Log(LogLevel.Warning, element.ToString());

					continue;
				}

				var node = BaseNode.CreateInstanceFromType(nodeType, false);
				if (node == null)
				{
					logger.Log(LogLevel.Error, $"Could not create node of type: {nodeType}");

					continue;
				}

				node.Name = element.Attribute("Name")?.Value ?? string.Empty;
				node.Comment = element.Attribute("Comment")?.Value ?? string.Empty;
				node.IsHidden = element.Attribute("bHidden")?.Value.Equals("1") ?? false;

				// Convert the Custom node into normal hex nodes.
				if (node is CustomNode customNode)
				{
					int.TryParse(element.Attribute("Size")?.Value, out var size);

					foreach (var paddingNode in customNode.GetEquivalentNodes(size))
					{
						yield return paddingNode;
					}

					continue;
				}

				// ClassInstanceNode, ClassPointerNode, ClassInstanceArrayNode, ClassPointerArrayNode
				if (node is BaseWrapperNode baseWrapperNode)
				{
					string reference;
					int arrayCount = 0;
					if (node is BaseClassArrayNode) // ClassInstanceArrayNode, ClassPointerArrayNode
					{
						reference = element.Element("Array")?.Attribute("Name")?.Value;

						if (node is ClassInstanceArrayNode)
						{
							TryGetAttributeValue(element, "Total", out arrayCount, logger);
						}
						else
						{
							TryGetAttributeValue(element, "Count", out arrayCount, logger);
						}
					}
					else // ClassInstanceNode, ClassPointerNode
					{
						reference = element.Attribute("Pointer")?.Value ?? element.Attribute("Instance")?.Value;
					}

					if (reference == null || !classes.ContainsKey(reference))
					{
						logger.Log(LogLevel.Error, $"Skipping node with unknown reference: {reference}");
						logger.Log(LogLevel.Warning, element.ToString());

						continue;
					}

					var innerClassNode = classes[reference];
					if (baseWrapperNode.ShouldPerformCycleCheckForInnerNode() && !ClassUtil.IsCyclicIfClassIsAccessibleFromParent(parent, innerClassNode, project.Classes))
					{
						logger.Log(LogLevel.Error, $"Skipping node with cycle reference: {parent.Name}->{node.Name}");

						continue;
					}

					// ClassPointerNode, ClassInstanceArrayNode and ClassPointerArrayNode need to be converted to supported nodes.
					if (node is BaseClassArrayNode classArrayNode) // ClassInstanceArrayNode, ClassPointerArrayNode
					{
						node = classArrayNode.GetEquivalentNode(arrayCount, innerClassNode);
					}
					else if (node is ClassPointerNode classPointerNode) // ClassPointerNode
					{
						node = classPointerNode.GetEquivalentNode(innerClassNode);
					}
					else // ClassInstanceNode, ClassPointerNode
					{
						baseWrapperNode.ChangeInnerNode(innerClassNode);
					}
				}

				switch (node)
				{
					case VirtualMethodTableNode vtableNode:
						element
							.Elements("Function")
							.Select(e => new VirtualMethodNode
							{
								Name = e.Attribute("Name")?.Value ?? string.Empty,
								Comment = e.Attribute("Comment")?.Value ?? string.Empty,
								IsHidden = e.Attribute("bHidden")?.Value.Equals("1") ?? false
							})
							.ForEach(vtableNode.AddNode);
						break;
					case BaseTextNode textNode:
					{
						TryGetAttributeValue(element, "Size", out var length, logger);
						textNode.Length = textNode is Utf16TextNode ? length / 2 : length;
						break;
					}
					case BitFieldNode bitFieldNode:
					{
						TryGetAttributeValue(element, "Size", out var bits, logger);
						bitFieldNode.Bits = bits * 8;
						break;
					}
				}

				yield return node;
			}
		}

		private static void TryGetAttributeValue(XElement element, string attribute, out int val, ILogger logger)
		{
			if (!int.TryParse(element.Attribute(attribute)?.Value, out val))
			{
				val = 0;

				logger.Log(LogLevel.Error, $"Node is missing a valid '{attribute}' attribute, defaulting to 0.");
				logger.Log(LogLevel.Warning, element.ToString());
			}
		}

		#region ReClass 2011 / ReClass 2013

		private static readonly Type[] typeMap2013 =
		{
			null,
			typeof(ClassInstanceNode),
			null,
			null,
			typeof(Hex32Node),
			typeof(Hex16Node),
			typeof(Hex8Node),
			typeof(ClassPointerNode),
			typeof(Int32Node),
			typeof(Int16Node),
			typeof(Int8Node),
			typeof(FloatNode),
			typeof(UInt32Node),
			typeof(UInt16Node),
			typeof(UInt8Node),
			typeof(Utf8TextNode),
			typeof(FunctionPtrNode),
			typeof(CustomNode),
			typeof(Vector2Node),
			typeof(Vector3Node),
			typeof(Vector4Node),
			typeof(Matrix4x4Node),
			typeof(VirtualMethodTableNode),
			typeof(ClassInstanceArrayNode),
			null,
			null,
			null,
			typeof(Int64Node),
			typeof(DoubleNode),
			typeof(Utf16TextNode),
			typeof(ClassPointerArrayNode)
		};

		#endregion

		#region ReClass 2015 / ReClass 2016

		private static readonly Type[] typeMap2016 =
		{
			null,
			typeof(ClassInstanceNode),
			null,
			null,
			typeof(Hex32Node),
			typeof(Hex64Node),
			typeof(Hex16Node),
			typeof(Hex8Node),
			typeof(ClassPointerNode),
			typeof(Int64Node),
			typeof(Int32Node),
			typeof(Int16Node),
			typeof(Int8Node),
			typeof(FloatNode),
			typeof(DoubleNode),
			typeof(UInt32Node),
			typeof(UInt16Node),
			typeof(UInt8Node),
			typeof(Utf8TextNode),
			typeof(Utf16TextNode),
			typeof(FunctionPtrNode),
			typeof(CustomNode),
			typeof(Vector2Node),
			typeof(Vector3Node),
			typeof(Vector4Node),
			typeof(Matrix4x4Node),
			typeof(VirtualMethodTableNode),
			typeof(ClassInstanceArrayNode),
			null,
			typeof(Utf8TextPtrNode),
			typeof(Utf16TextPtrNode),
			typeof(BitFieldNode),
			typeof(UInt64Node),
			typeof(FunctionNode)
		};

		#endregion
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassNetFile.Constants.cs`:

```cs
namespace ReClassNET.DataExchange.ReClass
{
	public partial class ReClassNetFile
	{
		public const string FormatName = "ReClass.NET File";
		public const string FileExtension = ".rcnet";
		public const string FileExtensionId = "rcnetfile";

		private const uint FileVersion = 0x00010001;
		private const uint FileVersionCriticalMask = 0xFFFF0000;

		private const string DataFileName = "Data.xml";

		private const string SerializationClassName = "__Serialization_Class__";

		public const string XmlRootElement = "reclass";
		public const string XmlCustomDataElement = "custom_data";
		public const string XmlTypeMappingElement = "type_mapping";
		public const string XmlEnumsElement = "enums";
		public const string XmlEnumElement = "enum";
		public const string XmlClassesElement = "classes";
		public const string XmlClassElement = "class";
		public const string XmlNodeElement = "node";
		public const string XmlMethodElement = "method";
		public const string XmlVersionAttribute = "version";
		public const string XmlPlatformAttribute = "type";
		public const string XmlUuidAttribute = "uuid";
		public const string XmlNameAttribute = "name";
		public const string XmlCommentAttribute = "comment";
		public const string XmlHiddenAttribute = "hidden";
		public const string XmlAddressAttribute = "address";
		public const string XmlTypeAttribute = "type";
		public const string XmlReferenceAttribute = "reference";
		public const string XmlCountAttribute = "count";
		public const string XmlBitsAttribute = "bits";
		public const string XmlLengthAttribute = "length";
		public const string XmlSizeAttribute = "size";
		public const string XmlSignatureAttribute = "signature";
		public const string XmlFlagsAttribute = "flags";
		public const string XmlItemElement = "item";
		public const string XmlValueAttribute = "value";
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassNetFile.Read.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.DataExchange.ReClass.Legacy;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public partial class ReClassNetFile
	{
		public void Load(string filePath, ILogger logger)
		{
			using var fs = new FileStream(filePath, FileMode.Open);

			Load(fs, logger);
		}

		public void Load(Stream input, ILogger logger)
		{
			Contract.Requires(input != null);
			Contract.Requires(logger != null);

			using var archive = new ZipArchive(input, ZipArchiveMode.Read);
			var dataEntry = archive.GetEntry(DataFileName);
			if (dataEntry == null)
			{
				throw new FormatException();
			}

			using var entryStream = dataEntry.Open();
			var document = XDocument.Load(entryStream);
			if (document.Root?.Element(XmlClassesElement) == null)
			{
				throw new FormatException("The data has not the correct format.");
			}

			uint.TryParse(document.Root.Attribute(XmlVersionAttribute)?.Value, out var fileVersion);
			if ((fileVersion & FileVersionCriticalMask) > (FileVersion & FileVersionCriticalMask))
			{
				throw new FormatException($"The file version is unsupported. A newer {Constants.ApplicationName} version is required to read it.");
			}

			var platform = document.Root.Attribute(XmlPlatformAttribute)?.Value;
			if (platform != Constants.Platform)
			{
				logger.Log(LogLevel.Warning, $"The platform of the file ({platform}) doesn't match the program platform ({Constants.Platform}).");
			}

			var customDataElement = document.Root.Element(XmlCustomDataElement);
			if (customDataElement != null)
			{
				project.CustomData.Deserialize(customDataElement);
			}

			var typeMappingElement = document.Root.Element(XmlTypeMappingElement);
			if (typeMappingElement != null)
			{
				project.TypeMapping.Deserialize(typeMappingElement);
			}

			var enumsElement = document.Root.Element(XmlEnumsElement);
			if (enumsElement != null)
			{
				foreach (var enumElement in enumsElement.Elements(XmlEnumElement))
				{
					var name = enumElement.Attribute(XmlNameAttribute)?.Value ?? string.Empty;
					var useFlagsMode = (bool?)enumElement.Attribute(XmlFlagsAttribute) ?? false;
					var size = enumElement.Attribute(XmlSizeAttribute).GetEnumValue<EnumDescription.UnderlyingTypeSize>();

					var values = new Dictionary<string, long>();
					foreach (var itemElement in enumElement.Elements(XmlItemElement))
					{
						var itemName = itemElement.Attribute(XmlNameAttribute)?.Value ?? string.Empty;
						var itemValue = (long?)itemElement.Attribute(XmlValueAttribute) ?? 0L;

						values.Add(itemName, itemValue);
					}

					var @enum = new EnumDescription
					{
						Name = name
					};
					@enum.SetData(useFlagsMode, size, values);

					project.AddEnum(@enum);
				}
			}

			var classes = new List<(XElement, ClassNode)>();

			var classesElement = document.Root.Element(XmlClassesElement);
			if (classesElement != null)
			{
				foreach (var element in classesElement
					.Elements(XmlClassElement)
					.DistinctBy(e => e.Attribute(XmlUuidAttribute)?.Value))
				{
					var node = new ClassNode(false)
					{
						Uuid = ParseUuid(element.Attribute(XmlUuidAttribute)?.Value),
						Name = element.Attribute(XmlNameAttribute)?.Value ?? string.Empty,
						Comment = element.Attribute(XmlCommentAttribute)?.Value ?? string.Empty,
						AddressFormula = element.Attribute(XmlAddressAttribute)?.Value ?? string.Empty
					};

					if (!project.ContainsClass(node.Uuid))
					{
						project.AddClass(node);

						classes.Add((element, node));
					}
				}
			}

			foreach (var (element, classNode) in classes)
			{
				var nodes = element.Elements(XmlNodeElement)
					.Select(e => CreateNodeFromElement(e, classNode, logger))
					.Where(n => n != null);

				classNode.BeginUpdate();
				classNode.AddNodes(nodes);
				classNode.EndUpdate();
			}
		}

		private BaseNode CreateNodeFromElement(XElement element, BaseNode parent, ILogger logger)
		{
			Contract.Requires(element != null);
			Contract.Requires(logger != null);

			BaseNode CreateNode()
			{
				var converter = CustomNodeSerializer.GetReadConverter(element);
				if (converter != null)
				{
					return converter.CreateNodeFromElement(element, parent, project.Classes, logger, CreateNodeFromElement);
				}

				if (!buildInStringToTypeMap.TryGetValue(element.Attribute(XmlTypeAttribute)?.Value ?? string.Empty, out var nodeType))
				{
					logger.Log(LogLevel.Error, $"Skipping node with unknown type: {element.Attribute(XmlTypeAttribute)?.Value}");
					logger.Log(LogLevel.Warning, element.ToString());

					return null;
				}

				return BaseNode.CreateInstanceFromType(nodeType, false);
			}

			var node = CreateNode();
			if (node == null)
			{
				logger.Log(LogLevel.Error, "Could not create node.");

				return null;
			}

			node.ParentNode = parent;

			node.Name = element.Attribute(XmlNameAttribute)?.Value ?? string.Empty;
			node.Comment = element.Attribute(XmlCommentAttribute)?.Value ?? string.Empty;
			node.IsHidden = bool.TryParse(element.Attribute(XmlHiddenAttribute)?.Value, out var val) && val;

			if (node is BaseWrapperNode wrapperNode)
			{
				ClassNode GetClassNodeFromElementReference()
				{
					var reference = ParseUuid(element.Attribute(XmlReferenceAttribute)?.Value);
					if (!project.ContainsClass(reference))
					{
						logger.Log(LogLevel.Error, $"Skipping node with unknown reference: {reference}");
						logger.Log(LogLevel.Warning, element.ToString());

						return null;
					}

					return project.GetClassByUuid(reference);
				}

				// Legacy Support
				if (node is ClassPointerNode || node is ClassInstanceArrayNode || node is ClassPointerArrayNode)
				{
					var innerClass = GetClassNodeFromElementReference();
					if (innerClass == null)
					{
						return null;
					}

					node = node switch
					{
						BaseClassArrayNode classArrayNode => classArrayNode.GetEquivalentNode(0, innerClass),
						ClassPointerNode classPointerNode => classPointerNode.GetEquivalentNode(innerClass)
					};
				}
				else
				{
					BaseNode innerNode = null;

					if (node is BaseClassWrapperNode)
					{
						innerNode = GetClassNodeFromElementReference();
						if (innerNode == null)
						{
							return null;
						}
					}
					else
					{
						var innerElement = element.Elements().FirstOrDefault();
						if (innerElement != null)
						{
							innerNode = CreateNodeFromElement(innerElement, node, logger);
						}
					}

					if (wrapperNode.CanChangeInnerNodeTo(innerNode))
					{
						var rootWrapperNode = node.GetRootWrapperNode();
						if (rootWrapperNode.ShouldPerformCycleCheckForInnerNode()
							&& innerNode is ClassNode classNode
							&& ClassUtil.IsCyclicIfClassIsAccessibleFromParent(node.GetParentClass(), classNode, project.Classes))
						{
							logger.Log(LogLevel.Error, $"Skipping node with cyclic class reference: {node.GetParentClass().Name}->{rootWrapperNode.Name}");

							return null;
						}

						wrapperNode.ChangeInnerNode(innerNode);
					}
					else
					{
						logger.Log(LogLevel.Error, $"The node {innerNode} is not a valid child for {node}.");
					}
				}
			}

			switch (node)
			{
				case VirtualMethodTableNode vtableNode:
				{
					var nodes = element
						.Elements(XmlMethodElement)
						.Select(e => new VirtualMethodNode
						{
							Name = e.Attribute(XmlNameAttribute)?.Value ?? string.Empty,
							Comment = e.Attribute(XmlCommentAttribute)?.Value ?? string.Empty,
							IsHidden = (bool?)e.Attribute(XmlHiddenAttribute) ?? false
						});

					vtableNode.AddNodes(nodes);
					break;
				}
				case UnionNode unionNode:
				{
					var nodes = element
						.Elements()
						.Select(e => CreateNodeFromElement(e, unionNode, logger));

					unionNode.AddNodes(nodes);
					break;
				}
				case BaseWrapperArrayNode arrayNode:
				{
					arrayNode.Count = (int?)element.Attribute(XmlCountAttribute) ?? 0;
					break;
				}
				case BaseTextNode textNode:
				{
					textNode.Length = (int?)element.Attribute(XmlLengthAttribute) ?? 0;
					break;
				}
				case BitFieldNode bitFieldNode:
				{
					bitFieldNode.Bits = (int?)element.Attribute(XmlBitsAttribute) ?? 0;
					break;
				}
				case FunctionNode functionNode:
				{
					functionNode.Signature = element.Attribute(XmlSignatureAttribute)?.Value ?? string.Empty;

					var reference = ParseUuid(element.Attribute(XmlReferenceAttribute)?.Value);
					if (project.ContainsClass(reference))
					{
						functionNode.BelongsToClass = project.GetClassByUuid(reference);
					}
					break;
				}
				case EnumNode enumNode:
				{
					var enumName = element.Attribute(XmlReferenceAttribute)?.Value ?? string.Empty;
					var @enum = project.Enums.FirstOrDefault(e => e.Name == enumName) ?? EnumDescription.Default;
					
					enumNode.ChangeEnum(@enum);
					break;
				}
			}

			return node;
		}

		private static Guid ParseUuid(string raw) => raw == null
				? throw new ArgumentNullException()
				: raw.Length == 24
					? new Guid(Convert.FromBase64String(raw))
					: Guid.Parse(raw);

		public static Tuple<List<ClassNode>, List<BaseNode>> DeserializeNodesFromStream(Stream input, ReClassNetProject templateProject, ILogger logger)
		{
			Contract.Requires(input != null);
			Contract.Requires(logger != null);
			Contract.Ensures(Contract.Result<Tuple<List<ClassNode>, List<BaseNode>>>() != null);

			using var project = new ReClassNetProject();
			templateProject?.Classes.ForEach(project.AddClass);

			var file = new ReClassNetFile(project);
			file.Load(input, logger);

			var classes = project.Classes
				.Where(c => c.Name != SerializationClassName);
			if (templateProject != null)
			{
				classes = classes.Where(c => !templateProject.ContainsClass(c.Uuid));
			}

			var nodes = project.Classes
				.Where(c => c.Name == SerializationClassName)
				.SelectMany(c => c.Nodes);

			return Tuple.Create(classes.ToList(), nodes.ToList());
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassNetFile.Write.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public partial class ReClassNetFile
	{
		public void Save(string filePath, ILogger logger)
		{
			using var fs = new FileStream(filePath, FileMode.Create);

			Save(fs, logger);
		}

		public void Save(Stream output, ILogger logger)
		{
			using var archive = new ZipArchive(output, ZipArchiveMode.Create);

			var dataEntry = archive.CreateEntry(DataFileName);
			using var entryStream = dataEntry.Open();

			var document = new XDocument(
				new XComment($"{Constants.ApplicationName} {Constants.ApplicationVersion} by {Constants.Author}"),
				new XComment($"Website: {Constants.HomepageUrl}"),
				new XElement(
					XmlRootElement,
					new XAttribute(XmlVersionAttribute, FileVersion),
					new XAttribute(XmlPlatformAttribute, Constants.Platform),
					project.CustomData.Serialize(XmlCustomDataElement),
					project.TypeMapping.Serialize(XmlTypeMappingElement),
					new XElement(XmlEnumsElement, CreateEnumElements(project.Enums)),
					new XElement(XmlClassesElement, CreateClassElements(project.Classes, logger))
				)
			);

			document.Save(entryStream);
		}

		private static IEnumerable<XElement> CreateEnumElements(IEnumerable<EnumDescription> enums)
		{
			return enums.Select(e => new XElement(
				XmlEnumElement,
				new XAttribute(XmlNameAttribute, e.Name),
				new XAttribute(XmlSizeAttribute, e.Size),
				new XAttribute(XmlFlagsAttribute, e.UseFlagsMode),
				e.Values.Select(kv => new XElement(
					XmlItemElement,
					new XAttribute(XmlNameAttribute, kv.Key),
					new XAttribute(XmlValueAttribute, kv.Value)
				))
			));
		}

		private static IEnumerable<XElement> CreateClassElements(IEnumerable<ClassNode> classes, ILogger logger)
		{
			Contract.Requires(classes != null);
			Contract.Requires(Contract.ForAll(classes, c => c != null));
			Contract.Requires(logger != null);
			Contract.Ensures(Contract.Result<IEnumerable<XElement>>() != null);

			return classes.Select(c => new XElement(
				XmlClassElement,
				new XAttribute(XmlUuidAttribute, c.Uuid),
				new XAttribute(XmlNameAttribute, c.Name ?? string.Empty),
				new XAttribute(XmlCommentAttribute, c.Comment ?? string.Empty),
				new XAttribute(XmlAddressAttribute, c.AddressFormula ?? string.Empty),
				c.Nodes.Select(n => CreateElementFromNode(n, logger)).Where(e => e != null)
			));
		}

		private static XElement CreateElementFromNode(BaseNode node, ILogger logger)
		{
			Contract.Requires(node != null);
			Contract.Requires(logger != null);

			XElement CreateElement()
			{
				var converter = CustomNodeSerializer.GetWriteConverter(node);
				if (converter != null)
				{
					return converter.CreateElementFromNode(node, logger, CreateElementFromNode);
				}

				if (!buildInTypeToStringMap.TryGetValue(node.GetType(), out var typeString))
				{
					logger.Log(LogLevel.Error, $"Skipping node with unknown type: {node.Name}");
					logger.Log(LogLevel.Warning, node.GetType().ToString());

					return null;
				}

				return new XElement(
					XmlNodeElement,
					new XAttribute(XmlTypeAttribute, typeString)
				);
			}

			var element = CreateElement();
			if (element == null)
			{
				logger.Log(LogLevel.Error, "Could not create element.");

				return null;
			}

			element.SetAttributeValue(XmlNameAttribute, node.Name ?? string.Empty);
			element.SetAttributeValue(XmlCommentAttribute, node.Comment ?? string.Empty);
			element.SetAttributeValue(XmlHiddenAttribute, node.IsHidden);

			if (node is BaseWrapperNode wrapperNode)
			{
				if (node is BaseClassWrapperNode classWrapperNode)
				{
					element.SetAttributeValue(XmlReferenceAttribute, ((ClassNode)classWrapperNode.InnerNode).Uuid);
				}
				else if (wrapperNode.InnerNode != null)
				{
					element.Add(CreateElementFromNode(wrapperNode.InnerNode, logger));
				}
			}

			switch (node)
			{
				case VirtualMethodTableNode vtableNode:
				{
					element.Add(vtableNode.Nodes.Select(n => new XElement(
						XmlMethodElement,
						new XAttribute(XmlNameAttribute, n.Name ?? string.Empty),
						new XAttribute(XmlCommentAttribute, n.Comment ?? string.Empty),
						new XAttribute(XmlHiddenAttribute, n.IsHidden)
					)));
					break;
				}
				case UnionNode unionNode:
				{
					element.Add(unionNode.Nodes.Select(n => CreateElementFromNode(n, logger)));
					break;
				}
				case BaseWrapperArrayNode arrayNode:
				{
					element.SetAttributeValue(XmlCountAttribute, arrayNode.Count);
					break;
				}
				case BaseTextNode textNode:
				{
					element.SetAttributeValue(XmlLengthAttribute, textNode.Length);
					break;
				}
				case BitFieldNode bitFieldNode:
				{
					element.SetAttributeValue(XmlBitsAttribute, bitFieldNode.Bits);
					break;
				}
				case FunctionNode functionNode:
				{
					var uuid = functionNode.BelongsToClass?.Uuid ?? Guid.Empty;
					element.SetAttributeValue(XmlReferenceAttribute, uuid);
					element.SetAttributeValue(XmlSignatureAttribute, functionNode.Signature);
					break;
				}
				case EnumNode enumNode:
				{
					element.SetAttributeValue(XmlReferenceAttribute, enumNode.Enum.Name);
					break;
				}
			}

			return element;
		}

		public static void SerializeNodesToStream(Stream output, IEnumerable<BaseNode> nodes, ILogger logger)
		{
			Contract.Requires(output != null);
			Contract.Requires(nodes != null);
			Contract.Requires(Contract.ForAll(nodes, n => n != null));
			Contract.Requires(logger != null);

			using var project = new ReClassNetProject();

			void RecursiveAddClasses(BaseNode node)
			{
				ClassNode classNode = null;
				switch (node)
				{
					case ClassNode c1:
						classNode = c1;
						break;
					case BaseWrapperNode wrapperNode when wrapperNode.ResolveMostInnerNode() is ClassNode c2:
						classNode = c2;
						break;
				}

				if (classNode == null || project.ContainsClass(classNode.Uuid))
				{
					return;
				}

				project.AddClass(classNode);

				foreach (var wrapperNodeChild in classNode.Nodes.OfType<BaseWrapperNode>())
				{
					RecursiveAddClasses(wrapperNodeChild);
				}
			}

			var serialisationClass = new ClassNode(false)
			{
				Name = SerializationClassName
			};

			var needsSerialisationClass = true;

			foreach (var node in nodes)
			{
				RecursiveAddClasses(node);

				if (!(node is ClassNode))
				{
					if (needsSerialisationClass)
					{
						needsSerialisationClass = false;

						project.AddClass(serialisationClass);
					}

					serialisationClass.AddNode(node);
				}
			}

			var file = new ReClassNetFile(project);
			file.Save(output, logger);
		}
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassNetFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using ReClassNET.DataExchange.ReClass.Legacy;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public partial class ReClassNetFile : IReClassImport, IReClassExport
	{
		private readonly ReClassNetProject project;

		public ReClassNetFile(ReClassNetProject project)
		{
			Contract.Requires(project != null);

			this.project = project;
		}

		static ReClassNetFile()
		{
			// Obsolete: The name of the class was changed. Because of this older versions can't load these nodes.
			buildInStringToTypeMap["UTF8TextNode"] = typeof(Utf8TextNode);
			buildInStringToTypeMap["UTF8TextPtrNode"] = typeof(Utf8TextPtrNode);
			buildInStringToTypeMap["UTF16TextNode"] = typeof(Utf16TextNode);
			buildInStringToTypeMap["UTF16TextPtrNode"] = typeof(Utf16TextPtrNode);
			buildInStringToTypeMap["UTF32TextNode"] = typeof(Utf32TextNode);
			buildInStringToTypeMap["UTF32TextPtrNode"] = typeof(Utf32TextPtrNode);
			buildInStringToTypeMap["VTableNode"] = typeof(VirtualMethodTableNode);

			// Legacy
			buildInStringToTypeMap["ClassInstanceArrayNode"] = typeof(ClassInstanceArrayNode);
			buildInStringToTypeMap["ClassPtrArrayNode"] = typeof(ClassPointerArrayNode);
			buildInStringToTypeMap["ClassPtrNode"] = typeof(ClassPointerNode);
		}

		private static readonly Dictionary<string, Type> buildInStringToTypeMap = new[]
		{
			typeof(BoolNode),
			typeof(BitFieldNode),
			typeof(EnumNode),
			typeof(ClassInstanceNode),
			typeof(DoubleNode),
			typeof(FloatNode),
			typeof(FunctionNode),
			typeof(FunctionPtrNode),
			typeof(Hex8Node),
			typeof(Hex16Node),
			typeof(Hex32Node),
			typeof(Hex64Node),
			typeof(Int8Node),
			typeof(Int16Node),
			typeof(Int32Node),
			typeof(Int64Node),
			typeof(NIntNode),
			typeof(Matrix3x3Node),
			typeof(Matrix3x4Node),
			typeof(Matrix4x4Node),
			typeof(UInt8Node),
			typeof(UInt16Node),
			typeof(UInt32Node),
			typeof(UInt64Node),
			typeof(NUIntNode),
			typeof(Utf8TextNode),
			typeof(Utf8TextPtrNode),
			typeof(Utf16TextNode),
			typeof(Utf16TextPtrNode),
			typeof(Utf32TextNode),
			typeof(Utf32TextPtrNode),
			typeof(Vector2Node),
			typeof(Vector3Node),
			typeof(Vector4Node),
			typeof(VirtualMethodTableNode),
			typeof(ArrayNode),
			typeof(PointerNode),
			typeof(UnionNode)
		}.ToDictionary(t => t.Name, t => t);

		private static readonly Dictionary<Type, string> buildInTypeToStringMap = buildInStringToTypeMap.ToDictionary(kv => kv.Value, kv => kv.Key);
	}
}

```

`ReClass.NET/DataExchange/ReClass/ReClassQtFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.DataExchange.ReClass.Legacy;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;

namespace ReClassNET.DataExchange.ReClass
{
	public class ReClassQtFile : IReClassImport
	{
		public const string FormatName = "ReClassQt File";
		public const string FileExtension = ".reclassqt";

		private readonly Type[] typeMap = {
			null,
			null,
			typeof(ClassPointerNode),
			typeof(ClassInstanceNode),
			typeof(Hex64Node),
			typeof(Hex32Node),
			typeof(Hex16Node),
			typeof(Hex8Node),
			typeof(Int64Node),
			typeof(Int32Node),
			typeof(Int16Node),
			typeof(Int8Node),
			typeof(UInt32Node),
			null,
			null,
			typeof(UInt32Node), //bool
			null,
			typeof(FloatNode),
			typeof(DoubleNode),
			typeof(Vector4Node),
			typeof(Vector3Node),
			typeof(Vector2Node)
		};

		private readonly ReClassNetProject project;

		public ReClassQtFile(ReClassNetProject project)
		{
			Contract.Requires(project != null);

			this.project = project;
		}

		public void Load(string filePath, ILogger logger)
		{
			var document = XDocument.Load(filePath);
			if (document.Root == null)
			{
				return;
			}

			var classes = new List<Tuple<XElement, ClassNode>>();

			foreach (var element in document.Root
				.Elements("Namespace")
				.SelectMany(ns => ns.Elements("Class"))
				.DistinctBy(e => e.Attribute("ClassId")?.Value))
			{
				var node = new ClassNode(false)
				{
					Name = element.Attribute("Name")?.Value ?? string.Empty,
					AddressFormula = ParseAddressString(element)
				};

				project.AddClass(node);

				classes.Add(Tuple.Create(element, node));
			}

			var classMap = classes.ToDictionary(c => c.Item1.Attribute("ClassId")?.Value, c => c.Item2);
			foreach (var (classElement, classNode) in classes)
			{
				ReadNodeElements(
					classElement.Elements("Node"),
					classNode,
					classMap,
					logger
				).ForEach(classNode.AddNode);
			}
		}

		/// <summary>Parse a ReClassQT address string and transform it into a ReClass.NET formula.</summary>
		/// <param name="element">The class element.</param>
		/// <returns>A string with an address formula.</returns>
		private static string ParseAddressString(XElement element)
		{
			Contract.Requires(element != null);

			var address = element.Attribute("Address")?.Value;
			if (string.IsNullOrEmpty(address))
			{
				return string.Empty;
			}

			if (element.Attribute("DerefTwice")?.Value == "1")
			{
				address = $"[{address}]";
			}

			return address;
		}

		private IEnumerable<BaseNode> ReadNodeElements(IEnumerable<XElement> elements, ClassNode parent, IReadOnlyDictionary<string, ClassNode> classes, ILogger logger)
		{
			Contract.Requires(elements != null);
			Contract.Requires(Contract.ForAll(elements, e => e != null));
			Contract.Requires(parent != null);
			Contract.Requires(logger != null);

			foreach (var element in elements)
			{
				Type nodeType = null;

				if (int.TryParse(element.Attribute("Type")?.Value, out var typeVal))
				{
					if (typeVal >= 0 && typeVal < typeMap.Length)
					{
						nodeType = typeMap[typeVal];
					}
				}

				if (nodeType == null)
				{
					logger.Log(LogLevel.Error, $"Skipping node with unknown type: {element.Attribute("Type")?.Value}");
					logger.Log(LogLevel.Warning, element.ToString());

					continue;
				}

				var node = BaseNode.CreateInstanceFromType(nodeType, false);
				if (node == null)
				{
					logger.Log(LogLevel.Error, $"Could not create node of type: {nodeType}");

					continue;
				}

				node.Name = element.Attribute("Name")?.Value ?? string.Empty;
				node.Comment = element.Attribute("Comments")?.Value ?? string.Empty;

				// ClassInstanceNode, ClassPointerNode
				if (node is BaseWrapperNode wrapperNode)
				{
					var pointToClassId = element.Attribute("PointToClass")?.Value;
					if (pointToClassId == null || !classes.ContainsKey(pointToClassId))
					{
						logger.Log(LogLevel.Error, $"Skipping node with unknown reference: {pointToClassId}");
						logger.Log(LogLevel.Warning, element.ToString());

						continue;
					}

					var innerClassNode = classes[pointToClassId];
					if (wrapperNode.ShouldPerformCycleCheckForInnerNode() && !ClassUtil.IsCyclicIfClassIsAccessibleFromParent(parent, innerClassNode, project.Classes))
					{
						logger.Log(LogLevel.Error, $"Skipping node with cycle reference: {parent.Name}->{node.Name}");

						continue;
					}

					if (node is ClassPointerNode classPointerNode)
					{
						node = classPointerNode.GetEquivalentNode(innerClassNode);
					}
					else // ClassInstanceNode
					{
						wrapperNode.ChangeInnerNode(innerClassNode);
					}
				}

				yield return node;
			}
		}
	}
}

```

`ReClass.NET/DataExchange/Scanner/CheatEngineFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml.Linq;
using ReClassNET.Logger;
using ReClassNET.MemoryScanner;

namespace ReClassNET.DataExchange.Scanner
{
	public class CheatEngineFile : IScannerImport
	{
		public const string FormatName = "Cheat Engine Tables";
		public const string FileExtension = ".ct";

		private const string Version26 = "26";

		public const string XmlVersionElement = "CheatEngineTableVersion";
		public const string XmlEntriesElement = "CheatEntries";
		public const string XmlEntryElement = "CheatEntry";
		public const string XmlDescriptionElement = "Description";
		public const string XmlValueTypeElement = "VariableType";
		public const string XmlAddressElement = "Address";
		public const string XmlUnicodeElement = "Unicode";
		public const string XmlLengthElement = "Length";

		public IEnumerable<MemoryRecord> Load(string filePath, ILogger logger)
		{
			using var stream = File.OpenRead(filePath);

			var document = XDocument.Load(stream);
			if (document.Root != null)
			{
				var version = document.Root.Attribute(XmlVersionElement)?.Value;
				if (string.Compare(version, Version26, StringComparison.Ordinal) >= 0)
				{
					var entries = document.Root.Element(XmlEntriesElement);
					if (entries != null)
					{
						foreach (var entry in entries.Elements(XmlEntryElement))
						{
							var description = entry.Element(XmlDescriptionElement)?.Value.Trim() ?? string.Empty;
							if (description == "\"No description\"")
							{
								description = string.Empty;
							}
							var variableTypeStr = entry.Element(XmlValueTypeElement)?.Value.Trim() ?? string.Empty;
							var valueType = Parse(variableTypeStr, logger);

							var record = new MemoryRecord
							{
								Description = description,
								ValueType = valueType
							};

							var addressStr = entry.Element(XmlAddressElement)?.Value.Trim() ?? string.Empty;
							var addressParts = addressStr.Split('+');
							if (addressParts.Length == 2)
							{
								long.TryParse(addressParts[1], NumberStyles.HexNumber, null, out var value);
								record.AddressOrOffset = (IntPtr)value;

								record.ModuleName = addressParts[0].Trim();
							}
							else
							{
								long.TryParse(addressStr, NumberStyles.HexNumber, null, out var value);
								record.AddressOrOffset = (IntPtr)value;
							}

							if (valueType == ScanValueType.ArrayOfBytes || valueType == ScanValueType.String)
							{
								var lengthStr = entry.Element(XmlLengthElement)?.Value ?? string.Empty;
								int.TryParse(lengthStr, NumberStyles.Integer, null, out var valueLength);

								record.ValueLength = Math.Max(1, valueLength);

								if (valueType == ScanValueType.String)
								{
									var isUnicode = (entry.Element(XmlUnicodeElement)?.Value ?? string.Empty) == "1";

									record.Encoding = isUnicode ? Encoding.Unicode : Encoding.UTF8;
								}
							}

							yield return record;
						}
					}
				}
			}
		}

		private static ScanValueType Parse(string value, ILogger logger)
		{
			switch (value)
			{
				case "Byte":
					return ScanValueType.Byte;
				case "2 Bytes":
					return ScanValueType.Short;
				case "4 Bytes":
					return ScanValueType.Integer;
				case "8 Bytes":
					return ScanValueType.Long;
				case "Float":
					return ScanValueType.Float;
				case "Double":
					return ScanValueType.Double;
				case "String":
					return ScanValueType.String;
				case "Array of byte":
					return ScanValueType.ArrayOfBytes;
				default:
					logger?.Log(LogLevel.Warning, $"Unknown value type: {value}");

					return ScanValueType.Integer;
			}
		}
	}
}

```

`ReClass.NET/DataExchange/Scanner/CrySearchFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Xml.Linq;
using ReClassNET.Logger;
using ReClassNET.MemoryScanner;

namespace ReClassNET.DataExchange.Scanner
{
	public class CrySearchFile : IScannerImport
	{
		public const string FormatName = "CrySearch Address Tables";
		public const string FileExtension = ".csat";

		private const string Version3 = "3.0";

		public const string XmlVersionElement = "CrySearchVersion";
		public const string XmlEntriesElement = "Entries";
		public const string XmlItemElement = "item";
		public const string XmlDescriptionElement = "Description";
		public const string XmlValueTypeElement = "ValueType";
		public const string XmlAddressElement = "Address";
		public const string XmlModuleNameElement = "ModuleName";
		public const string XmlIsRelativeElement = "IsRelative";
		public const string XmlSizeElement = "Size";

		public const string XmlValueAttribute = "value";

		public IEnumerable<MemoryRecord> Load(string filePath, ILogger logger)
		{
			var document = XDocument.Load(filePath);
			if (document.Root != null)
			{
				var version = document.Root.Element(XmlVersionElement)?.Value;
				if (string.Compare(version, Version3, StringComparison.Ordinal) >= 0)
				{
					var entries = document.Root.Element(XmlEntriesElement);
					if (entries != null)
					{
						foreach (var entry in entries.Elements(XmlItemElement))
						{
							var description = entry.Element(XmlDescriptionElement)?.Value.Trim() ?? string.Empty;
							var valueTypeStr = entry.Element(XmlValueTypeElement)?.Attribute(XmlValueAttribute)?.Value.Trim() ?? string.Empty;
							var addressStr = entry.Element(XmlAddressElement)?.Attribute(XmlValueAttribute)?.Value.Trim() ?? string.Empty;
							var moduleName = entry.Element(XmlModuleNameElement)?.Value.Trim() ?? string.Empty;

							long.TryParse(addressStr, NumberStyles.Number, null, out var value);
							var valueType = Parse(valueTypeStr, logger);

							var record = new MemoryRecord
							{
								AddressOrOffset = (IntPtr)value,
								Description = description,
								ValueType = valueType
							};

							if ((entry.Element(XmlIsRelativeElement)?.Attribute(XmlValueAttribute)?.Value.Trim() ?? string.Empty) == "1" && !string.IsNullOrEmpty(moduleName))
							{
								record.ModuleName = moduleName;
							}

							if (valueType == ScanValueType.ArrayOfBytes || valueType == ScanValueType.String)
							{
								var lengthStr = (entry.Element(XmlSizeElement)?.Attribute(XmlValueAttribute)?.Value.Trim() ?? string.Empty);
								int.TryParse(lengthStr, NumberStyles.Integer, null, out var valueLength);

								record.ValueLength = Math.Max(1, valueLength);

								if (valueType == ScanValueType.String)
								{
									switch (valueTypeStr)
									{
										default:
										// case "8":
											record.Encoding = Encoding.UTF8;
											break;
										case "9":
											record.Encoding = Encoding.Unicode;
											break;
									}
								}
							}

							yield return record;
						}
					}
				}
			}
		}

		private static ScanValueType Parse(string value, ILogger logger)
		{
			switch (value)
			{
				case "1":
					return ScanValueType.Byte;
				case "2":
					return ScanValueType.Short;
				case "3":
					return ScanValueType.Integer;
				case "4":
					return ScanValueType.Long;
				case "5":
					return ScanValueType.Float;
				case "6":
					return ScanValueType.Double;
				case "7":
					return ScanValueType.ArrayOfBytes;
				case "8":
				case "9":
					return ScanValueType.String;
				default:
					logger?.Log(LogLevel.Warning, $"Unknown value type: {value}");

					return ScanValueType.Integer;
			}
		}
	}
}

```

`ReClass.NET/DataExchange/Scanner/IScannerExport.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using ReClassNET.Logger;
using ReClassNET.MemoryScanner;

namespace ReClassNET.DataExchange.Scanner
{
	[ContractClass(typeof(ScannerExportContract))]
	public interface IScannerExport
	{
		void Save(IEnumerable<MemoryRecord> records, string filePath, ILogger logger);
	}

	[ContractClassFor(typeof(IScannerExport))]
	internal abstract class ScannerExportContract : IScannerExport
	{
		public void Save(IEnumerable<MemoryRecord> records, string filePath, ILogger logger)
		{
			Contract.Requires(records != null);
			Contract.Requires(filePath != null);
			Contract.Requires(logger != null);
		}
	}
}

```

`ReClass.NET/DataExchange/Scanner/IScannerImport.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using ReClassNET.Logger;
using ReClassNET.MemoryScanner;

namespace ReClassNET.DataExchange.Scanner
{
	[ContractClass(typeof(ScannerImportContract))]
	public interface IScannerImport
	{
		IEnumerable<MemoryRecord> Load(string filePath, ILogger logger);
	}

	[ContractClassFor(typeof(IScannerImport))]
	internal abstract class ScannerImportContract : IScannerImport
	{
		public IEnumerable<MemoryRecord> Load(string filePath, ILogger logger)
		{
			Contract.Requires(filePath != null);
			Contract.Requires(logger != null);
			Contract.Ensures(Contract.Result<IEnumerable<MemoryRecord>>() != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/DataExchange/Scanner/ReClassScanFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.MemoryScanner;

namespace ReClassNET.DataExchange.Scanner
{
	public class ReClassScanFile : IScannerImport, IScannerExport
	{
		public const string FormatName = "ReClass.NET Scanner File";
		public const string FileExtension = ".rcnetscan";

		private const string Version1 = "1";

		private const string DataFileName = "Data.xml";

		public const string XmlRootElement = "records";
		public const string XmlRecordElement = "record";

		public const string XmlVersionAttribute = "version";
		public const string XmlPlatformAttribute = "platform";
		public const string XmlValueTypeAttribute = "type";
		public const string XmlAddressAttribute = "address";
		public const string XmlModuleAttribute = "module";
		public const string XmlDescriptionAttribute = "description";
		public const string XmlValueLengthAttribute = "length";
		public const string XmlEncodingAttribute = "encoding";

		public IEnumerable<MemoryRecord> Load(string filePath, ILogger logger)
		{
			using var fs = new FileStream(filePath, FileMode.Open);
			using var archive = new ZipArchive(fs, ZipArchiveMode.Read);

			var dataEntry = archive.GetEntry(DataFileName);
			if (dataEntry == null)
			{
				throw new FormatException();
			}

			using var entryStream = dataEntry.Open();
			var document = XDocument.Load(entryStream);
			if (document.Root == null)
			{
				logger.Log(LogLevel.Error, "File has not the correct format.");
				yield break;
			}

			//var version = document.Root.Attribute(XmlVersionAttribute)?.Value;
			var platform = document.Root.Attribute(XmlPlatformAttribute)?.Value;
			if (platform != Constants.Platform)
			{
				logger.Log(LogLevel.Warning, $"The platform of the file ({platform}) doesn't match the program platform ({Constants.Platform}).");
			}

			foreach (var element in document.Root.Elements(XmlRecordElement))
			{
				var valueTypeStr = element.Attribute(XmlValueTypeAttribute)?.Value ?? string.Empty;

				if (!Enum.TryParse<ScanValueType>(valueTypeStr, out var valueType))
				{
					logger?.Log(LogLevel.Warning, $"Unknown value type: {valueTypeStr}");
					continue;
				}

				var description = element.Attribute(XmlDescriptionAttribute)?.Value ?? string.Empty;

				var addressStr = element.Attribute(XmlAddressAttribute)?.Value ?? string.Empty;
				var moduleName = element.Attribute(XmlModuleAttribute)?.Value ?? string.Empty;

				long.TryParse(addressStr, NumberStyles.HexNumber, null, out var address);

				var record = new MemoryRecord
				{
					Description = description,
					AddressOrOffset = (IntPtr)address,
					ValueType = valueType
				};

				if (!string.IsNullOrEmpty(moduleName))
				{
					record.ModuleName = moduleName;
				}

				if (valueType == ScanValueType.ArrayOfBytes || valueType == ScanValueType.String)
				{
					var lengthStr = element.Attribute(XmlValueLengthAttribute)?.Value ?? string.Empty;
					int.TryParse(lengthStr, NumberStyles.Integer, null, out var valueLength);

					record.ValueLength = Math.Max(1, valueLength);

					if (valueType == ScanValueType.String)
					{
						switch (element.Attribute(XmlEncodingAttribute)?.Value ?? string.Empty)
						{
							default:
								record.Encoding = Encoding.UTF8;
								break;
							case "UTF16":
								record.Encoding = Encoding.Unicode;
								break;
							case "UTF32":
								record.Encoding = Encoding.UTF32;
								break;
						}
					}
				}

				yield return record;
			}
		}

		public void Save(IEnumerable<MemoryRecord> records, string filePath, ILogger logger)
		{
			using var fs = new FileStream(filePath, FileMode.Create);
			using var archive = new ZipArchive(fs, ZipArchiveMode.Create);

			var dataEntry = archive.CreateEntry(DataFileName);
			using var entryStream = dataEntry.Open();

			var document = new XDocument(
				new XComment($"{Constants.ApplicationName} Scanner {Constants.ApplicationVersion} by {Constants.Author}"),
				new XComment($"Website: {Constants.HomepageUrl}"),
				new XElement(
					XmlRootElement,
					new XAttribute(XmlVersionAttribute, Version1),
					new XAttribute(XmlPlatformAttribute, Constants.Platform),
					records.Select(r =>
					{
						var temp = new XElement(
							XmlRecordElement,
							new XAttribute(XmlValueTypeAttribute, r.ValueType.ToString()),
							new XAttribute(XmlDescriptionAttribute, r.Description ?? string.Empty),
							new XAttribute(XmlAddressAttribute, r.AddressOrOffset.ToString(Constants.AddressHexFormat))
						);
						if (r.IsRelativeAddress)
						{
							temp.SetAttributeValue(XmlModuleAttribute, r.ModuleName);
						}
						if (r.ValueType == ScanValueType.ArrayOfBytes || r.ValueType == ScanValueType.String)
						{
							temp.SetAttributeValue(XmlValueLengthAttribute, r.ValueLength);
							if (r.ValueType == ScanValueType.String)
							{
								temp.SetAttributeValue(XmlEncodingAttribute, r.Encoding.IsSameCodePage(Encoding.UTF8) ? "UTF8" : r.Encoding.IsSameCodePage(Encoding.Unicode) ? "UTF16" : "UTF32");
							}
						}
						return temp;
					})
				)
			);

			document.Save(entryStream);
		}
	}
}

```

`ReClass.NET/Debugger/BreakpointAlreadySetException.cs`:

```cs
using System;
using System.Diagnostics.Contracts;

namespace ReClassNET.Debugger
{
	public class BreakpointAlreadySetException : Exception
	{
		public IBreakpoint Breakpoint { get; }

		public BreakpointAlreadySetException(IBreakpoint breakpoint)
			: base("This breakpoint is already set.")
		{
			Contract.Requires(breakpoint != null);

			Breakpoint = breakpoint;
		}
	}
}

```

`ReClass.NET/Debugger/DataExchange.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace ReClassNET.Debugger
{
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct ExceptionDebugInfo
	{
		public IntPtr ExceptionCode;
		public IntPtr ExceptionFlags;
		public IntPtr ExceptionAddress;

		public HardwareBreakpointRegister CausedBy;

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct RegisterInfo
		{
#if RECLASSNET64
			public IntPtr Rax;
			public IntPtr Rbx;
			public IntPtr Rcx;
			public IntPtr Rdx;
			public IntPtr Rdi;
			public IntPtr Rsi;
			public IntPtr Rsp;
			public IntPtr Rbp;
			public IntPtr Rip;

			public IntPtr R8;
			public IntPtr R9;
			public IntPtr R10;
			public IntPtr R11;
			public IntPtr R12;
			public IntPtr R13;
			public IntPtr R14;
			public IntPtr R15;
#else
			public IntPtr Eax;
			public IntPtr Ebx;
			public IntPtr Ecx;
			public IntPtr Edx;
			public IntPtr Edi;
			public IntPtr Esi;
			public IntPtr Esp;
			public IntPtr Ebp;
			public IntPtr Eip;
#endif
		};

		public RegisterInfo Registers;
	}

	public enum DebugContinueStatus
	{
		Handled,
		NotHandled
	}

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct DebugEvent
	{
		public DebugContinueStatus ContinueStatus;

		public IntPtr ProcessId;
		public IntPtr ThreadId;

		public ExceptionDebugInfo ExceptionInfo;
	}
}

```

`ReClass.NET/Debugger/HardwareBreakpoint.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using ReClassNET.Memory;

namespace ReClassNET.Debugger
{
	public enum HardwareBreakpointRegister
	{
		InvalidRegister,

		Dr0,
		Dr1,
		Dr2,
		Dr3
	}

	public enum HardwareBreakpointTrigger
	{
		Execute,
		Access,
		Write,
	}

	public enum HardwareBreakpointSize
	{
		Size1 = 1,
		Size2 = 2,
		Size4 = 4,
		Size8 = 8
	}

	public sealed class HardwareBreakpoint : IBreakpoint
	{
		public IntPtr Address { get; }
		public HardwareBreakpointRegister Register { get; }
		public HardwareBreakpointTrigger Trigger { get; }
		public HardwareBreakpointSize Size { get; }

		private readonly BreakpointHandler handler;

		public HardwareBreakpoint(IntPtr address, HardwareBreakpointRegister register, HardwareBreakpointTrigger trigger, HardwareBreakpointSize size, BreakpointHandler handler)
		{
			Contract.Requires(handler != null);

			if (register == HardwareBreakpointRegister.InvalidRegister)
			{
				throw new InvalidOperationException();
			}

			Address = address;
			Register = register;
			Trigger = trigger;
			Size = size;

			this.handler = handler;
		}

		public bool Set(RemoteProcess process)
		{
			return process.CoreFunctions.SetHardwareBreakpoint(process.UnderlayingProcess.Id, Address, Register, Trigger, Size, true);
		}

		public void Remove(RemoteProcess process)
		{
			process.CoreFunctions.SetHardwareBreakpoint(process.UnderlayingProcess.Id, Address, Register, Trigger, Size, false);
		}

		public void Handler(ref DebugEvent evt)
		{
			handler?.Invoke(this, ref evt);
		}

		public override bool Equals(object obj)
		{
			var hwbp = obj as HardwareBreakpoint;

			// Two hardware breakpoints are equal if they use the same register.
			return hwbp?.Register == Register;
		}

		public override int GetHashCode()
		{
			return Register.GetHashCode();
		}
	}
}

```

`ReClass.NET/Debugger/IBreakpoint.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using ReClassNET.Memory;

namespace ReClassNET.Debugger
{
	public delegate void BreakpointHandler(IBreakpoint breakpoint, ref DebugEvent evt);

	[ContractClass(typeof(BreakpointContract))]
	public interface IBreakpoint
	{
		IntPtr Address { get; }

		bool Set(RemoteProcess process);
		void Remove(RemoteProcess process);

		void Handler(ref DebugEvent evt);
	}

	[ContractClassFor(typeof(IBreakpoint))]
	internal abstract class BreakpointContract : IBreakpoint
	{
		public IntPtr Address => throw new NotImplementedException();

		public void Handler(ref DebugEvent evt)
		{
			throw new NotImplementedException();
		}

		public void Remove(RemoteProcess process)
		{
			Contract.Requires(process != null);

			throw new NotImplementedException();
		}

		public bool Set(RemoteProcess process)
		{
			Contract.Requires(process != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Debugger/NoHardwareBreakpointAvailableException.cs`:

```cs
using System;

namespace ReClassNET.Debugger
{
	public class NoHardwareBreakpointAvailableException : Exception
	{
		public NoHardwareBreakpointAvailableException()
			: base("All available hardware breakpoints are already set.")
		{

		}
	}
}

```

`ReClass.NET/Debugger/RemoteDebugger.Extensions.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Windows.Forms;

namespace ReClassNET.Debugger
{
	public static class RemoteDebuggerExtensions
	{
		public static bool AskUserAndAttachDebugger(this RemoteDebugger debugger)
		{
			Contract.Requires(debugger != null);

			return debugger.StartDebuggerIfNeeded(
				() => MessageBox.Show(
					"This will attach the debugger of ReClass.NET to the current process. Continue?",
					"Confirmation",
					MessageBoxButtons.YesNo,
					MessageBoxIcon.Question
				) == DialogResult.Yes
			);
		}
	}
}

```

`ReClass.NET/Debugger/RemoteDebugger.Handler.cs`:

```cs
namespace ReClassNET.Debugger
{
	public partial class RemoteDebugger
	{
		private void HandleExceptionEvent(ref DebugEvent evt)
		{
			lock (syncBreakpoint)
			{
				var causedBy = evt.ExceptionInfo.CausedBy;

				foreach (var bp in breakpoints)
				{
					if (bp is HardwareBreakpoint hwbp && hwbp.Register == causedBy)
					{
						hwbp.Handler(ref evt);

						break;
					}
				}
			}
		}
	}
}

```

`ReClass.NET/Debugger/RemoteDebugger.Thread.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Threading;

namespace ReClassNET.Debugger
{
	public partial class RemoteDebugger
	{
		private readonly object syncThread = new object();

		private Thread thread;

		private volatile bool running = true;
		private volatile bool isAttached;

		public bool IsAttached => isAttached;

		public bool StartDebuggerIfNeeded(Func<bool> queryAttach)
		{
			Contract.Requires(queryAttach != null);

			if (!process.IsValid)
			{
				return false;
			}

			lock (syncThread)
			{
				if (thread != null && IsAttached)
				{
					return true;
				}

				if (queryAttach())
				{
					thread = new Thread(Run)
					{
						IsBackground = true
					};
					thread.Start();

					return true;
				}
			}

			return false;
		}

		private void Run()
		{
			try
			{
				if (!process.CoreFunctions.AttachDebuggerToProcess(process.UnderlayingProcess.Id))
				{
					return;
				}

				isAttached = true;

				var evt = new DebugEvent();

				running = true;
				while (running)
				{
					if (process.CoreFunctions.AwaitDebugEvent(ref evt, 100))
					{
						evt.ContinueStatus = DebugContinueStatus.Handled;

						HandleExceptionEvent(ref evt);

						process.CoreFunctions.HandleDebugEvent(ref evt);
					}
					else
					{
						if (!process.IsValid)
						{
							Terminate(false);
						}
					}
				}

				process.CoreFunctions.DetachDebuggerFromProcess(process.UnderlayingProcess.Id);
			}
			finally
			{
				isAttached = false;
			}
		}

		public void Terminate()
		{
			Terminate(true);
		}

		private void Terminate(bool join)
		{
			lock (syncBreakpoint)
			{
				foreach (var bp in breakpoints)
				{
					bp.Remove(process);
				}
				breakpoints.Clear();
			}

			running = false;

			if (join)
			{
				lock (syncThread)
				{
					thread?.Join();
				}
			}
		}
	}
}

```

`ReClass.NET/Debugger/RemoteDebugger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using ReClassNET.Extensions;
using ReClassNET.Forms;
using ReClassNET.Memory;

namespace ReClassNET.Debugger
{
	public partial class RemoteDebugger
	{
		private readonly object syncBreakpoint = new object();

		private readonly RemoteProcess process;

		private readonly HashSet<IBreakpoint> breakpoints = new HashSet<IBreakpoint>();

		public RemoteDebugger(RemoteProcess process)
		{
			Contract.Requires(process != null);

			this.process = process;
		}

		public void AddBreakpoint(IBreakpoint breakpoint)
		{
			Contract.Requires(breakpoint != null);

			lock (syncBreakpoint)
			{
				if (!breakpoints.Add(breakpoint))
				{
					throw new BreakpointAlreadySetException(breakpoint);
				}

				breakpoint.Set(process);
			}
		}

		public void RemoveBreakpoint(IBreakpoint bp)
		{
			Contract.Requires(bp != null);

			lock (syncBreakpoint)
			{
				if (breakpoints.Remove(bp))
				{
					bp.Remove(process);
				}
			}
		}

		public void FindWhatAccessesAddress(IntPtr address, int size)
		{
			FindCodeByBreakpoint(address, size, HardwareBreakpointTrigger.Access);
		}

		public void FindWhatWritesToAddress(IntPtr address, int size)
		{
			FindCodeByBreakpoint(address, size, HardwareBreakpointTrigger.Write);
		}

		public void FindCodeByBreakpoint(IntPtr address, int size, HardwareBreakpointTrigger trigger)
		{
			var register = GetUsableDebugRegister();
			if (register == HardwareBreakpointRegister.InvalidRegister)
			{
				throw new NoHardwareBreakpointAvailableException();
			}

			var breakpointList = SplitBreakpoint(address, size);

			var fcf = new FoundCodeForm(process, breakpointList[0].Address, trigger);

			var localBreakpoints = new List<IBreakpoint>();
			fcf.Stop += (sender, e) =>
			{
				lock (localBreakpoints)
				{
					foreach (var bp in localBreakpoints)
					{
						RemoveBreakpoint(bp);
					}

					localBreakpoints.Clear();
				}
			};

			void HandleBreakpoint(IBreakpoint bp, ref DebugEvent evt)
			{
				fcf.AddRecord(evt.ExceptionInfo);
			}

			var breakpoint = new HardwareBreakpoint(breakpointList[0].Address, register, trigger, (HardwareBreakpointSize)breakpointList[0].Size, HandleBreakpoint);
			try
			{
				AddBreakpoint(breakpoint);
				localBreakpoints.Add(breakpoint);

				fcf.Show();
			}
			catch
			{
				fcf.Dispose();

				throw;
			}

			if (breakpointList.Count > 1)
			{
				foreach (var split in breakpointList.Skip(1))
				{
					register = GetUsableDebugRegister();
					if (register == HardwareBreakpointRegister.InvalidRegister)
					{
						break;
					}

					breakpoint = new HardwareBreakpoint(split.Address, register, trigger, (HardwareBreakpointSize)split.Size, HandleBreakpoint);
					AddBreakpoint(breakpoint);
					localBreakpoints.Add(breakpoint);
				}
			}
		}

		private List<BreakpointSplit> SplitBreakpoint(IntPtr address, int size)
		{
			var splits = new List<BreakpointSplit>();

			while (size > 0)
			{
#if RECLASSNET64
				if (size >= 8)
				{
					if (address.Mod(8) == 0)
					{
						splits.Add(new BreakpointSplit { Address = address, Size = 8 });

						address += 8;
						size -= 8;

						continue;
					}
				}
#endif
				if (size >= 4)
				{
					if (address.Mod(4) == 0)
					{
						splits.Add(new BreakpointSplit { Address = address, Size = 4 });

						address += 4;
						size -= 4;

						continue;
					}
				}
				if (size >= 2)
				{
					if (address.Mod(2) == 0)
					{
						splits.Add(new BreakpointSplit { Address = address, Size = 2 });

						address += 2;
						size -= 2;

						continue;
					}
				}

				splits.Add(new BreakpointSplit { Address = address, Size = 1 });

				address += 1;
				size -= 1;
			}

			return splits;
		}

		private HardwareBreakpointRegister GetUsableDebugRegister()
		{
			var all = new HashSet<HardwareBreakpointRegister>
			{
				HardwareBreakpointRegister.Dr0,
				HardwareBreakpointRegister.Dr1,
				HardwareBreakpointRegister.Dr2,
				HardwareBreakpointRegister.Dr3
			};

			lock (syncBreakpoint)
			{
				foreach (var bp in breakpoints)
				{
					if (bp is HardwareBreakpoint hwbp)
					{
						all.Remove(hwbp.Register);
					}
				}
			}

			if (all.Count > 0)
			{
				return all.First();
			}

			return HardwareBreakpointRegister.InvalidRegister;
		}
	}

	internal class BreakpointSplit
	{
		public IntPtr Address { get; set; }
		public int Size { get; set; }
	}
}

```

`ReClass.NET/Debugger/SoftwareBreakpoint.cs`:

```cs
using System;
using ReClassNET.Memory;
using System.Diagnostics.Contracts;

namespace ReClassNET.Debugger
{
	public sealed class SoftwareBreakpoint : IBreakpoint
	{
		public IntPtr Address { get; }

		private byte orig;

		private readonly BreakpointHandler handler;

		public SoftwareBreakpoint(IntPtr address, BreakpointHandler handler)
		{
			Contract.Requires(handler != null);

			Address = address;

			this.handler = handler;
		}

		public bool Set(RemoteProcess process)
		{
			var temp = new byte[1];
			if (!process.ReadRemoteMemoryIntoBuffer(Address, ref temp))
			{
				return false;
			}
			orig = temp[0];

			return process.WriteRemoteMemory(Address, new byte[] { 0xCC });
		}

		public void Remove(RemoteProcess process)
		{
			process.WriteRemoteMemory(Address, new[] { orig });
		}

		public void Handler(ref DebugEvent evt)
		{
			handler?.Invoke(this, ref evt);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is SoftwareBreakpoint bp))
			{
				return false;
			}

			return Address == bp.Address;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode();
		}
	}
}

```

`ReClass.NET/Extensions/BinaryReaderWriterExtensions.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.IO;

namespace ReClassNET.Extensions
{
	public static class BinaryReaderWriterExtension
	{
		public static IntPtr ReadIntPtr(this BinaryReader br)
		{
			Contract.Requires(br != null);

#if RECLASSNET64
			return (IntPtr)br.ReadInt64();
#else
			return (IntPtr)br.ReadInt32();
#endif
		}

		public static void Write(this BinaryWriter bw, IntPtr value)
		{
			Contract.Requires(bw != null);

#if RECLASSNET64
			bw.Write(value.ToInt64());
#else
			bw.Write(value.ToInt32());
#endif
		}
	}
}

```

`ReClass.NET/Extensions/ByteExtension.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace ReClassNET.Extensions
{
	public static class ByteExtension
	{
		/// <summary>
		/// Sets every element in the array to zero.
		/// </summary>
		/// <param name="array"></param>
		[DebuggerStepThrough]
		public static void FillWithZero(this byte[] array)
		{
			Contract.Requires(array != null);

			Array.Clear(array, 0, array.Length);
		}
	}
}

```

`ReClass.NET/Extensions/ColorExtensions.cs`:

```cs
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Drawing;

namespace ReClassNET.Extensions
{
	public static class ExtensionColor
	{
		[Pure]
		[DebuggerStepThrough]
		public static int ToRgb(this Color color)
		{
			return 0xFFFFFF & color.ToArgb();
		}

		[Pure]
		[DebuggerStepThrough]
		public static Color Invert(this Color color)
		{
			return Color.FromArgb(color.A, 255 - color.R, 255 - color.G, 255 - color.B);
		}
	}
}

```

`ReClass.NET/Extensions/DataGridViewExtensions.cs`:

```cs
using System.Collections.Generic;
using System.Windows.Forms;

namespace ReClassNET.Extensions
{
	public static class DataGridViewExtension
	{
		public static IEnumerable<DataGridViewRow> GetVisibleRows(this DataGridView dgv)
		{
			var visibleRowsCount = dgv.DisplayedRowCount(true);
			var firstVisibleRowIndex = dgv.FirstDisplayedCell?.RowIndex ?? 0;
			var lastVisibleRowIndex = firstVisibleRowIndex + visibleRowsCount - 1;
			for (var i = firstVisibleRowIndex; i <= lastVisibleRowIndex; i++)
			{
				yield return dgv.Rows[i];
			}
		}
	}
}

```

`ReClass.NET/Extensions/DictionaryExtensions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;

namespace ReClassNET.Extensions
{
	public static class DictionaryExtension
	{
		public static void RemoveWhere<TKey, TValue>(this IDictionary<TKey, TValue> source, Func<KeyValuePair<TKey, TValue>, bool> selector)
		{
			Contract.Requires(source != null);
			Contract.Requires(selector != null);

			foreach (var kv in source.Where(selector).ToList())
			{
				source.Remove(kv.Key);
			}
		}
	}
}

```

`ReClass.NET/Extensions/EncodingExtensions.cs`:

```cs
using System;
using System.Text;

namespace ReClassNET.Extensions
{
	public static class EncodingExtension
	{
		/// <summary>Gets the (perhaps wrong) byte count per character. Special characters may need more bytes.</summary>
		/// <param name="encoding">The encoding.</param>
		/// <returns>The byte count per character.</returns>
		public static int GuessByteCountPerChar(this Encoding encoding)
		{
			if (encoding.IsSameCodePage(Encoding.UTF8) || encoding.CodePage == 1252 /* Windows-1252 */ || encoding.IsSameCodePage(Encoding.ASCII))
			{
				return 1;
			}
			if (encoding.IsSameCodePage(Encoding.Unicode) || encoding.IsSameCodePage(Encoding.BigEndianUnicode))
			{
				return 2;
			}
			if (encoding.IsSameCodePage(Encoding.UTF32))
			{
				return 4;
			}

			throw new NotImplementedException();
		}

		/// <summary>
		/// Checks if the code page of both encodings is equal.
		/// </summary>
		/// <param name="encoding"></param>
		/// <param name="other"></param>
		/// <returns></returns>
		public static bool IsSameCodePage(this Encoding encoding, Encoding other)
		{
			return encoding.CodePage == other.CodePage;
		}
	}
}

```

`ReClass.NET/Extensions/EnumerableExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;

namespace ReClassNET.Extensions
{
	public static class EnumerableExtension
	{
		[DebuggerStepThrough]
		public static bool None<TSource>(this IEnumerable<TSource> source)
		{
			Contract.Requires(source != null);

			return !source.Any();
		}

		[DebuggerStepThrough]
		public static bool None<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			Contract.Requires(source != null);
			Contract.Requires(predicate != null);

			return !source.Any(predicate);
		}

		[DebuggerStepThrough]
		public static IEnumerable<TSource> WhereNot<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			Contract.Requires(source != null);
			Contract.Requires(predicate != null);

			return source.Where(item => predicate(item) == false);
		}

		[DebuggerStepThrough]
		public static int FindIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			Contract.Requires(source != null);
			Contract.Requires(predicate != null);
			Contract.Ensures(Contract.Result<int>() >= -1);

			var index = 0;
			foreach (var item in source)
			{
				if (predicate(item))
				{
					return index;
				}
				++index;
			}
			return -1;
		}

		[DebuggerStepThrough]
		public static void ForEach<TSource>(this IEnumerable<TSource> source, Action<TSource> func)
		{
			Contract.Requires(source != null);
			Contract.Requires(func != null);

			foreach (var item in source)
			{
				func(item);
			}
		}

		[DebuggerStepThrough]
		public static IEnumerable<TSource> Traverse<TSource>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TSource>> childSelector)
		{
			Contract.Requires(source != null);
			Contract.Requires(childSelector != null);
			Contract.Ensures(Contract.Result<IEnumerable<TSource>>() != null);

			var queue = new Queue<TSource>(source);
			while (queue.Count > 0)
			{
				var next = queue.Dequeue();

				yield return next;

				foreach (var child in childSelector(next))
				{
					queue.Enqueue(child);
				}
			}
		}

		[DebuggerStepThrough]
		public static IEnumerable<TSource> TakeWhileInclusive<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			Contract.Requires(source != null);
			Contract.Requires(predicate != null);
			Contract.Ensures(Contract.Result<IEnumerable<TSource>>() != null);

			foreach (var item in source)
			{
				yield return item;

				if (!predicate(item))
				{
					yield break;
				}
			}
		}

		[DebuggerStepThrough]
		public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			Contract.Requires(source != null);
			Contract.Requires(keySelector != null);
			Contract.Ensures(Contract.Result<IEnumerable<TSource>>() != null);

			var knownKeys = new HashSet<TKey>();
			foreach (var element in source)
			{
				if (knownKeys.Add(keySelector(element)))
				{
					yield return element;
				}
			}
		}

		[DebuggerStepThrough]
		public static bool IsEquivalentTo<T>(this IEnumerable<T> source, IEnumerable<T> other)
		{
			Contract.Requires(source != null);
			Contract.Requires(other != null);

			var expected = new List<T>(source);

			if (other.Any(item => !expected.Remove(item)))
			{
				return false;
			}

			return expected.Count == 0;
		}

		/// <summary>
		/// Scans the source and returns the first element where the predicate matches.
		/// If the predicate doesn't match the first element of the source is returned.
		/// </summary>
		/// <param name="source"></param>
		/// <param name="predicate"></param>
		/// <returns></returns>
		public static TSource PredicateOrFirst<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			Contract.Requires(source != null);
			Contract.Requires(predicate != null);

			var result = default(TSource);
			var first = true;
			foreach (var element in source)
			{
				if (predicate(element))
				{
					return element;
				}
				if (first)
				{
					result = element;
					first = false;
				}
			}

			if (first)
			{
				throw new InvalidOperationException("Sequence contains no elements");
			}

			return result;
		}

		public static IEnumerable<IEnumerable<T>> GroupWhile<T>(this IEnumerable<T> source, Func<T, T, bool> condition)
		{
			Contract.Requires(source != null);
			Contract.Requires(condition != null);

			using var it = source.GetEnumerator();
			if (it.MoveNext())
			{
				var previous = it.Current;
				var list = new List<T> { previous };

				while (it.MoveNext())
				{
					var item = it.Current;

					if (condition(previous, item) == false)
					{
						yield return list;

						list = new List<T>();
					}

					list.Add(item);

					previous = item;
				}

				yield return list;
			}
		}
	}
}

```

`ReClass.NET/Extensions/FloatingPointExtensions.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace ReClassNET.Extensions
{
	public static class FloatingPointExtension
	{
		[Pure]
		[DebuggerStepThrough]
		public static bool IsNearlyEqual(this float val, float other, float epsilon)
		{
			if (val == other)
			{
				return true;
			}

			return Math.Abs(val - other) <= epsilon;
		}

		[Pure]
		[DebuggerStepThrough]
		public static bool IsNearlyEqual(this double val, double other, double epsilon)
		{
			if (val == other)
			{
				return true;
			}

			return Math.Abs(val - other) <= epsilon;
		}
	}
}

```

`ReClass.NET/Extensions/GraphicsExtensions.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace ReClassNET.Extensions
{
	public static class GraphicsExtension
	{
		/// <summary>
		/// Use GDI to render normal text because GDI+ doesn't work nicely with long texts and the custom width calculation.
		/// But GDI is simple, there is no custom rendering (rotation, scale, ...). So the BitFieldNode uses GDI+ for rendering.
		/// </summary>
		/// <param name="g">The graphics context.</param>
		/// <param name="text">The text to render.</param>
		/// <param name="font">The font to use.</param>
		/// <param name="color">The color to use.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		public static void DrawStringEx(this Graphics g, string text, Font font, Color color, int x, int y)
		{
			TextRenderer.DrawText(g, text, font, new Point(x, y), color);
		}
	}
}

```

`ReClass.NET/Extensions/IRemoteMemoryReaderExtension.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Text;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner;

namespace ReClassNET.Extensions
{
	public static class IRemoteMemoryReaderExtension
	{
		public static sbyte ReadRemoteInt8(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(sbyte));

			return (sbyte)data[0];
		}

		public static byte ReadRemoteUInt8(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(byte));

			return data[0];
		}

		public static short ReadRemoteInt16(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(short));

			return reader.BitConverter.ToInt16(data, 0);
		}

		public static ushort ReadRemoteUInt16(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(ushort));

			return reader.BitConverter.ToUInt16(data, 0);
		}

		public static int ReadRemoteInt32(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(int));

			return reader.BitConverter.ToInt32(data, 0);
		}

		public static uint ReadRemoteUInt32(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(uint));

			return reader.BitConverter.ToUInt32(data, 0);
		}

		public static long ReadRemoteInt64(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(long));

			return reader.BitConverter.ToInt64(data, 0);
		}

		public static ulong ReadRemoteUInt64(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(ulong));

			return reader.BitConverter.ToUInt64(data, 0);
		}

		public static float ReadRemoteFloat(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(float));

			return reader.BitConverter.ToSingle(data, 0);
		}

		public static double ReadRemoteDouble(this IRemoteMemoryReader reader, IntPtr address)
		{
			var data = reader.ReadRemoteMemory(address, sizeof(double));

			return reader.BitConverter.ToDouble(data, 0);
		}

		public static IntPtr ReadRemoteIntPtr(this IRemoteMemoryReader reader, IntPtr address)
		{
#if RECLASSNET64
			return (IntPtr)reader.ReadRemoteInt64(address);
#else
			return (IntPtr)reader.ReadRemoteInt32(address);
#endif
		}

		public static string ReadRemoteString(this IRemoteMemoryReader reader, IntPtr address, Encoding encoding, int length)
		{
			Contract.Requires(encoding != null);
			Contract.Requires(length >= 0);
			Contract.Ensures(Contract.Result<string>() != null);

			var data = reader.ReadRemoteMemory(address, length * encoding.GuessByteCountPerChar());

			try
			{
				var sb = new StringBuilder(encoding.GetString(data));
				for (var i = 0; i < sb.Length; ++i)
				{
					if (sb[i] == '\0')
					{
						sb.Length = i;
						break;
					}
					if (!sb[i].IsPrintable())
					{
						sb[i] = '.';
					}
				}
				return sb.ToString();
			}
			catch
			{
				return string.Empty;
			}
		}

		public static string ReadRemoteStringUntilFirstNullCharacter(this IRemoteMemoryReader reader, IntPtr address, Encoding encoding, int length)
		{
			Contract.Requires(encoding != null);
			Contract.Requires(length >= 0);
			Contract.Ensures(Contract.Result<string>() != null);

			var data = reader.ReadRemoteMemory(address, length * encoding.GuessByteCountPerChar());

			// TODO We should cache the pattern per encoding.
			var index = PatternScanner.FindPattern(BytePattern.From(new byte[encoding.GuessByteCountPerChar()]), data);
			if (index == -1)
			{
				index = data.Length;
			}

			try
			{
				return encoding.GetString(data, 0, Math.Min(index, data.Length));
			}
			catch
			{
				return string.Empty;
			}
		}
	}
}

```

`ReClass.NET/Extensions/IRemoteMemoryWriterExtension.cs`:

```cs
using System;
using System.Text;
using ReClassNET.Memory;

namespace ReClassNET.Extensions
{
	public static class IRemoteMemoryWriterExtension
	{
		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, sbyte value) => writer.WriteRemoteMemory(address, new[] { (byte)value });

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, byte value) => writer.WriteRemoteMemory(address, new[] { value });

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, short value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, ushort value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, int value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, uint value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, long value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, ulong value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, float value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, double value) => writer.WriteRemoteMemory(address, writer.BitConverter.GetBytes(value));

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, IntPtr value)
		{
#if RECLASSNET64
			writer.WriteRemoteMemory(address, value.ToInt64());
#else
			writer.WriteRemoteMemory(address, value.ToInt32());
#endif
		}

		public static void WriteRemoteMemory(this IRemoteMemoryWriter writer, IntPtr address, string value, Encoding encoding) => writer.WriteRemoteMemory(address, encoding.GetBytes(value));
	}
}

```

`ReClass.NET/Extensions/IntPtrExtensions.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace ReClassNET.Extensions
{
	public static class IntPtrExtension
	{
		[Pure]
		[DebuggerStepThrough]
		public static bool IsNull(this IntPtr ptr)
		{
			return ptr == IntPtr.Zero;
		}

		[Pure]
		[DebuggerStepThrough]
		public static bool MayBeValid(this IntPtr ptr)
		{
#if RECLASSNET64
			return ptr.IsInRange((IntPtr)0x10000, (IntPtr)long.MaxValue);
#else
			return ptr.IsInRange((IntPtr)0x10000, (IntPtr)int.MaxValue);
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr Add(this IntPtr lhs, IntPtr rhs)
		{
#if RECLASSNET64
			return new IntPtr(lhs.ToInt64() + rhs.ToInt64());
#else
			return new IntPtr(lhs.ToInt32() + rhs.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr Sub(this IntPtr lhs, IntPtr rhs)
		{
#if RECLASSNET64
			return new IntPtr(lhs.ToInt64() - rhs.ToInt64());
#else
			return new IntPtr(lhs.ToInt32() - rhs.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr Mul(this IntPtr lhs, IntPtr rhs)
		{
#if RECLASSNET64
			return new IntPtr(lhs.ToInt64() * rhs.ToInt64());
#else
			return new IntPtr(lhs.ToInt32() * rhs.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr Div(this IntPtr lhs, IntPtr rhs)
		{
			Contract.Requires(!rhs.IsNull());

#if RECLASSNET64
			return new IntPtr(lhs.ToInt64() / rhs.ToInt64());
#else
			return new IntPtr(lhs.ToInt32() / rhs.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static int Mod(this IntPtr lhs, int mod)
		{
#if RECLASSNET64
			return (int)(lhs.ToInt64() % mod);
#else
			return lhs.ToInt32() % mod;
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr Negate(this IntPtr ptr)
		{
#if RECLASSNET64
			return new IntPtr(-ptr.ToInt64());
#else
			return new IntPtr(-ptr.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static bool IsInRange(this IntPtr address, IntPtr start, IntPtr end)
		{
#if RECLASSNET64
			var val = (ulong)address.ToInt64();
			return (ulong)start.ToInt64() <= val && val <= (ulong)end.ToInt64();
#else
			var val = (uint)address.ToInt32();
			return (uint)start.ToInt32() <= val && val <= (uint)end.ToInt32();
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static int CompareTo(this IntPtr lhs, IntPtr rhs)
		{
#if RECLASSNET64
			return ((ulong)lhs.ToInt64()).CompareTo((ulong)rhs.ToInt64());
#else
			return ((uint)lhs.ToInt32()).CompareTo((uint)rhs.ToInt32());
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static int CompareToRange(this IntPtr address, IntPtr start, IntPtr end)
		{
			if (IsInRange(address, start, end))
			{
				return 0;
			}
			return CompareTo(address, start);
		}

		/// <summary>
		/// Changes the behaviour of ToInt64 in x86 mode.
		/// IntPtr(int.MaxValue + 1) = (int)0x80000000 (-2147483648) = (long)0xFFFFFFFF80000000
		/// This method converts the value to (long)0x0000000080000000 (2147483648).
		/// </summary>
		/// <param name="ptr"></param>
		/// <returns></returns>
		[Pure]
		[DebuggerStepThrough]
		public static long ToInt64Bits(this IntPtr ptr)
		{
#if RECLASSNET64
			return ptr.ToInt64();
#else
			var value = ptr.ToInt64();

			if (value < 0)
			{
				var intValue = ptr.ToInt32();
				if (value == intValue)
				{
					value = intValue & 0xFFFFFFFFL;
				}
			}

			return value;
#endif
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr From(int value)
		{
			return (IntPtr)value;
		}

		[Pure]
		[DebuggerStepThrough]
		public static IntPtr From(long value)
		{
#if RECLASSNET64
			return (IntPtr)value;
#else
			return (IntPtr)unchecked((int)value);
#endif
		}
	}
}

```

`ReClass.NET/Extensions/ListExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace ReClassNET.Extensions
{
	public static class ListExtension
	{
		/// <summary>
		/// Searches a range of elements in the sorted list for an element using the specified comparer and returns the zero-based index of the element.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="source"></param>
		/// <param name="comparer">The comparer to use</param>
		/// <returns>The zero-based index in the sorted list, if an item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger or, if there is no larger element, the bitwise complement of <see cref="IList{T}.Count"/>.</returns>
		[Pure]
		[DebuggerStepThrough]
		public static int BinarySearch<T>(this IList<T> source, Func<T, int> comparer)
		{
			Contract.Requires(source != null);
			Contract.Requires(comparer != null);

			var lo = 0;
			var hi = source.Count - 1;

			while (lo <= hi)
			{
				var i = lo + (hi - lo >> 1);

				var order = comparer(source[i]);
				if (order == 0)
				{
					return i;
				}
				if (order > 0)
				{
					lo = i + 1;
				}
				else
				{
					hi = i - 1;
				}
			}

			return ~lo;
		}
	}
}

```

`ReClass.NET/Extensions/PointExtension.cs`:

```cs
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Drawing;

namespace ReClassNET.Extensions
{
	public static class PointExtension
	{
		/// <summary>
		/// Creates a new point which is relocated with the given offsets.
		/// </summary>
		/// <param name="point"></param>
		/// <param name="offsetX">The offset in x direction.</param>
		/// <param name="offsetY">The offset in y direction.</param>
		/// <returns>The relocated point.</returns>
		[Pure]
		[DebuggerStepThrough]
		public static Point Relocate(this Point point, int offsetX, int offsetY)
		{
			return new Point(point.X + offsetX, point.Y + offsetY);
		}
	}
}

```

`ReClass.NET/Extensions/RichTextBoxExtensions.cs`:

```cs
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace ReClassNET.Extensions
{
	public static class RichTextBoxExtension
	{
		public static void SetInnerMargin(this TextBoxBase textBox, int left, int top, int right, int bottom)
		{
			var rect = textBox.GetFormattingRect();

			var newRect = new Rectangle(left, top, rect.Width - left - right, rect.Height - top - bottom);
			textBox.SetFormattingRect(newRect);
		}

		[StructLayout(LayoutKind.Sequential)]
		private readonly struct RECT
		{
			public readonly int Left;
			public readonly int Top;
			public readonly int Right;
			public readonly int Bottom;

			private RECT(int left, int top, int right, int bottom)
			{
				Left = left;
				Top = top;
				Right = right;
				Bottom = bottom;
			}

			public RECT(Rectangle r)
				: this(r.Left, r.Top, r.Right, r.Bottom)
			{
			}
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		private static extern int SendMessage(IntPtr hWnd, uint msg, int wParam, ref RECT rect);

		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		private static extern int SendMessage(IntPtr hwnd, int wMsg, IntPtr wParam, ref Rectangle lParam);

		private const int EmGetrect = 0xB2;
		private const int EmSetrect = 0xB3;

		private static void SetFormattingRect(this TextBoxBase textbox, Rectangle rect)
		{
			var rc = new RECT(rect);
			SendMessage(textbox.Handle, EmSetrect, 0, ref rc);
		}

		private static Rectangle GetFormattingRect(this TextBoxBase textbox)
		{
			var rect = new Rectangle();
			SendMessage(textbox.Handle, EmGetrect, (IntPtr)0, ref rect);
			return rect;
		}
	}
}

```

`ReClass.NET/Extensions/StringBuilderExtensions.cs`:

```cs
using System.Text;

namespace ReClassNET.Extensions
{
	public static class StringBuilderExtensions
	{
		public static StringBuilder Prepend(this StringBuilder sb, char value)
		{
			return sb.Insert(0, value);
		}

		public static StringBuilder Prepend(this StringBuilder sb, string value)
		{
			return sb.Insert(0, value);
		}
	}
}

```

`ReClass.NET/Extensions/StringReaderExtensions.cs`:

```cs
using System.IO;

namespace ReClassNET.Extensions
{
	public static class StringReaderExtension
	{
		public static int ReadSkipWhitespaces(this StringReader sr)
		{
			while (true)
			{
				var i = sr.Read();
				if (i == -1)
				{
					return i;
				}

				if (!char.IsWhiteSpace((char)i))
				{
					return i;
				}
			}
		}
	}
}

```

`ReClass.NET/Extensions/XAttributeExtensions.cs`:

```cs
using System;
using System.Xml.Linq;

namespace ReClassNET.Extensions
{
	public static class XAttributeExtensions
	{
		public static TEnum GetEnumValue<TEnum>(this XAttribute attribute) where TEnum : struct
		{
			TEnum @enum = default;
			if (attribute != null)
			{
				Enum.TryParse(attribute.Value, out @enum);
			}
			return @enum;
		}
	}
}

```

`ReClass.NET/Forms/AboutForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class AboutForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutForm));
			this.bannerBox = new BannerBox();
			this.infoLabel = new System.Windows.Forms.Label();
			this.platformLabel = new System.Windows.Forms.Label();
			this.buildTimeLabel = new System.Windows.Forms.Label();
			this.authorLabel = new System.Windows.Forms.Label();
			this.homepageLabel = new System.Windows.Forms.Label();
			this.platformValueLabel = new System.Windows.Forms.Label();
			this.buildTimeValueLabel = new System.Windows.Forms.Label();
			this.authorValueLabel = new System.Windows.Forms.Label();
			this.homepageValueLabel = new System.Windows.Forms.LinkLabel();
			this.licenseGroupBox = new System.Windows.Forms.GroupBox();
			this.licenseTextBox = new System.Windows.Forms.TextBox();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.licenseGroupBox.SuspendLayout();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = null;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(409, 48);
			this.bannerBox.TabIndex = 0;
			this.bannerBox.Title = "";
			// 
			// infoLabel
			// 
			this.infoLabel.AutoSize = true;
			this.infoLabel.Location = new System.Drawing.Point(12, 140);
			this.infoLabel.Name = "infoLabel";
			this.infoLabel.Size = new System.Drawing.Size(333, 26);
			this.infoLabel.TabIndex = 1;
			this.infoLabel.Text = "This is a port of ReClass to the .NET platform with additional features.\r\nReClass" +
    " was originally written by DrUnKeN ChEeTaH.";
			// 
			// platformLabel
			// 
			this.platformLabel.AutoSize = true;
			this.platformLabel.Location = new System.Drawing.Point(12, 60);
			this.platformLabel.Name = "platformLabel";
			this.platformLabel.Size = new System.Drawing.Size(51, 13);
			this.platformLabel.TabIndex = 2;
			this.platformLabel.Text = "Platform: ";
			// 
			// buildTimeLabel
			// 
			this.buildTimeLabel.AutoSize = true;
			this.buildTimeLabel.Location = new System.Drawing.Point(12, 79);
			this.buildTimeLabel.Name = "buildTimeLabel";
			this.buildTimeLabel.Size = new System.Drawing.Size(58, 13);
			this.buildTimeLabel.TabIndex = 3;
			this.buildTimeLabel.Text = "Build time: ";
			// 
			// authorLabel
			// 
			this.authorLabel.AutoSize = true;
			this.authorLabel.Location = new System.Drawing.Point(12, 98);
			this.authorLabel.Name = "authorLabel";
			this.authorLabel.Size = new System.Drawing.Size(41, 13);
			this.authorLabel.TabIndex = 4;
			this.authorLabel.Text = "Author:";
			// 
			// homepageLabel
			// 
			this.homepageLabel.AutoSize = true;
			this.homepageLabel.Location = new System.Drawing.Point(12, 117);
			this.homepageLabel.Name = "homepageLabel";
			this.homepageLabel.Size = new System.Drawing.Size(66, 13);
			this.homepageLabel.TabIndex = 5;
			this.homepageLabel.Text = "Home Page:";
			// 
			// platformValueLabel
			// 
			this.platformValueLabel.AutoSize = true;
			this.platformValueLabel.Location = new System.Drawing.Point(84, 60);
			this.platformValueLabel.Name = "platformValueLabel";
			this.platformValueLabel.Size = new System.Drawing.Size(19, 13);
			this.platformValueLabel.TabIndex = 6;
			this.platformValueLabel.Text = "<>";
			// 
			// buildTimeValueLabel
			// 
			this.buildTimeValueLabel.AutoSize = true;
			this.buildTimeValueLabel.Location = new System.Drawing.Point(84, 79);
			this.buildTimeValueLabel.Name = "buildTimeValueLabel";
			this.buildTimeValueLabel.Size = new System.Drawing.Size(19, 13);
			this.buildTimeValueLabel.TabIndex = 7;
			this.buildTimeValueLabel.Text = "<>";
			// 
			// authorValueLabel
			// 
			this.authorValueLabel.AutoSize = true;
			this.authorValueLabel.Location = new System.Drawing.Point(84, 98);
			this.authorValueLabel.Name = "authorValueLabel";
			this.authorValueLabel.Size = new System.Drawing.Size(19, 13);
			this.authorValueLabel.TabIndex = 8;
			this.authorValueLabel.Text = "<>";
			// 
			// homepageValueLabel
			// 
			this.homepageValueLabel.AutoSize = true;
			this.homepageValueLabel.Location = new System.Drawing.Point(84, 117);
			this.homepageValueLabel.Name = "homepageValueLabel";
			this.homepageValueLabel.Size = new System.Drawing.Size(19, 13);
			this.homepageValueLabel.TabIndex = 9;
			this.homepageValueLabel.TabStop = true;
			this.homepageValueLabel.Text = "<>";
			this.homepageValueLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.homepageValueLabel_LinkClicked);
			// 
			// licenseGroupBox
			// 
			this.licenseGroupBox.Controls.Add(this.licenseTextBox);
			this.licenseGroupBox.Location = new System.Drawing.Point(15, 178);
			this.licenseGroupBox.Name = "licenseGroupBox";
			this.licenseGroupBox.Size = new System.Drawing.Size(382, 174);
			this.licenseGroupBox.TabIndex = 10;
			this.licenseGroupBox.TabStop = false;
			this.licenseGroupBox.Text = "MIT License";
			// 
			// licenseTextBox
			// 
			this.licenseTextBox.Location = new System.Drawing.Point(6, 19);
			this.licenseTextBox.Multiline = true;
			this.licenseTextBox.Name = "licenseTextBox";
			this.licenseTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.licenseTextBox.Size = new System.Drawing.Size(370, 149);
			this.licenseTextBox.TabIndex = 0;
			this.licenseTextBox.Text = resources.GetString("licenseTextBox.Text");
			// 
			// AboutForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(409, 364);
			this.Controls.Add(this.licenseGroupBox);
			this.Controls.Add(this.homepageValueLabel);
			this.Controls.Add(this.authorValueLabel);
			this.Controls.Add(this.buildTimeValueLabel);
			this.Controls.Add(this.platformValueLabel);
			this.Controls.Add(this.homepageLabel);
			this.Controls.Add(this.authorLabel);
			this.Controls.Add(this.buildTimeLabel);
			this.Controls.Add(this.platformLabel);
			this.Controls.Add(this.infoLabel);
			this.Controls.Add(this.bannerBox);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AboutForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Info";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.licenseGroupBox.ResumeLayout(false);
			this.licenseGroupBox.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private BannerBox bannerBox;
		private System.Windows.Forms.Label infoLabel;
		private System.Windows.Forms.Label platformLabel;
		private System.Windows.Forms.Label buildTimeLabel;
		private System.Windows.Forms.Label authorLabel;
		private System.Windows.Forms.Label homepageLabel;
		private System.Windows.Forms.Label platformValueLabel;
		private System.Windows.Forms.Label buildTimeValueLabel;
		private System.Windows.Forms.Label authorValueLabel;
		private System.Windows.Forms.LinkLabel homepageValueLabel;
		private System.Windows.Forms.GroupBox licenseGroupBox;
		private System.Windows.Forms.TextBox licenseTextBox;
	}
}
```

`ReClass.NET/Forms/AboutForm.cs`:

```cs
using System;
using System.Diagnostics;
using System.Windows.Forms;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class AboutForm : IconForm
	{
		public AboutForm()
		{
			InitializeComponent();

			bannerBox.Icon = Properties.Resources.ReClassNet.ToBitmap();
			bannerBox.Title = Constants.ApplicationName;
			bannerBox.Text = $"Version: {Constants.ApplicationVersion}";

			platformValueLabel.Text = Constants.Platform;
			buildTimeValueLabel.Text = Properties.Resources.BuildDate;
			authorValueLabel.Text = Constants.Author;
			homepageValueLabel.Text = Constants.HomepageUrl;
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void homepageValueLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			Process.Start(Constants.HomepageUrl);
		}
	}
}

```

`ReClass.NET/Forms/AboutForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="licenseTextBox.Text" xml:space="preserve">
    <value>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</value>
  </data>
</root>
```

`ReClass.NET/Forms/ClassSelectionForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class ClassSelectionForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.bannerBox = new BannerBox();
			this.classesListBox = new System.Windows.Forms.ListBox();
			this.filterNameTextBox = new PlaceholderTextBox();
			this.cancelButton = new System.Windows.Forms.Button();
			this.selectButton = new System.Windows.Forms.Button();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B16x16_Class_Type;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(516, 48);
			this.bannerBox.TabIndex = 9;
			this.bannerBox.Text = "Select a class of the project.";
			this.bannerBox.Title = "Class Selection";
			// 
			// classesListBox
			// 
			this.classesListBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.classesListBox.DisplayMember = "Name";
			this.classesListBox.FormattingEnabled = true;
			this.classesListBox.Location = new System.Drawing.Point(12, 80);
			this.classesListBox.Name = "classesListBox";
			this.classesListBox.Size = new System.Drawing.Size(492, 186);
			this.classesListBox.TabIndex = 2;
			this.classesListBox.SelectedIndexChanged += new System.EventHandler(this.classesListBox_SelectedIndexChanged);
			this.classesListBox.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.classesListBox_MouseDoubleClick);
			// 
			// filterNameTextBox
			// 
			this.filterNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.filterNameTextBox.Location = new System.Drawing.Point(12, 54);
			this.filterNameTextBox.Name = "filterNameTextBox";
			this.filterNameTextBox.PlaceholderText = "Filter by Class Name...";
			this.filterNameTextBox.Size = new System.Drawing.Size(492, 20);
			this.filterNameTextBox.TabIndex = 1;
			this.filterNameTextBox.TextChanged += new System.EventHandler(this.filterNameTextBox_TextChanged);
			// 
			// cancelButton
			// 
			this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(430, 272);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(75, 23);
			this.cancelButton.TabIndex = 4;
			this.cancelButton.Text = "Cancel";
			this.cancelButton.UseVisualStyleBackColor = true;
			// 
			// selectButton
			// 
			this.selectButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.selectButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.selectButton.Enabled = false;
			this.selectButton.Location = new System.Drawing.Point(328, 272);
			this.selectButton.Name = "selectButton";
			this.selectButton.Size = new System.Drawing.Size(95, 23);
			this.selectButton.TabIndex = 3;
			this.selectButton.Text = "Select Class";
			this.selectButton.UseVisualStyleBackColor = true;
			// 
			// ClassSelectionForm
			// 
			this.AcceptButton = this.selectButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(516, 306);
			this.Controls.Add(this.selectButton);
			this.Controls.Add(this.cancelButton);
			this.Controls.Add(this.filterNameTextBox);
			this.Controls.Add(this.classesListBox);
			this.Controls.Add(this.bannerBox);
			this.Name = "ClassSelectionForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Class Selection";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private BannerBox bannerBox;
		private System.Windows.Forms.ListBox classesListBox;
		private PlaceholderTextBox filterNameTextBox;
		private System.Windows.Forms.Button cancelButton;
		private System.Windows.Forms.Button selectButton;
	}
}
```

`ReClass.NET/Forms/ClassSelectionForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Nodes;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class ClassSelectionForm : IconForm
	{
		private readonly List<ClassNode> allClasses;

		public ClassNode SelectedClass => classesListBox.SelectedItem as ClassNode;

		public ClassSelectionForm(IEnumerable<ClassNode> classes)
		{
			Contract.Requires(classes != null);

			allClasses = classes.ToList();

			InitializeComponent();

			ShowFilteredClasses();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void filterNameTextBox_TextChanged(object sender, EventArgs e)
		{
			ShowFilteredClasses();
		}

		private void classesListBox_SelectedIndexChanged(object sender, EventArgs e)
		{
			selectButton.Enabled = SelectedClass != null;
		}

		private void classesListBox_MouseDoubleClick(object sender, MouseEventArgs e)
		{
			if (SelectedClass != null)
			{
				selectButton.PerformClick();
			}
		}

		private void ShowFilteredClasses()
		{
			IEnumerable<ClassNode> classes = allClasses;

			if (!string.IsNullOrEmpty(filterNameTextBox.Text))
			{
				classes = classes.Where(c => c.Name.IndexOf(filterNameTextBox.Text, StringComparison.OrdinalIgnoreCase) >= 0);
			}

			classesListBox.DataSource = classes.ToList();
		}
	}
}

```

`ReClass.NET/Forms/ClassSelectionForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/CodeForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class CodeForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.bannerBox = new BannerBox();
			this.codeRichTextBox = new System.Windows.Forms.RichTextBox();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Page_Code;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(629, 48);
			this.bannerBox.TabIndex = 2;
			this.bannerBox.Text = "The classes transformed into source code.";
			this.bannerBox.Title = "Code Generator";
			// 
			// codeRichTextBox
			// 
			this.codeRichTextBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
			this.codeRichTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
			this.codeRichTextBox.Location = new System.Drawing.Point(0, 48);
			this.codeRichTextBox.Name = "codeRichTextBox";
			this.codeRichTextBox.Size = new System.Drawing.Size(629, 390);
			this.codeRichTextBox.TabIndex = 3;
			this.codeRichTextBox.Text = "";
			// 
			// CodeForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(629, 438);
			this.Controls.Add(this.codeRichTextBox);
			this.Controls.Add(this.bannerBox);
			this.MinimumSize = new System.Drawing.Size(350, 185);
			this.Name = "CodeForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Code Generator";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);

		}

		#endregion
		private BannerBox bannerBox;
		private System.Windows.Forms.RichTextBox codeRichTextBox;
	}
}
```

`ReClass.NET/Forms/CodeForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ColorCode;
using ColorCode.Parsing;
using ReClassNET.CodeGenerator;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Nodes;
using ReClassNET.Project;
using ReClassNET.UI;
using ReClassNET.Util.Rtf;

namespace ReClassNET.Forms
{
	public partial class CodeForm : IconForm
	{
		public CodeForm(ICodeGenerator generator, IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ILogger logger)
		{
			Contract.Requires(generator != null);
			Contract.Requires(classes != null);
			Contract.Requires(enums != null);

			InitializeComponent();

			codeRichTextBox.SetInnerMargin(5, 5, 5, 5);

			var code = generator.GenerateCode(classes, enums, logger);

			var buffer = new StringBuilder(code.Length * 2);
			using (var writer = new StringWriter(buffer))
			{
				new CodeColorizer().Colorize(
					code,
					generator.Language == Language.Cpp ? Languages.Cpp : Languages.CSharp,
					new RtfFormatter(),
					StyleSheets.Default,
					writer
				);
			}

			codeRichTextBox.Rtf = buffer.ToString();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}
	}

	internal class RtfFormatter : IFormatter
	{
		private readonly RtfBuilder builder = new RtfBuilder(RtfFont.Consolas, 20);

		public void Write(string parsedSourceCode, IList<Scope> scopes, IStyleSheet styleSheet, TextWriter textWriter)
		{
			if (scopes.Any())
			{
				builder.SetForeColor(styleSheet.Styles[scopes.First().Name].Foreground).Append(parsedSourceCode);
			}
			else
			{
				builder.Append(parsedSourceCode);
			}
		}

		public void WriteHeader(IStyleSheet styleSheet, ILanguage language, TextWriter textWriter)
		{

		}

		public void WriteFooter(IStyleSheet styleSheet, ILanguage language, TextWriter textWriter)
		{
			textWriter.Write(builder.ToString());
		}
	}
}

```

`ReClass.NET/Forms/CodeForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/EnumEditorForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class EnumEditorForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.bannerBox = new BannerBox();
			this.saveButton = new System.Windows.Forms.Button();
			this.enumNameLabel = new System.Windows.Forms.Label();
			this.cancelButton = new System.Windows.Forms.Button();
			this.enumFlagCheckBox = new System.Windows.Forms.CheckBox();
			this.enumNameTextBox = new System.Windows.Forms.TextBox();
			this.enumDataGridView = new System.Windows.Forms.DataGridView();
			this.enumValueKeyColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.enumValueNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.enumUnderlyingTypeSizeLabel = new System.Windows.Forms.Label();
			this.enumUnderlyingTypeSizeComboBox = new ReClassNET.Forms.UnderlyingSizeComboBox();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.enumDataGridView)).BeginInit();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B16x16_Class_Type;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(380, 48);
			this.bannerBox.TabIndex = 15;
			this.bannerBox.Text = "Edit an enum of the project.";
			this.bannerBox.Title = "Enum Editor";
			// 
			// saveButton
			// 
			this.saveButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.saveButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.saveButton.Location = new System.Drawing.Point(214, 250);
			this.saveButton.Name = "saveButton";
			this.saveButton.Size = new System.Drawing.Size(75, 23);
			this.saveButton.TabIndex = 22;
			this.saveButton.Text = "Save";
			this.saveButton.UseVisualStyleBackColor = true;
			this.saveButton.Click += new System.EventHandler(this.saveButton_Click);
			// 
			// enumNameLabel
			// 
			this.enumNameLabel.AutoSize = true;
			this.enumNameLabel.Location = new System.Drawing.Point(9, 57);
			this.enumNameLabel.Name = "enumNameLabel";
			this.enumNameLabel.Size = new System.Drawing.Size(38, 13);
			this.enumNameLabel.TabIndex = 21;
			this.enumNameLabel.Text = "Name:";
			// 
			// cancelButton
			// 
			this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(295, 250);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(75, 23);
			this.cancelButton.TabIndex = 19;
			this.cancelButton.Text = "Cancel";
			this.cancelButton.UseVisualStyleBackColor = true;
			// 
			// enumFlagCheckBox
			// 
			this.enumFlagCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.enumFlagCheckBox.AutoSize = true;
			this.enumFlagCheckBox.Location = new System.Drawing.Point(267, 82);
			this.enumFlagCheckBox.Name = "enumFlagCheckBox";
			this.enumFlagCheckBox.Size = new System.Drawing.Size(103, 17);
			this.enumFlagCheckBox.TabIndex = 18;
			this.enumFlagCheckBox.Text = "Use Flags Mode";
			this.enumFlagCheckBox.UseVisualStyleBackColor = true;
			// 
			// enumNameTextBox
			// 
			this.enumNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.enumNameTextBox.Location = new System.Drawing.Point(53, 54);
			this.enumNameTextBox.Name = "enumNameTextBox";
			this.enumNameTextBox.Size = new System.Drawing.Size(315, 20);
			this.enumNameTextBox.TabIndex = 17;
			// 
			// enumDataGridView
			// 
			this.enumDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.enumDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.enumDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.enumValueKeyColumn,
            this.enumValueNameColumn});
			this.enumDataGridView.Location = new System.Drawing.Point(12, 108);
			this.enumDataGridView.Name = "enumDataGridView";
			this.enumDataGridView.RowHeadersVisible = false;
			this.enumDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.enumDataGridView.Size = new System.Drawing.Size(358, 136);
			this.enumDataGridView.TabIndex = 16;
			this.enumDataGridView.CellValidating += new System.Windows.Forms.DataGridViewCellValidatingEventHandler(this.enumDataGridView_CellValidating);
			this.enumDataGridView.DefaultValuesNeeded += new System.Windows.Forms.DataGridViewRowEventHandler(this.enumDataGridView_DefaultValuesNeeded);
			// 
			// enumValueKeyColumn
			// 
			this.enumValueKeyColumn.HeaderText = "Value";
			this.enumValueKeyColumn.Name = "enumValueKeyColumn";
			// 
			// enumValueNameColumn
			// 
			this.enumValueNameColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.enumValueNameColumn.HeaderText = "Name";
			this.enumValueNameColumn.Name = "enumValueNameColumn";
			// 
			// enumUnderlyingTypeSizeLabel
			// 
			this.enumUnderlyingTypeSizeLabel.AutoSize = true;
			this.enumUnderlyingTypeSizeLabel.Location = new System.Drawing.Point(9, 83);
			this.enumUnderlyingTypeSizeLabel.Name = "enumUnderlyingTypeSizeLabel";
			this.enumUnderlyingTypeSizeLabel.Size = new System.Drawing.Size(30, 13);
			this.enumUnderlyingTypeSizeLabel.TabIndex = 24;
			this.enumUnderlyingTypeSizeLabel.Text = "Size:";
			// 
			// enumUnderlyingTypeSizeComboBox
			// 
			this.enumUnderlyingTypeSizeComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.enumUnderlyingTypeSizeComboBox.Location = new System.Drawing.Point(53, 80);
			this.enumUnderlyingTypeSizeComboBox.Name = "enumUnderlyingTypeSizeComboBox";
			this.enumUnderlyingTypeSizeComboBox.Size = new System.Drawing.Size(208, 21);
			this.enumUnderlyingTypeSizeComboBox.TabIndex = 25;
			// 
			// EnumEditorForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(380, 282);
			this.Controls.Add(this.enumUnderlyingTypeSizeComboBox);
			this.Controls.Add(this.enumUnderlyingTypeSizeLabel);
			this.Controls.Add(this.saveButton);
			this.Controls.Add(this.enumNameLabel);
			this.Controls.Add(this.cancelButton);
			this.Controls.Add(this.enumFlagCheckBox);
			this.Controls.Add(this.enumNameTextBox);
			this.Controls.Add(this.enumDataGridView);
			this.Controls.Add(this.bannerBox);
			this.MinimumSize = new System.Drawing.Size(396, 321);
			this.Name = "EnumEditorForm";
			this.Text = "ReClass.NET - Enum Editor";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.enumDataGridView)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private BannerBox bannerBox;
		private System.Windows.Forms.Button saveButton;
		private System.Windows.Forms.Label enumNameLabel;
		private System.Windows.Forms.Button cancelButton;
		private System.Windows.Forms.CheckBox enumFlagCheckBox;
		private System.Windows.Forms.TextBox enumNameTextBox;
		private System.Windows.Forms.DataGridView enumDataGridView;
		private System.Windows.Forms.Label enumUnderlyingTypeSizeLabel;
		private System.Windows.Forms.DataGridViewTextBoxColumn enumValueKeyColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn enumValueNameColumn;
		private UnderlyingSizeComboBox enumUnderlyingTypeSizeComboBox;
	}
}
```

`ReClass.NET/Forms/EnumEditorForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Controls;
using ReClassNET.Project;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class EnumEditorForm : IconForm
	{
		private readonly EnumDescription @enum;

		public EnumEditorForm(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			InitializeComponent();

			this.@enum = @enum;

			enumNameTextBox.Text = @enum.Name;
			enumUnderlyingTypeSizeComboBox.SelectedValue = @enum.Size;
			enumFlagCheckBox.Checked = @enum.UseFlagsMode;

			foreach (var kv in @enum.Values)
			{
				enumDataGridView.Rows.Add(kv.Value, kv.Key);
			}
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void enumDataGridView_DefaultValuesNeeded(object sender, DataGridViewRowEventArgs e)
		{
			long value = e.Row.Index;
			if (enumFlagCheckBox.Checked)
			{
				value = (long)Math.Pow(2, e.Row.Index);
			}

			e.Row.Cells[0].Value = value;
		}

		private void saveButton_Click(object sender, EventArgs e)
		{
			@enum.Name = enumNameTextBox.Text;

			var values = new Dictionary<string, long>();

			foreach (var row in enumDataGridView.Rows.Cast<DataGridViewRow>().Where(r => r.IsNewRow == false))
			{
				if (!long.TryParse(Convert.ToString(row.Cells[0].Value), out var itemValue))
				{
					continue;
				}

				var itemName = Convert.ToString(row.Cells[1].Value);

				values.Add(itemName, itemValue);
			}

			@enum.SetData(enumFlagCheckBox.Checked, enumUnderlyingTypeSizeComboBox.SelectedValue, values);
		}

		private void enumDataGridView_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
		{
			void SetErrorText(string text)
			{
				enumDataGridView.Rows[e.RowIndex].Cells[e.ColumnIndex].ErrorText = text;
			}

			SetErrorText(null);

			var formattedValue = Convert.ToString(e.FormattedValue);

			if (e.ColumnIndex == 0 && !long.TryParse(formattedValue, out _))
			{
				SetErrorText($"'{formattedValue}' is not a valid value.");
			}
			else if (e.ColumnIndex == 1 && string.IsNullOrWhiteSpace(formattedValue))
			{
				SetErrorText("Empty names are not allowed.");
			}
		}
	}

	internal class UnderlyingSizeComboBox : EnumComboBox<EnumDescription.UnderlyingTypeSize> { }
}

```

`ReClass.NET/Forms/EnumEditorForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="enumValueKeyColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="enumValueNameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="enumValueKeyColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="enumValueNameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/EnumListForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class EnumListForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.filterNameTextBox = new PlaceholderTextBox();
			this.itemListBox = new System.Windows.Forms.ListBox();
			this.bannerBox = new BannerBox();
			this.addEnumIconButton = new IconButton();
			this.removeEnumIconButton = new IconButton();
			this.editEnumIconButton = new IconButton();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// filterNameTextBox
			// 
			this.filterNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.filterNameTextBox.Location = new System.Drawing.Point(12, 60);
			this.filterNameTextBox.Name = "filterNameTextBox";
			this.filterNameTextBox.PlaceholderText = "Filter by Enum Name...";
			this.filterNameTextBox.Size = new System.Drawing.Size(411, 20);
			this.filterNameTextBox.TabIndex = 10;
			this.filterNameTextBox.TextChanged += new System.EventHandler(this.filterNameTextBox_TextChanged);
			// 
			// itemListBox
			// 
			this.itemListBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.itemListBox.DisplayMember = "Name";
			this.itemListBox.FormattingEnabled = true;
			this.itemListBox.Location = new System.Drawing.Point(12, 86);
			this.itemListBox.Name = "itemListBox";
			this.itemListBox.Size = new System.Drawing.Size(492, 212);
			this.itemListBox.TabIndex = 11;
			this.itemListBox.SelectedIndexChanged += new System.EventHandler(this.itemListBox_SelectedIndexChanged);
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B16x16_Class_Type;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(516, 48);
			this.bannerBox.TabIndex = 14;
			this.bannerBox.Text = "Edit the enums of the project.";
			this.bannerBox.Title = "Enums";
			// 
			// addEnumIconButton
			// 
			this.addEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.addEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add;
			this.addEnumIconButton.Location = new System.Drawing.Point(456, 59);
			this.addEnumIconButton.Name = "addEnumIconButton";
			this.addEnumIconButton.Pressed = false;
			this.addEnumIconButton.Selected = false;
			this.addEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.addEnumIconButton.TabIndex = 15;
			this.addEnumIconButton.Click += new System.EventHandler(this.addEnumIconButton_Click);
			// 
			// removeEnumIconButton
			// 
			this.removeEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.removeEnumIconButton.Enabled = false;
			this.removeEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Remove;
			this.removeEnumIconButton.Location = new System.Drawing.Point(481, 59);
			this.removeEnumIconButton.Name = "removeEnumIconButton";
			this.removeEnumIconButton.Pressed = false;
			this.removeEnumIconButton.Selected = false;
			this.removeEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.removeEnumIconButton.TabIndex = 16;
			this.removeEnumIconButton.Click += new System.EventHandler(this.removeEnumIconButton_Click);
			// 
			// editEnumIconButton
			// 
			this.editEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.editEnumIconButton.Enabled = false;
			this.editEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Custom_Type;
			this.editEnumIconButton.Location = new System.Drawing.Point(431, 59);
			this.editEnumIconButton.Name = "editEnumIconButton";
			this.editEnumIconButton.Pressed = false;
			this.editEnumIconButton.Selected = false;
			this.editEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.editEnumIconButton.TabIndex = 16;
			this.editEnumIconButton.Click += new System.EventHandler(this.editEnumIconButton_Click);
			// 
			// EnumListForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(516, 308);
			this.Controls.Add(this.editEnumIconButton);
			this.Controls.Add(this.addEnumIconButton);
			this.Controls.Add(this.removeEnumIconButton);
			this.Controls.Add(this.filterNameTextBox);
			this.Controls.Add(this.itemListBox);
			this.Controls.Add(this.bannerBox);
			this.Name = "EnumListForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Enums";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion
		private PlaceholderTextBox filterNameTextBox;
		private System.Windows.Forms.ListBox itemListBox;
		private BannerBox bannerBox;
		private IconButton addEnumIconButton;
		private IconButton removeEnumIconButton;
		private IconButton editEnumIconButton;
	}
}
```

`ReClass.NET/Forms/EnumListForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Project;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class EnumListForm : IconForm
	{
		private readonly ReClassNetProject project;

		public EnumDescription SelectedItem => itemListBox.SelectedItem as EnumDescription;

		public EnumListForm(ReClassNetProject project)
		{
			Contract.Requires(project != null);

			this.project = project;

			InitializeComponent();

			ShowFilteredEnums();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void filterNameTextBox_TextChanged(object sender, EventArgs e)
		{
			ShowFilteredEnums();
		}

		private void itemListBox_SelectedIndexChanged(object sender, EventArgs e)
		{
			editEnumIconButton.Enabled = removeEnumIconButton.Enabled = SelectedItem != null;
		}

		private void editEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = SelectedItem;
			if (@enum == null)
			{
				return;
			}

			using var eef = new EnumEditorForm(@enum);

			eef.ShowDialog();
		}

		private void addEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = new EnumDescription
			{
				Name = "Enum"
			};

			using var eef = new EnumEditorForm(@enum);

			if (eef.ShowDialog() == DialogResult.OK)
			{
				project.AddEnum(@enum);

				ShowFilteredEnums();
			}
		}

		private void removeEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = SelectedItem;
			if (@enum == null)
			{
				return;
			}

			project.RemoveEnum(@enum);

			ShowFilteredEnums();
		}

		private void ShowFilteredEnums()
		{
			IEnumerable<EnumDescription> enums = project.Enums;

			if (!string.IsNullOrEmpty(filterNameTextBox.Text))
			{
				enums = enums.Where(c => c.Name.IndexOf(filterNameTextBox.Text, StringComparison.OrdinalIgnoreCase) >= 0);
			}

			itemListBox.DataSource = enums.ToList();
		}
	}
}

```

`ReClass.NET/Forms/EnumListForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/EnumSelectionForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class EnumSelectionForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.selectButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.filterNameTextBox = new PlaceholderTextBox();
			this.itemListBox = new System.Windows.Forms.ListBox();
			this.bannerBox = new BannerBox();
			this.addEnumIconButton = new IconButton();
			this.removeEnumIconButton = new IconButton();
			this.editEnumIconButton = new IconButton();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// selectButton
			// 
			this.selectButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.selectButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.selectButton.Enabled = false;
			this.selectButton.Location = new System.Drawing.Point(328, 278);
			this.selectButton.Name = "selectButton";
			this.selectButton.Size = new System.Drawing.Size(95, 23);
			this.selectButton.TabIndex = 12;
			this.selectButton.Text = "Select Enum";
			this.selectButton.UseVisualStyleBackColor = true;
			// 
			// cancelButton
			// 
			this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(430, 278);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(75, 23);
			this.cancelButton.TabIndex = 13;
			this.cancelButton.Text = "Cancel";
			this.cancelButton.UseVisualStyleBackColor = true;
			// 
			// filterNameTextBox
			// 
			this.filterNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.filterNameTextBox.Location = new System.Drawing.Point(12, 60);
			this.filterNameTextBox.Name = "filterNameTextBox";
			this.filterNameTextBox.PlaceholderText = "Filter by Enum Name...";
			this.filterNameTextBox.Size = new System.Drawing.Size(411, 20);
			this.filterNameTextBox.TabIndex = 10;
			this.filterNameTextBox.TextChanged += new System.EventHandler(this.filterNameTextBox_TextChanged);
			// 
			// itemListBox
			// 
			this.itemListBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.itemListBox.DisplayMember = "Name";
			this.itemListBox.FormattingEnabled = true;
			this.itemListBox.Location = new System.Drawing.Point(12, 86);
			this.itemListBox.Name = "itemListBox";
			this.itemListBox.Size = new System.Drawing.Size(492, 186);
			this.itemListBox.TabIndex = 11;
			this.itemListBox.SelectedIndexChanged += new System.EventHandler(this.itemListBox_SelectedIndexChanged);
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B16x16_Class_Type;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(516, 48);
			this.bannerBox.TabIndex = 14;
			this.bannerBox.Text = "Select an enum of the project.";
			this.bannerBox.Title = "Enum Selection";
			// 
			// addEnumIconButton
			// 
			this.addEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.addEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add;
			this.addEnumIconButton.Location = new System.Drawing.Point(456, 59);
			this.addEnumIconButton.Name = "addEnumIconButton";
			this.addEnumIconButton.Pressed = false;
			this.addEnumIconButton.Selected = false;
			this.addEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.addEnumIconButton.TabIndex = 15;
			this.addEnumIconButton.Click += new System.EventHandler(this.addEnumIconButton_Click);
			// 
			// removeEnumIconButton
			// 
			this.removeEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.removeEnumIconButton.Enabled = false;
			this.removeEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Remove;
			this.removeEnumIconButton.Location = new System.Drawing.Point(481, 59);
			this.removeEnumIconButton.Name = "removeEnumIconButton";
			this.removeEnumIconButton.Pressed = false;
			this.removeEnumIconButton.Selected = false;
			this.removeEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.removeEnumIconButton.TabIndex = 16;
			this.removeEnumIconButton.Click += new System.EventHandler(this.removeEnumIconButton_Click);
			// 
			// editEnumIconButton
			// 
			this.editEnumIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.editEnumIconButton.Enabled = false;
			this.editEnumIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Custom_Type;
			this.editEnumIconButton.Location = new System.Drawing.Point(431, 59);
			this.editEnumIconButton.Name = "editEnumIconButton";
			this.editEnumIconButton.Pressed = false;
			this.editEnumIconButton.Selected = false;
			this.editEnumIconButton.Size = new System.Drawing.Size(23, 22);
			this.editEnumIconButton.TabIndex = 16;
			this.editEnumIconButton.Click += new System.EventHandler(this.editEnumIconButton_Click);
			// 
			// EnumSelectionForm
			// 
			this.AcceptButton = this.selectButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(516, 306);
			this.Controls.Add(this.editEnumIconButton);
			this.Controls.Add(this.addEnumIconButton);
			this.Controls.Add(this.removeEnumIconButton);
			this.Controls.Add(this.selectButton);
			this.Controls.Add(this.cancelButton);
			this.Controls.Add(this.filterNameTextBox);
			this.Controls.Add(this.itemListBox);
			this.Controls.Add(this.bannerBox);
			this.Name = "EnumSelectionForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Enum Selection";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.Button selectButton;
		private System.Windows.Forms.Button cancelButton;
		private PlaceholderTextBox filterNameTextBox;
		private System.Windows.Forms.ListBox itemListBox;
		private BannerBox bannerBox;
		private IconButton addEnumIconButton;
		private IconButton removeEnumIconButton;
		private IconButton editEnumIconButton;
	}
}
```

`ReClass.NET/Forms/EnumSelectionForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Project;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class EnumSelectionForm : IconForm
	{
		private readonly ReClassNetProject project;

		public EnumDescription SelectedItem => itemListBox.SelectedItem as EnumDescription;

		public EnumSelectionForm(ReClassNetProject project)
		{
			Contract.Requires(project != null);

			this.project = project;

			InitializeComponent();

			ShowFilteredEnums();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void filterNameTextBox_TextChanged(object sender, EventArgs e)
		{
			ShowFilteredEnums();
		}

		private void itemListBox_SelectedIndexChanged(object sender, EventArgs e)
		{
			selectButton.Enabled = editEnumIconButton.Enabled = removeEnumIconButton.Enabled = SelectedItem != null;
		}

		private void editEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = SelectedItem;
			if (@enum == null)
			{
				return;
			}

			using var eef = new EnumEditorForm(@enum);

			eef.ShowDialog();
		}

		private void addEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = new EnumDescription
			{
				Name = "Enum"
			};

			using var eef = new EnumEditorForm(@enum);

			if (eef.ShowDialog() == DialogResult.OK)
			{
				project.AddEnum(@enum);

				ShowFilteredEnums();
			}
		}

		private void removeEnumIconButton_Click(object sender, EventArgs e)
		{
			var @enum = SelectedItem;
			if (@enum == null)
			{
				return;
			}

			project.RemoveEnum(@enum);

			ShowFilteredEnums();
		}

		private void ShowFilteredEnums()
		{
			IEnumerable<EnumDescription> enums = project.Enums;

			if (!string.IsNullOrEmpty(filterNameTextBox.Text))
			{
				enums = enums.Where(c => c.Name.IndexOf(filterNameTextBox.Text, StringComparison.OrdinalIgnoreCase) >= 0);
			}

			itemListBox.DataSource = enums.ToList();
		}
	}
}

```

`ReClass.NET/Forms/EnumSelectionForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/FoundCodeForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class FoundCodeForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.splitContainer = new System.Windows.Forms.SplitContainer();
			this.foundCodeDataGridView = new System.Windows.Forms.DataGridView();
			this.counterDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.instructionDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.infoTextBox = new System.Windows.Forms.TextBox();
			this.stopButton = new System.Windows.Forms.Button();
			this.closeButton = new System.Windows.Forms.Button();
			this.createFunctionButton = new System.Windows.Forms.Button();
			this.bannerBox = new BannerBox();
			((System.ComponentModel.ISupportInitialize)(this.splitContainer)).BeginInit();
			this.splitContainer.Panel1.SuspendLayout();
			this.splitContainer.Panel2.SuspendLayout();
			this.splitContainer.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.foundCodeDataGridView)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// splitContainer
			// 
			this.splitContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.splitContainer.Location = new System.Drawing.Point(0, 49);
			this.splitContainer.Name = "splitContainer";
			this.splitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
			// 
			// splitContainer.Panel1
			// 
			this.splitContainer.Panel1.Controls.Add(this.foundCodeDataGridView);
			// 
			// splitContainer.Panel2
			// 
			this.splitContainer.Panel2.Controls.Add(this.infoTextBox);
			this.splitContainer.Size = new System.Drawing.Size(476, 426);
			this.splitContainer.SplitterDistance = 200;
			this.splitContainer.TabIndex = 0;
			// 
			// foundCodeDataGridView
			// 
			this.foundCodeDataGridView.AllowUserToAddRows = false;
			this.foundCodeDataGridView.AllowUserToDeleteRows = false;
			this.foundCodeDataGridView.AllowUserToResizeRows = false;
			this.foundCodeDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.foundCodeDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.foundCodeDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.counterDataGridViewTextBoxColumn,
            this.instructionDataGridViewTextBoxColumn});
			this.foundCodeDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.foundCodeDataGridView.Location = new System.Drawing.Point(0, 0);
			this.foundCodeDataGridView.MultiSelect = false;
			this.foundCodeDataGridView.Name = "foundCodeDataGridView";
			this.foundCodeDataGridView.ReadOnly = true;
			this.foundCodeDataGridView.RowHeadersVisible = false;
			this.foundCodeDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.foundCodeDataGridView.Size = new System.Drawing.Size(476, 200);
			this.foundCodeDataGridView.TabIndex = 0;
			this.foundCodeDataGridView.SelectionChanged += new System.EventHandler(this.foundCodeDataGridView_SelectionChanged);
			// 
			// counterDataGridViewTextBoxColumn
			// 
			this.counterDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.counterDataGridViewTextBoxColumn.DataPropertyName = "counter";
			this.counterDataGridViewTextBoxColumn.HeaderText = "Counter";
			this.counterDataGridViewTextBoxColumn.Name = "counterDataGridViewTextBoxColumn";
			this.counterDataGridViewTextBoxColumn.ReadOnly = true;
			this.counterDataGridViewTextBoxColumn.Width = 69;
			// 
			// instructionDataGridViewTextBoxColumn
			// 
			this.instructionDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.instructionDataGridViewTextBoxColumn.DataPropertyName = "instruction";
			this.instructionDataGridViewTextBoxColumn.HeaderText = "Instruction";
			this.instructionDataGridViewTextBoxColumn.Name = "instructionDataGridViewTextBoxColumn";
			this.instructionDataGridViewTextBoxColumn.ReadOnly = true;
			// 
			// infoTextBox
			// 
			this.infoTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
			this.infoTextBox.Location = new System.Drawing.Point(0, 0);
			this.infoTextBox.Multiline = true;
			this.infoTextBox.Name = "infoTextBox";
			this.infoTextBox.ReadOnly = true;
			this.infoTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.infoTextBox.Size = new System.Drawing.Size(476, 222);
			this.infoTextBox.TabIndex = 0;
			// 
			// stopButton
			// 
			this.stopButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.stopButton.Location = new System.Drawing.Point(489, 101);
			this.stopButton.Name = "stopButton";
			this.stopButton.Size = new System.Drawing.Size(86, 35);
			this.stopButton.TabIndex = 1;
			this.stopButton.Text = "Stop";
			this.stopButton.UseVisualStyleBackColor = true;
			this.stopButton.Click += new System.EventHandler(this.stopButton_Click);
			// 
			// closeButton
			// 
			this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.closeButton.Location = new System.Drawing.Point(489, 101);
			this.closeButton.Name = "closeButton";
			this.closeButton.Size = new System.Drawing.Size(86, 35);
			this.closeButton.TabIndex = 2;
			this.closeButton.Text = "Close";
			this.closeButton.UseVisualStyleBackColor = true;
			this.closeButton.Visible = false;
			this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
			// 
			// createFunctionButton
			// 
			this.createFunctionButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.createFunctionButton.Location = new System.Drawing.Point(489, 60);
			this.createFunctionButton.Name = "createFunctionButton";
			this.createFunctionButton.Size = new System.Drawing.Size(86, 35);
			this.createFunctionButton.TabIndex = 3;
			this.createFunctionButton.Text = "Create Function Node";
			this.createFunctionButton.UseVisualStyleBackColor = true;
			this.createFunctionButton.Click += new System.EventHandler(this.createFunctionButton_Click);
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_3D_Glasses;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(587, 48);
			this.bannerBox.TabIndex = 8;
			this.bannerBox.Text = "<>";
			this.bannerBox.Title = "Instruction Finder";
			// 
			// FoundCodeForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(587, 474);
			this.Controls.Add(this.bannerBox);
			this.Controls.Add(this.createFunctionButton);
			this.Controls.Add(this.closeButton);
			this.Controls.Add(this.stopButton);
			this.Controls.Add(this.splitContainer);
			this.MinimumSize = new System.Drawing.Size(603, 464);
			this.Name = "FoundCodeForm";
			this.Text = "<>";
			this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.FoundCodeForm_FormClosed);
			this.splitContainer.Panel1.ResumeLayout(false);
			this.splitContainer.Panel2.ResumeLayout(false);
			this.splitContainer.Panel2.PerformLayout();
			((System.ComponentModel.ISupportInitialize)(this.splitContainer)).EndInit();
			this.splitContainer.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.foundCodeDataGridView)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.SplitContainer splitContainer;
		private System.Windows.Forms.DataGridView foundCodeDataGridView;
		private System.Windows.Forms.Button stopButton;
		private System.Windows.Forms.DataGridViewTextBoxColumn counterDataGridViewTextBoxColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn instructionDataGridViewTextBoxColumn;
		private System.Windows.Forms.Button closeButton;
		private System.Windows.Forms.TextBox infoTextBox;
		private System.Windows.Forms.Button createFunctionButton;
		private BannerBox bannerBox;
	}
}
```

`ReClass.NET/Forms/FoundCodeForm.cs`:

```cs
using System;
using System.Data;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ReClassNET.Debugger;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class FoundCodeForm : IconForm
	{
		private class FoundCodeInfo
		{
			public ExceptionDebugInfo DebugInfo { get; set; }
			public DisassembledInstruction[] Instructions { get; set; }
		}

		public delegate void StopEventHandler(object sender, EventArgs e);

		private readonly RemoteProcess process;
		
		private readonly DataTable data;
		private volatile bool acceptNewRecords = true;

		public event StopEventHandler Stop;

		public FoundCodeForm(RemoteProcess process, IntPtr address, HardwareBreakpointTrigger trigger)
		{
			Contract.Requires(process != null);

			this.process = process;

			InitializeComponent();

			foundCodeDataGridView.AutoGenerateColumns = false;
			infoTextBox.Font = new Font(FontFamily.GenericMonospace, infoTextBox.Font.Size);

			if (trigger == HardwareBreakpointTrigger.Write)
			{
				Text = "Find out what writes to " + address.ToString(Constants.AddressHexFormat);
			}
			else
			{
				Text = "Find out what accesses " + address.ToString(Constants.AddressHexFormat);
			}

			bannerBox.Text = Text;

			data = new DataTable();
			data.Columns.Add("counter", typeof(int));
			data.Columns.Add("instruction", typeof(string));
			data.Columns.Add("info", typeof(FoundCodeInfo));

			foundCodeDataGridView.DataSource = data;
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void foundCodeDataGridView_SelectionChanged(object sender, EventArgs e)
		{
			var info = GetSelectedInfo();
			if (info == null)
			{
				return;
			}

			var sb = new StringBuilder();

			for (var i = 0; i < 5; ++i)
			{
				var code = $"{info.Instructions[i].Address.ToString(Constants.AddressHexFormat)} - {info.Instructions[i].Instruction}";
				if (i == 2)
				{
					sb.AppendLine(code + " <<<");
				}
				else
				{
					sb.AppendLine(code);
				}
			}

			sb.AppendLine();

#if RECLASSNET64
			sb.AppendLine($"RAX = {info.DebugInfo.Registers.Rax.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RBX = {info.DebugInfo.Registers.Rbx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RCX = {info.DebugInfo.Registers.Rcx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RDX = {info.DebugInfo.Registers.Rdx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RDI = {info.DebugInfo.Registers.Rdi.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RSI = {info.DebugInfo.Registers.Rsi.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RSP = {info.DebugInfo.Registers.Rsp.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RBP = {info.DebugInfo.Registers.Rbp.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"RIP = {info.DebugInfo.Registers.Rip.ToString(Constants.AddressHexFormat)}");

			sb.AppendLine($"R8  = {info.DebugInfo.Registers.R8.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R9  = {info.DebugInfo.Registers.R9.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R10 = {info.DebugInfo.Registers.R10.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R11 = {info.DebugInfo.Registers.R11.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R12 = {info.DebugInfo.Registers.R12.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R13 = {info.DebugInfo.Registers.R13.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"R14 = {info.DebugInfo.Registers.R14.ToString(Constants.AddressHexFormat)}");
			sb.Append($"R15 = {info.DebugInfo.Registers.R15.ToString(Constants.AddressHexFormat)}");
#else
			sb.AppendLine($"EAX = {info.DebugInfo.Registers.Eax.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"EBX = {info.DebugInfo.Registers.Ebx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"ECX = {info.DebugInfo.Registers.Ecx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"EDX = {info.DebugInfo.Registers.Edx.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"EDI = {info.DebugInfo.Registers.Edi.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"ESI = {info.DebugInfo.Registers.Esi.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"ESP = {info.DebugInfo.Registers.Esp.ToString(Constants.AddressHexFormat)}");
			sb.AppendLine($"EBP = {info.DebugInfo.Registers.Ebp.ToString(Constants.AddressHexFormat)}");
			sb.Append($"EIP = {info.DebugInfo.Registers.Eip.ToString(Constants.AddressHexFormat)}");
#endif

			infoTextBox.Text = sb.ToString();
		}

		private void FoundCodeForm_FormClosed(object sender, FormClosedEventArgs e)
		{
			StopRecording();
		}

		private void createFunctionButton_Click(object sender, EventArgs e)
		{
			var info = GetSelectedInfo();
			if (info == null)
			{
				return;
			}

			var disassembler = new Disassembler(process.CoreFunctions);
			var functionStartAddress = disassembler.RemoteGetFunctionStartAddress(process, info.DebugInfo.ExceptionAddress);
			if (functionStartAddress.IsNull())
			{
				MessageBox.Show("Could not find the start of the function. Aborting.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);

				return;
			}

			var node = LinkedWindowFeatures.CreateClassAtAddress(functionStartAddress, false);
			node.AddNode(new FunctionNode
			{
				Comment = info.Instructions[2].Instruction
			});
		}

		private void stopButton_Click(object sender, EventArgs e)
		{
			StopRecording();

			stopButton.Visible = false;
			closeButton.Visible = true;
		}

		private void closeButton_Click(object sender, EventArgs e)
		{
			Close();
		}

		#endregion

		private FoundCodeInfo GetSelectedInfo()
		{
			var row = foundCodeDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault();
			var view = row?.DataBoundItem as DataRowView;
			return view?["info"] as FoundCodeInfo;
		}

		private void StopRecording()
		{
			acceptNewRecords = false;

			Stop?.Invoke(this, EventArgs.Empty);
		}

		public void AddRecord(ExceptionDebugInfo? context)
		{
			if (context == null)
			{
				return;
			}
			if (!acceptNewRecords)
			{
				return;
			}

			if (InvokeRequired)
			{
				Invoke((MethodInvoker)(() => AddRecord(context)));

				return;
			}

			var row = data.AsEnumerable().FirstOrDefault(r => r.Field<FoundCodeInfo>("info").DebugInfo.ExceptionAddress == context.Value.ExceptionAddress);
			if (row != null)
			{
				row["counter"] = row.Field<int>("counter") + 1;
			}
			else
			{
				var disassembler = new Disassembler(process.CoreFunctions);

				var causedByInstruction = disassembler.RemoteGetPreviousInstruction(process, context.Value.ExceptionAddress);
				if (causedByInstruction == null)
				{
					return;
				}

				var instructions = new DisassembledInstruction[5];
				instructions[2] = causedByInstruction;
				instructions[1] = disassembler.RemoteGetPreviousInstruction(process, instructions[2].Address);
				instructions[0] = disassembler.RemoteGetPreviousInstruction(process, instructions[1].Address);

				var i = 3;
				foreach (var instruction in disassembler.RemoteDisassembleCode(process, context.Value.ExceptionAddress, 2 * Disassembler.MaximumInstructionLength, 2))
				{
					instructions[i++] = instruction;
				}

				row = data.NewRow();
				row["counter"] = 1;
				row["instruction"] = causedByInstruction.Instruction;
				row["info"] = new FoundCodeInfo
				{
					DebugInfo = context.Value,
					Instructions = instructions
				};
				data.Rows.Add(row);
			}
		}
	}
}

```

`ReClass.NET/Forms/FoundCodeForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="counterDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="instructionDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/IconForm.cs`:

```cs
using System.Windows.Forms;

namespace ReClassNET.Forms
{
	public class IconForm : Form
	{
		public IconForm()
		{
			Icon = Properties.Resources.ReClassNet;
		}
	}
}

```

`ReClass.NET/Forms/InputBytesForm.Designer.cs`:

```cs
namespace ReClassNET.Forms
{
	partial class InputBytesForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.hexRadioButton = new System.Windows.Forms.RadioButton();
			this.decimalRadioButton = new System.Windows.Forms.RadioButton();
			this.label2 = new System.Windows.Forms.Label();
			this.currentSizeLabel = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.newSizeLabel = new System.Windows.Forms.Label();
			this.okButton = new System.Windows.Forms.Button();
			this.bytesNumericUpDown = new System.Windows.Forms.NumericUpDown();
			((System.ComponentModel.ISupportInitialize)(this.bytesNumericUpDown)).BeginInit();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(5, 9);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(121, 13);
			this.label1.TabIndex = 1;
			this.label1.Text = "Number of Bytes to add:";
			// 
			// hexRadioButton
			// 
			this.hexRadioButton.AutoSize = true;
			this.hexRadioButton.Location = new System.Drawing.Point(77, 51);
			this.hexRadioButton.Name = "hexRadioButton";
			this.hexRadioButton.Size = new System.Drawing.Size(44, 17);
			this.hexRadioButton.TabIndex = 2;
			this.hexRadioButton.Text = "Hex";
			this.hexRadioButton.UseVisualStyleBackColor = true;
			this.hexRadioButton.CheckedChanged += new System.EventHandler(this.hexRadioButton_CheckedChanged);
			// 
			// decimalRadioButton
			// 
			this.decimalRadioButton.AutoSize = true;
			this.decimalRadioButton.Checked = true;
			this.decimalRadioButton.Location = new System.Drawing.Point(8, 51);
			this.decimalRadioButton.Name = "decimalRadioButton";
			this.decimalRadioButton.Size = new System.Drawing.Size(63, 17);
			this.decimalRadioButton.TabIndex = 3;
			this.decimalRadioButton.TabStop = true;
			this.decimalRadioButton.Text = "Decimal";
			this.decimalRadioButton.UseVisualStyleBackColor = true;
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(5, 79);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(92, 13);
			this.label2.TabIndex = 4;
			this.label2.Text = "Current class size:";
			// 
			// currentSizeLabel
			// 
			this.currentSizeLabel.AutoSize = true;
			this.currentSizeLabel.Location = new System.Drawing.Point(111, 79);
			this.currentSizeLabel.Name = "currentSizeLabel";
			this.currentSizeLabel.Size = new System.Drawing.Size(19, 13);
			this.currentSizeLabel.TabIndex = 5;
			this.currentSizeLabel.Text = "<>";
			// 
			// label4
			// 
			this.label4.AutoSize = true;
			this.label4.Location = new System.Drawing.Point(5, 98);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(80, 13);
			this.label4.TabIndex = 6;
			this.label4.Text = "New class size:";
			// 
			// newSizeLabel
			// 
			this.newSizeLabel.AutoSize = true;
			this.newSizeLabel.Location = new System.Drawing.Point(111, 98);
			this.newSizeLabel.Name = "newSizeLabel";
			this.newSizeLabel.Size = new System.Drawing.Size(19, 13);
			this.newSizeLabel.TabIndex = 7;
			this.newSizeLabel.Text = "<>";
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(146, 121);
			this.okButton.Name = "okButton";
			this.okButton.Size = new System.Drawing.Size(75, 23);
			this.okButton.TabIndex = 8;
			this.okButton.Text = "OK";
			this.okButton.TextImageRelation = System.Windows.Forms.TextImageRelation.ImageBeforeText;
			this.okButton.UseVisualStyleBackColor = true;
			// 
			// bytesNumericUpDown
			// 
			this.bytesNumericUpDown.Location = new System.Drawing.Point(8, 25);
			this.bytesNumericUpDown.Name = "bytesNumericUpDown";
			this.bytesNumericUpDown.Size = new System.Drawing.Size(212, 20);
			this.bytesNumericUpDown.TabIndex = 9;
			this.bytesNumericUpDown.ValueChanged += new System.EventHandler(this.bytesNumericUpDown_ValueChanged);
			// 
			// InputBytesForm
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(228, 151);
			this.Controls.Add(this.bytesNumericUpDown);
			this.Controls.Add(this.okButton);
			this.Controls.Add(this.newSizeLabel);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.currentSizeLabel);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.decimalRadioButton);
			this.Controls.Add(this.hexRadioButton);
			this.Controls.Add(this.label1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "InputBytesForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "<>";
			((System.ComponentModel.ISupportInitialize)(this.bytesNumericUpDown)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.RadioButton hexRadioButton;
		private System.Windows.Forms.RadioButton decimalRadioButton;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label currentSizeLabel;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label newSizeLabel;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.NumericUpDown bytesNumericUpDown;
	}
}
```

`ReClass.NET/Forms/InputBytesForm.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Windows.Forms;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class InputBytesForm : IconForm
	{
		private readonly int currentSize;

		public int Bytes => (int)bytesNumericUpDown.Value;

		public InputBytesForm(int currentSize)
		{
			this.currentSize = currentSize;

			InitializeComponent();

			bytesNumericUpDown.Maximum = int.MaxValue;

			FormatLabelText(currentSizeLabel, currentSize);
			FormatLabelText(newSizeLabel, currentSize);
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void hexRadioButton_CheckedChanged(object sender, EventArgs e)
		{
			bytesNumericUpDown.Hexadecimal = hexRadioButton.Checked;
		}

		private void bytesNumericUpDown_ValueChanged(object sender, EventArgs e)
		{
			FormatLabelText(newSizeLabel, currentSize + Bytes);
		}

		#endregion

		private void FormatLabelText(Label label, int size)
		{
			Contract.Requires(label != null);

			label.Text = $"0x{size:X} / {size}";
		}
	}
}

```

`ReClass.NET/Forms/InputBytesForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/InputCorrelatorForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class InputCorrelatorForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.refineTimer = new System.Windows.Forms.Timer(this.components);
			this.bannerBox = new BannerBox();
			this.settingsGroupBox = new System.Windows.Forms.GroupBox();
			this.removeButton = new System.Windows.Forms.Button();
			this.addButton = new System.Windows.Forms.Button();
			this.valueTypeComboBox = new ReClassNET.Forms.ScannerForm.ScanValueTypeComboBox();
			this.label1 = new System.Windows.Forms.Label();
			this.hotkeyListBox = new System.Windows.Forms.ListBox();
			this.hotkeyBox = new HotkeyBox();
			this.startStopButton = new System.Windows.Forms.Button();
			this.infoLabel = new System.Windows.Forms.Label();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.settingsGroupBox.SuspendLayout();
			this.SuspendLayout();
			// 
			// refineTimer
			// 
			this.refineTimer.Interval = 50;
			this.refineTimer.Tick += new System.EventHandler(this.refineTimer_Tick);
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Canvas_Size;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(301, 48);
			this.bannerBox.TabIndex = 8;
			this.bannerBox.Text = "Scan for values correlated to input.";
			this.bannerBox.Title = "Input Correlator";
			// 
			// settingsGroupBox
			// 
			this.settingsGroupBox.Controls.Add(this.removeButton);
			this.settingsGroupBox.Controls.Add(this.addButton);
			this.settingsGroupBox.Controls.Add(this.valueTypeComboBox);
			this.settingsGroupBox.Controls.Add(this.label1);
			this.settingsGroupBox.Controls.Add(this.hotkeyListBox);
			this.settingsGroupBox.Controls.Add(this.hotkeyBox);
			this.settingsGroupBox.Location = new System.Drawing.Point(7, 54);
			this.settingsGroupBox.Name = "settingsGroupBox";
			this.settingsGroupBox.Size = new System.Drawing.Size(288, 179);
			this.settingsGroupBox.TabIndex = 9;
			this.settingsGroupBox.TabStop = false;
			this.settingsGroupBox.Text = "Settings";
			// 
			// removeButton
			// 
			this.removeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.removeButton.Location = new System.Drawing.Point(203, 45);
			this.removeButton.Name = "removeButton";
			this.removeButton.Size = new System.Drawing.Size(79, 23);
			this.removeButton.TabIndex = 13;
			this.removeButton.Text = "Remove Key";
			this.removeButton.UseVisualStyleBackColor = true;
			this.removeButton.Click += new System.EventHandler(this.removeButton_Click);
			// 
			// addButton
			// 
			this.addButton.Location = new System.Drawing.Point(6, 45);
			this.addButton.Name = "addButton";
			this.addButton.Size = new System.Drawing.Size(58, 23);
			this.addButton.TabIndex = 12;
			this.addButton.Text = "Add Key";
			this.addButton.UseVisualStyleBackColor = true;
			this.addButton.Click += new System.EventHandler(this.addButton_Click);
			// 
			// valueTypeComboBox
			// 
			this.valueTypeComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.valueTypeComboBox.Location = new System.Drawing.Point(66, 149);
			this.valueTypeComboBox.Name = "valueTypeComboBox";
			this.valueTypeComboBox.Size = new System.Drawing.Size(216, 21);
			this.valueTypeComboBox.TabIndex = 11;
			// 
			// label1
			// 
			this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(3, 152);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(64, 13);
			this.label1.TabIndex = 12;
			this.label1.Text = "Value Type:";
			// 
			// hotkeyListBox
			// 
			this.hotkeyListBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.hotkeyListBox.FormattingEnabled = true;
			this.hotkeyListBox.Location = new System.Drawing.Point(6, 74);
			this.hotkeyListBox.Name = "hotkeyListBox";
			this.hotkeyListBox.Size = new System.Drawing.Size(276, 69);
			this.hotkeyListBox.TabIndex = 11;
			// 
			// hotkeyBox
			// 
			this.hotkeyBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.hotkeyBox.Input = null;
			this.hotkeyBox.Location = new System.Drawing.Point(6, 19);
			this.hotkeyBox.Name = "hotkeyBox";
			this.hotkeyBox.Size = new System.Drawing.Size(276, 20);
			this.hotkeyBox.TabIndex = 10;
			// 
			// startStopButton
			// 
			this.startStopButton.Location = new System.Drawing.Point(7, 239);
			this.startStopButton.Name = "startStopButton";
			this.startStopButton.Size = new System.Drawing.Size(288, 23);
			this.startStopButton.TabIndex = 13;
			this.startStopButton.Text = "Start Scan";
			this.startStopButton.UseVisualStyleBackColor = true;
			this.startStopButton.Click += new System.EventHandler(this.startStopButton_Click);
			// 
			// infoLabel
			// 
			this.infoLabel.AutoSize = true;
			this.infoLabel.Location = new System.Drawing.Point(4, 265);
			this.infoLabel.Name = "infoLabel";
			this.infoLabel.Size = new System.Drawing.Size(19, 13);
			this.infoLabel.TabIndex = 11;
			this.infoLabel.Text = "<>";
			// 
			// InputCorrelatorForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(301, 287);
			this.Controls.Add(this.infoLabel);
			this.Controls.Add(this.startStopButton);
			this.Controls.Add(this.settingsGroupBox);
			this.Controls.Add(this.bannerBox);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "InputCorrelatorForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Input Correlator";
			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.InputCorrelatorForm_FormClosing);
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.settingsGroupBox.ResumeLayout(false);
			this.settingsGroupBox.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion
		private System.Windows.Forms.Timer refineTimer;
		private BannerBox bannerBox;
		private System.Windows.Forms.GroupBox settingsGroupBox;
		private HotkeyBox hotkeyBox;
		private System.Windows.Forms.ListBox hotkeyListBox;
		private System.Windows.Forms.Button removeButton;
		private System.Windows.Forms.Button addButton;
		private ScannerForm.ScanValueTypeComboBox valueTypeComboBox;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Button startStopButton;
		private System.Windows.Forms.Label infoLabel;
	}
}
```

`ReClass.NET/Forms/InputCorrelatorForm.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.Input;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class InputCorrelatorForm : IconForm
	{
		private static readonly TimeSpan refineInterval = TimeSpan.FromMilliseconds(400);

		private readonly ScannerForm scannerForm;
		private readonly RemoteProcess process;

		private readonly KeyboardInput input;
		private InputCorrelatedScanner scanner;

		private bool isScanning = false;
		private DateTime lastRefineTime;

		public InputCorrelatorForm(ScannerForm scannerForm, RemoteProcess process)
		{
			Contract.Requires(scannerForm != null);
			Contract.Requires(process != null);

			this.scannerForm = scannerForm;
			this.process = process;

			InitializeComponent();

			valueTypeComboBox.SetAvailableValues(
				ScanValueType.Byte,
				ScanValueType.Short,
				ScanValueType.Integer,
				ScanValueType.Long,
				ScanValueType.Float,
				ScanValueType.Double
			);
			valueTypeComboBox.SelectedValue = ScanValueType.Integer;

			input = new KeyboardInput();

			hotkeyBox.Input = input;

			infoLabel.Text = string.Empty;
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private async void InputCorrelatorForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			hotkeyBox.Input = null;

			refineTimer.Enabled = false;

			if (isScanning)
			{
				e.Cancel = true;

				Hide();

				await Task.Delay(TimeSpan.FromSeconds(1));

				Close();

				return;
			}

			scanner?.Dispose();

			input?.Dispose();
		}

		private void addButton_Click(object sender, EventArgs e)
		{
			var hotkey = hotkeyBox.Hotkey.Clone();
			if (hotkey.IsEmpty)
			{
				return;
			}

			hotkeyListBox.Items.Add(hotkey);

			hotkeyBox.Clear();
		}

		private void removeButton_Click(object sender, EventArgs e)
		{
			var index = hotkeyListBox.SelectedIndex;
			if (index < 0)
			{
				return;
			}

			hotkeyListBox.Items.RemoveAt(index);
		}

		private async void startStopButton_Click(object sender, EventArgs e)
		{
			if (scanner == null)
			{
				if (hotkeyListBox.Items.Count == 0)
				{
					MessageBox.Show("Please add at least one hotkey.", Constants.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Error);

					return;
				}

				scanner = new InputCorrelatedScanner(
					process,
					input,
					hotkeyListBox.Items.Cast<KeyboardHotkey>(),
					valueTypeComboBox.SelectedValue
				);

				settingsGroupBox.Enabled = false;

				try
				{
					await scanner.Initialize();

					startStopButton.Text = "Stop Scan";

					refineTimer.Enabled = true;

					return;
				}
				catch (Exception ex)
				{
					Program.ShowException(ex);
				}
			}
			else
			{
				refineTimer.Enabled = false;

				startStopButton.Text = "Start Scan";

				while (isScanning)
				{
					await Task.Delay(TimeSpan.FromSeconds(1));
				}

				scannerForm.ShowScannerResults(scanner);

				scanner.Dispose();
				scanner = null;
			}

			settingsGroupBox.Enabled = true;
		}

		private async void refineTimer_Tick(object sender, EventArgs e)
		{
			if (isScanning)
			{
				return;
			}

			scanner.CorrelateInput();

			if (lastRefineTime + refineInterval < DateTime.Now)
			{
				isScanning = true;

				try
				{
					await scanner.RefineResults(CancellationToken.None, null);

					infoLabel.Text = $"Scan Count: {scanner.ScanCount} Possible Values: {scanner.TotalResultCount}";
				}
				catch (Exception ex)
				{
					Program.ShowException(ex);
				}

				isScanning = false;

				lastRefineTime = DateTime.Now;
			}
		}

		#endregion
	}
}

```

`ReClass.NET/Forms/InputCorrelatorForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="refineTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/LogForm.Designer.cs`:

```cs
namespace ReClassNET.Forms
{
	partial class LogForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.closeButton = new System.Windows.Forms.Button();
			this.copyToClipboardButton = new System.Windows.Forms.Button();
			this.entriesDataGridView = new System.Windows.Forms.DataGridView();
			this.iconColumn = new System.Windows.Forms.DataGridViewImageColumn();
			this.messageColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.contextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.showDetailsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			((System.ComponentModel.ISupportInitialize)(this.entriesDataGridView)).BeginInit();
			this.contextMenuStrip.SuspendLayout();
			this.SuspendLayout();
			// 
			// closeButton
			// 
			this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.closeButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.closeButton.Location = new System.Drawing.Point(466, 206);
			this.closeButton.Name = "closeButton";
			this.closeButton.Size = new System.Drawing.Size(109, 23);
			this.closeButton.TabIndex = 2;
			this.closeButton.Text = "Close";
			this.closeButton.UseVisualStyleBackColor = true;
			this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
			// 
			// copyToClipboardButton
			// 
			this.copyToClipboardButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.copyToClipboardButton.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Copy;
			this.copyToClipboardButton.Location = new System.Drawing.Point(12, 206);
			this.copyToClipboardButton.Name = "copyToClipboardButton";
			this.copyToClipboardButton.Size = new System.Drawing.Size(120, 23);
			this.copyToClipboardButton.TabIndex = 3;
			this.copyToClipboardButton.Text = "Copy to Clipboard";
			this.copyToClipboardButton.TextImageRelation = System.Windows.Forms.TextImageRelation.ImageBeforeText;
			this.copyToClipboardButton.UseVisualStyleBackColor = true;
			this.copyToClipboardButton.Click += new System.EventHandler(this.copyToClipboardButton_Click);
			// 
			// entriesDataGridView
			// 
			this.entriesDataGridView.AllowUserToAddRows = false;
			this.entriesDataGridView.AllowUserToDeleteRows = false;
			this.entriesDataGridView.AllowUserToResizeColumns = false;
			this.entriesDataGridView.AllowUserToResizeRows = false;
			this.entriesDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.entriesDataGridView.BackgroundColor = System.Drawing.SystemColors.Window;
			this.entriesDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.entriesDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
			this.entriesDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.entriesDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.iconColumn,
            this.messageColumn});
			this.entriesDataGridView.Location = new System.Drawing.Point(12, 12);
			this.entriesDataGridView.MultiSelect = false;
			this.entriesDataGridView.Name = "entriesDataGridView";
			this.entriesDataGridView.ReadOnly = true;
			this.entriesDataGridView.RowHeadersVisible = false;
			this.entriesDataGridView.ContextMenuStrip = this.contextMenuStrip;
			this.entriesDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.entriesDataGridView.Size = new System.Drawing.Size(563, 188);
			this.entriesDataGridView.TabIndex = 1;
			this.entriesDataGridView.CellContentDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.entriesDataGridView_CellContentDoubleClick);
			// 
			// iconColumn
			// 
			this.iconColumn.DataPropertyName = "Icon";
			this.iconColumn.HeaderText = "";
			this.iconColumn.MinimumWidth = 18;
			this.iconColumn.Name = "iconColumn";
			this.iconColumn.ReadOnly = true;
			this.iconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
			this.iconColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.Automatic;
			this.iconColumn.Width = 18;
			// 
			// messageColumn
			// 
			this.messageColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.messageColumn.DataPropertyName = "Message";
			this.messageColumn.HeaderText = "Message";
			this.messageColumn.Name = "messageColumn";
			this.messageColumn.ReadOnly = true;
			// 
			// contextMenuStrip
			// 
			this.contextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.showDetailsToolStripMenuItem});
			this.contextMenuStrip.Name = "contextMenuStrip";
			this.contextMenuStrip.Size = new System.Drawing.Size(150, 26);
			// 
			// showDetailsToolStripMenuItem
			// 
			this.showDetailsToolStripMenuItem.Name = "showDetailsToolStripMenuItem";
			this.showDetailsToolStripMenuItem.Size = new System.Drawing.Size(149, 22);
			this.showDetailsToolStripMenuItem.Text = "Show details...";
			this.showDetailsToolStripMenuItem.Click += new System.EventHandler(this.showDetailsToolStripMenuItem_Click);
			// 
			// LogForm
			// 
			this.AcceptButton = this.closeButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(587, 237);
			this.Controls.Add(this.copyToClipboardButton);
			this.Controls.Add(this.closeButton);
			this.Controls.Add(this.entriesDataGridView);
			this.Name = "LogForm";
			this.Text = "ReClass.NET - Diagnostic Messages";
			((System.ComponentModel.ISupportInitialize)(this.entriesDataGridView)).EndInit();
			this.contextMenuStrip.ResumeLayout(false);
			this.ResumeLayout(false);

		}

		#endregion
		private System.Windows.Forms.DataGridView entriesDataGridView;
		private System.Windows.Forms.DataGridViewImageColumn iconColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn messageColumn;
		private System.Windows.Forms.Button closeButton;
		private System.Windows.Forms.Button copyToClipboardButton;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem showDetailsToolStripMenuItem;
	}
}
```

`ReClass.NET/Forms/LogForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Logger;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class LogForm : IconForm
	{
		private class LogItem
		{
			public Image Icon { get; set; }

			public string Message { get; set; }

			public Exception Exception { get; set; }
		}

		private readonly List<LogItem> items = new List<LogItem>();

		public LogForm()
		{
			InitializeComponent();

			entriesDataGridView.AutoGenerateColumns = false;
			entriesDataGridView.DataSource = items;
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void copyToClipboardButton_Click(object sender, EventArgs e)
		{
			Clipboard.SetText(items.Select(i => i.Message).Aggregate((a, b) => $"{a}{Environment.NewLine}{b}"));
		}

		private void closeButton_Click(object sender, EventArgs e)
		{
			Close();
		}

		private void entriesDataGridView_CellContentDoubleClick(object sender, DataGridViewCellEventArgs e)
		{
			ShowDetailsForm();
		}

		private void showDetailsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			ShowDetailsForm();
		}

		#endregion

		private void RefreshDataBinding()
		{
			var cm = entriesDataGridView.BindingContext[items] as CurrencyManager;
			cm?.Refresh();
		}

		public void Clear()
		{
			items.Clear();

			RefreshDataBinding();
		}

		public void Add(LogLevel level, string message, Exception ex)
		{
			Contract.Requires(message != null);

			Image icon;
			switch (level)
			{
				case LogLevel.Error:
					icon = Properties.Resources.B16x16_Error;
					break;
				case LogLevel.Warning:
					icon = Properties.Resources.B16x16_Warning;
					break;
				case LogLevel.Information:
					icon = Properties.Resources.B16x16_Information;
					break;
				default:
					icon = Properties.Resources.B16x16_Gear;
					break;
			}

			items.Add(new LogItem { Icon = icon, Message = message, Exception = ex });

			RefreshDataBinding();
		}

		private void ShowDetailsForm()
		{
			var item = entriesDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault()?.DataBoundItem as LogItem;
			if (item?.Exception != null)
			{
				Program.ShowException(item.Exception);
			}
		}
	}
}

```

`ReClass.NET/Forms/LogForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="iconColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="messageColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="contextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/MainForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class MainForm
	{
		/// <summary>
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Verwendete Ressourcen bereinigen.
		/// </summary>
		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Vom Windows Form-Designer generierter Code

		/// <summary>
		/// Erforderliche Methode für die Designerunterstützung.
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
			this.processUpdateTimer = new System.Windows.Forms.Timer(this.components);
			this.splitContainer = new System.Windows.Forms.SplitContainer();
			this.projectView = new ReClassNET.Controls.ProjectView();
			this.projectClassContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.deleteClassToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator19 = new System.Windows.Forms.ToolStripSeparator();
			this.removeUnusedClassesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator20 = new System.Windows.Forms.ToolStripSeparator();
			this.showCodeOfClassToolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
			this.projectClassesContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.enableHierarchyViewToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.autoExpandHierarchyViewToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator21 = new System.Windows.Forms.ToolStripSeparator();
			this.expandAllClassesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.collapseAllClassesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator22 = new System.Windows.Forms.ToolStripSeparator();
			this.addNewClassToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.projectEnumContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.editEnumToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.projectEnumsContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.editEnumsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.memoryViewControl = new ReClassNET.Controls.MemoryViewControl();
			this.selectedNodeContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.changeTypeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.addBytesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.integerToolStripMenuItem1 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem2 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem3 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem4 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem5 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem6 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem7 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
			this.insertBytesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.integerToolStripMenuItem8 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem9 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem10 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem11 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem12 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem13 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.integerToolStripMenuItem14 = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator8 = new System.Windows.Forms.ToolStripSeparator();
			this.createClassFromNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator13 = new System.Windows.Forms.ToolStripSeparator();
			this.dissectNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator9 = new System.Windows.Forms.ToolStripSeparator();
			this.searchForEqualValuesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator15 = new System.Windows.Forms.ToolStripSeparator();
			this.findOutWhatAccessesThisAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.findOutWhatWritesToThisAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator14 = new System.Windows.Forms.ToolStripSeparator();
			this.copyNodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.pasteNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator10 = new System.Windows.Forms.ToolStripSeparator();
			this.removeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator12 = new System.Windows.Forms.ToolStripSeparator();
			this.hideNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.unhideNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.unhideChildNodesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.unhideNodesAboveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.unhideNodesBelowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator18 = new System.Windows.Forms.ToolStripSeparator();
			this.copyAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator11 = new System.Windows.Forms.ToolStripSeparator();
			this.showCodeOfClassToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.shrinkClassToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStrip = new System.Windows.Forms.ToolStrip();
			this.attachToProcessToolStripSplitButton = new System.Windows.Forms.ToolStripSplitButton();
			this.toolStripSeparator6 = new System.Windows.Forms.ToolStripSeparator();
			this.openProjectToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.saveToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.toolStripSeparator7 = new System.Windows.Forms.ToolStripSeparator();
			this.newClassToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.addBytesToolStripDropDownButton = new System.Windows.Forms.ToolStripDropDownButton();
			this.add4BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add8BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add64BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add256BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add1024BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add2048BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.add4096BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.addXBytesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.insertBytesToolStripDropDownButton = new System.Windows.Forms.ToolStripDropDownButton();
			this.insert4BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert8BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert64BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert256BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert1024BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert2048BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insert4096BytesToolStripMenuItem = new ReClassNET.Controls.IntegerToolStripMenuItem();
			this.insertXBytesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.nodeTypesToolStripSeparator = new System.Windows.Forms.ToolStripSeparator();
			this.statusStrip = new System.Windows.Forms.StatusStrip();
			this.processInfoToolStripStatusLabel = new System.Windows.Forms.ToolStripStatusLabel();
			this.infoToolStripStatusLabel = new System.Windows.Forms.ToolStripStatusLabel();
			this.mainMenuStrip = new System.Windows.Forms.MenuStrip();
			this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.attachToProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.reattachToProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.detachToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
			this.openProjectToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.mergeWithProjectToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.clearProjectToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
			this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.saveAsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
			this.settingsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.pluginsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator5 = new System.Windows.Forms.ToolStripSeparator();
			this.quitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.processToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.processInformationsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.memorySearcherToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.namedAddressesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator23 = new System.Windows.Forms.ToolStripSeparator();
			this.isLittleEndianToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator17 = new System.Windows.Forms.ToolStripSeparator();
			this.loadSymbolToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.loadSymbolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
			this.resumeProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.suspendProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.terminateProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.projectToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.goToClassToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.cleanUnusedClassesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.showEnumsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator16 = new System.Windows.Forms.ToolStripSeparator();
			this.generateCppCodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.generateCSharpCodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			((System.ComponentModel.ISupportInitialize)(this.splitContainer)).BeginInit();
			this.splitContainer.Panel1.SuspendLayout();
			this.splitContainer.Panel2.SuspendLayout();
			this.splitContainer.SuspendLayout();
			this.projectClassContextMenuStrip.SuspendLayout();
			this.projectClassesContextMenuStrip.SuspendLayout();
			this.projectEnumContextMenuStrip.SuspendLayout();
			this.projectEnumsContextMenuStrip.SuspendLayout();
			this.selectedNodeContextMenuStrip.SuspendLayout();
			this.toolStrip.SuspendLayout();
			this.statusStrip.SuspendLayout();
			this.mainMenuStrip.SuspendLayout();
			this.SuspendLayout();
			// 
			// processUpdateTimer
			// 
			this.processUpdateTimer.Enabled = true;
			this.processUpdateTimer.Interval = 5000;
			this.processUpdateTimer.Tick += new System.EventHandler(this.processUpdateTimer_Tick);
			// 
			// splitContainer
			// 
			this.splitContainer.Dock = System.Windows.Forms.DockStyle.Fill;
			this.splitContainer.FixedPanel = System.Windows.Forms.FixedPanel.Panel1;
			this.splitContainer.Location = new System.Drawing.Point(0, 49);
			this.splitContainer.Name = "splitContainer";
			// 
			// splitContainer.Panel1
			// 
			this.splitContainer.Panel1.Controls.Add(this.projectView);
			// 
			// splitContainer.Panel2
			// 
			this.splitContainer.Panel2.BackColor = System.Drawing.SystemColors.Control;
			this.splitContainer.Panel2.Controls.Add(this.memoryViewControl);
			this.splitContainer.Size = new System.Drawing.Size(1141, 524);
			this.splitContainer.SplitterDistance = 201;
			this.splitContainer.TabIndex = 4;
			// 
			// projectView
			// 
			this.projectView.ClassContextMenuStrip = this.projectClassContextMenuStrip;
			this.projectView.ClassesContextMenuStrip = this.projectClassesContextMenuStrip;
			this.projectView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.projectView.EnumContextMenuStrip = this.projectEnumContextMenuStrip;
			this.projectView.EnumsContextMenuStrip = this.projectEnumsContextMenuStrip;
			this.projectView.Location = new System.Drawing.Point(0, 0);
			this.projectView.Name = "projectView";
			this.projectView.Size = new System.Drawing.Size(201, 524);
			this.projectView.TabIndex = 0;
			this.projectView.SelectionChanged += new ReClassNET.Controls.ProjectView.SelectionChangedEvent(this.classesView_ClassSelected);
			// 
			// projectClassContextMenuStrip
			// 
			this.projectClassContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.deleteClassToolStripMenuItem,
            this.toolStripSeparator19,
            this.removeUnusedClassesToolStripMenuItem,
            this.toolStripSeparator20,
            this.showCodeOfClassToolStripMenuItem2});
			this.projectClassContextMenuStrip.Name = "contextMenuStrip";
			this.projectClassContextMenuStrip.Size = new System.Drawing.Size(206, 82);
			// 
			// deleteClassToolStripMenuItem
			// 
			this.deleteClassToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Remove;
			this.deleteClassToolStripMenuItem.Name = "deleteClassToolStripMenuItem";
			this.deleteClassToolStripMenuItem.Size = new System.Drawing.Size(205, 22);
			this.deleteClassToolStripMenuItem.Text = "Delete class";
			this.deleteClassToolStripMenuItem.Click += new System.EventHandler(this.deleteClassToolStripMenuItem_Click);
			// 
			// toolStripSeparator19
			// 
			this.toolStripSeparator19.Name = "toolStripSeparator19";
			this.toolStripSeparator19.Size = new System.Drawing.Size(202, 6);
			// 
			// removeUnusedClassesToolStripMenuItem
			// 
			this.removeUnusedClassesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Chart_Delete;
			this.removeUnusedClassesToolStripMenuItem.Name = "removeUnusedClassesToolStripMenuItem";
			this.removeUnusedClassesToolStripMenuItem.Size = new System.Drawing.Size(205, 22);
			this.removeUnusedClassesToolStripMenuItem.Text = "Remove unused classes";
			this.removeUnusedClassesToolStripMenuItem.Click += new System.EventHandler(this.removeUnusedClassesToolStripMenuItem_Click);
			// 
			// toolStripSeparator20
			// 
			this.toolStripSeparator20.Name = "toolStripSeparator20";
			this.toolStripSeparator20.Size = new System.Drawing.Size(202, 6);
			// 
			// showCodeOfClassToolStripMenuItem2
			// 
			this.showCodeOfClassToolStripMenuItem2.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Code_Cpp;
			this.showCodeOfClassToolStripMenuItem2.Name = "showCodeOfClassToolStripMenuItem2";
			this.showCodeOfClassToolStripMenuItem2.Size = new System.Drawing.Size(205, 22);
			this.showCodeOfClassToolStripMenuItem2.Text = "Show C++ Code of Class";
			this.showCodeOfClassToolStripMenuItem2.Click += new System.EventHandler(this.showCodeOfClassToolStripMenuItem2_Click);
			// 
			// projectClassesContextMenuStrip
			// 
			this.projectClassesContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.enableHierarchyViewToolStripMenuItem,
            this.autoExpandHierarchyViewToolStripMenuItem,
            this.toolStripSeparator21,
            this.expandAllClassesToolStripMenuItem,
            this.collapseAllClassesToolStripMenuItem,
            this.toolStripSeparator22,
            this.addNewClassToolStripMenuItem});
			this.projectClassesContextMenuStrip.Name = "rootContextMenuStrip";
			this.projectClassesContextMenuStrip.Size = new System.Drawing.Size(222, 126);
			// 
			// enableHierarchyViewToolStripMenuItem
			// 
			this.enableHierarchyViewToolStripMenuItem.Name = "enableHierarchyViewToolStripMenuItem";
			this.enableHierarchyViewToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
			this.enableHierarchyViewToolStripMenuItem.Text = "Enable hierarchy view";
			this.enableHierarchyViewToolStripMenuItem.Click += new System.EventHandler(this.enableHierarchyViewToolStripMenuItem_Click);
			// 
			// autoExpandHierarchyViewToolStripMenuItem
			// 
			this.autoExpandHierarchyViewToolStripMenuItem.Name = "autoExpandHierarchyViewToolStripMenuItem";
			this.autoExpandHierarchyViewToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
			this.autoExpandHierarchyViewToolStripMenuItem.Text = "Auto expand hierarchy view";
			this.autoExpandHierarchyViewToolStripMenuItem.Click += new System.EventHandler(this.autoExpandHierarchyViewToolStripMenuItem_Click);
			// 
			// toolStripSeparator21
			// 
			this.toolStripSeparator21.Name = "toolStripSeparator21";
			this.toolStripSeparator21.Size = new System.Drawing.Size(218, 6);
			// 
			// expandAllClassesToolStripMenuItem
			// 
			this.expandAllClassesToolStripMenuItem.Enabled = false;
			this.expandAllClassesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Tree_Expand;
			this.expandAllClassesToolStripMenuItem.Name = "expandAllClassesToolStripMenuItem";
			this.expandAllClassesToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
			this.expandAllClassesToolStripMenuItem.Text = "Expand all classes";
			this.expandAllClassesToolStripMenuItem.Click += new System.EventHandler(this.expandAllClassesToolStripMenuItem_Click);
			// 
			// collapseAllClassesToolStripMenuItem
			// 
			this.collapseAllClassesToolStripMenuItem.Enabled = false;
			this.collapseAllClassesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Tree_Collapse;
			this.collapseAllClassesToolStripMenuItem.Name = "collapseAllClassesToolStripMenuItem";
			this.collapseAllClassesToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
			this.collapseAllClassesToolStripMenuItem.Text = "Collapse all classes";
			this.collapseAllClassesToolStripMenuItem.Click += new System.EventHandler(this.collapseAllClassesToolStripMenuItem_Click);
			// 
			// toolStripSeparator22
			// 
			this.toolStripSeparator22.Name = "toolStripSeparator22";
			this.toolStripSeparator22.Size = new System.Drawing.Size(218, 6);
			// 
			// addNewClassToolStripMenuItem
			// 
			this.addNewClassToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.addNewClassToolStripMenuItem.Name = "addNewClassToolStripMenuItem";
			this.addNewClassToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
			this.addNewClassToolStripMenuItem.Text = "Add new class";
			this.addNewClassToolStripMenuItem.Click += new System.EventHandler(this.newClassToolStripButton_Click);
			// 
			// projectEnumContextMenuStrip
			// 
			this.projectEnumContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.editEnumToolStripMenuItem});
			this.projectEnumContextMenuStrip.Name = "projectEnumContextMenuStrip";
			this.projectEnumContextMenuStrip.Size = new System.Drawing.Size(138, 26);
			// 
			// editEnumToolStripMenuItem
			// 
			this.editEnumToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Enum_Type;
			this.editEnumToolStripMenuItem.Name = "editEnumToolStripMenuItem";
			this.editEnumToolStripMenuItem.Size = new System.Drawing.Size(137, 22);
			this.editEnumToolStripMenuItem.Text = "Edit Enum...";
			this.editEnumToolStripMenuItem.Click += new System.EventHandler(this.editEnumToolStripMenuItem_Click);
			// 
			// projectEnumsContextMenuStrip
			// 
			this.projectEnumsContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.editEnumsToolStripMenuItem});
			this.projectEnumsContextMenuStrip.Name = "projectEnumsContextMenuStrip";
			this.projectEnumsContextMenuStrip.Size = new System.Drawing.Size(143, 26);
			// 
			// editEnumsToolStripMenuItem
			// 
			this.editEnumsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Category;
			this.editEnumsToolStripMenuItem.Name = "editEnumsToolStripMenuItem";
			this.editEnumsToolStripMenuItem.Size = new System.Drawing.Size(142, 22);
			this.editEnumsToolStripMenuItem.Text = "Edit enums...";
			this.editEnumsToolStripMenuItem.Click += new System.EventHandler(this.editEnumsToolStripMenuItem_Click);
			// 
			// memoryViewControl
			// 
			this.memoryViewControl.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.memoryViewControl.Dock = System.Windows.Forms.DockStyle.Fill;
			this.memoryViewControl.Location = new System.Drawing.Point(0, 0);
			this.memoryViewControl.Name = "memoryViewControl";
			this.memoryViewControl.NodeContextMenuStrip = this.selectedNodeContextMenuStrip;
			this.memoryViewControl.Size = new System.Drawing.Size(936, 524);
			this.memoryViewControl.TabIndex = 0;
			this.memoryViewControl.DrawContextRequested += new ReClassNET.Controls.DrawContextRequestEventHandler(this.memoryViewControl_DrawContextRequested);
			this.memoryViewControl.SelectionChanged += new System.EventHandler(this.memoryViewControl_SelectionChanged);
			this.memoryViewControl.ChangeClassTypeClick += new ReClassNET.Controls.NodeClickEventHandler(this.memoryViewControl_ChangeClassTypeClick);
			this.memoryViewControl.ChangeWrappedTypeClick += new ReClassNET.Controls.NodeClickEventHandler(this.memoryViewControl_ChangeWrappedTypeClick);
			this.memoryViewControl.ChangeEnumTypeClick += new ReClassNET.Controls.NodeClickEventHandler(this.memoryViewControl_ChangeEnumTypeClick);
			this.memoryViewControl.KeyDown += new System.Windows.Forms.KeyEventHandler(this.memoryViewControl_KeyDown);
			// 
			// selectedNodeContextMenuStrip
			// 
			this.selectedNodeContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.changeTypeToolStripMenuItem,
            this.addBytesToolStripMenuItem,
            this.insertBytesToolStripMenuItem,
            this.toolStripSeparator8,
            this.createClassFromNodesToolStripMenuItem,
            this.toolStripSeparator13,
            this.dissectNodesToolStripMenuItem,
            this.toolStripSeparator9,
            this.searchForEqualValuesToolStripMenuItem,
            this.toolStripSeparator15,
            this.findOutWhatAccessesThisAddressToolStripMenuItem,
            this.findOutWhatWritesToThisAddressToolStripMenuItem,
            this.toolStripSeparator14,
            this.copyNodeToolStripMenuItem,
            this.pasteNodesToolStripMenuItem,
            this.toolStripSeparator10,
            this.removeToolStripMenuItem,
            this.toolStripSeparator12,
            this.hideNodesToolStripMenuItem,
            this.unhideNodesToolStripMenuItem,
            this.toolStripSeparator18,
            this.copyAddressToolStripMenuItem,
            this.toolStripSeparator11,
            this.showCodeOfClassToolStripMenuItem,
            this.shrinkClassToolStripMenuItem});
			this.selectedNodeContextMenuStrip.Name = "selectedNodeContextMenuStrip";
			this.selectedNodeContextMenuStrip.Size = new System.Drawing.Size(270, 410);
			this.selectedNodeContextMenuStrip.Opening += new System.ComponentModel.CancelEventHandler(this.selectedNodeContextMenuStrip_Opening);
			// 
			// changeTypeToolStripMenuItem
			// 
			this.changeTypeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Exchange_Button;
			this.changeTypeToolStripMenuItem.Name = "changeTypeToolStripMenuItem";
			this.changeTypeToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.changeTypeToolStripMenuItem.Text = "Change Type";
			// 
			// addBytesToolStripMenuItem
			// 
			this.addBytesToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.integerToolStripMenuItem1,
            this.integerToolStripMenuItem2,
            this.integerToolStripMenuItem3,
            this.integerToolStripMenuItem4,
            this.integerToolStripMenuItem5,
            this.integerToolStripMenuItem6,
            this.integerToolStripMenuItem7,
            this.toolStripMenuItem1});
			this.addBytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_X;
			this.addBytesToolStripMenuItem.Name = "addBytesToolStripMenuItem";
			this.addBytesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.addBytesToolStripMenuItem.Text = "Add Bytes";
			// 
			// integerToolStripMenuItem1
			// 
			this.integerToolStripMenuItem1.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_4;
			this.integerToolStripMenuItem1.Name = "integerToolStripMenuItem1";
			this.integerToolStripMenuItem1.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem1.Text = "Add 4 Bytes";
			this.integerToolStripMenuItem1.Value = 4;
			this.integerToolStripMenuItem1.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem2
			// 
			this.integerToolStripMenuItem2.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_8;
			this.integerToolStripMenuItem2.Name = "integerToolStripMenuItem2";
			this.integerToolStripMenuItem2.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem2.Text = "Add 8 Bytes";
			this.integerToolStripMenuItem2.Value = 8;
			this.integerToolStripMenuItem2.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem3
			// 
			this.integerToolStripMenuItem3.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_64;
			this.integerToolStripMenuItem3.Name = "integerToolStripMenuItem3";
			this.integerToolStripMenuItem3.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem3.Text = "Add 64 Bytes";
			this.integerToolStripMenuItem3.Value = 64;
			this.integerToolStripMenuItem3.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem4
			// 
			this.integerToolStripMenuItem4.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_256;
			this.integerToolStripMenuItem4.Name = "integerToolStripMenuItem4";
			this.integerToolStripMenuItem4.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem4.Text = "Add 256 Bytes";
			this.integerToolStripMenuItem4.Value = 256;
			this.integerToolStripMenuItem4.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem5
			// 
			this.integerToolStripMenuItem5.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_1024;
			this.integerToolStripMenuItem5.Name = "integerToolStripMenuItem5";
			this.integerToolStripMenuItem5.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem5.Text = "Add 1024 Bytes";
			this.integerToolStripMenuItem5.Value = 1024;
			this.integerToolStripMenuItem5.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem6
			// 
			this.integerToolStripMenuItem6.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_2048;
			this.integerToolStripMenuItem6.Name = "integerToolStripMenuItem6";
			this.integerToolStripMenuItem6.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem6.Text = "Add 2048 Bytes";
			this.integerToolStripMenuItem6.Value = 2048;
			this.integerToolStripMenuItem6.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem7
			// 
			this.integerToolStripMenuItem7.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_4096;
			this.integerToolStripMenuItem7.Name = "integerToolStripMenuItem7";
			this.integerToolStripMenuItem7.Size = new System.Drawing.Size(154, 22);
			this.integerToolStripMenuItem7.Text = "Add 4096 Bytes";
			this.integerToolStripMenuItem7.Value = 4096;
			this.integerToolStripMenuItem7.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// toolStripMenuItem1
			// 
			this.toolStripMenuItem1.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_X;
			this.toolStripMenuItem1.Name = "toolStripMenuItem1";
			this.toolStripMenuItem1.Size = new System.Drawing.Size(154, 22);
			this.toolStripMenuItem1.Text = "Add ... Bytes";
			this.toolStripMenuItem1.Click += new System.EventHandler(this.addXBytesToolStripMenuItem_Click);
			// 
			// insertBytesToolStripMenuItem
			// 
			this.insertBytesToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.integerToolStripMenuItem8,
            this.integerToolStripMenuItem9,
            this.integerToolStripMenuItem10,
            this.integerToolStripMenuItem11,
            this.integerToolStripMenuItem12,
            this.integerToolStripMenuItem13,
            this.integerToolStripMenuItem14,
            this.toolStripMenuItem2});
			this.insertBytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_X;
			this.insertBytesToolStripMenuItem.Name = "insertBytesToolStripMenuItem";
			this.insertBytesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.insertBytesToolStripMenuItem.Text = "Insert Bytes";
			// 
			// integerToolStripMenuItem8
			// 
			this.integerToolStripMenuItem8.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_4;
			this.integerToolStripMenuItem8.Name = "integerToolStripMenuItem8";
			this.integerToolStripMenuItem8.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem8.Text = "Insert 4 Bytes";
			this.integerToolStripMenuItem8.Value = 4;
			this.integerToolStripMenuItem8.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem9
			// 
			this.integerToolStripMenuItem9.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_8;
			this.integerToolStripMenuItem9.Name = "integerToolStripMenuItem9";
			this.integerToolStripMenuItem9.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem9.Text = "Insert 8 Bytes";
			this.integerToolStripMenuItem9.Value = 8;
			this.integerToolStripMenuItem9.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem10
			// 
			this.integerToolStripMenuItem10.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_64;
			this.integerToolStripMenuItem10.Name = "integerToolStripMenuItem10";
			this.integerToolStripMenuItem10.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem10.Text = "Insert 64 Bytes";
			this.integerToolStripMenuItem10.Value = 64;
			this.integerToolStripMenuItem10.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem11
			// 
			this.integerToolStripMenuItem11.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_256;
			this.integerToolStripMenuItem11.Name = "integerToolStripMenuItem11";
			this.integerToolStripMenuItem11.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem11.Text = "Insert 256 Bytes";
			this.integerToolStripMenuItem11.Value = 256;
			this.integerToolStripMenuItem11.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem12
			// 
			this.integerToolStripMenuItem12.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_1024;
			this.integerToolStripMenuItem12.Name = "integerToolStripMenuItem12";
			this.integerToolStripMenuItem12.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem12.Text = "Insert 1024 Bytes";
			this.integerToolStripMenuItem12.Value = 1024;
			this.integerToolStripMenuItem12.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem13
			// 
			this.integerToolStripMenuItem13.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_2048;
			this.integerToolStripMenuItem13.Name = "integerToolStripMenuItem13";
			this.integerToolStripMenuItem13.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem13.Text = "Insert 2048 Bytes";
			this.integerToolStripMenuItem13.Value = 2048;
			this.integerToolStripMenuItem13.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// integerToolStripMenuItem14
			// 
			this.integerToolStripMenuItem14.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_4096;
			this.integerToolStripMenuItem14.Name = "integerToolStripMenuItem14";
			this.integerToolStripMenuItem14.Size = new System.Drawing.Size(161, 22);
			this.integerToolStripMenuItem14.Text = "Insert 4096 Bytes";
			this.integerToolStripMenuItem14.Value = 4096;
			this.integerToolStripMenuItem14.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// toolStripMenuItem2
			// 
			this.toolStripMenuItem2.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_X;
			this.toolStripMenuItem2.Name = "toolStripMenuItem2";
			this.toolStripMenuItem2.Size = new System.Drawing.Size(161, 22);
			this.toolStripMenuItem2.Text = "Insert ... Bytes";
			this.toolStripMenuItem2.Click += new System.EventHandler(this.insertXBytesToolStripMenuItem_Click);
			// 
			// toolStripSeparator8
			// 
			this.toolStripSeparator8.Name = "toolStripSeparator8";
			this.toolStripSeparator8.Size = new System.Drawing.Size(266, 6);
			// 
			// createClassFromNodesToolStripMenuItem
			// 
			this.createClassFromNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.createClassFromNodesToolStripMenuItem.Name = "createClassFromNodesToolStripMenuItem";
			this.createClassFromNodesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.createClassFromNodesToolStripMenuItem.Text = "Create Class from Nodes";
			this.createClassFromNodesToolStripMenuItem.Click += new System.EventHandler(this.createClassFromNodesToolStripMenuItem_Click);
			// 
			// toolStripSeparator13
			// 
			this.toolStripSeparator13.Name = "toolStripSeparator13";
			this.toolStripSeparator13.Size = new System.Drawing.Size(266, 6);
			// 
			// dissectNodesToolStripMenuItem
			// 
			this.dissectNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Camera;
			this.dissectNodesToolStripMenuItem.Name = "dissectNodesToolStripMenuItem";
			this.dissectNodesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.dissectNodesToolStripMenuItem.Text = "Dissect Node(s)";
			this.dissectNodesToolStripMenuItem.Click += new System.EventHandler(this.dissectNodesToolStripMenuItem_Click);
			// 
			// toolStripSeparator9
			// 
			this.toolStripSeparator9.Name = "toolStripSeparator9";
			this.toolStripSeparator9.Size = new System.Drawing.Size(266, 6);
			// 
			// searchForEqualValuesToolStripMenuItem
			// 
			this.searchForEqualValuesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.searchForEqualValuesToolStripMenuItem.Name = "searchForEqualValuesToolStripMenuItem";
			this.searchForEqualValuesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.searchForEqualValuesToolStripMenuItem.Text = "Search for equal values...";
			this.searchForEqualValuesToolStripMenuItem.Click += new System.EventHandler(this.searchForEqualValuesToolStripMenuItem_Click);
			// 
			// toolStripSeparator15
			// 
			this.toolStripSeparator15.Name = "toolStripSeparator15";
			this.toolStripSeparator15.Size = new System.Drawing.Size(266, 6);
			// 
			// findOutWhatAccessesThisAddressToolStripMenuItem
			// 
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Find_Access;
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Name = "findOutWhatAccessesThisAddressToolStripMenuItem";
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Text = "Find out what accesses this address...";
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Click += new System.EventHandler(this.findOutWhatAccessesThisAddressToolStripMenuItem_Click);
			// 
			// findOutWhatWritesToThisAddressToolStripMenuItem
			// 
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Find_Write;
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Name = "findOutWhatWritesToThisAddressToolStripMenuItem";
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Text = "Find out what writes to this address...";
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Click += new System.EventHandler(this.findOutWhatWritesToThisAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator14
			// 
			this.toolStripSeparator14.Name = "toolStripSeparator14";
			this.toolStripSeparator14.Size = new System.Drawing.Size(266, 6);
			// 
			// copyNodeToolStripMenuItem
			// 
			this.copyNodeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Copy;
			this.copyNodeToolStripMenuItem.Name = "copyNodeToolStripMenuItem";
			this.copyNodeToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.copyNodeToolStripMenuItem.Text = "Copy Node(s)";
			this.copyNodeToolStripMenuItem.Click += new System.EventHandler(this.copyNodeToolStripMenuItem_Click);
			// 
			// pasteNodesToolStripMenuItem
			// 
			this.pasteNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Paste;
			this.pasteNodesToolStripMenuItem.Name = "pasteNodesToolStripMenuItem";
			this.pasteNodesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.pasteNodesToolStripMenuItem.Text = "Paste Node(s)";
			this.pasteNodesToolStripMenuItem.Click += new System.EventHandler(this.pasteNodesToolStripMenuItem_Click);
			// 
			// toolStripSeparator10
			// 
			this.toolStripSeparator10.Name = "toolStripSeparator10";
			this.toolStripSeparator10.Size = new System.Drawing.Size(266, 6);
			// 
			// removeToolStripMenuItem
			// 
			this.removeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Delete;
			this.removeToolStripMenuItem.Name = "removeToolStripMenuItem";
			this.removeToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.removeToolStripMenuItem.Text = "Remove Node(s)";
			this.removeToolStripMenuItem.Click += new System.EventHandler(this.removeToolStripMenuItem_Click);
			// 
			// toolStripSeparator12
			// 
			this.toolStripSeparator12.Name = "toolStripSeparator12";
			this.toolStripSeparator12.Size = new System.Drawing.Size(266, 6);
			// 
			// hideNodesToolStripMenuItem
			// 
			this.hideNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.hideNodesToolStripMenuItem.Name = "hideNodesToolStripMenuItem";
			this.hideNodesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.hideNodesToolStripMenuItem.Text = "Hide selected Node(s)";
			this.hideNodesToolStripMenuItem.Click += new System.EventHandler(this.hideNodesToolStripMenuItem_Click);
			// 
			// unhideNodesToolStripMenuItem
			// 
			this.unhideNodesToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.unhideChildNodesToolStripMenuItem,
            this.unhideNodesAboveToolStripMenuItem,
            this.unhideNodesBelowToolStripMenuItem});
			this.unhideNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.unhideNodesToolStripMenuItem.Name = "unhideNodesToolStripMenuItem";
			this.unhideNodesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.unhideNodesToolStripMenuItem.Text = "Unhide...";
			// 
			// unhideChildNodesToolStripMenuItem
			// 
			this.unhideChildNodesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.unhideChildNodesToolStripMenuItem.Name = "unhideChildNodesToolStripMenuItem";
			this.unhideChildNodesToolStripMenuItem.Size = new System.Drawing.Size(163, 22);
			this.unhideChildNodesToolStripMenuItem.Text = "... Child Node(s)";
			this.unhideChildNodesToolStripMenuItem.Click += new System.EventHandler(this.unhideChildNodesToolStripMenuItem_Click);
			// 
			// unhideNodesAboveToolStripMenuItem
			// 
			this.unhideNodesAboveToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.unhideNodesAboveToolStripMenuItem.Name = "unhideNodesAboveToolStripMenuItem";
			this.unhideNodesAboveToolStripMenuItem.Size = new System.Drawing.Size(163, 22);
			this.unhideNodesAboveToolStripMenuItem.Text = "... Node(s) above";
			this.unhideNodesAboveToolStripMenuItem.Click += new System.EventHandler(this.unhideNodesAboveToolStripMenuItem_Click);
			// 
			// unhideNodesBelowToolStripMenuItem
			// 
			this.unhideNodesBelowToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.unhideNodesBelowToolStripMenuItem.Name = "unhideNodesBelowToolStripMenuItem";
			this.unhideNodesBelowToolStripMenuItem.Size = new System.Drawing.Size(163, 22);
			this.unhideNodesBelowToolStripMenuItem.Text = "... Node(s) below";
			this.unhideNodesBelowToolStripMenuItem.Click += new System.EventHandler(this.unhideNodesBelowToolStripMenuItem_Click);
			// 
			// toolStripSeparator18
			// 
			this.toolStripSeparator18.Name = "toolStripSeparator18";
			this.toolStripSeparator18.Size = new System.Drawing.Size(266, 6);
			// 
			// copyAddressToolStripMenuItem
			// 
			this.copyAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Copy;
			this.copyAddressToolStripMenuItem.Name = "copyAddressToolStripMenuItem";
			this.copyAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.copyAddressToolStripMenuItem.Text = "Copy Address";
			this.copyAddressToolStripMenuItem.Click += new System.EventHandler(this.copyAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator11
			// 
			this.toolStripSeparator11.Name = "toolStripSeparator11";
			this.toolStripSeparator11.Size = new System.Drawing.Size(266, 6);
			// 
			// showCodeOfClassToolStripMenuItem
			// 
			this.showCodeOfClassToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Code_Cpp;
			this.showCodeOfClassToolStripMenuItem.Name = "showCodeOfClassToolStripMenuItem";
			this.showCodeOfClassToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.showCodeOfClassToolStripMenuItem.Text = "Show C++ Code of Class";
			this.showCodeOfClassToolStripMenuItem.Click += new System.EventHandler(this.showCodeOfClassToolStripMenuItem_Click);
			// 
			// shrinkClassToolStripMenuItem
			// 
			this.shrinkClassToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Chart_Delete;
			this.shrinkClassToolStripMenuItem.Name = "shrinkClassToolStripMenuItem";
			this.shrinkClassToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.shrinkClassToolStripMenuItem.Text = "Shrink Class";
			this.shrinkClassToolStripMenuItem.Click += new System.EventHandler(this.shrinkClassToolStripMenuItem_Click);
			// 
			// toolStrip
			// 
			this.toolStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.attachToProcessToolStripSplitButton,
            this.toolStripSeparator6,
            this.openProjectToolStripButton,
            this.saveToolStripButton,
            this.toolStripSeparator7,
            this.newClassToolStripButton,
            this.addBytesToolStripDropDownButton,
            this.insertBytesToolStripDropDownButton,
            this.nodeTypesToolStripSeparator});
			this.toolStrip.Location = new System.Drawing.Point(0, 24);
			this.toolStrip.Name = "toolStrip";
			this.toolStrip.Size = new System.Drawing.Size(1141, 25);
			this.toolStrip.TabIndex = 3;
			// 
			// attachToProcessToolStripSplitButton
			// 
			this.attachToProcessToolStripSplitButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.attachToProcessToolStripSplitButton.Image = global::ReClassNET.Properties.Resources.B16x16_Magnifier;
			this.attachToProcessToolStripSplitButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.attachToProcessToolStripSplitButton.Name = "attachToProcessToolStripSplitButton";
			this.attachToProcessToolStripSplitButton.Size = new System.Drawing.Size(32, 22);
			this.attachToProcessToolStripSplitButton.ToolTipText = "Attach to Process...";
			this.attachToProcessToolStripSplitButton.ButtonClick += new System.EventHandler(this.attachToProcessToolStripSplitButton_ButtonClick);
			this.attachToProcessToolStripSplitButton.DropDownClosed += new System.EventHandler(this.attachToProcessToolStripSplitButton_DropDownClosed);
			this.attachToProcessToolStripSplitButton.DropDownOpening += new System.EventHandler(this.attachToProcessToolStripSplitButton_DropDownOpening);
			// 
			// toolStripSeparator6
			// 
			this.toolStripSeparator6.Name = "toolStripSeparator6";
			this.toolStripSeparator6.Size = new System.Drawing.Size(6, 25);
			// 
			// openProjectToolStripButton
			// 
			this.openProjectToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.openProjectToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Folder;
			this.openProjectToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.openProjectToolStripButton.Name = "openProjectToolStripButton";
			this.openProjectToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.openProjectToolStripButton.ToolTipText = "Open Project...";
			this.openProjectToolStripButton.Click += new System.EventHandler(this.openProjectToolStripMenuItem_Click);
			// 
			// saveToolStripButton
			// 
			this.saveToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.saveToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Save;
			this.saveToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.saveToolStripButton.Name = "saveToolStripButton";
			this.saveToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.saveToolStripButton.ToolTipText = "Save Project";
			this.saveToolStripButton.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
			// 
			// toolStripSeparator7
			// 
			this.toolStripSeparator7.Name = "toolStripSeparator7";
			this.toolStripSeparator7.Size = new System.Drawing.Size(6, 25);
			// 
			// newClassToolStripButton
			// 
			this.newClassToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.newClassToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.newClassToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.newClassToolStripButton.Name = "newClassToolStripButton";
			this.newClassToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.newClassToolStripButton.Text = "addClassToolStripButton";
			this.newClassToolStripButton.ToolTipText = "Add a new class to this project";
			this.newClassToolStripButton.Click += new System.EventHandler(this.newClassToolStripButton_Click);
			// 
			// addBytesToolStripDropDownButton
			// 
			this.addBytesToolStripDropDownButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.addBytesToolStripDropDownButton.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.add4BytesToolStripMenuItem,
            this.add8BytesToolStripMenuItem,
            this.add64BytesToolStripMenuItem,
            this.add256BytesToolStripMenuItem,
            this.add1024BytesToolStripMenuItem,
            this.add2048BytesToolStripMenuItem,
            this.add4096BytesToolStripMenuItem,
            this.addXBytesToolStripMenuItem});
			this.addBytesToolStripDropDownButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_X;
			this.addBytesToolStripDropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.addBytesToolStripDropDownButton.Name = "addBytesToolStripDropDownButton";
			this.addBytesToolStripDropDownButton.Size = new System.Drawing.Size(29, 22);
			// 
			// add4BytesToolStripMenuItem
			// 
			this.add4BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_4;
			this.add4BytesToolStripMenuItem.Name = "add4BytesToolStripMenuItem";
			this.add4BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add4BytesToolStripMenuItem.Tag = "";
			this.add4BytesToolStripMenuItem.Text = "Add 4 Bytes";
			this.add4BytesToolStripMenuItem.Value = 4;
			this.add4BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add8BytesToolStripMenuItem
			// 
			this.add8BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_8;
			this.add8BytesToolStripMenuItem.Name = "add8BytesToolStripMenuItem";
			this.add8BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add8BytesToolStripMenuItem.Text = "Add 8 Bytes";
			this.add8BytesToolStripMenuItem.Value = 8;
			this.add8BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add64BytesToolStripMenuItem
			// 
			this.add64BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_64;
			this.add64BytesToolStripMenuItem.Name = "add64BytesToolStripMenuItem";
			this.add64BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add64BytesToolStripMenuItem.Text = "Add 64 Bytes";
			this.add64BytesToolStripMenuItem.Value = 64;
			this.add64BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add256BytesToolStripMenuItem
			// 
			this.add256BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_256;
			this.add256BytesToolStripMenuItem.Name = "add256BytesToolStripMenuItem";
			this.add256BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add256BytesToolStripMenuItem.Text = "Add 256 Bytes";
			this.add256BytesToolStripMenuItem.Value = 256;
			this.add256BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add1024BytesToolStripMenuItem
			// 
			this.add1024BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_1024;
			this.add1024BytesToolStripMenuItem.Name = "add1024BytesToolStripMenuItem";
			this.add1024BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add1024BytesToolStripMenuItem.Text = "Add 1024 Bytes";
			this.add1024BytesToolStripMenuItem.Value = 1024;
			this.add1024BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add2048BytesToolStripMenuItem
			// 
			this.add2048BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_2048;
			this.add2048BytesToolStripMenuItem.Name = "add2048BytesToolStripMenuItem";
			this.add2048BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add2048BytesToolStripMenuItem.Text = "Add 2048 Bytes";
			this.add2048BytesToolStripMenuItem.Value = 2048;
			this.add2048BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// add4096BytesToolStripMenuItem
			// 
			this.add4096BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_4096;
			this.add4096BytesToolStripMenuItem.Name = "add4096BytesToolStripMenuItem";
			this.add4096BytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.add4096BytesToolStripMenuItem.Text = "Add 4096 Bytes";
			this.add4096BytesToolStripMenuItem.Value = 4096;
			this.add4096BytesToolStripMenuItem.Click += new System.EventHandler(this.addBytesToolStripMenuItem_Click);
			// 
			// addXBytesToolStripMenuItem
			// 
			this.addXBytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add_Bytes_X;
			this.addXBytesToolStripMenuItem.Name = "addXBytesToolStripMenuItem";
			this.addXBytesToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
			this.addXBytesToolStripMenuItem.Text = "Add ... Bytes";
			this.addXBytesToolStripMenuItem.Click += new System.EventHandler(this.addXBytesToolStripMenuItem_Click);
			// 
			// insertBytesToolStripDropDownButton
			// 
			this.insertBytesToolStripDropDownButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.insertBytesToolStripDropDownButton.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.insert4BytesToolStripMenuItem,
            this.insert8BytesToolStripMenuItem,
            this.insert64BytesToolStripMenuItem,
            this.insert256BytesToolStripMenuItem,
            this.insert1024BytesToolStripMenuItem,
            this.insert2048BytesToolStripMenuItem,
            this.insert4096BytesToolStripMenuItem,
            this.insertXBytesToolStripMenuItem});
			this.insertBytesToolStripDropDownButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_X;
			this.insertBytesToolStripDropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.insertBytesToolStripDropDownButton.Name = "insertBytesToolStripDropDownButton";
			this.insertBytesToolStripDropDownButton.Size = new System.Drawing.Size(29, 22);
			this.insertBytesToolStripDropDownButton.ToolTipText = "Insert bytes at selected position";
			// 
			// insert4BytesToolStripMenuItem
			// 
			this.insert4BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_4;
			this.insert4BytesToolStripMenuItem.Name = "insert4BytesToolStripMenuItem";
			this.insert4BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert4BytesToolStripMenuItem.Tag = "";
			this.insert4BytesToolStripMenuItem.Text = "Insert 4 Bytes";
			this.insert4BytesToolStripMenuItem.Value = 4;
			this.insert4BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert8BytesToolStripMenuItem
			// 
			this.insert8BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_8;
			this.insert8BytesToolStripMenuItem.Name = "insert8BytesToolStripMenuItem";
			this.insert8BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert8BytesToolStripMenuItem.Text = "Insert 8 Bytes";
			this.insert8BytesToolStripMenuItem.Value = 8;
			this.insert8BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert64BytesToolStripMenuItem
			// 
			this.insert64BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_64;
			this.insert64BytesToolStripMenuItem.Name = "insert64BytesToolStripMenuItem";
			this.insert64BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert64BytesToolStripMenuItem.Text = "Insert 64 Bytes";
			this.insert64BytesToolStripMenuItem.Value = 64;
			this.insert64BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert256BytesToolStripMenuItem
			// 
			this.insert256BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_256;
			this.insert256BytesToolStripMenuItem.Name = "insert256BytesToolStripMenuItem";
			this.insert256BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert256BytesToolStripMenuItem.Text = "Insert 256 Bytes";
			this.insert256BytesToolStripMenuItem.Value = 256;
			this.insert256BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert1024BytesToolStripMenuItem
			// 
			this.insert1024BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_1024;
			this.insert1024BytesToolStripMenuItem.Name = "insert1024BytesToolStripMenuItem";
			this.insert1024BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert1024BytesToolStripMenuItem.Text = "Insert 1024 Bytes";
			this.insert1024BytesToolStripMenuItem.Value = 1024;
			this.insert1024BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert2048BytesToolStripMenuItem
			// 
			this.insert2048BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_2048;
			this.insert2048BytesToolStripMenuItem.Name = "insert2048BytesToolStripMenuItem";
			this.insert2048BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert2048BytesToolStripMenuItem.Text = "Insert 2048 Bytes";
			this.insert2048BytesToolStripMenuItem.Value = 2048;
			this.insert2048BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insert4096BytesToolStripMenuItem
			// 
			this.insert4096BytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_4096;
			this.insert4096BytesToolStripMenuItem.Name = "insert4096BytesToolStripMenuItem";
			this.insert4096BytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insert4096BytesToolStripMenuItem.Text = "Insert 4096 Bytes";
			this.insert4096BytesToolStripMenuItem.Value = 4096;
			this.insert4096BytesToolStripMenuItem.Click += new System.EventHandler(this.insertBytesToolStripMenuItem_Click);
			// 
			// insertXBytesToolStripMenuItem
			// 
			this.insertXBytesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Insert_Bytes_X;
			this.insertXBytesToolStripMenuItem.Name = "insertXBytesToolStripMenuItem";
			this.insertXBytesToolStripMenuItem.Size = new System.Drawing.Size(161, 22);
			this.insertXBytesToolStripMenuItem.Text = "Insert ... Bytes";
			this.insertXBytesToolStripMenuItem.Click += new System.EventHandler(this.insertXBytesToolStripMenuItem_Click);
			// 
			// nodeTypesToolStripSeparator
			// 
			this.nodeTypesToolStripSeparator.Name = "nodeTypesToolStripSeparator";
			this.nodeTypesToolStripSeparator.Size = new System.Drawing.Size(6, 25);
			// 
			// statusStrip
			// 
			this.statusStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.processInfoToolStripStatusLabel,
            this.infoToolStripStatusLabel});
			this.statusStrip.Location = new System.Drawing.Point(0, 573);
			this.statusStrip.Name = "statusStrip";
			this.statusStrip.Size = new System.Drawing.Size(1141, 22);
			this.statusStrip.TabIndex = 1;
			// 
			// processInfoToolStripStatusLabel
			// 
			this.processInfoToolStripStatusLabel.Name = "processInfoToolStripStatusLabel";
			this.processInfoToolStripStatusLabel.Size = new System.Drawing.Size(112, 17);
			this.processInfoToolStripStatusLabel.Text = "No process selected";
			// 
			// infoToolStripStatusLabel
			// 
			this.infoToolStripStatusLabel.Name = "infoToolStripStatusLabel";
			this.infoToolStripStatusLabel.Size = new System.Drawing.Size(23, 17);
			this.infoToolStripStatusLabel.Text = "<>";
			this.infoToolStripStatusLabel.Visible = false;
			// 
			// mainMenuStrip
			// 
			this.mainMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.processToolStripMenuItem,
            this.projectToolStripMenuItem,
            this.helpToolStripMenuItem});
			this.mainMenuStrip.Location = new System.Drawing.Point(0, 0);
			this.mainMenuStrip.Name = "mainMenuStrip";
			this.mainMenuStrip.Size = new System.Drawing.Size(1141, 24);
			this.mainMenuStrip.TabIndex = 2;
			// 
			// fileToolStripMenuItem
			// 
			this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.attachToProcessToolStripMenuItem,
            this.reattachToProcessToolStripMenuItem,
            this.detachToolStripMenuItem,
            this.toolStripSeparator1,
            this.openProjectToolStripMenuItem,
            this.mergeWithProjectToolStripMenuItem,
            this.clearProjectToolStripMenuItem,
            this.toolStripSeparator2,
            this.saveToolStripMenuItem,
            this.saveAsToolStripMenuItem,
            this.toolStripSeparator3,
            this.settingsToolStripMenuItem,
            this.pluginsToolStripMenuItem,
            this.toolStripSeparator5,
            this.quitToolStripMenuItem});
			this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
			this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
			this.fileToolStripMenuItem.Text = "File";
			this.fileToolStripMenuItem.DropDownOpening += new System.EventHandler(this.fileToolStripMenuItem_DropDownOpening);
			// 
			// attachToProcessToolStripMenuItem
			// 
			this.attachToProcessToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Magnifier;
			this.attachToProcessToolStripMenuItem.Name = "attachToProcessToolStripMenuItem";
			this.attachToProcessToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.attachToProcessToolStripMenuItem.Text = "Attach to Process...";
			this.attachToProcessToolStripMenuItem.Click += new System.EventHandler(this.attachToProcessToolStripSplitButton_ButtonClick);
			// 
			// reattachToProcessToolStripMenuItem
			// 
			this.reattachToProcessToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Magnifier_Arrow;
			this.reattachToProcessToolStripMenuItem.Name = "reattachToProcessToolStripMenuItem";
			this.reattachToProcessToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.reattachToProcessToolStripMenuItem.Text = "<>";
			this.reattachToProcessToolStripMenuItem.Click += new System.EventHandler(this.reattachToProcessToolStripMenuItem_Click);
			// 
			// detachToolStripMenuItem
			// 
			this.detachToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Magnifier_Remove;
			this.detachToolStripMenuItem.Name = "detachToolStripMenuItem";
			this.detachToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.detachToolStripMenuItem.Text = "Detach";
			this.detachToolStripMenuItem.Click += new System.EventHandler(this.detachToolStripMenuItem_Click);
			// 
			// toolStripSeparator1
			// 
			this.toolStripSeparator1.Name = "toolStripSeparator1";
			this.toolStripSeparator1.Size = new System.Drawing.Size(192, 6);
			// 
			// openProjectToolStripMenuItem
			// 
			this.openProjectToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Folder;
			this.openProjectToolStripMenuItem.Name = "openProjectToolStripMenuItem";
			this.openProjectToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
			this.openProjectToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.openProjectToolStripMenuItem.Text = "Open Project...";
			this.openProjectToolStripMenuItem.Click += new System.EventHandler(this.openProjectToolStripMenuItem_Click);
			// 
			// mergeWithProjectToolStripMenuItem
			// 
			this.mergeWithProjectToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Folder_Add;
			this.mergeWithProjectToolStripMenuItem.Name = "mergeWithProjectToolStripMenuItem";
			this.mergeWithProjectToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.mergeWithProjectToolStripMenuItem.Text = "Merge with Project...";
			this.mergeWithProjectToolStripMenuItem.Click += new System.EventHandler(this.mergeWithProjectToolStripMenuItem_Click);
			// 
			// clearProjectToolStripMenuItem
			// 
			this.clearProjectToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Arrow_Refresh;
			this.clearProjectToolStripMenuItem.Name = "clearProjectToolStripMenuItem";
			this.clearProjectToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.clearProjectToolStripMenuItem.Text = "Clear Project";
			this.clearProjectToolStripMenuItem.Click += new System.EventHandler(this.clearProjectToolStripMenuItem_Click);
			// 
			// toolStripSeparator2
			// 
			this.toolStripSeparator2.Name = "toolStripSeparator2";
			this.toolStripSeparator2.Size = new System.Drawing.Size(192, 6);
			// 
			// saveToolStripMenuItem
			// 
			this.saveToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Save;
			this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
			this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
			this.saveToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.saveToolStripMenuItem.Text = "Save";
			this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
			// 
			// saveAsToolStripMenuItem
			// 
			this.saveAsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Save_As;
			this.saveAsToolStripMenuItem.Name = "saveAsToolStripMenuItem";
			this.saveAsToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift) 
            | System.Windows.Forms.Keys.S)));
			this.saveAsToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.saveAsToolStripMenuItem.Text = "Save as...";
			this.saveAsToolStripMenuItem.Click += new System.EventHandler(this.saveAsToolStripMenuItem_Click);
			// 
			// toolStripSeparator3
			// 
			this.toolStripSeparator3.Name = "toolStripSeparator3";
			this.toolStripSeparator3.Size = new System.Drawing.Size(192, 6);
			// 
			// settingsToolStripMenuItem
			// 
			this.settingsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Cogs;
			this.settingsToolStripMenuItem.Name = "settingsToolStripMenuItem";
			this.settingsToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.settingsToolStripMenuItem.Text = "Settings...";
			this.settingsToolStripMenuItem.Click += new System.EventHandler(this.settingsToolStripMenuItem_Click);
			// 
			// pluginsToolStripMenuItem
			// 
			this.pluginsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Plugin;
			this.pluginsToolStripMenuItem.Name = "pluginsToolStripMenuItem";
			this.pluginsToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.pluginsToolStripMenuItem.Text = "Plugins...";
			this.pluginsToolStripMenuItem.Click += new System.EventHandler(this.pluginsToolStripButton_Click);
			// 
			// toolStripSeparator5
			// 
			this.toolStripSeparator5.Name = "toolStripSeparator5";
			this.toolStripSeparator5.Size = new System.Drawing.Size(192, 6);
			// 
			// quitToolStripMenuItem
			// 
			this.quitToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Quit;
			this.quitToolStripMenuItem.Name = "quitToolStripMenuItem";
			this.quitToolStripMenuItem.Size = new System.Drawing.Size(195, 22);
			this.quitToolStripMenuItem.Text = "Quit";
			this.quitToolStripMenuItem.Click += new System.EventHandler(this.quitToolStripMenuItem_Click);
			// 
			// processToolStripMenuItem
			// 
			this.processToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.processInformationsToolStripMenuItem,
            this.memorySearcherToolStripMenuItem,
            this.namedAddressesToolStripMenuItem,
            this.toolStripSeparator23,
            this.isLittleEndianToolStripMenuItem,
            this.toolStripSeparator17,
            this.loadSymbolToolStripMenuItem,
            this.loadSymbolsToolStripMenuItem,
            this.toolStripSeparator4,
            this.resumeProcessToolStripMenuItem,
            this.suspendProcessToolStripMenuItem,
            this.terminateProcessToolStripMenuItem});
			this.processToolStripMenuItem.Name = "processToolStripMenuItem";
			this.processToolStripMenuItem.Size = new System.Drawing.Size(59, 20);
			this.processToolStripMenuItem.Text = "Process";
			// 
			// processInformationsToolStripMenuItem
			// 
			this.processInformationsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Category;
			this.processInformationsToolStripMenuItem.Name = "processInformationsToolStripMenuItem";
			this.processInformationsToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.processInformationsToolStripMenuItem.Text = "Process Informations...";
			this.processInformationsToolStripMenuItem.Click += new System.EventHandler(this.memoryViewerToolStripMenuItem_Click);
			// 
			// memorySearcherToolStripMenuItem
			// 
			this.memorySearcherToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Eye;
			this.memorySearcherToolStripMenuItem.Name = "memorySearcherToolStripMenuItem";
			this.memorySearcherToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.memorySearcherToolStripMenuItem.Text = "Memory Searcher...";
			this.memorySearcherToolStripMenuItem.Click += new System.EventHandler(this.memorySearcherToolStripMenuItem_Click);
			// 
			// namedAddressesToolStripMenuItem
			// 
			this.namedAddressesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Custom_Type;
			this.namedAddressesToolStripMenuItem.Name = "namedAddressesToolStripMenuItem";
			this.namedAddressesToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.namedAddressesToolStripMenuItem.Text = "Named Addresses...";
			this.namedAddressesToolStripMenuItem.Click += new System.EventHandler(this.namedAddressesToolStripMenuItem_Click);
			// 
			// toolStripSeparator23
			// 
			this.toolStripSeparator23.Name = "toolStripSeparator23";
			this.toolStripSeparator23.Size = new System.Drawing.Size(191, 6);
			// 
			// isLittleEndianToolStripMenuItem
			// 
			this.isLittleEndianToolStripMenuItem.CheckOnClick = true;
			this.isLittleEndianToolStripMenuItem.Name = "isLittleEndianToolStripMenuItem";
			this.isLittleEndianToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.isLittleEndianToolStripMenuItem.Text = "Is Little Endian";
			this.isLittleEndianToolStripMenuItem.Click += new System.EventHandler(this.isLittleEndianToolStripMenuItem_Click);
			// 
			// toolStripSeparator17
			// 
			this.toolStripSeparator17.Name = "toolStripSeparator17";
			this.toolStripSeparator17.Size = new System.Drawing.Size(191, 6);
			// 
			// loadSymbolToolStripMenuItem
			// 
			this.loadSymbolToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Pdb;
			this.loadSymbolToolStripMenuItem.Name = "loadSymbolToolStripMenuItem";
			this.loadSymbolToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.loadSymbolToolStripMenuItem.Text = "Load Symbol...";
			this.loadSymbolToolStripMenuItem.Click += new System.EventHandler(this.loadSymbolToolStripMenuItem_Click);
			// 
			// loadSymbolsToolStripMenuItem
			// 
			this.loadSymbolsToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("loadSymbolsToolStripMenuItem.Image")));
			this.loadSymbolsToolStripMenuItem.Name = "loadSymbolsToolStripMenuItem";
			this.loadSymbolsToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.loadSymbolsToolStripMenuItem.Text = "Load all Symbols";
			this.loadSymbolsToolStripMenuItem.Click += new System.EventHandler(this.loadSymbolsToolStripMenuItem_Click);
			// 
			// toolStripSeparator4
			// 
			this.toolStripSeparator4.Name = "toolStripSeparator4";
			this.toolStripSeparator4.Size = new System.Drawing.Size(191, 6);
			// 
			// resumeProcessToolStripMenuItem
			// 
			this.resumeProcessToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Control_Play;
			this.resumeProcessToolStripMenuItem.Name = "resumeProcessToolStripMenuItem";
			this.resumeProcessToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.resumeProcessToolStripMenuItem.Text = "Resume";
			this.resumeProcessToolStripMenuItem.Click += new System.EventHandler(this.ControlRemoteProcessToolStripMenuItem_Click);
			// 
			// suspendProcessToolStripMenuItem
			// 
			this.suspendProcessToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Control_Pause;
			this.suspendProcessToolStripMenuItem.Name = "suspendProcessToolStripMenuItem";
			this.suspendProcessToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.suspendProcessToolStripMenuItem.Text = "Suspend";
			this.suspendProcessToolStripMenuItem.Click += new System.EventHandler(this.ControlRemoteProcessToolStripMenuItem_Click);
			// 
			// terminateProcessToolStripMenuItem
			// 
			this.terminateProcessToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Control_Stop;
			this.terminateProcessToolStripMenuItem.Name = "terminateProcessToolStripMenuItem";
			this.terminateProcessToolStripMenuItem.Size = new System.Drawing.Size(194, 22);
			this.terminateProcessToolStripMenuItem.Text = "Kill";
			this.terminateProcessToolStripMenuItem.Click += new System.EventHandler(this.ControlRemoteProcessToolStripMenuItem_Click);
			// 
			// projectToolStripMenuItem
			// 
			this.projectToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.goToClassToolStripMenuItem,
            this.cleanUnusedClassesToolStripMenuItem,
            this.showEnumsToolStripMenuItem,
            this.toolStripSeparator16,
            this.generateCppCodeToolStripMenuItem,
            this.generateCSharpCodeToolStripMenuItem});
			this.projectToolStripMenuItem.Name = "projectToolStripMenuItem";
			this.projectToolStripMenuItem.Size = new System.Drawing.Size(56, 20);
			this.projectToolStripMenuItem.Text = "Project";
			// 
			// goToClassToolStripMenuItem
			// 
			this.goToClassToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Class_Type;
			this.goToClassToolStripMenuItem.Name = "goToClassToolStripMenuItem";
			this.goToClassToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.F)));
			this.goToClassToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
			this.goToClassToolStripMenuItem.Text = "Go to class...";
			this.goToClassToolStripMenuItem.Click += new System.EventHandler(this.goToClassToolStripMenuItem_Click);
			// 
			// cleanUnusedClassesToolStripMenuItem
			// 
			this.cleanUnusedClassesToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Chart_Delete;
			this.cleanUnusedClassesToolStripMenuItem.Name = "cleanUnusedClassesToolStripMenuItem";
			this.cleanUnusedClassesToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
			this.cleanUnusedClassesToolStripMenuItem.Text = "Remove unused classes";
			this.cleanUnusedClassesToolStripMenuItem.Click += new System.EventHandler(this.cleanUnusedClassesToolStripMenuItem_Click);
			// 
			// showEnumsToolStripMenuItem
			// 
			this.showEnumsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Category;
			this.showEnumsToolStripMenuItem.Name = "showEnumsToolStripMenuItem";
			this.showEnumsToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
			this.showEnumsToolStripMenuItem.Text = "Show Enums...";
			this.showEnumsToolStripMenuItem.Click += new System.EventHandler(this.showEnumsToolStripMenuItem_Click);
			// 
			// toolStripSeparator16
			// 
			this.toolStripSeparator16.Name = "toolStripSeparator16";
			this.toolStripSeparator16.Size = new System.Drawing.Size(195, 6);
			// 
			// generateCppCodeToolStripMenuItem
			// 
			this.generateCppCodeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Code_Cpp;
			this.generateCppCodeToolStripMenuItem.Name = "generateCppCodeToolStripMenuItem";
			this.generateCppCodeToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
			this.generateCppCodeToolStripMenuItem.Text = "Generate C++ Code...";
			this.generateCppCodeToolStripMenuItem.Click += new System.EventHandler(this.generateCppCodeToolStripMenuItem_Click);
			// 
			// generateCSharpCodeToolStripMenuItem
			// 
			this.generateCSharpCodeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Code_Csharp;
			this.generateCSharpCodeToolStripMenuItem.Name = "generateCSharpCodeToolStripMenuItem";
			this.generateCSharpCodeToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
			this.generateCSharpCodeToolStripMenuItem.Text = "Generate C# Code...";
			this.generateCSharpCodeToolStripMenuItem.Click += new System.EventHandler(this.generateCSharpCodeToolStripMenuItem_Click);
			// 
			// helpToolStripMenuItem
			// 
			this.helpToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutToolStripMenuItem});
			this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
			this.helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
			this.helpToolStripMenuItem.Text = "Help";
			// 
			// aboutToolStripMenuItem
			// 
			this.aboutToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Information;
			this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";
			this.aboutToolStripMenuItem.Size = new System.Drawing.Size(116, 22);
			this.aboutToolStripMenuItem.Text = "About...";
			this.aboutToolStripMenuItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);
			// 
			// MainForm
			// 
			this.AllowDrop = true;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(1141, 595);
			this.Controls.Add(this.splitContainer);
			this.Controls.Add(this.toolStrip);
			this.Controls.Add(this.statusStrip);
			this.Controls.Add(this.mainMenuStrip);
			this.MainMenuStrip = this.mainMenuStrip;
			this.MinimumSize = new System.Drawing.Size(200, 100);
			this.Name = "MainForm";
			this.Text = "ReClass.NET";
			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MainForm_FormClosing);
			this.DragDrop += new System.Windows.Forms.DragEventHandler(this.MainForm_DragDrop);
			this.DragEnter += new System.Windows.Forms.DragEventHandler(this.MainForm_DragEnter);
			this.splitContainer.Panel1.ResumeLayout(false);
			this.splitContainer.Panel2.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.splitContainer)).EndInit();
			this.splitContainer.ResumeLayout(false);
			this.projectClassContextMenuStrip.ResumeLayout(false);
			this.projectClassesContextMenuStrip.ResumeLayout(false);
			this.projectEnumContextMenuStrip.ResumeLayout(false);
			this.projectEnumsContextMenuStrip.ResumeLayout(false);
			this.selectedNodeContextMenuStrip.ResumeLayout(false);
			this.toolStrip.ResumeLayout(false);
			this.toolStrip.PerformLayout();
			this.statusStrip.ResumeLayout(false);
			this.statusStrip.PerformLayout();
			this.mainMenuStrip.ResumeLayout(false);
			this.mainMenuStrip.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();

		}


		#endregion

		private MemoryViewControl memoryViewControl;
		private System.Windows.Forms.StatusStrip statusStrip;
		private System.Windows.Forms.MenuStrip mainMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem attachToProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
		private System.Windows.Forms.ToolStripMenuItem clearProjectToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem openProjectToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
		private System.Windows.Forms.ToolStripMenuItem saveToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem saveAsToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
		private System.Windows.Forms.ToolStripMenuItem quitToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem processToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem processInformationsToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator4;
		private System.Windows.Forms.ToolStripMenuItem resumeProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem suspendProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem terminateProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem settingsToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator5;
		private System.Windows.Forms.ToolStripMenuItem loadSymbolsToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;
		private System.Windows.Forms.ToolStrip toolStrip;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator6;
		private System.Windows.Forms.SplitContainer splitContainer;
		private System.Windows.Forms.ToolStripStatusLabel processInfoToolStripStatusLabel;
		private System.Windows.Forms.ToolStripMenuItem pluginsToolStripMenuItem;
		private System.Windows.Forms.ToolStripButton saveToolStripButton;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator7;
		private System.Windows.Forms.ToolStripButton newClassToolStripButton;
		private System.Windows.Forms.ToolStripDropDownButton addBytesToolStripDropDownButton;
		private IntegerToolStripMenuItem add4BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add8BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add64BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add256BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add1024BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add2048BytesToolStripMenuItem;
		private IntegerToolStripMenuItem add4096BytesToolStripMenuItem;
		private System.Windows.Forms.ToolStripDropDownButton insertBytesToolStripDropDownButton;
		private IntegerToolStripMenuItem insert4BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert8BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert64BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert256BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert1024BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert2048BytesToolStripMenuItem;
		private IntegerToolStripMenuItem insert4096BytesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem addXBytesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem insertXBytesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator nodeTypesToolStripSeparator;
		private ProjectView projectView;
		private System.Windows.Forms.ToolStripMenuItem projectToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem cleanUnusedClassesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator16;
		private System.Windows.Forms.ToolStripMenuItem generateCppCodeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem generateCSharpCodeToolStripMenuItem;
		private System.Windows.Forms.Timer processUpdateTimer;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator17;
		private System.Windows.Forms.ToolStripMenuItem loadSymbolToolStripMenuItem;
		private System.Windows.Forms.ToolStripButton openProjectToolStripButton;
		private System.Windows.Forms.ToolStripStatusLabel infoToolStripStatusLabel;
		private System.Windows.Forms.ToolStripMenuItem mergeWithProjectToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem detachToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem memorySearcherToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem reattachToProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripSplitButton attachToProcessToolStripSplitButton;
		private System.Windows.Forms.ToolStripMenuItem namedAddressesToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip selectedNodeContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem changeTypeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem addBytesToolStripMenuItem;
		private IntegerToolStripMenuItem integerToolStripMenuItem1;
		private IntegerToolStripMenuItem integerToolStripMenuItem2;
		private IntegerToolStripMenuItem integerToolStripMenuItem3;
		private IntegerToolStripMenuItem integerToolStripMenuItem4;
		private IntegerToolStripMenuItem integerToolStripMenuItem5;
		private IntegerToolStripMenuItem integerToolStripMenuItem6;
		private IntegerToolStripMenuItem integerToolStripMenuItem7;
		private System.Windows.Forms.ToolStripMenuItem insertBytesToolStripMenuItem;
		private IntegerToolStripMenuItem integerToolStripMenuItem8;
		private IntegerToolStripMenuItem integerToolStripMenuItem9;
		private IntegerToolStripMenuItem integerToolStripMenuItem10;
		private IntegerToolStripMenuItem integerToolStripMenuItem11;
		private IntegerToolStripMenuItem integerToolStripMenuItem12;
		private IntegerToolStripMenuItem integerToolStripMenuItem13;
		private IntegerToolStripMenuItem integerToolStripMenuItem14;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator8;
		private System.Windows.Forms.ToolStripMenuItem createClassFromNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator13;
		private System.Windows.Forms.ToolStripMenuItem dissectNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator9;
		private System.Windows.Forms.ToolStripMenuItem searchForEqualValuesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator15;
		private System.Windows.Forms.ToolStripMenuItem findOutWhatAccessesThisAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem findOutWhatWritesToThisAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator14;
		private System.Windows.Forms.ToolStripMenuItem copyNodeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem pasteNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator10;
		private System.Windows.Forms.ToolStripMenuItem removeToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator12;
		private System.Windows.Forms.ToolStripMenuItem hideNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem unhideNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem unhideChildNodesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem unhideNodesAboveToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem unhideNodesBelowToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator18;
		private System.Windows.Forms.ToolStripMenuItem copyAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator11;
		private System.Windows.Forms.ToolStripMenuItem showCodeOfClassToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem shrinkClassToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem1;
		private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem2;
		private System.Windows.Forms.ToolStripMenuItem goToClassToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip projectClassContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem deleteClassToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator19;
		private System.Windows.Forms.ToolStripMenuItem removeUnusedClassesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator20;
		private System.Windows.Forms.ToolStripMenuItem showCodeOfClassToolStripMenuItem2;
		private System.Windows.Forms.ContextMenuStrip projectClassesContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem enableHierarchyViewToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem autoExpandHierarchyViewToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator21;
		private System.Windows.Forms.ToolStripMenuItem expandAllClassesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem collapseAllClassesToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator22;
		private System.Windows.Forms.ToolStripMenuItem addNewClassToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip projectEnumContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem editEnumToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip projectEnumsContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem editEnumsToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem showEnumsToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator23;
		private System.Windows.Forms.ToolStripMenuItem isLittleEndianToolStripMenuItem;
	}
}


```

`ReClass.NET/Forms/MainForm.Functions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.CodeGenerator;
using ReClassNET.Controls;
using ReClassNET.DataExchange.ReClass;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.Project;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class MainForm
	{
		public void ShowPartialCodeGeneratorForm(IReadOnlyList<ClassNode> partialClasses)
		{
			Contract.Requires(partialClasses != null);

			ShowCodeGeneratorForm(partialClasses, new EnumDescription[0], new CppCodeGenerator(currentProject.TypeMapping));
		}

		public void ShowCodeGeneratorForm(ICodeGenerator generator)
		{
			Contract.Requires(generator != null);

			ShowCodeGeneratorForm(currentProject.Classes, currentProject.Enums, generator);
		}

		public void ShowCodeGeneratorForm(IReadOnlyList<ClassNode> classes, IReadOnlyList<EnumDescription> enums, ICodeGenerator generator)
		{
			Contract.Requires(classes != null);
			Contract.Requires(generator != null);
			Contract.Requires(enums != null);

			new CodeForm(generator, classes, enums, Program.Logger).Show();
		}

		public void AttachToProcess(string processName)
		{
			var info = Program.CoreFunctions.EnumerateProcesses().FirstOrDefault(p => string.Equals(p.Name, processName, StringComparison.OrdinalIgnoreCase));
			if (info == null)
			{
				MessageBox.Show($"Process '{processName}' could not be found.", Constants.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Error);

				Program.Settings.LastProcess = string.Empty;
			}
			else
			{
				AttachToProcess(info);
			}
		}

		public void AttachToProcess(ProcessInfo info)
		{
			Contract.Requires(info != null);

			Program.RemoteProcess.Close();

			Program.RemoteProcess.Open(info);
			Program.RemoteProcess.UpdateProcessInformations();

			Program.Settings.LastProcess = Program.RemoteProcess.UnderlayingProcess.Name;
		}

		/// <summary>Sets the current project.</summary>
		/// <param name="newProject">The new project.</param>
		public void SetProject(ReClassNetProject newProject)
		{
			Contract.Requires(newProject != null);

			if (currentProject == newProject)
			{
				return;
			}

			if (currentProject != null)
			{
				ClassNode.ClassCreated -= currentProject.AddClass;
			}

			void UpdateClassNodes(BaseNode node)
			{
				projectView.UpdateClassNode((ClassNode)node);
			}

			currentProject = newProject;
			currentProject.ClassAdded += c =>
			{
				projectView.AddClass(c);
				c.NodesChanged += UpdateClassNodes;
				c.NameChanged += UpdateClassNodes;
			};
			currentProject.ClassRemoved += c =>
			{
				projectView.RemoveClass(c);
				c.NodesChanged -= UpdateClassNodes;
				c.NameChanged -= UpdateClassNodes;
			};
			currentProject.EnumAdded += e => { projectView.AddEnum(e); };

			ClassNode.ClassCreated += currentProject.AddClass;

			projectView.Clear();
			projectView.AddEnums(currentProject.Enums);
			projectView.AddClasses(currentProject.Classes);
			CurrentClassNode = currentProject.Classes.FirstOrDefault();
		}

		/// <summary>Opens the <see cref="InputBytesForm"/> and calls <paramref name="callback"/> with the result.</summary>
		/// <param name="title">The title of the input form.</param>
		/// <param name="callback">The function to call afterwards.</param>
		private void AskAddOrInsertBytes(string title, Action<int> callback)
		{
			Contract.Requires(title != null);
			Contract.Requires(callback != null);

			var classNode = CurrentClassNode;
			if (classNode == null)
			{
				return;
			}

			using var ib = new InputBytesForm(classNode.MemorySize)
			{
				Text = title
			};

			if (ib.ShowDialog() == DialogResult.OK)
			{
				callback(ib.Bytes);
			}
		}

		/// <summary>
		/// Adds <paramref name="bytes"/> bytes at the end of the current class.
		/// </summary>
		/// <param name="bytes">Amount of bytes</param>
		public void AddBytesToClass(int bytes)
		{
			Contract.Requires(bytes >= 0);

			var node = memoryViewControl.GetSelectedNodes().Select(h => h.Node).FirstOrDefault();
			if (node == null)
			{
				return;
			}

			(node as BaseContainerNode ?? node.GetParentContainer())?.AddBytes(bytes);

			Invalidate();
		}

		/// <summary>
		/// Inserts <paramref name="bytes"/> bytes at the first selected node to the current class.
		/// </summary>
		/// <param name="bytes">Amount of bytes</param>
		public void InsertBytesInClass(int bytes)
		{
			Contract.Requires(bytes >= 0);

			var node = memoryViewControl.GetSelectedNodes().Select(h => h.Node).FirstOrDefault();
			if (node == null)
			{
				return;
			}

			(node as BaseContainerNode ?? node.GetParentContainer())?.InsertBytes(node, bytes);

			Invalidate();
		}

		/// <summary>
		/// Unselects all selected nodes.
		/// </summary>
		public void ClearSelection()
		{
			memoryViewControl.ClearSelection();
		}

		/// <summary>Shows an <see cref="OpenFileDialog"/> with all valid file extensions.</summary>
		/// <returns>The path to the selected file or null if no file was selected.</returns>
		public static string ShowOpenProjectFileDialog()
		{
			using var ofd = new OpenFileDialog
			{
				CheckFileExists = true,
				Filter = $"All ReClass Types |*{ReClassNetFile.FileExtension};*{ReClassFile.FileExtension};*{ReClassQtFile.FileExtension}"
				         + $"|{ReClassNetFile.FormatName} (*{ReClassNetFile.FileExtension})|*{ReClassNetFile.FileExtension}"
				         + $"|{ReClassFile.FormatName} (*{ReClassFile.FileExtension})|*{ReClassFile.FileExtension}"
				         + $"|{ReClassQtFile.FormatName} (*{ReClassQtFile.FileExtension})|*{ReClassQtFile.FileExtension}"
			};

			if (ofd.ShowDialog() == DialogResult.OK)
			{
				return ofd.FileName;
			}

			return null;
		}

		/// <summary>Loads the file as a new project.</summary>
		/// <param name="path">Full pathname of the file.</param>
		public void LoadProjectFromPath(string path)
		{
			Contract.Requires(path != null);

			var project = new ReClassNetProject();

			LoadProjectFromPath(path, ref project);

			// If the file is a ReClass.NET file remember the path.
			if (Path.GetExtension(path) == ReClassNetFile.FileExtension)
			{
				project.Path = path;
			}

			SetProject(project);
		}

		/// <summary>Loads the file into the given project.</summary>
		/// <param name="path">Full pathname of the file.</param>
		/// <param name="project">[in,out] The project.</param>
		private static void LoadProjectFromPath(string path, ref ReClassNetProject project)
		{
			Contract.Requires(path != null);
			Contract.Requires(project != null);
			Contract.Ensures(Contract.ValueAtReturn(out project) != null);

			IReClassImport import;
			switch (Path.GetExtension(path)?.ToLower())
			{
				case ReClassNetFile.FileExtension:
					import = new ReClassNetFile(project);
					break;
				case ReClassQtFile.FileExtension:
					import = new ReClassQtFile(project);
					break;
				case ReClassFile.FileExtension:
					import = new ReClassFile(project);
					break;
				default:
					Program.Logger.Log(LogLevel.Error, $"The file '{path}' has an unknown type.");
					return;
			}
			import.Load(path, Program.Logger);
		}

		/// <summary>Loads all symbols for the current process and displays the progress status.</summary>
		private void LoadAllSymbolsForCurrentProcess()
		{
			if (loadSymbolsTask != null && !loadSymbolsTask.IsCompleted)
			{
				return;
			}

			infoToolStripStatusLabel.Visible = true;

			var index = 0;

			var progress = new Progress<Tuple<Module, IReadOnlyList<Module>>>(
				report =>
				{
					infoToolStripStatusLabel.Text = $"[{++index}/{report.Item2.Count}] Loading symbols for module: {report.Item1.Name}";
				}
			);

			loadSymbolsTaskToken = new CancellationTokenSource();

			loadSymbolsTask = Program.RemoteProcess
				.LoadAllSymbolsAsync(progress, loadSymbolsTaskToken.Token)
				.ContinueWith(_ => infoToolStripStatusLabel.Visible = false, TaskScheduler.FromCurrentSynchronizationContext());
		}

		public void ReplaceSelectedNodesWithType(Type type)
		{
			Contract.Requires(type != null);
			Contract.Requires(type.IsSubclassOf(typeof(BaseNode)));

			var selectedNodes = memoryViewControl.GetSelectedNodes();

			var newSelected = new List<MemoryViewControl.SelectedNodeInfo>(selectedNodes.Count);

			var hotSpotPartitions = selectedNodes
				.WhereNot(s => s.Node is ClassNode)
				.GroupBy(s => s.Node.GetParentContainer())
				.Select(g => new
				{
					Container = g.Key,
					Partitions = g.OrderBy(s => s.Node.Offset)
						.GroupWhile((s1, s2) => s1.Node.Offset + s1.Node.MemorySize == s2.Node.Offset)
				});

			foreach (var containerPartitions in hotSpotPartitions)
			{
				containerPartitions.Container.BeginUpdate();

				foreach (var partition in containerPartitions.Partitions)
				{
					var hotSpotsToReplace = new Queue<MemoryViewControl.SelectedNodeInfo>(partition);
					while (hotSpotsToReplace.Count > 0)
					{
						var selected = hotSpotsToReplace.Dequeue();

						var node = BaseNode.CreateInstanceFromType(type);

						var createdNodes = new List<BaseNode>();
						containerPartitions.Container.ReplaceChildNode(selected.Node, node, ref createdNodes);

						node.IsSelected = true;

						var info = new MemoryViewControl.SelectedNodeInfo(node, selected.Process, selected.Memory, selected.Address, selected.Level);

						newSelected.Add(info);

						// If more than one node is selected I assume the user wants to replace the complete range with the desired node type.
						if (selectedNodes.Count > 1)
						{
							foreach (var createdNode in createdNodes)
							{
								hotSpotsToReplace.Enqueue(new MemoryViewControl.SelectedNodeInfo(createdNode, selected.Process, selected.Memory, selected.Address + createdNode.Offset - node.Offset, selected.Level));
							}
						}
					}
				}

				containerPartitions.Container.EndUpdate();
			}

			memoryViewControl.ClearSelection();

			if (newSelected.Count > 0)
			{
				memoryViewControl.SetSelectedNodes(newSelected);
			}
		}

		private void FindWhatInteractsWithSelectedNode(bool writeOnly)
		{
			var selectedNode = memoryViewControl.GetSelectedNodes().FirstOrDefault();
			if (selectedNode == null)
			{
				return;
			}

			LinkedWindowFeatures.FindWhatInteractsWithAddress(selectedNode.Address, selectedNode.Node.MemorySize, writeOnly);
		}

		private void CopySelectedNodesToClipboard()
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count > 0)
			{
				ReClassClipboard.Copy(selectedNodes.Select(h => h.Node), Program.Logger);
			}
		}

		private void PasteNodeFromClipboardToSelection()
		{
			var (classNodes, nodes) = ReClassClipboard.Paste(CurrentProject, Program.Logger);
			foreach (var pastedClassNode in classNodes)
			{
				if (!CurrentProject.ContainsClass(pastedClassNode.Uuid))
				{
					CurrentProject.AddClass(pastedClassNode);
				}
			}

			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count == 1)
			{
				var selectedNode = selectedNodes[0].Node;
				var containerNode = selectedNode.GetParentContainer();
				var classNode = selectedNode.GetParentClass();
				if (containerNode != null && classNode != null)
				{
					containerNode.BeginUpdate();

					foreach (var node in nodes)
					{
						if (node is BaseWrapperNode)
						{
							var rootWrapper = node.GetRootWrapperNode();
							Debug.Assert(rootWrapper == node);

							if (rootWrapper.ShouldPerformCycleCheckForInnerNode())
							{
								if (rootWrapper.ResolveMostInnerNode() is ClassNode innerNode)
								{
									if (!IsCycleFree(classNode, innerNode))
									{
										continue;
									}
								}
							}
						}

						containerNode.InsertNode(selectedNode, node);
					}

					containerNode.EndUpdate();
				}
			}
		}

		private void EditSelectedNodeName()
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count == 1)
			{
				memoryViewControl.ShowNodeNameEditBox(selectedNodes[0].Node);
			}
		}

		private void RemoveSelectedNodes()
		{
			memoryViewControl.GetSelectedNodes()
				.WhereNot(h => h.Node is ClassNode)
				.ForEach(h => h.Node.GetParentContainer().RemoveNode(h.Node));

			ClearSelection();
		}

		private void HideSelectedNodes()
		{
			foreach (var hotSpot in memoryViewControl.GetSelectedNodes())
			{
				hotSpot.Node.IsHidden = true;
			}

			ClearSelection();
		}

		private void UnhideChildNodes()
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count != 1)
			{
				return;
			}

			if (!(selectedNodes[0].Node is BaseContainerNode containerNode))
			{
				return;
			}

			foreach (var bn in containerNode.Nodes)
			{
				bn.IsHidden = false;
				bn.IsSelected = false;
			}

			containerNode.IsSelected = false;

			ClearSelection();
		}

		private void UnhideNodesBelow()
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count != 1)
			{
				return;
			}

			var selectedNode = selectedNodes[0].Node;

			var parentNode = selectedNode.GetParentContainer();
			if (parentNode == null)
			{
				return;
			}

			var hiddenNodeStartIndex = parentNode.FindNodeIndex(selectedNode) + 1;
			if (hiddenNodeStartIndex >= parentNode.Nodes.Count)
			{
				return;
			}

			for (var i = hiddenNodeStartIndex; i < parentNode.Nodes.Count; i++)
			{
				var indexNode = parentNode.Nodes[i];
				if (indexNode.IsHidden)
				{
					indexNode.IsHidden = false;
					indexNode.IsSelected = false;
				}
				else
				{
					break;
				}
			}

			selectedNode.IsSelected = false;

			ClearSelection();
		}

		private void UnhideNodesAbove()
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count != 1)
			{
				return;
			}

			var selectedNode = selectedNodes[0].Node;

			var parentNode = selectedNode.GetParentContainer();
			if (parentNode == null)
			{
				return;
			}

			var hiddenNodeStartIndex = parentNode.FindNodeIndex(selectedNode) - 1;
			if (hiddenNodeStartIndex < 0)
			{
				return;
			}

			for (var i = hiddenNodeStartIndex; i > -1; i--)
			{
				var indexNode = parentNode.Nodes[i];
				if (indexNode.IsHidden)
				{
					indexNode.IsHidden = false;
					indexNode.IsSelected = false;
				}
				else
				{
					break;
				}
			}

			selectedNode.IsSelected = false;

			ClearSelection();
		}

		private bool IsCycleFree(ClassNode parent, ClassNode node)
		{
			if (ClassUtil.IsCyclicIfClassIsAccessibleFromParent(parent, node, CurrentProject.Classes))
			{
				MessageBox.Show("Invalid operation because this would create a class cycle.", "Cycle Detected", MessageBoxButtons.OK, MessageBoxIcon.Error);

				return false;
			}

			return true;
		}
	}
}

```

`ReClass.NET/Forms/MainForm.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.AddressParser;
using ReClassNET.CodeGenerator;
using ReClassNET.Controls;
using ReClassNET.Core;
using ReClassNET.DataExchange.ReClass;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Nodes;
using ReClassNET.Plugins;
using ReClassNET.Project;
using ReClassNET.UI;
using ReClassNET.Util;
using ReClassNET.Util.Conversion;

namespace ReClassNET.Forms
{
	public partial class MainForm : IconForm
	{
		private readonly PluginManager pluginManager;
		private readonly IconProvider iconProvider = new IconProvider();

		private ReClassNetProject currentProject;
		public ReClassNetProject CurrentProject => currentProject;

		private ClassNode currentClassNode;

		private readonly MemoryBuffer memoryViewBuffer = new MemoryBuffer();

		private Task updateProcessInformationsTask;
		private Task loadSymbolsTask;
		private CancellationTokenSource loadSymbolsTaskToken;

		public ProjectView ProjectView => projectView;

		public MenuStrip MainMenu => mainMenuStrip;

		public ClassNode CurrentClassNode
		{
			get => currentClassNode;
			set
			{
				currentClassNode = value;

				projectView.SelectedClass = value;

				memoryViewControl.Reset();
				memoryViewControl.Invalidate();
			}
		}

		private void UpdateWindowTitle(string extra = null)
		{
			var title = $"{(Program.Settings.RandomizeWindowTitle ? Utils.RandomString(Program.GlobalRandom.Next(15, 20)) : Constants.ApplicationName)} ({Constants.Platform})";
			if (!string.IsNullOrEmpty(extra))
			{
				title += $" - {extra}";
			}
			Text = title;
		}

		public MainForm()
		{
			Contract.Ensures(pluginManager != null);
			Contract.Ensures(currentProject != null);

			InitializeComponent();
			UpdateWindowTitle();

			mainMenuStrip.Renderer = new CustomToolStripProfessionalRenderer(true, true);
			toolStrip.Renderer = new CustomToolStripProfessionalRenderer(true, false);
			isLittleEndianToolStripMenuItem.Checked = BitConverter.IsLittleEndian;

			Program.RemoteProcess.ProcessAttached += sender =>
			{
				var text = $"{sender.UnderlayingProcess.Name} (ID: {sender.UnderlayingProcess.Id.ToString()})";
				processInfoToolStripStatusLabel.Text = text;
				UpdateWindowTitle(text);

			};
			Program.RemoteProcess.ProcessClosed += sender =>
			{
				UpdateWindowTitle();
				processInfoToolStripStatusLabel.Text = "No process selected";
			};

			pluginManager = new PluginManager(new DefaultPluginHost(this, Program.RemoteProcess, Program.Logger));
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);

			pluginManager.LoadAllPlugins(Path.Combine(Application.StartupPath, Constants.PluginsFolder), Program.Logger);

			toolStrip.Items.AddRange(NodeTypesBuilder.CreateToolStripButtons(ReplaceSelectedNodesWithType).ToArray());
			changeTypeToolStripMenuItem.DropDownItems.AddRange(NodeTypesBuilder.CreateToolStripMenuItems(ReplaceSelectedNodesWithType, false).ToArray());

			var createDefaultProject = true;

			if (Program.CommandLineArgs.FileName != null)
			{
				try
				{
					LoadProjectFromPath(Program.CommandLineArgs.FileName);

					createDefaultProject = false;
				}
				catch (Exception ex)
				{
					Program.Logger.Log(ex);
				}
			}
			
			if (createDefaultProject)
			{
				SetProject(new ReClassNetProject());

				LinkedWindowFeatures.CreateDefaultClass();
			}

			if (Program.CommandLineArgs[Constants.CommandLineOptions.AttachTo] != null)
			{
				AttachToProcess(Program.CommandLineArgs[Constants.CommandLineOptions.AttachTo]);
			}
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			pluginManager.UnloadAllPlugins();

			GlobalWindowManager.RemoveWindow(this);

			base.OnFormClosed(e);
		}

		private async void MainForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			// Stop the update timer
			processUpdateTimer.Stop();

			// and cancel all running tasks.
			if (loadSymbolsTask != null || updateProcessInformationsTask != null)
			{
				e.Cancel = true;

				Hide();

				if (loadSymbolsTask != null)
				{
					loadSymbolsTaskToken.Cancel();

					try
					{
						await loadSymbolsTask;
					}
					catch
					{
						// ignored
					}

					loadSymbolsTask = null;
				}

				if (updateProcessInformationsTask != null)
				{
					try
					{
						await updateProcessInformationsTask;
					}
					catch
					{
						// ignored
					}

					updateProcessInformationsTask = null;
				}

				Close();
			}
		}

		#region Menustrip

		private void fileToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
		{
			var lastProcess = Program.Settings.LastProcess;
			if (string.IsNullOrEmpty(lastProcess))
			{
				reattachToProcessToolStripMenuItem.Visible = false;
			}
			else
			{
				reattachToProcessToolStripMenuItem.Visible = true;
				reattachToProcessToolStripMenuItem.Text = $"Re-Attach to '{lastProcess}'";
			}
		}

		private void reattachToProcessToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var lastProcess = Program.Settings.LastProcess;
			if (string.IsNullOrEmpty(lastProcess))
			{
				return;
			}

			AttachToProcess(lastProcess);
		}

		private void detachToolStripMenuItem_Click(object sender, EventArgs e)
		{
			Program.RemoteProcess.Close();
		}

		private void newClassToolStripButton_Click(object sender, EventArgs e)
		{
			LinkedWindowFeatures.CreateDefaultClass();
		}

		private void openProjectToolStripMenuItem_Click(object sender, EventArgs e)
		{
			try
			{
				var path = ShowOpenProjectFileDialog();
				if (path != null)
				{
					LoadProjectFromPath(path);
				}
			}
			catch (Exception ex)
			{
				Program.Logger.Log(ex);
			}
		}

		private void mergeWithProjectToolStripMenuItem_Click(object sender, EventArgs e)
		{
			try
			{
				var path = ShowOpenProjectFileDialog();
				if (path != null)
				{
					LoadProjectFromPath(path, ref currentProject);
				}
			}
			catch (Exception ex)
			{
				Program.Logger.Log(ex);
			}
		}

		private void goToClassToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var csf = new ClassSelectionForm(currentProject.Classes.OrderBy(c => c.Name));

			if (csf.ShowDialog() == DialogResult.OK)
			{
				var selectedClassNode = csf.SelectedClass;
				if (selectedClassNode != null)
				{
					projectView.SelectedClass = selectedClassNode;
				}
			}
		}

		private void clearProjectToolStripMenuItem_Click(object sender, EventArgs e)
		{
			SetProject(new ReClassNetProject());
		}

		private void saveToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!currentProject.Classes.Any())
			{
				return;
			}

			if (string.IsNullOrEmpty(currentProject.Path))
			{
				saveAsToolStripMenuItem_Click(sender, e);

				return;
			}

			var file = new ReClassNetFile(currentProject);
			file.Save(currentProject.Path, Program.Logger);
		}

		private void saveAsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!currentProject.Classes.Any())
			{
				return;
			}

			using var sfd = new SaveFileDialog
			{
				DefaultExt = ReClassNetFile.FileExtension,
				Filter = $"{ReClassNetFile.FormatName} (*{ReClassNetFile.FileExtension})|*{ReClassNetFile.FileExtension}"
			};

			if (sfd.ShowDialog() == DialogResult.OK)
			{
				currentProject.Path = sfd.FileName;

				saveToolStripMenuItem_Click(sender, e);
			}
		}

		private void settingsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var sd = new SettingsForm(Program.Settings, CurrentProject.TypeMapping);

			sd.ShowDialog();
		}

		private void pluginsToolStripButton_Click(object sender, EventArgs e)
		{
			using var pf = new PluginForm(pluginManager);

			pf.ShowDialog();
		}

		private void quitToolStripMenuItem_Click(object sender, EventArgs e)
		{
			Close();
		}

		private void memoryViewerToolStripMenuItem_Click(object sender, EventArgs e)
		{
			new ProcessInfoForm(Program.RemoteProcess).Show();
		}

		private void memorySearcherToolStripMenuItem_Click(object sender, EventArgs e)
		{
			new ScannerForm(Program.RemoteProcess).Show();
		}

		private void namedAddressesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			new NamedAddressesForm(Program.RemoteProcess).Show();
		}

		private void isLittleEndianToolStripMenuItem_Click(object sender, EventArgs e)
		{
			Program.RemoteProcess.BitConverter = isLittleEndianToolStripMenuItem.Checked ? (EndianBitConverter)EndianBitConverter.Little : EndianBitConverter.Big;
		}

		private void loadSymbolToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var ofd = new OpenFileDialog
			{
				Filter = "Program Debug Database (*.pdb)|*.pdb|All Files (*.*)|*.*"
			};


			if (ofd.ShowDialog() == DialogResult.OK)
			{
				try
				{
					Program.RemoteProcess.Symbols.LoadSymbolsFromPDB(ofd.FileName);
				}
				catch (Exception ex)
				{
					Program.Logger.Log(ex);
				}
			}
		}

		private void loadSymbolsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LoadAllSymbolsForCurrentProcess();
		}

		private void ControlRemoteProcessToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!Program.RemoteProcess.IsValid)
			{
				return;
			}

			var action = ControlRemoteProcessAction.Terminate;
			if (sender == resumeProcessToolStripMenuItem)
			{
				action = ControlRemoteProcessAction.Resume;
			}
			else if (sender == suspendProcessToolStripMenuItem)
			{
				action = ControlRemoteProcessAction.Suspend;
			}

			Program.RemoteProcess.ControlRemoteProcess(action);
		}

		private void cleanUnusedClassesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			currentProject.RemoveUnusedClasses();
		}

		private void generateCppCodeToolStripMenuItem_Click(object sender, EventArgs e)
		{
			ShowCodeGeneratorForm(new CppCodeGenerator(currentProject.TypeMapping));
		}

		private void generateCSharpCodeToolStripMenuItem_Click(object sender, EventArgs e)
		{
			ShowCodeGeneratorForm(new CSharpCodeGenerator());
		}

		private void aboutToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var af = new AboutForm();

			af.ShowDialog();
		}

		#endregion

		#region Toolstrip

		private void attachToProcessToolStripSplitButton_ButtonClick(object sender, EventArgs e)
		{
			using var pb = new ProcessBrowserForm(Program.Settings.LastProcess);

			if (pb.ShowDialog() == DialogResult.OK)
			{
				if (pb.SelectedProcess != null)
				{
					AttachToProcess(pb.SelectedProcess);

					if (pb.LoadSymbols)
					{
						LoadAllSymbolsForCurrentProcess();
					}
				}
			}
		}

		private void attachToProcessToolStripSplitButton_DropDownClosed(object sender, EventArgs e)
		{
			attachToProcessToolStripSplitButton.DropDownItems.Clear();
		}

		private void attachToProcessToolStripSplitButton_DropDownOpening(object sender, EventArgs e)
		{
			attachToProcessToolStripSplitButton.DropDownItems.AddRange(
				Program.CoreFunctions.EnumerateProcesses()
					.OrderBy(p => p.Name).ThenBy(p => p.Id, IntPtrComparer.Instance)
					.Select(p => new ToolStripMenuItem($"[{p.Id}] {p.Name}", p.Icon, (sender2, e2) => AttachToProcess(p)))
					.Cast<ToolStripItem>()
					.ToArray()
			);
		}

		private void selectedNodeContextMenuStrip_Opening(object sender, CancelEventArgs e)
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();

			var count = selectedNodes.Count;
			var node = selectedNodes.Select(s => s.Node).FirstOrDefault();
			var parentNode = node?.GetParentContainer();

			var nodeIsClass = node is ClassNode;
			var nodeIsSearchableValueNode = node switch
			{
				BaseHexNode _ => true,
				FloatNode _ => true,
				DoubleNode _ => true,
				Int8Node _ => true,
				UInt8Node _ => true,
				Int16Node _ => true,
				UInt16Node _ => true,
				Int32Node _ => true,
				UInt32Node _ => true,
				Int64Node _ => true,
				UInt64Node _ => true,
				NIntNode _ => true,
				NUIntNode _ => true,
				Utf8TextNode _ => true,
				Utf16TextNode _ => true,
				Utf32TextNode _ => true,
				_ => false
			};

			addBytesToolStripMenuItem.Enabled = parentNode != null || nodeIsClass;
			insertBytesToolStripMenuItem.Enabled = count == 1 && parentNode != null && !nodeIsClass;

			changeTypeToolStripMenuItem.Enabled = count > 0 && !nodeIsClass;

			createClassFromNodesToolStripMenuItem.Enabled = count > 0 && !nodeIsClass;
			dissectNodesToolStripMenuItem.Enabled = count > 0 && !nodeIsClass;
			searchForEqualValuesToolStripMenuItem.Enabled = count == 1 && nodeIsSearchableValueNode;

			pasteNodesToolStripMenuItem.Enabled = count == 1 && ReClassClipboard.ContainsNodes;
			removeToolStripMenuItem.Enabled = !nodeIsClass;

			copyAddressToolStripMenuItem.Enabled = !nodeIsClass;

			showCodeOfClassToolStripMenuItem.Enabled = nodeIsClass;
			shrinkClassToolStripMenuItem.Enabled = nodeIsClass;

			hideNodesToolStripMenuItem.Enabled = selectedNodes.All(h => !(h.Node is ClassNode));

			unhideChildNodesToolStripMenuItem.Enabled = count == 1 && node is BaseContainerNode bcn && bcn.Nodes.Any(n => n.IsHidden);
			unhideNodesAboveToolStripMenuItem.Enabled = count == 1 && parentNode != null && parentNode.TryGetPredecessor(node, out var predecessor) && predecessor.IsHidden;
			unhideNodesBelowToolStripMenuItem.Enabled = count == 1 && parentNode != null && parentNode.TryGetSuccessor(node, out var successor) && successor.IsHidden;
		}

		private void addBytesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!(sender is IntegerToolStripMenuItem item))
			{
				return;
			}

			AddBytesToClass(item.Value);
		}

		private void addXBytesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			AskAddOrInsertBytes("Add Bytes", AddBytesToClass);
		}

		private void insertBytesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!(sender is IntegerToolStripMenuItem item))
			{
				return;
			}

			InsertBytesInClass(item.Value);
		}

		private void insertXBytesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			AskAddOrInsertBytes("Insert Bytes", InsertBytesInClass);
		}

		private void createClassFromNodesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();

			if (selectedNodes.Count > 0 && !(selectedNodes[0].Node is ClassNode))
			{
				if (selectedNodes[0].Node.GetParentContainer() is ClassNode parentNode)
				{
					var newClassNode = ClassNode.Create();
					selectedNodes.Select(h => h.Node).ForEach(newClassNode.AddNode);

					var classInstanceNode = new ClassInstanceNode();
					classInstanceNode.ChangeInnerNode(newClassNode);

					parentNode.InsertNode(selectedNodes[0].Node, classInstanceNode);

					selectedNodes.Select(h => h.Node).ForEach(c => parentNode.RemoveNode(c));

					ClearSelection();
				}
			}
		}

		private void dissectNodesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var hexNodes = memoryViewControl.GetSelectedNodes().Where(h => h.Node is BaseHexNode).ToList();
			if (!hexNodes.Any())
			{
				return;
			}

			foreach (var g in hexNodes.GroupBy(n => n.Node.GetParentContainer()))
			{
				NodeDissector.DissectNodes(g.Select(h => (BaseHexNode)h.Node), Program.RemoteProcess, g.First().Memory);
			}

			ClearSelection();
		}

		private void searchForEqualValuesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var selectedNode = memoryViewControl.GetSelectedNodes().FirstOrDefault();
			if (selectedNode == null)
			{
				return;
			}

			var bitConverter = Program.RemoteProcess.BitConverter;

			IScanComparer comparer;
			switch (selectedNode.Node)
			{
				case BaseHexNode node:
					comparer = new ArrayOfBytesMemoryComparer(node.ReadValueFromMemory(selectedNode.Memory));
					break;
				case FloatNode node:
					comparer = new FloatMemoryComparer(ScanCompareType.Equal, ScanRoundMode.Normal, 2, node.ReadValueFromMemory(selectedNode.Memory), 0.0f, bitConverter);
					break;
				case DoubleNode node:
					comparer = new DoubleMemoryComparer(ScanCompareType.Equal, ScanRoundMode.Normal, 2, node.ReadValueFromMemory(selectedNode.Memory), 0.0, bitConverter);
					break;
				case Int8Node node:
					comparer = new ByteMemoryComparer(ScanCompareType.Equal, (byte)node.ReadValueFromMemory(selectedNode.Memory), 0);
					break;
				case UInt8Node node:
					comparer = new ByteMemoryComparer(ScanCompareType.Equal, node.ReadValueFromMemory(selectedNode.Memory), 0);
					break;
				case Int16Node node:
					comparer = new ShortMemoryComparer(ScanCompareType.Equal, node.ReadValueFromMemory(selectedNode.Memory), 0, bitConverter);
					break;
				case UInt16Node node:
					comparer = new ShortMemoryComparer(ScanCompareType.Equal, (short)node.ReadValueFromMemory(selectedNode.Memory), 0, bitConverter);
					break;
				case Int32Node node:
					comparer = new IntegerMemoryComparer(ScanCompareType.Equal, node.ReadValueFromMemory(selectedNode.Memory), 0, bitConverter);
					break;
				case UInt32Node node:
					comparer = new IntegerMemoryComparer(ScanCompareType.Equal, (int)node.ReadValueFromMemory(selectedNode.Memory), 0, bitConverter);
					break;
				case Int64Node node:
					comparer = new LongMemoryComparer(ScanCompareType.Equal, node.ReadValueFromMemory(selectedNode.Memory), 0L, bitConverter);
					break;
				case UInt64Node node:
					comparer = new LongMemoryComparer(ScanCompareType.Equal, (long)node.ReadValueFromMemory(selectedNode.Memory), 0L, bitConverter);
					break;
				case NIntNode node:
				{
					var value = node.ReadValueFromMemory(selectedNode.Memory);
#if RECLASSNET64
					comparer = new LongMemoryComparer(ScanCompareType.Equal, value.ToInt64(), 0L, bitConverter);
#else
					comparer = new IntegerMemoryComparer(ScanCompareType.Equal, value.ToInt32(), 0, bitConverter);
#endif
					break;
				}
				case NUIntNode node:
				{
					var value = node.ReadValueFromMemory(selectedNode.Memory);
#if RECLASSNET64
					comparer = new LongMemoryComparer(ScanCompareType.Equal, (long)value.ToUInt64(), 0L, bitConverter);
#else
					comparer = new IntegerMemoryComparer(ScanCompareType.Equal, (int)value.ToUInt32(), 0, bitConverter);
#endif
					break;
				}
				case Utf8TextNode node:
					comparer = new StringMemoryComparer(node.ReadValueFromMemory(selectedNode.Memory), Encoding.UTF8, true);
					break;
				case Utf16TextNode node:
					comparer = new StringMemoryComparer(node.ReadValueFromMemory(selectedNode.Memory), Encoding.Unicode, true);
					break;
				case Utf32TextNode node:
					comparer = new StringMemoryComparer(node.ReadValueFromMemory(selectedNode.Memory), Encoding.UTF32, true);
					break;
				default:
					return;
			}

			LinkedWindowFeatures.StartMemoryScan(comparer);
		}

		private void findOutWhatAccessesThisAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			FindWhatInteractsWithSelectedNode(false);
		}

		private void findOutWhatWritesToThisAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			FindWhatInteractsWithSelectedNode(true);
		}

		private void copyNodeToolStripMenuItem_Click(object sender, EventArgs e)
		{
			CopySelectedNodesToClipboard();
		}

		private void pasteNodesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			PasteNodeFromClipboardToSelection();
		}

		private void removeToolStripMenuItem_Click(object sender, EventArgs e)
		{
			RemoveSelectedNodes();
		}

		private void hideNodesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			HideSelectedNodes();
		}

		private void unhideChildNodesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			UnhideChildNodes();
		}

		private void unhideNodesAboveToolStripMenuItem_Click(object sender, EventArgs e)
		{
			UnhideNodesAbove();
		}

		private void unhideNodesBelowToolStripMenuItem_Click(object sender, EventArgs e)
		{
			UnhideNodesBelow();
		}

		private void copyAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var selectedNodes = memoryViewControl.GetSelectedNodes();
			if (selectedNodes.Count > 0)
			{
				Clipboard.SetText(selectedNodes.First().Address.ToString("X"));
			}
		}

		private void showCodeOfClassToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (memoryViewControl.GetSelectedNodes().FirstOrDefault()?.Node is ClassNode node)
			{
				ShowPartialCodeGeneratorForm(new[] { node });
			}
		}

		private void shrinkClassToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var node = memoryViewControl.GetSelectedNodes().Select(s => s.Node).FirstOrDefault();
			if (!(node is ClassNode classNode))
			{
				return;
			}

			foreach (var nodeToDelete in classNode.Nodes.Reverse().TakeWhile(n => n is BaseHexNode))
			{
				classNode.RemoveNode(nodeToDelete);
			}
		}

#endregion

		private void MainForm_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent(DataFormats.FileDrop))
			{
				if (e.Data.GetData(DataFormats.FileDrop) is string[] files && files.Any())
				{
					switch (Path.GetExtension(files.First()))
					{
						case ReClassNetFile.FileExtension:
						case ReClassQtFile.FileExtension:
						case ReClassFile.FileExtension:
							e.Effect = DragDropEffects.Copy;
							break;
					}
				}
			}
		}

		private void MainForm_DragDrop(object sender, DragEventArgs e)
		{
			if (e.Data.GetData(DataFormats.FileDrop) is string[] files && files.Any())
			{
				try
				{
					var path = files.First();

					LoadProjectFromPath(path);
				}
				catch (Exception ex)
				{
					Program.Logger.Log(ex);
				}
			}
		}

		private void processUpdateTimer_Tick(object sender, EventArgs e)
		{
			if (updateProcessInformationsTask != null && !updateProcessInformationsTask.IsCompleted)
			{
				return;
			}

			updateProcessInformationsTask = Program.RemoteProcess.UpdateProcessInformationsAsync();
		}

		private void classesView_ClassSelected(object sender, ClassNode node)
		{
			CurrentClassNode = node;
		}

		private void memoryViewControl_KeyDown(object sender, KeyEventArgs args)
		{
			switch (args.KeyCode)
			{
				case Keys.C when args.Control:
					CopySelectedNodesToClipboard();
					break;
				case Keys.V when args.Control:
					PasteNodeFromClipboardToSelection();
					break;

				case Keys.Delete:
					RemoveSelectedNodes();
					break;

				case Keys.F2:
					EditSelectedNodeName();
					break;
			}
		}

		private void memoryViewControl_SelectionChanged(object sender, EventArgs e)
		{
			if (!(sender is MemoryViewControl memoryView))
			{
				return;
			}

			var selectedNodes = memoryView.GetSelectedNodes();

			var node = selectedNodes.FirstOrDefault()?.Node;
			var parentContainer = node?.GetParentContainer();
			var nodeIsClass = node is ClassNode;

			addBytesToolStripDropDownButton.Enabled = parentContainer != null || nodeIsClass;
			insertBytesToolStripDropDownButton.Enabled = selectedNodes.Count == 1 && parentContainer != null && !nodeIsClass;

			var enabled = selectedNodes.Count > 0 && !nodeIsClass;
			toolStrip.Items.OfType<TypeToolStripButton>().ForEach(b => b.Enabled = enabled);
		}

		private void memoryViewControl_ChangeClassTypeClick(object sender, NodeClickEventArgs e)
		{
			var classes = CurrentProject.Classes.OrderBy(c => c.Name);

			if (e.Node is FunctionNode functionNode)
			{
				var noneClass = new ClassNode(false)
				{
					Name = "None"
				};

				using var csf = new ClassSelectionForm(classes.Prepend(noneClass));

				if (csf.ShowDialog() == DialogResult.OK)
				{
					var selectedClassNode = csf.SelectedClass;
					if (selectedClassNode != null)
					{
						if (selectedClassNode == noneClass)
						{
							selectedClassNode = null;
						}

						functionNode.BelongsToClass = selectedClassNode;
					}
				}
			}
			else if (e.Node is BaseWrapperNode refNode)
			{
				using var csf = new ClassSelectionForm(classes);

				if (csf.ShowDialog() == DialogResult.OK)
				{
					var selectedClassNode = csf.SelectedClass;
					if (refNode.CanChangeInnerNodeTo(selectedClassNode))
					{
						if (!refNode.GetRootWrapperNode().ShouldPerformCycleCheckForInnerNode() || IsCycleFree(e.Node.GetParentClass(), selectedClassNode))
						{
							refNode.ChangeInnerNode(selectedClassNode);
						}
					}
				}
			}
		}

		private void memoryViewControl_ChangeWrappedTypeClick(object sender, NodeClickEventArgs e)
		{
			if (e.Node is BaseWrapperNode wrapperNode)
			{
				var items = NodeTypesBuilder.CreateToolStripMenuItems(t =>
				{
					var node = BaseNode.CreateInstanceFromType(t);
					if (wrapperNode.CanChangeInnerNodeTo(node))
					{
						wrapperNode.ChangeInnerNode(node);
					}
				}, wrapperNode.CanChangeInnerNodeTo(null));

				var menu = new ContextMenuStrip();
				menu.Items.AddRange(items.ToArray());
				menu.Show(this, e.Location);
			}
		}

		private void memoryViewControl_ChangeEnumTypeClick(object sender, NodeClickEventArgs e)
		{
			if (e.Node is EnumNode enumNode)
			{
				using var csf = new EnumSelectionForm(CurrentProject);

				var size = enumNode.Enum.Size;

				if (csf.ShowDialog() == DialogResult.OK)
				{
					var @enum = csf.SelectedItem;
					if (@enum != null)
					{
						enumNode.ChangeEnum(@enum);
					}
				}

				if (size != enumNode.Enum.Size)
				{
					// Update the parent container because the enum size has changed.
					enumNode.GetParentContainer()?.ChildHasChanged(enumNode);
				}

				foreach (var @enum in CurrentProject.Enums)
				{
					projectView.UpdateEnumNode(@enum);
				}
			}
		}

		private void showCodeOfClassToolStripMenuItem2_Click(object sender, EventArgs e)
		{
			var classNode = projectView.SelectedClass;
			if (classNode == null)
			{
				return;
			}

			ShowPartialCodeGeneratorForm(new[] { classNode });
		}

		private void enableHierarchyViewToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var isChecked = !enableHierarchyViewToolStripMenuItem.Checked;

			enableHierarchyViewToolStripMenuItem.Checked = isChecked;

			expandAllClassesToolStripMenuItem.Enabled = collapseAllClassesToolStripMenuItem.Enabled = isChecked;

			projectView.EnableClassHierarchyView = isChecked;
		}

		private void autoExpandHierarchyViewToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var isChecked = !autoExpandHierarchyViewToolStripMenuItem.Checked;

			autoExpandHierarchyViewToolStripMenuItem.Checked = isChecked;

			projectView.AutoExpandClassNodes = isChecked;
		}

		private void expandAllClassesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			projectView.ExpandAllClassNodes();
		}

		private void collapseAllClassesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			projectView.CollapseAllClassNodes();
		}

		private void removeUnusedClassesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			CurrentProject.RemoveUnusedClasses();
		}

		private void deleteClassToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var classNode = projectView.SelectedClass;
			if (classNode == null)
			{
				return;
			}

			try
			{
				CurrentProject.Remove(classNode);
			}
			catch (ClassReferencedException ex)
			{
				Program.Logger.Log(ex);
			}
		}

		private void editEnumsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var elf = new EnumListForm(currentProject);

			elf.ShowDialog();
		}

		private void editEnumToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var @enum = projectView.SelectedEnum;
			if (@enum != null)
			{
				using var eef = new EnumEditorForm(@enum);

				eef.ShowDialog();
			}
		}

		private void showEnumsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using var elf = new EnumListForm(currentProject);

			elf.ShowDialog();
		}

		private void memoryViewControl_DrawContextRequested(object sender, DrawContextRequestEventArgs args)
		{
			var process = Program.RemoteProcess;

			var classNode = CurrentClassNode;
			if (classNode != null)
			{
				memoryViewBuffer.Size = classNode.MemorySize;

				IntPtr address;
				try
				{
					address = process.ParseAddress(classNode.AddressFormula);
				}
				catch (ParseException)
				{
					address = IntPtr.Zero;
				}
				memoryViewBuffer.UpdateFrom(process, address);

				args.Settings = Program.Settings;
				args.IconProvider = iconProvider;
				args.Process = process;
				args.Memory = memoryViewBuffer;
				args.Node = classNode;
				args.BaseAddress = address;
			}
		}
	}
}

```

`ReClass.NET/Forms/MainForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="processUpdateTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>366, 17</value>
  </metadata>
  <metadata name="projectClassContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>756, 17</value>
  </metadata>
  <metadata name="projectClassesContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>986, 17</value>
  </metadata>
  <metadata name="projectEnumContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>1214, 17</value>
  </metadata>
  <metadata name="projectEnumsContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>1434, 17</value>
  </metadata>
  <metadata name="selectedNodeContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>530, 17</value>
  </metadata>
  <metadata name="toolStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>268, 17</value>
  </metadata>
  <metadata name="statusStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="mainMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>133, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="loadSymbolsToolStripMenuItem.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>42</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/NamedAddressesForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class NamedAddressesForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.bannerBox = new BannerBox();
			this.addressTextBox = new PlaceholderTextBox();
			this.nameTextBox = new PlaceholderTextBox();
			this.namedAddressesListBox = new System.Windows.Forms.ListBox();
			this.removeAddressIconButton = new IconButton();
			this.addAddressIconButton = new IconButton();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B16x16_Custom_Type;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(429, 48);
			this.bannerBox.TabIndex = 10;
			this.bannerBox.Text = "Give special memory addresses meaningfull names.";
			this.bannerBox.Title = "Named Addresses";
			// 
			// addressTextBox
			// 
			this.addressTextBox.Location = new System.Drawing.Point(13, 55);
			this.addressTextBox.Name = "addressTextBox";
			this.addressTextBox.PlaceholderText = "Address";
			this.addressTextBox.Size = new System.Drawing.Size(154, 20);
			this.addressTextBox.TabIndex = 1;
			this.addressTextBox.TextChanged += new System.EventHandler(this.InputTextBox_TextChanged);
			// 
			// nameTextBox
			// 
			this.nameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.nameTextBox.Location = new System.Drawing.Point(173, 55);
			this.nameTextBox.Name = "nameTextBox";
			this.nameTextBox.PlaceholderText = "Name";
			this.nameTextBox.Size = new System.Drawing.Size(190, 20);
			this.nameTextBox.TabIndex = 2;
			this.nameTextBox.TextChanged += new System.EventHandler(this.InputTextBox_TextChanged);
			// 
			// namedAddressesListBox
			// 
			this.namedAddressesListBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.namedAddressesListBox.FormattingEnabled = true;
			this.namedAddressesListBox.Location = new System.Drawing.Point(13, 81);
			this.namedAddressesListBox.Name = "namedAddressesListBox";
			this.namedAddressesListBox.Size = new System.Drawing.Size(404, 186);
			this.namedAddressesListBox.TabIndex = 0;
			this.namedAddressesListBox.SelectedIndexChanged += new System.EventHandler(this.namedAddressesListBox_SelectedIndexChanged);
			// 
			// removeAddressIconButton
			// 
			this.removeAddressIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.removeAddressIconButton.Enabled = false;
			this.removeAddressIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Remove;
			this.removeAddressIconButton.Location = new System.Drawing.Point(394, 54);
			this.removeAddressIconButton.Name = "removeAddressIconButton";
			this.removeAddressIconButton.Pressed = false;
			this.removeAddressIconButton.Selected = false;
			this.removeAddressIconButton.Size = new System.Drawing.Size(23, 22);
			this.removeAddressIconButton.TabIndex = 4;
			this.removeAddressIconButton.Click += new System.EventHandler(this.removeAddressIconButton_Click);
			// 
			// addAddressIconButton
			// 
			this.addAddressIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.addAddressIconButton.Enabled = false;
			this.addAddressIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Add;
			this.addAddressIconButton.Location = new System.Drawing.Point(369, 54);
			this.addAddressIconButton.Name = "addAddressIconButton";
			this.addAddressIconButton.Pressed = false;
			this.addAddressIconButton.Selected = false;
			this.addAddressIconButton.Size = new System.Drawing.Size(23, 22);
			this.addAddressIconButton.TabIndex = 3;
			this.addAddressIconButton.Click += new System.EventHandler(this.addAddressIconButton_Click);
			// 
			// NamedAddressesForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(429, 279);
			this.Controls.Add(this.addAddressIconButton);
			this.Controls.Add(this.removeAddressIconButton);
			this.Controls.Add(this.namedAddressesListBox);
			this.Controls.Add(this.nameTextBox);
			this.Controls.Add(this.addressTextBox);
			this.Controls.Add(this.bannerBox);
			this.MinimumSize = new System.Drawing.Size(445, 317);
			this.Name = "NamedAddressesForm";
			this.Text = "ReClass.NET - Named Addresses";
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private BannerBox bannerBox;
		private PlaceholderTextBox addressTextBox;
		private PlaceholderTextBox nameTextBox;
		private System.Windows.Forms.ListBox namedAddressesListBox;
		private IconButton removeAddressIconButton;
		private IconButton addAddressIconButton;
	}
}
```

`ReClass.NET/Forms/NamedAddressesForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class NamedAddressesForm : IconForm
	{
		private readonly RemoteProcess process;

		public NamedAddressesForm(RemoteProcess process)
		{
			Contract.Requires(process != null);

			this.process = process;

			InitializeComponent();

			DisplayNamedAddresses();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void InputTextBox_TextChanged(object sender, EventArgs e)
		{
			addAddressIconButton.Enabled = IsValidInput();
		}

		private void namedAddressesListBox_SelectedIndexChanged(object sender, EventArgs e)
		{
			removeAddressIconButton.Enabled = namedAddressesListBox.SelectedIndex != -1;
		}

		private void addAddressIconButton_Click(object sender, EventArgs e)
		{
			if (!IsValidInput())
			{
				return;
			}

			var address = process.ParseAddress(addressTextBox.Text.Trim());
			var name = nameTextBox.Text.Trim();

			process.NamedAddresses[address] = name;

			addressTextBox.Text = nameTextBox.Text = null;

			DisplayNamedAddresses();
		}

		private void removeAddressIconButton_Click(object sender, EventArgs e)
		{
			if (namedAddressesListBox.SelectedItem is BindingDisplayWrapper<KeyValuePair<IntPtr, string>> namedAddress)
			{
				process.NamedAddresses.Remove(namedAddress.Value.Key);

				DisplayNamedAddresses();
			}
		}

		#endregion

		private void DisplayNamedAddresses()
		{
			namedAddressesListBox.DataSource = process.NamedAddresses
				.Select(kv => new BindingDisplayWrapper<KeyValuePair<IntPtr, string>>(kv, v => $"0x{v.Key.ToString(Constants.AddressHexFormat)}: {v.Value}"))
				.ToList();

			namedAddressesListBox_SelectedIndexChanged(null, null);
		}

		private bool IsValidInput()
		{
			try
			{
				var address = process.ParseAddress(addressTextBox.Text.Trim());
				var name = nameTextBox.Text.Trim();

				return !address.IsNull() && !string.IsNullOrEmpty(name);
			}
			catch
			{
				return false;
			}
		}
	}
}

```

`ReClass.NET/Forms/NamedAddressesForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Forms/PluginForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class PluginForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tabControl = new System.Windows.Forms.TabControl();
			this.pluginsTabPage = new System.Windows.Forms.TabPage();
			this.descriptionGroupBox = new System.Windows.Forms.GroupBox();
			this.descriptionLabel = new System.Windows.Forms.Label();
			this.pluginsDataGridView = new System.Windows.Forms.DataGridView();
			this.nativesTabPage = new System.Windows.Forms.TabPage();
			this.label2 = new System.Windows.Forms.Label();
			this.functionsProvidersComboBox = new System.Windows.Forms.ComboBox();
			this.label1 = new System.Windows.Forms.Label();
			this.getMoreLinkLabel = new System.Windows.Forms.LinkLabel();
			this.closeButton = new System.Windows.Forms.Button();
			this.bannerBox = new ReClassNET.Controls.BannerBox();
			this.iconColumn = new System.Windows.Forms.DataGridViewImageColumn();
			this.nameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.versionColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.authorColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.tabControl.SuspendLayout();
			this.pluginsTabPage.SuspendLayout();
			this.descriptionGroupBox.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.pluginsDataGridView)).BeginInit();
			this.nativesTabPage.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// tabControl
			// 
			this.tabControl.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.tabControl.Controls.Add(this.pluginsTabPage);
			this.tabControl.Controls.Add(this.nativesTabPage);
			this.tabControl.Location = new System.Drawing.Point(12, 60);
			this.tabControl.Name = "tabControl";
			this.tabControl.SelectedIndex = 0;
			this.tabControl.Size = new System.Drawing.Size(716, 328);
			this.tabControl.TabIndex = 0;
			// 
			// pluginsTabPage
			// 
			this.pluginsTabPage.Controls.Add(this.descriptionGroupBox);
			this.pluginsTabPage.Controls.Add(this.pluginsDataGridView);
			this.pluginsTabPage.Location = new System.Drawing.Point(4, 22);
			this.pluginsTabPage.Name = "pluginsTabPage";
			this.pluginsTabPage.Padding = new System.Windows.Forms.Padding(3);
			this.pluginsTabPage.Size = new System.Drawing.Size(708, 302);
			this.pluginsTabPage.TabIndex = 0;
			this.pluginsTabPage.Text = "Plugins";
			this.pluginsTabPage.UseVisualStyleBackColor = true;
			// 
			// descriptionGroupBox
			// 
			this.descriptionGroupBox.Controls.Add(this.descriptionLabel);
			this.descriptionGroupBox.Location = new System.Drawing.Point(6, 206);
			this.descriptionGroupBox.Name = "descriptionGroupBox";
			this.descriptionGroupBox.Size = new System.Drawing.Size(696, 90);
			this.descriptionGroupBox.TabIndex = 1;
			this.descriptionGroupBox.TabStop = false;
			this.descriptionGroupBox.Text = "<>";
			// 
			// descriptionLabel
			// 
			this.descriptionLabel.Location = new System.Drawing.Point(6, 16);
			this.descriptionLabel.Name = "descriptionLabel";
			this.descriptionLabel.Size = new System.Drawing.Size(684, 65);
			this.descriptionLabel.TabIndex = 0;
			this.descriptionLabel.Text = "<>";
			// 
			// pluginsDataGridView
			// 
			this.pluginsDataGridView.AllowUserToAddRows = false;
			this.pluginsDataGridView.AllowUserToDeleteRows = false;
			this.pluginsDataGridView.AllowUserToResizeRows = false;
			this.pluginsDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.pluginsDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.pluginsDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.iconColumn,
            this.nameColumn,
            this.versionColumn,
            this.authorColumn});
			this.pluginsDataGridView.Dock = System.Windows.Forms.DockStyle.Top;
			this.pluginsDataGridView.Location = new System.Drawing.Point(3, 3);
			this.pluginsDataGridView.MultiSelect = false;
			this.pluginsDataGridView.Name = "pluginsDataGridView";
			this.pluginsDataGridView.ReadOnly = true;
			this.pluginsDataGridView.RowHeadersVisible = false;
			this.pluginsDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.pluginsDataGridView.Size = new System.Drawing.Size(702, 197);
			this.pluginsDataGridView.TabIndex = 0;
			this.pluginsDataGridView.SelectionChanged += new System.EventHandler(this.pluginsDataGridView_SelectionChanged);
			// 
			// nativesTabPage
			// 
			this.nativesTabPage.Controls.Add(this.label2);
			this.nativesTabPage.Controls.Add(this.functionsProvidersComboBox);
			this.nativesTabPage.Controls.Add(this.label1);
			this.nativesTabPage.Location = new System.Drawing.Point(4, 22);
			this.nativesTabPage.Name = "nativesTabPage";
			this.nativesTabPage.Padding = new System.Windows.Forms.Padding(3);
			this.nativesTabPage.Size = new System.Drawing.Size(708, 302);
			this.nativesTabPage.TabIndex = 1;
			this.nativesTabPage.Text = "Native Helper";
			this.nativesTabPage.UseVisualStyleBackColor = true;
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(6, 66);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(98, 13);
			this.label2.TabIndex = 21;
			this.label2.Text = "Functions Provider:";
			// 
			// functionsProvidersComboBox
			// 
			this.functionsProvidersComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.functionsProvidersComboBox.FormattingEnabled = true;
			this.functionsProvidersComboBox.Location = new System.Drawing.Point(110, 63);
			this.functionsProvidersComboBox.Name = "functionsProvidersComboBox";
			this.functionsProvidersComboBox.Size = new System.Drawing.Size(305, 21);
			this.functionsProvidersComboBox.TabIndex = 20;
			this.functionsProvidersComboBox.SelectionChangeCommitted += new System.EventHandler(this.functionsProvidersComboBox_SelectionChangeCommitted);
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(6, 6);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(409, 39);
			this.label1.TabIndex = 0;
			this.label1.Text = "Plugins can provide different methods how ReClass.NET accesses a remote process.\r" +
    "\n\r\nWarning: You should detach from the current process before changing a functio" +
    "n.";
			// 
			// getMoreLinkLabel
			// 
			this.getMoreLinkLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.getMoreLinkLabel.AutoSize = true;
			this.getMoreLinkLabel.Location = new System.Drawing.Point(9, 396);
			this.getMoreLinkLabel.Name = "getMoreLinkLabel";
			this.getMoreLinkLabel.Size = new System.Drawing.Size(95, 13);
			this.getMoreLinkLabel.TabIndex = 1;
			this.getMoreLinkLabel.TabStop = true;
			this.getMoreLinkLabel.Text = "Get more plugins...";
			this.getMoreLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.getMoreLinkLabel_LinkClicked);
			// 
			// closeButton
			// 
			this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.closeButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.closeButton.Location = new System.Drawing.Point(653, 391);
			this.closeButton.Name = "closeButton";
			this.closeButton.Size = new System.Drawing.Size(75, 23);
			this.closeButton.TabIndex = 2;
			this.closeButton.Text = "Close";
			this.closeButton.UseVisualStyleBackColor = true;
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Plugin;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(740, 48);
			this.bannerBox.TabIndex = 3;
			this.bannerBox.Text = "Here you can configure all loaded ReClass.NET plugins.";
			this.bannerBox.Title = "Plugins";
			// 
			// iconColumn
			// 
			this.iconColumn.DataPropertyName = "Icon";
			this.iconColumn.HeaderText = "";
			this.iconColumn.ImageLayout = System.Windows.Forms.DataGridViewImageCellLayout.Zoom;
			this.iconColumn.MinimumWidth = 18;
			this.iconColumn.Name = "iconColumn";
			this.iconColumn.ReadOnly = true;
			this.iconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
			this.iconColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.Automatic;
			this.iconColumn.Width = 18;
			// 
			// nameColumn
			// 
			this.nameColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.nameColumn.DataPropertyName = "Name";
			this.nameColumn.HeaderText = "Name";
			this.nameColumn.Name = "nameColumn";
			this.nameColumn.ReadOnly = true;
			// 
			// versionColumn
			// 
			this.versionColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.versionColumn.DataPropertyName = "Version";
			this.versionColumn.HeaderText = "Version";
			this.versionColumn.Name = "versionColumn";
			this.versionColumn.ReadOnly = true;
			this.versionColumn.Width = 67;
			// 
			// authorColumn
			// 
			this.authorColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.authorColumn.DataPropertyName = "Author";
			this.authorColumn.HeaderText = "Author";
			this.authorColumn.Name = "authorColumn";
			this.authorColumn.ReadOnly = true;
			this.authorColumn.Width = 63;
			// 
			// PluginForm
			// 
			this.AcceptButton = this.closeButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(740, 423);
			this.Controls.Add(this.bannerBox);
			this.Controls.Add(this.closeButton);
			this.Controls.Add(this.getMoreLinkLabel);
			this.Controls.Add(this.tabControl);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "PluginForm";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Plugins";
			this.tabControl.ResumeLayout(false);
			this.pluginsTabPage.ResumeLayout(false);
			this.descriptionGroupBox.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.pluginsDataGridView)).EndInit();
			this.nativesTabPage.ResumeLayout(false);
			this.nativesTabPage.PerformLayout();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.TabControl tabControl;
		private System.Windows.Forms.TabPage pluginsTabPage;
		private System.Windows.Forms.GroupBox descriptionGroupBox;
		private System.Windows.Forms.DataGridView pluginsDataGridView;
		private System.Windows.Forms.TabPage nativesTabPage;
		private System.Windows.Forms.LinkLabel getMoreLinkLabel;
		private System.Windows.Forms.Button closeButton;
		private System.Windows.Forms.Label descriptionLabel;
		private System.Windows.Forms.Label label1;
		private BannerBox bannerBox;
		private System.Windows.Forms.ComboBox functionsProvidersComboBox;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.DataGridViewImageColumn iconColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn nameColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn versionColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn authorColumn;
	}
}
```

`ReClass.NET/Forms/PluginForm.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Plugins;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class PluginForm : IconForm
	{
		private class PluginInfoRow
		{
			private readonly PluginInfo plugin;

			public Image Icon => plugin.Interface?.Icon ?? Properties.Resources.B16x16_Plugin;
			public string Name => plugin.Name;
			public string Version => plugin.FileVersion;
			public string Author => plugin.Author;
			public string Description => plugin.Description;

			public PluginInfoRow(PluginInfo plugin)
			{
				Contract.Requires(plugin != null);
				Contract.Ensures(this.plugin != null);

				this.plugin = plugin;
			}
		}

		internal PluginForm(PluginManager pluginManager)
		{
			Contract.Requires(pluginManager != null);

			InitializeComponent();

			// Plugins Tab

			pluginsDataGridView.AutoGenerateColumns = false;
			pluginsDataGridView.DataSource = pluginManager.Plugins.Select(p => new PluginInfoRow(p)).ToList();

			UpdatePluginDescription();

			// Native Methods Tab

			var providers = Program.CoreFunctions.FunctionProviders.ToArray();
			functionsProvidersComboBox.Items.AddRange(providers);
			functionsProvidersComboBox.SelectedIndex = Array.IndexOf(providers, Program.CoreFunctions.CurrentFunctionsProvider);
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void pluginsDataGridView_SelectionChanged(object sender, EventArgs e)
		{
			UpdatePluginDescription();
		}

		private void functionsProvidersComboBox_SelectionChangeCommitted(object sender, EventArgs e)
		{
			if (!(functionsProvidersComboBox.SelectedItem is string provider))
			{
				return;
			}

			Program.CoreFunctions.SetActiveFunctionsProvider(provider);
		}

		private void getMoreLinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			Process.Start(Constants.PluginUrl);
		}

		#endregion

		private void UpdatePluginDescription()
		{
			var row = pluginsDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault();
			if (row == null)
			{
				descriptionGroupBox.Text = string.Empty;
				descriptionLabel.Text = string.Empty;

				return;
			}

			if (row.DataBoundItem is PluginInfoRow plugin)
			{
				descriptionGroupBox.Text = plugin.Name;
				descriptionLabel.Text = plugin.Description;
			}
		}
	}
}

```

`ReClass.NET/Forms/PluginForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="iconColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="nameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="versionColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="authorColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/ProcessBrowserForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class ProcessBrowserForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.processDataGridView = new System.Windows.Forms.DataGridView();
			this.iconColumn = new System.Windows.Forms.DataGridViewImageColumn();
			this.processNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.pidColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.pathColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.filterCheckBox = new System.Windows.Forms.CheckBox();
			this.refreshButton = new System.Windows.Forms.Button();
			this.attachToProcessButton = new System.Windows.Forms.Button();
			this.loadSymbolsCheckBox = new System.Windows.Forms.CheckBox();
			this.filterGroupBox = new System.Windows.Forms.GroupBox();
			this.previousProcessLinkLabel = new System.Windows.Forms.LinkLabel();
			this.label2 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.filterTextBox = new System.Windows.Forms.TextBox();
			this.bannerBox = new BannerBox();
			((System.ComponentModel.ISupportInitialize)(this.processDataGridView)).BeginInit();
			this.filterGroupBox.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.SuspendLayout();
			// 
			// processDataGridView
			// 
			this.processDataGridView.AllowUserToAddRows = false;
			this.processDataGridView.AllowUserToDeleteRows = false;
			this.processDataGridView.AllowUserToResizeColumns = false;
			this.processDataGridView.AllowUserToResizeRows = false;
			this.processDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.processDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.processDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.processDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.iconColumn,
            this.processNameColumn,
            this.pidColumn,
            this.pathColumn});
			this.processDataGridView.Location = new System.Drawing.Point(12, 199);
			this.processDataGridView.MultiSelect = false;
			this.processDataGridView.Name = "processDataGridView";
			this.processDataGridView.ReadOnly = true;
			this.processDataGridView.RowHeadersVisible = false;
			this.processDataGridView.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.processDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.processDataGridView.Size = new System.Drawing.Size(549, 291);
			this.processDataGridView.TabIndex = 0;
			this.processDataGridView.CellMouseDoubleClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.processDataGridView_CellMouseDoubleClick);
			// 
			// iconColumn
			// 
			this.iconColumn.DataPropertyName = "icon";
			this.iconColumn.HeaderText = "";
			this.iconColumn.MinimumWidth = 18;
			this.iconColumn.Name = "iconColumn";
			this.iconColumn.ReadOnly = true;
			this.iconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.True;
			this.iconColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.Automatic;
			this.iconColumn.Width = 18;
			// 
			// processNameColumn
			// 
			this.processNameColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.processNameColumn.DataPropertyName = "name";
			this.processNameColumn.HeaderText = "Process";
			this.processNameColumn.Name = "processNameColumn";
			this.processNameColumn.ReadOnly = true;
			this.processNameColumn.Width = 70;
			// 
			// pidColumn
			// 
			this.pidColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.pidColumn.DataPropertyName = "id";
			this.pidColumn.HeaderText = "PID";
			this.pidColumn.Name = "pidColumn";
			this.pidColumn.ReadOnly = true;
			this.pidColumn.Width = 50;
			// 
			// pathColumn
			// 
			this.pathColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.pathColumn.DataPropertyName = "path";
			this.pathColumn.HeaderText = "Path";
			this.pathColumn.Name = "pathColumn";
			this.pathColumn.ReadOnly = true;
			// 
			// filterCheckBox
			// 
			this.filterCheckBox.AutoSize = true;
			this.filterCheckBox.Checked = true;
			this.filterCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.filterCheckBox.Location = new System.Drawing.Point(9, 72);
			this.filterCheckBox.Name = "filterCheckBox";
			this.filterCheckBox.Size = new System.Drawing.Size(158, 17);
			this.filterCheckBox.TabIndex = 1;
			this.filterCheckBox.Text = "Exclude common processes";
			this.filterCheckBox.UseVisualStyleBackColor = true;
			this.filterCheckBox.CheckedChanged += new System.EventHandler(this.filterCheckBox_CheckedChanged);
			// 
			// refreshButton
			// 
			this.refreshButton.Image = global::ReClassNET.Properties.Resources.B16x16_Arrow_Refresh;
			this.refreshButton.Location = new System.Drawing.Point(9, 99);
			this.refreshButton.Name = "refreshButton";
			this.refreshButton.Size = new System.Drawing.Size(158, 23);
			this.refreshButton.TabIndex = 2;
			this.refreshButton.Text = "Refresh";
			this.refreshButton.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.refreshButton.TextImageRelation = System.Windows.Forms.TextImageRelation.ImageBeforeText;
			this.refreshButton.UseVisualStyleBackColor = true;
			this.refreshButton.Click += new System.EventHandler(this.refreshButton_Click);
			// 
			// attachToProcessButton
			// 
			this.attachToProcessButton.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.attachToProcessButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.attachToProcessButton.Image = global::ReClassNET.Properties.Resources.B16x16_Accept;
			this.attachToProcessButton.Location = new System.Drawing.Point(12, 519);
			this.attachToProcessButton.Name = "attachToProcessButton";
			this.attachToProcessButton.Size = new System.Drawing.Size(549, 23);
			this.attachToProcessButton.TabIndex = 3;
			this.attachToProcessButton.Text = "Attach to Process";
			this.attachToProcessButton.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.attachToProcessButton.TextImageRelation = System.Windows.Forms.TextImageRelation.ImageBeforeText;
			this.attachToProcessButton.UseVisualStyleBackColor = true;
			// 
			// loadSymbolsCheckBox
			// 
			this.loadSymbolsCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.loadSymbolsCheckBox.AutoSize = true;
			this.loadSymbolsCheckBox.Location = new System.Drawing.Point(12, 496);
			this.loadSymbolsCheckBox.Name = "loadSymbolsCheckBox";
			this.loadSymbolsCheckBox.Size = new System.Drawing.Size(92, 17);
			this.loadSymbolsCheckBox.TabIndex = 4;
			this.loadSymbolsCheckBox.Text = "Load Symbols";
			this.loadSymbolsCheckBox.UseVisualStyleBackColor = true;
			// 
			// filterGroupBox
			// 
			this.filterGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.filterGroupBox.Controls.Add(this.previousProcessLinkLabel);
			this.filterGroupBox.Controls.Add(this.label2);
			this.filterGroupBox.Controls.Add(this.label1);
			this.filterGroupBox.Controls.Add(this.filterCheckBox);
			this.filterGroupBox.Controls.Add(this.refreshButton);
			this.filterGroupBox.Controls.Add(this.filterTextBox);
			this.filterGroupBox.Location = new System.Drawing.Point(12, 60);
			this.filterGroupBox.Name = "filterGroupBox";
			this.filterGroupBox.Size = new System.Drawing.Size(549, 133);
			this.filterGroupBox.TabIndex = 5;
			this.filterGroupBox.TabStop = false;
			this.filterGroupBox.Text = "Filter";
			// 
			// previousProcessLinkLabel
			// 
			this.previousProcessLinkLabel.AutoSize = true;
			this.previousProcessLinkLabel.Location = new System.Drawing.Point(103, 47);
			this.previousProcessLinkLabel.Name = "previousProcessLinkLabel";
			this.previousProcessLinkLabel.Size = new System.Drawing.Size(19, 13);
			this.previousProcessLinkLabel.TabIndex = 3;
			this.previousProcessLinkLabel.TabStop = true;
			this.previousProcessLinkLabel.Text = "<>";
			this.previousProcessLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.previousProcessLinkLabel_LinkClicked);
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(6, 47);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(92, 13);
			this.label2.TabIndex = 2;
			this.label2.Text = "Previous Process:";
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(6, 22);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(79, 13);
			this.label1.TabIndex = 1;
			this.label1.Text = "Process Name:";
			// 
			// filterTextBox
			// 
			this.filterTextBox.Location = new System.Drawing.Point(103, 19);
			this.filterTextBox.Name = "filterTextBox";
			this.filterTextBox.Size = new System.Drawing.Size(270, 20);
			this.filterTextBox.TabIndex = 0;
			this.filterTextBox.TextChanged += new System.EventHandler(this.filterTextBox_TextChanged);
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Magnifier;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(573, 48);
			this.bannerBox.TabIndex = 6;
			this.bannerBox.Text = "Select the process to which ReClass.NET is to be attached.";
			this.bannerBox.Title = "Attach to Process";
			// 
			// ProcessBrowserForm
			// 
			this.AcceptButton = this.attachToProcessButton;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(573, 554);
			this.Controls.Add(this.bannerBox);
			this.Controls.Add(this.filterGroupBox);
			this.Controls.Add(this.loadSymbolsCheckBox);
			this.Controls.Add(this.attachToProcessButton);
			this.Controls.Add(this.processDataGridView);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "ProcessBrowserForm";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Attach to Process";
			((System.ComponentModel.ISupportInitialize)(this.processDataGridView)).EndInit();
			this.filterGroupBox.ResumeLayout(false);
			this.filterGroupBox.PerformLayout();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.DataGridView processDataGridView;
		private System.Windows.Forms.CheckBox filterCheckBox;
		private System.Windows.Forms.Button refreshButton;
		private System.Windows.Forms.Button attachToProcessButton;
		private System.Windows.Forms.CheckBox loadSymbolsCheckBox;
		private System.Windows.Forms.DataGridViewImageColumn iconColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn processNameColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn pidColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn pathColumn;
		private System.Windows.Forms.GroupBox filterGroupBox;
		private System.Windows.Forms.LinkLabel previousProcessLinkLabel;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox filterTextBox;
		private BannerBox bannerBox;
	}
}
```

`ReClass.NET/Forms/ProcessBrowserForm.cs`:

```cs
using System;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Memory;
using ReClassNET.Native;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class ProcessBrowserForm : IconForm
	{
		private const string NoPreviousProcess = "No previous process";

		private static readonly string[] commonProcesses = 
		{
			"[system process]", "system", "svchost.exe", "services.exe", "wininit.exe",
			"smss.exe", "csrss.exe", "lsass.exe", "winlogon.exe", "wininit.exe", "dwm.exe"
		};

		/// <summary>Gets the selected process.</summary>
		public ProcessInfo SelectedProcess => (processDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault()?.DataBoundItem as DataRowView)
			?.Row
			?.Field<ProcessInfo>("info");

		/// <summary>Gets if symbols should get loaded.</summary>
		public bool LoadSymbols => loadSymbolsCheckBox.Checked;

		public ProcessBrowserForm(string previousProcess)
		{
			InitializeComponent();

			processDataGridView.AutoGenerateColumns = false;

			// TODO: Workaround, Mono can't display a DataGridViewImageColumn.
			if (NativeMethods.IsUnix())
			{
				iconColumn.Visible = false;
			}

			previousProcessLinkLabel.Text = string.IsNullOrEmpty(previousProcess) ? NoPreviousProcess : previousProcess;

			RefreshProcessList();

			foreach (var row in processDataGridView.Rows.Cast<DataGridViewRow>())
			{
				if (row.Cells[1].Value as string == previousProcess)
				{
					processDataGridView.CurrentCell = row.Cells[1];
					break;
				}
			}
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void filterCheckBox_CheckedChanged(object sender, EventArgs e)
		{
			RefreshProcessList();
		}

		private void filterTextBox_TextChanged(object sender, EventArgs e)
		{
			ApplyFilter();
		}

		private void refreshButton_Click(object sender, EventArgs e)
		{
			RefreshProcessList();
		}

		private void previousProcessLinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			filterTextBox.Text = previousProcessLinkLabel.Text == NoPreviousProcess ? string.Empty : previousProcessLinkLabel.Text;
		}

		private void processDataGridView_CellMouseDoubleClick(object sender, DataGridViewCellMouseEventArgs e)
		{
			AcceptButton.PerformClick();
		}

		#endregion

		/// <summary>Queries all processes and displays them.</summary>
		private void RefreshProcessList()
		{
			var dt = new DataTable();
			dt.Columns.Add("icon", typeof(Image));
			dt.Columns.Add("name", typeof(string));
			dt.Columns.Add("id", typeof(IntPtr));
			dt.Columns.Add("path", typeof(string));
			dt.Columns.Add("info", typeof(ProcessInfo));

			var shouldFilter = filterCheckBox.Checked;

			foreach (var p in Program.CoreFunctions.EnumerateProcesses().Where(p => !shouldFilter || !commonProcesses.Contains(p.Name.ToLower())))
			{
				var row = dt.NewRow();
				row["icon"] = p.Icon;
				row["name"] = p.Name;
				row["id"] = p.Id;
				row["path"] = p.Path;
				row["info"] = p;
				dt.Rows.Add(row);
			}

			dt.DefaultView.Sort = "name ASC";

			processDataGridView.DataSource = dt;

			ApplyFilter();
		}

		private void ApplyFilter()
		{
			var filter = filterTextBox.Text;
			if (!string.IsNullOrEmpty(filter))
			{
				filter = $"name like '%{filter}%' or path like '%{filter}%' or CONVERT(id, System.String) like '%{filter}%'";
			}
			((DataTable)processDataGridView.DataSource).DefaultView.RowFilter = filter;
		}
	}
}

```

`ReClass.NET/Forms/ProcessBrowserForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="iconColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="processNameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="pidColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="pathColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/ProcessInfoForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class ProcessInfoForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.contextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.setCurrentClassAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.createClassAtAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
			this.dumpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.sectionsDataGridView = new System.Windows.Forms.DataGridView();
			this.addressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.sizeColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.nameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.protectionColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.typeColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.moduleColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.bannerBox1 = new ReClassNET.Controls.BannerBox();
			this.tabControl = new System.Windows.Forms.TabControl();
			this.modulesTabPage = new System.Windows.Forms.TabPage();
			this.modulesDataGridView = new System.Windows.Forms.DataGridView();
			this.moduleIconDataGridViewImageColumn = new System.Windows.Forms.DataGridViewImageColumn();
			this.moduleNameDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.moduleAddressDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.moduleSizeDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.modulePathDataGridViewTextBoxColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.sectionsTabPage = new System.Windows.Forms.TabPage();
			this.contextMenuStrip.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.sectionsDataGridView)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox1)).BeginInit();
			this.tabControl.SuspendLayout();
			this.modulesTabPage.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.modulesDataGridView)).BeginInit();
			this.sectionsTabPage.SuspendLayout();
			this.SuspendLayout();
			// 
			// contextMenuStrip
			// 
			this.contextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.setCurrentClassAddressToolStripMenuItem,
            this.createClassAtAddressToolStripMenuItem,
            this.toolStripSeparator2,
            this.dumpToolStripMenuItem});
			this.contextMenuStrip.Name = "contextMenuStrip";
			this.contextMenuStrip.Size = new System.Drawing.Size(203, 98);
			this.contextMenuStrip.Opening += new System.ComponentModel.CancelEventHandler(this.contextMenuStrip_Opening);
			// 
			// setCurrentClassAddressToolStripMenuItem
			// 
			this.setCurrentClassAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Exchange_Button;
			this.setCurrentClassAddressToolStripMenuItem.Name = "setCurrentClassAddressToolStripMenuItem";
			this.setCurrentClassAddressToolStripMenuItem.Size = new System.Drawing.Size(202, 22);
			this.setCurrentClassAddressToolStripMenuItem.Text = "Set current class address";
			this.setCurrentClassAddressToolStripMenuItem.Click += new System.EventHandler(this.setCurrentClassAddressToolStripMenuItem_Click);
			// 
			// createClassAtAddressToolStripMenuItem
			// 
			this.createClassAtAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.createClassAtAddressToolStripMenuItem.Name = "createClassAtAddressToolStripMenuItem";
			this.createClassAtAddressToolStripMenuItem.Size = new System.Drawing.Size(202, 22);
			this.createClassAtAddressToolStripMenuItem.Text = "Create class at address";
			this.createClassAtAddressToolStripMenuItem.Click += new System.EventHandler(this.createClassAtAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator2
			// 
			this.toolStripSeparator2.Name = "toolStripSeparator2";
			this.toolStripSeparator2.Size = new System.Drawing.Size(199, 6);
			// 
			// dumpToolStripMenuItem
			// 
			this.dumpToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Drive_Go;
			this.dumpToolStripMenuItem.Name = "dumpToolStripMenuItem";
			this.dumpToolStripMenuItem.Size = new System.Drawing.Size(202, 22);
			this.dumpToolStripMenuItem.Text = "Dump...";
			this.dumpToolStripMenuItem.Click += new System.EventHandler(this.dumpToolStripMenuItem_Click);
			// 
			// sectionsDataGridView
			// 
			this.sectionsDataGridView.AllowUserToAddRows = false;
			this.sectionsDataGridView.AllowUserToDeleteRows = false;
			this.sectionsDataGridView.AllowUserToResizeRows = false;
			this.sectionsDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.sectionsDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.sectionsDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.addressColumn,
            this.sizeColumn,
            this.nameColumn,
            this.protectionColumn,
            this.typeColumn,
            this.moduleColumn});
			this.sectionsDataGridView.ContextMenuStrip = this.contextMenuStrip;
			this.sectionsDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.sectionsDataGridView.Location = new System.Drawing.Point(3, 3);
			this.sectionsDataGridView.MultiSelect = false;
			this.sectionsDataGridView.Name = "sectionsDataGridView";
			this.sectionsDataGridView.ReadOnly = true;
			this.sectionsDataGridView.RowHeadersVisible = false;
			this.sectionsDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.sectionsDataGridView.Size = new System.Drawing.Size(796, 386);
			this.sectionsDataGridView.TabIndex = 0;
			this.sectionsDataGridView.CellMouseDoubleClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.sectionsDataGridView_CellMouseDoubleClick);
			this.sectionsDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.SelectRow_CellMouseDown);
			// 
			// addressColumn
			// 
			this.addressColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.addressColumn.DataPropertyName = "address";
			this.addressColumn.HeaderText = "Address";
			this.addressColumn.Name = "addressColumn";
			this.addressColumn.ReadOnly = true;
			this.addressColumn.Width = 70;
			// 
			// sizeColumn
			// 
			this.sizeColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.sizeColumn.DataPropertyName = "size";
			this.sizeColumn.HeaderText = "Size";
			this.sizeColumn.Name = "sizeColumn";
			this.sizeColumn.ReadOnly = true;
			this.sizeColumn.Width = 52;
			// 
			// nameColumn
			// 
			this.nameColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.nameColumn.DataPropertyName = "name";
			this.nameColumn.HeaderText = "Name";
			this.nameColumn.Name = "nameColumn";
			this.nameColumn.ReadOnly = true;
			this.nameColumn.Width = 60;
			// 
			// protectionColumn
			// 
			this.protectionColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.protectionColumn.DataPropertyName = "protection";
			this.protectionColumn.HeaderText = "Protection";
			this.protectionColumn.Name = "protectionColumn";
			this.protectionColumn.ReadOnly = true;
			this.protectionColumn.Width = 80;
			// 
			// typeColumn
			// 
			this.typeColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.typeColumn.DataPropertyName = "type";
			this.typeColumn.HeaderText = "Type";
			this.typeColumn.Name = "typeColumn";
			this.typeColumn.ReadOnly = true;
			this.typeColumn.Width = 56;
			// 
			// moduleColumn
			// 
			this.moduleColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.moduleColumn.DataPropertyName = "module";
			this.moduleColumn.HeaderText = "Module";
			this.moduleColumn.Name = "moduleColumn";
			this.moduleColumn.ReadOnly = true;
			// 
			// bannerBox1
			// 
			this.bannerBox1.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox1.Icon = global::ReClassNET.Properties.Resources.B32x32_Magnifier;
			this.bannerBox1.Location = new System.Drawing.Point(0, 0);
			this.bannerBox1.Name = "bannerBox1";
			this.bannerBox1.Size = new System.Drawing.Size(834, 48);
			this.bannerBox1.TabIndex = 2;
			this.bannerBox1.Text = "View informations about the current process.";
			this.bannerBox1.Title = "Process Informations";
			// 
			// tabControl
			// 
			this.tabControl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.tabControl.Controls.Add(this.modulesTabPage);
			this.tabControl.Controls.Add(this.sectionsTabPage);
			this.tabControl.Location = new System.Drawing.Point(12, 60);
			this.tabControl.Name = "tabControl";
			this.tabControl.SelectedIndex = 0;
			this.tabControl.Size = new System.Drawing.Size(810, 418);
			this.tabControl.TabIndex = 3;
			// 
			// modulesTabPage
			// 
			this.modulesTabPage.Controls.Add(this.modulesDataGridView);
			this.modulesTabPage.Location = new System.Drawing.Point(4, 22);
			this.modulesTabPage.Name = "modulesTabPage";
			this.modulesTabPage.Padding = new System.Windows.Forms.Padding(3);
			this.modulesTabPage.Size = new System.Drawing.Size(802, 392);
			this.modulesTabPage.TabIndex = 1;
			this.modulesTabPage.Text = "Modules";
			this.modulesTabPage.UseVisualStyleBackColor = true;
			// 
			// modulesDataGridView
			// 
			this.modulesDataGridView.AllowUserToAddRows = false;
			this.modulesDataGridView.AllowUserToDeleteRows = false;
			this.modulesDataGridView.AllowUserToResizeRows = false;
			this.modulesDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.modulesDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.modulesDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.moduleIconDataGridViewImageColumn,
            this.moduleNameDataGridViewTextBoxColumn,
            this.moduleAddressDataGridViewTextBoxColumn,
            this.moduleSizeDataGridViewTextBoxColumn,
            this.modulePathDataGridViewTextBoxColumn});
			this.modulesDataGridView.ContextMenuStrip = this.contextMenuStrip;
			this.modulesDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
			this.modulesDataGridView.Location = new System.Drawing.Point(3, 3);
			this.modulesDataGridView.MultiSelect = false;
			this.modulesDataGridView.Name = "modulesDataGridView";
			this.modulesDataGridView.ReadOnly = true;
			this.modulesDataGridView.RowHeadersVisible = false;
			this.modulesDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.modulesDataGridView.Size = new System.Drawing.Size(796, 386);
			this.modulesDataGridView.TabIndex = 1;
			this.modulesDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.SelectRow_CellMouseDown);
			// 
			// moduleIconDataGridViewImageColumn
			// 
			this.moduleIconDataGridViewImageColumn.DataPropertyName = "icon";
			this.moduleIconDataGridViewImageColumn.HeaderText = "";
			this.moduleIconDataGridViewImageColumn.MinimumWidth = 18;
			this.moduleIconDataGridViewImageColumn.Name = "moduleIconDataGridViewImageColumn";
			this.moduleIconDataGridViewImageColumn.ReadOnly = true;
			this.moduleIconDataGridViewImageColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
			this.moduleIconDataGridViewImageColumn.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.Automatic;
			this.moduleIconDataGridViewImageColumn.Width = 18;
			// 
			// moduleNameDataGridViewTextBoxColumn
			// 
			this.moduleNameDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.moduleNameDataGridViewTextBoxColumn.DataPropertyName = "name";
			this.moduleNameDataGridViewTextBoxColumn.HeaderText = "Module";
			this.moduleNameDataGridViewTextBoxColumn.Name = "moduleNameDataGridViewTextBoxColumn";
			this.moduleNameDataGridViewTextBoxColumn.ReadOnly = true;
			this.moduleNameDataGridViewTextBoxColumn.Width = 67;
			// 
			// moduleAddressDataGridViewTextBoxColumn
			// 
			this.moduleAddressDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.moduleAddressDataGridViewTextBoxColumn.DataPropertyName = "address";
			this.moduleAddressDataGridViewTextBoxColumn.HeaderText = "Address";
			this.moduleAddressDataGridViewTextBoxColumn.Name = "moduleAddressDataGridViewTextBoxColumn";
			this.moduleAddressDataGridViewTextBoxColumn.ReadOnly = true;
			this.moduleAddressDataGridViewTextBoxColumn.Width = 70;
			// 
			// moduleSizeDataGridViewTextBoxColumn
			// 
			this.moduleSizeDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.DisplayedCells;
			this.moduleSizeDataGridViewTextBoxColumn.DataPropertyName = "size";
			this.moduleSizeDataGridViewTextBoxColumn.HeaderText = "Size";
			this.moduleSizeDataGridViewTextBoxColumn.Name = "moduleSizeDataGridViewTextBoxColumn";
			this.moduleSizeDataGridViewTextBoxColumn.ReadOnly = true;
			this.moduleSizeDataGridViewTextBoxColumn.Width = 52;
			// 
			// modulePathDataGridViewTextBoxColumn
			// 
			this.modulePathDataGridViewTextBoxColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.modulePathDataGridViewTextBoxColumn.DataPropertyName = "path";
			this.modulePathDataGridViewTextBoxColumn.HeaderText = "Path";
			this.modulePathDataGridViewTextBoxColumn.Name = "modulePathDataGridViewTextBoxColumn";
			this.modulePathDataGridViewTextBoxColumn.ReadOnly = true;
			// 
			// sectionsTabPage
			// 
			this.sectionsTabPage.Controls.Add(this.sectionsDataGridView);
			this.sectionsTabPage.Location = new System.Drawing.Point(4, 22);
			this.sectionsTabPage.Name = "sectionsTabPage";
			this.sectionsTabPage.Padding = new System.Windows.Forms.Padding(3);
			this.sectionsTabPage.Size = new System.Drawing.Size(802, 392);
			this.sectionsTabPage.TabIndex = 0;
			this.sectionsTabPage.Text = "Sections";
			this.sectionsTabPage.UseVisualStyleBackColor = true;
			// 
			// ProcessInfoForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(834, 490);
			this.Controls.Add(this.tabControl);
			this.Controls.Add(this.bannerBox1);
			this.MinimumSize = new System.Drawing.Size(586, 320);
			this.Name = "ProcessInfoForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Process Informations";
			this.Load += new System.EventHandler(this.ProcessInfoForm_Load);
			this.contextMenuStrip.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.sectionsDataGridView)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox1)).EndInit();
			this.tabControl.ResumeLayout(false);
			this.modulesTabPage.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.modulesDataGridView)).EndInit();
			this.sectionsTabPage.ResumeLayout(false);
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.DataGridView sectionsDataGridView;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem setCurrentClassAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem createClassAtAddressToolStripMenuItem;
		private BannerBox bannerBox1;
		private System.Windows.Forms.TabControl tabControl;
		private System.Windows.Forms.TabPage modulesTabPage;
		private System.Windows.Forms.DataGridView modulesDataGridView;
		private System.Windows.Forms.TabPage sectionsTabPage;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
		private System.Windows.Forms.ToolStripMenuItem dumpToolStripMenuItem;
		private System.Windows.Forms.DataGridViewImageColumn moduleIconDataGridViewImageColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn moduleNameDataGridViewTextBoxColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn moduleAddressDataGridViewTextBoxColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn moduleSizeDataGridViewTextBoxColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn modulePathDataGridViewTextBoxColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn addressColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn sizeColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn nameColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn protectionColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn typeColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn moduleColumn;
	}
}
```

`ReClass.NET/Forms/ProcessInfoForm.cs`:

```cs
using System;
using System.ComponentModel;
using System.Data;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.Memory;
using ReClassNET.Native;
using ReClassNET.UI;

namespace ReClassNET.Forms
{
	public partial class ProcessInfoForm : IconForm
	{
		private readonly IProcessReader process;

		/// <summary>The context menu of the sections grid view.</summary>
		public ContextMenuStrip GridContextMenu => contextMenuStrip;

		public ProcessInfoForm(IProcessReader process)
		{
			Contract.Requires(process != null);

			this.process = process;

			InitializeComponent();

			tabControl.ImageList = new ImageList();
			tabControl.ImageList.Images.Add(Properties.Resources.B16x16_Category);
			tabControl.ImageList.Images.Add(Properties.Resources.B16x16_Page_White_Stack);
			modulesTabPage.ImageIndex = 0;
			sectionsTabPage.ImageIndex = 1;

			modulesDataGridView.AutoGenerateColumns = false;
			sectionsDataGridView.AutoGenerateColumns = false;

			// TODO: Workaround, Mono can't display a DataGridViewImageColumn.
			if (NativeMethods.IsUnix())
			{
				moduleIconDataGridViewImageColumn.Visible = false;
			}
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private async void ProcessInfoForm_Load(object sender, EventArgs e)
		{
			var sectionsTable = new DataTable();
			sectionsTable.Columns.Add("address", typeof(string));
			sectionsTable.Columns.Add("size", typeof(string));
			sectionsTable.Columns.Add("name", typeof(string));
			sectionsTable.Columns.Add("protection", typeof(string));
			sectionsTable.Columns.Add("type", typeof(string));
			sectionsTable.Columns.Add("module", typeof(string));
			sectionsTable.Columns.Add("section", typeof(Section));

			var modulesTable = new DataTable();
			modulesTable.Columns.Add("icon", typeof(Icon));
			modulesTable.Columns.Add("name", typeof(string));
			modulesTable.Columns.Add("address", typeof(string));
			modulesTable.Columns.Add("size", typeof(string));
			modulesTable.Columns.Add("path", typeof(string));
			modulesTable.Columns.Add("module", typeof(Module));

			await Task.Run(() =>
			{
				if (process.EnumerateRemoteSectionsAndModules(out var sections, out var modules))
				{
					foreach (var section in sections)
					{
						var row = sectionsTable.NewRow();
						row["address"] = section.Start.ToString(Constants.AddressHexFormat);
						row["size"] = section.Size.ToString(Constants.AddressHexFormat);
						row["name"] = section.Name;
						row["protection"] = section.Protection.ToString();
						row["type"] = section.Type.ToString();
						row["module"] = section.ModuleName;
						row["section"] = section;
						sectionsTable.Rows.Add(row);
					}
					foreach (var module in modules)
					{
						var row = modulesTable.NewRow();
						row["icon"] = NativeMethods.GetIconForFile(module.Path);
						row["name"] = module.Name;
						row["address"] = module.Start.ToString(Constants.AddressHexFormat);
						row["size"] = module.Size.ToString(Constants.AddressHexFormat);
						row["path"] = module.Path;
						row["module"] = module;
						modulesTable.Rows.Add(row);
					}
				}
			});

			sectionsDataGridView.DataSource = sectionsTable;
			modulesDataGridView.DataSource = modulesTable;
		}

		private void SelectRow_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
		{
			if (!(sender is DataGridView dgv))
			{
				return;
			}

			if (e.Button == MouseButtons.Right)
			{
				int row = e.RowIndex;
				if (e.RowIndex != -1)
				{
					dgv.Rows[row].Selected = true;
				}
			}
		}

		private void contextMenuStrip_Opening(object sender, CancelEventArgs e)
		{
			var sourceControl = (sender as ContextMenuStrip)?.SourceControl;

			e.Cancel = sourceControl == null || (sourceControl == modulesDataGridView && GetSelectedModule() == null) || (sourceControl == sectionsDataGridView && GetSelectedSection() == null);
		}

		private void setCurrentClassAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LinkedWindowFeatures.SetCurrentClassAddress(GetSelectedAddress(sender));
		}

		private void createClassAtAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LinkedWindowFeatures.CreateClassAtAddress(GetSelectedAddress(sender), true);
		}

		private void dumpToolStripMenuItem_Click(object sender, EventArgs e)
		{
			Func<SaveFileDialog> createDialogFn;
			Action<IRemoteMemoryReader, Stream> dumpFn;

			if (GetToolStripSourceControl(sender) == modulesDataGridView)
			{
				var module = GetSelectedModule();
				if (module == null)
				{
					return;
				}

				createDialogFn = () => new SaveFileDialog
				{
					FileName = $"{Path.GetFileNameWithoutExtension(module.Name)}_Dumped{Path.GetExtension(module.Name)}",
					InitialDirectory = Path.GetDirectoryName(module.Path)
				};

				dumpFn = (reader, stream) =>
				{
					Dumper.DumpModule(reader, module, stream);

					MessageBox.Show("Module successfully dumped.", Constants.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Information);
				};
			}
			else
			{
				var section = GetSelectedSection();
				if (section == null)
				{
					return;
				}

				createDialogFn = () => new SaveFileDialog
				{
					FileName = $"Section_{section.Start.ToString("X")}_{section.End.ToString("X")}.dat"
				};

				dumpFn = (reader, stream) =>
				{
					Dumper.DumpSection(reader, section, stream);

					MessageBox.Show("Section successfully dumped.", Constants.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Information);
				};
			}

			using var sfd = createDialogFn();
			sfd.Filter = "All|*.*";

			if (sfd.ShowDialog() != DialogResult.OK)
			{
				return;
			}

			try
			{
				using var stream = sfd.OpenFile();

				dumpFn(process, stream);
			}
			catch (Exception ex)
			{
				Program.ShowException(ex);
			}
		}

		private void sectionsDataGridView_CellMouseDoubleClick(object sender, DataGridViewCellMouseEventArgs e)
		{
			setCurrentClassAddressToolStripMenuItem_Click(sender, e);

			Close();
		}

		#endregion

		private IntPtr GetSelectedAddress(object sender)
		{
			if (GetToolStripSourceControl(sender) == modulesDataGridView)
			{
				return GetSelectedModule()?.Start ?? IntPtr.Zero;
			}
			return GetSelectedSection()?.Start ?? IntPtr.Zero;
		}

		private static Control GetToolStripSourceControl(object sender)
		{
			return ((sender as ToolStripMenuItem)?.GetCurrentParent() as ContextMenuStrip)?.SourceControl;
		}

		private Module GetSelectedModule()
		{
			var row = modulesDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault()?.DataBoundItem as DataRowView;
			return row?["module"] as Module;
		}

		private Section GetSelectedSection()
		{
			var row = sectionsDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault()?.DataBoundItem as DataRowView;
			return row?["section"] as Section;
		}
	}
}

```

`ReClass.NET/Forms/ProcessInfoForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="contextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="addressColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="sizeColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="nameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="protectionColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="typeColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleIconDataGridViewImageColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleNameDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleAddressDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleSizeDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="modulePathDataGridViewTextBoxColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/ProcessMemoryViewForm.Designer.cs`:

```cs
namespace ReClassNET
{
	partial class ProcessMemoryViewer
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
			this.contextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.setCurrentClassAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
			this.createClassAtAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.regionsGroupBox = new System.Windows.Forms.GroupBox();
			this.sectionsDataGridView = new System.Windows.Forms.DataGridView();
			this.bannerBox1 = new ReClassNET.UI.BannerBox();
			this.addressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.sizeColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.nameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.protectionColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.typeColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.moduleColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
			this.contextMenuStrip.SuspendLayout();
			this.regionsGroupBox.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.sectionsDataGridView)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox1)).BeginInit();
			this.SuspendLayout();
			// 
			// contextMenuStrip
			// 
			this.contextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.setCurrentClassAddressToolStripMenuItem,
            this.toolStripSeparator1,
            this.createClassAtAddressToolStripMenuItem});
			this.contextMenuStrip.Name = "contextMenuStrip";
			this.contextMenuStrip.Size = new System.Drawing.Size(203, 54);
			// 
			// setCurrentClassAddressToolStripMenuItem
			// 
			this.setCurrentClassAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Exchange_Button;
			this.setCurrentClassAddressToolStripMenuItem.Name = "setCurrentClassAddressToolStripMenuItem";
			this.setCurrentClassAddressToolStripMenuItem.Size = new System.Drawing.Size(202, 22);
			this.setCurrentClassAddressToolStripMenuItem.Text = "Set current class address";
			this.setCurrentClassAddressToolStripMenuItem.Click += new System.EventHandler(this.setCurrentClassAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator1
			// 
			this.toolStripSeparator1.Name = "toolStripSeparator1";
			this.toolStripSeparator1.Size = new System.Drawing.Size(199, 6);
			// 
			// createClassAtAddressToolStripMenuItem
			// 
			this.createClassAtAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.createClassAtAddressToolStripMenuItem.Name = "createClassAtAddressToolStripMenuItem";
			this.createClassAtAddressToolStripMenuItem.Size = new System.Drawing.Size(202, 22);
			this.createClassAtAddressToolStripMenuItem.Text = "Create class at address";
			this.createClassAtAddressToolStripMenuItem.Click += new System.EventHandler(this.createClassAtAddressToolStripMenuItem_Click);
			// 
			// regionsGroupBox
			// 
			this.regionsGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.regionsGroupBox.Controls.Add(this.sectionsDataGridView);
			this.regionsGroupBox.Location = new System.Drawing.Point(12, 60);
			this.regionsGroupBox.Name = "regionsGroupBox";
			this.regionsGroupBox.Size = new System.Drawing.Size(810, 418);
			this.regionsGroupBox.TabIndex = 1;
			this.regionsGroupBox.TabStop = false;
			this.regionsGroupBox.Text = "Memory Regions";
			// 
			// sectionsDataGridView
			// 
			this.sectionsDataGridView.AllowUserToAddRows = false;
			this.sectionsDataGridView.AllowUserToDeleteRows = false;
			this.sectionsDataGridView.AllowUserToResizeRows = false;
			this.sectionsDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.sectionsDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.SingleHorizontal;
			this.sectionsDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
			this.sectionsDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.addressColumn,
            this.sizeColumn,
            this.nameColumn,
            this.protectionColumn,
            this.typeColumn,
            this.moduleColumn});
			this.sectionsDataGridView.Location = new System.Drawing.Point(6, 19);
			this.sectionsDataGridView.MultiSelect = false;
			this.sectionsDataGridView.Name = "sectionsDataGridView";
			this.sectionsDataGridView.ReadOnly = true;
			this.sectionsDataGridView.RowHeadersVisible = false;
			this.sectionsDataGridView.RowTemplate.ContextMenuStrip = this.contextMenuStrip;
			this.sectionsDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
			this.sectionsDataGridView.Size = new System.Drawing.Size(798, 393);
			this.sectionsDataGridView.TabIndex = 0;
			this.sectionsDataGridView.CellMouseDoubleClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.sectionsDataGridView_CellMouseDoubleClick);
			this.sectionsDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.sectionsDataGridView_CellMouseDown);
			// 
			// bannerBox1
			// 
			this.bannerBox1.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox1.Icon = global::ReClassNET.Properties.Resources.B32x32_Magnifier;
			this.bannerBox1.Location = new System.Drawing.Point(0, 0);
			this.bannerBox1.Name = "bannerBox1";
			this.bannerBox1.Size = new System.Drawing.Size(834, 48);
			this.bannerBox1.TabIndex = 2;
			this.bannerBox1.Text = "View all memory regions mapped in the process.";
			this.bannerBox1.Title = "Memory Viewer";
			// 
			// addressColumn
			// 
			this.addressColumn.DataPropertyName = "address";
			dataGridViewCellStyle1.Format = "X";
			this.addressColumn.DefaultCellStyle = dataGridViewCellStyle1;
			this.addressColumn.HeaderText = "Address";
			this.addressColumn.Name = "addressColumn";
			this.addressColumn.ReadOnly = true;
			// 
			// sizeColumn
			// 
			this.sizeColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.sizeColumn.DataPropertyName = "size";
			dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleRight;
			dataGridViewCellStyle2.Format = "X";
			this.sizeColumn.DefaultCellStyle = dataGridViewCellStyle2;
			this.sizeColumn.HeaderText = "Size";
			this.sizeColumn.Name = "sizeColumn";
			this.sizeColumn.ReadOnly = true;
			this.sizeColumn.Width = 52;
			// 
			// nameColumn
			// 
			this.nameColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.nameColumn.DataPropertyName = "name";
			this.nameColumn.HeaderText = "Name";
			this.nameColumn.Name = "nameColumn";
			this.nameColumn.ReadOnly = true;
			this.nameColumn.Width = 60;
			// 
			// protectionColumn
			// 
			this.protectionColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.protectionColumn.DataPropertyName = "protection";
			this.protectionColumn.HeaderText = "Protection";
			this.protectionColumn.Name = "protectionColumn";
			this.protectionColumn.ReadOnly = true;
			this.protectionColumn.Width = 80;
			// 
			// typeColumn
			// 
			this.typeColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
			this.typeColumn.DataPropertyName = "type";
			this.typeColumn.HeaderText = "Type";
			this.typeColumn.Name = "typeColumn";
			this.typeColumn.ReadOnly = true;
			this.typeColumn.Width = 56;
			// 
			// moduleColumn
			// 
			this.moduleColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
			this.moduleColumn.DataPropertyName = "module";
			this.moduleColumn.HeaderText = "Module";
			this.moduleColumn.Name = "moduleColumn";
			this.moduleColumn.ReadOnly = true;
			// 
			// ProcessMemoryViewer
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(834, 490);
			this.Controls.Add(this.bannerBox1);
			this.Controls.Add(this.regionsGroupBox);
			this.MinimumSize = new System.Drawing.Size(586, 320);
			this.Name = "ProcessMemoryViewer";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Memory Viewer";
			this.contextMenuStrip.ResumeLayout(false);
			this.regionsGroupBox.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.sectionsDataGridView)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox1)).EndInit();
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.DataGridView sectionsDataGridView;
		private System.Windows.Forms.GroupBox regionsGroupBox;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem setCurrentClassAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
		private System.Windows.Forms.ToolStripMenuItem createClassAtAddressToolStripMenuItem;
		private UI.BannerBox bannerBox1;
		private System.Windows.Forms.DataGridViewTextBoxColumn addressColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn sizeColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn nameColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn protectionColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn typeColumn;
		private System.Windows.Forms.DataGridViewTextBoxColumn moduleColumn;
	}
}
```

`ReClass.NET/Forms/ProcessMemoryViewForm.cs`:

```cs
using System;
using System.Data;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Forms;
using ReClassNET.Memory;
using ReClassNET.Nodes;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET
{
	public partial class ProcessMemoryViewer : IconForm
	{
		private readonly ClassNodeView classesView;

		public ProcessMemoryViewer(RemoteProcess process, ClassNodeView classesView)
		{
			Contract.Requires(process != null);
			Contract.Requires(classesView != null);

			this.classesView = classesView;

			InitializeComponent();

			sectionsDataGridView.AutoGenerateColumns = false;

			if (process.IsValid)
			{
				DataTable dt = new DataTable();
				dt.Columns.Add("address", typeof(string));
				dt.Columns.Add("address_val", typeof(IntPtr));
				dt.Columns.Add("size", typeof(ulong));
				dt.Columns.Add("name", typeof(string));
				dt.Columns.Add("protection", typeof(string));
				dt.Columns.Add("type", typeof(string));
				dt.Columns.Add("module", typeof(string));

				process.NativeHelper.EnumerateRemoteSectionsAndModules(process.Process.Handle, delegate (IntPtr baseAddress, IntPtr regionSize, string name, NativeMethods.StateEnum state, NativeMethods.AllocationProtectEnum protection, NativeMethods.TypeEnum type, string modulePath)
				{
					var row = dt.NewRow();
					row["address"] = baseAddress.ToString("X");
					row["address_val"] = baseAddress;
					row["size"] = (ulong)regionSize.ToInt64();
					row["name"] = name;
					row["protection"] = protection.ToString();
					row["type"] = type.ToString();
					row["module"] = Path.GetFileName(modulePath);
					dt.Rows.Add(row);
				},
				null);

				sectionsDataGridView.DataSource = dt;
			}
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void sectionsDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
		{
			if (e.Button == MouseButtons.Right)
			{
				int row = e.RowIndex;
				if (e.RowIndex != -1)
				{
					sectionsDataGridView.Rows[row].Selected = true;
				}
			}
		}

		private void setCurrentClassAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var address = GetSelectedRegionAddress();
			if (address != IntPtr.Zero)
			{
				var node = classesView.SelectedClass;
				if (node != null)
				{
					node.Address = address;
				}
			}
		}

		private void createClassAtAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var address = GetSelectedRegionAddress();
			if (address != IntPtr.Zero)
			{
				var node = ClassNode.Create();
				node.Address = address;
				node.AddBytes(64);

				classesView.SelectedClass = node;
			}
		}

		private void sectionsDataGridView_CellMouseDoubleClick(object sender, DataGridViewCellMouseEventArgs e)
		{
			setCurrentClassAddressToolStripMenuItem_Click(sender, e);
		}

		#endregion

		private IntPtr GetSelectedRegionAddress()
		{
			var row = sectionsDataGridView.SelectedRows.Cast<DataGridViewRow>().FirstOrDefault()?.DataBoundItem as DataRowView;
			if (row != null)
			{
				return (IntPtr)row["address_val"];
			}
			return IntPtr.Zero;
		}
	}
}

```

`ReClass.NET/Forms/ProcessMemoryViewForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="contextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="addressColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="sizeColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="nameColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="protectionColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="typeColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="moduleColumn.UserAddedColumn" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/ScannerForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class ScannerForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.bannerBox = new ReClassNET.Controls.BannerBox();
			this.filterGroupBox = new System.Windows.Forms.GroupBox();
			this.valueTypeComboBox = new ReClassNET.Forms.ScannerForm.ScanValueTypeComboBox();
			this.label3 = new System.Windows.Forms.Label();
			this.compareTypeComboBox = new ReClassNET.Forms.ScannerForm.ScanCompareTypeComboBox();
			this.label1 = new System.Windows.Forms.Label();
			this.isHexCheckBox = new System.Windows.Forms.CheckBox();
			this.dualValueBox = new ReClassNET.Controls.DualValueBox();
			this.scanOptionsGroupBox = new System.Windows.Forms.GroupBox();
			this.fastScanAlignmentTextBox = new System.Windows.Forms.TextBox();
			this.fastScanCheckBox = new System.Windows.Forms.CheckBox();
			this.scanCopyOnWriteCheckBox = new System.Windows.Forms.CheckBox();
			this.scanExecutableCheckBox = new System.Windows.Forms.CheckBox();
			this.scanWritableCheckBox = new System.Windows.Forms.CheckBox();
			this.scanMappedCheckBox = new System.Windows.Forms.CheckBox();
			this.scanImageCheckBox = new System.Windows.Forms.CheckBox();
			this.scanPrivateCheckBox = new System.Windows.Forms.CheckBox();
			this.stopAddressTextBox = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.startAddressTextBox = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.flowLayoutPanel = new System.Windows.Forms.FlowLayoutPanel();
			this.floatingOptionsGroupBox = new System.Windows.Forms.GroupBox();
			this.roundTruncateRadioButton = new System.Windows.Forms.RadioButton();
			this.roundLooseRadioButton = new System.Windows.Forms.RadioButton();
			this.roundStrictRadioButton = new System.Windows.Forms.RadioButton();
			this.stringOptionsGroupBox = new System.Windows.Forms.GroupBox();
			this.caseSensitiveCheckBox = new System.Windows.Forms.CheckBox();
			this.encodingUtf32RadioButton = new System.Windows.Forms.RadioButton();
			this.encodingUtf16RadioButton = new System.Windows.Forms.RadioButton();
			this.encodingUtf8RadioButton = new System.Windows.Forms.RadioButton();
			this.firstScanButton = new System.Windows.Forms.Button();
			this.nextScanButton = new System.Windows.Forms.Button();
			this.scanProgressBar = new System.Windows.Forms.ProgressBar();
			this.resultCountLabel = new System.Windows.Forms.Label();
			this.updateValuesTimer = new System.Windows.Forms.Timer(this.components);
			this.resultMemoryRecordList = new ReClassNET.Controls.MemoryRecordList();
			this.resultListContextMenuStrip = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.addSelectedResultsToAddressListToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.removeSelectedRecordsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.changeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.descriptionToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.addressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.valueTypeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.valueToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
			this.setCurrentClassAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.createClassAtAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
			this.findOutWhatAccessesThisAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.findOutWhatWritesToThisAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
			this.copyAddressToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.addressListMemoryRecordList = new ReClassNET.Controls.MemoryRecordList();
			this.toolStripPanel = new System.Windows.Forms.ToolStripPanel();
			this.menuToolStrip = new System.Windows.Forms.ToolStrip();
			this.openAddressFileToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.saveAddressFileToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.saveAddressFileAsToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
			this.clearAddressListToolStripButton = new System.Windows.Forms.ToolStripButton();
			this.infoToolTip = new System.Windows.Forms.ToolTip(this.components);
			this.undoIconButton = new ReClassNET.Controls.IconButton();
			this.showInputCorrelatorIconButton = new ReClassNET.Controls.IconButton();
			this.cancelScanIconButton = new ReClassNET.Controls.IconButton();
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
			this.filterGroupBox.SuspendLayout();
			this.scanOptionsGroupBox.SuspendLayout();
			this.flowLayoutPanel.SuspendLayout();
			this.floatingOptionsGroupBox.SuspendLayout();
			this.stringOptionsGroupBox.SuspendLayout();
			this.resultListContextMenuStrip.SuspendLayout();
			this.toolStripPanel.SuspendLayout();
			this.menuToolStrip.SuspendLayout();
			this.SuspendLayout();
			// 
			// bannerBox
			// 
			this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
			this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Eye;
			this.bannerBox.Location = new System.Drawing.Point(0, 0);
			this.bannerBox.Name = "bannerBox";
			this.bannerBox.Size = new System.Drawing.Size(612, 48);
			this.bannerBox.TabIndex = 7;
			this.bannerBox.Text = "Scan the process memory for specific values.";
			this.bannerBox.Title = "Scanner";
			// 
			// filterGroupBox
			// 
			this.filterGroupBox.Controls.Add(this.valueTypeComboBox);
			this.filterGroupBox.Controls.Add(this.label3);
			this.filterGroupBox.Controls.Add(this.compareTypeComboBox);
			this.filterGroupBox.Controls.Add(this.label1);
			this.filterGroupBox.Controls.Add(this.isHexCheckBox);
			this.filterGroupBox.Controls.Add(this.dualValueBox);
			this.filterGroupBox.Location = new System.Drawing.Point(3, 3);
			this.filterGroupBox.Margin = new System.Windows.Forms.Padding(3, 3, 3, 1);
			this.filterGroupBox.Name = "filterGroupBox";
			this.filterGroupBox.Size = new System.Drawing.Size(308, 103);
			this.filterGroupBox.TabIndex = 8;
			this.filterGroupBox.TabStop = false;
			this.filterGroupBox.Text = "Filter";
			// 
			// valueTypeComboBox
			// 
			this.valueTypeComboBox.Location = new System.Drawing.Point(72, 74);
			this.valueTypeComboBox.Name = "valueTypeComboBox";
			this.valueTypeComboBox.Size = new System.Drawing.Size(224, 21);
			this.valueTypeComboBox.TabIndex = 8;
			this.valueTypeComboBox.SelectionChangeCommitted += new System.EventHandler(this.valueTypeComboBox_SelectionChangeCommitted);
			// 
			// label3
			// 
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(3, 77);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(64, 13);
			this.label3.TabIndex = 7;
			this.label3.Text = "Value Type:";
			// 
			// compareTypeComboBox
			// 
			this.compareTypeComboBox.Location = new System.Drawing.Point(72, 50);
			this.compareTypeComboBox.Name = "compareTypeComboBox";
			this.compareTypeComboBox.Size = new System.Drawing.Size(224, 21);
			this.compareTypeComboBox.TabIndex = 5;
			this.compareTypeComboBox.SelectionChangeCommitted += new System.EventHandler(this.scanTypeComboBox_SelectionChangeCommitted);
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(3, 53);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(62, 13);
			this.label1.TabIndex = 4;
			this.label1.Text = "Scan Type:";
			// 
			// isHexCheckBox
			// 
			this.isHexCheckBox.AutoSize = true;
			this.isHexCheckBox.Location = new System.Drawing.Point(6, 28);
			this.isHexCheckBox.Name = "isHexCheckBox";
			this.isHexCheckBox.RightToLeft = System.Windows.Forms.RightToLeft.Yes;
			this.isHexCheckBox.Size = new System.Drawing.Size(56, 17);
			this.isHexCheckBox.TabIndex = 3;
			this.isHexCheckBox.Text = "Is Hex";
			this.isHexCheckBox.UseVisualStyleBackColor = true;
			// 
			// dualValueBox
			// 
			this.dualValueBox.Location = new System.Drawing.Point(72, 12);
			this.dualValueBox.Name = "dualValueBox";
			this.dualValueBox.ShowSecondInputField = false;
			this.dualValueBox.Size = new System.Drawing.Size(224, 34);
			this.dualValueBox.TabIndex = 2;
			this.dualValueBox.Value1 = "0";
			this.dualValueBox.Value2 = "0";
			// 
			// scanOptionsGroupBox
			// 
			this.scanOptionsGroupBox.Controls.Add(this.fastScanAlignmentTextBox);
			this.scanOptionsGroupBox.Controls.Add(this.fastScanCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanCopyOnWriteCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanExecutableCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanWritableCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanMappedCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanImageCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.scanPrivateCheckBox);
			this.scanOptionsGroupBox.Controls.Add(this.stopAddressTextBox);
			this.scanOptionsGroupBox.Controls.Add(this.label4);
			this.scanOptionsGroupBox.Controls.Add(this.startAddressTextBox);
			this.scanOptionsGroupBox.Controls.Add(this.label2);
			this.scanOptionsGroupBox.Location = new System.Drawing.Point(3, 239);
			this.scanOptionsGroupBox.Margin = new System.Windows.Forms.Padding(3, 0, 3, 3);
			this.scanOptionsGroupBox.Name = "scanOptionsGroupBox";
			this.scanOptionsGroupBox.Size = new System.Drawing.Size(308, 141);
			this.scanOptionsGroupBox.TabIndex = 9;
			this.scanOptionsGroupBox.TabStop = false;
			this.scanOptionsGroupBox.Text = "Scan Options";
			// 
			// fastScanAlignmentTextBox
			// 
			this.fastScanAlignmentTextBox.Location = new System.Drawing.Point(144, 112);
			this.fastScanAlignmentTextBox.Name = "fastScanAlignmentTextBox";
			this.fastScanAlignmentTextBox.Size = new System.Drawing.Size(26, 20);
			this.fastScanAlignmentTextBox.TabIndex = 11;
			// 
			// fastScanCheckBox
			// 
			this.fastScanCheckBox.AutoSize = true;
			this.fastScanCheckBox.Checked = true;
			this.fastScanCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.fastScanCheckBox.Location = new System.Drawing.Point(9, 114);
			this.fastScanCheckBox.Name = "fastScanCheckBox";
			this.fastScanCheckBox.Size = new System.Drawing.Size(129, 17);
			this.fastScanCheckBox.TabIndex = 10;
			this.fastScanCheckBox.Text = "Fast Scan, Alignment:";
			this.fastScanCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanCopyOnWriteCheckBox
			// 
			this.scanCopyOnWriteCheckBox.AutoSize = true;
			this.scanCopyOnWriteCheckBox.Location = new System.Drawing.Point(189, 91);
			this.scanCopyOnWriteCheckBox.Name = "scanCopyOnWriteCheckBox";
			this.scanCopyOnWriteCheckBox.Size = new System.Drawing.Size(95, 17);
			this.scanCopyOnWriteCheckBox.TabIndex = 9;
			this.scanCopyOnWriteCheckBox.Text = "Copy On Write";
			this.scanCopyOnWriteCheckBox.ThreeState = true;
			this.scanCopyOnWriteCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanExecutableCheckBox
			// 
			this.scanExecutableCheckBox.AutoSize = true;
			this.scanExecutableCheckBox.Checked = true;
			this.scanExecutableCheckBox.CheckState = System.Windows.Forms.CheckState.Indeterminate;
			this.scanExecutableCheckBox.Location = new System.Drawing.Point(91, 91);
			this.scanExecutableCheckBox.Name = "scanExecutableCheckBox";
			this.scanExecutableCheckBox.Size = new System.Drawing.Size(79, 17);
			this.scanExecutableCheckBox.TabIndex = 8;
			this.scanExecutableCheckBox.Text = "Executable";
			this.scanExecutableCheckBox.ThreeState = true;
			this.scanExecutableCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanWritableCheckBox
			// 
			this.scanWritableCheckBox.AutoSize = true;
			this.scanWritableCheckBox.Checked = true;
			this.scanWritableCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.scanWritableCheckBox.Location = new System.Drawing.Point(9, 91);
			this.scanWritableCheckBox.Name = "scanWritableCheckBox";
			this.scanWritableCheckBox.Size = new System.Drawing.Size(65, 17);
			this.scanWritableCheckBox.TabIndex = 7;
			this.scanWritableCheckBox.Text = "Writable";
			this.scanWritableCheckBox.ThreeState = true;
			this.scanWritableCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanMappedCheckBox
			// 
			this.scanMappedCheckBox.AutoSize = true;
			this.scanMappedCheckBox.Location = new System.Drawing.Point(189, 68);
			this.scanMappedCheckBox.Name = "scanMappedCheckBox";
			this.scanMappedCheckBox.Size = new System.Drawing.Size(65, 17);
			this.scanMappedCheckBox.TabIndex = 6;
			this.scanMappedCheckBox.Text = "Mapped";
			this.scanMappedCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanImageCheckBox
			// 
			this.scanImageCheckBox.AutoSize = true;
			this.scanImageCheckBox.Checked = true;
			this.scanImageCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.scanImageCheckBox.Location = new System.Drawing.Point(91, 68);
			this.scanImageCheckBox.Name = "scanImageCheckBox";
			this.scanImageCheckBox.Size = new System.Drawing.Size(55, 17);
			this.scanImageCheckBox.TabIndex = 5;
			this.scanImageCheckBox.Text = "Image";
			this.scanImageCheckBox.UseVisualStyleBackColor = true;
			// 
			// scanPrivateCheckBox
			// 
			this.scanPrivateCheckBox.AutoSize = true;
			this.scanPrivateCheckBox.Checked = true;
			this.scanPrivateCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.scanPrivateCheckBox.Location = new System.Drawing.Point(9, 68);
			this.scanPrivateCheckBox.Name = "scanPrivateCheckBox";
			this.scanPrivateCheckBox.Size = new System.Drawing.Size(59, 17);
			this.scanPrivateCheckBox.TabIndex = 4;
			this.scanPrivateCheckBox.Text = "Private";
			this.scanPrivateCheckBox.UseVisualStyleBackColor = true;
			// 
			// stopAddressTextBox
			// 
			this.stopAddressTextBox.Location = new System.Drawing.Point(66, 42);
			this.stopAddressTextBox.Name = "stopAddressTextBox";
			this.stopAddressTextBox.Size = new System.Drawing.Size(218, 20);
			this.stopAddressTextBox.TabIndex = 3;
			// 
			// label4
			// 
			this.label4.AutoSize = true;
			this.label4.Location = new System.Drawing.Point(6, 45);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(32, 13);
			this.label4.TabIndex = 2;
			this.label4.Text = "Stop:";
			// 
			// startAddressTextBox
			// 
			this.startAddressTextBox.Location = new System.Drawing.Point(66, 19);
			this.startAddressTextBox.Name = "startAddressTextBox";
			this.startAddressTextBox.Size = new System.Drawing.Size(218, 20);
			this.startAddressTextBox.TabIndex = 1;
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(6, 22);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(32, 13);
			this.label2.TabIndex = 0;
			this.label2.Text = "Start:";
			// 
			// flowLayoutPanel
			// 
			this.flowLayoutPanel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.flowLayoutPanel.Controls.Add(this.filterGroupBox);
			this.flowLayoutPanel.Controls.Add(this.floatingOptionsGroupBox);
			this.flowLayoutPanel.Controls.Add(this.stringOptionsGroupBox);
			this.flowLayoutPanel.Controls.Add(this.scanOptionsGroupBox);
			this.flowLayoutPanel.FlowDirection = System.Windows.Forms.FlowDirection.TopDown;
			this.flowLayoutPanel.Location = new System.Drawing.Point(292, 80);
			this.flowLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.flowLayoutPanel.Name = "flowLayoutPanel";
			this.flowLayoutPanel.Size = new System.Drawing.Size(317, 314);
			this.flowLayoutPanel.TabIndex = 9;
			this.flowLayoutPanel.WrapContents = false;
			// 
			// floatingOptionsGroupBox
			// 
			this.floatingOptionsGroupBox.Controls.Add(this.roundTruncateRadioButton);
			this.floatingOptionsGroupBox.Controls.Add(this.roundLooseRadioButton);
			this.floatingOptionsGroupBox.Controls.Add(this.roundStrictRadioButton);
			this.floatingOptionsGroupBox.Location = new System.Drawing.Point(3, 107);
			this.floatingOptionsGroupBox.Margin = new System.Windows.Forms.Padding(3, 0, 3, 1);
			this.floatingOptionsGroupBox.Name = "floatingOptionsGroupBox";
			this.floatingOptionsGroupBox.Size = new System.Drawing.Size(308, 64);
			this.floatingOptionsGroupBox.TabIndex = 9;
			this.floatingOptionsGroupBox.TabStop = false;
			this.floatingOptionsGroupBox.Visible = false;
			// 
			// roundTruncateRadioButton
			// 
			this.roundTruncateRadioButton.AutoSize = true;
			this.roundTruncateRadioButton.Location = new System.Drawing.Point(72, 42);
			this.roundTruncateRadioButton.Name = "roundTruncateRadioButton";
			this.roundTruncateRadioButton.Size = new System.Drawing.Size(68, 17);
			this.roundTruncateRadioButton.TabIndex = 2;
			this.roundTruncateRadioButton.Text = "Truncate";
			this.infoToolTip.SetToolTip(this.roundTruncateRadioButton, "123.45 == 123.99");
			this.roundTruncateRadioButton.UseVisualStyleBackColor = true;
			// 
			// roundLooseRadioButton
			// 
			this.roundLooseRadioButton.AutoSize = true;
			this.roundLooseRadioButton.Checked = true;
			this.roundLooseRadioButton.Location = new System.Drawing.Point(72, 26);
			this.roundLooseRadioButton.Name = "roundLooseRadioButton";
			this.roundLooseRadioButton.Size = new System.Drawing.Size(103, 17);
			this.roundLooseRadioButton.TabIndex = 1;
			this.roundLooseRadioButton.TabStop = true;
			this.roundLooseRadioButton.Text = "Rounded (loose)";
			this.infoToolTip.SetToolTip(this.roundLooseRadioButton, "123.44 <= x <= 123.46");
			this.roundLooseRadioButton.UseVisualStyleBackColor = true;
			// 
			// roundStrictRadioButton
			// 
			this.roundStrictRadioButton.AutoSize = true;
			this.roundStrictRadioButton.Location = new System.Drawing.Point(72, 10);
			this.roundStrictRadioButton.Name = "roundStrictRadioButton";
			this.roundStrictRadioButton.Size = new System.Drawing.Size(100, 17);
			this.roundStrictRadioButton.TabIndex = 0;
			this.roundStrictRadioButton.Text = "Rounded (strict)";
			this.infoToolTip.SetToolTip(this.roundStrictRadioButton, "123.45 == 123.454319");
			this.roundStrictRadioButton.UseVisualStyleBackColor = true;
			// 
			// stringOptionsGroupBox
			// 
			this.stringOptionsGroupBox.Controls.Add(this.caseSensitiveCheckBox);
			this.stringOptionsGroupBox.Controls.Add(this.encodingUtf32RadioButton);
			this.stringOptionsGroupBox.Controls.Add(this.encodingUtf16RadioButton);
			this.stringOptionsGroupBox.Controls.Add(this.encodingUtf8RadioButton);
			this.stringOptionsGroupBox.Location = new System.Drawing.Point(3, 172);
			this.stringOptionsGroupBox.Margin = new System.Windows.Forms.Padding(3, 0, 3, 3);
			this.stringOptionsGroupBox.Name = "stringOptionsGroupBox";
			this.stringOptionsGroupBox.Size = new System.Drawing.Size(308, 64);
			this.stringOptionsGroupBox.TabIndex = 10;
			this.stringOptionsGroupBox.TabStop = false;
			this.stringOptionsGroupBox.Visible = false;
			// 
			// caseSensitiveCheckBox
			// 
			this.caseSensitiveCheckBox.AutoSize = true;
			this.caseSensitiveCheckBox.Checked = true;
			this.caseSensitiveCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
			this.caseSensitiveCheckBox.Location = new System.Drawing.Point(164, 10);
			this.caseSensitiveCheckBox.Name = "caseSensitiveCheckBox";
			this.caseSensitiveCheckBox.Size = new System.Drawing.Size(94, 17);
			this.caseSensitiveCheckBox.TabIndex = 3;
			this.caseSensitiveCheckBox.Text = "Case sensitive";
			this.infoToolTip.SetToolTip(this.caseSensitiveCheckBox, "ASD == asd");
			this.caseSensitiveCheckBox.UseVisualStyleBackColor = true;
			// 
			// encodingUtf32RadioButton
			// 
			this.encodingUtf32RadioButton.AutoSize = true;
			this.encodingUtf32RadioButton.Location = new System.Drawing.Point(72, 42);
			this.encodingUtf32RadioButton.Name = "encodingUtf32RadioButton";
			this.encodingUtf32RadioButton.Size = new System.Drawing.Size(61, 17);
			this.encodingUtf32RadioButton.TabIndex = 2;
			this.encodingUtf32RadioButton.Text = "UTF-32";
			this.encodingUtf32RadioButton.UseVisualStyleBackColor = true;
			// 
			// encodingUtf16RadioButton
			// 
			this.encodingUtf16RadioButton.AutoSize = true;
			this.encodingUtf16RadioButton.Location = new System.Drawing.Point(72, 26);
			this.encodingUtf16RadioButton.Name = "encodingUtf16RadioButton";
			this.encodingUtf16RadioButton.Size = new System.Drawing.Size(61, 17);
			this.encodingUtf16RadioButton.TabIndex = 1;
			this.encodingUtf16RadioButton.Text = "UTF-16";
			this.encodingUtf16RadioButton.UseVisualStyleBackColor = true;
			// 
			// encodingUtf8RadioButton
			// 
			this.encodingUtf8RadioButton.AutoSize = true;
			this.encodingUtf8RadioButton.Checked = true;
			this.encodingUtf8RadioButton.Location = new System.Drawing.Point(72, 10);
			this.encodingUtf8RadioButton.Name = "encodingUtf8RadioButton";
			this.encodingUtf8RadioButton.Size = new System.Drawing.Size(55, 17);
			this.encodingUtf8RadioButton.TabIndex = 0;
			this.encodingUtf8RadioButton.TabStop = true;
			this.encodingUtf8RadioButton.Text = "UTF-8";
			this.encodingUtf8RadioButton.UseVisualStyleBackColor = true;
			// 
			// firstScanButton
			// 
			this.firstScanButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.firstScanButton.Location = new System.Drawing.Point(292, 54);
			this.firstScanButton.Name = "firstScanButton";
			this.firstScanButton.Size = new System.Drawing.Size(75, 23);
			this.firstScanButton.TabIndex = 11;
			this.firstScanButton.Text = "First Scan";
			this.firstScanButton.UseVisualStyleBackColor = true;
			this.firstScanButton.Click += new System.EventHandler(this.firstScanButton_Click);
			// 
			// nextScanButton
			// 
			this.nextScanButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.nextScanButton.Enabled = false;
			this.nextScanButton.Location = new System.Drawing.Point(373, 54);
			this.nextScanButton.Name = "nextScanButton";
			this.nextScanButton.Size = new System.Drawing.Size(75, 23);
			this.nextScanButton.TabIndex = 12;
			this.nextScanButton.Text = "Next Scan";
			this.nextScanButton.UseVisualStyleBackColor = true;
			this.nextScanButton.Click += new System.EventHandler(this.nextScanButton_Click);
			// 
			// scanProgressBar
			// 
			this.scanProgressBar.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.scanProgressBar.Location = new System.Drawing.Point(454, 54);
			this.scanProgressBar.Name = "scanProgressBar";
			this.scanProgressBar.Size = new System.Drawing.Size(149, 23);
			this.scanProgressBar.TabIndex = 13;
			// 
			// resultCountLabel
			// 
			this.resultCountLabel.AutoSize = true;
			this.resultCountLabel.Location = new System.Drawing.Point(8, 59);
			this.resultCountLabel.Name = "resultCountLabel";
			this.resultCountLabel.Size = new System.Drawing.Size(19, 13);
			this.resultCountLabel.TabIndex = 15;
			this.resultCountLabel.Text = "<>";
			// 
			// updateValuesTimer
			// 
			this.updateValuesTimer.Enabled = true;
			this.updateValuesTimer.Interval = 1000;
			this.updateValuesTimer.Tick += new System.EventHandler(this.updateValuesTimer_Tick);
			// 
			// resultMemoryRecordList
			// 
			this.resultMemoryRecordList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.resultMemoryRecordList.ContextMenuStrip = this.resultListContextMenuStrip;
			this.resultMemoryRecordList.Location = new System.Drawing.Point(11, 80);
			this.resultMemoryRecordList.Name = "resultMemoryRecordList";
			this.resultMemoryRecordList.ShowAddressColumn = true;
			this.resultMemoryRecordList.ShowDescriptionColumn = false;
			this.resultMemoryRecordList.ShowPreviousValueColumn = true;
			this.resultMemoryRecordList.ShowValueColumn = true;
			this.resultMemoryRecordList.ShowValueTypeColumn = false;
			this.resultMemoryRecordList.Size = new System.Drawing.Size(268, 314);
			this.resultMemoryRecordList.TabIndex = 16;
			this.resultMemoryRecordList.RecordDoubleClick += new ReClassNET.Controls.MemorySearchResultControlResultDoubleClickEventHandler(this.memorySearchResultControl_ResultDoubleClick);
			// 
			// resultListContextMenuStrip
			// 
			this.resultListContextMenuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.addSelectedResultsToAddressListToolStripMenuItem,
            this.removeSelectedRecordsToolStripMenuItem,
            this.changeToolStripMenuItem,
            this.toolStripSeparator2,
            this.setCurrentClassAddressToolStripMenuItem,
            this.createClassAtAddressToolStripMenuItem,
            this.toolStripSeparator3,
            this.findOutWhatAccessesThisAddressToolStripMenuItem,
            this.findOutWhatWritesToThisAddressToolStripMenuItem,
            this.toolStripSeparator4,
            this.copyAddressToolStripMenuItem});
			this.resultListContextMenuStrip.Name = "resultListContextMenuStrip";
			this.resultListContextMenuStrip.Size = new System.Drawing.Size(270, 198);
			this.resultListContextMenuStrip.Opening += new System.ComponentModel.CancelEventHandler(this.resultListContextMenuStrip_Opening);
			// 
			// addSelectedResultsToAddressListToolStripMenuItem
			// 
			this.addSelectedResultsToAddressListToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Tree_Expand;
			this.addSelectedResultsToAddressListToolStripMenuItem.Name = "addSelectedResultsToAddressListToolStripMenuItem";
			this.addSelectedResultsToAddressListToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.addSelectedResultsToAddressListToolStripMenuItem.Text = "Add selected results to address list";
			this.addSelectedResultsToAddressListToolStripMenuItem.Click += new System.EventHandler(this.addSelectedResultsToAddressListToolStripMenuItem_Click);
			// 
			// removeSelectedRecordsToolStripMenuItem
			// 
			this.removeSelectedRecordsToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Delete;
			this.removeSelectedRecordsToolStripMenuItem.Name = "removeSelectedRecordsToolStripMenuItem";
			this.removeSelectedRecordsToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.removeSelectedRecordsToolStripMenuItem.Text = "Remove selected records";
			this.removeSelectedRecordsToolStripMenuItem.Click += new System.EventHandler(this.removeSelectedRecordsToolStripMenuItem_Click);
			// 
			// changeToolStripMenuItem
			// 
			this.changeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.descriptionToolStripMenuItem,
            this.addressToolStripMenuItem,
            this.valueTypeToolStripMenuItem,
            this.valueToolStripMenuItem});
			this.changeToolStripMenuItem.Enabled = false;
			this.changeToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Textfield_Rename;
			this.changeToolStripMenuItem.Name = "changeToolStripMenuItem";
			this.changeToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.changeToolStripMenuItem.Text = "Change...";
			// 
			// descriptionToolStripMenuItem
			// 
			this.descriptionToolStripMenuItem.Name = "descriptionToolStripMenuItem";
			this.descriptionToolStripMenuItem.Size = new System.Drawing.Size(134, 22);
			this.descriptionToolStripMenuItem.Text = "Description";
			// 
			// addressToolStripMenuItem
			// 
			this.addressToolStripMenuItem.Name = "addressToolStripMenuItem";
			this.addressToolStripMenuItem.Size = new System.Drawing.Size(134, 22);
			this.addressToolStripMenuItem.Text = "Address";
			// 
			// valueTypeToolStripMenuItem
			// 
			this.valueTypeToolStripMenuItem.Name = "valueTypeToolStripMenuItem";
			this.valueTypeToolStripMenuItem.Size = new System.Drawing.Size(134, 22);
			this.valueTypeToolStripMenuItem.Text = "Value Type";
			// 
			// valueToolStripMenuItem
			// 
			this.valueToolStripMenuItem.Name = "valueToolStripMenuItem";
			this.valueToolStripMenuItem.Size = new System.Drawing.Size(134, 22);
			this.valueToolStripMenuItem.Text = "Value";
			// 
			// toolStripSeparator2
			// 
			this.toolStripSeparator2.Name = "toolStripSeparator2";
			this.toolStripSeparator2.Size = new System.Drawing.Size(266, 6);
			// 
			// setCurrentClassAddressToolStripMenuItem
			// 
			this.setCurrentClassAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Exchange_Button;
			this.setCurrentClassAddressToolStripMenuItem.Name = "setCurrentClassAddressToolStripMenuItem";
			this.setCurrentClassAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.setCurrentClassAddressToolStripMenuItem.Text = "Set current class address";
			this.setCurrentClassAddressToolStripMenuItem.Click += new System.EventHandler(this.setCurrentClassAddressToolStripMenuItem_Click);
			// 
			// createClassAtAddressToolStripMenuItem
			// 
			this.createClassAtAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Class_Add;
			this.createClassAtAddressToolStripMenuItem.Name = "createClassAtAddressToolStripMenuItem";
			this.createClassAtAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.createClassAtAddressToolStripMenuItem.Text = "Create class at address";
			this.createClassAtAddressToolStripMenuItem.Click += new System.EventHandler(this.createClassAtAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator3
			// 
			this.toolStripSeparator3.Name = "toolStripSeparator3";
			this.toolStripSeparator3.Size = new System.Drawing.Size(266, 6);
			// 
			// findOutWhatAccessesThisAddressToolStripMenuItem
			// 
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Find_Access;
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Name = "findOutWhatAccessesThisAddressToolStripMenuItem";
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Text = "Find out what accesses this address...";
			this.findOutWhatAccessesThisAddressToolStripMenuItem.Click += new System.EventHandler(this.findOutWhatAccessesThisAddressToolStripMenuItem_Click);
			// 
			// findOutWhatWritesToThisAddressToolStripMenuItem
			// 
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Find_Write;
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Name = "findOutWhatWritesToThisAddressToolStripMenuItem";
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Text = "Find out what writes to this address...";
			this.findOutWhatWritesToThisAddressToolStripMenuItem.Click += new System.EventHandler(this.findOutWhatWritesToThisAddressToolStripMenuItem_Click);
			// 
			// toolStripSeparator4
			// 
			this.toolStripSeparator4.Name = "toolStripSeparator4";
			this.toolStripSeparator4.Size = new System.Drawing.Size(266, 6);
			// 
			// copyAddressToolStripMenuItem
			// 
			this.copyAddressToolStripMenuItem.Image = global::ReClassNET.Properties.Resources.B16x16_Page_Copy;
			this.copyAddressToolStripMenuItem.Name = "copyAddressToolStripMenuItem";
			this.copyAddressToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
			this.copyAddressToolStripMenuItem.Text = "Copy Address";
			this.copyAddressToolStripMenuItem.Click += new System.EventHandler(this.copyAddressToolStripMenuItem_Click);
			// 
			// addressListMemoryRecordList
			// 
			this.addressListMemoryRecordList.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
			this.addressListMemoryRecordList.ContextMenuStrip = this.resultListContextMenuStrip;
			this.addressListMemoryRecordList.Location = new System.Drawing.Point(11, 425);
			this.addressListMemoryRecordList.Name = "addressListMemoryRecordList";
			this.addressListMemoryRecordList.ShowAddressColumn = true;
			this.addressListMemoryRecordList.ShowDescriptionColumn = true;
			this.addressListMemoryRecordList.ShowPreviousValueColumn = false;
			this.addressListMemoryRecordList.ShowValueColumn = true;
			this.addressListMemoryRecordList.ShowValueTypeColumn = true;
			this.addressListMemoryRecordList.Size = new System.Drawing.Size(592, 169);
			this.addressListMemoryRecordList.TabIndex = 17;
			// 
			// toolStripPanel
			// 
			this.toolStripPanel.Controls.Add(this.menuToolStrip);
			this.toolStripPanel.Location = new System.Drawing.Point(11, 397);
			this.toolStripPanel.Name = "toolStripPanel";
			this.toolStripPanel.Orientation = System.Windows.Forms.Orientation.Horizontal;
			this.toolStripPanel.RenderMode = System.Windows.Forms.ToolStripRenderMode.Professional;
			this.toolStripPanel.RowMargin = new System.Windows.Forms.Padding(0);
			this.toolStripPanel.Size = new System.Drawing.Size(128, 25);
			// 
			// menuToolStrip
			// 
			this.menuToolStrip.Dock = System.Windows.Forms.DockStyle.None;
			this.menuToolStrip.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
			this.menuToolStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.openAddressFileToolStripButton,
            this.saveAddressFileToolStripButton,
            this.saveAddressFileAsToolStripButton,
            this.toolStripSeparator1,
            this.clearAddressListToolStripButton});
			this.menuToolStrip.Location = new System.Drawing.Point(0, 0);
			this.menuToolStrip.Name = "menuToolStrip";
			this.menuToolStrip.Size = new System.Drawing.Size(101, 25);
			this.menuToolStrip.TabIndex = 0;
			// 
			// openAddressFileToolStripButton
			// 
			this.openAddressFileToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.openAddressFileToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Folder;
			this.openAddressFileToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.openAddressFileToolStripButton.Name = "openAddressFileToolStripButton";
			this.openAddressFileToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.openAddressFileToolStripButton.ToolTipText = "Open...";
			this.openAddressFileToolStripButton.Click += new System.EventHandler(this.openAddressFileToolStripButton_Click);
			// 
			// saveAddressFileToolStripButton
			// 
			this.saveAddressFileToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.saveAddressFileToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Save;
			this.saveAddressFileToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.saveAddressFileToolStripButton.Name = "saveAddressFileToolStripButton";
			this.saveAddressFileToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.saveAddressFileToolStripButton.ToolTipText = "Save";
			this.saveAddressFileToolStripButton.Click += new System.EventHandler(this.saveAddressFileToolStripButton_Click);
			// 
			// saveAddressFileAsToolStripButton
			// 
			this.saveAddressFileAsToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.saveAddressFileAsToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Save_As;
			this.saveAddressFileAsToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.saveAddressFileAsToolStripButton.Name = "saveAddressFileAsToolStripButton";
			this.saveAddressFileAsToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.saveAddressFileAsToolStripButton.ToolTipText = "Save As...";
			this.saveAddressFileAsToolStripButton.Click += new System.EventHandler(this.saveAsToolStripButton_Click);
			// 
			// toolStripSeparator1
			// 
			this.toolStripSeparator1.Name = "toolStripSeparator1";
			this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
			// 
			// clearAddressListToolStripButton
			// 
			this.clearAddressListToolStripButton.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
			this.clearAddressListToolStripButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Delete;
			this.clearAddressListToolStripButton.ImageTransparentColor = System.Drawing.Color.Magenta;
			this.clearAddressListToolStripButton.Name = "clearAddressListToolStripButton";
			this.clearAddressListToolStripButton.Size = new System.Drawing.Size(23, 22);
			this.clearAddressListToolStripButton.ToolTipText = "Clear";
			this.clearAddressListToolStripButton.Click += new System.EventHandler(this.clearAddressListToolStripButton_Click);
			// 
			// infoToolTip
			// 
			this.infoToolTip.AutomaticDelay = 100;
			// 
			// undoIconButton
			// 
			this.undoIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.undoIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Undo;
			this.undoIconButton.Location = new System.Drawing.Point(256, 54);
			this.undoIconButton.Name = "undoIconButton";
			this.undoIconButton.Pressed = false;
			this.undoIconButton.Selected = false;
			this.undoIconButton.Size = new System.Drawing.Size(23, 22);
			this.undoIconButton.TabIndex = 18;
			this.undoIconButton.Click += new System.EventHandler(this.undoIconButton_Click);
			// 
			// showInputCorrelatorIconButton
			// 
			this.showInputCorrelatorIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.showInputCorrelatorIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Canvas_Size;
			this.showInputCorrelatorIconButton.Location = new System.Drawing.Point(580, 398);
			this.showInputCorrelatorIconButton.Name = "showInputCorrelatorIconButton";
			this.showInputCorrelatorIconButton.Pressed = false;
			this.showInputCorrelatorIconButton.Selected = false;
			this.showInputCorrelatorIconButton.Size = new System.Drawing.Size(23, 22);
			this.showInputCorrelatorIconButton.TabIndex = 19;
			this.showInputCorrelatorIconButton.Click += new System.EventHandler(this.showInputCorrelatorIconButton_Click);
			// 
			// cancelScanIconButton
			// 
			this.cancelScanIconButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.cancelScanIconButton.Image = global::ReClassNET.Properties.Resources.B16x16_Button_Delete;
			this.cancelScanIconButton.Location = new System.Drawing.Point(517, 54);
			this.cancelScanIconButton.Name = "cancelScanIconButton";
			this.cancelScanIconButton.Pressed = false;
			this.cancelScanIconButton.Selected = false;
			this.cancelScanIconButton.Size = new System.Drawing.Size(23, 22);
			this.cancelScanIconButton.TabIndex = 21;
			this.cancelScanIconButton.Visible = false;
			this.cancelScanIconButton.Click += new System.EventHandler(this.cancelScanIconButton_Click);
			// 
			// ScannerForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(612, 607);
			this.Controls.Add(this.cancelScanIconButton);
			this.Controls.Add(this.showInputCorrelatorIconButton);
			this.Controls.Add(this.undoIconButton);
			this.Controls.Add(this.toolStripPanel);
			this.Controls.Add(this.addressListMemoryRecordList);
			this.Controls.Add(this.resultMemoryRecordList);
			this.Controls.Add(this.resultCountLabel);
			this.Controls.Add(this.scanProgressBar);
			this.Controls.Add(this.nextScanButton);
			this.Controls.Add(this.firstScanButton);
			this.Controls.Add(this.flowLayoutPanel);
			this.Controls.Add(this.bannerBox);
			this.MinimumSize = new System.Drawing.Size(628, 622);
			this.Name = "ScannerForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "ReClass.NET - Scanner";
			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MemorySearchForm_FormClosing);
			((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
			this.filterGroupBox.ResumeLayout(false);
			this.filterGroupBox.PerformLayout();
			this.scanOptionsGroupBox.ResumeLayout(false);
			this.scanOptionsGroupBox.PerformLayout();
			this.flowLayoutPanel.ResumeLayout(false);
			this.floatingOptionsGroupBox.ResumeLayout(false);
			this.floatingOptionsGroupBox.PerformLayout();
			this.stringOptionsGroupBox.ResumeLayout(false);
			this.stringOptionsGroupBox.PerformLayout();
			this.resultListContextMenuStrip.ResumeLayout(false);
			this.toolStripPanel.ResumeLayout(false);
			this.toolStripPanel.PerformLayout();
			this.menuToolStrip.ResumeLayout(false);
			this.menuToolStrip.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private BannerBox bannerBox;
		private System.Windows.Forms.GroupBox filterGroupBox;
		private DualValueBox dualValueBox;
		private System.Windows.Forms.CheckBox isHexCheckBox;
		private ScanCompareTypeComboBox compareTypeComboBox;
		private System.Windows.Forms.Label label1;
		private ScanValueTypeComboBox valueTypeComboBox;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.GroupBox scanOptionsGroupBox;
		private System.Windows.Forms.TextBox fastScanAlignmentTextBox;
		private System.Windows.Forms.CheckBox fastScanCheckBox;
		private System.Windows.Forms.CheckBox scanCopyOnWriteCheckBox;
		private System.Windows.Forms.CheckBox scanExecutableCheckBox;
		private System.Windows.Forms.CheckBox scanWritableCheckBox;
		private System.Windows.Forms.CheckBox scanMappedCheckBox;
		private System.Windows.Forms.CheckBox scanImageCheckBox;
		private System.Windows.Forms.CheckBox scanPrivateCheckBox;
		private System.Windows.Forms.TextBox stopAddressTextBox;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.TextBox startAddressTextBox;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel;
		private System.Windows.Forms.GroupBox floatingOptionsGroupBox;
		private System.Windows.Forms.RadioButton roundTruncateRadioButton;
		private System.Windows.Forms.RadioButton roundLooseRadioButton;
		private System.Windows.Forms.RadioButton roundStrictRadioButton;
		private System.Windows.Forms.GroupBox stringOptionsGroupBox;
		private System.Windows.Forms.CheckBox caseSensitiveCheckBox;
		private System.Windows.Forms.RadioButton encodingUtf32RadioButton;
		private System.Windows.Forms.RadioButton encodingUtf16RadioButton;
		private System.Windows.Forms.RadioButton encodingUtf8RadioButton;
		private System.Windows.Forms.Button firstScanButton;
		private System.Windows.Forms.Button nextScanButton;
		private System.Windows.Forms.ProgressBar scanProgressBar;
		private System.Windows.Forms.Label resultCountLabel;
		private System.Windows.Forms.Timer updateValuesTimer;
		private MemoryRecordList resultMemoryRecordList;
		private MemoryRecordList addressListMemoryRecordList;
		private System.Windows.Forms.ToolStripPanel toolStripPanel;
		private System.Windows.Forms.ToolStrip menuToolStrip;
		private System.Windows.Forms.ToolStripButton openAddressFileToolStripButton;
		private System.Windows.Forms.ToolStripButton saveAddressFileToolStripButton;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
		private System.Windows.Forms.ToolStripButton clearAddressListToolStripButton;
		private System.Windows.Forms.ToolTip infoToolTip;
		private System.Windows.Forms.ToolStripButton saveAddressFileAsToolStripButton;
		private System.Windows.Forms.ContextMenuStrip resultListContextMenuStrip;
		private System.Windows.Forms.ToolStripMenuItem addSelectedResultsToAddressListToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
		private System.Windows.Forms.ToolStripMenuItem setCurrentClassAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem createClassAtAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
		private System.Windows.Forms.ToolStripMenuItem findOutWhatAccessesThisAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem findOutWhatWritesToThisAddressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem removeSelectedRecordsToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem changeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem descriptionToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem addressToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem valueTypeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem valueToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator4;
		private System.Windows.Forms.ToolStripMenuItem copyAddressToolStripMenuItem;
		private IconButton undoIconButton;
		private IconButton showInputCorrelatorIconButton;
		private IconButton cancelScanIconButton;
	}
}
```

`ReClass.NET/Forms/ScannerForm.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.Controls;
using ReClassNET.DataExchange.Scanner;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Forms
{
	public partial class ScannerForm : IconForm
	{
		// The designer can't handle generic controls...
		internal class ScanCompareTypeComboBox : EnumComboBox<ScanCompareType> { }
		internal class ScanValueTypeComboBox : EnumComboBox<ScanValueType> { }

		private const int MaxVisibleResults = 10000;

		private readonly RemoteProcess process;

		private bool isFirstScan;

		private Scanner scanner;
		private CancellationTokenSource cts;

		private string addressFilePath;

		public ScannerForm(RemoteProcess process)
		{
			Contract.Requires(process != null);

			this.process = process;

			InitializeComponent();

			toolStripPanel.Renderer = new CustomToolStripProfessionalRenderer(true, false);
			menuToolStrip.Renderer = new CustomToolStripProfessionalRenderer(false, false);

			SetGuiFromSettings(ScanSettings.Default);

			OnValueTypeChanged();

			Reset();

			firstScanButton.Enabled = flowLayoutPanel.Enabled = process.IsValid;

			process.ProcessAttached += RemoteProcessOnProcessAttached;
			process.ProcessClosing += RemoteProcessOnProcessClosing;
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		#region Event Handler

		private void RemoteProcessOnProcessAttached(RemoteProcess remoteProcess)
		{
			firstScanButton.Enabled = nextScanButton.Enabled = flowLayoutPanel.Enabled = true;

			Reset();

			if (addressListMemoryRecordList.Records.Any())
			{
				if (MessageBox.Show("Keep the current address list?", "Process has changed", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
				{
					addressListMemoryRecordList.Clear();
				}
				else
				{
					foreach (var record in addressListMemoryRecordList.Records)
					{
						record.ResolveAddress(process);
						record.RefreshValue(process);
					}
				}
			}
		}

		private void RemoteProcessOnProcessClosing(RemoteProcess remoteProcess)
		{
			Reset();

			firstScanButton.Enabled = nextScanButton.Enabled = flowLayoutPanel.Enabled = false;
		}

		private void MemorySearchForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			scanner?.Dispose();

			process.ProcessAttached -= RemoteProcessOnProcessAttached;
			process.ProcessClosing -= RemoteProcessOnProcessClosing;
		}

		private void updateValuesTimer_Tick(object sender, EventArgs e)
		{
			resultMemoryRecordList.RefreshValues(process);
			addressListMemoryRecordList.RefreshValues(process);
		}

		private void scanTypeComboBox_SelectionChangeCommitted(object sender, EventArgs e)
		{
			OnCompareTypeChanged();
		}

		private void valueTypeComboBox_SelectionChangeCommitted(object sender, EventArgs e)
		{
			OnValueTypeChanged();
		}

		private async void firstScanButton_Click(object sender, EventArgs e)
		{
			if (isFirstScan)
			{
				try
				{
					var settings = CreateSearchSettings();
					var comparer = CreateComparer(settings);

					await StartFirstScanEx(settings, comparer);
				}
				catch (Exception ex)
				{
					Program.ShowException(ex);
				}

				return;
			}

			Reset();
		}

		private async void nextScanButton_Click(object sender, EventArgs e)
		{
			if (!process.IsValid)
			{
				return;
			}

			if (!isFirstScan)
			{
				firstScanButton.Enabled = false;
				nextScanButton.Enabled = false;
				cancelScanIconButton.Visible = true;

				try
				{
					var comparer = CreateComparer(scanner.Settings);

					var report = new Progress<int>(i =>
					{
						scanProgressBar.Value = i;
						SetResultCount(scanner.TotalResultCount);
					});
					cts = new CancellationTokenSource();

					await scanner.Search(comparer, report, cts.Token);

					ShowScannerResults(scanner);

					undoIconButton.Enabled = scanner.CanUndoLastScan;
				}
				catch (Exception ex)
				{
					Program.ShowException(ex);
				}

				firstScanButton.Enabled = true;
				nextScanButton.Enabled = true;
				cancelScanIconButton.Visible = false;

				scanProgressBar.Value = 0;
			}
		}

		private void cancelScanIconButton_Click(object sender, EventArgs e)
		{
			cts?.Cancel();
		}

		private void memorySearchResultControl_ResultDoubleClick(object sender, MemoryRecord record)
		{
			addressListMemoryRecordList.Records.Add(record);
		}

		private void openAddressFileToolStripButton_Click(object sender, EventArgs e)
		{
			using var ofd = new OpenFileDialog
			{
				CheckFileExists = true,
				Filter = $"All Scanner Types |*{ReClassScanFile.FileExtension};*{CheatEngineFile.FileExtension};*{CrySearchFile.FileExtension}"
				         + $"|{ReClassScanFile.FormatName} (*{ReClassScanFile.FileExtension})|*{ReClassScanFile.FileExtension}"
				         + $"|{CheatEngineFile.FormatName} (*{CheatEngineFile.FileExtension})|*{CheatEngineFile.FileExtension}"
				         + $"|{CrySearchFile.FormatName} (*{CrySearchFile.FileExtension})|*{CrySearchFile.FileExtension}"
			};

			if (ofd.ShowDialog() == DialogResult.OK)
			{
				IScannerImport import = null;
				switch (Path.GetExtension(ofd.FileName)?.ToLower())
				{
					case ReClassScanFile.FileExtension:
						import = new ReClassScanFile();
						break;
					case CheatEngineFile.FileExtension:
						import = new CheatEngineFile();
						break;
					case CrySearchFile.FileExtension:
						import = new CrySearchFile();
						break;
					default:
						Program.Logger.Log(LogLevel.Error, $"The file '{ofd.FileName}' has an unknown type.");
						break;
				}
				if (import == null)
				{
					return;
				}

				if (addressListMemoryRecordList.Records.Any())
				{
					if (MessageBox.Show("The address list contains addresses. Do you really want to open the file?", $"{Constants.ApplicationName} Scanner", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
					{
						return;
					}
				}

				if (import is ReClassScanFile)
				{
					addressFilePath = ofd.FileName;
				}

				addressListMemoryRecordList.SetRecords(
					import.Load(ofd.FileName, Program.Logger)
						.Select(r =>
						{
							r.ResolveAddress(process);
							r.RefreshValue(process);
							return r;
						})
				);
			}
		}

		private void saveAddressFileToolStripButton_Click(object sender, EventArgs e)
		{
			if (addressListMemoryRecordList.Records.None())
			{
				return;
			}

			if (string.IsNullOrEmpty(addressFilePath))
			{
				saveAsToolStripButton_Click(sender, e);

				return;
			}

			var file = new ReClassScanFile();
			file.Save(addressListMemoryRecordList.Records, addressFilePath, Program.Logger);
		}

		private void saveAsToolStripButton_Click(object sender, EventArgs e)
		{
			if (addressListMemoryRecordList.Records.None())
			{
				return;
			}

			using var sfd = new SaveFileDialog
			{
				DefaultExt = ReClassScanFile.FileExtension,
				Filter = $"{ReClassScanFile.FormatName} (*{ReClassScanFile.FileExtension})|*{ReClassScanFile.FileExtension}"
			};

			if (sfd.ShowDialog() == DialogResult.OK)
			{
				addressFilePath = sfd.FileName;

				saveAddressFileToolStripButton_Click(sender, e);
			}
		}

		private void clearAddressListToolStripButton_Click(object sender, EventArgs e)
		{
			addressListMemoryRecordList.Clear();
		}

		private void showInputCorrelatorIconButton_Click(object sender, EventArgs e)
		{
			new InputCorrelatorForm(this, process).Show();
		}

		private void resultListContextMenuStrip_Opening(object sender, CancelEventArgs e)
		{
			var cms = (ContextMenuStrip)sender;

			var isResultList = cms.SourceControl.Parent == resultMemoryRecordList;

			addSelectedResultsToAddressListToolStripMenuItem.Visible = isResultList;
			changeToolStripMenuItem.Visible = !isResultList;
			removeSelectedRecordsToolStripMenuItem.Visible = !isResultList;

			// Hide all other items if multiple records are selected.
			var multipleRecordsSelected = (isResultList ? resultMemoryRecordList.SelectedRecords.Count : addressListMemoryRecordList.SelectedRecords.Count) > 1;
			for (var i = 3; i < cms.Items.Count; ++i)
			{
				cms.Items[i].Visible = !multipleRecordsSelected;
			}
		}

		private static MemoryRecordList GetMemoryRecordListFromMenuItem(object sender) =>
			(MemoryRecordList)((ContextMenuStrip)((ToolStripMenuItem)sender).Owner).SourceControl.Parent;

		private void addSelectedResultsToAddressListToolStripMenuItem_Click(object sender, EventArgs e)
		{
			foreach (var record in resultMemoryRecordList.SelectedRecords)
			{
				addressListMemoryRecordList.Records.Add(record);
			}
		}

		private void removeSelectedRecordsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			foreach (var record in addressListMemoryRecordList.SelectedRecords)
			{
				addressListMemoryRecordList.Records.Remove(record);
			}
		}

		private void setCurrentClassAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LinkedWindowFeatures.SetCurrentClassAddress(GetMemoryRecordListFromMenuItem(sender).SelectedRecord.RealAddress);
		}

		private void createClassAtAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LinkedWindowFeatures.CreateClassAtAddress(GetMemoryRecordListFromMenuItem(sender).SelectedRecord.RealAddress, true);
		}

		private void findOutWhatAccessesThisAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			FindWhatInteractsWithSelectedRecord(
				GetMemoryRecordListFromMenuItem(sender).SelectedRecord,
				false
			);
		}

		private void findOutWhatWritesToThisAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			FindWhatInteractsWithSelectedRecord(
				GetMemoryRecordListFromMenuItem(sender).SelectedRecord,
				true
			);
		}

		private void copyAddressToolStripMenuItem_Click(object sender, EventArgs e)
		{
			var record = GetMemoryRecordListFromMenuItem(sender)?.SelectedRecord;
			if (record != null)
			{
				Clipboard.SetText(record.RealAddress.ToString("X"));
			}
		}

		private void undoIconButton_Click(object sender, EventArgs e)
		{
			if (scanner.CanUndoLastScan)
			{
				scanner.UndoLastScan();

				ShowScannerResults(scanner);
			}

			undoIconButton.Enabled = scanner.CanUndoLastScan;
		}

		#endregion

		/// <summary>
		/// Displays the total result count.
		/// </summary>
		/// <param name="count">Number of.</param>
		private void SetResultCount(int count)
		{
			resultCountLabel.Text = count > MaxVisibleResults ? $"Found: {count} (only {MaxVisibleResults} shown)" : $"Found: {count}";
		}

		/// <summary>
		/// Shows some of the scanner results.
		/// </summary>
		public void ShowScannerResults(Scanner scanner)
		{
			Contract.Requires(scanner != null);

			SetResultCount(scanner.TotalResultCount);

			resultMemoryRecordList.SetRecords(
				scanner.GetResults()
					.Take(MaxVisibleResults)
					.OrderBy(r => r.Address, IntPtrComparer.Instance)
					.Select(r =>
					{
						var record = new MemoryRecord(r);
						record.ResolveAddress(process);
						return record;
					})
			);
		}

		/// <summary>
		/// Set input elements according to the selected compare type.
		/// </summary>
		private void OnCompareTypeChanged()
		{
			var enableHexCheckBox = true;
			var enableValueBox = true;
			var enableDualInput = false;

			switch (compareTypeComboBox.SelectedValue)
			{
				case ScanCompareType.Unknown:
					enableHexCheckBox = false;
					enableValueBox = false;
					break;
				case ScanCompareType.Between:
				case ScanCompareType.BetweenOrEqual:
					enableDualInput = true;
					break;
			}

			switch (valueTypeComboBox.SelectedValue)
			{
				case ScanValueType.Float:
				case ScanValueType.Double:
				case ScanValueType.ArrayOfBytes:
				case ScanValueType.String:
				case ScanValueType.Regex:
					isHexCheckBox.Checked = false;
					enableHexCheckBox = false;
					break;
			}

			isHexCheckBox.Enabled = enableHexCheckBox;
			dualValueBox.Enabled = enableValueBox;
			dualValueBox.ShowSecondInputField = enableDualInput;
		}

		/// <summary>
		/// Hide gui elements after the value type has changed.
		/// </summary>
		private void OnValueTypeChanged()
		{
			SetValidCompareTypes();

			var valueType = valueTypeComboBox.SelectedValue;

			switch (valueType)
			{
				case ScanValueType.Byte:
				case ScanValueType.Short:
				case ScanValueType.Integer:
				case ScanValueType.Long:
					isHexCheckBox.Enabled = true;
					break;
				case ScanValueType.Float:
				case ScanValueType.Double:
				case ScanValueType.ArrayOfBytes:
				case ScanValueType.String:
				case ScanValueType.Regex:
					isHexCheckBox.Checked = false;
					isHexCheckBox.Enabled = false;
					break;
			}

			var alignment = 1;
			switch (valueType)
			{
				case ScanValueType.Short:
					alignment = 2;
					break;
				case ScanValueType.Float:
				case ScanValueType.Double:
				case ScanValueType.Integer:
				case ScanValueType.Long:
					alignment = 4;
					break;
			}
			fastScanAlignmentTextBox.Text = alignment.ToString();

			floatingOptionsGroupBox.Visible = valueType == ScanValueType.Float || valueType == ScanValueType.Double;
			stringOptionsGroupBox.Visible = valueType == ScanValueType.String || valueType == ScanValueType.Regex;
		}

		/// <summary>
		/// Sets valid compare types dependend on the selected value type.
		/// </summary>
		private void SetValidCompareTypes()
		{
			var compareType = compareTypeComboBox.SelectedValue;
			var valueType = valueTypeComboBox.SelectedValue;
			if (valueType == ScanValueType.ArrayOfBytes || valueType == ScanValueType.String || valueType == ScanValueType.Regex)
			{
				compareTypeComboBox.SetAvailableValues(ScanCompareType.Equal);
			}
			else if (isFirstScan)
			{
				compareTypeComboBox.SetAvailableValuesExclude(
					ScanCompareType.Changed, ScanCompareType.NotChanged, ScanCompareType.Decreased,
					ScanCompareType.DecreasedOrEqual, ScanCompareType.Increased, ScanCompareType.IncreasedOrEqual
				);
			}
			else
			{
				compareTypeComboBox.SetAvailableValuesExclude(ScanCompareType.Unknown);
			}

			compareTypeComboBox.SelectedValue = compareType;
		}

		/// <summary>
		/// Resets all fields.
		/// </summary>
		private void Reset()
		{
			scanner?.Dispose();
			scanner = null;

			undoIconButton.Enabled = false;

			SetResultCount(0);
			resultMemoryRecordList.Clear();

			firstScanButton.Enabled = true;
			nextScanButton.Enabled = false;

			isHexCheckBox.Enabled = true;
			//isHexCheckBox.Checked = false;

			valueTypeComboBox.Enabled = true;
			//valueTypeComboBox.SelectedItem = valueTypeComboBox.Items.Cast<EnumDescriptionDisplay<ScanValueType>>().PredicateOrFirst(e => e.Value == ScanValueType.Integer);
			OnValueTypeChanged();

			floatingOptionsGroupBox.Enabled = true;
			stringOptionsGroupBox.Enabled = true;
			scanOptionsGroupBox.Enabled = true;

			isFirstScan = true;
			undoIconButton.Enabled = false;

			SetValidCompareTypes();
		}

		/// <summary>
		/// Excutes a new scan with the provided settings and comparer.
		/// </summary>
		/// <param name="settings">The scan settings.</param>
		/// <param name="comparer">The comparer.</param>
		public void ExcuteScan(ScanSettings settings, IScanComparer comparer)
		{
			Contract.Requires(settings != null);
			Contract.Requires(comparer != null);

			Reset();

			SetGuiFromSettings(settings);

			Invoke((Action)(async () => await StartFirstScanEx(settings, comparer)));
		}

		/// <summary>
		/// Starts a new first scan with the provided settings and comparer.
		/// </summary>
		/// <param name="settings">The scan settings.</param>
		/// <param name="comparer">The comparer.</param>
		private async Task StartFirstScanEx(ScanSettings settings, IScanComparer comparer)
		{
			if (!process.IsValid)
			{
				return;
			}

			firstScanButton.Enabled = false;
			cancelScanIconButton.Visible = true;

			try
			{
				scanner = new Scanner(process, settings);

				var report = new Progress<int>(i =>
				{
					scanProgressBar.Value = i;
					SetResultCount(scanner.TotalResultCount);
				});
				cts = new CancellationTokenSource();

				await scanner.Search(comparer, report, cts.Token);

				ShowScannerResults(scanner);

				cancelScanIconButton.Visible = false;
				nextScanButton.Enabled = true;
				valueTypeComboBox.Enabled = false;

				floatingOptionsGroupBox.Enabled = false;
				stringOptionsGroupBox.Enabled = false;
				scanOptionsGroupBox.Enabled = false;

				isFirstScan = false;

				SetValidCompareTypes();
				OnCompareTypeChanged();
			}
			finally
			{
				firstScanButton.Enabled = true;

				scanProgressBar.Value = 0;
			}
		}

		/// <summary>
		/// Creates the search settings from the user input.
		/// </summary>
		/// <returns>The scan settings.</returns>
		private ScanSettings CreateSearchSettings()
		{
			Contract.Ensures(Contract.Result<ScanSettings>() != null);

			var settings = new ScanSettings
			{
				ValueType = valueTypeComboBox.SelectedValue
			};

			long.TryParse(startAddressTextBox.Text, NumberStyles.HexNumber, null, out var startAddressVar);
			long.TryParse(stopAddressTextBox.Text, NumberStyles.HexNumber, null, out var endAddressVar);
#if RECLASSNET64
			settings.StartAddress = (IntPtr)startAddressVar;
			settings.StopAddress = (IntPtr)endAddressVar;
#else
			settings.StartAddress = unchecked((IntPtr)(int)startAddressVar);
			settings.StopAddress = unchecked((IntPtr)(int)endAddressVar);
#endif
			settings.EnableFastScan = fastScanCheckBox.Checked;
			int.TryParse(fastScanAlignmentTextBox.Text, out var alignment);
			settings.FastScanAlignment = Math.Max(1, alignment);

			static SettingState CheckStateToSettingState(CheckState state)
			{
				switch (state)
				{
					case CheckState.Checked:
						return SettingState.Yes;
					case CheckState.Unchecked:
						return SettingState.No;
					default:
						return SettingState.Indeterminate;
				}
			}

			settings.ScanPrivateMemory = scanPrivateCheckBox.Checked;
			settings.ScanImageMemory = scanImageCheckBox.Checked;
			settings.ScanMappedMemory = scanMappedCheckBox.Checked;
			settings.ScanWritableMemory = CheckStateToSettingState(scanWritableCheckBox.CheckState);
			settings.ScanExecutableMemory = CheckStateToSettingState(scanExecutableCheckBox.CheckState);
			settings.ScanCopyOnWriteMemory = CheckStateToSettingState(scanCopyOnWriteCheckBox.CheckState);

			return settings;
		}

		/// <summary>
		/// Sets the input fields according to the provided settings.
		/// </summary>
		/// <param name="settings">The scan settings.</param>
		private void SetGuiFromSettings(ScanSettings settings)
		{
			Contract.Requires(settings != null);

			valueTypeComboBox.SelectedValue = settings.ValueType;

			startAddressTextBox.Text = settings.StartAddress.ToString(Constants.AddressHexFormat);
			stopAddressTextBox.Text = settings.StopAddress.ToString(Constants.AddressHexFormat);

			fastScanCheckBox.Checked = settings.EnableFastScan;
			fastScanAlignmentTextBox.Text = Math.Max(1, settings.FastScanAlignment).ToString();

			static CheckState SettingStateToCheckState(SettingState state)
			{
				switch (state)
				{
					case SettingState.Yes:
						return CheckState.Checked;
					case SettingState.No:
						return CheckState.Unchecked;
					default:
						return CheckState.Indeterminate;
				}
			}

			scanPrivateCheckBox.Checked = settings.ScanPrivateMemory;
			scanImageCheckBox.Checked = settings.ScanImageMemory;
			scanMappedCheckBox.Checked = settings.ScanMappedMemory;
			scanWritableCheckBox.CheckState = SettingStateToCheckState(settings.ScanWritableMemory);
			scanExecutableCheckBox.CheckState = SettingStateToCheckState(settings.ScanExecutableMemory);
			scanCopyOnWriteCheckBox.CheckState = SettingStateToCheckState(settings.ScanCopyOnWriteMemory);
		}

		/// <summary>
		/// Creates the comparer from the user input.
		/// </summary>
		/// <returns>The scan comparer.</returns>
		private IScanComparer CreateComparer(ScanSettings settings)
		{
			Contract.Requires(settings != null);
			Contract.Ensures(Contract.Result<IScanComparer>() != null);

			var compareType = compareTypeComboBox.SelectedValue;
			var checkBothInputFields = compareType == ScanCompareType.Between || compareType == ScanCompareType.BetweenOrEqual;

			if (settings.ValueType == ScanValueType.Byte || settings.ValueType == ScanValueType.Short || settings.ValueType == ScanValueType.Integer || settings.ValueType == ScanValueType.Long)
			{
				var numberStyle = isHexCheckBox.Checked ? NumberStyles.HexNumber : NumberStyles.Integer;
				if (!long.TryParse(dualValueBox.Value1, numberStyle, null, out var value1)) throw new InvalidInputException(dualValueBox.Value1);
				if (!long.TryParse(dualValueBox.Value2, numberStyle, null, out var value2) && checkBothInputFields) throw new InvalidInputException(dualValueBox.Value2);

				if (compareType == ScanCompareType.Between || compareType == ScanCompareType.BetweenOrEqual)
				{
					if (value1 > value2)
					{
						Utils.Swap(ref value1, ref value2);
					}
				}

				switch (settings.ValueType)
				{
					case ScanValueType.Byte:
						return new ByteMemoryComparer(compareType, (byte)value1, (byte)value2);
					case ScanValueType.Short:
						return new ShortMemoryComparer(compareType, (short)value1, (short)value2, process.BitConverter);
					case ScanValueType.Integer:
						return new IntegerMemoryComparer(compareType, (int)value1, (int)value2, process.BitConverter);
					case ScanValueType.Long:
						return new LongMemoryComparer(compareType, value1, value2, process.BitConverter);
				}
			}
			else if (settings.ValueType == ScanValueType.Float || settings.ValueType == ScanValueType.Double)
			{
				int CalculateSignificantDigits(string input, NumberFormatInfo numberFormat)
				{
					Contract.Requires(input != null);
					Contract.Requires(numberFormat != null);

					var digits = 0;

					var decimalIndex = input.IndexOf(numberFormat.NumberDecimalSeparator, StringComparison.Ordinal);
					if (decimalIndex != -1)
					{
						digits = input.Length - 1 - decimalIndex;
					}

					return digits;
				}

				var nf1 = NumberFormat.GuessNumberFormat(dualValueBox.Value1);
				if (!double.TryParse(dualValueBox.Value1, NumberStyles.Float, nf1, out var value1)) throw new InvalidInputException(dualValueBox.Value1);
				var nf2 = NumberFormat.GuessNumberFormat(dualValueBox.Value2);
				if (!double.TryParse(dualValueBox.Value2, NumberStyles.Float, nf2, out var value2) && checkBothInputFields) throw new InvalidInputException(dualValueBox.Value2);

				if (compareType == ScanCompareType.Between || compareType == ScanCompareType.BetweenOrEqual)
				{
					if (value1 > value2)
					{
						Utils.Swap(ref value1, ref value2);
					}
				}

				var significantDigits = Math.Max(
					CalculateSignificantDigits(dualValueBox.Value1, nf1),
					CalculateSignificantDigits(dualValueBox.Value2, nf2)
				);

				var roundMode = roundStrictRadioButton.Checked ? ScanRoundMode.Strict : roundLooseRadioButton.Checked ? ScanRoundMode.Normal : ScanRoundMode.Truncate;

				switch (settings.ValueType)
				{
					case ScanValueType.Float:
						return new FloatMemoryComparer(compareType, roundMode, significantDigits, (float)value1, (float)value2, process.BitConverter);
					case ScanValueType.Double:
						return new DoubleMemoryComparer(compareType, roundMode, significantDigits, value1, value2, process.BitConverter);
				}
			}
			else if (settings.ValueType == ScanValueType.ArrayOfBytes)
			{
				var pattern = BytePattern.Parse(dualValueBox.Value1);

				return new ArrayOfBytesMemoryComparer(pattern);
			}
			else if (settings.ValueType == ScanValueType.String || settings.ValueType == ScanValueType.Regex)
			{
				if (string.IsNullOrEmpty(dualValueBox.Value1))
				{
					throw new InvalidInputException(dualValueBox.Value1);
				}

				var encoding = encodingUtf8RadioButton.Checked ? Encoding.UTF8 : encodingUtf16RadioButton.Checked ? Encoding.Unicode : Encoding.UTF32;
				if (settings.ValueType == ScanValueType.String)
				{
					return new StringMemoryComparer(dualValueBox.Value1, encoding, caseSensitiveCheckBox.Checked);
				}
				else
				{
					return new RegexStringMemoryComparer(dualValueBox.Value1, encoding, caseSensitiveCheckBox.Checked);
				}
			}

			throw new InvalidOperationException();
		}

		/// <summary>
		/// Attaches the debugger to find what interacts with the selected record.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown when one or more arguments are outside the required range.</exception>
		/// <param name="record">The record.</param>
		/// <param name="writeOnly">True to search only for write access.</param>
		private static void FindWhatInteractsWithSelectedRecord(MemoryRecord record, bool writeOnly)
		{
			int size;
			switch (record.ValueType)
			{
				case ScanValueType.Byte:
					size = 1;
					break;
				case ScanValueType.Short:
					size = 2;
					break;
				case ScanValueType.Integer:
				case ScanValueType.Float:
					size = 4;
					break;
				case ScanValueType.Long:
				case ScanValueType.Double:
					size = 8;
					break;
				case ScanValueType.ArrayOfBytes:
					size = record.ValueLength;
					break;
				case ScanValueType.String:
				case ScanValueType.Regex:
					size = record.ValueLength;
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}

			LinkedWindowFeatures.FindWhatInteractsWithAddress(record.RealAddress, size, writeOnly);
		}
	}

	internal class InvalidInputException : Exception
	{
		public InvalidInputException(string input)
			: base($"'{input}' is not a valid input.")
		{

		}
	}
}

```

`ReClass.NET/Forms/ScannerForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="infoToolTip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>304, 6</value>
  </metadata>
  <metadata name="updateValuesTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>15, 6</value>
  </metadata>
  <metadata name="resultListContextMenuStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>417, 6</value>
  </metadata>
  <metadata name="menuToolStrip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>172, 6</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>42</value>
  </metadata>
</root>
```

`ReClass.NET/Forms/SettingsForm.Designer.cs`:

```cs
using ReClassNET.Controls;

namespace ReClassNET.Forms
{
	partial class SettingsForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.settingsTabControl = new System.Windows.Forms.TabControl();
            this.generalSettingsTabPage = new System.Windows.Forms.TabPage();
            this.fileAssociationGroupBox = new System.Windows.Forms.GroupBox();
            this.removeAssociationButton = new System.Windows.Forms.Button();
            this.createAssociationButton = new System.Windows.Forms.Button();
            this.associationInfoLabel = new System.Windows.Forms.Label();
            this.commentsGroupBox = new System.Windows.Forms.GroupBox();
            this.showPluginInfoCheckBox = new System.Windows.Forms.CheckBox();
            this.showStringCheckBox = new System.Windows.Forms.CheckBox();
            this.showSymbolsCheckBox = new System.Windows.Forms.CheckBox();
            this.showRttiCheckBox = new System.Windows.Forms.CheckBox();
            this.showPointerCheckBox = new System.Windows.Forms.CheckBox();
            this.showIntegerCheckBox = new System.Windows.Forms.CheckBox();
            this.showFloatCheckBox = new System.Windows.Forms.CheckBox();
            this.displayGroupBox = new System.Windows.Forms.GroupBox();
            this.randomizeWindowTitleCheckBox = new System.Windows.Forms.CheckBox();
            this.runAsAdminCheckBox = new System.Windows.Forms.CheckBox();
            this.highlightChangedValuesCheckBox = new System.Windows.Forms.CheckBox();
            this.showTextCheckBox = new System.Windows.Forms.CheckBox();
            this.showNodeOffsetCheckBox = new System.Windows.Forms.CheckBox();
            this.showNodeAddressCheckBox = new System.Windows.Forms.CheckBox();
            this.stayOnTopCheckBox = new System.Windows.Forms.CheckBox();
            this.colorsSettingTabPage = new System.Windows.Forms.TabPage();
            this.nodeColorGroupBox = new System.Windows.Forms.GroupBox();
            this.nodeValueLabel = new System.Windows.Forms.Label();
            this.nodePluginLabel = new System.Windows.Forms.Label();
            this.nodeHexValueColorBox = new ReClassNET.Controls.ColorBox();
            this.nodePluginColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeHexValueLabel = new System.Windows.Forms.Label();
            this.nodeVTableLabel = new System.Windows.Forms.Label();
            this.nodeOffsetColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeVTableColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeOffsetLabel = new System.Windows.Forms.Label();
            this.nodeTextLabel = new System.Windows.Forms.Label();
            this.nodeAddressColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeTextColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeAddressLabel = new System.Windows.Forms.Label();
            this.nodeCommentLabel = new System.Windows.Forms.Label();
            this.nodeHiddenColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeCommentColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeHiddenLabel = new System.Windows.Forms.Label();
            this.nodeIndexLabel = new System.Windows.Forms.Label();
            this.nodeSelectedColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeIndexColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeSelectedLabel = new System.Windows.Forms.Label();
            this.nodeTypeColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeValueColorBox = new ReClassNET.Controls.ColorBox();
            this.nodeTypeLabel = new System.Windows.Forms.Label();
            this.nodeNameLabel = new System.Windows.Forms.Label();
            this.nodeNameColorBox = new ReClassNET.Controls.ColorBox();
            this.backgroundLabel = new System.Windows.Forms.Label();
            this.backgroundColorBox = new ReClassNET.Controls.ColorBox();
            this.typeDefinitionsSettingsTabPage = new System.Windows.Forms.TabPage();
            this.nuintSettingsLabel = new System.Windows.Forms.Label();
            this.nuintTypeTextBox = new System.Windows.Forms.TextBox();
            this.nintSettingsLabel = new System.Windows.Forms.Label();
            this.nintTypeTextBox = new System.Windows.Forms.TextBox();
            this.boolSettingsLabel = new System.Windows.Forms.Label();
            this.boolTypeTextBox = new System.Windows.Forms.TextBox();
            this.generatorInfoLabel = new System.Windows.Forms.Label();
            this.functionPtrSettingsLabel = new System.Windows.Forms.Label();
            this.functionPtrTypeTextBox = new System.Windows.Forms.TextBox();
            this.utf16TextSettingsLabel = new System.Windows.Forms.Label();
            this.utf16TextTypeTextBox = new System.Windows.Forms.TextBox();
            this.utf8TextSettingsLabel = new System.Windows.Forms.Label();
            this.utf8TextTypeTextBox = new System.Windows.Forms.TextBox();
            this.matrix3x3SettingsLabel = new System.Windows.Forms.Label();
            this.matrix3x3TypeTextBox = new System.Windows.Forms.TextBox();
            this.matrix3x4SettingsLabel = new System.Windows.Forms.Label();
            this.matrix3x4TypeTextBox = new System.Windows.Forms.TextBox();
            this.matrix4x4SettingsLabel = new System.Windows.Forms.Label();
            this.matrix4x4TypeTextBox = new System.Windows.Forms.TextBox();
            this.vector2SettingsLabel = new System.Windows.Forms.Label();
            this.vector2TypeTextBox = new System.Windows.Forms.TextBox();
            this.vector3SettingsLabel = new System.Windows.Forms.Label();
            this.vector3TypeTextBox = new System.Windows.Forms.TextBox();
            this.vector4SettingsLabel = new System.Windows.Forms.Label();
            this.vector4TypeTextBox = new System.Windows.Forms.TextBox();
            this.doubleSettingsLabel = new System.Windows.Forms.Label();
            this.doubleTypeTextBox = new System.Windows.Forms.TextBox();
            this.floatSettingsLabel = new System.Windows.Forms.Label();
            this.floatTypeTextBox = new System.Windows.Forms.TextBox();
            this.uint64SettingsLabel = new System.Windows.Forms.Label();
            this.uint64TypeTextBox = new System.Windows.Forms.TextBox();
            this.uint32SettingsLabel = new System.Windows.Forms.Label();
            this.uint32TypeTextBox = new System.Windows.Forms.TextBox();
            this.uint16SettingsLabel = new System.Windows.Forms.Label();
            this.uint16TypeTextBox = new System.Windows.Forms.TextBox();
            this.uint8SettingsLabel = new System.Windows.Forms.Label();
            this.uint8TypeTextBox = new System.Windows.Forms.TextBox();
            this.int64SettingsLabel = new System.Windows.Forms.Label();
            this.int64TypeTextBox = new System.Windows.Forms.TextBox();
            this.int32SettingsLabel = new System.Windows.Forms.Label();
            this.int32TypeTextBox = new System.Windows.Forms.TextBox();
            this.int16SettingsLabel = new System.Windows.Forms.Label();
            this.int16TypeTextBox = new System.Windows.Forms.TextBox();
            this.int8SettingsLabel = new System.Windows.Forms.Label();
            this.int8TypeTextBox = new System.Windows.Forms.TextBox();
            this.bannerBox = new ReClassNET.Controls.BannerBox();
            this.utf32TextSettingsLabel = new System.Windows.Forms.Label();
            this.utf32TextTypeTextBox = new System.Windows.Forms.TextBox();
            this.settingsTabControl.SuspendLayout();
            this.generalSettingsTabPage.SuspendLayout();
            this.fileAssociationGroupBox.SuspendLayout();
            this.commentsGroupBox.SuspendLayout();
            this.displayGroupBox.SuspendLayout();
            this.colorsSettingTabPage.SuspendLayout();
            this.nodeColorGroupBox.SuspendLayout();
            this.typeDefinitionsSettingsTabPage.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.bannerBox)).BeginInit();
            this.SuspendLayout();
            // 
            // settingsTabControl
            // 
            this.settingsTabControl.Controls.Add(this.generalSettingsTabPage);
            this.settingsTabControl.Controls.Add(this.colorsSettingTabPage);
            this.settingsTabControl.Controls.Add(this.typeDefinitionsSettingsTabPage);
            this.settingsTabControl.Location = new System.Drawing.Point(12, 60);
            this.settingsTabControl.Name = "settingsTabControl";
            this.settingsTabControl.SelectedIndex = 0;
            this.settingsTabControl.Size = new System.Drawing.Size(562, 355);
            this.settingsTabControl.TabIndex = 1;
            // 
            // generalSettingsTabPage
            // 
            this.generalSettingsTabPage.Controls.Add(this.fileAssociationGroupBox);
            this.generalSettingsTabPage.Controls.Add(this.commentsGroupBox);
            this.generalSettingsTabPage.Controls.Add(this.displayGroupBox);
            this.generalSettingsTabPage.Controls.Add(this.stayOnTopCheckBox);
            this.generalSettingsTabPage.Location = new System.Drawing.Point(4, 22);
            this.generalSettingsTabPage.Name = "generalSettingsTabPage";
            this.generalSettingsTabPage.Padding = new System.Windows.Forms.Padding(3);
            this.generalSettingsTabPage.Size = new System.Drawing.Size(554, 329);
            this.generalSettingsTabPage.TabIndex = 0;
            this.generalSettingsTabPage.Text = "General";
            this.generalSettingsTabPage.UseVisualStyleBackColor = true;
            // 
            // fileAssociationGroupBox
            // 
            this.fileAssociationGroupBox.Controls.Add(this.removeAssociationButton);
            this.fileAssociationGroupBox.Controls.Add(this.createAssociationButton);
            this.fileAssociationGroupBox.Controls.Add(this.associationInfoLabel);
            this.fileAssociationGroupBox.Location = new System.Drawing.Point(6, 231);
            this.fileAssociationGroupBox.Name = "fileAssociationGroupBox";
            this.fileAssociationGroupBox.Size = new System.Drawing.Size(542, 85);
            this.fileAssociationGroupBox.TabIndex = 4;
            this.fileAssociationGroupBox.TabStop = false;
            this.fileAssociationGroupBox.Text = "RCNET File Association";
            // 
            // removeAssociationButton
            // 
            this.removeAssociationButton.FlatStyle = System.Windows.Forms.FlatStyle.System;
            this.removeAssociationButton.Location = new System.Drawing.Point(146, 52);
            this.removeAssociationButton.Name = "removeAssociationButton";
            this.removeAssociationButton.Size = new System.Drawing.Size(135, 23);
            this.removeAssociationButton.TabIndex = 2;
            this.removeAssociationButton.Text = "&Remove Association";
            this.removeAssociationButton.UseVisualStyleBackColor = true;
            this.removeAssociationButton.Click += new System.EventHandler(this.removeAssociationButton_Click);
            // 
            // createAssociationButton
            // 
            this.createAssociationButton.FlatStyle = System.Windows.Forms.FlatStyle.System;
            this.createAssociationButton.Location = new System.Drawing.Point(9, 52);
            this.createAssociationButton.Name = "createAssociationButton";
            this.createAssociationButton.Size = new System.Drawing.Size(131, 23);
            this.createAssociationButton.TabIndex = 1;
            this.createAssociationButton.Text = "Create &Association";
            this.createAssociationButton.UseVisualStyleBackColor = true;
            this.createAssociationButton.Click += new System.EventHandler(this.createAssociationButton_Click);
            // 
            // associationInfoLabel
            // 
            this.associationInfoLabel.Location = new System.Drawing.Point(6, 21);
            this.associationInfoLabel.Name = "associationInfoLabel";
            this.associationInfoLabel.Size = new System.Drawing.Size(525, 28);
            this.associationInfoLabel.TabIndex = 0;
            this.associationInfoLabel.Text = "RCNET files can be associated with ReClass.NET. When you double-click a RCNET fil" +
    "e, they will automatically be opened by ReClass.NET.";
            // 
            // commentsGroupBox
            // 
            this.commentsGroupBox.Controls.Add(this.showPluginInfoCheckBox);
            this.commentsGroupBox.Controls.Add(this.showStringCheckBox);
            this.commentsGroupBox.Controls.Add(this.showSymbolsCheckBox);
            this.commentsGroupBox.Controls.Add(this.showRttiCheckBox);
            this.commentsGroupBox.Controls.Add(this.showPointerCheckBox);
            this.commentsGroupBox.Controls.Add(this.showIntegerCheckBox);
            this.commentsGroupBox.Controls.Add(this.showFloatCheckBox);
            this.commentsGroupBox.Location = new System.Drawing.Point(6, 39);
            this.commentsGroupBox.Name = "commentsGroupBox";
            this.commentsGroupBox.Size = new System.Drawing.Size(265, 186);
            this.commentsGroupBox.TabIndex = 3;
            this.commentsGroupBox.TabStop = false;
            this.commentsGroupBox.Text = "Node Comments";
            // 
            // showPluginInfoCheckBox
            // 
            this.showPluginInfoCheckBox.AutoSize = true;
            this.showPluginInfoCheckBox.Location = new System.Drawing.Point(6, 157);
            this.showPluginInfoCheckBox.Name = "showPluginInfoCheckBox";
            this.showPluginInfoCheckBox.Size = new System.Drawing.Size(111, 17);
            this.showPluginInfoCheckBox.TabIndex = 6;
            this.showPluginInfoCheckBox.Text = "Show Plugin Infos";
            this.showPluginInfoCheckBox.UseVisualStyleBackColor = true;
            // 
            // showStringCheckBox
            // 
            this.showStringCheckBox.AutoSize = true;
            this.showStringCheckBox.Location = new System.Drawing.Point(6, 134);
            this.showStringCheckBox.Name = "showStringCheckBox";
            this.showStringCheckBox.Size = new System.Drawing.Size(88, 17);
            this.showStringCheckBox.TabIndex = 5;
            this.showStringCheckBox.Text = "Show Strings";
            this.showStringCheckBox.UseVisualStyleBackColor = true;
            // 
            // showSymbolsCheckBox
            // 
            this.showSymbolsCheckBox.AutoSize = true;
            this.showSymbolsCheckBox.Location = new System.Drawing.Point(6, 111);
            this.showSymbolsCheckBox.Name = "showSymbolsCheckBox";
            this.showSymbolsCheckBox.Size = new System.Drawing.Size(130, 17);
            this.showSymbolsCheckBox.TabIndex = 4;
            this.showSymbolsCheckBox.Text = "Show Debug Symbols";
            this.showSymbolsCheckBox.UseVisualStyleBackColor = true;
            // 
            // showRttiCheckBox
            // 
            this.showRttiCheckBox.AutoSize = true;
            this.showRttiCheckBox.Location = new System.Drawing.Point(6, 88);
            this.showRttiCheckBox.Name = "showRttiCheckBox";
            this.showRttiCheckBox.Size = new System.Drawing.Size(81, 17);
            this.showRttiCheckBox.TabIndex = 3;
            this.showRttiCheckBox.Text = "Show RTTI";
            this.showRttiCheckBox.UseVisualStyleBackColor = true;
            // 
            // showPointerCheckBox
            // 
            this.showPointerCheckBox.AutoSize = true;
            this.showPointerCheckBox.Location = new System.Drawing.Point(6, 65);
            this.showPointerCheckBox.Name = "showPointerCheckBox";
            this.showPointerCheckBox.Size = new System.Drawing.Size(94, 17);
            this.showPointerCheckBox.TabIndex = 2;
            this.showPointerCheckBox.Text = "Show Pointers";
            this.showPointerCheckBox.UseVisualStyleBackColor = true;
            // 
            // showIntegerCheckBox
            // 
            this.showIntegerCheckBox.AutoSize = true;
            this.showIntegerCheckBox.Location = new System.Drawing.Point(6, 42);
            this.showIntegerCheckBox.Name = "showIntegerCheckBox";
            this.showIntegerCheckBox.Size = new System.Drawing.Size(124, 17);
            this.showIntegerCheckBox.TabIndex = 1;
            this.showIntegerCheckBox.Text = "Show Integer Values";
            this.showIntegerCheckBox.UseVisualStyleBackColor = true;
            // 
            // showFloatCheckBox
            // 
            this.showFloatCheckBox.AutoSize = true;
            this.showFloatCheckBox.Location = new System.Drawing.Point(6, 19);
            this.showFloatCheckBox.Name = "showFloatCheckBox";
            this.showFloatCheckBox.Size = new System.Drawing.Size(114, 17);
            this.showFloatCheckBox.TabIndex = 0;
            this.showFloatCheckBox.Text = "Show Float Values";
            this.showFloatCheckBox.UseVisualStyleBackColor = true;
            // 
            // displayGroupBox
            // 
            this.displayGroupBox.Controls.Add(this.randomizeWindowTitleCheckBox);
            this.displayGroupBox.Controls.Add(this.runAsAdminCheckBox);
            this.displayGroupBox.Controls.Add(this.highlightChangedValuesCheckBox);
            this.displayGroupBox.Controls.Add(this.showTextCheckBox);
            this.displayGroupBox.Controls.Add(this.showNodeOffsetCheckBox);
            this.displayGroupBox.Controls.Add(this.showNodeAddressCheckBox);
            this.displayGroupBox.Location = new System.Drawing.Point(283, 39);
            this.displayGroupBox.Name = "displayGroupBox";
            this.displayGroupBox.Size = new System.Drawing.Size(265, 160);
            this.displayGroupBox.TabIndex = 2;
            this.displayGroupBox.TabStop = false;
            this.displayGroupBox.Text = "Display";
            // 
            // randomizeWindowTitleCheckBox
            // 
            this.randomizeWindowTitleCheckBox.AutoSize = true;
            this.randomizeWindowTitleCheckBox.Location = new System.Drawing.Point(6, 134);
            this.randomizeWindowTitleCheckBox.Name = "randomizeWindowTitleCheckBox";
            this.randomizeWindowTitleCheckBox.Size = new System.Drawing.Size(137, 17);
            this.randomizeWindowTitleCheckBox.TabIndex = 5;
            this.randomizeWindowTitleCheckBox.Text = "Randomize window title";
            this.randomizeWindowTitleCheckBox.UseVisualStyleBackColor = true;
            // 
            // runAsAdminCheckBox
            // 
            this.runAsAdminCheckBox.AutoSize = true;
            this.runAsAdminCheckBox.Location = new System.Drawing.Point(6, 111);
            this.runAsAdminCheckBox.Name = "runAsAdminCheckBox";
            this.runAsAdminCheckBox.Size = new System.Drawing.Size(200, 17);
            this.runAsAdminCheckBox.TabIndex = 4;
            this.runAsAdminCheckBox.Text = "Run as administrator (requires restart)";
            this.runAsAdminCheckBox.UseVisualStyleBackColor = true;
            // 
            // highlightChangedValuesCheckBox
            // 
            this.highlightChangedValuesCheckBox.AutoSize = true;
            this.highlightChangedValuesCheckBox.Location = new System.Drawing.Point(6, 88);
            this.highlightChangedValuesCheckBox.Name = "highlightChangedValuesCheckBox";
            this.highlightChangedValuesCheckBox.Size = new System.Drawing.Size(148, 17);
            this.highlightChangedValuesCheckBox.TabIndex = 3;
            this.highlightChangedValuesCheckBox.Text = "Highlight Changed Values";
            this.highlightChangedValuesCheckBox.UseVisualStyleBackColor = true;
            // 
            // showTextCheckBox
            // 
            this.showTextCheckBox.AutoSize = true;
            this.showTextCheckBox.Location = new System.Drawing.Point(6, 65);
            this.showTextCheckBox.Name = "showTextCheckBox";
            this.showTextCheckBox.Size = new System.Drawing.Size(166, 17);
            this.showTextCheckBox.TabIndex = 2;
            this.showTextCheckBox.Text = "Show Textual Representation";
            this.showTextCheckBox.UseVisualStyleBackColor = true;
            // 
            // showNodeOffsetCheckBox
            // 
            this.showNodeOffsetCheckBox.AutoSize = true;
            this.showNodeOffsetCheckBox.Location = new System.Drawing.Point(6, 42);
            this.showNodeOffsetCheckBox.Name = "showNodeOffsetCheckBox";
            this.showNodeOffsetCheckBox.Size = new System.Drawing.Size(113, 17);
            this.showNodeOffsetCheckBox.TabIndex = 1;
            this.showNodeOffsetCheckBox.Text = "Show Node Offset";
            this.showNodeOffsetCheckBox.UseVisualStyleBackColor = true;
            // 
            // showNodeAddressCheckBox
            // 
            this.showNodeAddressCheckBox.AutoSize = true;
            this.showNodeAddressCheckBox.Location = new System.Drawing.Point(6, 19);
            this.showNodeAddressCheckBox.Name = "showNodeAddressCheckBox";
            this.showNodeAddressCheckBox.Size = new System.Drawing.Size(123, 17);
            this.showNodeAddressCheckBox.TabIndex = 0;
            this.showNodeAddressCheckBox.Text = "Show Node Address";
            this.showNodeAddressCheckBox.UseVisualStyleBackColor = true;
            // 
            // stayOnTopCheckBox
            // 
            this.stayOnTopCheckBox.AutoSize = true;
            this.stayOnTopCheckBox.Location = new System.Drawing.Point(6, 6);
            this.stayOnTopCheckBox.Name = "stayOnTopCheckBox";
            this.stayOnTopCheckBox.Size = new System.Drawing.Size(187, 17);
            this.stayOnTopCheckBox.TabIndex = 1;
            this.stayOnTopCheckBox.Text = "Force ReClass.NET to stay on top";
            this.stayOnTopCheckBox.UseVisualStyleBackColor = true;
            // 
            // colorsSettingTabPage
            // 
            this.colorsSettingTabPage.Controls.Add(this.nodeColorGroupBox);
            this.colorsSettingTabPage.Controls.Add(this.backgroundLabel);
            this.colorsSettingTabPage.Controls.Add(this.backgroundColorBox);
            this.colorsSettingTabPage.Location = new System.Drawing.Point(4, 22);
            this.colorsSettingTabPage.Name = "colorsSettingTabPage";
            this.colorsSettingTabPage.Padding = new System.Windows.Forms.Padding(3);
            this.colorsSettingTabPage.Size = new System.Drawing.Size(554, 329);
            this.colorsSettingTabPage.TabIndex = 1;
            this.colorsSettingTabPage.Text = "Colors";
            this.colorsSettingTabPage.UseVisualStyleBackColor = true;
            // 
            // nodeColorGroupBox
            // 
            this.nodeColorGroupBox.Controls.Add(this.nodeValueLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodePluginLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeHexValueColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodePluginColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeHexValueLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeVTableLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeOffsetColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeVTableColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeOffsetLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeTextLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeAddressColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeTextColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeAddressLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeCommentLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeHiddenColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeCommentColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeHiddenLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeIndexLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeSelectedColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeIndexColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeSelectedLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeTypeColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeValueColorBox);
            this.nodeColorGroupBox.Controls.Add(this.nodeTypeLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeNameLabel);
            this.nodeColorGroupBox.Controls.Add(this.nodeNameColorBox);
            this.nodeColorGroupBox.Location = new System.Drawing.Point(9, 43);
            this.nodeColorGroupBox.Name = "nodeColorGroupBox";
            this.nodeColorGroupBox.Size = new System.Drawing.Size(539, 225);
            this.nodeColorGroupBox.TabIndex = 28;
            this.nodeColorGroupBox.TabStop = false;
            this.nodeColorGroupBox.Text = "Node Colors";
            // 
            // nodeValueLabel
            // 
            this.nodeValueLabel.AutoSize = true;
            this.nodeValueLabel.Location = new System.Drawing.Point(9, 198);
            this.nodeValueLabel.Name = "nodeValueLabel";
            this.nodeValueLabel.Size = new System.Drawing.Size(64, 13);
            this.nodeValueLabel.TabIndex = 17;
            this.nodeValueLabel.Text = "Value Color:";
            // 
            // nodePluginLabel
            // 
            this.nodePluginLabel.AutoSize = true;
            this.nodePluginLabel.Location = new System.Drawing.Point(286, 172);
            this.nodePluginLabel.Name = "nodePluginLabel";
            this.nodePluginLabel.Size = new System.Drawing.Size(87, 13);
            this.nodePluginLabel.TabIndex = 27;
            this.nodePluginLabel.Text = "Plugin Info Color:";
            // 
            // nodeHexValueColorBox
            // 
            this.nodeHexValueColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeHexValueColorBox.Location = new System.Drawing.Point(133, 117);
            this.nodeHexValueColorBox.Name = "nodeHexValueColorBox";
            this.nodeHexValueColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeHexValueColorBox.TabIndex = 2;
            // 
            // nodePluginColorBox
            // 
            this.nodePluginColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodePluginColorBox.Location = new System.Drawing.Point(410, 169);
            this.nodePluginColorBox.Name = "nodePluginColorBox";
            this.nodePluginColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodePluginColorBox.TabIndex = 26;
            // 
            // nodeHexValueLabel
            // 
            this.nodeHexValueLabel.AutoSize = true;
            this.nodeHexValueLabel.Location = new System.Drawing.Point(9, 120);
            this.nodeHexValueLabel.Name = "nodeHexValueLabel";
            this.nodeHexValueLabel.Size = new System.Drawing.Size(86, 13);
            this.nodeHexValueLabel.TabIndex = 3;
            this.nodeHexValueLabel.Text = "Hex Value Color:";
            // 
            // nodeVTableLabel
            // 
            this.nodeVTableLabel.AutoSize = true;
            this.nodeVTableLabel.Location = new System.Drawing.Point(286, 94);
            this.nodeVTableLabel.Name = "nodeVTableLabel";
            this.nodeVTableLabel.Size = new System.Drawing.Size(71, 13);
            this.nodeVTableLabel.TabIndex = 25;
            this.nodeVTableLabel.Text = "VTable Color:";
            // 
            // nodeOffsetColorBox
            // 
            this.nodeOffsetColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeOffsetColorBox.Location = new System.Drawing.Point(133, 91);
            this.nodeOffsetColorBox.Name = "nodeOffsetColorBox";
            this.nodeOffsetColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeOffsetColorBox.TabIndex = 4;
            // 
            // nodeVTableColorBox
            // 
            this.nodeVTableColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeVTableColorBox.Location = new System.Drawing.Point(410, 91);
            this.nodeVTableColorBox.Name = "nodeVTableColorBox";
            this.nodeVTableColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeVTableColorBox.TabIndex = 24;
            // 
            // nodeOffsetLabel
            // 
            this.nodeOffsetLabel.AutoSize = true;
            this.nodeOffsetLabel.Location = new System.Drawing.Point(9, 94);
            this.nodeOffsetLabel.Name = "nodeOffsetLabel";
            this.nodeOffsetLabel.Size = new System.Drawing.Size(65, 13);
            this.nodeOffsetLabel.TabIndex = 5;
            this.nodeOffsetLabel.Text = "Offset Color:";
            // 
            // nodeTextLabel
            // 
            this.nodeTextLabel.AutoSize = true;
            this.nodeTextLabel.Location = new System.Drawing.Point(286, 146);
            this.nodeTextLabel.Name = "nodeTextLabel";
            this.nodeTextLabel.Size = new System.Drawing.Size(58, 13);
            this.nodeTextLabel.TabIndex = 23;
            this.nodeTextLabel.Text = "Text Color:";
            // 
            // nodeAddressColorBox
            // 
            this.nodeAddressColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeAddressColorBox.Location = new System.Drawing.Point(133, 65);
            this.nodeAddressColorBox.Name = "nodeAddressColorBox";
            this.nodeAddressColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeAddressColorBox.TabIndex = 6;
            // 
            // nodeTextColorBox
            // 
            this.nodeTextColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeTextColorBox.Location = new System.Drawing.Point(410, 143);
            this.nodeTextColorBox.Name = "nodeTextColorBox";
            this.nodeTextColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeTextColorBox.TabIndex = 22;
            // 
            // nodeAddressLabel
            // 
            this.nodeAddressLabel.AutoSize = true;
            this.nodeAddressLabel.Location = new System.Drawing.Point(9, 68);
            this.nodeAddressLabel.Name = "nodeAddressLabel";
            this.nodeAddressLabel.Size = new System.Drawing.Size(75, 13);
            this.nodeAddressLabel.TabIndex = 7;
            this.nodeAddressLabel.Text = "Address Color:";
            // 
            // nodeCommentLabel
            // 
            this.nodeCommentLabel.AutoSize = true;
            this.nodeCommentLabel.Location = new System.Drawing.Point(286, 120);
            this.nodeCommentLabel.Name = "nodeCommentLabel";
            this.nodeCommentLabel.Size = new System.Drawing.Size(81, 13);
            this.nodeCommentLabel.TabIndex = 21;
            this.nodeCommentLabel.Text = "Comment Color:";
            // 
            // nodeHiddenColorBox
            // 
            this.nodeHiddenColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeHiddenColorBox.Location = new System.Drawing.Point(410, 18);
            this.nodeHiddenColorBox.Name = "nodeHiddenColorBox";
            this.nodeHiddenColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeHiddenColorBox.TabIndex = 8;
            // 
            // nodeCommentColorBox
            // 
            this.nodeCommentColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeCommentColorBox.Location = new System.Drawing.Point(410, 117);
            this.nodeCommentColorBox.Name = "nodeCommentColorBox";
            this.nodeCommentColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeCommentColorBox.TabIndex = 20;
            // 
            // nodeHiddenLabel
            // 
            this.nodeHiddenLabel.AutoSize = true;
            this.nodeHiddenLabel.Location = new System.Drawing.Point(286, 21);
            this.nodeHiddenLabel.Name = "nodeHiddenLabel";
            this.nodeHiddenLabel.Size = new System.Drawing.Size(71, 13);
            this.nodeHiddenLabel.TabIndex = 9;
            this.nodeHiddenLabel.Text = "Hidden Color:";
            // 
            // nodeIndexLabel
            // 
            this.nodeIndexLabel.AutoSize = true;
            this.nodeIndexLabel.Location = new System.Drawing.Point(286, 68);
            this.nodeIndexLabel.Name = "nodeIndexLabel";
            this.nodeIndexLabel.Size = new System.Drawing.Size(63, 13);
            this.nodeIndexLabel.TabIndex = 19;
            this.nodeIndexLabel.Text = "Index Color:";
            // 
            // nodeSelectedColorBox
            // 
            this.nodeSelectedColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeSelectedColorBox.Location = new System.Drawing.Point(133, 18);
            this.nodeSelectedColorBox.Name = "nodeSelectedColorBox";
            this.nodeSelectedColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeSelectedColorBox.TabIndex = 10;
            // 
            // nodeIndexColorBox
            // 
            this.nodeIndexColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeIndexColorBox.Location = new System.Drawing.Point(410, 65);
            this.nodeIndexColorBox.Name = "nodeIndexColorBox";
            this.nodeIndexColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeIndexColorBox.TabIndex = 18;
            // 
            // nodeSelectedLabel
            // 
            this.nodeSelectedLabel.AutoSize = true;
            this.nodeSelectedLabel.Location = new System.Drawing.Point(9, 21);
            this.nodeSelectedLabel.Name = "nodeSelectedLabel";
            this.nodeSelectedLabel.Size = new System.Drawing.Size(79, 13);
            this.nodeSelectedLabel.TabIndex = 11;
            this.nodeSelectedLabel.Text = "Selected Color:";
            // 
            // nodeTypeColorBox
            // 
            this.nodeTypeColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeTypeColorBox.Location = new System.Drawing.Point(133, 143);
            this.nodeTypeColorBox.Name = "nodeTypeColorBox";
            this.nodeTypeColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeTypeColorBox.TabIndex = 12;
            // 
            // nodeValueColorBox
            // 
            this.nodeValueColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeValueColorBox.Location = new System.Drawing.Point(133, 195);
            this.nodeValueColorBox.Name = "nodeValueColorBox";
            this.nodeValueColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeValueColorBox.TabIndex = 16;
            // 
            // nodeTypeLabel
            // 
            this.nodeTypeLabel.AutoSize = true;
            this.nodeTypeLabel.Location = new System.Drawing.Point(9, 146);
            this.nodeTypeLabel.Name = "nodeTypeLabel";
            this.nodeTypeLabel.Size = new System.Drawing.Size(61, 13);
            this.nodeTypeLabel.TabIndex = 13;
            this.nodeTypeLabel.Text = "Type Color:";
            // 
            // nodeNameLabel
            // 
            this.nodeNameLabel.AutoSize = true;
            this.nodeNameLabel.Location = new System.Drawing.Point(9, 172);
            this.nodeNameLabel.Name = "nodeNameLabel";
            this.nodeNameLabel.Size = new System.Drawing.Size(65, 13);
            this.nodeNameLabel.TabIndex = 15;
            this.nodeNameLabel.Text = "Name Color:";
            // 
            // nodeNameColorBox
            // 
            this.nodeNameColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.nodeNameColorBox.Location = new System.Drawing.Point(133, 169);
            this.nodeNameColorBox.Name = "nodeNameColorBox";
            this.nodeNameColorBox.Size = new System.Drawing.Size(123, 20);
            this.nodeNameColorBox.TabIndex = 14;
            // 
            // backgroundLabel
            // 
            this.backgroundLabel.AutoSize = true;
            this.backgroundLabel.Location = new System.Drawing.Point(6, 14);
            this.backgroundLabel.Name = "backgroundLabel";
            this.backgroundLabel.Size = new System.Drawing.Size(161, 13);
            this.backgroundLabel.TabIndex = 1;
            this.backgroundLabel.Text = "Memory View Background Color:";
            // 
            // backgroundColorBox
            // 
            this.backgroundColorBox.Color = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.backgroundColorBox.Location = new System.Drawing.Point(175, 11);
            this.backgroundColorBox.Name = "backgroundColorBox";
            this.backgroundColorBox.Size = new System.Drawing.Size(123, 20);
            this.backgroundColorBox.TabIndex = 0;
            // 
            // typeDefinitionsSettingsTabPage
            // 
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf32TextSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf32TextTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.nuintSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.nuintTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.nintSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.nintTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.boolSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.boolTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.generatorInfoLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.functionPtrSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.functionPtrTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf16TextSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf16TextTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf8TextSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.utf8TextTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix3x3SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix3x3TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix3x4SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix3x4TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix4x4SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.matrix4x4TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector2SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector2TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector3SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector3TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector4SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.vector4TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.doubleSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.doubleTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.floatSettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.floatTypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint64SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint64TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint32SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint32TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint16SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint16TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint8SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.uint8TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int64SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int64TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int32SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int32TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int16SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int16TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int8SettingsLabel);
            this.typeDefinitionsSettingsTabPage.Controls.Add(this.int8TypeTextBox);
            this.typeDefinitionsSettingsTabPage.Location = new System.Drawing.Point(4, 22);
            this.typeDefinitionsSettingsTabPage.Name = "typeDefinitionsSettingsTabPage";
            this.typeDefinitionsSettingsTabPage.Padding = new System.Windows.Forms.Padding(3);
            this.typeDefinitionsSettingsTabPage.Size = new System.Drawing.Size(554, 329);
            this.typeDefinitionsSettingsTabPage.TabIndex = 2;
            this.typeDefinitionsSettingsTabPage.Text = "Type Definitions";
            this.typeDefinitionsSettingsTabPage.UseVisualStyleBackColor = true;
            // 
            // nuintSettingsLabel
            // 
            this.nuintSettingsLabel.AutoSize = true;
            this.nuintSettingsLabel.Location = new System.Drawing.Point(6, 233);
            this.nuintSettingsLabel.Name = "nuintSettingsLabel";
            this.nuintSettingsLabel.Size = new System.Drawing.Size(38, 13);
            this.nuintSettingsLabel.TabIndex = 50;
            this.nuintSettingsLabel.Text = "NUInt:";
            // 
            // nuintTypeTextBox
            // 
            this.nuintTypeTextBox.Location = new System.Drawing.Point(98, 230);
            this.nuintTypeTextBox.Name = "nuintTypeTextBox";
            this.nuintTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.nuintTypeTextBox.TabIndex = 49;
            // 
            // nintSettingsLabel
            // 
            this.nintSettingsLabel.AutoSize = true;
            this.nintSettingsLabel.Location = new System.Drawing.Point(6, 123);
            this.nintSettingsLabel.Name = "nintSettingsLabel";
            this.nintSettingsLabel.Size = new System.Drawing.Size(30, 13);
            this.nintSettingsLabel.TabIndex = 48;
            this.nintSettingsLabel.Text = "NInt:";
            // 
            // nintTypeTextBox
            // 
            this.nintTypeTextBox.Location = new System.Drawing.Point(98, 120);
            this.nintTypeTextBox.Name = "nintTypeTextBox";
            this.nintTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.nintTypeTextBox.TabIndex = 47;
            // 
            // boolSettingsLabel
            // 
            this.boolSettingsLabel.AutoSize = true;
            this.boolSettingsLabel.Location = new System.Drawing.Point(254, 35);
            this.boolSettingsLabel.Name = "boolSettingsLabel";
            this.boolSettingsLabel.Size = new System.Drawing.Size(31, 13);
            this.boolSettingsLabel.TabIndex = 46;
            this.boolSettingsLabel.Text = "Bool:";
            // 
            // boolTypeTextBox
            // 
            this.boolTypeTextBox.Location = new System.Drawing.Point(346, 32);
            this.boolTypeTextBox.Name = "boolTypeTextBox";
            this.boolTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.boolTypeTextBox.TabIndex = 45;
            // 
            // generatorInfoLabel
            // 
            this.generatorInfoLabel.AutoSize = true;
            this.generatorInfoLabel.Location = new System.Drawing.Point(6, 6);
            this.generatorInfoLabel.Name = "generatorInfoLabel";
            this.generatorInfoLabel.Size = new System.Drawing.Size(236, 13);
            this.generatorInfoLabel.TabIndex = 44;
            this.generatorInfoLabel.Text = "These types are used to generate the C++ code:";
            // 
            // functionPtrSettingsLabel
            // 
            this.functionPtrSettingsLabel.AutoSize = true;
            this.functionPtrSettingsLabel.Location = new System.Drawing.Point(254, 255);
            this.functionPtrSettingsLabel.Name = "functionPtrSettingsLabel";
            this.functionPtrSettingsLabel.Size = new System.Drawing.Size(87, 13);
            this.functionPtrSettingsLabel.TabIndex = 43;
            this.functionPtrSettingsLabel.Text = "Function Pointer:";
            // 
            // functionPtrTypeTextBox
            // 
            this.functionPtrTypeTextBox.Location = new System.Drawing.Point(346, 252);
            this.functionPtrTypeTextBox.Name = "functionPtrTypeTextBox";
            this.functionPtrTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.functionPtrTypeTextBox.TabIndex = 42;
            // 
            // utf16TextSettingsLabel
            // 
            this.utf16TextSettingsLabel.AutoSize = true;
            this.utf16TextSettingsLabel.Location = new System.Drawing.Point(254, 211);
            this.utf16TextSettingsLabel.Name = "utf16TextSettingsLabel";
            this.utf16TextSettingsLabel.Size = new System.Drawing.Size(43, 13);
            this.utf16TextSettingsLabel.TabIndex = 39;
            this.utf16TextSettingsLabel.Text = "UTF16:";
            // 
            // utf16TextTypeTextBox
            // 
            this.utf16TextTypeTextBox.Location = new System.Drawing.Point(346, 208);
            this.utf16TextTypeTextBox.Name = "utf16TextTypeTextBox";
            this.utf16TextTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.utf16TextTypeTextBox.TabIndex = 38;
            // 
            // utf8TextSettingsLabel
            // 
            this.utf8TextSettingsLabel.AutoSize = true;
            this.utf8TextSettingsLabel.Location = new System.Drawing.Point(254, 189);
            this.utf8TextSettingsLabel.Name = "utf8TextSettingsLabel";
            this.utf8TextSettingsLabel.Size = new System.Drawing.Size(37, 13);
            this.utf8TextSettingsLabel.TabIndex = 35;
            this.utf8TextSettingsLabel.Text = "UTF8:";
            // 
            // utf8TextTypeTextBox
            // 
            this.utf8TextTypeTextBox.Location = new System.Drawing.Point(346, 186);
            this.utf8TextTypeTextBox.Name = "utf8TextTypeTextBox";
            this.utf8TextTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.utf8TextTypeTextBox.TabIndex = 34;
            // 
            // matrix3x3SettingsLabel
            // 
            this.matrix3x3SettingsLabel.AutoSize = true;
            this.matrix3x3SettingsLabel.Location = new System.Drawing.Point(254, 123);
            this.matrix3x3SettingsLabel.Name = "matrix3x3SettingsLabel";
            this.matrix3x3SettingsLabel.Size = new System.Drawing.Size(64, 13);
            this.matrix3x3SettingsLabel.TabIndex = 33;
            this.matrix3x3SettingsLabel.Text = "Matrix (3x3):";
            // 
            // matrix3x3TypeTextBox
            // 
            this.matrix3x3TypeTextBox.Location = new System.Drawing.Point(346, 120);
            this.matrix3x3TypeTextBox.Name = "matrix3x3TypeTextBox";
            this.matrix3x3TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.matrix3x3TypeTextBox.TabIndex = 32;
            // 
            // matrix3x4SettingsLabel
            // 
            this.matrix3x4SettingsLabel.AutoSize = true;
            this.matrix3x4SettingsLabel.Location = new System.Drawing.Point(254, 145);
            this.matrix3x4SettingsLabel.Name = "matrix3x4SettingsLabel";
            this.matrix3x4SettingsLabel.Size = new System.Drawing.Size(64, 13);
            this.matrix3x4SettingsLabel.TabIndex = 31;
            this.matrix3x4SettingsLabel.Text = "Matrix (3x4):";
            // 
            // matrix3x4TypeTextBox
            // 
            this.matrix3x4TypeTextBox.Location = new System.Drawing.Point(346, 142);
            this.matrix3x4TypeTextBox.Name = "matrix3x4TypeTextBox";
            this.matrix3x4TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.matrix3x4TypeTextBox.TabIndex = 30;
            // 
            // matrix4x4SettingsLabel
            // 
            this.matrix4x4SettingsLabel.AutoSize = true;
            this.matrix4x4SettingsLabel.Location = new System.Drawing.Point(254, 167);
            this.matrix4x4SettingsLabel.Name = "matrix4x4SettingsLabel";
            this.matrix4x4SettingsLabel.Size = new System.Drawing.Size(64, 13);
            this.matrix4x4SettingsLabel.TabIndex = 29;
            this.matrix4x4SettingsLabel.Text = "Matrix (4x4):";
            // 
            // matrix4x4TypeTextBox
            // 
            this.matrix4x4TypeTextBox.Location = new System.Drawing.Point(346, 164);
            this.matrix4x4TypeTextBox.Name = "matrix4x4TypeTextBox";
            this.matrix4x4TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.matrix4x4TypeTextBox.TabIndex = 28;
            // 
            // vector2SettingsLabel
            // 
            this.vector2SettingsLabel.AutoSize = true;
            this.vector2SettingsLabel.Location = new System.Drawing.Point(254, 57);
            this.vector2SettingsLabel.Name = "vector2SettingsLabel";
            this.vector2SettingsLabel.Size = new System.Drawing.Size(47, 13);
            this.vector2SettingsLabel.TabIndex = 27;
            this.vector2SettingsLabel.Text = "Vector2:";
            // 
            // vector2TypeTextBox
            // 
            this.vector2TypeTextBox.Location = new System.Drawing.Point(346, 54);
            this.vector2TypeTextBox.Name = "vector2TypeTextBox";
            this.vector2TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.vector2TypeTextBox.TabIndex = 26;
            // 
            // vector3SettingsLabel
            // 
            this.vector3SettingsLabel.AutoSize = true;
            this.vector3SettingsLabel.Location = new System.Drawing.Point(254, 79);
            this.vector3SettingsLabel.Name = "vector3SettingsLabel";
            this.vector3SettingsLabel.Size = new System.Drawing.Size(47, 13);
            this.vector3SettingsLabel.TabIndex = 25;
            this.vector3SettingsLabel.Text = "Vector3:";
            // 
            // vector3TypeTextBox
            // 
            this.vector3TypeTextBox.Location = new System.Drawing.Point(346, 76);
            this.vector3TypeTextBox.Name = "vector3TypeTextBox";
            this.vector3TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.vector3TypeTextBox.TabIndex = 24;
            // 
            // vector4SettingsLabel
            // 
            this.vector4SettingsLabel.AutoSize = true;
            this.vector4SettingsLabel.Location = new System.Drawing.Point(254, 101);
            this.vector4SettingsLabel.Name = "vector4SettingsLabel";
            this.vector4SettingsLabel.Size = new System.Drawing.Size(47, 13);
            this.vector4SettingsLabel.TabIndex = 23;
            this.vector4SettingsLabel.Text = "Vector4:";
            // 
            // vector4TypeTextBox
            // 
            this.vector4TypeTextBox.Location = new System.Drawing.Point(346, 98);
            this.vector4TypeTextBox.Name = "vector4TypeTextBox";
            this.vector4TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.vector4TypeTextBox.TabIndex = 22;
            // 
            // doubleSettingsLabel
            // 
            this.doubleSettingsLabel.AutoSize = true;
            this.doubleSettingsLabel.Location = new System.Drawing.Point(6, 277);
            this.doubleSettingsLabel.Name = "doubleSettingsLabel";
            this.doubleSettingsLabel.Size = new System.Drawing.Size(44, 13);
            this.doubleSettingsLabel.TabIndex = 21;
            this.doubleSettingsLabel.Text = "Double:";
            // 
            // doubleTypeTextBox
            // 
            this.doubleTypeTextBox.Location = new System.Drawing.Point(98, 274);
            this.doubleTypeTextBox.Name = "doubleTypeTextBox";
            this.doubleTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.doubleTypeTextBox.TabIndex = 20;
            // 
            // floatSettingsLabel
            // 
            this.floatSettingsLabel.AutoSize = true;
            this.floatSettingsLabel.Location = new System.Drawing.Point(6, 255);
            this.floatSettingsLabel.Name = "floatSettingsLabel";
            this.floatSettingsLabel.Size = new System.Drawing.Size(33, 13);
            this.floatSettingsLabel.TabIndex = 19;
            this.floatSettingsLabel.Text = "Float:";
            // 
            // floatTypeTextBox
            // 
            this.floatTypeTextBox.Location = new System.Drawing.Point(98, 252);
            this.floatTypeTextBox.Name = "floatTypeTextBox";
            this.floatTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.floatTypeTextBox.TabIndex = 18;
            // 
            // uint64SettingsLabel
            // 
            this.uint64SettingsLabel.AutoSize = true;
            this.uint64SettingsLabel.Location = new System.Drawing.Point(6, 211);
            this.uint64SettingsLabel.Name = "uint64SettingsLabel";
            this.uint64SettingsLabel.Size = new System.Drawing.Size(42, 13);
            this.uint64SettingsLabel.TabIndex = 17;
            this.uint64SettingsLabel.Text = "UInt64:";
            // 
            // uint64TypeTextBox
            // 
            this.uint64TypeTextBox.Location = new System.Drawing.Point(98, 208);
            this.uint64TypeTextBox.Name = "uint64TypeTextBox";
            this.uint64TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.uint64TypeTextBox.TabIndex = 16;
            // 
            // uint32SettingsLabel
            // 
            this.uint32SettingsLabel.AutoSize = true;
            this.uint32SettingsLabel.Location = new System.Drawing.Point(6, 189);
            this.uint32SettingsLabel.Name = "uint32SettingsLabel";
            this.uint32SettingsLabel.Size = new System.Drawing.Size(42, 13);
            this.uint32SettingsLabel.TabIndex = 15;
            this.uint32SettingsLabel.Text = "UInt32:";
            // 
            // uint32TypeTextBox
            // 
            this.uint32TypeTextBox.Location = new System.Drawing.Point(98, 186);
            this.uint32TypeTextBox.Name = "uint32TypeTextBox";
            this.uint32TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.uint32TypeTextBox.TabIndex = 14;
            // 
            // uint16SettingsLabel
            // 
            this.uint16SettingsLabel.AutoSize = true;
            this.uint16SettingsLabel.Location = new System.Drawing.Point(6, 167);
            this.uint16SettingsLabel.Name = "uint16SettingsLabel";
            this.uint16SettingsLabel.Size = new System.Drawing.Size(42, 13);
            this.uint16SettingsLabel.TabIndex = 13;
            this.uint16SettingsLabel.Text = "UInt16:";
            // 
            // uint16TypeTextBox
            // 
            this.uint16TypeTextBox.Location = new System.Drawing.Point(98, 164);
            this.uint16TypeTextBox.Name = "uint16TypeTextBox";
            this.uint16TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.uint16TypeTextBox.TabIndex = 12;
            // 
            // uint8SettingsLabel
            // 
            this.uint8SettingsLabel.AutoSize = true;
            this.uint8SettingsLabel.Location = new System.Drawing.Point(6, 145);
            this.uint8SettingsLabel.Name = "uint8SettingsLabel";
            this.uint8SettingsLabel.Size = new System.Drawing.Size(36, 13);
            this.uint8SettingsLabel.TabIndex = 11;
            this.uint8SettingsLabel.Text = "UInt8:";
            // 
            // uint8TypeTextBox
            // 
            this.uint8TypeTextBox.Location = new System.Drawing.Point(98, 142);
            this.uint8TypeTextBox.Name = "uint8TypeTextBox";
            this.uint8TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.uint8TypeTextBox.TabIndex = 10;
            // 
            // int64SettingsLabel
            // 
            this.int64SettingsLabel.AutoSize = true;
            this.int64SettingsLabel.Location = new System.Drawing.Point(6, 101);
            this.int64SettingsLabel.Name = "int64SettingsLabel";
            this.int64SettingsLabel.Size = new System.Drawing.Size(34, 13);
            this.int64SettingsLabel.TabIndex = 9;
            this.int64SettingsLabel.Text = "Int64:";
            // 
            // int64TypeTextBox
            // 
            this.int64TypeTextBox.Location = new System.Drawing.Point(98, 98);
            this.int64TypeTextBox.Name = "int64TypeTextBox";
            this.int64TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.int64TypeTextBox.TabIndex = 8;
            // 
            // int32SettingsLabel
            // 
            this.int32SettingsLabel.AutoSize = true;
            this.int32SettingsLabel.Location = new System.Drawing.Point(6, 79);
            this.int32SettingsLabel.Name = "int32SettingsLabel";
            this.int32SettingsLabel.Size = new System.Drawing.Size(34, 13);
            this.int32SettingsLabel.TabIndex = 7;
            this.int32SettingsLabel.Text = "Int32:";
            // 
            // int32TypeTextBox
            // 
            this.int32TypeTextBox.Location = new System.Drawing.Point(98, 76);
            this.int32TypeTextBox.Name = "int32TypeTextBox";
            this.int32TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.int32TypeTextBox.TabIndex = 6;
            // 
            // int16SettingsLabel
            // 
            this.int16SettingsLabel.AutoSize = true;
            this.int16SettingsLabel.Location = new System.Drawing.Point(6, 57);
            this.int16SettingsLabel.Name = "int16SettingsLabel";
            this.int16SettingsLabel.Size = new System.Drawing.Size(34, 13);
            this.int16SettingsLabel.TabIndex = 5;
            this.int16SettingsLabel.Text = "Int16:";
            // 
            // int16TypeTextBox
            // 
            this.int16TypeTextBox.Location = new System.Drawing.Point(98, 54);
            this.int16TypeTextBox.Name = "int16TypeTextBox";
            this.int16TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.int16TypeTextBox.TabIndex = 4;
            // 
            // int8SettingsLabel
            // 
            this.int8SettingsLabel.AutoSize = true;
            this.int8SettingsLabel.Location = new System.Drawing.Point(6, 35);
            this.int8SettingsLabel.Name = "int8SettingsLabel";
            this.int8SettingsLabel.Size = new System.Drawing.Size(28, 13);
            this.int8SettingsLabel.TabIndex = 3;
            this.int8SettingsLabel.Text = "Int8:";
            // 
            // int8TypeTextBox
            // 
            this.int8TypeTextBox.Location = new System.Drawing.Point(98, 32);
            this.int8TypeTextBox.Name = "int8TypeTextBox";
            this.int8TypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.int8TypeTextBox.TabIndex = 2;
            // 
            // bannerBox
            // 
            this.bannerBox.Dock = System.Windows.Forms.DockStyle.Top;
            this.bannerBox.Icon = global::ReClassNET.Properties.Resources.B32x32_Cogs;
            this.bannerBox.Location = new System.Drawing.Point(0, 0);
            this.bannerBox.Name = "bannerBox";
            this.bannerBox.Size = new System.Drawing.Size(586, 48);
            this.bannerBox.TabIndex = 2;
            this.bannerBox.Text = "Configure the global settings.";
            this.bannerBox.Title = "Settings";
            // 
            // utf32TextSettingsLabel
            // 
            this.utf32TextSettingsLabel.AutoSize = true;
            this.utf32TextSettingsLabel.Location = new System.Drawing.Point(254, 233);
            this.utf32TextSettingsLabel.Name = "utf32TextSettingsLabel";
            this.utf32TextSettingsLabel.Size = new System.Drawing.Size(43, 13);
            this.utf32TextSettingsLabel.TabIndex = 52;
            this.utf32TextSettingsLabel.Text = "UTF32:";
            // 
            // utf32TextTypeTextBox
            // 
            this.utf32TextTypeTextBox.Location = new System.Drawing.Point(346, 230);
            this.utf32TextTypeTextBox.Name = "utf32TextTypeTextBox";
            this.utf32TextTypeTextBox.Size = new System.Drawing.Size(120, 20);
            this.utf32TextTypeTextBox.TabIndex = 51;
            // 
            // SettingsForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(586, 427);
            this.Controls.Add(this.bannerBox);
            this.Controls.Add(this.settingsTabControl);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "SettingsForm";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "ReClass.NET - Settings";
            this.settingsTabControl.ResumeLayout(false);
            this.generalSettingsTabPage.ResumeLayout(false);
            this.generalSettingsTabPage.PerformLayout();
            this.fileAssociationGroupBox.ResumeLayout(false);
            this.commentsGroupBox.ResumeLayout(false);
            this.commentsGroupBox.PerformLayout();
            this.displayGroupBox.ResumeLayout(false);
            this.displayGroupBox.PerformLayout();
            this.colorsSettingTabPage.ResumeLayout(false);
            this.colorsSettingTabPage.PerformLayout();
            this.nodeColorGroupBox.ResumeLayout(false);
            this.nodeColorGroupBox.PerformLayout();
            this.typeDefinitionsSettingsTabPage.ResumeLayout(false);
            this.typeDefinitionsSettingsTabPage.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.bannerBox)).EndInit();
            this.ResumeLayout(false);

		}

		#endregion
		private System.Windows.Forms.TabControl settingsTabControl;
		private System.Windows.Forms.TabPage generalSettingsTabPage;
		private System.Windows.Forms.TabPage colorsSettingTabPage;
		private System.Windows.Forms.TabPage typeDefinitionsSettingsTabPage;
		private System.Windows.Forms.CheckBox stayOnTopCheckBox;
		private System.Windows.Forms.GroupBox displayGroupBox;
		private System.Windows.Forms.CheckBox showNodeAddressCheckBox;
		private System.Windows.Forms.CheckBox showTextCheckBox;
		private System.Windows.Forms.CheckBox showNodeOffsetCheckBox;
		private System.Windows.Forms.CheckBox highlightChangedValuesCheckBox;
		private System.Windows.Forms.GroupBox commentsGroupBox;
		private System.Windows.Forms.CheckBox showRttiCheckBox;
		private System.Windows.Forms.CheckBox showPointerCheckBox;
		private System.Windows.Forms.CheckBox showIntegerCheckBox;
		private System.Windows.Forms.CheckBox showFloatCheckBox;
		private System.Windows.Forms.CheckBox showPluginInfoCheckBox;
		private System.Windows.Forms.CheckBox showStringCheckBox;
		private System.Windows.Forms.CheckBox showSymbolsCheckBox;
		private ColorBox backgroundColorBox;
		private System.Windows.Forms.Label nodeSelectedLabel;
		private ColorBox nodeSelectedColorBox;
		private System.Windows.Forms.Label nodeHiddenLabel;
		private ColorBox nodeHiddenColorBox;
		private System.Windows.Forms.Label nodeAddressLabel;
		private ColorBox nodeAddressColorBox;
		private System.Windows.Forms.Label nodeOffsetLabel;
		private ColorBox nodeOffsetColorBox;
		private System.Windows.Forms.Label nodeHexValueLabel;
		private ColorBox nodeHexValueColorBox;
		private System.Windows.Forms.Label backgroundLabel;
		private System.Windows.Forms.Label nodeValueLabel;
		private ColorBox nodeValueColorBox;
		private System.Windows.Forms.Label nodeNameLabel;
		private ColorBox nodeNameColorBox;
		private System.Windows.Forms.Label nodeTypeLabel;
		private ColorBox nodeTypeColorBox;
		private System.Windows.Forms.Label nodeVTableLabel;
		private ColorBox nodeVTableColorBox;
		private System.Windows.Forms.Label nodeTextLabel;
		private ColorBox nodeTextColorBox;
		private System.Windows.Forms.Label nodeCommentLabel;
		private ColorBox nodeCommentColorBox;
		private System.Windows.Forms.Label nodeIndexLabel;
		private ColorBox nodeIndexColorBox;
		private System.Windows.Forms.Label nodePluginLabel;
		private ColorBox nodePluginColorBox;
		private System.Windows.Forms.Label floatSettingsLabel;
		private System.Windows.Forms.TextBox floatTypeTextBox;
		private System.Windows.Forms.Label uint64SettingsLabel;
		private System.Windows.Forms.TextBox uint64TypeTextBox;
		private System.Windows.Forms.Label uint32SettingsLabel;
		private System.Windows.Forms.TextBox uint32TypeTextBox;
		private System.Windows.Forms.Label uint16SettingsLabel;
		private System.Windows.Forms.TextBox uint16TypeTextBox;
		private System.Windows.Forms.Label uint8SettingsLabel;
		private System.Windows.Forms.TextBox uint8TypeTextBox;
		private System.Windows.Forms.Label int64SettingsLabel;
		private System.Windows.Forms.TextBox int64TypeTextBox;
		private System.Windows.Forms.Label int32SettingsLabel;
		private System.Windows.Forms.TextBox int32TypeTextBox;
		private System.Windows.Forms.Label int16SettingsLabel;
		private System.Windows.Forms.TextBox int16TypeTextBox;
		private System.Windows.Forms.Label int8SettingsLabel;
		private System.Windows.Forms.TextBox int8TypeTextBox;
		private System.Windows.Forms.Label functionPtrSettingsLabel;
		private System.Windows.Forms.TextBox functionPtrTypeTextBox;
		private System.Windows.Forms.Label utf16TextSettingsLabel;
		private System.Windows.Forms.TextBox utf16TextTypeTextBox;
		private System.Windows.Forms.Label utf8TextSettingsLabel;
		private System.Windows.Forms.TextBox utf8TextTypeTextBox;
		private System.Windows.Forms.Label matrix3x3SettingsLabel;
		private System.Windows.Forms.TextBox matrix3x3TypeTextBox;
		private System.Windows.Forms.Label matrix3x4SettingsLabel;
		private System.Windows.Forms.TextBox matrix3x4TypeTextBox;
		private System.Windows.Forms.Label matrix4x4SettingsLabel;
		private System.Windows.Forms.TextBox matrix4x4TypeTextBox;
		private System.Windows.Forms.Label vector2SettingsLabel;
		private System.Windows.Forms.TextBox vector2TypeTextBox;
		private System.Windows.Forms.Label vector3SettingsLabel;
		private System.Windows.Forms.TextBox vector3TypeTextBox;
		private System.Windows.Forms.Label vector4SettingsLabel;
		private System.Windows.Forms.TextBox vector4TypeTextBox;
		private System.Windows.Forms.Label doubleSettingsLabel;
		private System.Windows.Forms.TextBox doubleTypeTextBox;
		private System.Windows.Forms.GroupBox nodeColorGroupBox;
		private System.Windows.Forms.Label generatorInfoLabel;
		private BannerBox bannerBox;
		private System.Windows.Forms.Label boolSettingsLabel;
		private System.Windows.Forms.TextBox boolTypeTextBox;
		private System.Windows.Forms.GroupBox fileAssociationGroupBox;
		private System.Windows.Forms.Button removeAssociationButton;
		private System.Windows.Forms.Button createAssociationButton;
		private System.Windows.Forms.Label associationInfoLabel;
		private System.Windows.Forms.CheckBox randomizeWindowTitleCheckBox;
		private System.Windows.Forms.CheckBox runAsAdminCheckBox;
		private System.Windows.Forms.Label nuintSettingsLabel;
		private System.Windows.Forms.TextBox nuintTypeTextBox;
		private System.Windows.Forms.Label nintSettingsLabel;
		private System.Windows.Forms.TextBox nintTypeTextBox;
		private System.Windows.Forms.Label utf32TextSettingsLabel;
		private System.Windows.Forms.TextBox utf32TextTypeTextBox;
	}
}
```

`ReClass.NET/Forms/SettingsForm.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Windows.Forms;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Native;
using ReClassNET.Project;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Forms
{
	public partial class SettingsForm : IconForm
	{
		private readonly Settings settings;
		private readonly CppTypeMapping typeMapping;

		public TabControl SettingsTabControl => settingsTabControl;

		public SettingsForm(Settings settings, CppTypeMapping typeMapping)
		{
			Contract.Requires(settings != null);
			Contract.Requires(typeMapping != null);

			this.settings = settings;
			this.typeMapping = typeMapping;

			InitializeComponent();

			var imageList = new ImageList();
			imageList.Images.Add(Properties.Resources.B16x16_Gear);
			imageList.Images.Add(Properties.Resources.B16x16_Color_Wheel);
			imageList.Images.Add(Properties.Resources.B16x16_Settings_Edit);

			settingsTabControl.ImageList = imageList;
			generalSettingsTabPage.ImageIndex = 0;
			colorsSettingTabPage.ImageIndex = 1;
			typeDefinitionsSettingsTabPage.ImageIndex = 2;

			SetGeneralBindings();
			SetColorBindings();
			SetTypeDefinitionBindings();

			if (NativeMethods.IsUnix())
			{
				fileAssociationGroupBox.Enabled = false;
				runAsAdminCheckBox.Enabled = false;
			}
			else
			{
				NativeMethodsWindows.SetButtonShield(createAssociationButton, true);
				NativeMethodsWindows.SetButtonShield(removeAssociationButton, true);
			}
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);

			GlobalWindowManager.AddWindow(this);
		}

		protected override void OnFormClosed(FormClosedEventArgs e)
		{
			base.OnFormClosed(e);

			GlobalWindowManager.RemoveWindow(this);
		}

		private void createAssociationButton_Click(object sender, EventArgs e)
		{
			WinUtil.RunElevated(PathUtil.LauncherExecutablePath, $"-{Constants.CommandLineOptions.FileExtRegister}");
		}

		private void removeAssociationButton_Click(object sender, EventArgs e)
		{
			WinUtil.RunElevated(PathUtil.LauncherExecutablePath, $"-{Constants.CommandLineOptions.FileExtUnregister}");
		}

		private static void SetBinding(IBindableComponent control, string propertyName, object dataSource, string dataMember)
		{
			Contract.Requires(control != null);
			Contract.Requires(propertyName != null);
			Contract.Requires(dataSource != null);
			Contract.Requires(dataMember != null);

			control.DataBindings.Add(propertyName, dataSource, dataMember, true, DataSourceUpdateMode.OnPropertyChanged);
		}

		private void SetGeneralBindings()
		{
			SetBinding(stayOnTopCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.StayOnTop));
			stayOnTopCheckBox.CheckedChanged += (_, _2) => GlobalWindowManager.Windows.ForEach(w => w.TopMost = stayOnTopCheckBox.Checked);

			SetBinding(showNodeAddressCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowNodeAddress));
			SetBinding(showNodeOffsetCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowNodeOffset));
			SetBinding(showTextCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowNodeText));
			SetBinding(highlightChangedValuesCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.HighlightChangedValues));

			SetBinding(showFloatCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentFloat));
			SetBinding(showIntegerCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentInteger));
			SetBinding(showPointerCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentPointer));
			SetBinding(showRttiCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentRtti));
			SetBinding(showSymbolsCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentSymbol));
			SetBinding(showStringCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentString));
			SetBinding(showPluginInfoCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.ShowCommentPluginInfo));
			SetBinding(runAsAdminCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.RunAsAdmin));
			SetBinding(randomizeWindowTitleCheckBox, nameof(CheckBox.Checked), settings, nameof(Settings.RandomizeWindowTitle));
		}

		private void SetColorBindings()
		{
			SetBinding(backgroundColorBox, nameof(ColorBox.Color), settings, nameof(Settings.BackgroundColor));

			SetBinding(nodeSelectedColorBox, nameof(ColorBox.Color), settings, nameof(Settings.SelectedColor));
			SetBinding(nodeHiddenColorBox, nameof(ColorBox.Color), settings, nameof(Settings.HiddenColor));
			SetBinding(nodeAddressColorBox, nameof(ColorBox.Color), settings, nameof(Settings.AddressColor));
			SetBinding(nodeOffsetColorBox, nameof(ColorBox.Color), settings, nameof(Settings.OffsetColor));
			SetBinding(nodeHexValueColorBox, nameof(ColorBox.Color), settings, nameof(Settings.HexColor));
			SetBinding(nodeTypeColorBox, nameof(ColorBox.Color), settings, nameof(Settings.TypeColor));
			SetBinding(nodeNameColorBox, nameof(ColorBox.Color), settings, nameof(Settings.NameColor));
			SetBinding(nodeValueColorBox, nameof(ColorBox.Color), settings, nameof(Settings.ValueColor));
			SetBinding(nodeIndexColorBox, nameof(ColorBox.Color), settings, nameof(Settings.IndexColor));
			SetBinding(nodeVTableColorBox, nameof(ColorBox.Color), settings, nameof(Settings.VTableColor));
			SetBinding(nodeCommentColorBox, nameof(ColorBox.Color), settings, nameof(Settings.CommentColor));
			SetBinding(nodeTextColorBox, nameof(ColorBox.Color), settings, nameof(Settings.TextColor));
			SetBinding(nodePluginColorBox, nameof(ColorBox.Color), settings, nameof(Settings.PluginColor));
		}

		private void SetTypeDefinitionBindings()
		{
			SetBinding(boolTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeBool));
			SetBinding(int8TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeInt8));
			SetBinding(int16TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeInt16));
			SetBinding(int32TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeInt32));
			SetBinding(int64TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeInt64));
			SetBinding(nintTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeNInt));
			SetBinding(uint8TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUInt8));
			SetBinding(uint16TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUInt16));
			SetBinding(uint32TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUInt32));
			SetBinding(uint64TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUInt64));
			SetBinding(nuintTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeNUInt));
			SetBinding(floatTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeFloat));
			SetBinding(doubleTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeDouble));
			SetBinding(vector2TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeVector2));
			SetBinding(vector3TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeVector3));
			SetBinding(vector4TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeVector4));
			SetBinding(matrix3x3TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeMatrix3x3));
			SetBinding(matrix3x4TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeMatrix3x4));
			SetBinding(matrix4x4TypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeMatrix4x4));
			SetBinding(utf8TextTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUtf8Text));
			SetBinding(utf16TextTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUtf16Text));
			SetBinding(utf32TextTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeUtf32Text));
			SetBinding(functionPtrTypeTextBox, nameof(TextBox.Text), typeMapping, nameof(CppTypeMapping.TypeFunctionPtr));
		}
	}
}

```

`ReClass.NET/Forms/SettingsForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ReClass.NET/Input/KeyboardHotkey.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;

namespace ReClassNET.Input
{
	public class KeyboardHotkey
	{
		private readonly HashSet<Keys> keys = new HashSet<Keys>();

		public IEnumerable<Keys> Keys => keys;

		public bool IsEmpty => keys.Count == 0;

		public void Clear() => keys.Clear();

		public bool AddKey(Keys key) => keys.Add(key);

		public bool Matches(Keys[] pressedKeys)
		{
			Contract.Requires(pressedKeys != null);

			if (keys.Count == 0 || keys.Count > pressedKeys.Length)
			{
				return false;
			}

			return keys.All(pressedKeys.Contains);
		}

		public KeyboardHotkey Clone()
		{
			var copy = new KeyboardHotkey();
			foreach (var key in Keys) copy.AddKey(key);
			return copy;
		}

		public override string ToString()
		{
			if (keys.Count == 0)
			{
				return string.Empty;
			}
			return keys.Select(k => k.ToString()).Aggregate((s1, s2) => $"{s1} + {s2}");
		}
	}
}

```

`ReClass.NET/Input/KeyboardInput.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Windows.Forms;

namespace ReClassNET.Input
{
	public class KeyboardInput : IDisposable
	{
		private readonly IntPtr handle;

		public KeyboardInput()
		{
			handle = Program.CoreFunctions.InitializeInput();
		}

		public void Dispose()
		{
			ReleaseUnmanagedResources();

			GC.SuppressFinalize(this);
		}

		~KeyboardInput()
		{
			ReleaseUnmanagedResources();
		}

		private void ReleaseUnmanagedResources()
		{
			Program.CoreFunctions.ReleaseInput(handle);
		}

		public Keys[] GetPressedKeys()
		{
			Contract.Ensures(Contract.Result<Keys[]>() != null);

			return Program.CoreFunctions.GetPressedKeys(handle);
		}
	}
}

```

`ReClass.NET/Logger/BaseLogger.cs`:

```cs
using Microsoft.SqlServer.MessageBox;
using System;
using System.Diagnostics.Contracts;

namespace ReClassNET.Logger
{
	public abstract class BaseLogger : ILogger
	{
		private readonly object sync = new object();

		public event NewLogEntryEventHandler NewLogEntry;

		public void Log(Exception ex)
		{
			Log(LogLevel.Error, ExceptionMessageBox.GetMessageText(ex), ex);
		}

		public void Log(LogLevel level, string message)
		{
			Log(level, message, null);
		}

		private void Log(LogLevel level, string message, Exception ex)
		{
			Contract.Requires(message != null);

			lock (sync)
			{
				NewLogEntry?.Invoke(level, message, ex);
			}
		}
	}
}

```

`ReClass.NET/Logger/GuiLogger.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Windows.Forms;
using ReClassNET.Forms;
using System;

namespace ReClassNET.Logger
{
	/// <summary>A logger which displays messages in a form.</summary>
	public class GuiLogger : BaseLogger
	{
		private readonly LogForm form;

		public LogLevel Level { get; set; } = LogLevel.Warning;

		public GuiLogger()
		{
			form = new LogForm();
			form.FormClosing += delegate (object sender, FormClosingEventArgs e)
			{
				form.Clear();

				form.Hide();

				e.Cancel = true;
			};

			NewLogEntry += OnNewLogEntry;
		}

		private void OnNewLogEntry(LogLevel level, string message, Exception ex)
		{
			Contract.Requires(message != null);

			if (level < Level)
			{
				return;
			}

			ShowForm();

			form.Add(level, message, ex);
		}

		public void ShowForm()
		{
			if (!form.Visible)
			{
				form.Show();

				form.BringToFront();
			}
		}
	}
}

```

`ReClass.NET/Logger/ILogger.cs`:

```cs
using System;
using System.Diagnostics.Contracts;

namespace ReClassNET.Logger
{
	public delegate void NewLogEntryEventHandler(LogLevel level, string message, Exception ex);

	[ContractClass(typeof(LoggerContract))]
	public interface ILogger
	{
		/// <summary>Gets triggered every time a new entry is created.</summary>
		event NewLogEntryEventHandler NewLogEntry;

		/// <summary>Logs the given exception. The <see cref="LogLevel"/> is always set to <see cref="LogLevel.Error"/>.</summary>
		/// <param name="ex">The exception to log.</param>
		void Log(Exception ex);

		/// <summary>Logs the given message.</summary>
		/// <param name="level">The level of the message.</param>
		/// <param name="message">The message to log.</param>
		void Log(LogLevel level, string message);
	}

	[ContractClassFor(typeof(ILogger))]
	internal abstract class LoggerContract : ILogger
	{
		public event NewLogEntryEventHandler NewLogEntry { add { throw new NotImplementedException(); } remove { } }

		public void Log(Exception ex)
		{
			Contract.Requires(ex != null);

			throw new NotImplementedException();
		}

		public void Log(LogLevel level, string message)
		{
			Contract.Requires(message != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Logger/LogLevel.cs`:

```cs
namespace ReClassNET.Logger
{
	public enum LogLevel
	{
		Debug,
		Information,
		Warning,
		Error
	}
}

```

`ReClass.NET/Logger/NullLogger.cs`:

```cs
using System;

namespace ReClassNET.Logger
{
	/// <summary>A logger that does nothing.</summary>
	public class NullLogger : ILogger
	{
		public event NewLogEntryEventHandler NewLogEntry { add { } remove { } }

		public void Log(Exception ex)
		{

		}

		public void Log(LogLevel level, string message)
		{

		}
	}
}

```

`ReClass.NET/Makefile`:

```
.PHONY: all clean debug clean_debug release clean_release update docker_debug docker_release podman_debug podman_release

all: debug release

clean: clean_debug clean_release

debug:
	msbuild /p:Configuration=Debug /p:Platform=x86 ReClass.NET.csproj
	msbuild /p:Configuration=Debug /p:Platform=x64 ReClass.NET.csproj

clean_debug:
	msbuild /t:Clean ReClass.NET.csproj

release:
	msbuild /p:Configuration=Release /p:Platform=x86 ReClass.NET.csproj
	msbuild /p:Configuration=Release /p:Platform=x64 ReClass.NET.csproj

clean_release:
	msbuild /t:Clean ReClass.NET.csproj

update:
	mono --runtime=v4.0 ../Dependencies/nuget.exe restore ReClass.NET.csproj -SolutionDirectory ../

docker_debug:
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Debug /p:Platform=x86 ReClass.NET.csproj"
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Debug /p:Platform=x64 ReClass.NET.csproj"

docker_release:
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Release /p:Platform=x86 ReClass.NET.csproj"
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Release /p:Platform=x64 ReClass.NET.csproj"

podman_debug:
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Debug /p:Platform=x86 ReClass.NET.csproj"
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Debug /p:Platform=x64 ReClass.NET.csproj"

podman_release:
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Release /p:Platform=x86 ReClass.NET.csproj"
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET && msbuild /p:Configuration=Release /p:Platform=x64 ReClass.NET.csproj"

```

`ReClass.NET/Memory/Disassembler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Runtime.InteropServices;
using ReClassNET.Core;
using ReClassNET.Extensions;

namespace ReClassNET.Memory
{
	public class Disassembler
	{
		// The maximum number of bytes of a x86-64 instruction.
		public const int MaximumInstructionLength = 15;

		private readonly CoreFunctionsManager coreFunctions;

		public Disassembler(CoreFunctionsManager coreFunctions)
		{
			Contract.Requires(coreFunctions != null);

			this.coreFunctions = coreFunctions;
		}

		/// <summary>Disassembles the code in the given range (<paramref name="address"/>, <paramref name="length"/>) in the remote process.</summary>
		/// <param name="process">The process to read from.</param>
		/// <param name="address">The address of the code.</param>
		/// <param name="length">The length of the code in bytes.</param>
		/// <returns>A list of <see cref="DisassembledInstruction"/>.</returns>
		public IReadOnlyList<DisassembledInstruction> RemoteDisassembleCode(IRemoteMemoryReader process, IntPtr address, int length)
		{
			Contract.Requires(process != null);
			Contract.Ensures(Contract.Result<IList<DisassembledInstruction>>() != null);

			return RemoteDisassembleCode(process, address, length, -1);
		}

		/// <summary>Disassembles the code in the given range (<paramref name="address"/>, <paramref name="length"/>) in the remote process.</summary>
		/// <param name="process">The process to read from.</param>
		/// <param name="address">The address of the code.</param>
		/// <param name="length">The length of the code in bytes.</param>
		/// <param name="maxInstructions">The maximum number of instructions to disassemble. If <paramref name="maxInstructions"/> is -1, all available instructions get returned.</param>
		/// <returns>A list of <see cref="DisassembledInstruction"/>.</returns>
		public IReadOnlyList<DisassembledInstruction> RemoteDisassembleCode(IRemoteMemoryReader process, IntPtr address, int length, int maxInstructions)
		{
			Contract.Requires(process != null);
			Contract.Ensures(Contract.Result<IList<DisassembledInstruction>>() != null);

			var buffer = process.ReadRemoteMemory(address, length);

			return DisassembleCode(buffer, address, maxInstructions);
		}

		/// <summary>Disassembles the code in the given data.</summary>
		/// <param name="data">The data to disassemble.</param>
		/// <param name="virtualAddress">The virtual address of the code. This allows to decode instructions located anywhere in memory even if they are not at their original place.</param>
		/// <param name="maxInstructions">The maximum number of instructions to disassemble. If <paramref name="maxInstructions"/> is -1, all available instructions get returned.</param>
		/// <returns>A list of <see cref="DisassembledInstruction"/>.</returns>
		public IReadOnlyList<DisassembledInstruction> DisassembleCode(byte[] data, IntPtr virtualAddress, int maxInstructions)
		{
			Contract.Requires(data != null);
			Contract.Ensures(Contract.Result<IList<DisassembledInstruction>>() != null);

			var handle = GCHandle.Alloc(data, GCHandleType.Pinned);
			try
			{
				var instructions = new List<DisassembledInstruction>();

				coreFunctions.DisassembleCode(handle.AddrOfPinnedObject(), data.Length, virtualAddress, false, (ref InstructionData instruction) =>
				{
					instructions.Add(new DisassembledInstruction(ref instruction));

					return maxInstructions == -1 || instructions.Count < maxInstructions;
				});

				return instructions;
			}
			finally
			{
				if (handle.IsAllocated)
				{
					handle.Free();
				}
			}
		}

		/// <summary>Disassembles the code in the given range (<paramref name="address"/>, <paramref name="maxLength"/>) in the remote process until the first 0xCC instruction.</summary>
		/// <param name="process">The process to read from.</param>
		/// <param name="address">The address of the code.</param>
		/// <param name="maxLength">The maximum maxLength of the code.</param>
		/// <returns>A list of <see cref="DisassembledInstruction"/> which belong to the function.</returns>
		public IReadOnlyList<DisassembledInstruction> RemoteDisassembleFunction(IRemoteMemoryReader process, IntPtr address, int maxLength)
		{
			Contract.Requires(process != null);
			Contract.Ensures(Contract.Result<IEnumerable<DisassembledInstruction>>() != null);

			var buffer = process.ReadRemoteMemory(address, maxLength);

			return DisassembleFunction(buffer, address);
		}

		/// <summary>Disassembles the code in the given data.</summary>
		/// <param name="data">The data to disassemble.</param>
		/// <param name="virtualAddress">The virtual address of the code. This allows to decode instructions located anywhere in memory even if they are not at their original place.</param>
		/// <returns>A list of <see cref="DisassembledInstruction"/> which belong to the function.</returns>
		public IReadOnlyList<DisassembledInstruction> DisassembleFunction(byte[] data, IntPtr virtualAddress)
		{
			Contract.Requires(data != null);
			Contract.Ensures(Contract.Result<IEnumerable<DisassembledInstruction>>() != null);

			var handle = GCHandle.Alloc(data, GCHandleType.Pinned);
			try
			{
				var instructions = new List<DisassembledInstruction>();

				// Read until first CC.
				coreFunctions.DisassembleCode(handle.AddrOfPinnedObject(), data.Length, virtualAddress, false, (ref InstructionData result) =>
				{
					if (result.Length == 1 && result.Data[0] == 0xCC)
					{
						return false;
					}

					instructions.Add(new DisassembledInstruction(ref result));

					return true;
				});

				return instructions;
			}
			finally
			{
				if (handle.IsAllocated)
				{
					handle.Free();
				}
			}
		}

		/// <summary>Tries to find and disassembles the instruction prior to the given address.</summary>
		/// <param name="process">The process to read from.</param>
		/// <param name="address">The address of the code.</param>
		/// <returns>The prior instruction.</returns>
		public DisassembledInstruction RemoteGetPreviousInstruction(IRemoteMemoryReader process, IntPtr address)
		{
			const int TotalBufferSize = 7 * MaximumInstructionLength;
			const int BufferShiftSize = 6 * MaximumInstructionLength;

			var buffer = process.ReadRemoteMemory(address - BufferShiftSize, TotalBufferSize);

			var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			try
			{
				var bufferAddress = handle.AddrOfPinnedObject();
				var targetBufferAddress = bufferAddress + BufferShiftSize;

				var instruction = default(InstructionData);

				foreach (var offset in new[]
				{
					6 * MaximumInstructionLength,
					4 * MaximumInstructionLength,
					2 * MaximumInstructionLength,
					1 * MaximumInstructionLength,
					14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
				})
				{
					var currentAddress = targetBufferAddress - offset;

					coreFunctions.DisassembleCode(currentAddress, offset + 1, address - offset, false, (ref InstructionData data) =>
					{
						var nextAddress = currentAddress + data.Length;
						if (nextAddress.CompareTo(targetBufferAddress) > 0)
						{
							return false;
						}

						instruction = data;

						currentAddress = nextAddress;

						return true;
					});

					if (currentAddress == targetBufferAddress)
					{
						return new DisassembledInstruction(ref instruction);
					}
				}

				return null;
			}
			finally
			{
				if (handle.IsAllocated)
				{
					handle.Free();
				}
			}
		}

		/// <summary>Tries to find the start address of the function <paramref name="address"/> points into.</summary>
		/// <param name="process">The process to read from.</param>
		/// <param name="address">The address inside the function.</param>
		/// <returns>The start address of the function (maybe) or <see cref="IntPtr.Zero"/> if no start address could be found.</returns>
		public IntPtr RemoteGetFunctionStartAddress(IRemoteMemoryReader process, IntPtr address)
		{
			const int BufferLength = 512;

			var buffer = new byte[2 + BufferLength + 2 + 1];

			for (var i = 1; i <= 10; ++i)
			{
				if (!process.ReadRemoteMemoryIntoBuffer(address - i * BufferLength - 2, ref buffer))
				{
					return IntPtr.Zero;
				}

				for (var o = BufferLength + 4; o > 0; --o)
				{
					// Search for two CC in a row.
					if (buffer[o] == 0xCC && buffer[o - 1] == 0xCC)
					{
						var start = address - i * BufferLength + o - 1;

						// Check if the two previous instructions are really a CC.
						var prevInstruction = RemoteGetPreviousInstruction(process, start);
						if (prevInstruction.Length == 1 && prevInstruction.Data[0] == 0xCC)
						{
							prevInstruction = RemoteGetPreviousInstruction(process, start - 1);
							if (prevInstruction.Length == 1 && prevInstruction.Data[0] == 0xCC)
							{
								// Disassemble the code from the start and check if the instructions sum up to address.
								var totalInstructionLength = RemoteDisassembleCode(process, start, address.Sub(start).ToInt32())
									.Sum(ins => ins.Length);
								if (start + totalInstructionLength == address)
								{
									return start;
								}
							}
							else
							{
								o -= prevInstruction.Length;
							}
						}
						else
						{
							o -= prevInstruction.Length;
						}
					}
				}
			}

			return IntPtr.Zero;
		}
	}

	public class DisassembledInstruction
	{
		public IntPtr Address { get; set; }
		public int Length { get; set; }
		public byte[] Data { get; set; }
		public string Instruction { get; set; }

		public bool IsValid => Length > 0;

		public DisassembledInstruction(ref InstructionData data)
		{
			Address = data.Address;
			Length = data.Length;
			Data = data.Data;
			Instruction = data.Instruction;
		}

		public override string ToString() => $"{Address.ToString(Constants.AddressHexFormat)} - {Instruction}";
	}
}

```

`ReClass.NET/Memory/Dumper.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.IO;

namespace ReClassNET.Memory
{
	public static class Dumper
	{
		/// <summary>Dumps a chunk of memory to the given stream.</summary>
		/// <param name="reader">The memory reader to use.</param>
		/// <param name="address">The begin of the chunk.</param>
		/// <param name="size">The size of the chunk.</param>
		/// <param name="stream">The stream to dump to.</param>
		public static void DumpRaw(IRemoteMemoryReader reader, IntPtr address, int size, Stream stream)
		{
			Contract.Requires(size >= 0);
			Contract.Requires(stream != null);

			var data = reader.ReadRemoteMemory(address, size);

			stream.Write(data, 0, data.Length);
		}

		/// <summary>Dumps a section to the given stream.</summary>
		/// <param name="reader">The memory reader to use.</param>
		/// <param name="section">The section to dump.</param>
		/// <param name="stream">The stream to dump to.</param>
		public static void DumpSection(IRemoteMemoryReader reader, Section section, Stream stream)
		{
			Contract.Requires(section != null);
			Contract.Requires(stream != null);

			DumpRaw(reader, section.Start, section.Size.ToInt32(), stream);
		}

		/// <summary>Dumps a module to the given stream. The section headers of the pe header get fixed to build a valid pe file.</summary>
		/// <param name="reader">The memory reader to use.</param>
		/// <param name="module">The module to dump.</param>
		/// <param name="stream">The stream to dump to.</param>
		public static void DumpModule(IRemoteMemoryReader reader, Module module, Stream stream)
		{
			Contract.Requires(module != null);
			Contract.Requires(stream != null);

			var data = reader.ReadRemoteMemory(module.Start, module.Size.ToInt32());

			SimplePeHeader.FixSectionHeaders(data);

			stream.Write(data, 0, data.Length);
		}
	}
}

```

`ReClass.NET/Memory/IProcessReader.cs`:

```cs
using System;
using System.Collections.Generic;

namespace ReClassNET.Memory
{
	public interface IProcessReader : IRemoteMemoryReader
	{
		Section GetSectionToPointer(IntPtr address);

		Module GetModuleToPointer(IntPtr address);

		Module GetModuleByName(string name);

		bool EnumerateRemoteSectionsAndModules(out List<Section> sections, out List<Module> modules);
	}
}

```

`ReClass.NET/Memory/IRemoteMemoryReader.cs`:

```cs
using System;
using ReClassNET.Util.Conversion;

namespace ReClassNET.Memory
{
	public interface IRemoteMemoryReader
	{
		EndianBitConverter BitConverter { get; set; }

		/// <summary>Reads remote memory from the address into the buffer.</summary>
		/// <param name="address">The address to read from.</param>
		/// <param name="buffer">[out] The data buffer to fill. If the remote process is not valid, the buffer will get filled with zeros.</param>
		bool ReadRemoteMemoryIntoBuffer(IntPtr address, ref byte[] buffer);

		/// <summary>Reads remote memory from the address into the buffer.</summary>
		/// <param name="address">The address to read from.</param>
		/// <param name="buffer">[out] The data buffer to fill. If the remote process is not valid, the buffer will get filled with zeros.</param>
		/// <param name="offset">The offset in the data.</param>
		/// <param name="length">The number of bytes to read.</param>
		bool ReadRemoteMemoryIntoBuffer(IntPtr address, ref byte[] buffer, int offset, int length);

		/// <summary>Reads <paramref name="size"/> bytes from the address in the remote process.</summary>
		/// <param name="address">The address to read from.</param>
		/// <param name="size">The size in bytes to read.</param>
		/// <returns>An array of bytes.</returns>
		byte[] ReadRemoteMemory(IntPtr address, int size);

		/// <summary>Reads remote runtime type information for the given address from the remote process.</summary>
		/// <param name="address">The address.</param>
		/// <returns>A string containing the runtime type information or null if no information could get found.</returns>
		string ReadRemoteRuntimeTypeInformation(IntPtr address);
	}
}

```

`ReClass.NET/Memory/IRemoteMemoryWriter.cs`:

```cs
using System;
using System.Text;
using ReClassNET.Util.Conversion;

namespace ReClassNET.Memory
{
	public interface IRemoteMemoryWriter
	{
		EndianBitConverter BitConverter { get; set; }

		/// <summary>Writes the given <paramref name="data"/> to the <paramref name="address"/> in the remote process.</summary>
		/// <param name="address">The address to write to.</param>
		/// <param name="data">The data to write.</param>
		/// <returns>True if it succeeds, false if it fails.</returns>
		bool WriteRemoteMemory(IntPtr address, byte[] data);
	}
}

```

`ReClass.NET/Memory/MemoryBuffer.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Text;
using ReClassNET.Extensions;
using ReClassNET.Util.Conversion;

namespace ReClassNET.Memory
{
	public class MemoryBuffer
	{
		private byte[] data;
		private byte[] historyData;

		private bool hasHistory;

		public byte[] RawData => data;

		public EndianBitConverter BitConverter { get; set; } = EndianBitConverter.System;

		public int Size
		{
			get => data.Length;
			set
			{
				if (value >= 0 && value != data.Length)
				{
					data = new byte[value];
					historyData = new byte[value];
					
					hasHistory = false;

					ContainsValidData = false;
				}
			}
		}

		public int Offset { get; set; }

		public bool ContainsValidData { get; private set; }

		[ContractInvariantMethod]
		private void ObjectInvariants()
		{
			Contract.Invariant(data != null);
			Contract.Invariant(historyData != null);
		}

		public MemoryBuffer()
		{
			Contract.Ensures(data != null);
			Contract.Ensures(historyData != null);

			data = Array.Empty<byte>();
			historyData = Array.Empty<byte>();
		}

		public MemoryBuffer Clone()
		{
			Contract.Ensures(Contract.Result<MemoryBuffer>() != null);

			return new MemoryBuffer
			{
				data = data,
				historyData = historyData,
				hasHistory = hasHistory,

				BitConverter = BitConverter,
				ContainsValidData = ContainsValidData,
				Offset = Offset
			};
		}

		public void UpdateFrom(IRemoteMemoryReader reader, IntPtr address)
		{
			if (reader == null)
			{
				data.FillWithZero();

				hasHistory = false;

				return;
			}

			Array.Copy(data, historyData, data.Length);

			hasHistory = ContainsValidData;

			BitConverter = reader.BitConverter;

			ContainsValidData = reader.ReadRemoteMemoryIntoBuffer(address, ref data);
			if (!ContainsValidData)
			{
				data.FillWithZero();

				hasHistory = false;
			}
		}

		public byte[] ReadBytes(int offset, int length)
		{
			Contract.Requires(offset >= 0);
			Contract.Requires(length >= 0);

			var buffer = new byte[length];

			ReadBytes(offset, buffer);

			return buffer;
		}

		public void ReadBytes(int offset, byte[] buffer)
		{
			Contract.Requires(offset >= 0);
			Contract.Requires(buffer != null);

			offset = Offset + offset;
			if (offset + buffer.Length > data.Length)
			{
				return;
			}

			Array.Copy(data, offset, buffer, 0, buffer.Length);
		}

		#region Read Primitive Types

		/// <summary>Reads a <see cref="sbyte"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="sbyte"/> or 0 if the offset is outside the data.</returns>
		public sbyte ReadInt8(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(sbyte) > data.Length)
			{
				return default;
			}

			return (sbyte)data[offset];
		}

		/// <summary>Reads a <see cref="byte"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="byte"/> or 0 if the offset is outside the data.</returns>
		public byte ReadUInt8(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(byte) > data.Length)
			{
				return default;
			}

			return data[offset];
		}

		/// <summary>Reads a <see cref="short"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="short"/> or 0 if the offset is outside the data.</returns>
		public short ReadInt16(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(short) > data.Length)
			{
				return default;
			}

			return BitConverter.ToInt16(data, offset);
		}

		/// <summary>Reads a <see cref="ushort"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="ushort"/> or 0 if the offset is outside the data.</returns>
		public ushort ReadUInt16(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(ushort) > data.Length)
			{
				return default;
			}

			return BitConverter.ToUInt16(data, offset);
		}

		/// <summary>Reads a <see cref="int"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="int"/> or 0 if the offset is outside the data.</returns>
		public int ReadInt32(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(int) > data.Length)
			{
				return default;
			}

			return BitConverter.ToInt32(data, offset);
		}

		/// <summary>Reads a <see cref="uint"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="uint"/> or 0 if the offset is outside the data.</returns>
		public uint ReadUInt32(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(uint) > data.Length)
			{
				return default;
			}

			return BitConverter.ToUInt32(data, offset);
		}

		/// <summary>Reads a <see cref="long"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="long"/> or 0 if the offset is outside the data.</returns>
		public long ReadInt64(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(long) > data.Length)
			{
				return default;
			}

			return BitConverter.ToInt64(data, offset);
		}

		/// <summary>Reads a <see cref="ulong"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="ulong"/> or 0 if the offset is outside the data.</returns>
		public ulong ReadUInt64(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(ulong) > data.Length)
			{
				return default;
			}

			return BitConverter.ToUInt64(data, offset);
		}

		/// <summary>Reads a <see cref="float"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="float"/> or 0 if the offset is outside the data.</returns>
		public float ReadFloat(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(float) > data.Length)
			{
				return default;
			}

			return BitConverter.ToSingle(data, offset);
		}

		/// <summary>Reads a <see cref="double"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="double"/> or 0 if the offset is outside the data.</returns>
		public double ReadDouble(int offset)
		{
			Contract.Requires(offset >= 0);

			offset = Offset + offset;
			if (offset + sizeof(double) > data.Length)
			{
				return default;
			}

			return BitConverter.ToDouble(data, offset);
		}

		/// <summary>Reads a <see cref="IntPtr"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="IntPtr"/> or 0 if the offset is outside the data.</returns>
		public IntPtr ReadIntPtr(int offset)
		{
			Contract.Requires(offset >= 0);

#if RECLASSNET64
			return (IntPtr)ReadInt64(offset);
#else
			return (IntPtr)ReadInt32(offset);
#endif
		}

		/// <summary>Reads a <see cref="UIntPtr"/> from the specific offset.</summary>
		/// <param name="offset">The offset into the data.</param>
		/// <returns>The data read as <see cref="UIntPtr"/> or 0 if the offset is outside the data.</returns>
		public UIntPtr ReadUIntPtr(int offset)
		{
			Contract.Requires(offset >= 0);

#if RECLASSNET64
			return (UIntPtr)ReadUInt64(offset);
#else
			return (UIntPtr)ReadUInt32(offset);
#endif
		}

		#endregion

		public string ReadString(Encoding encoding, int offset, int length)
		{
			Contract.Requires(encoding != null);
			Contract.Requires(offset >= 0);
			Contract.Requires(length >= 0);
			Contract.Ensures(Contract.Result<string>() != null);

			if (Offset + offset + length > data.Length)
			{
				length = Math.Max(data.Length - Offset - offset, 0);
			}

			if (length <= 0)
			{
				return string.Empty;
			}

			var sb = new StringBuilder(encoding.GetString(data, Offset + offset, length));
			for (var i = 0; i < sb.Length; ++i)
			{
				if (!sb[i].IsPrintable())
				{
					sb[i] = '.';
				}
			}
			return sb.ToString();
		}

		public bool HasChanged(int offset, int length)
		{
			if (!hasHistory)
			{
				return false;
			}

			if (Offset + offset + length > data.Length)
			{
				return false;
			}

			var end = Offset + offset + length;

			for (var i = Offset + offset; i < end; ++i)
			{
				if (data[i] != historyData[i])
				{
					return true;
				}
			}

			return false;
		}
	}
}

```

`ReClass.NET/Memory/Module.cs`:

```cs
using System;

namespace ReClassNET.Memory
{
	public class Module
	{
		public IntPtr Start { get; set; }
		public IntPtr End { get; set; }
		public IntPtr Size { get; set; }
		public string Name { get; set; }
		public string Path { get; set; }
	}
}

```

`ReClass.NET/Memory/NodeDissector.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using ReClassNET.Extensions;
using ReClassNET.Nodes;

namespace ReClassNET.Memory
{
	public class NodeDissector
	{
		public static void DissectNodes(IEnumerable<BaseHexNode> nodes, IProcessReader reader, MemoryBuffer memory)
		{
			Contract.Requires(nodes != null);
			Contract.Requires(Contract.ForAll(nodes, n => n != null));
			Contract.Requires(memory != null);

			foreach (var node in nodes)
			{
				if (GuessNode(node, reader, memory, out var guessedNode))
				{
					node.GetParentContainer()?.ReplaceChildNode(node, guessedNode);
				}
			}
		}

		public static bool GuessNode(BaseHexNode node, IProcessReader reader, MemoryBuffer memory, out BaseNode guessedNode)
		{
			Contract.Requires(node != null);
			Contract.Requires(memory != null);

			guessedNode = null;

			var offset = node.Offset;
			var is4ByteAligned = offset % 4 == 0;
			var is8ByteAligned = offset % 8 == 0;

			// The node is not aligned, skip it.
			if (!is4ByteAligned)
			{
				return false;
			}

			var data64 = new UInt64FloatDoubleData
			{
				Raw1 = memory.ReadInt32(offset),
				Raw2 = memory.ReadInt32(offset + sizeof(int))
			}; ;
			var data32 = new UInt32FloatData
			{
				Raw = memory.ReadInt32(offset)
			};

			var raw = memory.ReadBytes(offset, node.MemorySize);
			if (raw.InterpretAsSingleByteCharacter().IsLikelyPrintableData())
			{
				guessedNode = new Utf8TextNode();

				return true;
			}
			if (raw.InterpretAsDoubleByteCharacter().IsLikelyPrintableData())
			{
				guessedNode = new Utf16TextNode();

				return true;
			}

#if RECLASSNET64
			if (is8ByteAligned)
			{
				if (GuessPointerNode(data64.IntPtr, reader, out guessedNode))
				{
					return true;
				}
			}
#else
			if (GuessPointerNode(data32.IntPtr, reader, out guessedNode))
			{
				return true;
			}
#endif

			// 0 could be anything.
			if (data32.IntValue != 0)
			{
				// If the data represents a reasonable range, it could be a float.
				if (-999999.0f <= data32.FloatValue && data32.FloatValue <= 999999.0f && !data32.FloatValue.IsNearlyEqual(0.0f, 0.001f))
				{
					guessedNode = new FloatNode();

					return true;
				}

				if (-999999 <= data32.IntValue && data32.IntValue <= 999999)
				{
					guessedNode = new Int32Node();

					return true;
				}
			}

			if (is8ByteAligned)
			{
				if (data64.LongValue != 0)
				{
					// If the data represents a reasonable range, it could be a double.
					if (-999999.0 <= data64.DoubleValue && data64.DoubleValue <= 999999.0 && !data64.DoubleValue.IsNearlyEqual(0.0, 0.001))
					{
						guessedNode = new DoubleNode();

						return true;
					}
				}
			}

			return false;
		}

		private static bool GuessPointerNode(IntPtr address, IProcessReader process, out BaseNode node)
		{
			Contract.Requires(process != null);

			node = null;

			if (address.IsNull())
			{
				return false;
			}

			var section = process.GetSectionToPointer(address);
			if (section == null)
			{
				return false;
			}

			if (section.Category == SectionCategory.CODE) // If the section contains code, it should be a function pointer.
			{
				node = new FunctionPtrNode();

				return true;
			}
			if (section.Category == SectionCategory.DATA || section.Category == SectionCategory.HEAP) // If the section contains data, it is at least a pointer to a class or something.
			{
				// Check if it is a vtable. Check if the first 3 values are pointers to a code section.
				if (process.GetSectionToPointer(process.ReadRemoteIntPtr(address))?.Category == SectionCategory.CODE
				    && process.GetSectionToPointer(process.ReadRemoteIntPtr(address + IntPtr.Size))?.Category == SectionCategory.CODE
				    && process.GetSectionToPointer(process.ReadRemoteIntPtr(address + 2 * IntPtr.Size))?.Category == SectionCategory.CODE)
				{
					node = new VirtualMethodTableNode();

					return true;
				}

				// Check if it is a string.
				var data = process.ReadRemoteMemory(address, IntPtr.Size * 2);
				if (data.Take(IntPtr.Size).InterpretAsSingleByteCharacter().IsLikelyPrintableData())
				{
					node = new Utf8TextPtrNode();

					return true;
				}
				if (data.InterpretAsDoubleByteCharacter().IsLikelyPrintableData())
				{
					node = new Utf16TextPtrNode();

					return true;
				}

				// Now it could be a pointer to something else but we can't tell. :(
				node = new PointerNode();

				return true;
			}

			return false;
		}
	}
}

```

`ReClass.NET/Memory/ProcessInfo.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Native;

namespace ReClassNET.Memory
{
	public class ProcessInfo
	{
		public IntPtr Id { get; }
		public string Name { get; }
		public string Path { get; }
		public Image Icon => icon.Value;

		private readonly Lazy<Image> icon;

		public ProcessInfo(IntPtr id, string name, string path)
		{
			Contract.Requires(name != null);
			Contract.Requires(path != null);

			Id = id;
			Name = name;
			Path = path;
			icon = new Lazy<Image>(() =>
			{
				using var i = NativeMethods.GetIconForFile(Path);
				return i?.ToBitmap();
			});
		}
	}
}

```

`ReClass.NET/Memory/RemoteProcess.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ReClassNET.AddressParser;
using ReClassNET.Core;
using ReClassNET.Debugger;
using ReClassNET.Extensions;
using ReClassNET.Native;
using ReClassNET.Symbols;
using ReClassNET.Util.Conversion;

namespace ReClassNET.Memory
{
	public delegate void RemoteProcessEvent(RemoteProcess sender);

	public class RemoteProcess : IDisposable, IRemoteMemoryReader, IRemoteMemoryWriter, IProcessReader
	{
		private readonly object processSync = new object();

		private readonly CoreFunctionsManager coreFunctions;

		private readonly RemoteDebugger debugger;

		private readonly Dictionary<string, Func<RemoteProcess, IntPtr>> formulaCache = new Dictionary<string, Func<RemoteProcess, IntPtr>>();

		private readonly Dictionary<IntPtr, string> rttiCache = new Dictionary<IntPtr, string>();

		private readonly List<Module> modules = new List<Module>();

		private readonly List<Section> sections = new List<Section>();

		private readonly SymbolStore symbols = new SymbolStore();

		private ProcessInfo process;
		private IntPtr handle;

		/// <summary>Event which gets invoked when a process was opened.</summary>
		public event RemoteProcessEvent ProcessAttached;

		/// <summary>Event which gets invoked before a process gets closed.</summary>
		public event RemoteProcessEvent ProcessClosing;

		/// <summary>Event which gets invoked after a process was closed.</summary>
		public event RemoteProcessEvent ProcessClosed;

		public CoreFunctionsManager CoreFunctions => coreFunctions;

		public RemoteDebugger Debugger => debugger;

		public ProcessInfo UnderlayingProcess => process;

		public SymbolStore Symbols => symbols;

		public EndianBitConverter BitConverter { get; set; } = EndianBitConverter.System;

		/// <summary>Gets a copy of the current modules list. This list may change if the remote process (un)loads a module.</summary>
		public IEnumerable<Module> Modules
		{
			get
			{
				lock (modules)
				{
					return new List<Module>(modules);
				}
			}
		}

		/// <summary>Gets a copy of the current sections list. This list may change if the remote process (un)loads a section.</summary>
		public IEnumerable<Section> Sections
		{
			get
			{
				lock (sections)
				{
					return new List<Section>(sections);
				}
			}
		}

		/// <summary>A map of named addresses.</summary>
		public Dictionary<IntPtr, string> NamedAddresses { get; } = new Dictionary<IntPtr, string>();

		public bool IsValid => process != null && coreFunctions.IsProcessValid(handle);

		public RemoteProcess(CoreFunctionsManager coreFunctions)
		{
			Contract.Requires(coreFunctions != null);

			this.coreFunctions = coreFunctions;

			debugger = new RemoteDebugger(this);
		}

		public void Dispose()
		{
			Close();
		}

		/// <summary>Opens the given process to gather informations from.</summary>
		/// <param name="info">The process information.</param>
		public void Open(ProcessInfo info)
		{
			Contract.Requires(info != null);

			if (process != info)
			{
				lock (processSync)
				{
					Close();

					rttiCache.Clear();

					process = info;

					handle = coreFunctions.OpenRemoteProcess(process.Id, ProcessAccess.Full);
				}

				ProcessAttached?.Invoke(this);
			}
		}

		/// <summary>Closes the underlaying process. If the debugger is attached, it will automaticly detached.</summary>
		public void Close()
		{
			if (process != null)
			{
				ProcessClosing?.Invoke(this);

				lock (processSync)
				{
					debugger.Terminate();

					coreFunctions.CloseRemoteProcess(handle);

					handle = IntPtr.Zero;

					process = null;
				}

				ProcessClosed?.Invoke(this);
			}
		}

		#region ReadMemory

		public bool ReadRemoteMemoryIntoBuffer(IntPtr address, ref byte[] buffer)
		{
			Contract.Requires(buffer != null);
			Contract.Ensures(Contract.ValueAtReturn(out buffer) != null);

			return ReadRemoteMemoryIntoBuffer(address, ref buffer, 0, buffer.Length);
		}

		public bool ReadRemoteMemoryIntoBuffer(IntPtr address, ref byte[] buffer, int offset, int length)
		{
			Contract.Requires(buffer != null);
			Contract.Requires(offset >= 0);
			Contract.Requires(length >= 0);
			Contract.Requires(offset + length <= buffer.Length);
			Contract.Ensures(Contract.ValueAtReturn(out buffer) != null);
			Contract.EndContractBlock();

			if (!IsValid)
			{
				Close();

				buffer.FillWithZero();

				return false;
			}

			return coreFunctions.ReadRemoteMemory(handle, address, ref buffer, offset, length);
		}

		public byte[] ReadRemoteMemory(IntPtr address, int size)
		{
			Contract.Requires(size >= 0);
			Contract.Ensures(Contract.Result<byte[]>() != null);

			var data = new byte[size];
			ReadRemoteMemoryIntoBuffer(address, ref data);
			return data;
		}

		public string ReadRemoteRuntimeTypeInformation(IntPtr address)
		{
			if (address.MayBeValid())
			{
				if (!rttiCache.TryGetValue(address, out var rtti))
				{
					var objectLocatorPtr = this.ReadRemoteIntPtr(address - IntPtr.Size);
					if (objectLocatorPtr.MayBeValid())
					{

#if RECLASSNET64
						rtti = ReadRemoteRuntimeTypeInformation64(objectLocatorPtr);
#else
						rtti = ReadRemoteRuntimeTypeInformation32(objectLocatorPtr);
#endif

						rttiCache[address] = rtti;
					}
				}
				return rtti;
			}

			return null;
		}

		private string ReadRemoteRuntimeTypeInformation32(IntPtr address)
		{
			var classHierarchyDescriptorPtr = this.ReadRemoteIntPtr(address + 0x10);
			if (classHierarchyDescriptorPtr.MayBeValid())
			{
				var baseClassCount = this.ReadRemoteInt32(classHierarchyDescriptorPtr + 8);
				if (baseClassCount > 0 && baseClassCount < 25)
				{
					var baseClassArrayPtr = this.ReadRemoteIntPtr(classHierarchyDescriptorPtr + 0xC);
					if (baseClassArrayPtr.MayBeValid())
					{
						var sb = new StringBuilder();
						for (var i = 0; i < baseClassCount; ++i)
						{
							var baseClassDescriptorPtr = this.ReadRemoteIntPtr(baseClassArrayPtr + (4 * i));
							if (baseClassDescriptorPtr.MayBeValid())
							{
								var typeDescriptorPtr = this.ReadRemoteIntPtr(baseClassDescriptorPtr);
								if (typeDescriptorPtr.MayBeValid())
								{
									var name = this.ReadRemoteStringUntilFirstNullCharacter(typeDescriptorPtr + 0x0C, Encoding.UTF8, 60);
									if (name.EndsWith("@@"))
									{
										name = NativeMethods.UndecorateSymbolName("?" + name);
									}

									sb.Append(name);
									sb.Append(" : ");

									continue;
								}
							}

							break;
						}

						if (sb.Length != 0)
						{
							sb.Length -= 3;

							return sb.ToString();
						}
					}
				}
			}

			return null;
		}

		private string ReadRemoteRuntimeTypeInformation64(IntPtr address)
		{
			int baseOffset = this.ReadRemoteInt32(address + 0x14);
			if (baseOffset != 0)
			{
				var baseAddress = address - baseOffset;

				var classHierarchyDescriptorOffset = this.ReadRemoteInt32(address + 0x10);
				if (classHierarchyDescriptorOffset != 0)
				{
					var classHierarchyDescriptorPtr = baseAddress + classHierarchyDescriptorOffset;

					var baseClassCount = this.ReadRemoteInt32(classHierarchyDescriptorPtr + 0x08);
					if (baseClassCount > 0 && baseClassCount < 25)
					{
						var baseClassArrayOffset = this.ReadRemoteInt32(classHierarchyDescriptorPtr + 0x0C);
						if (baseClassArrayOffset != 0)
						{
							var baseClassArrayPtr = baseAddress + baseClassArrayOffset;

							var sb = new StringBuilder();
							for (var i = 0; i < baseClassCount; ++i)
							{
								var baseClassDescriptorOffset = this.ReadRemoteInt32(baseClassArrayPtr + (4 * i));
								if (baseClassDescriptorOffset != 0)
								{
									var baseClassDescriptorPtr = baseAddress + baseClassDescriptorOffset;

									var typeDescriptorOffset = this.ReadRemoteInt32(baseClassDescriptorPtr);
									if (typeDescriptorOffset != 0)
									{
										var typeDescriptorPtr = baseAddress + typeDescriptorOffset;

										var name = this.ReadRemoteStringUntilFirstNullCharacter(typeDescriptorPtr + 0x14, Encoding.UTF8, 60);
										if (string.IsNullOrEmpty(name))
										{
											break;
										}

										if (name.EndsWith("@@"))
										{
											name = NativeMethods.UndecorateSymbolName("?" + name);
										}

										sb.Append(name);
										sb.Append(" : ");

										continue;
									}
								}

								break;
							}

							if (sb.Length != 0)
							{
								sb.Length -= 3;

								return sb.ToString();
							}
						}
					}
				}
			}

			return null;
		}

		#endregion

		#region WriteMemory

		public bool WriteRemoteMemory(IntPtr address, byte[] data)
		{
			Contract.Requires(data != null);

			if (!IsValid)
			{
				return false;
			}

			return coreFunctions.WriteRemoteMemory(handle, address, ref data, 0, data.Length);
		}

		#endregion

		public Section GetSectionToPointer(IntPtr address)
		{
			lock (sections)
			{
				var index = sections.BinarySearch(s => address.CompareToRange(s.Start, s.End));
				return index < 0 ? null : sections[index];
			}
		}

		public Module GetModuleToPointer(IntPtr address)
		{
			lock (modules)
			{
				var index = modules.BinarySearch(m => address.CompareToRange(m.Start, m.End));
				return index < 0 ? null : modules[index];
			}
		}

		public Module GetModuleByName(string name)
		{
			lock (modules)
			{
				return modules
					.FirstOrDefault(m => m.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase));
			}
		}

		/// <summary>Tries to map the given address to a section or a module of the process.</summary>
		/// <param name="address">The address to map.</param>
		/// <returns>The named address or null if no mapping exists.</returns>
		public string GetNamedAddress(IntPtr address)
		{
			if (NamedAddresses.TryGetValue(address, out var namedAddress))
			{
				return namedAddress;
			}

			var section = GetSectionToPointer(address);
			if (section != null)
			{
				if (section.Category == SectionCategory.CODE || section.Category == SectionCategory.DATA)
				{
					// Code and Data sections belong to a module.
					return $"<{section.Category}>{section.ModuleName}.{address.ToString("X")}";
				}
				if (section.Category == SectionCategory.HEAP)
				{
					return $"<HEAP>{address.ToString("X")}";
				}
			}
			var module = GetModuleToPointer(address);
			if (module != null)
			{
				return $"{module.Name}.{address.ToString("X")}";
			}
			return null;
		}

		public bool EnumerateRemoteSectionsAndModules(out List<Section> _sections, out List<Module> _modules)
		{
			if (!IsValid)
			{
				_sections = null;
				_modules = null;

				return false;
			}

			_sections = new List<Section>();
			_modules = new List<Module>();

			coreFunctions.EnumerateRemoteSectionsAndModules(handle, _sections.Add, _modules.Add);

			return true;
		}

		/// <summary>Updates the process informations.</summary>
		public void UpdateProcessInformations()
		{
			UpdateProcessInformationsAsync().Wait();
		}

		/// <summary>Updates the process informations asynchronous.</summary>
		/// <returns>The Task.</returns>
		public Task UpdateProcessInformationsAsync()
		{
			Contract.Ensures(Contract.Result<Task>() != null);

			if (!IsValid)
			{
				lock (modules)
				{
					modules.Clear();
				}
				lock (sections)
				{
					sections.Clear();
				}

				// TODO: Mono doesn't support Task.CompletedTask at the moment.
				//return Task.CompletedTask;
				return Task.FromResult(true);
			}

			return Task.Run(() =>
			{
				EnumerateRemoteSectionsAndModules(out var newSections, out var newModules);

				newModules.Sort((m1, m2) => m1.Start.CompareTo(m2.Start));
				newSections.Sort((s1, s2) => s1.Start.CompareTo(s2.Start));

				lock (modules)
				{
					modules.Clear();
					modules.AddRange(newModules);
				}
				lock (sections)
				{
					sections.Clear();
					sections.AddRange(newSections);
				}
			});
		}

		/// <summary>Parse the address formula.</summary>
		/// <param name="addressFormula">The address formula.</param>
		/// <returns>The result of the parsed address or <see cref="IntPtr.Zero"/>.</returns>
		public IntPtr ParseAddress(string addressFormula)
		{
			Contract.Requires(addressFormula != null);

			if (!formulaCache.TryGetValue(addressFormula, out var func))
			{
				var expression = Parser.Parse(addressFormula);

				func = DynamicCompiler.CompileExpression(expression);

				formulaCache.Add(addressFormula, func);
			}

			return func(this);
		}

		/// <summary>Loads all symbols asynchronous.</summary>
		/// <param name="progress">The progress reporter is called for every module. Can be null.</param>
		/// <param name="token">The token used to cancel the task.</param>
		/// <returns>The task.</returns>
		public Task LoadAllSymbolsAsync(IProgress<Tuple<Module, IReadOnlyList<Module>>> progress, CancellationToken token)
		{
			List<Module> copy;
			lock (modules)
			{
				copy = modules.ToList();
			}

			// Try to resolve all symbols in a background thread. This can take a long time because symbols are downloaded from the internet.
			// The COM objects can only be used in the thread they were created so we can't use them.
			// Thats why an other task loads the real symbols afterwards in the UI thread context.
			return Task.Run(
				() =>
				{
					foreach (var module in copy)
					{
						token.ThrowIfCancellationRequested();

						progress?.Report(Tuple.Create<Module, IReadOnlyList<Module>>(module, copy));

						Symbols.TryResolveSymbolsForModule(module);
					}
				},
				token
			)
			.ContinueWith(
				_ =>
				{
					foreach (var module in copy)
					{
						token.ThrowIfCancellationRequested();

						try
						{
							Symbols.LoadSymbolsForModule(module);
						}
						catch
						{
							//ignore
						}
					}
				},
				token,
				TaskContinuationOptions.None,
				TaskScheduler.FromCurrentSynchronizationContext()
			);
		}

		public void ControlRemoteProcess(ControlRemoteProcessAction action)
		{
			if (!IsValid)
			{
				return;
			}

			coreFunctions.ControlRemoteProcess(handle, action);
		}
	}
}

```

`ReClass.NET/Memory/Section.cs`:

```cs
using System;

namespace ReClassNET.Memory
{
	public enum SectionCategory
	{
		Unknown,
		CODE,
		DATA,
		HEAP
	}

	[Flags]
	public enum SectionProtection
	{
		NoAccess = 0,

		Read = 1,
		Write = 2,
		CopyOnWrite = 4,
		Execute = 8,

		Guard = 16
	}

	public enum SectionType
	{
		Unknown,

		Private,
		Mapped,
		Image
	}

	public class Section
	{
		public IntPtr Start { get; set; }
		public IntPtr End { get; set; }
		public IntPtr Size { get; set; }
		public string Name { get; set; }
		public SectionCategory Category { get; set; }
		public SectionProtection Protection { get; set; }
		public SectionType Type { get; set; }
		public string ModuleName { get; set; }
		public string ModulePath { get; set; }
	}
}

```

`ReClass.NET/Memory/SimplePeHeader.cs`:

```cs
using System;
using System.IO;

namespace ReClassNET.Memory
{
	public class SimplePeHeader
	{
		private readonly byte[] data;

		private int e_lfanew => BitConverter.ToInt32(data, 60);

		private int FileHeader => e_lfanew + 4;

		public int NumberOfSections => BitConverter.ToInt16(data, FileHeader + 2);

		private int SizeOfOptionalHeader => BitConverter.ToInt16(data, FileHeader + 16);

		private int FirstSectionOffset => e_lfanew + 24 + SizeOfOptionalHeader;

		public int SectionOffset(int index) => FirstSectionOffset + index * 40;

		private SimplePeHeader(byte[] data)
		{
			this.data = data;
		}

		/// <summary>
		/// Rewrites the section headers to build a valid pe file.
		/// </summary>
		/// <param name="data">The memory of a dumped module.</param>
		public static void FixSectionHeaders(byte[] data)
		{
			var pe = new SimplePeHeader(data);

			using var ms = new MemoryStream(data);
			using var bw = new BinaryWriter(ms);
			for (var i = 0; i < pe.NumberOfSections; ++i)
			{
				var offset = pe.SectionOffset(i);
				bw.Seek(offset + 16, SeekOrigin.Begin);
				bw.Write(BitConverter.ToUInt32(data, offset + 8)); // SizeOfRawData = VirtualSize
				bw.Write(BitConverter.ToUInt32(data, offset + 12)); // PointerToRawData = VirtualAddress
			}
		}
	}
}

```

`ReClass.NET/Memory/UnionDataType.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace ReClassNET.Memory
{
	[StructLayout(LayoutKind.Explicit)]
	public struct UInt8Data
	{
		[FieldOffset(0)]
		public sbyte SByteValue;

		[FieldOffset(0)]
		public byte ByteValue;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct UInt16Data
	{
		[FieldOffset(0)]
		public short ShortValue;

		[FieldOffset(0)]
		public ushort UShortValue;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct UInt32FloatData
	{
		[FieldOffset(0)]
		public int Raw;

		[FieldOffset(0)]
		public int IntValue;

		public IntPtr IntPtr => (IntPtr)IntValue;

		[FieldOffset(0)]
		public uint UIntValue;

		public UIntPtr UIntPtr => (UIntPtr)UIntValue;

		[FieldOffset(0)]
		public float FloatValue;
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct UInt64FloatDoubleData
	{
		[FieldOffset(0)]
		public int Raw1;

		[FieldOffset(4)]
		public int Raw2;

		[FieldOffset(0)]
		public long LongValue;

		public IntPtr IntPtr =>
#if RECLASSNET32
			unchecked((IntPtr)(int)LongValue);
#else
			(IntPtr)LongValue;
#endif

		[FieldOffset(0)]
		public ulong ULongValue;

		public UIntPtr UIntPtr =>
#if RECLASSNET32
			unchecked((UIntPtr)(uint)ULongValue);
#else
			(UIntPtr)ULongValue;
#endif

		[FieldOffset(0)]
		public float FloatValue;

		[FieldOffset(0)]
		public double DoubleValue;
	}
}

```

`ReClass.NET/MemoryScanner/BytePattern.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Text;
using ReClassNET.Extensions;

namespace ReClassNET.MemoryScanner
{
	public enum PatternMaskFormat
	{
		/// <summary>
		/// Example: AA BB ?? D? ?E FF
		/// </summary>
		Combined,
		/// <summary>
		/// Example: \xAA\xBB\x00\x00\x00\xFF xx???x
		/// </summary>
		Separated
	}

	public class BytePattern
	{
		private interface IPatternByte
		{
			/// <summary>
			/// Gets the byte value of the pattern byte if possible.
			/// </summary>
			/// <returns></returns>
			byte ToByte();

			/// <summary>
			/// Compares the pattern byte with the given byte.
			/// </summary>
			/// <param name="b"></param>
			/// <returns></returns>
			bool Equals(byte b);

			/// <summary>
			/// Formats the pattern byte as string.
			/// </summary>
			/// <param name="format"></param>
			/// <returns></returns>
			Tuple<string, string> ToString(PatternMaskFormat format);
		}

		private class PatternByte : IPatternByte
		{
			private struct Nibble
			{
				public int Value;
				public bool IsWildcard;
			}

			private Nibble nibble1;
			private Nibble nibble2;

			public bool HasWildcard => nibble1.IsWildcard || nibble2.IsWildcard;

			public byte ToByte() => !HasWildcard ? (byte)((nibble1.Value << 4) + nibble2.Value) : throw new InvalidOperationException();

			public static PatternByte NewWildcardByte()
			{
				var pb = new PatternByte
				{
					nibble1 = { IsWildcard = true },
					nibble2 = { IsWildcard = true }
				};
				return pb;
			}

			private static bool IsHexValue(char c)
			{
				return '0' <= c && c <= '9'
					|| 'A' <= c && c <= 'F'
					|| 'a' <= c && c <= 'f';
			}

			private static int HexToInt(char c)
			{
				if ('0' <= c && c <= '9') return c - '0';
				if ('A' <= c && c <= 'F') return c - 'A' + 10;
				return c - 'a' + 10;
			}

			public bool TryRead(StringReader sr)
			{
				Contract.Requires(sr != null);

				var temp = sr.ReadSkipWhitespaces();
				if (temp == -1 || !IsHexValue((char)temp) && (char)temp != '?')
				{
					return false;
				}

				nibble1.Value = HexToInt((char)temp) & 0xF;
				nibble1.IsWildcard = (char)temp == '?';

				temp = sr.Read();
				if (temp == -1 || char.IsWhiteSpace((char)temp) || (char)temp == '?')
				{
					nibble2.IsWildcard = true;

					return true;
				}

				if (!IsHexValue((char)temp))
				{
					return false;
				}
				nibble2.Value = HexToInt((char)temp) & 0xF;
				nibble2.IsWildcard = false;

				return true;
			}

			public bool Equals(byte b)
			{
				if (nibble1.IsWildcard || ((b >> 4) & 0xF) == nibble1.Value)
				{
					if (nibble2.IsWildcard || (b & 0xF) == nibble2.Value)
					{
						return true;
					}
				}

				return false;
			}

			public Tuple<string, string> ToString(PatternMaskFormat format)
			{
				switch (format)
				{
					case PatternMaskFormat.Separated:
						return HasWildcard ? Tuple.Create("\\x00", "?") : Tuple.Create($"\\x{ToByte():X02}", "x");
					case PatternMaskFormat.Combined:
						var sb = new StringBuilder();
						if (nibble1.IsWildcard) sb.Append('?');
						else sb.AppendFormat("{0:X}", nibble1.Value);
						if (nibble2.IsWildcard) sb.Append('?');
						else sb.AppendFormat("{0:X}", nibble2.Value);
						return Tuple.Create(sb.ToString(), (string)null);
					default:
						throw new ArgumentOutOfRangeException(nameof(format), format, null);
				}
			}

			public override string ToString() => ToString(PatternMaskFormat.Combined).Item1;
		}

		private class SimplePatternByte : IPatternByte
		{
			private readonly byte value;

			public SimplePatternByte(byte value)
			{
				this.value = value;
			}

			public byte ToByte() => value;

			public bool Equals(byte b) => value == b;

			public Tuple<string, string> ToString(PatternMaskFormat format)
			{
				switch (format)
				{
					case PatternMaskFormat.Separated:
						return Tuple.Create($"\\x{ToByte():X02}", "x");
					case PatternMaskFormat.Combined:
						return Tuple.Create($"{ToByte():X02}", (string)null);
					default:
						throw new ArgumentOutOfRangeException(nameof(format), format, null);
				}
			}
		}

		private readonly List<IPatternByte> pattern = new List<IPatternByte>();

		/// <summary>
		/// Gets the length of the pattern in byte.
		/// </summary>
		public int Length => pattern.Count;

		/// <summary>
		/// Gets if the pattern contains wildcards.
		/// </summary>
		public bool HasWildcards => pattern.Any(pb => pb is PatternByte pb2 && pb2.HasWildcard);

		private BytePattern()
		{

		}

		/// <summary>
		/// Parses the provided string for a byte pattern. Wildcards are supported by nibble.
		/// </summary>
		/// <example>
		/// Valid patterns:
		/// AA BB CC DD
		/// AABBCCDD
		/// aabb CCdd
		/// A? ?B ?? DD
		/// </example>
		/// <exception cref="ArgumentException">Thrown if the provided string doesn't contain a valid byte pattern.</exception>
		/// <param name="value">The byte pattern in hex format.</param>
		/// <returns>The corresponding <see cref="BytePattern"/>.</returns>
		public static BytePattern Parse(string value)
		{
			Contract.Requires(!string.IsNullOrEmpty(value));
			Contract.Ensures(Contract.Result<BytePattern>() != null);

			var pattern = new BytePattern();

			using var sr = new StringReader(value);
			while (true)
			{
				var pb = new PatternByte();
				if (pb.TryRead(sr))
				{
					if (!pb.HasWildcard)
					{
						pattern.pattern.Add(new SimplePatternByte(pb.ToByte()));
					}
					else
					{
						pattern.pattern.Add(pb);
					}
				}
				else
				{
					break;
				}
			}

			// Check if we are not at the end of the stream
			if (sr.Peek() != -1)
			{
				throw new ArgumentException($"'{value}' is not a valid byte pattern.");
			}

			return pattern;
		}

		/// <summary>
		/// Creates a byte pattern from the provided bytes.
		/// </summary>
		/// <param name="data">The bytes to match.</param>
		/// <returns></returns>
		public static BytePattern From(IEnumerable<byte> data)
		{
			var pattern = new BytePattern();
			pattern.pattern.AddRange(data.Select(b => new SimplePatternByte(b)));
			return pattern;
		}

		/// <summary>
		/// Creates a byte pattern with wildcard support from the provided bytes. The boolean tuple item signals a wildcard.
		/// </summary>
		/// <param name="data">The byte data or the wildcard flag.</param>
		/// <returns></returns>
		public static BytePattern From(IEnumerable<Tuple<byte, bool>> data)
		{
			var pattern = new BytePattern();

			foreach (var (value, isWildcard) in data)
			{
				var pb = isWildcard ? (IPatternByte)PatternByte.NewWildcardByte() : new SimplePatternByte(value);

				pattern.pattern.Add(pb);
			}

			return pattern;
		}

		/// <summary>
		/// Tests if the provided byte array matches the byte pattern at the provided index.
		/// </summary>
		/// <param name="data">The byte array to be compared.</param>
		/// <param name="index">The index into the byte array.</param>
		/// <returns>True if the pattern matches, false if they are not.</returns>
		public bool Equals(byte[] data, int index)
		{
			Contract.Requires(data != null);

			for (var j = 0; j < pattern.Count; ++j)
			{
				if (!pattern[j].Equals(data[index + j]))
				{
					return false;
				}
			}

			return true;
		}

		/// <summary>
		/// Converts this <see cref="BytePattern"/> to a byte array.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern contains wildcards.</exception>
		/// <returns>The bytes of the pattern.
		/// </returns>
		public byte[] ToByteArray()
		{
			Contract.Ensures(Contract.Result<byte[]>() != null);

			if (HasWildcards)
			{
				throw new InvalidOperationException();
			}

			return pattern.Select(pb => pb.ToByte()).ToArray();
		}

		/// <summary>
		/// Formats the <see cref="BytePattern"/> in the specified <see cref="PatternMaskFormat"/>.
		/// </summary>
		/// <param name="format">The format of the pattern.</param>
		/// <returns>A tuple containing the format. If <paramref name="format"/> is not <see cref="PatternMaskFormat.Separated"/> the second item is null.</returns>
		public Tuple<string, string> ToString(PatternMaskFormat format)
		{
			switch (format)
			{
				case PatternMaskFormat.Separated:
					var sb1 = new StringBuilder();
					var sb2 = new StringBuilder();
					pattern
						.Select(p => p.ToString(PatternMaskFormat.Separated))
						.ForEach(t =>
						{
							sb1.Append(t.Item1);
							sb2.Append(t.Item2);
						});
					return Tuple.Create(sb1.ToString(), sb2.ToString());
				case PatternMaskFormat.Combined:
					return Tuple.Create<string, string>(string.Join(" ", pattern.Select(p => p.ToString(PatternMaskFormat.Combined).Item1)), null);
				default:
					throw new ArgumentOutOfRangeException(nameof(format), format, null);
			}
		}

		public override string ToString() => ToString(PatternMaskFormat.Combined).Item1;
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/ArrayOfBytesMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class ArrayOfBytesMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType => ScanCompareType.Equal;
		public int ValueSize => bytePattern?.Length ?? byteArray.Length;

		private readonly BytePattern bytePattern;
		private readonly byte[] byteArray;

		public ArrayOfBytesMemoryComparer(BytePattern pattern)
		{
			Contract.Requires(pattern != null);

			bytePattern = pattern;

			if (!bytePattern.HasWildcards)
			{
				byteArray = bytePattern.ToByteArray();
			}
		}

		public ArrayOfBytesMemoryComparer(byte[] pattern)
		{
			Contract.Requires(pattern != null);

			byteArray = pattern;
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			result = null;

			if (byteArray != null)
			{
				for (var i = 0; i < byteArray.Length; ++i)
				{
					if (data[index + i] != byteArray[i])
					{
						return false;
					}
				}
			}
			else if (!bytePattern.Equals(data, index))
			{
				return false;
			}

			var temp = new byte[ValueSize];
			Array.Copy(data, index, temp, 0, temp.Length);
			result = new ArrayOfBytesScanResult(temp);

			return true;
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is ArrayOfBytesScanResult);
#endif

			return Compare(data, index, out result);
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/ByteMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class ByteMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public byte Value1 { get; }
		public byte Value2 { get; }
		public int ValueSize => sizeof(byte);

		public ByteMemoryComparer(ScanCompareType compareType, byte value1, byte value2)
		{
			CompareType = compareType;

			Value1 = value1;
			Value2 = value2;
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is ByteScanResult);
#endif

			return Compare(data, index, (ByteScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, ByteScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private static bool CompareInternal(byte[] data, int index, Func<short, bool> matcher, out ScanResult result)
		{
			result = null;

			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}
			if ((uint)index >= data.Length)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}
			if (index > data.Length - 1)
			{
				throw new ArgumentException();
			}

			var value = data[index];

			if (!matcher(value))
			{
				return false;
			}

			result = new ByteScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/DoubleMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using ReClassNET.Extensions;
using ReClassNET.Util.Conversion;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class DoubleMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public ScanRoundMode RoundType { get; }
		public double Value1 { get; }
		public double Value2 { get; }
		public int ValueSize => sizeof(double);

		private readonly int significantDigits;
		private readonly double minValue;
		private readonly double maxValue;

		private readonly EndianBitConverter bitConverter;

		public DoubleMemoryComparer(ScanCompareType compareType, ScanRoundMode roundType, int significantDigits, double value1, double value2, EndianBitConverter bitConverter)
		{
			CompareType = compareType;

			RoundType = roundType;
			this.significantDigits = Math.Max(significantDigits, 1);
			Value1 = Math.Round(value1, this.significantDigits, MidpointRounding.AwayFromZero);
			Value2 = Math.Round(value2, this.significantDigits, MidpointRounding.AwayFromZero);

			var factor = (int)Math.Pow(10.0, this.significantDigits);

			minValue = value1 - 1.0 / factor;
			maxValue = value1 + 1.0 / factor;

			this.bitConverter = bitConverter;
		}

		private bool CheckRoundedEquality(double value) =>
			RoundType switch
			{
				ScanRoundMode.Strict => Value1.IsNearlyEqual(Math.Round(value, significantDigits, MidpointRounding.AwayFromZero), 0.0001),
				ScanRoundMode.Normal => minValue < value && value < maxValue,
				ScanRoundMode.Truncate => (long)value == (long)Value1,
				_ => throw new ArgumentOutOfRangeException()
			};

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => CheckRoundedEquality(value),
					ScanCompareType.NotEqual => !CheckRoundedEquality(value),
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is DoubleScanResult);
#endif

			return Compare(data, index, (DoubleScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, DoubleScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => CheckRoundedEquality(value),
					ScanCompareType.NotEqual => !CheckRoundedEquality(value),
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private bool CompareInternal(byte[] data, int index, Func<double, bool> matcher, out ScanResult result)
		{
			result = null;

			var value = bitConverter.ToDouble(data, index);

			if (!matcher(value))
			{
				return false;
			}

			result = new DoubleScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/FloatMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using ReClassNET.Extensions;
using ReClassNET.Util.Conversion;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class FloatMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public ScanRoundMode RoundType { get; }
		public float Value1 { get; }
		public float Value2 { get; }
		public int ValueSize => sizeof(float);

		private readonly int significantDigits;
		private readonly float minValue;
		private readonly float maxValue;

		private readonly EndianBitConverter bitConverter;

		public FloatMemoryComparer(ScanCompareType compareType, ScanRoundMode roundType, int significantDigits, float value1, float value2, EndianBitConverter bitConverter)
		{
			CompareType = compareType;

			RoundType = roundType;
			this.significantDigits = Math.Max(significantDigits, 1);
			Value1 = (float)Math.Round(value1, this.significantDigits, MidpointRounding.AwayFromZero);
			Value2 = (float)Math.Round(value2, this.significantDigits, MidpointRounding.AwayFromZero);

			var factor = (int)Math.Pow(10.0, this.significantDigits);

			minValue = value1 - 1.0f / factor;
			maxValue = value1 + 1.0f / factor;

			this.bitConverter = bitConverter;
		}

		private bool CheckRoundedEquality(float value) =>
			RoundType switch
			{
				ScanRoundMode.Strict => Value1.IsNearlyEqual((float)Math.Round(value, significantDigits, MidpointRounding.AwayFromZero), 0.0001f),
				ScanRoundMode.Normal => minValue < value && value < maxValue,
				ScanRoundMode.Truncate => (int)value == (int)Value1,
				_ => throw new ArgumentOutOfRangeException()
			};

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => CheckRoundedEquality(value),
					ScanCompareType.NotEqual => !CheckRoundedEquality(value),
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is FloatScanResult);
#endif

			return Compare(data, index, (FloatScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, FloatScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => CheckRoundedEquality(value),
					ScanCompareType.NotEqual => !CheckRoundedEquality(value),
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private bool CompareInternal(byte[] data, int index, Func<float, bool> matcher, out ScanResult result)
		{
			result = null;

			var value = bitConverter.ToSingle(data, index);

			if (!matcher(value))
			{
				return false;
			}

			result = new FloatScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/IComplexScanComparer.cs`:

```cs
using System.Collections.Generic;

namespace ReClassNET.MemoryScanner.Comparer
{
	public interface IComplexScanComparer : IScanComparer
	{
		/// <summary>
		/// Compares all data to the current <see cref="IScanComparer.CompareType"/>.
		/// </summary>
		/// <param name="data">The byte array to be compared.</param>
		/// <param name="size">The index into the byte array.</param>
		/// <returns>List of matches.</returns>
		IEnumerable<ScanResult> Compare(byte[] data, int size);

		/// <summary>
		/// Compares all data to the current <see cref="IScanComparer.CompareType"/>.
		/// The previous results may be used.
		/// </summary>
		/// <param name="data">The byte array to be compared.</param>
		/// <param name="size">The index into the byte array.</param>
		/// <param name="previous">Scan result to be compared.</param>
		/// <param name="result">[out] The scan result if the <see cref="IScanComparer.CompareType"/> matched.</param>
		/// <returns>True if matched.</returns>
		bool CompareWithPrevious(byte[] data, int size, ScanResult previous, out ScanResult result);
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/IScanComparer.cs`:

```cs
namespace ReClassNET.MemoryScanner.Comparer
{
	public interface IScanComparer
	{
		ScanCompareType CompareType { get; }
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/ISimpleScanComparer.cs`:

```cs
namespace ReClassNET.MemoryScanner.Comparer
{
	public interface ISimpleScanComparer : IScanComparer
	{
		int ValueSize { get; }

		/// <summary>
		/// Compares the data at the provided index to the current <see cref="IScanComparer.CompareType"/>.
		/// </summary>
		/// <param name="data">The byte array to be compared.</param>
		/// <param name="index">The index into the byte array.</param>
		/// <param name="result">[out] The scan result if the <see cref="IScanComparer.CompareType"/> matched.</param>
		/// <returns>True if matched.</returns>
		bool Compare(byte[] data, int index, out ScanResult result);

		/// <summary>
		/// Compares the data at the provided index to the current <see cref="IScanComparer.CompareType"/>.
		/// The previous results may be used.
		/// </summary>
		/// <param name="data">The byte array to be compared.</param>
		/// <param name="index">The index into the byte array.</param>
		/// <param name="previous">Scan result to be compared.</param>
		/// <param name="result">[out] The scan result if the <see cref="IScanComparer.CompareType"/> matched.</param>
		/// <returns>True if matched.</returns>
		bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result);
	}
}
```

`ReClass.NET/MemoryScanner/Comparer/IntegerMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using ReClassNET.Util.Conversion;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class IntegerMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public int Value1 { get; }
		public int Value2 { get; }
		public int ValueSize => sizeof(int);

		private readonly EndianBitConverter bitConverter;

		public IntegerMemoryComparer(ScanCompareType compareType, int value1, int value2, EndianBitConverter bitConverter)
		{
			CompareType = compareType;

			Value1 = value1;
			Value2 = value2;

			this.bitConverter = bitConverter;
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is IntegerScanResult);
#endif

			return Compare(data, index, (IntegerScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, IntegerScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private bool CompareInternal(byte[] data, int index, Func<int, bool> matcher, out ScanResult result)
		{
			result = null;

			var value = bitConverter.ToInt32(data, index);

			if (!matcher(value))
			{
				return false;
			}

			result = new IntegerScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/InvalidCompareTypeException.cs`:

```cs
using System;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class InvalidCompareTypeException : Exception
	{
		public InvalidCompareTypeException(ScanCompareType type)
			: base($"{type} is not valid in the current state.")
		{
			
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/LongMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using ReClassNET.Util.Conversion;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class LongMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public long Value1 { get; }
		public long Value2 { get; }
		public int ValueSize => sizeof(long);

		private readonly EndianBitConverter bitConverter;

		public LongMemoryComparer(ScanCompareType compareType, long value1, long value2, EndianBitConverter bitConverter)
		{
			CompareType = compareType;

			Value1 = value1;
			Value2 = value2;

			this.bitConverter = bitConverter;
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is LongScanResult);
#endif

			return Compare(data, index, (LongScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, LongScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private bool CompareInternal(byte[] data, int index, Func<long, bool> matcher, out ScanResult result)
		{
			result = null;

			var value = bitConverter.ToInt64(data, index);

			if (!matcher(value))
			{
				return false;
			}

			result = new LongScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/RegexStringMemoryComparer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class RegexStringMemoryComparer : IComplexScanComparer
	{
		public ScanCompareType CompareType => ScanCompareType.Equal;

		public Regex Pattern { get; }

		public Encoding Encoding { get; }

		public RegexStringMemoryComparer(string pattern, Encoding encoding, bool caseSensitive)
		{
			var options = RegexOptions.Singleline | RegexOptions.Compiled;
			if (!caseSensitive)
			{
				options |= RegexOptions.IgnoreCase;
			}

			Pattern = new Regex(pattern, options);

			Encoding = encoding;
		}

		public IEnumerable<ScanResult> Compare(byte[] data, int size)
		{
			var buffer = Encoding.GetString(data, 0, size);
			var bufferArray = buffer.ToCharArray();

			var lastIndex = 0;
			var lastOffset = 0;

			var match = Pattern.Match(buffer);
			while (match.Success)
			{
				var byteOffset = Encoding.GetByteCount(bufferArray, lastIndex, match.Index - lastIndex) + lastOffset;

				lastIndex = match.Index;
				lastOffset = byteOffset;

				yield return new RegexStringScanResult(match.Value, Encoding)
				{
					Address = (IntPtr)byteOffset
				};

				match = match.NextMatch();
			}
		}

		public bool CompareWithPrevious(byte[] data, int size, ScanResult previous, out ScanResult result)
		{
			result = null;

			var byteOffset = previous.Address.ToInt32();
			if (byteOffset >= size)
			{
				return false;
			}

			var buffer = Encoding.GetString(data, byteOffset, size - byteOffset);

			var match = Pattern.Match(buffer);
			if (!match.Success)
			{
				return false;
			}

			result = new RegexStringScanResult(match.Value, Encoding)
			{
				Address = (IntPtr)byteOffset
			};

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/ShortMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using ReClassNET.Util.Conversion;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class ShortMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType { get; }
		public short Value1 { get; }
		public short Value2 { get; }
		public int ValueSize => sizeof(short);

		private readonly EndianBitConverter bitConverter;

		public ShortMemoryComparer(ScanCompareType compareType, short value1, short value2, EndianBitConverter bitConverter)
		{
			CompareType = compareType;

			Value1 = value1;
			Value2 = value2;

			this.bitConverter = bitConverter;
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Unknown => true,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is ShortScanResult);
#endif

			return Compare(data, index, (ShortScanResult)previous, out result);
		}

		public bool Compare(byte[] data, int index, ShortScanResult previous, out ScanResult result)
		{
			return CompareInternal(
				data,
				index,
				value => CompareType switch
				{
					ScanCompareType.Equal => value == Value1,
					ScanCompareType.NotEqual => value != Value1,
					ScanCompareType.GreaterThan => value > Value1,
					ScanCompareType.GreaterThanOrEqual => value >= Value1,
					ScanCompareType.LessThan => value < Value1,
					ScanCompareType.LessThanOrEqual => value <= Value1,
					ScanCompareType.Between => Value1 < value && value < Value2,
					ScanCompareType.BetweenOrEqual => Value1 <= value && value <= Value2,
					ScanCompareType.Changed => value != previous.Value,
					ScanCompareType.NotChanged => value == previous.Value,
					ScanCompareType.Increased => value > previous.Value,
					ScanCompareType.IncreasedOrEqual => value >= previous.Value,
					ScanCompareType.Decreased => value < previous.Value,
					ScanCompareType.DecreasedOrEqual => value <= previous.Value,
					_ => throw new InvalidCompareTypeException(CompareType)
				},
				out result
			);
		}

		private bool CompareInternal(byte[] data, int index, Func<short, bool> matcher, out ScanResult result)
		{
			result = null;

			var value = bitConverter.ToInt16(data, index);

			if (!matcher(value))
			{
				return false;
			}

			result = new ShortScanResult(value);

			return true;
		}
	}
}

```

`ReClass.NET/MemoryScanner/Comparer/StringMemoryComparer.cs`:

```cs
using System;
using System.Diagnostics;
using System.Text;
using ReClassNET.Extensions;

namespace ReClassNET.MemoryScanner.Comparer
{
	public class StringMemoryComparer : ISimpleScanComparer
	{
		public ScanCompareType CompareType => ScanCompareType.Equal;
		public bool CaseSensitive { get; }
		public Encoding Encoding { get; }
		public string Value { get; }
		public int ValueSize { get; }

		public StringMemoryComparer(string value, Encoding encoding, bool caseSensitive)
		{
			Value = value;
			Encoding = encoding;
			CaseSensitive = caseSensitive;
			ValueSize = Value.Length * Encoding.GuessByteCountPerChar();
		}

		public bool Compare(byte[] data, int index, out ScanResult result)
		{
			result = null;

			var value = Encoding.GetString(data, index, ValueSize);

			if (!Value.Equals(value, CaseSensitive ? StringComparison.InvariantCulture : StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}

			result = new StringScanResult(value, Encoding);

			return true;
		}

		public bool Compare(byte[] data, int index, ScanResult previous, out ScanResult result)
		{
#if DEBUG
			Debug.Assert(previous is StringScanResult);
#endif

			return Compare(data, index, out result);
		}
	}
}

```

`ReClass.NET/MemoryScanner/ComplexScannerWorker.cs`:

```cs
using System.Collections.Generic;
using System.Threading;
using ReClassNET.MemoryScanner.Comparer;

namespace ReClassNET.MemoryScanner
{
	internal class ComplexScannerWorker : IScannerWorker
	{
		private readonly ScanSettings settings;
		private readonly IComplexScanComparer comparer;

		public ComplexScannerWorker(ScanSettings settings, IComplexScanComparer comparer)
		{
			this.settings = settings;
			this.comparer = comparer;
		}

		public IList<ScanResult> Search(byte[] data, int count, CancellationToken ct)
		{
			var results = new List<ScanResult>();

			foreach (var result in comparer.Compare(data, count))
			{
				results.Add(result);

				if (ct.IsCancellationRequested)
				{
					break;
				}
			}

			return results;
		}

		public IList<ScanResult> Search(byte[] data, int count, IEnumerable<ScanResult> previousResults, CancellationToken ct)
		{
			var results = new List<ScanResult>();

			foreach (var previousResult in previousResults)
			{
				if (ct.IsCancellationRequested)
				{
					break;
				}

				if (comparer.CompareWithPrevious(data, count, previousResult, out var result))
				{
					results.Add(result);
				}
			}

			return results;
		}
	}
}

```

`ReClass.NET/MemoryScanner/IScannerWorker.cs`:

```cs
using System.Collections.Generic;
using System.Threading;
using ReClassNET.MemoryScanner.Comparer;

namespace ReClassNET.MemoryScanner
{
	internal interface IScannerWorker
	{
		/// <summary>
		/// Uses the <see cref="IScanComparer"/> to scan the byte array for results.
		/// </summary>
		/// <param name="data">The data to scan.</param>
		/// <param name="count">The length of the <paramref name="data"/> parameter.</param>
		/// <param name="ct">The <see cref="CancellationToken"/> to stop the scan.</param>
		/// <returns>An enumeration of all <see cref="ScanResult"/>s.</returns>
		IList<ScanResult> Search(byte[] data, int count, CancellationToken ct);

		/// <summary>
		/// Uses the <see cref="IScanComparer"/> to scan the byte array for results.
		/// The comparer uses the provided previous results to compare to the current value.
		/// </summary>
		/// <param name="data">The data to scan.</param>
		/// <param name="count">The length of the <paramref name="data"/> parameter.</param>
		/// <param name="previousResults">The previous results to use.</param>
		/// <param name="ct">The <see cref="CancellationToken"/> to stop the scan.</param>
		/// <returns>An enumeration of all <see cref="ScanResult"/>s.</returns>
		IList<ScanResult> Search(byte[] data, int count, IEnumerable<ScanResult> previousResults, CancellationToken ct);
	}
}

```

`ReClass.NET/MemoryScanner/InputCorrelatedScanner.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ReClassNET.Input;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner.Comparer;

namespace ReClassNET.MemoryScanner
{
	public class InputCorrelatedScanner : Scanner
	{
		private readonly RemoteProcess process;
		private readonly KeyboardInput input;
		private readonly List<KeyboardHotkey> hotkeys;

		/// <summary>
		/// Gets the count of executed scans.
		/// </summary>
		public int ScanCount { get; private set; }

		public InputCorrelatedScanner(RemoteProcess process, KeyboardInput input, IEnumerable<KeyboardHotkey> hotkeys, ScanValueType valueType)
			: base(process, CreateScanSettings(valueType))
		{
			Contract.Requires(process != null);
			Contract.Requires(input != null);
			Contract.Requires(hotkeys != null);
			Contract.Ensures(this.input != null);

			this.process = process;
			this.input = input;
			this.hotkeys = hotkeys.ToList();
		}

		/// <summary>
		/// Creates <see cref="ScanSettings"/> from the given <see cref="ScanValueType"/>.
		/// </summary>
		/// <param name="valueType">The <see cref="ScanValueType"/> to use.</param>
		/// <returns>The created <see cref="ScanSettings"/>.</returns>
		private static ScanSettings CreateScanSettings(ScanValueType valueType)
		{
			Contract.Ensures(Contract.Result<ScanSettings>() != null);

			var settings = ScanSettings.Default;
			settings.ValueType = valueType;
			return settings;
		}

		/// <summary>
		/// Creates a <see cref="IScanComparer"/> for the given <see cref="ScanCompareType"/> and <see cref="ScanValueType"/>.
		/// </summary>
		/// <param name="compareType">The <see cref="ScanCompareType"/> to use.</param>
		/// <returns>The created <see cref="IScanComparer"/>.</returns>
		private IScanComparer CreateScanComparer(ScanCompareType compareType)
		{
			Contract.Ensures(Contract.Result<IScanComparer>() != null);

			return Settings.ValueType switch
			{
				ScanValueType.Byte => new ByteMemoryComparer(compareType, 0, 0),
				ScanValueType.Short => new ShortMemoryComparer(compareType, 0, 0, process.BitConverter),
				ScanValueType.Integer => new IntegerMemoryComparer(compareType, 0, 0, process.BitConverter),
				ScanValueType.Long => new LongMemoryComparer(compareType, 0, 0, process.BitConverter),
				ScanValueType.Float => new FloatMemoryComparer(compareType, ScanRoundMode.Normal, 2, 0, 0, process.BitConverter),
				ScanValueType.Double => new DoubleMemoryComparer(compareType, ScanRoundMode.Normal, 2, 0, 0, process.BitConverter),
				_ => throw new InvalidOperationException(),
			};
		}

		/// <summary>
		/// Initializes the scanner. Needs to get called at first.
		/// </summary>
		/// <returns>A task that represents the asynchronous operation.</returns>
		public Task Initialize()
		{
			return Search(CreateScanComparer(ScanCompareType.Unknown), null, CancellationToken.None);
		}

		private bool shouldHaveChangedSinceLastScan = false;

		/// <summary>
		/// Checks if the registered keys got pressed.
		/// </summary>
		public void CorrelateInput()
		{
			if (shouldHaveChangedSinceLastScan)
			{
				return;
			}

			var keys = input.GetPressedKeys().Select(k => k & Keys.KeyCode).Where(k => k != Keys.None).ToArray();

			if (keys.Length != 0 && hotkeys.Any(h => h.Matches(keys)))
			{
				shouldHaveChangedSinceLastScan = true;
			}
		}

		/// <summary>
		/// Performs a new scan to refine the current scan result.
		/// </summary>
		/// <param name="ct">The <see cref="CancellationToken"/> to abort the scan.</param>
		/// <param name="progress">Used to report the progress of the scan.</param>
		/// <returns>A task that represents the asynchronous operation.</returns>
		public async Task RefineResults(CancellationToken ct, IProgress<int> progress)
		{
			var compareType = shouldHaveChangedSinceLastScan ? ScanCompareType.Changed : ScanCompareType.NotChanged;

			if (compareType == ScanCompareType.Changed)
			{
				// If the value should have changed, we give the target some time to react to the pressed key.
				await Task.Delay(TimeSpan.FromMilliseconds(200), ct);
			}

			await Search(CreateScanComparer(compareType), progress, ct);

			shouldHaveChangedSinceLastScan = false;

			ScanCount++;
		}
	}
}

```

`ReClass.NET/MemoryScanner/MemoryRecord.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Text;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Util;

namespace ReClassNET.MemoryScanner
{
	public enum MemoryRecordAddressMode
	{
		Absolute,
		Relative,
		Unknown
	}

	public class MemoryRecord : INotifyPropertyChanged
	{
		private IntPtr addressOrOffset;
		private string moduleName;

		public MemoryRecordAddressMode AddressMode { get; set; }

		public IntPtr AddressOrOffset
		{
			get => addressOrOffset;
			set
			{
				addressOrOffset = value;
				AddressMode = MemoryRecordAddressMode.Unknown;
			}
		}

		public IntPtr RealAddress { get; private set; }
	
		public string AddressStr => RealAddress.ToString(Constants.AddressHexFormat);

		public string ModuleName
		{
			get => moduleName;
			set
			{
				moduleName = value;
				AddressMode = MemoryRecordAddressMode.Relative;
			}
		}
		public bool IsRelativeAddress => !string.IsNullOrEmpty(ModuleName);

		public string Description { get; set; } = string.Empty;
		public ScanValueType ValueType { get; set; }

		public string ValueStr { get; private set; }
		public string PreviousValueStr { get; }
		public bool HasChangedValue { get; private set; }

		public int ValueLength { get; set; }

		public Encoding Encoding { get; set; }

		public bool ShowValueHexadecimal { get; set; }

		public event PropertyChangedEventHandler PropertyChanged;

		public MemoryRecord()
		{

		}

		public MemoryRecord(ScanResult result)
		{
			Contract.Requires(result != null);

			addressOrOffset = result.Address;
			AddressMode = MemoryRecordAddressMode.Unknown;
			ValueType = result.ValueType;

			switch (ValueType)
			{
				case ScanValueType.Byte:
					ValueStr = FormatValue(((ByteScanResult)result).Value, false);
					break;
				case ScanValueType.Short:
					ValueStr = FormatValue(((ShortScanResult)result).Value, false);
					break;
				case ScanValueType.Integer:
					ValueStr = FormatValue(((IntegerScanResult)result).Value, false);
					break;
				case ScanValueType.Long:
					ValueStr = FormatValue(((LongScanResult)result).Value, false);
					break;
				case ScanValueType.Float:
					ValueStr = FormatValue(((FloatScanResult)result).Value);
					break;
				case ScanValueType.Double:
					ValueStr = FormatValue(((DoubleScanResult)result).Value);
					break;
				case ScanValueType.ArrayOfBytes:
					var byteData = ((ArrayOfBytesScanResult)result).Value;
					ValueLength = byteData.Length;
					ValueStr = FormatValue(byteData);
					break;
				case ScanValueType.String:
				case ScanValueType.Regex:
					var strResult = (StringScanResult)result;
					ValueLength = strResult.Value.Length;
					Encoding = strResult.Encoding;
					ValueStr = FormatValue(strResult.Value);
					break;
				default:
					throw new InvalidOperationException();
			}

			PreviousValueStr = ValueStr;
		}

		private void NotifyPropertyChanged(string propertyName)
		{
			var propertyChanged = PropertyChanged;
			propertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}

		public void ResolveAddress(RemoteProcess process)
		{
			Contract.Requires(process != null);

			if (AddressMode == MemoryRecordAddressMode.Unknown)
			{
				RealAddress = addressOrOffset;

				var module = process.GetModuleToPointer(addressOrOffset);
				if (module != null)
				{
					addressOrOffset = addressOrOffset.Sub(module.Start);
					ModuleName = module.Name;

					AddressMode = MemoryRecordAddressMode.Relative;
				}
				else
				{
					AddressMode = MemoryRecordAddressMode.Absolute;
				}
			}
			else if (AddressMode == MemoryRecordAddressMode.Relative)
			{
				var module = process.GetModuleByName(ModuleName);
				if (module != null)
				{
					RealAddress = module.Start.Add(addressOrOffset);
				}
			}
		}

		public void RefreshValue(RemoteProcess process)
		{
			Contract.Requires(process != null);

			byte[] buffer;

			switch (ValueType)
			{
				case ScanValueType.Byte:
					buffer = new byte[1];
					break;
				case ScanValueType.Short:
					buffer = new byte[2];
					break;
				case ScanValueType.Integer:
				case ScanValueType.Float:
					buffer = new byte[4];
					break;
				case ScanValueType.Long:
				case ScanValueType.Double:
					buffer = new byte[8];
					break;
				case ScanValueType.ArrayOfBytes:
					buffer = new byte[ValueLength];
					break;
				case ScanValueType.String:
				case ScanValueType.Regex:
					buffer = new byte[ValueLength * Encoding.GuessByteCountPerChar()];
					break;
				default:
					throw new InvalidOperationException();
			}

			if (process.ReadRemoteMemoryIntoBuffer(RealAddress, ref buffer))
			{
				switch (ValueType)
				{
					case ScanValueType.Byte:
						ValueStr = FormatValue(buffer[0], ShowValueHexadecimal);
						break;
					case ScanValueType.Short:
						ValueStr = FormatValue(process.BitConverter.ToInt16(buffer, 0), ShowValueHexadecimal);
						break;
					case ScanValueType.Integer:
						ValueStr = FormatValue(process.BitConverter.ToInt32(buffer, 0), ShowValueHexadecimal);
						break;
					case ScanValueType.Long:
						ValueStr = FormatValue(process.BitConverter.ToInt64(buffer, 0), ShowValueHexadecimal);
						break;
					case ScanValueType.Float:
						ValueStr = FormatValue(process.BitConverter.ToSingle(buffer, 0));
						break;
					case ScanValueType.Double:
						ValueStr = FormatValue(process.BitConverter.ToDouble(buffer, 0));
						break;
					case ScanValueType.ArrayOfBytes:
						ValueStr = FormatValue(buffer);
						break;
					case ScanValueType.String:
					case ScanValueType.Regex:
						ValueStr = FormatValue(Encoding.GetString(buffer));
						break;
				}
			}
			else
			{
				ValueStr = "???";
			}

			HasChangedValue = ValueStr != PreviousValueStr;

			NotifyPropertyChanged(nameof(ValueStr));
		}

		public void SetValue(RemoteProcess process, string input, bool isHex)
		{
			Contract.Requires(process != null);
			Contract.Requires(input != null);

			byte[] data = null;

			if (ValueType == ScanValueType.Byte || ValueType == ScanValueType.Short || ValueType == ScanValueType.Integer || ValueType == ScanValueType.Long)
			{
				var numberStyle = isHex ? NumberStyles.HexNumber : NumberStyles.Integer;
				long.TryParse(input, numberStyle, null, out var value);

				switch (ValueType)
				{
					case ScanValueType.Byte:
						data = process.BitConverter.GetBytes((byte)value);
						break;
					case ScanValueType.Short:
						data = process.BitConverter.GetBytes((short)value);
						break;
					case ScanValueType.Integer:
						data = process.BitConverter.GetBytes((int)value);
						break;
					case ScanValueType.Long:
						data = process.BitConverter.GetBytes(value);
						break;
				}
			}
			else if (ValueType == ScanValueType.Float || ValueType == ScanValueType.Double)
			{
				var nf = NumberFormat.GuessNumberFormat(input);
				double.TryParse(input, NumberStyles.Float, nf, out var value);

				switch (ValueType)
				{
					case ScanValueType.Float:
						data = process.BitConverter.GetBytes((float)value);
						break;
					case ScanValueType.Double:
						data = process.BitConverter.GetBytes(value);
						break;
				}
			}

			if (data != null)
			{
				process.WriteRemoteMemory(RealAddress, data);

				RefreshValue(process);
			}
		}

		private static string FormatValue(byte value, bool showAsHex) => showAsHex ? value.ToString("X") : value.ToString();
		private static string FormatValue(short value, bool showAsHex) => showAsHex ? value.ToString("X") : value.ToString();
		private static string FormatValue(int value, bool showAsHex) => showAsHex ? value.ToString("X") : value.ToString();
		private static string FormatValue(long value, bool showAsHex) => showAsHex ? value.ToString("X") : value.ToString();
		private static string FormatValue(float value) => value.ToString("0.0000");
		private static string FormatValue(double value) => value.ToString("0.0000");
		private static string FormatValue(byte[] value) => HexadecimalFormatter.ToString(value);
		private static string FormatValue(string value) => value;
	}
}

```

`ReClass.NET/MemoryScanner/PatternScanner.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Runtime.InteropServices;
using ReClassNET.Core;
using ReClassNET.Memory;

namespace ReClassNET.MemoryScanner
{
	public class PatternScanner
	{
		/// <summary>
		/// Searchs for the <see cref="BytePattern"/> in the specified <see cref="Module"/>.
		/// </summary>
		/// <param name="pattern">The pattern to search.</param>
		/// <param name="process">The process to read from.</param>
		/// <param name="module">The module of the process.</param>
		/// <returns>The address of the pattern or <see cref="IntPtr.Zero"/> if the pattern was not found.</returns>
		public static IntPtr FindPattern(BytePattern pattern, RemoteProcess process, Module module)
		{
			Contract.Requires(pattern != null);
			Contract.Requires(process != null);
			Contract.Requires(module != null);

			return FindPattern(pattern, process, module.Start, module.Size.ToInt32());
		}

		/// <summary>
		/// Searchs for the <see cref="BytePattern"/> in the specified <see cref="Section"/>.
		/// </summary>
		/// <param name="pattern">The pattern to search.</param>
		/// <param name="process">The process to read from.</param>
		/// <param name="section">The section of the process.</param>
		/// <returns>The address of the pattern or <see cref="IntPtr.Zero"/> if the pattern was not found.</returns>
		public static IntPtr FindPattern(BytePattern pattern, RemoteProcess process, Section section)
		{
			Contract.Requires(pattern != null);
			Contract.Requires(process != null);
			Contract.Requires(section != null);

			return FindPattern(pattern, process, section.Start, section.Size.ToInt32());
		}

		/// <summary>
		/// Searchs for the <see cref="BytePattern"/> in the specified address range.
		/// </summary>
		/// <param name="pattern">The pattern to search.</param>
		/// <param name="process">The process to read from.</param>
		/// <param name="start">The start address.</param>
		/// <param name="size">The size of the address range.</param>
		/// <returns>The address of the pattern or <see cref="IntPtr.Zero"/> if the pattern was not found.</returns>
		public static IntPtr FindPattern(BytePattern pattern, RemoteProcess process, IntPtr start, int size)
		{
			Contract.Requires(pattern != null);
			Contract.Requires(process != null);

			var moduleBytes = process.ReadRemoteMemory(start, size);

			var offset = FindPattern(pattern, moduleBytes);
			if (offset == -1)
			{
				return IntPtr.Zero;
			}

			return start + offset;
		}

		/// <summary>
		/// Searchs for the <see cref="BytePattern"/> in the specified data.
		/// </summary>
		/// <param name="pattern">The pattern to search.</param>
		/// <param name="data">The data to scan.</param>
		/// <returns>The index in data where the pattern was found or -1 otherwise.</returns>
		public static int FindPattern(BytePattern pattern, byte[] data)
		{
			Contract.Requires(pattern != null);
			Contract.Requires(data != null);

			var limit = data.Length - pattern.Length;
			for (var i = 0; i < limit; ++i)
			{
				if (pattern.Equals(data, i))
				{
					return i;
				}
			}

			return -1;
		}

		/// <summary>
		/// Creates a <see cref="BytePattern"/> for the given address range.
		/// </summary>
		/// <param name="process">The process to use.</param>
		/// <param name="start">The start of the address range.</param>
		/// <param name="size">The size of the address range.</param>
		/// <returns>A <see cref="BytePattern"/> describing the address range.</returns>
		public static BytePattern CreatePatternFromCode(RemoteProcess process, IntPtr start, int size)
		{
			var data = new List<Tuple<byte, bool>>();

			var buffer = process.ReadRemoteMemory(start, size);

			var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			try
			{
				var eip = handle.AddrOfPinnedObject();

				process.CoreFunctions.DisassembleCode(eip, size, IntPtr.Zero, true, (ref InstructionData instruction) =>
				{
					for (var i = 0; i < instruction.Length; ++i)
					{
						data.Add(Tuple.Create(instruction.Data[i], i >= instruction.StaticInstructionBytes));
					}
					return true;
				});
			}
			finally
			{
				if (handle.IsAllocated)
				{
					handle.Free();
				}
			}

			return BytePattern.From(data);
		}
	}
}

```

`ReClass.NET/MemoryScanner/ScanCompareType.cs`:

```cs
using System.ComponentModel;

namespace ReClassNET.MemoryScanner
{
	public enum ScanCompareType
	{
		[Description("Is Equal")]
		Equal,
		[Description("Is Not Equal")]
		NotEqual,
		[Description("Has Changed")]
		Changed,
		[Description("Has Not Changed")]
		NotChanged,
		[Description("Is Greater Than")]
		GreaterThan,
		[Description("Is Greater Than Or Equal")]
		GreaterThanOrEqual,
		[Description("Has Increased")]
		Increased,
		[Description("Has Increased Or Is Equal")]
		IncreasedOrEqual,
		[Description("Is Less Than")]
		LessThan,
		[Description("Is Less Than Or Equal")]
		LessThanOrEqual,
		[Description("Has Decreased")]
		Decreased,
		[Description("Has Decreased Or Is Equal")]
		DecreasedOrEqual,
		[Description("Is Between")]
		Between,
		[Description("Is Between Or Equal")]
		BetweenOrEqual,
		[Description("Unknown Initial Value")]
		Unknown
	}
}

```

`ReClass.NET/MemoryScanner/ScanResult.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Text;
using ReClassNET.Extensions;

namespace ReClassNET.MemoryScanner
{
	public abstract class ScanResult
	{
		public abstract ScanValueType ValueType { get; }

		public IntPtr Address { get; set; }

		public abstract int ValueSize { get; }

		public abstract ScanResult Clone();
	}

	public class ByteScanResult : ScanResult, IEquatable<ByteScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Byte;

		public override int ValueSize => sizeof(byte);

		public byte Value { get; }

		public ByteScanResult(byte value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new ByteScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as ByteScanResult);
		}

		public bool Equals(ByteScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class ShortScanResult : ScanResult, IEquatable<ShortScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Short;

		public override int ValueSize => sizeof(short);

		public short Value { get; }

		public ShortScanResult(short value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new ShortScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as ShortScanResult);
		}

		public bool Equals(ShortScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class IntegerScanResult : ScanResult, IEquatable<IntegerScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Integer;

		public override int ValueSize => sizeof(int);

		public int Value { get; }

		public IntegerScanResult(int value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new IntegerScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as IntegerScanResult);
		}

		public bool Equals(IntegerScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class LongScanResult : ScanResult, IEquatable<LongScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Long;

		public override int ValueSize => sizeof(long);

		public long Value { get; }

		public LongScanResult(long value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new LongScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as LongScanResult);
		}

		public bool Equals(LongScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class FloatScanResult : ScanResult, IEquatable<FloatScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Float;

		public override int ValueSize => sizeof(float);

		public float Value { get; }

		public FloatScanResult(float value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new FloatScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as FloatScanResult);
		}

		public bool Equals(FloatScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class DoubleScanResult : ScanResult, IEquatable<DoubleScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.Double;

		public override int ValueSize => sizeof(double);

		public double Value { get; }

		public DoubleScanResult(double value)
		{
			Value = value;
		}

		public override ScanResult Clone()
		{
			return new DoubleScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as DoubleScanResult);
		}

		public bool Equals(DoubleScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value;
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class ArrayOfBytesScanResult : ScanResult, IEquatable<ArrayOfBytesScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.ArrayOfBytes;

		public override int ValueSize => Value.Length;

		public byte[] Value { get; }

		public ArrayOfBytesScanResult(byte[] value)
		{
			Contract.Requires(value != null);

			Value = value;
		}

		public override ScanResult Clone()
		{
			return new ArrayOfBytesScanResult(Value) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as ArrayOfBytesScanResult);
		}

		public bool Equals(ArrayOfBytesScanResult other)
		{
			return other != null && Address == other.Address && Value.SequenceEqual(other.Value);
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode();
		}
	}

	public class StringScanResult : ScanResult, IEquatable<StringScanResult>
	{
		public override ScanValueType ValueType => ScanValueType.String;

		public override int ValueSize => Value.Length * Encoding.GuessByteCountPerChar();

		public string Value { get; }

		public Encoding Encoding { get; }

		public StringScanResult(string value, Encoding encoding)
		{
			Contract.Requires(value != null);
			Contract.Requires(encoding != null);

			Value = value;
			Encoding = encoding;
		}

		public override ScanResult Clone()
		{
			return new StringScanResult(Value, Encoding) { Address = Address };
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as StringScanResult);
		}

		public bool Equals(StringScanResult other)
		{
			return other != null && Address == other.Address && Value == other.Value && Encoding.Equals(other.Encoding);
		}

		public override int GetHashCode()
		{
			return Address.GetHashCode() * 19 + Value.GetHashCode() * 19 + Encoding.GetHashCode();
		}
	}

	public class RegexStringScanResult : StringScanResult
	{
		public override ScanValueType ValueType => ScanValueType.Regex;

		public RegexStringScanResult(string value, Encoding encoding)
			: base(value, encoding)
		{

		}

		public override ScanResult Clone()
		{
			return new RegexStringScanResult(Value, Encoding) { Address = Address };
		}
	}
}

```

`ReClass.NET/MemoryScanner/ScanResultBlock.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using ReClassNET.Extensions;

namespace ReClassNET.MemoryScanner
{
	internal class ScanResultBlock
	{
		public IntPtr Start { get; }
		public IntPtr End { get; }
		public int Size => End.Sub(Start).ToInt32();
		public IReadOnlyList<ScanResult> Results { get; }

		public ScanResultBlock(IntPtr start, IntPtr end, IReadOnlyList<ScanResult> results)
		{
			Contract.Requires(results != null);

			Start = start;
			End = end;
			Results = results;
		}
	}
}

```

`ReClass.NET/MemoryScanner/ScanResultStore.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Text;
using ReClassNET.Extensions;

namespace ReClassNET.MemoryScanner
{
	/// <summary>
	/// The store of all found scan results. If the result count exceed the <see cref="MaximumMemoryResultsCount"/> limit,
	/// the results are stored in temporary files.
	/// </summary>
	internal class ScanResultStore : IDisposable
	{
		private enum StorageMode
		{
			Memory,
			File
		}

		private const int MaximumMemoryResultsCount = 10000000;

		private readonly List<ScanResultBlock> store = new List<ScanResultBlock>();

		private readonly string storePath;
		private FileStream fileStream;

		private StorageMode mode = StorageMode.Memory;

		private readonly ScanValueType valueType;

		/// <summary>
		/// Gets the number of total results.
		/// </summary>
		public int TotalResultCount { get; private set; }

		public ScanResultStore(ScanValueType valueType, string storePath)
		{
			this.valueType = valueType;
			this.storePath = Path.Combine(storePath, $"ReClass.NET_MemoryScanner_{Guid.NewGuid()}.tmp");
		}

		public void Dispose()
		{
			Finish();

			store.Clear();

			try
			{
				if (File.Exists(storePath))
				{
					File.Delete(storePath);
				}
			}
			catch
			{
				// ignored
			}
		}

		public void Finish()
		{
			if (mode == StorageMode.File)
			{
				fileStream?.Dispose();
				fileStream = null;
			}
		}

		/// <summary>
		/// Gets the result blocks from the store. This may read results from files..
		/// </summary>
		public IEnumerable<ScanResultBlock> GetResultBlocks()
		{
			Contract.Ensures(Contract.Result<IEnumerable<ScanResultBlock>>() != null);

			return mode == StorageMode.Memory ? store : ReadBlocksFromFile();
		}

		/// <summary>
		/// Adds a result block to the store. If the result count exceed the <see cref="MaximumMemoryResultsCount"/> limit,
		/// the results are stored in temporary files.
		/// </summary>
		/// <param name="block">The result block to add.</param>
		public void AddBlock(ScanResultBlock block)
		{
			Contract.Requires(block != null);

			lock (store)
			{
				TotalResultCount += block.Results.Count;

				if (mode == StorageMode.Memory)
				{
					if (TotalResultCount > MaximumMemoryResultsCount)
					{
						mode = StorageMode.File;

						fileStream = File.OpenWrite(storePath);

						foreach (var b in store)
						{
							AppendBlockToFile(b);
						}
						store.Clear();
						store.TrimExcess();

						AppendBlockToFile(block);
					}
					else
					{
						store.Add(block);
					}
				}
				else
				{
					AppendBlockToFile(block);
				}
			}
		}

		/// <summary>
		/// Writes a result block to the file.
		/// </summary>
		/// <param name="block">The result block to add.</param>
		private void AppendBlockToFile(ScanResultBlock block)
		{
			Contract.Requires(block != null);

			using var bw = new BinaryWriter(fileStream, Encoding.Unicode, true);
			bw.Write(block.Start);
			bw.Write(block.End);
			bw.Write(block.Results.Count);

			foreach (var result in block.Results)
			{
				WriteSearchResult(bw, result);
			}
		}

		/// <summary>
		/// Reads all memory blocks from the file.
		/// </summary>
		private IEnumerable<ScanResultBlock> ReadBlocksFromFile()
		{
			Contract.Ensures(Contract.Result<IEnumerable<ScanResultBlock>>() != null);

			using var stream = File.OpenRead(storePath);
			using var br = new BinaryReader(stream, Encoding.Unicode);

			var length = stream.Length;

			while (stream.Position < length)
			{
				var start = br.ReadIntPtr();
				var end = br.ReadIntPtr();

				var resultCount = br.ReadInt32();

				var results = new List<ScanResult>(resultCount);
				for (var i = 0; i < resultCount; ++i)
				{
					results.Add(ReadScanResult(br));
				}

				yield return new ScanResultBlock(start, end, results);
			}
		}

		/// <summary>
		/// Reads a single scan result from the file.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the <see cref="ScanValueType"/> is not valid.</exception>
		/// <param name="br">The <see cref="BinaryReader"/> to read from.</param>
		/// <returns>The scan result.</returns>
		private ScanResult ReadScanResult(BinaryReader br)
		{
			Contract.Ensures(Contract.Result<ScanResult>() != null);

			var address = br.ReadIntPtr();

			ScanResult result;
			switch (valueType)
			{
				case ScanValueType.Byte:
					result = new ByteScanResult(br.ReadByte());
					break;
				case ScanValueType.Short:
					result = new ShortScanResult(br.ReadInt16());
					break;
				case ScanValueType.Integer:
					result = new IntegerScanResult(br.ReadInt32());
					break;
				case ScanValueType.Long:
					result = new LongScanResult(br.ReadInt64());
					break;
				case ScanValueType.Float:
					result = new FloatScanResult(br.ReadSingle());
					break;
				case ScanValueType.Double:
					result = new DoubleScanResult(br.ReadDouble());
					break;
				case ScanValueType.ArrayOfBytes:
					result = new ArrayOfBytesScanResult(br.ReadBytes(br.ReadInt32()));
					break;
				case ScanValueType.String:
				case ScanValueType.Regex:
					var encoding = br.ReadInt32() switch
					{
						0 => Encoding.UTF8,
						1 => Encoding.Unicode,
						_ => Encoding.UTF32
					};
					var value = br.ReadString();

					result = valueType == ScanValueType.String ? new StringScanResult(value, encoding) : new RegexStringScanResult(value, encoding);
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}

			result.Address = address;

			return result;
		}

		/// <summary>
		/// Writes a single scan result to the file.
		/// </summary>
		/// <param name="bw">The <see cref="BinaryWriter"/> to write to.</param>
		/// <param name="result">The result to write.</param>
		private static void WriteSearchResult(BinaryWriter bw, ScanResult result)
		{
			Contract.Requires(bw != null);
			Contract.Requires(result != null);

			bw.Write(result.Address);

			switch (result)
			{
				case ByteScanResult byteSearchResult:
					bw.Write(byteSearchResult.Value);
					break;
				case ShortScanResult shortSearchResult:
					bw.Write(shortSearchResult.Value);
					break;
				case IntegerScanResult integerSearchResult:
					bw.Write(integerSearchResult.Value);
					break;
				case LongScanResult longSearchResult:
					bw.Write(longSearchResult.Value);
					break;
				case FloatScanResult floatSearchResult:
					bw.Write(floatSearchResult.Value);
					break;
				case DoubleScanResult doubleSearchResult:
					bw.Write(doubleSearchResult.Value);
					break;
				case ArrayOfBytesScanResult arrayOfBytesSearchResult:
					bw.Write(arrayOfBytesSearchResult.Value.Length);
					bw.Write(arrayOfBytesSearchResult.Value);
					break;
				case StringScanResult stringSearchResult:
					bw.Write(stringSearchResult.Encoding.IsSameCodePage(Encoding.UTF8) ? 0 : stringSearchResult.Encoding.IsSameCodePage(Encoding.Unicode) ? 1 : 2);
					bw.Write(stringSearchResult.Value);
					break;
			}
		}
	}
}

```

`ReClass.NET/MemoryScanner/ScanRoundMode.cs`:

```cs
namespace ReClassNET.MemoryScanner
{
	public enum ScanRoundMode
	{
		Strict,
		Normal,
		Truncate
	}
}

```

`ReClass.NET/MemoryScanner/ScanSettings.cs`:

```cs
using System;

namespace ReClassNET.MemoryScanner
{
	public enum SettingState
	{
		Yes,
		No,
		Indeterminate
	}

	public class ScanSettings
	{
		public IntPtr StartAddress { get; set; } = IntPtr.Zero;
		public IntPtr StopAddress { get; set; } =
#if RECLASSNET64
			(IntPtr)long.MaxValue;
#else
			(IntPtr)int.MaxValue;
#endif
		public SettingState ScanWritableMemory { get; set; } = SettingState.Yes;
		public SettingState ScanExecutableMemory { get; set; } = SettingState.Indeterminate;
		public SettingState ScanCopyOnWriteMemory { get; set; } = SettingState.No;
		public bool ScanPrivateMemory { get; set; } = true;
		public bool ScanImageMemory { get; set; } = true;
		public bool ScanMappedMemory { get; set; } = false;
		public bool EnableFastScan { get; set; } = true;
		public int FastScanAlignment { get; set; } = 4;
		public ScanValueType ValueType { get; set; } = ScanValueType.Integer;

		public static ScanSettings Default => new ScanSettings();
	}
}

```

`ReClass.NET/MemoryScanner/ScanValueType.cs`:

```cs
using System.ComponentModel;

namespace ReClassNET.MemoryScanner
{
	public enum ScanValueType
	{
		[Description("Byte")]
		Byte,
		[Description("Short (2 Bytes)")]
		Short,
		[Description("Integer (4 Bytes)")]
		Integer,
		[Description("Long (8 Bytes)")]
		Long,
		[Description("Float (4 Bytes)")]
		Float,
		[Description("Double (8 Bytes)")]
		Double,
		[Description("Array of Bytes")]
		ArrayOfBytes,
		[Description("String")]
		String,
		[Description("Regular Expression")]
		Regex
	}
}

```

`ReClass.NET/MemoryScanner/Scanner.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Util;

namespace ReClassNET.MemoryScanner
{
	public class Scanner : IDisposable
	{
		/// <summary>
		/// Helper class for consolidated memory regions.
		/// </summary>
		private class ConsolidatedMemoryRegion
		{
			public IntPtr Address { get; set; }
			public int Size { get; set; }
		}

		private readonly RemoteProcess process;
		private readonly CircularBuffer<ScanResultStore> stores;

		public ScanSettings Settings { get; }

		private ScanResultStore CurrentStore => stores.Head;

		/// <summary>
		/// Gets the total result count from the last scan.
		/// </summary>
		public int TotalResultCount => CurrentStore?.TotalResultCount ?? 0;

		/// <summary>
		/// Checks if the last scan can be undone.
		/// </summary>
		public bool CanUndoLastScan => stores.Count > 1;

		private bool isFirstScan;

		public Scanner(RemoteProcess process, ScanSettings settings)
		{
			Contract.Requires(process != null);
			Contract.Requires(settings != null);

			stores = new CircularBuffer<ScanResultStore>(3);

			this.process = process;
			Settings = settings;

			isFirstScan = true;
		}

		public void Dispose()
		{
			foreach (var store in stores)
			{
				store?.Dispose();
			}
			stores.Clear();
		}

		/// <summary>
		/// Retrieves the results of the last scan from the store.
		/// </summary>
		/// <returns>
		/// An enumeration of the <see cref="ScanResult"/>s of the last scan.
		/// </returns>
		public IEnumerable<ScanResult> GetResults()
		{
			Contract.Ensures(Contract.Result<IEnumerable<ScanResult>>() != null);

			if (CurrentStore == null)
			{
				return Enumerable.Empty<ScanResult>();
			}

			return CurrentStore.GetResultBlocks().SelectMany(rb => rb.Results.Select(r =>
			{
				// Convert the block offset to a real address.
				var scanResult = r.Clone();
				scanResult.Address = scanResult.Address.Add(rb.Start);
				return scanResult;
			}));
		}

		/// <summary>
		/// Restores the results of the previous scan.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if no previous results are present.</exception>
		public void UndoLastScan()
		{
			if (!CanUndoLastScan)
			{
				throw new InvalidOperationException();
			}

			var store = stores.Dequeue();
			store?.Dispose();
		}

		/// <summary>
		/// Creates a new <see cref="ScanResultStore"/> and uses the system temporary path as file location.
		/// </summary>
		/// <returns>The new <see cref="ScanResultStore"/>.</returns>
		private ScanResultStore CreateStore()
		{
			return new ScanResultStore(Settings.ValueType, Path.GetTempPath());
		}

		/// <summary>
		/// Gets a list of the sections which meet the provided scan settings.
		/// </summary>
		/// <returns>A list of searchable sections.</returns>
		private IList<Section> GetSearchableSections()
		{
			Contract.Ensures(Contract.Result<IList<Section>>() != null);

			return process.Sections
				.Where(s => !s.Protection.HasFlag(SectionProtection.Guard))
				.Where(s => s.Start.IsInRange(Settings.StartAddress, Settings.StopAddress)
							|| Settings.StartAddress.IsInRange(s.Start, s.End)
							|| Settings.StopAddress.IsInRange(s.Start, s.End))
				.Where(s => s.Type switch
				{
					SectionType.Private => Settings.ScanPrivateMemory,
					SectionType.Image => Settings.ScanImageMemory,
					SectionType.Mapped => Settings.ScanMappedMemory,
					_ => false
				})
				.Where(s =>
				{
					var isWritable = s.Protection.HasFlag(SectionProtection.Write);
					return Settings.ScanWritableMemory switch
					{
						SettingState.Yes => isWritable,
						SettingState.No => !isWritable,
						_ => true
					};
				})
				.Where(s =>
				{
					var isExecutable = s.Protection.HasFlag(SectionProtection.Execute);
					return Settings.ScanExecutableMemory switch
					{
						SettingState.Yes => isExecutable,
						SettingState.No => !isExecutable,
						_ => true
					};
				})
				.Where(s =>
				{
					var isCopyOnWrite = s.Protection.HasFlag(SectionProtection.CopyOnWrite);
					return Settings.ScanCopyOnWriteMemory switch
					{
						SettingState.Yes => isCopyOnWrite,
						SettingState.No => !isCopyOnWrite,
						_ => true
					};
				})
				.ToList();
		}

		/// <summary>
		/// Starts an async search with the provided <see cref="IScanComparer"/>.
		/// The results are stored in the store.
		/// </summary>
		/// <param name="comparer">The comparer to scan for values.</param>
		/// <param name="progress">The <see cref="IProgress{T}"/> object to report the current progress.</param>
		/// <param name="ct">The <see cref="CancellationToken"/> to stop the scan.</param>
		/// <returns> The asynchronous result indicating if the scan completed.</returns>
		public Task<bool> Search(IScanComparer comparer, IProgress<int> progress, CancellationToken ct)
		{
			return isFirstScan ? FirstScan(comparer, progress, ct) : NextScan(comparer, progress, ct);
		}

		/// <summary>
		/// Starts an async first scan with the provided <see cref="IScanComparer"/>.
		/// </summary>
		/// <param name="comparer">The comparer to scan for values.</param>
		/// <param name="progress">The <see cref="IProgress{T}"/> object to report the current progress.</param>
		/// <param name="ct">The <see cref="CancellationToken"/> to stop the scan.</param>
		/// <returns> The asynchronous result indicating if the scan completed.</returns>
		private Task<bool> FirstScan(IScanComparer comparer, IProgress<int> progress, CancellationToken ct)
		{
			Contract.Requires(comparer != null);
			Contract.Ensures(Contract.Result<Task<bool>>() != null);

			var store = CreateStore();

			var sections = GetSearchableSections();
			if (sections.Count == 0)
			{
				return Task.FromResult(true);
			}

			var regions = ConsolidateSections(sections);

			var initialBufferSize = (int)(regions.Average(s => s.Size) + 1);

			progress?.Report(0);

			var counter = 0;
			var totalSectionCount = (float)regions.Count;

			return Task.Run(() =>
			{
				// Algorithm:
				// 1. Partition the sections for the worker threads.
				// 2. Create a ScannerContext per worker thread.
				// 3. n Worker -> m Sections: Read data, search results, store results

				var result = Parallel.ForEach(
					regions, // Sections get grouped by the framework to balance the workers.
					() => new ScannerContext(CreateWorker(Settings, comparer), initialBufferSize), // Create a new context for every worker (thread).
					(s, state, _, context) =>
					{
						if (!ct.IsCancellationRequested)
						{
							var start = s.Address;
							var end = s.Address + s.Size;
							var size = s.Size;

							if (Settings.StartAddress.IsInRange(start, end))
							{
								size -= Settings.StartAddress.Sub(start).ToInt32();
								start = Settings.StartAddress;
							}
							if (Settings.StopAddress.IsInRange(start, end))
							{
								size -= end.Sub(Settings.StopAddress).ToInt32();
							}

							context.EnsureBufferSize(size);
							var buffer = context.Buffer;
							if (process.ReadRemoteMemoryIntoBuffer(start, ref buffer, 0, size)) // Fill the buffer.
							{
								var results = context.Worker.Search(buffer, size, ct) // Search for results.
									.OrderBy(r => r.Address, IntPtrComparer.Instance)
									.ToList();
								if (results.Count > 0)
								{
									var block = CreateResultBlock(results, start);
									store.AddBlock(block); // Store the result block.
								}
							}

							progress?.Report((int)(Interlocked.Increment(ref counter) / totalSectionCount * 100));
						}
						else
						{
							state.Stop();
						}
						return context;
					},
					w => { }
				);

				store.Finish();

				var previousStore = stores.Enqueue(store);
				previousStore?.Dispose();

				isFirstScan = false;

				return result.IsCompleted;
			}, ct);
		}

		/// <summary>
		/// Starts an async next scan with the provided <see cref="IScanComparer"/>.
		/// The next scan uses the previous results to refine the results.
		/// </summary>
		/// <param name="comparer">The comparer to scan for values.</param>
		/// <param name="progress">The <see cref="IProgress{T}"/> object to report the current progress.</param>
		/// <param name="ct">The <see cref="CancellationToken"/> to stop the scan.</param>
		/// <returns> The asynchronous result indicating if the scan completed.</returns>
		private Task<bool> NextScan(IScanComparer comparer, IProgress<int> progress, CancellationToken ct)
		{
			Contract.Requires(comparer != null);
			Contract.Ensures(Contract.Result<Task<bool>>() != null);

			var store = CreateStore();

			progress?.Report(0);

			var counter = 0;
			var totalResultCount = (float)CurrentStore.TotalResultCount;

			return Task.Run(() =>
			{
				var result = Parallel.ForEach(
					CurrentStore.GetResultBlocks(),
					() => new ScannerContext(CreateWorker(Settings, comparer), 0),
					(b, state, _, context) =>
					{
						if (!ct.IsCancellationRequested)
						{
							context.EnsureBufferSize(b.Size);
							var buffer = context.Buffer;
							if (process.ReadRemoteMemoryIntoBuffer(b.Start, ref buffer, 0, b.Size))
							{
								var results = context.Worker.Search(buffer, buffer.Length, b.Results, ct)
									.OrderBy(r => r.Address, IntPtrComparer.Instance)
									.ToList();
								if (results.Count > 0)
								{
									var block = CreateResultBlock(results, b.Start);
									store.AddBlock(block);
								}
							}

							progress?.Report((int)(Interlocked.Add(ref counter, b.Results.Count) / totalResultCount * 100));
						}
						else
						{
							state.Stop();
						}
						return context;
					},
					w => { }
				);

				store.Finish();

				var previousStore = stores.Enqueue(store);
				previousStore?.Dispose();

				return result.IsCompleted;
			}, ct);
		}

		/// <summary>
		/// Consolidate memory sections which are direct neighbours to reduce the number of work items.
		/// </summary>
		/// <param name="sections">A list of sections.</param>
		/// <returns>A list of consolidated memory regions.</returns>
		private static List<ConsolidatedMemoryRegion> ConsolidateSections(IList<Section> sections)
		{
			var regions = new List<ConsolidatedMemoryRegion>();

			if (sections.Count > 0)
			{
				var address = sections[0].Start;
				var size = sections[0].Size.ToInt32();

				for (var i = 1; i < sections.Count; ++i)
				{
					var section = sections[i];
					if (address + size != section.Start)
					{
						regions.Add(new ConsolidatedMemoryRegion { Address = address, Size = size });

						address = section.Start;
						size = section.Size.ToInt32();
					}
					else
					{
						size += section.Size.ToInt32();
					}
				}

				regions.Add(new ConsolidatedMemoryRegion { Address = address, Size = size });
			}

			return regions;
		}

		/// <summary>
		/// Creates a result block from the scan results and adjusts the result offset.
		/// </summary>
		/// <param name="results">The results in this block.</param>
		/// <param name="previousStartAddress">The start address of the previous block or section.</param>
		/// <returns>The new result block.</returns>
		private static ScanResultBlock CreateResultBlock(IReadOnlyList<ScanResult> results, IntPtr previousStartAddress)
		{
			var firstResult = results.First();
			var lastResult = results.Last();

			// Calculate start and end address
			var startAddress = firstResult.Address.Add(previousStartAddress);
			var endAddress = lastResult.Address.Add(previousStartAddress) + lastResult.ValueSize;

			// Adjust the offsets of the results
			var firstOffset = firstResult.Address;
			foreach (var result in results)
			{
				result.Address = result.Address.Sub(firstOffset);
			}

			var block = new ScanResultBlock(
				startAddress,
				endAddress,
				results
			);
			return block;
		}

		private static IScannerWorker CreateWorker(ScanSettings settings, IScanComparer comparer)
		{
			if (comparer is ISimpleScanComparer simpleScanComparer)
			{
				return new SimpleScannerWorker(settings, simpleScanComparer);
			}
			if (comparer is IComplexScanComparer complexScanComparer)
			{
				return new ComplexScannerWorker(settings, complexScanComparer);
			}

			throw new Exception();
		}
	}
}

```

`ReClass.NET/MemoryScanner/ScannerContext.cs`:

```cs
using System.Diagnostics.Contracts;

namespace ReClassNET.MemoryScanner
{
	internal class ScannerContext
	{
		public byte[] Buffer { get; private set; }
		public IScannerWorker Worker { get; }

		public ScannerContext(IScannerWorker worker, int bufferSize)
		{
			Contract.Requires(bufferSize >= 0);
			Contract.Ensures(Buffer != null);
			Contract.Ensures(Worker != null);

			EnsureBufferSize(bufferSize);

			Worker = worker;
		}

		public void EnsureBufferSize(int size)
		{
			Contract.Requires(size >= 0);
			Contract.Ensures(Buffer != null);

			if (Buffer == null || Buffer.Length < size)
			{
				Buffer = new byte[size];
			}
		}
	}
}

```

`ReClass.NET/MemoryScanner/SimpleScannerWorker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Threading;
using ReClassNET.MemoryScanner.Comparer;

namespace ReClassNET.MemoryScanner
{
	internal class SimpleScannerWorker : IScannerWorker
	{
		private readonly ScanSettings settings;
		private readonly ISimpleScanComparer comparer;

		public SimpleScannerWorker(ScanSettings settings, ISimpleScanComparer comparer)
		{
			Contract.Requires(settings != null);
			Contract.Requires(comparer != null);

			this.settings = settings;
			this.comparer = comparer;
		}

		public IList<ScanResult> Search(byte[] data, int count, CancellationToken ct)
		{
			Contract.Requires(data != null);

			var results = new List<ScanResult>();

			var endIndex = count - comparer.ValueSize;

			for (var i = 0; i < endIndex; i += settings.FastScanAlignment)
			{
				if (ct.IsCancellationRequested)
				{
					break;
				}

				if (comparer.Compare(data, i, out var result))
				{
					result.Address = (IntPtr)i;

					results.Add(result);
				}
			}

			return results;
		}

		public IList<ScanResult> Search(byte[] data, int count, IEnumerable<ScanResult> previousResults, CancellationToken ct)
		{
			Contract.Requires(data != null);
			Contract.Requires(previousResults != null);

			var results = new List<ScanResult>();

			var endIndex = count - comparer.ValueSize;

			foreach (var previousResult in previousResults)
			{
				if (ct.IsCancellationRequested)
				{
					break;
				}

				var offset = previousResult.Address.ToInt32();
				if (offset <= endIndex)
				{
					if (comparer.Compare(data, offset, previousResult, out var result))
					{
						result.Address = previousResult.Address;

						results.Add(result);
					}
				}
			}

			return results;
		}
	}
}

```

`ReClass.NET/Native/INativeMethods.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;

namespace ReClassNET.Native
{
	[ContractClass(typeof(NativeMethodsContract))]
	internal interface INativeMethods
	{
		IntPtr LoadLibrary(string fileName);

		IntPtr GetProcAddress(IntPtr handle, string name);

		void FreeLibrary(IntPtr handle);

		Icon GetIconForFile(string path);

		void EnableDebugPrivileges();

		string UndecorateSymbolName(string name);

		void SetProcessDpiAwareness();

		bool RegisterExtension(string fileExtension, string extensionId, string applicationPath, string applicationName);

		void UnregisterExtension(string fileExtension, string extensionId);
	}

	[ContractClassFor(typeof(INativeMethods))]
	internal abstract class NativeMethodsContract : INativeMethods
	{
		public IntPtr LoadLibrary(string fileName)
		{
			Contract.Requires(fileName != null);

			throw new NotImplementedException();
		}

		public IntPtr GetProcAddress(IntPtr handle, string name)
		{
			Contract.Requires(name != null);

			throw new NotImplementedException();
		}

		public void FreeLibrary(IntPtr handle)
		{
			throw new NotImplementedException();
		}

		public Icon GetIconForFile(string path)
		{
			Contract.Requires(path != null);

			throw new NotImplementedException();
		}

		public void EnableDebugPrivileges()
		{
			throw new NotImplementedException();
		}

		public string UndecorateSymbolName(string name)
		{
			Contract.Requires(name != null);
			Contract.Ensures(Contract.Result<string>() != null);

			throw new NotImplementedException();
		}

		public void SetProcessDpiAwareness()
		{
			throw new NotImplementedException();
		}

		public bool RegisterExtension(string fileExtension, string extensionId, string applicationPath, string applicationName)
		{
			Contract.Requires(!string.IsNullOrEmpty(fileExtension));
			Contract.Requires(!string.IsNullOrEmpty(extensionId));
			Contract.Requires(applicationPath != null);
			Contract.Requires(applicationName != null);

			throw new NotImplementedException();
		}

		public void UnregisterExtension(string fileExtension, string extensionId)
		{
			Contract.Requires(!string.IsNullOrEmpty(fileExtension));
			Contract.Requires(!string.IsNullOrEmpty(extensionId));

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Native/NativeMethods.Unix.cs`:

```cs
using System;
using System.Drawing;
using System.Runtime.InteropServices;

namespace ReClassNET.Native
{
	internal class NativeMethodsUnix : INativeMethods
	{
		#region Imports

		private const int RTLD_NOW = 2;

		[DllImport("__Internal")]
		private static extern IntPtr dlopen(string fileName, int flags);

		[DllImport("__Internal")]
		private static extern IntPtr dlsym(IntPtr handle, string symbol);

		[DllImport("__Internal")]
		private static extern int dlclose(IntPtr handle);

		#endregion

		public IntPtr LoadLibrary(string fileName)
		{
			return dlopen(fileName, RTLD_NOW);
		}

		public IntPtr GetProcAddress(IntPtr handle, string name)
		{
			// Warning: dlsym could return IntPtr.Zero to a valid function.
			// Error checking with dlerror is needed but we treat IntPtr.Zero as error value...

			return dlsym(handle, name);
		}

		public void FreeLibrary(IntPtr handle)
		{
			dlclose(handle);
		}

		public Icon GetIconForFile(string path)
		{
			return null;
		}

		public void EnableDebugPrivileges()
		{

		}

		public string UndecorateSymbolName(string name)
		{
			return name;
		}

		public void SetProcessDpiAwareness()
		{

		}

		public bool RegisterExtension(string fileExtension, string extensionId, string applicationPath, string applicationName)
		{
			return false;
		}

		public void UnregisterExtension(string fileExtension, string extensionId)
		{

		}
	}
}

```

`ReClass.NET/Native/NativeMethods.Windows.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Windows.Forms;
using Microsoft.Win32;
using ReClassNET.Extensions;
using ReClassNET.Util;

namespace ReClassNET.Native
{
	internal class NativeMethodsWindows : INativeMethods
	{
		#region Imports

		[DllImport("kernel32.dll", ExactSpelling = true)]
		private static extern bool CloseHandle(IntPtr hObject);

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
		private static extern IntPtr LoadLibrary(string lpFileName);

		[DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true)]
		private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

		[DllImport("kernel32.dll", ExactSpelling = true)]
		private static extern bool FreeLibrary(IntPtr hModule);

		private const uint SHGFI_ICON = 0x100;
		private const uint SHGFI_LARGEICON = 0x0;
		private const uint SHGFI_SMALLICON = 0x1;

		[StructLayout(LayoutKind.Sequential)]
		private struct SHFILEINFO
		{
			public IntPtr hIcon;
			public IntPtr iIcon;
			public uint dwAttributes;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
			public string szDisplayName;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 80)]
			public string szTypeName;
		};

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		private struct LUID
		{
			public uint LowPart;
			public int HighPart;
		}

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		private struct TOKEN_PRIVILEGES
		{
			public uint PrivilegeCount;
			public LUID Luid;
			public uint Attributes;
		}

		[DllImport("shell32.dll")]
		private static extern IntPtr SHGetFileInfo(string pszPath, int dwFileAttributes, ref SHFILEINFO psfi, int cbSizeFileInfo, uint uFlags);

		[DllImport("user32.dll", ExactSpelling = true)]
		private static extern int DestroyIcon(IntPtr hIcon);

		[DllImport("advapi32.dll", ExactSpelling = true)]
		private static extern bool OpenProcessToken(IntPtr ProcessHandle, TokenAccessLevels DesiredAccess, out IntPtr TokenHandle);

		[DllImport("advapi32.dll", ExactSpelling = true)]
		private static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, [MarshalAs(UnmanagedType.Bool)]bool DisableAllPrivileges, ref TOKEN_PRIVILEGES NewState, uint Zero, IntPtr Null1, IntPtr Null2);

		[DllImport("dbghelp.dll", CharSet = CharSet.Unicode)]
		private static extern int UnDecorateSymbolName(string DecoratedName, StringBuilder UnDecoratedName, int UndecoratedLength, int Flags);

		[DllImport("user32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool SetProcessDPIAware();

		private enum ProcessDpiAwareness : uint
		{
			Unaware = 0,
			SystemAware = 1,
			PerMonitorAware = 2
		}

		[DllImport("shcore.dll")]
		private static extern int SetProcessDpiAwareness([MarshalAs(UnmanagedType.U4)] ProcessDpiAwareness a);

		[DllImport("shell32.dll")]
		private static extern void SHChangeNotify(int wEventId, uint uFlags, IntPtr dwItem1, IntPtr dwItem2);

		private const int SHCNE_ASSOCCHANGED = 0x08000000;
		private const uint SHCNF_IDLIST = 0x0000;

		[DllImport("user32.dll")]
		private static extern IntPtr SendMessage(IntPtr hWnd, int nMsg, IntPtr wParam, IntPtr lParam);

		private const int BCM_SETSHIELD = 0x160C;

		#endregion

		IntPtr INativeMethods.LoadLibrary(string fileName)
		{
			return LoadLibrary(fileName);
		}

		IntPtr INativeMethods.GetProcAddress(IntPtr handle, string name)
		{
			return GetProcAddress(handle, name);
		}

		void INativeMethods.FreeLibrary(IntPtr handle)
		{
			FreeLibrary(handle);
		}

		public Icon GetIconForFile(string path)
		{
			var shinfo = new SHFILEINFO();
			if (!SHGetFileInfo(path, 0, ref shinfo, Marshal.SizeOf(shinfo), SHGFI_ICON | SHGFI_SMALLICON).IsNull())
			{
				var icon = Icon.FromHandle(shinfo.hIcon).Clone() as Icon;
				DestroyIcon(shinfo.hIcon);
				return icon;
			}

			return null;
		}

		public void EnableDebugPrivileges()
		{
			if (OpenProcessToken(System.Diagnostics.Process.GetCurrentProcess().Handle, TokenAccessLevels.AllAccess, out var token))
			{
				var privileges = new TOKEN_PRIVILEGES
				{
					PrivilegeCount = 1,
					Luid =
					{
						LowPart = 0x14,
						HighPart = 0
					},
					Attributes = 2
				};

				AdjustTokenPrivileges(token, false, ref privileges, 0, IntPtr.Zero, IntPtr.Zero);

				CloseHandle(token);
			}
		}

		public string UndecorateSymbolName(string name)
		{
			var sb = new StringBuilder(255);
			if (UnDecorateSymbolName(name, sb, sb.Capacity, /*UNDNAME_NAME_ONLY*/0x1000) != 0)
			{
				return sb.ToString();
			}
			return name;
		}

		public void SetProcessDpiAwareness()
		{
			if (WinUtil.IsAtLeastWindows10)
			{
				SetProcessDpiAwareness(ProcessDpiAwareness.SystemAware);
			}
			else if (WinUtil.IsAtLeastWindowsVista)
			{
				SetProcessDPIAware();
			}
		}

		public bool RegisterExtension(string fileExtension, string extensionId, string applicationPath, string applicationName)
		{
			try
			{
				var classesRoot = Registry.ClassesRoot;

				using (var fileExtensionKey = classesRoot.CreateSubKey(fileExtension))
				{
					fileExtensionKey?.SetValue(string.Empty, extensionId, RegistryValueKind.String);
				}

				using (var extensionInfoKey = classesRoot.CreateSubKey(extensionId))
				{
					extensionInfoKey?.SetValue(string.Empty, applicationName, RegistryValueKind.String);

					using (var icon = extensionInfoKey?.CreateSubKey("DefaultIcon"))
					{
						icon?.SetValue(string.Empty, "\"" + applicationPath + "\",0", RegistryValueKind.String);
					}

					using (var shellKey = extensionInfoKey?.CreateSubKey("shell"))
					{
						using (var openKey = shellKey?.CreateSubKey("open"))
						{
							openKey?.SetValue(string.Empty, $"&Open with {applicationName}", RegistryValueKind.String);

							using (var commandKey = openKey?.CreateSubKey("command"))
							{
								commandKey?.SetValue(string.Empty, $"\"{applicationPath}\" \"%1\"", RegistryValueKind.String);
							}
						}
					}
				}

				ShChangeNotify();

				return true;
			}
			catch (Exception)
			{
				return false;
			}
		}

		public void UnregisterExtension(string fileExtension, string extensionId)
		{
			try
			{
				var classesRoot = Registry.ClassesRoot;

				classesRoot.DeleteSubKeyTree(fileExtension);
				classesRoot.DeleteSubKeyTree(extensionId);

				ShChangeNotify();
			}
			catch
			{
				// ignored
			}
		}

		private static void ShChangeNotify()
		{
			try
			{
				SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, IntPtr.Zero, IntPtr.Zero);
			}
			catch
			{
				// ignored
			}
		}

		public static void SetButtonShield(Button button, bool setShield)
		{
			Contract.Requires(button != null);

			try
			{
				if (button.FlatStyle != FlatStyle.System)
				{
					button.FlatStyle = FlatStyle.System;
				}

				var h = button.Handle;
				if (h == IntPtr.Zero)
				{
					return;
				}

				SendMessage(h, BCM_SETSHIELD, IntPtr.Zero, (IntPtr)(setShield ? 1 : 0));
			}
			catch
			{
				// ignored
			}
		}
	}
}

```

`ReClass.NET/Native/NativeMethods.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;

namespace ReClassNET.Native
{
	public static class NativeMethods
	{
		private static readonly INativeMethods nativeMethods;

		static NativeMethods()
		{
			if (IsUnix())
			{
				nativeMethods = new NativeMethodsUnix();
			}
			else
			{
				nativeMethods = new NativeMethodsWindows();
			}
		}

		private static bool? isUnix;
		public static bool IsUnix()
		{
			if (isUnix.HasValue)
			{
				return isUnix.Value;
			}

			var p = GetPlatformId();

			isUnix = (p == PlatformID.Unix) || (p == PlatformID.MacOSX) || ((int)p == 128);

			return isUnix.Value;
		}

		private static PlatformID? plattformId;
		public static PlatformID GetPlatformId()
		{
			if (plattformId.HasValue)
			{
				return plattformId.Value;
			}

			plattformId = Environment.OSVersion.Platform;

			// TODO: Mono returns PlatformID.Unix on Mac OS X

			return plattformId.Value;
		}

		public static IntPtr LoadLibrary(string name)
		{
			Contract.Requires(name != null);

			return nativeMethods.LoadLibrary(name);
		}

		public static IntPtr GetProcAddress(IntPtr handle, string name)
		{
			Contract.Requires(name != null);

			return nativeMethods.GetProcAddress(handle, name);
		}

		public static void FreeLibrary(IntPtr handle)
		{
			nativeMethods.FreeLibrary(handle);
		}

		public static Icon GetIconForFile(string path)
		{
			Contract.Requires(path != null);

			return nativeMethods.GetIconForFile(path);
		}

		public static void EnableDebugPrivileges()
		{
			nativeMethods.EnableDebugPrivileges();
		}

		public static string UndecorateSymbolName(string name)
		{
			Contract.Requires(name != null);
			Contract.Ensures(Contract.Result<string>() != null);

			return nativeMethods.UndecorateSymbolName(name);
		}

		public static void SetProcessDpiAwareness()
		{
			nativeMethods.SetProcessDpiAwareness();
		}

		public static bool RegisterExtension(string fileExtension, string extensionId, string applicationPath, string applicationName)
		{
			Contract.Requires(!string.IsNullOrEmpty(fileExtension));
			Contract.Requires(!string.IsNullOrEmpty(extensionId));
			Contract.Requires(applicationPath != null);
			Contract.Requires(applicationName != null);

			return nativeMethods.RegisterExtension(fileExtension, extensionId, applicationPath, applicationName);
		}

		public static void UnregisterExtension(string fileExtension, string extensionId)
		{
			Contract.Requires(!string.IsNullOrEmpty(fileExtension));
			Contract.Requires(!string.IsNullOrEmpty(extensionId));

			nativeMethods.UnregisterExtension(fileExtension, extensionId);
		}
	}
}

```

`ReClass.NET/Nodes/ArrayNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class ArrayNode : BaseWrapperArrayNode
	{
		public ArrayNode()
		{
			IsReadOnly = false;
		}

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Array";
			icon = Properties.Resources.B16x16_Button_Array;
		}

		public override void Initialize()
		{
			ChangeInnerNode(IntPtr.Size == 4 ? (BaseNode)new Hex32Node() : new Hex64Node());
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, "Array");
		}

		protected override Size DrawChild(DrawContext context, int x, int y)
		{
			var innerContext = context.Clone();
			innerContext.Address = context.Address + Offset + InnerNode.MemorySize * CurrentIndex;
			innerContext.Memory = context.Memory.Clone();
			innerContext.Memory.Offset += Offset + InnerNode.MemorySize * CurrentIndex;

			return InnerNode.Draw(innerContext, x, y);
		}
	}
}

```

`ReClass.NET/Nodes/BaseClassWrapperNode.cs`:

```cs
namespace ReClassNET.Nodes
{
	public abstract class BaseClassWrapperNode : BaseWrapperNode
	{
		public override void Initialize()
		{
			var node = ClassNode.Create();
			node.Initialize();

			ChangeInnerNode(node);
		}

		public override bool CanChangeInnerNodeTo(BaseNode node)
		{
			return node is ClassNode;
		}
	}
}

```

`ReClass.NET/Nodes/BaseContainerNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;

namespace ReClassNET.Nodes
{
	public abstract class BaseContainerNode : BaseNode
	{
		private readonly List<BaseNode> nodes = new List<BaseNode>();

		private int updateCount;

		/// <summary>The child nodes of the container.</summary>
		public IReadOnlyList<BaseNode> Nodes => nodes;

		/// <summary>
		/// If true and the size of replaced nodes differs, the gap will be padded with default nodes (see <see cref="CreateDefaultNodeForSize"/>).
		/// </summary>
		protected abstract bool ShouldCompensateSizeChanges { get; }

		/// <summary>
		/// Should be called before adding a child to test if the container can handle the node type.
		/// </summary>
		/// <param name="node">The new child node.</param>
		/// <returns>True if the container can handle the child node or false otherwise.</returns>
		public abstract bool CanHandleChildNode(BaseNode node);

		private void CheckCanHandleChildNode(BaseNode node)
		{
			if (!CanHandleChildNode(node))
			{
				throw new ArgumentException();
			}
		}

		public override void ClearSelection()
		{
			base.ClearSelection();

			foreach (var node in Nodes)
			{
				node.ClearSelection();
			}
		}

		/// <summary>Calculates the offset of every child node.</summary>
		public virtual void UpdateOffsets()
		{
			var offset = 0;
			foreach (var node in Nodes)
			{
				node.Offset = offset;
				offset += node.MemorySize;
			}
		}

		/// <summary>Searches for the node and returns the zero based index.</summary>
		/// <param name="node">The node to search.</param>
		/// <returns>The found node index or -1 if the node was not found.</returns>
		public int FindNodeIndex(BaseNode node)
		{
			Contract.Requires(node != null);
			Contract.Ensures(Contract.Result<int>() >= -1 && Contract.Result<int>() < nodes.Count);

			return nodes.FindIndex(n => n == node);
		}

		/// <summary>
		/// Checks if the node exists in the container.
		/// </summary>
		/// <param name="node">The node to search.</param>
		/// <returns>True if the node exists in the container, false otherwise.</returns>
		public bool ContainsNode(BaseNode node)
		{
			return FindNodeIndex(node) != -1;
		}

		/// <summary>
		/// Tries to get the predecessor of the given node in the container.
		/// </summary>
		/// <param name="node">The root node.</param>
		/// <param name="predecessor">The predecessor of the given node.</param>
		/// <returns>True if a predecessor exists, otherwise false.</returns>
		public bool TryGetPredecessor(BaseNode node, out BaseNode predecessor)
		{
			Contract.Requires(node != null);

			return TryGetNeighbour(node, -1, out predecessor);
		}

		/// <summary>
		/// Tries to get the successor of the given node in the container.
		/// </summary>
		/// <param name="node">The root node.</param>
		/// <param name="successor">The successor of the given node.</param>
		/// <returns>True if a successor exists, otherwise false.</returns>
		public bool TryGetSuccessor(BaseNode node, out BaseNode successor)
		{
			Contract.Requires(node != null);

			return TryGetNeighbour(node, 1, out successor);
		}

		private bool TryGetNeighbour(BaseNode node, int offset, out BaseNode neighbour)
		{
			Contract.Requires(node != null);

			neighbour = null;

			var index = FindNodeIndex(node);
			if (index == -1)
			{
				return false;
			}

			var neighbourIndex = index + offset;
			if (neighbourIndex < 0 || neighbourIndex >= nodes.Count)
			{
				return false;
			}

			neighbour = nodes[neighbourIndex];

			return true;
		}

		/// <summary>
		/// Disables internal events to speed up batch processing.
		/// <see cref="EndUpdate"/> must be called to restore the functionality.
		/// </summary>
		public void BeginUpdate()
		{
			updateCount++;
		}

		/// <summary>
		/// Enables internal events disabled by <see cref="BeginUpdate"/>.
		/// </summary>
		public void EndUpdate()
		{
			updateCount = Math.Max(0, updateCount - 1);

			OnNodesUpdated();
		}

		private void OnNodesUpdated()
		{
			if (updateCount == 0)
			{
				UpdateOffsets();

				GetParentContainer()?.ChildHasChanged(this);
			}
		}

		/// <summary>Replaces the old node with the new node.</summary>
		/// <param name="oldNode">The old node to replacce.</param>
		/// <param name="newNode">The new node.</param>
		public void ReplaceChildNode(BaseNode oldNode, BaseNode newNode)
		{
			Contract.Requires(oldNode != null);
			Contract.Requires(newNode != null);

			List<BaseNode> dummy = null;
			ReplaceChildNode(oldNode, newNode, ref dummy);
		}

		/// <summary>Replaces the old node with the new node.</summary>
		/// <param name="oldNode">The old node to replacce.</param>
		/// <param name="newNode">The new node.</param>
		/// <param name="additionalCreatedNodes">[out] A list for additional created nodes (see <see cref="ShouldCompensateSizeChanges"/>) or null if not needed.</param>
		public void ReplaceChildNode(BaseNode oldNode, BaseNode newNode, ref List<BaseNode> additionalCreatedNodes)
		{
			Contract.Requires(oldNode != null);
			Contract.Requires(newNode != null);

			CheckCanHandleChildNode(newNode);

			var index = FindNodeIndex(oldNode);
			if (index == -1)
			{
				throw new ArgumentException($"Node {oldNode} is not a child of {this}.");
			}

			newNode.CopyFromNode(oldNode);

			newNode.ParentNode = this;

			nodes[index] = newNode;

			if (ShouldCompensateSizeChanges)
			{
				var oldSize = oldNode.MemorySize;
				var newSize = newNode.MemorySize;

				if (newSize < oldSize)
				{
					InsertBytes(index + 1, oldSize - newSize, ref additionalCreatedNodes);
				}
				/*else if (newSize > oldSize)
				{
					RemoveNodes(index + 1, newSize - oldSize);
				}*/
			}

			OnNodesUpdated();
		}

		/// <summary>
		/// Creates the default container node which takes up to <paramref name="size"/> bytes.
		/// </summary>
		/// <param name="size">The maximum size in bytes.</param>
		/// <returns>A new node or null if no node is available for this size.</returns>
		protected virtual BaseNode CreateDefaultNodeForSize(int size)
		{
			Contract.Requires(size > 0);

#if RECLASSNET64
			if (size >= 8)
			{
				return new Hex64Node();
			}
#endif
			if (size >= 4)
			{
				return new Hex32Node();
			}
			if (size >= 2)
			{
				return new Hex16Node();
			}

			return new Hex8Node();
		}

		/// <summary>Adds the specific amount of bytes at the end of the node.</summary>
		/// <param name="size">The number of bytes to insert.</param>
		public void AddBytes(int size)
		{
			List<BaseNode> dummy = null;
			InsertBytes(nodes.Count, size, ref dummy);
		}

		public void InsertBytes(BaseNode position, int size)
		{
			List<BaseNode> dummy = null;
			InsertBytes(FindNodeIndex(position), size, ref dummy);
		}

		/// <summary>Inserts <paramref name="size"/> bytes at the specified position.</summary>
		/// <param name="index">Zero-based position.</param>
		/// <param name="size">The number of bytes to insert.</param>
		/// <param name="createdNodes">[out] A list with the created nodes.</param>
		protected void InsertBytes(int index, int size, ref List<BaseNode> createdNodes)
		{
			if (index < 0 || index > nodes.Count)
			{
				throw new ArgumentOutOfRangeException($"The index {index} is not in the range [0, {nodes.Count}].");
			}

			if (size == 0)
			{
				return;
			}

			while (size > 0)
			{
				var node = CreateDefaultNodeForSize(size);
				if (node == null)
				{
					break;
				}

				node.ParentNode = this;

				nodes.Insert(index, node);

				createdNodes?.Add(node);

				size -= node.MemorySize;

				index++;
			}

			OnNodesUpdated();
		}

		/// <summary>
		/// Adds all nodes at the end of the container.
		/// </summary>
		/// <param name="nodes">The nodes to add.</param>
		public void AddNodes(IEnumerable<BaseNode> nodes)
		{
			Contract.Requires(nodes != null);

			foreach (var node in nodes)
			{
				AddNode(node);
			}
		}

		/// <summary>
		/// Adds the node at the end of the container.
		/// </summary>
		/// <param name="node">The node to add.</param>
		public void AddNode(BaseNode node)
		{
			Contract.Requires(node != null);

			CheckCanHandleChildNode(node);

			node.ParentNode = this;

			nodes.Add(node);

			OnNodesUpdated();
		}

		/// <summary>
		/// Inserts the node infront of the <paramref name="position"/> node.
		/// </summary>
		/// <param name="position">The target node.</param>
		/// <param name="node">The node to insert.</param>
		public void InsertNode(BaseNode position, BaseNode node)
		{
			Contract.Requires(node != null);

			CheckCanHandleChildNode(node);

			var index = FindNodeIndex(position);
			if (index == -1)
			{
				throw new ArgumentException();
			}

			node.ParentNode = this;

			nodes.Insert(index, node);

			OnNodesUpdated();
		}

		/// <summary>Removes the specified node.</summary>
		/// <param name="node">The node to remove.</param>
		/// <returns>True if it succeeds, false if it fails.</returns>
		public bool RemoveNode(BaseNode node)
		{
			Contract.Requires(node != null);

			var result = nodes.Remove(node);
			if (result)
			{
				OnNodesUpdated();
			}
			return result;
		}

		/// <summary>Called by a child if it has changed.</summary>
		/// <param name="child">The child.</param>
		protected internal virtual void ChildHasChanged(BaseNode child)
		{
			// TODO Add BaseNode.GetParentContainer
		}
	}
}

```

`ReClass.NET/Nodes/BaseFunctionNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseFunctionNode : BaseNode
	{
		protected class FunctionNodeInstruction
		{
			public string Address { get; set; }
			public string Data { get; set; }
			public string Instruction { get; set; }
		}

		protected IntPtr Address = IntPtr.Zero;
		protected readonly List<FunctionNodeInstruction> Instructions = new List<FunctionNodeInstruction>();

		protected Size DrawInstructions(DrawContext view, int tx, int y)
		{
			Contract.Requires(view != null);

			var origY = y;

			var minWidth = 26 * view.Font.Width;
			var maxWidth = 0;

			using (var brush = new SolidBrush(view.Settings.HiddenColor))
			{
				foreach (var instruction in Instructions)
				{
					y += view.Font.Height;

					var x = AddText(view, tx, y, view.Settings.AddressColor, HotSpot.ReadOnlyId, instruction.Address) + 6;

					view.Graphics.FillRectangle(brush, x, y, 1, view.Font.Height);
					x += 6;

					x = Math.Max(AddText(view, x, y, view.Settings.HexColor, HotSpot.ReadOnlyId, instruction.Data) + 6, x + minWidth);

					view.Graphics.FillRectangle(brush, x, y, 1, view.Font.Height);
					x += 6;

					x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, instruction.Instruction);

					maxWidth = Math.Max(x - tx, maxWidth);
				}
			}

			return new Size(maxWidth, y - origY);
		}

		protected void DisassembleRemoteCode(RemoteProcess process, IntPtr address, out int memorySize)
		{
			Contract.Requires(process != null);

			memorySize = 0;

			var disassembler = new Disassembler(process.CoreFunctions);
			foreach (var instruction in disassembler.RemoteDisassembleFunction(process, address, 8192))
			{
				memorySize += instruction.Length;

				Instructions.Add(new FunctionNodeInstruction
				{
					Address = instruction.Address.ToString(Constants.AddressHexFormat),
					Data = string.Join(" ", instruction.Data.Take(instruction.Length).Select(b => $"{b:X2}")),
					Instruction = instruction.Instruction
				});
			}
		}
	}
}

```

`ReClass.NET/Nodes/BaseFunctionPtrNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseFunctionPtrNode : BaseFunctionNode
	{
		public override int MemorySize => IntPtr.Size;

		public override string GetToolTipText(HotSpot spot)
		{
			var ptr = spot.Memory.ReadIntPtr(Offset);

			DisassembleRemoteCode(spot.Process, ptr);

			return string.Join("\n", Instructions.Select(i => i.Instruction));
		}

		protected Size Draw(DrawContext context, int x, int y, string type, string name)
		{
			Contract.Requires(context != null);
			Contract.Requires(type != null);
			Contract.Requires(name != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Function, HotSpot.NoneId, HotSpotType.None);

			var tx = x;

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, name) + context.Font.Width;
			}

			x = AddOpenCloseIcon(context, x, y) + context.Font.Width;

			x = AddComment(context, x, y);

			if (context.Settings.ShowCommentSymbol)
			{
				var value = context.Memory.ReadIntPtr(Offset);

				var module = context.Process.GetModuleToPointer(value);
				if (module != null)
				{
					var symbols = context.Process.Symbols.GetSymbolsForModule(module);
					var symbol = symbols?.GetSymbolString(value, module);
					if (!string.IsNullOrEmpty(symbol))
					{
						x = AddText(context, x, y, context.Settings.OffsetColor, HotSpot.ReadOnlyId, symbol);
					}
				}
			}

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			var size = new Size(x - origX, context.Font.Height);

			if (LevelsOpen[context.Level])
			{
				var ptr = context.Memory.ReadIntPtr(Offset);

				DisassembleRemoteCode(context.Process, ptr);

				var instructionSize = DrawInstructions(context, tx, y);

				size.Width = Math.Max(size.Width, instructionSize.Width + tx - origX);
				size.Height += instructionSize.Height;
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += Instructions.Count * context.Font.Height;
			}
			return height;
		}

		private void DisassembleRemoteCode(RemoteProcess process, IntPtr address)
		{
			Contract.Requires(process != null);

			if (this.Address != address)
			{
				Instructions.Clear();

				this.Address = address;

				if (!address.IsNull() && process.IsValid)
				{
					DisassembleRemoteCode(process, address, out _);
				}
			}
		}
	}
}

```

`ReClass.NET/Nodes/BaseHexCommentNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Text;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseHexCommentNode : BaseHexNode
	{
		protected int AddComment(DrawContext view, int x, int y, float fvalue, IntPtr ivalue, UIntPtr uvalue)
		{
			Contract.Requires(view != null);

			if (view.Settings.ShowCommentFloat)
			{
				x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, fvalue > -999999.0f && fvalue < 999999.0f ? fvalue.ToString("0.000") : "#####") + view.Font.Width;
			}
			if (view.Settings.ShowCommentInteger)
			{
				if (ivalue == IntPtr.Zero)
				{
					x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, "0") + view.Font.Width;
				}
				else
				{
					x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, ivalue.ToInt64().ToString()) + view.Font.Width;
					x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, $"0x{uvalue.ToUInt64():X}") + view.Font.Width;
				}
			}

			if (ivalue != IntPtr.Zero)
			{
				var namedAddress = view.Process.GetNamedAddress(ivalue);
				if (!string.IsNullOrEmpty(namedAddress))
				{
					if (view.Settings.ShowCommentPointer)
					{
						x = AddText(view, x, y, view.Settings.OffsetColor, HotSpot.NoneId, "->") + view.Font.Width;
						x = AddText(view, x, y, view.Settings.OffsetColor, HotSpot.ReadOnlyId, namedAddress) + view.Font.Width;
					}

					if (view.Settings.ShowCommentRtti)
					{
						var rtti = view.Process.ReadRemoteRuntimeTypeInformation(ivalue);
						if (!string.IsNullOrEmpty(rtti))
						{
							x = AddText(view, x, y, view.Settings.OffsetColor, HotSpot.ReadOnlyId, rtti) + view.Font.Width;
						}
					}

					if (view.Settings.ShowCommentSymbol)
					{
						var module = view.Process.GetModuleToPointer(ivalue);
						if (module != null)
						{
							var symbols = view.Process.Symbols.GetSymbolsForModule(module);
							var symbol = symbols?.GetSymbolString(ivalue, module);
							if (!string.IsNullOrEmpty(symbol))
							{
								x = AddText(view, x, y, view.Settings.OffsetColor, HotSpot.ReadOnlyId, symbol) + view.Font.Width;
							}
						}
					}

					if (view.Settings.ShowCommentString)
					{
						var data = view.Process.ReadRemoteMemory(ivalue, 64);

						var isWideString = false;
						string text = null;

						// First check if it could be an UTF8 string and if not try UTF16.
						if (data.Take(IntPtr.Size).InterpretAsSingleByteCharacter().IsPrintableData())
						{
							text = new string(Encoding.UTF8.GetChars(data).TakeWhile(c => c != 0).ToArray());
						}
						else if (data.Take(IntPtr.Size * 2).InterpretAsDoubleByteCharacter().IsPrintableData())
						{
							isWideString = true;

							text = new string(Encoding.Unicode.GetChars(data).TakeWhile(c => c != 0).ToArray());
						}

						if (text != null)
						{
							x = AddText(view, x, y, view.Settings.TextColor, HotSpot.NoneId, isWideString ? "L'" : "'");
							x = AddText(view, x, y, view.Settings.TextColor, HotSpot.ReadOnlyId, text);
							x = AddText(view, x, y, view.Settings.TextColor, HotSpot.NoneId, "'") + view.Font.Width;
						}
					}

					if (view.Settings.ShowCommentPluginInfo)
					{
						var nodeAddress = view.Address + Offset;

						foreach (var reader in NodeInfoReader)
						{
							var info = reader.ReadNodeInfo(this, view.Process, view.Memory, nodeAddress, ivalue);
							if (info != null)
							{
								x = AddText(view, x, y, view.Settings.PluginColor, HotSpot.ReadOnlyId, info) + view.Font.Width;
							}
						}
					}
				}
			}

			return x;
		}
	}
}

```

`ReClass.NET/Nodes/BaseHexNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Nodes
{
	public abstract class BaseHexNode : BaseNode
	{
		private static readonly Random highlightRandom = new Random();
		private static readonly Color[] highlightColors = {
			Color.Aqua, Color.Aquamarine, Color.Blue, Color.BlueViolet, Color.Chartreuse, Color.Crimson, Color.LawnGreen, Color.Magenta
		};
		private static Color GetRandomHighlightColor() => highlightColors[highlightRandom.Next(highlightColors.Length)];

		private static readonly TimeSpan hightlightDuration = TimeSpan.FromSeconds(1);

		private static readonly Dictionary<IntPtr, ValueTypeWrapper<DateTime>> highlightTimer = new Dictionary<IntPtr, ValueTypeWrapper<DateTime>>();

		private readonly byte[] buffer;

		protected BaseHexNode()
		{
			Contract.Ensures(buffer != null);

			buffer = new byte[MemorySize];
		}

		protected Size Draw(DrawContext context, int x, int y, string text, int length)
		{
			Contract.Requires(context != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);
			x = AddIconPadding(context, x);

			x = AddAddressOffset(context, x, y);

			if (!string.IsNullOrEmpty(text))
			{
				x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, text);
			}

			context.Memory.ReadBytes(Offset, buffer);

			var color = context.Settings.HexColor;
			if (context.Settings.HighlightChangedValues)
			{
				var address = context.Address + Offset;

				highlightTimer.RemoveWhere(kv => kv.Value.Value < context.CurrentTime);

				if (highlightTimer.TryGetValue(address, out var until))
				{
					if (until.Value >= context.CurrentTime)
					{
						color = GetRandomHighlightColor();

						if (context.Memory.HasChanged(Offset, MemorySize))
						{
							until.Value = context.CurrentTime.Add(hightlightDuration);
						}
					}
				}
				else if (context.Memory.HasChanged(Offset, MemorySize))
				{
					highlightTimer.Add(address, context.CurrentTime.Add(hightlightDuration));

					color = GetRandomHighlightColor();
				}
			}

			for (var i = 0; i < length; ++i)
			{
				x = AddText(context, x, y, color, i, $"{buffer[i]:X02}") + context.Font.Width;
			}

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}

		/// <summary>Updates the node from the given spot. Sets the value of the selected byte.</summary>
		/// <param name="spot">The spot.</param>
		/// <param name="maxId">The highest spot id.</param>
		public void Update(HotSpot spot, int maxId)
		{
			Contract.Requires(spot != null);

			base.Update(spot);

			if (spot.Id >= 0 && spot.Id < maxId)
			{
				if (byte.TryParse(spot.Text, NumberStyles.HexNumber, null, out var val))
				{
					spot.Process.WriteRemoteMemory(spot.Address + spot.Id, val);
				}
			}
		}

		public byte[] ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadBytes(Offset, MemorySize);
		}
	}
}

```

`ReClass.NET/Nodes/BaseMatrixNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseMatrixNode : BaseNode
	{
		/// <summary>Size of the value type in bytes.</summary>
		public abstract int ValueTypeSize { get; }

		protected BaseMatrixNode()
		{
			LevelsOpen.DefaultValue = true;
		}

		protected delegate void DrawMatrixValues(int x, ref int maxX, ref int y);

		protected Size DrawMatrixType(DrawContext context, int x, int y, string type, int rows, int columns)
		{
			Contract.Requires(context != null);
			Contract.Requires(type != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Matrix, HotSpot.NoneId, HotSpotType.None);

			var tx = x;

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name);
			}
			x = AddOpenCloseIcon(context, x, y);

			x += context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			if (LevelsOpen[context.Level])
			{
				var index = 0;
				for (var row = 0; row < rows; ++row)
				{
					y += context.Font.Height;
					var x2 = tx;

					x2 = AddText(context, x2, y, context.Settings.NameColor, HotSpot.NoneId, "|");

					for (var column = 0; column < columns; ++column)
					{
						var value = context.Memory.ReadFloat(Offset + index * sizeof(float));
						x2 = AddText(context, x2, y, context.Settings.ValueColor, index, $"{value,14:0.000}");

						index++;
					}

					x2 = AddText(context, x2, y, context.Settings.NameColor, HotSpot.NoneId, "|");

					x = Math.Max(x2, x);
				}
			}

			return new Size(x - origX, y - origY + context.Font.Height);
		}

		protected delegate void DrawVectorValues(ref int x, ref int y);
		protected Size DrawVectorType(DrawContext context, int x, int y, string type, int columns)
		{
			Contract.Requires(context != null);
			Contract.Requires(type != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			DrawInvalidMemoryIndicatorIcon(context, y);

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Vector, HotSpot.NoneId, HotSpotType.None);
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name);
			}
			x = AddOpenCloseIcon(context, x, y);

			if (LevelsOpen[context.Level])
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NoneId, "(");
				for (var column = 0; column < columns; ++column)
				{
					var value = context.Memory.ReadFloat(Offset + column * sizeof(float));

					x = AddText(context, x, y, context.Settings.ValueColor, column, $"{value:0.000}");

					if (column < columns - 1)
					{
						x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NoneId, ",");
					}
				}
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NoneId, ")");
			}

			x += context.Font.Width;

			x = AddComment(context, x, y);

			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, y - origY + context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += CalculateValuesHeight(context);
			}
			return height;
		}

		protected abstract int CalculateValuesHeight(DrawContext context);

		public void Update(HotSpot spot, int max)
		{
			Contract.Requires(spot != null);

			base.Update(spot);

			if (spot.Id >= 0 && spot.Id < max)
			{
				if (float.TryParse(spot.Text, out var val))
				{
					spot.Process.WriteRemoteMemory(spot.Address + spot.Id * ValueTypeSize, val);
				}
			}
		}
	}
}

```

`ReClass.NET/Nodes/BaseNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Nodes
{
	public delegate void NodeEventHandler(BaseNode sender);

	[DebuggerDisplay("{" + nameof(DebuggerDisplay) + ",nq}")]
	[ContractClass(typeof(BaseNodeContract))]
	public abstract class BaseNode
	{
		private string DebuggerDisplay => $"Type: {GetType().Name} Name: {Name} Offset: 0x{Offset:X}";

		internal static readonly List<INodeInfoReader> NodeInfoReader = new List<INodeInfoReader>();

		protected static readonly int HiddenHeight = 0;

		private static int nodeIndex = 0;

		private string name = string.Empty;
		private string comment = string.Empty;

		/// <summary>Gets or sets the offset of the node.</summary>
		public int Offset { get; set; }

		/// <summary>Gets or sets the name of the node. If a new name was set the property changed event gets fired.</summary>
		public virtual string Name { get => name; set { if (value != null && name != value) { name = value; NameChanged?.Invoke(this); } } }

		/// <summary>Gets or sets the comment of the node.</summary>
		public string Comment { get => comment; set { if (value != null && comment != value) { comment = value; CommentChanged?.Invoke(this); } } }

		/// <summary>Gets or sets the parent node.</summary>
		public BaseNode ParentNode { get; internal set; }

		/// <summary>Gets a value indicating whether this node is wrapped into an other node.</summary>
		public bool IsWrapped => ParentNode is BaseWrapperNode;

		/// <summary>Gets or sets a value indicating whether this node is hidden.</summary>
		public bool IsHidden { get; set; }

		/// <summary>Gets or sets a value indicating whether this node is selected.</summary>
		public bool IsSelected { get; set; }

		/// <summary>Size of the node in bytes.</summary>
		public abstract int MemorySize { get; }

		public event NodeEventHandler NameChanged;
		public event NodeEventHandler CommentChanged;

		protected GrowingList<bool> LevelsOpen { get; } = new GrowingList<bool>(false);

		[ContractInvariantMethod]
		private void ObjectInvariants()
		{
			Contract.Invariant(name != null);
			Contract.Invariant(comment != null);
			Contract.Invariant(Offset >= 0);
			Contract.Invariant(LevelsOpen != null);
		}

		/// <summary>
		/// Creates an instance of the specific node type.
		/// </summary>
		/// <param name="nodeType">The <see cref="Type"/> of the node.</param>
		/// <returns>An instance of the node type or null if the type is not a valid node type.</returns>
		public static BaseNode CreateInstanceFromType(Type nodeType)
		{
			return CreateInstanceFromType(nodeType, true);
		}

		/// <summary>
		/// Creates an instance of the specific node type.
		/// </summary>
		/// <param name="nodeType">The <see cref="Type"/> of the node.</param>
		/// <param name="callInitialize">If true <see cref="Initialize"/> gets called for the new node.</param>
		/// <returns>An instance of the node type or null if the type is not a valid node type.</returns>
		public static BaseNode CreateInstanceFromType(Type nodeType, bool callInitialize)
		{
			var node = Activator.CreateInstance(nodeType) as BaseNode;
			if (callInitialize)
			{
				node?.Initialize();
			}
			return node;
		}

		/// <summary>Constructor which sets a unique <see cref="Name"/>.</summary>
		protected BaseNode()
		{
			Contract.Ensures(name != null);
			Contract.Ensures(comment != null);

			Name = $"N{nodeIndex++:X08}";
			Comment = string.Empty;

			LevelsOpen[0] = true;
		}

		public abstract void GetUserInterfaceInfo(out string name, out Image icon);

		public virtual bool UseMemoryPreviewToolTip(HotSpot spot, out IntPtr address)
		{
			Contract.Requires(spot != null);

			address = IntPtr.Zero;

			return false;
		}

		/// <summary>Gets informations about this node to show in a tool tip.</summary>
		/// <param name="spot">The spot.</param>
		/// <returns>The information to show in a tool tip or null if no information should be shown.</returns>
		public virtual string GetToolTipText(HotSpot spot)
		{
			Contract.Requires(spot != null);

			return null;
		}

		/// <summary>Called when the node was created. Does not get called after loading a project.</summary>
		public virtual void Initialize()
		{

		}

		/// <summary>Initializes this object from the given node. It copies the name and the comment.</summary>
		/// <param name="node">The node to copy from.</param>
		public virtual void CopyFromNode(BaseNode node)
		{
			Contract.Requires(node != null);

			Name = node.Name;
			Comment = node.Comment;
			Offset = node.Offset;
		}

		/// <summary>
		/// Gets the parent container of the node.
		/// </summary>
		/// <returns></returns>
		public BaseContainerNode GetParentContainer()
		{
			var parentNode = ParentNode;
			while (parentNode != null)
			{
				if (parentNode is BaseContainerNode containerNode)
				{
					return containerNode;
				}

				parentNode = parentNode.ParentNode;
			}

			if (this is BaseContainerNode containerNode2)
			{
				return containerNode2;
			}

			return null;
		}

		/// <summary>
		/// Gets the parent class of the node.
		/// </summary>
		/// <returns></returns>
		public ClassNode GetParentClass()
		{
			var parentNode = ParentNode;
			while (parentNode != null)
			{
				if (parentNode is ClassNode classNode)
				{
					return classNode;
				}

				parentNode = parentNode.ParentNode;
			}

			return null;
		}

		/// <summary>
		/// Gets the root wrapper node if this node is the inner node of a wrapper chain.
		/// </summary>
		/// <returns>The root <see cref="BaseWrapperNode"/> or null if this node is not wrapped or isn't itself a wrapper node.</returns>
		public BaseWrapperNode GetRootWrapperNode()
		{
			BaseWrapperNode rootWrapperNode = null;

			var parentNode = ParentNode;
			while (parentNode is BaseWrapperNode wrapperNode)
			{
				rootWrapperNode = wrapperNode;

				parentNode = parentNode.ParentNode;
			}

			// Test if this node is the root wrapper node.
			if (rootWrapperNode == null)
			{
				if (this is BaseWrapperNode wrapperNode)
				{
					return wrapperNode;
				}
			}

			return rootWrapperNode;
		}

		/// <summary>Clears the selection of the node.</summary>
		public virtual void ClearSelection()
		{
			IsSelected = false;
		}

		/// <summary>Draws the node.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The pixel size the node occupies.</returns>
		public abstract Size Draw(DrawContext context, int x, int y);

		/// <summary>
		/// Calculates the height of the node if drawn.
		/// This method is used to determine if a node outside the visible area should be drawn.
		/// The returned height must be equal to the height which is returned by the <see cref="Draw(DrawContext, int, int)"/> method.
		/// </summary>
		/// <param name="context">The drawing context.</param>
		/// <returns>The calculated height.</returns>
		public abstract int CalculateDrawnHeight(DrawContext context);

		/// <summary>Updates the node from the given <paramref name="spot"/>. Sets the <see cref="Name"/> and <see cref="Comment"/> of the node.</summary>
		/// <param name="spot">The spot.</param>
		public virtual void Update(HotSpot spot)
		{
			Contract.Requires(spot != null);

			if (spot.Id == HotSpot.NameId)
			{
				Name = spot.Text;
			}
			else if (spot.Id == HotSpot.CommentId)
			{
				Comment = spot.Text;
			}
		}

		/// <summary>Toggles the specified level.</summary>
		/// <param name="level">The level to toggle.</param>
		internal void ToggleLevelOpen(int level)
		{
			LevelsOpen[level] = !LevelsOpen[level];
		}

		/// <summary>Sets the specific level.</summary>
		/// <param name="level">The level to set.</param>
		/// <param name="open">True to open.</param>
		internal void SetLevelOpen(int level, bool open)
		{
			LevelsOpen[level] = open;
		}

		/// <summary>Adds a <see cref="HotSpot"/> the user can interact with.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="spot">The spot.</param>
		/// <param name="text">The text to edit.</param>
		/// <param name="id">The id of the spot.</param>
		/// <param name="type">The type of the spot.</param>
		protected void AddHotSpot(DrawContext context, Rectangle spot, string text, int id, HotSpotType type)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Memory != null);
			Contract.Requires(text != null);

			if (spot.Top > context.ClientArea.Bottom || spot.Bottom < 0)
			{
				return;
			}

			context.HotSpots.Add(new HotSpot
			{
				Rect = spot,
				Text = text,
				Address = context.Address + Offset,
				Id = id,
				Type = type,
				Node = this,
				Level = context.Level,
				Process = context.Process,
				Memory = context.Memory
			});
		}

		/// <summary>Draws the specific text and adds a <see cref="HotSpot"/> if <paramref name="hitId"/> is not <see cref="HotSpot.NoneId"/>.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <param name="color">The color of the text.</param>
		/// <param name="hitId">Id for the clickable area.</param>
		/// <param name="text">The text to draw.</param>
		/// <returns>The new x coordinate after drawing the text.</returns>
		protected int AddText(DrawContext context, int x, int y, Color color, int hitId, string text)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);
			Contract.Requires(context.Font != null);
			Contract.Requires(text != null);

			var width = Math.Max(text.Length, hitId != HotSpot.NoneId ? 1 : 0) * context.Font.Width;

			if (y >= -context.Font.Height && y + context.Font.Height <= context.ClientArea.Bottom + context.Font.Height)
			{
				if (hitId != HotSpot.NoneId)
				{
					var rect = new Rectangle(x, y, width, context.Font.Height);
					AddHotSpot(context, rect, text, hitId, HotSpotType.Edit);
				}

				context.Graphics.DrawStringEx(text, context.Font.Font, color, x, y);
				/*using (var brush = new SolidBrush(color))
				{
					context.Graphics.DrawString(text, context.Font.Font, brush, x, y);
				}*/
			}

			return x + width;
		}

		/// <summary>Draws the address and <see cref="Offset"/> of the node.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The new x coordinate after drawing the text.</returns>
		protected int AddAddressOffset(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);
			Contract.Requires(context.Font != null);

			if (context.Settings.ShowNodeOffset)
			{
				x = AddText(context, x, y, context.Settings.OffsetColor, HotSpot.NoneId, $"{Offset:X04}") + context.Font.Width;
			}

			if (context.Settings.ShowNodeAddress)
			{
				x = AddText(context, x, y, context.Settings.AddressColor, HotSpot.AddressId, (context.Address + Offset).ToString(Constants.AddressHexFormat)) + context.Font.Width;
			}

			return x;
		}

		/// <summary>Draws a bar which indicates the selection status of the node. A <see cref="HotSpot"/> for this area gets added too.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <param name="height">The height of the bar.</param>
		protected void AddSelection(DrawContext context, int x, int y, int height)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);

			if (y > context.ClientArea.Bottom || y + height < 0 || IsWrapped)
			{
				return;
			}

			if (IsSelected)
			{
				using var brush = new SolidBrush(context.Settings.SelectedColor);

				context.Graphics.FillRectangle(brush, 0, y, context.ClientArea.Right, height);
			}

			AddHotSpot(context, new Rectangle(0, y, context.ClientArea.Right - (IsSelected ? 16 : 0), height), string.Empty, HotSpot.NoneId, HotSpotType.Select);
		}

		protected int AddIconPadding(DrawContext view, int x)
		{
			return x + view.IconProvider.Dimensions;
		}

		/// <summary>Draws an icon and adds a <see cref="HotSpot"/> if <paramref name="id"/> is not <see cref="HotSpot.NoneId"/>.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <param name="icon">The icon.</param>
		/// <param name="id">The id of the spot.</param>
		/// <param name="type">The type of the spot.</param>
		/// <returns>The new x coordinate after drawing the icon.</returns>
		protected int AddIcon(DrawContext context, int x, int y, Image icon, int id, HotSpotType type)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);
			Contract.Requires(icon != null);

			var size = context.IconProvider.Dimensions;

			if (y > context.ClientArea.Bottom || y + size < 0)
			{
				return x + size;
			}

			context.Graphics.DrawImage(icon, x + 2, y, size, size);

			if (id != HotSpot.NoneId)
			{
				AddHotSpot(context, new Rectangle(x, y, size, size), string.Empty, id, type);
			}

			return x + size;
		}

		/// <summary>Adds a togglable Open/Close icon.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The new x coordinate after drawing the icon.</returns>
		protected int AddOpenCloseIcon(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);

			if (y > context.ClientArea.Bottom || y + context.IconProvider.Dimensions < 0)
			{
				return x + context.IconProvider.Dimensions;
			}

			var icon = LevelsOpen[context.Level] ? context.IconProvider.OpenCloseOpen : context.IconProvider.OpenCloseClosed;
			return AddIcon(context, x, y, icon, 0, HotSpotType.OpenClose);
		}

		/// <summary>Draws a context drop icon if the node is selected.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="y">The y coordinate.</param>
		protected void AddContextDropDownIcon(DrawContext context, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);

			if (context.MultipleNodesSelected || y > context.ClientArea.Bottom || y + context.IconProvider.Dimensions < 0 || IsWrapped)
			{
				return;
			}

			if (IsSelected)
			{
				AddIcon(context, 0, y, context.IconProvider.DropArrow, 0, HotSpotType.Context);
			}
		}

		/// <summary>Draws a delete icon if the node is selected.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="y">The y coordinate.</param>
		protected void AddDeleteIcon(DrawContext context, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);

			if (y > context.ClientArea.Bottom || y + context.IconProvider.Dimensions < 0 || IsWrapped)
			{
				return;
			}

			if (IsSelected)
			{
				AddIcon(context, context.ClientArea.Right - context.IconProvider.Dimensions, y, context.IconProvider.Delete, 0, HotSpotType.Delete);
			}
		}

		/// <summary>Draws the <see cref="Comment"/>.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The new x coordinate after drawing the comment.</returns>
		protected virtual int AddComment(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);
			Contract.Requires(context.Font != null);

			x = AddText(context, x, y, context.Settings.CommentColor, HotSpot.NoneId, "//");
			x = AddText(context, x, y, context.Settings.CommentColor, HotSpot.CommentId, Comment) + context.Font.Width;

			return x;
		}

		/// <summary>Draws a vertical line to show the hidden state.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The size of the drawing.</returns>
		protected Size DrawHidden(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);
			Contract.Requires(context.Graphics != null);

			using (var brush = new SolidBrush(IsSelected ? context.Settings.SelectedColor : context.Settings.HiddenColor))
			{
				context.Graphics.FillRectangle(brush, 0, y, context.ClientArea.Right, 1);
			}

			return new Size(0, HiddenHeight);
		}

		/// <summary>Draws an error indicator if the used memory buffer is not valid.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="y">The y coordinate.</param>
		protected void DrawInvalidMemoryIndicatorIcon(DrawContext context, int y)
		{
			if (!context.Memory.ContainsValidData)
			{
				AddIcon(context, 0, y, Properties.Resources.B16x16_Error, HotSpot.NoneId, HotSpotType.None);
			}
		}
	}

	[ContractClassFor(typeof(BaseNode))]
	internal abstract class BaseNodeContract : BaseNode
	{
		public override int MemorySize
		{
			get
			{
				Contract.Ensures(Contract.Result<int>() >= 0);

				throw new NotImplementedException();
			}
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);

			throw new NotImplementedException();
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			Contract.Requires(context != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Nodes/BaseNumericNode.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseNumericNode : BaseNode
	{
		/// <summary>Draws the node.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <param name="icon">The icon of the node.</param>
		/// <param name="type">The type of the node.</param>
		/// <param name="value">The value of the node.</param>
		/// <param name="alternativeValue">An alternative value of the node.</param>
		/// <returns>The pixel size the node occupies.</returns>
		protected Size DrawNumeric(DrawContext context, int x, int y, Image icon, string type, string value, string alternativeValue)
		{
			Contract.Requires(context != null);
			Contract.Requires(icon != null);
			Contract.Requires(type != null);
			Contract.Requires(value != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, icon, HotSpot.NoneId, HotSpotType.None);
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}
			x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NoneId, "=") + context.Font.Width;
			x = AddText(context, x, y, context.Settings.ValueColor, 0, value) + context.Font.Width;
			if (alternativeValue != null)
			{
				x = AddText(context, x, y, context.Settings.ValueColor, 1, alternativeValue) + context.Font.Width;
			}

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}
	}
}

```

`ReClass.NET/Nodes/BaseTextNode.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Text;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseTextNode : BaseNode
	{
		public int Length { get; set; }

		public override int MemorySize => Length * CharacterSize;

		/// <summary>The encoding of the string.</summary>
		public abstract Encoding Encoding { get; }

		/// <summary>Size of one character in bytes.</summary>
		private int CharacterSize => Encoding.GuessByteCountPerChar();

		public override void CopyFromNode(BaseNode node)
		{
			Length = node.MemorySize / CharacterSize;
		}

		protected Size DrawText(DrawContext context, int x, int y, string type)
		{
			Contract.Requires(context != null);
			Contract.Requires(type != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var length = MemorySize / CharacterSize;
			var text = ReadValueFromMemory(context.Memory);

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Text, HotSpot.NoneId, HotSpotType.None);
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name);
			}
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, "[");
			x = AddText(context, x, y, context.Settings.IndexColor, 0, length.ToString());
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, "]") + context.Font.Width;

			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, "= '");
			x = AddText(context, x, y, context.Settings.TextColor, 1, text.LimitLength(150));
			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, "'") + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0)
			{
				if (int.TryParse(spot.Text, out var val) && val > 0)
				{
					Length = val;

					GetParentContainer()?.ChildHasChanged(this);
				}
			}
			else if (spot.Id == 1)
			{
				var data = Encoding.GetBytes(spot.Text);
				spot.Process.WriteRemoteMemory(spot.Address, data);
			}
		}

		public string ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadString(Encoding, Offset, MemorySize);
		}
	}
}

```

`ReClass.NET/Nodes/BaseTextPtrNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Text;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseTextPtrNode : BaseNode
	{
		private const int MaxStringCharacterCount = 256;

		public override int MemorySize => IntPtr.Size;

		/// <summary>The encoding of the string.</summary>
		public abstract Encoding Encoding { get; }

		/// <summary>Draws this node.</summary>
		/// <param name="context">The drawing context.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <param name="type">The name of the type.</param>
		/// <returns>The pixel size the node occupies.</returns>
		public Size DrawText(DrawContext context, int x, int y, string type)
		{
			Contract.Requires(context != null);
			Contract.Requires(type != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var ptr = context.Memory.ReadIntPtr(Offset);
			var text = context.Process.ReadRemoteString(ptr, Encoding, MaxStringCharacterCount);

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Text, HotSpot.NoneId, HotSpotType.None);
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}

			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, "= '");
			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.ReadOnlyId, text);
			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, "'") + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}
	}
}

```

`ReClass.NET/Nodes/BaseWrapperArrayNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public abstract class BaseWrapperArrayNode : BaseWrapperNode
	{
		public override int MemorySize => InnerNode.MemorySize * Count;

		public int CurrentIndex { get; set; }
		public int Count { get; set; } = 1;
		public bool IsReadOnly { get; protected set; }

		protected override bool PerformCycleCheck => true;

		public override bool CanChangeInnerNodeTo(BaseNode node)
		{
			switch (node)
			{
				case null:
				case ClassNode _:
				case VirtualMethodNode _:
					return false;
			}

			return true;
		}

		protected Size Draw(DrawContext context, int x, int y, string type)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddOpenCloseIcon(context, x, y);
			x = AddIcon(context, x, y, context.IconProvider.Array, HotSpot.NoneId, HotSpotType.None);

			var tx = x;
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, type) + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name);
			}
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, "[");
			x = AddText(context, x, y, context.Settings.IndexColor, IsReadOnly ? HotSpot.NoneId : 0, Count.ToString());
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, "]");

			x = AddIcon(context, x, y, context.IconProvider.LeftArrow, 2, HotSpotType.Click);
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, "(");
			x = AddText(context, x, y, context.Settings.IndexColor, 1, CurrentIndex.ToString());
			x = AddText(context, x, y, context.Settings.IndexColor, HotSpot.NoneId, ")");
			x = AddIcon(context, x, y, context.IconProvider.RightArrow, 3, HotSpotType.Click) + context.Font.Width;

			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, $"<Size={MemorySize}>") + context.Font.Width;
			x = AddIcon(context, x + 2, y, context.IconProvider.Change, 4, HotSpotType.ChangeWrappedType);

			x += context.Font.Width;
			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			y += context.Font.Height;

			var size = new Size(x - origX, context.Font.Height);

			if (LevelsOpen[context.Level])
			{
				var childSize = DrawChild(context, tx, y);

				size.Width = Math.Max(size.Width, childSize.Width + tx - origX);
				size.Height += childSize.Height;
			}

			return size;
		}

		protected abstract Size DrawChild(DrawContext context, int x, int y);

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += InnerNode.CalculateDrawnHeight(context);
			}
			return height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (int.TryParse(spot.Text, out var value))
				{
					if (spot.Id == 0 && !IsReadOnly)
					{
						if (value != 0)
						{
							Count = value;

							GetParentContainer()?.ChildHasChanged(this);
						}
					}
					else
					{
						if (value < Count)
						{
							CurrentIndex = value;
						}
					}
				}
			}
			else if (spot.Id == 2)
			{
				if (CurrentIndex > 0)
				{
					--CurrentIndex;
				}
			}
			else if (spot.Id == 3)
			{
				if (CurrentIndex < Count - 1)
				{
					++CurrentIndex;
				}
			}
		}
	}
}

```

`ReClass.NET/Nodes/BaseWrapperNode.cs`:

```cs
using System;

namespace ReClassNET.Nodes
{
	public abstract class BaseWrapperNode : BaseNode
	{
		/// <summary>Gets or sets the inner node.</summary>
		public BaseNode InnerNode { get; private set; }

		/// <summary>Gets signaled if the inner node was changed.</summary>
		public event NodeEventHandler InnerNodeChanged;

		/// <summary>True to perform class cycle checks when changing the inner node.</summary>
		protected abstract bool PerformCycleCheck { get; }

		/// <summary>
		/// Should be called before <see cref="ChangeInnerNode"/> to test if the node can handle the inner node type.
		/// </summary>
		/// <param name="node">The new inner node type.</param>
		/// <returns>True if the class can handle the inner node type or false otherwise.</returns>
		public abstract bool CanChangeInnerNodeTo(BaseNode node);

		/// <summary>Changes the inner node.</summary>
		/// <param name="node">The new node.</param>
		public void ChangeInnerNode(BaseNode node)
		{
			if (!CanChangeInnerNodeTo(node))
			{
				throw new InvalidOperationException($"Can't change inner node to '{node?.GetType().ToString() ?? "null"}'");
			}

			if (InnerNode != node)
			{
				InnerNode = node;

				if (node != null)
				{
					node.ParentNode = this;
				}

				InnerNodeChanged?.Invoke(this);

				GetParentContainer()?.ChildHasChanged(this);
			}
		}

		/// <summary>
		/// Resolve the most inner node of a <see cref="BaseWrapperNode"/> chain.
		/// </summary>
		/// <returns>The most inner node or null.</returns>
		public BaseNode ResolveMostInnerNode()
		{
			if (InnerNode == null)
			{
				return null;
			}
			if (InnerNode is BaseWrapperNode baseWrapperNode)
			{
				return baseWrapperNode.ResolveMostInnerNode();
			}
			return InnerNode;
		}

		/// <summary>
		/// Tests if the cycle check is really needed in a <see cref="BaseWrapperNode"/> chain.
		/// </summary>
		/// <returns></returns>
		public bool ShouldPerformCycleCheckForInnerNode()
		{
			// TODO Should there be a "is ClassNode" for the last inner node?

			if (!PerformCycleCheck)
			{
				return false;
			}

			var wrapperNode = this;
			while (wrapperNode.InnerNode is BaseWrapperNode wrappedNode)
			{
				if (!wrappedNode.PerformCycleCheck)
				{
					return false;
				}

				wrapperNode = wrappedNode;
			}

			return true;
		}

		/// <summary>
		/// Tests if the given node type is present in the chain of wrapped nodes.
		/// </summary>
		/// <typeparam name="TNode">The node type to check.</typeparam>
		/// <returns>True if the given node type is present in the chain of wrapped nodes, false otherwise.</returns>
		public bool IsNodePresentInChain<TNode>() where TNode : BaseNode
		{
			BaseNode node = this;
			while (node is BaseWrapperNode wrapperNode)
			{
				if (node is TNode)
				{
					return true;
				}

				node = wrapperNode.InnerNode;
			}

			return false;
		}
	}
}

```

`ReClass.NET/Nodes/BitFieldNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Nodes
{
	public class BitFieldNode : BaseNode
	{
		private int size;
		private int bits;

		/// <summary>Gets or sets the bit count.</summary>
		/// <value>Possible values: 64, 32, 16, 8</value>
		public int Bits
		{
			get => bits;
			set
			{
				Contract.Ensures(bits > 0);
				Contract.Ensures(size > 0);

				if (value >= 64)
				{
					bits = 64;
				}
				else if (value >= 32)
				{
					bits = 32;
				}
				else if (value >= 16)
				{
					bits = 16;
				}
				else
				{
					bits = 8;
				}

				size = bits / 8;
			}
		}

		public override int MemorySize => size;

		public BitFieldNode()
		{
			Bits = IntPtr.Size * 8;

			LevelsOpen.DefaultValue = true;
		}

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Bitfield";
			icon = Properties.Resources.B16x16_Button_Bits;
		}

		public override void CopyFromNode(BaseNode node)
		{
			base.CopyFromNode(node);

			Bits = node.MemorySize * 8;
		}

		/// <summary>
		/// Gets the underlaying node for the bit field.
		/// </summary>
		/// <returns></returns>
		public BaseNumericNode GetUnderlayingNode()
		{
			switch (Bits)
			{
				case 8:
					return new UInt8Node();
				case 16:
					return new UInt16Node();
				case 32:
					return new UInt32Node();
				case 64:
					return new UInt64Node();
			}

			throw new Exception(); // TODO
		}

		/// <summary>Converts the memory value to a bit string.</summary>
		/// <param name="memory">The process memory.</param>
		/// <returns>The value converted to a bit string.</returns>
		private string ConvertValueToBitString(MemoryBuffer memory)
		{
			Contract.Requires(memory != null);
			Contract.Ensures(Contract.Result<string>() != null);

			switch(bits)
			{
				case 64:
					return BitString.ToString(memory.ReadInt64(Offset));
				case 32:
					return BitString.ToString(memory.ReadInt32(Offset));
				case 16:
					return BitString.ToString(memory.ReadInt16(Offset));
				default:
					return BitString.ToString(memory.ReadUInt8(Offset));
			}
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			const int BitsPerBlock = 4;

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);
			x = AddIconPadding(context, x);

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Bits") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}

			x = AddOpenCloseIcon(context, x, y) + context.Font.Width;

			var tx = x - 3;

			for (var i = 0; i < bits; ++i)
			{
				var rect = new Rectangle(x + (i + i / BitsPerBlock) * context.Font.Width, y, context.Font.Width, context.Font.Height);
				AddHotSpot(context, rect, string.Empty, i, HotSpotType.Edit);
			}

			var value = ConvertValueToBitString(context.Memory);

			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, value) + context.Font.Width;

			x += context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			if (LevelsOpen[context.Level])
			{
				y += context.Font.Height;

				var format = new StringFormat(StringFormatFlags.DirectionVertical);

				using (var brush = new SolidBrush(context.Settings.ValueColor))
				{
					var maxCharCount = bits + (bits / 4 - 1) - 1;

					for (int bitCount = 0, padding = 0; bitCount < bits; bitCount += 4, padding += 5)
					{
						context.Graphics.DrawString(bitCount.ToString(), context.Font.Font, brush, tx + (maxCharCount - padding) * context.Font.Width, y, format);
					}
				}

				y += 8;
			}

			return new Size(x - origX, y - origY + context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += context.Font.Height + 8;
			}
			return height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id >= 0 && spot.Id < bits)
			{
				if (spot.Text == "1" || spot.Text == "0")
				{
					var bit = bits - 1 - spot.Id;
					var add = bit / 8;
					bit = bit % 8;

					var val = spot.Memory.ReadUInt8(Offset + add);
					if (spot.Text == "1")
					{
						val |= (byte)(1 << bit);
					}
					else
					{
						val &= (byte)~(1 << bit);
					}
					spot.Process.WriteRemoteMemory(spot.Address + add, val);
				}
			}
		}
	}
}

```

`ReClass.NET/Nodes/BoolNode.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class BoolNode : BaseNumericNode
	{
		public override int MemorySize => 1;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Bool";
			icon = Properties.Resources.B16x16_Button_Bool;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);
			x = AddIconPadding(context, x);

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Bool") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}
			x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NoneId, "=") + context.Font.Width;

			var value = context.Memory.ReadUInt8(Offset);
			x = AddText(context, x, y, context.Settings.ValueColor, 0, value == 0 ? "false" : "true") + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}

		/// <summary>Updates the node from the given spot and sets the value.</summary>
		/// <param name="spot">The spot.</param>
		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0)
			{
				if (bool.TryParse(spot.Text, out var val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, (byte)(val ? 1 : 0));
				}
			}
		}
	}
}

```

`ReClass.NET/Nodes/ClassInstanceArrayNode.cs`:

```cs
using System.Drawing;
using ReClassNET.Extensions;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class ClassInstanceArrayNode : BaseArrayNode
	{
		public override int MemorySize => InnerNode.MemorySize * Count;

		public override bool PerformCycleCheck => true;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Class Instance Array";
			icon = Properties.Resources.B16x16_Button_Array;
		}

		public override void Intialize()
		{
			InnerNode = ClassNode.Create();
			InnerNode.Intialize();
		}

		public override Size Draw(ViewInfo view, int x, int y)
		{
			return Draw(view, x, y, "Array", HotSpotType.ChangeClassType);
		}

		protected override Size DrawChild(ViewInfo view, int x, int y)
		{
			var v = view.Clone();
			v.Address = view.Address.Add(Offset) + InnerNode.MemorySize * CurrentIndex;
			v.Memory = view.Memory.Clone();
			v.Memory.Offset += Offset.ToInt32() + InnerNode.MemorySize * CurrentIndex;

			return InnerNode.Draw(v, x, y);
		}
	}
}

```

`ReClass.NET/Nodes/ClassInstanceNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class ClassInstanceNode : BaseClassWrapperNode
	{
		public override int MemorySize => InnerNode.MemorySize;

		protected override bool PerformCycleCheck => true;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Class Instance";
			icon = Properties.Resources.B16x16_Button_Class_Instance;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddOpenCloseIcon(context, x, y);
			x = AddIcon(context, x, y, context.IconProvider.Class, HotSpot.NoneId, HotSpotType.None);

			var tx = x;
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Instance") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}
			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, $"<{InnerNode.Name}>") + context.Font.Width;
			x = AddIcon(context, x, y, context.IconProvider.Change, 4, HotSpotType.ChangeClassType) + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			y += context.Font.Height;

			var size = new Size(x - origX, y - origY);

			if (LevelsOpen[context.Level])
			{
				var innerContext = context.Clone();
				innerContext.Address = context.Address + Offset;
				innerContext.Memory = context.Memory.Clone();
				innerContext.Memory.Offset += Offset;

				var innerSize = InnerNode.Draw(innerContext, tx, y);
				size.Width = Math.Max(size.Width, innerSize.Width + tx - origX);
				size.Height += innerSize.Height;
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += InnerNode.CalculateDrawnHeight(context);
			}
			return height;
		}
	}
}

```

`ReClass.NET/Nodes/ClassNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public delegate void ClassCreatedEventHandler(ClassNode node);

	public class ClassNode : BaseContainerNode
	{
		public static event ClassCreatedEventHandler ClassCreated;

#if RECLASSNET64
		public static IntPtr DefaultAddress { get; } = (IntPtr)0x140000000;
		public static string DefaultAddressFormula { get; } = "140000000";
#else
		public static IntPtr DefaultAddress { get; } = (IntPtr)0x400000;
		public static string DefaultAddressFormula { get; } = "400000";
#endif

		public override int MemorySize => Nodes.Sum(n => n.MemorySize);

		protected override bool ShouldCompensateSizeChanges => true;

		public Guid Uuid { get; set; }

		public string AddressFormula { get; set; } = DefaultAddressFormula;

		public event NodeEventHandler NodesChanged;

		internal ClassNode(bool notifyClassCreated)
		{
			Contract.Ensures(AddressFormula != null);

			LevelsOpen.DefaultValue = true;

			Uuid = Guid.NewGuid();

			if (notifyClassCreated)
			{
				ClassCreated?.Invoke(this);
			}
		}

		public static ClassNode Create()
		{
			Contract.Ensures(Contract.Result<ClassNode>() != null);

			return new ClassNode(true);
		}

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			throw new InvalidOperationException($"The '{nameof(ClassNode)}' node should not be accessible from the ui.");
		}

		public override bool CanHandleChildNode(BaseNode node)
		{
			switch (node)
			{
				case null:
				case ClassNode _:
				case VirtualMethodNode _:
					return false;
			}

			return true;
		}

		public override void Initialize()
		{
			AddBytes(IntPtr.Size);
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			AddSelection(context, 0, y, context.Font.Height);

			var origX = x;
			var origY = y;

			x = AddOpenCloseIcon(context, x, y);

			var tx = x;

			x = AddIcon(context, x, y, context.IconProvider.Class, HotSpot.NoneId, HotSpotType.None);
			x = AddText(context, x, y, context.Settings.OffsetColor, 0, AddressFormula) + context.Font.Width;

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Class") + context.Font.Width;
			x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, $"[{MemorySize}]") + context.Font.Width;
			x = AddComment(context, x, y);

			y += context.Font.Height;

			var size = new Size(x - origX, y - origY);

			if (LevelsOpen[context.Level])
			{
				var childOffset = tx - origX;

				var innerContext = context.Clone();
				innerContext.Level++;
				foreach (var node in Nodes)
				{
					Size AggregateNodeSizes(Size baseSize, Size newSize)
					{
						return new Size(Math.Max(baseSize.Width, newSize.Width), baseSize.Height + newSize.Height);
					}

					Size ExtendWidth(Size baseSize, int width)
					{
						return new Size(baseSize.Width + width, baseSize.Height);
					}

					// Draw the node if it is in the visible area.
					if (context.ClientArea.Contains(tx, y))
					{
						var innerSize = node.Draw(innerContext, tx, y);

						size = AggregateNodeSizes(size, ExtendWidth(innerSize, childOffset));

						y += innerSize.Height;
					}
					else
					{
						// Otherwise calculate the height...
						var calculatedHeight = node.CalculateDrawnHeight(innerContext);

						// and check if the node area overlaps with the visible area...
						if (new Rectangle(tx, y, 9999999, calculatedHeight).IntersectsWith(context.ClientArea))
						{
							// then draw the node...
							var innerSize = node.Draw(innerContext, tx, y);

							size = AggregateNodeSizes(size, ExtendWidth(innerSize, childOffset));

							y += innerSize.Height;
						}
						else
						{
							// or skip drawing and just use the calculated height.
							size = AggregateNodeSizes(size, new Size(0, calculatedHeight));

							y += calculatedHeight;
						}
					}
				}
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				var nv = context.Clone();
				nv.Level++;
				height += Nodes.Sum(n => n.CalculateDrawnHeight(nv));
			}
			return height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0)
			{
				AddressFormula = spot.Text;
			}
		}

		protected internal override void ChildHasChanged(BaseNode child)
		{
			NodesChanged?.Invoke(this);
		}
	}
}

```

`ReClass.NET/Nodes/ClassUtil.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using ReClassNET.Util;

namespace ReClassNET.Nodes
{
	public class ClassUtil
	{
		/// <summary>
		/// Tests if the class to check can be inserted into the parent class without creating a cycle.
		/// </summary>
		/// <param name="parent">The class into which </param>
		/// <param name="classToCheck">The class which should get inserted.</param>
		/// <param name="classes">An enumeration of all available classes.</param>
		/// <returns>True if a cycle is detected, false otherwise.</returns>
		public static bool IsCyclicIfClassIsAccessibleFromParent(ClassNode parent, ClassNode classToCheck, IEnumerable<ClassNode> classes)
		{
			Contract.Requires(parent != null);
			Contract.Requires(classToCheck != null);
			Contract.Requires(classes != null);
			Contract.Requires(Contract.ForAll(classes, c => c != null));

			var graph = new DirectedGraph<ClassNode>();
			graph.AddVertices(classes);

			graph.AddEdge(parent, classToCheck);

			foreach (var c in graph.Vertices)
			{
				foreach (var wrapperNode in c.Nodes.OfType<BaseWrapperNode>())
				{
					if (wrapperNode.ShouldPerformCycleCheckForInnerNode() && wrapperNode.ResolveMostInnerNode() is ClassNode classNode)
					{
						graph.AddEdge(c, classNode);
					}
				}
			}

			return graph.ContainsCycle();
		}
	}
}

```

`ReClass.NET/Nodes/DoubleNode.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class DoubleNode : BaseNumericNode
	{
		public override int MemorySize => 8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Double";
			icon = Properties.Resources.B16x16_Button_Double;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawNumeric(context, x, y, context.IconProvider.Double, "Double", ReadValueFromMemory(context.Memory).ToString("0.000"), null);
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0)
			{
				if (double.TryParse(spot.Text, out var val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public double ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadDouble(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/EnumNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Text;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Project;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class EnumNode : BaseNode
	{
		public override int MemorySize => (int)Enum.Size;

		public EnumDescription Enum { get; private set; } = EnumDescription.Default;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Enum";
			icon = Properties.Resources.B16x16_Button_Enum;
		}

		public void ChangeEnum(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			Enum = @enum;

			GetParentContainer()?.ChildHasChanged(this);
		}

		private string GetTextRepresentation(MemoryBuffer memory)
		{
			return Enum.UseFlagsMode ? GetFlagsStringRepresentation(memory) : GetStringRepresentation(memory);
		}

		private long ReadSignedValueFromMemory(MemoryBuffer memory)
		{
			switch (Enum.Size)
			{
				case EnumDescription.UnderlyingTypeSize.OneByte:
					return memory.ReadInt8(Offset);
				case EnumDescription.UnderlyingTypeSize.TwoBytes:
					return memory.ReadInt16(Offset);
				case EnumDescription.UnderlyingTypeSize.FourBytes:
					return memory.ReadInt32(Offset);
				case EnumDescription.UnderlyingTypeSize.EightBytes:
					return memory.ReadInt64(Offset);
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		private string GetStringRepresentation(MemoryBuffer memory)
		{
			var value = ReadSignedValueFromMemory(memory);
			var index = Enum.Values.FindIndex(kv => kv.Value == value);
			if (index == -1)
			{
				return value.ToString();
			}

			return Enum.Values[index].Key;
		}

		private ulong ReadUnsignedValueFromMemory(MemoryBuffer memory)
		{
			switch (Enum.Size)
			{
				case EnumDescription.UnderlyingTypeSize.OneByte:
					return memory.ReadUInt8(Offset);
				case EnumDescription.UnderlyingTypeSize.TwoBytes:
					return memory.ReadUInt16(Offset);
				case EnumDescription.UnderlyingTypeSize.FourBytes:
					return memory.ReadUInt32(Offset);
				case EnumDescription.UnderlyingTypeSize.EightBytes:
					return memory.ReadUInt64(Offset);
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		private string GetFlagsStringRepresentation(MemoryBuffer memory)
		{
			var value = ReadUnsignedValueFromMemory(memory);
			var result = value;

			var values = Enum.Values;

			var index = values.Count - 1;
			var retval = new StringBuilder();
			var firstTime = true;
			var saveResult = result;

			while (index >= 0)
			{
				var temp = (ulong)values[index].Value;
				if (index == 0 && temp == 0)
				{
					break;
				}

				if ((result & temp) == temp)
				{
					result -= temp;
					if (!firstTime)
					{
						retval.Prepend(" | ");
					}

					retval.Prepend(values[index].Key);
					firstTime = false;
				}

				index--;
			}

			if (result != 0)
			{
				return value.ToString();
			}

			if (saveResult == 0)
			{
				if (values.Count > 0 && values[0].Value == 0)
				{
					return values[0].Key;
				}

				return "0";
			}

			return retval.ToString();
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Enum, HotSpot.NoneId, HotSpotType.None);

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Enum") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}
			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, $"<{Enum.Name}>") + context.Font.Width;
			x = AddIcon(context, x, y, context.IconProvider.Change, 4, HotSpotType.ChangeEnumType) + context.Font.Width;

			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, "=") + context.Font.Width;

			var text = GetTextRepresentation(context.Memory);

			x = AddText(context, x, y, context.Settings.TextColor, HotSpot.NoneId, text) + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			return new Size(x - origX, context.Font.Height);
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			return IsHidden && !IsWrapped ? HiddenHeight : context.Font.Height;
		}
	}
}

```

`ReClass.NET/Nodes/FloatNode.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class FloatNode : BaseNumericNode
	{
		public override int MemorySize => 4;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Float";
			icon = Properties.Resources.B16x16_Button_Float;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawNumeric(context, x, y, context.IconProvider.Float, "Float", ReadValueFromMemory(context.Memory).ToString("0.000"), null);
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0)
			{
				if (float.TryParse(spot.Text, out var val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public float ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadFloat(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/FunctionNode.Tokenizer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using ReClassNET.Memory;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET.Nodes
{
	public class FunctionNode : BaseNode
	{
		private IntPtr address = IntPtr.Zero;
		private readonly List<string> instructions = new List<string>();
		private readonly List<Tuple<string, string, string>> instructions2 = new List<Tuple<string, string, string>>();

		public string Signature { get; set; } = "void function()";

		public ClassNode BelongsToClass { get; set; }

		private int memorySize = IntPtr.Size;
		/// <summary>Size of the node in bytes.</summary>
		public override int MemorySize => memorySize;

		public override string GetToolTipText(HotSpot spot, MemoryBuffer memory)
		{
			DisassembleRemoteCode(memory, spot.Address);

			return string.Join("\n", instructions);
		}

		public override int Draw(ViewInfo view, int x, int y)
		{
			Contract.Requires(view != null);

			if (IsHidden)
			{
				return DrawHidden(view, x, y);
			}

			AddSelection(view, x, y, view.Font.Height);
			AddDelete(view, x, y);
			AddTypeDrop(view, x, y);

			x += TextPadding;

			x = AddIcon(view, x, y, Icons.Function, -1, HotSpotType.None);

			var tx = x;

			x = AddAddressOffset(view, x, y);

			x = AddText(view, x, y, view.Settings.TypeColor, HotSpot.NoneId, "Function") + view.Font.Width;
			x = AddText(view, x, y, view.Settings.NameColor, HotSpot.NameId, Name) + view.Font.Width;

			x = AddOpenClose(view, x, y) + view.Font.Width;

			x = AddComment(view, x, y);

			var ptr = view.Address.Add(Offset);

			DisassembleRemoteCode(view.Memory, ptr);

			if (levelsOpen[view.Level])
			{
				y += view.Font.Height;
				x = AddText(view, tx, y, view.Settings.TypeColor, HotSpot.NoneId, "Signature:") + view.Font.Width;
				x = AddText(view, x, y, view.Settings.ValueColor, 0, Signature);

				y += view.Font.Height;
				x = AddText(view, tx, y, view.Settings.TextColor, HotSpot.NoneId, "Belongs to: ");
				x = AddText(view, x, y, view.Settings.ValueColor, HotSpot.NoneId, BelongsToClass == null ? "<None>" : $"<{BelongsToClass.Name}>");
				x = AddIcon(view, x, y, Icons.Change, 1, HotSpotType.ChangeType);

				var minWidth = 26 * view.Font.Width;

				var addressColor = Color.FromArgb(128, 128, 128);

				y += 4;
				foreach (var line in instructions2)
				{
					y += view.Font.Height;

					//AddText(view, tx, y, view.Settings.NameColor, HotSpot.ReadOnlyId, line);
					x = AddText(view, tx, y, view.Settings.AddressColor, HotSpot.ReadOnlyId, line.Item1) + 15;
					x = Math.Max(AddText(view, x, y, view.Settings.HexColor, HotSpot.ReadOnlyId, line.Item2), x + minWidth) + 6;

					/*foreach (var token in new AssemblerTokenizer().Read(line.Item3))
					{
						var color = Color.Black;
						if (token.TokenType == TokenType.Keyword)
						{
							if (AssemblerTokenizer.IsKeyword(token.Value))
							{
								color = Color.Navy;
							}
							else if (AssemblerTokenizer.IsRegister(token.Value))
							{
								color = Color.Green;
							}
						}
						else if (token.TokenType == TokenType.Bracket)
						{
							color = Color.Purple;
						}
						else if (token.TokenType == TokenType.Operation)
						{
							color = Color.Red;
						}

						x = AddText(view, x, y, color, HotSpot.NoneId, token.Value) + 5;
					}*/
					AddText(view, x, y, view.Settings.ValueColor, HotSpot.ReadOnlyId, line.Item3);

				}
				y += 4;
			}

			return y + view.Font.Height;
		}

		public override int CalculateHeight(ViewInfo view)
		{
			if (IsHidden)
			{
				return HiddenHeight;
			}

			var h = view.Font.Height;
			if (levelsOpen[view.Level])
			{
				h += instructions.Count() * view.Font.Height;
			}
			return h;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0) // Signature
			{
				Signature = spot.Text;
			}
		}

		private void DisassembleRemoteCode(MemoryBuffer memory, IntPtr address)
		{
			Contract.Requires(memory != null);

			if (this.address != address)
			{
				instructions.Clear();

				this.address = address;

				if (!address.IsNull() && memory.Process.IsValid)
				{
					memorySize = 0;

					var disassembler = new Disassembler(memory.Process.CoreFunctions);
					foreach (var instruction in disassembler.RemoteDisassembleFunction(memory.Process, address, 8192))
					{
						memorySize += instruction.Length;

						instructions.Add($"{instruction.Address.ToString(Constants.StringHexFormat)} {instruction.Instruction}");
						instructions2.Add(Tuple.Create(instruction.Address.ToString(Constants.StringHexFormat), Utils.BytesToString(instruction.Data, instruction.Length), instruction.Instruction));
					}

					ParentNode?.ChildHasChanged(this);
				}
			}
		}
	}

	enum TokenType
	{
		Number,
		Keyword,
		Operation,
		Bracket,
		Register,
		Text
	}

	class Token
	{
		/// <summary>The type of the token.</summary>
		public TokenType TokenType { get; }

		/// <summary>The value of the token.</summary>
		public string Value { get; }

		public Token(TokenType type, string value)
		{
			Contract.Requires(value != null);

			TokenType = type;
			Value = value;
		}

		public override string ToString()
		{
			return $"{TokenType} {Value}";
		}
	}

	class AssemblerTokenizer
	{
		public List<Token> Read(string instruction)
		{
			Contract.Requires(instruction != null);

			var tokens = new List<Token>();

			var characters = instruction.ToCharArray();
			for (var i = 0; i < characters.Length; ++i)
			{
				if (IsPartOfKeyword(characters[i], true))
				{
					var buffer = characters[i].ToString();
					while (++i < characters.Length && IsPartOfKeyword(characters[i], false))
					{
						buffer += characters[i];
					}

					if (IsRegister(buffer))
					{
						tokens.Add(new Token(TokenType.Register, buffer));
					}
					else if (IsKeyword(buffer))
					{
						tokens.Add(new Token(TokenType.Keyword, buffer));
					}
					else
					{
						tokens.Add(new Token(TokenType.Text, buffer));
					}

					if (i == characters.Length)
					{
						continue;
					}
				}

				if (IsPartOfNumber(characters[i], true))
				{
					var buffer = characters[i].ToString();
					while (++i < characters.Length && IsPartOfNumber(characters[i], false))
					{
						buffer += characters[i];
					}

					tokens.Add(new Token(TokenType.Number, buffer));

					if (i == characters.Length)
					{
						continue;
					}
				}

				switch (characters[i])
				{
					case ' ':
						continue;
					case ',':
					case ':':
						tokens.Add(new Token(TokenType.Text, characters[i].ToString()));
						break;
					case '+':
					case '-':
					case '*':
					case '/':
						tokens.Add(new Token(TokenType.Operation, characters[i].ToString()));
						break;
					case '[':
					case ']':
						tokens.Add(new Token(TokenType.Bracket, characters[i].ToString()));
						break;
					default:
						throw new Exception($"Invalid token '{characters[i]}' detected at position {i}.");
				}
			}

			return tokens;
		}

		private bool IsPartOfKeyword(char character, bool isFirstCharacter)
		{
			return (character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') || (!isFirstCharacter && (character >= '0' && character <= '9'));
		}

		private bool IsPartOfNumber(char character, bool isFirstCharacter)
		{
			return (character >= '0' && character <= '9') || (character >= 'a' && character <= 'f') || (character >= 'A' && character <= 'F') || (!isFirstCharacter && (character == 'x' || character == 'X'));
		}

		private static HashSet<string> Registers = new HashSet<string>
		{
			"rax", "eax", "ax", "al", "ah",
			"rbx", "ebx", "bx", "bl", "bh",
			"rcx", "ecx", "cx", "cl", "ch",
			"rdx", "edx", "dx", "dl", "dh",
			"rsi", "esi", "si", "sil",
			"rdi", "edi", "di", "dil",
			"rbp", "ebp", "bp", "bpl",
			"rsp", "esp", "sp", "spl",
			"r8", "r8d", "r8w", "r8b",
			"r9", "r9d", "r9w", "r9b",
			"r10", "r10d", "r10w", "r10b",
			"r11", "r11d", "r11w", "r11b",
			"r12", "r12d", "r12w", "r12b",
			"r13", "r13d", "r13w", "r13b",
			"r14", "r14d", "r14w", "r14b",
			"r15", "r15d", "r15w", "r15b",
			"xmm0", "ymm0",
			"xmm1", "ymm1",
			"xmm2", "ymm2",
			"xmm3", "ymm3",
			"xmm4", "ymm4",
			"xmm5", "ymm5",
			"xmm6", "ymm6",
			"xmm7", "ymm7",
			"xmm8", "ymm8",
			"xmm9", "ymm9",
			"xmm10", "ymm10",
			"xmm11", "ymm11",
			"xmm12", "ymm12",
			"xmm13", "ymm13",
			"xmm14", "ymm14",
			"xmm15", "ymm15"
		};

		public static bool IsRegister(string text)
		{
			return Registers.Contains(text);
		}

		private static HashSet<string> Keywords = new HashSet<string>
		{
			"ret", "retn",
			"call",
			"jl", "ja", "jb", "jbe", "je", "jz", "js", "jne", "jnz", "jns", "jae", "jmp",
			"push", "pop"
		};

		public static bool IsKeyword(string text)
		{
			return Keywords.Contains(text);
		}
	}
}

```

`ReClass.NET/Nodes/FunctionNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class FunctionNode : BaseFunctionNode
	{
		public string Signature { get; set; } = "void function()";

		public ClassNode BelongsToClass { get; set; }

		private int memorySize = IntPtr.Size;
		public override int MemorySize => memorySize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Function";
			icon = Properties.Resources.B16x16_Button_Function;
		}

		public override string GetToolTipText(HotSpot spot)
		{
			DisassembleRemoteCode(spot.Process, spot.Address);

			return string.Join("\n", Instructions.Select(i => i.Instruction));
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			Contract.Requires(context != null);

			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;

			AddSelection(context, x, y, context.Font.Height);

			x = AddIconPadding(context, x);

			x = AddIcon(context, x, y, context.IconProvider.Function, HotSpot.NoneId, HotSpotType.None);

			var tx = x;

			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Function") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}

			x = AddOpenCloseIcon(context, x, y) + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			var size = new Size(x - origX, context.Font.Height);

			var ptr = context.Address + Offset;
			DisassembleRemoteCode(context.Process, ptr);

			if (LevelsOpen[context.Level])
			{
				y += context.Font.Height;
				x = AddText(context, tx, y, context.Settings.TypeColor, HotSpot.NoneId, "Signature:") + context.Font.Width;
				x = AddText(context, x, y, context.Settings.ValueColor, 0, Signature);
				size.Width = Math.Max(size.Width, x - origX);
				size.Height += context.Font.Height;

				y += context.Font.Height;
				x = AddText(context, tx, y, context.Settings.TextColor, HotSpot.NoneId, "Belongs to: ");
				x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, BelongsToClass == null ? "<None>" : $"<{BelongsToClass.Name}>") + context.Font.Width;
				x = AddIcon(context, x, y, context.IconProvider.Change, 1, HotSpotType.ChangeClassType);
				size.Width = Math.Max(size.Width, x - origX);
				size.Height += context.Font.Height;

				var instructionSize = DrawInstructions(context, tx, y + 4);
				size.Width = Math.Max(size.Width, instructionSize.Width + tx - origX);
				size.Height += instructionSize.Height + 4;
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += Instructions.Count * context.Font.Height;
			}
			return height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0) // Signature
			{
				Signature = spot.Text;
			}
		}

		private void DisassembleRemoteCode(RemoteProcess process, IntPtr address)
		{
			Contract.Requires(process != null);

			if (this.Address != address)
			{
				Instructions.Clear();

				this.Address = address;

				if (!address.IsNull() && process.IsValid)
				{
					DisassembleRemoteCode(process, address, out memorySize);
				}

				GetParentContainer()?.ChildHasChanged(this);
			}
		}
	}
}

```

`ReClass.NET/Nodes/FunctionPtrNode.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class FunctionPtrNode : BaseFunctionPtrNode
	{
		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Function Pointer";
			icon = Properties.Resources.B16x16_Button_Function_Pointer;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, "FunctionPtr", Name);
		}
	}
}

```

`ReClass.NET/Nodes/Hex16Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Hex16Node : BaseHexNode
	{
		public override int MemorySize => 2;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Hex16";
			icon = Properties.Resources.B16x16_Button_Hex_16;
		}

		public override string GetToolTipText(HotSpot spot)
		{
			var value = new UInt16Data { ShortValue = spot.Memory.ReadInt16(Offset) };

			return $"Int16: {value.ShortValue}\nUInt16: 0x{value.UShortValue:X04}";
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, context.Settings.ShowNodeText ? context.Memory.ReadString(context.Settings.RawDataEncoding, Offset, 2) + "       " : null, 2);
		}

		public override void Update(HotSpot spot)
		{
			Update(spot, 2);
		}
	}
}

```

`ReClass.NET/Nodes/Hex32Node.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Hex32Node : BaseHexCommentNode
	{
		public override int MemorySize => 4;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Hex32";
			icon = Properties.Resources.B16x16_Button_Hex_32;
		}

		public override bool UseMemoryPreviewToolTip(HotSpot spot, out IntPtr address)
		{
			var value = ReadFromBuffer(spot.Memory, Offset);

			address = value.IntPtr;

			return spot.Process?.GetNamedAddress(value.IntPtr) != null;
		}

		public override string GetToolTipText(HotSpot spot)
		{
			var value = ReadFromBuffer(spot.Memory, Offset);

			return $"Int32: {value.IntValue}\nUInt32: 0x{value.UIntValue:X08}\nFloat: {value.FloatValue:0.000}";
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, context.Settings.ShowNodeText ? context.Memory.ReadString(context.Settings.RawDataEncoding, Offset, 4) + "     " : null, 4);
		}

		public override void Update(HotSpot spot)
		{
			Update(spot, 4);
		}

		protected override int AddComment(DrawContext context, int x, int y)
		{
			x = base.AddComment(context, x, y);

			var value = ReadFromBuffer(context.Memory, Offset);

			x = AddComment(context, x, y, value.FloatValue, value.IntPtr, value.UIntPtr);

			return x;
		}

		private static UInt32FloatData ReadFromBuffer(MemoryBuffer memory, int offset) => new UInt32FloatData
		{
			Raw = memory.ReadInt32(offset)
		};
	}
}

```

`ReClass.NET/Nodes/Hex64Node.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Hex64Node : BaseHexCommentNode
	{
		public override int MemorySize => 8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Hex64";
			icon = Properties.Resources.B16x16_Button_Hex_64;
		}

		public override bool UseMemoryPreviewToolTip(HotSpot spot, out IntPtr address)
		{
			var value = ReadFromBuffer(spot.Memory, Offset);

			address = value.IntPtr;

			return spot.Process.GetSectionToPointer(value.IntPtr) != null;
		}

		public override string GetToolTipText(HotSpot spot)
		{
			var value = ReadFromBuffer(spot.Memory, Offset);

			return $"Int64: {value.LongValue}\nUInt64: 0x{value.ULongValue:X016}\nFloat: {value.FloatValue:0.000}\nDouble: {value.DoubleValue:0.000}";
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, context.Settings.ShowNodeText ? context.Memory.ReadString(context.Settings.RawDataEncoding, Offset, 8) + " " : null, 8);
		}

		public override void Update(HotSpot spot)
		{
			Update(spot, 8);
		}

		protected override int AddComment(DrawContext context, int x, int y)
		{
			x = base.AddComment(context, x, y);

			var value = ReadFromBuffer(context.Memory, Offset);

			x = AddComment(context, x, y, value.FloatValue, value.IntPtr, value.UIntPtr);

			return x;
		}

		private static UInt64FloatDoubleData ReadFromBuffer(MemoryBuffer memory, int offset) => new UInt64FloatDoubleData
		{
			Raw1 = memory.ReadInt32(offset),
			Raw2 = memory.ReadInt32(offset + sizeof(int))
		};
	}
}

```

`ReClass.NET/Nodes/Hex8Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Hex8Node : BaseHexNode
	{
		public override int MemorySize => 1;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Hex8";
			icon = Properties.Resources.B16x16_Button_Hex_8;
		}

		public override string GetToolTipText(HotSpot spot)
		{
			var b = spot.Memory.ReadUInt8(Offset);

			return $"Int8: {(int)b}\nUInt8: 0x{b:X02}";
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, context.Settings.ShowNodeText ? context.Memory.ReadString(context.Settings.RawDataEncoding, Offset, 1) + "        " : null, 1);
		}

		public override void Update(HotSpot spot)
		{
			Update(spot, 1);
		}
	}
}

```

`ReClass.NET/Nodes/INodeInfoReader.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using ReClassNET.Memory;

namespace ReClassNET.Nodes
{
	[ContractClass(typeof(NodeInfoReaderContract))]
	public interface INodeInfoReader
	{
		/// <summary>
		/// Used to print custom informations about a node.
		/// </summary>
		/// <param name="node">The node.</param>
		/// <param name="reader">The current <see cref="IRemoteMemoryReader"/>.</param>
		/// <param name="memory">The current <see cref="MemoryBuffer"/>.</param>
		/// <param name="nodeAddress">The absolute address of the node.</param>
		/// <param name="nodeValue">The memory value of the node as <see cref="IntPtr"/>.</param>
		/// <returns>Custom informations about the node or null.</returns>
		string ReadNodeInfo(BaseHexCommentNode node, IRemoteMemoryReader reader, MemoryBuffer memory, IntPtr nodeAddress, IntPtr nodeValue);
	}

	[ContractClassFor(typeof(INodeInfoReader))]
	internal abstract class NodeInfoReaderContract : INodeInfoReader
	{
		public string ReadNodeInfo(BaseHexCommentNode node, IRemoteMemoryReader reader, MemoryBuffer memory, IntPtr nodeAddress, IntPtr nodeValue)
		{
			Contract.Requires(node != null);
			Contract.Requires(reader != null);
			Contract.Requires(memory != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Nodes/Int16Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Int16Node : BaseNumericNode
	{
		public override int MemorySize => 2;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Int16";
			icon = Properties.Resources.B16x16_Button_Int_16;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Signed, "Int16", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (short.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && short.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public short ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadInt16(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/Int32Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Int32Node : BaseNumericNode
	{
		public override int MemorySize => 4;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Int32";
			icon = Properties.Resources.B16x16_Button_Int_32;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Signed, "Int32", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (int.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && int.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public int ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadInt32(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/Int64Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Int64Node : BaseNumericNode
	{
		public override int MemorySize => 8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Int64";
			icon = Properties.Resources.B16x16_Button_Int_64;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Signed, "Int64", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (long.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && long.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public long ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadInt64(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/Int8Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Int8Node : BaseNumericNode
	{
		public override int MemorySize => 1;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Int8";
			icon = Properties.Resources.B16x16_Button_Int_8;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Signed, "Int8", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (sbyte.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && sbyte.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public sbyte ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadInt8(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/Matrix3x3Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Matrix3x3Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 9 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Matrix 3x3";
			icon = Properties.Resources.B16x16_Button_Matrix_3x3;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawMatrixType(context, x2, y2, "Matrix (3x3)", 3, 3);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 3 * context.Font.Height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 9);
		}
	}
}

```

`ReClass.NET/Nodes/Matrix3x4Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Matrix3x4Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 12 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Matrix 3x4";
			icon = Properties.Resources.B16x16_Button_Matrix_3x4;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawMatrixType(context, x2, y2, "Matrix (3x4)", 3, 4);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 3 * context.Font.Height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 12);
		}
	}
}

```

`ReClass.NET/Nodes/Matrix4x4Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Matrix4x4Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 16 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Matrix 4x4";
			icon = Properties.Resources.B16x16_Button_Matrix_4x4;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawMatrixType(context, x2, y2, "Matrix (4x4)", 4, 4);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 4 * context.Font.Height;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 16);
		}
	}
}

```

`ReClass.NET/Nodes/NIntNode.cs`:

```cs
using System;
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class NIntNode : BaseNumericNode
	{
		public override int MemorySize => IntPtr.Size;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "NInt";
			icon = Properties.Resources.B16x16_Button_NInt;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory)
#if RECLASSNET64
				.ToInt64();
#else
				.ToInt32();
#endif
			return DrawNumeric(context, x, y, context.IconProvider.Signed, "NInt", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
#if RECLASSNET64
				if (long.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && long.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
#else
				if (int.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && int.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
#endif
			}
		}

		public IntPtr ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadIntPtr(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/NUIntNode.cs`:

```cs
using System;
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class NUIntNode : BaseNumericNode
	{
		public override int MemorySize => UIntPtr.Size;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "NUInt";
			icon = Properties.Resources.B16x16_Button_NUInt;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory)
#if RECLASSNET64
				.ToUInt64();
#else
				.ToUInt32();
#endif
			return DrawNumeric(context, x, y, context.IconProvider.Unsigned, "NUInt", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
#if RECLASSNET64
				if (ulong.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && ulong.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
#else
				if (uint.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && uint.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
#endif
			}
		}

		public UIntPtr ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadUIntPtr(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/PointerNode.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class PointerNode : BaseWrapperNode
	{
		private readonly MemoryBuffer memory = new MemoryBuffer();

		public override int MemorySize => IntPtr.Size;

		protected override bool PerformCycleCheck => false;

		public PointerNode()
		{
			LevelsOpen.DefaultValue = true;
		}

		public override void Initialize()
		{
			var node = new ClassInstanceNode();
			node.Initialize();
			((BaseContainerNode)node.InnerNode).AddBytes(16 * IntPtr.Size);

			ChangeInnerNode(node);
		}

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Pointer";
			icon = Properties.Resources.B16x16_Button_Pointer;
		}

		public override bool UseMemoryPreviewToolTip(HotSpot spot, out IntPtr address)
		{
			// TODO Should the preview be disabled if an inner node is set?

			address = spot.Memory.ReadIntPtr(Offset);

			return spot.Process.GetNamedAddress(address) != null;
		}

		public override bool CanChangeInnerNodeTo(BaseNode node) =>
			node switch
			{
				ClassNode _ => false,
				VirtualMethodNode _ => false,
				_ => true
			};

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			if (InnerNode != null)
			{
				x = AddOpenCloseIcon(context, x, y);
			}
			else
			{
				x = AddIconPadding(context, x);
			}
			x = AddIcon(context, x, y, context.IconProvider.Pointer, HotSpot.NoneId, HotSpotType.None);

			var tx = x;
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Ptr") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}
			if (InnerNode == null)
			{
				x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, "<void>") + context.Font.Width;
			}
			x = AddIcon(context, x, y, context.IconProvider.Change, 4, HotSpotType.ChangeWrappedType) + context.Font.Width;

			var ptr = context.Memory.ReadIntPtr(Offset);

			x = AddText(context, x, y, context.Settings.OffsetColor, HotSpot.NoneId, "->") + context.Font.Width;
			x = AddText(context, x, y, context.Settings.ValueColor, 0, "0x" + ptr.ToString(Constants.AddressHexFormat)) + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			y += context.Font.Height;

			var size = new Size(x - origX, y - origY);

			if (LevelsOpen[context.Level] && InnerNode != null)
			{
				memory.Size = InnerNode.MemorySize;
				memory.UpdateFrom(context.Process, ptr);

				var innerContext = context.Clone();
				innerContext.Address = ptr;
				innerContext.Memory = memory;

				var innerSize = InnerNode.Draw(innerContext, tx, y);

				size.Width = Math.Max(size.Width, innerSize.Width + tx - origX);
				size.Height += innerSize.Height;
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level] && InnerNode != null)
			{
				height += InnerNode.CalculateDrawnHeight(context);
			}
			return height;
		}
	}
}

```

`ReClass.NET/Nodes/UInt16Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class UInt16Node : BaseNumericNode
	{
		public override int MemorySize => 2;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UInt16 / WORD";
			icon = Properties.Resources.B16x16_Button_UInt_16;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Unsigned, "UInt16", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (ushort.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && ushort.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public ushort ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadUInt16(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/UInt32Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class UInt32Node : BaseNumericNode
	{
		public override int MemorySize => 4;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UInt32 / DWORD";
			icon = Properties.Resources.B16x16_Button_UInt_32;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Unsigned, "UInt32", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (uint.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && uint.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public uint ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadUInt32(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/UInt64Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class UInt64Node : BaseNumericNode
	{
		public override int MemorySize => 8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UInt64 / QWORD";
			icon = Properties.Resources.B16x16_Button_UInt_64;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Unsigned, "UInt64", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (ulong.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && ulong.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public ulong ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadUInt64(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/UInt8Node.cs`:

```cs
using System.Drawing;
using System.Globalization;
using ReClassNET.Controls;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class UInt8Node : BaseNumericNode
	{
		public override int MemorySize => 1;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UInt8 / BYTE";
			icon = Properties.Resources.B16x16_Button_UInt_8;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			var value = ReadValueFromMemory(context.Memory);
			return DrawNumeric(context, x, y, context.IconProvider.Unsigned, "UInt8", value.ToString(), $"0x{value:X}");
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			if (spot.Id == 0 || spot.Id == 1)
			{
				if (byte.TryParse(spot.Text, out var val) || spot.Text.TryGetHexString(out var hexValue) && byte.TryParse(hexValue, NumberStyles.HexNumber, null, out val))
				{
					spot.Process.WriteRemoteMemory(spot.Address, val);
				}
			}
		}

		public byte ReadValueFromMemory(MemoryBuffer memory)
		{
			return memory.ReadUInt8(Offset);
		}
	}
}

```

`ReClass.NET/Nodes/UTF16TextNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf16TextNode : BaseTextNode
	{
		public override Encoding Encoding => Encoding.Unicode;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF16 / Unicode Text";
			icon = Properties.Resources.B16x16_Button_UText;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text16");
		}
	}
}

```

`ReClass.NET/Nodes/UTF16TextPtrNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf16TextPtrNode : BaseTextPtrNode
	{
		public override Encoding Encoding => Encoding.Unicode;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF16 / Unicode Text Pointer";
			icon = Properties.Resources.B16x16_Button_UText_Pointer;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text16Ptr");
		}
	}
}

```

`ReClass.NET/Nodes/UTF32TextNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf32TextNode : BaseTextNode
	{
		public override Encoding Encoding => Encoding.UTF32;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF32 Text";
			icon = Properties.Resources.B16x16_Button_UText;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text32");
		}
	}
}

```

`ReClass.NET/Nodes/UTF32TextPtrNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf32TextPtrNode : BaseTextPtrNode
	{
		public override Encoding Encoding => Encoding.UTF32;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF32 Text Pointer";
			icon = Properties.Resources.B16x16_Button_UText_Pointer;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text32Ptr");
		}
	}
}

```

`ReClass.NET/Nodes/UTF8TextNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf8TextNode : BaseTextNode
	{
		public override Encoding Encoding => Encoding.UTF8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF8 / ASCII Text";
			icon = Properties.Resources.B16x16_Button_Text;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text8");
		}
	}
}

```

`ReClass.NET/Nodes/UTF8TextPtrNode.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class Utf8TextPtrNode : BaseTextPtrNode
	{
		public override Encoding Encoding => Encoding.UTF8;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "UTF8 / ASCII Text Pointer";
			icon = Properties.Resources.B16x16_Button_Text_Pointer;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return DrawText(context, x, y, "Text8Ptr");
		}
	}
}

```

`ReClass.NET/Nodes/UnionNode.cs`:

```cs
using System;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class UnionNode : BaseContainerNode
	{
		public override int MemorySize => Nodes.Max(n => n.MemorySize);

		protected override bool ShouldCompensateSizeChanges => false;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Union";
			icon = Properties.Resources.B16x16_Button_Union;
		}

		public override bool CanHandleChildNode(BaseNode node)
		{
			switch (node)
			{
				case null:
				case ClassNode _:
				case VirtualMethodNode _:
					return false;
			}

			return true;
		}

		public override void Initialize()
		{
			AddNode(CreateDefaultNodeForSize(IntPtr.Size));
		}

		public override void UpdateOffsets()
		{
			foreach (var node in Nodes)
			{
				node.Offset = 0;
			}
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddOpenCloseIcon(context, x, y);
			x = AddIcon(context, x, y, context.IconProvider.Union, -1, HotSpotType.None);

			var tx = x;
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.TypeColor, HotSpot.NoneId, "Union") + context.Font.Width;

			x = AddText(context, x, y, context.Settings.ValueColor, HotSpot.NoneId, $"[Nodes: {Nodes.Count}, Size: {MemorySize}]") + context.Font.Width;

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			y += context.Font.Height;

			var size = new Size(x - origX, y - origY);

			if (LevelsOpen[context.Level])
			{
				var innerContext = context.Clone();
				innerContext.Settings = Program.Settings.Clone();
				innerContext.Settings.ShowNodeAddress = false;
				innerContext.Address = context.Address + Offset;
				innerContext.Memory = context.Memory.Clone();
				innerContext.Memory.Offset += Offset;

				foreach (var node in Nodes)
				{
					var innerSize = node.Draw(innerContext, tx, y);

					size.Width = Math.Max(size.Width, innerSize.Width + tx - origX);
					size.Height += innerSize.Height;

					y += innerSize.Height;
				}
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += Nodes.Sum(n => n.CalculateDrawnHeight(context));
			}
			return height;
		}
	}
}

```

`ReClass.NET/Nodes/Vector2Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Vector2Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 2 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Vector2";
			icon = Properties.Resources.B16x16_Button_Vector_2;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawVectorType(context, x2, y2, "Vector2", 2);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 0;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 2);
		}
	}
}

```

`ReClass.NET/Nodes/Vector3Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Vector3Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 3 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Vector3";
			icon = Properties.Resources.B16x16_Button_Vector_3;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawVectorType(context, x2, y2, "Vector3", 3);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 0;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 3);
		}
	}
}

```

`ReClass.NET/Nodes/Vector4Node.cs`:

```cs
using System.Drawing;
using ReClassNET.Controls;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class Vector4Node : BaseMatrixNode
	{
		public override int ValueTypeSize => sizeof(float);

		public override int MemorySize => 4 * ValueTypeSize;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "Vector4";
			icon = Properties.Resources.B16x16_Button_Vector_4;
		}

		public override Size Draw(DrawContext context, int x2, int y2)
		{
			return DrawVectorType(context, x2, y2, "Vector4", 4);
		}

		protected override int CalculateValuesHeight(DrawContext context)
		{
			return 0;
		}

		public override void Update(HotSpot spot)
		{
			base.Update(spot);

			Update(spot, 4);
		}
	}
}

```

`ReClass.NET/Nodes/VirtualMethodNode.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.Controls;

namespace ReClassNET.Nodes
{
	public class VirtualMethodNode : BaseFunctionPtrNode
	{
		public string MethodName => string.IsNullOrEmpty(Name) ? $"Function{Offset / IntPtr.Size}" : Name;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			throw new InvalidOperationException($"The '{nameof(VirtualMethodNode)}' node should not be accessible from the ui.");
		}

		public VirtualMethodNode()
		{
			Contract.Ensures(Name != null);

			Name = string.Empty;
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			return Draw(context, x, y, $"({Offset / IntPtr.Size})", MethodName);
		}
	}
}

```

`ReClass.NET/Nodes/VirtualMethodTableNode.cs`:

```cs
using System;
using System.Drawing;
using System.Linq;
using ReClassNET.Controls;
using ReClassNET.Memory;
using ReClassNET.UI;

namespace ReClassNET.Nodes
{
	public class VirtualMethodTableNode : BaseContainerNode
	{
		private readonly MemoryBuffer memory = new MemoryBuffer();

		public override int MemorySize => IntPtr.Size;

		protected override bool ShouldCompensateSizeChanges => false;

		public override void GetUserInterfaceInfo(out string name, out Image icon)
		{
			name = "VTable Pointer";
			icon = Properties.Resources.B16x16_Button_VTable;
		}

		public override bool CanHandleChildNode(BaseNode node)
		{
			return node is VirtualMethodNode;
		}

		public override void Initialize()
		{
			for (var i = 0; i < 10; ++i)
			{
				AddNode(CreateDefaultNodeForSize(IntPtr.Size));
			}
		}

		public override Size Draw(DrawContext context, int x, int y)
		{
			if (IsHidden && !IsWrapped)
			{
				return DrawHidden(context, x, y);
			}

			var origX = x;
			var origY = y;

			AddSelection(context, x, y, context.Font.Height);

			x = AddOpenCloseIcon(context, x, y);
			x = AddIcon(context, x, y, context.IconProvider.VirtualTable, HotSpot.NoneId, HotSpotType.None);

			var tx = x;
			x = AddAddressOffset(context, x, y);

			x = AddText(context, x, y, context.Settings.VTableColor, HotSpot.NoneId, $"VTable[{Nodes.Count}]") + context.Font.Width;
			if (!IsWrapped)
			{
				x = AddText(context, x, y, context.Settings.NameColor, HotSpot.NameId, Name) + context.Font.Width;
			}

			x = AddComment(context, x, y);

			DrawInvalidMemoryIndicatorIcon(context, y);
			AddContextDropDownIcon(context, y);
			AddDeleteIcon(context, y);

			y += context.Font.Height;

			var size = new Size(x - origX, y - origY);

			if (LevelsOpen[context.Level])
			{
				var ptr = context.Memory.ReadIntPtr(Offset);

				memory.Size = Nodes.Count * IntPtr.Size;
				memory.UpdateFrom(context.Process, ptr);

				var innerContext = context.Clone();
				innerContext.Address = ptr;
				innerContext.Memory = memory;

				foreach (var node in Nodes)
				{
					var innerSize = node.Draw(innerContext, tx, y);

					size.Width = Math.Max(size.Width, innerSize.Width + tx - origX);
					size.Height += innerSize.Height;

					y += innerSize.Height;
				}
			}

			return size;
		}

		public override int CalculateDrawnHeight(DrawContext context)
		{
			if (IsHidden && !IsWrapped)
			{
				return HiddenHeight;
			}

			var height = context.Font.Height;
			if (LevelsOpen[context.Level])
			{
				height += Nodes.Sum(n => n.CalculateDrawnHeight(context));
			}
			return height;
		}

		protected override BaseNode CreateDefaultNodeForSize(int size)
		{
			// ignore the size parameter
			return new VirtualMethodNode();
		}
	}
}

```

`ReClass.NET/Plugins/DefaultPluginHost.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Resources;
using ReClassNET.Forms;
using ReClassNET.Logger;
using ReClassNET.Memory;

namespace ReClassNET.Plugins
{
	internal sealed class DefaultPluginHost : IPluginHost
	{
		public MainForm MainWindow { get; }

		public ResourceManager Resources => Properties.Resources.ResourceManager;

		public RemoteProcess Process { get; }

		public ILogger Logger { get; }

		public Settings Settings => Program.Settings;

		public DefaultPluginHost(MainForm form, RemoteProcess process, ILogger logger)
		{
			Contract.Requires(form != null);
			Contract.Requires(process != null);
			Contract.Requires(logger != null);

			MainWindow = form;
			Process = process;
			Logger = logger;
		}
	}
}

```

`ReClass.NET/Plugins/IPluginHost.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Resources;
using ReClassNET.Forms;
using ReClassNET.Logger;
using ReClassNET.Memory;

namespace ReClassNET.Plugins
{
	[ContractClass(typeof(PluginHostContract))]
	public interface IPluginHost
	{
		/// <summary>Gets the main window of ReClass.NET.</summary>
		MainForm MainWindow { get; }

		/// <summary>Gets the resources of ReClass.NET.</summary>
		ResourceManager Resources { get; }

		/// <summary>Gets the process ReClass.NET is attached to.</summary>
		RemoteProcess Process { get; }

		/// <summary>Gets the logger ReClass.NET is using.</summary>
		ILogger Logger { get; }

		/// <summary>Gets the settings ReClass.NET is using.</summary>
		Settings Settings { get; }
	}

	[ContractClassFor(typeof(IPluginHost))]
	internal abstract class PluginHostContract : IPluginHost
	{
		public ILogger Logger
		{
			get
			{
				Contract.Ensures(Logger != null);

				throw new NotImplementedException();
			}
		}

		public MainForm MainWindow
		{
			get
			{
				Contract.Ensures(MainWindow != null);

				throw new NotImplementedException();
			}
		}

		public RemoteProcess Process
		{
			get
			{
				Contract.Ensures(Process != null);

				throw new NotImplementedException();
			}
		}

		public ResourceManager Resources
		{
			get
			{
				Contract.Ensures(Resources != null);

				throw new NotImplementedException();
			}
		}

		public Settings Settings
		{
			get
			{
				Contract.Ensures(Settings != null);

				throw new NotImplementedException();
			}
		}
	}
}

```

`ReClass.NET/Plugins/Plugin.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using ReClassNET.CodeGenerator;
using ReClassNET.DataExchange.ReClass;
using ReClassNET.Nodes;

namespace ReClassNET.Plugins
{
	public class Plugin
	{
		public class CustomNodeTypes
		{
			/// <summary>
			/// A list with custom node types.
			/// </summary>
			public IReadOnlyList<Type> NodeTypes { get; set; }

			/// <summary>
			/// An instance of a serializer which can process the custom node types.
			/// </summary>
			public ICustomNodeSerializer Serializer { get; set; }

			/// <summary>
			/// An instance of a code generator which can process the custom node types.
			/// </summary>
			public CustomCppCodeGenerator CodeGenerator { get; set; }
		}

		/// <summary>
		/// The icon of the plugin.
		/// </summary>
		public virtual Image Icon => null;

		public virtual bool Initialize(IPluginHost host)
		{
			Contract.Requires(host != null);

			return true;
		}

		public virtual void Terminate()
		{

		}

		/// <summary>
		/// Gets called once to receive all node info readers the plugin provides.
		/// </summary>
		/// <returns>A list with node info readers or <c>null</c> if the plugin provides none.</returns>
		public virtual IReadOnlyList<INodeInfoReader> GetNodeInfoReaders()
		{
			return null;
		}

		/// <summary>
		/// Gets called once to receive all custom node types the plugin provides.
		/// </summary>
		/// <returns>Informations about the custom nodes or <c>null</c> if the plugin provides none.</returns>
		public virtual CustomNodeTypes GetCustomNodeTypes()
		{
			return null;
		}
	}
}

```

`ReClass.NET/Plugins/PluginInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.IO;
using ReClassNET.Extensions;
using ReClassNET.Native;
using ReClassNET.Nodes;

namespace ReClassNET.Plugins
{
	internal class PluginInfo : IDisposable
	{
		public const string PluginName = "ReClass.NET Plugin";
		public const string PluginNativeName = "ReClass.NET Native Plugin";

		public string FilePath { get; }

		public string FileVersion { get; }

		public string Name { get; }

		public string Description { get; }

		public string Author { get; }

		public bool IsNative { get; }

		public Plugin Interface { get; set; }

		public IntPtr NativeHandle { get; set; }

		public IReadOnlyList<INodeInfoReader> NodeInfoReaders { get; set; }

		public Plugin.CustomNodeTypes CustomNodeTypes { get; set; }

		public PluginInfo(string filePath, FileVersionInfo versionInfo)
		{
			Contract.Requires(filePath != null);
			Contract.Requires(versionInfo != null);

			FilePath = filePath;
			IsNative = versionInfo.ProductName == null /* Unix */ || versionInfo.ProductName == PluginNativeName;

			FileVersion = (versionInfo.FileVersion ?? string.Empty).Trim();

			Description = (versionInfo.Comments ?? string.Empty).Trim();
			Author = (versionInfo.CompanyName ?? string.Empty).Trim();

			Name = (versionInfo.FileDescription ?? string.Empty).Trim();
			if (Name == string.Empty)
			{
				Name = Path.GetFileNameWithoutExtension(FilePath);
			}
		}

		~PluginInfo()
		{
			ReleaseUnmanagedResources();
		}

		private void ReleaseUnmanagedResources()
		{
			if (!NativeHandle.IsNull())
			{
				NativeMethods.FreeLibrary(NativeHandle);

				NativeHandle = IntPtr.Zero;
			}
		}

		public void Dispose()
		{
			if (Interface != null)
			{
				try
				{
					Interface.Terminate();
				}
				catch
				{
					// ignored
				}
			}

			ReleaseUnmanagedResources();

			GC.SuppressFinalize(this);
		}
	}
}

```

`ReClass.NET/Plugins/PluginManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.IO;
using ReClassNET.CodeGenerator;
using ReClassNET.Core;
using ReClassNET.DataExchange.ReClass;
using ReClassNET.Extensions;
using ReClassNET.Logger;
using ReClassNET.Native;
using ReClassNET.Nodes;
using ReClassNET.UI;

namespace ReClassNET.Plugins
{
	internal sealed class PluginManager
	{
		private readonly List<PluginInfo> plugins = new List<PluginInfo>();

		private readonly IPluginHost host;

		public IEnumerable<PluginInfo> Plugins => plugins;

		public PluginManager(IPluginHost host)
		{
			Contract.Requires(host != null);

			this.host = host;
		}

		public void LoadAllPlugins(string path, ILogger logger)
		{
			Contract.Requires(path != null);
			Contract.Requires(logger != null);

			try
			{
				if (!Directory.Exists(path))
				{
					return;
				}

				var directory = new DirectoryInfo(path);

				LoadPlugins(directory.GetFiles("*.dll", SearchOption.AllDirectories), logger, true);

				LoadPlugins(directory.GetFiles("*.exe", SearchOption.AllDirectories), logger, true);

				LoadPlugins(directory.GetFiles("*.so", SearchOption.AllDirectories), logger, false);
			}
			catch (Exception ex)
			{
				logger.Log(ex);
			}
		}

		private void LoadPlugins(IEnumerable<FileInfo> files, ILogger logger, bool checkProductName)
		{
			// TODO: How to include plugin infos for unix files as they don't have embedded version info.

			Contract.Requires(files != null);
			Contract.Requires(logger != null);

			foreach (var fi in files)
			{
				FileVersionInfo fvi;
				try
				{
					fvi = FileVersionInfo.GetVersionInfo(fi.FullName);

					if (checkProductName && fvi.ProductName != PluginInfo.PluginName && fvi.ProductName != PluginInfo.PluginNativeName)
					{
						continue;
					}
				}
				catch
				{
					continue;
				}

				try
				{
					var pi = new PluginInfo(fi.FullName, fvi);
					if (!pi.IsNative)
					{
						pi.Interface = CreatePluginInstance(pi.FilePath);

						if (!pi.Interface.Initialize(host))
						{
							continue;
						}

						RegisterNodeInfoReaders(pi);
						RegisterCustomNodeTypes(pi);
					}
					else
					{
						pi.NativeHandle = CreateNativePluginInstance(pi.FilePath);

						Program.CoreFunctions.RegisterFunctions(
							pi.Name,
							new NativeCoreWrapper(pi.NativeHandle)
						);
					}

					plugins.Add(pi);
				}
				catch (Exception ex)
				{
					logger.Log(ex);
				}
			}
		}

		public void UnloadAllPlugins()
		{
			foreach (var pi in plugins)
			{
				if (pi.Interface != null) // Exclude native plugins
				{
					DeregisterNodeInfoReaders(pi);
					DeregisterCustomNodeTypes(pi);
				}

				pi.Dispose();
			}

			plugins.Clear();
		}

		private static Plugin CreatePluginInstance(string filePath)
		{
			Contract.Requires(filePath != null);

			var type = Path.GetFileNameWithoutExtension(filePath);
			type = type + "." + type + "Ext";

			var handle = Activator.CreateInstanceFrom(filePath, type);

			if (!(handle.Unwrap() is Plugin plugin))
			{
				throw new FileLoadException();
			}
			return plugin;
		}

		private static IntPtr CreateNativePluginInstance(string filePath)
		{
			Contract.Requires(filePath != null);

			var handle = NativeMethods.LoadLibrary(filePath);
			if (handle.IsNull())
			{
				throw new FileLoadException($"Failed to load native plugin: {Path.GetFileName(filePath)}");
			}
			return handle;
		}

		private static void RegisterNodeInfoReaders(PluginInfo pluginInfo)
		{
			Contract.Requires(pluginInfo != null);

			var nodeInfoReaders = pluginInfo.Interface.GetNodeInfoReaders();

			if (nodeInfoReaders == null || nodeInfoReaders.Count == 0)
			{
				return;
			}

			pluginInfo.NodeInfoReaders = nodeInfoReaders;

			BaseNode.NodeInfoReader.AddRange(nodeInfoReaders);
		}

		private static void DeregisterNodeInfoReaders(PluginInfo pluginInfo)
		{
			Contract.Requires(pluginInfo != null);

			if (pluginInfo.NodeInfoReaders == null)
			{
				return;
			}

			foreach (var reader in pluginInfo.NodeInfoReaders)
			{
				BaseNode.NodeInfoReader.Remove(reader);
			}
		}

		private static void RegisterCustomNodeTypes(PluginInfo pluginInfo)
		{
			Contract.Requires(pluginInfo != null);

			var customNodeTypes = pluginInfo.Interface.GetCustomNodeTypes();

			if (customNodeTypes == null)
			{
				return;
			}

			if (customNodeTypes.NodeTypes == null || customNodeTypes.Serializer == null || customNodeTypes.CodeGenerator == null)
			{
				throw new ArgumentException(); // TODO
			}

			foreach (var nodeType in customNodeTypes.NodeTypes)
			{
				if (!nodeType.IsSubclassOf(typeof(BaseNode)))
				{
					throw new ArgumentException($"Type '{nodeType}' is not a valid node.");
				}
			}

			pluginInfo.CustomNodeTypes = customNodeTypes;

			NodeTypesBuilder.AddPluginNodeGroup(pluginInfo.Interface, customNodeTypes.NodeTypes);

			CustomNodeSerializer.Add(customNodeTypes.Serializer);
			CppCodeGenerator.Add(customNodeTypes.CodeGenerator);
		}

		private static void DeregisterCustomNodeTypes(PluginInfo pluginInfo)
		{
			Contract.Requires(pluginInfo != null);

			if (pluginInfo.CustomNodeTypes == null)
			{
				return;
			}

			NodeTypesBuilder.RemovePluginNodeGroup(pluginInfo.Interface);

			CustomNodeSerializer.Remove(pluginInfo.CustomNodeTypes.Serializer);
			CppCodeGenerator.Remove(pluginInfo.CustomNodeTypes.CodeGenerator);
		}
	}
}

```

`ReClass.NET/Program.cs`:

```cs
using System;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Windows.Forms;
using Microsoft.SqlServer.MessageBox;
using ReClassNET.Core;
using ReClassNET.Forms;
using ReClassNET.Logger;
using ReClassNET.Memory;
using ReClassNET.Native;
using ReClassNET.UI;
using ReClassNET.Util;

namespace ReClassNET
{
	public static class Program
	{
		public static CommandLineArgs CommandLineArgs { get; private set; }

		public static Settings Settings { get; private set; }

		public static ILogger Logger { get; private set; }

		public static Random GlobalRandom { get; } = new Random();

		public static RemoteProcess RemoteProcess { get; private set; }

		public static CoreFunctionsManager CoreFunctions => RemoteProcess.CoreFunctions;

		public static MainForm MainForm { get; private set; }

		public static bool DesignMode { get; private set; } = true;

		public static FontEx MonoSpaceFont { get; private set; }

		[STAThread]
		static void Main(string[] args)
		{
			DesignMode = false; // The designer doesn't call Main()

			CommandLineArgs = new CommandLineArgs(args);

			try
			{
				DpiUtil.ConfigureProcess();
				DpiUtil.TrySetDpiFromCurrentDesktop();
			}
			catch
			{
				// ignored
			}

			MonoSpaceFont = new FontEx
			{
				Font = new Font("Courier New", DpiUtil.ScaleIntX(13), GraphicsUnit.Pixel),
				Width = DpiUtil.ScaleIntX(8),
				Height = DpiUtil.ScaleIntY(16)
			};

			NativeMethods.EnableDebugPrivileges();

			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);

			CultureInfo.DefaultThreadCurrentCulture = CultureInfo.InvariantCulture;

			Settings = SettingsSerializer.Load();
			Logger = new GuiLogger();

			if (!NativeMethods.IsUnix() && Settings.RunAsAdmin && !WinUtil.IsAdministrator)
			{
				WinUtil.RunElevated(Process.GetCurrentProcess().MainModule?.FileName, args.Length > 0 ? string.Join(" ", args) : null);
				return;
			}

#if !DEBUG
			try
			{
#endif
			using (var coreFunctions = new CoreFunctionsManager())
			{
				RemoteProcess = new RemoteProcess(coreFunctions);

				MainForm = new MainForm();

				Application.Run(MainForm);

				RemoteProcess.Dispose();
			}
#if !DEBUG
			}
			catch (Exception ex)
			{
				ShowException(ex);
			}
#endif

			SettingsSerializer.Save(Settings);
		}

		/// <summary>Shows the exception in a special form.</summary>
		/// <param name="ex">The exception.</param>
		public static void ShowException(Exception ex)
		{
			ex.HelpLink = Constants.HelpUrl;

			var msg = new ExceptionMessageBox(ex)
			{
				Beep = false,
				ShowToolBar = true,
				Symbol = ExceptionMessageBoxSymbol.Error
			};
			msg.Show(null);
		}
	}
}

```

`ReClass.NET/Project/CppTypeMapping.cs`:

```cs
using System.Xml.Linq;
using ReClassNET.Util;

namespace ReClassNET.Project
{
	public class CppTypeMapping
	{
		public string TypeBool { get; set; } = "bool";

		public string TypeInt8 { get; set; } = "int8_t";
		public string TypeInt16 { get; set; } = "int16_t";
		public string TypeInt32 { get; set; } = "int32_t";
		public string TypeInt64 { get; set; } = "int64_t";
		public string TypeNInt { get; set; } = "ptrdiff_t";

		public string TypeUInt8 { get; set; } = "uint8_t";
		public string TypeUInt16 { get; set; } = "uint16_t";
		public string TypeUInt32 { get; set; } = "uint32_t";
		public string TypeUInt64 { get; set; } = "uint64_t";
		public string TypeNUInt { get; set; } = "size_t";

		public string TypeFloat { get; set; } = "float";
		public string TypeDouble { get; set; } = "double";

		public string TypeVector2 { get; set; } = "Vector2";
		public string TypeVector3 { get; set; } = "Vector3";
		public string TypeVector4 { get; set; } = "Vector4";

		public string TypeMatrix3x3 { get; set; } = "Matrix3x3";
		public string TypeMatrix3x4 { get; set; } = "Matrix3x4";
		public string TypeMatrix4x4 { get; set; } = "Matrix4x4";

		public string TypeUtf8Text { get; set; } = "char";
		public string TypeUtf16Text { get; set; } = "wchar_t"; // Should be char16_t, but this type isn't well supported at the moment.
		public string TypeUtf32Text { get; set; } = "char32_t";

		public string TypeFunctionPtr { get; set; } = "void*";

		internal XElement Serialize(string name)
		{
			return new XElement(
				name,
				XElementSerializer.ToXml(nameof(TypeBool), TypeBool),
				XElementSerializer.ToXml(nameof(TypeInt8), TypeInt8),
				XElementSerializer.ToXml(nameof(TypeInt16), TypeInt16),
				XElementSerializer.ToXml(nameof(TypeInt32), TypeInt32),
				XElementSerializer.ToXml(nameof(TypeInt64), TypeInt64),
				XElementSerializer.ToXml(nameof(TypeNInt), TypeNInt),
				XElementSerializer.ToXml(nameof(TypeUInt8), TypeUInt8),
				XElementSerializer.ToXml(nameof(TypeUInt16), TypeUInt16),
				XElementSerializer.ToXml(nameof(TypeUInt32), TypeUInt32),
				XElementSerializer.ToXml(nameof(TypeUInt64), TypeUInt64),
				XElementSerializer.ToXml(nameof(TypeNUInt), TypeNUInt),
				XElementSerializer.ToXml(nameof(TypeFloat), TypeFloat),
				XElementSerializer.ToXml(nameof(TypeDouble), TypeDouble),
				XElementSerializer.ToXml(nameof(TypeVector2), TypeVector2),
				XElementSerializer.ToXml(nameof(TypeVector3), TypeVector3),
				XElementSerializer.ToXml(nameof(TypeVector4), TypeVector4),
				XElementSerializer.ToXml(nameof(TypeMatrix3x3), TypeMatrix3x3),
				XElementSerializer.ToXml(nameof(TypeMatrix3x4), TypeMatrix3x4),
				XElementSerializer.ToXml(nameof(TypeMatrix4x4), TypeMatrix4x4),
				XElementSerializer.ToXml(nameof(TypeUtf8Text), TypeUtf8Text),
				XElementSerializer.ToXml(nameof(TypeUtf16Text), TypeUtf16Text),
				XElementSerializer.ToXml(nameof(TypeUtf32Text), TypeUtf32Text),
				XElementSerializer.ToXml(nameof(TypeFunctionPtr), TypeFunctionPtr)
			);
		}

		internal void Deserialize(XElement element)
		{
			XElementSerializer.TryRead(element, nameof(TypeBool), e => TypeBool = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeInt8), e => TypeInt8 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeInt16), e => TypeInt16 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeInt32), e => TypeInt32 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeInt64), e => TypeInt64 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeNInt), e => TypeNInt = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUInt8), e => TypeUInt8 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUInt16), e => TypeUInt16 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUInt32), e => TypeUInt32 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUInt64), e => TypeUInt64 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeNUInt), e => TypeNUInt = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeFloat), e => TypeFloat = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeDouble), e => TypeDouble = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeVector2), e => TypeVector2 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeVector3), e => TypeVector3 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeVector4), e => TypeVector4 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeMatrix3x3), e => TypeMatrix3x3 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeMatrix3x4), e => TypeMatrix3x4 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeMatrix4x4), e => TypeMatrix4x4 = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUtf8Text), e => TypeUtf8Text = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUtf16Text), e => TypeUtf16Text = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeUtf32Text), e => TypeUtf32Text = XElementSerializer.ToString(e));
			XElementSerializer.TryRead(element, nameof(TypeFunctionPtr), e => TypeFunctionPtr = XElementSerializer.ToString(e));
		}
	}
}

```

`ReClass.NET/Project/EnumDescription.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ReClassNET.Project
{
	public class EnumDescription
	{
		public enum UnderlyingTypeSize
		{
			OneByte = 1,
			TwoBytes = 2,
			FourBytes = 4,
			EightBytes = 8
		}

		public static EnumDescription Default => new EnumDescription { Name = "DummyEnum" };

		public string Name { get; set; } = string.Empty;

		public bool UseFlagsMode { get; private set; }

		public UnderlyingTypeSize Size { get; private set; } = UnderlyingTypeSize.FourBytes;

		public IReadOnlyList<KeyValuePair<string, long>> Values { get; private set; } = new Dictionary<string, long>().ToList();

		public void SetData(bool useFlagsMode, UnderlyingTypeSize size, IEnumerable<KeyValuePair<string, long>> values)
		{
			var temp = values.OrderBy(t => t.Value).ToList();

			if (useFlagsMode)
			{
				var maxPossibleValue = ulong.MaxValue;
				switch (size)
				{
					case UnderlyingTypeSize.OneByte:
						maxPossibleValue = byte.MaxValue;
						break;
					case UnderlyingTypeSize.TwoBytes:
						maxPossibleValue = ushort.MaxValue;
						break;
					case UnderlyingTypeSize.FourBytes:
						maxPossibleValue = uint.MaxValue;
						break;
				}

				if (temp.Select(kv => (ulong)kv.Value).Max() > maxPossibleValue)
				{
					throw new ArgumentOutOfRangeException();
				}
			}
			else
			{
				var minPossibleValue = long.MinValue;
				var maxPossibleValue = long.MaxValue;
				switch (size)
				{
					case UnderlyingTypeSize.OneByte:
						minPossibleValue = sbyte.MinValue;
						maxPossibleValue = sbyte.MaxValue;
						break;
					case UnderlyingTypeSize.TwoBytes:
						minPossibleValue = short.MinValue;
						maxPossibleValue = short.MaxValue;
						break;
					case UnderlyingTypeSize.FourBytes:
						minPossibleValue = int.MinValue;
						maxPossibleValue = int.MaxValue;
						break;
				}

				if (temp.Max(kv => kv.Value) > maxPossibleValue || temp.Min(kv => kv.Value) < minPossibleValue)
				{
					throw new ArgumentOutOfRangeException();
				}
			}

			UseFlagsMode = useFlagsMode;
			Size = size;
			Values = temp;
		}
	}
}

```

`ReClass.NET/Project/ReClassNetProject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using ReClassNET.Nodes;
using ReClassNET.Util;

namespace ReClassNET.Project
{
	public class ReClassNetProject : IDisposable
	{
		public delegate void ClassesChangedEvent(ClassNode sender);
		public event ClassesChangedEvent ClassAdded;
		public event ClassesChangedEvent ClassRemoved;

		public delegate void EnumsChangedEvent(EnumDescription sender);
		public event EnumsChangedEvent EnumAdded;
		public event EnumsChangedEvent EnumRemoved;

		private readonly List<EnumDescription> enums = new List<EnumDescription>();
		private readonly List<ClassNode> classes = new List<ClassNode>();

		public IReadOnlyList<EnumDescription> Enums => enums;

		public IReadOnlyList<ClassNode> Classes => classes;

		public string Path { get; set; }

		/// <summary>
		/// Key-Value map with custom data for plugins to store project related data.
		/// The preferred key format is {Plugin Name}_{Key Name}.
		/// </summary>
		public CustomDataMap CustomData { get; } = new CustomDataMap();

		/// <summary>
		/// List of data types to use while generating C++ code for nodes.
		/// </summary>
		public CppTypeMapping TypeMapping { get; } = new CppTypeMapping();

		public void Dispose()
		{
			Clear();

			ClassAdded = null;
			ClassRemoved = null;

			EnumAdded = null;
			EnumRemoved = null;
		}

		public void AddClass(ClassNode node)
		{
			Contract.Requires(node != null);

			classes.Add(node);

			node.NodesChanged += NodesChanged_Handler;

			ClassAdded?.Invoke(node);
		}

		public bool ContainsClass(Guid uuid)
		{
			Contract.Requires(uuid != null);

			return classes.Any(c => c.Uuid.Equals(uuid));
		}

		public ClassNode GetClassByUuid(Guid uuid)
		{
			Contract.Requires(uuid != null);

			return classes.First(c => c.Uuid.Equals(uuid));
		}

		private void NodesChanged_Handler(BaseNode sender)
		{
			classes.ForEach(c => c.UpdateOffsets());
		}

		public void Clear()
		{
			var temp = classes.ToList();

			classes.Clear();

			foreach (var node in temp)
			{
				node.NodesChanged -= NodesChanged_Handler;

				ClassRemoved?.Invoke(node);
			}

			var temp2 = enums.ToList();

			enums.Clear();

			foreach (var @enum in temp2)
			{
				EnumRemoved?.Invoke(@enum);
			}
		}

		private IEnumerable<ClassNode> GetClassReferences(ClassNode node)
		{
			Contract.Requires(node != null);

			return classes
				.Where(c => c != node)
				.Where(c => c.Nodes.OfType<BaseWrapperNode>().Any(w => w.ResolveMostInnerNode() == node));
		}

		public void Remove(ClassNode node)
		{
			Contract.Requires(node != null);

			var references = GetClassReferences(node).ToList();
			if (references.Any())
			{
				throw new ClassReferencedException(node, references);
			}

			if (classes.Remove(node))
			{
				node.NodesChanged -= NodesChanged_Handler;

				ClassRemoved?.Invoke(node);
			}
		}

		public void RemoveUnusedClasses()
		{
			var toRemove = classes
				.Except(classes.Where(x => GetClassReferences(x).Any())) // check for references
				.Where(c => c.Nodes.All(n => n is BaseHexNode)) // check if only hex nodes are present
				.ToList();
			foreach (var node in toRemove)
			{
				if (classes.Remove(node))
				{
					ClassRemoved?.Invoke(node);
				}
			}
		}

		public void AddEnum(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			enums.Add(@enum);

			EnumAdded?.Invoke(@enum);
		}

		public void RemoveEnum(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			var refrences = GetEnumReferences(@enum).ToList();
			if (refrences.Any())
			{
				throw new EnumReferencedException(@enum, refrences.Select(e => e.GetParentClass()).Distinct());
			}

			if (enums.Remove(@enum))
			{
				EnumRemoved?.Invoke(@enum);
			}
		}

		private IEnumerable<EnumNode> GetEnumReferences(EnumDescription @enum)
		{
			Contract.Requires(@enum != null);

			return classes
				.SelectMany(c => c.Nodes.Where(n => n is EnumNode || (n as BaseWrapperNode)?.ResolveMostInnerNode() is EnumNode))
				.Cast<EnumNode>()
				.Where(e => e.Enum == @enum);
		}
	}

	public class ClassReferencedException : Exception
	{
		public ClassNode ClassNode { get; }
		public IEnumerable<ClassNode> References { get; }

		public ClassReferencedException(ClassNode node, IEnumerable<ClassNode> references)
			: base($"The class '{node.Name}' is referenced in other classes.")
		{
			Contract.Requires(node != null);
			Contract.Requires(references != null);
			Contract.Requires(Contract.ForAll(references, c => c != null));

			ClassNode = node;
			References = references;
		}
	}

	public class EnumReferencedException : Exception
	{
		public EnumDescription Enum { get; }
		public IEnumerable<ClassNode> References { get; }

		public EnumReferencedException(EnumDescription @enum, IEnumerable<ClassNode> references)
			: base($"The enum '{@enum.Name}' is referenced in other classes.")
		{
			Contract.Requires(@enum != null);
			Contract.Requires(references != null);
			Contract.Requires(Contract.ForAll(references, c => c != null));

			Enum = @enum;
			References = references;
		}
	}
}

```

`ReClass.NET/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

// Allgemeine Informationen über eine Assembly werden über die folgenden 
// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
// die einer Assembly zugeordnet sind.
[assembly: AssemblyTitle("Reclass.NET")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Reclass.NET")]
[assembly: AssemblyCopyright("KN4CK3R")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Durch Festlegen von ComVisible auf "false" werden die Typen in dieser Assembly unsichtbar 
// für COM-Komponenten.  Wenn Sie auf einen Typ in dieser Assembly von 
// COM aus zugreifen müssen, sollten Sie das ComVisible-Attribut für diesen Typ auf "True" festlegen.
[assembly: ComVisible(false)]

// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
[assembly: Guid("bfb8917d-e9b4-463f-a6e8-612c35728c78")]

// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
//
//      Hauptversion
//      Nebenversion 
//      Buildnummer
//      Revision
//
// Sie können alle Werte angeben oder die standardmäßigen Build- und Revisionsnummern 
// übernehmen, indem Sie "*" eingeben:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.2.0.0")]
[assembly: AssemblyFileVersion("1.2.0.0")]

```

`ReClass.NET/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ReClassNET.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ReClassNET.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Accept {
            get {
                object obj = ResourceManager.GetObject("B16x16_Accept", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Array_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Array_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Arrow_Refresh {
            get {
                object obj = ResourceManager.GetObject("B16x16_Arrow_Refresh", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_1024 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_1024", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_2048 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_2048", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_256 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_256", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_4 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_4", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_4096 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_4096", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_64 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_64", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_8 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_8", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Add_Bytes_X {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Add_Bytes_X", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Array {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Array", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Bits {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Bits", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Bool {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Bool", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Class_Add {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Class_Add", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Class_Instance {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Class_Instance", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Class_Pointer {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Class_Pointer", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Class_Remove {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Class_Remove", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Delete {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Delete", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Double {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Double", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Drop_Down {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Drop_Down", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Enum {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Enum", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Float {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Float", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Function {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Function", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Function_Pointer {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Function_Pointer", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Hex_16 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Hex_16", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Hex_32 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Hex_32", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Hex_64 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Hex_64", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Hex_8 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Hex_8", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_1024 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_1024", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_2048 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_2048", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_256 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_256", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_4 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_4", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_4096 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_4096", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_64 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_64", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_8 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_8", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Insert_Bytes_X {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Insert_Bytes_X", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Int_16 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Int_16", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Int_32 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Int_32", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Int_64 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Int_64", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Int_8 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Int_8", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Matrix_3x3 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Matrix_3x3", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Matrix_3x4 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Matrix_3x4", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Matrix_4x4 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Matrix_4x4", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_NInt {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_NInt", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_NUInt {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_NUInt", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Pointer {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Pointer", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Pointer_Array {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Pointer_Array", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Remove {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Remove", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Text {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Text", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Text_Pointer {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Text_Pointer", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UInt_16 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UInt_16", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UInt_32 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UInt_32", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UInt_64 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UInt_64", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UInt_8 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UInt_8", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Union {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Union", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UText {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UText", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_UText_Pointer {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_UText_Pointer", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Vector_2 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Vector_2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Vector_3 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Vector_3", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_Vector_4 {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_Vector_4", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Button_VTable {
            get {
                object obj = ResourceManager.GetObject("B16x16_Button_VTable", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Camera {
            get {
                object obj = ResourceManager.GetObject("B16x16_Camera", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Canvas_Size {
            get {
                object obj = ResourceManager.GetObject("B16x16_Canvas_Size", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Category {
            get {
                object obj = ResourceManager.GetObject("B16x16_Category", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Chart_Delete {
            get {
                object obj = ResourceManager.GetObject("B16x16_Chart_Delete", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Class_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Class_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Closed_Icon {
            get {
                object obj = ResourceManager.GetObject("B16x16_Closed_Icon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Cogs {
            get {
                object obj = ResourceManager.GetObject("B16x16_Cogs", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Color_Wheel {
            get {
                object obj = ResourceManager.GetObject("B16x16_Color_Wheel", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Control_Pause {
            get {
                object obj = ResourceManager.GetObject("B16x16_Control_Pause", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Control_Play {
            get {
                object obj = ResourceManager.GetObject("B16x16_Control_Play", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Control_Stop {
            get {
                object obj = ResourceManager.GetObject("B16x16_Control_Stop", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Custom_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Custom_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Double_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Double_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Drive_Go {
            get {
                object obj = ResourceManager.GetObject("B16x16_Drive_Go", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Enum_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Enum_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Error {
            get {
                object obj = ResourceManager.GetObject("B16x16_Error", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Exchange_Button {
            get {
                object obj = ResourceManager.GetObject("B16x16_Exchange_Button", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Eye {
            get {
                object obj = ResourceManager.GetObject("B16x16_Eye", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Find_Access {
            get {
                object obj = ResourceManager.GetObject("B16x16_Find_Access", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Find_Write {
            get {
                object obj = ResourceManager.GetObject("B16x16_Find_Write", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Float_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Float_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Folder {
            get {
                object obj = ResourceManager.GetObject("B16x16_Folder", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Folder_Add {
            get {
                object obj = ResourceManager.GetObject("B16x16_Folder_Add", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Function_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Function_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Gear {
            get {
                object obj = ResourceManager.GetObject("B16x16_Gear", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Help {
            get {
                object obj = ResourceManager.GetObject("B16x16_Help", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Information {
            get {
                object obj = ResourceManager.GetObject("B16x16_Information", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Interface_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Interface_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Left_Button {
            get {
                object obj = ResourceManager.GetObject("B16x16_Left_Button", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Magnifier {
            get {
                object obj = ResourceManager.GetObject("B16x16_Magnifier", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Magnifier_Arrow {
            get {
                object obj = ResourceManager.GetObject("B16x16_Magnifier_Arrow", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Magnifier_Remove {
            get {
                object obj = ResourceManager.GetObject("B16x16_Magnifier_Remove", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Matrix_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Matrix_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Open_Icon {
            get {
                object obj = ResourceManager.GetObject("B16x16_Open_Icon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Code {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Code", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Code_Add {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Code_Add", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Code_Cpp {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Code_Cpp", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Code_Csharp {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Code_Csharp", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Copy {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Copy", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_Paste {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_Paste", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Page_White_Stack {
            get {
                object obj = ResourceManager.GetObject("B16x16_Page_White_Stack", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Pdb {
            get {
                object obj = ResourceManager.GetObject("B16x16_Pdb", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Plugin {
            get {
                object obj = ResourceManager.GetObject("B16x16_Plugin", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Pointer_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Pointer_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Quit {
            get {
                object obj = ResourceManager.GetObject("B16x16_Quit", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Redo {
            get {
                object obj = ResourceManager.GetObject("B16x16_Redo", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Right_Button {
            get {
                object obj = ResourceManager.GetObject("B16x16_Right_Button", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Save {
            get {
                object obj = ResourceManager.GetObject("B16x16_Save", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Save_As {
            get {
                object obj = ResourceManager.GetObject("B16x16_Save_As", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Settings_Edit {
            get {
                object obj = ResourceManager.GetObject("B16x16_Settings_Edit", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Signed_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Signed_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Table_Gear {
            get {
                object obj = ResourceManager.GetObject("B16x16_Table_Gear", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Text_List_Bullets {
            get {
                object obj = ResourceManager.GetObject("B16x16_Text_List_Bullets", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Text_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Text_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Textfield_Rename {
            get {
                object obj = ResourceManager.GetObject("B16x16_Textfield_Rename", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Tree_Collapse {
            get {
                object obj = ResourceManager.GetObject("B16x16_Tree_Collapse", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Tree_Expand {
            get {
                object obj = ResourceManager.GetObject("B16x16_Tree_Expand", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Undo {
            get {
                object obj = ResourceManager.GetObject("B16x16_Undo", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Unsigned_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Unsigned_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Vector_Type {
            get {
                object obj = ResourceManager.GetObject("B16x16_Vector_Type", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B16x16_Warning {
            get {
                object obj = ResourceManager.GetObject("B16x16_Warning", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_3D_Glasses {
            get {
                object obj = ResourceManager.GetObject("B32x32_3D_Glasses", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Canvas_Size {
            get {
                object obj = ResourceManager.GetObject("B32x32_Canvas_Size", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Cogs {
            get {
                object obj = ResourceManager.GetObject("B32x32_Cogs", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Eye {
            get {
                object obj = ResourceManager.GetObject("B32x32_Eye", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Magnifier {
            get {
                object obj = ResourceManager.GetObject("B32x32_Magnifier", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Page_Code {
            get {
                object obj = ResourceManager.GetObject("B32x32_Page_Code", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap B32x32_Plugin {
            get {
                object obj = ResourceManager.GetObject("B32x32_Plugin", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 2020/10/17 09:45:04
        ///.
        /// </summary>
        internal static string BuildDate {
            get {
                return ResourceManager.GetString("BuildDate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Icon similar to (Icon).
        /// </summary>
        internal static System.Drawing.Icon ReClassNet {
            get {
                object obj = ResourceManager.GetObject("ReClassNet", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
    }
}

```

`ReClass.NET/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="B16x16_Tree_Collapse" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Tree_Collapse.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Plugin" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Plugin.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Class_Add" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Class_Add.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Table_Gear" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Table_Gear.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Pointer_Array" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Pointer_Array.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Enum_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Enum_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Chart_Delete" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Chart_Delete.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_VTable" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_VTable.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_4096" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_4096.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Hex_8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Hex_8.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_X" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_X.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Plugin" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Plugin.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_4096" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_4096.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Settings_Edit" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Settings_Edit.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Closed_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Closed_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Class_Pointer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Class_Pointer.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Text_List_Bullets" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Text_List_Bullets.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Code_Csharp" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Code_Csharp.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UText" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UText.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Error" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Error.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Interface_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Interface_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Matrix_3x4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Matrix_3x4.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Folder_Add" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Folder_Add.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Text" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Text.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Int_64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Int_64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UText_Pointer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UText_Pointer.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_256" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_256.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Text_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Text_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Bits" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Bits.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Pointer_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Pointer_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Double_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Double_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Array_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Array_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Custom_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Custom_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UInt_16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UInt_16.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Code" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Code.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Arrow_Refresh" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Arrow_Refresh.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Save" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Save.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Matrix_3x3" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Matrix_3x3.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Gear" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Gear.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Code_Add" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Code_Add.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Paste" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Paste.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Hex_16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Hex_16.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Tree_Expand" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Tree_Expand.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Int_32" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Int_32.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Folder" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Folder.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Page_Code" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Page_Code.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Delete" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Delete.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Pdb" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Pdb.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_2048" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_2048.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Copy" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Copy.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Class_Remove" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Class_Remove.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Control_Play" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Control_Play.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Array" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Array.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Class_Instance" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Class_Instance.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Information" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Information.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Warning" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Warning.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Quit" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Quit.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Int_8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Int_8.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Matrix_4x4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Matrix_4x4.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Camera" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Camera.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_4.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Bool" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Bool.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Control_Stop" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Control_Stop.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Class_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Class_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Cogs" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Cogs.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Float_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Float_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Drive_Go" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Drive_Go.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_2048" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_2048.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Right_Button" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Right_Button.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UInt_32" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UInt_32.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Textfield_Rename" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Textfield_Rename.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Magnifier_Remove" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Magnifier_Remove.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Unsigned_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Unsigned_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_X" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_X.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Magnifier" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Magnifier.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Text_Pointer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Text_Pointer.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Vector_3" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Vector_3.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Signed_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Signed_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Function_Pointer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Function_Pointer.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Hex_32" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Hex_32.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Save_As" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Save_As.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Vector_4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Vector_4.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Open_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Open_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Left_Button" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Left_Button.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ReClassNet" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Icon\ReClassNet.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="BuildDate" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\BuildDate.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-16</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_8.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_256" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_256.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UInt_64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UInt_64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_1024" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_1024.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_1024" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_1024.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_Code_Cpp" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_Code_Cpp.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Color_Wheel" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Color_Wheel.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Category" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Category.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_8.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Page_White_Stack" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Page_White_Stack.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Insert_Bytes_64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Insert_Bytes_64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Vector_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Vector_2.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Accept" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Accept.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Help" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Help.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Function" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Function.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Vector_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Vector_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Control_Pause" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Control_Pause.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Magnifier" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Magnifier.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Exchange_Button" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Exchange_Button.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Cogs" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Cogs.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Drop_Down" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Drop_Down.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_UInt_8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_UInt_8.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Hex_64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Hex_64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Int_16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Int_16.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Float" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Float.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Function_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Function_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Double" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Double.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Matrix_Type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Matrix_Type.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add_Bytes_4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add_Bytes_4.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Find_Access" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Find_Access.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Find_Write" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Find_Write.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Eye" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Eye.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Magnifier_Arrow" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Magnifier_Arrow.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_3D_Glasses" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_3D_Glasses.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Eye" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Eye.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B32x32_Canvas_Size" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B32x32_Canvas_Size.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Canvas_Size" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Canvas_Size.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Redo" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Redo.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Undo" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Undo.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Add" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Add.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Remove" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Remove.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Pointer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Pointer.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Enum" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Enum.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_Union" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_Union.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_NInt" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_NInt.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="B16x16_Button_NUInt" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Images\B16x16_Button_NUInt.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`ReClass.NET/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ReClassNET.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.9.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`ReClass.NET/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`ReClass.NET/ReClass.NET.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProjectGuid>{BFB8917D-E9B4-463F-A6E8-612C35728C78}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ReClassNET</RootNamespace>
    <AssemblyName>ReClass.NET</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <CodeContractsAssemblyMode>0</CodeContractsAssemblyMode>
    <TargetFrameworkProfile />
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>$(SolutionDir)bin\Debug\x86\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\x86\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>TRACE;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
    <CodeContractsEnableRuntimeChecking>False</CodeContractsEnableRuntimeChecking>
    <CodeContractsRuntimeOnlyPublicSurface>False</CodeContractsRuntimeOnlyPublicSurface>
    <CodeContractsRuntimeThrowOnFailure>True</CodeContractsRuntimeThrowOnFailure>
    <CodeContractsRuntimeCallSiteRequires>False</CodeContractsRuntimeCallSiteRequires>
    <CodeContractsRuntimeSkipQuantifiers>False</CodeContractsRuntimeSkipQuantifiers>
    <CodeContractsRunCodeAnalysis>False</CodeContractsRunCodeAnalysis>
    <CodeContractsNonNullObligations>True</CodeContractsNonNullObligations>
    <CodeContractsBoundsObligations>True</CodeContractsBoundsObligations>
    <CodeContractsArithmeticObligations>True</CodeContractsArithmeticObligations>
    <CodeContractsEnumObligations>True</CodeContractsEnumObligations>
    <CodeContractsRedundantAssumptions>True</CodeContractsRedundantAssumptions>
    <CodeContractsAssertsToContractsCheckBox>True</CodeContractsAssertsToContractsCheckBox>
    <CodeContractsRedundantTests>True</CodeContractsRedundantTests>
    <CodeContractsMissingPublicRequiresAsWarnings>True</CodeContractsMissingPublicRequiresAsWarnings>
    <CodeContractsMissingPublicEnsuresAsWarnings>False</CodeContractsMissingPublicEnsuresAsWarnings>
    <CodeContractsInferRequires>True</CodeContractsInferRequires>
    <CodeContractsInferEnsures>False</CodeContractsInferEnsures>
    <CodeContractsInferEnsuresAutoProperties>True</CodeContractsInferEnsuresAutoProperties>
    <CodeContractsInferObjectInvariants>False</CodeContractsInferObjectInvariants>
    <CodeContractsSuggestAssumptions>False</CodeContractsSuggestAssumptions>
    <CodeContractsSuggestAssumptionsForCallees>False</CodeContractsSuggestAssumptionsForCallees>
    <CodeContractsSuggestRequires>False</CodeContractsSuggestRequires>
    <CodeContractsNecessaryEnsures>True</CodeContractsNecessaryEnsures>
    <CodeContractsSuggestObjectInvariants>False</CodeContractsSuggestObjectInvariants>
    <CodeContractsSuggestReadonly>True</CodeContractsSuggestReadonly>
    <CodeContractsRunInBackground>True</CodeContractsRunInBackground>
    <CodeContractsShowSquigglies>True</CodeContractsShowSquigglies>
    <CodeContractsUseBaseLine>False</CodeContractsUseBaseLine>
    <CodeContractsEmitXMLDocs>False</CodeContractsEmitXMLDocs>
    <CodeContractsCustomRewriterAssembly />
    <CodeContractsCustomRewriterClass />
    <CodeContractsLibPaths />
    <CodeContractsExtraRewriteOptions />
    <CodeContractsExtraAnalysisOptions />
    <CodeContractsSQLServerOption />
    <CodeContractsBaseLineFile />
    <CodeContractsCacheAnalysisResults>True</CodeContractsCacheAnalysisResults>
    <CodeContractsSkipAnalysisIfCannotConnectToCache>False</CodeContractsSkipAnalysisIfCannotConnectToCache>
    <CodeContractsFailBuildOnWarnings>False</CodeContractsFailBuildOnWarnings>
    <CodeContractsBeingOptimisticOnExternal>True</CodeContractsBeingOptimisticOnExternal>
    <CodeContractsRuntimeCheckingLevel>Full</CodeContractsRuntimeCheckingLevel>
    <CodeContractsReferenceAssembly>%28none%29</CodeContractsReferenceAssembly>
    <CodeContractsAnalysisWarningLevel>3</CodeContractsAnalysisWarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>$(SolutionDir)bin\Release\x86\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\x86\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>TRACE;RELEASE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>$(SolutionDir)bin\Debug\x64\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\x64\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>TRACE;DEBUG;RECLASSNET64</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x64' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>$(SolutionDir)bin\Release\x64\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\x64\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>TRACE;RECLASSNET64;RELEASE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Resources\Icon\ReClassNet.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup />
  <ItemGroup>
    <Reference Include="ColorCode, Version=1.0.1.62759, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\Dependencies\ColorCode.dll</HintPath>
    </Reference>
    <Reference Include="Dia2Lib">
      <HintPath>..\Dependencies\Dia2Lib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="Microsoft.ExceptionMessageBox, Version=11.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\Dependencies\Microsoft.ExceptionMessageBox.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Design" />
    <Reference Include="System.IO.Compression" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AddressParser\DynamicCompiler.cs" />
    <Compile Include="AddressParser\IExecutor.cs" />
    <Compile Include="AddressParser\Interpreter.cs" />
    <Compile Include="AddressParser\Expressions.cs" />
    <Compile Include="AddressParser\ITokenizer.cs" />
    <Compile Include="AddressParser\ParseException.cs" />
    <Compile Include="AddressParser\Parser.cs" />
    <Compile Include="AddressParser\Token.cs" />
    <Compile Include="AddressParser\Tokenizer.cs" />
    <Compile Include="CodeGenerator\Language.cs" />
    <Compile Include="Core\CoreFunctionsManager.cs" />
    <Compile Include="Core\DataExchange.cs" />
    <Compile Include="Core\ICoreProcessFunctions.cs" />
    <Compile Include="Core\IInternalCoreFunctions.cs" />
    <Compile Include="Core\InternalCoreFunctions.cs" />
    <Compile Include="Core\NativeCoreWrapper.cs" />
    <Compile Include="DataExchange\ReClass\ReClassClipboard.cs" />
    <Compile Include="DataExchange\ReClass\ReClassNetFile.Constants.cs" />
    <Compile Include="DataExchange\ReClass\ReClassNetFile.Read.cs" />
    <Compile Include="DataExchange\ReClass\ReClassNetFile.Write.cs" />
    <Compile Include="DataExchange\ReClass\Legacy\BaseClassArrayNode.cs" />
    <Compile Include="DataExchange\ReClass\Legacy\ClassInstanceArrayNode.cs" />
    <Compile Include="DataExchange\ReClass\Legacy\ClassPointerArrayNode.cs" />
    <Compile Include="DataExchange\ReClass\Legacy\ClassPointerNode.cs" />
    <Compile Include="DataExchange\ReClass\Legacy\CustomNode.cs" />
    <Compile Include="DataExchange\Scanner\CheatEngineFile.cs" />
    <Compile Include="DataExchange\Scanner\CrySearchFile.cs" />
    <Compile Include="DataExchange\Scanner\IScannerExport.cs" />
    <Compile Include="DataExchange\Scanner\IScannerImport.cs" />
    <Compile Include="DataExchange\Scanner\ReClassScanFile.cs" />
    <Compile Include="Debugger\BreakpointAlreadySetException.cs" />
    <Compile Include="Debugger\DataExchange.cs" />
    <Compile Include="Debugger\HardwareBreakpoint.cs" />
    <Compile Include="Debugger\NoHardwareBreakpointAvailableException.cs" />
    <Compile Include="Debugger\RemoteDebugger.Extensions.cs" />
    <Compile Include="Debugger\RemoteDebugger.Thread.cs" />
    <Compile Include="Debugger\SoftwareBreakpoint.cs" />
    <Compile Include="Extensions\ByteExtension.cs" />
    <Compile Include="Extensions\IRemoteMemoryReaderExtension.cs" />
    <Compile Include="Extensions\IRemoteMemoryWriterExtension.cs" />
    <Compile Include="Extensions\ListExtension.cs" />
    <Compile Include="Extensions\PointExtension.cs" />
    <Compile Include="Extensions\StringBuilderExtensions.cs" />
    <Compile Include="Extensions\XAttributeExtensions.cs" />
    <Compile Include="Forms\EnumEditorForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\EnumEditorForm.Designer.cs">
      <DependentUpon>EnumEditorForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\EnumListForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\EnumListForm.Designer.cs">
      <DependentUpon>EnumListForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\EnumSelectionForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\EnumSelectionForm.Designer.cs">
      <DependentUpon>EnumSelectionForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\MainForm.Functions.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\NamedAddressesForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\NamedAddressesForm.Designer.cs">
      <DependentUpon>NamedAddressesForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\ClassSelectionForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\ClassSelectionForm.Designer.cs">
      <DependentUpon>ClassSelectionForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\FoundCodeForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\FoundCodeForm.Designer.cs">
      <DependentUpon>FoundCodeForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\InputBytesForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\InputBytesForm.Designer.cs">
      <DependentUpon>InputBytesForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Debugger\RemoteDebugger.cs" />
    <Compile Include="Forms\InputCorrelatorForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\InputCorrelatorForm.Designer.cs">
      <DependentUpon>InputCorrelatorForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\ScannerForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\ScannerForm.Designer.cs">
      <DependentUpon>ScannerForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Input\KeyboardInput.cs" />
    <Compile Include="Input\KeyboardHotkey.cs" />
    <Compile Include="MemoryScanner\BytePattern.cs" />
    <Compile Include="MemoryScanner\Comparer\ArrayOfBytesMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\ByteMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\DoubleMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\FloatMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\IComplexScanComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\IScanComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\IntegerMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\ISimpleScanComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\LongMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\RegexStringMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\ShortMemoryComparer.cs" />
    <Compile Include="MemoryScanner\Comparer\StringMemoryComparer.cs" />
    <Compile Include="MemoryScanner\ComplexScannerWorker.cs" />
    <Compile Include="MemoryScanner\InputCorrelatedScanner.cs" />
    <Compile Include="MemoryScanner\IScannerWorker.cs" />
    <Compile Include="MemoryScanner\MemoryRecord.cs" />
    <Compile Include="MemoryScanner\PatternScanner.cs" />
    <Compile Include="MemoryScanner\ScanCompareType.cs" />
    <Compile Include="MemoryScanner\ScannerContext.cs" />
    <Compile Include="MemoryScanner\SimpleScannerWorker.cs" />
    <Compile Include="MemoryScanner\ScanResultBlock.cs" />
    <Compile Include="MemoryScanner\ScanResultStore.cs" />
    <Compile Include="MemoryScanner\ScanValueType.cs" />
    <Compile Include="MemoryScanner\Comparer\InvalidCompareTypeException.cs" />
    <Compile Include="MemoryScanner\ScanRoundMode.cs" />
    <Compile Include="MemoryScanner\ScanResult.cs" />
    <Compile Include="MemoryScanner\Scanner.cs" />
    <Compile Include="MemoryScanner\ScanSettings.cs" />
    <Compile Include="Memory\Disassembler.cs" />
    <Compile Include="Debugger\IBreakpoint.cs" />
    <Compile Include="Memory\IProcessReader.cs" />
    <Compile Include="Memory\IRemoteMemoryReader.cs" />
    <Compile Include="Memory\IRemoteMemoryWriter.cs" />
    <Compile Include="Memory\Module.cs" />
    <Compile Include="Memory\NodeDissector.cs" />
    <Compile Include="Memory\Dumper.cs" />
    <Compile Include="Memory\Section.cs" />
    <Compile Include="Memory\SimplePeHeader.cs" />
    <Compile Include="Memory\UnionDataType.cs" />
    <Compile Include="Native\INativeMethods.cs" />
    <Compile Include="Native\NativeMethods.Unix.cs" />
    <Compile Include="Native\NativeMethods.Windows.cs" />
    <Compile Include="Nodes\ArrayNode.cs" />
    <Compile Include="Nodes\BaseClassWrapperNode.cs" />
    <Compile Include="Nodes\BaseFunctionNode.cs" />
    <Compile Include="Nodes\BaseWrapperArrayNode.cs" />
    <Compile Include="Nodes\BaseWrapperNode.cs" />
    <Compile Include="Nodes\BoolNode.cs" />
    <Compile Include="Nodes\ClassUtil.cs" />
    <Compile Include="Nodes\EnumNode.cs" />
    <Compile Include="Nodes\FunctionNode.cs" />
    <Compile Include="Nodes\NIntNode.cs" />
    <Compile Include="Nodes\PointerNode.cs" />
    <Compile Include="Nodes\NUIntNode.cs" />
    <Compile Include="Nodes\UnionNode.cs" />
    <Compile Include="Project\CppTypeMapping.cs" />
    <Compile Include="Project\EnumDescription.cs" />
    <Compile Include="Project\ReClassNetProject.cs" />
    <Compile Include="Controls\BannerBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="CodeGenerator\CppCodeGenerator.cs" />
    <Compile Include="CodeGenerator\CSharpCodeGenerator.cs" />
    <Compile Include="CodeGenerator\ICodeGenerator.cs" />
    <Compile Include="Constants.cs" />
    <Compile Include="DataExchange\ReClass\CustomNodeSerializer.cs" />
    <Compile Include="DataExchange\ReClass\IReClassExport.cs" />
    <Compile Include="DataExchange\ReClass\ReClassFile.cs" />
    <Compile Include="Forms\AboutForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\AboutForm.Designer.cs">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </Compile>
    <Compile Include="UI\BannerFactory.cs" />
    <Compile Include="UI\BindingDisplayWrapper.cs" />
    <Compile Include="Controls\DrawContextRequestEventArgs.cs" />
    <Compile Include="Controls\NodeClickEventArgs.cs" />
    <Compile Include="UI\DpiUtil.cs" />
    <Compile Include="Nodes\INodeInfoReader.cs" />
    <Compile Include="Controls\ProjectView.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Controls\ProjectView.Designer.cs">
      <DependentUpon>ProjectView.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\CodeForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\CodeForm.Designer.cs">
      <DependentUpon>CodeForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\ColorBox.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Controls\ColorBox.Designer.cs">
      <DependentUpon>ColorBox.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\CustomToolStripItems.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\IconForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\LogForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\LogForm.Designer.cs">
      <DependentUpon>LogForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\DualValueBox.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Controls\DualValueBox.Designer.cs">
      <DependentUpon>DualValueBox.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\EnumComboBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\EnumDescriptionDisplay.cs" />
    <Compile Include="Controls\HotkeyBox.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Controls\HotkeyBox.Designer.cs">
      <DependentUpon>HotkeyBox.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\IconButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="UI\IconProvider.cs" />
    <Compile Include="UI\LinkedWindowFeatures.cs" />
    <Compile Include="Controls\MemoryPreviewPopUp.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\MemoryRecordList.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Controls\MemoryRecordList.Designer.cs">
      <DependentUpon>MemoryRecordList.cs</DependentUpon>
    </Compile>
    <Compile Include="Controls\MemoryViewControl.Designer.cs">
      <DependentUpon>MemoryViewControl.cs</DependentUpon>
    </Compile>
    <Compile Include="UI\CustomToolStripProfessionalRenderer.cs" />
    <Compile Include="UI\NodeTypesBuilder.cs" />
    <Compile Include="Controls\PlaceholderTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Util\BitString.cs" />
    <Compile Include="Util\CircularBuffer.cs" />
    <Compile Include="Util\CommandLineArgs.cs" />
    <Compile Include="Util\Conversion\BigEndianBitConverter.cs" />
    <Compile Include="Util\Conversion\EndianBitConverter.cs" />
    <Compile Include="Util\Conversion\LittleEndianBitConverter.cs" />
    <Compile Include="Util\CustomDataMap.cs" />
    <Compile Include="Extensions\BinaryReaderWriterExtensions.cs" />
    <Compile Include="Extensions\ColorExtensions.cs" />
    <Compile Include="Extensions\DataGridViewExtensions.cs" />
    <Compile Include="Extensions\DictionaryExtensions.cs" />
    <Compile Include="Extensions\EncodingExtensions.cs" />
    <Compile Include="Extensions\FloatingPointExtensions.cs" />
    <Compile Include="Extensions\GraphicsExtensions.cs" />
    <Compile Include="Extensions\IntPtrExtensions.cs" />
    <Compile Include="Extensions\RichTextBoxExtensions.cs" />
    <Compile Include="Extensions\StringExtensions.cs" />
    <Compile Include="Extensions\StringReaderExtensions.cs" />
    <Compile Include="Util\DirectedGraph.cs" />
    <Compile Include="Util\GrowingList.cs" />
    <Compile Include="Forms\PluginForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\PluginForm.Designer.cs">
      <DependentUpon>PluginForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\SettingsForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\SettingsForm.Designer.cs">
      <DependentUpon>SettingsForm.cs</DependentUpon>
    </Compile>
    <Compile Include="UI\HotSpot.cs" />
    <Compile Include="UI\FontEx.cs" />
    <Compile Include="Controls\HotSpotTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\MainForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="DataExchange\ReClass\IReClassImport.cs" />
    <Compile Include="DataExchange\ReClass\ReClassNetFile.cs" />
    <Compile Include="DataExchange\ReClass\ReClassQtFile.cs" />
    <Compile Include="Logger\BaseLogger.cs" />
    <Compile Include="Logger\GuiLogger.cs" />
    <Compile Include="Logger\ILogger.cs" />
    <Compile Include="Logger\LogLevel.cs" />
    <Compile Include="Logger\NullLogger.cs" />
    <Compile Include="Memory\MemoryBuffer.cs" />
    <Compile Include="Controls\MemoryViewControl.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Native\NativeMethods.cs" />
    <Compile Include="Nodes\BaseContainerNode.cs" />
    <Compile Include="Nodes\BaseFunctionPtrNode.cs" />
    <Compile Include="Nodes\BaseHexCommentNode.cs" />
    <Compile Include="Nodes\BaseHexNode.cs" />
    <Compile Include="Nodes\BaseNode.cs" />
    <Compile Include="Nodes\BaseTextNode.cs" />
    <Compile Include="Nodes\BaseTextPtrNode.cs" />
    <Compile Include="Nodes\BaseMatrixNode.cs" />
    <Compile Include="Nodes\BitFieldNode.cs" />
    <Compile Include="Nodes\ClassInstanceNode.cs" />
    <Compile Include="Nodes\DoubleNode.cs" />
    <Compile Include="Nodes\FloatNode.cs" />
    <Compile Include="Nodes\FunctionPtrNode.cs" />
    <Compile Include="Nodes\Int16Node.cs" />
    <Compile Include="Nodes\Int32Node.cs" />
    <Compile Include="Nodes\Int64Node.cs" />
    <Compile Include="Nodes\Int8Node.cs" />
    <Compile Include="Nodes\Matrix3x3Node.cs" />
    <Compile Include="Nodes\Matrix3x4Node.cs" />
    <Compile Include="Nodes\Matrix4x4Node.cs" />
    <Compile Include="Nodes\BaseNumericNode.cs" />
    <Compile Include="Nodes\UTF16TextNode.cs" />
    <Compile Include="Nodes\UTF16TextPtrNode.cs" />
    <Compile Include="Nodes\UTF32TextNode.cs" />
    <Compile Include="Nodes\UTF32TextPtrNode.cs" />
    <Compile Include="Nodes\UTF8TextNode.cs" />
    <Compile Include="Nodes\UInt32Node.cs" />
    <Compile Include="Nodes\UInt64Node.cs" />
    <Compile Include="Nodes\UInt8Node.cs" />
    <Compile Include="Nodes\ClassNode.cs" />
    <Compile Include="Nodes\Hex16Node.cs" />
    <Compile Include="Nodes\Hex32Node.cs" />
    <Compile Include="Nodes\Hex64Node.cs" />
    <Compile Include="Nodes\Hex8Node.cs" />
    <Compile Include="Nodes\UInt16Node.cs" />
    <Compile Include="Nodes\UTF8TextPtrNode.cs" />
    <Compile Include="Nodes\Vector2Node.cs" />
    <Compile Include="Nodes\Vector3Node.cs" />
    <Compile Include="Nodes\Vector4Node.cs" />
    <Compile Include="Forms\ProcessBrowserForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\ProcessBrowserForm.Designer.cs">
      <DependentUpon>ProcessBrowserForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\ProcessInfoForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\ProcessInfoForm.Designer.cs">
      <DependentUpon>ProcessInfoForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Nodes\VirtualMethodNode.cs" />
    <Compile Include="Nodes\VirtualMethodTableNode.cs" />
    <Compile Include="Plugins\DefaultPluginHost.cs" />
    <Compile Include="Plugins\IPluginHost.cs" />
    <Compile Include="Plugins\Plugin.cs" />
    <Compile Include="Plugins\PluginInfo.cs" />
    <Compile Include="Plugins\PluginManager.cs" />
    <Compile Include="Memory\ProcessInfo.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Memory\RemoteProcess.cs" />
    <Compile Include="Settings.cs" />
    <Compile Include="Symbols\ComDisposableWrapper.cs" />
    <Compile Include="Symbols\SymbolReader.cs" />
    <Compile Include="Symbols\SymbolStore.cs" />
    <Compile Include="UI\GlobalWindowManager.cs" />
    <Compile Include="Controls\DrawContext.cs" />
    <Compile Include="Extensions\EnumerableExtension.cs" />
    <Compile Include="Util\HexadecimalFormatter.cs" />
    <Compile Include="Util\IntPtrComparer.cs" />
    <Compile Include="Util\NumberFormat.cs" />
    <Compile Include="Util\PathUtil.cs" />
    <Compile Include="Util\Rtf\RtfBuilder.cs" />
    <Compile Include="Util\Rtf\RtfBuilder.RtfFormatWrapper.cs" />
    <Compile Include="Util\Rtf\RtfFont.cs" />
    <Compile Include="Util\SettingsSerializer.cs" />
    <Compile Include="Util\Util.cs" />
    <Compile Include="Util\ValueTypeWrapper.cs" />
    <Compile Include="Util\WinUtil.cs" />
    <Compile Include="Util\XElementSerializer.cs" />
    <EmbeddedResource Include="Forms\AboutForm.resx">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\EnumEditorForm.resx">
      <DependentUpon>EnumEditorForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\EnumListForm.resx">
      <DependentUpon>EnumListForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\EnumSelectionForm.resx">
      <DependentUpon>EnumSelectionForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\NamedAddressesForm.resx">
      <DependentUpon>NamedAddressesForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\ClassSelectionForm.resx">
      <DependentUpon>ClassSelectionForm.cs</DependentUpon>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\CodeForm.resx">
      <DependentUpon>CodeForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\FoundCodeForm.resx">
      <DependentUpon>FoundCodeForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\InputBytesForm.resx">
      <DependentUpon>InputBytesForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\InputCorrelatorForm.resx">
      <DependentUpon>InputCorrelatorForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\ScannerForm.resx">
      <DependentUpon>ScannerForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\ProjectView.resx">
      <DependentUpon>ProjectView.cs</DependentUpon>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\LogForm.resx">
      <DependentUpon>LogForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\ColorBox.resx">
      <DependentUpon>ColorBox.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\DualValueBox.resx">
      <DependentUpon>DualValueBox.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\HotkeyBox.resx">
      <DependentUpon>HotkeyBox.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\MemoryRecordList.resx">
      <DependentUpon>MemoryRecordList.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Controls\MemoryViewControl.resx">
      <DependentUpon>MemoryViewControl.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\PluginForm.resx">
      <DependentUpon>PluginForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\ProcessBrowserForm.resx">
      <DependentUpon>ProcessBrowserForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\ProcessInfoForm.resx">
      <DependentUpon>ProcessInfoForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\SettingsForm.resx">
      <DependentUpon>SettingsForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <SubType>Designer</SubType>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Debugger\RemoteDebugger.Handler.cs" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_4.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_8.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_64.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_256.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_1024.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_2048.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_4096.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add_Bytes_X.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Array.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Class_Instance.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Class_Pointer.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Class_Remove.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Double.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Float.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Function_Pointer.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Hex_8.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Hex_16.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Hex_32.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Hex_64.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_4.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_8.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_64.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_256.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_1024.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_2048.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_4096.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Insert_Bytes_X.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Int_8.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Int_16.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Int_32.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Int_64.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Matrix_3x3.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Matrix_3x4.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Matrix_4x4.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Text.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Text_Pointer.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UInt_8.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UInt_16.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UInt_32.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UInt_64.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UText.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_UText_Pointer.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Vector_2.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Vector_3.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Vector_4.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_VTable.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Control_Pause.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Control_Play.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Control_Stop.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Textfield_Rename.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Accept.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Arrow_Refresh.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Quit.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Chart_Delete.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Gear.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Delete.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Error.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Folder.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Help.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Information.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Code.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Code_Add.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Pdb.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Plugin.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Save.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Class_Add.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Save_As.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Table_Gear.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Text_List_Bullets.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Array_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Drop_Down.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Class_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Closed_Icon.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Custom_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Double_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Enum_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Exchange_Button.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Float_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Left_Button.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Matrix_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Open_Icon.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Pointer_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Right_Button.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Signed_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Text_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Unsigned_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Vector_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Copy.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Pointer_Array.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Function_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Interface_Type.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Icon\ReClassNet.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Code_Cpp.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Code_Csharp.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Bits.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Warning.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Color_Wheel.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Settings_Edit.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Page_Code.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Plugin.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Magnifier.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Cogs.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Magnifier.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Cogs.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\BuildDate.txt" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Tree_Collapse.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Tree_Expand.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_Paste.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Camera.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Folder_Add.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Magnifier_Remove.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Bool.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Function.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Category.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Page_White_Stack.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Drive_Go.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Find_Access.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Find_Write.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Eye.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Magnifier_Arrow.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Bug.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_3D_Glasses.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Eye.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B32x32_Canvas_Size.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Canvas_Size.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Redo.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Undo.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Add.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Remove.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Pointer.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Enum.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_Union.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_NInt.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Images\B16x16_Button_NUInt.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PreBuildEvent Condition=" '$(OS)' == 'Windows_NT' ">powershell -Command "((Get-Date).ToUniversalTime()).ToString(\"yyyy\/MM\/dd HH:mm:ss\") | Out-File '$(ProjectDir)Resources\BuildDate.txt'"</PreBuildEvent>
    <PreBuildEvent Condition=" '$(OS)' == 'Unix' ">date +"%Y/%m/%d %H:%M:%S" &gt; $(ProjectDir)/Resources/BuildDate.txt</PreBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`ReClass.NET/Resources/Icon/icon.pdn`:

```pdn
PDN3áí<pdnImage width="256" height="256" layers="7" savedWithVersion="4.12.6099.39434"><custom><thumb png="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" /></custom></pdnImage>     ÿÿÿÿ          OPaintDotNet.Data, Version=4.12.6099.39434, Culture=neutral, PublicKeyToken=null   PaintDotNet.Document   
isDisposedlayerswidthheight	savedWithuserMetadataItems   PaintDotNet.LayerList   System.VersionæSystem.Collections.Generic.KeyValuePair`2[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]][]    	         	   	      PaintDotNet.LayerList   parentArrayList+_itemsArrayList+_sizeArrayList+_version  PaintDotNet.Document      	   	            System.Version   _Major_Minor_Build	_Revision          Ó  
š         	   äSystem.Collections.Generic.KeyValuePair`2[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]øÿÿÿäSystem.Collections.Generic.KeyValuePair`2[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]   keyvalue	   
$exif.tag3
   D<exif id="318" len="16" type="5" value="JXoAAKCGAQCDgAAAoIYBAA==" />õÿÿÿøÿÿÿ   
$exif.tag4   l<exif id="319" len="48" type="5" value="//kAAKCGAQDpgAAAoIYBADB1AACghgEAYOoAAKCGAQCYOgAAoIYBAG8XAACghgEA" />òÿÿÿøÿÿÿ   
$exif.tag5   1<exif id="20752" len="1" type="1" value="AQ==" />ïÿÿÿøÿÿÿ   
$exif.tag6   5<exif id="20753" len="4" type="4" value="xA4AAA==" />ìÿÿÿøÿÿÿ   
$exif.tag7   5<exif id="20754" len="4" type="4" value="xA4AAA==" />éÿÿÿøÿÿÿ   
$exif.tag8   D<exif id="305" len="17" type="2" value="cGFpbnQubmV0IDQuMC4xMgA=" />æÿÿÿøÿÿÿ   
$exif.tag9   /<exif id="296" len="2" type="3" value="AgA=" />ãÿÿÿøÿÿÿ   $exif.tag10   7<exif id="282" len="8" type="5" value="C3cBAOgDAAA=" />àÿÿÿøÿÿÿ!   $exif.tag11"   7<exif id="283" len="8" type="5" value="C3cBAOgDAAA=" />      	#   	$   	%   	&   	'   	(   	)   
*   OPaintDotNet.Core, Version=4.12.6099.39434, Culture=neutral, PublicKeyToken=null#   PaintDotNet.BitmapLayer   
propertiessurfaceLayer+isDisposedLayer+widthLayer+heightLayer+properties   -PaintDotNet.BitmapLayer+BitmapLayerProperties   PaintDotNet.Surface*   !PaintDotNet.Layer+LayerProperties      	+   	,          	-   $   #   	.   	/          	0   %   #   	1   	2          	3   &   #   	4   	5          	6   '   #   	7   	8          	9   (   #   	:   	;          	<   )   #   	=   	>          	?   +   -PaintDotNet.BitmapLayer+BitmapLayerProperties   blendOp&PaintDotNet.UserBlendOps+NormalBlendOp      	@   ,   PaintDotNet.Surface   widthheightstridescan0   PaintDotNet.MemoryBlock*   *            	A   -   !PaintDotNet.Layer+LayerProperties   nameuserMetadataItemsvisibleisBackgroundopacity	blendMode   æSystem.Collections.Generic.KeyValuePair`2[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]][]PaintDotNet.LayerBlendMode      B   16x16	C    ÿ¼ÿÿÿPaintDotNet.LayerBlendMode   value__        .   +   	E   /   ,            	F   0   -   G   32x32	C    ÿ·ÿÿÿ¼ÿÿÿ    1   +   	J   2   ,            	K   3   -   L   48x48	C    ÿ²ÿÿÿ¼ÿÿÿ    4   +   	O   5   ,            	P   6   -   Q   64x64	C    ÿ­ÿÿÿ¼ÿÿÿ    7   +   	T   8   ,            	U   9   -   V   96x96	C    ÿ¨ÿÿÿ¼ÿÿÿ    :   +   	Y   ;   ,            	Z   <   -   [   128x128	C    ÿ£ÿÿÿ¼ÿÿÿ    =   +   	^   >   ,            	_   ?   -   `   256x256	C   ÿžÿÿÿ¼ÿÿÿ    @   &PaintDotNet.UserBlendOps+NormalBlendOp       A   PaintDotNet.MemoryBlock   length64	hasParentdeferred   	*           C           äSystem.Collections.Generic.KeyValuePair`2[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]E   @   F   A           J   @   K   A           O   @   P   A           T   @   U   A           Y   @   Z   A           ^   @   _   A                     +‹      íÙolÕåà—-"SþTe„PD£†8ª"JØpÄf8Xi)2;ÔÊ(´Ì¶j×¹ebKÇ +‡²¨Q"fNÙ ÅYbX²± ÈæØ”dÃ ED!b‹øìGÝ\²íÓÉ’“&×I®/'9Éýå~Þ÷}NJÿþ¶–==þ®ù{ÓŒÑÅÿúnÝú_¥¿Þ8÷…-Ú¶õ¥Gž{vSÝ–ç_èWSS“æUW§ˆ z©þýûªaâä±Ë¿óá­ë–ÅwŸ^ƒ[KW^pÕå£ÿ´sûŽ;£»sW|ôÞßãØ±ëõ?ìnnYtqµþC¯¶páÂ”æ_rÖ°Öò<Ñßo¸1îmjŒ–Ÿ/Ž­¿åx|ðFÄíGß‰è:œýä“Ìñxãµíï.m»k`¾ó¹+))I©¶è•áKfEÝú5ñÃ£©ê[qGÛYÕ³¾wîˆ®ý¯G×]qüÝ¿ÆÇGöÅ§3àD,k[r[¾ó¹kooOiÁ¥·œyÛÄÃ%?[·¿ôÛ¸eó=ñàÚ³c¾3N|3ºö½–ÙÑó89²‡@ÄÇ‡ã¹MÖæ;?»Õ«í‘&=§oÓeï\´´6*žz8VoÞ”uüýøäý=YïÿøÙèÊf@Ù›½öÄÆgÖ=•ïü@îfUV¦Y³*?Ûÿ}så¼Ü41ªÚWd×ücÝãø¡·£ûÀ?gÀþÙ›`{Ä‡{¢¹åÇ7ç;?»>Îþ¯ýß’ïÕGÑ“ãí·²»~tEÛŸù‹xowÏ> íˆm¿Ûz¬¥õ'§å;?»Ô¯ðîÿÚV-ŽÇ×ý"6nÙGí‹#ÞŠ£ûÞÌü9:¶ut×,¨¿pÚ´’¼çr—Nžÿÿ±ÿ[úüÃñì«›ã7ÍŽe±èÉåqß†5ñÀ†ÇâÆ‡ZâŒ¦kªŠ‹‹SiiiÞó¹ëéß!=û¿4eÄÖÂqcâþU«âæ'ÖÄ¼öêXPmT7WGÕâ9qzÝqjãÄƒ©þŠsÊËËÓôéÓóžÈ]OÿOšR:}JAAAÌ(›_Ÿ=£{ÂòûbÎú£ìÉ–˜qçÔh­¸>jo¿!Æ´]E÷Î;2rQY“þCï–ŒÌºÿ…¬ûƒ¢bfyÔÖÖœ>áÊiiþ¹ß\ß~ü—Q¾öÑ˜ÙvC\Ý05>_7.Æ­˜·Í~Fÿ¡wëÓï‹3‡œU×]ÛÓýQ_ÕÀ³Ç¤a£Ç§4÷Ü’¾õ—í¾ôþŸFñš1¢yR\}ÏœøÊÝ×ÿÅýz¿>§¿ffÅôh¨¯‹Æ~í«gŒº<,š”F-N©àü“ÿœ–æœ·rèÂ²×VgþèÑ÷ÖI³õz¿Ï,JM(ò¥Âa•©ß 4`pa8xX4dDJ§¤ÉS§¥;~“ÝÎ+NóÇìMõW¾ÜÑÑ‘ô                                                                                                                                                                                                                                              øû6tÐr             
¥‹      íÝyPÔçÇñµÞmŽ6V{$“˜Lj¦Z¥ÑÅ¯Á+!Æƒ€¢Ä‹AÄÔ "¨ñ¾£`ˆŠ%*‰Ñq– B<E–C0AA"ñþô·›%¢’öu†÷3óšav~ËÎóÇçû{žg¿»k2Ýgø;=ÿÜL·+/Îô½ÉÒ.Àx¤Æý.-NNNµ“““_ÎÊÊê™íº{÷n'??¿zŽ$ rß`žçµ1Jþ-Uß¸05ß%Ýäß¶Ee—nØ°áùÜÜÜå………ÅVköíÌŒ}ÊØ·WFñXi~~þ¦mÛ¶µ#ÿÀ£¥òì;w4Yœãÿ4½Ú,®¶‹ü441R›ãõƒñx¸iZ§Z?]YcÏž=ãì—Ü—¢ì´­*:”¬K©ºtâ€Îæg*{ÿne~þ©rsónîÝ»w©¿¿]ò<îcÚ7k<±ÛÅŽËýõ×hOx?\k#4eÃ¹¯ 	ï¨q¨ËaÓØ¶ÿ0Ö÷+r¬Goÿr—®ìÖÕÓºqá„n–žÕÍ²ouëêeÝ¾ñƒn”]ÔñìLådg)--mûÝ5ÀÑóª³{†Å9ù¥(O#§	r]æ§ð5¡
²ŒÕœ¡JØ<C±cä³q–,k¢nY­Y*Îý\WOîµgÿú·yºñ]¡n\:uO¸}ë†Š¿ÎR~^ŽŒ½Àrò8^Åu»&¸èÏôú"ou]4L½5d°‡FûPhP âb¦jRÜ$e|‘©³ÇèZÑ#û™ºV|D×ÏYÿc¸Xy8SxXGŽ¹µlÙ²öäp¬;ëþWž2˜Kêïªß‡»êÍuaºaš–nž®i“†É½?ùúx)$p¬VmŠÕÉÂ\]={D×Î|eÔ€ƒöü_+9úÐpýÊ>nÕVcÀ±î¬ûÍëLíõ›ÀªWì8lJÖèÄH¹'LUø–­xo‚† éó,úwÊn}{:×ÈzŽ®géÚÙÃ?æ¿Š5àü‰,¥§§ÿÐ»wïFŽž?PÝµö·{ÿ2[hé®aë7êµu§5yK‚5`TâtEk·W‡+;;[—Š¬ºadüÇpÔÈ~V•kÀw'¾TNNŽæÍ›×ÁÑóª³
cœ¹¹QRl5 ~HZ¢1É‡5øã¯46)Z½ãÂ4<6Bùùy*;W`dûxÕjÀ…Š5àâñLhÕªUîŽž?PU2j˜Ìo›œKmuà…ý4âÃ8Y¶ï[üù¯™©‚cÇTvþk#Ó'lW±Üµ¸—¢‚‚cŠ‰‰éïèùÕÙ}G€9ÆÖÿc«uƒ;É¼ÈO“’–È#6UyyyºTòµn^þæ×× cÍpîèNY­VEEEµuôüê¬òìßéÿ{vÆ Õ
ê`¯œú††Æ.Pæûõ]ñOëùòP•½Àù<{¯@Iþ>¥¦¦^6›Íõ= :»gTÒÿ·äƒ0½ÑÛ^j{UË7­Õ™¢Sº^ZRõpö°®žÚ§Òc»têx®6oÞœÀû€cÝ3Ðÿë¯úÁÕ2l ²­Ù*)2ö WÎ= üôÞ`ÑA{ÐÆ½ÿ›œt<tèÖÂ…[’À±*®ûÞÿ·rÅý}f_mÙñ±ýïü™¯ö¡*ÊIS^nŽ>HÚ8¿ü%= :»³î¯zÿßä„0mMÝ©ŒŒåX­:Yhä¼´¸b¸ëL°¬è°
Ž¤×f+%%e£››[Mò8ÞuÕúÿ"æ*âã÷´woš¢£#´~K¢¬9Vûçýs³ªäd®.èò™<-øRÙS•™žj¿fêúÅÖN~þì0ùì®µ•úÿîˆÓ¾Œ}
	òWÀ˜ÑŠÑ’õ³õaÚNåæçiÿþýÆ=þ3ýgÏ:tHGs­ŠKùH­f.µ-þò¸ÁÑóª³
ãýÁIïjÖGk•nd?zE˜Fø¸é­A5r„¯‚-Š	Sóð~ê<¤<V‡i`ì™£}õDhO5u‘Q_FÜ{ØHþGªd”÷ÿ]2ù¶ÕÓ¯;©ó¨Júd‡âããå»d²ÜÖ„hö¦ÉŠŒð“{ÿ>êå©‰ËÔq¦¯´è©Ð.FÞíïÖ0öÆÿK«ì…È?àX÷¯¼`®ýxã+Mš4Q«V­ôfßþÚ²s»º¯Ú/ß÷gêÕeþò§ùk‚9RmæziÚ»X´hîDõœã®šFökvÐ_"ú–Úk
ù)•Žzx¦vúåÙïÑ£‡<==Õr´q¯_ª¶«NÉ'!I.ËFËe©‘ýy>3JCõ—Ï·4vÔH……kúRµžñ†ºÇ«_|˜êïø™}AþGBU³ïíí­fžíý“÷{äµ1O>k§é¥è!rY<LsÖÈ2ÒCƒÜhÄ°¡š1uœ^~§·jÏiîªáIsÕ"ê­2ûY#ù®ªÙïñšëÁ:>Î&‹óiÛ¾þñ‰Ýõ¤|?<¡±ÿÚ*çw½Õ2ÚCCcý4;ÚOžƒúÉËØÔ	î¬ßv°ŸxnˆTÐ¶¶ó€uäp¼
Ù¯×à¾Ùoú¢Óïì×…´odÔ€•FžoÛzÚÌv×È¤íê“\¨~«§ª™í;Ã£Ü¼úm5žØMµƒ:ÙÏ …º¨qh·’†!]­ö^#ò8ÜÝÙoÚ´©Z·n­îÝ»Wžý»G@»ÎFÈ³¿W8¾³ú¬š¤¶[
åºéµš=Pëƒz!]íû…i‰ïhÊæÙ¶5@çÀ£ÃôdóÆuê58Vžýž={Ú³ïåå¥½*ÏþÏÏg®o²˜çëù›5Œ:ðÜtWõÞ(×•¡j9«¯ž2îÿ5µÿð÷‚ä ãšDò<:L¦æuŸ|ºÙ®6mÚ¨W¯^¿¼ï?Q•œš,íœŒ=ÁaÛZÀvÖ÷Xh7%îX¬~‹½Uo|5¬!].Úúÿî¼.ùÍ>š´lØ±³Ë.Û=ßÇÇ§<û~M>M~Nµí¿à|Õþ=A¯Úkíó„åý•½¶£çTgå£IËnûºy|ÚÕ¥çñºûÌÿüÿl¿j1§ÿ¢ÿo·£ç	à^G‹:¦ºuŸ5þø¿¾—ßäfªiÿÍp‹ó÷†+¶ßwô<                                                                                                                                                                                                                                                                                                                                             àaþáWs¾             ½‹      íÝPWWÚðc	hL45®1qS±fP±÷¨€ Hé‚J“"k‹±&Q£hlA$®&1ö£;"E:64J}öÜKQÉâÇ0ßsf~Ãè`™;ó¼ç}ï½ç/¸\tº×öèq[¸éî:Ÿ÷­õë×Ýºu-[¶Ÿ~ú©ðõõ"$$DXYYÕÕÓÓk»gÏ³¤¤¤ ÔÔ´/SÓÒ—%%'Ï9sæŒƒ¹¹¹Ž››[å{›7o."""”?#ÌÌÌ„‹‹‹øì³ÏDÿþýÅ AƒT ˆèoz¡5¦U}™ûÃCWNÁÈU>Ð˜ÜûŽp×	}DÝÉÿÔ©S…¿¿¿¨5wî\Ù³ç^¸xikfVöoé™ñÒõŒÌ¬Øä”»W®\¹0,,ÌP~½fÍš‰ððpammÍü½/´\»[5õ^üËzÌ>)ÿY6³ÍŠ…›Îá¦ÝëYùûí·EÇŽ…———øúë¯~;uúà­»÷óïäÞGìÙ³8°ïgüôÃ6ìþ~öþøN;ŒŒôtÜÉý§NŸ¹¼hÑ¢©²4Ð××¦¦¦Ì?Q{Áü·“{þíñ‘óÐãËIh7×
Î;Ãx] ^›: WÖùÂ¡K£'óß¸qcÑ£G–ÇŽÛ–˜|ññ×pâÐœø91?­Æ•ƒëôëV$žúWÆ™[qôç-8ðã6\ˆ‹Uë@Œ\ŽŽŽ=ŒŒŒ„³³3óOT…žŸû5…»öLÙëÿ$3~¿yÀgè0Ï#Öø¡£üªæ©»V¢ÝKÙèžnÝ”å¿uëÖÂÚÊªÏ¥ËW’o¤ãô‰ƒ8d;nÆî@Aün§î$ y·€¢ò¿R É/wp7õ<âNüˆãv#ázŠæÍ›7ÞÒÒ’ù'ªBÏ]îÚNr/îºÐý—{¢e>ô×À)";vÍ‚ÿfôZ`çí‹`1¦*ub•˜Ü¥©………nüµ„?Rn¤"îä^äœß¢¤}(L:ˆüÌ8ÞMEQn
ïI÷³PôÇM=Ì
óQ²
p+õ"bÿ„„k×p-!³fÍš û	Ñ§O1jÔ(¡ÌÕ}ýˆj²7ß|³Rr®ÿ¨¶{ŒŸÛÀ3"®›‚ñÁLÈ½ÕwÁ	˜‚È!X³3–+'aà2wxí\†ní‹ë9éÆþõx–’ýøØ#È½v E)G—xy±(¸u]J@¡üZx7…¹é(ºŸ-Û€[²ÜEqþ}¨½€\nßÀ•ß÷#))	gÎÄäMœ8±·\ê}ÅN:Uûõ#ªÉ”¹º2rßÑØo(:Í·ÃÙ£8vl>ø·)¦ç/'x¸8cš×d,ùÜÛ¾Ÿ‰àH_X4v‘óðuä:\OJAÒåS¸wý0
ROâaÒQ<¼ñò³/#?ç
r® àf‚Z
ï(5 E÷Jj@q^®ZŠó ¬û9ÉH¼ð+RRÓ°ÿþßGŽùzY‹RÝ×¨&Sž«=I¸w·®ãÙ«¸eˆ‘ÜóÍ`±Ô_Ú¢ûçc17Äf¦c0ÞÆÎŽðòpCÀ4o„Œo˜	ó\‡IWåxE¿#OæþaÊ¯êÞŸŸyùYd5àæU)¾´ÜPû€Â{Yú€²p;å<RÎ#)%...Ì?ÑÿNOO¯áÔõá®“XÊ 4	†>CÐy¡z/uƒÇæ lX5¶–£1f´!¬-Ìà`7îÎ“d/à‰¥óý°nó:ÜHMEÖõfÄ  ý,òROI§eþÏ©³yÈ)«×dH¬|(PfbåßCFü)d¤§"*úû‹²h ÌÕ}ýˆj²'V-™ýõÂ½^™Üõ¦ôÇû3Ma¸>P5qS0fF…bíŽÌƒ‘#`f¢ôVj/ðï.8á²ÓS›|E9‘Ÿ.3Ÿƒ¼ôäËý_íÊë@iÈ‘5 G¹X:<ªÅä,§Ô ¥8‡¬äËHHL¾¾¾eS¹ªûúÕdÚÚÚå„kwcá¦›§ä¿–GO¼>m F~ë‹E?|Ÿ­s`TZ¼·„`ÙÎ™Xóí4ØÛÃØÐ ~Þöðœ3ÉÉ)ÈIGÑM™ë¬‹%{}ºÌ¼Ò¨Ù/©å½@Ù,óüY E(¿—t©²¿ðóó[:zôè>Õ}ýˆj²Ù³g—n:»…».”ü+ÞŸi"³Œ‘k/â_ËSñï¨õ·1X­c7ª½@ø÷3ðy¨­÷Å¬UKJÞßK»‚¢[2ËÊ½>¥dÄ©¹W÷ýòü—õOÏ…•ÎÊ³Á?póúoÈHMÆÚµëö/X°À³º¯QM¶|ùòrÂ]ûŸ²ÿß"ë@QIÐ-GÀmc\7@·UÀ?êfì˜£Ö€1²L’3Aèö°Z€°ë‘•™ûYñ2Ã	%yVîóg—Õ€seÿ‰> óñ> ô~@Ù,PÚ ðn];‚ìŒlÚ™°T®ê¾~D5YXXXê= íÑ²$•õ¯LîíãðyôR8lO‚áö„îŠ„CD0ÖMÇ¨5þ0Àæí[‘•‘Ž‡92»·Kr\ZòËfµ8÷üYàæ•Çj@é, û€â¼»¸ue?²Ó“°#*:kÕªÕßU÷õ#ªÉžÌypþ´¥ú.Ÿ»ÎÃ²^ iÀp8È>ßÿ?{Ðzë]˜íüS·ÎÄÈoý`¼Ò[¢¶Ëý?n&£èNrù{>j¨0œS3ÿtxlÈyâ¹À½Lå¦áÖ¥=ÈÉHÆ¶íQòÿ¹®º¯QM¶bÅŠgA¢¶pÕ*ë@Ö£^@]¾°FPô—ðÿiì6Ãr} ×NÇúÈdgg©ïëå¦Ê½;YÍ¯úžÚ\F’ïÒÿÄ,_é,PòŽ2f_@Îù]È–5fcÄ¦K²ý_XÝ×¨&“úSÂ¹›vëxô,¿7ØÈg0†­ð€áÚ 9ÿ¯Åè51_‹ÌÌLÜÉJAñ=Ù³ß½¡ÎðjPû€ø¿<ä+5 ô™@^Ò!d]Ü‹ôô¬[µ{Ö¬Y«ûúÕd¶¶¶ÏTáüŸ«ÎýÆ2óõ¼ú@¸•ôu=õ 5{,|7ÏÆ°o/Àö‹mHKOÇ­¬TßÏ”ùOWÏù–Í7+Ÿ¿/øÔsù½ÊŸUžÞ¿¥¾W”’šÏÉ“¿4hP·ê¾~D5Ù;ï¼óL•ÿûlµ:nå½ÀkSbôr¸Ì›‡„„ë¸™‰{rÀƒl™ÿ´Çj@â£ûê,ðìûåï	Ê /í
÷!;6YéI¸tå†®ß¤I“†Õ}ýˆj2GGÇJýÙù?'_'|ä7µJ{åþ Öt#ìØ­Î Yi‰(–ù/Rû€´òY °ü~À³gUºâ,¦œD~âAüqu7Ò/CFf6"·l=3`À õ3FªûúÕdmÛ¶­Ô‹œÿ›ìåŽQÓ-ðš—Êîš„º"5-i©7p7Kö oª÷îŸšÊŸ\z4”f^Ùï•3SN¨ç•¹ÿüOHM¾Žsç/ÁÇÇgÒˆ#„¡¡aµ_?¢š¬òÏýøkçÿ&N™„6~ÃÔ á ƒðm›qãF*R’ðàNziÈ¨0Vx.påÑ, ¼+œSr^èÆo(L=‰Û—÷âú¥3êÙ¿Õ›×Ÿ533«maa!lllªýúÕdO­¿yþoª—Ì‚mÐÀCÖ-Ç…ÔÏûK¸*ç÷»@þ­§f’û•¼#$k@œŠ3cp'þ ®ÄGJj:ÿz<O[[»½†††P>XQÝ×¨&«Êóa+ü1|¹;flZŠ¸¸8œ—5àò•«8ƒÜl9Ü–½@Î÷+¾#¤ÌÅ7/Ùç}ù0Îþvêg‡^O(¶õr²¬[·âGŽW÷õ#ªÉ*¬ÿñüŸWx ÂüðËñ½8vì6lØ€K—.«}Àñ£Gp9îî)u ï¦”<}Á½4 7E’¿Ÿ›Ü¾Š[	§pî×_pâØaõs„Î]<Ÿ`4tèPñúë¯3ÿDU¤ÂúÏÿ¯À±¸Ó2ïñð÷ó…ã$¸‡LÁ¾c‡••Ó§OcÿÞ=8zhbOÅõ‹§‘ƒ”+¿#>öbŽïÁ‘}»p`ßœ‹;D™ýÍûv¢…S¿í={öæææÌ?QªxßïïŸÿ³X€ƒ±'ÕìûN›
ûñãà6É	Þžn0ó¶FèÆ%¸pí
<xˆ³gc±oß>ìúÏNDEmGtT~Üµ‡‘™OFVvœ>ûoB éÙ;SyÙ¯_?æŸ¨ŠU²þòù?“5AØsBÍþœ™¾0=
¦ÆFge	'û	ðts«—+ø›BÏ×‹wnÀ‘¿ãÂÕË¸{/wss‘”t{bŽÂyÙŸï­ÙÐôîå$¡<ïgþ‰ªÖ3×œÿ3Ù´ów,EÔáŸ‘˜˜ÏÙþœŽˆ¾pŸ8Æ†ú°43ÅÛqpušˆYÁÞ0XlÏÞh8u Þ1F£I½ÑÄ¥>5Á«Þý >wðÓ*Ïw)ï 3ÿD/Çs×£ó	j/à¬‹ºf= åaÇÅÓ±uï~lÝ‰ïÂÃá·p/ó‚a˜7Ü¾›†Å[ýñÕÎ02YÚX`áª)h;ÇæË0|†	4'?:OT«ôk]ÙkhÊ: ÿ½ûÂ½«–rþˆù'z9^h)?ÛÏ©ëÑ¦U¡F}M4iÒmÛ·ÇDW,]¶GŽéW?ÃgóúÍdôúÚ&aÜ4+Â§ÁËÅ3ƒìÑo±tæÛ`Ébox{¸cü4üÓg¿çXK=c¨üZç¦ü:D©AÌ?ÑËñB«¶æ+B£Q´¦¦š5}ZZ£k·.èøÉ¿°ø«åX¸þk_‹w¿ºÏM;`¾z*t—8IŽ°]íŽÅ[|àæ"gzKã[+Lœ`§¾CìíåŽaÓÍPr¯Ò ‹Ó?ƒÍÆ™xÃgðùë01©[æŸ¨êýéªSOf¿a„¦¦&šËìüñÇÐÖÖÆÐ¡Caa6æ6ãñú„^êù¿)‘[ðö—w1|í%øoš‹2ÿL€ö;´™k…Kì0¦#G„ÅXØ³†ËDGµpðqÂÇ¾C éÙÊýÆEÜ³ÝÙ+½Àu9ƒÊÿM-æŸ¨êüÉ¾_Oîû[4ä¾ß¼YÓòì2cÇŽÅDGX³CËÎêýÁwƒàù] ¬Ã‡öêûÙ±f+ÝÑaÞ8hÍ±BßE¶	÷Ä7KÝ`mfXú±yù;Ä¡A^ò…	4¼ú Žg/õ3Fl7Ï…KÔ¼é7¬HÖ€Hõ%óOT%þ¤çR{~%ûZZåÙ733ƒ½½½Ì¿=L‹k[tºS6Ã×óî‹þ‹Æ#hëZoÌ‚ÃÖk²X€îóÇáÃYæêÏž´zæ­uGÀTkŽ‚™©	ÆÛ`ör7¼:¥¿úîqm^ê, Ô§í‹0ïP$ÚËB}&ÀüU‰g÷üžêùËö}%ûö0c„ö:ƒ×îíäÞ|°¬(½À[Ãá´ÖÑ'1"ò>ü£ÁØoœÐ:ÔD2Æ°%6wÇ¢¯œacnˆ@;tÕ‡¦W_Ô¬W~°•ì)‚ö¬Gð/ëÑÄohžúŽ2óOT%*ïùßØ¢¡QyÏ?aÂ8ØOÀc#´é¢·à­}…fƒ7„#êÈ0QÊ(«JŽÿ5ÛÁ[—bÌö4F¥ÂsÓtšk†æAxÆh}eƒ›½`þ¥5êO {ÿ¾êçŠÕrï){€ž¨/û‰£ðÖôPÏ&)ï'1ÿDU¢â¾/{~Í7¢ê×«‡·š7Ã‡~T~¯¯¬çWö}%ûZõæ7ÕÒïvê/óßèÑßáÒý=á¦-ë@AY/ð†Ï ˜.w†ó÷‡ðÁ¶\˜F‚Á²IxKæº±ßp¼<¯M¤ž7Tf%ÿífcÐrweÏ‡ü»‚äÜo*\;5ãý?¢ªS¡ç×lQ¯^}´hñÚ¶m<ø‰žßXÙ÷—(Ù»CÏ§ó¯,‡.¯È½ÚZöée½€2ÇkÍ0„ë¦è´#í¶§ÃYömBñºÏ`¼:m êy÷Sß5þ(dNß„V@kŽ¹’ÿ¯øü¨ê©ítiÏ_OîûÿP³ßºººÊglªÙ·µµ•=¿}yÏß¬®h%³ßêYù/[u›Ëì†—õ
åþ!‹¬1.j7zF%¨Ÿ+ôšÌ¿Òû+ïý){ÿ;A#±6z.>ßŠ†+}ÿjæŸ¨ê‰­ŠúMW¼ZOCÝ÷Û´)Éþ°aÃõüræmh ­.%=Yöÿ4ÿÊê#êÊyÀHføò£ûƒ=Ñjúp˜.s„òƒÓ¿›‚¿|‰·ü«}Bÿáøt¾ÚÎ±Rîd(çÿ˜¢ª'·ïP»Ñ{^-š7E‡ö²_v¯ÏÑ~BIÏßµ÷’¦—ôü)ÿrev®:«ïêÈ½^9ç3/Âûö.G+ÿ!ê=Ã–Á£ñÁ,3žÿ#zÉDãB4é(¿ó‰‡®®FSÓ±°³³Sïó›˜ŒA»n}4oÛS¼ó‰ÞSZwXrÿÿ9KÖ1gÎ¡|f§pÓ ë@ìãïü¿RzæGÙûyþèÿŽhÜNÔjÒ^¼Ò¢³xï“¾îJÏïâì¤¾Û§d_«SÏyo~ØM´l«S©V{W>7ÿúúúbÆŒÂÊÊªäçŠ(ç‰ÜµÈ™ ÷9çÿîñüÑË¥ä¿ö›íÅ«ow?ÐŸèôœ$³oinŠ¶ÝúÕ}µ±š³Úuê<C]!jÕª,ö–òYýnnnjþ#""”ßª%\ºëÉyàL%çÿŠåÌï³jÕ*Áü½<êþ/óß@æ¿YÛ¾¢i»â½N½=Z}ÜqZý¦ïŠ:u5þ4Û/²ºví*¼¼¼Êó'rssK~Æ ú|_÷NÙù?™ýÃbL«úÌ?ÑËõdþ[}:Thþã¹;«û{-ñÄûvwijjŠ†
--­
ùoÝºµPÿ7í.Ò~YnîÑÑÑ‚ù'""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""¢ÿOþÞ(æ3             |‹      íÝ	XYßðlÏÌàf3óóxÆ¬‡13žQÉ0Ãˆ‘”È¾‹ÐžP‰’Æ2Ù²«A‘viAÙÂXšDQ#kE‘}/Ë÷=çü+mRÆóÖ\ï÷\×‰ÿÿ}]ßsÿÎ}Ÿsn Z/Ôluô´¬un	®Z¦Zµ^ìEÊm5ºvíúŽÏw{÷îµ:vìØì””ïÔÔÔUÇ_|àÀ§ˆˆˆÞöööŸŠ[ûE~ Äg'úÿ®ÒÍêãWDîS^ŸôjÚ¶…–•v’–¶ö‹d°d355}SäzxRRRLNNÎõÜÜÜ'nß¾k×®áÊ•+¸qãîÝ»‡¼¼<Üºu+÷ôéÓÇãââf999µ/Q³¢?«ª;QuPéf£3Sæ~bŒ7&löF7cˆ¿Ë}‚§ê^ 5ŒŽŽž"²œ%òýäâÅ‹8zô(¶oÅúõað_ƒµ¾+±FX·Ö¡!!ˆ‰‰ÁÁC‡pöìY\½zÙÙÙ÷öíÛæêêúEE~fUw¢ê RmœÎÇ2ëí—Xaæî`ÌÛŽ…"Ñ}¥£¦°Ö9«e¥Ó¡¯XcÉ’%†‰‰‰§³²²ž¤¥¥Ad[7E`×¦ ÙîS{páP ²ãƒý{2ãdœ?â·¬Fl¤/b6nÀ®]» Æ¸páDr744ÔCGGç5æŸ¨|•jVmšˆŒßo³ÀS¶¯uô|6s œ¶®„«øúÃé¦¢Ðý€¶ÖèÖÊ{©æÍ›ÿ-$$ÄSd>ïÌ™3HøýwìÝ±	ÇãÂs,
wOnÁ½´-¸~/òrRðèÖE<¾wÜÂ“Ü;â÷›È½žœ´}8º3{¶EãðáÃ8yò¤ª	bcc÷Œ=úÌ?Ñ³UºÙè.ª!Îõ#B<ñ¾¨ýÿ³`4ÞšÜ]}&`Áþèå7¯Œo/kt-Ë6e½DëÖ­ëFEE…ˆ¬>‘yM8| Éû£p-u+îÙû§·ãþ¹ÝÈ»rRåþÑíl<º“#òïßÈïîâÉÃûxò(OÈÅÌd$îCBüA¤¦¦ª~@ÔXXX|Êü•­b™oû™–µî1uÍ_žß…ú;áóYÑsíTù¹à‹9CÐj†)ì7-‡ÇÎuøtF¿üZ@'TËâ›·
^Jž÷ÃÃÃÃD½®êý£ñû™(ÎóçöhœÝ‰wí^?‡G72Dp¡Dp½D‹'âQÞ=œKÜ†£‡÷âÔ©SjL Æi#FŒhÊü•V±üëÄ½êðšÏÝEãÐ~©8é£‡ßd•ˆéÝ6cœÐÉ³7¾_fƒyûÂ14x&^sø^^¼,ú¡â•jøùù-8räÈ1NÇ‰Äßp9Uä=}?ˆ:ÿÁ¹8MöÅyÿáµSBY}ÀågÔš>@ü‚K'àÄïq8wîœºŽ±¿sçÎõ˜¢âžÛlu-äy¼Õœáèâ3ÝW;£Ë/ÐÐ©ŒÖLÁð@WD¸cÕ"ìŽ×î˜°ÖïNéëÈÅ˜±+_Î¦jÇ~ñû÷ï(Ïû''àÊÉ=xyHe^õéû{ù„ÈÿÈ»Z¼xXfßäïžä÷i'Žàüùó8tèÐoooOæŸ¨¸rÛ8Ý¦²ækòÐY8þ[fâð!_ŒpAS÷^è¸Âa=àì`‹Iö˜æ2ÛÂ<à»e†ø·h9£tšcÎÞ0˜­›…µáÁ8vìÒÏBVŠÈþÅßñàÂá§}ÀÅäÉüç¤<í®žù/o,Pvðäñ#¤Å…Œóøã?°cÇŽûcÇŽmÍü=Un³ÒŽ®i«‡ÏfB«¹#‘ç‹¤„ƒðŠœŠ·'wÃäPÌvµÀØQf°±‡	ö¶ptó&cSÌ¬c“ãð¯éÆpó[qîGVVÎ&‹ó|V¢p¹¢ÈÍïr/%‰ü/Ý¼`ðèÁ¤ÅoQó†<ˆ5kÖl–cæŸHã™MŽ×EÍþÆd|øS?|6kl|-±<b
¾šÕ»!xõ$ô3í¡ƒ`Ôˆá°c{+U¸9OÀ†uÓ°wÏlŒðqÀúÈpu]þüéÜÊçùl‘õ¬£Oû Iä?÷RòKí®§'"ólªº'øë¯¿>433kÍüi”ÙäõzËuìÛã­)=ðž›	ÞvéŽŽñŽ‹þ5{<#Ý1ß}ztCocì×#†ÆYXˆZÀNS,ötFdàÏjŽNNNÒSjÆø2çEû Y¨ü—ÓÈ±@¹÷J‹ßÏÄoVó†ãââ°bÅŠÅÌ?‘Æ3Îý¡òÜÿê„ŽxÝ±:wC]ñgƒÕNêz¿4-Â«Å8?rÍDîg„ž=U-0d ¨†ƒ…¬¬­0ÑÞëÖü‚„„d_HÇÍŒc"Ó©šlí²Š¯“”ŠöåÖEú€K©»q5'ÉÉÉ

JŸðÕª>îDÕAé1#Í=þ¶¨e÷-^qøµì¿E/óÂìKÃÝà¸Þ3"§cßŽ™øyêHvû½{jjáCD-`6.Ç!*:JÝ‹Ë8u¹òÞžÌrÉ> ûXáù¿Ü>àJåÇ÷sÒžzr]ÁæÍ›>¼UUw¢ê X“svå¼=‘ÿ¶z¢hìj¤2¿|ólÌßèQ¬äçpwDÅÎBð:'ŒdãÝÑ×´—º.°j¥«wãúõëÈLK¹çï«i¢8Y¼P¹O.‘ÿò®T|,ðH|}.!F®TïÅÃÃÃ¬ª;QuP¬Ùè.+–}¡Ž8÷ÿ¸jìB§aÐº£ÐöÉÄª-¿`L°[aÐÏªú~ð¶™ŽñÀBÑèÑýG,še©>3±sçNÜÙ»tö¨ÈëÙrú€d•÷
Õ•Èµç…áþýûê½xyyÍ©êãNTÏ¿öä‚ù½²þ×ômÕ<ß‰anâÜ÷ÞF½ù1#j¼6Î@¯bcWuï¦ìŠt…wô4LY1WÝ÷»qí*®gžÐdõZÑ> èXàx‘~ ©„ÊŽŠÌÒáî;ê½¬X±"¨ª;QuPzü¯ÓAËZ7­h æûOê„®Þ¶ðŽ™‹Ðchîô¾‚í~°q+6&×ú®uá*'xü²P­Ë»zå2nf‰¼ßHÏïÎ<£(Þ¼Œ±À£»9È< j›r. |||"«ú¸Ue¶¡M_UûyXë<,Y|ôS_Ø‡¸Â[z…ÜB»`ÀcëaÑ/üSMþý¦Àpµ3º­rÄO>^ˆ×ä?ûÝÌ|Ú<s,pü¥ŽäÏÉ<„;·oªy@"ÿáU}Ü‰ªƒr›Ü×ËZçHñZ -êNøß-µÄÊ-?cÚ–#h
|¶á¼cÔu ¹P®è¶ÒîÞÔ9÷Æõk¸v1M“Ë¢}Àµòû€J®–=s2…àîÝ;Ø»w/–-[æ[ÕÇ¨:xnëÐ¡¶ÚçÓZç~É1Á?Ü{Á2h
VÆúãÓW %j ]kÑKæ_ÔþÝ~q„ãòÙjÞÍ1ö¾œþ‡ÈdVé>àzÅ®<w,p¥ôXà¡øY÷ÎÄâ\|„Ú7066,˜^ÕÇ¨:¨pS{ èü^p}° ë‚ušcÙæ™X°s¦mp‡¡¯ÆLCðŒYì†íÛ·«üËy¸eMþÜ> ü: 2c¼ìdÜ=ƒóGw¨{[·n…‹‹K¿ª>îDÕA¥šªt÷ˆ~ %kÆnF¸ÖYýVOÆ/1¾è½6ó×z¨{îrîoÆ9‘íÛ—4ãò"}À£ÿÒX O¼Îý3;p+u32ÒÕZàèèè<CCÃ«ú¸U?÷ßÿ§–m;”¬ä\¯æc‚©˜µ¯Í}ˆF?g!týzµ×¥ì‹¸•“®îÍ•ì^þXàÜ?§ö»x$Ws.!11þþþGÅ'ªUÕÇ¨:¨XþËÞÿç«y#PÇ®]©Z@®ê½r<|c–BÏ'6+¶ãÀ¸yó¦Èûqï*?_?8¿Oí%vït,Î$îPÏk¼¼¼¦ÊTÕÇ¨:xn{Îþ?}ü&¡­z@ñZ –èä¼!·Ð)póÀöØXµ?wúù3¸{íâ3û€?5È>†â5{‰Ésÿ¹Ý¸”¼ÎŸVõÇæÍ›ïš˜˜4eþ‰4Êm•ØÿÇØ~(êÚ|[ªx}RgtY4aj Ü‹ãÜ©‘ÿ+•¬J¯’yÏ-X?,s_¸—Øoª¸{f7ÒwãòåËøí·ßä}ï‚VÕÇ¨:(·Urÿk{K´´í¢sˆú‚ÓF`OÜÍ:Àôó¸”yZ­Ëyñ±@‘µÃözÚÜOß³	[q!3Cíµyã=SSÓÂçTõq'ªžÙþÄþ?}Æ@CÛï‹×Ö:ðZµ\ÍÌÌÌDÚÉT\»”®™£ÿÂcÒ}€f?ÁƒÈLÚŽS‡|¶Èþßö£‡Û˜=E?^Uw¢ê Ìööÿ±±³Bk;“bµÀÊÈ@5ÿ.))IÝ‹K9‘„kÙç+X<k½@ñ}„\ø’w %ùˆÚóK^ó·_<ý®–ñço1ÿDÅ=ãÜÿÒöÿl?
ïOì¤ú€iAKTý/ç§¤¤¨gt;šˆ¬ói/p= tpÿÂu­?)1rqY÷ÏðF½Ñ:ýK~Äª>îDÕAé1ÿËÝÿÇcŠl˜ŠfÓMÑs–•Êÿ¦M›Ô8@^“—ý€|ö_JRn_É|þ}2ú€ÜËÇqåô!=°GâŸÿåîëïí|Ëêâªú¸UÅÚaÿŸðõ®èöË$X­õDöåKjýÝj__¹º/Ççò<-ÿ~_Ü¤‹Çõì³È»•ýÜ:àÁåT\>¯r·;V­3–çýS§O!(2l‡Áe8Ì?‘T¬ýöÿàëµsu)[ëçÍ›c›!Ð³ì«AX´
ééj¬.k¹V`ë–ìÞ¹M=ðLêdMFNz
rÎÇÅS‰8uì7$ìßŽ¿nÄ–˜Mª‘{{ÊùÇN$£ûlKÔ´ÐvVö™"âùùûÿØúÏ-Ìþüùsa1ÖvV–0³‹ìô¡e¥ƒ¶nC°q_,r®ä¨ËgöÉ~ <<ð÷_‹µkü°Fð_»Aâï"£¢äó}Õù^Î)ÈÊºˆ=»#Ñ}±^ßA¼íEÌ?QùJµ—¸ÿýºy…Ù_°`žÄ°Áƒ`>r¬Æ…ƒ­5ôíào6z¨e¥=÷aX¹5éYÔZÝÛ·oãÒ¥KêšÏËë…òÞ¡œË+¿K|_R<\ƒ—Â`ôYâÝ)†PëäÜ%æŸ¨\e¶—°ÿ}ÀÓìÏ÷šg»á0ên€>½L0x@?Œ6ãF‚­•#ØYàcÛnùÏ}ÍwÐq
ë5³±tK"Äø~kÂ^=qXô©8ÿ+ú.qDÓ‰Ýñšm|:sZxï-ÿ™ãVºåeŸù'Ò(·UrÿŸåÛü1oýRØ­œìüì{Šó¾Ã/ŽÝ:+½¬`bÔ&ÆFèßÇCÄhYŒƒñ6Ö0°„¿Û·/5‡XÞ¨7©3ÌW˜!a§¦¯³†œ› ¯M¾=¥>pï£æ(Ék¢~‰{^ö™"ç¶röÿù`ª	Ì×8cYŒ/>	¹ˆqÑ)HOOÇ¢E‹°{÷nÌñšã…¶ÆVN˜¿a*vntÃ$ëª0íÕƒú‹Z`èŒm÷É¶pó·EýüùE×É?ÿMŒë_›ÐQüþjÚ¶Ã+ß©ù‰ïL5BÝ‰?@óÿóóOT1nšý~+ÌeÇ£Ö›o¢î»ï¢ÑG¡ù—_" $\®¯…³³³ºÇo9ßúÞè´b<ô—Û¡ßªñ˜0	Q¿NÇê%6èml€žF=4µÀ 	š¬Ö7›ÑÃ—D»¥jù{m»öêï^ý€¬$MÝ¯=©¢§ª;QuP©&k+][­o?Ï­U§ê×¯F¡Y³fhÕª´Û¶Ã$''©y·Cm†÷&Oú8ˆñ‚-¾]bNK­0Ê×~§Â/Ü.¢æ—sˆþ4}–ÁÇ3Àp‰V/vRë‰ZÙ£äz¢¢}Bíüq€è›îhY}Ùœù'ª¸J¶Zuß›\«víG%³¯§§‡.]ºÀ´o­€ÛÒejÿŸ·½îÂ3*Ðn‰tŽC¯10ñ¶Ä²Hx„LB¤ïÌž¨®ã5Ÿ5ÁAN0™¿žÈÚ
ìÍÐÐæû÷%õ
k‚š¶mÕÚ-kÝ{j¬bªU‹ù'z¾—™ý^½zaðàÁhß§g±ý´<®¾§°8r>º/·Vùo=Ú®AÐyñh|å9ŸÌ÷@{X˜xºžÈl$¬Õz"KhÛõBMëÒµ@1fXt 
WØ¡¦f­á-kíÖÌ?Qù^vöGŽ‰ö¦=‹íÿã±õççâíE¹˜½“&àk‘ý/çš¡¥çp4ÿy¨Z_ü¹°qÃdµžHÎ!.XOd&×™†]þz¢wìŠ\´ÑQçÿOfôÃO»áüëJ¼7ÕP|O'OÝÃ´úøæŸ¨l/;ûÃ‡G[‘Ý6O÷ÿéºt–F/€©ÿi4Y
ÌÀšÍ¡¿xŒºoÿ/‘Yû&ÎÿË#±r½#æº™¡G÷nj=Ñ€~}Ôz"sYŒ{ktœØ¯Øé¡Ž]{u/PÞ÷z¯qÅ’ƒa´Ú9¿ÐNSsš˜¢R^vöûõë‡V];«Ñå8½©{oØ­›ˆå›£ÐÞ÷Úù=Äâ˜XLµ@‹Ÿ‡ˆÚ>š1@Ôòƒ0/Ìv~–ˆtÄˆA=alØ}{‹Ÿ3 ¿¨†bœ¨B×MF#g}u/PÞ÷¯Yd?âŠŸ5go\·û¡™‡iÁ½ÉÌ?Qq/;ûõ»ÞmØEoŠ–µîÙ’÷îämæÀò¨pŒH…ž?0"üüb–¢“×H4ùÿ§G_|àn
óUca´x8‚¢±x¦¹ZOÔËØúöÁœi–0Y8P­M–ù¯-ò_ð3¤†NúøiwŒ†ÇÎ M`¥½Œù'*®üì×©tö›´Ðë©^a\óú"‹‹Jí(4šbˆQ«m°zk(z†ÞB‡àÇðÜz Ó'ˆóµ&ÿÿ3Í]…¾×Ì´Atˆ#,ÌLÑ¯·øÛâµ	Tþeí/¯5Í?wLßˆŸãÂÔuµ¦Y®mfþ‰ŠyVöëÔùÛ£ºuë¾Xö‹6Íâ”’sˆå½æ3ûc^¸+¦Å$á«`À0ò
–Ç¬D¯a*ÿ\ñ¡»	þ3«¬V™#0Ê›ÃœÑÔÕ p Ê¿m»"óƒÚª½I?òè£®?jjÿ6F%ßVUw¢ê Töëk²_¯^=4iÒM›6}ñì4Íz¢é%×©ýE»¢Ç’QXý«:FÜ@ãP`Ì–Lšˆ&¢óûßté.j†î¸tÞÿ¾î¤ðªCÇÂ±Ák5pÔÇÇ?õÍ_G¤ªæ+–¨û™¢§Jf¿v~Í/³ÿá‡¢M›6J×®]_,ûE›e›Ve­'ª-ê÷Lë‰éÁŽ¿õ0j‰Zàýõ·0g‹?º.Œ7äÞ£N]ñºSÔ¯;©SáØ¿–ÞŸj Ïˆ©pÿ	ß/·ËÏ?ïÿ=Oaöó¯õ½þúëhÜ¸±ªù¿ùæhkk£G044üsÙ/hj=‘öø²ÖÕ›ø¾›7c¼Ÿ'>HŒÜ‚Ñdjwü]d_Îõ/:ö—×ÜD­p<!çŽ…¡§Ÿ‹º æ2ÿDåÒ*r­¯Aƒx÷ÝwñÉ'Ÿàë¯¿†®®®Ê¾$s/óÿ§²_´ÉõD6:q%×ùÉkõo¹ÀÎÏ[w£vÈ18„o=ûæŸû;ûËÿ3l¥•Z¼g—~X1¾pÿŸ"Ÿ‘ù'*ƒÖ›ŸëÈì7lØï¼ó>ÿüs|ñÅhß¾=ºuëccãÂì›››ÃÄÄ?èwùsÙ/Úäó­un—¬d¾[ÏêƒyÑ^˜0AÕþÿö0†£ß|3£gáØ_þyÏ Ãâ±¥öÿ)óó2ÿD…´Þø÷uÿþF¦¼Îß¼ys´hÑ;v„¾¾>z÷î¡C‡*£GVãÿ.?¼¼ì4«6MD-]²×òåºþw\º©ü{‡;ãDÒlçyÍØ¿Z\Öþ?å~fæŸH‘­N£–-?øç'­Z}N:)²Æ0`€:÷K¦¦¦"ûÝ^~ö‹dQ=sÌZ'ç™ûÿxWlÿŸª>¦D­^“Ö-¿þ¦m†¼Î/sß·o_Œ3C†Q_ëwýñ…³_©÷3ºõÛÏzÑýªú˜ýUm>kßRÿÇ™r¬oaaªq§Î]î6mÑþ™Ùÿ¯¼/[]‘çŒÊîÿSÕÇ“è¯¤dkÔò‡–½ûÊ×ùå¹¿SgýÛÿ¥ÝV|«æÿù{³iÕPËZ×§‚ûÿ‘û~Tõñ$ú+)«½ß¢ã]ŒÏÿƒþï}Ø¢Êß£æ™ÅÖÝÿG­õ·lÓª2Ÿ·ª?QuðÌöÁWk5hÜ¬ªß_áû”ë‰J<“ °°Ò™YÙÏYÕŸ‡¨:xN«‘ÿojü¹ª©õD6:I…ckí¹ÇOe?cU¢êæ/Óž>“à¶–¥Ž^Eÿ[U_"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""¢êêS6à!             5Ã‹      íT”Ç÷÷7j¢¦™Ä$Æ4Ó5ÍEjì ¢€Š¢¨ ½WE)
¨Ø{ÃÒAi"Ø±7, ˆ`{W”ï;3Ë"àÒ‹ïÿÎ9Ÿ³È>û<ç{çÞ™;÷@¯5tþxObÝ±ÄJÙVb×á»×ûcÿy÷˜ êµ>L:´dÚßÏx$±VN‘˜«ô‘¸KêÕþ½Òx‡ñ®††Æû:::MÆŽû…žžÞ—Ÿñ«©©5b?¯_ü{ol(ú™„ŒZ|î·Rg½ïØïØ¨1ðXb¥äÇøU¢#´õ?ß~ûmc]]ÝV,ÐŽ‹‹óÚ¿ðÉ“'SÏ;wàâÅ‹—.]:——wòÌ™3û?·}ûvßÐÐP[ww÷ž=zôhÆþÄ»µ}MŠ~æ!£V‡e'm¦ý'8ö€–¿+Tš¢±C7p{ÀHgèKU?ªÝ7}yüñÇººº*EEEy=z4ýÚµk7?~\ôìÙ³¢çÏŸØ×à¢øë"ì{E÷îÝ{œ››{e×®]›|}}“Ô’-Pô3'µ6,ÛÿÌæú]ïX«¢ó"3ølÃ¬á0Œ˜æn¸xÎ~ž/±Rñ“˜þýií½ñ‹¡©©ÙtÉ’%c÷ìÙ“tåÊ•[LÃÏ>|öŠ‚‚°9Ì`÷îÝØºu+6oND|B±mÛ68p Ì7 ó	póæMÜ¿_À¾~zöìÙs±±±Kmmm•[´hÑèu®SÑÏœ dÔÊ0jÿ>Óõ<¦ñÂï§hÁ1~%Ó8æîŽÄÂôh,Ø³][àcçžX«p_à2ÃDbÙö‹Úx{îãûøøè2]ïasý“Û·oqý2ÿGŽÁÖ”lŒŽFXX(‚‚è¿~«°v%Ö­d_¯ß
@Xh"##‘°y3ØÜÓ§OƒýManÜ¸'lÜ¸ÑwäÈ‘¼êõ*ú™„ŒZVí¿gúObÚFû¹†pÛºž©A˜¾-ñ+0aó*ÌÛ£³ñ×ÌQÜpà.{“Xª´{uwŒŒŒ:$$$Ä1_ýi~~~›÷‘™™)´»™i8vS$â£‚½{ã×âxò:œÙîœ]ë‘»Ûçw®CöŽ5ÈLY…#›W`×¦åHŠðE\d û¿Qâo¤¦¦áÐ¡C`ï«W¯‚½GÑ±cÇ®-X°ÀAMMí“š^´¢Ÿ9AÈ¨•aùKC¦ÿ)<öoî6&‘óášä;¦ý?™Þ›¹j@/Ø[øÞi!è¹ÜíÕ¤ëÖ*G%–Ê–ûÖÔä-Û·oÿþüùóÍ˜.s/\¸PÄçú¬¬,¤§ïEjJ2R"‘žˆÌÁ¸r(·NlÂ½Ó±x‹‡Yñxtn+_HÇ“«ÇPXp…7Îâ	{}xé0ngïÄÅýÌV¬ÅŽ˜ÕHŽßÀlÀVfSvƒéçÏŸ{Odgg?‰ŽŽÞÄlÐß5¹vE?s‚QkÃ¦ÃO|ßÇÿÿ0ÀzÓ2(-0FÓIýð»Ï(|Ä|ÿ?fèÁ2z1¤o„CÜrüá£‡wíº¯¦H,”;	[RÅhÙ²åG~~~+222q-ò¸žërÏžÝØ‘ƒÃ©¡¸x0
w3ððLb1›ñkþÊÞÎÃ³ûùxþð&ž?ºçï0î¡èÉ>*¡ðÁÜ¿r¹û7b_üjlßÍìKºð¸‘““ƒ³gÏ>OMMÍ´°°è!©æ¾¡¢Ÿ9AÈxQObÝ¡¥ÄBEWÌß–ÊÓ™†OqßžÇùÝ—ÚÍwb6@ÓßjË¬ñýÔ!øb²:†ø¹Šø`ÆöP\3M]úûÊYK¥Icåo*zÓÁƒ¾‰é¯ˆiOÌù|Moï.æ£§mÀå£1¸6YÌï²Ùkvc+ž\9Êt…÷.ãÙ½«Rý?¸ÎlÀfn1¸¸ËlÀ}=-¶Ïž èy¡àÉË¸p8û°o÷vñž§NBñ5íÝ»÷ê¤I“†‰ûBú'Þ^yØ2Z)…2Ý0Ý>1})ø¾ßž:°n¯w6 ÿš	P^0j>Zlî	{ðµA›˜%h9MW¶.pŸÙ’,žøKžö#""Oœ8ñœÏ¿\ûÇãÀÎDdï‹ÆÝ3)x˜³rR)R»O¯gŠ9ŸëÿÙ‹xv÷…xVÆÜ.e¾°Ïž2ðL¼Þ»v'·‡`ÿŽÍ`×!®_ËÉ“'‹vïÞ}mòäÉÃ%UøŠ~æ!ã•‡•ÒL>g¿gÿ¯˜ÓôÒA»¹P]d†_¦ÃGzBékŸcâïhO$NÃìnè0SßLêõÕÎ˜š€Å{c0l½‡Ø+¬gÓ™Ç·Ä{X+ýÎßŽÅûM‚‚‚âÙ¼ûœïÑñy÷ÔÉÞ+Çñèü<ÎÝÁ^·3íKmÀã¼ÝxÊâúÂ[ç9Lÿ¹x&lÀ¥26ày…6€ûKl ˜À
™¯w8Ò¢púô)¾ ö	Ž?^”–––?~üøž¤âmà•†µj[¦ÍõlTÑŠÅôý™?ÏóþnbŽçöà/íísÖÅycÇ¦i8±m&¦oòBð–é·Ö
-§B‡Ù£16ÌÓ7Á9Á—ùÆ¨oÛ™ùÊO™ØýžaG­¥Ë—ù³¸»ˆiLè-+óŽïIÀL6×3?ÎÝÅØùÂäíaó~–X×+¼™Íxa^ö®1?  PÚÚ€"ÆµÓ;q$-g³2qþ|®È8|øpQllìY}}ý¶¤¢®SãaÚåS¦ËÜWÿŒÅíª‹ÌÑk¥ú­r†Æ\;	Î'ô’Ú¦}Çˆ)HÝèo7',ô™ˆ›§cKê˜†z`m¬+þ3ŸNìƒþ«œDÞÐÌaÊ|Ï\ú€ÅEjõnnÛ¾íÓ–Xë;—}'ÒqóÓù…½bÿ1Óûã¼bÀ^ŸæŸúz#Kêpp«"p¥ŠX ¬PbXLPp6G·E2ýç //O¬CîÛ·¯hÝºu›»té"7ÏIÑÏœ dÔhˆ}>%Wï7bñý>£„þ]B'!uû$¤ÍÇøÀÉøo…Ðÿ¿Ë¬0žùýÉ[¦Ák²=œìí0ÁÁî.ŽØ°Öû·ú 2y:\"§"dóT|9¹~óÒ‚^È4ÌÝ‰iiÁèícŠÐM‘\S"Ö¾—‹Œ})¸y–éüÒ~<¾¸WŠ°»…öŸ\9Œ§§™"öç6@žðìÎË±@Y?àŠ*YÚ€Bæì@³G<oÛ€ýû÷óÃÂ©S§º’þ‰ºLÍôßAUb¥r†ÏýÍÝ5ÑvŽ!:Î7Æ±Ý‹u4²v!j‹7þ[n‡&zCm‰V1¿Í"'XššÀÖÊŽ¶6Â¸89`ÑLlŽôÂnÌd1}ˆÆûŽÇg{³¿a‹	±+±&,Päër¿ÿêÕ+8}dò3·3íÄ“KŠmÀ¾6€ùO®±¹?ÿÔK6àiµbr~ÀãjÄì5ïP<Îß+rùÚÄž={wkàÀíHÿD]¥FÃŠûýÊÏøšßoÓGâÏYcÐfŽÎî^‚íÉñ8vp'’½Äþ?_ÿ7œˆ¨ É°17€±Á8˜ÁÚÜö6Vp.öxL¾Ú©É3Èb›PW¸;â_-ôt3@jZš˜û/_¾Œœ3§{</Æ“Ë‡/Û€'WŽH}ÁÉjÙ yk‚Ïª³7XÊxúð62w†ábî9qÖ€çïØ±‹/,^@ÑÏœ dTkðü\eK¾Þ_Ï¦3¾t„½‡ãfZ±À%Ð‰[¦#9y´–™¢©K?ü4U›c§ÂÕ~,F
}½0£cÃq°01†¥9l­…àøLqF2óbÙßÙ»ÃZKí°*p5¶3q¿??ÿ2¥áÁEæÛ_9*t.Ï<¹vOò3JÙ€Jü€—öª»7(ß¸{ùNî‰çx>âÎ;W__¿éŸ¨‹ToÞWjÏæýãÜïß©'¾tŒo§j£…×0´˜:Tøë|¿%Óü‡ìç_»À¬HøÎ±ÀA 5XºÃt0j„.ÆŽ£qc™/0Vf¦Ì°„“mÉº@ðJ7lÛÌâÿUHIIsÿõë×‘}ú(
Îîú~zõ˜\ ^¹þ¯•Ö~@öåø…¥óž ÷@ò²OâöíÛ"G(55µháÂ…Á’Rg‡ýÌ	BF•Ã¨}¦ûElîZß¶+šLì‡¦®˜ÐDó)C„Þy¬ÿ“÷P‘Ðq14Ö8cU‚7býœ` 7Ôû3;0Cµµ0’ùcF¾€‰¡t]ÀÒ6R_`’³¦¹9 8`×Žˆ¥¯°˜úèv<ºÊtÍµ}Už8$Öý¤ú—Ú€²v@fN—ìÈ]|•¡ÂÇ%~À£çqjw$nÝº%ÖÓXü•?hÐ ’3Š~æ!£ê¹_ÅHÔðasC‡îøÐ¹7³}ñÙ$u|À¾nÈâü^¾"¿OÆõn"×')ÍI	ž˜ía]í¨¡Î|A®£=ÝáÌèaü¸10oKæØYq_À†ù6ˆñ3?w››}
Ùû™_Rªe®ë2~@ñzÀÕ£âû¥m@ý¿I? T,³'Wò²EÝ½{÷òúÏ§L™âDú'ê•k¿ý÷Kå\iN¯*Þ³WC#‡L÷=½ÐÀ®+þ˜9ªLžG'À«¦I÷÷™/“4A¾ö°1M©/ £5Dþº€…9¼¦NARR’ØK¿{çÎOgsÿIéÜ-Ó±<?€}-âƒr6 ìz@i? â½Ayû•ç	¾°wòáìá­¢vÈ™3gœœ\´lÙ²=ìŽ6$ýu‰JüþwEM’œ~Už—‹¶ÿŠ9ŸkŸçùõ^åø’þùü¯è.ôïŸ(µ;¶ù`gÂT,ò6Fÿ¾}0ˆùÚ|]`¨Fq_`´žXàøû­õyøZþÕË¸xz¯4—ëµÄÈñŠõ_¹8)7¨:G¨úk‚Oï\FÖÎÜ¾uSìðuŒ6ÜQUUý™ôOÔ%ä¾ÞoÙi‹ùóeÚ‡i¿ëÎàõ=;/6gzw…óO6ÏÏ€e˜ÇK¶€ã1~Ì°˜‚Û}8ºÌÐ€æ@è,ÖGGkÄÄlõ¸î°¹?7û4nåcsô¦ÿ,éœÍu[ Ç¸z¼Œþ«å\Ý¡—×ž3[»'W/d€×"‰‹‹+277×"ýu	¹Ã²ÓLû{äjß¦³ðZùŒÄ ëpGXÒr¸Em‡_âZxnôÄˆÀ²úÉ|ý w,ŒõÆüX/,b¯{=±rŽyÉºÀÍ0=f;‹š;<‡îÁÃÈ>yó‹µYÞ”Ž„ ]|ríx5ü€RR.x¥¡ò~À³G¸~r3ÎŸØ^çðÏäéé9“ÝÝwýÌ	B†ü¸_Ùiü)×ùËÚWÅNÿA}íD¡íEqÞ0ÝÆsñë’ë˜‹à-3EÞoù˜À€}o³áÉÓ±€ÙðDol	š[ÓaÌôƒ§Ë8,ñ)´ÂÏÓÝ¿çNìÃ“Åz”gJû×dúÏ¨¹ð:9B_öîß3ûãðèÑ#±À?Óüùó7²»ûž¢Ÿ9AÈ;¬•œÅùÛR±¿Ìà¯ül^Û9ã0hí±¾7?vÚ¬ÈÇ»³Ÿ¡áœçÐÈÆÆ­AðŽö†›÷ËÇváSÅyà„”Ìo˜ŠiÓ²Â–ùý˜»j‘Ð
¯¯Åãç¼ÓðôfŽT‡rmÀ©bp¢ŒxZ#PUŽÐùêí>~±/ðèÒAdîó?_ÇàŸiÅŠùå—ýÌ	B†|ý·ùDb£b.Ëù‘QÚà6 ¹û@tYl†iÑ^X·y5ŒBàËEOðÕ ·ÿM,NHâ8°¸¿¼à¾ÀÄÈ©bM <iVÄ{ÁqýD,Yç+êqçççãzþU\=w„é/WªÁ
m@éXàDµm@¥9B×«¿7XþÌ·<G9k{ îÝ»+Ö ùgò÷÷?ß±cÇ¯ýÌ	BF…ƒ÷ò‘®Äòºžå}á0xž›Ùc0.h2ÇÍÆú-›ÐÇ¿ ­WÝ×?…}ôYÄ§®eq'´å¬š‡zÀ)‚Å
~“¡±ØkƒÖcË–-"æêå‹(ÈÍ(®Ý“[¬™È–œ*öäÛ ¹ëæ•[¬Q®ð<¾t@Ô¾sû¦ø,ü3]éÙ³ç÷Š~æ!£Ê!µÚ+¥½Ì<+o¤qª¨ó©²ÈŽáˆÙº3b÷A#äº¡[XVnMAØÖeb¯ ´àùBƒÖMÆ€µ.è¿ÀëC‚ø~¹Xû¿r)×/œB!_ƒ/m¸Ëù…/­Ô’P£¡~ ¯?’½ÃŸÅ0×E.0Ïg`úÏïÕ«×Š~æ!£ÚCê¬.¿. ‹ø¿ßµû­fŒ„®¿3–ÆyÃ/)–›ò ömÂŸaXl–¤ld~‚7Æ»—è Ó¿Ó¿ú|[„‹½ÿ»wï2ý_`ú?ÍôQº'×œªÔÈóäÛ€Ês„äù<Gè³³·"{çzÜaúçó?×ppðÕ>}úü ègN2j4”?“X*•X+Ÿ¨h]€ç}>¹?º.6ƒK¤'6¦,Ãì-éh4	¾Þp[v"*elÂ§@Óï…þûÏ1ÿsý_»r	ùy|þ¿$Õ³eb9ë…¯ÈÍÊ¬yŽûúAV<ÎîÄÝÛ·D3÷ÿ/¨ªª~­ègN2^iØ*7fñÀræ\’öõ{9&àßãg‚ÔW9`a¬‚S¡›ÆaO!	-B˜¤íZŽë]™ï?	k&¢óÿKÇÿüÜÏ•œ(äÚº+ÏÔþšà+å•‹¸Í¸:Y;ƒqÿÞ]Q„¯ÿ­Y³ætÇŽ›*ú™„ŒW¼çŸ¥ê æÄ”­ýý"&àëŸºôEûù†°÷€ÒBLJJE‹È;°LLÇÜX1÷óØÓßÅöX²VºþÏ5sçÎmä9ÆôEª-¹6 
? 
P¥ð
9B¼é½S1ÈÜ)öÿxß0¾ÿ·téÒÍ›7_ÑÏœ d¼æ¨'±ìô­ÄRiAù=‚Òë¼^Ð^ÚÐYçŒ™›¼‘°Ó¡[Ã È½Ä÷Ÿ±q
–G{`ÖÊ…B+¼ŽÞƒp.ó(žÞ¹"­Ñùª~€œ5Á7•#Txãœè5tûÄ&œ9¸Eäÿð\&þ™æÍ›ÀîYE?s‚Q+ƒŸ°î4”Ù€Û,.€¼½BÑÄ±;ÚÎ½õ“aâ!bîûÛ†òâ5xKW/*ÉÿãÚÉÎÌÀÃ[—¤±µð¬
? 2P£X  *p^ä)ð:Ä\ÿùG£{ú€˜ÿy_qþ™&L˜àÌo—¢Ÿ9AÈx!¯ÿW×y½b½Ë³¼g ¯Âûñúà<þJœõuY¨?»Z³ã…V¸f¸vòr²qûjŽt]M®¸øZëåã€×ÉzríÝ"úæî‹ÀµK¹b“ŸeŠ‰‰y6tèÐIÿD]â•GEý¿¬”õmJÛ€²{ü•÷ü{–>†ûOÂÚ„X·Ÿ/x„Ï'g 6>Ah†ï›ä_Ã¥œSRýó>øòs„äù•ïÈõªÈâ6€OôËNÂý¬Dd¥od×SÔ-åûë×¯¿ÔªU«¦¤¢.ñÊ£ý¿þœ©'tþN¹õÁÒþ@3·PaÿÇ>d2â¶.ÎÊX´.\h†çÍó}@<ák *·Ïªð^ÊÊ¯¡,Q—èÑùm%=GodÄàì±¸wï¾èÈ÷þçÏŸ.)îªègN2^iT³ÿ—¦ßdt[nï§AU¹{Ò^¡Ýñë4]ŒZëˆÅ›¦cŽïJl)®ÿÃÏÏçÏÆõËÙ"Ï^êÇröÊØ€Êr…_;GHzfˆ×ã½ÅÜ.EäýœÛ‰«Ì÷çþ¯œðÔÎÎNWvûýÌ	BFÇ+ôÿ2vÝ#|b­Væq»Ñm±,: >!Û·oµoðú¿™L÷òKÙ€êÆUå
×4GHúûO®—Ö/Õsô!³·3qú@²È_8þ¼¨a”©¦¦öéŸ¨kÔh¼fÿ/;s´µÑDCë.úõm» ÅdMÌ[»Lh‡×þçóè¹³Y¸q%Gœ³yÉ¨(¸U}šæ±ùþñåƒxœ—þRÏÑ‡9i8·?
ÎŸ9|3%%¥hÚ´iÞ’R=ÁýÌ	BFÍôÿúý¿ìl¬ÐÇn¾±é…zVòëðïu™¨‡¤ädÑG‹Ÿædb¾öíkÒûjØ€ªö
_ŠÊÖõ¯–ª1ÎûŒ”î5Æ{ŽÊl ‹®Ÿdsÿ¡4æ¯Ü@NNŽ¨_~ISSóçÒ·QÑÏœ dÔhÔRÿ/[kØ™ ½íà2{²}nYtÁ4ßØÁâçÌÌLœÏ9‡çN£ðþ6àÁëÙ€Šk‰1íWÒg¨|ÏÑ{Ùi8½7/œÇÕ«WÅÜŸ¶-#\Í·HŠ×ýHÿD]£ZãöÿÒ²‹omz£œœß­ 5-éééb/àÓUæ©\¿œ#ÎØ‰zÜÕ°UæÈ«%&«)Z‘xÑwøQînäˆÅÙÓÇDÞò©S§DÏÒùë–5¯<³üíTô3'Õ›÷ßlÿ/c;3t¶ÑAcëÎe×,Uá:Ç[Ä ¼†&ßKçuÁN?‚ÛùðüáÍ×®WàäWä*ã<dú¿x,'íÆ%f£Î;'z–%$'âO›™k¥ßIÿD]¥Êñ?êÿeÃì€–Ý4³ù¯L<à4×SäqMñy•û9,8yü0î\¿(­·QÔbŽP9?@N,ðˆéÿrF2ŽïOg|8ÜNñzß:S-Ö7í8VøN¤¢ŽRõÜÿ¿íÿecg‰¶Ãñ‰šÈr[3WäpM:tHÔÒå:ËÊÊÄ‰cqëZ‹nÛ‚äUU? ” §ßàãKq)c+Ží•ö(äë}8|ø0&/Ÿ‰÷UWŠÚIr†¢Ÿ9AÈ¨\ûŠéÿålg_ü2e FÌ¶ç y=¾¦Æm·ÙÙÙÂ8rh?ò/f£PÔß+^¨"G¨PnŽPeu„Êú.@Î‘dJOk“üZNž<‰#G`iè:|`Úù¢Ä®ÃwÝVE?s‚QáPPÿ/3£ñX³Àëã=Ñk¹5þõ6@Öùl±®ÆÏñù•kÛ ®=>ç<°9g2ððö•ùUøUÅ/×Ì9?·ÎíÅ©}‰8¸w§Èíå× ®ãD¢Ãî|kÑ{·ÄBiXefUÑÏœ dÈ
ìÿå1Á[â<1hÍôñuÄ¸HJÙ*|ìâ\:¡y®9n¸=Š}{Óqä`:ò/œy‚Ò5WÉz9W˜ç÷ß¿t¹Ç·aÿŽDö^{p”½'?£Ì¯‹ç(mÞ’xÚÄÄD¹r‡ŠôOÔ-äöÿ
Zí—pWôõu†á/?yBœ¡MKKCdd$.\ˆY³fáàÁƒb­ûÞÜðØ =}³/Ûpô@:®äfâÑ­Ë(¬É¾@¹\á'™¸{ñÎgìÀþí	Ø‘¶UìE:tXhžÇü§™šäû°¥Þª£}Ò?Q—;ÔÿË{²!üb¦B›ým£µÓpðØ<~üXÌõpwwƒ+ÃÖÎÎÎÎHÞšŒó¹çE­ þ;Üðó6ÜOHÝš„½»¶áÌ‰CÈ¿˜…û7.àÉíKxÊôÏë	òš¢…¥m Óÿ“çð¨àî^>‰ËYû±/;Sâ±5i³ø›|òøñã"¯ŸïCfœ:ã…®hlÞ¥Pb­4ôO¼mÈ
êÿ•˜èÃÀI0Zã-´ÿäÉ¡ëÀÀ@Lœ0æ¦Æ°05a¯&Ð³0Dos]ø¬]Ìl@.®\¹"öy<Àm@RR²X/ˆ‹‹EB\R“°oW
2íÆÙû‘›yÎÁ…¬ÃÈ=u YÇvãhz
v§Æ#9!q1#þïßÍ÷¸îynÏCØ¾gÆ.uÃ'N½ j Z)›þ‰·ùúWLÿ/—w­›†ã'2Jæ}¦}'ŽÕëƒæ<‡ØÂöÖVckŒöÖƒÑÝUaÉ1¸xùnÜ¸!Ö
ùÚ ÏâµD£££ÐÐP^ƒAX€õþþu ûÿÿ6 66VäðØ‚Û~ž§àúudœ<†¥!‹1x‘5ZMY\óDéŒÄº£
éŸxÛ¨p( ÿ—™ßŒ2>?Ÿ÷Ý&;COwFê‡¾ÞHŒ;&<_€ù vV°²µ€¦íh4³ìŽþÞ&ˆÜ¶—®^k¼vï½Ç×	ø¾_Cˆë!!!b-‘k><<›6mu:xžoiýá;¢þÀufSö?·õ‹Ðw¶9Tæ›²Ï<ï;ö€¨}ÄÏDò³‘¤â-£Êñ?êÿe²núK>ÿÔ)“`8zhÉ^!Ï’æó¼¡9Ä<oÈÒÞÊ¶ÚøÒ¢;”]GÂ+x)ž>†»÷î	{òôéSÿškšÛ~®X¦q^k”ÿ¼°°P¼>xøgrÏaUBúX¢íÔÑø}Æhü={þž5Vä<òóâLï‹Rƒ¡ègN2ª=Þ`ÿ/S6ï—÷ù¦¸ bƒ;ÂWÚÁxŒ¨÷Ãà0Œç&|ƒ±ÒbSãâbhÛ•ž-¶PÆûæ]ð×mŒ[âŠeñÁØÊbÿŒœ,\*¸Šë·oâÆ[(¸}7pùçyß±t,ˆXŠÎúøÔ²ê[ªâ×øÑëÅy'~ö™û>ì^\—XtjSí“þ‰ºDF-öÿ
Œ™ë0X¬Ÿ…Cå|~;÷‰0]íŒðD/øDº"™á9AšúaÐ yC#u1nô(Œ7(^0—®Ø£‹ƒ6>°ëZrõ˜ŽYÿ‹O­{à[‡þøÙy Z¹háO×aè=}4B"Üp(y>fÚ ùÄÞÂ–qóóNÍÜ4ñÍ~Þi(Zx5JŠãþ—Îö‘þ‰·‰W¯Ùÿëó¥§±1ýV¬š†ÃÇ–ñùÜ] ±Äcý'`üú	°vA|²76$zbÓz'˜h3?@]ø:ZƒE1Ï2Ð-rˆ¹p´µDÄ:Wûš ‘ƒZ¥õGù+Ïglìô;þ'Î8¼gßMØ³úÌ~|ÌÏ:LÖÀnƒÐŒÍû¼‡øÌ–Ê1¢2éŸx‹yåñŠý¿CpàL.]º$ÖÞd½>¸ÏoçÁµïˆÞ+Ðs…=z,·Ã¤°IÐ_çÈü€ÉXã†¨“0oêx×À|uhijb˜Ž–È!æg‹ùy"Ÿ)ÖX1	ªsÇˆùúÓ‰ýÐÄ±ÛK×X¶îXW¡{ÿZf>tî%lÀ§â¼S/ñ™˜þó˜ß¯.)UÓ‹ôO¼¼æõÿšË4q¯D_F,&Powz¶E½^mñžzG|5²:™Ã‘“ÇÄ>=_ƒwttøøø`²ç$,a6bèÚ	Bÿÿqý/³CÏe¶ÐXio¦g-_'LÁfFôzgèë‚Fÿ~<h€8[<bøPè3_ :Ì«-D¢Ÿ¦éBmž>óë­ñ£]_”·U¥}îï×·é*^9<hÄü÷‹Ï;	¿_ºæ7G¢ß¢Ñ«Þ4E?s‚Q+ƒŸ°Rê"ö
õ;=’|ßõß{7ÆÇMšàËfÍð]‹ïñÓ¯¿ÁÔv""6ÀÉÉ	ööö¼/Ž˜ÿ½ç¹blÐa$®Æ¤pwô÷u@w¦ÿnK­Ñu‰º,¶Ä€ÖXíŠ+,‘¸Õ±ñîX<Ã£‡Â@õþª¥	ß9ÖðuÚÿeÚ´9
‹Ã±x–lì¬ÐÓN_XÿWI<PÖGà¾À»öj¨Wó+_—˜)óz~¯4÷“þ‰ºD­ŽÖí:K>ýìJýúõÑ˜i¿	×þ—_âûï¿GË–-Ñ¦MüÓ¾zjhÃŽiŸïÅó|~Ž×jŽêÏ|Š¶+®Âsc–ÅxaÌ:§ýwfúçµ†;/2ƒM€¦†9cÌlÛê…þN°3G‹‘ˆŠš„³ÇàW¦ÿŸ™þÍ×Z l¬MÅÙb;ž7dgŒV6x¯|½¡RõÈåyxÇJ¥xþWÙÄüžAb„ôO¼ÅÔÚhÚ¾•ä½3íU¤}%%%¨©©¡g¯Þ°vtE~A87;s¾æ†¬ý¿$³€&óahÀ	DlYŠ‰!.è²Ä’éß*ÍÐi	þ[b†.‹L07ÒSBœ09Ø§b{¬;Æ®2gs¿žÐ»Y£í†ÉF"oˆŸ-¶43ù¶æèm7Zÿ+·OYyíóž†¿y}xTf.2[°T¢¯Vã8@ÑÏœ dÔšö6Ù/Oû¿ýö[í÷éÓƒ‚¶ÎPLŸ»îvè4}\Iÿ/Ý€£Ì<`v ÍÞÃôè­XºiôÖØ¡+›ÿ¹þ;Ì7Bûyã¡ºÀ]ŒGp¼tV˜¡ß#´ž©/­Mì£‡Å‘Îðv1”îŽÐÅ8ýÑ%5¬ŠsˆM™øÓf Þ·fq?ï](/&`ßoî: ®[Ö`ÖÎpöÞøÐIÄ|- ƒÅ>Z"gšôO¼e¼öhÖú¯ªæ}eeåíkòõúaÃ0jÔ(h†wG)¿Ôÿkî¦h»ü*ê1_@ô^
¾qþð
ŸŒ™ÿÏõÿÓ»¹†Pb¯ÃW23Ýÿ>s4ZÎ%æÃÕæˆrÆà¢9Ã´†×	C^{ÐÈ°¤ö µ%ÔíôÐÜº×KõÈ¥(‹<çîË¬ášä‡EéÑîƒ=µe?Ïgv`¥¼ZŸ¤¢.óZ£>¿lÞ—iÜ¸qÐÑ‰÷Fwy©ÿ—u‚WC?è˜8WÜxþsüã{ÞÑ©ˆs‡æ
¡Þ¤õlü=kL)ýK}ÿ±«Ì°=ÞæºPïÇìÎ e6@—çû¢'ó¬-ÌEOC[üe;õ­ÊêŸ_ßh`Û_¹€EôB,Ûï´ t˜k Û(5¸/Àk'‘þ‰·€×Ò~}þ¡C‡–hßÐÐ:ÃuÑP¯ËKý¿x¿Ð>Ë,™ßïŽe±!øwÍ5|·´ß-+‚~HB“B1=ÂÝ‹|ü¿˜þgúoå3º8ö¡Ë;Ñ.ZfÓ±Ú¢ÎˆØ+dv`$ß+Ô{Q‡Ø¼¸ö ½­tlÇáÛÞx×FØwû€ïÚ©	ýóÚGïÚu…òcLÜ¼ËöÅÁ6f)Z2ÿåÕ"i­Tå‰)ó*°Š~æ!ã•Ækøü2í;šZCÑP·ìš»ÌðóD­g1mú;À/~!\£Ò¡´æ~_	ôò¿‹¹q{±*fFúZ íì±Rý3ßÿW¦ÿë³ù_sÉx˜¯5ÇÆÍnr„×Ä1ÐÑT—æ)Î!1\šC,[07…ƒVù:Ceº&Ù«‰œ ¡¦ûz6]J®‘û£‚§aþž(ÌÜ†îK­¥ëÒ=‚cKsQ?ôOÔQj<^Óç—iäÈ‘P0¨¨¡®êKëï²³Å¼ÏXs·A¸Â
³#§ *9ZAh·èâ÷‘gžäŸð	hËl…Ì÷çû~üÒÏlNžáˆþ‹ÆŠ×¤xf–Ú`´®¦Èö$"=O$ëI0Þs<m9ŸMè]’Ì} î›”Ö¿è‡âØ}V:`îîH,Jß«èE¥×n2IÿD]¥ÆÚMŸ_¦}¨õè}ÿ=¦‘lÎ|TQNÏ¹çëƒËÌ±!qæÅmƒVð-t(BÏ çðI8Œ°ÄùÐó5Gë™£„þòÖÅ^ÃðýT¨Î…%‘Nh?K+7:#u‹¼]ÆˆÚƒ<‡˜Ÿ'VÜ“ÀÖÂ áAÑe¦¶¨u.Ë	æs}›²±
§³	=—ÛÁgGïÁòýñ˜±-DØ‹â5wÒ?QW©ö¨%Ÿ_¦ý>}û>ÿ¡uç%É/%ÖJ?H,•§J¬”nTt¶˜ëìKWt™?aœè«9èT„.ËM¹ðMŒÂìˆÉP™«™þ[xÃwLÿ-<uðûôaÌƒé¡¶è»`4Žm›¿åÖ°2Š"‡˜ùCcÙ\k8®5=Í•Ìý/|ÿwÊä©à»)ƒa·3v„cî®(ÌÚ®K,dû†{¨ÿQ—©ö¼_K>¿Tûý
iÓÕOòY§KÞƒçÒñœ:+åÃ•åè¿ïÔ¿MŽ¡+Íá?k’¶A=ì:‡¡Ä¸ÄŸ@äf/_nŒ½¤úÿfª¶èUÖršþbvÀÞÏîV°^c‚m1n˜;Åƒö‡á(m„DMÀOeÎò¹¼A±ï_^ÿÚþîpe1ˆgj¦oÃ˜0|äÜ“kÿš¨¡Ný¿ˆ:Lµ´ßð“Zóùù¼/´ß¤‚|³?>”X*Ù±˜àB…g‹mTEý¿|FÁÖßQIasÝÂãfÔ7Þ†jfD¸Ce¶³Rý7óÐÄnšh7cZyiaFˆF-‡å2[£˜ïà£-Îû4v|áûËô/ë}PÚ÷ÿÚ}þ`×¡Ìó—ÛŠ5Áâõ¿yÔÿ‹¨ëT:Š}þ5lØ°V|þŸþî²ªÌ¼_Ñ°ê¨!öÑÊ­”ÎÑoÈ´ùÓ_ÿ%†Xí‰…‰[ }-Ã€vÃtó),‹_
£U&øÅKGô,åúÿÜu ¾óµ9#ÐÒs0ü79ÃÉÏ&¾†âœŸ´@ßŸï÷Õ·-ûóÚï–ª/R+åóÔÿ‹x¨p4çó¾ÔçÿðÃñÙgŸ¡iÓ¦µëóW>¤g‹­•L%VJåíÈò†>bšmã£‹uÌØºñ9ø1ø2¼7^ƒÏ–MXå"l ¯ãÁõÏkz|2I]ä_¢Ï'õE“‰}Šçþò¾Wñ>²÷o:©¿˜ï›±¿S\(i~û:Íû	Ôÿ‹x[;Jùü\ûœï¾û?þø£ Ö}þª†´ö`8óîT´.PŸé³)Óóß3t±"z2æ%ÅàßMWPŸÅï0þÉÃú¤•¿Ú¿z‘êß¥¿èeü1Óý‡,žàs¿Ì÷/»ï×Yät™««WX†{A/ØíæŒ“é?Tb×þóêÞ_E?s‚ñÒà>ÃO„Ïß¨Q#|òÉ'hÑ¢¾þúk´nÝÿüóÚµk‡nÝºÕ¾Ï_Ù0jÿ9Ó™³'äÇ*¢6÷ËòÔÆ8_øÆÏƒ^Bš„?†„Ù€Ÿ#oabb2D¹Ceæp¹úoìôBÿ²u^?¬ÃL]D%ÏÂùc°ïj¸Dz¡×JÙ>–Ä\ùïêÞcE?s‚Qf4•úü²xÿ‹/¾pý·mÛ­Zµs~÷îÝoÀç¯|ðµtk%%á”ëIP¾ñ§.ýÐiæHÌˆpÅ¢”X|y‡Ù à#fzÆæ`ÍæE0[e„æ®êøˆiÿ…þÿûþ2ýËj}ŽZe…c»üpìÐ>äžÚÎl‹74ý&³ßuÅžòþ_Õ½ÏŠ~æ!£¬ö¥¹=|ðˆ÷?ÿüs¡ù_~ùEèŸk¾S§NbÎç8ðÍùü•ÚÞ“@E›Ù€Óõ&‘Ù/Ý ïB}øÇz`|Â~4‹¸/â/Á/a&Z{ú—úþ\ÿ¥}5‘óÃÿÖàåæHMš‹][‚p„ÙéÌ‡àý‰?a¾ƒ¬ÿWµî3éŸ¨CˆQìósíôÑGà|óÍ7øùçŸñÓO?AUUíÛ·>ÿ!CÐ«W/Œ=Z0bÄŒ?þÍøüUså˜6UÖ“€×íâÚþÍk<‚1}s8ºÅäÂesô—õIKôï$'ö/ÖÿÏ^:0ò³ƒo´;<Â\ ¹Êþ¥þ_UÞgÒ?QÇ4m÷5Óþ¡Þûû<ÞçküÍ›7ñ>×=÷ÕÕÕÑ£G1ç3ZZZ055óþðáÃ¡§§÷f|þª¯»ÁÏÜZ)]¬h@ìÕÛñ³´h–ÅÎÂ²“ðû÷Çúàç)0+Ô‘ñ.0Y9:Éöþº–èÿ[-´kˆ.MD"yý¿ª¼×¤¢Ž!ùôW#YnßÛ/ïó}>ïsÝó¹ŸÏï<æç>¿™™™Ð=åÚçv¡wïÞoÎç¯`”|Ë¶_0?`†¨Í]I}_žÓËëyï1°díÏrµ	ÎŒBÎ™“8˜¾½f•æüóó¾6ÒÿÃÏÿ1S¿Âþ_Õº×¤¢Ž!iúg·†ï|‡çö4kÖLÄû¿þú«˜û¹îù>×üàÁƒÅ+Ÿó¹Ïo`` ´Ï×ø¿û««ÿo|þ
ô/>¯Ém¥¢!­Ã¡\XÚ”öøš÷õùÜÏõ?ÁÏÓ°{{
îYyÃEì/ê~°ß­ªÿWµï5éŸ¨c°Q¯Á—¿›4ý²ù-YnŠŠŠðûùÜÏuÏæõ2ñ¾µµ5tuuÅ¼ÏéÝ»óù»üï|þ*tTœ/0‹q»âú¾ª¢®7û;N×Bt¼2w/Á¼P;4wéSíþ_¯p¿þÌ	B†t¨5hüuk“~þín›6­EN¯,Þçs>÷¹às?_ëãÚ722s¯^½ŸÿÖNíúüò®¹ZŸÍJ©5c'³ÞTÿ¯W¹ßŠ~æ!£Ô¨×¤E‡±mÛwºÛ­›úöí+â}¾ÞÏ_-,,„îMLLDü?ˆÅûêêÏnóïñùkíóIûMbqÁ™7ÑÿëUî·¢Ÿ9AÈ(7êÕ²³q×î½nñyŸ¯ïŸÇû|þçö€Û¦ýZóùßøgäë"oH%­6û)úÙÄë"gÔÿ®M7cƒïñyžëžÇû<îçðïñuþŸ¸ökèó+ü³ò³ÅÖJV¢6ß«÷ÿÊàµ
ýY¢6¨`Ôû®M¯1:ÃGÞ_œ×Çã}¾Ð«W/®ýÕÅÚ¯'‘öÁ(ú³Tëóª©5Ø(ÿSœC|¯âõÁ—{ ±ß/à¹ŠþQ[T2êÿÚ¾±ö°·d¹=ýú«?ûéoåÉ»M~c?«ç@‰Ië/‹Ï]©Nÿ/±Ÿh©¼Dâ¨ú‘¢¯ j‹*FýÚõ2þ¯¯Æÿõ.üö·v»$õdßWÑ×]kŸ_¬*¯—Îí,¶—ßÿ‹Çü»$fí~QôõDmRQ¿ñ7”~ñkoIý÷äžqÛa6àc¦o}‰•ÊÞ
ú=&¿Ÿø¿ÂÿÉ¡&i 1ïøÓúú²g
Åü^Q-¿êE?O‚¨	ÿ§¯1`©Ü—Í÷iL÷lÞWÞ/ìÂkE?O‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ‚ ¢rþ;M=š             I'‹      íX”WöÆI6ÝlL311ÅMÙ$nšÑµÄ£K,Q‰%bÃ †"àª¬J€ üEcÙØ… „P"E±PDŠ{Åöþï¹3ß0Ì 8“ÝsŸç'8ßð½ç¾÷Ü{Ï`hæôéÇŽíÎ[8¶/¶pjß¯aþnÔjúÛ2ŒÂ}mŽí…î¡Á±]¸…ÓgOßßQ¯í!Ác-Z´hÚ»wïw­­­?=zt{777Kggç/ÿõ¯õ°±±ùL|½ÕgŸ}Öœž'žÿ°úçLÒL}¿1æÅ}kNíœ+i¿"œ·pj;òþ½{j‘†…ž;Ì™3Ç&$$dQFFÆÖ}ûöí-))9R&Ú¥K—®^¾|ùâÕ«WË¯ˆ&>¿|úôé³G=’———•šš·fÍ?//¯qß~ûmËgŸ}ö)UL¸/ÍÔ÷c^Ü—æÔ¶¹Jç*Í·_`‡'&~®Èˆç™_{¸S§N/¹ººX»víÂlÑNž<yîúõëwoÞ¼‰;wîHîÞ½«šöçÄíÛ·åónÝº%‹Ðp]ÄŒs™™™;ýýýýìíí{¶jÕê%ñÿ=Øcêû1/îKÓòýúYcÑŽ(ÌH
Æ;3‡èñÂ'˜A{ñÅ	/ßyÕªU?ïÚµ+_ôáBò×qãÆIyy¹„¾vñâEœ9s'Nœ@qq1
QTT„ýû÷Côû:Ç¹sçäó”ŸW~Çµk× ¼JKK/‰X9wîÜéÝ»wÿH¼„ÇâºL}¿1æEƒ7òöj}?îö9|„îç§Gà—ÌX¼#öáóÌÊ4iÒäÉ1cÆô>/4{Gxxê¯%.\:/((€ðòØƒððp¯[‡_ý«WÃß? +W®Åjñùo¿ý†õë×cÃ†Ø¼y3vìØ!cƒÐ¼Œ	b¼ ù(~ÿíœœœÃK–,ùOÿþýÛYÔóØÀÔ÷c^4h£Üž–ïäßäõðKÅÜôp,Èˆ”^`^Z8ZÎU57àÔþÇ†}•ÚCß}÷]ÇÀÀÀ0¡ûKçÏŸAzÃzÙïÞ½[¶lAdd$~ÿýw©éàß‚ø+‚Öøã·_W hõrù/FPÀñx‚èkô½Àµ2„„„ÈŸˆÀÆ‘œœŒÜÜ\éÎž=«ü„ˆ¥,˜óùçŸ¿S_iêû1/´‘~ÕZ~Ýk <ÖÂ;13“ÖaVJæ¤…a^­^ Ýn9oØ€­mÛ¶ÍçÌ™óB‡eblGx}©?êŸ©Ÿß––†¸¸xDEG#òpüŒ¨ Ä‡-GÊË°cãräÆ¯D~ÂJHôGaÒ*ñq%
V`oüRì‰Y‚ô?~ÁÖ°EˆY·‘ëºNü®DoŒÁ¦ØX$$$`ûöí8xð N:zâµàØ±cw“’’
&L˜ð½:WxOÍÔ÷c^4hÓÊù¿0­7Üã0}Ëx%Êq€‡xÜzžÆG,¨äº.uÖïê®úüž¢Îãö»äë	ê‹óóó±mÛ6¡ËDÄÅÆ 6*	‘k¹1 ù‰¿âhf0Îì	Å…¼\ÎÄ•}‘¸Zð®îSqm®ÆâZQ<®ˆÅåý›p.'§vãàÖåØµ )á‹æ˜¨0ÄÇÇ!!q+„Öåø€rÇ—¨ãÐ••+WþÖ¹sç·ïå‚M}¿1æEƒ7ÕZ©áž+&aJ¬?¦m^-½ Í(ßk#âÀÌäu/à½Ï»÷ÔÍˆßÕ¶K}¼¬wÞyç¯ÞÞÞSEŸ[FÞž}­—gíÜ‰””TlMˆGÂÆP¤ÇüŠ‚ä@œÚŽKû¢qeŒÐ¶šýqõ@4®J@yÉvÜ<S€[—Žãöµs¸#¸{ã"îÞ¼†;7.©>^?‡[WN£üô~\8 ãHö¦EH
_‚ÍÑ!Øš˜ âN222ÉÿãÐ¡Còµ>|GŽ¡±GöèÑ£¿—ð—º\·©ï7Æ¼hðFëüÔú}Ô­"bò¦U<C~í%¾xMŒ”üà˜¿Ú½€cû¹÷âhéÒ¥B_·(_OÎòòòdß›¶-Éñ`G| Š3Ç¹üh\-Š}y®KD¿~ Föï7ŽeàæÙ"Üº|·¯–IÍß¹vVèü¼ŠDÚ/¿"ôUÆ€»·nàîí›¸{ç6î”_ÆÍ%8_˜,ÇÛ"cklÒÓÒ±]¼Ê9Ð„^Aãƒ”””2‹:Ì˜ú~cÌ‹orî¿Â´›o+üþ/h<¹;ví„Þþîè¿f::-rcÿ/äs>ð³®â^õì_/^àóÏ?síÚµ›E?—æèHOäµ)·SôûiÉ›‘¿‡2…·/:?´Eöí×éãÁxµþãpãh:n–âöå‚RÐÿ•S‚3¸#ãÀYÙ×ß¹~AÄ€‹êpY+n«ãÀÝÛ Åñ¼ÅÈOX…mQþHOÝŠ]»vK°oß>9§H¯õÀÈÎÎ¾8eÊ”éâ’sý¦¾ßó¢^›Ì÷‹¾™æïdÞNÏz?AË9ª\;áÿIû
Þœa¥ñý¦j¼À²¬ôY5EßúAƒ×Sý·ß~ËZºK}ª¢¥½{÷Š~v'2"‘Ÿ‚²½›pµx+®KTÈ8°YåóOæàö…£¸}±D ¼>ù}”pº"\«)\¯ˆwnBü#cÁ­«gq*?YÑ‘.^Svöù•×L)?!¼ÁõÉ“'ûXáL}¿1æE½6éËõk^òýÚÚ×¦ûRGØ,!Ÿ÷–ˆ”3TyhL‹Ðãäcû‰Úµk÷VPPÐvÑÏß%-Ñ8_ÑÒî¬d%†áèÎH\9¸7Ž¤àúád¡û$A¢
ò âk7ÏâÖùbÜºpXpDèÿ˜Þpçêp^+ˆ±@y51àÎ-ˆkçŽbòZdÄý†ì=» ³Hÿä„g)wuuýQ\â#†ü‰L}¿1æE½5òâ:o<¥;šLë…÷…ŸÿpöHôX>ONê*}«è~R¨†z 0n&’’gá½YÃ«zÌ(,^Àj­§¾¹Âp}ë†Z¶lù²¿¿²ðÌw/M¾¿¨°»wlÃž¤0œÞ+|ý‘T¡ýT©ÿ¤¶ªô/¾.Çùç	ýÒÄ •04èø€r=cÛ•c åKvGaûÆ•ÈÙ½CŒÊ< Å º"--íª½½ýö™ú~cÌ‹zkZ~ÿ­C¤—ï»z*]Zµ
òÆ³­Uk€E,ÐÕþØ`OœÈšƒÜôÙ8˜9[~N±€>oéÝGã&Æ,×x™rñÐ×¿ñÆçÏŸºk×®»{öì‘9>ÒOñ¡bdgmCÞ¶œ/}þÑ4Á6º1@|^^¶·¨ï?w°†PRóX@+p§¶±€V_Ä™‚ddE-FÞžíâõË¹ ò0tMÄ¦M›ÊFŽ9@\ò¬ÆPê¥i­ó¡¾ºÛ27X®˜„^b¼Þ'ÀýVOÃÀµh1Kåé©_×Õ?õ÷«=±fÑtšÛâ+¡¯Ó÷{þ2ígö•?o)|Dí^ }¢ÅÈÞú÷¿ÿí»mÛ¶Û”Û£¾’rý¤Ü]éÈO‹Ä…ƒBç%¸q,]æôªÄ ÁÍÓù¸Yv@åýe¨ÉèÄ€Ëº1à¼ÎX@_N°¼J¸+8wh;vF/Á¾œâTó•4&ÈÊÊ’ˆñÍnÝº½ÏúgåÞµÿéÇÚºûpö(|¾Ø]—º¢»ÐiÏ“U^ @åšLíU)ïO,ˆòAAÒ,L™è&ñpŸˆÔˆÒÐ÷à2Ï‹Ÿ§ÿ§™G¿*^@É+*4·íveCtÔšÓý¿Ô¾\Û“%´¿—	—ldªc@FEPÊK÷àæ™ýBÿûub@UP‘ÐŽ¥†ÏÜª%Ü¹³3±S\wáþ<q-ªõA4wAkÓÓÓïÎ;7ò™gžiÌúgáž›–ïo:½Ú/°GÇ…è¹Ìëb½‘8«c|0Pø òmØÊçÒ|ŸâûÉïÏŸ9	“\]41€X>ªô¤}Åx„{#)ÁKÆú=9Â7e½ÆØGÌ—^à±ïÛcöÊ…ÈÌÌ”Ú ¯Lkû
÷ïEî¶(ÑïoCùñ,Ü8¾C+dªc€z,p,ShŸu8{@RÙkÅ€êó5Ï\©a^à¶V¸…Óû¶bgü)>„ÒR¹FXÎ]fddÐúÁ›vvvN¬Æî©iùþG\;ã£9cÐzž­œ×Ûœàƒ£{Ö¢´xJ÷®qÀWzÊj¤ï˜§ñöpqrÄDgLvs­ä¶„øÈA^@ú (h¿|OìŒgÜ-áù‹Æüœü;ÆÌ˜Hëd¤&¨¤µôGFvZÊ
Eß~|ÊOd©cÀv=> MôýÙ*ï¯Ž·Ê´}ÀP|æTq€¼Á±¬d§nÀ‰ã'ä^ZH×Jk–ƒƒƒ¶lÙòCÖ?Su×~åšÍ½ãáý[Î‹VóÆIïž™šˆüÜ”.”ŸS^ Í<[ÍÜÿ¬Hä'Ì„“½ìÇÙÀÁÞÎãáæìTÅ,ôsc?Mnb =î²Ð»TöÞ¿-ÁÆM1RÔ÷“G&ýçf%áÄÞ­¸q‚´¯PM¾àæé½jª‹ÕžÐ7Ðtæn‰Ÿ)H\ýÙBÿg”ý‚òš‰iÓ¦-·Ð³FØÔ÷c^Ô¹iÕôh4©+Þ™9\ôéÖxßo¤ô¤÷-QÁHÜ't—ˆ¢?™xÍs€ü™~þ“¤~='Ã(ë°5¶6c1ÞvœÊ8:èõ1A^òçp/9Ç“à;áè÷>ãÖ¾KæË¾Ÿt@kæhÿîA1^.Ü‡ëÔï‹1}yéî*1 \;Ð¸_£ÿÊ1€Öø.ÔÇ¼@¹žy»¸r² »cW äè!¹g˜by ÚSq±G]XÿLMÔ©iíë{À¹^õ„7fÁ[3‡á]ßhágiÁn8š9©Q²cÜƒ'Ko@?C9¼Mb<äŽ¡ƒaøÐ!9|ÆŒ´Æ¸1£T^ÀÎVzWgG½^ g³jn`yŒŠD,,â@§ã0Ôc¸ìûI”'í—–ž@^f<.ÎÂÍ“9áë«ª|@ù©\”ŸÎÓ‰ûj‰UçôçõÅ€ó5äªÏ	žÈŽFnj$ÊDÿOõ
h>€®øé§Ÿ‚Å_ëQÖ?SÆk¿²ïÚ½'^öˆ×¼¡¹Þœ1Tz—=ú£ë<k_á€^mäçô|ÊÛ¹‡NGQê,¡ýþ4 ?¬Ä°!V1lh…;FzGpªäš/$Ÿ#Æ4×¸þ,]¹ [·n•ý?í›“šÈËÂ±½É(?™+´Ÿ[MØYè1éÿT^ÕpÆxP5”ÖÛ¼ ý|^ü)Ê—×Jñ.==]¾!!!ºwïÞŠõÏT‡ÑM®±Sr~]ðü´¾xAhû%áë›	ðº÷`4ÞWïš_ê÷ß?Çs,zYö@ßÞ½0 __8 Côx;m/àTÕÌ™1EzÜ4?DMEDäHLL”ûø¨vÏÉÒäïØŒ+%”ËZ>USPû úšÔ51 ÒX@ß¼€¾œ 1óç˜¸‹²ý[‘“ŠsçÎ‚j•ÑúFz77·…ZëM}¿1æ…q}Å^Þœ: ñK<#4ýü´>h2½šzªâÀƒbL@{ùZÍ+óü´Þï‹¥.2ß¯¬ï-JñÅl±èÙ£;úôê‰~}zc`ÿ~*/`5XåFÇXm/`o'½ åu½@ÈÊiøu™¯¬ÏE÷=åÃ©¦Þ½»p¼`›Ðp¾Z»5Ä u_Óè_*ë¿¦œ n¨ëZáêæ®U™¸uùò…()Þ/õO¹@ò?TS(   øÍ7ß|•õÏèÃpíW®åG}ÿ““»Ë@c€ç¦ö–^àQ·Ï+Íïëƒr÷¹êyý„õî6¸~/ ÆÖäÄ˜@z›±Ò8i¼@E~r†ÁAk¤þÓÒÒ¤>[vû²qùxŽZ«ê@z&ªñ7Oå¨bDcÀ}žã€“»#Ÿ¾…ç¡:¥´&˜jnØ°áæèÑ£‡±þ}Ü´|?åüHçOìŠF“ºá©)=ÐØÝRÄƒòû´‡·:íSÿ¯ÊÝ{kÖõ‘XäkËîÝÐ»ge/0T°¯â\à=Í±±±Rÿ´¿4p´¸GòREß_ «“V¥ÈWû ý1@[ÿ•ã@Í1ÀÐœ`ýÎ”Ë5A×ËŠ¿e§KU×~ô¨Ô||<¦OŸ¾ÞB½?ÐÔ÷c^Ö÷Wø~Eÿ¹t’àQ·/ðÄ$&w“_×]Û«Oÿ4ï¯íhßßŽT?dlð€Íˆþ/Ð¿o™Ôõ6Ú^@ôûÿšðV/Ÿ-ïuò¼4Fµ´ów§áÂÑlÑ7PõÏ†Æ í«È«ðFÏºVØyýûn‹çJ^…Ã»äyä¨– ½'+W®,~å•Wš±þ]óýõ{Hã
:wÄÃ.¥xH½G·¦GMÐüÅ å1Aùü
/`YÕP~¼ÀHk•gƒå±6pµ¼×iÎŸ´îl
vnÅõS*Òþ=ípF;èä´´^0h^@oNðžœ`}ÌÜÄ™ìä¥FÈë§sIhMp\\­¸ñõ×_Éúgt©Ý÷W®é¡­%újzÐþ=‡õžµÆòäÈP< é§qƒ¥èÓ«²¦ö4W8ÇÛ	¡«§Èšü¤ZëKgêÐš˜#ùª]·”~XoÐÊ	žRÇ u~@_0t^@Nð^÷Ô4/pWd"7~•ˆ}gä{@kŸHÿQQQwÝYÿŒ.5÷ý•kzèj_A™××öý+6Í@Fê
©ez\“þ)F(q‚< ÍÐZÊÌsÀ€¾=+yÊ’°5{·ÌÀD¿I´ÿ]êŸÆ½tïæïAÙ‘•Þ¨n‡&¨!¨ÇJ~Ð€`>ó×Q~®û·,CéÑBùÐ8ˆôOï§§g¨ø‹>hêû1/êâûõéŸæú´kyvß^|Q—¸VŽïiœ_[ ç‘P~}žç-½€2W¨xà¥nˆØäéó}å=Nù.:gïêÕ+Ø'Æþ—O¨tFš«jòyµêß˜`èÞáª1 Ôðyµ¸%ž{t›?æ¥kÎ%¤|(½7óçÏÏ¦óCL}¿1æEõú¯|^wMÚ§u=ºãzç°ðƒ†QÁ9Ø—±Pöí¤oCrô\zLk…ÉG¬_ê"¼€¥ônÃåºßo—¸aÁ²Eò§5¯”û¾tñöíÙ†ëgŠÔ^['”éñº9Ab€éæô×¡ïÊúû2£¥þ	zOè½ñ÷÷?ùúë¯77õýÆ˜†ê¿º x%ïGý6åC6‡¢é/å•bÀë‹Ê™ªÉù×–Ðöô|Š4Wè=É9›}07ÒÝý~ÀêÀ5ò§½~t®îÙ²Ó(ÊI~˜´uX¨4ØWk¨>˜j^àœ<[@;PL8—ý;r“ÖÉ9 z/è=¡÷&((èjëÖ­ÿiêû1/jÿWìï¯)h×ô¥}ùÊ?êï©ß—úŸ<5h¶pÈEa¦a^€rŠ Ç™©³d¿Ÿ˜ä+×ü5s<B~ÿ]ÞãÙÙÙòž?UzG
¶«´OšRbÀ9íPTË¼À^ƒc€ák…8®§ŽþõHÿsÃ‘»åW\ºtQž/Nï	½7ááá·---{šú~cÌ‹ZÕ÷ÒSË¿º@^@©ïI}¶âZ.¿ˆo.>XtYD$FiÖÕ6P|Àøu°Z3Mî÷#ý÷ö/sÿ111rÝ;ÝóÇ£äÀ.U_*´¤ŠÅzb@mù€úõ1/P]N_ÚŽ¼-þ¸p®L¾´ô¿aÃ†»fêû1/nä´ÖÿÖ(' Ôø¦~›Æï^‘Yxo9ð‰?Ðn5Ðq-àY"úó…ÒÛ×äTsƒªýþ}¦Ê¹Ò¿ÇKíTÓ›îù£‡Qz0[=–>*ã@Õ ;/P¿1àþÏ\_¿¼7{·¬Âù³§¥¢óý:tŒ©ï7Æ¼0ª©ÎòJ4&/ x%·Ÿš«u—ÑAh¿S ˆÁ@· <)ZöïÊÚ@}Pa©¡}ÒÏU“1ðGyTßSêÿP!Nç
SëG72n^à”‚)çªætçn‰çþ÷%¬ÂÙ3'¥þi ½7´`Äˆß›ú~cÌ‹:5ÊáèeÿyYïsSz¬:Ú>ZÞp;3VÉÜ?ù}}ú§¾¿ºï'ýÒÒ?ÕõVô_z(Oè¥D}F—V8¯åjÌ	êÎ*¾g`> ®µÅuò7Ë
„þÃ‘Ÿ€se'«ôÿÃ†kêû1/êÜŒôÚ5?IÛ¤ñìôUY†O„öß¼&|@³PÀcKª¦ÞgmúÿFŸþÄ‰ƒ¢ÿW|³.hÇ }óõ—¬94Ì¼ Õ.¹œ!ô¿Zãÿ©î±¢ÿÁƒóøŸ©Ä=7Úd¤Pö+künIÃGaÀóBÿŠ8`!ü@K2´¼€Æûký©žp?{yÓøŸÎõ!ýŸ(9‚cEÙBÿB#—Nèušh˜œà½ÕWÏˆ±Àõƒ›qIè?/ñW\<VêŸöBÒûq§wïÞ}L}¿1æE½4Um€pc¼ í&+^€|ßèãRûÚL^€r‡c‚<ªŒýIÿ}„þ7nÜ(ïqêëHÿ§NžÀá‚Ý¸)u¢Ö¿N0l^ ºµÂ÷k^ÀðÚâ®ˆÆÅ<¡ÿ­A¸¬žÿ£sOè½	.ÿòË/;šú~cÌ‹zmÒT¬®ÍP Å(õ¼—%EãAáýÓç4ÿ¯ÏûËó¼¾GXX˜ìÿ©þµ\ÿsö,Šöf	ý«ûG}1@ß¼Ày#æN5ô¼€qk…ËOì–ú?—Ž¼”PÍúª…Bú_½zõ…÷ßÿ]SßoŒyQïMµo@ï9àµyšã£yÀ}™Ñ%ªDB1ahàt÷'ý
Põÿ–Bÿ]gØ"ð· ySÍ?ºç©VAnnœ?®>ƒÏØ »VØ¼ç(ïMxÿk6âôîß±o{,®_».c Õ  ÷féÒ¥‡^|ñÅL}¿1æEƒ5Ú;h„Ð^C¬xòýôXwì½e&rÒüà<]þW.•÷8Õ¼£{žØ—»—ËŽªõ¯.V7/`ÈZáÚç”8P¿óÕÇ€ò{„öcpUèÿhf0ŠówÈý´ŠöDÑ{3{öìdñWyÔÔ÷c^4hSyHc×+^@Y íý§†zjÖÓÇeL‡÷‚Yò§Ú?Tó—ö½íß‹²ã…rOœÞPo9Ázœ¨KmñsÅ¸^k…±¸²#¤âdI±Ô?í…Vöÿº¹¹ýÇ‚÷ÿ2:4xSÍ·plgpÐöÚú§5¿´ö¿«ÿ¹§€ö­ÿ+—þ¤Ùÿ_ZZªªÿqìŽÈQéÿÊé
ýkb@ÕyÛz×	š÷¼ Ux½(N‹‹û¢‘—ŒçÏÊ÷ //Oê?22òîðáÃePSßoŒyQ¿ZWýi]€ž=ÕQÛbÅû‡nž!k	hï)$†Ì’µ?Iÿ´ÞúÿsgÏb?å .
½_=­š#«ôåîÿ¼@]×
—ŸÌÆõƒñjýÇáLNò36áòå+r4åþHÿ¿þúë¹6mÚ´`ý3ºÔk«&ïWÇÚc€öâ÷ý¬¥÷·žŽÌ”Y2P]Eÿœƒ p©:ÿŽî}¢`o6.œ:,kéjÉ	¹V¸º|@ÝçŠäÏ]?¸×m–1àZa¥¯ÃaáyèÚé ‘þ,X.þ:XÿŒ.õÖtj…)k}šLë%õKû èìï''u•š~×w(žÐÑ/ÐS®!¦¼ÿâ(U@¥ÆÈÞà¾ PêŸÎþ {_ÖÀ>\Œ#Ey¸uù´\S9¬ë¼€k…ë2/P~2×‹·
í'T1àbAò’×£ìô)yí´‚jÿÐ{âààð£ø=Èúgt©·¦å÷ßš1DæðÈ·ã÷Ak=aäf[Ëï+{‚ÈÛ?ÿïž{âmñ»iÞßf­;2R|¥h½ü4ºyFa“ºþ?íy¡9€³eeØ—“…«çËõ±2P.@“0`nÐÌæè|‚ëÅI‚D"\>àÄîpìÛ¹UÖü¢ùOòAô^¬_¿þJ=Ú+&SßoŒyQ/M«NÈãnŸ£Û27X®˜$×éô	p—ù»k=ÐbÖˆJû (.<éÚÉ`/ðÔänh¿ÀÝÅÿãî¢ŒÙ˜°p-Ö…o÷|ff¦FEö¡ôÈ~©ý;ÒèÆ€šs‚÷o^ ¦œà>ùuy6ùád\—(1 WŠ6#?eŽ=$¯ùøñãòüOz/æÏŸOó~O°þ}Ü»ö?ýX[³Î…Ï;£ëRWt~ŸújéT^ ÉÔ^UjÓ>€í›}ðwç^Fy7}¬äÿcå?	‘QX¾lôÿtï;vLjáÔÉ“ÈÏÝ‰kçOàÎµ²ŠpÕð`šyågsqãøNÜ8º7Ž¤h1@Œ®‰Pš‰¼Ì89ßOqo÷îÝò}ˆ½cmm=Fü•`ý3ú¸ç¦åû›Nï#ûåŽÐs™ÖÅz#!q&VÇø` ðäÚ.°•ÏUÖý*u}æÏœ$ÏöýÆus4</@~ã“9cEÌqÁÔÿü1£¥þI¤ÿóçÏ¡p>ŽÍ—é‰1/°O8mhÈÁÒlÜ8!t_’)ôž¦ÖªÔ>àRÑìMYc‡‹ä™?'Nœë è=X¾|ùV­Z½¤ýç2õýÆ˜÷Ô´|ÿ#®ñÑœ1h=ÏVÎÝoNðÁÑ=kQZ¼¥{×‰8à«Z¯/<ö€öþDL“çx¹89b¢‹3œÝœö¯zöG{ß±X°j‰¬yK())Q~²{s²p©¬DU+ƒâ€’¨)'X¯óŠî•³†„Î%9j²UçŽÓäÇw¨¼>i¿$CÎñß8š®Šš8 ò Çvþ½YI(;S&ûª÷G×Oëþìíí'Zhõý¬F—ºkŸÖõTìûmî=XŒãG¡¥è‹[Í'óó™©‰Â{ç äp¡üœòmæ©úŠ´¾/?a&œìmä9^övpv/Ïô$/0ÌÕºìuý½¦ŽCüæx©:—4QVV†ƒEPT 4vùŒºf–1 >æj8o°\ëÜárÑß—ŸÈ’ûøËo×Ò41àúáœ+ˆGvr8Ž—•×HëýhÎŸ®ÝßßÿÛo¿ÝL÷Ïfêû1/êÜ´j4šÔïÌ.útk¼ï7Rú Òû–¨`$nŽCnV"Š2üd^à5Ïògú‰1;ù~ÏÉãä9^6t¶¯ÍXŒ·§òŽ/ðÏ	ß¼nè!Û¶ðY<WžHPM ÒÆ©S§„ØG„6¯ž­îÛ¼@Íg«Pb€®H×ø€Ë‡’±o[
ó³qúôiyÖ÷G×wgÌ˜1vúþl¦¾ßó¢NMël ÒÝ«^ƒðÆŒ!xkæ0¼ë;-ü¬1-ØG3ç¢ u!JvÌƒ{ðdé”u}´Ï/6ÈCél_:Ó“ÎöiqcF©¼€­ô®ÎŽÆyÇöxÛÖ›âã¤²²²¤6H#ÇDÿ˜»gÎ<‚ÛT3SŒÏ	ÞÛ¼€ž3Gð×oCñŽHäe%Ëñ>Å6Z÷Hs~tÍÓfÿTHgý°þ™Ú0^û•}ÿÓî=ñ²×@¼æ=Í}¬ðæŒ¡Ò¼ìÑ]çYcø
ôZh#?WÖó¹‡NGQê,¡ýþò/:Û—Îô1lh…;FzGpÂd7Wtt\«xð‡öpôšŒôôt©	ªC1€ö@^ö\*;^%Ü©×yÏ5ÀÜÐŠ×„8ž³	»ScpäÈa©ª{J{ŸéZƒÃBîtù¦Wêþ|¦¾ßóÂè¦Uçç×.x~Z_¼ ´ý’ðõÍ„xÝ{0šNï«W£Ôï+¾ŽçXy¶oßÞ½0 __y¦ç=^ÀNÛ8©¼Àh7;¼èÔµÆ0`Âh¹ö•4AÚ :˜¤ÿãÇKP°/ù9;qå\©ªvvù€†Ü/PCÐÄ%ìÀu¡ÿÒ¼ÍØ•²‹öËü&ÍsÒ\ó³59	C'Œ[.þJaý3†`T£ú>ŠÖœ: ñK<#4ýü´>h2½šzªâÀƒBTÛ‡Î¥<?­÷Sêÿ*gÑ9^³=ÆjÎôTÎö•^Àj°ÊŒŽ±Ú^ÀÞNzÊÖælfNRibëV©ªƒEý$i†ê„îÍËQÕ8{Â€`Ì¼€±µÅËÜ(Ù“ù[°;%

òÅ5•ù>ÚãGã~Zó4aæ´Â×_ýéšþ„¦¾ßóÂpíËçµûþ''w—1€Æ ÏMí-½À£nŸWšß×Õô sˆ„õî6¸~/ ÆÖäÄ˜@z›±Ò8i¼€3ì\Çã5gË*1 ßt[\¾|Y³4BõÁ(þé¬Üœ=Ø+ÆÏÓÔq^ ¦Úâ†œ9ZM¸^’…{·`WröíÍÅ¡CÅ8|ø°<ïˆæ8¨ÿŸµâ?åÿèþé?kû3šú~cÌƒ›–ï§þ•tþøÄ®h4©žšÒÝ-E<è¡Z—7ÃªÆs|”3¿è1Å ò‹|maÙ½z÷¬ì†êñöU¼€¬¼Fà¯nkˆ[:õ“µÀ(ïG{`Hÿ47Ný%Í	4&ÈÞ³Ù»2Qv¢Xèýæj­-^·y«Çvàðžxd%oD^n¶xÍEòµS¾âáÿ{ÞÖÅÝ?£©ï7Æ¼0¨iù~Eÿ¹t’àQ·/ðÄ$&w“_×]Û«OÿJ]ÅÐ9t6PÆØŒè¯ñýûö‘ùA]/`£íÆÛÃ}¢ŠÅï±_3ÏNQy§í;c{ö.Ü½{WêœêþI/ÔoÒ!ú:éhÏî]Ø¹=ÇàÆ¥Óf1/P^šƒ‹‡3±{¶§Ä	¯’-_+½fÚÛ—ŸŸ/cYpd(Þú¾{º¡aÜÔ÷c^Ô®}YÓ£XožÝ¹#vé,½ Åe]Omgy*ÐÚ?åìOzLÐº
/`YÕP~¼ÀHk•gƒ¤0/YöÑúÂçŒÂ#âµMYä+÷ÂRÞÆ6ls„¢%úHŸ“‡ÎÌØ†‚¼¸pZèøŠzP­óúj‹×u^@®ØƒÒ})r¬Ok¨(né¾f""&êÚ?l{&ZØvx†õÏÔ…Z›NMÝùvŠ}j÷ië;l‹¯<÷¯¶8@~€|€êŒOÕÞþŒH8,½@Ÿ^•½À0µ ¹Â9ÞN²&ØÀ€)Bû*ýÓ¾Ào~™ŒßÖ¯“óÿ¤Z·jÕ*Ú+û~EKý(ù#¤§mÃŽŒ.ÌÃ•³%ª=uš0äÌÑÊcëÂÿ—ÜŽüí±HKŒFFú6™·T<å,è5"žùî»ïXè¬ïeý3ÆPcÓ©é¡oý½vmßOçüe¤®Z¦Ç5éŸb„'ÈÐü€r6PÀ<èÛ³’ ü y›QÃåúaZO ì- †.›†øÄ-rüOceÚMu°àååEûb¤¦8 ärss¥þi® ]ÄŠ”¤Dde¤âHa..•SÕ¡þ¿žç¨žÇõ“{Qvh
vÄ#=1
É‰›å¼åöí;d~bå-•×ºqãÆ¼|iŒîYÿŒ>ª×~õ¾_Ÿþi®OÑ³²§jtT£ƒÆ÷4Î¯-ÐóÈ(¿ƒ>Ï‰ó–^@™+T¼@ðR7éû•³ HûÃ—MG\Âf©}åüKêó—,Y‚ÿY€Ÿ~ú‰êáÈ4?HytŠ	Ê:šÔÔTlq#qK<2¶%b¿œ))ÄÕs%¸yùTõ9AöÜ<{7NïÇ¥’\”ìKGNz’ã#±%>I[·Êÿ›^ù~z]4Ï'óýû0e¡ïµnÝº}\í³þ]ª×ÅßÚú~Z×£;®Wjs)(õº©o'}’ çÒcZ+L>býRá,¥ps.}ÿˆµSeßOc]íS¿ùÇÀÏÏ?ü€1Ž¶°v¶Åœ`?~<Ü&º!9%Yê‹ÖÑÐÚ êc)@¤³3È;ÄÇÅ!vSŒÐç&dŠXP³ÇíÅùÒƒ¸Rv×Ï—È³Æn^(‘gŽÊŽÉµA7ÏFù¹b\=]„‹'öáLq6Žäg 's3R6o@üÆ?°)&›ãã‘ þ/ú?)‘×§:ÊŸô];`9u²£:Êm›³þ™úÀPý×´ÿV»^7õÛ4–Ù*ëskÇ€×•#2!T“ó¯-' íèùh®Ð{’5r6û`n¤—æ°áË~Ô«ýY³fa‚³“f?‘ƒ:ÚÀ[ö–xwœ%>c‰i‹gá`ñ!¹––r…´V˜ü6å”š4@cˆÈÈHDþ¨ÈpÄoÚ€”„MØ‘–€œÉ(Ø“ŽÂÜLÜ»…y™8†ü)Ø±™I›‰MQ¡Øþ;þˆCä†ÂËÇÈÚåÊ:ò+Ê~úxäØQ¬
ÿ­§|¥†º—±þ™z Æ¦µ¿ßý·”ÿ£š~Ê?åœ©ÿÙÀSóf‹ ÷ˆ\fæ(w ø zœ™:Köû‰I¾šs G,¯^ûŽB÷Õí'RÖÿÅ¾ÚN´Bð¦œú§ú¡´g>RßK>œ| 3JsáááEHH«‰ß~BPÐZk´öW
‚kÅçAø-(H>7$äwù³ô;¢¢¢¤îÉoÐš$ú?éìBÚ³L{z’¶m…Ý‚ÑÖwLÅû/×`qÿÏÔµ6ªï¥§–Mgw(õ=©ÏV¼@ËåñÂBàÍ¥À+€.k€ˆÄ(ÍZ ÚÆŠ¿ÎVk¦É³@Hÿ#VV¯}òü£­¿«¼†¸ºýDŽíðø÷íÑÇÓ$ÅâÄ©“²~Õ!H—¤QÊÇÓšbÒîï¿ÿŽuëÖaíÚµ’€€ 	Í3«WËÏ×È$Ÿ!5Oy=ÓÓï¥ÿ‡êvgÊÎ mg\—øâ3ßïÑñ??ÈGZïýuÕ>ëŸÑÅàF÷ÖúßÚâ€rv‡ÒoÓøÝ+2ï->ñÚ­:®\"KD¾Pzûš¼€jnÐ«Ò9€Ö+=«Õþx{{9G@û‰¬kÜOäŒÑn¶û‰„Çþ«mGXN‹€è--‘géÐ:åL]zL}4h^Žæç”|CLc3PÚƒHý;=ÆT£‹~QB¿—ÓÇc'J™‡1ó§âSŸ1h3×~—=úi÷ý»ïEû¬F£šê,¯ÄÚb€v^@ñJn?5%Vë.£ƒÐ~§@‚n!@xR´ìß•µúÐœ*´?r¥WµÚ·³µÅ€¾_¹ŸÈ_º­T{ðÛvøÀ¥y#&c+JOŸ”Z½uë–†;wîàöíÛr¡ò9}T¾FŸ+Ð×è{7oÞ”¯¹ôÌ)ÄŠßë¼Ø]½Æá}¯áxÿÿ¬ñ‘º†Ò»¾ÃuÆ^ŸÖ9ïÏúgôQ§F¹A#¼ ¢ìÿ#/ ë}nÊBu@AÁGëÁÎagÆ*™û'¿¯OÿÔ÷×¤}ïé®nÕ·Ò~"}kˆõí'’ùA}û‰Æ·Åvñ¦s/ú?gÌ^·ñ;RpDxƒ²çp£¼åBÓÔHói]‰ô¯‰~þÔ©HØ™†Ÿ_%Ï[zã1»OñÒÔ¾²nÂÛT?eÖYCéÃÙcdMÅúòý¬FunFzB©ùIÚ&g§¯ÂØÈ2|"´ÿžà5áš…[ReŒ 5@ºú¹Ê»Zí;OsE~Škˆ…YÃ~"ÊêzJ×÷C{<n×ÏÿðZ¸õC§é#ðílWŒ[ô#¦øÏëªYøií\$Ç¬Bøú5Y„­Ì…ë¾G£>Ã#k&ie3Y?e0Þð‚·¨~Šè÷›Lë]¯¾ŸõÏèãží2Ò({ƒ•5~·¤á£0ày¡ÿE°~ ¥ˆÂlŠýIô•ãñõJwŒö'íoÑïù§º +éÿà>#WOBNÚ¬Jû‰t××´ŸHÛ|4©O­óšësl'÷B<9ñK<9©&Øb_ÚL"&¢‰¸vÚ3E{&èù´g¢Éô¾hêÑ/{”uÔ^÷±êüŸuŸïÓm¦¾ßó¢^šª6@¸1^€öSOñäûûF—Ú×°ú2|Vàâ…³ç9Ñq›ôjÿû»`ØÊIðö’çØN‘g­ˆòÔxêÖëÛOD^ÀYx©“œQ4ßü2Rô×Ÿ<JŸHû"»É½‘´OšâAúWžKû¥Ÿ‘uúà~êJ+û~ÚQÍÔ÷c^Ôk“^ bÍpm:¡AŠ 9@òË’¢ñ ð¤}«E12oFyö¸øxªi-çÈhŒ¶ö¿Z2QÖ'íéÉ¾ð›†Î‹œ´É…kˆU^ bñuíAk¥ö ÚŒ^ rõtÄÄyÊqù>ß¢Ñ¿j®9Vu.´³Ô>ÅEûÊ>Iú^Eý”^xNÖPê‹FâkZÚ/–±µ›©ï7Æ¼¨÷¦Ú7 ÷ðJ:q:×NÐÍ§D·n´òßX¿ÁY‰sà¼"L£}š/ÿùçŸ1nÜ8©ù°°0Ì™3GhßUjŸöû)úÿb±­r“Ú·];Ij¿ûbGÌŸªòáZû‰úöî­©7¤ë¦O²Çñ³æ‘ú§üÜ‚¦¢Ÿn:ù£¼€ªN‚JÿòkNªú)OˆØ@1€ê§P%¢¡|¿ÒL}¿1æEƒ5ºwõy¡û¾n‹·ßÀƒÍ^Å_^{¼þ7<ñÎßñÂ‡-ñZ‡Nø{»vÈÉ/ÔhîÜ¹°µcs''¬X±...˜æþœƒ¦iöû*}?é¿Ë"g©ÿiëÝ1uÝ9ã‰ðX/Ämñ©v?‘•–Ø¹É3×OÚ®¥ÿ!˜´Ö	Ûb¼:“€ÐÞ'MõV×OQÆ	o îûýâÏbêû1/´éz_~‹ÇÇ_þò }ôa4jôžyº1^|¡	^}¥Þ|ãoxGÄ‚¶],±î÷0Ì›7O£}Ú¿KµohíÕ¿ç#7u„û®š¨ÑÿçRÿNRÿ:
í;`Ø*é¾X8Ÿ/´—>€>Z=úXª½@EíÁ€ù.HIô‘yxÒ?åäIÿæZã@ú,øzºÕé|"Ýï“Þi@^àaW­ßãØîr}û~¥™ú~cÌ‹ûÒhÝÊøv{,º¶‚Å#
íÿEhÿQ¡ýFxúé§ñÂ/à•W^Áo¼wß}~ø!Z¶l‰O:tƒõè±˜0ÁYjŸjvPîbÀÜåxÁçˆ\[œ“æ‡À)²ï×§êÿ».r@ÛùvÒ„Åz¢ó/vˆÝâ-÷Mvªñ6Cd|èµpœZÿÃ¤þÉûGÇyÊ³
uÎ'2äL%è«ŸR©ß×Îû5@0õýÆ˜÷§µxÄâÙ÷§X<ôÈ-C´ÿÏþ:tÀgŸ}†O¿ü¿,^ŽƒE…Rû´Gÿç%xÂ.V³¯pÀÚr¯Ñ†Í>èµÌEjŸ sˆIÿt&q;A›ù¶Xí!µßi­ô ‹"¦j¼@á2£<¥ï§sŒ´½ÿä@gYkÄÑnlåýDFœIPÓj­¾_'ÿ×¾_}þ%L}¿1æEÃ7µö|øš1ÚÿüóÏÑ£Gô¾|Ä÷pðÈ	Ñïˆñÿøý<UÖÑÞ[üø\`Å¦(9ïç4Eöý*ý—ú§¾ŸôßzÞ8¹¶vqäT„mò”km]×ªÆÔï“ïoÖ÷'ýwœ;2fÁcÒ¸{:“ 6ý?áÖ½VþK ¹Õúñ¦¾ßó¢aÛ½i¿OŸ>øæ›o0xÐ7ûÃDüôó\tþ×p,ŽRÕÔ­1Btõ?"½@dœ7º/vªVÿÔÿwœ?æÛHíówÄÐåãÑ{‘­ìûµÇþëb¦!x±«æ|¢Jû‰ôœI0ÊÕVï™µõýÖëfbÅ®Xx&¬Ák^tcÀùúð¦¾ßó¢áZýhÿÛo¿Åwß}‡áÃ†âËNx{ÆYïÃf­;2ÄØj‹µ^~ºŠðO‘ºžâ.½¿¶þ?™k#¡óHû/µÇÂpw¹æ¾…€ú~mï?r…½<«pÈ ~5î'Òw&Akˆu´Os×LÇâÑX¶sVí‰ÃÐ /¹F¢ªàýÿLýÐ0­~µ?jÔ(IÓž_Èó}ŸšÜMöé4ïçî!=ÿt¡wÒ½&ÌºøŸFVê
9ç×{©ƒÔ+-ý“÷§}6ø’ú§óËµ½K¿Ò÷kŸUX—5Äú¼€N®OÄÕúÂfžý0%v–fÅH/à—"âÑP=^ s]þ2¦¾ßó¢þ[ýkìØ±=z4š	ýÓÚEoúXÉ9?+ÿIØ’8SÖ–^`6ð°ˆOÎš/æD©¼€×úÉýSßOúÿ@ê¤^ýSÿï³ÎÍð3	/ µ†XÙOÔËõ;½^€PÎRQÖ=WL2ÀÐþ+ã¼€©ï7Æ¼ø3hŸ°¶¶F3KÒÿ§•¼3ÕÆùDè˜æýhÍ/y¯ˆ4ýxfÐt!ðšˆƒÏ %%©I30p™ƒZÿc4úo¡ÖÅØ_5ï7>À;Sf")ÁÛèýDãu¼ ÍþÝ¹Wß¯¬¤}A”§ëfn×:F0|o°©ï7Æ¼ø3hŸ6¯tWõÿúòg¯zö—¹>ËeÎ2÷W±VAGe½Á7–ï,Þ_øEeÉþÜ/tŠÊûÏUíØÿ#µÿ°È¯{[É8 »†¸¦ýDã´½€Ãxp›c‡—&w×¢:GUAÑ?ù íkû|±æ¤†i¼€cä/úò»©bêû1/þÚ§¯Y	m½òeX8T¿¾îQ·.BÓ£ä¼Ÿs jíðæ(´ºo±øp…ªöØààËHKDJâô[lW­÷§yÿ‹Ç¡¹ÏLZã(ô?_Ì³Æ†Xj×WÙO$ÆÒØŽ“^`Š›ê¬Â.~ƒ+íRé¿“^ýÏ¹[ÂyÃ¢š½€ŠYÿŒ¡ü´?dÈô}ìK];UZS]xÎ½§Ì÷w[ä ×ûQ­a—°"´\´ Ú
Ú¯¬ADµ†OA›9£*é_YóKkþIÿÁÑSÑwá¹G?JèCìt¹¸¦ýDÃÕ^`Œ–H
õÂ/¡.UöSßÿ°Zûúô¯`:§"/°+“7-ÇóSu÷UŸ4õýÆ˜íÓsèùOtï`pêGß}8ÅQ.Ø“ê‹Ø¤Pô¼%kRýAª?:`ý-lN	Å.áí­–ÙUûKýûþ­d}Ò¾í*{éÞž1½~)Ç´†xŠÖb}û‰Tg:¢ ÝM§ZÖYÿ®ÑK1?#RôÿQÒ,ß©ò•Ç¬Æ0þÚïÙ³'ÞmÕi¯Åkß°0òL‚g¦XÊ|—_ìäš?ò>Q¹RûNA*fÄì•ß[6ŸøYköû’þiì¯èÿÝ™Vè2o„¬ÕAÀo½+/#½@uû‰†$Ï*<˜ê‡¾ó‡©k‚èzÿÊc}úïºÔ¾)!˜†yéX±‹„è³jŠÎšáê×
šú~cÌ‹?ƒö[´êT`ñJ§6šÿÞÈ3	ré(´;@ÆëUNÒlN•}?i¿£ C0Ð/ô"’¢eÎÖýþ›KýÖèŸêóö?ñŠÄ/¼é3ùZI°vÃÕ~"Ç
/ÐO\+å#ü'cuä$¹×W·&ˆÒ÷W7ö'žžÒ]Îø$cfòzø¥†bnZ8&
ÿ_ù¹5×0õýÆ˜uÓ~‹û«ýfÛê})FzªÉ×b–5:Ì‡Y¡“¥fçÇî”5È©q{A[Áø¨ãÒ¬‹ž†|‡Iý“ö‰—ÕúoêÙ/xô—u»"…˜èˆç¦öÆ¢°‰ò÷&¬wÇ°Á}ä\¡ÛøaÒ÷¿$Æéúêâý‡ù`j\ <¶¬…wbf$­“^àMŸÁÚ}­µÂL}¿1æ…ñÚýþ_1½ö51À¸:Ä
/@gjÐ¼ßÅvr¿OZZ ††_‘Úo- zÄíCähéë‡/³Õôý•õßM¦÷ƒåüxÃ«?:ø©öwŸ;¾ÁNÒÌö+Ï*±xdµõ kÓ?Ík¼&þÏÖólÐi¡úLÅ¨?|±ØÙ`ßÏúgôa´öÕýþ#<‚'Ÿ|Ò´Ú¯Œ;“€Ö½5cˆœ÷÷QõÙsãv¢ÕzÕY-ï„ ÖÑÇemRÊù·ö&µ¯«ªßIŒZfƒ©kd/÷5ã‘°Å;’}3UÖ÷©ÐÍó~ÕåþjÁ ½A¦¾ßóÂ(í«û}ÒýO<§žzÊ<´¯‰ÆŸI@uöiÞ¯Ëü1²Öç¡õaÎá]¡ý7¯ÒÇ0`æ–4é\W;Hý+Þ_[ÿTË÷™©½ÐÂg€Œ'm}…g˜Þ/Oë…FRûÆýß¯­VíÓž ›©ï7Æ¼0HûMTýþC=„‡~ýë_ñòË/ãùçŸGÓ¦MÍCûÚÍÈ3	È_ÓŸæý§:Ëüß‚„4¼/tÿ’ÐÿÓ‚G…h§>“€òþ-g‘Ú§š½¤ýç¤ö{ËZ¾Ôÿw›;TÖõ¤~Ÿhd€÷×~­/ˆ¸ô®ï0Œ\?Kç ¶]Ôg³ÿ(kFÔ0õýÆ˜µj_ôûÈ~ÿAMŸOýÿK/½„÷Þ{¯¾ú*Þzë-|ôÑGæ¡}¥ÕáL‚§§XÊù¾sG":ÎCú~Ë¨sh´¾â\ªMî Æ	ä¦:éÑOYÓ›ÐÖMcšŸ ÿŸæðÛÎ·Å€5è…!A>¾n&^õPYÿ÷ÐL}¿1æEõ­r¿Oã}Ò?éžü>õýo¿ý6Úµk'û~ÒÇŽÍCûÚÍH/@}ñKÂÛÓ¼Ÿ½ÿxÕ¿äh4¢3	´Î&i~±iHcü³‡¡ÿªcÿÔë•F­™ŒÄ$_9v ³RC¼aävìŒÊñ×ÔL}¿1æ…þ¦šãSúýÇÏ=÷œôýô‘ôÞ¢E¼öÚkøä“OÐ½{w´nÝíÛ·ÇW_}e>ÚWZ5gÔäžšÜCæü[ÌT­ýÝ—¹]¢J*ŸO´NåH¯”÷£±¿¢Ò¾¢ÿšÆþJßÿžïp$$ÎÄá]Á8~¤§
‘›>[z^«&WÎóßC3õýÆ˜U›’ëSõû¤ýÇ{Lö÷4Î§ñ>éž¼~›6mä S§N0` ºté‚nÝºaàÀæ£}íVÝ™5¬!~^ôé†.µ‘^@s>‘ŽXŸŠ¬d9î×íûkû+ãþ6óleIJØ‚=;³P\T(?·Z3MžDç&jš×õ-0õýÆ˜•›öÚž¥çöÙgÑ¤I9Ï÷úë¯ãã?Æ›o¾)uO^ÿ‹/¾}?i™´Mûõëg~ÚWš¡çiÏŠ>›æûhÍÿìWéFlÚ[ÅPˆØ4Õ¨±¿¶þ³Sg!#vb££“¾E™³ÑSôýtNbåz€m»Ôüw¬¾™ú~cÌ‹ŠVuŽúþÆ£yóæøÛßþ&sþï¿ÿ¾ìï?øàé¾þúké÷©V÷ Aƒðý÷ßk¼¿Ùi_»I/`øbzLþžâ@ÏÖ¢¯Ÿ!õþLØ-(þ …wÿJúW¼ucEÿoø†Õ
'¹g¹8}ž¬câ2MÖ8£œ Ö\ßyêÿÿ»Vn¦¾ßóBÕ>{Èâ¹“µçø(ÏO¹>êÿI÷¤w‚rý4Î'Sîúÿ¡C‡J½ÓØŸ´îìì,¿6|øpY·Ëì´¯¥c×“né¬Î7¼Âo‹ÆP.ÐqÕ8£ÆþÚúo,žOµÉ¨FáØ WtüÅAs†	­UÒzm?Öío\ùº†íÅOz[<ôèUê÷i=/åù”9þwÞyÍš5Ãßÿþw™ß'íS®ŸrüƒF×®]Ñ»woy6'iŸ¼?×åææ&¿O¹ Š¦Ö~ï‘û‰èq£ÉÝä¼Ÿå¼ár¡û#íÏv”cx"<ÆMÜ»WÑ¿ò{›Nï'ëµœk#kÓ¾eªgDk•µúþÝ¦¾_˜ÿ.D{À¢ñ[”õüäûI÷Ô÷Ó¸ŸrýmÛ¶•s}”ë'S¾ÿÓO?•š3fŒôÿäýéŒ>;;;ùuòý2P|è!~¦E«Ž÷Mûuz/Œ\CLg÷‘æiÞÖüiÏûµñˆãYóQ´oJKŠQš»“l«ÔúS<Õ ½ITŒê’’xW|­òkùôcSß/Ì²5ù‡ý#5ºù¤z/Ï‹/¾(uOš§œó)¯Ogò‘ ~½ÿþ²ï'oO:'ýS¾	&H/@1úý#FHý·ø¤áµ_/ï‡‘kˆé#ùzÝyÿ)kì‘Ÿ²©ÉIÈÍÞƒ£û¥¨4ï¯þ/{ô—õ¨îÈ»³FÈzdä*¯û3Þ÷3LmÈöâ‡þÒäÝ¥ŸyöÎ‹êõü”ã§~Ÿú|%×Oš'ý“÷'¯Oã{Ò¹\]]e€ÆùäH÷–––ò¹->iÏß ï‹‘^€ö’çWÆþÔÿÍœ‹Í‘#YKeÿ¯›÷§Ÿ¡}…T_€ÖRÝ!ò´/}?ÓÐhÚ³mžzì¥–¾ÜìÕ;Úëù©ïÜ¹³ô ¤uÒ<išæûííí¥ÿ§1¾rF7ÅúõýÄãÈñ~ÛzÑþ}o¤0n1ù{eÞoòj;¹ï_ÖŽ˜ˆ&Sºkô¯¬/ õÃMEÿÿ²ç@¹Îàu+ñq Žï¯:ßÇ0õA¥öL«ÆO¼ÒrÑ[÷ÖGê½<Ôß÷íÛWæöi}õñäïi\¯ø}êÿIóä	è{ä÷»‹ñÂ{-;ÜS¿oê÷Fó¹†XT7ï¯<÷ÉÉ=dî€òˆ´—ö’¨äûÛÏ5õõ3ÿ½TiÂ<ý·ÖK>jÙúfGõ^òñ¤uÊëõêÕKöùŽŽŽ2@çrP¿O)7Hy€þ"6¼ÿÏÎFkßÔïEïSöQ~PwÞOÉùÑ÷È#P¾€öÒœ"yF“»kk¿˜þ_S_;óß‹Þ&|À‹o·_Þ¡SçrÒ>ù~òø´¶‡ò}Ô×?^öýÊZòÿVVVrnà½Oï÷M}ýF¿_F®!¦Ç¤{EÿòkNª3ž±AÉPþ`ßÏÜOªmÂ¼üÎËz|Õóæ@µÆ)§Gk{hnO‰?üðƒôû#¾úÊ¶ù¬Fí›úzëå=«Ãb¥¶—êq™ÿ§x Œ((Þ@Ý÷û›ú:™ÿ~jlÏ}ú××>übiÿï(ëùi¬ïââ"“æ)&rmž9>S__ƒ¾wFzÝï“Þi@^àaµ7¨XãË¾ŸixjmÂ4ÿ¸Ûâ!C‡ß¶Q¯ç§5½äÿi®O5Ç×ÿø'åù;|ô¿ ûJïy#Öë~<A¥~_E?S_ó¿Aí™VßnýÕ¢¡ÃGÜ=ºb/åi E«{-^lÕÄÔ×bÒ÷ÑÀ5Ä5åÕ}¸©¯…ùßÁà&bÀßÿi¹ä›AV7‡Ê½<„çÿ
ï¶üô€ÅS¯¿mêë0õzõÏ¾Ÿ¹ÏÕDøÛÇ]wùò«Ë_tí~ëíÛm·hÔ´©©¯ÁÜPyãê«óý#MýÚ™ÿ-ŒnMZ<ùØ+m†<ñòN>ÓØÔ¯ßœ©mqeßß>ÑÔ¯—ùß£ŽíAÁ¦~íªÛO¤3æ7¨¦ÃÜ/¸ÕsÞ^ŸPQýyÝum¦¾˜?7Ü é[CLÞ š©ïæÏ·lr?Qûb•øôã†ø/L}ÿ0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0Ã0þÂãþ            85‹      ì]XVÙE§Þô<§gœî™çèŒ3

ÖØÝ­ØX4*a!¥(b „€"-HIw§ ¡€Ýëí}îáÁ˜Ò‰û}û»÷ïûß{ÖÚkïsÎ> TðLE·Ãnj²}D§©è¨E&;JFÏ›ªèªvVÑQ}KE§Ã3*ºêô^ÅgUUè=uÆ›zN?'¿Þð<:ªHßÝAéóÏ©+ýžüyõú¯é(¾[÷QM­¾Õž·šâ{e»ßùi(Î_éùFÏ¯áõhøûªŽ›:?¥Ï‹ÇôÛ:¿òü”Ÿ¿Ïï6vtÔêßÃÚk$ß/åßSzM<Vœ{£çw¿ûÔÔãÆŸû-Øý=ìñãû¡ðO¸Vû‰[ÒõßO…•ÐóÛè:Î¢{¢F÷í=º_ÍþÅÿ¿øÿÿ‹ÿû\Ç'Ç> Ó¦kCv“®?a¿=Û-º†GÈRé¹tß&Ðýú¨>ÿÅÿ¿øÿÿMãÿ×´É?ÍÈ—«¾LÖl;Ý—ctß ð?÷g¨hÿ¬àæÕJº7;é>Í¤÷´£ëü>}æ™ñÿ/þÿIøÿ[mºª/‘ýL¶ˆ,ŸîËm¡ûµ	ós‚Êœ¶d´×nÇÏÝ%;A¯§Ó5Þ¤¢§:IE·ý·ôø©Çý7þÝšÜš=îø+mÿ@ü@\Kþ\uÙ	÷äóç¶ñ3öû³~€ÊÌÖÄ?J¯ñsè©úÒÞÞ×…ìc²ç÷ßùnÿ‘Þ}÷Ý7‡Ï~öÙgÐþE~ý“O>yû7Þx—_xûí·_üðÃùXæìædÿÞ7ÅöÂ¿®ê³d]	Ïnd'Içßþ~V4×m‹úãÝ¥ƒñ¬éßAE«Tf+8€õ€nû“ôùÂ½;é†9´o%â·ßsk.(ðý
ïÛ¶mÛž0þÝÀ;6lü˜1cLš5k–ÁÌ™3uV¯^mliiiµ`Ás333{{ûezzzKæÌ™£½dÉ’¹ZZZ³Ç?µÿþ;uê¤Ö¥K—ŽÄ_¾òÊ+-è7žzýõ×_VùòÂ?ÿŒS]ÕoÉLûyÂ§3¦g“¯×úÿ5íž› ¹k4œæâ“_H´!øŸx]h‚Z-Ð¸£Cážà]ÕèøùÇýÿ¢›Œ÷gÙgôÑG¯6;khhôÓÕÕDX¶!l¯Øåëë‘]TRRR]VVVpðàÁÃ§OŸ¾vüøñCdÇ._¾ÚŸ:qâÄ¡3gÎ\>uêÔ•êêêò}ûöÓû¤¥¥å†ïÜºu«‡••Õ:â‘9Ä)#‰[ºÏ´ûôÓO¿hpŽÛ˜âƒ¡ûgNÃÉ.
ì³ï'Œ?E1ÀÏöÓa»>%ÉpÊÅps¼mÖ_h•éßJ0»­”'¹Aµs´'-ÐÞð?›·%ûÏƒOäßM±ñµz‰µ9a½× Aƒ,^¼Ø’°î˜œœ\ZTTTräÈ‘×¯_Ç¥K—.Þ¸q¼ÑþšØîÜ¹S{|÷îÝz¯Ý¼yó¶||íÚµâ‡sd×é7®¤§§—GGGGzxxx¯]»vãŒ3úöí;ò»ï¾ûŒbˆ·Z´hñŠŠRìñwÙþø×íð<a”bvUÂèq‘ïcìÏ }¯Õ˜Á¬@xí‹GÌá"DT`sv$´Ðjµ&þ£¯.áŸßÏš€cæ©à„È%è¨™‘õyŽ3þÝnÂÏ“–á‹/¾hÝ£GN¤ÛíììwïÞC~¹‚¶ªóçÏãÖ­[w®\¹R‹ÛÛ·ka{_|+oÊ¯)†7úþzï#^¨}|îÜ¹kG=EzáSñA0Å«è\'¨ªªvüæ›o¾xé¥—ÞxÐŸý«l{üëjü‡ðÿ?‘·±»ê[öëÓ¾Á0Ðuùüø•¦
ÿ¿³8	»JRà^•	>ãe…—¢Ïî'IŸû¶~^@§ýYÂ}ÅÛi?‡~‡óO?î¿þ¤lo¾ùæ;´½IþtŽŽŽî†Ü÷ìÙ“ž››[Á8?{öìµšš?öõÊ¸dìÊö°< ü¸á1ïùóÌü˜ù÷•y€“æ¸}áÂŽ'îäääÙ¾}{ˆ½½½ƒ¦¦æÔnÝºuýŠ6ú{é¸ï€ÿwÿš„G?Âé	WÆ-ùóæ¤çÛØNÁ’˜íð,J€ga<6f…aé×üø§À¿4C¼¶ b+Ú9háE})/Èz€û„Pät:àñÃª<~¸Aöòã¾aÜ÷å—_~ÒªU+UmÚV®\éB˜-..¾zøðá³ŒsÆéðZüñs¼—±(ûiÞË8V~þêÕ«Âøó„U0Vù;ø9âñÝüÌ1üœÌÊXçï•S~^>~?ÇüY~Ž¿´Á­ÄÄÄÂ;wî¦ÿd3xðà1íi{ùå—_Üý×lü«·'\n"|#ìß’òý?
ýÿ¡ù0L÷·‡cz\röÂ™°ïûÔ ‘pÍ‹ÆŽ}’ð¦ØÀ1=ã¼—£å’Aî§+rƒr<À¹]ÕsdE*zj*zˆÔÔé·_xÜ—áOÜ^iÝºõûäG>,]]]cÉÏï'Ì]¼xQ`Ž±Ä¸b|ñó2æÛ|Ìïá×Ó¼?vì:þÒæ(,,DAA’’’’’‚ÌÌLÄÅÅbxP,Â(bbb@yyy sûƒ‚â}öéâ;ñ†8>'™_ø\d~‘9@æ~Ÿ×N…„„dÐt?~ü\55µN¤s>R©ëk|â·¿-þu5ž#{OE·#ÏïIØd?ÍX%ü¿6¿'†¸™aU’/œ2öÀ1-öÉ°IöƒMŠ¿à€u!Ø’¯}	=˜ØÃEÄ‰ÐZ‡ï­'á%Ã.—hµVè6Ò"Özj×ÿI¤=VÐãþt_½ô¸/Ëµ½úê«¯½ýöÛ5jÒªU«Ö…‡‡ç———_&ÌÖ0–÷Œ/Æ6çèeŸ*cŽboñ¾'N`ÿþý(++CjjªÀ2c;   ÁÁÁ

‚››vìØ!lË–-â±§§'6Ó±‹‹‹8¦Ø^s——üýü°k×.øúú"44T|ów~~¾ø-æþíÓ§O¬3îë|®ò9óžÏ‘õ†"FÀ©S§®GEEÑ9èéé™¶k×®ÛÇÌ<ðÄÇ_üw|¬;áo-ùàCµãûHó7×UC«Õ“a¸gœ³Ã±>sl“ü±2Þ‡âý°NÜ;â€µéÁpÊÚƒmù{I$#ü`"«
á¿?«}1Ìm	Z.‚fÜ/ òßÔÏh·¿L¸/%üÐÞ”ðß‘Îço|öÙg?’ÿ½téR7ÂTážqT#c†}%ã„Mûì{ù1ûuöËìÏ“““&ÞÙÜ	ÇÞÞÞÂ¶ns…»»;(‡ËÖmØæê&°ÏÇ›	ëÛ¶mƒ+=·Ùe=ïN°]<v¥÷ðgø;øû¶o÷|àïï/Œ‡µC
ý~vv6(NaÿŽ“'O
¼ËØçÿ ãŸÏŸ9‹yù‚ßK:¤rÓ¦M{LLLh(r…Ol.èï‹5òýj÷«ù‘cúy\ïìŸð¼q7¨¯×Æ¢hlÊø_•°V±^Xçk:vH¢çCá«x/˜Ó{×¥íF@Y&â”"îhÅ‰ÐÛ½­¬'àY½
m¡;8«µÔÇ Í%¸Dø—´€n‡Ád_7½ò¸/ÑoÜžþüóÏ[’æMþ~ù¿ý¤Ë¯°Ï$(°Âø`“ñ"ky~âhás³²²æÙ'ïÙ³GàbkøùùcÇNxyï=iïA>ÝËs;<¶{	ÌowwXÞFØwÛJÀu+áŸŒŽÝÝ¶Ñk„}æ wÒ^ž„y/l÷ô–t}§÷Î]ôÝ>ô[~BøøøÔêú?BplÁ¼ÄüÄÚ€ñÎÿƒMþœk`ã×˜XGdddœ#]¬©©iÜ¦M›oU¤±‰OÜö7Æÿ;dcÈ¼ÈNÔÎï!L>kÐ	?¯Ñ‚qø¬§˜ß‘tþŠDXÄxbY¬·ðÿkÒ‚Éÿ‡ÀŒp?ÂÓÝ6`ÂÎ•XM:9 áXb”Àw
l“}1qçr|½jž1P—òƒ<~û¤þæ€Ëted»UD}]TtÕÿŠ9#öe/wêÔ©ùûÕ„×ý%%%gY33ÎÏœ9SëÙd?É¯3.óŒ§øøxÄÆÆb÷î¡çY×ûæ‹~ä}vùb×Noìò!¿ïéÏmðñvÅ÷ÍØåá¿í›àë±»ÜÖ!pûø{¬Ç®mkà±~Nðus¯ùmw¦÷o„·«3|<6ÁÇË¾Ï]˜Ïoø’ØE¿Ë¿-ô‹Ðtn»Aq"##¦Eî¡ººZøzþÊØçÿÎÜÆÆÿ—ù‚´Ì9[[[Î¼üòË_>î›×pûãÿU252i~¿b¼ß)W÷‘åpLö±†5áÙŽ|ýrÒþ–„ÿåñÞ„q?ÿ¤Ææ?_>/wãún1)ñ†Kn"ªò‘vò ’‰8>XåŠ®ôðŠIwI(Æ]ÀÚƒy@WíªŠ^‡D2Â?ñ“úôÜ÷åz˜büÿ’ÖÿœÚò"ÒÒ¹¹¹wÈ/Ö0Æ¹½Ëí^Æãž1Àx)**øaÌ3žÂÂÂLØgŒñž1èï?ß]ðÛá† ]îÜé‚Ý^¾köîrB´ïz$:#9Ð	©Aë‘º»7 'Ô	9aÎÈ
åãõÈ
YL:N^‡´ µH\‡x¿õˆÝµ‘;Ö Üg=öìÜ€@Ïð÷Üÿ®ðßå-¸‡c  Â~[H(BB÷.	CDD„8oŽ8ç(çXÇðVÆ??f~àcæ<âŒ»Äw•léÜ¹sÿ>úèãÇ}/åíoŒ®ïñ:ÙÅ˜¿" æ÷µÅóF]ÐqÝl„8“æ÷±ÿ
Žý“(öOÄêdÌ	Z‡Ö¶SðNó3¨Lù
¯vÂÿ¬'/,Çšô „ÌAÅqGöcwEÖg„bñÊ—+ÆãiŠ	¦‘˜þ]]nPÒ¨VØ«¢ÓqcozîíÇ}Éî·½õÖ[Ÿ¡ÍÜÜÜƒÚònßœGç6Ï¹t~Ìí^æn÷œà<=ã%!!a
_)éýÐ“¿òóFH ™ÏV„ûnFlÀfÂùdìÙ„Üpì‹Þ‚²87T$¸áPŠ;Ž¦{ápº'NdyâTÖNÚïÀÉ,/œÉñÆ©ì8ž¾'3Üq<s;Ž¤¹ãH²%º 2a+öïuFqäzDì^ºÇ1>k¾cqÂ&„ìrçàïƒà :ÇP„ED!<"tî{÷îÆ<Æ–““Ò?âZðÿæëÁ×Bùš0r¿!Ç...±3fÌ0ä1PtY9üXÇÿmñ/oºj_ö)îV+&Œ]—b€ŸD,ðú‚>äÏMaæ‚U‰¾¤ãöÙL#·¡3ùò;î¿†ÊDÂÿÄOéøK4'þxwÉ ôØd£°ÍØœ‰=ò¯àÿÒt,Ù»×ëáµy=¤93¿—Œc‚9ò8bµ[bÜ®ê:âƒqb>‘Žz‹Ç}ÉlÍ?øàƒŸ´µµ—z{{ó˜»Ü¶åöÍ8çcnûŠv.pÏþ‘qÏ¹¼¨½Ñ"žfÜ°ž	BxH BýÜà†˜@$oBvÄ6F¹ "ÉU©Þ8–á3ù~8Mv¾À—öáRq0.ïÄÕýÁ¸Z„ËÅt\ì«%t€+…;é±Ÿx|)ßWöùáJénœÏñÄÅ\/\,ôÅù\âˆ4KÚŒ£iÛP½…{dÿ5¤éKºÃovû{ø!<l7"ùEÇÄÖâŸãæ6Î2°ÖáëÁ×B¾|˜˜HÕÐu('Ýôý÷ß ëûXçýðÏqÀ@²­d‡…g<ëG4#øtÙhLÞeƒ•	¾pLç|_0,ã¼1ÜÓo-ì+åôµ¾Çóð²ñ/x–k…p_ßÔoñüœvøÜj4ÆzYÁ.9ÁåÙÿqGJ\‘)ò…Sé»[ÛNÂ3ú¤qƒÓd- ÷´»Aø¯¤s‹$üS¬Ò±Š®Æ¡Z¶lÙ¢[·n,--½©WUVVŠöÌÆþŽÛµÜgÆýòœ#ã~v¹/žqè½„ý(òû„ùÈØè„ d„mCAäV”%z¢’ð~2Çg‚p¾ˆp^BøÞƒ+ûCq­,×Ë÷ˆ½8.&Áµ’ 2Ü¨ˆ } ®Óþæ¡dzonV'áÖñ±¿y45'òQs4×«póX–°ke{p¹$—Ê"q¾ÐŸ8ÁU1ëPµaëè€GìõsF¸¿+öù bOá?1qñˆ‹OøgŽcKKK<PZZŠªªªÚëÃÆ×‡û9øÚñõ¢˜à†““SIª9_ý5çKÁßÿ¼éª¾MøšF–BV£"Ïñ§øü…yÝÐ}³1–F{’vÃ*Šýg¬Á×+Æ ã•4ÿ«¦=ÐÚ~::8éà›IøïÂ>ôYâ€1BeòWxk~oÒF˜GZÀ9;Œb‚l$Ÿ(GòñR”¦Á<Æ¿VxcAoi¼€ò<¡xn±Úu²,ëILò[^€çÀMž<yÖæÍ›3ÏçØ×ËãoØä14¼ç~2Î‹qÛOJJVà!IøÇ˜½¤™Ã‚°7Øq!îHuAþ^w”æføàŒÀ;ùôý{pµ,œ,ŒpŽk„a¶ëôÜuî¯îÙ®—‡¼ß<”‚•q„í<Ü:[ŽšSûpçÚ9Ü¾t·/n^n\Ä+'¥ãÛ5t|
w¯îÐñµ³ô¾jÜ¹t5çâæ™râ‡$âž=8ãƒ£©¨ˆÛŒü¤Ú#Îw-ö¸ <ÈQaÁˆÙ‹xúŸ‰ôŸùs_7â>Ž{8?À<À×ˆM¾~Ì£|\QQÁý•úúú«Û·o¯®˜ƒü§nÿüÿ‡l È½ë¨]øç>{òã\ïãkŠçg¬…ub LÂ·¡‹“>žãa\K<§Ó­l&cøvLò]¡Û—¢£“6ZšÁ³üž‰ŸCeÒ—ô>U|IZbèvs¬$	:„c¥ìGÈlÈƒñÊÿVkâ½Ž°1‰xDä®©h«VÄ¨è*òºíßú³/Ù566^±k×®JÒñ5ì¯ä6+·aöcÜ¶Ù×1îÙç§¤¦Š¾<ÆBlt$b#‚½ÛI¡î¤íÝPïŽêô]8™KZžð~¥”pLø¾q Š°!Œ}ø5Æ·l¥Œý0ÒóA¸NX¿^¹—ð^(Œ1~çêiÜ¾|wk®àÎK¸sýîÞºNðæÇÅ±°›—[7ˆnÑãâ9Ü•Æß½}]|žŽ$^¸~·ÎÀÍãù¸|0§Cp4söG:"7Ø‰~ˆõß„(úo{#BMÿ;…þ:á?½–x¼!#àë$_;ŽäkÉüI¼YC1Ñakkk¯N:õ¥Ëÿ§öÿåñ¯«ñiæ73Ÿ¶¿#lOöY;²N„!žŸßŸl!'Ðû.Ióÿ~VÌçm‡×ôAg=ÌpÄ¨íVh¹x°È÷±ÿÿÀb(zn™‡É„}­ Lò[QÞè±ÙßXOÀ+ßs®_ä¿Ák&=I'èC+x=lR±k*Å¥H<ZNZ Ë(¶èEzã­Eýµ†ÚHñ„ÜO åjè\ÈÖÑykÒÿø™ž{þë™+âïnÞ¦M›>Ë—/w£xýçìÙoq{eã¶+·aö]Ü¶¹3öÓÒ3šš‚Ä„xÄFîF|¸C]‘»w;Ê’¼p,ÇgŠvãr)ùõ
Â{E$á~/i÷HÂ¼l
Ú¼VŒÅ#™¨9]‚[ÿ.°NØg¼#_^{|ý<½~AàŸ÷wé½wo\p—tÀÝškuv‹ì6ñá^ÞËÛÝ;·é{ÏàñKÍ¹
\¬ÊÀéü@ˆsA^5Rì‰6"6Ô±{Ãé¿' -5™ Ñ$®çYÉZ€¯Ÿ|=9^âçX?1g¬Y³&¼OŸ>ÓÿÌù…iüëvâºÜþû®'<ÖÖŽŒ4´ª;Y(a(š0KÇ¹b®®ŽjM]_ Tû§ÙÜŸðÎ’èà8?ØNÁszR¬þš)ay½6FxY`â®UÐôµÆŸ·sFyY¢ß¶øyíL¼OZàÎ+h~AzàKúÞöxwé0Š	æa^Ä6xîK$PŠ¤ãe?˜·üh„nD»53ñ‚QWi¼ ÇÌ#RN€µÀQTW5‘öNRbþ +ÉãÕŸ#:ŠÚ`(µÅ›<þ–qÎmSn¯ÜVÙø5îÃç¶••-Úza?!&’pï‹”ðíÈ‰"Ÿ²“p€äç/•’o?Mz}/íÉÈçk€¶«äó¯ˆÆ5z½æt±Ðõ·ÙÏ3î	Ûâ˜t¼ÀæÕ3öecìËVË¤Øn*sÀU…)8@Ö	ÌÂêæŠÞƒ[W+Çpíd)Î…¢:Õù»mêoø Íôßý‘Dü—––!°ŸEºˆµ_'¾^œäëÉ¸çëÉÇÌ£¼gEï»ííí3pà@W_}õ•?aÁ_ÿºêÍÉÞ%L ü¯QÔñ.$+#¼T““jõ¨qÝ.ÔÖù›#º[äñ¾!ûO“ÎâúWL»‹|ý³zêøŸÍöXLx_Ž1„ù‘ÄÃ½Ì1ÂÛ£wìXŽAÛ—@c£>>Z1Ïð|€­¥ïœù=iƒîhm74ƒÖe„"¬2é§*‘}¦•ùbœQ?S¼¹¨b¼€"7Èš`¶œµ9&Ø©¢£>‹þóÏ*ºÞuŒŸMÔ¾êÑ£ÇTŠõ“Éçßæü=·Q¹mÊ¾ŠûœÛç<_Nnù:Ò»É	ˆBr„7áÞƒpO±sn.ì§xžqÌ¸?#Œ9@˜Œÿz@ø'­£*7f£æLáü„d—y²ž	ÿ/¬\;§ÄÊpI2Æ¿lÊ:@æ%¸{»†…€ðÆú€íúÔ\¨Æ™ýÑ¨JrEÞžµHò#ØíŽ¤èP¤s.07_\#¾VŒ™øºòõ”¯±lŠë{ƒ8 Ô¨Qf-Z´hù;Ýã&·¿.þEß~_Â…Y¾¨é££Êuüo+êø£¶¦¿<çW`_£ûƒ„³™mêæòrnŽ^oFŸùÀb8i|cŒ!œ3þY!.ìaF¶C<-0ÔË
ƒ¼–¡—›9Úm4ÆWö3ÐjÕhh,ïÖÔñâÒ3Ûâ­ùýÐmó<,ŽÛ¿òL$à1CÌ[²#0'È?ØMÃ:IõÆêÕúYªC,´‹ZýW'úß#	ÿÿWñ)Ó3dÈWW×<Æ>·IÖªÌr›äçø1·]Îk1þóòò‘‘–‚ÔÄ($„ù 3ÊÅ	^„û`œ-¦x±^+ìFíö•ð°¡ˆt~u*nŸ¯¤ø»Räên_:*â{ÉŽK<PË§$pU¡®*ë€s÷à¿–î«”9àf-ˆøàNƒ²Cwè5Ò7HŸœ)AEÜd‡8"1À‰®ÉN¤%Å!›â£üüB‰kÇ1_G¾ž²ÿçcöÿlðc??¿cÇŽµz÷Ýw¿¦ûô‡Õ“ùKâ_Wõ)òéßÓž×îÉcêÄøÞvŠ9>?*æáü¤¨íËóó¥z=ÍH4'}ÿÃÎh1¿7Þ 8üã®hÆ\0å+Á-HtX7ÃÈ·³Ö½Ã
Ã<Í1ˆð?ÐÝýÉ¸Ó1ñ@_stu³D'WâÏ¥Xì¿îÁ¦°pŒïh@eü§Põ1žÓ&=á0SÖŠ>ÆÀ²Ä.AqÁž¹°O	À ×Exoé <Åç*xIiAmµ*ú¿îd3é±*YË_Yƒô)ž³>lØ0£íÛ·—‘oºÃm‘ý;·CÿrûØ/’Úp>ù±ô”¤Ä„Ö÷FñZu†?Nï#_AØ®Š'ÌÇ×âÿzeLÕâ?ºÿ„ý‡RpóX®ÈéÝ¾xDÊá_<Zg÷á€&uÀuep¸''p½ÔÔ˜ð ¿ïê‘ÏñCñÞHZƒ„7¤Æ…#+3]\3ÿœàë,_cÿüçTøZó˜Á€€€#“'O¶~ã7Ö#üÝ¶¿þ¥õ;H÷·Gû(ÂÁ¡ñuú~öu¹uÅü›fŒwÂxÒÙo/„–ÃðÝjMt$Œ·wœ…÷-†à©¹ôÞ©_áýŽhe;ƒãc¼­0ÚÛRèþažKþû¸™¡§«ñÀbLð^
ÍæB¯ ÷ší^…È${”g:À/|	º9Œ¹ •±ŸÍj‹7A÷Í&Xå
¯¢DÄ*8 â`>Üóc± ÒÝ(žhÁ}…â¿ü¯®¹”¸Kÿ›×)ä¾L'ÚO¦kñÙ£pÀS\SwÄˆÆ^^^ÈŸßaŸÏí®!þëÚe‰h»ùä÷“c‘å‡¬½^(MÞ…“…¡¸TC:?×«þ…‰|}l}h¨Dˆ¾øšSÅ¸Ezú6ç÷ê™ÿ—Ž*iã’ÕÆ§”x aN@Y\¨ËÔÆ÷Ñâ€: àÑ T_èÎmÜ$îºX™‚JŠ	2|—!%Ø)ÑÈÎLCáž¯£Œqù:7†9Öòññ© Xýæ›o~öGÀé/ˆÿçÉçqNß‘ìÒº]¤ÛÕ¿êxÅ¸Þ^Ø-Íã#«áølùhŠå5¡JXç1}Ý7bÛ"ß¾]œuñîÒ"ØŒø£¥ùPôØb,4?›À>½µÂþ/ÛÌÐy«F’¯_²®Ñ+±.j…°ÐD[”d9"7cì÷X£Ë&#|´r"¾·€V¦ñ²Ö×P™ü5þ£×ßÙLƒ¦¯-V'`gqŠà´±·ºë3wc¢Ï
|½ržã¾BÖ&¬˜äñÜ‡¡«VIÿŸëþ»‘}$®Ïý·§¸æµûy?·3öIñ/·ËE»ÌËÍFzRÒ¢|»U™8·?Š´>ùûjŠÙÉx|M­	ü7ÅŒý½¸É}÷çàkþ‹‡$` ka2þ> hL4ž¼ÓhNðZ#9Á›÷Ä9€0/òw•jÞ­ÁK'p,7Å‘àˆ¤0Od§'ˆë\\²Ÿ®si=žå½Œ6e­°{÷îÓ|þ{Ãé/ˆÿO©Í/$Ë¢v_#t±K§Šçºá«QB»÷Ýj‚®0Àméê…FøM1û„+Äøü‰>+ÑŸ^ÿÖz<ž7ÔñÂ+&=Ñ~í,ŠõÍ1q×JŒ¥Ø8éþÁäëö{“ßï´•ñ¿:¾ˆM¶&ßgÃùö¨Ì³Ã©Â58˜»î1¶ê½m·,Áxosl³€»¿†¬ê§9¶GZ`zÒ#Ð8Â8Üî…\{”´À±2DU`Gq‚˜sÌ\ÅµJD< æ(ú	çŠúwÈN’eöÝUôTgÓõ¹_âæÿýï_0`€ž»»{cŸÛšÜÎ”}’Ü&%]PŒœìt¤Ç‡!=Ò%I~8–ŠË„çªDÂ~nJpƒp£–dÛH,GØÏ—0ÏØ?_EØ§ý…*Áµ<ÐP\lÈÇ›Î	^m"'xã~9Á†pMP«šÐwïå;7/ábUš˜·¹{’÷¸“vŠAA~nm}9À¦Ìr}#¾tîPŒV:zôhó×_ý½ßNüëv Ýßá5òyý¥zª¤˜_Z³«¹n¼¿tº:n—‹þúIÜ_·k&ø,þtÒ®U˜îo'êúŽ£÷tX?ÿe=CªÝóÅ<No,ù}îïãÜßðíæBë÷¢Ø¼ë62WŽÓ‘+q$Ó·³íp5Ý7sìýkp¸ÈëbV i†ÞpŠrÀ™bœÍwÄ*|°¸¿À¾Šæ—"FyÙô´¶›ŠQ;VÀ<~'¼‹“¤é' æP6e‡aŒ×21¡¹®<^ •4—@æi}¢Š5êê×_Ÿˆëï¾Ð³gÏ...û³³³ö¹5ŒIëòÒÜ/µ9)H!½¿é8µ/×ª’$ÜWK{ýê&8 àÜÀÍ…ÎÏTà_Éå€:àÒCê€«ÊøWæ€¦ò—1'¨Ì
üs­B…Ý%¸z,‡2üdƒä ÈJ
§kÎãIc)åXå<«2þyÏ¼Ì9WOOÏŠ¼ðÂïª(­“ò[¶¿þ_%ãñ<+ÉJ…þ­Óÿ^ ÍßÆv†¸“Ï%,!ÿ;ÌËC¿ƒ…‘Ž÷²Â8ŸUÄ«1ÊÓ’âÙþùÿ7ÍúAcƒ6FQÌ/ð¿s™Èûq®¯;a_}ë"öZÛÈåÈK·Auìjdí´B¼›9
—ã=w¼Ð¡i«±"b9l#V!>uÎmDQÖ,
\†6ŽÚxßr$>3ëM:â=ÎQ¶Å‹ÆÝñƒýLÌÞ ·‚8$-£x€8 º^E	XÈs‹õ¥óåþYˆµ
ýºªgéšÐµ‘êëpâÚ¼À3:uëììœ“™™y‡1/÷Iñ1·9n{u}}ÔÉ?	ìÇ!7Ö•Y¡¤÷I·W'ãÆ¡d1ÖþF-þïåë÷p ë¯[ aœuÿ¹ƒ
8Ø ÿ’ÕÅ‡ëðÿÀœà¯ìl*'Øhß`#9Áz Gp^àDÁ„: 5È‰´TŠò³	ÿ„ýÊªÚ1<¾‚ïó1ß¹¯•Ç’ÝÚ´iSa·nÝ´è~¾ö{Àê/„ÿ/¥ºj	d’ïWôésNŸëpuÛ a„ÿ!îKÑÓeÔ7š ½³Â6šBcËBôr[‚¡žV¿[ˆõ~>_>ÏrŒMðCu|k3‘´þ"ÖœÓçœ_WÂ~7Šýõƒ-‘šm‹³ä÷Óûk­æÃÒÔWÎG”‡9ò¢V"?Õù¹v(/r@u¡²3ìá¾<W@}ÅÛÀb‡>¶LÆK»Ký#ZBerk¼o1C½VÂ&9eH&È>]…½UEX—¾ã¼—áSŠqžb¼ÏTô_r_ælÅúDb¼ƒ¢±Žê<ÂW•ém?ýæ‡VƒmllûÜ®¸=Éø—Ç§Éã|*©=VPÌÍLØÏ÷Áá¼p\(§8ÿPªÈÕK–\g¥â%ÍÏ˜?W¡°ƒuÖP(ë€Ú8àÈýs‚÷è€S÷æé¬Ë	ÞzHÐ0µ€¼Qq¶"ûÂ¸&#2ã‚°¯0·Þ˜ y|%ßº¾ViÇ\ÛÔÚÚ:FCCc¡â7×•ýKà_ø~µAŠÚ9ÈîJù~i>ýkó{áG»iè³eÅýÐu³	TÐv~\§ŸÈ~^o µÆÐØlŠ„å!Û-ÅX}u'¼Kº¿ÙÜEŽíM³¾è²QOÔý`­0ÞÓ´?ûÿ	;–Â+ÑçIçŸLX/‡E0Ô6ÀŒºÐ×1€ÅÂyp¡ç–ãñÃÝòµô^Ä¤®†a°ºQ<0žbÏh¥Ù#0Â£œ¦áeƒ.PGñÀèOÈ¯Mz£-éíÐMØ–‹½$+Etu!¼
ãa¶×•þ«1÷@Éÿ‹ÿ“Æ/ˆ¼€àFÅúDí<^òƒñâùq			·åq{2þ•ç©HVƒÔó²RIØ/HðÅÑÂH\:Hx>’†‡Ó”8 1üßËR.0^Œ§¯!Ÿ_s¶\Ì×¹u®\¡šÐJp¯8ÒH>àØ}bÓM÷>lNð~}ƒw”tÀ¦8à}ÿeœ+EqÈj¤Sš€âÂÂ?¯>\oŒµ\+‰±Ÿ­KÈã­###¯.[¶,ä‡~PSùó‡ŸxüKu<Ú“­ùn]UÔŽß%ü?gÔ	_¬ƒnÎzèµÅIcëæuÑ“p<f«>¦ºêc2Ù˜mFèç2]6™¢§«9ùÙå¤í¡Ý¼`ÔYôµ=«¯N:|šß;†8 ·»9:“ßçþ?»È(/°Çål{ÄS<±|Á<ÌÒÒÃ´éz˜9SsfëÃÄÐW/DÊNKŽ³Æñ,[ºo6Ø’°÷,ƒÓÞUÈËXƒê'ìŒ±ÃH·…øÔz>X:_›uCK£Ÿð”Öwh>ûg|h9ˆ3E{Â£(ÑÄ<nˆóîyÑ˜´ßÛLÆ‹|îœ˜ñ}ƒü *ž™òÓ™zš‡üjäv¤Œö)umî*Éåg§
ßT”èOØÂ¥JÂô‘t	ÿGdüË–ü``ìË&ÌWöË„ÝªÇup®!þ›ÒŸ|pßàr‚÷ô(çëlLÔï'<0¥Ñ<N`ñl JH0÷ò=ç	óž9€5€Œ™üýýk¦OŸ¾öË/¿ü^å7Ôùàÿc¡cuTÓD¾_§ÿOéuÀ;‹àg{-t'ÜwÞÈØ×A«5ÚèMØŸ·c¶†,„¸v‘m^£¦äb‚®ôq·À`Šï;Ó{…P¬åñùŠÑèÇ}Ä=ÿÝ)¦Ð'ÿ’c‡ë…k`…5&Ð×–0¯C@_×z:’™a¥Ù<x¬]„dÿe¨ x <ß¹y¶(Î³ÇÑ‚µHN[ƒ…»W¡ñPâ—…¾‹°=xn€ÏLèÿý*¾Â†¿àö30•|Å†ì„Wå‹Ü@Å»ö%‹1ÄÜOñ¡Å0Éÿs½ûÀuŽ§ÿ„V3úÂq‹óž_’­4ñÏù¾º9½GPEú³0'YŒý$+ÚKØOV`?½ŽË: íÞXàü'à&}îÖ™ýd¥bL¯ÄåJ: ¢>üÐTß ÐMõžk²oðÁóäXàúCæ•ò‚	àRu:J#×"ÝŸ|D| JKö	üËó«™˜›9ÿÇ˜—ï!×Eß¶m[ÕØ±cMT~CðÄâ_Wµ¹¨‹Çù~]µ@)ßß^y~^1íï¬'¢#iåŽNz¤™uðãÚ¹è·QK|LcÊlœ)Ú‚“.ØŸ±¡{-a¹kF»š¢7iú~³÷Ú¶ßÐ÷<Ãó~æüˆ·÷Gû¤Ü)ö÷´„æ®eðL´Áùâµ8A>ÝÕÚzs´É÷ë@W[Æ††056¾ß@ÏºÄÚs`bd„µËç#œx¦2ÖWp§Ì×Ê™nƒ¹AVH:c>Ï%K_“yà¾¶£É·%ü!æ4ÓSÃGËF¡¿ÛbQ³Ø£ {«
z¬	Gö‹5	ôCñƒí$</¯U8­Þ›¨ãf¢F…rÛ‘ç¤Éóx¥¹éÕ(Ê£÷Ä‡`ùýãEÑ¸RMþýha^¶ô: ­q Ì‡SPs²H`¿ÿµ ¤Î> ¨Í	6ä€c„êåÿöœà#ÍPÎ	6Åus	îŸ\ªÎÂþGd¯GNRÊK÷	.>rähmí æ ŽÓdß/Ï+Œ‹‹»ckk›ùóÏ?Qù•k<Áøç¾¾ÎŠ|YÝXþŸ…=c¨!jxòºŽëtÐfÍ\|a«u³`îc„´x+œ+pÂíŠ àHp,5•{p¶p32–ÁÖo>qÀ|ôr]*ìG-¼lÜEä ^2é†Ïm§Auña}¬*
q.Ýa[a¡Þ\L<Z3æPÜ¯K87 üK08ÀÈ€y€´ i#Ú[ÌŸw‡EÈò_Žóv¸Q²™¹6X½«"V ,ÉU„ýÜ',#M êl€WN@kËhcÖ-ô”ò“ºÄS“ ég§ìpI+EÜá„TdaMZ †¸›á-³~xq\Œ6šŠ=áa¢ÍpíM™X÷s®I¹6ÍþÂ<d%ìAaR Ž’ß¿R•ŠšcYþ6Ä¿ÔË4Ì	$RÌŸ‹šÓûÉJk9àÁ:à!s‚Õ7ØXNðÌCåï;_àas‚Mé ¥íüÁ4ïq@z°#
Ò÷RÀu–ŽüËµÖ8GÈq cŸs€¬çøžÜš7o^ð'Ÿ|ò³Ê¯è|‚ñÿ	™a?®^¾Ÿ|?çû__Ôÿ[=	jkgC•|þW63ñÞŠ)èµAAq£p-Pê‹«i8¸WOŸ N—G£p«xâ÷.†ööyèBxVß²ßÛÍÀ+ÿmÄXáVO†ËB,·A~‘“ø¾ôK`e¢S§cÊ¤äÿg“Þ×&¼ëÂØ@OðÀ|âùÄlÆÄú¤8>˜g`[ËùÝfŽ‚°•(H±Fj†ù\;œ#>¨Èu€=ÿ‹«þ·i	&y›cKˆœ|æ ÷ªþx†ûû†½•Ißâu³!ÄY‹1¯;¶æïEÏ+<y i'*°³8“¶˜cÉ4ìðß%ü„ÜV¸íp€û—öKm¬¼´˜|Oòp¤p/.ö¹f–lõ9 n:'x“øçìKø/©Çõu@ùÃç/T>bßà½9Á:pŸœàýæ<lN°^ßà&tÀ]Ü9Á8ì¶FzÈFe'áPuU-þå:‹œàû)ãŸï'÷Ýz{{Ÿå±A-Z´xÿQaöDâŸ×ÏÖUý…0ïIv†ì®Œ}æçuÇçËÆˆ9síÉÿÿä0Ÿ®šŠ7–ib€ód$.ö» ¦(’pU€Â}GPY}O] ØTí@YÊR˜x¯5A«õóðéÊ‰Ò:ß3Äó¦½ñÝš9Ðô±‚oÚZ\)ß€ã1+±ÉRÓ'OÆøq“1uÒtÌÖšEúŸ4€®6ù{‰IIÀñ€‘¾‘Ðœ0Ò7Äc8YSLàeÒ¸Õ¸¾opÀ%¹¶X²ÝÍÑÓÃ
Nv8µ9‰+ ã:WÔQ™ð5TFHð5ž3ê†ïí§c¢Ÿ-ìÒ‚r0©Ç ´(+Ýœá¼u‹ðõÜNdüË5*¹]Émªê`rÓb‘KØ¯Îã\_šÈÕÉ5ò$È${€8ÔRD?öKîá Ág‰ææ›ìü3æÜ/'xŸùw›ÒuZàÔ¾(Qk,#Ü¥…98*j+žõåûÅã4dü³ñ1×ZtppÈëÑ£ÇG…Ú‡¯¢«ú-áÜDQ³C¡ûÛ‹œöÓ„Ñ÷—&ß??Pûok?ß“Vÿ`¹&^³œ€!›f $Ý(sÇ…Ì($Fg#,®É¹§pààEÜ>V"?—i‰Å>úøi½>±›ƒ7–C3Î™kµÅó‡ ËÖùX·÷mÀ…,;„mœƒ™S0fôxŒ£‰i“§þµ ={&tæ’ 0d- GZ@_âÎI< kí9‚lÌMFZ :Ú—rìPšcÏ$kXF®€]ä*D'Û£,Ëañ¶˜æ½ŸÙÎ¤ÿ=_Ìï„wuÛàé™ßŠyÊïšG§-¦ÐsÁ¦Ìl	÷‡ÃF'i-+E=:ÿC2öåZ½GŽFQVŠÈ=Ì‰À…ƒïçîsê8àhÜ7h¨è=<§§>öe-°ÿ!tÀ¯È	þÁóÏ	>â|ûäo_9ã¹AÈ
²Cv´–Ó}:U‹^SïÇoò}å{ÌtK[[ÛówÞáµ†ºnÈ“‡Õó³5û/*Ïïá:/™tÇgV£ñ½Í´&Ü·¶Šo‰Þ_>ÿµA„ÿÂ4òÿ[qübrX,ÂÂÒ‘˜TB1<µŸÙ@ÅTd,‡Ù.c´^«#tÃsÆÝEß»ŠÖÏha93ƒ–#oÿÜØ·i^a¦7cGÅèQã1qÜDLŸ2³gLÃœ™Ó1w–ÄzsfC_{.èæ×¯˜˜õa@z€÷–ŒE^ n‡%
bW¡„8 ¢ÐNŒ!>gˆ$˜Òyts[Šî®K`ºk1ÖûaÞæ	heÖ™ÎõP™òžÒÑÀç¤_FnYc{+øøîªmr;aÝÈ¹~åúôû÷åöw£,sÎ–')p¯ŒÿÆt@¦RÐHNPÁ<ÎGà¿Q(¹7ð09Á{ú«šÈ<™óÐÔ|¥±‚5ç¡*ÉY»×!?5‡ª*kñÏõÃùþñX!QoQq¹æ"÷xxxœéÛ·¯é£Ô{bð/Íë}™¬»büêqi^¯ŒÿvxÖ°3Þ]2_®˜€ïól¬¾^¥‰–Ë&à«qøeÃtG/ÆÍ‚õ¸å‰ÃqØ†)±¸Ppm©ÂMˆ_†¹^¦øÚnž_4ÍfýMÒ×ÚÑÖQÛÓ©=»âl¢5Ö/ÖÂ¨a#1pðHòÿã0iÂLŸ¤	­©“1súÒÌ3 =k&tgSL0G¡HyŽ	˜Øæ‹þBî#0&-°ÚÂ~„Ý¢°¸AZ kpyÿ„¤Xcv€¥è‡Ð÷_‰”Ôõ8™ë„Ý‘èç8	Ïéw‚ÊäoEÁs¤¾Ñ€UëD[PÆ?û~îçW^Ÿê@y	rR"Qœ‚S¥ñ¸~4[äê„ÝÃõ9àA9AQo›â,®Û%Ù½øo¨:'xð‡Íh8>è×Ì¸ó°9Á;¸z4eÑ[¹gŠs’pôÈ!ºg§kñÏÜÍq¿|ŸÿÌ¼ÞÂ¢E‹¢ZµjÕéaa÷áÿ%²ŸÉ)j_Þcüqs½Žøï‚¾ødÙh|µj"Ùa_“1|Høwù´]3ów"+i®Vnfºá|º'.gï öyãF‘r’m`¸}6à«ñh¦G¾Tó²oÅ £€¨*ß‚;¥ÎHp#m=eúõŒ~‡cÌ¨1„ÿq˜2q¦Nâ8`fLB<0sfÌÀÜ™Z‚tæÌ¢˜ô¤üà<C}ÑG åaL1¾¢¯Ð€8`é|cl±Y€´–8•²í‘•mç˜•°]†q«q<ŸðŸïL546¢…Å8´¤óý~ñ/øR[õ&ˆu6¸=°qÛà6Âz‘ÛŒXƒ‚ìÈ¡jdÅ#?y7ŽÆâÚ‘lÔÏ«ÃSÐd,P_Ôœ,PÂþ¾:Ð4­”8à}ƒš|„ùMæÄ÷ô>LN°¡PôÒçÎ”Ä `7ÅQ^8X¶îÛYÂÿqy­1î³á|ŽŒyÒ g§Nº²E‹UGø	Âÿ‡d³¤9ljgjç÷ˆ¼¿*^ }þ>ÅºŸ/‡/VŽ'½;Ÿ­ƒ/VÐããñ)qÀÇ+ˆ¬'¡‹ã4,Ü¡¨sT¤Ù¢*m-ª3q(Ó)	Ë±Òoz9ÏÅ{¤ž6è&44÷µ7×Õ@ÿ­³‘˜¿¨tÁþÝ–Xn4£‡!üÂÀAÃÈÿ&ý?VpÀdâ€)š@Z`Ú4Š	¦cŽÖ0èjSL ;Whc}‘˜oh(âÖœ”Æ‘00Äª%ó°sƒRƒ–¡0Á9¶È¦¸ zŸÎî[ƒè$[Lò²ÄgŽóÑÎÉºÛ`í9Œ„Ã†µbÍö2þÙ/pÿ1ÇŽg¨:y
¥E¹ÈIÁœH\ª"MOØçõ1n><('HÏ×Ç~h$¸_NðW÷>lN°Ið ù÷©!r«©œàÃÏ¸uù$¥º!3ÈùI!8z¸Jp·¼¾*¯?Ìý8œÿ“j®Kk¬qÞÇÆÆ&¯M›6=Tblð]ÕççÝÈÜÈN’Ý©íïãšñú¢hi5
/#4ÀÇËF
ãõ{>'øŠâß/)ø˜4Àû–£ðÍŠQæ<‹wêÁ!p>ƒ`uÀ<Ìp›‹Ÿl'âÕ…ÑŒ´¾Êäo¤]³Bë5šØH˜»T¹çgÎ¤û‡€ž=úa@ÿA6Œð?j$Æ	ãÆÐœ0“‰Xpß€kiS%à˜`6ÅŠü ®ŽÈrL`j$åLý„œä±CÜOÀ}…6–¦r]Šâ:Ÿ"â£µ8UbmÑËÐËÕ?nZ=_+DÅÚ`‡‡/7ADd„ðÊøç1~ò:µÜvUDnjJÒ(æ¯ ½~LÂ¾0ŸÏ\ð«u áŸûû›ÄSÐDNðLc±À#Îh˜|èùMé€÷Æ”|ˆùŠíÚÉ”Æ8‹µL÷ç§âäÉ8£Xk˜ñÏyÖvò:k<Î‹ï»¯¯ïõÉ“'¯ç5Ÿxüsí:]Õ¯ï†Ò|U([s=u¼lÚï,†÷,G¶G %Ù–Ãñ¡Õ|Dœðéò±ør%Ådö_0í½.xÎ°+Þ#}üí²ah½r$¾²†×öA3òó*Ó~ ½ÿT&‘Ín‡oWÆò0”mÄùLG;êaÜ þø±mg¨wê‰aä°¡5‚9`Æ…ñce- à ²é¬¦0LÅ¬¤ˆær"/ÀùACŠ	Œ)&}…„ÿÂŒy#Ì#å¬ÍƒŸó‡­Äùl;-°E@òJÌß½‹‚-°'~5ò(.X³ÖnÛÝÄ½—ý?ëCÖýÜVÎ;OÇG±/7tŽ'îÏS¬¥‘_ß”u@=ü7¥êr‚7Iûß<Uô+8 ~,P?ðæ<Žœà#Ïh¢†È›8[‡‚ðuÈ‰ÞI1é>…þ?/4 âOÆ?ßwÞ[[[·nÝºŸÊÖ{ðÿÙ$²€ÚšÝµÖÏ†[,ìwÌ‡â‹ax×\²÷è¸¥Å|Hxÿ„4ÁçÄ</öMÒ	Íu¹Žn¨Lm%ígµýú*Z?ˆq±"gÆ~Æ÷h®ß-—ÇlßEÈÌ]‡ë…NØ°ËtÇ¢SÇ.øê[U´kß}zõÅÐÁƒ1|è`â€¡3r8Æ*´€Ðã) óÜ?Ày­éÄZ¬(àüàYÌ…±¾®è#Ç˜þÅØA]E^@× ‹çÃiÅ„{X (f%
ÓW#-s5Š(&8™o°]a¾ÊLè>y-JnÜ&X²¯àvÂÚÿ çü’ÂH÷Gábu–„ý“…R?½°&8àÈjÀŠ1BÇ2öe»?ü9Áë€ß%'Øä|&r‚µùÀß2_@Šj.Á¡¤mÈÚíˆ¢´Hœ$?þ‚¸§/^| ¯µÊ÷ŸuŸŸŸßEMMM‡çŸþ¾õ‚+þu;°ïW%s&;@vKªw/jÛá)ƒNxÉ´^7ˆ·—‘l	qÁÒ¡‚>°)b‚	ûï,ŒŒ~‘°>MªÑL®ûÍuùÙèµgˆ[^6îŠ7—Æ'ÖSÑeË|,°EqÁ\Ï]ƒbß…°7™ˆÁ}zà‡:àûÖ Ú¡+z÷êƒ!ƒbsÀ°!=b¸ˆÆq<0v4YŒWä&q^@â­i¬¦c®–"7HZ@o®BPL ¨×G`(!–æÀ‚´€—“2‚—ãHªî¯ÅÙ¬UØºÞ Û½<jï½ŒžßÃùbn#ÜVŽ?‚ü¬D¦„âdy*®³Ö?Y¤Àá½:@ÄMq@v£±€xcÿ¤dÔ ¿gßàC×i¨þˆ"¿f¾@9Aâ†+•)(_ƒ¬H7T–æã¬‚ÓùÞ^½zUŒåæ~¹°ñZË666ùíÛ·ïòDâ_WãiÝŽŸÎµó)d7ëaŸtÿóÆ¿àµ…}	ÿðæâ
„·çÌï2þ	÷<7æ=Ò/™ô@3^×‹üú3ôo.€—¢˜a(Z˜õc†[’và¹>\û§ëfcQËwˆ§ƒ¬±3ÞÅv8–´Ù;Mád6ã÷E‡öhû“:Ô5º¡WÏÞÐ¿?†ˆáC†`äða=r„¤87¨àM‘OZ€Ç
H}³¦O«ËÔòÀÅx{óÌ†òøA, ~p\1an¨ŒZ…Â 3¬³](0¯¼5û~®ßuùòe…ö?‡eEäû÷ *?—sŒ^¤ÀC¨¯%'ÈŸ½yªP²“©N?8ðÛæT>¤8~ŸœàÃÍ¨Ÿüæðvó"Ž¦{ ;ØVâïãÇjs€W®\€Çvñ½ç±€l¬]]]¯Œ=z	×||òðßé¿„ÿa¤<D=ki¹~Èù½Hxæ>?Æ­dý\@@:à±Á«z£9Ç3ZáiÚBœÐ™k¸ÌC×Múè¸~®¨÷Íµµl[(êúŽáu=v¬À /KŒð4‡¡Ÿü(¦>Q´·Pn¶³¡;eztí†ví4 ¦Ö]»ô x @0#‡£˜@Œ…	Šü æxÒÇ‘˜ ´ÀŒ)Rnó¢@Èã†Xés^@_1ŸHŠ„ 0{Ï76ÀÒùó°cÝ"¸ÚÀe“bbbêáŸÇú°ï¿té’h#ÇFAVögDàÌÒé'dL)x P‰Ä”ù¤<PÈZ 1øæœ¿_ßà‘FtÀ¯œ/Ð0ð{ÍÛ]\9š#æ
g…»â@IÎž=#ü?s<÷ñpþ‡ÛãŸ÷Ü¼`Á‚ä¯¿þšë„4:&ðñá_ý'ÂùzÂû!±&·Âï7#ì?¥¯ŽçŒº
ü¿bÚ›8 àa™à-³Á"x“´ÀkôÜ3¼vŽ¢Ž_Ë¥ƒÑ}³!Fz[b”·•¨á+Öîq7kzŒô2Ç˜Vb¯Á^VèÅó|]cúŽ¥Øµåykp£Ü	Wö­EUò*Äy›ÂÊh<ôêöÄªí;¡[çîèÛ«7 -0xFÈ¹A‘qÄRn`Lm_á49?8•b‚éSjy@[ÎÌåù„Ú0Ô“æ±X0Ï@â Òœœ:]3´ô`f0Ö¦Ø³gO=ü³ögßÏ~ñþü9”—ä#7%‡Špåùè“2æŠêë€MÄ“<žÝ@S0öAüŠ¾Á{s‚Ï	>lß`“9Á‡™/PÇ>_ ‘ºÂÊóD*ð2Näø!'Ô<fëÄQ\º,Ýc6¨˜\‹ÎlØ°á|÷îÝg©4±®ðŸŽ]uŠùÕ? ß?›ðŸ)û{ÙxœÏ3øQ7¼0¯;iú^xu~o²>äãûà5¼i6PØ«úáYŽùyì>ù~®ã£¶n¶¨‰Á5ü¸†¿X«x€ëzŽëy˜‹ßC<—¢—ÛbQ×oŒç¬¶Ddì*ä¥Ú"5ÝHËwÄ±Â5(4‡·µæŒ„î]º c‡ÎèÜ©+ºuí‰>½ûb0ÇCIç¼ ó Ç£êå§p< ©ÈL­iRL s Ç:Äz
-0Ï@ÒóDNÀPßPÔš:•â…Ù3°ÎÁFÜgÿ|ß9çÏãû¸M°_`­X™€}éá8[•…'eÍ]¬„=¥8 )ÐXNP‰jD¿_a=xäXà™/Ð0'ð+jˆüÑóöÖ[_@¡èù+\/$Ê9‘®¨*/ÀÅK—kñÏ÷šyŸû¸p›`zgÖ¬YÞ-Z´øæÉÀÇ÷çãÉ|	ûçÅ¿agŽÿ_0aè‰—M{áÒø¬óyÎ¼FØ~^¡xÞnsív¢v¯í¡IØï³R}Æ¼´ŽÏ±žÇ%àÁëy,Dm‹`ìkA×keØÐÞ‹‚–a¼¯,"W¡ `-P¾7³W#ÓÇvó'bäÀÞhß^?ü¨uõ_Ð»gìßCD^€óƒCëç0©6/0Aiì œÐÂ\âmE^ÀPWÆŠ1ÄFúúÐÓÑƒö}èÎšƒ¥Æsàï'â<ÿ¬ýyœ¯Ü&XVV”"/%Õ…’ï¯Ã•<&¯¡(l:p¼é~ñ:®Ôœ¬Ëþé9Á†ù€‡®!ò}ƒMåu¾@c9Á†óxž0Ë‘dä„8b_Z8Îœ>U«nÜ¸!Æ(jˆ6!·{{ûR55µ~ÿºêÏþÕçÎ„ûƒd·”±ÏÖŒðÿ´a'¡ÿexÞ¸ÅÄó{XØ›ö}ˆzR¬ ¡Xï¯Å}Ðm“X·kÜÎ÷ë¤ý‡*0ÏÆ± ×õîáº}ÝÌ`h…¼äÕ8˜nƒ­aËñËV3|½a¦ì\Šø[\)]ë6àÔ>GÇXÁk­6fNŒNêñç:vÅ/]{ _o)/0Bä(&®Ð"/ 34^?(ÆNšT›˜IñÀ¬™3jû
õçhkC_[‡âþ¹Ðš1Fsu°rþlØ­XT›ç‘ï3ã9¢²ö?{æŠsÓPÌqÿÁl\?±¯®dü+ðwòár‚5h 1æWà»°Î~µøçü.5DqÍÑ?b¾€¢VÀ…ýØj'ÖY>ZY^ËõÜÀ€çËã Ù8àááqaâÄ‰æ*Ô	ûÓð/òýêŸþµç©Ê1Cü?EúÿiÒ Ïò¶nøñÀ‹¦Ý¼Lð‚i<mÔEª¤Õ
Ïéw@kû)¤ï-0ü>¯Ç7xûR$?H¬Ù+a~¨bÏ*ÖóH1€‰Ÿ¼)ö÷ˆX¹>æh¿y!ºº,ÂÊ`+äP<P–³‘ø¦Ú#!Ãi6È^ŒuK§bØ€^¤ÔÉ:Q<Ày>¤Èˆ˜@ÁœTÎHc&PL )å¦)ÆÔÆÌžC|0Ó¦ÎÂ´)³`n¤g+m¸ºl÷Vÿœ–sBÜ&Ž®D~ê^TÆáò‘Ææâ7®îÉ	6Þ7¨Ìµø—?w²°¾x¤œà“>_àq¬9z[än¯Fu¼3²C7 4/	çÏž÷š9ÿúõëb^ ÇýÜÿ'ã?((èîüùó£>ùä“/#þ9ß?˜0¾ìhöUëa_˜~G47PÇÓÄÏë"ê]¼`ÂÐCðÀ3ç7ã|?×½'ÿÏ5úº˜ˆ˜Ÿuÿ íæ¢okk2ÆÙ×7ä ^Ïs€Ûb±¾×ï¥Ð§`ús±Î¯`h‰Äk”§ÛÂ?Æsü-1ÅÏ.q68Y¶¨Ü€s©+á¬½ICÐ­S¨ªvBÇ]Ñ¥Kwôâü`ÿ~:hFUÊ(ã†xü ÈHcˆg‹˜`Å3÷Ó1eòèl^¡‡M6&"ï§ŒŽõ¸~÷µk×þ/^ºˆ²â<¦EâDY:Åývd?ZW§šŠ>'(á¿°¾~h j~—|À£Îx5Du¾ÀC×¹+xàLa
ö¬A^‚?N?,î7ãŸ5 óæ< 2þ###y<à¡öíÛTi0'àOÄÿ„Âù~²	óuþ¿û
üÐW}O“ÆŽôÀóó(&0î†çŒ»ˆ5¼ÅZ˜d¯šö„šãlŒ¦aùþ¾nKD\ÿYW^»o1=·X¬å5HIRðÂ0ŠÜ—ˆõ=Õ·,ÂŒKá·w%JÒlE>À”p¯±uñÊl^…ÃEŽ¸T¶ËÖáF‘ÊB–`ýâÉ>°7Ú¶í€6?v„ºzWôìÙúõyÚ˜`ÄpŒVh	cFAs¬¤&)Ò¢˜`Æ”©˜<q
&Ž§ø`êt8,ÕÇng89XŠû«ŒŽû¸˜Û ·…Ó§N 03‘tK,.Î¯ß—v_ÐDNðãë°ß4¥ˆÿßc¾Àãª!ò{ÍPÎ	JùÀ+‡3P³9‘Ûp¨¢¨þyÏuÂ¸]Èm„µ¡››[Í AƒÌÖøÃñ¯«Ñœì-Òþ	çÑd7‹ù›6Â?÷ïñüÎ°6ùþY?Šz@¼–÷Â%ûýÁžVèAØçµz'z-Æus»n•ÖîíãZ_ÈÀ1@o7^ßs‘Xëg&Å .a+XS0‚ÞÇ9CÒ1¤	fÙ!‰â‚ 4{¤­Ã9â‚“)«°{æN,´@GµNè¬ÁyîèÓ“b‚þý1lˆÔW8RÑW8nÔÁ¬&
`-0Ó&ibÊDMŒ;‘^›„…:³»m!‚·ÌÃ–-Î÷àŸëz)·ª¥ÈKÂ‘’\¾¿LaÊ<Pòð: ÉX@Á¢¯¯°ýßˆhüCç<°†È0_à×½IÿáXºr÷8aÖ^\¼pîû5qïYÿq=gÎ(·Ö‹³fÍòã78¨]/àÇ‡×Éú9‘U7ÄþƒñÏ:@Oéu"ÓrýB÷ÿ$êu½½x€X#Ws×JŒñY…înæP'œŽõ2ƒmÈRl[J¾›õüBkÖ}ëýÝ%- ô€ÿýÜÍp¼0Ús	fÌ"¹´}Žc÷ð•8HñQªÖìY†©~V0
]… t{œ)vÄÍ|{”í^gó©˜0¼á¿3:¨q_á/èÕ£iþ<x bÜÐPŒ9¬n¼ Ï'?FŒœ0nÅl0}òl]©Êpsl\;×ƒ÷U¾·|¯¹¶ß{nœ()ÈãÅÏV‘>gßÏ8¸ÿcûé ehD(úûë½WI÷7,üós‚OÚ|G\s”ç\¾Š#Ö#/vNŸ<†«Š{Ï9 ïÉµeüËÀÂÂ"ÿ›o¾ùEEi,ÐŠÝäûyJUKÒùd—Ë÷=ØÔÑ\WâýŽ’ßùþñ²i±^7¯å7ŽâþÁÞËÐÍ•ýø",
\‚ÄDœÎ^‚}©ó±6tÆyòúfè¶MZË¯'Y?ÂµÈ6@±Þ7ó@gò¹ê.Ež€û}£V!7Ù¾¤&ïX53ú}â™½Ö8´o-j*qµt=JVÂÇYÆ3Gb@ïPïØ;vE×®=Ñ»w1nˆµÀÈaÊy‘ÄœƒáÃGaØÐQ˜8n<,Œg"ßo)òÃÃjÕ¢Ú±]2þYûsÜ'ãÿÌ™SÈÏˆCEn.-"(ùÃp¯ø•9Ác~îÍÞ«jdüÿa}ƒ’üë¬9Êó¯TÄâ`¬3²Â6£šb Yû1þÙX².”ãæ‚­[·žîÝ»÷lBfíúð0þß!¼#‹"»$ÖíSÂÿÃa_2ñ^×Ž±?³5i5|k=Ã=–bÂ.kòZŽ_X÷»/€žïøE›ãp–°ÏØO<k
¯HLÛ¹€4Àh¸,}ÿ}ˆ+ú¹I˜—sƒÀóì;“fèÂëÒsz»Ìa¼N!Ë Oº€×ä¾ÃåAVHN²AI¶=bIø¦Ø!1{ªrìQJÜ°BSFÐögtTïŠ¤ú÷í«4†XÒcFÇ¨Ä†a@ÿaÐž2áMp1s56o5‚£C-öÙø¾òZ|ÿeü©æ¼—¤’öß__ŸyÐp|@P/'XÐþ•´ÀÃê€ß2_ ä^ð»Öùƒç<âš£bJ ]×#‰‘²%Y±¸tñB-þkjjÄx`Î	Ëøˆˆà5ÃnL˜0ÁAy>À‚ÝNóózÝ½ï¬ûÕùüFò}ðýl¢Ÿ€×ûä|ÿœŸðîÒèµÙš¤ùÇúXöÍÑqËLßa„€#Td,CfŠ7‚x\LrÎåmÄ¹Ü%‡Eþó0ÆÓýÝ$=Àý¼gý?°pœÀ{Î/LðZ‚©Þ´§Ø —"¯¸ÀßI«q*ÇQñ« ï+/´Ù»•¥N@µ3®dÙ"Þ•~wîhôëÕíUÿÏÞ[€Evïã¬Û»ïvw¼»ïûîîwËÅlÅTîî»EETìNéî,P[ÄÜûÎ3ó†\1ö÷Ÿë:×# ÎóÜçÜ§;AUMZ»¡gwò	z÷Qä
€þý Oïþ2`0f»¡‚¸DAb0¬-±&Bœ¥„Öñ÷—bÿ…¹ÈŒ?€òââþbïžL”ôÀ¥Ú: 1 Ü+Ð@L°Fí@#¾ÀÃb‚»_ NLðqí}|ýÍÝ9Êy€û×ËP¿Y»æ #z3.]¼ ðÿïÜ¹#ú?¸LÂÿîÝ»±yóæ¶¶¶;¾þúkÅ\Âÿ{„ÿ?T,ÕƒëÙÕñ~Éî×–Æñ¯ÂöŸ}~Ž÷›·Ç{®=¡6w²¨çEø@¼_k¹ñy'n±AQ¼ùèá³%m—ÜB{çÍÙä³¯Âƒtoœ ?_¾Û	f‘®d×e<_›x ?÷& brÀ¹Aåœ!ëÖZ„ÿ«<1›¸@~ÜTœH˜Š¹;üEŒ°Ýw8oDFÚl€ü¿Šæ“î™‰¼½>X7Ë‡ë‰Ø ÷hèÖµ'zõêM˜ïmíÞÄú`€^8™ŽÁ±Õ.¨Ìœ…°-n˜èaÅõœâ,%üs½'sÖû|öìûe§Å!?å0®•V.Éãßõé€Z1Áº: 1ÁZøWæM	þýÜ`‹Ìiá~¦Ï‘ûœ ÷¯¦o@þþyHÙ»
e§‹ïÛÎ*ãûöí

ÊnÓ¦FËâ_£É(Âÿ²÷wê÷ù›ŠÂ>çúäóÿyþ÷Ÿ30x5óþ`Œðñþ^ÄéM"¹ßy±Ó°fï>t\|*Þôð>˜yãÖáà‘­¸>7R=°ï|6;cü²û®ò|¡;ÙuáH9‚r=À1ÂÞ+ÜåœÁúÄ	ü‰ûGí—Õ­óB§P7÷ÂâÝÈN˜Žâä™8–0ûÉÈÍšƒó‰!8¾Ê>Ä†ôÑF·N]É/èµŽZèÐ±ÚªÒkõ˜0|¶Ì±Bé•”äé0™o	koaû•ñÏq>k	ÿÎ—’ï“Ù±¨¼_}¿ø¯­
OL°ü×åµ~î	ô<•£µ_ ²nnðÁQ|³`NF/FòÎÅ(ÉMF¥þ™p@ÿ,sçÎ-ïÒ¥Ëpù®°–ÁGÎõîªñ«©â÷+öýª‹=·½—9Â0j:ÆošŽ>áþèJ¶ß`­3VîqEúñ)„ñM¿ö$Þò *.ôp†Ð¯Où‹lóelKF~|îeø¡$Ñ«÷:
.Àþ@wy? ç¤¸@_)G(=æôçlÿÇ¯õ‚i¤F®–Õ%0wG€¨%Î‰ŠÕû‚`F>Âä-þ?6çræ 9³qî ?6Í6‡í¤!ÐéÑ­[«á§ÿSÅÿý®.êˆƒíÆáì>?\)˜‡¹{üÑÇË!³¦+ÎQòýy´tæü|º¤éqq®(UewZè€²û^Ÿx1Aî+ºP»†¸6h &ø¬ô<®£ÍíhîÎQÎþuUgp>.iœL>ˆë×®(âÜÀõ`–ðÏÏË–-»;pà@gy-pËà_Ídµ˜ã«Àµ>â_/0—íÿyÉFßú†îrmž…	$}#‚Ñ{•7<·¸#ã¸*Óçâpô>ôYUQwO?àý™w¡¿ævÙëóp=Õ‹¸€¼‰Œ%.Ð¸ Û÷îÄ8¨ËqU5sRž ×JY>¡ÝRW¨-uÃäuÞØz qÓ°çP0é´YâF¿Ïö¢(}®-À’S‰Ó°;Ü~ö£ ßOšjšÐêÔfca¨ndpÿá,L\ã
GC¬_Uÿ|¶ç‘ÎüfåMæ¤#+á *NeàÎ¥ÕwZÒò€æÄëáåÇÿ“	>Gý²s”ë èÿ})y5²÷-Å *Î¡Šp/áŸg?rˆ„æŽëÖ­ÃèÑ£Êë€^h!üóÿp’òºøWk$P—Èì¿š|ï§*ÞwÓA‡Ù“EOÿÈõ!´6ÃÖ`êNóCÖl$l„}T¾˜{Gàù¿Š‡\ä:àµiÀ/‹oÁms>òâÖâ~¦?áÑá{œa)Ó=Âdz —<6¨'·ÿÊñÁ^ò|¢Z¨+:“ïoDø_º; ëÉîû’oÀsÚþMèý‡CP”4ã§cEÌ4l%?%›t@î~_l$.àa¬÷ÉúˆšeŽ³Gƒ“6SÈö÷Z`ÁN¦<×µþ9¾Ë5·åg~ýúUä¦' 7ù®•&”ýÚËé€†y@ã1ÁZ<@Áê×	þ­~†b‚5k…ŸÜÎÑó¿_ vLðþmú·ŸÀ•ôu(<´©VãBÙ‚ÛwøçXÏƒ|F)`ddõå—_þ@HmÕBøJâBr¬:çß<<(Ó²@/Ù¨ã#·Þ"÷§I¸àšÞëá±}
vDOAQâTâô°ÿÈf¸oÉ@§°Kø˜|9ö%À:Þ{60!òŽÛdÎÃÍ4/:ìH\À£"œÉö»ŠAàz5sÌtåz€ëŠF®ö‚ÍX®÷9æc"¼¾7'	ë©1!ðÛâ‹Ák¼àL~B\úlÜ;¹ •‰S¹Æéá¸r$ å™³°ì`0Óß¯b‚‰®6¢îG:GÖéßå9Pþ¯\®@fJŠ2bpSøþÊõîÅøµsƒµc‚MíÈ®%ñ€Ú˜:ýÏßÎÑJEN€ÿîkY›pòèr$ï]†³ÅÙ
üs€c ÜªŒæŒvvv±ò}á/¶þy®Ÿ:‰—\T6OÔÆ¿:ªw1è€Wl4ñ¡».~f€ž¡N»­S0{O0öF£$iJ“—ÐëÝ0ÛP€ïçWA%@I0ð!	Þ›è†_CèžtœIZ‹¿2ýP–hK\ÀŽø»é¶í®¢—@ää±©nHÒýäyŽ°Nà#þÚg³	AnüT¬Û€Q«=D/y”/vÇMGyþ<ÜÍƒ;)ÓñWÊ4ü•3±ñÓèïö„ê|{tð6„½¯{sdüs|—ÏX†ÿÛ¸xþÒ£q2'•å|§OÖºÃÅð€‡Å›Ò/ ”',¯Ÿü­ÜàãîxÎwŽ> ß{#wÎ_”Ý‹Qœ§ðÿ|/xß»ò½á|±Oá?þØúr‹ÕÿXª½E¢IâD²¤ a.P;7X_Pªê «à\ ïí†oý‡áÏ9fÐXê‚«ýà½#ûc|q!Å·Òƒ‘·!Û“	Ã—ðÞŒ2=à'— ’©À¿ˆ´[ö Ž›Ëp<æ îg,Àµ/ì=ä¿Íöá(rûg.Àvõ@?åœôá^0ú’‘žðÚì‹°=XNb¿ÑGèýÕž˜»3 1ÇB‚hâÇ	ó©I3pøøT„lõE¿å.h?ßÝ'ÀzHs”ê~øŒ%û_væ2ãlA2ª*Ø÷?©$ñ€¦åïUÔÖõñ %»_žÕ h87˜Y?hVL°i¹ÁÂÎÑ¤K*ó¶á\|8Òv/D~Ê!Ü’× ñ`Àó ”ãÿì7N:õ|»ví†J_kÙú?Õ·	ßÿ%ÜçŽÉë ájú²: y<PšëÍyku¼éÜ_ø@ëyÖèá›­XzÀ‹°åkiþ¸œº»ïÀäÈü´¨¯Í¤ÿØ¹þ[M>˜ü
]{Sw¦ŸÝ;é!¸šâˆìá°ÁYÔpÝ_÷07Qg,‹TÇ¥š!öKçCÂ=0n­×yaÌOñ¾v˜\ÉöÇAQÜDí÷‡s”7Œ6ùÀ"ÊOô§ß©êL>ŽººLÀÌ¹³ëàŸç=IzžÏütI2áBqî\Vº«WêáõÆëÑÍÌ*óÿ&ÄîÔÇþ_ëxÄ£*Ëq+;.$E cÏdÇïÂÍ×øç:@¾#|W”yã¼yó®wëÖë€ÿÕâý?Bt$.ÐQ]Î¢HòI®=\¨ÕÏ9AÒ<ïÛ´µ˜Â3x¦ÿO3Œ êŠ‘þðßå=1Þ(%[~--±«°xwÆ®;‡?–ÞÅ[sè?HØW™¼2x—tÀ§ö+ Û-8x4×Óè‹to¤³Åô-Ìœˆ¸ˆØ ÔW¨³¢:OØOÎúÉ¿æ˜ç¹6@-ÔMè€à­þH‰™‚´˜`LÙêƒžË]ñÇ"¨óÜ’îÄe´—:£Ç<;ôqž„%¡Kg(ñ8®û“ðÏ¹¿“…yÈN:ŒŠÓ„›Ë«:UKÔÒ|xnPƒMãuã€õ÷(ðßœÜ`‹ÍiÁ~ª¦õðÏÞÊßŠ”uÈ&ügÝŒ«W.	_PÂ?ßöù¥{Ã6$,,ìNß¾}]	™ï>ü ö/’IôH‚H×ŸlˆÔ—ì(¯n/ã
. #vút Û90Â&›0}/Æx’OàC>ÁläÅoÄÂÝÐ¿/ ¯“xäÂÿ‡ôõ×K ÕUÀÈõ·0mÏò!öà/ò%*’l±ó€-œ˜¬äžBWt%_žó„lïu¥^9þ9FÐ;L†ÿ.ËÝEL€u‚ùËw`ÑN?/ÐXâ‚6‹ÈÞÓsWÂ~²ý½H´çÚ`€“!ÂÃÃ±k×.Å9r^‡ó;þ9÷W”›‰Ü”h\.ÍsbøNJ6ªy< ¾˜`ssƒÊ< ©1ÁÈ6lé~æì-¯lB¿ ã¿’ð)-¹û!ýÐz\®¸ Àÿ½{÷ÄL@îS¶6l¸¯¯¯?•PùáÃµxS°#‰ I©žÚ\ !¨)j„„À³yOØÏÄ:,q‚^„ì¶aS´Î¥ºâ¯Lo”%-Ãúý1°ÜX­•wñÃRàóÅdÿI>'üK_ÿh®Ì¶^Çî£ñ¸–A˜á…´cŽ˜±Å"É'pszÈs½”{
åuƒzòºb=y=1Ï%0&Ÿ`Òž;BþÄ2t#]¢CÒ‹üþÞËÑg™3zÎ¶Â`#‘ûãné¥Üëx>ëÄûò³R—zWËòä÷±:FÕ¨/Ð”˜`~¦Ä•ü€ç%&ø8vŽ*ü€–Ý9*ÙÿË‘È?°©×àâùRÿgüsm8Û
éÞ°Ù²eËƒ±cÇ.zóÍ7?yâø—é Žþ›¤ÙozÞEr¾y1ŽŠÞ šu‚2¿à‹2.à¢-Ø@wµ/L·bÖ^9êFø÷%ß~.ù›°`OFGV¢ÃJà?ËoB/H¾ZüHïµ'0xÓ]LÛw
9	[H£<É	»ö;Às“3†…3p#ü»ŠgŽˆØÀŠê¾ÂJ¹iA_òtùûéçXtYÂ\dBøï>ÃúÆ"o+áŸÏëþy·‡„ÿëô:7#IÌ„»~® ÿ×N×ä5&ø°~Ú<àQb‚ä•c‚Ï\¿Àß	6­_àýÜ­üm¸’±^Ô ¤ìÇ…ÒS5ðÏw„ïŠ„¾CÛ¶m{0qâÄ•¼ð©à_¡T_’ÍP3•×eÐ×—”÷€5¨/6ÐQ°”Õ‰<éžö©WüoÚ¨.v½Â6[‚°æ 
<È¿÷ÅÙäPì8|^ÛÏcHä´#îÿ=Ùþ/I|EÏ_“øšÞk¿°Üy»ŽÇàRz8î§#'ÆKw8Â"Ò	ƒWÉò…"FØÐ¼!yœgô^Îø'=æJâ½å2Ü³íïMü¿Û4SŒt4~›2þyÆ#÷{Hø¿võ
²ÓP˜q7Î)Ý¿Ú: )< ±~G™!R_^àyÀsÐ/ð¤fˆðï¼•·×27àÄ‘P$ï]ógKjÄÿxïRÆÿÖ­[­!üùTñ/Ó¯^¿%éA¯ÝIv’œ˜¨¬æ"6 ù`.@ï½æÐŸxÁï³-Ñs¥/&lÄ”Ý>ØÌçS¼Q•6…	±rŒ¢*Ñ™lþÏ„ùïûŸ’|Hòy8ð¤t¶Ü…Û¾2DÇG£*}>ªRœtÄ![œ0"Ü…ø¼«˜/ &‹÷Ió†¤z¾ò#¬ØþüÓ÷×Ä¿ºM1Áx'·Uæÿ¼ï‘sÿþ9î“¢Ì8Ü¸p‚îŸt÷äzàjC:àdÃ¾Àcë¨Çx(hZLð®Rà³Ó/ðdvŽòÙÝÊÝ,ð_½Lì9w¦¨þy60ÛŠÚø711ÙðÚk¯}õÔñ¯Ðj¯‘´!Ü›¬$I!i4.Pí4Ö;¤¦¤Ú‹‚Ýôðã”	h»È½Ã}á°-ëøöq…ô@Ibv9ŽàÝe³ù.4ïßG ‘.xŸä]Òï¬&n	ôÞv£³PžN€±nÛá ëµÐ\@6'€ët”j¥žÂ~<›˜9‚àþ.Bö—9¡W¨#ºÁÐÕ¦þyæ2þ¯\&ü§ÆãDv<n–Ó¼ªl{ªyÀ½Fy@q]_àqöÔ›|
1ÁÈÎQþ»*åøçÀ”=ËPzª þ¹N´þÿ277"üýÌà_¦^'ÌCÒEPå¸À…¦Õ>¬°ƒ<>Ø­ˆ[¼l§…¼á·9æèîÃ¨`øïòÁÆC®È‹óÅµÔ™8´£“a¹ã*´6 >ð>aÿU‚z+â/’x›tÃO›`ô¾?~çÓâ~Š+’Ûbúf'ŒõuóBdqi¶À þ«±_ÿþ†˜ìj[ÿ‰‰‰"çWÿËrü'ÈðÏwïXm ¨[kÌhbn°Ù3Dê‹	þ_ ¡˜`Sk„žë£WÅç ðŸµ'…5ÿfff›Þyçïž)ü+ô€êËò¹S‘Íä5/?POý°™¼^À´Ø3ò¡§þ7Í jKœ îÃMXvÀ9	n¨LóÄ¥”8zü ‚÷Å âü?Þ_' B:@eµ\H/´".ðó¶›p;œ‰¬dú¦Ì \ˆsÄº]°‰t"[ïŒ®dãÅÜÁ0™?ÐOÿa5ñÏ"áßÄÍ®þ¹ï_šõTÿ%„ýÚø¯Éê	6³_à‘fˆ<jn°	ýJ¾Ã?¾_€ìÿíÓ1Äÿ·Èz þÃPVþëáÿÿßHøÿö™Ä¿L¼JÂqcò	ÔN6?G¨T;(q³ê¸ÀKÖêbÇà§>CñËL3tYæ1ëýá¿ÓÛyàd¼'*S§X‡õÄŒv]ÁÏ×ÖÒ!Ç¸ü™Þû`ã=ôÜUŽðØh\IŸ‡¿R\uÔó¶9bôjäš!ÙŽŽÿ»Uã?¬&þÙÿïêowû:øç=ŸuðŸ–€¢¬òÿ‹«ñÿPðrƒM!rñ	ó€òÎÑÛWQU¼·ò¶
ü—0þ÷®À¹Ó5ýŽÿ×ÿ366^÷LÄÿš¤ÔÈ'àžB1C<Až+¬—4ÞKT;W(›)ÄÏ¼gè=×Þø.hþœoƒž+½aº)¡û|‘zÜW“½q!yÄ†÷Á³è¹ã6>Ú(³ý‚¬”?‡ËôÀw[«àx(	Iëq!urã‚I¿Ëm£†­tC/ž=Jþ Çþêåÿ¡$K¡ågØ4ü_¹ŒœŒ$fÆËñ_*fÄÕÕgêø5ëƒš“lNLP9ð¨1ÁÆújÿ?tç¨¼Vøþ­‹¢öWÿ£Œÿ•8¶¸þ¹?´vþñohh¸ò7Þøì9Áÿ„ÙOT,5Ú—7V±è¸NÅB­DÄöêí%j¨~X9G ùuC\3À;F>ð€Ÿ¦‹Y~ãÖÀk›/6ô@A¼®¥ÎÆé”µXw<Ã÷\Äg›þª«ä>Á;îAuGÜ¥"&)
—Óæ ã¨/6¹¡a¾Ç27ô–çû9î¯'áŸkÈö3þ»øÂ¸þ¯ìÿ_½z¹™ÉÈñöÿká¿I¾@sûZ*&Ø0þ›ß/ðOÚ9ZÍîÓïãÜçÿ¯þ‹ÿûÂQ^VRÇþó~ˆÚø?~übBÖÓ©ÿù;Kâê£	»HxèÒw«±ß±ù¾”+4i#zŠ¸nè—^øÆ$ZÏµ†6qÉQXBö;-Ö—’¼P–<ûcwÃù`!Úm»†W×ÿ%³ý’“é‚öÛ¯`CÂa {!*}1w««À?ïåz?)ç'IŸåNÄdøïêg„I.Ö5ðÏùŽÿ+ãÿúõkÈÏNE^F,®'Œ^+“ã¿¬P7&Øxn°%újcðQëê‹üÓvŽ*ñ€ªË¸[–,°/á¿0z9RDàâ¹35ðÏõ\+ªŒÿ¨¨¨#FŒ˜Ihúà9Ä?qõÏ	×jò¸À2ÂŽLÔÿÆs…Jó…9& Ïò×/ÙtÆû²~¢îa»1žÛ}¾ÏéÇ<q#9S—#2ö zï)Ãkä¶Ÿñ¿Œ$T–#èC¶?q+*R¦áÈ!ØGr}¿:/u…Ž<çÏœ_‡8?Ï2BØ×^â„.“aàl)z¸”í?Çt•ó7oÞ@ANrÓbpåáñºü5Šÿ†rƒMìhò‘ÆvŽÖ®ª-3&øOØ9ZOnðö‰2þÏõ™›xR­Ã¥çjàŸ{D”ëÿù­Y³æÞàÁƒ}Mï=wøW~ˆº¡ŽU,Ô§‘Op€ä$}}«yuÄr ÍPÎðÌÑw]tðCð´]h‡.+¼Å®±™»ü‘pÔUÉn¸>¢0ù@!~ ¿_e}h+dòù¦»>šŒIíÏM.dû¡µÔ]CeøçšßÞ\ëKxï¸Øí:@u‘:/rD§@cŒ–×ÿ)÷ÿð\'ŽíJøçÙ¯EùÙÈNŽÁ¥2²K×Jká¿–/Ðhnðqô<Ê‘'lù~Ç9C¤ž~«gq«p—¨ýgp9cr†"ýè&\©(¯QÿËûÀ•ûÿø…††VõíÛ×žôÖsµV„YÞ-ÚštÀh’y¤’ÃUÍ¯”ç”gŽÊuÀæªxÅVïøq­eîÐ_ ‡Í¾X½Ï…±î¸Ÿê²Ô¥X|ì(ºì*Ç+ÄXúï½€ã‰Q¸à…;l1p¥4—:ìk/“ÇYÈöë,u‚á¿ÃB{´_dõèlŠ¡“¹g£Fût<ßMÂù%ÅÈJŠAÅÙ|Ü¹Z«¾¤>P_Lð™éxÔ˜`c¹ÁÆÎQþÿÝ*Ø!¤2o;.¥mDöþ¥ÈŠÝŽkW/×°ÿ'Nœ¨ÑÿÏvdÎœ9WµµµAo<×øW~Xj~BøïEø÷!üî%9Er·þaãµƒ*¢@).ÀsFLÛ‰}äï¸êàÛ ‘ømŽ%:‰\a æìDæqOÜMvÅù¤YX|/ìŽÃêð)DÄÅ™¤¹H8ä »u6„{'1§¨§ˆý¹‰:a-y¯ÿ¨.ä8Ãc£=#l¡½ØmƒÍÐËv""##kèpîéâÞNþ«n“®?‰L²ÿçOf7‚ÿ–ˆ	>æ~õé€fò€gf†Ècî û_UrXÿ›„ÿò”õÈÜ»9	ûpãæõ:óxæ2þ§NZ®¡¡1˜Póê?ÿü°ÔxŸø ÷ñÎÁù$Ù„ÿû×6¶wL>_@pÙrQ;h«‰·]ûàûh.qÆpâîÛ¹Ï)G}ïsP‘¹
²"p>u¢}´É	ÂœÿïgÛï†N„}ÕENè·Ü	AQ®ˆ;â‰â
»Â%ÒÝf›¡»í8¬\¹²ÎüævÕóxÞs)áÿ8Î¥ãö•R9o<÷p=PG(÷Ôö‰	>7ýÏúÎÑ†úÎ‹ßu«`§\dø/KŽDêž¥¢÷“÷€KøgIKK«1ÿ‹_{yyüòË/]TZrþßÓ|Xª}B¢CL| Žž¯6½^ nÍ€¢~PÌRš=èÔ_ùÃ¯³ÌÈ'ðÀèÈ „ìBÌQT¥z™^(÷À¼íî¼Êpï&r~Œ}–ždûÕ»Ïï£G"ÌßKÆ½ŒE(%ÎsÄÁ‘&à<-¬qŽÌéŠ‹‹øg©¨¸ˆÌÔxœÌOÅ­ËgkÎ¡~DÐx¿@Ï©‘ljL°rƒOrçhc<àæyÜ>/óýv	p#oÎ&¬Eòžå(ÉK&?°zÿç‡¸N¼öü?[[Ûãß|óÍ„”—þ‘øç‡¥Ú{„Û?‰‘_°ƒô@qtÀÃû
…PôÉäÎØvÂ[.½É'õ%.F:Àmk ÖïóBì/l¤g‹õžbFXçPw…ÝïA qþÎäó÷sÄìmN„yO\J]Š=GbÃÁCÈOX‚SqŽ˜>ÓgÏ¨áÇñ9æååÕ˜ÿyíêUdg$£('	7+N×ÿ:: i¹ÁGïhl†Èãí¨)O±_à‘wŽ6Ò/@çÄ~«h/á·ÿ»p=gJŽ¯Fòþpœ-Î­±ÿGêýUÆ?ûŽ&&&;?þøcÞÚ2óÿŸ¥‡¥Ç†þ·~¯4ÌÓµgÊ÷ˆ9Äm…^xÃ¡;¾ðŠ?æ˜‰}„ãÖÃeÛ8o	ÁÈµ~è¹B¶Œû}Yh’ÝW_ä ½åöðÞä€ø£î88+÷AßðèvÛ3Pœ¸G×˜bút¿:ó¿ÓÓÓ…Ž—ðóÆäå¤#7=W/”àîõóÂf<\<<7ØR1ÁÇÙ/ðh1Á'½sT™4#7xõ,îœ‰—ñ~Æ?q€Jz}5k
¢W õP$.ž;[ÿ.\¨±ÿ‡eãÆ7nÜâÝÿó¬=,:~¦"›1’¨"í#m$.ØxÝÒÌ1sy½€¨!VE+ëŽxÛ¥þ3u‚È]Œ1¦bØº@ŒðC¿UžèÇó‰t\ìŒN‹`±ÆÑ‡Q–4«öFÇÐKx%hå|9ç>L7#jÝ,˜îÁu[5ðÏÜŽu¼„žý|¢0™)±¸XZˆ;×«kGÎš<]Ão}´"Mìx,¹ÁZœà™œ!òð~Ö™·ŠöË±/“›„ÿŠŒÍÈ>°™ÇwàÚ•KŠ]|'x7œòþ?–•+WÞ0`€£JKîÿ{’KÍÉ¾Hÿ7aúÕßHþ$iOÒ‰pÊ½Äº$®ô:†¾¯RÆãå³Âš¬êÙMÆñA+iÆ@;àÝ$o9õÀ÷#Ðaž…èó¶6Pì)¶ÖýWyÓ{èê‚Ñ«œ±f·®¦ø ùxz¯¼_úÀ!Û[è¼9è9/~A5öñ™r_—òþ/–3§KþËJrPuµLQ3R“<„ü­:Ági†H}õÏa¿ ÍSÇå¸ß#—Ý¸‘¿R7"mïrä§ÅˆÊ»`¥Ø¿òþ¿Ù³g_ÔÔÔÔ'ä¼Ìðy®ñoÙéÂÿW„]Âµá=d:É<’•$;Ãû‡èu*Éy’»5æ0o’?ðýdÊõ°VÇÛÎÚøß”±Ð^æ„ákü1|] ú®ò…Î
/wGÈVdÅz¡*}&6ˆÆ/óoCÅ•>p9þyG‘ð¢ßôsYŽÕkêìÿ+++1@	ÿÎCfjJòRQy™ì†¢n¬6¨/&ØP}PsrƒOc†HÃø~gˆH¾Àiñ¬*Øª¢=BøÏÛ3ñk‘¼wNf ²²zÿ7ï„g~X{ÿ·‡‡GÖ¯¿þªJèy‘!ôÜâßR£	ñzM=Âÿ,²ÁI2I
ß§H.œüv¨¹3„ëüÿ¬zï9ÆU¼ ˜5$ý=mDÍÀ«v]ð¿>´YŠ~Ý•>Ð÷Ã„HÌßí‡¬8ÜH›Ø£;1!â4Þ™z_¶›w”¹Éu€û]ü×bæ…†×À?ç ¹¾CÂ?Ÿ=×åf¥!?#×ÊOÉð_YÞ xZ1ÁGÝ9Z‡£>ào÷4¬Y+ü÷úN‰˜iÕÉ#„û½r‘é€JÒW³·£ðè*¤ŒÄùÒS¢\Â?óB®UÆ?÷ý[ZZîzï½÷¾"µb=¿øWû€¤7Ùý™$é„½k„÷;$÷e»B;È÷v¨žÿ%°ßZ†ùÉŒý?d¯Mþ”Åò»=ÚH/‘¥Ro±EÅœ­;âC÷Þøuê8Ò¶Ð[é‘kà²% ë 0a
*R’ˆ‚õÆl|» 
/Éø¿ØWH:àã#ð˜ZÿœÈÌÌTÄ ùù:éý¹ÈJ>Ž‹gèÎÝ`ü_TÒMá'&øÿ÷<¾~bÜ)M@Õ‰}2Qè YàbÆd#ß§˜ÿ¦ŒÞûÁuÿÊøŒŒ¼?fÌ˜i„ž·%=—ø·T}‘lúoôìK¸ç˜^eõ\9ÆYøu­ž¶ó­x¨mg¼ï¬ƒÝúàuû.x¿òïr¼jà%ÍGŠ	ÔÜU&Í %.`Þ¯ÚwÆ×¾ƒÑn–1º/uÆ°_8nDØÞ ¤Æúàb²?
âB±tO,D”ã³¹÷dû	½×LÒ1Ñs‰â,ù\Y˜ãq's >{ž	|öô)¤'qP&ª®”‰ž1ÿ: )<à!ý->C¤¹¹Á†óÏ]¿ }¶wÎ§‰U'öÖÁ%áÿ\ÊF1ó«0#×¯ßPàŸŸ97ÌöAÿsçÎ½¤££c@zM‚Òs‡KUòùU‰÷wIÏû7U¤>~Æ9ÛrÃ_e"¯ÓaŒ¾Fß­>ñì‡/}áòËÕçš¢Ãc|á3 /2F'ý„—è{?ñÐ#ÑÅkvÊê¯#–æ(ûmåýDñ®³6~õ6è³Â‹¸€/<¶xbû!7”'{â^Öt¤Çm‚ST6~Zt/­lOAË<´öYx¶Ç $ûÏÂu@Yé‰(ÊNÁŠ3rüËåfC¾@sb‚s†ÈÓîÈ¬Ÿ4+&ø7sƒµ}ú,Y×U Üï¯¶ÿJ<àzÞ.”Ä®¾ÿ™â<Ü ½/áŸûÂØ.(ãŸó ®®®©äûkªÈ}~<‡øì*ÇôçœVpmÆ9aíe²ÝoÛwÅ'®½ñ¥w|ã7ÿ†ÿ›:ª„õÎ¬Ð}±-ú­pÃàp/h-´Äg^}ñáóÂç^„Nh7ËßÑÏ¾çÒ¯ØvzˆxØüA%ýd*ó3^³ÓÂÇ^ýEñ¯s¬Å, Óõ>ˆ<àÒd Ûg“–aÁ®XôYyŸÇ&k±bU„‚×±ð¹(Î^æ\GA^–˜XQFwêÆ%P›<ÎÜà£Ô	Öîü|ç(}nüsU%‡dØgÀ ¸ZÜ*Ü‹ËäûçZ‰ôè-¸X~Nð>ép_Ç†kÙÿ¿Œ7ïÿ5¡è	NÏ!þ¿'Ì»’$¦î*rðæªxÝ®+aVÉ®÷^æ=ž«³ÂEÌÚ´ÊÃVû`ôº@Œ‹Á˜È 1wççQxÝVSøo;öD‡ÙÆîA$ÝY“Ï>Ÿ¸ëâUÁÆÿÃt@¥RŒtÂËôoþÀs þ;Í]—ºÁ`­7¦lwÃáh\JñÀÍ´ÙHŒ‰‚Ûú$´uÞ
×ày"î§Ì¸ˆë $îÇ5àgNŸDFJÎgãöµsxpób: ‘˜`“ûžæ‘ÐÎQÒÂîŸŠ&œc_Iäø¯,Øƒs©›ºo…Ø÷x•Î^ÿlØF(ãÕªUw‡Â;?ßRyñoÙ‘g€½KxÓ%E‘\•ùü²züV„/¶Ý]Ú`ÄÚ Œß0ã6„`ôú@ŒŽ ¼Šš¼I›¦Ã(j¦ˆ¿uœgFö]‡|…ßÈ÷ÿŸ’oÐ¸Áˆuôýô½úk|Ñc‰~6ž8Â ¼éØ/ÛÔÇ:6M(÷_¥x~‰8ËnzøwÐ8´&.Ð#ÔÆ‘žÝí†œXÜJóÆé„…˜¾|,¼gŠÒÙ²ð,ÖùÊø¿x±œ|€dä¤àúEÂäÙÜˆûÊ¾@Ä›=Cäÿß9*óèóàëíSGe¶¿ø ’¨æ„ÿk¹»PLÜ?åàZœ>‘K|ÿ¦ÿ<ï/%%EØéŽðë3ªªª:„¤W”aõáÿ®çáÝÁùÂ¯VÌón‹7ˆóÿ1m"¬ôÄ¨µ¾& ƒ"|1 Üý…øÐ×~Lz`
ôWû’?`"Ã¿Ño"ö÷‘{h.0¸gü_çO?ï‰nKíÑz¶	¾	‰O<õð–ƒVýÆê”æñÞbzÿUâï»÷Ç¦A}‘#­t…ãgDîsBq¼Ê¢}1kŠÏoQœ-?s'çeØ¯wá*Ýƒ¢ü\Ñtát¾¨~p«¢Æ\ù&ó€§6Cäqô´@Lð‘sƒôïgRuRŽ}!«E‰TþË3¶"‹¸FìnT\</ü}>sÖÿgÏž5ÿÊøgûoeeµóë¯¿æšÿ•aõáÿ?„-'’hÑÏ§˜ßÛNÄô¿$ûÜu5aÆ“t€z†º@cÏÒË"ž»á
íž¸ÚCÉèI¶ý‡€ax…1I:à5[ü<uùnÿÌ®öB¯Ü»ã‚vó,ÑuþDèÎÖ¾ºxŸ|øœAÚx~à©ŸHy1É‹6¢†ø¿áb©æbGŒ]ãŽE»ÜyÜÛCM°tñ<QË%ùÿÌõ8È>€TûÁw¢ôìiòâQ’Ÿ†›—ÎÊðKÚ+Ó@L°9ýÍÞ/ð4ú%&Ø@nP)~ðxúdÿ/þ}U'£E_5þ•ô€¸A¾ÿ™ÄHÞŽ¢ìdqæþ¥¸?Ûeü¯^½ºjÄˆþ*²¼ßÊ°z.ð/l¿Z?’m*R/¯ÔC¶“ãé­§OD¯¥ä÷» ËG¨Î·A›¹Vb~g[’vól ¶ÀšKœDî€p_òó½¡1ßŸïÁŒë˜ô†Ö"+ŒZ$¸B_úžîanbŸçˆwÌÞã…}G<fU—þxÛ¢>.PÛhdw¹”#ô€ÏPû‰Þsï‹ÿL™ …öÐw‡ãFgL5Æ¼Ù¾Š`Æ?Ÿ5ïäYo²]à2üs 7;]ì¼XzB`½ÿÏFL°¥ûjä‘´D¿ ÿ_øÏÎ¥á¶ÀþYÐµõ€ÿ·NÀåÜÈ=²
©Ñ[Pv¦DqÖŒ®ùá¹Ðl$üóý(êÔ©“!é¥ÚÐzæño©ö2Iîå·T+ù8E^½-qæNø1p8º.´‚öRG¨/´Ås¬ó–èI8¾ÌÂ¬1ždør;ô	u€Öb'ôóÆÀˆ è­tÃÓðÇ÷ÿ¯/þçŒ‰Ð'ßa8é •Þè¼ÜƒV{búÞ@fÌÀäˆ\æŒ!ãð‹i?|lÞoZt®ÿåõÖÈôš´“àkÿø™¸@ûùöÐ›c{?KlØ)ÎYÂ?Ç{óóóv€ïËé“Å‚œ.ÊÂíëçª9€’/ððÜàß!ò¼ô4Tö#yç¨\gUäáÎùtÜ)Kþ¾À¿B$=p¨Ž/p³p?J“£²r’âòåKŠsfîÏó 8¬ŒssóMŸ~úé7*µl??žüK¸p ‰ñ~‹jüs.ýS=´ãù¼„ûÎ‹ûøu–9tûk°l»+6ívÇz’E[]a·Ö	ýx¯ù½Vú ÿjÂ7}¯à \dÞ?CÎ~èAøïN>…õV?O™ŽªÌYHòÃLGL27Å`ÓIèb1?Yö•qû
ëÓ’(ÕX*õ&pO!é…Wl»O ‹/ýÆàifèé2ÓçÍPøy,|æ¼¤¼¼\ÿ7*q‘¾ÎÎHENz".Ÿ'¼ÝöÉ5—´Ô‘§Ñ/ðb‚üï,—é(Æý3q2ìŸŠVè€ÛÊ: p9w7ò®EÊáM8}"Ÿ¸ÿuþ9îÇy æþÊø_¶lÙu]]]BÒ›õÁë™Å¿¥j+1ÃCM—d³,Þ_½«ƒ_¿íÔ¿„Œús¨Ï·BÂ~ëÙfè³Èž‘ŽØ}Ð%É3Q‘µ2B‘—0;öûÂw½†…9‰>ü>«¼¡½Ü?Ñïy™ñgÚZÔþtXÀ;ÂÉ÷_í‹±ëý±úèT\É™ó‡Câ+SsYÀÒÜ
†6fèo;ZÄ§=ñ†ÅÃê”çÔæe¹BKy¢°TÇ›=èß6ß;ècœ«µð$_Ïœë½KJJ>!×„ñ½()*DZ²ŒÜºrNiT}<àQb‚ÏA¿ÀSÛ9š£øûîœKÅÒD9îÉŸkJU:àfÑœMÙŒÔ«
Òë\÷)Óó7D¯/û€ÊøçgGGÇã?þø£˜õSÌžaüs®¯³<Þ_P]ËßNÏàûÆw0ÚÏšõ¹øc–~œfÍ¹ÆðŽ´CÜ?\Î˜ûEQÀÙc@Y<î–ìÄ¥Ì%HˆöÇ4ò¥‡…9C;ÌKHë™FxË^KÄ þåØ?L›Õ¥¤'ûóMGQæ\ŽŸ†]KÝàje†	ã'ÃÈÐÖ–p´³¹ÆÚMFëÑø¯‚ü^å<¹lG÷¾hÓ	oÛh£ƒ¹>–,[*x¿tÖü:##Cø’_Èºàü¹2deÈHDE)a‹gÈ+ë 9¸ÿ8b‚O¥_à)ï­Á”0Ïzè|†ÛgâIä6ÿtÉ1¹8VSÔæ$·ÿ9»³É‡7àÙ~ÖëþùuVV–˜	Íw€ïËºuën1"Ðô~C0{†ñÿ‰áäpx?ïé"ì|àÖÿ7eÔf›@•lþ§NÆçÐ^`„-{\q;s6¿•Eq¸r¦•ÏÒ}¸—³ Gö{À<ÜZ„g¥ømº!ÞøÿCÔ
3Å š¡®pÝ=éYóÅï‹_ç	?GsN˜ƒq†dÿM`ea;KØÛX	=`bg=›±hm= _ZöÄÛ–…ínzíp5âÿ/ßYj£Œ´`ä¥˜ÊzŸÏžkØ°À:€ïÈ¥K(>Qˆô”xœ,Èà/å]’J9†}fæŸÊÎÑzxÀ“Ü9J¿OüœxÎ {ŸFö>IÌì»}*VŽûãòç˜úñ_O<à:Ùþ3É[r Ù)GQ~á<aþªÿ<–÷AIw@²ÿÞÞÞY:uê¥"ïõ«ïñLâßRõ’ntçW“TüUÝ¯¯J<¸;~ðŽ?§OD²ÿmgNÆ÷Áð¡ÿXè-4DÂQ /w³ö¢(5™ÙgQrê®•_%œ\‹‚ã^pŒ°êBGü:ÏßÁkÖP™Ü¯;éà—Y¦é‡q³q³pÎÂb_KL?£FŽÇ„q“`bdLüŸ8€¥9l¬,d:ÀÖf¶æG\ Íò	àC‹nheÑœÞâš;«w´W|­&·…¦ùP„®ç-=Û Îr°„ÞÈõA9™iÈIKÄÅÒbÜ½q±? ±˜`íXÀ³Ò/ ¬­”ã'&ØPÖ²˜Þ¹tÜfÌslíýY’3±²×§cåSSá•Å‡QA~ö‘¤DoÁ©âB±ÓK²ÿÌïØö³ïÇç/É–-[î-ùðÃ?S©'î'=ž9ü[vx™°ÿ3ÝqGùÌ9ï—åÈ¹Vî¯þdûÇãÏ“Ðf†!~#®þUÀX¼ë;"7Þ(X‰«‰ûpô@2v.@Lj9N_Ãý²"àtÎ&úÂ#ÒmçÙà»é¦øÐs^`_Û¨^w ­eÎ˜{xŠ³àjÒtìZä ›É>lF‹‰ã'þ`n2fÄHØ2°".`-Óæ¶j;¬ãkË^ätÁKpê¸@]^Pc7‘œ¼7¦=¬ü\Å ŽûJgÏ~àÉ“'…máÿ*éƒ+(.–q€yé¸^A¸¬¼Ts§tåãˆ	>Ž"³_ ¾˜ R>°Ñú Úy%>!Ç<Ùø²4Ü%ßþvYa?QfïW-BÄÉ9Àñt@Mp½ð N&lBÒþ5ÈM#ÛðYàŸÏ—ë}âããkàŸíÁ”)S
UUU9ç÷rcp{öð¯úÝocµÝòž~EÏñø—cwüÛo~›j€ß	÷¿O›€ŸI|0ïùŽB?ÂfœÙÿe¸·1»a×®x=–K><Ý¥É@ÑZ%À}½=~Ÿm!xÃ«öÝ¡2é7Â;¼ï;“· -o)ngÏE\„+Ü­&`Ä°¦?
cFŽÁ$ƒñ01œÓÉ“`f,ÓV¦&°67ƒÐp°±†µ½%ìŒ¡kÃñÁAøÄ²Ç#ë€j= óZkŽ†ý±yË‘ÎŸuÛŽ°}à»Â|àÜ¹2äfgÈúNæ¡êêÂýe¹\j$7Ør1Á§³s4«¦0žÏ³dÉŸe>»ì}™]—ž§?'Ãû²dz,8¾Lÿr9+I-=Ð8U7PY|ç3v ãÐ¤ÆìÆÙÓÅû’ýçóåxŸ½2þyN¤¡¡áÂ7ß|óc•F¸??žüËúzß"éN¸'9Wmï:ˆþ}ÞÍý™gü'p4~!Ì³0ø_ðX|é?úD·“°õ€îdÌÃý¤Õ8s8
ÙwáÄñC¸šqÈßªÌÅ8tÄfNøßtc¼î6 /·…ÊØÿ‘]UG›9F›Cç†KGC0ÏÃúƒ†¢oÿ¡dÿGbÜèÑ˜4n,Œ&ŒÇäIÄXÂÜx2,MÈ'0•ó¡dqÁl&BÝz(¾µ".`©…ÙUú°ø€¨0UÅû£:À1ÀCÿ“ðÏýŸœ`ÛÏw…ïÌÅ‹8u²©‰ä$áÒ¹“„kÂ~Õ•š< ¡˜àóÞ/P#&XËöŸÏTÆºBd˜O­–²¹$Ëry’X­êÃÿY‰Ä>”\ÎÛ‡‚˜õH:¸…ÄÙ.^¼(0ÏgÉzóýlû•ñÏ\pÆŒ…º*J}þ=ž!üÿ‹¤‰Ýû’ŠÞyòy9þžKo|ç?ÿC2ZÈÿHX|Møÿ,`4ÚÌ2€ó:[$DUê|ÜI\+ñ«q#y-½·³B‘3!›=Ðk‘>õExêLØÿ‰ägÑ`å‚“…Kñ !¢W8ÁÊ`8úôê>}c¸þpÂÿHŒ	ãØÃ	¤&ÀÔÐf“„°05†•…)l¬dñA[kX˜hg‚¾¶cñ§õ |hùð¸@Ã±Yýà‹†íÑÝ|6Dm¾?ß¾R.€ï
ß~Íü±° Oø%¸y©÷„ ÌêÆ[l†H‹ö4e†H=5?’ý—tÀ¹tQ§w·^ ¤J«uÀízu€\Î(ó€ºøç>€E‡p2‰c~k™pee¥
ü³>çÙÞ¼Û‡ÏYÂ?ëýõ6Ü7nÜ,BÔ§MÝ3„ÿ¯IŒIvÒ¯PÔÄZÈòào?ÿÂ{0~)fgü4ÿŽéëÀQøžtÀ·¤BÆAkÎD¸®µÆ¾ƒÞ(Š›†“q³q*aN'ÎÀñè mtöB3|N|á%›®P1ø*£D+KMè.3ÁÑô¹@I(ò¶ù"Àn<†@øï‡¾ý‘ýFü„ÐãIŒ#×Ä&N$Ÿ`L…OÀ:ÀÒœ|K3ÁìÉà¸€q}[¨Z\à]Ë.xÙRãÑjˆC¼7Z¶Á¢Þƒïß	¶ÜÄÜŸE²e¥¥ÈÎL¯ö®±p¥¨@ý5Bk†È“éxø‘Ú1 e^S”y@ü×â
X Ä~@MPYrçÒw"óÈ:¤Ý‰’¢Q×%áŸŸ¹Ö“ÏWÿó·óp)ÖÔÔÔV©ÕçÓÐã™À¿¥ê«„ó®$+H.<¨®‡WÃË6ñ[_|é§oý‡ð­ÿP!ßÓëHü7hþC~À·Ä¾ðÕÇOú´Ð ë¬0s³3æluÁ”(®0CÛicðŽk_¼@\_e<ÙýQßCÅ¤-~Ÿ5‹¢Cp½d9.›†…Äûêé¡g>ÐÓí‡AƒÿúC1jø0Œ9\è±£Ga<é æœ0b.0q‚L°O`B><>hci!âƒìXÙ™c’1ÚŽG«!øÂ²çCãu¹€L´2ê€ö“û#|M„ÈIøgá^PÎIöŸïÎ…óˆ;ž@Zr²3P^zw8 ð¹A_àùéx„"õê€Œ:¾ÀÝ}”z|¤Fx@œ¨Ž	VŠÁÅœ}È;¶É‡6!?;çÎŸö^Â?Çv¹Ö“s½þùÜW¬ZY©;V‘ÜïoÒã©ãßR•ãýÿ%¼Û’¤(l¾\ZÏ}ËIŸzÂç¾„’/I¾òŒ¯ý†àÒ	ßŒÀ‚È ùŠ°ÿ†Sòµðªm|N|þgÿAø=h(þë7¸ö"›©	•‰ßÿ/TÆ‘˜´ÇÏS†!`—
²áJâlc…‘ýtÑºMghtê‰¾zý0tÐ@èa0#‡ëcÔ‰Èu É$æ¬&ÀØø é 3ÎÈã´%ŸÀž|æ¶ö6mgˆ.6Ãño«>Äº>”ÔÑfjxgŒ*\-q„ø?Çÿ%üóëÜÜ\Ñ$‹\wé\Y
òòš‡‚ì\½xFæÔÑ3&øÜôÔŠ6Ä„ÐX< ®/p§F<°ž˜€R<àJÁ!œˆßŒäë•r¥gÏŠÜ­„~æØ.Ÿ+ãŸŸ÷íÛ÷ÀÆÙ!îÓßä½žæûj?žüN2Ž$J1³[!Eíûû®ºøÔ{ >õ„Ï¼eò9½þÒg¾&¼GœàÒß“.øˆxB+ËNP1ü*~•=·y}#ÂüDzoüÏ2»oøZYkáË€Q0Ùà†ÄÔ¹¨Êœ¼(Oø[Ž@'u-ü÷gU´ï …^Ú½1°ØŸtÀ@:#ä\@ð€Qäâœà¸€Ñ$ÒFÌÈàø ©ÄÌ`om)r6vV0´3Å@Á>'.ðŠà×ÖŽ	´2QÅãºcÉŠeÂä{Áö…{Â8(ù |‡XÎœ>ƒœ¬¤%Åâd~&®5¨Z &ØÒý<C¤!_ ©1Áú}úy@ÍÜàõ¢#8“º©äó§Æî±Zží(áŸ}€ÂÂBÛUÆ?Çý¦ÏžYÞµ¶©Ê·ï¿Úø=Uü[vdÛ¯J²äÉ=å;Ïµ®ÿrÒÆî}ñ‰× ™x².ð(tÀW¾C…Oð-aÿSþxÃ®›ë3=^fîþ.ú³—I·¼eßyöÇw! µÔ{¦!'cªRg!gƒ+f8ŽAÿ^=ðçŸñÛï¡Ú±t´{a@¿¾Â:`Ð 2Xø#Ù1c™Œ’ÇÆq\@¦Œ&2˜3#yl¸€•™œO Õ°ek-›aø‘¸À{ÍŒ¼:¡ôéç×oØ îc_º'ÜÂ¹b¾Cþ™œ,)FFZ
Ò“Ie£’ûþÓw†È³¼s´!Ð’1Á8Ü(>†²Œ=È8‰¤èí(ÌÏç%áŸ…yjjªðû¥så3Þ°qÃ=cÃe_}õÕç*É÷Õ~<5ü[j¾¤b©þÝ_#Âüq’;5°O¼ÿuûnx×µ7á_yô•K?|L8g]ðãŸpÿ¿>>'~ð/ÇxÁ´°ë/ÓïøÈCßè“Ï0ï»ëŠšá/‰;p¯Ïþé²Ä=ÃÜ1`µl·„`Ý‘éÈI˜Ž²cAH^ç„ùîã1ªotì ‰6m5 ¡ÙÚ=u §«‹}ûbð€:x†"ã”ë±">8Š¸ ×
ÈrÆ“&VÇzÀT^/ ‹ØØYÀÈÎƒåñÁ/¬´›X/ ëúetLŸ1CÁ%aÿ÷A•––
ìó}â»Åw¬ˆûƒR‘‘'vÈV^!ìöÿº}µ~_àa1Ág©_à‘fˆ4–|ü1Á'cp.{²Ž®Gâ¡-d‡Rˆ›ç#áŸkº¹®“¹œ„)þçéï“üÛŸ¿ó\ßWŠ»Z§‡ÿN¼Ÿ{q€U„ûRö%üw1?ž·Ç9?Æ­Ltåº€t ñ€O…0Xøï¸è û†¿â%zæ;y&@¨º,¶†ú<31ï»ë"kè-wÅÐ±kÈÚ@ô‹ðÅÕÞ°Ýè‡G¦à|ÖlÜÏœ‰S»}°vš	,¡G—®hß^jjZè¢Õƒü^è¯§G: ?†D>Ü¦ÑòøàØQÄÆŒ$.0ZpCYlã"G ÷	¤º!ævÖ°†­½5FÙMRp,»áUË†wH>Á÷#;ÃÍÓ]ô(ÛÆ?ÛžÉwŠu€t¿JKÏ¢ÞOMNóÂÎ*µAŒÿ¿9&øwúN?¡~zb‚É65&X_@i=1ÁÒxÜ$ì_È=€ìc‘x8Š>®Ý,¡3)ºZv>¥Bw3ö%ü³°°`É¢òÎ}zZ¢þõ(0|zø×hK8ŸG÷ö4É]Å&ìóþÞ›ÅøÛI‡t@/¡„¸ö³2?vï/|ˆ¼Kï‰¹œò9~_zõG÷%¶ºÆúkü0˜°=`•ú¯tÇ pOÂ¾7†¯õ“íãŒðƒ6÷ù†y`ÒZ/,Û„Â´Y¸]87³gãdL0¯q‚ŸÝ(èi÷@Òª:¡kçîè­­ƒ¾zÄú÷Ã)6(âC0’ô€,60\‘+œ(Å'O0É@¡Ì¥¸€÷šÃÖJÖOÄ\`²½	qú	èd=ßXèàõFz‹yÙc»!hj6oÞ,f?1î¥»Âw‡sÆ\7ÂÜ_º[ÌØ¾äæd#9!Ùi	(cp½\I\jBLð)ö\n(7Øœ˜`í~¬t@f½¾@sb‚wËqóÔq”çBnLÙý(¤'Å ¤øÎÐyð™HøgŸŸó8óç3ä3eY³nmÕ°±£æ~ðÅ'_<*Ÿ8þ-5Èç×øŠl¿	á?Q²÷’pÏ½yÍ®+ÞpèNœ^ï8ëô"ßïÊuÀGî}…¼ãÒ¯°ÏÏµûdûyŽÚ\Œ ló¿‘dãç¬x®'ëÆÿ’«½ ½Â]—»cøjOLÙê‹½‡‚‘;±ñ3°'a&âÒç ,s
÷zcMˆLGõCw--¨wìŒÎº k—žè¥ÓýÙH\`0ÇX°O _#>hÀþÀXy\`Â8M”ù’`À‚t€•œ8ØÈ¸€#q	¶Æèf5?šëá}ónxÃJ59“LwþoBO„¯[#îÉöíÛE._Køgáø1û’þÏœ9‹ÓgÎˆ÷r²³’‹ìôD\8[„[Ä„/ðXrƒÏëÎÑ¦Åï6Èêú•§ãPžwy±›‘tp3ÒŽâùa§ù,ˆûKøg]Í±›Úøg~gjgµ÷·ß~ûS¥Þþ¦<ž<þÕ?'œ"Ù@wör½ø·í,ðÏþÿŽ¬zâ-'m¼MŸyþ»®½ð>ùïö_wè!›—aüZ™·³{x·ÇXÂþ¨È 9öó¾‚ó!a0Do•;º‘/Ðc¹ì7øàÈ‘`œN˜JÏ!pÛâQüà³7³Â¹¸“<‰‘N˜î<Cûê CMüÙZÝ Ó³úêêb€ˆp|p`Íø \ŒSÄF+ÕJq#˜‘0—Çl-Ía/¯!¶¶¶‚…1ú›ÐÇŸÎºøÐ¡sÁ¿'tGÄúµ"ÎÏ=\Î5Êøç»Ä9A®`ÀÏ|çN:-òÙ™HŽ?.t@ÙÉ|T]#Puµá˜àSíøû3Dwn°±˜à]’›§û‡ö™ó§ÄG£¨° 'O<ŒÏBÂ>ûüÌÙ$ü³ðyzùæwè©Å{¼‰÷K'ŠKWÿj„ó…tW‹IîÕ•§Ž—l;	þ/é€×í{/@:À¹'é â®:bFîôÞ‹Öšò}_Ð]Û`8Ùú‘ëîÖ‰û”cž…}½•èæ†Þ+Üá»Ùi1SP?Ëv Û2wüoÖyáÈñi¸™?U' <{rú!b¶9&îNÑ–ãê]Ð­KôÑ‘Å†ˆ¸ ùƒå\@Ää5C£dõƒ¢vpÜ8E\`2ùÆ“¹BkSÒææ°6·€©‰Œ¹·ÈÞAð\l„!s†á;Om¼¢´«ð«I]1{ÙB<xð@Ôþñ® ö¤ûÃw‰m
Çø®Uãÿ”À?óÍŒôT$&GVZ<JKòpó²¬NXÄ«Z87ØÔ~'¶sôñÅûÈîç'»h3éÙhäç¡ä¤ì³—ð/ôpv¶8'eüsgÖÂyºÑsýó>ÿ»|bøñ~ï	ÿF„óXeŸ¿6þ_¤ûüq€Wl¹†‡¥+^#=ð¦Sw¡Þ"ð†S¼d§%›‰aô+^µîˆßg¿÷Áh²ûCHô÷B_²ñýHúË1?PþÌ_÷%áÙÞ}ÉpÜèƒ5äû¯Ú³HotXâ*vrmõC
ù)³°—ü±30EqS‘¾Õs½&`ž6q’Näp\ úÉãÂ'ëŽ*Çd5£É'+‹L”×(|òLLI˜bâcL40F ³âÖû  >sv8BmÆ1#”ã<åS#-8OõÅ_ý%fB2×ß±c‡°|w$üókîà:R¾s¬$ü“(¢ŸÍ@ùœ<Sœƒ—Ê„/P]ðôúKLðÒ£ìmB¿Àùúrƒ©¸^‡²œCÈŽÙŒ„C[{ùy¹8Q\"l½„~ÍüŒÏGÿü^ØšðJ½ñúËÞúò£ÿ<X>Aüs¼¿?a|9Ii5öUk`_ˆµ:ZÙÈvð¾,DKìÆxÃ‘u@¡^&?Ÿça‰}Ÿdÿy&@ïPGáó3ïïî-r{=È·gŒ³­¯­ú1XÁqA¬ñ‚5ù “ÖzC‡~Žw xoöÅÑèÆOÃ¦ƒ!0Ýäƒ¾=<
 %p96{ZÂjÜ tí¤UÕNPïØZZÝ¡ÍñAÝ>Ø¯†TŠP®uC\?(â²bá’o`H¸Ÿƒñ†°61AäÜJšË…s¼Ûæšá;ÞKâÑïÐgó±iW{Ø	ûÏžÄÜŸýEÎHw‰Ÿù~±~`À÷NºÌòòÅ÷%ÄÅ ë
²DÐÝ›"ð×íh(&øì÷Ü&»­˜thæd"ìoERl4rsrHÏ£¨¨H|æáÏqÎç¢Œ~oóÎmwÙÿ¯Ößj=P>QüÿIøŸJ8Ï#¹«R£÷µV«µ\XkÈvqÇ•øÀëäØwÅ«öZb‡·ØïKòŽSO¨Í1û´Gö‘íï½ÂSøõÝHzžuÂ<è=²ù+e¸—8@?¹^´Š|ƒ•žôýîÐXêÃµ^Ø¸?¹qÓD<À‰p¯¹ÌôŠ'–Æ™¬9¸^0×
æâvÖLl÷Ä<ñÜWmÚtÄ­Õ¡¡Ñ={ö„^Ÿ>". ð	†Æ09=\cGÈ¸À8¥º!#ò	&`üŒEþÁ„I˜ícƒÄOÎÅÎØŒŠpE‡ù¶hC¾ÈŸ3ñ¿ QøÆ¹/´-FŠü?˜pÝ(÷sN€s‚|Ÿø^ñý’t s~Æ¾2þù^2?È ïMˆ?ŽòNä¦£¢¬·¯—û/Óõñ€g¤_à±Ä½_àvi
.ÃÉ´}H=²	ñ‡·#9îq{Ò»ô™óçÎŸ3îü™óþæýì÷Køç÷¶ïÞyÇÀÖ4æãŽ?÷U±ìÔèLæ<Zÿ–š­H>&î?†p~€äv}>ÃBø'a~Ëýÿ`n âýÆ­Å< Þå=„pÉv¿ÿj?ô ìë’Íá!D—pße™»Àv¯°š\@ÒìèÐÏt"Œw!™L>@è®@¡BÈBßÇ1[â‰'MÇ1ò¶ÄÍ@|Ö\\&]páx0¶Íµ€Ùèþ‚¨«uBgMŽtG¯žäèêbÐ Y®p¨<W8RˆÐÌÆÀ\`4&Žƒ1c1jÄú³qpµ0ÆñÕž@Þ¤¦M'®Bºj‰#Ôy§ÉB;t]dÍyæø=p,Ú[Æ¡è#P~pœû™0þùNIøç»Æö…ï"cŸ…ï$Ÿ_@–'~&).–üÕäf&ãbçÎËbµñÿLõÔŠ	¶p¿À=%Py6åyÑ(JÚE¾~âŽìBJb²³2‘Gz•u«„æa|ÊøçïÙ»ßmSgÛÄï»¶¦ÒŒÚþ¦<Zÿ? éE2ŸäTmì?ÿÌ4ñ¢U'Íê=º&mÅ¼®O<ôÄ>ï±ëƒ0<2ÝWxCƒpÊ»z¦m÷Â²]^d»™Ï»
\3èEX×])ã‚Èñßg¥»Ðì/#¬™0&NÜ~Ž}„•»ƒPLþVìTÌÚé	ý`·#[âg "gî¤Ï@Á6,ôž€Ñƒûþ;££ç
»A»‡6q]ôïßW^74Ã†ª®à~¢QÃEíàè‘#ÉG`Iã°<Ø7â¦â
ñþ€]¾è¶Ô		û:öíé3°COú´xºçx.š…+×¯	ûÏ¾ ÇønEEE	À9$É¾ð]ãúÖ	|%Û/Ã¾âN¦_ qÇ£EÊ©Ù¸ZÎ=-ß/Ð¤˜àßàÍîÈ©Ãîñ¼0Â?Ï ¼v*¥Y‡»	· 6z/R“é³Îú”?Seüókþü•ñÏúàà¡C·\¼ÜüÔ¹¾ŠÖ¿›UÛß”G‹âß²#Ù~Õ_I|‰ç'Ü¨/Þ÷pÑ@+Kò÷Õev_Äû[ã-òwy_7ïòI~ÿ5þèÆvÜn›=qô¨.&{";Ö³w8`äjÞÿçŽ®äpÎ¿'IÂµäHÂü@O®:/w…F¨«ˆpŽpÃ¾`¤ÆLÅâã×zB-Ôþ~Ò3ûCp:{6î–,Deþ<äG!r¡ì'…žNh¨w†ºztéÒ::½DÝs¡ƒ”ãCIpl`8ÖÇ ú3r|ì'#k³îö7Ç×qEÛùbŸ™a¿Çb{Â¾=Û¢Û"Ò3Ì1ÈÃI™i¸{÷®Ø	Ès€8ÆÇõ «W¯z€ïß?¾oŒ¾{’¨þÖ‰	ñˆ%”p…¹©(?[$ò÷å\ š<®~‡øO­_@ÆîÉåqÿÊÒTT’Ÿ”ºiG6#îÐ6ÂþâO²x«òg-áŸ…?weüó{ÑÑÑ7ýüüövèÐ¡·ÊCæø=ê£…ñÿ)á}$É>’ë*¼·O	ÿMÃ~­YøŒýÉ¿PÃÏ!c0x•F¯A¿ˆ tcÞ¿ÒV\°ñ€7Î$M²§g&=ê„ˆ½Ž˜¸Î…8€4C]Dî¿éŠ>+d˜—býå:@›tCgâZ¼/Þ³Zïi[ý1»?¬‰ðN@ÎlñCÌ±©ÈMžCÄ6ŸŽ£É³p2e²vn4‚~_¡Ú´Ó„ºFô . Û»·R±Œ×ý!¤3ôAOwÌFc÷"GÜÉ˜‰¤ôé0Ûè®ÄûÕ8@ƒðß±¿D†ÿnät^hK¼Àºn&Ø°i£˜ý#v ÈkÈùîñîÐ°°0lÚ´IáH÷’_ó½¬þ3ŽÈòÑ¤’ICBl4²Rãqš¸Àµ‹§q›}‚›•ôÀÓîh¡£rpOÎ*ËÒpõTJ³#'nânFì¡]ˆ9‚Ô”™ŸEŸ†üYòçÊö]úœ•ñÏþ×‘#G®ÿì}\•õ÷?ŽÊÊoeK3KÍ4µ,7q‚q²Dö¾ì½‘=\¸q ‚¢¢¢Èr à@†{•¦Vfj¥•eåûÎç¹\ÍQý¾Íïÿy½Îë¹.—{Ÿ÷û¼ÏùœÏ9ñññ¥šššãÕ~G]ÿ¯=þü+ô8æçyÝ„wÖý[|þò}ñý¢6¯ð\<Î÷»ÆkQa@×ýLÒüæÉ„ýhh/Ã:?lªôÃ¹ƒq8T“‡¢]»°·zn4.Æ†H”ì
@ØÆ ÌÈ	Â„U’àu>³þŸxpœÀgÎ/XåFÂ.Î(óŠ!cqp_
®Ö§£lOÅåR}ajy
ÎŸ^|œ…oêÒ°'›þ®»ÆŒ‚º†44õ¡?l$ÆŒ¢˜`ÜøæµÂ©S&c’ñdŒ7	Ó'OCf˜®W%áê™yH*Ã•Ab®ñp²‹$ßÏø_êGù‰¹§ês½•š€•+W
¼ò¾^S–c~Þ/Ê ==]ÌgóÎ2þU5€Ì2þù5xcˆš}Uâ¯;P…ÓÇëñÙ…Ó¸uý2îÜ$mÿí5%Ü«þÔœàWìÌÑï¯#­_ÏÏÔâLÝN4TmÃ¾²ÍÂç×ÖTöš×Zù³ãÏ?OþlUã,ÿÌÑä÷¿$¿_¬ôûöùøƒðßðß_M¡HX?Þ’ïØü»Gã¿y6&çû=†¢CèhÎwõ|–„ÿÉ¤ûõWFžBB‘Î =1E¼ô;%ÞL×oíüÜéù•%Ap/%¿.é|Ò|G rJàµAÕ5Cææ}Âÿ”5‘È$-pšâò¦b~qœÈYŽà-	8Ò˜	P<p÷ÜBâž¹8UƒüWØÏ0¹AÞK KZ`äˆ1;va~<Æ‘6ÉF“äf}9!¸MqÅöƒi°X%Ð"Ü3þG/	höý£ÉôÉ÷_ˆðŒd‘ïç5ÿ6ˆ> ŒmÆ9¯Êk‹/››+|Ç|VÅ?_£|[^“âk˜c€††Fq]s=!_çU{w¡ºª«qöD>¿xVÌg- Ïf¸ûÝ¯]|XNð×Åÿ½"-:à'qû~ ŸÏvó2Å>çöã|ã.4V£¦¢{+è\µKÔ[Õ)k-ê•øWÅ¾œï—sü™sÍ/}g_DDD¬ïß¿ÿ(µ?Hó«þu‘Yþ+Èßÿðà˜ÿ×â_9ÿFÙÿŸû˜c‹i9¬û“0%7NäûÇ’¦w-BAy(NÕ¦!¯´ZK¾„Z4ýQÀKs„Íºs¨Ü³ß7ÍÅ­†”í
BÌæ`ÌÊ!¿ª\/'¿!by`²’8G8nU¸R3„Á”4AiÿMåRÝS~ô–‡aÚÚ(,)IÀñƒéøèð\ì;8åœ<6W%£f?bHLo€‘z#(.M-}¨kÇ`º­=v3¦¢hž®¯4w„nÁŠ`áûuÙ÷ì4š|¿>ù~ƒÅAˆÏÊþ×ü8ïÇ×”<œë û\TXXÈ³!‘˜˜ˆ   ,]ºT<Ï8WõMªëüœj=
[]Ýa:(õ£¨Þ·{wW¢fo%ëjpîx#>¿t·®]Â[W•xÿBÌbø}9Á?{¿€¤~¾qFÌí½}å8¾ùä®žÝšvãhm±ˆñw—nAÕîrâÚ* ]tèTkÍõVüyÉ¹¹ÎGÆ¿ü9ó¹¬¢üZ@`Àª>}úð^Þß´ÿ÷þµx­/pöa5~÷rÀcâþæy¿Úx3f*Æ­„ã¦tÌÚ˜Žñkã0‚|¿íº`¬ÞŠ¦šÂøFÌZw/¤üµú‚!xàé”»ä›o ~ëaœ>‹ÌÆùCÈ)Z€ãQÊý ¼ ç&Êk„J3b@Ï³ÿŸµ.
nQ°È‘êLˆæÇ‹Zâµ©È)K„;ÅÎEqX»/Ÿ˜œÈÄg•qØ˜é_‡é0=j¢Ï{xïmQGœägƒËe³ñå™XT‘ãU!Ð#Üë³ö'0ji a_Â?¯d!nÑ\±ÆÇ=>~úé§æµ?ö9\¼cÇŽfì¯]»Ë–-ã^Ñƒ¯¯/.\(®Ùûñ¯ZÀ¯Å~LÞ‹"ï-bÇµÜ{h/Ï!Ú]š=»HìÃÙã‡ñé…SøêêÜþê³{ü>ë‚Ÿ¾ûâwäÿ€"*<ðÓsÍùÀ;ä÷¿ý”tþ¥Fò÷÷»p¤fjÊ7£ª|+*Ëv jÏnâ¿}ô9H{óø3á3cŸ?/þ,Uk¬äÏ“ó+ÖçÜž¡°ßöÊÛ]tþû(øñÇà_3œ,GôñýÅ>ÕÌ»}(þå¹WÒüž{×mö4LX§Í°#›˜›„qk¢YNßI¾mšÝ{Ë0~Í5´J@þÃÉ"Éf/Î½Ó¼KØ¾§7,ÀÍ†(Ò!ˆ&-0“´€1iöï£HppçÖÜ»F ¯Œ]-­'Y
ÍeapÎÆ–Š$œÙŸ†»’ˆb0hi½^•&à\S¾:·_’}|(%k1Ûß¦Æ†ÐÕÔ…¾Þp¸ÏœŠòå~¸u„÷fÀ¹0Š4?éþEIØ³T6É÷OXò`ìÿøãb_{ŒýU«V	­ÏÆØÏÌÌDjj*Ï‰ƒ\]]…àŸåk–s†ðµÊµiòõË¯Çù YÿË{Œå~TU{«°›gPVV`ï®rì£Ï¹îÀnœ:zÏÅµÏ>Ä·B|ŽÉø|÷¶2.yá¿´6xONðkƒ?})qÀOÂÎ‘¾?ƒï¯žÂ7„ûkÆ¥58{¸ûv ºb3ví,BeévTV”	ÎÛWµ5Ê~òþ|Æ>ëzþìîßcÁg~œ5TLV:O¼Ünò{Qj
õNdÿÕ5þGþ¹‡ÿZ²«Þ«þ°<À/õ€äÿ5•s?5ðb˜!Ô3Åž~‹õÉ˜º.fëâ‘º=Näüp,gÂÓ)¼>ÿwÖÿjJSr@»4àÝ%ß!lóiœÚ¿?#<cíÎ`xH0:[â±ÊÜ ‘Òÿ«æÇ*×5—‡bÅþN„ÿe%ñXO~?–bî+0„ðïJWìNÆ¹ºtTHÇªê4l¡8å8qÀÉòX’ˆp1E¸³)6exàrU"N4f µ4ž¸'DÄüzYŒù 
ßO`‰?a?ñÁ>û"öÿK–,øfÌgfd --MÜ§xþþþ°··‡……‚ƒIK­^-°-_¯2þùfãûðõ+ûÿr/z1›¼¢e¥¥t.ÅÞÊRì§ØøH}RœÄO?Â·×/áû¯?ö3c_ð€„æ‰$üÿü«ó‚ª–tÀOÍëçé6ß?;×?$û·¯žÆÍOŽâ«‹GðÙ™ø°i/Ž(Å]ÛPU¶¥Å›PA¸//ÛÙ<s¥ªj_sÏE6ÖF'±o¿¨ìã#ã_ÞgÁçrŠ•œâñ†½>ÚÚ:­¦Ðð&ì¿Mö«zwÿ7Ž?ÿ&d!dûZÖüfÏJ Í jë£WÂÆ‰µ?ÝEÞ¢¦×<?ÛRP¼7ç¥’¦_„ò=›^tzÙ×ñ*ÅþjqJìË:€9{1°+¸„ª}%ÀÑø¦1
»v’„en0ùþP±GPä¸^`Õ½k¬&(y€ëŠ,r¢à³!Šõ1bÍ€5„unÖ–&âa½¡:³‹b1-/
Á'ìoÊÄáÛC)8šŒ¦µørO<®ÍÀŠÊ$L_ýe¤û	ï#ÉÏ3î—J±ÿ¯Á>krÎõq¬Ÿ’’"ü¼£ƒ|¼½ °Š€€ ñœ»»;ÏŽ‚7=¿`ÁmÎ%È¾_uo:ß–ëøçäë_Æÿž={%¨¬DYY)v–ì@)Yey	öTìÄê]8z˜¹ —?<Ž/>9‹¯)F¸õÅÇøîÆeüxó
Ùg¸ó5aüó@‹àÛ?+ñÿó-ÉdüÿLçŸoJðóMÉdÀØ¿sã<~ ¬3Þ¿»zß\9…›ŸÀµ¸|šôý‘*;P†ƒ{¶£ªt3*JŠPº½;¶o#Ü—’•Ñ5²§yæ*›ÜƒŸó|ò¾J¹^ò^kæM¾Ÿ»¥†¾Öè`G×»ã ^ß:*á_ƒð¯ñOÇ?÷õÓ&‹RrÀ·¿îÇ¿²ÿè	Ì:@]ìy}9|ú¥ÙbÌò X$ÀoK
2w&¡toÎ×¥á“ÃKév	Ü7œÁ[oC-^…XÄ%æÖ~å;›p©nîOù’ð#ýBÃ¾=Tì%kÊÜ€\7$s±r€s Ì	\cÄ÷c6ÏFåždœ<Š|òç–9b/Ç¦X”ìOÇÕÓpçä<üPŸŽ»õi¸{"µÒèoGB3+@øþQËÈï“Uâßxi~%ö—/_Žäädu…§§è9`gcgGâ{¸»¹’¹‰ ë Š¬lf
àü ç³û|ýrß ¾–ùÚæÛrŒÀõ.ë U\Høß…
Òrýñöâí(Þ¶ø`;ÊJŠ)~ÞŽš=e¨Û¿›4Ï~œ;y˜ø€â„ÉËgpSpÂy|C¼pûKŠ¾ú?ÐùöuÂô×Ÿ]¦ûéqâa—ðÃ¥3ùùï®}H÷yü9|ýéi|õéI\¿xW>¬Ç¥S‡ðñ±œ¨Û…¦ýe¨Ýµ{JÉÏoßˆâ¢B”o¥÷º%;w¢´t§øÊé‘glóÿ'û|Î0îùs‘Mî¯ÄßçT˜+VÎC?{C<a7­\†*}›èiKÖIÌÂû“Ž?¬þG¡ù2]² ²mdg®î_|PP®R—ê x-Ð“çŽD·83˜çe!˜’3ÑÅI(¯ŽÅçõø®)	G÷ç!yÛaÂðut˜ó³Ä³•–H–
´'0dÅÏÜü)jª+ñÓ‘Eøº>
¥»‚0{³?lrÅçþY°_g0V]#Pêñ¼W ›~†Ì"7Q›c‘½3+Éücw˜æDbþöxTïKÆ¡Údì%]PC˜o¨›ƒÝ5©HÞã•!PÏò‡çú	ûãˆçÆ’˜ô;±ïIØwwvnî=È³IìgÁÞnííàDºÀ™žóôòÄ,W{Lše†ÑfÆpó÷ÂŠ‚µ¨9¸—?‘®eÕkœ9€“z‰žkžKÅØàdŒ}ÿ¥pýÇ#ÜŸhË–":oÁ¶­tÞ²	;‹9®.Æ>âƒƒû*P`Ž7ÔàÔ‘ý¸pº—ÎmÄ•óÇpõâ	|qñ$®O\¿|šì®~|×/Äµ‹ÇqõüQ|öaùõ3uøðX-Î©¥˜kjËq¨ªû*¶b/éú[±ð^¼e#Š6bËVzO„ûbâª’’â=ïÜYJï_úøÿàÏ˜ùŽý=ûuþd“û«ñ™û®;qÛ)f°KÄk3u f×_Ô°‹Ùöž<ïJ#po@öÌá>þØú?çßïn'+×ö)ë ÛÇòAz@ªPæå¾Þ¼.à­gƒÇàõ8s\àãÜøl‰Ç²Š(ÂV¾nŒÃ†,”ì.†sÁôYü-ÚÍ¥,Ei„ÿÖéÀK€÷—&ëî uÇEúÝbüÐ”Œ¯êQ\á€Á¢^€ëþFe‡‰:c)/Ð’”k†8.aœO_›uQpÌ‚u^¤xÜ ;¡äû««’qn
6•Ç!xS4œ6ÆÀsÓl±ï`½¦Áò`cÝO˜7`ì“M^Š„¬Œß…}'Šï2ŸÈÍYê;ÄsÊx>»Â6îv˜äf‰LFAÓaÜ‚Q{è@³ž•û«ö§—¯}ŽxÍ‹51ó û}ÆŒŒÎ1JP,zmÞ\$ÞóæMQ¸¾ ……ë±eS!¶mÄö­Q²m3ñÂ6ì)+FUe1j÷ì5õuÄÕuÕå8ÌVK·	×‡kÊq`ïNÂ7Çí;ãÅØK8/'Ÿ^¾}3vm ŒçÓë¯Ç¦Â|ú{ëè¼±qÓ&ñ~¶lÝŠmÅÅ(Þ¾]Ò,tæ÷ÎŸ;Ç6ìï9·'òl6þø3áïƒ9 ®©éÙYhöv¤a4_»„‘¯èšßMg²ÞdÊºŸ|ü¡ø—…i-m¥ØDvšìëÇóÀCæß6¯	p¿o·¢÷àžþ}æ8Awy(Ìâ·#;«£ñ	ùò¯q¤v–”ìÇÌüÏÐÙügýƒ„}µ9À“ÀÄ²€¡« ß¢k¨¬ªÆÍFºÓ¦}¾H/b-DZ Däå}…†«ZÖ	•:ÀXyŸs¼6ÈµšËÃ$m‰C}u
«“²%cV†¢ÿâhsß²Q¤e–“æ–ü¾À~'ö¹×Xó¬B[žU(õu³
y^©«²¹<«ÐKÙƒTšI ç1MôînŠ´ÕY"÷Ç×8_ïŒwûü>ä9cü<çy}K®;’q/Ÿ·ÎÞl5É‡¼F™Ÿ_€uyëèœ‚üuÈËËA^îZ¬/X‡yÈÏ[CØÍÃF²Âü¬_—£¼Ÿ‹ü\é¹Âü\¬ËYƒ|z®`]ÖÑïsÍc½æºuôÚë×‹¿U¨Ä>¿‡"z/EEEBŸ°ñš)sã^Žïe|«ÎVäÿ™o3pÍõ1Òú¹Ä]žs£ÑO1	O{èH>_Æ¾§èÝÆº8‘laÿ…ÿ;Ø~Ûñ§àŸ…f{²ždFÊÿw÷ƒ×¦´6¨¥¬*éf-`(fú¨/òÃ”ÜX¸nŽGúÎXTVGRLC1A&N(DVÉ­½….‹€§‰Ú‘=Oø™î¿¹ÐXX¬ÿi;/Q±w)–¸Vç‹í¾b-°š÷†bÅò¼NÈþ~‚¼—@‰ÎŒË–ð?|e¸È	0'P°²$‹·Ï†#éÒôƒC—Î#û£É÷]ŒñËÙ‚0õ÷bßÃCÌ&³¶RÎ(jžO¤œYê@Z@9ŸÈãžùDx+ˆpòwÁTßYä8}í0#Úk—â£ÒŒñû1À3jù,ûEÖŒŽGìKel10î•ç
QP°ž¬@à4—0+,7«×¬ÁêÕk°–ÎkV¯¹ÍììUÈ^•-n¯ÌÎ¦çW	Ë^µJÔ:H–#^cÝº|aÌ/\Ék=ñ ï‰â¿Íg¹V‚ß+¯orl/ûzÆ6ÿ|–ÿG¾ëÖ-ïó÷S°s+¼Òb06Æý‚LðBˆ¡çsìÊ=«¤˜ÿ+Ò³›é:Ÿ@ÖìOõý|üiø—…æ³Ê¼€Y.Y½ZsÐßÊ:ÊÜ€fsÄ«š¢w Ï	ëKZ@}iŒrgÃo["6îÁg¡¸{4ŸÖ­Àúòj(
?…þê;x{Ðy	ù²Î„ÿnt¿O6 ›¸o¹‰’ªøú=y$
û1§( v¹„ˆ¾£•kcU÷*ë”uÅFÊzbîKàB1C÷¡xbEF—’¥¸ÜJÂ=qÀ4Â~ÒïÀ¾aßÊÜffÒÞbeŸ‰¤>#2¸(çË}ˆ[f–z €8 È×Kð€¥ƒ¤œÌJðGö–|l<Œ~øA`€ù@ÆcäæÍ›ÍœÀ3F˜xÍ€s„ÌŒ7æïŒG6ýÜ\qf¿½6'§Ï¼FÉÆuŒÿ+WbåÊléþªUâ¹5ÌkÖŠsq¿ï}à3ë
~mþ›2öù3æ÷$Çõ¼†'¿oî¥ÄÿÿüÉ¼Ç‹¹œ—>ÆÞýÕˆ\6FáÎÐŒ™…Á‰³Ð)b¢Ô¯ÆCZÃRSðYýù®ýtÝÐõÛí¿²_üéøçCÊö IŸÿÿ;È®ü¶œ€VóÞ {ë¥¸ ñ«Ð!Ê¼€&äÄÂ­(¥1ØSFø¥Ø~>Å±hç1X|õÕ@¯•@×åÀëdo¬ zÒcC‰¦m¼ƒ´²qâ`q@®ÖaGy "7Ãl-k€0Â¨8s^@äVµì+œ¬²V Ï#˜H±Áþyú=¶	lÙ!’þ§®ø}Øçu¼¦¦¢ï Ùôé-³IÌå¤–÷Í/§x@5/ œ_ÎsÊ8&ðSÆ>¾
1Ÿhº-4\&¡§í(ôw5‚u¬7rvlÄÁ¦z~Ÿ2È{¿ùæ~œNîo/úŒ)gsÎñ(ùæ‚¿¼g‘ñÊØçÿ•ïóã|›ë™x¿û®eæÛòs|›ñÎ¼ÀÆ8g>á¿Á¹<ŽC˜‹äž¨rìÂû¦ù=³qÿ>óÿÁï1ÏïŸ9ïØ©(ß·a‹Ó0&Èê‘6ÐLv€Ö|7¼o&zW	ÍÏÕ³¹gûy²$2u²?¼ÎÿaÇ_‚ùPh´•úhº)ë…ŽÐýëš{Ù’xPn@š%~Žu k-âîÖ)jz§ÙAcIØ+ìS”ˆ¼Êœ9Añ},.^ŽâÝ5ˆÚvÓ~ÀÒþo‘ïïB\ðß$x“š(¶Ž5Õ¸Þ´?5&áDu(–Â³ ÓÖHë…"Gø°~CÊ<!÷·’ñO<J#òýVH~êŠðß…}WW7Lo,úµÌ(Sö"Wöe] õ!¶¼// Ï-v€»‹“èAªpsó‰Äüro/øzÃô€¯#ÆøX óXt¶ÑÃÄ6ñ~Xº15àãKÅûýþûïfd`ìÈgÆ÷(`^s‡+0'p}!ïabNà3Ç°1vÃŒmöãlü°og¾5çï¬-ø5XkðZ½¼—é²r¾.cžß‹ê{âÛò{•ß/öìó™8ç_P¶ÞsIçG9¡ ¤9bhš³˜/×7É
Ï–®Å–|ïçœßV2cò[Ïÿq {üñ—âŸ…ÆSBÿ(4GÓíp²ídWÇ¿Ì¶h‘ãw)ÖjCµŽÑÓñA¦cVÇÂ®0)%1ÄÝ‘¸RÛspö`!V—ƒÓ¦o1Œ|~_Â|wÂ~'²—É:¯Þ#0,ºƒ°²O±÷À^ÜnZˆÛõA¨Ûã‹ä¢ ˜¯!=*údKù>¹ß\/0QÙc„9€ý¿À?ý¼Œÿi¿ûn„}]ÝQÐÖÒÇè‘bOá¤‰Æb_±àžI`¢2Ÿˆô€<³TîCì$æÙÝ3ŸÈÓÕ•bwå|")/àëë	_Ò¾Æó‰œGã[-t³©Q®ˆ%¼«Ž°væ¤à îE$sûVÆŸÙo¼_‰Ÿ—ï³1g¨Î¾fÌÉ½
˜#8Ï¾›ór¬!ø6ŸÙ3ðçÄñÿ¿¿kyþ;ü™ò{à÷Å·ù1þ›|æÇÙø>¿_ùñçÎ éØ,X¿
Ö³}¡:=ý&¡O¬¹¨ELñ¦F†¤;àÕp#Ië{QÍ÷1ö÷J¹p­ÿJßÿËñ—ã_>šíÈî]ÉV“Õ“=2/Ð<jï¦
{^3BÏ;^ˆqkc°5ë÷Ì&ìãKâó‡²±cO’J>…õæ;Ð!¼¿•¼B\ð"ÙÄÏç6( ÆmýY{áj=q,Ö†!»8 Þë`*´€Ô'€ëUjå=…ÆÜ›˜5‚Ðþ!Â~/öý|w³„™ï%†¡êzÐÑ	ÑÜS¹Ïñ@óL‚_Ì/·j™Odk#ú«Î'òpcpyo…r€ô€¿¯4Ÿˆµ@_ï‰xY1ÿ±×ÄK6ÚÐó3‡[z8–lÎÁ®CÕøôó+çü¿°Oe\ñm6Æ=û^~^~\>ø¶êž&Æ¦|Ÿ‡_‹qÌ‡êm~N>øçåÇù¶l2¶å¿ÁïƒþÙ+W?~¿ºá ²·®‡ÿ‚ŒpÂ _¼>MX¯DK1S¶_ªî¥;¡ûl3<é«'iPw%ö=Å5{ZÊkéýÕ¾Ÿ¿þùPh>M˜ïJ6\Êhp^àóGsÀ£÷ª©®Šüà´&mñ„Ÿ>^ŠšŠ÷çy`üÚ8nJBÜŽî
Å©ý±øºa..Ö­CáÞÃPýÄ¤^$ì?EPoMZ qÀsÄ}6ÿ«²Ï±¶¦
W³ðS}(ïöEúæ ÌÌ•öýB¤¼€Ü[`r3þ[°?}eÄïÂ~H >,KÄñâH,‹w„Õ´	ÐT×Å@åÜbCCÁS”óËM¦I}ˆï_n!âžOÄ}ˆ…°å¼€r>Åî®Î"/ hž_î!´ sk3_{èú˜¢›b,žQè¢µã`<=k(º;ŽÆ08¤cþ†lT¨¹Æç/o4÷+—1Ë˜äCæ
ª?'?ökþ=ùgU¹Dæùï2¯ðÏžüðj›ê°jkç„btàLôóŸŽ·|Ñ=ÊÝãÌðÖìèoŽž	–èMZÿ½â€Y‚ž1rü’ß‘ðÏù~MR¾_ë²?­ÎïaÇß
ÿò¡ÐxBÙ7óÙjRï@žp÷·­< ~Ø]Y/à6HÌy9Ò½I·iò¾šµ³á¸1+*bqâ`¾mŒÄõúE¨ª©DRÙeL%Íß‡ðþ4q€q€ZŽÒˆZ“è»õ„í>Šc‡é‡ŽÆãóýÈß Ÿ‚ òõÁA>^ôÌ–âcUüg+±¿8ó7c? Àu•)¸tvN™‹ú²ÙX?ß>öÓ0j˜>Ö††–FŽ-f“L}ˆ'az3(ç5ç-Zò63[òNœP[L:À]šIÄóË}}àGZÀÆ×IÒ
Ò#ÑÎS­Ü)s‚gm5ðºÓ|ài“XÄ¬ÌÀæŠh:sõ'ŽàÆÍ¯îñùª‡ªÿ¿ÿx¨>§úš¬dÜ7œ>Ž“¤íÊ·"xi
¬â¼ÑÏÃ¯ÙÃnúx9`,º„Oóæß$ßÞ•ÎÝbÍˆfàmâ€wÿï&Û W‚^0¢kK[éoÔåµ¾;dud¡t]¿õçƒêÁÇßÿ|ˆ¼€çtÈ\È(&Ð¼ðÛ×Uje-àÞ’hë­-fvŠ1Á»sÝ1|E¬×Ç!n{,¶íŠÀ…‘ø¶!•´@>Ö“pÚñ%úíÖÑ“«ÄÿZå™{©ðGŒÙqkk÷âË¦¸[‚cUþX°5V9!"'È5CÒŒÎÿ‡	üOÏþØ÷÷ÆÖÍ³‘U2A[£‘Q‡†ºtÜ¨OÇÑ-‘Xe³I†:Dƒ‡è@_ô!6}ˆ'Ë3K§4Ï/oÎÞ<`>é…³3b­Ð]h‰¼àç§€³¯¦)l¡ín†žžãñ²ïˆ–ïÊM­(sŠgí4ÐÙ~8tüf`z´;"VÍELv&6í.Á™óâì…pöò\»q½Ùs_ã‡áþ»ïo·Ü¾ý]ÖoñºÃ×ëŸ^úgÎÃ†CHÎ[¿ùq˜ãu?S¡SÚ;j¡­í`´vŠ'HÃ¿4"§ sÌt1oþu:w!{“®æ·â‰’,ñN¢5ºDOÅ“>ÃîÇ>çý.’Í£Û¬mŸþk@õËão‹ÕC¡I1ï)=Ä*×
¨½—èþµB©§ŸyÎÏÑêNßá€…>³:n°¼,5¡øêp4>?¼µ»]ycŠ¿Ç+…’ïZ`µò¼Vâî[n#p×q¬[Ïæáäþ$Ðk…FÀluÆrïQŠ8÷g’ù»±¿{<rvÄbÜR?ôšë	â˜ª©ÀÇ‹²p©:EY¤ÏIŒ>ššÃ ©5ÃôGI1Á„ñ˜ÊóËy>Ñ´iÍyæ˜ 97Èó‰lÄ|"±VH<àîè'IpÝÄ¼F €§Å®°÷vu„-L’g`hœ^
Þò]‰ÜŒrþ“»Ú:Å‹:xÉ^]ÝÈÿN„¾Ÿ%ìÓC`—Œð•s°hÓäìÜŒœò"ä”nÆ¡cØÓx ›ö•b÷áZT5Ä¦šr¬#?^R]‰‚’lÞ¾;wæakÑ,_ƒä…Á˜™àˆ¾nãñªÃ<á …'µñ„‡Ž˜?+Çë<†gPó¼ùNQSÐ)zJóù5Š™ÿÝ	ÿo%˜Óm<dÐ²G¥%ß“Îedj
õ×þÌýý;þ!øoE×HG5…ÎÒò.jžZùtíœWæS°—èaõÃªkrL Þ\7Ä5<cä¥¨Éè“î"zùÙ¬GÔÖXl¨ŒÀ™1øº!ë×!¿æ fìü¯m¼ûKPÆÏoøÅ×¶«Õu›p£qŽTÅ"~cŒÉç^†©+ö½ÈÏæoˆÆöŠxxç† /a¿÷Oä‡¡išèA~ñø<k˜ƒó‡Rqb[VÆ9ÂršÔ5õ0X]zÃFÀ`Œ&Ž)•y1·X9›ÄÌVÄ<£Lž[,Ï'jŽ	D~Ð"&òƒž¤œœÜáêâŽ¸p_l ®«ØŽˆ<ô5\ûÈœŽ;k2i=·½:ž%Œ¶wÖÁÄmõÐÃÍGŠuÇ¾nÐ[1Ý]Ðüw?Â§ë¼é4ï(Æ£wàX¼ï7Æ gð(tôÖÇ³“xÖš¬Ÿåý%„}þ»Oúéã?Ác	ÿñJ¤1#Œñjä$t¤k¤sÌTŠLÐðÿ&ñ û6¢Îgˆ2îç˜_ë½æA²XÂÿûæÞþ_sü#ð¯z(tHh[Ñu²ˆŒçˆ^¢ÏöNöµ~q==66×
]‰uZ®z>d,ºÆY`à|opÞ”€¥ä¿k#p½.
Ÿž‡òÚWžÅ­_ã©õw%ß/ó@¶Òˆ†nûkvoÇûRqíP,æo	ø¿<
‰Y¿ûî>^pÍ
BÌ†pxå…`D–/†,ð†sN°àƒK‡æ`U22·E#¹$»ëçà›3ðíìYî‡X…9&m}èq^`¬4¿|ê$â©RL Í'’8@ª4—æ‘°'=à`;«e€âwÒ®NÎ„}88rÝÖÌ	ÁÕ½é¸uj.¢7z¡{ì´#¶õÑs]¦áØ#ÆCå;äYñnšÍ¹VNœ×*n·ö ó$ž§¿¡æÍµ7</Š~Î•~ÞEC:“¯gì·õÕ8o+æ§jËkt¿ëàiŠŸ‡aðb8i—ðñâürÄDÁ¯‘èk‚7bMñrøD‰×škPÕ•\¢uQÍS›®U±ô^_ú«ásÿñÄ?iíÎôi*ó+ès>!qÀƒñÿèµB•þÂœpoÉ×¶¥8îÅi?Ñ(ŠÏg&"r[,Ö–E i_$nNÆ+QP[‰q;?E»JßÏø_A¶\Z#Ð™_‚¸´(dÅYbãø„`ÒŠHÄÿ.ì+`œá‹‰Ë0qY ´ù _¦SW ‡°~á ùúšd$nÃÈ,o®ðÃœÒXœ;šœ] ÏÄ•Ýñ(HwƒÙDèjëa¨èC<cFs½À8LšhÔ2›„çs½€ÌÊ™¥–÷Ör^ÀÞžbØØ8ÀÙÑ‰á>8T0wI‡ì®…ÑGt ÝüL¨1áj<ž&mÝæpÿ|¨Gô†Pæw[‰ß“jëZy*_C<Ï¯¯'¬ç!™ºô»z„q	û¬ùTßÿ'ý†‰¼Ðsäÿ_ ­C(qÅŒà=gíF*µ¤ºJÜ¯ùa¿RM¡k­¦ö*ÙŸ^ßÿ¸ã‡ÕCÔiM¡Ï8x¶‚ìÝÿîñõ÷_O:hî/ ºN@Æ=GyïÆÛIÖœå‡á«¢Å¬±¹;âp°*·‡áû¦TÜçŠ³x›â~µ|úÐVIöJJ-fú
lïÝ³Væïˆù¹+EÚoÅþÄ¹>É½¾ûB}¡úfxþ½0sU òÿU»°dk$Æ/ñÆ[inå…[£Ð¸?G§£®>çeà
Å•«üîfcƒÑÐÑ&z®Ìð|"ÎLžÓ©RÝÏ*´äY…pÝ¯*ó¼À~Ö,X[ÚÀÊÂ>n.Ø’†¯ÍÅIâIOt§ùù¨éx‘ìµèi„£‰„›Ñhã«/bíÖr¿Ç‡âÿq³"T¾?Öð^Òì8ž%ÿ„ßp<å?O
!=Æ{FyÎtkoíæ¿Í\ÐŽž{–øé?x>Øl,sÀxâ Â?ù…Ž‘“ñig‚ÆˆyµÍ¹>)ßÇõýÇéšL$üðWCåaÇ?ÿžš­éûâÙ¢‰¬ÈÐç]Gßãíß^;¨ô%ª=G•ÐÊCƒ|„>:ÐwÞ‹´€þŠp˜®‹GÀæXä”…ãlm8~jˆÃ§Ë°d_†ï¸Š'I<‘tã½¢ïÉO¯Ì[c+3ÌŸ?ÿ7cßˆ°?j±4ëS4¿&áÐ|/%›²Ì>yÁð[„©ËId¸cð<ç‡ vO"«) ^pÌ§¸a[$jëRqãè\|\‡sÜá`>	ÚÚÃ0TCzzR^ÀˆâÉ\;Èk…ÍsÊ¦)÷¨ÔÎ´¢¸Àš°os3KzÌiaž¸XžŒoÎÎCò¶ ôN±"ì›à¥hSò™ÒÚk1ÓñL˜1ÚP|þ\ð¼<R¬ÇÜ‹ÿÇÄ÷÷‹lææßs¤yŽ<aýýSÌdB÷ó<Yoq=ˆØ^ƒc~þiÿ‘Ä£ñÂ÷sÁJ`¼Ðû¯„}ÐÆ‡õ…ºÒäú~‘ï_(ÍÀÑ}î¯†ÊÃŽ4þU…nGÂÿXÂ}¥jÒþŠïœ#|tí šØG ’àÚm·!â:y>ÔÝ-ðþ<ôÄZa<æ•$àhM$îÅ•º¬¯)…å’"˜øD4ãž×¸¶ýÈÑ£bJ||¼ØC/¬é%ìI÷Á°,iÆsÀpžóG ·ˆliâ‚Q¤÷µx¢ï\7¼Ÿá†Ù~B|D¾¿¬"&Ë½Ð5Åc–x!oW<nž_\Z‚¯¦£4ÛAîf;f†ªëBCSšY:z”!&ðZ!k©\;8Ehy?‘µ˜[l3S3LŸfFü`og;Tf‡ãîÉù¨9œ£å.hOØoN~?ÖoÌ–¬ÅÍÏFLÃSa“0$ÕæY––Hq5éî'„&{\^àaß¡
wÈß?ÿœ„m¶'|†‰sk]e.XCÄmšgMë‹=¤2´g! -ÈqÀ‹Ä¬	øg¤~CU×úHƒjì"³3ðþÆÇ¿ÿ|(t^¤Ï›÷ñÌÁùj¼Ÿ¨97ø°µÂ‡Ï’®#yPŠëDí ¯.ž£ïÿ­d[è.ÆÒá[)¦.‹@}UŠWû#&ØùØçºuÞWÊ{Q¸gVV–¨cçúrÞgÊ=³ä÷G¦{‰¹^:„užïÇÆúÝÁ/ð†qûýÞ„½E
xäaÍöh—ÍFìú¨gºâ4'8­ñG	Å	6ÍÅ™¦œ¬Ÿƒ§áTi,Ö¦¸Š¼€–¦.Ò†¦¦>FŒƒqãÆÃX™˜.×O—ö˜‘Mš<&Lƒ…%V%ùâ&éþËÇç tƒÞO›I¾ß”bòû3„uŒ1¡ûÓILÇ{©–HØì]{"0wq]¸:zR\ ×m=”~Eý·êïzi	/ô€Òä\"c¿5káÿu›9@Öœx6ˆx XÒÿ¡óÓCðkˆkÄ³y­ÿ6]sÇÈRéo3pÿÆÇ¿
ÿò¡ÐìHf¨Æû+=µ*Õ¤º¡‡äÓØSÎ(c7ÕÞƒ£ðFœ™Àœ>i«‚DxÒm?_ëbŸûEòžTî©‚Y/sï}î3Á~ŸyAÆ>Ïäñ÷÷Bâ,Vy‘¿÷zŸy€Ï¬ÿ‡g)ñÏœ°ÐÚ„ÿ!¤ùÏsÇ˜Å^°[€ Š¼r1îÉtƒU¶/ŠÊbqv
J*ãY²MÕ	øæÜÜ>’úÜ$zYÂÔÈz:úBhëŒÀ(žYÊk…\CÌû
§L!Ÿ?“¦LÅ£É+LC¬—#.”$â§bÅF:¶x}¶9^!¿ÿùûnqþ_ˆœ†g"¦¢Gòxç{âD}¾Ø?yKÂ03ÀƒÜ¦ãuwCüÇSÿ<polð‹= Ô*¼¡b­ï¿ï%ñƒÄÃD-O;ÿábïØÓ<8š!~¦9Öã~OÍ«tÍ­"-Êy©Ž5wü+ñÏ‡è§¢Mü«Ó’ð¤xàQyåÚ³]Vd³èú±'}hI@÷ÕÉ¬é;¶$°U§Ÿ#½è ‡g=Ð-Þ„Ùcª—ýC±ÏûQeì;88`ÆŒ¢çnTT”Ð¼GŸç~ü~þþØ³=ŸÖ£°”×ö¼1’t»æ"Ö^Ðb¼/ô…îBÆ>éòÿzÐ!ý¯M6|¡†Äã÷Ãè~Òºó=0{C(ÎQ<pù`*ælÁ 'tOs„ûú@œ<’\^
œ]ˆÏv'bûR„º™b´¾>>è¯	­a5Š´€áX±·ØxâDòùF07“&N‚ÂÞ
¥K‚ãóq¸>æ+ÝÐ™°ß!’c~³fßß™n?Oºÿ¹¨©0Xl‡ŠÚ|$ûyŽCd œÝÝaææOkôWLÆËŠ‘§ÖqÎ>ÿ­T¹Aù³­yÞ¼—ŽÈ2ÆyÈ0îŸò¡\/TyOž²i5Ð5ç¨¦Ð{¬í_ƒÇÿZüË‡B§£š§ç¢éûÙ®ö°>ÄÎdVd£× Õ€þhÕ»Zê‡Ö õ{ ÍàÐV} ÚB6OhD½Áh«5íFi£ýÐ~ÍØÿñÎGbßÊÊJôèˆ‰‰ABB‚˜»ajj*úo»zùÃhÉiÄo;‚óu«q»)Õ{}]è…é+äïºÀçy“¯']@¦K÷õ	óÃÈt• NZ` é‘÷æ¸¢/Ù°îËFùýM;c`¹Â¯&ÌB·d{øåàè|sz>.œœ‡†#sÐt 	5¤FÌÂŒ‰†ÐÕ]]}²áÐ×…‘#0l„†‹Y3¦#?Í·È‡v<Q›ðžÐý¤ó#MÐ%–°OÖ1Ú”|ÿt<Oþ¿_šR¶úãë“ø¬2ËƒáíîgG(Ü½àæë	S_;høLÇ›^cñ‚bžT<¦vè¡ûÁŒÿGÍ¢< r‡:"Oø¯#øJyÞ›§ä>¾·è:+£kÎŒ|Î‹õ¥ÿkŽ=þùàïÂS«/Ùúž¤>Äž*}ˆÉ«M$ñN/´zåu´nûÚ´ÿžxú9<õô3xú¹çðL‡WÑ¾Ã+èðâKxáõ7ðb§7ñêko c÷îx¥G/t|³^êú.fgàøépåÊg8vì¸è/ó ìso.Æ=?Çý-8°³³ÃT3K<ë­ã€.ó~‚[áG¨¯Ý œˆÃõä—xÁaµ'ôzb`¦'‘æWŸOš€L[éÿe Nþ~P¦»ðýlšóÝ0u™\(þ7Yææ8ãýt'¸¬òEiùlœ'MP²{6|ƒ`»> +*cp©)_R¬P¹ÜŽ&ÏùÁ¡:8Hƒ†êaÀP}Œn€x¯Y¸Rš\XŒœÝQ¤5ìIó›Š|§˜èJ~ÿŠžù¾)èo<Ž×'ãV]&¶/‹D¨·'í]àäÀ½Ç¤ýDÞþ
Øú¹ÀÈÇƒ½(&P¢­Bç—±ýâƒ{cSÜÛSþqëŠ’ô€È(´ïõý2þ%¿ÒD×Y
ùÝÿ¯ÿÿN‡Ü‡ØS3ˆlÙi5GÍoÔÆÒuÐùM´"Ü·n¥†6mÛâÉ¶­Ñî©¶xæ™gÐþÙ§ñüžÅ‹:àå—_B§W_F—ÎÑ¥ËèÖõMôêÑ={¾=ßÁëï„wX"aÿ(êë 7'çØçü?cŸù{äòq¸¾oO€šÿPþIÌ'yvÏ&ù[v—ãÇcYøáH4ÊÊ½ï‹ž™%­ÿ}!ñÆ|	û2hhÌcsÇWÒû.xŸpß9Ñ¯“M]¢ÀÆÑø¬.Õ{âa³ÒÏÇÍD·T;$mÅÕSó€KKñý‰ùhÜŒ°Y°11‚Ž¶z¿«Ž÷ûkÃrŠ1Š)aÝúÄÌÊUàµ8s‘óëL>¿ÝfÝÏë~í	ÿìûG/²Gimîž\ j„bƒ<ádç [G¸8rß1i/A€¯—à…Ÿ¾ŽÐ÷™·½Æ£i'ªµVx_?ù_ÿVÊx µÌ%¿à-ÕøŸ×œþˆ5i^›Vh¿*Öªÿ†ÇÿþùPhµ§ï¢'Ù5Íyj#µÏ«uzãn+µVhÝºÚ´i'žxíÚµSbÿY<Gþ¿ƒû;vDçÎñF—.„ý®èÑã-ôêÕ}úôÆ{}{£oß¾è3XvŠPd¯^‹y™™Ä>÷çÞW||ùÕWpŠ]gÒéÚüjwÅŒ’6)@¿ÅßÂ{ã9ì«Þ‚ŸŽ'à›_l-óW®7q€Hç÷'BxWŸ/ñ€–ÿÚdZJü³Ï'Õ	ìÐ5É–¤6îˆFa?aCz¥ØC-Ü:™ÎØPƒ/ŽeââñL45ÌÁ¹út\Ø›ˆòþðw˜ŽQL=óBìq¾"e yçl	ûfx‘ðÿÅÿÝâÍÅºßËÑ&x5ÆýÓ¬‘¾-·ÎÍÃµªtdÅzÃÞf¬,m`?Ë®ŽN¢¹·§|¼<Ä~¢ oxûyÁÉ4Œ¯-ÔItVP<ð uÂqÀý9Â_[S¤b
Õ<‚Êß’÷”Ê{þ<Ô¿£Ç.H5iÚiô3Sè~·¿úÒÐñ?‡ù¨ÕCí},µ¯·¢¡uëÖ„ý6„ý'[°ß¾½
ö_nÆ~Â~WýJì÷Á{ï½‡>ø @^}Ñ±ç`Œ5u€_ è›ammý@ìóÚÜƒûKó:`hÜ¨Ù„ZØ]iNYY,Ð>ý.Æ¬¹†UûñÕÑeÄ aŸ?’=1e©«Ð÷2<Ðo®ÞŸëN±4þÉ´æ»Cƒð?d®ôNsDß4ey b] Y Æ.r#M0‹b$ãÃýiøø`Vîˆ‚qÃü²(œ>:·ç !/ÙavÈvÆù¢Ü8šAï+
úðaþåèèDÖnw%ÿÿ¯ÿ“ï'Åë¼pöxîÉÄÖEAðu¶ÃSK˜›óž;¸9*{Ž‰þ£Äô¹ù*¤^C¬¤™NBôôš Ôã–Zàß­®#HõBJßï2jÎHæ:PâQ¨uBMÔ¨k¸i'tVSèþÿýåñ}oè©=Ûé£{±ÿÄÿ	û¤Øx(´5Õ¡©¡þZ£0j¢aß
þ~>"Þç^Ô÷cŸ{Òq-Ü÷VÇÂŸbÜFi>a$ZæÓýÖIÀ›óïÀ¾àjj·'Sñuc ¶”zÀ};ô¸þ]ñã<ÓCæI64Ól¤ÿÕé¹As˜œ 3Ï†„{ö÷=“íH8Àe*vÅáÒÁtïŒ…ÙOô¢x`â
äíŠÁçÄ8’;Õ©ø±&]èþC’`½ÊÈ×?GX-–c~òýqxn¿iBO‡ÁbTJkµ¹‘ö´ƒµ…ÌM-`eaG[[òÿÊ™.ÊùDÍ³I<D âo_O¡¦s~Ð›óô™=¨^@Uü~üÿûþ;E¡ûìéx†{}Ù÷…šmo¨9ö“ÖˆÅL
õ;jžê—ûµd‹ÿèvý«! ÿsø—±ÿL§sö555¡££ƒaz:P×ÒA_Ñ1É‘1ñ¢wõÃ°Ïû€¸½“­	|319çs¼6ÿGi>a4¤™¥òìâh®-´V^ÇÚò}¸z$86Göú eƒ+L–9Cwá›üý»s˜œ1qO¦¡´¡dƒùñ¹Žx7ÍžbYx“|¿î|gøçrž1
ëK¢áµÆ½’mñZüL˜.sGÎŽH4Õ&ãbÓ\=9OØ±Ã©HÞŒ¡sìð|´™Èù¿Añ~÷x	û¯D›’î7E¿T+ÄùãÖÙy¸R‘ŒôÂ½)¦N33î7b-æ’rÿQ¹qóÞbW©ß÷“yÀ×¾~Þ°òã¼€zxZà©Çä7oúA:á~ìsðåÐq˜°<>Å‹`œ‚ŽaãÑŠ÷2þúIs¾ø¾Gsÿ¯óbïºBÇEÚËÎ{Úÿ¼YŸ:þ§ðÿ'a_oØ0ŒÁûéFaøˆ‘Ð3œ€hìÙ½×>ÿ´¹ïÔýØŸikŒ­pçhšöoDÐ¦ãè³øÚ$)9 BÅ8& Ç»-üvùQ¶w'~:–†/›|PVîOÒºó]Ñ7ÝýÈÏÌpÆ òûÉïóy(ÝBøï?Ç}ÿ=SlÑ›|¼F†¦,ö€ÝJ/˜/S`pº=aß
£8aõ¶p4U'¡¤"©EÁˆÞ„8:æûaR–+ú$ÎDGÂ{§XÆ¾÷¿H\ðløt¼•d×<Oì'ßÿEm*6gøÂc–%&O…ñ¤©¢~XžI Í'’úŒ8Ù·ô õ½È•=Hå>Ä>Ò\G?Lñ™M¯éxSaˆgÄž¿_»äa cÿ—¿ûBðè/ôDdù*l8Yƒ•eÄYÐ˜ï‚gü†IàðÅý%- åî\!8(õ²áž6Ýì>þgðÿga_OO`ôèÑ044„Ñ8CQ;kdj‡Ô¬\¹zw•ñ¾*ö‡™cbøLä—Gà“Ã¤©Ãq¹ní¨ÅøÕWðzæh•€ÇÉ¬n`IÙ!|Ü¸FôlÚëÄõ¤—RœLØJúþ=âÞ©Nx/Í‰ô¿„ÿAsˆ„îÿ€âþþdÒñ~*qi‚×â¬ðN²üs|p¢&	LAúÆ hÌµÃÛÉ3éçméµlEïÛ^	VèNz¿{œ%Þ"ßß…4 ×ü?6#³ì±í@nËDåŠ ;[ÁdòM˜ŒÉ“§a†™JbžKBÀ{‹Eb%p©±<¹±§[sÿÑ@Ò^>
Xû:b”9ÞõžˆW£Ðî±õ\¬)ÕüJì³½J¾~êê,<XŒ=—O¡îêT||Š0iu^šHñçHÀgÎˆ<¡X'àšTîiçLœ AÖ…ìOŸò?ÿ¿ûãÇÇÄ‰allŒ±ŒajçuÛöâê×ññ…(°?pÒ(¼ád„KÃ`».)ÛÂ°{o ®×Gà›ÆLªÞ„¨¢£´ì&žJƒ4·<J%& mÐŠ´@×…?Â,ïSäWìÅ—Yø¦!{+Ý¾Î‹œIç;âíâ G±îßŸl Ç ƒæ:68€ãI¶x3a&º‘iÌµ§×ðCÕ®8ïŒ†ùR7¼mŽg#g?X¢[¢ÞJ°DOÂOÒ
o“½I±'‘ó7Å;I–ˆØ€K'3qiWRýí`l8žôÑXÂ?ï+š&f5ï-¶0Wö!f-`E Í)cç¹¹:ÿr>‘7Ï'ò‚‹Ÿ›Ô‡ØÛÝ)&ø5Z@èfPbßëa?§‰ö#¡9ÏaåÙØtæ ^=úë±ç“SXw²
ÁeË¡·È‚÷„}ûw)&ø@Ò<³Ö}(kîi[Cç…d³(è#zßþ‰Ç¿ÿ1ö'OžLñíTL<QÌàpR„ sY.iôrlÚ¸ýÆE›©ï‰s=mDMßèåáp)ˆÄò’0œ¨ÁwÑ¤#¯|¬Ö}‚·þ |¾Ðá*ñ ß'ÐcÑwˆÜr^œŒÇÇû}±p“+L–:B=CÊû÷J•x ùú„ûAs$ü³xŸ4ÿ»ivè›b‡÷(&Ð¡ß±Yá‰°<?¸e{ahº^µÀ«³-Ð•0ß#‰0OÐ‹-ño‰N1f˜b@ÚLxçzc_u>©NÆÆ/XN2Â A<›`Œ¸ßÐ1›dÆt©ßesïA©ï˜íL+eÏ1iv¹³£=\œ”}ˆ[òrâ îAê%õ!öµ -`ŒWI<</p?(±ÿ ü«¬õ=<ƒé³±Û˜ŠÌƒ[PüQ4Þ¸Œ}ŸÆ’úô}Åáí8S´á¼¼>àÜ_¹F0T®>O¯[HæCø!õÀ×üSz„þ«ñÿ7Á>×õš››“Æ5Å¤)&0˜6n1xwù%ãw¤¹Åäw¸®üÅðI„M'h/$}ŠÀÁ((ÂGÂp»)§®#}PÍ_áét¥ãež€8à•ùw1-ï:
wÕà[îC|$´€¾9¼€â òñlïÖßSZ?²Èú+í}zžã€A¤	4Hh“œf‹ÞÉ¬Hë3Ö­)N Ü'Éø·DÒ¯F›	ÿ?i‰¶îŠÁ—ué8¹1É¾31Bw8zõQÇ !Ã`8f,&?¨ß<ŸÈb†²÷ ÷“ú;(ç¹Š˜À±¹ÿ(¯¨Î$àY….~<ŸÈ^Ì'’fü:-ðP“{ÃðzŸë ´%®x9l,tº#¨t9
NÔ¢öÊ‡¨¿ÆZà$òOîÃìÝ¹0Xæ‡<€qïøžR–ë~¦×ýœì°šB}µ4‡gáh¶û£!ò¯Åÿßû¼ÏÇÒÒRÔ XÓµlJ±î@ƒIP3ìsob2®5.d,^§Ø™{ê.	ÄÌ¼p,ÞAZ` ¾mÇ%Ò*waVþEt#-Ð*Q%u@<Ð–øAsåmÌÛqŸÔ '’q®6 s7:cÚ[hdÚ
Ü÷H±E×d[Š¤ûæ	ü;P\o¾Éë'Ù k¼5aÞš°n>Ä½“f
.x'ÙJÌ¿x'ÑRÌ¾èAþÿÂÇ	ÿÅ„ÿ[‡çà£m1XëËÉã1h 6ú¼«!êz=jŒ'ŽÇ4ÒH&S$}ˆ›9@ÊØRL õ!ž	{;›{rƒÎÎÊü T3 Í)Sˆü ¿Ÿ7ly>‘7i/I<ý{y@®ÿãïË™±ü>qÁxÊW—>˜çÅ#½f¶œ«ÃþÏ?BãõK¨úô4–7î„õú¼g‚ÖÜ+€óƒü»NJ-Ð2ôŠ4O3œtÁh²n¢þtü+ñÿ7Ã>ïíáÚ?aVfè©3­Mu¤~5Êž³rß¸Ötñ|¢áÑ‹4¸N–?L×†#°0kwD“OOÇ¹º\ÌÙQõå7ñtªT#$°«Ô¤žH£x`ñÏpÜð9J÷îÃ­¦Å¸Ý„}»œžgáóíñV²^§Ø£{Ò,ôM•4¿döÂ8à\à[„ýž‰ößM±ó.ú’ñì«>I-Ð3Á¯ÅÌ±ÿÀTkçù`ÿ¾|Ip¾d66¤»ÃÅb245ôÐï}¨ÓyÔ¨Ñ0?Ž´ÀDâI0zß|"úg*ûqÒY6VÍ½9/àà ê†8&ðpu§Ï)k™Yêë£€«¯Ì}0Ü[ªjÿ[9À“°ï­'ú‰qŸî%by^ãSb˜×tç»#`ÇòýÕÄ¢î‹"Øx¦Ùžå‰ôsûv}¥µB97(õ¹®&õ®XKæ¦œ…ó‡ì%ü×áÿoŒ}[Š_Ùllfâ½ácÑÚ„®!O•Zôæ™¥Rïxy&Á›qæèKZ`èBLËEê–pÔ×„à»#a¸Ö° …•»a½î3t_tmS%ß/ð'q€Z
ðÂ|`ôêo± ä.Þ OÆÅýþÈÚì³¥¶4wÞI™…žÉ³Ð#Ñï$ÙÆíÈÿÛá]²¾¤ÞeÜËFøïËF·™$ü[¢7áÿÂ?×ý¾eJq€)†gÚ!«8_ž¦7qa)¾®MÅŽ¥¾u3Ç¸Ñ£0xˆé 6RÄÆŒ0mÒ$‘h™Uh
+•~C3­ïí?êlg'rR~Pš[Ì5ÄÍà%ÕsÍ€=iñ¾VøÀ{:)Fÿº˜@Ì*Ð}Â9N{ÊW_ì}ÿ8ÏÏy=§÷Ež¿=Ç³­ò±3¶ž;,b‚Ã×/b÷''°äðvÌ,HDú¬žæ¾£\'Àñ ç
¹w¸T¯Àk…;”³ðFÒc=Èþóß„Ë¿
ÿsìóþ>{{{º=GC«ÉäOØ§4Ï%Pé7ä!­ñž“'}‡SL0]f[c@†–Ã« ˆ´@ ÎÁOG“pö`>Ò·5B?û+¼I_çUŒtÀs?õ•?Â{ãØ²ë®Ö¯¢x"
uU
Ä8ciwÿÝI°ÞçÛ½)&èCúÿ]:¿Ÿ:ýØï+±ß‡MŽ(öØf!úûqŸÏW£M0|®-2‹‚q¾i.n[„kG3p¦:6G`y‚3lLÆCC]ƒÓg«+Í'š œO4Ue&j^@ÊZÞ;ŸˆóÍ3	H4Ï,uWæäy¥^pósÇL?'Œö¶B/…Ú{ê?û¢Æ—{Cxh‰~áÜ¨}'-=Ät$îfà"å÷¹_ÁËaã »ÈA;W¨AÕggQKz òÒ1l<]‹ÔêB˜¬A×˜éô»Äùv}¤Ü@snP¬Þ s=½\5/M?:ëÒýgÿ[ù×àÿ€}ÞäHuùÿA£Æ£Í$í¯;+dÐhÉ(´EºŽ‘Óðv²=/ð†Éê`Ò¨ÝëKÚ:W-ÄÖÊrønüºÙß¢ã UªT'$ø€8 ]Ð-¿ö¤íøÇíÀÝãqýpò¶¹Àf™-ÔçØ x?Áo½•0‹pn#ÖøïÅ¿äû{SLðN‚•Ò$ýß™÷þF™`@ŠBs½QY‹:ŠÖïŒïyeyŽ×§âúþTì_ˆÙæ˜2Ö z:Ã¡¥œOd Ò‡Xä¦«Ì'ó
ÍÅÌRæ Öv¶3¥Ü r&+q€›2æ¹‘h©b-ÀsÊÆ*Hyðƒ¼õ¥JŸß¼È<­ÐÁŒÂ>ûîÎ}ÂÚú*÷{jI}â8&P®÷?å§‡ÞÉV˜¹>Ià½àD5v_:…†k—pèêy¬§ë††ÌuD{zMˆúÁ÷¥£¨!½L¯þw«ñì`O#2ÞÃÖþÿ
›þÿAØçóLºV‡ÖÆÚJÿÿˆþuÍûÊZ‘?à^³Ü;¿k¼%fºcÌ2?Øæúbþ6ÔïÂ­ú$ÜhX…»«áD1Ï%?ã‰¹ô%¦*mð$éƒŽ+îÂ~Ã—È¯lÄ×M9øùDNV»">ßú™6èBñþË±–èoMz@ÊõIf#ø€ñßWÿ½”ùÿxûsÍ¯Ébg”WÆàêá4lÚÃy¶x…üÝ¨EöØ¶7øx	ðÑb|Z‘€¼Tw8YL=ÇÒ¦¶>ÆŒ£qR^€ûš4ÇÓ$ë”}ˆUç±pVò€X+ä½îxÊ<  ³ìÜÝ0CáãÀ™0 ½òN„as?©·'G„qŸaÿO*±Ï}ÿ<#Pè ŽäïÌMž3+ùòƒD½€ç–Èn¬DÕå38üÅEÔ\9KñÁ!dÔn†e~"ºÇN—â›^’`QÎª$Ÿð5áþ´˜!ì©Á{ØµÅžöÿÃñÇÿ?û|Ÿ÷Iø7Òy$þ[ö©Ëó
•3Ky x:EO•rv™ž½< !…¨Øå‡[¤ ®¶‰ÅÂ(çt_<‘!á_ø -Ý~fÐ…´À˜5w0gÇÇø¨¡8;_Õû#»È	&Yë[ââšÎqVx3ÞJäÿ{&qÎ_â‘ûkÆ¿¥°·”øç½ÿ3—¹¡‚|Ã¾x¬QàÙÐÉô?`é‚Í¥Q¸}v!nž_ˆÇçàXUŠWú#Ja	cÃ1ôÙsb=è‰±cEÏ11“@žOÄýGML`eöËùDv"70¶\C,å=dà5ÒÜcÀÕÉ¾Š|)JU t‰3F¥LA{?e/ÖýžÚ‚w9SÅ¾Œî&õÑ}ZfÊ¨KøWúó6ÞZèo“51ˆ«\‡¼cU(§X öósØ÷é)Š	ö#´4[¬·¶ãß—kˆùÌ5œ’zŒÞ$ìï#^J üO&MðqÃïê1þÆÿ?ûü¸%ýÜ‘cÑz‚òúR<l.‰¶òZ’gmŽ¹1_“í‚ÆŠš{Þç£¿ÄÖk|¾Ùu{}(¶Ã—«P^µ>?Á€åwÑa>ðùÿ¶™<KÐ•\ððµ€wÑ7Ø¸÷n4qq$÷x!*×ºs­‰,D­sÀ[‰ÖbJO2Îùsì/é~Ézýo&öþŒÌ°CPÅÜk½0$ÝOþß¦Ø :ÇMÕ‰8z 	‹J‚¸Ñ+JÃpâ@2ÎUÄ£h¾<fN%-0ƒë@[ÖôÙO6–ëˆTç™«Ì'RÎ/—÷pL rƒ"/@F<À³Êìm]ˆÜˆãE)¸{z!
*ƒé=N ÏYG2/=1¯ì)%þ¥>`’ßçm3þ½îÇ¿†´ÆÏõ¿\÷ÃÚžtÁs£0˜÷YnÊÀâú”œoÀÞON¢ââQl>s‹êv`Öú¼k"åxO!¯¢Ìið\Á3„ÿmtmþuÉ~³øÇâÿŠ}~Þœ~~ðHC´¯ÝŒÿ{÷¤ü²¯õ=³‰d-@ÆÏµƒW"¹§–•¨à¾à~ëüQRá‹uÁø¾)ÇlÅÂ’s0[÷=¬ ý¿xš°ÿñÁst"è½0Îû¥áLývüt|®AîGX,¶ÂûÉäÿ-ñzá[p¥˜{-Õþ´àÿm²®q3Ðe¶zM›)r‚ÿ‰œFÏ›“ðBCUÎíOÂÿkï:À¢8»îRÄÞvÆ®±KÁ.Ø°÷BQ)DÅ®±—Ø1Ö¨‰½k¢±wM4ÅôäKû’üé‰ÑóßóÎÌ² `‰Šú1ÏsŸÙí3{î=·¼÷¾¼%/Më"ïŒ!ëÂpƒ=H?“/su.n‹)Ãº£¥¿?q~¹³'<<y-D±1{‘kþ€6“@ŸOÔE¯èfµž¨WOKlk‹ûqVYï¾ªßÐˆ¡aØ8oþ:¿ ß¾7­w‘sí¡ì>ó}vÊæë3C,ø×|ÿz0½O…³©kj•Ó!—§=ïWöòX9×OBÒÑâÂ¶÷Oaÿ'—E\ÃÆwŽcô¾•pŸ†Â1Mµx@ßZ®q0c¾‰ù7ûÙE˜ä³Äp©ô 0z&ñÿcŸÏë$¯sön;öšÑº´ô{Û[Ö êõœYÌxýOÎÕ,Ïà¾h8º¬.°uÎ¼9
¿^žŠß®¬Ä‰Ç¿ãø&ßFåW€Âÿ‹.($ûb"<æùêmDlÿ¯»„o/mÄíË…›ÅÌM}0¿§àžý¼;f;£âdê„®j­ïIZíÏ‹ê6çawRý¾9ë#ï¸öpˆßþå^X¾}4®¾„»ÆÀoNO˜¢•þŠ[?×ÏOÇO×çáÇsñãå9¸¹6Î
GÎ'rõBáfÙûúú!0 Z·l‰vÌ3	8Ÿ¨“V3ªr…¬0â=U\ ?}°n½Dz#|à@,˜ƒwwMÇŸ7æã•}Q(2Æ_0fV¶Ÿ¹~}^P*üOáþþm­ñoô
2êˆ­ëÉ–_Bé¸@.…„Ck±úòal¹qBq€7Þ?M¢ˆÞÛ>OÕçãºB¥?êh¼"ÂÉøÏü¢ë€Ñ‚ÿÒ3‡ÿgû|~ˆø­ÎÞ~wìš¹ÿ“þSë‚Œféÿ/«ùåŒWqMÑ¸Ö(+þú‹3¡ÉÂH_…í¢ñÕÙüzi*®ÚŽÞÃà­?ÃgíT]®ë…š(#:à¥Õ@Ç×þÂÜýŸãÊ™·ðç;Ëñë…qØµgú½Òõ§û…ˆíž¨í9/™¾‘ÊIQ‰úA¤ÌÄŽ(ß^õýsŸÝc×EbÆæ(t]Ü¥Ú#ï˜Öh3¿víKÀû§¦a×ÁxÌÜƒ‡âpñÜT|sj®l‹…cú [û xy4‘ëÄ^Ä>ªyP‹@•+ì`Ì'
Ñê†X?ØUt@7Ñ=X3Ô½»Hôì!¬K9Þã£ÂprÝÜº6ož/\¥Ô¼Ð¡<ÏšÏŸ+-þ-¸7¸
öm-óåÓö	´ºM=Ð»*LKÃFð\ofÄî[Ž¥öaÕåCX}åÖ_}StÁIÜ*ûyrÍºl˜„Š:ÀžüŸ\bˆÐÞ÷[‘µ"q§g
ÿÏöùºöâ·:yùÞ²ósûÚ4Ä|ëžkR2˜YªÙsJ½€ül„oÚs~eŒŠŽ¾=­¯ê²"q›Â°óÀp|>¿_^†³'`Ê®ÏÑfýmÔŸ ¼ÐnÇ%@qÙ—Y¦é€îˆýù«Ž|Š›çwàÎ•)øèDæmîÿyÝPQpÎu>%éï³Ç¯Þã¿ÒDÿ”ò“:Á11DIÍ©]Eô€ÓŒP”KFá¸¶h0½«Ò7Å÷¿p,	‘«‡¢â”4œŠ);¢ðÉ¥™ÀÍ%øãÂ\¼¹z$Fî?oo4jä¦smn1ãí´¸@'Ý'PõƒôB;+Ÿ ´sWñ¿ºÊ±n$×gÍôhü|j~|ÿeHî[áûœné•’ëWØçm/KÎ/Çýà?•pÕ|UKà¤ùô]ÊÂ~`}Åñ'Y‡eàÑKÏïÃŠ°VtÀæë'…œÁ®/(Ÿ |Ç”Ol§åPµBz~0Âüªª~€í™Áÿs‚}¾¾µØªF>Ú»»½)ø?`Êh&Aº~A:ý*?Ó¨á1Î­á¬jÇñQij_4’ÿY÷Õ‘X¹+Ÿœ¿…×ß<»¯z‘¯ÿŠf¯uVjØ/!RFxAeÑuÖ ›€	{¿Åé3Çð÷»+ðÇ¥xáÑ{Y(^šÞe&„ xbG­×HYÑäÿ†àíròœÒ¢Š&t@Î1m`?ªŠ‰_àýrÌ|-
G'bá¶4œÖ¦ÍP"±-FoˆÀÕ3â»|¼?}²ï™†½ëb1st/ô‚·g¸¸p-¡·Š´

Dû6V¹Â`ÍèÖE¸€œûíBäZ† gh(¦ŽŠ«¯'©^d+FÃ1¾™`Ÿú”¸öVu~äSÖqÖüÜ?%ö¯ùþv–ÁéÄm,×HŸ!Å:±ý¥Æ¶D·S0çÔ,»t‹ÎïU=(KÏíU¹ÂMïžÀÞ.áÀ'W1ùÍ¨*¼K«¬«×+ýòø“Eº?¬ž	ü?GØçûÉ´®³×ïvuÜ'™»tP5šÿöÛƒq´ýi>ÔÎ.@{äå‹BcÛ¢Â”^¨7w(Z¼ŽÑ‡`ïÁ|}.¿^Y.{…ëwÙü7ê‰Ý/'¸/µL“²r»šóÜ ôßþÖ}_\Þ\›†›o‡aöæžðŸ#<_ì9ûûs¾GÉñÄzGd-`%ñ*
þKF!Á|î¸6ÂûÛ ¤ðÿ—¦vAðâ¾¸ršÎé!Ç[	/h…îKûaç¾xœ};	ëŒÃ¸×G`öÎœ9ž„¯ßžŽcÉ£?´ü›øÈõ4£±“šêqVœ]Üºµæ„´W>Ap»hÈž#íÑ·'¯ˆÇíë‹pâìD˜gïôP>¿ªñõFnÖùZ8ûáßM‰mz>š¥†ØY«¨õÉ7ÒM—GüÁdÁý>,Û?ïÌNÌ9ù†ª˜z–_<„ï¾-ï°íÖÄ£@¬Ÿ^TOÇ¿ë_¦p·C¦Pñ]>´žzü?gØç{4óÇuÜ¿4•ólejíV@þîZÇ¼ó~¸À½g]¹éõêpU¶p\øêPyZÔŸ;V„cñŽaxïdþ¹<ß^Ü„×ß¼Š¨í?£™`½¶`¾¼`¿ExAy‘ÚÂZnþIû¾Å™3§ñ÷µ•øùB<vï„ÁËºÀyz°pÁxBˆ’¢ãCÔÜ¿
œý'ú œØÿÒ¢¨J	(=¾Ê&v@…IÁâ;tÐæj‰ó{áÀÁ|{n^ÛÏ™¡È9*ÍôÄÛg¦ ßÉ—ûh)ÞÙ1óâú SPs¸:{ ±ë†8Ÿ¨yó ñ	h£æ·
j-~Bkñ‚± >ÿwz¾ýhz®ê[9?ŒùÛ²®W÷õsé¢áß+þ=¬ršÝ·µÂ¿…ë[zêÜŒ˜íW¶â³½4»†í^ˆ¹âÛ/<»sNïÄÌÛ0ëÄVÌ–ý|á +Åþ¿úÎ[˜v'B’Ç£è¨æzO!®`Ð™=†ßü‹ñ¬'RøAàõTãÿ9Ã~›6mÐ"  ž^(XÙ}»©¼{Mù•6jM‡ªá0³–C8œ‹p—ŸSfØßoLÀ:.`ŒpÖf[Ëÿ”3ìò	BIñÏÙ¤é’Á¶n0vì‹ÀçãwãÆÙýxyßÞ|×ÕóW	=PZt@dÀ[üþ;oaÉÑÏqYžÿ×åÙøél¶ìèE¬ÿAáä¬t¤)+¸§ßoñ_r|;ámstK˜b[ ÀØ6°bÎKR=Ç¢ÖEž˜ò[¼Ñ|^œ=-øÿJ|áƒóÓqýè$Y‹±ƒ;ÃßÛº
ð”ëÊõDr=[°×Pøû¶@pkñ)Âzáò–	¢?cùÁX8&È{uWq?û(mÆŸšù­ùý©ñŸ‚}…KÍOš~Áü[¯r²Ôpm@—õ1[ìü±ýóû³N¼Žoo°Uìÿv,:»[Å—‹_¾s!Ê'´Õz30´¡º®òùLÞ¡èüfòýŠ<Ðœ‘§ÿÏ!ö9;×Û»	*×sûÂ¶¼{S©†yRýfM0‡ËzŽm"ï=X\ ß3ÜÈA§Äù¿Í3Ò…ãÛ¡LRw¼ôò@t]†;ÂñÁ‰(±çIøäÜfl;ö.ÆîþÁ[D¼ªq€b"Ž¢*ˆ¨±ðíFïû‡OŸÇ¯×_®NÁùÃƒ0zU¸LÑ¸@<{ ¶Gþ¸v(ßAù	å'PBÔmGñŠÆ·E>áücZ¢„üÏÛ/ê£j&lˆD£éa€ÊÚ#iã0Ü<3žŽ»GaÒöØ}2__œ…wMÀ†¤Áˆm‡@ß¦p7{ÁÙYÄ¥	9{ÃÓÝCB;b×ÂàúBœ9—×Y!0±î>œ8ÖÖöåV~jü;¤âýéáß=þïŠÿs]/×õÿÏë¿%#0éèz¬¾t+.Æáú³ß~Cé€—…ÿ/>°ââA¬ìO9¾n‡ÂVÕUÓêÃœîè6â€HW¹ÖŽ³§ÿÏ)öùY5º~kWÁcªúémæ|r=_	™¬Ç2˜]~¸ uÚ°?áàcöÂuó‰Í-=±+êÎ€æ‹!,y’wÃÇ§â„Û/À§—öaý›ï£ï¿£ñz ’à¾´ð’k´}Ñ®›®;þÄŒ#_ãì¹ãøûêü|&Û¶÷B§…¡(#6>çèV*ÏWd\;•ë/!ÜßQçÿ¥Æ·GÉ„v(&: p|kámQsJG8Mï"˜ï€\£Åh˜ä0œ[ùød$®‹@­)PuŠßŽëg .ÆßççàÊkã„ß÷E×vpvrGšÎ¨]ÇÍ¼ý1od?üx|~¼9’û«s@¿ß†þý-Þ—Ëðû•¤àßaxÆ±›T:Àj¾¨Á†j~?_Ëµ>Q»–`áéÝX~á Øù½˜#>ÀlûôûWˆßŸ|õMÌ=­åý
²_@?½oõH¸íÂ¹®LáìàúPóÅž:ü?çØÏQÑc–©Œç‹÷<.yDŒ¸Àë"×D~¸¿¸@õFŸË¼z³ªoÉ7º9Š‹“º¡úŒ~h¹t(¦oŠKÇ†â¯+ãðÃ¥dì;qc÷ý€¶ÛþAý@9Ñ%Wkz L²¦ÌâÜý+¶¸Œ®‰ãpm.
GÔò®h0¹­øûmT’q¿|cÚ¢ˆè®a°è€ñí”í/Îçk{ñ÷MÃü`îÓ:c®ðÃ‡±hkM»áƒ"âËŒy5ïž›Žÿ¾7]›…ëç¦âÔ®x¬˜>ƒBÛÀÏÓ[ÄÃzvÄñU£ñÏXsx4Êè¦ðo/œ?OLS}¾·Ž{CÒà_á~¸68]ü[Ï6ðÏ¸ŸøìÄ1mäŽ…w cEâ®Á¸CÉ˜pt¦{MËˆíåâDî\„ÊIµ¾ ƒRÕÿ~j
w](~€|NÑ‡…ÛS…ÿçûåû¥]«Ý÷ù`=w„™\ ™îì‘û_?\½@Ú|”¦È8ãÚ^¸nîQjÝk<æ@ß•}±zû`|vjŒªùðÂN,{óCôØþ·ÂzUÁ|)Á~aÑ…E”È×‘ã­wÜBÒÑÿ¿>$¯›‹oÏDaõÖ^šÓQ¸@;ä.@)(~>y1áÿÅ4üÓö—)0V|±û¦¨fÂý[ Öäô[6 #VAÀœîÈ+ß5çyÏî¢Æã«‹3±õÐ8ŒØ8q¯…c×áx¼sx"­ŒÁœØÞ˜9¬.ŠÁWÇ§ãØ‰	^b'XWµ>¢sÆø ¯à?w´¯^ëÓ$UÍÏƒà?õõpÕû»5VkƒóÇú©Þ œÕ°,A+F£õê±Y7AÕü3¿?úÀ*$Y¨=¯¨yî9å3U¯°”ž¡j³Ý»›"<J<¨Ïo½=5øÏÆ~Æ{?i= †è5^WDþ«ÅÓfVCœ2ÏÆXOà¤Þ‡kXòÈÿ³`\kÕß»ò´Þhºp âÖÆ©#‘øóR<¾¿²O]BÒÁŸÐiû?xI¸@QÑyÿyEP\ü„Ú[€~û~ÂŽ3çðãõÍ¸}e2Žï‚+ºÂiªØýxâ¿5òÊgå=\[Åÿ‰J1ÅÄgÿ$ÿ˜V(#þA­¤`TŸØ^å1ìc›£Æ¤`ÌÜ4_ž›‰+o'¡çÒ>òÝEWˆO0wW4¾~gn]ž‡/wOÆço$áï3sñÙ¥™âã@öâÎo#Ø¶_?ÆWì¿¯Åþ[Äz½¯þYó›R÷ë–¦ö×êZý‚U­ž‹ªÓæçÎUb\âDeÛ£ÒÄÕC‰u¾MGÂgñpµ3†lT¯A}ŽH8ãýæâ×Íì×ÿ·°{*ðoÁ~Élìg´E¸8˜8+&Âì§j¼THÕ+2S.`Ò}ýL{¨R­ŽTý—‡y"Wl3áçíQvRwÔ™Ù!Ëúa¥p/O3v6Oøý^l>~=vþ…š"ë€|‚ý<¢Dò
7¨ô(O:ú5Îœ·¯-ÆÿÅ®r>Ï˜Ø£ƒ`7:¹ãZ*>Px\ùÜ6Ê(Á=9‚.…Æ´„ÃÈæ0Åø+ðrw,_€uC37Cåñmä7x£vR;ÌßO®ÌÆ_7Š3_|‘…À{‹°SxAí$®A›:ŒØÌÇŠÝûO±Æ¿Cªµþ)ñëÚ_{+ü[ÖýYôª³VŸGìid=8%7«ÖršU¿ ûanÈ5Âù„‹Q†¹§¼‡Zû«ô4g¬ü·a®ï~ðûoå±n–Yœ¥²±?{BG¸4ÔzD»°Wô…{ÇîÑ_ Âú?«Çä¿—K¸p>Ágá„”Òóû#qã œ;†?/ŽÃ÷×`ÿÉsˆ?øwÜFÍÍbûEä=`#:ÀNöùåþ‹¢‚÷üŽ5§ÞÃwï¾!úc>?>S×†ÂcZK”NB~Á?ó¹ãùävQñÿ‰J1Á~á	ùå»äüSJ'´†×¬®è»¬?, óôN‚ãæ¨2¾5â×†áä›pêØ$lÝ?ëöÁë‡â±Qö–÷CÁ‘ÍTŸkü„óçIÿ)Ø·®û»ÿ†ýO½&ÃEÃ«šÚHëçÊçrÑ+tHƒ4·¤øøõõÂÊßoh©ç}K®÷I‘¦÷ÿöÏ4þ­9¿­Â¾½½þÝîçûÆá’[›áâ­õ†43.ðMÆ:àÞó.ïZ_®ñ
þÏ#ùƒœõÑøåÞh»¨'’Ö÷Ãù#¬š‰®lÂ–“WÑoïh¼pŸÀAì¿Iðo=`/·‹‹nh´tä'l={?]IÆíóq8¾§/Â–vFÍIí—ö\`õA+Ì"öþ[‰ý}ÔBI±±-Q^ì}•‰íPVtC¬?r/^ÐçÞbßƒ—±vÇHÍEÝ)íÐ`z4˜ÚâEÏDûÁf˜7lGø
æuü‹®Ë>þÓÖþ¤Â>mô]k³,s¿8÷£ÄØ ”ŽŸ_¸†Â¹1pˆ7P÷ ëÞjYãs[®õGòþ‹å¶Yðïð$°ÿØðŸ†óÓækø·ÏÆþýnœ¥âìm^¥òAfòÃ;÷Ö™øiÖÙ’—
F
þ¸†ÏqbW4˜ÕCVöÃÞ=ƒñó¹‘øûÚ"œ»pIG¿ÎÄæÛ¯Óu …ú@ôB>9î¶ëOL=þ®_Ù->ÁlüçXæ­ëŠ¦3ÚÀ1>¹DØŒ„)6PÕü1Qt,¥¥ðþ@(º PÅ íhË£šŠíõVëŸC÷ÆÁÿÅã“Ðÿ•~È-vÓø¾Ø{›>pc´ûüMÄ~¹Ÿ;Ê×’÷³ðÿ»jÿRòÿ*ï?LçMCõšþÁúŒ?Šî¯ ×¹ƒà¹ Ž¢¶iÛ¾~áìéåü¾Èe9ßï‰|.çþ+‘oäØòœ_…1×÷‘‰=@ÃÍÝ„¯•~RØ,øO'ÖG¾oHîÜ¹ö,˜ý{mœ¡Å˜+dÒfJ~r\ÀûÖñkÃÐ×DšÕÝ–=°{Ì¿Õ¦vGàü^˜ºq ®½5B|ìéøöÚëØtò]ôÜ÷+jlòn_`ŽŠÜvØTxã´=ø’OŸÃ¯.Ç‹18¹·7†,í(v½%l„ËÛÄ4?PÕ(°f± Â}`JÓy…0hÝLpí'˜nç©›<+ ÆDÆ¼Ôz>îmFxÃŽ8×m~Þ‘"ºíO‹ýÔë}ÓÔü5?FM/±Ïõx–>]Úú«<1~h0»/ºoœ‚WQn|ÛnoY·ÃXžË|‘h‘$¹¿L‹ñºnÙg
w=©÷úZi
wïbŠðkí™ã™Åþ>1Ÿ7o^äÌ™S	ñ_¤H‘lì?ÈaŸ€3¥9[š3¦U®0.R—ži½@d^«×3.{dÕË¯db4.¶º?öîˆÿž…ÿ»¼ÇÏÀ¤·¾F³=·à¸EþDë5_@ÉZMä=Pkç}ì\¸²·Þƒ›oEaJr'xOBù„@Á<}þ@ØŠ.È92 GkØ§¨|¼ò]rñqÑÔ/&¶Áã[!ÿ(Ñ‚k»(Íæç~[ü„<J4ìç‰õûï“jfø'ïWœŸØUüÝIïî¦­Ÿ"×˜V(šØ5fôE›5	¶k	zlž¦åñõ?)ó~N‹_ß_¤¾ˆðzÖ€w’kÓK0&2Fd¤)Ü-D8L¥'‰ûGŽÿtü}bŸþ>ñ^´hQ…yÞ¦.(T¨P6öd‹0ÛÈÿ¦¤ØïÆâ
pÝ(ÿ§ïÎ¸Þ—°è‚ð”E6z¬Ú†¾¯à*ðsÇ„Õ'4`A7$¬ësG£ñÏ•YøîÚfl:u!û‡ãVát@°F×ÂŠðÝÿ˜qòÞ¿´Ÿ…sû{bä²Î¨5±­ø -`ŠöÐL>OóÿÙ™|€y€Br»€øyb›)|ç²’ÜÂWòŒôá|â+pŸWáßOãþ1÷ƒÿ&:þÝ5ÎÏ8í7{ö‡Ñ7
DÉ‰ÝPiæ Ô˜7ÇÂ}Ùh4_•€ÐÍ³&øï¾i*jOï¡âª*îgÔñD¸œÓây.•ÿùe_\®‘£HYÅëÂÍUE^”kêø¤â}ÿéøû†ÐÞïÄ~©R¥æÉýéûóvùòåQ±bÅlì?Èá.\ÀU|E—EZÌØ:.`k¿ “<µO`ä±äxáÔ¹w\³[0!5§‡¢ÿÊ>Ø¹{ ~8ƒŸ.-Âáó§0æØ7ðØû;
o¹­é€Õº$Ã(#z ÿÑ/ðöÅC*ÇøßSQX¶©üf´E1ñ£íÄ~Û‘ïÓ/ˆ@¾1-PHðO.PPðŸŸølçÞÍX@¹Ÿ_	±¯I^…{?þsÇèq¿´~¿Â¾µý÷Pë{5Î¯ÅílÄ`Ý²×‚!¼1vNÂô=“‘´k
¢¶MAMÓÐåµ—Ñ}Û\tÚ0.s¡çÕ×«µY.×MìÝnn(òÄbzOÿÎŸÚß'ç7ø>ã}Ä¼££#*Uª¤l}ñâÅÿ/S¦L6öt‹p'(-ÿ/‘©ãi±Ÿ‘0¸ulÀè/ ç¨ÈØSxxáqíUï?ß¹¡ˆµŽŒÀ¯—fâ×w7ãÀ…ÓèvèÜªÛþ5iô€øùÅW0ïýC¸À»øòÚÜ¾š€Ë`ÔrÑ-‰š0o
S”¿ª`Íb‘|r»€Ž÷¼ºä¬IÁ¾5þû±¾)ø·Ò–øJß•çW±>=V/¿Ûq|t\¥{'áÜ©©øÏÅøöâtÜ8=Û%aìë“ºq2Úm˜†6ë’à»t*Œo£—Ö»ç»7·y"ùü'ŠÿTœßÆ’ã#æißóçÏ¯âýÔÄ?í=ñ_«V-…wòê„^xA«S§N6ö`S×O‹2. \ÀM¸€«è×Ö¹¦ƒÿôâƒVuÄ¬ŒtS8ÉEŽ>ZãU§†¢Û’^Xÿú |w2¸6W/ïFÌ±ÏQs×?È±9?`pÑ…¶ÝFÏ#_àø¥ƒ¸sc!þ8‹Í[BÑvV”‰óƒm´L#¸6À6Ô1ö©
ˆßO)h…ûþuì§Åº¹ÿìÝ¯êoô™ÝùÅiµ4ëOÇ§çãöûË€O„Ä|"?êý5øäì\l;0	£·$ ÃºD¬„€ÕãP{ZwØRwª`#=þo>&#R9«±þHñŸ&Î¯ø¾nû‰yâŸö~?õ …·iï_|ñEÔ«W5kÖD¹rå”T«V-û÷¹¥º~.z\ÀÝI¤—àwÜ¿ÓüÇC×Xâƒ.V"¯¥Žî{áçÇ¶C…	!pš‚ðåÝpdïPÜ¾”ˆÛ×WbÓÙÓØÿ#
lÕ¸*=@a‘pÏ½?cÊÛïâƒËrçj"¾9Ö3Ö£Ö„@=ïç#üÃvÑ~šÍ©aÞ"©lü+ìûZ°Ÿ1þ9ÛÇ¬ó~'Ø÷AÝéÝ1ýxÜ<?·oÈÿx?î|uøî}à?çñÏ‡¯ã‹ós±iúo¿ä‰J4ž3 ö<oìã­êy]n	î?Y$R?«±þÈðŸNŽ¹}ŠÁý‰ÿ%J(ßž˜§ÿO1ì=±îæÆ¹”> / ÷wvv†««k6ö­¶û¾–îÔ\3–(xÝ/ò±ÈŸé¯%ÐÖ¯e^?häœÙÕjí›š“'X³ áå'tDðÂîX»µ¾{;w®ÎÀ¹K0êøpÙûò0G@ŸÀð> z ÌëcÈÑÏpúòQü~ãüz&ë¶ô@ËÙmPrŒ?ìÃ¶Q~pˆöW}òò×¸¿ÜNíû§à?5þ­Öü¦_ûç!¿SŸñ;Ä,>G+´^:ŽNÄ_×–àÖ;ÛñÝõ‹øòãoðý·à·ïpw>HÆ…cã1jóHø­ID³W§ÀcqòÆ4ÑÖñjøglõwö{hbŠp¶Íj¼ÿküg’ã£ŸÏx?ù¿aïÛ'¾©èóSó£¯ß¸qcxyy)ÌÓþS¨ˆû&MšüÏcÿ¡®g„[Á6ë†ºŠÌ7©õD.§¿–à>òiëôuÌ˜ÔúáàcZ«^N3:cèòî8°g0þº8¿ÝXO£ÝÁï‘o‹†÷T\`µv¬¸ø^û~Á˜ã7qêüøåâ4\?:sÖ÷F‹ÙP". v¢ì£ýTü/_ì§Žÿ5UkpòXá?mÌßºöO›íé¬õîüç‚þk£ð.û½³?]Ø‡‹'/ãíó_àò¿àó/Ç?_ œ`3>8™ˆñ¯ÅÀu<ü_
¿#Q*¾lTÝ@c«XŠË[‚ýv"y²ïÿ
ÿ™Ôôxg^ñ~
ë{èãÿ´÷Ä<¹¾ó£¿Oàïïoooõr òâ‘Çÿ±ÿH®k„Y¸€¹¹ÈTÁùa=>˜N\À5Ÿ ³µÅ)5ZŸ/±Í¾ÈÛ¹E”ŸØAóC±äµ¾øäøÁÏ>»‘o~†ú{þD¾mÐ|‚d+. ÇŠl¹ƒæû¾Ã¶s'ðûõuøõâìØ3tAÑÑÍaN.à«b|ùGÝ­TìØÖ$e½ï=ðoé¹ï‚‚	¹a$>>?¸¶ßžÜ‰#ûŽcÛÞË8pâ\¹öüúÉ5àæ&|x*‰[¢ÑtÕXø¬‚ÀÕãPcjWÑ9MRÖiø¿ Øï'â(b“Õ˜(ügã#ç·Îñ‘ßÓÆSXÇü\×­[Wqr úÿ...ÊÆ‹Ä{Ã†Q¿~}Åˆû   ÿì?òka.,ö»¾)Ü½›)Üm)<³¸@F}‡2è;¦÷±1ò‘ž°Í:ÿR‰¬ÉF¯Å]°vÛ |r"ß^Y…çßFï#_á…·T}Ð]q;Ñ^ûÁ–—DlÀ÷ç§`ÁæA¨3±%LÃ¼Uoî‘MQ`´¿ŠÐÈ7ÊÈýû©ºŸ¼¢(¬ûÍÿZÝçúÙ°VWÍâuA‘ñÑÿÕQ¸xjn_^‚N¬Ç™=;±wûÚWO_Ä7Ž×WãÊÛ‰Âÿ£á¹|š¬žˆ@ÑõfôRó[UßvcvK„ËU‘a‚ý*"vYùÆ9>Æù¾OîOÛÏzú÷´óŒÿ9¾*Uª(\Ó¯7|~£> ¿OÐ®];…yÆþ¨+|}}³±ÿ(®q¸GIÑ‚ÿ	ò?Ü¯ÖšD¸üv¯õÅ™¯'0úÞ¦Ø9®-Î!6×.¶rpmáø¶pŸÝ	3ÖuÇ‡G‡àÖÅ$\¿ôfŸ¼€?¡˜ð~U;Hì¯Y!²(!aæ©ðã;kñÅÉ±HXÓU•ý7÷Qu?™â?65þÓæüSãß]Ã?ëvÂ]Q$¡ü—DbÉîD|zj~?#:àø«øôÈ|üæ|fî\Ûˆ_/-Àîƒ	èûj,\_Ÿ•ãá·,FÍ fc†›>Û[Ç¿‹àßåÙÂ&9>ÚxÖóñ6ýâß:ŸGŽOûÏc¼M¬“ïëÜó9F€X'Î»wï®ô ýêŠ€€ „„„ S§NÏ%öŸØuw/"ÿïºòÿô²È)5sþž< =ü§ôÂ³^Sh£jÞ5.`ÑTt@ 
'´Aí)íÐkQ0¶½Þ?ž?ß]‰·/Á £Ÿ£Ôö4`†}îöÜÂ®'ðÓ¹‰Xµ±LlQMaÃ÷ŒöÓêþDr‰ääzÖ ;æ¢Y,¶Þ*ïwÎ?þz_Ù³î¸Úô^Y1«vÅãóÓâ\^$²¸°¸´?_œƒSo%aÒÖ8´Ÿßã•1ð^6õg÷SóUý eÒ'ä\÷qd¾&«1ßøO/Çg—bûÉïißº^êÃÞ3–Ç_õêÕUÐÈññ˜‡‡‡òë‰qúüF€Ç:tè t 1OÀç³Äqhhèsƒý,»Þ.%ûMEâäöVmJÆ}ˆ3‹	¤ÄŒ<QGìªæ—çüåP\ Æ¶†ûŒÌ\×G¸@$þ¹4ï\ÚŠ‰'?@ãýâ0W¸(ýÆÄûž_Žc»û hš¿`TôI¸7ì£üT0c€¬O6Ezi½½‡¸iû0]Èé™£Ðû|§—ó7ðoÏç²z¨6{=WŒJ$v@Í™}ÑiÅ0¼²{,.Ÿ˜„/ÎNÅ§§'ãòñ	Ø¶o,Æn‰+GÂ_¸¿ï+£Ð`ö@Òl¾QîrGÎÉ÷²_¯÷y{vâéôí¡¯oôï°®é¡?Ï8ã}F¯Á÷‰kîiÿÉˆuò}ëÜ3þOŸ€X'ß'Î‰ib¸E‹Š/ØïÕ«×3‹ý¬¾Þšp.$RMëCl6úßs>QÆ|À:.¢L¬§æ¡8»M4ó-Qub[t™×k·ôÃ×'ãðóÕåØrþ,ºýmüŠñ'?Á[ç^Ç©Ã£1bi{”ÕDõóà`Æÿûö1¬òÑÖý–Ïëï¤É Æñ\´õ:Ã¼`¥ÍûH½¿g
þ#ô¹}áN*Èºã
Sº£þÜAhþJ$GbÜÆ(%“‡!hiÜDÂkI,š	þ9ƒ±t|Õ@Ë#62üþŸäœÕ×ÿUy6ò™äø(FÃÞÓ¶ïŒéñ>ã¬ñe|Üžù<â›5Þf¼¿eË–ÊÎsO@¿Ÿú€Çˆñ!C†(Lóqêâ™X7$ûÿV°ñƒÍ'ÊLýqSõQywØ‹?nŠi†q-ažŒ¤äî¸tp(>;ó2N^<„ï\Ä7Ä7fcÖú¾¨1¾¹êÝÍ^^Ä»¼Þ&JÛ3Þ_q\ œ& é¤æð™à—ñ~¨>ÖÙû“ó¾"ÛŒIXq~ka_DõUÏÆ¢ÜQtL*þ«Í€Ê3û£æ¬~p7îó¡®ØùfDÍ9áp_ƒ&KF êä.òþž©{i5Ô<Ÿœÿæ%çºPV_ïûÂÿ=r|´ï´ûŒ÷ëxó#®Éå¹'ÿ7êüxŒ|¿Y³fJÐþu>M›6U¾>í=qJÀçëÄnß¾}¡pNûO=@\óø³„ý¬¾Æ™ë€´ó‰øùßé ëuÅ.*— Õj5¶1þjÍõ‰mÐq^0oˆ+Ç§àÖUÀÍWpùÍ8´žÓöÃÙÃ·‰êåcí«bÿäüôóÝ¦µÇÄW`ÿþœ?‡óÇãðÖáXlØŽ^» ØH_mÞg8{x)ã.ük}~Ô÷%nÅà|²ãÛ£æ´Þ¨%ø¯:£¿H_ÔPgVÔcuæ…óÂaðX‰—föF!æ&éç³æ7Ì’÷ÿI¸{»iyóSgûïÂyRiý}ƒ÷§Íñu½ÖëzˆkÚvÆõÈ	ÈxÌÈñµnÝZùôô(Ä;³Ä4c|Ìò9Ä.q†˜˜<ÁÁÁ
ÏŒ8PáÿiÆ~V_Û‡ÐÆ|¢-"ï˜TâûÉd0¯Ô²† eo#>à‘þ»½èrm×iŸÜ‡÷Gáì‘‘˜¼n ª&¶RØ'ïÏÍþ_Âù#›(›^a\s$®í‡ÎN>Ý |·øñˆìwáöÍå8zpZÍFNñˆròû4s¾´õþnšž"þåû±Ç@ÕÉ¡xI0_Oð^w¶à~f_Ô©+÷ë¿<nÂÑdñ08Í Çq­`©÷×æ±i}|]NÉû²[Å¬¾¶÷…ÿÒ¾EMe=¢ûXçøˆ{#ÇgÔôÐ¶Ó—çžz€œß¨ócþžq{ÖñÓ'0jýøí=cúÔ	ä Äº¡ŸŸ9@òâ~ÀÐ¡C­öÔF<¶ÿiÄ~V_Ó¡ŒùD"ãRúßÈHXÍÈÔëÔÚâNé¦(4¦ªMh…¦³Ú£í¼Îp›ŒârÌV¯÷q=Á>…ô×šÝ÷Äí’oNãÎ_âöo?¿}*:àM|wy!nCÃI-¿7…¹*½a;LÃ¿ƒŽÛáîÚoÐãõŒpnaíé½Pof±í}ó½Ed/ø¯7{ œæ†Ç‚0ñù‡ 
s}Â)4î`éùÁ÷üX«»2;‹<Ñ~>…ÿ
^¹û]MÊ¾gíï>¾Ñ»‡9~âßÈç1wgÔõòñnÄ÷iï‰q>‡q bÇó#^çãó¨+ßžøŒŒT¸¦N àqÚú#F ..áááJ/°.ˆqrúOö³úZ>:=À¾cÚ‡8í¬²´õƒÖÏ786ÛV|{r|®ûc"Â	¸æ?·êùá§l?ý~òþê[!!¹><1xïü~óüç“ÿÃW_ßÆo?ü&ø¿>zŽ%!ì•PŠö²ÄU}‚ŽÅû#õþèCÃ–¹ÿÑx1)ufægôB­é=PsFÔ–ÛuE4Ûï2w\æVs>
ŒôKé¦ÅûØƒ1¿"­EïÌêkyø·Q3«JÔÞlck›ªG·‘Ó'¾‰{£g'ïÓÞ3·gíó3þÇc´ý¬ß£½'Æu½F>ßÐäÄ¨‘ãã1b:€ÜžSOãŒ>\ùƒRñ ¾uñO^À÷ÍÆþ#Óéõ!Î”Üÿô{¤~›Ò*^'þ>ûýQ°X!öÕ\ÅýéûŽóGàÜNH~#
_Ÿž?/ïÄ§ç/âÄ¹/pâÚøøãðÇ—_¸²³7@ÙÑÞ0h¬bZ,ÐS_ócôòÖf÷p>X¹ñÁªïaÍi=QcZw¹Šê‚óš¢êˆŸßèåp™3õgõC‰±-5®O?%ÞGì¿¥ÅS]«fõ5¼?üÛ™Ê˜}L*|dkcº«?¿áßÓ—g®ú€1 â¸'ß'·gmc ÆÚ>Ã®Ã´ûÌPˆKÚvbzÀ€èÒ¥‹Òôûi»ÉçÓóùÉï©øXTT”â
Ô|ã‚ü¾¯†}ï'†ý¬¾~O@äÿ³Ñ‡Øj>ÑÃÕ¤®HY—Ècv´ÍÂï¹Ö· `¿0{ É>'û‚G(8ÚÍætÄª7¢ñ•àÿ[ñÞ[G±gïyì<|—.|€Ÿ>¼|v __žˆÿƒÍª§6×CQê}(>®5*%uÆ‹SBñâä®¨2¹‹’ªrŸº ÎŒžh ¸o8k *Mì¤Ö«xŸ^7 ÷û|O‹÷»z>¶_]ß†s˜J¹¶¶É_ö¦]8¤™ÍaÔøÐ¶“ßÓîÓç7òþ·§gLÏ!`ý®uŽº€þ ó|¼ÍcŒÝãÔäú<N}@@[?jÔ(…wê bÝˆðØ°aÃÔëé0VÀ×{àîšÌûY}Ýž¬0}ˆý¯v>‘Uµ–@xyŽ¨&j_ÁÑÍÿ¢š«œ?c •Æ·Ä˜µðþ‰i¸}i-¾:¶ÇvÂÑ='ðá©SøãÆaÜzN›€þKBQ0Zìÿ`Ææ©‹ðP=üã¬#.“ØÿìoTiR'¼0©3*Ëí'k öôž¢z)}PóÅŒÙ=áþïç\wÆû]‰<Uu~^[Úÿ²fOÛÂ/\Êá+ÝþüFßâšvž7úv2¾g¬×!Éó'çg>Ÿ¶ßàè´Ï|s|Ä+9;ñÌ}~Úyêê rb<66VéÚwbŸïÅçó9ôûùšV"ž¢ƒjÔwy¬ØÏêë•Åz í|¢ó&m6Éí‡Áª¸€U¾÷mÅN³~7¿øØôØÿÓ¥ÕþøÌÆö=#ñ×¥…ÀÅøáÔN|†óH÷ïoÂWçgbÖÆ!¨;¡%lUí ›K#½6Ÿü„sŠk…²‚QnbG”Û^Aö't=ÐUDTü×Ÿ ªð‚ãZ
OqKé“¨åúþ9'2F¾ÿY}ÿ&ÆÿmJ5š`Ÿ¯Äsçf^?/
ZÍæ`âüž¸&çg-/s|ä ÖÉÅi§‰q£—ãûÖñzêcîŸ·yŒ1=ò}ê#~×£GïgÜ:€Xç{SÇÐ÷7ÖpßNîSÏ¼äìýÇ®,q‘áZ®PÅ»3à ÷Óc$MÏR]Ð6;Dyi³{cýaÃ8@TS8ŽmAËzãä‘üyyðÞà£ÀÍdüru.6ìïiís¸–/Tù¿H}–—aûåý áß¥ƒE:¨>eEÊ'†(=ð‚p‚*SCQmJwUÀ9¡i°Ï÷úLdžÜf¬$wV_£Æ¿ÉdkªÐ´†M©†+s.õSœÍQ(ÝþüôùéÇÓ¿g¬Ÿy ƒ¤õùéX¯ï%^‰qb–±;úýŒÙy~æøÛ3|~ÚyúüŒý1&È\ yƒQK@}ÐR8¿Ü¯Ñ@üýŠûY}žFÑçÕé%²Pp{Â”î|¢´ýîÅÜRÖ«ÚAW-_ÕDõ!µQëÿ›©Þáý–öÆÒ7"pøH,N¿5{÷Ç`Ö¦Á˜‚±¾òzm]²Zçï¡ðoŠ0x¿»Šùk	Ç„vpßÎ²/•Ð^é âŸ1&w‘Û!úlA£ÎÇïÿYöDºš"œK=mëûïÿ&å”÷pµs¬¿,_ÑR+ZŽ%K¤Â>c{Fý}ÚqêrÖüy{bœX¥?Àç’£ó}{ò}ÆùxŒœž8'Ç'þ™ããmò â›>‚' `¬€:FÕ	ùø(¿Z]çÇb÷³úÚ<í¢ë€²é÷!Î˜ã©s™¬'0bŠÃ\UüÎVï7Â~ÿÅãðBbÔI
D½I-Pm|s8ŽöCî(o•WTuFÂì˜cŒLÑ+ä ¢Oò
ü·BñøÖ"­T3IK&´.Ð^|`OÆ"íTOcÝï§qýEÞóŒ×U×}ÚÖö?þõ­¼OûÒ“–¨ø}©ÒeP¾\™T³9 ÖÉí™·£gL>¿‘û7ÖìÒÞÓŽ½¼È¬s|FžŸB}@;O¾O=`Ä÷X!ý>Ÿu‚ä!¢c¼<=Q»±‡`ßí‘b?«¯É³(òÿ7úëó‰\ïs>QfsKÓÌ.ŽH™U¦­ðÒlüP7mÐ`m¦ÕØ³æ?ŠužZcÎÑpwñ'ØC¤…š1RdlK¨öÅÆµR: ”ð€²BPnBGÛJå-ý<ïç÷rýÌî¶Hë¹èV4«¯Á#Á?kÊ4qv(Ópe±Ò/üY¡B9TÖí¾ÑŸŸ1@cmí7qÍX?ãäüF]?1M¿x¥½6¸í9ñOŸŸÓÖëûŒx s|F|ßˆ+ð=µ<_+•ç«ãäõÈ9V_gU¬ú[Í'J¤7Ÿ(ƒµÅº°±Ô=\õõ\ãã©Ä&œÂZ~æö=ãöµþÞ©ò“Œ)0¿À¹Bôÿ)ÌùƒâÿÊP\nçâlßpg«^'
ÿ	ö›"<º›"¼Jˆ<•õýŒc+ãåâP¦ñŠâª}W¹Ê‹¨Y£º`¿–%®GÞO¾ÏXí7ãòÄ)ñO½@îOÜÓfÓ§7|~7ø>mýÈ‘# ®uc‚Ô´û|uuèrþê/¹<Rìgõuxž$e>‘™qc&KâÌðŸy\ ¥qJïAæòØk|¹ÖßA‰&jí¯WJ¿þÙÔì	Â˜bþØf(¨f	ˆ´P³Æ
ü ¾-Š
`ÏaµFÀÙ:Gñ·Zî:EðÿRVŸïu­2ÚX ¾€CyçÕe*×ù¥VÍš¨÷RÝtûó÷Ä:qMŸž> õm¶‘Ï7|~3Öøç†0Öøu½ÔŒýñµ¼ÏãAAòy6Ç—Õçÿy””ùDfáæ&KbóßÍ'Ë¸©5H»¦ÈUÅñìãÄ:í}Êœ/áýª·¿»ªKT¾û•Š/ÀÇÙ4oŒŸê!Êü¿ÒŠ*¾_|lkÅØÇDÕù)±Ô*|¦Å<]›	þdõùþW×ê^[yw·¼—U¬úÒ/õë×ƒ³`ßÕ
ûäýŒÇ÷Ä,9;qlôï5ÖñÒ–“Ó“ðq
ŸK;OŸ9>>8·®¦ý7Ö7mêûÈr|Y}ÞÿWDp"Ü˜}ˆ]õ>ÄÍ'J«2Zcœ¦ß¾žÈf¸†mûáZ?÷¶ªÎ×ÍR[Ä^_Ì%pû‚:€½
Œn¦×µPk É	ø-_èdë“ïîrDë£æê˜Õç÷__ŸûÙJ{ÕË]Áœ\¹v£ÿ:±ÖO°OûnÝ£›q:bš6ž¶œ¸çqb™1|âžÀˆíÏäüŒçu½F|Ÿ¯áûÒ¯0j{š5ód9¾¬>çÿkb2úG¸uÓæ™3èCl­2ï1p×ŒÃHW-6H> ‹±Ù˜kl§ì¿‡E<@Íé§f‹h=EýÕÜ0¾GÊLD…ÿ?Dç\™!Ÿ)¿Çõ™ôùS]›ûÙª4Ïi*íi.PÉuEíú.yyº«Ü›u~â”þ;ëñèïÓ®ÓnkxhçÇŒcáûF]/m¿¡ø:cM€áïW«ëô¯í~VŸëÿuÑæ¹¥3Ÿ(=^ý`Fk‹­ô†•Ø¦½©éMx©ZödÏ?ÎÓfù©ºC>ÇâkXz™¿Ÿµ)Ü­HÉ¬>Ÿäš<ÈVÖÃ)_%×U5¹}ëíí{§…ØiúäÄ0±O›nøîŒïÑÞ“¿=¼ž^ôùø>uƒQLî@=@®À÷	€>F-ù<»‘ãËêsœ-Vÿ·÷tæ™oe^?x¯<aúø·±Öúsµ:@w$Æ¹ŽGÅT¯PÎ
òÑó…ÖóNa^Ó½¿)Â³”ˆ}VŸËGr=d#(åÞ°@e÷•õÍÞ¿¶P¹¸ôúóÛ¬ßgŽ˜6rwÔŒéñ1ê bž¾ãû†éÐ¡=Z‹Îl:NMšógõ¹Í–Lþw–ùD*.pPäC‘{ôËH¤ÿ_ân¡ô€Šº«8¡ê6B‹¨u©ã”þ?S3T"<eõ¹{¤×áa¶Ò®…_ôXîäá÷cKÁiˆØéNVØ'7rÿFý>}|#îGÀÇÈ(|ù¾‘ãóõõù×9¾¬>¯Ùrÿ=K\À½³ìÅ§v=&òÛ]¾}ºõÄ©{
X$ÂºvèÞyEh|@ëè–Úök·Y×œ,ïÙAð_$«ÏÛ#½·ÙšJ{Ö/PÕkµ“góŸh³»vé’îlÚz#¾oÔû‘ó“+= øÖ‘Š<LŽ/«Ïc¶ü‹ÿ`„GQÁVÁûfìy_$ƒ>Ä™å
SðnŠ¼?üÛèþ€­¡KîÒ=®Ëþ¤È ùŽ•žÞo9÷»©¾înÅ«y-óòú«k—Îè!xVýùuì}zéóSP¾oÔõR0.@ÎÐAômÿKäü™`?«ÏY¶<†ÿa„[öÌi#2Y$“>ÄiuÀÝ=†î¯¦ÈJ"ÒÌ2Ñä–ÜÿHd±ˆ‹|Ç§º—ßC÷»•òhP¸šÏj7ÿÖßuîz§oŸÞ
÷iûósÏœ€Á÷Éõß7Öü3ŽÐ\Ž1¶¨sþªÙ˜ÿßÁY~7˜ÙOƒ=u2™IÛ{8ü=ÉÒY‡¬ú¹nÜ‡Š”ÎêsóXÎ÷¿Ýt47.ZÝgyÓÀöôéÝýûÝÝŸßX¿Ãõ ãýFŽÏèÛS9¾ŠîMŽOßœôly‚ÿÉ×|"/š´Þù“õâLæY¯)|püß}þÏÊûÿ¤œÈsgûÕ¹~D›}iWs‰ê¾Ëšß«g/èßOñ £??ù=í>ù>“óÓç'çgßÕ¯¯œÛTSÉFÙØÏ%‚?c>Ñ(“6Ÿˆ³
Ì<.xý­Ÿ“ö™üJn/Ü7ÎêóðXÏñ£Ú(f®_´†Ï*ßÀàŸ{ö`°×]ýùU^_pÏ=9?s|u=¿ÏQÖ<ÇT¤Fþ¬>Ùòt‰)õ|¢	"L÷èC¬ÕÝ{~ùÝ½ˆ-Â÷ß"¶¿»à¿xVŸƒÇz~ífc*çæîXÓ÷¿À¿õPõû©ûó}z[¶Ôò|Õê»ü`_¶q²)_Ù*Y}.²åéÁc“6O#BËÅ™/›î1ŸH	õÀ]y€L±Ï^†œw0Bð_KðŸ+«ûc=¯c+æÒ puß5îþ­¾ïÒQåYÀºž6j®Gµn¨F=×Ÿìë½aÊ]Ü#«ÏC¶<ý¢û•Lª±9Nd÷ýpÅ,:@Ç~d†Ïý¦_\˜|¦zù=Ô9}›Z/àj.ZÝ{™»oÐŸj&GËVjO«ÀæððòFõzæÿ³/Yw¿)W‘¦Y}²åÙ“êCln(2Ø¤õ»ç|¢ c?}üÿŸÈ^Áþ ‘rYý;ŸÈ¹|œ[I§ÂU›Ì«ëìûa#7Ÿ_Ý<}ñRc¯Ÿ+ÖrùÚ¾D­]¦œ…=³ú÷gË³)‚ÓÜ"ÒÌ'úæ~¸@&rIÞ+V¤&{fõo|"çñqnUªä49:ÕÌUÞ-ªPe×%ª8ïÌ]¶þN›"U&™r®Õ¿=[ž}Ñ{ÖbÅTÜÖ_³Z×'Yý»žØù{¼›IÕ
7*g*QÇÅT¨’“)cE“]žÿ	Ýš-OF´y¥j>Q-nçòšÈ€ÿïõXÂÀÿÞo9wÓt€Édo2å}¦z£gË³%‚_;»÷Y*÷OëñÁtú[ä=—Àxbcy]¾¬þO³Èù±³.é3gp_—pŠqÜk@¸6\Ž¹jÇÕc®ú1Š›öX„ÕqãùVb¼6Üœæ³ÓŠñ=Ìwžå{ß×úû¹éÏ7~y¤O÷÷epîuŽR}?Wý{¤÷ý¬¿·õcú¹UßÏ8WÖß/íg§óù÷ãwfúýÌ™|?wýÜºY]Çû½†éž?úeä}œä=ê}ˆ?Îÿ_™Ô\S—¦"ùµ>Æxž dã?ÿÏ?þ]Sþ÷sûáÖçS}—
r]Ø‡x‘I[ÃGŸ@ë5¢õüKä°H˜¼®ÜÝ×âé“lügãÿ¹Çªÿ@:byÌêýS³àßF®Ki9n–cƒDVŠ\Oéç£ê‰YSØH$GÊg¸¦#™=öä$ÿÙøþñŸÉ5LõXz×0íç¹æãìAì%2RnïùRä;‘}r¬¯IåïßÏ>þÿXŸÔ	   
```

`ReClass.NET/Settings.cs`:

```cs
using System.Drawing;
using System.Text;
using ReClassNET.Util;

namespace ReClassNET
{
	public class Settings
	{
		// Application Settings

		public string LastProcess { get; set; } = string.Empty;

		public bool StayOnTop { get; set; } = false;

		public bool RunAsAdmin { get; set; } = false;

		public bool RandomizeWindowTitle { get; set; } = false;

		// Node Drawing Settings

		public bool ShowNodeAddress { get; set; } = true;

		public bool ShowNodeOffset { get; set; } = true;

		public bool ShowNodeText { get; set; } = true;

		public bool HighlightChangedValues { get; set; } = true;

		public Encoding RawDataEncoding { get; set; } = Encoding.GetEncoding(1252); /* Windows-1252 */

		// Comment Drawing Settings

		public bool ShowCommentFloat { get; set; } = true;

		public bool ShowCommentInteger { get; set; } = true;

		public bool ShowCommentPointer { get; set; } = true;

		public bool ShowCommentRtti { get; set; } = true;

		public bool ShowCommentSymbol { get; set; } = true;

		public bool ShowCommentString { get; set; } = true;

		public bool ShowCommentPluginInfo { get; set; } = true;

		// Colors

		public Color BackgroundColor { get; set; } = Color.FromArgb(255, 255, 255);

		public Color SelectedColor { get; set; } = Color.FromArgb(240, 240, 240);

		public Color HiddenColor { get; set; } = Color.FromArgb(240, 240, 240);

		public Color OffsetColor { get; set; } = Color.FromArgb(255, 0, 0);

		public Color AddressColor { get; set; } = Color.FromArgb(0, 200, 0);

		public Color HexColor { get; set; } = Color.FromArgb(0, 0, 0);

		public Color TypeColor { get; set; } = Color.FromArgb(0, 0, 255);

		public Color NameColor { get; set; } = Color.FromArgb(32, 32, 128);

		public Color ValueColor { get; set; } = Color.FromArgb(255, 128, 0);

		public Color IndexColor { get; set; } = Color.FromArgb(32, 200, 200);

		public Color CommentColor { get; set; } = Color.FromArgb(0, 200, 0);

		public Color TextColor { get; set; } = Color.FromArgb(0, 0, 255);

		public Color VTableColor { get; set; } = Color.FromArgb(0, 255, 0);

		public Color PluginColor { get; set; } = Color.FromArgb(255, 0, 255);

		public CustomDataMap CustomData { get; } = new CustomDataMap();

		public Settings Clone() => MemberwiseClone() as Settings;
	}
}

```

`ReClass.NET/Symbols/ComDisposableWrapper.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Runtime.InteropServices;

namespace ReClassNET.Symbols
{
	class DisposableWrapper : IDisposable
	{
		protected object Object;

		[ContractInvariantMethod]
		private void ObjectInvariants()
		{
			Contract.Invariant(Object != null);
		}

		public DisposableWrapper(object obj)
		{
			Contract.Requires(obj != null);

			this.Object = obj;
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				Marshal.ReleaseComObject(Object);
			}
		}

		~DisposableWrapper()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);

			GC.SuppressFinalize(this);
		}
	}

	class ComDisposableWrapper<T> : DisposableWrapper
	{
		public T Interface => (T)Object;

		public ComDisposableWrapper(T com)
			: base(com)
		{
			Contract.Requires(com != null);
		}
	}
}

```

`ReClass.NET/Symbols/SymbolReader.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Text;
using Dia2Lib;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Native;

namespace ReClassNET.Symbols
{
	public class SymbolReader : IDisposable
	{
		private ComDisposableWrapper<DiaSource> diaSource;
		private ComDisposableWrapper<IDiaSession> diaSession;

		public SymbolReader()
		{
			diaSource = new ComDisposableWrapper<DiaSource>(new DiaSource());
		}

		protected virtual void Dispose(bool disposing)
		{
			if (diaSource != null)
			{
				diaSource.Dispose();
				diaSource = null;

				if (diaSession != null)
				{
					diaSession.Dispose();
					diaSession = null;
				}
			}
		}

		~SymbolReader()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public static void TryResolveSymbolsForModule(Module module, string searchPath)
		{
			Contract.Requires(module != null);

			using var diaSource = new ComDisposableWrapper<DiaSource>(new DiaSource());
			diaSource.Interface.loadDataForExe(module.Path, searchPath, null);
		}

		public static SymbolReader FromModule(Module module, string searchPath)
		{
			Contract.Requires(module != null);

			var reader = new SymbolReader();
			reader.diaSource.Interface.loadDataForExe(module.Path, searchPath, null);
			reader.CreateSession();
			return reader;
		}

		public static SymbolReader FromDatabase(string path)
		{
			Contract.Requires(path != null);

			var reader = new SymbolReader();
			reader.diaSource.Interface.loadDataFromPdb(path);
			reader.CreateSession();
			return reader;
		}

		private void CreateSession()
		{
			Contract.Ensures(diaSession != null);

			diaSource.Interface.openSession(out var session);

			diaSession = new ComDisposableWrapper<IDiaSession>(session);
		}

		public string GetSymbolString(IntPtr address, Module module)
		{
			Contract.Requires(module != null);

			var rva = address.Sub(module.Start);

			diaSession.Interface.findSymbolByRVA((uint)rva.ToInt32(), SymTagEnum.SymTagNull, out var diaSymbol);
			if (diaSymbol != null)
			{
				using var symbol = new ComDisposableWrapper<IDiaSymbol>(diaSymbol);

				var sb = new StringBuilder();
				ReadSymbol(symbol.Interface, sb);
				return sb.ToString();
			}
			return null;
		}

		private void ReadSymbol(IDiaSymbol symbol, StringBuilder sb)
		{
			Contract.Requires(symbol != null);
			Contract.Requires(sb != null);

			/*switch ((SymTagEnum)symbol.symTag)
			{
				case SymTagEnum.SymTagData:
					ReadData(symbol, sb);
					break;
				case SymTagEnum.SymTagFunction:
					sb.Append(symbol.callingConvention.ToString());
					ReadName(symbol, sb);
					break;
				case SymTagEnum.SymTagBlock:
					sb.AppendFormat("len({0:X08}) ", symbol.length);
					ReadName(symbol, sb);
					break;
			}

			ReadSymbolType(symbol, sb);*/
			ReadName(symbol, sb);
		}

		private void ReadSymbolType(IDiaSymbol symbol, StringBuilder sb)
		{
			Contract.Requires(symbol != null);
			Contract.Requires(sb != null);

			if (symbol.type != null)
			{
				using var type = new ComDisposableWrapper<IDiaSymbol>(symbol.type);

				ReadType(type.Interface, sb);
			}
		}

		private void ReadType(IDiaSymbol symbol, StringBuilder sb)
		{
			Contract.Requires(symbol != null);
			Contract.Requires(sb != null);

			throw new NotImplementedException();
		}

		private void ReadName(IDiaSymbol symbol, StringBuilder sb)
		{
			Contract.Requires(symbol != null);
			Contract.Requires(sb != null);

			if (string.IsNullOrEmpty(symbol.name))
			{
				return;
			}

			if (!string.IsNullOrEmpty(symbol.undecoratedName))
			{
				// If symbol.name equals symbol.undecoratedName there is some extra stuff which can't get undecorated. Try to fix it.
				if (symbol.name == symbol.undecoratedName)
				{
					var name = symbol.name;
					if (name.StartsWith("@ILT+"))
					{
						var start = name.IndexOf('(');
						if (start != -1)
						{
							name = name.Substring(start + 1, name.Length - 1 - start - 1);
						}
					}
					else if (!name.StartsWith("?"))
					{
						name = '?' + name;
					}

					sb.Append(NativeMethods.UndecorateSymbolName(name).TrimStart('?', ' '));
				}
				else
				{
					sb.Append(symbol.undecoratedName);
				}
			}
			else
			{
				sb.Append(symbol.name);
			}
		}

		private void ReadData(IDiaSymbol symbol, StringBuilder sb)
		{
			Contract.Requires(symbol != null);
			Contract.Requires(sb != null);

			throw new NotImplementedException();
		}
	}
}

```

`ReClass.NET/Symbols/SymbolStore.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using Dia2Lib;
using Microsoft.Win32;
using ReClassNET.Extensions;
using ReClassNET.Memory;
using ReClassNET.Native;

namespace ReClassNET.Symbols
{
	class DiaUtil : IDisposable
	{
		public readonly IDiaDataSource DiaDataSource;
		public readonly IDiaSession DiaSession;

		public DiaUtil(string pdbName)
		{
			Contract.Requires(pdbName != null);

			DiaDataSource = new DiaSource();
			DiaDataSource.loadDataFromPdb(pdbName);
			DiaDataSource.openSession(out DiaSession);
		}

		private bool isDisposed;

		protected virtual void Dispose(bool disposing)
		{
			if (!isDisposed)
			{
				Marshal.ReleaseComObject(DiaSession);
				Marshal.ReleaseComObject(DiaDataSource);

				isDisposed = true;
			}
		}

		~DiaUtil()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
	}

	public class SymbolStore
	{
		private const string BlackListFile = "blacklist.txt";

		public string SymbolCachePath { get; private set; } = "./SymbolsCache";

		public string SymbolDownloadPath { get; set; } = "http://msdl.microsoft.com/download/symbols";

		public string SymbolSearchPath => $"srv*{SymbolCachePath}*{SymbolDownloadPath}";

		private readonly Dictionary<string, SymbolReader> symbolReaders = new Dictionary<string, SymbolReader>();

		private readonly HashSet<string> moduleBlacklist = new HashSet<string>();

		public SymbolStore()
		{
			if (NativeMethods.IsUnix())
			{
				// TODO: Are there symbol files like on windows?

				return;
			}

			ResolveSearchPath();

			var blacklistPath = Path.Combine(SymbolCachePath, BlackListFile);

			if (File.Exists(blacklistPath))
			{
				File.ReadAllLines(Path.Combine(SymbolCachePath, BlackListFile))
					.Select(l => l.Trim().ToLower())
					.ForEach(l => moduleBlacklist.Add(l));
			}
		}

		private void ResolveSearchPath()
		{
			using var vsKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\VisualStudio");
			if (vsKey == null)
			{
				return;
			}

			foreach (var subKeyName in vsKey.GetSubKeyNames())
			{
				using var debuggerKey = vsKey.OpenSubKey($@"{subKeyName}\Debugger");
				if (debuggerKey?.GetValue("SymbolCacheDir") is string symbolCacheDir)
				{
					if (Directory.Exists(symbolCacheDir))
					{
						SymbolCachePath = symbolCacheDir;
					}

					break;
				}
			}
		}

		public void TryResolveSymbolsForModule(Module module)
		{
			Contract.Requires(module != null);
			Contract.Requires(module.Name != null);

			if (NativeMethods.IsUnix())
			{
				return;
			}

			var name = module.Name.ToLower();

			bool isBlacklisted;
			lock (symbolReaders)
			{
				isBlacklisted = moduleBlacklist.Contains(name);
			}

			if (!isBlacklisted)
			{
				try
				{
					SymbolReader.TryResolveSymbolsForModule(module, SymbolSearchPath);
				}
				catch
				{
					lock (symbolReaders)
					{
						moduleBlacklist.Add(name);

						File.WriteAllLines(
							Path.Combine(SymbolCachePath, BlackListFile),
							moduleBlacklist.ToArray()
						);
					}
				}
			}
		}

		public void LoadSymbolsForModule(Module module)
		{
			Contract.Requires(module != null);
			Contract.Requires(module.Name != null);

			if (NativeMethods.IsUnix())
			{
				return;
			}

			var moduleName = module.Name.ToLower();

			bool createNew;
			lock (symbolReaders)
			{
				createNew = !symbolReaders.ContainsKey(moduleName);
			}

			if (createNew)
			{
				var reader = SymbolReader.FromModule(module, SymbolSearchPath);
				
				lock(symbolReaders)
				{
					symbolReaders[moduleName] = reader;
				}
			}
		}

		public void LoadSymbolsFromPDB(string path)
		{
			Contract.Requires(path != null);

			if (NativeMethods.IsUnix())
			{
				return;
			}

			var moduleName = Path.GetFileName(path)?.ToLower();
			if (string.IsNullOrEmpty(moduleName))
			{
				return;
			}

			bool createNew;
			lock (symbolReaders)
			{
				createNew = !symbolReaders.ContainsKey(moduleName);
			}

			if (createNew)
			{
				var reader = SymbolReader.FromDatabase(path);

				lock (symbolReaders)
				{
					symbolReaders[moduleName] = reader;
				}
			}
		}

		public SymbolReader GetSymbolsForModule(Module module)
		{
			Contract.Requires(module != null);
			Contract.Requires(module.Name != null);

			if (NativeMethods.IsUnix())
			{
				return null;
			}

			var name = module.Name.ToLower();

			lock (symbolReaders)
			{
				if (!symbolReaders.TryGetValue(name, out var reader))
				{
					name = Path.ChangeExtension(name, ".pdb");

					symbolReaders.TryGetValue(name, out reader);
				}
				return reader;
			}
		}
	}
}

```

`ReClass.NET/UI/BannerFactory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Linq;

namespace ReClassNET.UI
{
	public static class BannerFactory
	{
		private const int StdHeight = 48; // 96 DPI
		private const int StdIconDim = 32;

		private const int MaxCacheEntries = 20;
		private static readonly Dictionary<string, Image> imageCache = new Dictionary<string, Image>();

		/// <summary>Creates a banner with the given <paramref name="icon"/>, <paramref name="title"/> and <paramref name="text"/>.</summary>
		/// <param name="bannerWidth">Width of the banner.</param>
		/// <param name="bannerHeight">Height of the banner.</param>
		/// <param name="icon">The icon of the banner.</param>
		/// <param name="title">The title of the banner.</param>
		/// <param name="text">The text of the banner.</param>
		/// <param name="skipCache">True to skip cache.</param>
		/// <returns>The created banner.</returns>
		public static Image CreateBanner(int bannerWidth, int bannerHeight, Image icon, string title, string text, bool skipCache)
		{
			Contract.Requires(title != null);
			Contract.Requires(text != null);

			var bannerId = $"{bannerWidth}x{bannerHeight}:{title}:{text}";

			if (skipCache || !imageCache.TryGetValue(bannerId, out var image))
			{
				image = new Bitmap(bannerWidth, bannerHeight, PixelFormat.Format24bppRgb);
				using (var g = Graphics.FromImage(image))
				{
					int xIcon = DpiScaleInt(10, bannerHeight);

					var rect = new Rectangle(0, 0, bannerWidth, bannerHeight);
					using (var brush = new LinearGradientBrush(rect, Color.FromArgb(151, 154, 173), Color.FromArgb(27, 27, 37), LinearGradientMode.Vertical))
					{
						g.FillRectangle(brush, rect);
					}

					int wIconScaled = StdIconDim;
					if (icon != null)
					{
						var iconRel = icon.Width / (float)icon.Height;
						wIconScaled = (int)Math.Round(DpiScaleFloat(iconRel * StdIconDim, bannerHeight));
						var hIconScaled = DpiScaleInt(StdIconDim, bannerHeight);

						int yIcon = (bannerHeight - hIconScaled) / 2;
						if (hIconScaled == icon.Height)
						{
							g.DrawImageUnscaled(icon, xIcon, yIcon);
						}
						else
						{
							g.DrawImage(icon, xIcon, yIcon, wIconScaled, hIconScaled);
						}

						var attributes = new ImageAttributes();
						attributes.SetColorMatrix(new ColorMatrix
						{
							Matrix33 = 0.1f
						});

						int w = wIconScaled * 2;
						int h = hIconScaled * 2;
						int x = bannerWidth - w - xIcon;
						int y = (bannerHeight - h) / 2;
						g.DrawImage(icon, new Rectangle(x, y, w, h), 0, 0, icon.Width, icon.Height, GraphicsUnit.Pixel, attributes);
					}

					int tx = 2 * xIcon;
					int ty = DpiScaleInt(4, bannerHeight);
					if (icon != null)
					{
						tx += wIconScaled;
					}

					float fontSize = DpiScaleFloat((12.0f * 96.0f) / g.DpiY, bannerHeight);
					using (var font = new Font(FontFamily.GenericSansSerif, fontSize, FontStyle.Bold))
					{
						DrawText(g, title, tx, ty, font, Color.White);
					}

					tx += xIcon;
					ty += xIcon * 2 + 2;

					float fontSizeSmall = DpiScaleFloat((9.0f * 96.0f) / g.DpiY, bannerHeight);
					using (var fontSmall = new Font(FontFamily.GenericSansSerif, fontSizeSmall, FontStyle.Regular))
					{
						DrawText(g, text, tx, ty, fontSmall, Color.White);
					}
				}

				if (!skipCache)
				{
					while (imageCache.Count > MaxCacheEntries)
					{
						imageCache.Remove(imageCache.Keys.First());
					}

					imageCache[bannerId] = image;
				}
			}

			return image;
		}

		private static void DrawText(Graphics g, string text, int x, int y, Font font, Color color)
		{
			using var brush = new SolidBrush(color);
			using var format = new StringFormat(StringFormatFlags.FitBlackBox | StringFormatFlags.NoClip);

			g.DrawString(text, font, brush, x, y, format);
		}

		private static int DpiScaleInt(int x, int height) => (int)Math.Round((x * height) / (double)StdHeight);

		private static float DpiScaleFloat(float x, int height) => (x * height) / StdHeight;
	}
}

```

`ReClass.NET/UI/BindingDisplayWrapper.cs`:

```cs
using System;
using System.Diagnostics.Contracts;

namespace ReClassNET.UI
{
	public class BindingDisplayWrapper<T>
	{
		public T Value { get; }
		private readonly Func<T, string> toString;

		public BindingDisplayWrapper(T value, Func<T, string> toString)
		{
			Contract.Requires(toString != null);

			Value = value;
			this.toString = toString;
		}

		public override string ToString() => toString(Value);
	}
}

```

`ReClass.NET/UI/CustomToolStripProfessionalRenderer.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace ReClassNET.UI
{
	internal class CustomToolStripProfessionalRenderer : ToolStripProfessionalRenderer
	{
		private readonly bool renderGrip;
		private readonly bool renderBorder;

		public CustomToolStripProfessionalRenderer(bool renderGrip, bool renderBorder)
			: base(new CustomProfessionalColorTable())
		{
			this.renderGrip = renderGrip;
			this.renderBorder = renderBorder;
		}

		protected override void OnRenderGrip(ToolStripGripRenderEventArgs e)
		{
			if (renderGrip)
			{
				base.OnRenderGrip(e);
			}
		}

		protected override void OnRenderToolStripBorder(ToolStripRenderEventArgs e)
		{
			if (renderBorder)
			{
				base.OnRenderToolStripBorder(e);
			}
		}

		protected override void OnRenderToolStripPanelBackground(ToolStripPanelRenderEventArgs e)
		{
			//base.OnRenderToolStripPanelBackground(e);
		}
	}

	internal class CustomProfessionalColorTable : ProfessionalColorTable
	{
		public override Color MenuStripGradientBegin => SystemColors.Control;

		public override Color MenuStripGradientEnd => SystemColors.Control;

		public override Color ToolStripGradientBegin => SystemColors.Control;

		public override Color ToolStripGradientMiddle => SystemColors.Control;

		public override Color ToolStripGradientEnd => SystemColors.Control;
	}
}

```

`ReClass.NET/UI/DpiUtil.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using ReClassNET.Native;

namespace ReClassNET.UI
{
	public static class DpiUtil
	{
		public const int DefalutDpi = 96;

		private static int dpiX = DefalutDpi;
		private static int dpiY = DefalutDpi;

		private static double scaleX = 1.0;
		private static double scaleY = 1.0;

		public static void ConfigureProcess()
		{
			NativeMethods.SetProcessDpiAwareness();
		}

		public static void SetDpi(int x, int y)
		{
			dpiX = x;
			dpiY = y;

			if (dpiX <= 0 || dpiY <= 0)
			{
				dpiX = DefalutDpi;
				dpiY = DefalutDpi;
			}

			scaleX = dpiX / (double)DefalutDpi;
			scaleY = dpiY / (double)DefalutDpi;
		}

		public static void TrySetDpiFromCurrentDesktop()
		{
			try
			{
				using var g = Graphics.FromHwnd(IntPtr.Zero);

				SetDpi((int)g.DpiX, (int)g.DpiY);
			}
			catch
			{
				// ignored
			}
		}

		public static int ScaleIntX(int i)
		{
			return (int)Math.Round(i * scaleX);
		}

		public static int ScaleIntY(int i)
		{
			return (int)Math.Round(i * scaleY);
		}

		public static Image ScaleImage(Image sourceImage)
		{
			if (sourceImage == null)
			{
				return null;
			}

			var width = sourceImage.Width;
			var height = sourceImage.Height;
			var scaledWidth = ScaleIntX(width);
			var scaledHeight = ScaleIntY(height);

			if (width == scaledWidth && height == scaledHeight)
			{
				return sourceImage;
			}

			return ScaleImage(sourceImage, scaledWidth, scaledHeight);
		}

		private static Image ScaleImage(Image sourceImage, int width, int height)
		{
			Contract.Requires(sourceImage != null);
			Contract.Requires(width >= 0);
			Contract.Requires(height >= 0);

			var scaledImage = new Bitmap(width, height, PixelFormat.Format32bppArgb);

			using var g = Graphics.FromImage(scaledImage);
			g.Clear(Color.Transparent);

			g.SmoothingMode = SmoothingMode.HighQuality;
			g.CompositingQuality = CompositingQuality.HighQuality;

			var sourceWidth = sourceImage.Width;
			var sourceHeight = sourceImage.Height;

			var interpolationMode = InterpolationMode.HighQualityBicubic;
			if (sourceWidth > 0 && sourceHeight > 0)
			{
				if ((width % sourceWidth) == 0 && (height % sourceHeight) == 0)
				{
					interpolationMode = InterpolationMode.NearestNeighbor;
				}
			}

			g.InterpolationMode = interpolationMode;

			var srcRect = new RectangleF(0.0f, 0.0f, sourceWidth, sourceHeight);
			var destRect = new RectangleF(0.0f, 0.0f, width, height);
			AdjustScaleRects(ref srcRect, ref destRect);

			g.DrawImage(sourceImage, destRect, srcRect, GraphicsUnit.Pixel);

			return scaledImage;
		}

		private static void AdjustScaleRects(ref RectangleF srcRect, ref RectangleF destRect)
		{
			if (destRect.Width > srcRect.Width)
				srcRect.X -= 0.5f;
			if (destRect.Height > srcRect.Height)
				srcRect.Y -= 0.5f;

			if (destRect.Width < srcRect.Width)
				srcRect.X += 0.5f;
			if (destRect.Height < srcRect.Height)
				srcRect.Y += 0.5f;
		}
	}
}

```

`ReClass.NET/UI/FontEx.cs`:

```cs
using System.Drawing;

namespace ReClassNET.UI
{
	public class FontEx
	{
		public Font Font { get; set; }
		public int Width { get; set; }
		public int Height { get; set; }
	}
}

```

`ReClass.NET/UI/GlobalWindowManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;

namespace ReClassNET.UI
{
	public sealed class GlobalWindowManagerEventArgs : EventArgs
	{
		public Form Form { get; }

		public GlobalWindowManagerEventArgs(Form form)
		{
			Contract.Requires(form != null);

			Form = form;
		}
	}

	public static class GlobalWindowManager
	{
		private static readonly List<Form> windows = new List<Form>();

		public static Form TopWindow => windows.LastOrDefault();
		public static IEnumerable<Form> Windows => windows;

		public static event EventHandler<GlobalWindowManagerEventArgs> WindowAdded;
		public static event EventHandler<GlobalWindowManagerEventArgs> WindowRemoved;

		public static void AddWindow(Form form)
		{
			Contract.Requires(form != null);

			windows.Add(form);

			form.TopMost = Program.Settings.StayOnTop;

			WindowAdded?.Invoke(null, new GlobalWindowManagerEventArgs(form));
		}

		public static void RemoveWindow(Form form)
		{
			Contract.Requires(form != null);

			if (windows.Remove(form))
			{
				WindowRemoved?.Invoke(null, new GlobalWindowManagerEventArgs(form));
			}
		}
	}
}

```

`ReClass.NET/UI/HotSpot.cs`:

```cs
using System;
using System.Drawing;
using ReClassNET.Memory;
using ReClassNET.Nodes;

namespace ReClassNET.UI
{
	public enum HotSpotType
	{
		None,
		Edit,
		OpenClose,
		Select,
		Click,
		DoubleClick,
		ChangeClassType,
		ChangeWrappedType,
		ChangeEnumType,
		Context,
		Delete,
		Address,
		Name,
		Comment
	}

	public class HotSpot
	{
		public const int NoneId = -1;
		public const int AddressId = 100;
		public const int NameId = 101;
		public const int CommentId = 102;
		public const int ReadOnlyId = 999;

		public int Id { get; set; }
		public HotSpotType Type { get; set; }
		public int Level { get; set; }

		public string Text { get; set; }
		public BaseNode Node { get; set; }

		public Rectangle Rect { get; set; }

		public IntPtr Address { get; set; }

		public RemoteProcess Process { get; set; }

		public MemoryBuffer Memory { get; set; }
	}
}

```

`ReClass.NET/UI/IconProvider.cs`:

```cs
using System.Drawing;

namespace ReClassNET.UI
{
	public class IconProvider
	{
		public int Dimensions { get; } = DpiUtil.ScaleIntX(16);

		public Image OpenCloseOpen { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Open_Icon);
		public Image OpenCloseClosed { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Closed_Icon);
		public Image Delete { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Button_Delete);
		public Image DropArrow { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Button_Drop_Down);
		public Image Class { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Class_Type);
		public Image Enum { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Enum_Type);
		public Image Array { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Array_Type);
		public Image Union => Array;
		public Image LeftArrow { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Left_Button);
		public Image RightArrow { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Right_Button);
		public Image Change { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Exchange_Button);
		public Image Unsigned { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Unsigned_Type);
		public Image Signed { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Signed_Type);
		public Image Float { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Float_Type);
		public Image Double { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Double_Type);
		public Image Vector { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Vector_Type);
		public Image Matrix { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Matrix_Type);
		public Image Text { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Text_Type);
		public Image Pointer { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Pointer_Type);
		public Image Function { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Function_Type);
		public Image VirtualTable { get; } = DpiUtil.ScaleImage(Properties.Resources.B16x16_Interface_Type);
	}
}

```

`ReClass.NET/UI/LinkedWindowFeatures.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Debugger;
using ReClassNET.Forms;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Nodes;

namespace ReClassNET.UI
{
	public class LinkedWindowFeatures
	{
		public static ClassNode CreateClassAtAddress(IntPtr address, bool addDefaultBytes)
		{
			Contract.Ensures(Contract.Result<ClassNode>() != null);

			var classView = Program.MainForm.ProjectView;

			var node = ClassNode.Create();
			node.AddressFormula = address.ToString("X");
			if (addDefaultBytes)
			{
				node.AddBytes(16 * IntPtr.Size);
			}

			classView.SelectedClass = node;

			return node;
		}

		public static ClassNode CreateDefaultClass()
		{
			Contract.Ensures(Contract.Result<ClassNode>() != null);

			var address = ClassNode.DefaultAddress;

			var mainModule = Program.RemoteProcess.GetModuleByName(Program.RemoteProcess.UnderlayingProcess?.Name);
			if (mainModule != null)
			{
				address = mainModule.Start;
			}

			return CreateClassAtAddress(address, true);
		}

		public static void SetCurrentClassAddress(IntPtr address)
		{
			var classNode = Program.MainForm.ProjectView.SelectedClass;
			if (classNode == null)
			{
				return;
			}

			classNode.AddressFormula = address.ToString("X");
		}

		public static void FindWhatInteractsWithAddress(IntPtr address, int size, bool writeOnly)
		{
			var debugger = Program.RemoteProcess.Debugger;

			if (!debugger.AskUserAndAttachDebugger())
			{
				return;
			}

			if (writeOnly)
			{
				debugger.FindWhatWritesToAddress(address, size);
			}
			else
			{
				debugger.FindWhatAccessesAddress(address, size);
			}
		}

		public static void StartMemoryScan(IScanComparer comparer)
		{
			Contract.Requires(comparer != null);

			var sf = GlobalWindowManager.Windows.OfType<ScannerForm>().FirstOrDefault();
			if (sf != null)
			{
				if (MessageBox.Show("Open a new scanner window?", Constants.ApplicationName, MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.Yes)
				{
					sf = null;
				}
			}
			if (sf == null)
			{
				sf = new ScannerForm(Program.RemoteProcess);
				sf.Show();
			}

			var settings = ScanSettings.Default;
			switch (comparer)
			{
				case ByteMemoryComparer _:
					settings.ValueType = ScanValueType.Byte;
					break;
				case ShortMemoryComparer _:
					settings.ValueType = ScanValueType.Short;
					settings.FastScanAlignment = 2;
					break;
				case IntegerMemoryComparer _:
					settings.ValueType = ScanValueType.Integer;
					settings.FastScanAlignment = 4;
					break;
				case LongMemoryComparer _:
					settings.ValueType = ScanValueType.Long;
					settings.FastScanAlignment = 4;
					break;
				case FloatMemoryComparer _:
					settings.ValueType = ScanValueType.Float;
					settings.FastScanAlignment = 4;
					break;
				case DoubleMemoryComparer _:
					settings.ValueType = ScanValueType.Double;
					settings.FastScanAlignment = 4;
					break;
				case ArrayOfBytesMemoryComparer _:
					settings.ValueType = ScanValueType.ArrayOfBytes;
					break;
				case StringMemoryComparer _:
					settings.ValueType = ScanValueType.String;
					break;
			}

			sf.ExcuteScan(settings, comparer);
		}
	}
}

```

`ReClass.NET/UI/NodeTypesBuilder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using ReClassNET.Controls;
using ReClassNET.Nodes;
using ReClassNET.Plugins;

namespace ReClassNET.UI
{
	internal static class NodeTypesBuilder
	{
		private static readonly List<Type[]> defaultNodeTypeGroupList = new List<Type[]>();
		private static readonly Dictionary<Plugin, IReadOnlyList<Type>> pluginNodeTypes = new Dictionary<Plugin, IReadOnlyList<Type>>();

		static NodeTypesBuilder()
		{
			defaultNodeTypeGroupList.Add(new[] { typeof(Hex64Node), typeof(Hex32Node), typeof(Hex16Node), typeof(Hex8Node) });
			defaultNodeTypeGroupList.Add(new[] { typeof(NIntNode), typeof(Int64Node), typeof(Int32Node), typeof(Int16Node), typeof(Int8Node) });
			defaultNodeTypeGroupList.Add(new[] { typeof(NUIntNode), typeof(UInt64Node), typeof(UInt32Node), typeof(UInt16Node), typeof(UInt8Node) });
			defaultNodeTypeGroupList.Add(new[] { typeof(BoolNode), typeof(BitFieldNode), typeof(EnumNode) });
			defaultNodeTypeGroupList.Add(new[] { typeof(FloatNode), typeof(DoubleNode) });
			defaultNodeTypeGroupList.Add(new[] { typeof(Vector4Node), typeof(Vector3Node), typeof(Vector2Node), typeof(Matrix4x4Node), typeof(Matrix3x4Node), typeof(Matrix3x3Node) });
			defaultNodeTypeGroupList.Add(new[] { typeof(Utf8TextNode), typeof(Utf8TextPtrNode), typeof(Utf16TextNode), typeof(Utf16TextPtrNode) });
			defaultNodeTypeGroupList.Add(new[] { typeof(PointerNode), typeof(ArrayNode), typeof(UnionNode) });
			defaultNodeTypeGroupList.Add(new[] { typeof(ClassInstanceNode) });
			defaultNodeTypeGroupList.Add(new[] { typeof(VirtualMethodTableNode), typeof(FunctionNode), typeof(FunctionPtrNode) });
		}

		public static void AddPluginNodeGroup(Plugin plugin, IReadOnlyList<Type> nodeTypes)
		{
			Contract.Requires(plugin != null);
			Contract.Requires(nodeTypes != null);

			if (pluginNodeTypes.ContainsKey(plugin))
			{
				throw new InvalidOperationException(); // TODO
			}

			pluginNodeTypes.Add(plugin, nodeTypes);
		}

		public static void RemovePluginNodeGroup(Plugin plugin)
		{
			Contract.Requires(plugin != null);

			pluginNodeTypes.Remove(plugin);
		}

		public static IEnumerable<ToolStripItem> CreateToolStripButtons(Action<Type> handler)
		{
			Contract.Requires(handler != null);

			var clickHandler = new EventHandler((sender, e) => handler((sender as TypeToolStripButton)?.Value ?? ((TypeToolStripMenuItem)sender).Value));

			return CreateToolStripItems(t =>
			{
				GetNodeInfoFromType(t, out var label, out var icon);

				var item = new TypeToolStripButton
				{
					Value = t,
					ToolTipText = label,
					DisplayStyle = ToolStripItemDisplayStyle.Image,
					Image = icon
				};
				item.Click += clickHandler;
				return item;
			}, p => new ToolStripDropDownButton
			{
				ToolTipText = "",
				Image = p.Icon
			}, t =>
			{
				GetNodeInfoFromType(t, out var label, out var icon);

				var item = new TypeToolStripMenuItem
				{
					Value = t,
					Text = label,
					Image = icon
				};
				item.Click += clickHandler;
				return item;
			});
		}

		public static IEnumerable<ToolStripItem> CreateToolStripMenuItems(Action<Type> handler, bool addNoneType)
		{
			Contract.Requires(handler != null);

			var clickHandler = new EventHandler((sender, e) => handler(((TypeToolStripMenuItem)sender).Value));

			var items = CreateToolStripItems(t =>
			{
				GetNodeInfoFromType(t, out var label, out var icon);

				var item = new TypeToolStripMenuItem
				{
					Value = t,
					Text = label,
					Image = icon
				};
				item.Click += clickHandler;
				return item;
			}, p => new ToolStripMenuItem
			{
				Text = p.GetType().ToString(),
				Image = p.Icon
			});

			if (addNoneType)
			{
				ToolStripItem noneItem = new TypeToolStripMenuItem
				{
					Value = null,
					Text = "None"
				};

				items = items.Prepend(new ToolStripSeparator()).Prepend(noneItem);
			}

			return items;
		}

		private static IEnumerable<ToolStripItem> CreateToolStripItems(Func<Type, ToolStripItem> createItem, Func<Plugin, ToolStripDropDownItem> createPluginContainerItem)
		{
			Contract.Requires(createItem != null);
			Contract.Requires(createPluginContainerItem != null);

			return CreateToolStripItems(createItem, createPluginContainerItem, createItem);
		}

		private static IEnumerable<ToolStripItem> CreateToolStripItems(Func<Type, ToolStripItem> createItem, Func<Plugin, ToolStripDropDownItem> createPluginContainerItem, Func<Type, ToolStripItem> createPluginItem)
		{
			Contract.Requires(createItem != null);
			Contract.Requires(createPluginContainerItem != null);
			Contract.Requires(createPluginItem != null);

			if (!defaultNodeTypeGroupList.Any())
			{
				return Enumerable.Empty<ToolStripItem>();
			}

			var items = defaultNodeTypeGroupList
				.Select(t => t.Select(createItem))
				.Aggregate((l1, l2) => l1.Append(new ToolStripSeparator()).Concat(l2));

			if (pluginNodeTypes.Any())
			{
				foreach (var kv in pluginNodeTypes)
				{
					var pluginContainerItem = createPluginContainerItem(kv.Key);
					pluginContainerItem.Tag = kv.Key;
					pluginContainerItem.DropDownItems.AddRange(
						kv.Value
							.Select(createPluginItem)
							.ToArray()
					);
					items = items.Append(new ToolStripSeparator()).Append(pluginContainerItem);
				}
			}

			return items;
		}

		private static void GetNodeInfoFromType(Type nodeType, out string label, out Image icon)
		{
			Contract.Requires(nodeType != null);

			var node = BaseNode.CreateInstanceFromType(nodeType, false);
			if (node == null)
			{
				throw new InvalidOperationException($"'{nodeType}' is not a valid node type.");
			}

			node.GetUserInterfaceInfo(out label, out icon);
		}
	}
}

```

`ReClass.NET/Util/BitString.cs`:

```cs
using System;
using System.Text;

namespace ReClassNET.Util
{
	public static class BitString
	{
		/// <summary>
		/// Converts the value to the corresponding bit string.
		/// Format: 0000 0000
		/// </summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The corresponding bit string.</returns>
		public static string ToString(byte value)
		{
			return AddPaddingAndBuildBlocks(8, Convert.ToString(value, 2));
		}

		/// <summary>
		/// Converts the value to the corresponding bit string.
		/// Format: 0000 0000 0000 0000
		/// </summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The corresponding bit string.</returns>
		public static string ToString(short value)
		{
			return AddPaddingAndBuildBlocks(16, Convert.ToString(value, 2));
		}

		/// <summary>
		/// Converts the value to the corresponding bit string.
		/// Format: 0000 0000 0000 0000 0000 0000 0000 0000
		/// </summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The corresponding bit string.</returns>
		public static string ToString(int value)
		{
			return AddPaddingAndBuildBlocks(32, Convert.ToString(value, 2));
		}

		/// <summary>
		/// Converts the value to the corresponding bit string.
		/// Format: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
		/// </summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The corresponding bit string.</returns>
		public static string ToString(long value)
		{
			return AddPaddingAndBuildBlocks(64, Convert.ToString(value, 2));
		}

		private static string AddPaddingAndBuildBlocks(int bits, string value)
		{
			const int BitsPerBlock = 4;

			var sb = new StringBuilder(bits);

			var padding = bits - value.Length;

			// Add full padding blocks.
			while (padding > BitsPerBlock)
			{
				sb.Append("0000 ");
				padding -= BitsPerBlock;
			}

			// Add only a part of a block.
			if (padding > 0)
			{
				// {padding} 0 bits
				for (var i = 0; i < padding; ++i)
				{
					sb.Append('0');
				}

				// and {4 - padding} bits of the value.
				sb.Append(value, 0, BitsPerBlock - padding);

				if (value.Length > padding)
				{
					sb.Append(' ');
				}
			}

			// Add all remaining blocks.
			for (var i = padding == 0 ? 0 : BitsPerBlock - padding; i < value.Length; i += BitsPerBlock)
			{
				sb.Append(value, i, BitsPerBlock);
				if (i < value.Length - BitsPerBlock)
				{
					sb.Append(' ');
				}
			}

			return sb.ToString();
		}
	}
}

```

`ReClass.NET/Util/CircularBuffer.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace ReClassNET.Util
{
	/// <summary>
	/// A circular buffer with a fixed size.
	/// </summary>
	public class CircularBuffer<T> : IEnumerable<T>
	{
		private readonly T[] buffer;
		private int head;
		private int tail;

		public CircularBuffer(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(capacity));
			}

			buffer = new T[capacity];
			head = capacity - 1;
		}

		public int Count { get; private set; }

		public int Capacity => buffer.Length;

		public T Head => buffer[head];
		public T Tail => buffer[tail];

		public T Enqueue(T item)
		{
			head = (head + 1) % Capacity;
			var overwritten = buffer[head];
			buffer[head] = item;
			if (Count == Capacity)
			{
				tail = (tail + 1) % Capacity;
			}
			else
			{
				++Count;
			}

			return overwritten;
		}

		public T Dequeue()
		{
			if (Count == 0)
			{
				throw new InvalidOperationException();
			}

			var dequeued = buffer[head];
			buffer[head] = default;
			if (head == 0)
			{
				head = Capacity - 1;
			}
			else
			{
				head = (head - 1) % Capacity;
			}
			--Count;
			return dequeued;
		}

		public void Clear()
		{
			head = Capacity - 1;
			tail = 0;
			Count = 0;
		}

		public T this[int index]
		{
			get
			{
				if (index < 0 || index >= Count)
				{
					throw new ArgumentOutOfRangeException(nameof(index));
				}

				return buffer[(tail + index) % Capacity];
			}
			set
			{
				if (index < 0 || index >= Count)
				{
					throw new ArgumentOutOfRangeException(nameof(index));
				}

				buffer[(tail + index) % Capacity] = value;
			}
		}

		public int IndexOf(T item)
		{
			for (var i = 0; i < Count; ++i)
			{
				if (Equals(item, this[i]))
				{
					return i;
				}
			}

			return -1;
		}

		public void Insert(int index, T item)
		{
			if (index < 0 || index > Count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			if (Count == index)
			{
				Enqueue(item);
			}
			else
			{
				var last = this[Count - 1];
				for (var i = index; i < Count - 2; ++i)
				{
					this[i + 1] = this[i];
				}

				this[index] = item;
				Enqueue(last);
			}
		}

		public void RemoveAt(int index)
		{
			if (index < 0 || index >= Count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			for (var i = index; i > 0; --i)
			{
				this[i] = this[i - 1];
			}

			Dequeue();
		}

		public IEnumerator<T> GetEnumerator()
		{
			if (Count == 0 || Capacity == 0)
			{
				yield break;
			}

			for (var i = 0; i < Count; ++i)
			{
				yield return this[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}

```

`ReClass.NET/Util/CommandLineArgs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;

namespace ReClassNET.Util
{
	public class CommandLineArgs
	{
		private readonly List<string> fileNames = new List<string>();
		private readonly SortedDictionary<string, string> parms = new SortedDictionary<string, string>();

		/// <summary>
		/// Get the primary file name.
		/// </summary>
		public string FileName => fileNames.Count < 1 ? null : fileNames[0];

		/// <summary>
		/// Gets all file names.
		/// </summary>
		public IEnumerable<string> FileNames => fileNames;

		/// <summary>
		/// Gets all provided parameters.
		/// </summary>
		public IEnumerable<KeyValuePair<string, string>> Parameters => parms;

		public CommandLineArgs(string[] args)
		{
			if (args == null)
			{
				return;
			}

			foreach (var str in args)
			{
				if (string.IsNullOrEmpty(str))
				{
					continue;
				}

				var kv = GetParameter(str);
				if (kv.Key.Length == 0)
				{
					fileNames.Add(kv.Value);
				}
				else
				{
					parms[kv.Key] = kv.Value;
				}
			}
		}

		/// <summary>
		/// Get the value of a command line parameter.
		/// </summary>
		/// <returns>
		/// Returns <c>null</c> if no parameter with the specified key exists.
		/// </returns>
		public string this[string strKey]
		{
			get
			{
				if (parms.TryGetValue(strKey.ToLower(), out var strValue))
				{
					return strValue;
				}

				return null;
			}
		}

		/// <summary>
		/// Parses the parameter and extracts the key and value.
		/// </summary>
		/// <param name="str">The parameter string to parse.</param>
		/// <returns>
		/// The parameter split in key and value. An empty key signals a file name.
		/// </returns>
		internal static KeyValuePair<string, string> GetParameter(string str)
		{
			Contract.Requires(str != null);

			if (str.StartsWith("--"))
			{
				str = str.Remove(0, 2);
			}
			else if (str.StartsWith("-"))
			{
				str = str.Remove(0, 1);
			}
			else
			{
				return new KeyValuePair<string, string>(string.Empty, str);
			}

			var posColon = str.IndexOf(':');
			var posEqual = str.IndexOf('=');

			if (posColon < 0 && posEqual < 0)
			{
				return new KeyValuePair<string, string>(str.ToLower(), string.Empty);
			}

			var posMin = Math.Min(posColon, posEqual);
			if (posMin < 0)
			{
				posMin = posColon < 0 ? posEqual : posColon;
			}

			if (posMin <= 0)
			{
				return new KeyValuePair<string, string>(str.ToLower(), string.Empty);
			}

			var key = str.Substring(0, posMin).ToLower();
			var value = str.Remove(0, posMin + 1);
			return new KeyValuePair<string, string>(key, value);
		}
	}
}

```

`ReClass.NET/Util/Conversion/BigEndianBitConverter.cs`:

```cs
using System;

namespace ReClassNET.Util.Conversion
{
	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		protected override long FromBytes(byte[] buffer, int index, int bytesToConvert)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer));
			}
			if (index + bytesToConvert > buffer.Length)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[index + i]);
			}
			return ret;
		}

		protected override byte[] ToBytes(long value, int bytes)
		{
			var endOffset = bytes - 1;

			var buffer = new byte[bytes];
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xFF));
				value >>= 8;
			}
			return buffer;
		}
	}
}

```

`ReClass.NET/Util/Conversion/EndianBitConverter.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace ReClassNET.Util.Conversion
{
	public abstract class EndianBitConverter
	{
		public static LittleEndianBitConverter Little { get; } = new LittleEndianBitConverter();

		public static BigEndianBitConverter Big { get; } = new BigEndianBitConverter();

		public static EndianBitConverter System { get; } = BitConverter.IsLittleEndian ? (EndianBitConverter)Little : Big;


		public bool ToBoolean(byte[] value, int startIndex) => BitConverter.ToBoolean(value, startIndex);

		public char ToChar(byte[] value, int startIndex) => unchecked((char)FromBytes(value, startIndex, 2));

		public double ToDouble(byte[] value, int startIndex) => BitConverter.Int64BitsToDouble(ToInt64(value, startIndex));

		public float ToSingle(byte[] value, int startIndex) => new Int32FloatUnion(ToInt32(value, startIndex)).FloatValue;

		public short ToInt16(byte[] value, int startIndex) => unchecked((short)FromBytes(value, startIndex, 2));

		public int ToInt32(byte[] value, int startIndex) => unchecked((int)FromBytes(value, startIndex, 4));

		public long ToInt64(byte[] value, int startIndex) => FromBytes(value, startIndex, 8);

		public ushort ToUInt16(byte[] value, int startIndex) => unchecked((ushort)FromBytes(value, startIndex, 2));

		public uint ToUInt32(byte[] value, int startIndex) => unchecked((uint)FromBytes(value, startIndex, 4));

		public ulong ToUInt64(byte[] value, int startIndex) => unchecked((ulong)FromBytes(value, startIndex, 8));

		protected abstract long FromBytes(byte[] value, int index, int bytesToConvert);


		public byte[] GetBytes(bool value) => BitConverter.GetBytes(value);

		public byte[] GetBytes(char value) => ToBytes(value, 2);

		public byte[] GetBytes(double value) => ToBytes(BitConverter.DoubleToInt64Bits(value), 8);

		public byte[] GetBytes(short value) => ToBytes(value, 2);

		public byte[] GetBytes(int value) => ToBytes(value, 4);

		public byte[] GetBytes(long value) => ToBytes(value, 8);

		public byte[] GetBytes(float value) => ToBytes(new Int32FloatUnion(value).IntValue, 4);

		public byte[] GetBytes(ushort value) => ToBytes(value, 2);

		public byte[] GetBytes(uint value) => ToBytes(value, 4);

		public byte[] GetBytes(ulong value) => ToBytes(unchecked((long)value), 8);

		protected abstract byte[] ToBytes(long value, int bytes);


		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32FloatUnion
		{
			[FieldOffset(0)]
			public readonly int IntValue;

			[FieldOffset(0)]
			public readonly float FloatValue;

			internal Int32FloatUnion(int value)
			{
				FloatValue = 0.0f;
				IntValue = value;
			}

			internal Int32FloatUnion(float value)
			{
				IntValue = 0;
				FloatValue = value;
			}
		}
	}
}

```

`ReClass.NET/Util/Conversion/LittleEndianBitConverter.cs`:

```cs
using System;

namespace ReClassNET.Util.Conversion
{
	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		protected override long FromBytes(byte[] buffer, int index, int bytesToConvert)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer));
			}
			if (index + bytesToConvert > buffer.Length)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			var ret = 0L;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[index + bytesToConvert - 1 - i]);
			}
			return ret;
		}

		protected override byte[] ToBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];

			for (var i = 0; i < bytes; i++)
			{
				buffer[i] = unchecked((byte)(value & 0xFF));
				value >>= 8;
			}

			return buffer;
		}
	}
}

```

`ReClass.NET/Util/CustomDataMap.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Xml.Linq;

namespace ReClassNET.Util
{
	/// <summary>
	/// A class which stores custom data items from plugins.
	/// The key to an item should consist of "a-zA-z0-9.,;_-+".
	/// The naming convention for keys is "PluginName.[Group.]Item".
	/// </summary>
	public class CustomDataMap : IEnumerable<KeyValuePair<string, string>>
	{
		private readonly Dictionary<string, string> data = new Dictionary<string, string>();

		internal XElement Serialize(string name)
		{
			return XElementSerializer.ToXml(name, data);
		}

		internal void Deserialize(XElement element)
		{
			data.Clear();

			foreach (var kv in XElementSerializer.ToDictionary(element))
			{
				data[kv.Key] = kv.Value;
			}
		}

		public IEnumerator<KeyValuePair<string, string>> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public string this[string key]
		{
			get => GetString(key);
			set => SetString(key, value);
		}

		/// <summary>
		/// Removes an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		public void RemoveValue(string key)
		{
			ValidateKey(key);

			data.Remove(key);
		}

		/// <summary>
		/// Sets the string value of an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="value">The value of the item.</param>
		public void SetString(string key, string value)
		{
			ValidateKey(key);

			data[key] = value;
		}

		/// <summary>
		/// Sets the boolean value of an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="value">The value of the item.</param>
		public void SetBool(string key, bool value)
		{
			SetString(key, Convert.ToString(value));
		}

		/// <summary>
		/// Sets the long value of an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="value">The value of the item.</param>
		public void SetLong(string key, long value)
		{
			SetString(key, value.ToString(NumberFormatInfo.InvariantInfo));
		}

		/// <summary>
		/// Sets the ulong value of an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="value">The value of the item.</param>
		public void SetULong(string key, ulong value)
		{
			SetString(key, value.ToString(NumberFormatInfo.InvariantInfo));
		}

		/// <summary>
		/// Sets the XElement value of an item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="value">The value of the item.</param>
		public void SetXElement(string key, XElement value)
		{
			SetString(key, value?.ToString());
		}

		/// <summary>
		/// Gets the string value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <returns>The value of the config item or null if the key does not exists.</returns>
		public string GetString(string key)
		{
			return GetString(key, null);
		}

		/// <summary>
		/// Gets the string value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="def">The default value if the key does not exists.</param>
		/// <returns>The value of the config item or <paramref name="def"/> if the key does not exists.</returns>
		public string GetString(string key, string def)
		{
			ValidateKey(key);

			if (data.TryGetValue(key, out var value))
			{
				return value;
			}

			return def;
		}

		/// <summary>
		/// Gets the boolean value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="def">The default value if the key does not exists.</param>
		/// <returns>The value of the config item or <paramref name="def"/> if the key does not exists.</returns>
		public bool GetBool(string key, bool def)
		{
			var value = GetString(key, null);
			if (string.IsNullOrEmpty(value))
			{
				return def;
			}

			return Convert.ToBoolean(value);
		}

		/// <summary>
		/// Gets the long value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="def">The default value if the key does not exists.</param>
		/// <returns>The value of the config item or <paramref name="def"/> if the key does not exists.</returns>
		public long GetLong(string key, long def)
		{
			var str = GetString(key, null);
			if (string.IsNullOrEmpty(str))
			{
				return def;
			}

			if (long.TryParse(str, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out var value))
			{
				return value;
			}

			return def;
		}

		/// <summary>
		/// Gets the ulong value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="def">The default value if the key does not exists.</param>
		/// <returns>The value of the config item or <paramref name="def"/> if the key does not exists.</returns>
		public ulong GetULong(string key, ulong def)
		{
			var str = GetString(key, null);
			if (string.IsNullOrEmpty(str))
			{
				return def;
			}

			if (ulong.TryParse(str, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out var value))
			{
				return value;
			}

			return def;
		}

		/// <summary>
		/// Gets the XElement value of the item.
		/// </summary>
		/// <param name="key">The key of the item.</param>
		/// <param name="def">The default value if the key does not exists.</param>
		/// <returns>The value of the config item or <paramref name="def"/> if the key does not exists.</returns>
		public XElement GetXElement(string key, XElement def)
		{
			var str = GetString(key, null);
			if (string.IsNullOrEmpty(str))
			{
				return def;
			}

			return XElement.Parse(str);
		}

		/// <summary>
		/// Validates the given key.
		/// </summary>
		/// <param name="key">The key of an item.</param>
		private static void ValidateKey(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException(nameof(key));
			}
		}
	}
}

```

`ReClass.NET/Util/DirectedGraph.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ReClassNET.Util
{
	public class DirectedGraph<T>
	{
		private readonly IDictionary<T, HashSet<T>> adjacencyList = new Dictionary<T, HashSet<T>>();

		/// <summary>
		/// Gets an enumeration of all vertices in the graph.
		/// </summary>
		public IEnumerable<T> Vertices => adjacencyList.Keys;

		/// <summary>
		/// Adds the vertex to the graph.
		/// </summary>
		/// <param name="vertex"></param>
		/// <returns></returns>
		public bool AddVertex(T vertex)
		{
			if (adjacencyList.ContainsKey(vertex))
			{
				return false;
			}

			adjacencyList.Add(vertex, new HashSet<T>());

			return true;
		}

		/// <summary>
		/// Adds the vertices to the graph.
		/// </summary>
		/// <param name="vertices"></param>
		public void AddVertices(IEnumerable<T> vertices)
		{
			foreach (var vertex in vertices)
			{
				AddVertex(vertex);
			}
		}

		/// <summary>
		/// Tests if the graph contains the given vertex.
		/// </summary>
		/// <param name="vertex"></param>
		/// <returns></returns>
		public bool ContainsVertex(T vertex)
		{
			return adjacencyList.ContainsKey(vertex);
		}

		/// <summary>
		/// Adds an edge between both vertices to the graph.
		/// </summary>
		/// <param name="from"></param>
		/// <param name="to"></param>
		/// <returns>True if a new edge was added, false otherwise.</returns>
		public bool AddEdge(T from, T to)
		{
			if (!ContainsVertex(to) || !adjacencyList.TryGetValue(from, out var edges))
			{
				throw new ArgumentException("Vertex does not exist in graph.");
			}

			return edges.Add(to);
		}

		/// <summary>
		/// Tests if the graph contains an edge between both vertices.
		/// </summary>
		/// <param name="from"></param>
		/// <param name="to"></param>
		/// <returns></returns>
		public bool ContainsEdge(T from, T to)
		{
			if (!ContainsVertex(to) || !adjacencyList.TryGetValue(from, out var edges))
			{
				throw new ArgumentException("Vertex does not exist in graph.");
			}

			return edges.Contains(to);
		}

		/// <summary>
		/// Gets all neighbours of the given vertex.
		/// </summary>
		/// <param name="vertex">The vertex to check.</param>
		/// <returns>An enumeration of all neighbours of the given vertex.</returns>
		public IEnumerable<T> GetNeighbours(T vertex)
		{
			if (!adjacencyList.TryGetValue(vertex, out var edges))
			{
				throw new ArgumentException("Vertex does not exist in graph.");
			}

			return edges;
		}

		/// <summary>
		/// Tests with a depth first search if the graph contains a cycle.
		/// </summary>
		/// <returns>True if a cycle exists, false otherwise.</returns>
		public bool ContainsCycle()
		{
			var visited = new HashSet<T>();
			var recursionStack = new HashSet<T>();

			bool IsCyclic(T source)
			{
				if (visited.Add(source))
				{
					recursionStack.Add(source);

					foreach (var adjacent in GetNeighbours(source))
					{
						if (!visited.Contains(adjacent) && IsCyclic(adjacent))
						{
							return true;
						}

						if (recursionStack.Contains(adjacent))
						{
							return true;
						}
					}
				}

				recursionStack.Remove(source);

				return false;
			}

			return adjacencyList.Keys.Any(IsCyclic);
		}
	}
}

```

`ReClass.NET/Util/GrowingList.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.Contracts;

namespace ReClassNET.Util
{
	public class GrowingList<T>
	{
		private readonly List<T> list;

		public T DefaultValue { get; set; }

		public int Count => list.Count;

		public GrowingList()
		{
			Contract.Ensures(list != null);

			list = new List<T>();
		}

		public GrowingList(T defaultValue)
			: this()
		{
			DefaultValue = defaultValue;
		}

		private void GrowToSize(int size)
		{
			list.Capacity = size;

			for (var i = list.Count; i <= size; ++i)
			{
				list.Add(DefaultValue);
			}
		}

		private void CheckIndex(int index)
		{
			Contract.Requires(index >= 0);

			if (index >= list.Count)
			{
				GrowToSize(index);
			}
		}

		public T this[int index]
		{
			get
			{
				Contract.Requires(index >= 0);

				CheckIndex(index);

				return list[index];
			}
			set
			{
				Contract.Requires(index >= 0);

				CheckIndex(index);

				list[index] = value;
			}
		}
	}
}

```

`ReClass.NET/Util/HexadecimalFormatter.cs`:

```cs
using System.Diagnostics.Contracts;

namespace ReClassNET.Util
{
	public static class HexadecimalFormatter
	{
		private static readonly uint[] lookup = CreateHexLookup();

		private static uint[] CreateHexLookup()
		{
			var result = new uint[256];
			for (var i = 0; i < 256; i++)
			{
				var s = i.ToString("X2");
				result[i] = s[0] + ((uint)s[1] << 16);
			}
			return result;
		}

		public static string ToString(byte[] data)
		{
			Contract.Requires(data != null);

			if (data.Length == 0)
			{
				return string.Empty;
			}

			var result = new char[data.Length * 2 + data.Length - 1];

			var val = lookup[data[0]];
			result[0] = (char)val;
			result[1] = (char)(val >> 16);

			for (var i = 1; i < data.Length; i++)
			{
				val = lookup[data[i]];
				result[3 * i - 1] = ' ';
				result[3 * i] = (char)val;
				result[3 * i + 1] = (char)(val >> 16);
			}

			return new string(result);
		}
	}
}

```

`ReClass.NET/Util/IntPtrComparer.cs`:

```cs
using System;
using System.Collections.Generic;
using ReClassNET.Extensions;

namespace ReClassNET.Util
{
	public class IntPtrComparer : IComparer<IntPtr>
	{
		public static IntPtrComparer Instance { get; } = new IntPtrComparer();

		public int Compare(IntPtr x, IntPtr y)
		{
			return x.CompareTo(y);
		}
	}
}

```

`ReClass.NET/Util/NumberFormat.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Globalization;

namespace ReClassNET.Util
{
	public static class NumberFormat
	{
		public static NumberFormatInfo GuessNumberFormat(string input)
		{
			Contract.Requires(input != null);
			Contract.Ensures(Contract.Result<NumberFormatInfo>() != null);

			var commaIndex = input.IndexOf(',');
			var dotIndex = input.IndexOf('.');

			if (commaIndex > dotIndex)
			{
				return new NumberFormatInfo
				{
					NumberDecimalSeparator = ",",
					NumberGroupSeparator = "."
				};
			}
			
			return new NumberFormatInfo
			{
				NumberDecimalSeparator = ".",
				NumberGroupSeparator = ","
			};
		}
	}
}

```

`ReClass.NET/Util/PathUtil.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.IO;
using System.Reflection;

namespace ReClassNET.Util
{
	public class PathUtil
	{
		private static readonly Lazy<string> executablePath = new Lazy<string>(() =>
		{
			string path = null;
			try
			{
				path = Assembly.GetExecutingAssembly().Location;
			}
			catch
			{
				// ignored
			}

			if (string.IsNullOrEmpty(path))
			{
				path = Assembly.GetExecutingAssembly().GetName().CodeBase;
				path = FileUrlToPath(path);
			}

			return path;
		});

		/// <summary>Gets the full pathname of the executable file.</summary>
		public static string ExecutablePath => executablePath.Value;

		private static readonly Lazy<string> executableFolderPath = new Lazy<string>(() => Path.GetDirectoryName(executablePath.Value));

		/// <summary>Gets the full pathname of the executable folder.</summary>
		public static string ExecutableFolderPath => executableFolderPath.Value;

		private static readonly Lazy<string> temporaryFolderPath = new Lazy<string>(Path.GetTempPath);

		/// <summary>Gets the full pathname of the temporary folder.</summary>
		/// <remarks>%temp%</remarks>
		public static string TemporaryFolderPath => temporaryFolderPath.Value;

		private static readonly Lazy<string> settingsFolderPath = new Lazy<string>(() =>
		{
			string applicationData;
			try
			{
				applicationData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
			}
			catch (Exception)
			{
				applicationData = executableFolderPath.Value;
			}

			string localApplicationData;
			try
			{
				localApplicationData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
			}
			catch (Exception)
			{
				localApplicationData = applicationData;
			}

			return Path.Combine(localApplicationData, Constants.ApplicationName);
		});

		/// <summary>Gets the full pathname of the settings folder.</summary>
		/// <remarks>%localappdata%\ReClass.NET\</remarks>
		public static string SettingsFolderPath => settingsFolderPath.Value;

		private static readonly Lazy<string> launcherExecutablePath = new Lazy<string>(() =>
		{
			var path = Path.Combine(Directory.GetParent(ExecutableFolderPath).FullName, Constants.LauncherExecutableName);
			return !File.Exists(path) ? null : path;
		});

		/// <summary>Gets the full pathname of the launcher executable.</summary>
		public static string LauncherExecutablePath => launcherExecutablePath.Value;

		/// <summary>Converts a file url to a normal path.</summary>
		/// <param name="url">URL of the file.</param>
		/// <returns>The path part of the URL.</returns>
		public static string FileUrlToPath(string url)
		{
			Contract.Requires(url != null);

			if (url.StartsWith("file:///", StringComparison.OrdinalIgnoreCase))
			{
				url = url.Substring(8);
			}

			url = url.Replace('/', Path.DirectorySeparatorChar);

			return url;
		}
	}
}

```

`ReClass.NET/Util/Rtf/RtfBuilder.RtfFormatWrapper.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.Drawing;

namespace ReClassNET.Util.Rtf
{
	partial class RtfBuilder
	{
		private class RtfFormatWrapper : IDisposable
		{
			private readonly RtfBuilder builder;

			public RtfFormatWrapper(RtfBuilder builder)
			{
				Contract.Requires(builder != null);

				this.builder = builder;

				var buffer = builder.buffer;

				int oldLength = buffer.Length;

				if ((builder.fontStyle & FontStyle.Bold) == FontStyle.Bold)
				{
					buffer.Append(@"\b");
				}
				if ((builder.fontStyle & FontStyle.Italic) == FontStyle.Italic)
				{
					buffer.Append(@"\i");
				}
				if ((builder.fontStyle & FontStyle.Underline) == FontStyle.Underline)
				{
					buffer.Append(@"\ul");
				}
				if ((builder.fontStyle & FontStyle.Strikeout) == FontStyle.Strikeout)
				{
					buffer.Append(@"\strike");
				}

				if (builder.fontSize != builder.defaultFontSize)
				{
					buffer.AppendFormat(@"\fs{0}", builder.fontSize);
				}
				if (builder.fontIndex != 0)
				{
					buffer.AppendFormat(@"\f{0}", builder.fontIndex);
				}
				if (builder.foreColor != builder.defaultForeColor)
				{
					buffer.AppendFormat(@"\cf{0}", builder.IndexOfColor(builder.foreColor));
				}
				if (builder.backColor != builder.defaultBackColor)
				{
					buffer.AppendFormat(@"\highlight{0}", builder.IndexOfColor(builder.backColor));
				}

				if (buffer.Length > oldLength)
				{
					buffer.Append(" ");
				}
			}

			public void Dispose()
			{
				var buffer = builder.buffer;

				var oldLength = buffer.Length;

				if ((builder.fontStyle & FontStyle.Bold) == FontStyle.Bold)
				{
					buffer.Append(@"\b0");
				}
				if ((builder.fontStyle & FontStyle.Italic) == FontStyle.Italic)
				{
					buffer.Append(@"\i0");
				}
				if ((builder.fontStyle & FontStyle.Underline) == FontStyle.Underline)
				{
					buffer.Append(@"\ulnone");
				}
				if ((builder.fontStyle & FontStyle.Strikeout) == FontStyle.Strikeout)
				{
					buffer.Append(@"\strike0");
				}

				builder.fontStyle = FontStyle.Regular;

				if (builder.fontSize != builder.defaultFontSize)
				{
					builder.fontSize = builder.defaultFontSize;

					buffer.AppendFormat(@"\fs{0} ", builder.defaultFontSize);
				}
				if (builder.fontIndex != 0)
				{
					buffer.Append(@"\f0");

					builder.fontIndex = 0;
				}

				if (builder.foreColor != builder.defaultForeColor)
				{
					builder.foreColor = builder.defaultForeColor;

					buffer.Append(@"\cf0");
				}
				if (builder.backColor != builder.defaultBackColor)
				{
					builder.backColor = builder.defaultBackColor;

					buffer.Append(@"\highlight0");
				}

				if (buffer.Length > oldLength)
				{
					buffer.Append(" ");
				}
			}
		}
	}
}

```

`ReClass.NET/Util/Rtf/RtfBuilder.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

namespace ReClassNET.Util.Rtf
{
	public partial class RtfBuilder
	{
		private static readonly char[] slashable = { '{', '}', '\\' };

		private readonly StringBuilder buffer;

		private readonly Color defaultForeColor = Color.Black;
		private readonly Color defaultBackColor = Color.Empty;
		private readonly float defaultFontSize;

		private readonly List<Color> usedColors = new List<Color>();
		private readonly List<string> usedFonts = new List<string>();

		private Color foreColor;
		private Color backColor;

		private int fontIndex;
		private float fontSize;
		private FontStyle fontStyle;

		public RtfBuilder()
			: this(RtfFont.Calibri, 22.0f)
		{

		}

		public RtfBuilder(RtfFont defaultFont, float defaultFontSize)
		{
			buffer = new StringBuilder();

			fontIndex = IndexOfFont(defaultFont);

			this.defaultFontSize = defaultFontSize;
			fontSize = defaultFontSize;

			usedColors.Add(defaultForeColor);
			usedColors.Add(defaultBackColor);

			fontStyle = FontStyle.Regular;
			foreColor = defaultForeColor;
			backColor = defaultBackColor;
		}

		public RtfBuilder Append(char value)
		{
			return Append(value.ToString());
		}

		public RtfBuilder Append(string value)
		{
			if (!string.IsNullOrEmpty(value))
			{
				using (new RtfFormatWrapper(this))
				{
					value = EscapeString(value);
					if (value.IndexOf(Environment.NewLine, StringComparison.Ordinal) >= 0)
					{
						var lines = value.Split(new[] { Environment.NewLine }, StringSplitOptions.None);

						buffer.Append(string.Join(@"\line ", lines));
					}
					else
					{
						buffer.Append(value);
					}
				}
			}

			return this;
		}

		public RtfBuilder AppendLevel(int level)
		{
			buffer.AppendFormat(@"\level{0} ", level);

			return this;
		}

		public RtfBuilder AppendLine()
		{
			buffer.AppendLine(@"\line");

			return this;
		}

		public RtfBuilder AppendLine(string value)
		{
			Append(value);

			return AppendLine();
		}

		public RtfBuilder AppendParagraph()
		{
			buffer.AppendLine(@"\par");

			return this;
		}

		public RtfBuilder AppendPage()
		{
			buffer.AppendLine(@"\page");

			return this;
		}

		public RtfBuilder SetForeColor(Color color)
		{
			foreColor = color;

			return this;
		}

		public RtfBuilder SetBackColor(Color color)
		{
			backColor = color;

			return this;
		}

		public RtfBuilder SetFont(RtfFont font)
		{
			fontIndex = IndexOfFont(font);

			return this;
		}

		public RtfBuilder SetFontSize(float size)
		{
			fontSize = size;

			return this;
		}

		public RtfBuilder SetFontStyle(FontStyle style)
		{
			fontStyle = style;

			return this;
		}

		protected int IndexOfColor(Color color)
		{
			if (!usedColors.Contains(color))
			{
				usedColors.Add(color);
			}

			return usedColors.IndexOf(color) + 1;
		}

		private int IndexOfFont(RtfFont font)
		{
			return IndexOfRawFont(GetKnownFontString(font));
		}

		private int IndexOfRawFont(string font)
		{
			if (!string.IsNullOrEmpty(font))
			{
				var index = usedFonts.IndexOf(font);
				if (index < 0)
				{
					usedFonts.Add(font);

					return usedFonts.Count - 1;
				}
				return index;
			}
			return 0;
		}

		private static string GetKnownFontString(RtfFont font)
		{
			switch (font)
			{
				case RtfFont.Arial:
					return @"{{\f{0}\fswiss\fprq2\fcharset0 Arial;}}";
				case RtfFont.Calibri:
					return @"{{\f{0}\fnil\fcharset0 Calibri;}}";
				case RtfFont.Consolas:
					return @"{{\f{0}\fmodern\fprq1\fcharset0 Consolas;}}";
				case RtfFont.CourierNew:
					return @"{{\f{0}\fmodern\fprq1\fcharset0 Courier New;}}";
				case RtfFont.Impact:
					return @"{{\f{0}\fswiss\fprq2\fcharset0 Impact;}}";
				case RtfFont.LucidaConsole:
					return @"{{\f{0}\fmodern\fprq1\fcharset0 Lucida Console;}}";
				case RtfFont.MSSansSerif:
					return @"{{\f{0}\fswiss\fprq2\fcharset0 MS Reference Sans Serif;}}";
				case RtfFont.Symbol:
					return @"{{\f{0}\ftech\fcharset0 Symbol;}}";
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		public RtfBuilder Reset()
		{
			buffer.AppendLine(@"\pard");

			return this;
		}

		public override string ToString()
		{
			var sb = new StringBuilder();

			sb.Append(@"{\rtf1\ansi\ansicpg1252\deff0\deflang3081");

			sb.Append(@"{\fonttbl");
			for (var i = 0; i < usedFonts.Count; ++i)
			{
				sb.AppendFormat(usedFonts[i], i);
			}
			sb.AppendLine("}");

			sb.Append(@"{\colortbl ;");
			foreach (var color in usedColors)
			{
				sb.Append($@"\red{color.R}\green{color.G}\blue{color.B};");
			}
			sb.AppendLine("}");

			sb.Append(@"\viewkind4\uc1\pard\plain\f0");

			sb.AppendFormat(@"\fs{0} ", defaultFontSize);
			sb.AppendLine();

			sb.Append(buffer);
			sb.Append("}");

			return sb.ToString();
		}

		private static string EscapeString(string value)
		{
			if (!string.IsNullOrEmpty(value))
			{
				if (value.IndexOfAny(slashable) >= 0)
				{
					value = value.Replace("\\", "\\\\").Replace("{", @"\{").Replace("}", @"\}");
				}

				if (value.Any(c => c > 255))
				{
					var sb = new StringBuilder();

					foreach (var c in value)
					{
						if (c <= 255)
						{
							sb.Append(c);
						}
						else if (c == '\t')
						{
							sb.Append(@"\tab");
						}
						else
						{
							sb.Append(@"\u");
							sb.Append((int)c);
							sb.Append("?");
						}
					}
					value = sb.ToString();
				}
			}

			return value;
		}
	}
}
```

`ReClass.NET/Util/Rtf/RtfFont.cs`:

```cs
namespace ReClassNET.Util.Rtf
{
	public enum RtfFont
	{
		Arial,
		Calibri,
		Consolas,
		CourierNew,
		Impact,
		LucidaConsole,
		Symbol,
		MSSansSerif
	}
}

```

`ReClass.NET/Util/SettingsSerializer.cs`:

```cs
using System.Diagnostics.Contracts;
using System.IO;
using System.Xml.Linq;

namespace ReClassNET.Util
{
	internal sealed class SettingsSerializer
	{
		private const string XmlRootElement = "Settings";
		private const string XmlGeneralElement = "General";
		private const string XmlDisplayElement = "Display";
		private const string XmlColorsElement = "Colors";
		private const string XmlCustomDataElement = "CustomData";

		#region Read Settings

		public static Settings Load()
		{
			EnsureSettingsDirectoryAvailable();

			var settings = new Settings();

			try
			{
				var path = Path.Combine(PathUtil.SettingsFolderPath, Constants.SettingsFile);

				using var sr = new StreamReader(path);

				var document = XDocument.Load(sr);
				var root = document.Root;

				var general = root?.Element(XmlGeneralElement);
				if (general != null)
				{
					XElementSerializer.TryRead(general, nameof(settings.LastProcess), e => settings.LastProcess = XElementSerializer.ToString(e));
					XElementSerializer.TryRead(general, nameof(settings.StayOnTop), e => settings.StayOnTop = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(general, nameof(settings.RunAsAdmin), e => settings.RunAsAdmin = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(general, nameof(settings.RandomizeWindowTitle), e => settings.RandomizeWindowTitle = XElementSerializer.ToBool(e));
				}
				var display = root?.Element(XmlDisplayElement);
				if (display != null)
				{
					XElementSerializer.TryRead(display, nameof(settings.ShowNodeAddress), e => settings.ShowNodeAddress = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowNodeOffset), e => settings.ShowNodeOffset = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowNodeText), e => settings.ShowNodeText = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.HighlightChangedValues), e => settings.HighlightChangedValues = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentFloat), e => settings.ShowCommentFloat = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentInteger), e => settings.ShowCommentInteger = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentPointer), e => settings.ShowCommentPointer = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentRtti), e => settings.ShowCommentRtti = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentSymbol), e => settings.ShowCommentSymbol = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentString), e => settings.ShowCommentString = XElementSerializer.ToBool(e));
					XElementSerializer.TryRead(display, nameof(settings.ShowCommentPluginInfo), e => settings.ShowCommentPluginInfo = XElementSerializer.ToBool(e));
				}
				var colors = root?.Element(XmlColorsElement);
				if (colors != null)
				{
					XElementSerializer.TryRead(colors, nameof(settings.BackgroundColor), e => settings.BackgroundColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.SelectedColor), e => settings.SelectedColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.HiddenColor), e => settings.HiddenColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.OffsetColor), e => settings.OffsetColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.AddressColor), e => settings.AddressColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.HexColor), e => settings.HexColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.TypeColor), e => settings.TypeColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.NameColor), e => settings.NameColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.ValueColor), e => settings.ValueColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.IndexColor), e => settings.IndexColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.CommentColor), e => settings.CommentColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.TextColor), e => settings.TextColor = XElementSerializer.ToColor(e));
					XElementSerializer.TryRead(colors, nameof(settings.VTableColor), e => settings.VTableColor = XElementSerializer.ToColor(e));
				}
				var customData = root?.Element(XmlCustomDataElement);
				if (customData != null)
				{
					settings.CustomData.Deserialize(customData);
				}
			}
			catch
			{
				// ignored
			}

			return settings;
		}

		#endregion

		#region Write Settings

		public static void Save(Settings settings)
		{
			Contract.Requires(settings != null);

			EnsureSettingsDirectoryAvailable();

			var path = Path.Combine(PathUtil.SettingsFolderPath, Constants.SettingsFile);

			using var sw = new StreamWriter(path);

			var document = new XDocument(
				new XComment($"{Constants.ApplicationName} {Constants.ApplicationVersion} by {Constants.Author}"),
				new XComment($"Website: {Constants.HomepageUrl}"),
				new XElement(
					XmlRootElement,
					new XElement(
						XmlGeneralElement,
						XElementSerializer.ToXml(nameof(settings.LastProcess), settings.LastProcess),
						XElementSerializer.ToXml(nameof(settings.StayOnTop), settings.StayOnTop),
						XElementSerializer.ToXml(nameof(settings.RunAsAdmin), settings.RunAsAdmin),
						XElementSerializer.ToXml(nameof(settings.RandomizeWindowTitle), settings.RandomizeWindowTitle)
					),
					new XElement(
						XmlDisplayElement,
						XElementSerializer.ToXml(nameof(settings.ShowNodeAddress), settings.ShowNodeAddress),
						XElementSerializer.ToXml(nameof(settings.ShowNodeOffset), settings.ShowNodeOffset),
						XElementSerializer.ToXml(nameof(settings.ShowNodeText), settings.ShowNodeText),
						XElementSerializer.ToXml(nameof(settings.HighlightChangedValues), settings.HighlightChangedValues),
						XElementSerializer.ToXml(nameof(settings.ShowCommentFloat), settings.ShowCommentFloat),
						XElementSerializer.ToXml(nameof(settings.ShowCommentInteger), settings.ShowCommentInteger),
						XElementSerializer.ToXml(nameof(settings.ShowCommentPointer), settings.ShowCommentPointer),
						XElementSerializer.ToXml(nameof(settings.ShowCommentRtti), settings.ShowCommentRtti),
						XElementSerializer.ToXml(nameof(settings.ShowCommentSymbol), settings.ShowCommentSymbol),
						XElementSerializer.ToXml(nameof(settings.ShowCommentString), settings.ShowCommentString),
						XElementSerializer.ToXml(nameof(settings.ShowCommentPluginInfo), settings.ShowCommentPluginInfo)
					),
					new XElement(
						XmlColorsElement,
						XElementSerializer.ToXml(nameof(settings.BackgroundColor), settings.BackgroundColor),
						XElementSerializer.ToXml(nameof(settings.SelectedColor), settings.SelectedColor),
						XElementSerializer.ToXml(nameof(settings.HiddenColor), settings.HiddenColor),
						XElementSerializer.ToXml(nameof(settings.OffsetColor), settings.OffsetColor),
						XElementSerializer.ToXml(nameof(settings.AddressColor), settings.AddressColor),
						XElementSerializer.ToXml(nameof(settings.HexColor), settings.HexColor),
						XElementSerializer.ToXml(nameof(settings.TypeColor), settings.TypeColor),
						XElementSerializer.ToXml(nameof(settings.NameColor), settings.NameColor),
						XElementSerializer.ToXml(nameof(settings.ValueColor), settings.ValueColor),
						XElementSerializer.ToXml(nameof(settings.IndexColor), settings.IndexColor),
						XElementSerializer.ToXml(nameof(settings.CommentColor), settings.CommentColor),
						XElementSerializer.ToXml(nameof(settings.TextColor), settings.TextColor),
						XElementSerializer.ToXml(nameof(settings.VTableColor), settings.VTableColor)
					),
					settings.CustomData.Serialize(XmlCustomDataElement)
				)
			);

			document.Save(sw);
		}

		#endregion

		private static void EnsureSettingsDirectoryAvailable()
		{
			try
			{
				if (Directory.Exists(PathUtil.SettingsFolderPath) == false)
				{
					Directory.CreateDirectory(PathUtil.SettingsFolderPath);
				}
			}
			catch
			{
				// ignored
			}
		}
	}
}

```

`ReClass.NET/Util/Util.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;

namespace ReClassNET.Util
{
	public static class Utils
	{
		public static T Min<T, U>(T item1, T item2, Func<T, U> keySelector) where U : IComparable
		{
			Contract.Requires(keySelector != null);

			return Min(item1, item2, keySelector, Comparer<U>.Default);
		}

		public static T Min<T, U>(T item1, T item2, Func<T, U> keySelector, IComparer<U> comparer)
		{
			Contract.Requires(keySelector != null);
			Contract.Requires(comparer != null);

			if (comparer.Compare(keySelector(item1), keySelector(item2)) < 0)
			{
				return item1;
			}
			return item2;
		}

		public static T Max<T, U>(T item1, T item2, Func<T, U> keySelector) where U : IComparable
		{
			Contract.Requires(keySelector != null);

			return Max(item1, item2, keySelector, Comparer<U>.Default);
		}

		public static T1 Max<T1, T2>(T1 item1, T1 item2, Func<T1, T2> keySelector, IComparer<T2> comparer)
		{
			Contract.Requires(keySelector != null);
			Contract.Requires(comparer != null);

			if (comparer.Compare(keySelector(item1), keySelector(item2)) > 0)
			{
				return item1;
			}
			return item2;
		}

		public static void Swap<T>(ref T lhs, ref T rhs)
		{
			var temp = lhs;
			lhs = rhs;
			rhs = temp;
		}

		//thx again stack overflow https://stackoverflow.com/a/1344242
		public static string RandomString(int length)
		{
			const string Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
			return new string(Enumerable.Repeat(Chars, length)
			  .Select(s => s[Program.GlobalRandom.Next(s.Length)]).ToArray());
		}
	}
}

```

`ReClass.NET/Util/ValueTypeWrapper.cs`:

```cs
namespace ReClassNET.Util
{
	/// <summary>A wrapper for non reference types.</summary>
	/// <typeparam name="T">Generic type parameter.</typeparam>
	public class ValueTypeWrapper<T> where T : struct
	{
		public ValueTypeWrapper(T value)
		{
			Value = value;
		}

		public T Value { get; set; }

		public static implicit operator ValueTypeWrapper<T>(T value)
		{
			return new ValueTypeWrapper<T>(value);
		}
	}
}

```

`ReClass.NET/Util/WinUtil.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Security.Principal;
using Microsoft.Win32;

namespace ReClassNET.Util
{
	public static class WinUtil
	{
		public static bool IsWindows9x { get; }

		public static bool IsWindows2000 { get; }

		public static bool IsWindowsXP { get; }

		public static bool IsAtLeastWindows2000 { get; }

		public static bool IsAtLeastWindowsVista { get; }

		public static bool IsAtLeastWindows7 { get; }

		public static bool IsAtLeastWindows8 { get; }

		public static bool IsAtLeastWindows10 { get; }

		//from https://stackoverflow.com/a/11660205
		public static bool IsAdministrator => new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);

		static WinUtil()
		{
			var os = Environment.OSVersion;
			var v = os.Version;

			IsWindows9x = os.Platform == PlatformID.Win32Windows;
			IsWindows2000 = v.Major == 5 && v.Minor == 0;
			IsWindowsXP = v.Major == 5 && v.Minor == 1;

			IsAtLeastWindows2000 = v.Major >= 5;
			IsAtLeastWindowsVista = v.Major >= 6;
			IsAtLeastWindows7 = v.Major >= 7 || v.Major == 6 && v.Minor >= 1;
			IsAtLeastWindows8 = v.Major >= 7 || v.Major == 6 && v.Minor >= 2;

			try
			{
				using var rk = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion", false);
				if (rk != null)
				{
					var str = rk.GetValue("CurrentMajorVersionNumber", string.Empty)?.ToString();
					if (uint.TryParse(str, out var u))
					{
						IsAtLeastWindows10 = u >= 10;
					}
				}
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>Executes the a process with elevated permissions.</summary>
		/// <param name="applicationPath"> The executable path.</param>
		/// <param name="arguments">The arguments.</param>
		/// <returns>True if it succeeds, false if it fails.</returns>
		public static bool RunElevated(string applicationPath, string arguments)
		{
			Contract.Requires(applicationPath != null);

			try
			{
				var processStartInfo = new ProcessStartInfo
				{
					FileName = applicationPath,
					UseShellExecute = true,
					WindowStyle = ProcessWindowStyle.Normal
				};
				if (arguments != null)
				{
					processStartInfo.Arguments = arguments;
				}

				if (IsAtLeastWindowsVista)
				{
					processStartInfo.Verb = "runas";
				}

				Process.Start(processStartInfo);
			}
			catch (Exception)
			{
				return false;
			}

			return true;
		}
	}
}

```

`ReClass.NET/Util/XElementSerializer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Drawing;
using System.Globalization;
using System.Linq;
using System.Xml.Linq;
using ReClassNET.Extensions;

namespace ReClassNET.Util
{
	public static class XElementSerializer
	{
		public static bool TryRead(XContainer element, string name, Action<XElement> iff)
		{
			Contract.Requires(element != null);
			Contract.Requires(name != null);
			Contract.Requires(iff != null);

			var target = element.Element(name);
			if (target != null)
			{
				iff(target);

				return true;
			}

			return false;
		}

		public static bool ToBool(XElement value) => (bool?)value ?? false;
		public static int ToInt(XElement value) => (int?)value ?? 0;
		public static string ToString(XElement value) => value.Value;
		public static Color ToColor(XElement value) => Color.FromArgb((int)(0xFF000000 | int.Parse(value.Value, NumberStyles.HexNumber)));
		public static Dictionary<string, string> ToDictionary(XContainer value) => value.Elements().ToDictionary(e => e.Name.ToString(), e => e.Value);

		public static XElement ToXml(string name, bool value) => new XElement(name, value);
		public static XElement ToXml(string name, int value) => new XElement(name, value);
		public static XElement ToXml(string name, string value) => new XElement(name, value);
		public static XElement ToXml(string name, Color value) => new XElement(name, $"{value.ToRgb():X6}");
		public static XElement ToXml(string name, Dictionary<string, string> value) => new XElement(name, value.Select(kv => new XElement(kv.Key, kv.Value)));
	}
}

```

`ReClass.NET_Launcher/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
    </startup>
</configuration>

```

`ReClass.NET_Launcher/DataExchange/ReClass/ReClassNetFile.cs`:

```cs
using System;
using System.Diagnostics.Contracts;
using System.IO;
using System.IO.Compression;
using System.Xml.Linq;

namespace ReClassNET.DataExchange.ReClass
{
	public partial class ReClassNetFile
	{
		/// <summary>Reads a platform from the ReClass.NET file.</summary>
		/// <exception cref="FormatException">Thrown if the format of the file is incorrect.</exception>
		/// <param name="path">Full path of the file.</param>
		/// <returns>The platform as string.</returns>
		public static string ReadPlatform(string path)
		{
			Contract.Requires(path != null);

			using (var fs = new FileStream(path, FileMode.Open))
			{
				using (var archive = new ZipArchive(fs, ZipArchiveMode.Read))
				{
					var dataEntry = archive.GetEntry(DataFileName);
					if (dataEntry == null)
					{
						throw new FormatException();
					}
					using (var entryStream = dataEntry.Open())
					{
						var document = XDocument.Load(entryStream);

						//var version = document.Root.Attribute(XmlVersionAttribute)?.Value;
						var platform = document.Root?.Attribute(XmlPlatformAttribute)?.Value;

						return platform;
					}
				}
			}
		}
	}
}

```

`ReClass.NET_Launcher/Makefile`:

```
.PHONY: all clean debug clean_debug release clean_release docker_debug docker_release podman_debug podman_release

all: debug release

clean: clean_debug clean_release

debug:
	msbuild /p:Configuration=Debug ReClass.NET_Launcher.csproj

clean_debug:
	msbuild /t:Clean ReClass.NET_Launcher.csproj

release:
	msbuild /p:Configuration=Release ReClass.NET_Launcher.csproj

clean_release:
	msbuild /t:Clean ReClass.NET_Launcher.csproj

docker_debug:
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET_Launcher && msbuild /p:Configuration=Debug ReClass.NET_Launcher.csproj"

docker_release:
	docker container run --rm -v ${PWD}/..:/build:z -w /build -u $(shell id -u ${USER}):$(shell id -g ${USER}) mono:latest bash -c "cd ReClass.NET_Launcher && msbuild /p:Configuration=Release ReClass.NET_Launcher.csproj"

podman_debug:
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET_Launcher && msbuild /p:Configuration=Debug ReClass.NET_Launcher.csproj"

podman_release:
	podman container run --rm -v ${PWD}/..:/build:z -w /build mono:latest bash -c "cd ReClass.NET_Launcher && msbuild /p:Configuration=Release ReClass.NET_Launcher.csproj"

```

`ReClass.NET_Launcher/Program.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using ReClassNET;
using ReClassNET.DataExchange.ReClass;
using ReClassNET.Native;
using ReClassNET.Util;

namespace ReClassNET_Launcher
{
	static class Program
	{
		[STAThread]
		static void Main(string[] args)
		{
			var commandLineArgs = new CommandLineArgs(args);

			// Register the files with the launcher.
			if (commandLineArgs[Constants.CommandLineOptions.FileExtRegister] != null)
			{
				NativeMethods.RegisterExtension(ReClassNetFile.FileExtension, ReClassNetFile.FileExtensionId, PathUtil.ExecutablePath, Constants.ApplicationName);

				return;
			}
			if (commandLineArgs[Constants.CommandLineOptions.FileExtUnregister] != null)
			{
				NativeMethods.UnregisterExtension(ReClassNetFile.FileExtension, ReClassNetFile.FileExtensionId);

				return;
			}

			var is64Bit = IntPtr.Size == 8;

			// If there is a file in the commandline, read the platform.
			if (commandLineArgs.FileName != null)
			{
				try
				{
					is64Bit = ReClassNetFile.ReadPlatform(commandLineArgs.FileName) == "x64";
				}
				catch (Exception)
				{
					
				}
			}

			// And finally start the real ReClass.NET.
			var applicationPath = Path.Combine(PathUtil.ExecutableFolderPath, is64Bit ? "x64" : "x86", Constants.ApplicationExecutableName);

			try
			{
				var processStartInfo = new ProcessStartInfo
				{
					FileName = applicationPath,
					UseShellExecute = true,
					WindowStyle = ProcessWindowStyle.Normal
				};
				var arguments = GetCommandLineWithoutExecutablePath();
				if (arguments != null)
				{
					processStartInfo.Arguments = arguments;
				}

				Process.Start(processStartInfo);
			}
			catch (Exception)
			{
				MessageBox.Show($"Could not start '{applicationPath}'.", Constants.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Error);
			}
		}

		/// <summary>Gets command line without the executable path.</summary>
		/// <returns>If empty <c>null</c> else the command line parameters.</returns>
		private static string GetCommandLineWithoutExecutablePath()
		{
			var commandLine = Environment.CommandLine;

			if (string.IsNullOrEmpty(commandLine))
			{
				return null;
			}

			var arguments = string.Empty;
			int argIndex;

			if (commandLine[0] == '"')
			{
				var secondDoublequoteIndex = -1;
				for (var i = 1; i < commandLine.Length; ++i)
				{
					if (commandLine[i] == '\\')
					{
						++i;
						continue;
					}
					if (commandLine[i] == '"')
					{
						secondDoublequoteIndex = i + 1;
						break;
					}
				}
				argIndex = secondDoublequoteIndex;
			}
			else
			{
				argIndex = commandLine.IndexOf(" ", StringComparison.Ordinal);
			}
			if (argIndex != -1)
			{
				arguments = commandLine.Substring(argIndex + 1);
			}

			return arguments == string.Empty ? null : arguments;
		}
	}
}

```

`ReClass.NET_Launcher/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Allgemeine Informationen über eine Assembly werden über die folgenden
// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
// die einer Assembly zugeordnet sind.
[assembly: AssemblyTitle("ReClass.NET Launcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ReClass.NET")]
[assembly: AssemblyCopyright("KN4CK3R")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Durch Festlegen von ComVisible auf FALSE werden die Typen in dieser Assembly
// für COM-Komponenten unsichtbar.  Wenn Sie auf einen Typ in dieser Assembly von
// COM aus zugreifen müssen, sollten Sie das ComVisible-Attribut für diesen Typ auf "True" festlegen.
[assembly: ComVisible(false)]

// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
[assembly: Guid("16591d29-2370-428a-ba11-87e38d0f3551")]

// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
//
//      Hauptversion
//      Nebenversion
//      Buildnummer
//      Revision
//
// Sie können alle Werte angeben oder Standardwerte für die Build- und Revisionsnummern verwenden,
// übernehmen, indem Sie "*" eingeben:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ReClass.NET_Launcher/ReClass.NET_Launcher.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{16591D29-2370-428A-BA11-87E38D0F3551}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>ReClassNET_Launcher</RootNamespace>
    <AssemblyName>ReClass.NET_Launcher</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>$(SolutionDir)bin\Debug\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\any\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>$(SolutionDir)bin\Release\</OutputPath>
    <IntermediateOutputPath>$(SolutionDir)obj\$(Configuration)\any\$(MSBuildProjectName)\</IntermediateOutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>ReClassNet.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.IO.Compression" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Windows.Forms" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\ReClass.NET\Constants.cs">
      <Link>Constants.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\DataExchange\ReClass\ReClassNetFile.Constants.cs">
      <Link>DataExchange\ReClass\ReClassNetFile.Constants.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Native\INativeMethods.cs">
      <Link>Native\INativeMethods.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Native\NativeMethods.cs">
      <Link>Native\NativeMethods.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Native\NativeMethods.Unix.cs">
      <Link>Native\NativeMethods.Unix.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Native\NativeMethods.Windows.cs">
      <Link>Native\NativeMethods.Windows.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Extensions\IntPtrExtensions.cs">
      <Link>Extensions\IntPtrExtensions.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Util\PathUtil.cs">
      <Link>Util\PathUtil.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Util\CommandLineArgs.cs">
      <Link>Util\CommandLineArgs.cs</Link>
    </Compile>
    <Compile Include="..\ReClass.NET\Util\WinUtil.cs">
      <Link>Util\WinUtil.cs</Link>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="DataExchange\ReClass\ReClassNetFile.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="..\ReClass.Net\Resources\Icon\ReClassNet.ico" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`ReClass.NET_Tests/AddressParser/DynamicCompilerTest.cs`:

```cs
using ReClassNET.AddressParser;

namespace ReClass.NET_Tests.AddressParser
{
	public class DynamicCompilerTest : ExecutorTest
	{
		protected override IExecutor CreateExecutor()
		{
			return new DynamicCompiler();
		}
	}
}

```

`ReClass.NET_Tests/AddressParser/ExecutorTest.cs`:

```cs
using System;
using System.Collections.Generic;
using Moq;
using NFluent;
using ReClassNET.AddressParser;
using ReClassNET.Memory;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.AddressParser
{
	public abstract class ExecutorTest
	{
		protected abstract IExecutor CreateExecutor();

		public static IEnumerable<object[]> GetSimpleExpressionTestData() => new List<object[]>
		{
			new object[] { "0", (IntPtr)0x0 },
			new object[] { "0 + 0", (IntPtr)0x0 },
			new object[] { "+0", (IntPtr)0x0 },
			new object[] { "-0", (IntPtr)0x0 },
			new object[] { "-1", (IntPtr)(-1) },
			new object[] { "+0 + 0", (IntPtr)0x0 },
			new object[] { "-0 - 0", (IntPtr)0x0 },
			new object[] { "0 + 1", (IntPtr)0x1 },
			new object[] { "0 - 1", (IntPtr)(-1) },
			new object[] { "1 + 2 * 3", (IntPtr)0x7 },
			new object[] { "0x123 + 0x234 * 0x345", (IntPtr)0x73527 },
			new object[] { "4 / 0x2", (IntPtr)0x2 }
		};

		[Theory]
		[MemberData(nameof(GetSimpleExpressionTestData))]
		public void SimpleExpressionTest(string expression, IntPtr expected)
		{
			var mock = new Mock<IProcessReader>();

			var executor = CreateExecutor();

			Check.That(executor.Execute(Parser.Parse(expression), mock.Object)).IsEqualTo(expected);
		}

		public static IEnumerable<object[]> GetModuleExpressionTestData() => new List<object[]>
		{
			new object[] { "<test.module>", (IntPtr)0x100 },
			new object[] { "<test.module> + 0", (IntPtr)0x100 },
			new object[] { "<test.module> + 10", (IntPtr)0x110 },
			new object[] { "<test.module> * 2", (IntPtr)0x200 },
			new object[] { "<not.found>", (IntPtr)0x0 },
		};

		[Theory]
		[MemberData(nameof(GetModuleExpressionTestData))]
		public void ModuleExpressionTest(string expression, IntPtr expected)
		{
			var mock = new Mock<IProcessReader>();
			mock.Setup(p => p.GetModuleByName("test.module"))
				.Returns(new Module { Start = (IntPtr)0x100 });

			var executor = CreateExecutor();

			Check.That(executor.Execute(Parser.Parse(expression), mock.Object)).IsEqualTo(expected);
		}

		public static IEnumerable<object[]> GetReadMemoryExpressionTestData(int bytesToRead) => new List<object[]>
		{
			new object[] { $"[0,{bytesToRead}]", (IntPtr)0x0 },
			new object[] { $"[0,{bytesToRead}] + 10", (IntPtr)0x10 },
			new object[] { $"[10,{bytesToRead}]", (IntPtr)0x10 },
			new object[] { $"[10 + 10,{bytesToRead}]", (IntPtr)0x20 },
			new object[] { $"[[10,{bytesToRead}] + 10,{bytesToRead}]", (IntPtr)0x20 },
			new object[] { $"[[10,{bytesToRead}] + [10,{bytesToRead}],{bytesToRead}] + [10,{bytesToRead}]", (IntPtr)0x30 }
		};

		[Theory]
		[MemberData(nameof(GetReadMemoryExpressionTestData), 4)]
		public void ReadMemoryExpression32Test(string expression, IntPtr expected)
		{
			var converter = EndianBitConverter.System;

			var mock = new Mock<IProcessReader>();
			mock.SetupProperty(p => p.BitConverter)
				.SetupGet(p => p.BitConverter)
				.Returns(converter);
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0, sizeof(int)))
				.Returns(converter.GetBytes(0));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x10, sizeof(int)))
				.Returns(converter.GetBytes(0x10));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x20, sizeof(int)))
				.Returns(converter.GetBytes(0x20));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x30, sizeof(int)))
				.Returns(converter.GetBytes(0x30));

			var executor = CreateExecutor();

			Check.That(executor.Execute(Parser.Parse(expression), mock.Object)).IsEqualTo(expected);
		}

		[Theory]
		[MemberData(nameof(GetReadMemoryExpressionTestData), 8)]
		public void ReadMemoryExpression64Test(string expression, IntPtr expected)
		{
			var converter = EndianBitConverter.System;

			var mock = new Mock<IProcessReader>();
			mock.SetupProperty(p => p.BitConverter)
				.SetupGet(p => p.BitConverter)
				.Returns(converter);
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0, sizeof(long)))
				.Returns(converter.GetBytes(0L));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x10, sizeof(long)))
				.Returns(converter.GetBytes(0x10L));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x20, sizeof(long)))
				.Returns(converter.GetBytes(0x20L));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x30, sizeof(long)))
				.Returns(converter.GetBytes(0x30L));

			var executor = CreateExecutor();

			Check.That(executor.Execute(Parser.Parse(expression), mock.Object)).IsEqualTo(expected);
		}

		[Fact]
		public void ReadMemoryExpressionInvariantTest()
		{
			var converter = EndianBitConverter.System;

			var mock = new Mock<IProcessReader>();
			mock.SetupProperty(p => p.BitConverter)
				.SetupGet(p => p.BitConverter)
				.Returns(converter);
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x10, sizeof(int)))
				.Returns(converter.GetBytes(0x10));
			mock.Setup(p => p.ReadRemoteMemory((IntPtr)0x10, sizeof(long)))
				.Returns(converter.GetBytes(0x10L));

			var executor = CreateExecutor();

			Check.That(executor.Execute(Parser.Parse("[10]"), mock.Object)).IsEqualTo((IntPtr)0x10);
		}
	}
}

```

`ReClass.NET_Tests/AddressParser/InterpreterTest.cs`:

```cs
using ReClassNET.AddressParser;

namespace ReClass.NET_Tests.AddressParser
{
	public class InterpreterTest : ExecutorTest
	{
		protected override IExecutor CreateExecutor()
		{
			return new Interpreter();
		}
	}
}

```

`ReClass.NET_Tests/AddressParser/ParserTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.AddressParser;
using Xunit;

namespace ReClass.NET_Tests.AddressParser
{
	public class ParserTest
	{
		[Theory]
		[InlineData("-")]
		[InlineData("+")]
		[InlineData("*")]
		[InlineData("/")]
		[InlineData(",")]
		[InlineData("(")]
		[InlineData(")")]
		[InlineData("[")]
		[InlineData("]")]
		[InlineData("1-")]
		[InlineData("1(")]
		[InlineData("1)")]
		[InlineData("1[")]
		[InlineData("1]")]
		[InlineData("(1")]
		[InlineData(")1")]
		[InlineData("[1")]
		[InlineData("]1")]
		[InlineData("1+(")]
		[InlineData("1+)")]
		[InlineData("1 + ()")]
		[InlineData("(1 + 2")]
		[InlineData("1 + 2)")]
		[InlineData("[1 + 2)")]
		[InlineData("(1 + 2]")]
		[InlineData("[1,")]
		[InlineData("[1,]")]
		[InlineData("[1,2]")]
		[InlineData("1,")]
		[InlineData("1,2")]
		public void InvalidExpressionTests(string expression)
		{
			Check.ThatCode(() => Parser.Parse(expression)).Throws<ParseException>();
		}

		[Theory]
		[InlineData("1", typeof(ConstantExpression))]
		[InlineData("1 + 2", typeof(AddExpression))]
		[InlineData("1 - 2", typeof(SubtractExpression))]
		[InlineData("1 * 2", typeof(MultiplyExpression))]
		[InlineData("1 / 2", typeof(DivideExpression))]
		[InlineData("1 + 2 * 3", typeof(AddExpression))]
		[InlineData("(1 + 2) * 3", typeof(MultiplyExpression))]
		[InlineData("1 + (2 * 3)", typeof(AddExpression))]
		[InlineData("(1 + (2 * 3))", typeof(AddExpression))]
		[InlineData("[1]", typeof(ReadMemoryExpression))]
		[InlineData("[1,4]", typeof(ReadMemoryExpression))]
		[InlineData("[1,8]", typeof(ReadMemoryExpression))]
		[InlineData("<test>", typeof(ModuleExpression))]
		[InlineData("[<test>]", typeof(ReadMemoryExpression))]
		public void ValidExpressionTests(string expression, Type type)
		{
			Check.That(Parser.Parse(expression)).IsInstanceOfType(type);
		}

		[Fact]
		public void ReadMemoryDefaultByteCountCheck()
		{
			var expression = (ReadMemoryExpression)Parser.Parse("[1]");

			Check.That(expression.ByteCount).IsEqualTo(IntPtr.Size);
		}
	}
}

```

`ReClass.NET_Tests/AddressParser/TokenizerTest.cs`:

```cs
using System.IO;
using NFluent;
using ReClassNET.AddressParser;
using Xunit;

namespace ReClass.NET_Tests.AddressParser
{
	public class TokenizerTest
	{
		[Theory]
		[InlineData("", Token.None)]
		[InlineData(" ", Token.None)]
		[InlineData("\t", Token.None)]
		[InlineData("\n", Token.None)]
		[InlineData(" \t\n", Token.None)]
		[InlineData("0", Token.Number)]
		[InlineData("1", Token.Number)]
		[InlineData("0x0", Token.Number)]
		[InlineData("0x1", Token.Number)]
		[InlineData("00000000", Token.Number)]
		[InlineData("0x00000000", Token.Number)]
		[InlineData("+", Token.Add)]
		[InlineData("-", Token.Subtract)]
		[InlineData("*", Token.Multiply)]
		[InlineData("/", Token.Divide)]
		[InlineData("(", Token.OpenParenthesis)]
		[InlineData(")", Token.CloseParenthesis)]
		[InlineData("[", Token.OpenBrackets)]
		[InlineData("]", Token.CloseBrackets)]
		[InlineData(",", Token.Comma)]
		[InlineData("<test.exe>", Token.Identifier)]
		public void TestTokenType(string expression, Token type)
		{
			var tokenizer = new Tokenizer(new StringReader(expression));

			Check.That(tokenizer.Token).IsEqualTo(type);
		}

		[Theory]
		[InlineData("0", 0)]
		[InlineData("1", 1)]
		[InlineData("0x0", 0)]
		[InlineData("0x1", 1)]
		[InlineData("00000000", 0)]
		[InlineData("0x00000000", 0)]
		[InlineData("12345678", 0x12345678)]
		[InlineData("0x12345678", 0x12345678)]
		public void TestNumberValue(string expression, long value)
		{
			var tokenizer = new Tokenizer(new StringReader(expression));

			Check.That(tokenizer.Number).IsEqualTo(value);
		}

		[Theory]
		[InlineData("<>", "")]
		[InlineData("<test>", "test")]
		[InlineData("<module.test>", "module.test")]
		public void TestIdentifierValue(string expression, string value)
		{
			var tokenizer = new Tokenizer(new StringReader(expression));

			Check.That(tokenizer.Identifier).IsEqualTo(value);
		}

		[Theory]
		[InlineData("<")]
		[InlineData(">")]
		[InlineData("10000000000000000")]
		[InlineData("0x")]
		[InlineData("x")]
		public void TestInvalidExpression(string expression)
		{
			Check.ThatCode(() => new Tokenizer(new StringReader(expression))).Throws<ParseException>();
		}

		[Theory]
		[InlineData("1 + 2", Token.Number, Token.Add, Token.Number)]
		[InlineData("1+2", Token.Number, Token.Add, Token.Number)]
		[InlineData("+1", Token.Add, Token.Number)]
		[InlineData("1 + ( 2 )", Token.Number, Token.Add, Token.OpenParenthesis, Token.Number, Token.CloseParenthesis)]
		[InlineData("1 + )( 2", Token.Number, Token.Add, Token.CloseParenthesis, Token.OpenParenthesis, Token.Number)]
		[InlineData("1+<module>", Token.Number, Token.Add, Token.Identifier)]
		[InlineData("0x1+<module>", Token.Number, Token.Add, Token.Identifier)]
		[InlineData("(0x1+<module>)", Token.OpenParenthesis, Token.Number, Token.Add, Token.Identifier, Token.CloseParenthesis)]
		[InlineData("[ 1 ] + 2", Token.OpenBrackets, Token.Number, Token.CloseBrackets, Token.Add, Token.Number)]
		[InlineData("[1 + 2]", Token.OpenBrackets, Token.Number, Token.Add, Token.Number, Token.CloseBrackets)]
		public void TestExpressions(string expression, params Token[] tokens)
		{
			var tokenizer = new Tokenizer(new StringReader(expression));

			foreach (var token in tokens)
			{
				Check.That(tokenizer.Token).IsEqualTo(token);

				tokenizer.ReadNextToken();
			}

			Check.That(tokenizer.Token).IsEqualTo(Token.None);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/ByteExtensionTest.cs`:

```cs
using System.Linq;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class ByteExtensionTest
	{
		public static TheoryData<byte[]> GetTestFillWithZeroData() => new TheoryData<byte[]>
		{
			new byte[0],
			Enumerable.Repeat(1, 1).Select(i => (byte)i).ToArray(),
			Enumerable.Repeat(1, 10).Select(i => (byte)i).ToArray(),
			Enumerable.Repeat(1, 100).Select(i => (byte)i).ToArray(),
			Enumerable.Repeat(1, 1000).Select(i => (byte)i).ToArray()
		};

		[Theory]
		[MemberData(nameof(GetTestFillWithZeroData))]
		public void TestFillWithZero(byte[] sut)
		{
			sut.FillWithZero();

			Check.That(sut.All(b => b == 0)).IsTrue();
		}
	}
}

```

`ReClass.NET_Tests/Extensions/ColorExtensionTest.cs`:

```cs
using System.Drawing;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class ColorExtensionTest
	{
		public static TheoryData<Color, Color> GetTestInvertedColorData() => new TheoryData<Color, Color>
		{
			{ Color.White, Color.Black },
			{ Color.Black, Color.White },
			{ Color.Red, Color.Cyan },
			{ Color.Cyan, Color.Red },
			{ Color.Blue, Color.Yellow },
			{ Color.Yellow, Color.Blue },
			{ Color.Lime, Color.Fuchsia },
			{ Color.Fuchsia, Color.Lime },
			{ Color.FromArgb(100, 100, 100), Color.FromArgb(155, 155, 155) },
			{ Color.FromArgb(50, 100, 150), Color.FromArgb(205, 155, 105) }
		};

		[Theory]
		[MemberData(nameof(GetTestInvertedColorData))]
		public void TestInvertedColor(Color sut, Color expected)
		{
			Check.That(sut.Invert().ToArgb()).IsEqualTo(expected.ToArgb());
		}

		public static TheoryData<Color, int> GetTestToRgbData() => new TheoryData<Color, int>
		{
			{ Color.White, 0xFF_FF_FF },
			{ Color.Black, 0x00_00_00 },
			{ Color.Red, 0xFF_00_00 },
			{ Color.Cyan, 0x00_FF_FF },
			{ Color.Blue, 0x00_00_FF },
			{ Color.Yellow, 0xFF_FF_00 },
			{ Color.Lime, 0x00_FF_00 },
			{ Color.Fuchsia, 0xFF_00_FF },
			{ Color.FromArgb(100, 100, 100), 100 << 16 | 100 << 8 | 100 },
			{ Color.FromArgb(50, 100, 150), 50 << 16 | 100 << 8 | 150 }
		};

		[Theory]
		[MemberData(nameof(GetTestToRgbData))]
		public void TestToRgb(Color sut, int expected)
		{
			Check.That(sut.ToRgb()).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/DictionaryExtensionTest.cs`:

```cs
using System.Collections.Generic;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class DictionaryExtensionTest
	{
		[Fact]
		public void TestRemoveWhere()
		{
			var sut = new Dictionary<int, string>
			{
				{ 0, "val0" },
				{ 1, "val1" },
				{ 2, "val2" },
				{ 3, "val3" }
			};

			sut.RemoveWhere(kv => kv.Key % 2 == 1);

			Check.That(sut.Keys).IsEquivalentTo(0, 2);

			sut.RemoveWhere(kv => kv.Key == 2);

			Check.That(sut.Keys).IsEquivalentTo(0);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/EncodingExtensionTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class EncodingExtensionTest
	{
		public static TheoryData<Encoding, int> GetTestSimpleByteCountData() => new TheoryData<Encoding, int>
		{
			{ Encoding.ASCII, 1 },
			{ Encoding.GetEncoding(1252), 1 },
			{ Encoding.UTF8, 1 },
			{ Encoding.Unicode, 2 },
			{ Encoding.BigEndianUnicode, 2 },
			{ Encoding.UTF32, 4 }
		};

		[Theory]
		[MemberData(nameof(GetTestSimpleByteCountData))]
		public void TestSimpleByteCount(Encoding encoding, int expectedByteCount)
		{
			Check.That(encoding.GuessByteCountPerChar()).IsEqualTo(expectedByteCount);
		}

		public static IEnumerable<object[]> GetTestSimpleByteCountNotImplementedData() => Encoding.GetEncodings()
			.Select(e => e.GetEncoding())
			.WhereNot(e => e.IsSameCodePage(Encoding.ASCII) || e.IsSameCodePage(Encoding.UTF8) || e.IsSameCodePage(Encoding.Unicode) || e.IsSameCodePage(Encoding.BigEndianUnicode) || e.IsSameCodePage(Encoding.UTF32) || e.CodePage == 1252)
			.Select(e => new object[] { e });

		[Theory]
		[MemberData(nameof(GetTestSimpleByteCountNotImplementedData))]
		public void TestSimpleByteCountNotImplemented(Encoding encoding)
		{
			Check.ThatCode(encoding.GuessByteCountPerChar).Throws<NotImplementedException>();
		}

		public static TheoryData<Encoding, Encoding, bool> GetTestIsSameCodePageData() => new TheoryData<Encoding, Encoding, bool>
		{
			{ Encoding.ASCII, Encoding.ASCII, true },
			{ Encoding.UTF8, Encoding.UTF8, true },
			{ Encoding.Unicode, Encoding.Unicode, true },
			{ Encoding.UTF32, Encoding.UTF32, true },
			{ Encoding.ASCII, Encoding.UTF8, false },
			{ Encoding.ASCII, Encoding.Unicode, false },
			{ Encoding.ASCII, Encoding.UTF32, false },
			{ Encoding.UTF8, Encoding.UTF32, false },
			{ Encoding.Unicode, Encoding.UTF32, false },
			{ Encoding.UTF8, Encoding.Unicode, false }
		};

		[Theory]
		[MemberData(nameof(GetTestIsSameCodePageData))]
		public void TestIsSameCodePage(Encoding sut, Encoding other, bool expected)
		{
			Check.That(sut.IsSameCodePage(other)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/EnumerableExtensionTests.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class EnumerableExtensionTest
	{
		public static TheoryData<IEnumerable<int>, bool> GetTestNoneData => new TheoryData<IEnumerable<int>, bool>
		{
			{ new int[0], true },
			{ new int[1], false },
			{ Enumerable.Empty<int>(), true }
		};

		[Theory]
		[MemberData(nameof(GetTestNoneData))]
		public void TestNone(IEnumerable<int> sut, bool expected)
		{
			Check.That(sut.None()).IsEqualTo(expected);
		}

		public static TheoryData<IEnumerable<int>, Func<int, bool>, bool> GetTestNoneWithSelectorData => new TheoryData<IEnumerable<int>, Func<int, bool>, bool>
		{
			{ new int[0], i => false, true },
			{ new int[0], i => true, true },
			{ new [] { 1 }, i => i == 1, false },
			{ new [] { 1 }, i => i != 1, true },
			{ new [] { 1, 3, 5 }, i => i % 2 == 0, true }
		};

		[Theory]
		[MemberData(nameof(GetTestNoneWithSelectorData))]
		public void TestNoneWithSelector(IEnumerable<int> sut, Func<int, bool> selector, bool expected)
		{
			Check.That(sut.None(selector)).IsEqualTo(expected);
		}

		public static TheoryData<IEnumerable<int>, Func<int, bool>> GetTestWhereNotData => new TheoryData<IEnumerable<int>, Func<int, bool>>
		{
			{ new int[0], i => false },
			{ new int[0], i => true },
			{ new [] { 1 }, i => i == 1 },
			{ new [] { 1, 3, 5 }, i => i % 2 == 1 }
		};

		[Theory]
		[MemberData(nameof(GetTestWhereNotData))]
		public void TestWhereNot(IEnumerable<int> sut, Func<int, bool> selector)
		{
			Check.That(sut.WhereNot(selector)).IsEmpty();
		}

		public static TheoryData<IEnumerable<int>, int, int> GetTestFindIndexData => new TheoryData<IEnumerable<int>, int, int>
		{
			{ new int[0], 1, -1 },
			{ new [] { 1 }, 1, 0 },
			{ new [] { 1 }, 2, -1 },
			{ new [] { 1, 3, 5 }, 1, 0 },
			{ new [] { 1, 3, 5 }, 2, -1 },
			{ new [] { 1, 3, 5 }, 3, 1 },
			{ new [] { 1, 3, 5 }, 4, -1 },
			{ new [] { 1, 3, 5 }, 5, 2 }
		};

		[Theory]
		[MemberData(nameof(GetTestFindIndexData))]
		public void TestFindIndex(IEnumerable<int> sut, int item, int expected)
		{
			Check.That(sut.FindIndex(i => i == item)).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0)]
		[InlineData(1)]
		[InlineData(10)]
		public void TestForEach(int expected)
		{
			var counter = 0;
			Enumerable.Repeat(0, expected).ForEach(_ => ++counter);

			Check.That(counter).IsEqualTo(expected);
		}

		public static TheoryData<IEnumerable<int>, Func<int, int>, IEnumerable<int>> GetTestDistinctByData => new TheoryData<IEnumerable<int>, Func<int, int>, IEnumerable<int>>
		{
			{ Enumerable.Empty<int>(), i => i, Enumerable.Empty<int>() },
			{ new [] { 1 }, i => i, new [] { 1 } },
			{ new [] { 1, 1, 1, 1 }, i => i, new [] { 1 } },
			{ new [] { 1, 2, 3, 4 }, i => i, new [] { 1, 2, 3, 4 } },
			{ new [] { 1, 1, 2, 2, 3, 3 }, i => i, new [] { 1, 2, 3 } },
			{ new [] { 1, 1, 2, 2, 3, 4 }, i => i, new [] { 1, 2, 3, 4 } },
			{ new [] { 1, 1, 2, 2, 3, 4 }, i => 0, new [] { 1 } }
		};

		[Theory]
		[MemberData(nameof(GetTestDistinctByData))]
		public void TestDistinctBy(IEnumerable<int> sut, Func<int, int> selector, IEnumerable<int> expected)
		{
			Check.That(sut.DistinctBy(selector)).IsEquivalentTo(expected);
		}

		public static TheoryData<IEnumerable<int>, IEnumerable<int>, bool> GetTestIsEquivalentToData => new TheoryData<IEnumerable<int>, IEnumerable<int>, bool>
		{
			{ Enumerable.Empty<int>(), Enumerable.Empty<int>(), true },
			{ Enumerable.Empty<int>(), new int[0], true },
			{ new [] { 1 }, new int[0], false },
			{ new [] { 1 }, new [] { 2 }, false },
			{ new [] { 1, 2, 3 }, new [] { 1, 2, 3 }, true },
			{ new [] { 1, 2, 3 }, new [] { 3, 1, 2 }, true }
		};

		[Theory]
		[MemberData(nameof(GetTestIsEquivalentToData))]
		public void TestIsEquivalentTo(IEnumerable<int> sut, IEnumerable<int> other, bool expected)
		{
			Check.That(sut.IsEquivalentTo(other)).IsEqualTo(expected);
		}

		public static TheoryData<IEnumerable<int>, Func<int, bool>, IEnumerable<int>> GetTestTakeWhileInclusiveData => new TheoryData<IEnumerable<int>, Func<int, bool>, IEnumerable<int>>
		{
			{ Enumerable.Empty<int>(), i => false, Enumerable.Empty<int>() },
			{ new [] { 1 }, i => false, new [] { 1 } },
			{ new [] { 1 }, i => true, new [] { 1 } },
			{ new [] { 1, 1 }, i => false, new [] { 1 } },
			{ new [] { 1, 1 }, i => true, new [] { 1, 1 } },
			{ new [] { 1, 2, 3, 4 }, i => i != 2, new [] { 1, 2 } },
			{ new [] { 1, 2, 3, 4 }, i => i != 3, new [] { 1, 2, 3 } },
			{ new [] { 4, 3, 2, 1 }, i => false, new [] { 4 } }
		};

		[Theory]
		[MemberData(nameof(GetTestTakeWhileInclusiveData))]
		public void TestTakeWhileInclusive(IEnumerable<int> sut, Func<int, bool> predicate, IEnumerable<int> expected)
		{
			Check.That(sut.TakeWhileInclusive(predicate)).IsEquivalentTo(expected);
		}

		public static TheoryData<IEnumerable<int>, Func<int, int, bool>, IEnumerable<IEnumerable<int>>> GetTestGroupWhileData => new TheoryData<IEnumerable<int>, Func<int, int, bool>, IEnumerable<IEnumerable<int>>>
		{
			{ Enumerable.Empty<int>(), (x, y) => false, Enumerable.Empty<IEnumerable<int>>() },
			{ new [] { 1, 2, 3 }, (x, y) => x == y, new [] { new[] { 1 }, new[] { 2 }, new[] { 3 } } },
			{ new [] { 1, 1, 2, 3, 3, 4 }, (x, y) => x == y, new [] { new[] { 1, 1 }, new[] { 2 }, new[] { 3, 3 }, new[] { 4 } } },
			{ new [] { 1, 1, 2, 3, 3, 4 }, (x, y) => x != y, new [] { new[] { 1 }, new[] { 1, 2, 3 }, new[] { 3, 4 } } }
		};

		[Theory]
		[MemberData(nameof(GetTestGroupWhileData))]
		public void TestGroupWhile(IEnumerable<int> sut, Func<int, int, bool> predicate, IEnumerable<IEnumerable<int>> expected)
		{
			using (var expectedIt = expected.GetEnumerator())
			{
				using (var groupIt = sut.GroupWhile(predicate).GetEnumerator())
				{
					while (groupIt.MoveNext())
					{
						Check.That(expectedIt.MoveNext()).IsTrue();

						Check.That(groupIt.Current).IsEquivalentTo(expectedIt.Current);
					}
				}

				Check.That(expectedIt.MoveNext()).IsFalse();
			}
		}

		public static TheoryData<IEnumerable<int>, Func<int, bool>, int> GetTestPredicateOrFirstData => new TheoryData<IEnumerable<int>, Func<int, bool>, int>
		{
			{ new [] { 1 }, i => false, 1 },
			{ new [] { 1 }, i => true, 1 },
			{ new [] { 1, 2, 3, 4 }, i => i == 2, 2 },
			{ new [] { 1, 2, 3, 4 }, i => i == 4, 4 },
			{ new [] { 1, 2, 3, 4 }, i => i == 5, 1 }
		};

		[Theory]
		[MemberData(nameof(GetTestPredicateOrFirstData))]
		public void TestPredicateOrFirst(IEnumerable<int> sut, Func<int, bool> predicate, int expected)
		{
			Check.That(sut.PredicateOrFirst(predicate)).IsEqualTo(expected);
		}

		[Fact]
		public void TestPredicateOrFirstThrows()
		{
			Check.ThatCode(() => Enumerable.Empty<int>().PredicateOrFirst(i => true)).Throws<InvalidOperationException>();
		}

		public class Traversable
		{
			public IList<Traversable> Children { get; } = new List<Traversable>();
		}

		[Fact]
		public void TestTraverse()
		{
			var traversable = new Traversable();
			var child1 = new Traversable();
			child1.Children.Add(new Traversable());
			var child2 = new Traversable();
			child2.Children.Add(new Traversable());
			child2.Children.Add(new Traversable());
			var child3 = new Traversable();
			child3.Children.Add(new Traversable());
			child3.Children.Add(new Traversable());
			child3.Children.Add(new Traversable());
			traversable.Children.Add(child1);
			traversable.Children.Add(child2);
			traversable.Children.Add(child3);

			var expected = new[] { traversable }
				.Append(child1)
				.Append(child2)
				.Append(child3)
				.Concat(child1.Children)
				.Concat(child2.Children)
				.Concat(child3.Children);

			Check.That(new[] { traversable }.Traverse(t => t.Children)).ContainsExactly(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/FloatingPointExtensionTest.cs`:

```cs
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class FloatingPointExtensionTest
	{
		[Theory]
		[InlineData(0.0f, 0.0f, 0.0f, true)]
		[InlineData(0.0f, 1.0f, 0.0f, false)]
		[InlineData(0.0f, 1.0f, 1.0f, true)]
		[InlineData(1.0f, 0.0f, 1.0f, true)]
		[InlineData(-1.0f, 0.0f, 1.0f, true)]
		[InlineData(-1.0f, 1.0f, 1.0f, false)]
		[InlineData(-0.5f, 0.5f, 1.0f, true)]
		[InlineData(-0.25f, 0.75f, 1.0f, true)]
		[InlineData(-0.25f, 0.25f, 0.5f, true)]
		[InlineData(0.9999f, 1.0f, 0.0f, false)]
		[InlineData(0.9999f, 1.0f, 0.1f, true)]
		[InlineData(0.9999f, 1.0f, 0.01f, true)]
		[InlineData(0.9999f, 1.0f, 0.001f, true)]
		[InlineData(0.9999f, 1.0f, 0.0001f, true, Skip = "Should work but float can't hold these values")]
		[InlineData(0.9999f, 1.0f, 0.00001f, false, Skip = "Should work but float can't hold these values")]
		public void TestNearlyEqualFloat(float value1, float value2, float epsilon, bool expected)
		{
			Check.That(value1.IsNearlyEqual(value2, epsilon)).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0.0, 0.0, 0.0, true)]
		[InlineData(0.0, 1.0, 0.0, false)]
		[InlineData(0.0, 1.0, 1.0, true)]
		[InlineData(1.0, 0.0, 1.0, true)]
		[InlineData(-1.0, 0.0, 1.0, true)]
		[InlineData(-1.0, 1.0, 1.0, false)]
		[InlineData(-0.5, 0.5, 1.0, true)]
		[InlineData(-0.25, 0.75, 1.0, true)]
		[InlineData(-0.25, 0.25, 0.5, true)]
		[InlineData(0.9999, 1.0, 0.0, false)]
		[InlineData(0.9999, 1.0, 0.1, true)]
		[InlineData(0.9999, 1.0, 0.01, true)]
		[InlineData(0.9999, 1.0, 0.001, true)]
		[InlineData(0.9999, 1.0, 0.0001, true)]
		[InlineData(0.9999, 1.0, 0.00001, false)]
		public void TestNearlyEqualDouble(double value1, double value2, double epsilon, bool expected)
		{
			Check.That(value1.IsNearlyEqual(value2, epsilon)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/IntPtrExtensionTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class IntPtrExtensionTest
	{
		public static TheoryData<IntPtr, bool> GetTestIsNullData => new TheoryData<IntPtr, bool>
		{
			{ IntPtr.Zero, true },
			{ (IntPtr)1, false }
		};

		[Theory]
		[MemberData(nameof(GetTestIsNullData))]
		public void TestIsNull(IntPtr ptr, bool expected)
		{
			Check.That(ptr.IsNull()).IsEqualTo(expected);
		}

		public static TheoryData<IntPtr, bool> GetTestMayBeValidData => new TheoryData<IntPtr, bool>
		{
			{ IntPtr.Zero, false },
			{ (IntPtr)1, false },
			{ (IntPtr)0x10000, true },
			{ (IntPtr)int.MaxValue, true },
#if RECLASSNET64
			{ (IntPtr)long.MaxValue + 1, false }
#else
			{ (IntPtr)int.MaxValue + 1, false }
#endif
		};

		[Theory]
		[MemberData(nameof(GetTestMayBeValidData))]
		public void TestMayBeValid(IntPtr ptr, bool expected)
		{
			Check.That(ptr.MayBeValid()).IsEqualTo(expected);
		}

		public static TheoryData<IntPtr, IntPtr, IntPtr, bool> GetTestIsInRangeData => new TheoryData<IntPtr, IntPtr, IntPtr, bool>
		{
			{ (IntPtr)10, (IntPtr)100, (IntPtr)1000, false },
			{ (IntPtr)100, (IntPtr)100, (IntPtr)1000, true },
			{ (IntPtr)500, (IntPtr)100, (IntPtr)1000, true },
			{ (IntPtr)1000, (IntPtr)100, (IntPtr)1000, true },
			{ (IntPtr)1500, (IntPtr)100, (IntPtr)1000, false }
		};

		[Theory]
		[MemberData(nameof(GetTestIsInRangeData))]
		public void TestIsInRange(IntPtr ptr, IntPtr start, IntPtr end, bool expected)
		{
			Check.That(ptr.IsInRange(start, end)).IsEqualTo(expected);
		}

		public static TheoryData<IntPtr, IntPtr, int> GetTestCompareToData => new TheoryData<IntPtr, IntPtr, int>
		{
			{ (IntPtr)10, (IntPtr)100, -1 },
			{ (IntPtr)100, (IntPtr)100, 0 },
			{ (IntPtr)500, (IntPtr)100, 1 }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareToData))]
		public void TestCompareTo(IntPtr ptr, IntPtr other, int expected)
		{
			Check.That(ptr.CompareTo(other)).IsEqualTo(expected);
		}

		public static TheoryData<IntPtr, IntPtr, IntPtr, int> GetTestCompareToRangeData => new TheoryData<IntPtr, IntPtr, IntPtr, int>
		{
			{ (IntPtr)10, (IntPtr)100, (IntPtr)1000, -1 },
			{ (IntPtr)100, (IntPtr)100, (IntPtr)1000, 0 },
			{ (IntPtr)500, (IntPtr)100, (IntPtr)1000, 0 },
			{ (IntPtr)1000, (IntPtr)100, (IntPtr)1000, 0 },
			{ (IntPtr)1500, (IntPtr)100, (IntPtr)1000, 1 }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareToRangeData))]
		public void TestCompareToRange(IntPtr ptr, IntPtr start, IntPtr end, int expected)
		{
			Check.That(ptr.CompareToRange(start, end)).IsEqualTo(expected);
		}

		public static TheoryData<IntPtr, long> GetTestToInt64BitsData => new TheoryData<IntPtr, long>
		{
			{ (IntPtr)0x10, 0x10L },
			{ (IntPtr)int.MaxValue, 0x7FFF_FFFFL },
			{ (IntPtr)int.MaxValue + 1, 0x8000_0000L }
		};

		[Theory]
		[MemberData(nameof(GetTestToInt64BitsData))]
		public void TestToInt64Bits(IntPtr ptr, long expected)
		{
			Check.That(ptr.ToInt64Bits()).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/ListExtensionTest.cs`:

```cs
using System;
using System.Collections.Generic;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class ListExtensionTest
	{
		public static TheoryData<IList<int>, Func<int, int>, int> GetTestBinarySearchData() => new TheoryData<IList<int>, Func<int, int>, int>
		{
			{ new List<int> { 0, 2, 4, 6, 8, 10, 12 }, i => 2.CompareTo(i), 1 },
			{ new List<int> { 0, 2, 4, 6, 8, 10, 12 }, i => 8.CompareTo(i), 4 },
			{ new List<int> { 1, 3, 5, 7, 9, 11, 13 }, i => 1.CompareTo(i), 0 },
			{ new List<int> { 1, 3, 5, 7, 9, 11, 13 }, i => 2.CompareTo(i), ~1 },
			{ new List<int> { 1, 3, 5, 7, 9, 11, 13 }, i => 14.CompareTo(i), ~7 },
		};

		[Theory]
		[MemberData(nameof(GetTestBinarySearchData))]
		public void TestBinarySearch(IList<int> sut, Func<int, int> comparer, int expected)
		{
			Check.That(sut.BinarySearch(comparer)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/PointExtensionTest.cs`:

```cs
using System.Drawing;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class PointExtensionTest
	{
		public static TheoryData<Point, int, int, Point> GetTestRelocateData() => new TheoryData<Point, int, int, Point>
		{
			{ Point.Empty, 0, 0, Point.Empty },
			{ Point.Empty, 1, 1, new Point(1, 1) },
			{ Point.Empty, -1, -1, new Point(-1, -1) },
			{ new Point(-1, -1), 1, 1, Point.Empty },
		};

		[Theory]
		[MemberData(nameof(GetTestRelocateData))]
		public void TestRelocate(Point sut, int offsetX, int offsetY, Point expected)
		{
			Check.That(sut.Relocate(offsetX, offsetY)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/StringBuilderExtensionTest.cs`:

```cs
using System.Text;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class StringBuilderExtensionTest
	{
		[Fact]
		public void TestPrependChar()
		{
			var sut = new StringBuilder("test");
			sut.Prepend('x');

			Check.That(sut.ToString()).IsEqualTo("xtest");
		}

		[Theory]
		[InlineData(null)]
		[InlineData("")]
		[InlineData("test")]
		public void TestPrependString(string value)
		{
			var sut = new StringBuilder("test");
			sut.Prepend(value);

			Check.That(sut.ToString()).IsEqualTo(value + "test");
		}
	}
}

```

`ReClass.NET_Tests/Extensions/StringExtensionTest.cs`:

```cs
using System;
using System.Collections.Generic;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class StringExtensionTest
	{
		public static TheoryData<char> GetTestIsPrintableData() => new TheoryData<char>
		{
			'0', '9', ' ', 'a', 'A', 'z', 'Z', '-', '_', '°', '^', '"', '\\', '\"', '&', '@', '$', '|', '<', '>', ';', ',', '.', ':', '#', '*', '+', '~', '`', '´', 'ß', '?', '=', '(', ')', '[', ']', '{', '}'
		};

		[Theory]
		[MemberData(nameof(GetTestIsPrintableData))]
		public void TestIsPrintable(char c)
		{
			Check.That(c.IsPrintable()).IsTrue();
		}

		public static TheoryData<char> GetTestIsNotPrintableData() => new TheoryData<char>
		{
			'\u0000','\u0001', '\u0002', '\u009A','\u009B', '\u009C', '\u009D','\u009E', '\u009F'
		};

		[Theory]
		[MemberData(nameof(GetTestIsNotPrintableData))]
		public void TestIsNotPrintable(char c)
		{
			Check.That(c.IsPrintable()).IsFalse();
		}

		public static TheoryData<string, int, string> GetTestLimitLengthData() => new TheoryData<string, int, string>
		{
			{ string.Empty, 0, string.Empty },
			{ string.Empty, 1, string.Empty },
			{ "01234", 0, string.Empty },
			{ "01234", 1, "0" },
			{ "01234", 5, "01234" },
			{ "01234", 10, "01234" }
		};

		[Theory]
		[MemberData(nameof(GetTestLimitLengthData))]
		public void TestLimitLength(string sut, int length, string expected)
		{
			Check.That(sut.LimitLength(length)).IsEqualTo(expected);
		}

		[Fact]
		public void TestLimitLengthThrows()
		{
			Check.ThatCode(() => "".LimitLength(-1)).Throws<ArgumentOutOfRangeException>();
		}

		public static TheoryData<IEnumerable<byte>, IEnumerable<char>> GetTestInterpretAsSingleByteCharacterData() => new TheoryData<IEnumerable<byte>, IEnumerable<char>>
		{
			{ new byte[0], string.Empty },
			{ new [] { (byte)'t', (byte)'e', (byte)'s', (byte)'t' }, "test" }
		};

		[Theory]
		[MemberData(nameof(GetTestInterpretAsSingleByteCharacterData))]
		public void TestInterpretAsSingleByteCharacter(IEnumerable<byte> sut, IEnumerable<char> expected)
		{
			Check.That(sut.InterpretAsSingleByteCharacter()).ContainsExactly(expected);
		}

		public static TheoryData<IEnumerable<byte>, IEnumerable<char>> GetTestInterpretAsDoubleByteCharacterData() => new TheoryData<IEnumerable<byte>, IEnumerable<char>>
		{
			{ new byte[0], string.Empty },
			{ new [] { (byte)'t', (byte)0, (byte)'e', (byte)0, (byte)'s', (byte)0, (byte)'t', (byte)0 }, "test" }
		};

		[Theory]
		[MemberData(nameof(GetTestInterpretAsDoubleByteCharacterData))]
		public void TestInterpretAsDoubleByteCharacter(IEnumerable<byte> sut, IEnumerable<char> expected)
		{
			Check.That(sut.InterpretAsDoubleByteCharacter()).ContainsExactly(expected);
		}

		public static TheoryData<IEnumerable<char>, float> GetTestCalculatePrintableDataThresholdData() => new TheoryData<IEnumerable<char>, float>
		{
			{ new char[0], 0.0f },
			{ new [] { '\0' }, 0.0f },
			{ new [] { 'a' }, 1.0f },
			{ new [] { '\0', 'a' }, 0.0f },
			{ new [] { 'a', '\0' }, 0.5f },
			{ new [] { '\0', 'a', 'a' }, 0.0f },
			{ new [] { 'a', 'a', '\0' }, 2 / 3.0f },
			{ new [] { 'a', 'a', '\0', '\0' }, 0.5f },
			{ new [] { 'a', 'a', '\0', '\0', '\0' }, 2 / 5.0f }
		};

		[Theory]
		[MemberData(nameof(GetTestCalculatePrintableDataThresholdData))]
		public void TestCalculatePrintableDataThreshold(IEnumerable<char> sut, float expected)
		{
			Check.That(sut.CalculatePrintableDataThreshold()).IsCloseTo(expected, 0.001);
		}

		[Theory]
		[InlineData('a')]
		[InlineData('a', 'a')]
		[InlineData('a', 'a', 'f')]
		[InlineData('#', '+', 'r', '?', 'ß', '%', '&', '§', '_', '0', '/', '(', 'ö')]
		public void TestIsPrintableData(params char[] sut)
		{
			Check.That(sut.IsPrintableData()).IsTrue();
		}

		[Theory]
		[InlineData]
		[InlineData('a', '\0')]
		[InlineData('\0', 'a')]
		[InlineData('a', 'a', '\0')]
		[InlineData('a', 'a', 'f', '\0')]
		[InlineData('a', 'a', '\0', 'f')]
		[InlineData('a', '\0', 'a', 'f')]
		[InlineData('\0', 'a', 'a', 'f')]
		public void TestIsNotPrintableData(params char[] sut)
		{
			Check.That(sut.IsPrintableData()).IsFalse();
		}

		[Theory]
		[InlineData('a', 'a', 'f', '\0')]
		[InlineData('1', '2', '3', '4', '5', '6', '7', '8', '\0', '\0')]
		[InlineData('1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', '\0', '\0', '\0', '\0')]
		public void TestIsLikelyPrintableData(params char[] sut)
		{
			Check.That(sut.IsLikelyPrintableData()).IsTrue();
		}

		[Theory]
		[InlineData]
		[InlineData('a', '\0')]
		[InlineData('\0', 'a')]
		[InlineData('a', 'a', '\0')]
		[InlineData('a', 'a', '\0', 'f')]
		[InlineData('a', 'a', '\0', '\0')]
		[InlineData('a', '\0', 'a', 'f')]
		public void TestIsNotLikelyPrintableData(params char[] sut)
		{
			Check.That(sut.IsPrintableData()).IsFalse();
		}

		[Theory]
		[InlineData("", false, null)]
		[InlineData("-", false, null)]
		[InlineData("-0", false, null)]
		[InlineData("-0x0", false, null)]
		[InlineData("-h0", false, null)]
		[InlineData("0", true, "0")]
		[InlineData("h0", true, "0")]
		[InlineData("0x0", true, "0")]
		[InlineData("0123456789abcdef", true, "0123456789abcdef")]
		[InlineData("h0123456789abcdef", true, "0123456789abcdef")]
		[InlineData("0x0123456789abcdef", true, "0123456789abcdef")]
		[InlineData("0123456789ABCDEF", true, "0123456789ABCDEF")]
		public void TestTryGetHexString(string input, bool expectedResult, string expectedValue)
		{
			Check.That(input.TryGetHexString(out var value)).IsEqualTo(expectedResult);
			Check.That(value).IsEqualTo(expectedValue);
		}
	}
}

```

`ReClass.NET_Tests/Extensions/StringReaderExtensionTest.cs`:

```cs
using System.IO;
using NFluent;
using ReClassNET.Extensions;
using Xunit;

namespace ReClass.NET_Tests.Extensions
{
	public class StringReaderExtensionTest
	{
		[Theory]
		[InlineData("", -1)]
		[InlineData(" ", -1)]
		[InlineData("\t", -1)]
		[InlineData("\r", -1)]
		[InlineData("\n", -1)]
		[InlineData("x", (int)'x')]
		[InlineData("x ", (int)'x')]
		[InlineData(" x", (int)'x')]
		[InlineData("  x", (int)'x')]
		[InlineData("\tx ", (int)'x')]
		[InlineData("\rx ", (int)'x')]
		[InlineData("\nx ", (int)'x')]
		public void TestReadSkipWhitespaces(string input, int expected)
		{
			using (var sut = new StringReader(input))
			{
				Check.That(sut.ReadSkipWhitespaces()).IsEqualTo(expected);
			}
		}
	}
}

```

`ReClass.NET_Tests/Memory/MemoryBufferTest.cs`:

```cs
using System;
using System.Text;
using NFluent;
using ReClassNET.Memory;
using Xunit;

namespace ReClass.NET_Tests.Memory
{
	public class MemoryBufferTest
	{
		private static MemoryBuffer CreateFromBytes(params byte[] data)
		{
			var buffer = new MemoryBuffer
			{
				Size = data.Length
			};
			Array.Copy(data, buffer.RawData, data.Length);
			return buffer;
		}

		public static TheoryData<MemoryBuffer, int, int, byte[]> GetTestReadBytesData() => new TheoryData<MemoryBuffer, int, int, byte[]>
		{
			{ CreateFromBytes(), 0, 0, new byte[0] },
			{ CreateFromBytes(), 0, 4, new byte[] { 0, 0, 0, 0 } },
			{ CreateFromBytes(), 10, 4, new byte[] { 0, 0, 0, 0 } },
			{ CreateFromBytes(1, 2, 3, 4), 0, 0, new byte[0] },
			{ CreateFromBytes(1, 2, 3, 4), 0, 4, new byte[] { 1, 2, 3, 4 } },
			{ CreateFromBytes(1, 2, 3, 4), 2, 4, new byte[] { 0, 0, 0, 0 } },
			{ CreateFromBytes(1, 2, 3, 4), 10, 4, new byte[] { 0, 0, 0, 0 } },
			{ CreateFromBytes(1, 2, 3, 4, 5, 6), 2, 4, new byte[] { 3, 4, 5, 6 } }
		};

		[Theory]
		[MemberData(nameof(GetTestReadBytesData))]
		public void TestReadBytesReturn(MemoryBuffer sut, int offset, int length, byte[] expected)
		{
			Check.That(sut.ReadBytes(offset, length)).ContainsExactly(expected);
		}

		[Theory]
		[MemberData(nameof(GetTestReadBytesData))]
		public void TestReadBytesFill(MemoryBuffer sut, int offset, int length, byte[] expected)
		{
			var data = new byte[length];

			sut.ReadBytes(offset, data);

			Check.That(data).ContainsExactly(expected);
		}

		public static TheoryData<MemoryBuffer, int, sbyte, byte> GetTestReadUInt8Data() => new TheoryData<MemoryBuffer, int, sbyte, byte>
		{
			{ CreateFromBytes(), 0, 0, 0 },
			{ CreateFromBytes(), 4, 0, 0 },
			{ CreateFromBytes(1, 2, 3, 4), 0, 1, 1 },
			{ CreateFromBytes(1, 2, 3, 4), 2, 3, 3 },
			{ CreateFromBytes(1, 2, 3, 0xFF), 3, -1, 255 }
		};

		[Theory]
		[MemberData(nameof(GetTestReadUInt8Data))]
		public void TestReadInt8(MemoryBuffer sut, int offset, sbyte expectedSigned, byte expectedUnsigned)
		{
			Check.That(sut.ReadInt8(offset)).IsEqualTo(expectedSigned);
			Check.That(sut.ReadUInt8(offset)).IsEqualTo(expectedUnsigned);
		}

		public static TheoryData<MemoryBuffer, int, short, ushort> GetTestReadUInt16Data() => new TheoryData<MemoryBuffer, int, short, ushort>
		{
			{ CreateFromBytes(), 0, 0, 0 },
			{ CreateFromBytes(), 4, 0, 0 },
			{ CreateFromBytes(1, 2, 3, 4), 0, 0x0201, 0x0201 },
			{ CreateFromBytes(1, 2, 3, 4), 2, 0x0403, 0x0403 },
			{ CreateFromBytes(1, 2, 3, 0xBF, 0xFF), 3, unchecked((short)0xFFBF), 0xFFBF }
		};

		[Theory]
		[MemberData(nameof(GetTestReadUInt16Data))]
		public void TestReadInt16(MemoryBuffer sut, int offset, short expectedSigned, ushort expectedUnsigned)
		{
			Check.That(sut.ReadInt16(offset)).IsEqualTo(expectedSigned);
			Check.That(sut.ReadUInt16(offset)).IsEqualTo(expectedUnsigned);
		}

		public static TheoryData<MemoryBuffer, int, int, uint> GetTestReadUInt32Data() => new TheoryData<MemoryBuffer, int, int, uint>
		{
			{ CreateFromBytes(), 0, 0, 0 },
			{ CreateFromBytes(), 4, 0, 0 },
			{ CreateFromBytes(1, 2, 3, 4), 0, 0x04030201, 0x04030201 },
			{ CreateFromBytes(1, 2, 3, 4, 0xBF, 0xFF), 2, unchecked((int)0xFFBF0403), 0xFFBF0403 }
		};

		[Theory]
		[MemberData(nameof(GetTestReadUInt32Data))]
		public void TestReadInt32(MemoryBuffer sut, int offset, int expectedSigned, uint expectedUnsigned)
		{
			Check.That(sut.ReadInt32(offset)).IsEqualTo(expectedSigned);
			Check.That(sut.ReadUInt32(offset)).IsEqualTo(expectedUnsigned);
		}

		public static TheoryData<MemoryBuffer, int, long, ulong> GetTestReadUInt64Data() => new TheoryData<MemoryBuffer, int, long, ulong>
		{
			{ CreateFromBytes(), 0, 0, 0 },
			{ CreateFromBytes(), 4, 0, 0 },
			{ CreateFromBytes(1, 2, 3, 4, 5, 6, 7, 8), 0, 0x0807060504030201, 0x0807060504030201 },
			{ CreateFromBytes(1, 2, 3, 4, 5, 6, 0xBF, 0xFF, 0xBF, 0xFF), 2, unchecked((long)0xFFBFFFBF06050403), 0xFFBFFFBF06050403 }
		};

		[Theory]
		[MemberData(nameof(GetTestReadUInt64Data))]
		public void TestReadInt64(MemoryBuffer sut, int offset, long expectedSigned, ulong expectedUnsigned)
		{
			Check.That(sut.ReadInt64(offset)).IsEqualTo(expectedSigned);
			Check.That(sut.ReadUInt64(offset)).IsEqualTo(expectedUnsigned);
		}

		public static TheoryData<MemoryBuffer, int, float> GetTestReadFloatData() => new TheoryData<MemoryBuffer, int, float>
		{
			{ CreateFromBytes(), 0, 0.0f },
			{ CreateFromBytes(), 4, 0.0f },
			{ CreateFromBytes(0, 0x40, 0x9A, 0x44), 0, 1234.0f },
			{ CreateFromBytes(1, 2, 0, 8, 0x87, 0x45), 2, 4321.0f }
		};

		[Theory]
		[MemberData(nameof(GetTestReadFloatData))]
		public void TestReadFloat(MemoryBuffer sut, int offset, float expected)
		{
			Check.That(sut.ReadFloat(offset)).IsCloseTo(expected, 0.0001);
		}

		public static TheoryData<MemoryBuffer, int, double> GetTestReadDoubleData() => new TheoryData<MemoryBuffer, int, double>
		{
			{ CreateFromBytes(), 0, 0.0 },
			{ CreateFromBytes(), 4, 0.0 },
			{ CreateFromBytes(0x54, 0x74, 0x24, 0x97, 0x1F, 0xE1, 0xB0, 0x40), 0, 4321.1234 },
			{ CreateFromBytes(1, 2, 0x68, 0x22, 0x6C, 0x78, 0xBA, 0x49, 0x93, 0x40), 2, 1234.4321 }
		};

		[Theory]
		[MemberData(nameof(GetTestReadDoubleData))]
		public void TestReadDouble(MemoryBuffer sut, int offset, double expected)
		{
			Check.That(sut.ReadDouble(offset)).IsCloseTo(expected, 0.0001);
		}

		public static TheoryData<MemoryBuffer, Encoding, int, int, string> GetTestReadStringData() => new TheoryData<MemoryBuffer, Encoding, int, int, string>
		{
			{ CreateFromBytes(), Encoding.ASCII, 0, 0, string.Empty },
			{ CreateFromBytes(), Encoding.ASCII, 4, 0, string.Empty },
			{ CreateFromBytes(), Encoding.ASCII, 0, 4, string.Empty },
			{ CreateFromBytes(0x31, 0x32, 0x33, 0x61, 0x62, 0x63), Encoding.ASCII, 0, 6, "123abc" },
			{ CreateFromBytes(0x31, 0x32, 0x33, 0x61, 0x62, 0x63), Encoding.ASCII, 2, 3, "3ab" },
			{ CreateFromBytes(0, 0, 0, 0, 0, 0), Encoding.GetEncoding(1252), 0, 6, "......" },
			{ CreateFromBytes(0, 0, 0, 0, 0, 0), Encoding.UTF8, 0, 6, "......" },
			{ CreateFromBytes(0, 1, 2, 3, 4, 5), Encoding.UTF8, 0, 6, "......" },
			{ CreateFromBytes(0x31, 0x32, 0x33, 0x61, 0x62, 0x63, 0xC4, 0xD6, 0xDC), Encoding.GetEncoding(1252), 0, 9, "123abcÄÖÜ" },
			{ CreateFromBytes(0x31, 0x32, 0x33, 0x61, 0x62, 0x63, 0xC3, 0x84, 0xC3, 0x96, 0xC3, 0x9C), Encoding.UTF8, 0, 12, "123abcÄÖÜ" },
			{ CreateFromBytes(0x61, 0xC3), Encoding.UTF8, 0, 2, "a." },
			{ CreateFromBytes(0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0xC4, 0x00, 0xD6, 0x00, 0xDC, 0x00), Encoding.Unicode, 0, 18, "123abcÄÖÜ" },
			{ CreateFromBytes(0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0xD6, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00), Encoding.UTF32, 0, 36, "123abcÄÖÜ" }
		};

		[Theory]
		[MemberData(nameof(GetTestReadStringData))]
		public void TestReadString(MemoryBuffer sut, Encoding encoding, int offset, int length, string expected)
		{
			Check.That(sut.ReadString(encoding, offset, length)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/BytePatternTest.cs`:

```cs
using System;
using System.Collections.Generic;
using NFluent;
using ReClassNET.MemoryScanner;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner
{
	public class BytePatternTest
	{
		[Theory]
		[InlineData("", 0, false)]
		[InlineData("0", 1, true)]
		[InlineData("a", 1, true)]
		[InlineData("A", 1, true)]
		[InlineData("00", 1, false)]
		[InlineData("aa", 1, false)]
		[InlineData("AA", 1, false)]
		[InlineData("0000", 2, false)]
		[InlineData("00aa", 2, false)]
		[InlineData("00 aa", 2, false)]
		[InlineData("00\taa", 2, false)]
		[InlineData("?", 1, true)]
		[InlineData("??", 1, true)]
		[InlineData("????", 2, true)]
		[InlineData("?? ??", 2, true)]
		[InlineData("a?", 1, true)]
		[InlineData("?a", 1, true)]
		[InlineData("aa ?a", 2, true)]
		[InlineData("aa ?? 00", 3, true)]
		public void TestParse(string input, int expectedLength, bool expectedHasWildcards)
		{
			var sut = BytePattern.Parse(input);

			Check.That(sut.Length).IsEqualTo(expectedLength);
			Check.That(sut.HasWildcards).IsEqualTo(expectedHasWildcards);
		}

		[Fact]
		public void TestParseThrows()
		{
			Check.ThatCode(() => BytePattern.Parse("aa bb zz")).Throws<ArgumentException>();
		}

		public static TheoryData<IEnumerable<byte>, int> GetTestFromByteEnumerationData() => new TheoryData<IEnumerable<byte>, int>
		{
			{ new byte[0], 0 },
			{ new byte[] { 0x00, 0x11, 0xaa }, 3 }
		};

		[Theory]
		[MemberData(nameof(GetTestFromByteEnumerationData))]
		public void TestFromByteEnumeration(IEnumerable<byte> input, int expectedLength)
		{
			var sut = BytePattern.From(input);

			Check.That(sut.Length).IsEqualTo(expectedLength);
			Check.That(sut.HasWildcards).IsFalse();
		}

		public static TheoryData<IEnumerable<Tuple<byte, bool>>, int, bool> GetTestFromByteEnumerationWithWildcardsData() => new TheoryData<IEnumerable<Tuple<byte, bool>>, int, bool>
		{
			{ new Tuple<byte, bool>[0], 0, false },
			{ new [] { Tuple.Create((byte)0, false) }, 1, false },
			{ new [] { Tuple.Create((byte)0, true) }, 1, true },
			{ new [] { Tuple.Create((byte)0xaa, false), Tuple.Create((byte)0, true) }, 2, true }
		};

		[Theory]
		[MemberData(nameof(GetTestFromByteEnumerationWithWildcardsData))]
		public void TestFromByteEnumerationWithWildcards(IEnumerable<Tuple<byte, bool>> input, int expectedLength, bool expectedHasWildcards)
		{
			var sut = BytePattern.From(input);

			Check.That(sut.Length).IsEqualTo(expectedLength);
			Check.That(sut.HasWildcards).IsEqualTo(expectedHasWildcards);
		}

		[Fact]
		public void TestToArrayWithWildcardsThrows()
		{
			var sut = BytePattern.Parse("0?");

			Check.ThatCode(() => sut.ToByteArray()).Throws<InvalidOperationException>();
		}

		[Theory]
		[InlineData("")]
		[InlineData("00AA", (byte)0x00, (byte)0xAA)]
		[InlineData("00 aa bb 99", (byte)0x00, (byte)0xAA, (byte)0xBB, (byte)0x99)]
		public void TestToArray(string input, params byte[] expected)
		{
			var sut = BytePattern.Parse(input);

			Check.That(sut.ToByteArray()).ContainsExactly(expected);
		}

		public static TheoryData<string, PatternMaskFormat, string, string> GetTestToStringData() => new TheoryData<string, PatternMaskFormat, string, string>
		{
			{ string.Empty, PatternMaskFormat.Separated, string.Empty, string.Empty },
			{ string.Empty, PatternMaskFormat.Combined, string.Empty, null },
			{ "aa bb 00", PatternMaskFormat.Separated, @"\xAA\xBB\x00", "xxx" },
			{ "aa bb 00", PatternMaskFormat.Combined, "AA BB 00", null },
			{ "aa ?? 00", PatternMaskFormat.Separated, @"\xAA\x00\x00", "x?x" },
			{ "aa ?? 00", PatternMaskFormat.Combined, "AA ?? 00", null },
			{ "a? ?? ?0", PatternMaskFormat.Separated, @"\x00\x00\x00", "???" },
			{ "a? ?? ?0", PatternMaskFormat.Combined, "A? ?? ?0", null },
		};

		[Theory]
		[MemberData(nameof(GetTestToStringData))]
		public void TestToString(string input, PatternMaskFormat format, string expectedPattern, string expectedMask)
		{
			var sut = BytePattern.Parse(input);

			var (pattern, mask) = sut.ToString(format);

			Check.That(pattern).IsEqualTo(expectedPattern);
			Check.That(mask).IsEqualTo(expectedMask);
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/Comparer/ByteMemoryComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner.Comparer
{
	public class ByteMemoryComparerTest
	{
		[Theory]
		[InlineData(ScanCompareType.Equal, 0, 0)]
		[InlineData(ScanCompareType.Equal, 1, 2)]
		[InlineData(ScanCompareType.Equal, 2, 1)]
		[InlineData(ScanCompareType.Between, 2, 4)]
		[InlineData(ScanCompareType.BetweenOrEqual, 4, 2)]
		[InlineData(ScanCompareType.NotEqual, 0, 0)]
		public void TestConstructor(ScanCompareType compareType, byte value1, byte value2)
		{
			var sut = new ByteMemoryComparer(compareType, value1, value2);

			Check.That(sut.CompareType).IsEqualTo(compareType);
			Check.That(sut.ValueSize).IsEqualTo(sizeof(byte));
			Check.That(sut.Value1).IsOneOf(value1, value2);
			Check.That(sut.Value2).IsOneOf(value1, value2);
		}

		public static TheoryData<ScanCompareType, byte, byte, byte[], bool, ScanResult> GetTestCompareBasicData() => new TheoryData<ScanCompareType, byte, byte, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Equal, 0, 0, new byte[] { 0 }, true, new ByteScanResult(0) },
			{ ScanCompareType.Equal, 0, 0, new byte[] { 1 }, false, null },
			{ ScanCompareType.Equal, 1, 0, new byte[] { 1 }, true, new ByteScanResult(1) },
			{ ScanCompareType.Equal, 1, 0, new byte[] { 0 }, false, null },
			{ ScanCompareType.NotEqual, 1, 0, new byte[] { 0 }, true, new ByteScanResult(0) },
			{ ScanCompareType.NotEqual, 1, 0, new byte[] { 1 }, false, null },
			{ ScanCompareType.GreaterThan, 1, 0, new byte[] { 0 }, false, null },
			{ ScanCompareType.GreaterThan, 1, 0, new byte[] { 2 }, true, new ByteScanResult(2) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, new byte[] { 0 }, false, null },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, new byte[] { 1 }, true, new ByteScanResult(1) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, new byte[] { 2 }, true, new ByteScanResult(2) },
			{ ScanCompareType.LessThan, 1, 0, new byte[] { 1 }, false, null },
			{ ScanCompareType.LessThan, 1, 0, new byte[] { 0 }, true, new ByteScanResult(0) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, new byte[] { 2 }, false, null },
			{ ScanCompareType.LessThanOrEqual, 1, 0, new byte[] { 1 }, true, new ByteScanResult(1) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, new byte[] { 0 }, true, new ByteScanResult(0) },
			{ ScanCompareType.Between, 1, 2, new byte[] { 0 }, false, null },
			{ ScanCompareType.Between, 1, 2, new byte[] { 1 }, false, null },
			{ ScanCompareType.Between, 1, 2, new byte[] { 2 }, false, null },
			{ ScanCompareType.Between, 1, 2, new byte[] { 3 }, false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, new byte[] { 0 }, false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, new byte[] { 1 }, true, new ByteScanResult(1) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, new byte[] { 2 }, true, new ByteScanResult(2) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, new byte[] { 3 }, false, null }
		};

		public static TheoryData<ScanCompareType, byte, byte, byte[], bool, ScanResult> GetTestCompareScanCompareTypeUnknownData() => new TheoryData<ScanCompareType, byte, byte, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Unknown, 0, 0, new byte[] { 0 }, true, new ByteScanResult(0) },
			{ ScanCompareType.Unknown, 0, 0, new byte[] { 1 }, true, new ByteScanResult(1) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareBasicData))]
		[MemberData(nameof(GetTestCompareScanCompareTypeUnknownData))]
		public void TestCompare(ScanCompareType compareType, byte value1, byte value2, byte[] data, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new ByteMemoryComparer(compareType, value1, value2);

			Check.That(sut.Compare(data, 0, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<ByteScanResult>();
			}
		}

		[Theory]
		[InlineData(ScanCompareType.Changed)]
		[InlineData(ScanCompareType.NotChanged)]
		[InlineData(ScanCompareType.Decreased)]
		[InlineData(ScanCompareType.DecreasedOrEqual)]
		[InlineData(ScanCompareType.Increased)]
		[InlineData(ScanCompareType.IncreasedOrEqual)]
		public void TestCompareInvalidCompareTypeThrows(ScanCompareType compareType)
		{
			var sut = new ByteMemoryComparer(compareType, 0, 0);

			Check.ThatCode(() => sut.Compare(new byte[] { 0 }, 0, out _)).Throws<InvalidCompareTypeException>();
		}

		public static TheoryData<byte[], int, Type> GetTestCompareThrowsData() => new TheoryData<byte[], int, Type>
		{
			{ null, 0, typeof(ArgumentNullException) },
			{ new byte[0], 0, typeof(ArgumentOutOfRangeException) },
			{ new byte[1], 1, typeof(ArgumentOutOfRangeException) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareThrowsData))]
		public void TestCompareInvalidDataThrows(byte[] data, int index, Type expectedExceptionType)
		{
			var sut = new ByteMemoryComparer(ScanCompareType.Equal, 0, 0);

			Check.ThatCode(() => sut.Compare(data, index, out _)).ThrowsType(expectedExceptionType);
		}

		public static TheoryData<ScanCompareType, byte, byte, byte[], ScanResult, bool, ScanResult> GetTestCompareWithPreviousData()
		{
			var data = new TheoryData<ScanCompareType, byte, byte, byte[], ScanResult, bool, ScanResult>
			{
				{ ScanCompareType.Changed, 0, 0, new byte[] { 0 }, new ByteScanResult(1), true, new ByteScanResult(0) },
				{ ScanCompareType.Changed, 0, 0, new byte[] { 1 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.NotChanged, 0, 0, new byte[] { 1 }, new ByteScanResult(1), true, new ByteScanResult(1) },
				{ ScanCompareType.NotChanged, 0, 0, new byte[] { 0 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, new byte[] { 2 }, new ByteScanResult(1), true, new ByteScanResult(2) },
				{ ScanCompareType.Increased, 0, 0, new byte[] { 1 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, new byte[] { 0 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, new byte[] { 2 }, new ByteScanResult(1), true, new ByteScanResult(2) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, new byte[] { 1 }, new ByteScanResult(1), true, new ByteScanResult(1) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, new byte[] { 0 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, new byte[] { 0 }, new ByteScanResult(1), true, new ByteScanResult(0) },
				{ ScanCompareType.Decreased, 0, 0, new byte[] { 1 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, new byte[] { 2 }, new ByteScanResult(1), false, null },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, new byte[] { 0 }, new ByteScanResult(1), true, new ByteScanResult(0) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, new byte[] { 1 }, new ByteScanResult(1), true, new ByteScanResult(1) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, new byte[] { 2 }, new ByteScanResult(1), false, null }
			};

			var basicData = GetTestCompareBasicData();
			foreach (var x in basicData)
			{
				data.Add((ScanCompareType)x[0], (byte)x[1], (byte)x[2], (byte[])x[3], new ByteScanResult(1), (bool)x[4], (ScanResult)x[5]);
			}

			return data;
		}

		[Theory]
		[MemberData(nameof(GetTestCompareWithPreviousData))]
		public void TestCompareWithPrevious(ScanCompareType compareType, byte value1, byte value2, byte[] data, ScanResult previousScanResult, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new ByteMemoryComparer(compareType, value1, value2);

			Check.That(sut.Compare(data, 0, previousScanResult, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<ByteScanResult>();
			}
		}

		[Fact]
		public void TestCompareWithPreviousThrows()
		{
			var sut = new ByteMemoryComparer(ScanCompareType.Unknown, 0, 0);

			Check.ThatCode(() => sut.Compare(new byte[] { 0 }, 0, new ByteScanResult(0), out _)).Throws<InvalidCompareTypeException>();
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/Comparer/FloatMemoryComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner.Comparer
{
	public class FloatMemoryComparerTest
	{
		private static EndianBitConverter BitConverter { get; } = EndianBitConverter.System;

		[Theory]
		[InlineData(ScanCompareType.Equal, ScanRoundMode.Normal, 0.0f, 0.0f)]
		[InlineData(ScanCompareType.Equal, ScanRoundMode.Strict, 1.0f, 2.0f)]
		[InlineData(ScanCompareType.Equal, ScanRoundMode.Truncate, 2.0f, 1.0f)]
		[InlineData(ScanCompareType.Between, ScanRoundMode.Normal, 2.0f, 4.0f)]
		[InlineData(ScanCompareType.BetweenOrEqual, ScanRoundMode.Strict, 4.0f, 2.0f)]
		[InlineData(ScanCompareType.NotEqual, ScanRoundMode.Truncate, 0.0f, 0.0f)]
		public void TestConstructor(ScanCompareType compareType, ScanRoundMode roundMode, float value1, float value2)
		{
			var sut = new FloatMemoryComparer(compareType, roundMode, 1, value1, value2, BitConverter);

			Check.That(sut.CompareType).IsEqualTo(compareType);
			Check.That(sut.RoundType).IsEqualTo(roundMode);
			Check.That(sut.ValueSize).IsEqualTo(sizeof(float));
			Check.That(sut.Value1).IsOneOf(value1, value2);
			Check.That(sut.Value2).IsOneOf(value1, value2);
		}

		[Theory]
		[InlineData(1)]
		[InlineData(2)]
		[InlineData(3)]
		public void TestConstructorSignificantDigits(int significantDigits)
		{
			const float Value1 = 1.234567f;
			const float Value2 = 7.654321f;

			var sut = new FloatMemoryComparer(ScanCompareType.Equal, ScanRoundMode.Normal, significantDigits, Value1, Value2, BitConverter);

			Check.That(sut.Value1).IsEqualTo((float)Math.Round(Value1, significantDigits, MidpointRounding.AwayFromZero));
			Check.That(sut.Value2).IsEqualTo((float)Math.Round(Value2, significantDigits, MidpointRounding.AwayFromZero));
		}

		public static TheoryData<ScanCompareType, float, float, byte[], bool, ScanResult> GetTestCompareBasicData() => new TheoryData<ScanCompareType, float, float, byte[], bool, ScanResult>
		{
			{ ScanCompareType.GreaterThan, 1.0f, 0.0f, BitConverter.GetBytes(0.0f), false, null },
			{ ScanCompareType.GreaterThan, 1.0f, 0.0f, BitConverter.GetBytes(2.0f), true, new FloatScanResult(2.0f) },
			{ ScanCompareType.GreaterThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(0.0f), false, null },
			{ ScanCompareType.GreaterThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(1.0f), true, new FloatScanResult(1.0f) },
			{ ScanCompareType.GreaterThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(2.0f), true, new FloatScanResult(2.0f) },
			{ ScanCompareType.LessThan, 1.0f, 0.0f, BitConverter.GetBytes(1.0f), false, null },
			{ ScanCompareType.LessThan, 1.0f, 0.0f, BitConverter.GetBytes(0.0f), true, new FloatScanResult(0.0f) },
			{ ScanCompareType.LessThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(2.0f), false, null },
			{ ScanCompareType.LessThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(1.0f), true, new FloatScanResult(1.0f) },
			{ ScanCompareType.LessThanOrEqual, 1.0f, 0.0f, BitConverter.GetBytes(0.0f), true, new FloatScanResult(0.0f) },
			{ ScanCompareType.Between, 1.0f, 2.0f, BitConverter.GetBytes(0.0f), false, null },
			{ ScanCompareType.Between, 1.0f, 2.0f, BitConverter.GetBytes(1.0f), false, null },
			{ ScanCompareType.Between, 1.0f, 2.0f, BitConverter.GetBytes(2.0f), false, null },
			{ ScanCompareType.Between, 1.0f, 2.0f, BitConverter.GetBytes(3.0f), false, null },
			{ ScanCompareType.BetweenOrEqual, 1.0f, 2.0f, BitConverter.GetBytes(0.0f), false, null },
			{ ScanCompareType.BetweenOrEqual, 1.0f, 2.0f, BitConverter.GetBytes(1.0f), true, new FloatScanResult(1.0f) },
			{ ScanCompareType.BetweenOrEqual, 1.0f, 2.0f, BitConverter.GetBytes(2.0f), true, new FloatScanResult(2.0f) },
			{ ScanCompareType.BetweenOrEqual, 1.0f, 2.0f, BitConverter.GetBytes(3.0f), false, null }
		};

		public static TheoryData<ScanCompareType, float, float, byte[], bool, ScanResult> GetTestCompareScanCompareTypeUnknownData() => new TheoryData<ScanCompareType, float, float, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Unknown, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), true, new FloatScanResult(0.0f) },
			{ ScanCompareType.Unknown, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), true, new FloatScanResult(1.0f) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareBasicData))]
		[MemberData(nameof(GetTestCompareScanCompareTypeUnknownData))]
		public void TestCompare(ScanCompareType compareType, float value1, float value2, byte[] data, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new FloatMemoryComparer(compareType, ScanRoundMode.Normal, 1, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<FloatScanResult>();
			}
		}

		[Theory]
		[InlineData(ScanCompareType.Changed)]
		[InlineData(ScanCompareType.NotChanged)]
		[InlineData(ScanCompareType.Decreased)]
		[InlineData(ScanCompareType.DecreasedOrEqual)]
		[InlineData(ScanCompareType.Increased)]
		[InlineData(ScanCompareType.IncreasedOrEqual)]
		public void TestCompareInvalidCompareTypeThrows(ScanCompareType compareType)
		{
			var sut = new FloatMemoryComparer(compareType, ScanRoundMode.Normal, 1, 0.0f, 0.0f, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0.0f), 0, out _)).Throws<InvalidCompareTypeException>();
		}

		public static TheoryData<byte[], int, Type> GetTestCompareThrowsData() => new TheoryData<byte[], int, Type>
		{
			{ null, 0, typeof(ArgumentNullException) },
			{ new byte[0], 0, typeof(ArgumentOutOfRangeException) },
			{ new byte[1], 1, typeof(ArgumentOutOfRangeException) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareThrowsData))]
		public void TestCompareInvalidDataThrows(byte[] data, int index, Type expectedExceptionType)
		{
			var sut = new FloatMemoryComparer(ScanCompareType.Unknown, ScanRoundMode.Normal, 1, 0.0f, 0.0f, BitConverter);

			Check.ThatCode(() => sut.Compare(data, index, out _)).ThrowsType(expectedExceptionType);
		}

		public static TheoryData<ScanCompareType, float, float, byte[], ScanResult, bool, ScanResult> GetTestCompareWithPreviousData()
		{
			var data = new TheoryData<ScanCompareType, float, float, byte[], ScanResult, bool, ScanResult>
			{
				{ ScanCompareType.Changed, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), true, new FloatScanResult(0.0f) },
				{ ScanCompareType.Changed, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.NotChanged, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), true, new FloatScanResult(1.0f) },
				{ ScanCompareType.NotChanged, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.Increased, 0.0f, 0.0f, BitConverter.GetBytes(2.0f), new FloatScanResult(1.0f), true, new FloatScanResult(2.0f) },
				{ ScanCompareType.Increased, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.Increased, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.IncreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(2.0f), new FloatScanResult(1.0f), true, new FloatScanResult(2.0f) },
				{ ScanCompareType.IncreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), true, new FloatScanResult(1.0f) },
				{ ScanCompareType.IncreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.Decreased, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), true, new FloatScanResult(0.0f) },
				{ ScanCompareType.Decreased, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.Decreased, 0.0f, 0.0f, BitConverter.GetBytes(2.0f), new FloatScanResult(1.0f), false, null },
				{ ScanCompareType.DecreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(0.0f), new FloatScanResult(1.0f), true, new FloatScanResult(0.0f) },
				{ ScanCompareType.DecreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(1.0f), new FloatScanResult(1.0f), true, new FloatScanResult(1.0f) },
				{ ScanCompareType.DecreasedOrEqual, 0.0f, 0.0f, BitConverter.GetBytes(2.0f), new FloatScanResult(1.0f), false, null }
			};

			var basicData = GetTestCompareBasicData();
			foreach (var x in basicData)
			{
				data.Add((ScanCompareType)x[0], (float)x[1], (float)x[2], (byte[])x[3], new FloatScanResult(1.0f), (bool)x[4], (ScanResult)x[5]);
			}

			return data;
		}

		[Theory]
		[MemberData(nameof(GetTestCompareWithPreviousData))]
		public void TestCompareWithPrevious(ScanCompareType compareType, float value1, float value2, byte[] data, ScanResult previousScanResult, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new FloatMemoryComparer(compareType, ScanRoundMode.Normal, 1, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, previousScanResult, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<FloatScanResult>();
			}
		}

		[Fact]
		public void TestCompareWithPreviousThrows()
		{
			var sut = new FloatMemoryComparer(ScanCompareType.Unknown, ScanRoundMode.Normal, 1, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0.0f), 0, new FloatScanResult(0.0f), out _)).Throws<InvalidCompareTypeException>();
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/Comparer/IntegerMemoryComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner.Comparer
{
	public class IntegerMemoryComparerTest
	{
		private static EndianBitConverter BitConverter { get; } = EndianBitConverter.System;

		[Theory]
		[InlineData(ScanCompareType.Equal, 0, 0)]
		[InlineData(ScanCompareType.Equal, 1, 2)]
		[InlineData(ScanCompareType.Equal, 2, 1)]
		[InlineData(ScanCompareType.Between, 2, 4)]
		[InlineData(ScanCompareType.BetweenOrEqual, 4, 2)]
		[InlineData(ScanCompareType.NotEqual, 0, 0)]
		public void TestConstructor(ScanCompareType compareType, int value1, int value2)
		{
			var sut = new IntegerMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.CompareType).IsEqualTo(compareType);
			Check.That(sut.ValueSize).IsEqualTo(sizeof(int));
			Check.That(sut.Value1).IsOneOf(value1, value2);
			Check.That(sut.Value2).IsOneOf(value1, value2);
		}

		public static TheoryData<ScanCompareType, int, int, byte[], bool, ScanResult> GetTestCompareBasicData() => new TheoryData<ScanCompareType, int, int, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Equal, 0, 0, BitConverter.GetBytes(0), true, new IntegerScanResult(0) },
			{ ScanCompareType.Equal, 0, 0, BitConverter.GetBytes(1), false, null },
			{ ScanCompareType.Equal, 1, 0, BitConverter.GetBytes(1), true, new IntegerScanResult(1) },
			{ ScanCompareType.Equal, 1, 0, BitConverter.GetBytes(0), false, null },
			{ ScanCompareType.NotEqual, 1, 0, BitConverter.GetBytes(0), true, new IntegerScanResult(0) },
			{ ScanCompareType.NotEqual, 1, 0, BitConverter.GetBytes(1), false, null },
			{ ScanCompareType.GreaterThan, 1, 0, BitConverter.GetBytes(0), false, null },
			{ ScanCompareType.GreaterThan, 1, 0, BitConverter.GetBytes(2), true, new IntegerScanResult(2) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes(0), false, null },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes(1), true, new IntegerScanResult(1) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes(2), true, new IntegerScanResult(2) },
			{ ScanCompareType.LessThan, 1, 0, BitConverter.GetBytes(1), false, null },
			{ ScanCompareType.LessThan, 1, 0, BitConverter.GetBytes(0), true, new IntegerScanResult(0) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes(2), false, null },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes(1), true, new IntegerScanResult(1) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes(0), true, new IntegerScanResult(0) },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes(0), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes(1), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes(2), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes(3), false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes(0), false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes(1), true, new IntegerScanResult(1) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes(2), true, new IntegerScanResult(2) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes(3), false, null }
		};

		public static TheoryData<ScanCompareType, int, int, byte[], bool, ScanResult> GetTestCompareScanCompareTypeUnknownData() => new TheoryData<ScanCompareType, int, int, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Unknown, 0, 0, BitConverter.GetBytes(0), true, new IntegerScanResult(0) },
			{ ScanCompareType.Unknown, 0, 0, BitConverter.GetBytes(1), true, new IntegerScanResult(1) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareBasicData))]
		[MemberData(nameof(GetTestCompareScanCompareTypeUnknownData))]
		public void TestCompare(ScanCompareType compareType, int value1, int value2, byte[] data, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new IntegerMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<IntegerScanResult>();
			}
		}

		[Theory]
		[InlineData(ScanCompareType.Changed)]
		[InlineData(ScanCompareType.NotChanged)]
		[InlineData(ScanCompareType.Decreased)]
		[InlineData(ScanCompareType.DecreasedOrEqual)]
		[InlineData(ScanCompareType.Increased)]
		[InlineData(ScanCompareType.IncreasedOrEqual)]
		public void TestCompareInvalidCompareTypeThrows(ScanCompareType compareType)
		{
			var sut = new IntegerMemoryComparer(compareType, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0), 0, out _)).Throws<InvalidCompareTypeException>();
		}

		public static TheoryData<byte[], int, Type> GetTestCompareThrowsData() => new TheoryData<byte[], int, Type>
		{
			{ null, 0, typeof(ArgumentNullException) },
			{ new byte[0], 0, typeof(ArgumentOutOfRangeException) },
			{ new byte[4], 4, typeof(ArgumentOutOfRangeException) },
			{ new byte[3], 0, typeof(ArgumentException) },
			{ new byte[4], 1, typeof(ArgumentException) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareThrowsData))]
		public void TestCompareInvalidDataThrows(byte[] data, int index, Type expectedExceptionType)
		{
			var sut = new IntegerMemoryComparer(ScanCompareType.Equal, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(data, index, out _)).ThrowsType(expectedExceptionType);
		}

		public static TheoryData<ScanCompareType, int, int, byte[], ScanResult, bool, ScanResult> GetTestCompareWithPreviousData()
		{
			var data = new TheoryData<ScanCompareType, int, int, byte[], ScanResult, bool, ScanResult>
			{
				{ ScanCompareType.Changed, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), true, new IntegerScanResult(0) },
				{ ScanCompareType.Changed, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), false, null },
				{ ScanCompareType.NotChanged, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), true, new IntegerScanResult(1) },
				{ ScanCompareType.NotChanged, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes(2), new IntegerScanResult(1), true, new IntegerScanResult(2) },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), false, null },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes(2), new IntegerScanResult(1), true, new IntegerScanResult(2) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), true, new IntegerScanResult(1) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), true, new IntegerScanResult(0) },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes(2), new IntegerScanResult(1), false, null },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes(0), new IntegerScanResult(1), true, new IntegerScanResult(0) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes(1), new IntegerScanResult(1), true, new IntegerScanResult(1) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes(2), new IntegerScanResult(1), false, null }
			};

			var basicData = GetTestCompareBasicData();
			foreach (var x in basicData)
			{
				data.Add((ScanCompareType)x[0], (int)x[1], (int)x[2], (byte[])x[3], new IntegerScanResult(1), (bool)x[4], (ScanResult)x[5]);
			}

			return data;
		}

		[Theory]
		[MemberData(nameof(GetTestCompareWithPreviousData))]
		public void TestCompareWithPrevious(ScanCompareType compareType, int value1, int value2, byte[] data, ScanResult previousScanResult, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new IntegerMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, previousScanResult, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<IntegerScanResult>();
			}
		}

		[Fact]
		public void TestCompareWithPreviousThrows()
		{
			var sut = new IntegerMemoryComparer(ScanCompareType.Unknown, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0), 0, new IntegerScanResult(0), out _)).Throws<InvalidCompareTypeException>();
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/Comparer/LongMemoryComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner.Comparer
{
	public class LongMemoryComparerTest
	{
		private static EndianBitConverter BitConverter { get; } = EndianBitConverter.System;

		[Theory]
		[InlineData(ScanCompareType.Equal, 0L, 0L)]
		[InlineData(ScanCompareType.Equal, 1L, 2L)]
		[InlineData(ScanCompareType.Equal, 2L, 1L)]
		[InlineData(ScanCompareType.Between, 2L, 4L)]
		[InlineData(ScanCompareType.BetweenOrEqual, 4L, 2L)]
		[InlineData(ScanCompareType.NotEqual, 0L, 0L)]
		public void TestConstructor(ScanCompareType compareType, long value1, long value2)
		{
			var sut = new LongMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.CompareType).IsEqualTo(compareType);
			Check.That(sut.ValueSize).IsEqualTo(sizeof(long));
			Check.That(sut.Value1).IsOneOf(value1, value2);
			Check.That(sut.Value2).IsOneOf(value1, value2);
		}

		public static TheoryData<ScanCompareType, long, long, byte[], bool, ScanResult> GetTestCompareBasicData() => new TheoryData<ScanCompareType, long, long, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Equal, 0L, 0L, BitConverter.GetBytes(0L), true, new LongScanResult(0L) },
			{ ScanCompareType.Equal, 0L, 0L, BitConverter.GetBytes(1L), false, null },
			{ ScanCompareType.Equal, 1L, 0L, BitConverter.GetBytes(1L), true, new LongScanResult(1L) },
			{ ScanCompareType.Equal, 1L, 0L, BitConverter.GetBytes(0L), false, null },
			{ ScanCompareType.NotEqual, 1L, 0L, BitConverter.GetBytes(0L), true, new LongScanResult(0L) },
			{ ScanCompareType.NotEqual, 1L, 0L, BitConverter.GetBytes(1L), false, null },
			{ ScanCompareType.GreaterThan, 1L, 0L, BitConverter.GetBytes(0L), false, null },
			{ ScanCompareType.GreaterThan, 1L, 0L, BitConverter.GetBytes(2L), true, new LongScanResult(2L) },
			{ ScanCompareType.GreaterThanOrEqual, 1L, 0L, BitConverter.GetBytes(0L), false, null },
			{ ScanCompareType.GreaterThanOrEqual, 1L, 0L, BitConverter.GetBytes(1L), true, new LongScanResult(1L) },
			{ ScanCompareType.GreaterThanOrEqual, 1L, 0L, BitConverter.GetBytes(2L), true, new LongScanResult(2L) },
			{ ScanCompareType.LessThan, 1L, 0L, BitConverter.GetBytes(1L), false, null },
			{ ScanCompareType.LessThan, 1L, 0L, BitConverter.GetBytes(0L), true, new LongScanResult(0L) },
			{ ScanCompareType.LessThanOrEqual, 1L, 0L, BitConverter.GetBytes(2L), false, null },
			{ ScanCompareType.LessThanOrEqual, 1L, 0L, BitConverter.GetBytes(1L), true, new LongScanResult(1L) },
			{ ScanCompareType.LessThanOrEqual, 1L, 0L, BitConverter.GetBytes(0L), true, new LongScanResult(0L) },
			{ ScanCompareType.Between, 1L, 2L, BitConverter.GetBytes(0L), false, null },
			{ ScanCompareType.Between, 1L, 2L, BitConverter.GetBytes(1L), false, null },
			{ ScanCompareType.Between, 1L, 2L, BitConverter.GetBytes(2L), false, null },
			{ ScanCompareType.Between, 1L, 2L, BitConverter.GetBytes(3L), false, null },
			{ ScanCompareType.BetweenOrEqual, 1L, 2L, BitConverter.GetBytes(0L), false, null },
			{ ScanCompareType.BetweenOrEqual, 1L, 2L, BitConverter.GetBytes(1L), true, new LongScanResult(1L) },
			{ ScanCompareType.BetweenOrEqual, 1L, 2L, BitConverter.GetBytes(2L), true, new LongScanResult(2L) },
			{ ScanCompareType.BetweenOrEqual, 1L, 2L, BitConverter.GetBytes(3L), false, null }
		};

		public static TheoryData<ScanCompareType, long, long, byte[], bool, ScanResult> GetTestCompareScanCompareTypeUnknownData() => new TheoryData<ScanCompareType, long, long, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Unknown, 0L, 0L, BitConverter.GetBytes(0L), true, new LongScanResult(0L) },
			{ ScanCompareType.Unknown, 0L, 0L, BitConverter.GetBytes(1L), true, new LongScanResult(1L) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareBasicData))]
		[MemberData(nameof(GetTestCompareScanCompareTypeUnknownData))]
		public void TestCompare(ScanCompareType compareType, long value1, long value2, byte[] data, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new LongMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<LongScanResult>();
			}
		}

		[Theory]
		[InlineData(ScanCompareType.Changed)]
		[InlineData(ScanCompareType.NotChanged)]
		[InlineData(ScanCompareType.Decreased)]
		[InlineData(ScanCompareType.DecreasedOrEqual)]
		[InlineData(ScanCompareType.Increased)]
		[InlineData(ScanCompareType.IncreasedOrEqual)]
		public void TestCompareInvalidCompareTypeThrows(ScanCompareType compareType)
		{
			var sut = new LongMemoryComparer(compareType, 0L, 0L, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0L), 0, out _)).Throws<InvalidCompareTypeException>();
		}

		public static TheoryData<byte[], int, Type> GetTestCompareThrowsData() => new TheoryData<byte[], int, Type>
		{
			{ null, 0, typeof(ArgumentNullException) },
			{ new byte[0], 0, typeof(ArgumentOutOfRangeException) },
			{ new byte[8], 8, typeof(ArgumentOutOfRangeException) },
			{ new byte[7], 0, typeof(ArgumentException) },
			{ new byte[8], 1, typeof(ArgumentException) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareThrowsData))]
		public void TestCompareInvalidDataThrows(byte[] data, int index, Type expectedExceptionType)
		{
			var sut = new LongMemoryComparer(ScanCompareType.Equal, 0L, 0L, BitConverter);

			Check.ThatCode(() => sut.Compare(data, index, out _)).ThrowsType(expectedExceptionType);
		}

		public static TheoryData<ScanCompareType, long, long, byte[], ScanResult, bool, ScanResult> GetTestCompareWithPreviousData()
		{
			var data = new TheoryData<ScanCompareType, long, long, byte[], ScanResult, bool, ScanResult>
			{
				{ ScanCompareType.Changed, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), true, new LongScanResult(0) },
				{ ScanCompareType.Changed, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), false, null },
				{ ScanCompareType.NotChanged, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), true, new LongScanResult(1) },
				{ ScanCompareType.NotChanged, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), false, null },
				{ ScanCompareType.Increased, 0L, 0L, BitConverter.GetBytes(2L), new LongScanResult(1L), true, new LongScanResult(2) },
				{ ScanCompareType.Increased, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), false, null },
				{ ScanCompareType.Increased, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), false, null },
				{ ScanCompareType.IncreasedOrEqual, 0L, 0L, BitConverter.GetBytes(2L), new LongScanResult(1L), true, new LongScanResult(2) },
				{ ScanCompareType.IncreasedOrEqual, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), true, new LongScanResult(1) },
				{ ScanCompareType.IncreasedOrEqual, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), false, null },
				{ ScanCompareType.Decreased, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), true, new LongScanResult(0) },
				{ ScanCompareType.Decreased, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), false, null },
				{ ScanCompareType.Decreased, 0L, 0L, BitConverter.GetBytes(2L), new LongScanResult(1L), false, null },
				{ ScanCompareType.DecreasedOrEqual, 0L, 0L, BitConverter.GetBytes(0L), new LongScanResult(1L), true, new LongScanResult(0) },
				{ ScanCompareType.DecreasedOrEqual, 0L, 0L, BitConverter.GetBytes(1L), new LongScanResult(1L), true, new LongScanResult(1) },
				{ ScanCompareType.DecreasedOrEqual, 0L, 0L, BitConverter.GetBytes(2L), new LongScanResult(1L), false, null }
			};

			var basicData = GetTestCompareBasicData();
			foreach (var x in basicData)
			{
				data.Add((ScanCompareType)x[0], (long)x[1], (long)x[2], (byte[])x[3], new LongScanResult(1L), (bool)x[4], (ScanResult)x[5]);
			}

			return data;
		}

		[Theory]
		[MemberData(nameof(GetTestCompareWithPreviousData))]
		public void TestCompareWithPrevious(ScanCompareType compareType, long value1, long value2, byte[] data, ScanResult previousScanResult, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new LongMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, previousScanResult, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<LongScanResult>();
			}
		}

		[Fact]
		public void TestCompareWithPreviousThrows()
		{
			var sut = new LongMemoryComparer(ScanCompareType.Unknown, 0L, 0L, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes(0L), 0, new LongScanResult(0L), out _)).Throws<InvalidCompareTypeException>();
		}
	}
}

```

`ReClass.NET_Tests/MemoryScanner/Comparer/ShortMemoryComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.MemoryScanner;
using ReClassNET.MemoryScanner.Comparer;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.MemoryScanner.Comparer
{
	public class ShortMemoryComparerTest
	{
		private static EndianBitConverter BitConverter { get; } = EndianBitConverter.System;

		[Theory]
		[InlineData(ScanCompareType.Equal, 0, 0)]
		[InlineData(ScanCompareType.Equal, 1, 2)]
		[InlineData(ScanCompareType.Equal, 2, 1)]
		[InlineData(ScanCompareType.Between, 2, 4)]
		[InlineData(ScanCompareType.BetweenOrEqual, 4, 2)]
		[InlineData(ScanCompareType.NotEqual, 0, 0)]
		public void TestConstructor(ScanCompareType compareType, short value1, short value2)
		{
			var sut = new ShortMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.CompareType).IsEqualTo(compareType);
			Check.That(sut.ValueSize).IsEqualTo(sizeof(short));
			Check.That(sut.Value1).IsOneOf(value1, value2);
			Check.That(sut.Value2).IsOneOf(value1, value2);
		}

		public static TheoryData<ScanCompareType, short, short, byte[], bool, ScanResult> GetTestCompareBasicData() => new TheoryData<ScanCompareType, short, short, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Equal, 0, 0, BitConverter.GetBytes((short)0), true, new ShortScanResult(0) },
			{ ScanCompareType.Equal, 0, 0, BitConverter.GetBytes((short)1), false, null },
			{ ScanCompareType.Equal, 1, 0, BitConverter.GetBytes((short)1), true, new ShortScanResult(1) },
			{ ScanCompareType.Equal, 1, 0, BitConverter.GetBytes((short)0), false, null },
			{ ScanCompareType.NotEqual, 1, 0, BitConverter.GetBytes((short)0), true, new ShortScanResult(0) },
			{ ScanCompareType.NotEqual, 1, 0, BitConverter.GetBytes((short)1), false, null },
			{ ScanCompareType.GreaterThan, 1, 0, BitConverter.GetBytes((short)0), false, null },
			{ ScanCompareType.GreaterThan, 1, 0, BitConverter.GetBytes((short)2), true, new ShortScanResult(2) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes((short)0), false, null },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes((short)1), true, new ShortScanResult(1) },
			{ ScanCompareType.GreaterThanOrEqual, 1, 0, BitConverter.GetBytes((short)2), true, new ShortScanResult(2) },
			{ ScanCompareType.LessThan, 1, 0, BitConverter.GetBytes((short)1), false, null },
			{ ScanCompareType.LessThan, 1, 0, BitConverter.GetBytes((short)0), true, new ShortScanResult(0) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes((short)2), false, null },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes((short)1), true, new ShortScanResult(1) },
			{ ScanCompareType.LessThanOrEqual, 1, 0, BitConverter.GetBytes((short)0), true, new ShortScanResult(0) },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes((short)0), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes((short)1), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes((short)2), false, null },
			{ ScanCompareType.Between, 1, 2, BitConverter.GetBytes((short)3), false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes((short)0), false, null },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes((short)1), true, new ShortScanResult(1) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes((short)2), true, new ShortScanResult(2) },
			{ ScanCompareType.BetweenOrEqual, 1, 2, BitConverter.GetBytes((short)3), false, null }
		};

		public static TheoryData<ScanCompareType, short, short, byte[], bool, ScanResult> GetTestCompareScanCompareTypeUnknownData() => new TheoryData<ScanCompareType, short, short, byte[], bool, ScanResult>
		{
			{ ScanCompareType.Unknown, 0, 0, BitConverter.GetBytes((short)0), true, new ShortScanResult(0) },
			{ ScanCompareType.Unknown, 0, 0, BitConverter.GetBytes((short)1), true, new ShortScanResult(1) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareBasicData))]
		[MemberData(nameof(GetTestCompareScanCompareTypeUnknownData))]
		public void TestCompare(ScanCompareType compareType, short value1, short value2, byte[] data, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new ShortMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<ShortScanResult>();
			}
		}

		[Theory]
		[InlineData(ScanCompareType.Changed)]
		[InlineData(ScanCompareType.NotChanged)]
		[InlineData(ScanCompareType.Decreased)]
		[InlineData(ScanCompareType.DecreasedOrEqual)]
		[InlineData(ScanCompareType.Increased)]
		[InlineData(ScanCompareType.IncreasedOrEqual)]
		public void TestCompareInvalidCompareTypeThrows(ScanCompareType compareType)
		{
			var sut = new ShortMemoryComparer(compareType, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes((short)0), 0, out _)).Throws<InvalidCompareTypeException>();
		}

		public static TheoryData<byte[], int, Type> GetTestCompareThrowsData() => new TheoryData<byte[], int, Type>
		{
			{ null, 0, typeof(ArgumentNullException) },
			{ new byte[0], 0, typeof(ArgumentOutOfRangeException) },
			{ new byte[2], 2, typeof(ArgumentOutOfRangeException) },
			{ new byte[1], 0, typeof(ArgumentException) },
			{ new byte[2], 1, typeof(ArgumentException) }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareThrowsData))]
		public void TestCompareInvalidDataThrows(byte[] data, int index, Type expectedExceptionType)
		{
			var sut = new ShortMemoryComparer(ScanCompareType.Equal, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(data, index, out _)).ThrowsType(expectedExceptionType);
		}

		public static TheoryData<ScanCompareType, short, short, byte[], ScanResult, bool, ScanResult> GetTestCompareWithPreviousData()
		{
			var data = new TheoryData<ScanCompareType, short, short, byte[], ScanResult, bool, ScanResult>
			{
				{ ScanCompareType.Changed, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), true, new ShortScanResult(0) },
				{ ScanCompareType.Changed, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), false, null },
				{ ScanCompareType.NotChanged, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), true, new ShortScanResult(1) },
				{ ScanCompareType.NotChanged, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes((short)2), new ShortScanResult(1), true, new ShortScanResult(2) },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), false, null },
				{ ScanCompareType.Increased, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), false, null },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes((short)2), new ShortScanResult(1), true, new ShortScanResult(2) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), true, new ShortScanResult(1) },
				{ ScanCompareType.IncreasedOrEqual, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), true, new ShortScanResult(0) },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), false, null },
				{ ScanCompareType.Decreased, 0, 0, BitConverter.GetBytes((short)2), new ShortScanResult(1), false, null },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes((short)0), new ShortScanResult(1), true, new ShortScanResult(0) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes((short)1), new ShortScanResult(1), true, new ShortScanResult(1) },
				{ ScanCompareType.DecreasedOrEqual, 0, 0, BitConverter.GetBytes((short)2), new ShortScanResult(1), false, null }
			};

			var basicData = GetTestCompareBasicData();
			foreach (var x in basicData)
			{
				data.Add((ScanCompareType)x[0], (short)x[1], (short)x[2], (byte[])x[3], new ShortScanResult(1), (bool)x[4], (ScanResult)x[5]);
			}

			return data;
		}

		[Theory]
		[MemberData(nameof(GetTestCompareWithPreviousData))]
		public void TestCompareWithPrevious(ScanCompareType compareType, short value1, short value2, byte[] data, ScanResult previousScanResult, bool expectedResult, ScanResult expectedScanResult)
		{
			var sut = new ShortMemoryComparer(compareType, value1, value2, BitConverter);

			Check.That(sut.Compare(data, 0, previousScanResult, out var scanResult)).IsEqualTo(expectedResult);
			Check.That(scanResult).IsEqualTo(expectedScanResult);
			if (scanResult != null)
			{
				Check.That(scanResult).IsInstanceOf<ShortScanResult>();
			}
		}

		[Fact]
		public void TestCompareWithPreviousThrows()
		{
			var sut = new ShortMemoryComparer(ScanCompareType.Unknown, 0, 0, BitConverter);

			Check.ThatCode(() => sut.Compare(BitConverter.GetBytes((short)0), 0, new ShortScanResult(0), out _)).Throws<InvalidCompareTypeException>();
		}
	}
}

```

`ReClass.NET_Tests/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("ReClass.NET_Tests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ReClass.NET_Tests")]
[assembly: AssemblyCopyright("Copyright ©  2019")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("e2d0424d-738f-41c3-9935-1b282624600f")]

// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ReClass.NET_Tests/ReClass.NET_Tests.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProjectGuid>{E2D0424D-738F-41C3-9935-1B282624600F}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ReClass.NET_Tests</RootNamespace>
    <AssemblyName>ReClass.NET_Tests</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <TestProjectType>UnitTest</TestProjectType>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <PlatformTarget>x86</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <PlatformTarget>x86</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;RECLASSNET64</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x64' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE;RECLASSNET64</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Xml.Linq" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AddressParser\DynamicCompilerTest.cs" />
    <Compile Include="AddressParser\ExecutorTest.cs" />
    <Compile Include="AddressParser\InterpreterTest.cs" />
    <Compile Include="AddressParser\ParserTest.cs" />
    <Compile Include="AddressParser\TokenizerTest.cs" />
    <Compile Include="Extensions\ByteExtensionTest.cs" />
    <Compile Include="Extensions\ColorExtensionTest.cs" />
    <Compile Include="Extensions\DictionaryExtensionTest.cs" />
    <Compile Include="Extensions\EncodingExtensionTest.cs" />
    <Compile Include="Extensions\FloatingPointExtensionTest.cs" />
    <Compile Include="Extensions\EnumerableExtensionTests.cs" />
    <Compile Include="Extensions\IntPtrExtensionTest.cs" />
    <Compile Include="Extensions\ListExtensionTest.cs" />
    <Compile Include="Extensions\PointExtensionTest.cs" />
    <Compile Include="Extensions\StringBuilderExtensionTest.cs" />
    <Compile Include="Extensions\StringExtensionTest.cs" />
    <Compile Include="Extensions\StringReaderExtensionTest.cs" />
    <Compile Include="MemoryScanner\BytePatternTest.cs" />
    <Compile Include="MemoryScanner\Comparer\ByteMemoryComparerTest.cs" />
    <Compile Include="MemoryScanner\Comparer\FloatMemoryComparerTest.cs" />
    <Compile Include="MemoryScanner\Comparer\ShortMemoryComparerTest.cs" />
    <Compile Include="MemoryScanner\Comparer\LongMemoryComparerTest.cs" />
    <Compile Include="MemoryScanner\Comparer\IntegerMemoryComparerTest.cs" />
    <Compile Include="Memory\MemoryBufferTest.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="UI\DpiUtilTest.cs" />
    <Compile Include="Util\BitStringTest.cs" />
    <Compile Include="Util\CircularBufferTest.cs" />
    <Compile Include="Util\CommandLineArgsTest.cs" />
    <Compile Include="Util\Conversion\BigEndianBitConverterTest.cs" />
    <Compile Include="Util\Conversion\EndianBitConverterTest.cs" />
    <Compile Include="Util\Conversion\LittleEndianBitConverterTest.cs" />
    <Compile Include="Util\CustomDataMapTest.cs" />
    <Compile Include="Util\DirectedGraphTest.cs" />
    <Compile Include="Util\GrowingListTest.cs" />
    <Compile Include="Util\HexadecimalFormatterTest.cs" />
    <Compile Include="Util\IntPtrComparerTest.cs" />
    <Compile Include="Util\NumberFormatTest.cs" />
    <Compile Include="Util\PathUtilTest.cs" />
    <Compile Include="Util\XElementSerializerTest.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\ReClass.NET\ReClass.NET.csproj">
      <Project>{bfb8917d-e9b4-463f-a6e8-612c35728c78}</Project>
      <Name>ReClass.NET</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Moq">
      <Version>4.10.1</Version>
    </PackageReference>
    <PackageReference Include="NFluent">
      <Version>2.5.0</Version>
    </PackageReference>
    <PackageReference Include="xunit">
      <Version>2.4.1</Version>
    </PackageReference>
    <PackageReference Include="xunit.runner.visualstudio">
      <Version>2.4.1</Version>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`ReClass.NET_Tests/UI/DpiUtilTest.cs`:

```cs
using System.Drawing;
using NFluent;
using ReClassNET.UI;
using Xunit;

namespace ReClass.NET_Tests.UI
{
	public class DpiUtilTest
	{
		[Fact]
		public void ScaleImageReturnsNullOnNull()
		{
			Check.That(DpiUtil.ScaleImage(null)).IsNull();
		}

		[Fact]
		public void ScaleImageReturnsOriginalInstanceOnSameSize()
		{
			DpiUtil.SetDpi(DpiUtil.DefalutDpi, DpiUtil.DefalutDpi);

			using var sourceImage = new Bitmap(10, 10);
			var scaledImage = DpiUtil.ScaleImage(sourceImage);

			Check.That(sourceImage).IsSameReferenceAs(scaledImage);
		}

		[Fact]
		public void ScaleImageReturnsScaledImage()
		{
			const int SourceSize = 10;
			const int ScaleFactor = 2;

			DpiUtil.SetDpi(DpiUtil.DefalutDpi * ScaleFactor, DpiUtil.DefalutDpi * ScaleFactor);

			using var sourceImage = new Bitmap(SourceSize, SourceSize);
			using var scaledImage = DpiUtil.ScaleImage(sourceImage);

			Check.That(sourceImage).Not.IsSameReferenceAs(scaledImage);
			Check.That(scaledImage.Width).IsEqualTo(sourceImage.Width * ScaleFactor);
			Check.That(scaledImage.Height).IsEqualTo(sourceImage.Height * ScaleFactor);
		}
	}
}

```

`ReClass.NET_Tests/Util/BitStringTest.cs`:

```cs
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class BitStringTest
	{
		[Theory]
		[InlineData(0, "0000 0000")]
		[InlineData(1, "0000 0001")]
		[InlineData(127, "0111 1111")]
		[InlineData(128, "1000 0000")]
		[InlineData(255, "1111 1111")]
		[InlineData(0b1010_1010, "1010 1010")]
		public void TestToStringByte(byte value, string expected)
		{
			Check.That(BitString.ToString(value)).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0, "0000 0000 0000 0000")]
		[InlineData(1, "0000 0000 0000 0001")]
		[InlineData(127, "0000 0000 0111 1111")]
		[InlineData(128, "0000 0000 1000 0000")]
		[InlineData(255, "0000 0000 1111 1111")]
		[InlineData(short.MaxValue, "0111 1111 1111 1111")]
		[InlineData(short.MinValue, "1000 0000 0000 0000")]
		[InlineData(unchecked((short)0b1010_1010_1010_1010), "1010 1010 1010 1010")]
		public void TestToStringShort(short value, string expected)
		{
			Check.That(BitString.ToString(value)).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0, "0000 0000 0000 0000 0000 0000 0000 0000")]
		[InlineData(1, "0000 0000 0000 0000 0000 0000 0000 0001")]
		[InlineData(127, "0000 0000 0000 0000 0000 0000 0111 1111")]
		[InlineData(128, "0000 0000 0000 0000 0000 0000 1000 0000")]
		[InlineData(255, "0000 0000 0000 0000 0000 0000 1111 1111")]
		[InlineData(short.MaxValue, "0000 0000 0000 0000 0111 1111 1111 1111")]
		[InlineData(short.MinValue, "1111 1111 1111 1111 1000 0000 0000 0000")]
		[InlineData(int.MaxValue, "0111 1111 1111 1111 1111 1111 1111 1111")]
		[InlineData(int.MinValue, "1000 0000 0000 0000 0000 0000 0000 0000")]
		[InlineData(unchecked((int)0b1010_1010_1010_1010_1010_1010_1010_1010), "1010 1010 1010 1010 1010 1010 1010 1010")]
		public void TestToStringInt(int value, string expected)
		{
			Check.That(BitString.ToString(value)).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000")]
		[InlineData(1, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001")]
		[InlineData(127, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 1111")]
		[InlineData(128, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1000 0000")]
		[InlineData(255, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1111 1111")]
		[InlineData(short.MaxValue, "0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 1111 1111 1111")]
		[InlineData(short.MinValue, "1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000 0000 0000 0000")]
		[InlineData(int.MaxValue, "0000 0000 0000 0000 0000 0000 0000 0000 0111 1111 1111 1111 1111 1111 1111 1111")]
		[InlineData(int.MinValue, "1111 1111 1111 1111 1111 1111 1111 1111 1000 0000 0000 0000 0000 0000 0000 0000")]
		[InlineData(long.MaxValue, "0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111")]
		[InlineData(long.MinValue, "1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000")]
		[InlineData(unchecked((long)0b1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010_1010), "1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010")]
		public void TestToStringLong(long value, string expected)
		{
			Check.That(BitString.ToString(value)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Util/CircularBufferTest.cs`:

```cs
using System;
using System.Linq;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class CircularBufferTest
	{
		[Fact]
		public void CheckInitialCapacityCount()
		{
			const int Capacity = 5;

			var cb = new CircularBuffer<int>(Capacity);

			Check.That(cb.Capacity).IsEqualTo(Capacity);
			Check.That(cb.Count).IsEqualTo(0);
		}

		[Fact]
		public void DequeueFromEmptyBufferThrows()
		{
			var cb = new CircularBuffer<int>(1);

			Check.ThatCode(() => cb.Dequeue()).Throws<InvalidOperationException>();
		}

		[Theory]
		[InlineData(1)]
		[InlineData(2)]
		[InlineData(10)]
		[InlineData(100)]
		public void CheckEnqueueAndDeque(int value)
		{
			var cb = new CircularBuffer<int>(1);

			var overwrittenValue = cb.Enqueue(value);

			Check.That(overwrittenValue).IsEqualTo(default);

			Check.That(cb.Dequeue()).IsEqualTo(value);
		}

		[Theory]
		[InlineData(1)]
		[InlineData(1, 2)]
		[InlineData(1, 2, 3)]
		[InlineData(1, 2, 3, 4)]
		[InlineData(1, 2, 3, 4, 5)]
		public void CheckMultipleEnqueueAndDeque(params int[] values)
		{
			var cb = new CircularBuffer<int>(values.Length);

			foreach (var value in values)
			{
				cb.Enqueue(value);
			}

			foreach (var value in values.Reverse())
			{
				Check.That(cb.Dequeue()).IsEqualTo(value);
			}
		}

		[Theory]
		[InlineData(1, 2)]
		[InlineData(1, 2, 3)]
		[InlineData(1, 2, 3, 4)]
		[InlineData(1, 2, 3, 4, 5)]
		public void CheckOverflow(params int[] values)
		{
			var cb = new CircularBuffer<int>(1);

			cb.Enqueue(values[0]);

			for (var i = 1; i < values.Length; ++i)
			{
				Check.That(cb.Enqueue(values[i])).IsEqualTo(values[i - 1]);
			}

			Check.That(cb.Dequeue()).IsEqualTo(values[values.Length - 1]);
		}
	}
}

```

`ReClass.NET_Tests/Util/CommandLineArgsTest.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class CommandLineArgsTest
	{
		[Fact]
		public void TestNullArgs()
		{
			var sut = new CommandLineArgs(null);

			Check.That(sut.FileNames).IsEmpty();
			Check.That(sut.Parameters).IsEmpty();
		}

		[Fact]
		public void TestEmptyArgs()
		{
			var sut = new CommandLineArgs(new string[0]);

			Check.That(sut.FileNames).IsEmpty();
			Check.That(sut.Parameters).IsEmpty();
		}

		[Fact]
		public void TestEmptyStringArgs()
		{
			var sut = new CommandLineArgs(new[] { string.Empty, string.Empty });

			Check.That(sut.FileNames).IsEmpty();
			Check.That(sut.Parameters).IsEmpty();
		}

		[Theory]
		[InlineData("test.test")]
		[InlineData("test.test", "test2.test")]
		[InlineData("C:/test.test", "test2.test")]
		[InlineData("test.test", "C:/test2.test")]
		[InlineData("C:/test.test", "C:/test2.test")]
		[InlineData(@"C:\test.test", "test2.test")]
		[InlineData(@"test.test", @"C:\test2.test")]
		[InlineData(@"C:\test.test", @"C:\test2.test")]
		public void TestFilenames(params string[] args)
		{
			var sut = new CommandLineArgs(args);

			Check.That(sut.FileName).IsEqualTo(args[0]);
			Check.That(sut.FileNames).HasSize(args.Length);
			Check.That(sut.FileNames).IsEquivalentTo(args);

			Check.That(sut.Parameters).IsEmpty();
		}

		[Theory]
		[InlineData("-p")]
		[InlineData("-p=")]
		[InlineData("-p:")]
		[InlineData("-p=123")]
		[InlineData("-p:123")]
		[InlineData("--p")]
		[InlineData("--p=")]
		[InlineData("--p:")]
		[InlineData("--p=123")]
		[InlineData("--p:123")]
		public void TestParameterFormats(string arg)
		{
			var sut = new CommandLineArgs(new [] { arg });

			Check.That(sut.Parameters).HasSize(1);
			Check.That(sut.Parameters.First().Key).IsEqualTo("p");

			Check.That(sut.FileNames).IsEmpty();
		}

		[Theory]
		[InlineData("-p", "")]
		[InlineData("-p=", "")]
		[InlineData("-p:", "")]
		[InlineData("-p=123", "123")]
		[InlineData("-p:123", "123")]
		public void TestParameterValues(string arg, string expectedValue)
		{
			var sut = new CommandLineArgs(new[] { arg });

			Check.That(sut.Parameters.First().Value).IsEqualTo(expectedValue);
		}

		public static IEnumerable<object[]> GetTestFilenamesAndParametersData() => new List<object[]>
		{
			new object[] { new[] { "test.test" }, 1, 0 },
			new object[] { new[] { "-p" }, 0, 1 },
			new object[] { new[] { "test.test", "-p" }, 1, 1 },
			new object[] { new[] { "test.test", "-p", "test2.test" }, 2, 1 },
			new object[] { new[] { "test.test", "-p", "-p2=123", "test2.test" }, 2, 2 },
			new object[] { new[] { "-p3:4", "test.test", "-p", "-p2=123", "test2.test" }, 2, 3 }
		};

		[Theory]
		[MemberData(nameof(GetTestFilenamesAndParametersData))]
		public void TestFilenamesAndParameters(string[] args, int expectedFilenames, int expectedParameters)
		{
			var sut = new CommandLineArgs(args);

			Check.That(sut.FileNames).HasSize(expectedFilenames);
			Check.That(sut.Parameters).HasSize(expectedParameters);
		}
	}
}

```

`ReClass.NET_Tests/Util/Conversion/BigEndianBitConverterTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.Util.Conversion
{
	public class BigEndianBitConverterTest
	{
		[Fact]
		public void ToXXX_ThrowsOnNull()
		{
			var sut = new BigEndianBitConverter();

			Check.ThatCode(() => sut.ToInt32(null, 0)).Throws<ArgumentNullException>();
		}

		[Fact]
		public void ToXXX_ThrowsOnInvalidIndexOrSize()
		{
			var sut = new BigEndianBitConverter();

			var data = new byte[3];
			Check.ThatCode(() => sut.ToInt32(data, 0)).Throws<ArgumentOutOfRangeException>();

			data = new byte[4];
			Check.ThatCode(() => sut.ToInt32(data, 1)).Throws<ArgumentOutOfRangeException>();
		}

		[Fact]
		public void GetBytes()
		{
			var sut = new BigEndianBitConverter();

			Check.That(new byte[] { 0 }).ContainsExactly(sut.GetBytes(false));
			Check.That(new byte[] { 1 }).ContainsExactly(sut.GetBytes(true));

			Check.That(new byte[] { 0, 0 }).ContainsExactly(sut.GetBytes((short)0));
			Check.That(new byte[] { 0, 1 }).ContainsExactly(sut.GetBytes((short)1));
			Check.That(new byte[] { 1, 0 }).ContainsExactly(sut.GetBytes((short)256));
			Check.That(new byte[] { 255, 255 }).ContainsExactly(sut.GetBytes((short)-1));

			Check.That(new byte[] { 0, 0 }).ContainsExactly(sut.GetBytes((ushort)0));
			Check.That(new byte[] { 0, 1 }).ContainsExactly(sut.GetBytes((ushort)1));
			Check.That(new byte[] { 1, 0 }).ContainsExactly(sut.GetBytes((ushort)256));
			Check.That(new byte[] { 255, 255 }).ContainsExactly(sut.GetBytes(ushort.MaxValue));

			Check.That(new byte[] { 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0));
			Check.That(new byte[] { 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(1));
			Check.That(new byte[] { 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(256));
			Check.That(new byte[] { 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(65536));
			Check.That(new byte[] { 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216));
			Check.That(new byte[] { 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(-1));

			Check.That(new byte[] { 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0u));
			Check.That(new byte[] { 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(1u));
			Check.That(new byte[] { 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(256u));
			Check.That(new byte[] { 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(65536u));
			Check.That(new byte[] { 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216u));
			Check.That(new byte[] { 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(uint.MaxValue));

			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(1L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(256L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(65536L));
			Check.That(new byte[] { 0, 0, 0, 0, 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216L));
			Check.That(new byte[] { 0, 0, 0, 1, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(4294967296L));
			Check.That(new byte[] { 0, 0, 1, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1099511627776L));
			Check.That(new byte[] { 0, 1, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(281474976710656L));
			Check.That(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(72057594037927936L));
			Check.That(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(-1L));

			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(1UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(256UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(65536UL));
			Check.That(new byte[] { 0, 0, 0, 0, 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216UL));
			Check.That(new byte[] { 0, 0, 0, 1, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(4294967296UL));
			Check.That(new byte[] { 0, 0, 1, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1099511627776UL));
			Check.That(new byte[] { 0, 1, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(281474976710656UL));
			Check.That(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(72057594037927936UL));
			Check.That(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(ulong.MaxValue));
		}

		[Fact]
		public void ToXXX()
		{
			var sut = new BigEndianBitConverter();

			var data = new byte[] { 0, 0, 0, 0, 0, 0, 0, 3 };
			Check.That(sut.ToBoolean(data, 0)).IsFalse();
			Check.That(sut.ToBoolean(data, 7)).IsTrue();
			Check.That(sut.ToChar(data, 0)).IsEqualTo('\0');
			Check.That(sut.ToChar(data, 6)).IsEqualTo('\u0003');
			Check.That(sut.ToInt16(data, 0)).IsEqualTo(0);
			Check.That(sut.ToInt16(data, 6)).IsEqualTo(3);
			Check.That(sut.ToUInt16(data, 0)).IsEqualTo(0u);
			Check.That(sut.ToUInt16(data, 6)).IsEqualTo(3u);
			Check.That(sut.ToInt32(data, 0)).IsEqualTo(0);
			Check.That(sut.ToInt32(data, 4)).IsEqualTo(3);
			Check.That(sut.ToUInt32(data, 0)).IsEqualTo(0u);
			Check.That(sut.ToUInt32(data, 4)).IsEqualTo(3u);
			Check.That(sut.ToInt64(data, 0)).IsEqualTo(3L);
			Check.That(sut.ToUInt64(data, 0)).IsEqualTo(3UL);

			data = new byte[] { 0x41, 0x20, 0, 0, 0, 0, 0, 0 };
			Check.That(sut.ToSingle(data, 0)).IsEqualTo(10.0f);
			Check.That(sut.ToSingle(data, 4)).IsEqualTo(0.0f);

			data = new byte[] { 0x40, 0x24, 0, 0, 0, 0, 0, 0 };
			Check.That(sut.ToDouble(data, 0)).IsEqualTo(10.0);
		}
	}
}

```

`ReClass.NET_Tests/Util/Conversion/EndianBitConverterTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.Util.Conversion
{
	public class EndianBitConverterTest
	{
		[Fact]
		public void Properties_AreNotNull()
		{
			Check.That(EndianBitConverter.System).IsNotNull();
			Check.That(EndianBitConverter.Big).IsNotNull();
			Check.That(EndianBitConverter.Little).IsNotNull();
		}

		[Fact]
		public void Types()
		{
			Check.That(EndianBitConverter.Big.GetType()).IsNotEqualTo(EndianBitConverter.Little.GetType());
			Check.That(EndianBitConverter.System.GetType()).IsEqualTo(BitConverter.IsLittleEndian ? EndianBitConverter.Little.GetType() : EndianBitConverter.Big.GetType());
		}
	}
}

```

`ReClass.NET_Tests/Util/Conversion/LittleEndianBitConverterTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.Util.Conversion;
using Xunit;

namespace ReClass.NET_Tests.Util.Conversion
{
	public class LittleEndianBitConverterTest
	{
		[Fact]
		public void ToXXX_ThrowsOnNull()
		{
			var sut = new LittleEndianBitConverter();

			Check.ThatCode(() => sut.ToInt32(null, 0)).Throws<ArgumentNullException>();
		}

		[Fact]
		public void ToXXX_ThrowsOnInvalidIndexOrSize()
		{
			var sut = new LittleEndianBitConverter();

			var data = new byte[3];
			Check.ThatCode(() => sut.ToInt32(data, 0)).Throws<ArgumentOutOfRangeException>();

			data = new byte[4];
			Check.ThatCode(() => sut.ToInt32(data, 1)).Throws<ArgumentOutOfRangeException>();
		}

		[Fact]
		public void GetBytes()
		{
			var sut = new LittleEndianBitConverter();

			Check.That(new byte[] { 0 }).ContainsExactly(sut.GetBytes(false));
			Check.That(new byte[] { 1 }).ContainsExactly(sut.GetBytes(true));

			Check.That(new byte[] { 0, 0 }).ContainsExactly(sut.GetBytes((short)0));
			Check.That(new byte[] { 1, 0 }).ContainsExactly(sut.GetBytes((short)1));
			Check.That(new byte[] { 0, 1 }).ContainsExactly(sut.GetBytes((short)256));
			Check.That(new byte[] { 255, 255 }).ContainsExactly(sut.GetBytes((short)-1));

			Check.That(new byte[] { 0, 0 }).ContainsExactly(sut.GetBytes((ushort)0));
			Check.That(new byte[] { 1, 0 }).ContainsExactly(sut.GetBytes((ushort)1));
			Check.That(new byte[] { 0, 1 }).ContainsExactly(sut.GetBytes((ushort)256));
			Check.That(new byte[] { 255, 255 }).ContainsExactly(sut.GetBytes(ushort.MaxValue));

			Check.That(new byte[] { 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0));
			Check.That(new byte[] { 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1));
			Check.That(new byte[] { 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(256));
			Check.That(new byte[] { 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(65536));
			Check.That(new byte[] { 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(16777216));
			Check.That(new byte[] { 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(-1));

			Check.That(new byte[] { 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0u));
			Check.That(new byte[] { 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1u));
			Check.That(new byte[] { 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(256u));
			Check.That(new byte[] { 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(65536u));
			Check.That(new byte[] { 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(16777216u));
			Check.That(new byte[] { 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(uint.MaxValue));

			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0L));
			Check.That(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1L));
			Check.That(new byte[] { 0, 1, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(256L));
			Check.That(new byte[] { 0, 0, 1, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(65536L));
			Check.That(new byte[] { 0, 0, 0, 1, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216L));
			Check.That(new byte[] { 0, 0, 0, 0, 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(4294967296L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(1099511627776L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(281474976710656L));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(72057594037927936L));
			Check.That(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(-1L));

			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(0UL));
			Check.That(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(1UL));
			Check.That(new byte[] { 0, 1, 0, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(256UL));
			Check.That(new byte[] { 0, 0, 1, 0, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(65536UL));
			Check.That(new byte[] { 0, 0, 0, 1, 0, 0, 0, 0 }).ContainsExactly(sut.GetBytes(16777216UL));
			Check.That(new byte[] { 0, 0, 0, 0, 1, 0, 0, 0 }).ContainsExactly(sut.GetBytes(4294967296UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 1, 0, 0 }).ContainsExactly(sut.GetBytes(1099511627776UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 1, 0 }).ContainsExactly(sut.GetBytes(281474976710656UL));
			Check.That(new byte[] { 0, 0, 0, 0, 0, 0, 0, 1 }).ContainsExactly(sut.GetBytes(72057594037927936UL));
			Check.That(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255 }).ContainsExactly(sut.GetBytes(ulong.MaxValue));
		}

		[Fact]
		public void ToXXX()
		{
			var sut = new LittleEndianBitConverter();

			var data = new byte[] { 0x03, 0, 0, 0, 0, 0, 0, 0 };
			Check.That(sut.ToBoolean(data, 0)).IsTrue();
			Check.That(sut.ToBoolean(data, 7)).IsFalse();
			Check.That(sut.ToChar(data, 0)).IsEqualTo('\u0003');
			Check.That(sut.ToChar(data, 6)).IsEqualTo('\0');
			Check.That(sut.ToInt16(data, 0)).IsEqualTo(3);
			Check.That(sut.ToInt16(data, 6)).IsEqualTo(0);
			Check.That(sut.ToUInt16(data, 0)).IsEqualTo(3u);
			Check.That(sut.ToUInt16(data, 6)).IsEqualTo(0u);
			Check.That(sut.ToInt32(data, 0)).IsEqualTo(3);
			Check.That(sut.ToInt32(data, 4)).IsEqualTo(0);
			Check.That(sut.ToUInt32(data, 0)).IsEqualTo(3u);
			Check.That(sut.ToUInt32(data, 4)).IsEqualTo(0u);
			Check.That(sut.ToInt64(data, 0)).IsEqualTo(3L);
			Check.That(sut.ToUInt64(data, 0)).IsEqualTo(3UL);

			data = new byte[] { 0, 0, 0, 0, 0, 0, 0x20, 0x41 };
			Check.That(sut.ToSingle(data, 0)).IsEqualTo(0.0f);
			Check.That(sut.ToSingle(data, 4)).IsEqualTo(10.0f);

			data = new byte[] { 0, 0, 0, 0, 0, 0, 0x24, 0x40 };
			Check.That(sut.ToDouble(data, 0)).IsEqualTo(10.0);
		}
	}
}

```

`ReClass.NET_Tests/Util/CustomDataMapTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class CustomDataMapTest
	{
		[Fact]
		public void TestNullKeyNotAllowed()
		{
			var sut = new CustomDataMap();

			Check.ThatCode(() => sut.SetString(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.SetBool(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.SetLong(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.SetULong(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.SetXElement(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.GetString(null)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.GetBool(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.GetLong(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.GetULong(null, default)).Throws<ArgumentNullException>();
			Check.ThatCode(() => sut.GetXElement(null, default)).Throws<ArgumentNullException>();
		}

		[Theory]
		[InlineData("key", "")]
		[InlineData("key", "value")]
		public void TestSetGetString(string key, string value)
		{
			var sut = new CustomDataMap();

			sut.SetString(key, value);

			Check.That(sut.GetString(key)).IsEqualTo(value);
		}

		[Theory]
		[InlineData("key", "")]
		[InlineData("key", "value")]
		public void TestIndexString(string key, string value)
		{
			var sut = new CustomDataMap();

			sut.SetString(key, value);

			Check.That(sut[key]).IsEqualTo(value);
		}

		[Fact]
		public void TestItemEnumeration()
		{
			var data = new Dictionary<string, string>
			{
				{ "key1", "value1" },
				{ "key2", "value2" },
				{ "key3", "value3" }
			};

			var sut = new CustomDataMap();

			foreach (var kv in data)
			{
				sut.SetString(kv.Key, kv.Value);
			}

			Check.That(sut).IsEquivalentTo(data);
		}

		[Fact]
		public void TestRemoveItem()
		{
			const string KeyToRemove = "key2";

			var data = new Dictionary<string, string>
			{
				{ "key1", "value1" },
				{ KeyToRemove, "value2" },
				{ "key3", "value3" }
			};

			var sut = new CustomDataMap();

			foreach (var kv in data)
			{
				sut.SetString(kv.Key, kv.Value);
			}

			sut.RemoveValue(KeyToRemove);

			Check.That(sut).IsEquivalentTo(data.Where(kv => kv.Key != KeyToRemove));
		}

		[Theory]
		[InlineData("key", true)]
		[InlineData("key", false)]
		public void TestSetGetBool(string key, bool value)
		{
			var sut = new CustomDataMap();

			sut.SetBool(key, value);

			Check.That(sut.GetBool(key, !value)).IsEqualTo(value);
		}

		[Theory]
		[InlineData("key", -1)]
		[InlineData("key", 0)]
		[InlineData("key", 1)]
		[InlineData("key", long.MaxValue)]
		[InlineData("key", long.MinValue)]
		public void TestSetGetLong(string key, long value)
		{
			var sut = new CustomDataMap();

			sut.SetLong(key, value);

			Check.That(sut.GetLong(key, 0)).IsEqualTo(value);
		}

		[Theory]
		[InlineData("key", 0)]
		[InlineData("key", 1)]
		[InlineData("key", ulong.MaxValue)]
		[InlineData("key", ulong.MinValue)]
		public void TestSetGetULong(string key, ulong value)
		{
			var sut = new CustomDataMap();

			sut.SetULong(key, value);

			Check.That(sut.GetULong(key, 0)).IsEqualTo(value);
		}

		public static IEnumerable<object[]> GetTestSetGetXElementData() => new List<object[]>
		{
			new object[] { "key", null },
			new object[] { "key", new XElement("name") },
			new object[] { "key", new XElement("name", new XAttribute("attr", "test")) },
			new object[] { "key", new XElement("name", new XElement("value", "test")) }
		};

		[Theory]
		[MemberData(nameof(GetTestSetGetXElementData))]
		public void TestSetGetXElement(string key, XElement value)
		{
			var sut = new CustomDataMap();

			sut.SetXElement(key, value);

			Check.That(XNode.DeepEquals(sut.GetXElement(key, null), value)).IsTrue();
		}
	}
}

```

`ReClass.NET_Tests/Util/DirectedGraphTest.cs`:

```cs
using System;
using System.Collections.Generic;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class DirectedGraphTest
	{
		[Fact]
		public void TestAddContainsVertex()
		{
			const int Vertex = 0;

			var sut = new DirectedGraph<int>();

			Check.That(sut.AddVertex(Vertex)).IsTrue();

			Check.That(sut.ContainsVertex(Vertex)).IsTrue();
		}

		[Fact]
		public void TestAddExistingVertex()
		{
			const int Vertex = 0;

			var sut = new DirectedGraph<int>();

			sut.AddVertex(Vertex);

			Check.That(sut.AddVertex(Vertex)).IsFalse();
		}

		[Fact]
		public void TestContainsWithEmptyGraph()
		{
			const int Vertex = 0;

			var sut = new DirectedGraph<int>();

			Check.That(sut.ContainsVertex(Vertex)).IsFalse();
		}

		[Fact]
		public void TestAddContainsMultipleVertices()
		{
			var vertices = new[] { 0, 1, 2, 3 };

			var sut = new DirectedGraph<int>();

			sut.AddVertices(vertices);

			foreach (var vertex in vertices)
			{
				Check.That(sut.ContainsVertex(vertex)).IsTrue();
			}

			Check.That(sut.Vertices).IsEquivalentTo(vertices);
		}

		[Fact]
		public void TestAddEdgeToNonExistingVertex()
		{
			const int Vertex1 = 0;
			const int Vertex2 = 1;

			var sut = new DirectedGraph<int>();

			Check.ThatCode(() => sut.AddEdge(Vertex1, Vertex2)).Throws<ArgumentException>();

			sut.AddVertex(Vertex1);

			Check.ThatCode(() => sut.AddEdge(Vertex1, Vertex2)).Throws<ArgumentException>();
			Check.ThatCode(() => sut.AddEdge(Vertex2, Vertex1)).Throws<ArgumentException>();
		}

		[Fact]
		public void TestContainsEdgeToNonExistingVertex()
		{
			const int Vertex1 = 0;
			const int Vertex2 = 1;

			var sut = new DirectedGraph<int>();

			Check.ThatCode(() => sut.ContainsEdge(Vertex1, Vertex2)).Throws<ArgumentException>();

			sut.AddVertex(Vertex1);

			Check.ThatCode(() => sut.ContainsEdge(Vertex1, Vertex2)).Throws<ArgumentException>();
			Check.ThatCode(() => sut.ContainsEdge(Vertex2, Vertex1)).Throws<ArgumentException>();
		}

		[Fact]
		public void TestAddContainsEdge()
		{
			const int Vertex1 = 0;
			const int Vertex2 = 1;

			var sut = new DirectedGraph<int>();

			sut.AddVertex(Vertex1);
			sut.AddVertex(Vertex2);

			Check.That(sut.ContainsEdge(Vertex1, Vertex2)).IsFalse();

			Check.That(sut.AddEdge(Vertex1, Vertex2)).IsTrue();

			Check.That(sut.ContainsEdge(Vertex1, Vertex2)).IsTrue();
		}

		[Fact]
		public void TestAddExistingEdge()
		{
			const int Vertex1 = 0;
			const int Vertex2 = 1;

			var sut = new DirectedGraph<int>();

			sut.AddVertex(Vertex1);
			sut.AddVertex(Vertex2);
			sut.AddEdge(Vertex1, Vertex2);

			Check.That(sut.AddEdge(Vertex1, Vertex2)).IsFalse();
		}

		[Fact]
		public void TestGetNeighboursOfNonExistingVertex()
		{
			const int Vertex = 0;

			var sut = new DirectedGraph<int>();

			Check.ThatCode(() => sut.GetNeighbours(Vertex)).Throws<ArgumentException>();
		}

		public static IEnumerable<object[]> GetTestGetNeighboursData() => new List<object[]>
		{
			new object[] { new[] { 1 }, new[] { new[] { 1, 1 } }, new[] { 1 } },
			new object[] { new[] { 1, 2 }, new[] { new[] { 2, 1 } }, new int[0] },
			new object[] { new[] { 1, 2 }, new[] { new[] { 1, 2 } }, new[] { 2 } },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 2, 1 }, new[] { 2, 3 } }, new int[0] },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 2, 3 } }, new[] { 2 } },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 1, 3 } }, new[] { 2, 3 } },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 1 }, new[] { 1, 2 }, new[] { 1, 3 } }, new[] { 1, 2, 3 } }
		};

		[Theory]
		[MemberData(nameof(GetTestGetNeighboursData))]
		public void TestGetNeighbours(int[] vertices, int[][] edges, int[] neighbours)
		{
			var sut = new DirectedGraph<int>();

			sut.AddVertices(vertices);

			foreach (var edge in edges)
			{
				sut.AddEdge(edge[0], edge[1]);
			}

			Check.That(sut.GetNeighbours(vertices[0])).IsEquivalentTo(neighbours);
		}

		public static IEnumerable<object[]> GetTestContainsCycleData() => new List<object[]>
		{
			new object[] { new[] { 1 }, new[] { new[] { 1, 1 } }, true },
			new object[] { new[] { 1, 2 }, new[] { new[] { 1, 2 } }, false },
			new object[] { new[] { 1, 2 }, new[] { new[] { 1, 2 }, new[] { 2, 1 } }, true },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 2, 3 } }, false },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 1, 3 }, new[] { 2, 3 } }, false },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 1 } }, true },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 2 } }, true },
			new object[] { new[] { 1, 2, 3 }, new[] { new[] { 1, 2 }, new[] { 2, 1 }, new[] { 2, 3 }, new[] { 3, 2 } }, true }
		};

		[Theory]
		[MemberData(nameof(GetTestContainsCycleData))]
		public void TestContainsCycle(int[] vertices, int[][] edges, bool containsCycle)
		{
			var sut = new DirectedGraph<int>();

			sut.AddVertices(vertices);

			foreach (var edge in edges)
			{
				sut.AddEdge(edge[0], edge[1]);
			}

			Check.That(sut.ContainsCycle()).IsEqualTo(containsCycle);
		}
	}
}

```

`ReClass.NET_Tests/Util/GrowingListTest.cs`:

```cs
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class GrowingListTest
	{
		[Theory]
		[InlineData(0)]
		[InlineData(1)]
		[InlineData(2)]
		[InlineData(10)]
		[InlineData(100)]
		public void CheckSetCount(int index)
		{
			var gl = new GrowingList<int>
			{
				[index] = default
			};

			Check.That(gl.Count).IsEqualTo(index + 1);
		}

		[Theory]
		[InlineData(0, 1, 2)]
		[InlineData(1, 2, 3)]
		[InlineData(2, 10, 11)]
		[InlineData(10, 8, 11)]
		[InlineData(100, 200, 201)]
		[InlineData(0, 0, 1)]
		[InlineData(10, 1, 11)]
		[InlineData(2, 1, 3)]
		public void CheckMultipleSetCount(int index1, int index2, int expected)
		{
			var gl = new GrowingList<int>
			{
				[index1] = default,
				[index2] = default
			};

			Check.That(gl.Count).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(0)]
		[InlineData(1)]
		[InlineData(2)]
		[InlineData(10)]
		[InlineData(100)]
		public void CheckGetCount(int index)
		{
			var gl = new GrowingList<int>();

			var _ = gl[index];

			Check.That(gl.Count).IsEqualTo(index + 1);
		}

		[Theory]
		[InlineData(0, 1, 2)]
		[InlineData(1, 2, 3)]
		[InlineData(2, 10, 11)]
		[InlineData(10, 8, 11)]
		[InlineData(100, 200, 201)]
		[InlineData(0, 0, 1)]
		[InlineData(10, 1, 11)]
		[InlineData(2, 1, 3)]
		public void CheckMultipleGetCount(int index1, int index2, int expected)
		{
			var gl = new GrowingList<int>();

			var _ = gl[index1];
			_ = gl[index2];

			Check.That(gl.Count).IsEqualTo(expected);
		}

		[Theory]
		[InlineData(1, 0)]
		[InlineData(1, 10)]
		[InlineData(-1, 0)]
		[InlineData(-1, 20)]
		public void CheckDefaultValue(int value, int index)
		{
			var gl = new GrowingList<int>(value);

			Check.That(gl[index]).IsEqualTo(value);
		}
	}
}

```

`ReClass.NET_Tests/Util/HexadecimalFormatterTest.cs`:

```cs
using System.Collections.Generic;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class HexadecimalFormatterTest
	{
		public static IEnumerable<object[]> GetTestData() => new List<object[]>
		{
			new object[] { new byte[0], string.Empty },
			new object[] { new byte[] { 0x12 }, "12" },
			new object[] { new byte[] { 0x12, 0x23, 0x34, 0x45 }, "12 23 34 45" }
		};

		[Theory]
		[MemberData(nameof(GetTestData))]
		public void Test(byte[] data, string expected)
		{
			Check.That(HexadecimalFormatter.ToString(data)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Util/IntPtrComparerTest.cs`:

```cs
using System;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class IntPtrComparerTest
	{
		public static TheoryData<IntPtr, IntPtr, bool> GetTestCompareData() => new TheoryData<IntPtr, IntPtr, bool>
		{
			{ IntPtr.Zero, IntPtr.Zero, false },
			{ (IntPtr)0x1, IntPtr.Zero, false },
			{ (IntPtr)0x1, (IntPtr)0x10, true },
			{ (IntPtr)0x1, unchecked((IntPtr)(int)0xFFFFFFFF), true },
			{ unchecked((IntPtr)(int)0xFFFFFFFF), unchecked((IntPtr)(int)0xFFFFFFFF), false },
			{ unchecked((IntPtr)(int)0xFFFFFFFF), IntPtr.Zero, false }
		};

		[Theory]
		[MemberData(nameof(GetTestCompareData))]
		public void TestCompare(IntPtr lhs, IntPtr rhs, bool lhsIsSmaller)
		{
			var comparer = IntPtrComparer.Instance;

			Check.That(comparer.Compare(lhs, rhs) < 0).IsEqualTo(lhsIsSmaller);
		}
	}
}

```

`ReClass.NET_Tests/Util/NumberFormatTest.cs`:

```cs
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class NumberFormatTest
	{
		[Theory]
		[InlineData("123,34", ",", ".")]
		[InlineData("123.34", ".", ",")]
		[InlineData("1.123,34", ",", ".")]
		[InlineData("1,123.34", ".", ",")]
		public void TestGuess(string input, string expectedDecimalSeparator, string expectedGroupSeparator)
		{
			var nf = NumberFormat.GuessNumberFormat(input);

			Check.That(nf.NumberDecimalSeparator).IsEqualTo(expectedDecimalSeparator);
			Check.That(nf.NumberGroupSeparator).IsEqualTo(expectedGroupSeparator);
		}
	}
}

```

`ReClass.NET_Tests/Util/PathUtilTest.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using NFluent;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class PathUtilTest
	{
		public static IEnumerable<object[]> GetTestConversionData() => new List<object[]>
		{
			new object[] { string.Empty, string.Empty },
			new object[] { "C:/", "C:" + Path.DirectorySeparatorChar },
			new object[] { @"C:\", "C:" + Path.DirectorySeparatorChar },
			new object[] { "C:/test.test", Path.Combine("C:" + Path.DirectorySeparatorChar, "test.test") },
			new object[] { "file:///C:/test.test", Path.Combine("C:" + Path.DirectorySeparatorChar, "test.test") },
		};

		[Theory]
		[MemberData(nameof(GetTestConversionData))]
		public void TestConversion(string input, string expected)
		{
			Check.That(PathUtil.FileUrlToPath(input)).IsEqualTo(expected);
		}
	}
}

```

`ReClass.NET_Tests/Util/XElementSerializerTest.cs`:

```cs
using System.Collections.Generic;
using System.Drawing;
using NFluent;
using ReClassNET.Extensions;
using ReClassNET.Util;
using Xunit;

namespace ReClass.NET_Tests.Util
{
	public class XElementSerializerTest
	{
		[Theory]
		[InlineData(true)]
		[InlineData(false)]
		public void TestBoolSerialization(bool value)
		{
			const string Name = "BoolValue";

			var element = XElementSerializer.ToXml(Name, value);

			Check.That(element.Name.LocalName).IsEqualTo(Name);

			Check.That(XElementSerializer.ToBool(element)).IsEqualTo(value);
		}

		[Theory]
		[InlineData(0)]
		[InlineData(1)]
		[InlineData(-1)]
		[InlineData(int.MaxValue)]
		[InlineData(int.MinValue)]
		public void TestIntSerialization(int value)
		{
			const string Name = "IntValue";

			var element = XElementSerializer.ToXml(Name, value);

			Check.That(element.Name.LocalName).IsEqualTo(Name);

			Check.That(XElementSerializer.ToInt(element)).IsEqualTo(value);
		}

		[Theory]
		[InlineData("")]
		[InlineData("test")]
		public void TestStringSerialization(string value)
		{
			const string Name = "StringValue";

			var element = XElementSerializer.ToXml(Name, value);

			Check.That(element.Name.LocalName).IsEqualTo(Name);

			Check.That(XElementSerializer.ToString(element)).IsEqualTo(value);
		}

		public static IEnumerable<object[]> GetTestColorSerializationData() => new List<object[]>
		{
			new object[] { Color.Empty },
			new object[] { Color.Red },
			new object[] { Color.Blue },
			new object[] { Color.FromArgb(123, 123, 123) }
		};

		[Theory]
		[MemberData(nameof(GetTestColorSerializationData))]
		public void TestColorSerialization(Color value)
		{
			const string Name = "ColorValue";

			var element = XElementSerializer.ToXml(Name, value);

			Check.That(element.Name.LocalName).IsEqualTo(Name);

			Check.That(XElementSerializer.ToColor(element).ToRgb()).IsEqualTo(value.ToRgb());
		}

		public static IEnumerable<object[]> GetTestDictionarySerializationData() => new List<object[]>
		{
			new object[] { new Dictionary<string, string>() },
			new object[] { new Dictionary<string, string> { { "test", "test" }, { "test2", "test2" } } }
		};

		[Theory]
		[MemberData(nameof(GetTestDictionarySerializationData))]
		public void TestDictionarySerialization(Dictionary<string, string> value)
		{
			const string Name = "DictionaryValue";

			var element = XElementSerializer.ToXml(Name, value);

			Check.That(element.Name.LocalName).IsEqualTo(Name);

			Check.That(XElementSerializer.ToDictionary(element)).IsEquivalentTo(value);
		}
	}
}

```