Project Path: arc_gmh5225_ShadowStackWalk_8kvljb16

Source Tree:

```txt
arc_gmh5225_ShadowStackWalk_8kvljb16
├── LICENSE.txt
├── README.md
├── ShadowStackWalk
│   ├── ShadowStackWalk.cpp
│   ├── ShadowStackWalk.vcxproj
│   ├── ShadowStackWalk.vcxproj.filters
│   └── ShadowStackWalk.vcxproj.user
└── ShadowStackWalk.sln

```

`LICENSE.txt`:

```txt
Elastic License 2.0

URL: https://www.elastic.co/licensing/elastic-license

## Acceptance

By using the software, you agree to all of the terms and conditions below.

## Copyright License

The licensor grants you a non-exclusive, royalty-free, worldwide,
non-sublicensable, non-transferable license to use, copy, distribute, make
available, and prepare derivative works of the software, in each case subject to
the limitations and conditions below.

## Limitations

You may not provide the software to third parties as a hosted or managed
service, where the service provides users with access to any substantial set of
the features or functionality of the software.

You may not move, change, disable, or circumvent the license key functionality
in the software, and you may not remove or obscure any functionality in the
software that is protected by the license key.

You may not alter, remove, or obscure any licensing, copyright, or other notices
of the licensor in the software. Any use of the licensor’s trademarks is subject
to applicable law.

## Patents

The licensor grants you a license, under any patent claims the licensor can
license, or becomes able to license, to make, have made, use, sell, offer for
sale, import and have imported the software, in each case subject to the
limitations and conditions in this license. This license does not cover any
patent claims that you cause to be infringed by modifications or additions to
the software. If you or your company make any written claim that the software
infringes or contributes to infringement of any patent, your patent license for
the software granted under these terms ends immediately. If your company makes
such a claim, your patent license ends immediately for work on behalf of your
company.

## Notices

You must ensure that anyone who gets a copy of any part of the software from you
also gets a copy of these terms.

If you modify the software, you must include in any modified copies of the
software prominent notices stating that you have modified the software.

## No Other Rights

These terms do not imply any licenses other than those expressly granted in
these terms.

## Termination

If you use the software in violation of these terms, such use is not licensed,
and your licenses will automatically terminate. If the licensor provides you
with a notice of your violation, and you cease all violation of this license no
later than 30 days after you receive that notice, your licenses will be
reinstated retroactively. However, if you violate these terms after such
reinstatement, any additional violation of these terms will cause your licenses
to terminate automatically and permanently.

## No Liability

*As far as the law allows, the software comes as is, without any warranty or
condition, and the licensor will not be liable to you for any damages arising
out of these terms or the use or nature of the software, under any kind of
legal claim.*

## Definitions

The **licensor** is the entity offering these terms, and the **software** is the
software the licensor makes available under these terms, including any portion
of it.

**you** refers to the individual or entity agreeing to these terms.

**your company** is any legal entity, sole proprietorship, or other kind of
organization that you work for, plus all organizations that have control over,
are under the control of, or are under common control with that
organization. **control** means ownership of substantially all the assets of an
entity, or the power to direct its management and policies by vote, contract, or
otherwise. Control can be direct or indirect.

**your licenses** are all the licenses granted to you for the software under
these terms.

**use** means anything you do with the software requiring one of your licenses.

**trademark** means trademarks, service marks, and similar rights.
```

`README.md`:

```md
# Shadow Stack Walk

[Gabriel Landau](https://twitter.com/GabrielLandau) @ [Elastic Security](https://www.elastic.co/security-labs/security-research)

See the accompanying Elastic Security Labs article, [Finding Truth in the Shadows](https://www.elastic.co/security-labs/finding-truth-in-the-shadows).

The shadow stack provides an interesting detection opportunity.  Adversaries can use tools like [ThreadStackSpoofer](https://github.com/mgeeky/ThreadStackSpoofer/tree/master) and [CallStackSpoofer](https://github.com/WithSecureLabs/CallStackSpoofer) to obfuscate their presence against thread stack scans (e.g. `StackWalk64`) and inline stack traces like [Sysmon operations](https://www.lares.com/blog/hunting-in-the-sysmon-call-trace/).

By comparing a traditional stack walk against its shadowy sibling, we can both detect and see through thread stack spoofing.  This tool implements `CaptureStackBackTrace`/`StackWalk64` with the shadow stack (aka CET/HSP) to catch thread stack spoofing.  When the stack is normal, it functions similarly to `CaptureStackBackTrace` and `StackWalk64`:

```
Control run demonstrating equivalent output...

CONTROL CaptureStackBackTrace: dps 000001CE41EDA800
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!main + 0x5f
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
2: \Device\HarddiskVolume3\Windows\System32\kernel32.dll!BaseThreadInitThunk + 0x14
3: \Device\HarddiskVolume3\Windows\System32\ntdll.dll!RtlUserThreadStart + 0x21

CONTROL StackWalk64: dps 000001CE42F80D80
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!main + 0x5f
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
2: \Device\HarddiskVolume3\Windows\System32\kernel32.dll!BaseThreadInitThunk + 0x14
3: \Device\HarddiskVolume3\Windows\System32\ntdll.dll!RtlUserThreadStart + 0x21

CONTROL CET Stack: dps 000001CE41ED79C0
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!main + 0x5f
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
2: \Device\HarddiskVolume3\Windows\System32\kernel32.dll!BaseThreadInitThunk + 0x14
3: \Device\HarddiskVolume3\Windows\System32\ntdll.dll!RtlUserThreadStart + 0x21
```

It's unaffected by intentional breaks of the call stack such as [ThreadStackSpoofer](https://github.com/mgeeky/ThreadStackSpoofer/blob/f67caea38a7acdb526eae3aac7c451a08edef6a9/ThreadStackSpoofer/main.cpp#L20-L25).

```
Breaking stack walk with a NULL return address...

BROKEN CaptureStackBackTrace: dps 000001CE41ED79C0
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40

BROKEN StackWalk64: dps 000001CE42E1FCD0
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40

BROKEN CET Stack: dps 000001CE41F23020
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!main + 0x8c
2: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
3: \Device\HarddiskVolume3\Windows\System32\kernel32.dll!BaseThreadInitThunk + 0x14
4: \Device\HarddiskVolume3\Windows\System32\ntdll.dll!RtlUserThreadStart + 0x21
```

It doesn't care about forged stack frames:
```
Spoofing call stack to hide ShadowStackWalk.exe!main...

SPOOFED CaptureStackBackTrace: dps 000001CE41ED79C0
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
2: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__xi_z + 0x0

SPOOFED StackWalk64: dps 000001CE41F23020
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
2: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__xi_z + 0x0

SPOOFED CET Stack: dps 000001CE42C927C0
0: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!SpoofStackThenCall + 0x40
1: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!main + 0xbe
2: \Device\HarddiskVolume3\git\ShadowStackWalk\x64\Release\ShadowStackWalk.exe!__scrt_common_main_seh + 0x10c
3: \Device\HarddiskVolume3\Windows\System32\kernel32.dll!BaseThreadInitThunk + 0x14
4: \Device\HarddiskVolume3\Windows\System32\ntdll.dll!RtlUserThreadStart + 0x21
```

```

`ShadowStackWalk.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32929.386
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ShadowStackWalk", "ShadowStackWalk\ShadowStackWalk.vcxproj", "{2B2B52EE-3587-496D-88ED-FEC157AD96BB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2B2B52EE-3587-496D-88ED-FEC157AD96BB}.Debug|x64.ActiveCfg = Debug|x64
		{2B2B52EE-3587-496D-88ED-FEC157AD96BB}.Debug|x64.Build.0 = Debug|x64
		{2B2B52EE-3587-496D-88ED-FEC157AD96BB}.Release|x64.ActiveCfg = Release|x64
		{2B2B52EE-3587-496D-88ED-FEC157AD96BB}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A455CC8-BA59-4EFF-A5AF-64DB7296C243}
	EndGlobalSection
EndGlobal

```

`ShadowStackWalk/ShadowStackWalk.cpp`:

```cpp
// ShadowStackWalk.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdlib.h>
#include <vector>
#include <string>
#include <intrin.h>
#include <DbgHelp.h>
#include <Psapi.h>

#pragma optimize("", off)

void SymInit(HANDLE hProcess)
{
    std::wstring myPath(USHRT_MAX, L'\0');
    std::wstring myDir;
    myPath.resize(GetModuleFileNameW(NULL, &myPath[0], (DWORD)myPath.size()));
    myDir = myPath.substr(0, myPath.rfind('\\'));

    if (!SymInitializeW(hProcess, myDir.c_str(), TRUE))
    {
        printf("SymInitializeW failed with GLE %u\n", GetLastError());
    }
}

PVOID WINAPI GetSSP(HANDLE hThread)
{
    PCONTEXT pCtx = NULL;
    DWORD64 featureMask = 0;
    DWORD contextLength = 0;
    std::string buf;
    PXSAVE_CET_U_FORMAT pCet = NULL;
    DWORD cetLength = 0;

    if (!(GetEnabledXStateFeatures() & XSTATE_MASK_CET_U))
    {
        printf("XSTATE_MASK_CET_U is not enabled!\n");
        return 0;
    }

    (void)InitializeContext2(NULL, CONTEXT_XSTATE, NULL, &contextLength, XSTATE_MASK_CET_U);
    if (0 == contextLength)
    {
        printf("InitializeContext2 call 1 failed with GLE %u\n", GetLastError());
        return NULL;
    }

    buf.resize(contextLength);
    if (!InitializeContext2(&buf[0], CONTEXT_XSTATE, &pCtx, &contextLength, XSTATE_MASK_CET_U))
    {
        printf("InitializeContext2 call 2 failed with GLE %u\n", GetLastError());
        return NULL;
    }

    if (!GetThreadContext(hThread, pCtx))
    {
        printf("GetThreadContext failed with GLE %u\n", GetLastError());
        return NULL;
    }

    if (!GetXStateFeaturesMask(pCtx, &featureMask))
    {
        printf("GetXStateFeaturesMask failed with GLE %u\n", GetLastError());
        return NULL;
    }

    if (!(XSTATE_MASK_CET_U & featureMask))
    {
        printf("CET is not enabled on this thread\n");
        return NULL;
    }

    pCet = (PXSAVE_CET_U_FORMAT)LocateXStateFeature(pCtx, XSTATE_CET_U, &cetLength);
    if (!pCet || (sizeof(*pCet) != cetLength))
    {
        printf("Failed to locate XSTATE_MASK_CET_U feature\n");
        return NULL;
    }

    return (PVOID)pCet->Ia32Pl3SspMsr;
}

USHORT WINAPI CaptureStackBackTrace_CET(
    _In_      ULONG  FramesToSkip,
    _In_      ULONG  FramesToCapture,
    _Out_     PVOID* BackTrace
)
{
    USHORT frameCount = 0;

    PVOID* pSSP = (PVOID*)GetSSP(GetCurrentThread());
    
    if (!pSSP)
    {
        printf("CET not supported\n");
        return 0;
    }

    // Based on:
    // https://github.com/yardenshafir/cet-research/blob/f97cfb131165cb524671dc9ff0dbd8dcedfbf2d1/src/KiVerifyContextIpForUserCet.c#L145-L153
    __try
    {
        for (size_t i = 0; i < FramesToCapture + FramesToSkip; i++)
        {
            if (!((ULONG_PTR)pSSP & 0xFFF)) // Don't cross page boundaries
            {
                break;
            }

            if (i >= FramesToSkip)
            {
                BackTrace[frameCount] = *pSSP;
                frameCount++;
            }
            
            pSSP++;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return frameCount;
}

USHORT WINAPI CaptureStackBackTrace_StackWalk64(
    _In_      ULONG  FramesToSkip,
    _In_      ULONG  FramesToCapture,
    _Out_     PVOID* BackTrace
)
{
    USHORT frameCount = 0;
    HANDLE hProcess = GetCurrentProcess();
    HANDLE hThread = GetCurrentThread();
    STACKFRAME64 stackFrame = { 0 };
    CONTEXT ctx = { 0, };

    SymInit(GetCurrentProcess());

    ctx.ContextFlags = CONTEXT_CONTROL;
    RtlCaptureContext(&ctx);

    stackFrame.AddrPC.Mode = AddrModeFlat;
    stackFrame.AddrPC.Offset = ctx.Rip;
    stackFrame.AddrStack.Mode = AddrModeFlat;
    stackFrame.AddrStack.Offset = ctx.Rsp;
    stackFrame.AddrFrame.Mode = AddrModeFlat;
    stackFrame.AddrFrame.Offset = ctx.Rbp;

    for (size_t i = 0; i < FramesToCapture + FramesToSkip; i++)
    {
        if (!StackWalk64(IMAGE_FILE_MACHINE_AMD64, hProcess, hThread, &stackFrame, &ctx, NULL, 0, 0, NULL))
        {
            break;
        }

        if (i >= FramesToSkip)
        {
            BackTrace[frameCount] = (PVOID)stackFrame.AddrPC.Offset;
            frameCount++;
        }
    }

    SymCleanup(GetCurrentProcess());

    return frameCount;
}

#define MAX_SYMBOL_LENGTH 32768
void PrintStackFrame(HANDLE hProcess, ULONG number, PVOID address)
{
    PSYMBOL_INFOW pSymInfo = (PSYMBOL_INFOW)alloca(sizeof(SYMBOL_INFOW) + MAX_SYMBOL_LENGTH);
    DWORD64 displacement = 0;
    MEMORY_BASIC_INFORMATION mbi = { 0, };
    std::wstring module;

    ZeroMemory(pSymInfo, sizeof(SYMBOL_INFOW) + MAX_SYMBOL_LENGTH);
    pSymInfo->SizeOfStruct = sizeof(*pSymInfo);
    pSymInfo->MaxNameLen = MAX_SYMBOL_LENGTH;

    VirtualQueryEx(hProcess, address, &mbi, sizeof(mbi));
    switch (mbi.Type)
    {
    case MEM_PRIVATE:
        module = L"UNBACKED";
        break;
    case MEM_MAPPED:
        module = L"MAPPED";
        break;
    case MEM_IMAGE:
        module.resize(USHRT_MAX);
        module.resize(GetMappedFileNameW(hProcess, address, &module[0], (DWORD)module.size()));
        if (module.empty())
        {
            module = L"UNKNOWNIMAGE";
        }
        break;
    default:
        module = L"UNKNOWN";
    }

    if (SymFromAddrW(hProcess, (DWORD64)address, &displacement, pSymInfo))
    {
        wprintf(L"%u: %ws!%ws + 0x%llx\n", number, module.c_str(), pSymInfo->Name, displacement);
    }
    else
    {
        wprintf(L"%u: %ws (%p)\n", number, module.c_str(), address);
    }
}

void PrintStackTrace(HANDLE hProcess, const std::vector<PVOID>& stack)
{
    SymInit(hProcess);

    for (ULONG i = 0; i < stack.size(); i++)
    {
        PrintStackFrame(hProcess, i, stack[i]);
    }

    SymCleanup(hProcess);
}

void Demo_CaptureStackBackTrace(const char * testName)
{
    std::vector<PVOID> csbt;
    std::vector<PVOID> cetFrames;
    std::vector<PVOID> sw64Frames;

    csbt.resize(64);
    csbt.resize(CaptureStackBackTrace(1, (DWORD)csbt.size(), &csbt[0], NULL));
    if (!csbt.empty())
    {
        printf("\n%s CaptureStackBackTrace: dps %p\n", testName, &csbt[0]);
        PrintStackTrace(GetCurrentProcess(), csbt);
    }

    sw64Frames.resize(64);
    sw64Frames.resize(CaptureStackBackTrace_StackWalk64(2, (DWORD)sw64Frames.size(), &sw64Frames[0]));
    if (!sw64Frames.empty())
    {
        printf("\n%s StackWalk64: dps %p\n", testName, &sw64Frames[0]);
        PrintStackTrace(GetCurrentProcess(), sw64Frames);
    }

    cetFrames.resize(64);
    cetFrames.resize(CaptureStackBackTrace_CET(4, (DWORD)cetFrames.size(), &cetFrames[0]));
    if (!cetFrames.empty())
    {
        printf("\n%s CET Stack: dps %p\n", testName, &cetFrames[0]);
        PrintStackTrace(GetCurrentProcess(), cetFrames);
    }


}

typedef void (callme_t)(const char* testName);

void SpoofStackThenCall(const char* testName, PVOID fakeCaller, callme_t callme)
{
    PVOID* pReturnAddress = (PVOID*)_AddressOfReturnAddress();
    PVOID savedReturnAddress = *pReturnAddress;

    *pReturnAddress = fakeCaller;

    callme(testName);

    *pReturnAddress = savedReturnAddress;
}

// Set *pReturnAddress to NULL to break stack walk
// Emulates https://github.com/mgeeky/ThreadStackSpoofer/blob/f67caea38a7acdb526eae3aac7c451a08edef6a9/ThreadStackSpoofer/main.cpp#L20-L25
#define BreakStackThenCall(_t, _callme) SpoofStackThenCall(_t, NULL, _callme)

int main(int argc, char* argv[])
{
    alloca(1);

    printf("ShadowStackWalk by Gabriel Landau @ Elastic Security\n");
    printf("Demonstrates the shadow stack's ability to detect and circumvent various forms of stack tampering.\n\n");


    printf("Control run demonstrating equivalent output...\n");

    Demo_CaptureStackBackTrace("CONTROL");

    printf("\n==========================================\n\n");

    printf("Breaking stack walk with a NULL return address...\n");

    // Break stack walking
    BreakStackThenCall("BROKEN", Demo_CaptureStackBackTrace);

    printf("\n==========================================\n\n");

    printf("Spoofing call stack to hide ShadowStackWalk.exe!main...\n");

    // Skip over main() in the callstack
    SpoofStackThenCall("SPOOFED", _ReturnAddress(), Demo_CaptureStackBackTrace);

    return 0;
}

```

`ShadowStackWalk/ShadowStackWalk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2b2b52ee-3587-496d-88ed-fec157ad96bb}</ProjectGuid>
    <RootNamespace>ShadowStackWalk</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>dbghelp.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <CETCompat>true</CETCompat>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>dbghelp.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <CETCompat>true</CETCompat>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ShadowStackWalk.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ShadowStackWalk/ShadowStackWalk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ShadowStackWalk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`ShadowStackWalk/ShadowStackWalk.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```