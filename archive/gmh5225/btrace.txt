Project Path: arc_gmh5225_btrace_ljnnz4f4

Source Tree:

```txt
arc_gmh5225_btrace_ljnnz4f4
├── BinderTransactionNameResolver
│   └── MyService
│       └── app
│           └── src
│               └── main
│                   ├── AndroidManifest.xml
│                   ├── assets
│                   │   └── service.list
│                   └── java
│                       └── com
│                           └── example
│                               └── myservice
│                                   ├── MainActivity.java
│                                   └── MyService.java
├── Makefile
├── README.md
├── binder_transaction.byte.c
├── btrace
├── config.json
├── doc
│   ├── BPF Ring Buffer Chunking.md
│   └── image
│       └── BPFRingBufferChunking
│           ├── 1717997795515.png
│           └── 1717997982951.png
├── go.mod
├── go.sum
├── headers
│   ├── LICENSE.BSD-2-Clause
│   ├── binder_transaction_data.h
│   ├── bpf_endian.h
│   ├── bpf_helper_defs.h
│   ├── bpf_helpers.h
│   ├── bpf_tracing.h
│   ├── common.h
│   └── update.sh
├── image
│   └── README
│       ├── 1717907826094.png
│       ├── 1717908085506.png
│       └── 1717908229782.png
├── main.go
├── method_resolver.go
├── methods.json
├── package_resolver.go
└── parcel_parser.go

```

`BinderTransactionNameResolver/MyService/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyService"
        tools:targetApi="31" >
        <!--设置activity为不显示-->
        <activity
            android:name=".MainActivity"
            android:theme="@android:style/Theme.NoDisplay"
            android:exported="true"
            >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <service
            android:name=".MyService"
            android:exported="false"
            android:foregroundServiceType="dataSync"
            tools:ignore="ForegroundServicePermission" />
    </application>
</manifest>
```

`BinderTransactionNameResolver/MyService/app/src/main/assets/service.list`:

```list
3       accessibility: [android.view.accessibility.IAccessibilityManager]
4       account: [android.accounts.IAccountManager]
5       activity: [android.app.IActivityManager]
6       activity_task: [android.app.IActivityTaskManager]
7       adb: [android.debug.IAdbManager]
8       adservices_manager: [android.app.adservices.IAdServicesManager]
9       alarm: [android.app.IAlarmManager]
62      android.service.gatekeeper.IGateKeeperService: [android.service.gatekeeper.IGateKeeperService]
63      android.system.keystore2.IKeystoreService/default: [android.system.keystore2.IKeystoreService]
64      android.system.net.netd.INetd/default: [android.system.net.netd.INetd]
65      android.system.suspend.ISystemSuspend/default: [android.system.suspend.ISystemSuspend]
67      app_hibernation: [android.apphibernation.IAppHibernationService]
68      app_integrity: [android.content.integrity.IAppIntegrityManager]
69      app_prediction: [android.app.prediction.IPredictionManager]
70      app_search: [android.app.appsearch.aidl.IAppSearchManager]
71      appops: [com.android.internal.app.IAppOpsService]
72      appwidget: [com.android.internal.appwidget.IAppWidgetService]
73      attestation_verification: [android.security.attestationverification.IAttestationVerificationManagerService]
74      audio: [android.media.IAudioService]
75      auth: [android.hardware.biometrics.IAuthService]
76      autofill: [android.view.autofill.IAutoFillManager]
77      background_install_control: [android.content.pm.IBackgroundInstallControlService]
78      backup: [android.app.backup.IBackupManager]
80      batteryproperties: [android.os.IBatteryPropertiesRegistrar]
81      batterystats: [com.android.internal.app.IBatteryStats]
83      biometric: [android.hardware.biometrics.IBiometricService]
84      blob_store: [android.app.blob.IBlobStoreManager]
85      bluetooth_manager: [android.bluetooth.IBluetoothManager]
86      bugreport: [android.os.IDumpstate]
88      carrier_config: [com.android.internal.telephony.ICarrierConfigLoader]
89      clipboard: [android.content.IClipboard]
90      color_display: [android.hardware.display.IColorDisplayManager]
91      companiondevice: [android.companion.ICompanionDeviceManager]
92      connectivity: [android.net.IConnectivityManager]
93      connectivity_native: [android.net.connectivity.aidl.ConnectivityNative]
94      connmetrics: [android.net.IIpConnectivityMetrics]
95      content: [android.content.IContentService]
96      content_capture: [android.view.contentcapture.IContentCaptureManager]
97      content_suggestions: [android.app.contentsuggestions.IContentSuggestionsManager]
98      country_detector: [android.location.ICountryDetector]
101     credential: [android.credentials.ICredentialManager]
102     crossprofileapps: [android.content.pm.ICrossProfileApps]
103     dataloader_manager: [android.content.pm.IDataLoaderManager]
104     dbinfo: []
105     device_config: []
106     device_identifiers: [android.os.IDeviceIdentifiersPolicyService]
107     device_lock: [android.devicelock.IDeviceLockService]
108     device_policy: [android.app.admin.IDevicePolicyManager]
109     device_state: [android.hardware.devicestate.IDeviceStateManager]
110     deviceidle: [android.os.IDeviceIdleController]
111     devicestoragemonitor: []
112     diskstats: []
113     display: [android.hardware.display.IDisplayManager]
114     dnsresolver: [android.net.IDnsResolver]
115     domain_verification: [android.content.pm.verify.domain.IDomainVerificationManager]
116     dreams: [android.service.dreams.IDreamManager]
117     drm.drmManager: [drm.IDrmManagerService]
118     dropbox: [com.android.internal.os.IDropBoxManagerService]
119     dynamic_system: [android.os.image.IDynamicSystemService]
120     emergency_affordance: []
121     external_vibrator_service: [android.os.IExternalVibratorService]
122     face: [android.hardware.face.IFaceService]
123     file_integrity: [android.security.IFileIntegrityService]
124     fingerprint: [android.hardware.fingerprint.IFingerprintService]
125     font: [com.android.internal.graphics.fonts.IFontManager]
126     game: [android.app.IGameManagerService]
127     gfxinfo: []
128     gpu: [android.graphicsenv.IGpuService]
129     grammatical_inflection: [android.app.IGrammaticalInflectionManager]
130     graphicsstats: [android.view.IGraphicsStats]
131     hardware_properties: [android.os.IHardwarePropertiesManager]
132     healthconnect: [android.health.connect.aidl.IHealthConnectService]
133     imms: [com.android.internal.telephony.IMms]
134     incident: [android.os.IIncidentManager]
135     incidentcompanion: [android.os.IIncidentCompanion]
136     incremental: [android.os.incremental.IIncrementalService]
137     input: [android.hardware.input.IInputManager]
138     input_method: [com.android.internal.view.IInputMethodManager]
139     inputflinger: [android.os.IInputFlinger]
140     installd: [android.os.IInstalld]
141     ions: [com.android.internal.telephony.IOns]
142     iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo]
143     ipsec: [android.net.IIpSecService]
144     isms: [com.android.internal.telephony.ISms]
145     isub: [com.android.internal.telephony.ISub]
146     jobscheduler: [android.app.job.IJobScheduler]
147     launcherapps: [android.content.pm.ILauncherApps]
148     legacy_permission: [android.permission.ILegacyPermissionManager]
149     lights: [android.hardware.lights.ILightsManager]
150     locale: [android.app.ILocaleManager]
151     location: [android.location.ILocationManager]
152     location_time_zone_manager: []
153     lock_settings: [com.android.internal.widget.ILockSettings]
154     logcat: [android.os.logcat.ILogcatManagerService]
155     looper_stats: []
156     manager: [android.os.IServiceManager]
157     mdns: [android.net.mdns.aidl.IMDns]
158     media.audio_flinger: [android.media.IAudioFlingerService]
159     media.audio_policy: [android.media.IAudioPolicyService]
160     media.camera: [android.hardware.ICameraService]
161     media.camera.proxy: [android.hardware.ICameraServiceProxy]
162     media.extractor: [android.IMediaExtractorService]
163     media.metrics: [android.media.IMediaMetricsService]
164     media.player: [android.media.IMediaPlayerService]
165     media.resource_manager: [android.media.IResourceManagerService]
166     media.resource_observer: [android.media.IResourceObserverService]
167     media_communication: [android.media.IMediaCommunicationService]
168     media_metrics: [android.media.metrics.IMediaMetricsManager]
169     media_projection: [android.media.projection.IMediaProjectionManager]
170     media_resource_monitor: [android.media.IMediaResourceMonitor]
171     media_router: [android.media.IMediaRouterService]
172     media_session: [android.media.session.ISessionManager]
174     memtrack.proxy: [android.hardware.memtrack.IMemtrack]
175     midi: [android.media.midi.IMidiManager]
176     mount: [android.os.storage.IStorageManager]
177     music_recognition: [android.media.musicrecognition.IMusicRecognitionManager]
178     nearby: [android.nearby.INearbyManager]
179     netd: [android.net.INetd]
180     netd_listener: [android.net.metrics.INetdEventListener]
181     netpolicy: [android.net.INetworkPolicyManager]
182     netstats: [android.net.INetworkStatsService]
183     network_management: [android.os.INetworkManagementService]
184     network_score: [android.net.INetworkScoreService]
185     network_stack: [android.net.INetworkStackConnector]
186     network_time_update_service: []
187     network_watchlist: [com.android.internal.net.INetworkWatchlistManager]
188     notification: [android.app.INotificationManager]
189     ondevicepersonalization_system_service: [android.app.ondevicepersonalization.IOnDevicePersonalizationSystemService]
190     otadexopt: [android.content.pm.IOtaDexopt]
191     overlay: [android.content.om.IOverlayManager]
192     pac_proxy: [android.net.IPacProxyManager]
193     package: [android.content.pm.IPackageManager]
194     package_native: [android.content.pm.IPackageManagerNative]
195     people: [android.app.people.IPeopleManager]
196     performance_hint: [android.os.IHintManager]
197     permission: [android.os.IPermissionController]
198     permission_checker: [android.permission.IPermissionChecker]
199     permissionmgr: [android.permission.IPermissionManager]
200     phone: [com.android.internal.telephony.ITelephony]
201     pinner: []
202     platform_compat: [com.android.internal.compat.IPlatformCompat]
203     platform_compat_native: [com.android.internal.compat.IPlatformCompatNative]
204     power: [android.os.IPowerManager]
205     powerstats: []
206     print: [android.print.IPrintManager]
207     processinfo: [android.os.IProcessInfoService]
208     procstats: [com.android.internal.app.procstats.IProcessStats]
209     reboot_readiness: [android.scheduling.IRebootReadinessManager]
210     recovery: [android.os.IRecoverySystem]
211     remote_provisioning: [android.security.rkp.IRemoteProvisioning]
212     resources: [android.content.res.IResourcesManager]
213     restrictions: [android.content.IRestrictionsManager]
214     role: [android.app.role.IRoleManager]
215     rollback: [android.content.rollback.IRollbackManager]
217     safety_center: [android.safetycenter.ISafetyCenterManager]
218     scheduling_policy: [android.os.ISchedulingPolicyService]
219     sdk_sandbox: [android.app.sdksandbox.ISdkSandboxManager]
220     search: [android.app.ISearchManager]
221     search_ui: [android.app.search.ISearchUiManager]
222     sec_key_att_app_id_provider: [android.security.keymaster.IKeyAttestationApplicationIdProvider]
223     secure_element: [android.se.omapi.ISecureElementService]
224     selection_toolbar: [android.view.selectiontoolbar.ISelectionToolbarManager]
225     sensor_privacy: [android.hardware.ISensorPrivacyManager]
226     sensorservice: [android.gui.SensorServer]
227     serial: [android.hardware.ISerialManager]
228     servicediscovery: [android.net.nsd.INsdManager]
229     settings: []
230     shortcut: [android.content.pm.IShortcutService]
231     simphonebook: [com.android.internal.telephony.IIccPhoneBook]
232     slice: [android.app.slice.ISliceManager]
233     smartspace: [android.app.smartspace.ISmartspaceManager]
234     soundtrigger: [com.android.internal.app.ISoundTriggerService]
235     soundtrigger_middleware: [android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService]
236     speech_recognition: [android.speech.IRecognitionServiceManager]
237     stats: [android.os.IStatsd]
238     statsbootstrap: [android.os.IStatsBootstrapAtomService]
239     statscompanion: [android.os.IStatsCompanionService]
240     statsmanager: [android.os.IStatsManagerService]
241     statusbar: [com.android.internal.statusbar.IStatusBarService]
242     storaged: [android.os.IStoraged]
243     storaged_pri: [android.os.storaged.IStoragedPrivate]
244     storagestats: [android.app.usage.IStorageStatsManager]
245     suspend_control: [android.system.suspend.ISuspendControlService]
246     suspend_control_internal: [android.system.suspend.internal.ISuspendControlServiceInternal]
247     system_config: [android.os.ISystemConfig]
248     system_server_dumper: []
249     system_update: [android.os.ISystemUpdateManager]
250     tare: [android.app.tare.IEconomyManager]
251     telecom: [com.android.internal.telecom.ITelecomService]
252     telephony.registry: [com.android.internal.telephony.ITelephonyRegistry]
253     telephony_ims: [android.telephony.ims.aidl.IImsRcsController]
254     testharness: []
255     tethering: [android.net.ITetheringConnector]
256     textclassification: [android.service.textclassifier.ITextClassifierService]
257     textservices: [com.android.internal.textservice.ITextServicesManager]
258     texttospeech: [android.speech.tts.ITextToSpeechManager]
259     thermalservice: [android.os.IThermalService]
260     time_detector: [android.app.timedetector.ITimeDetectorService]
261     time_zone_detector: [android.app.timezonedetector.ITimeZoneDetectorService]
262     tracing.proxy: [android.tracing.ITracingServiceProxy]
263     translation: [android.view.translation.ITranslationManager]
264     transparency: [com.android.internal.os.IBinaryTransparencyService]
265     trust: [android.app.trust.ITrustManager]
266     uimode: [android.app.IUiModeManager]
267     updatelock: [android.os.IUpdateLock]
268     uri_grants: [android.app.IUriGrantsManager]
269     usagestats: [android.app.usage.IUsageStatsManager]
270     usb: [android.hardware.usb.IUsbManager]
271     user: [android.os.IUserManager]
272     vcn_management: [android.net.vcn.IVcnManagementService]
273     vibrator_manager: [android.os.IVibratorManagerService]
274     virtualdevice: [android.companion.virtual.IVirtualDeviceManager]
275     voiceinteraction: [com.android.internal.app.IVoiceInteractionManagerService]
276     vold: [android.os.IVold]
277     vpn_management: [android.net.IVpnManager]
278     wallpaper: [android.app.IWallpaperManager]
279     wallpaper_effects_generation: [android.app.wallpapereffectsgeneration.IWallpaperEffectsGenerationManager]
280     wearable_sensing: [android.app.wearable.IWearableSensingManager]
281     webviewupdate: [android.webkit.IWebViewUpdateService]
282     wifi: [android.net.wifi.IWifiManager]
283     wifinl80211: [android.net.wifi.nl80211.IWificond]
284     wifip2p: [android.net.wifi.p2p.IWifiP2pManager]
285     wifiscanner: [android.net.wifi.IWifiScanner]
286     window: [android.view.IWindowManager]

```

`BinderTransactionNameResolver/MyService/app/src/main/java/com/example/myservice/MainActivity.java`:

```java
package com.example.myservice;
import android.app.Activity;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //启动service
        //Intent service = new Intent(MainActivity.this, MyService.class);
        //MainActivity.this.startForegroundService(service);


        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            MainActivity.this.startForegroundService(new Intent(MainActivity.this, MyService.class));
        } else {
            MainActivity.this.startService(new Intent(MainActivity.this, MyService.class));
        }

    }

    //8.0以上手机需要添加此代码才能正常运行
    public void onResume() {
        super.onResume();
        finish();
    }
}
```

`BinderTransactionNameResolver/MyService/app/src/main/java/com/example/myservice/MyService.java`:

```java
package com.example.myservice;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.IBinder;
import android.util.Log;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MyService extends Service {
    private static final int NOTIFICATION_ID = 1;
    private static final String channelId = "my_channel_id";
    private static final String channelName = "my_channel_name";

    private Map<Integer, String> getMethodNames(String serviceName) {
        Map<Integer, String> methodNames = new HashMap<>();
        try {
            Class<?> aClass = Class.forName(serviceName + "$Stub");
            Field[] fields = aClass.getDeclaredFields();

            @SuppressLint("PrivateApi") Class<?> bClass = Class.forName("com.android.internal.os.BinderTransactionNameResolver");
            Method method = bClass.getMethod("getMethodName", Class.class, int.class);
            Object instance = bClass.newInstance();
            for (int i = 1; i <= fields.length; i++) {
                String fullMethodName = null;
                String transactionName = (String) method.invoke(instance,aClass,i);
                if(transactionName != null){
                    for(Method m : aClass.getMethods()) {
                        if (m.getName().equals(transactionName)) {
                            StringBuilder stringBuilder = new StringBuilder();
                            stringBuilder.append(m.getReturnType().getName());
                            stringBuilder.append(" ");
                            stringBuilder.append(transactionName);
                            stringBuilder.append("(");

                            Class<?>[] paramTypes = m.getParameterTypes();
                            for (int j = 0; j < paramTypes.length; j++) {
                                stringBuilder.append(paramTypes[j].getName());
                                if (j < paramTypes.length - 1) {
                                    stringBuilder.append(", ");
                                }
                            }

                            stringBuilder.append(")");
                            fullMethodName = stringBuilder.toString();
                            methodNames.put(i, fullMethodName);
                            break;
                        }
                    }
                    if (fullMethodName == null) {
                        Log.d("null-luo", transactionName);
                        methodNames.put(i, transactionName);
                    }
                }
            }
        } catch (ClassNotFoundException e) {
            return methodNames;
        } catch (InvocationTargetException | InstantiationException | IllegalAccessException |
                NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
        return methodNames;
    }

    private Notification createNotification() {
        Notification.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            // 创建通知渠道
            NotificationChannel channel = new NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW);
            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            manager.createNotificationChannel(channel);

            builder = new Notification.Builder(this, channelId);
        } else {
            builder = new Notification.Builder(this);
        }

        // 设置通知内容
        builder.setContentTitle("My Service")
                .setContentText("Service is running in foreground")
                .setSmallIcon(R.drawable.my_ic_notification)
                .setAutoCancel(false)
                .setOngoing(true);

        return builder.build();
    }

    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        Log.e("null-luo", "MyService onBind");
        return null;
    }

    @Override
    public void onCreate() {
        Log.v("null-luo", "MyService onCreate");
        super.onCreate();
    }

    @Override
    public void onStart(Intent intent, int startId) {
        Log.v("null-luo", "MyService onStart");
        super.onStart(intent, startId);
    }

    @SuppressLint("ForegroundServiceType")
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.v("null-luo", "MyService onStartCommand");

        try {
            Notification notification = createNotification();
            startForeground(NOTIFICATION_ID, notification);

            HashMap<String, Map<Integer, String>> resultMap = new HashMap<>();;
            InputStream is = getAssets().open("service.list");
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            Pattern pattern = Pattern.compile(".*\\[(.*)]");
            String line;
            while ((line = reader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line);
                if (matcher.find()) {
                    String serviceName = matcher.group(1);
                    if(!Objects.equals(serviceName, "")){
                        Map<Integer, String> serviceMap = getMethodNames(serviceName);
                        if(serviceMap!=null && !serviceMap.isEmpty()){
                            resultMap.put(serviceName, serviceMap);
                        }
                    }
                }
            }

            JSONObject root = new JSONObject();
            Iterator<Map.Entry<String, Map<Integer, String>>> it = resultMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry<String, Map<Integer, String>> entry = it.next();
                String key = entry.getKey();
                Map<Integer, String> innerMap = entry.getValue();
                JSONObject subObject = new JSONObject();
                Iterator<Map.Entry<Integer, String>> innerIt = innerMap.entrySet().iterator();
                while (innerIt.hasNext()) {
                    Map.Entry<Integer, String> innerEntry = innerIt.next();
                    subObject.put(String.valueOf(innerEntry.getKey()), innerEntry.getValue());
                }
                root.put(key, subObject);
            }
            String jsonString = root.toString(2);
            //System.out.println(jsonString);

            FileOutputStream fos = null;
            fos = openFileOutput("methods.json", Context.MODE_PRIVATE);
            fos.write(jsonString.getBytes());

            Log.v("null-luo", "MyService Done");

        } catch (IOException | JSONException e) {
            throw new RuntimeException(e);
        }

        return super.onStartCommand(intent, flags, startId);
    }
}

```

`Makefile`:

```
GO_RUN = go run github.com/cilium/ebpf/cmd/bpf2go
GO_MOD_TIDY = go mod tidy
GO_BUILD = go build
TARGET = arm64
PACKAGE = main
TYPE1 = trace_event
TYPE2 = trace_config
BPF_FILE = binder_transaction.byte.c
HEADERS = ./headers
BPF_OUTPUT = bpf
BINARY_NAME = btrace

all: bpf tidy build

bpf:
	$(GO_RUN) -go-package $(PACKAGE) --target=$(TARGET) -type $(TYPE1) -type $(TYPE2) $(BPF_OUTPUT) $(BPF_FILE) -- -I$(HEADERS)

tidy:
	$(GO_MOD_TIDY)

build: tidy
	$(GO_BUILD)

clean:
	rm -f $(BPF_OUTPUT)_$(TARGET)_bpfel.go $(BPF_OUTPUT)_$(TARGET)_bpfel.o $(BINARY_NAME)

.PHONY: all bpf tidy build clean

```

`README.md`:

```md
# btrace

## 简介

btrace：binder_transaction+eBPF+Golang实现通用的Android APP动态行为追踪工具。

方案说明：https://bbs.kanxue.com/thread-281895.htm

## 编译

ARM64的Linux环境中，需要先安装Golang开发环境，然后：

git clone https://github.com/null-luo/btrace.git

cd btrace

make

![1717907826094](image/README/1717907826094.png)

## 运行

真机或者ARM模拟器都可以：

adb push btrace /data/local/tmp

chmod +x btrace

./btrace

![1717908085506](image/README/1717908085506.png)

![1717908229782](image/README/1717908229782.png)

```

`binder_transaction.byte.c`:

```c
//go:build ignore

#include "common.h"
#include "bpf_tracing.h"
#include "binder_transaction_data.h"

char __license[] SEC("license") = "Dual MIT/GPL";

#define CHUNK_SIZE 0x400
#define MAX_CHUNKS 16

struct trace_event {
    u32 pid;
    u32 uid;
    u32 code;
    u32 flags;
    u64 data_size;
    u64 transaction_id;
    u64 chunk_index;
    u8 chunk_data[CHUNK_SIZE];
};

struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 1 << 24);
} trace_event_map SEC(".maps");

struct trace_config {
    u32 uid;
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(struct trace_config));
    __uint(max_entries, 1);
} trace_config_map SEC(".maps");

static __always_inline u64 get_transaction_id() {
    u64 id = bpf_ktime_get_ns();
    return id;
}

// Force emitting struct event into the ELF.
const struct trace_event *unused_trace_event __attribute__((unused));
const struct trace_config *unused_trace_config __attribute__((unused));

SEC("kprobe/binder_transaction")
int kprobe_binder_transaction(struct pt_regs *ctx) {

    u32 config_key = 0;
    struct trace_config* conf = bpf_map_lookup_elem(&trace_config_map, &config_key);
    if (conf == NULL) {
        return 0;
    }

    int reply = PT_REGS_PARM4(ctx);
    if (reply) {
        return 0;
    }

    struct binder_transaction_data *tr = (struct binder_transaction_data *)PT_REGS_PARM3(ctx);
    if (!tr) {
        bpf_printk("kprobe_binder_transaction error: tr is null");
        return 0;
    }

    u32 current_uid = bpf_get_current_uid_gid() >> 32;
    if ((conf->uid != 0) && (conf->uid != current_uid)) {
        return 0;
    }

	u32 current_pid = bpf_get_current_pid_tgid() >> 32;
    u64 transaction_id = get_transaction_id();

    u32 code;
    u32 flags;
    u64 data_size;
    bpf_probe_read(&code, sizeof(__u32), &(tr->code));
    bpf_probe_read(&flags, sizeof(__u32), &(tr->flags));
    bpf_probe_read(&data_size, sizeof(binder_size_t), &(tr->data_size));

    union {
        struct {
            binder_uintptr_t buffer;
            binder_uintptr_t offsets;
        } ptr;
        __u8 buf[8];
    } data;
    bpf_probe_read(&data, sizeof(data), &(tr->data));

    u32 total_chunks = (data_size + CHUNK_SIZE - 1) / CHUNK_SIZE;

    if (total_chunks > MAX_CHUNKS) {
        bpf_printk("kprobe_binder_transaction error: data size is too long：%d",data_size);
		return 0;
    }

    for (u32 i = 0; i < MAX_CHUNKS; i++) {

		if (i >= total_chunks) {
			return 0;
    	}

        struct trace_event *binder_transaction_event = bpf_ringbuf_reserve(&trace_event_map, sizeof(struct trace_event), 0);
		
        if (!binder_transaction_event) {
            bpf_printk("kprobe_binder_transaction error: failed to reserve ring buffer space");
            return 0;
        }
		
        binder_transaction_event->pid = current_pid;
        binder_transaction_event->uid = current_uid;
        binder_transaction_event->code = code;
        binder_transaction_event->flags = flags;
        binder_transaction_event->data_size = data_size;
        binder_transaction_event->transaction_id = transaction_id;
        binder_transaction_event->chunk_index = i;
		
        u64 chunk_size = ((i + 1) * CHUNK_SIZE > data_size) ? (data_size - i * CHUNK_SIZE) : CHUNK_SIZE;
		unsigned probe_read_size = chunk_size < sizeof(binder_transaction_event->chunk_data) ? chunk_size : sizeof(binder_transaction_event->chunk_data);
        bpf_probe_read_user(binder_transaction_event->chunk_data, probe_read_size, (void *)(data.ptr.buffer + i * CHUNK_SIZE));

		//bpf_printk("kprobe_binder_transaction: transaction_id=%lx,data_size=%d,probe_read_size=%d",transaction_id,data_size,probe_read_size);

        bpf_ringbuf_submit(binder_transaction_event, 0);
    }

    return 0;
}

```

`config.json`:

```json
{
    "customMethods": {
        "android.content.pm.IBackgroundInstallControlService": {
            "1": "android.content.pm.ParceledListSlice getBackgroundInstalledPackages(long, int)"
          },
          "android.net.nsd.INsdManager": {
            "1": "android.net.connectivity.android.net.nsd.INsdServiceConnector connect(android.net.connectivity.android.net.nsd.INsdManagerCallback, boolean)"
          }
    },

    "filters": [
        {
            "interface": "com.google.hardware.pixel.display.IDisplay",
            "method": ""
        },
        {
            "interface": "android.gui.IDisplayEventConnection",
            "method": ""
        },
        {
            "interface": "android.os.IMessenger",
            "method": ""
        }
    ]

}
```

`doc/BPF Ring Buffer Chunking.md`:

```md
# BPF Ring Buffer Chunking

在我们的场景里，BPF程序需要将hook到的数据发送到用户空间，BPF perf buffer是一个选择，但它存在一些问题，例如浪费内存、事件顺序无法保证等，所以我们倾向于使用内核5.8引入的另一个新的BPF 数据结构：BPF ring buffer（环形缓冲区），它提供了一套新的reserve/commit API（先预留再提交），内存效率更高，且能保证事件顺序。

可是BPF ring buffer的reserve/commit API有一个限制：BPF 校验器在校验时必须知道预留数据的大小，因此不支持动态大小的事件数据。所以在btrace的v1.0.0版本里我们使用了固定大小的事件结构：

![1717997795515](image/BPFRingBufferChunking/1717997795515.png)

但这样既浪费空间（很多事件里的data远小于0x2000），又不能完整传递数据（有的事件里的data大于0x2000）。

在btrace的v1.1.0版本里，我们进行了改进，在ebpf程序里对大块的data进行分片处理，每个分片带上一个事件唯一标识transaction_id，然后通过BPF ring buffer传送到用户空间，用户空间根据transaction_id来汇聚和重组分片。

但是BPF verifier为了保证 BPF 程序的所有操作必须在有限时间（bounded time）内完成，所以不支持动态次数的循环（5.17内核已经支持 `bpf_loop()`特性，但是我手上的手机和PC都是5.15的内核），所以我们只能在程序里手动限定循环次数（MAX_CHUNKS）：

![1717997982951](image/BPFRingBufferChunking/1717997982951.png)

```

`go.mod`:

```mod
module btrace

go 1.22.2

require (
	github.com/cilium/ebpf v0.15.0
	github.com/davecgh/go-spew v1.1.1
)

require (
	golang.org/x/exp v0.0.0-20230224173230-c95f2b4c22f2 // indirect
	golang.org/x/sys v0.15.0 // indirect
)

```

`go.sum`:

```sum
github.com/cilium/ebpf v0.15.0 h1:7NxJhNiBT3NG8pZJ3c+yfrVdHY8ScgKD27sScgjLMMk=
github.com/cilium/ebpf v0.15.0/go.mod h1:DHp1WyrLeiBh19Cf/tfiSMhqheEiK8fXFZ4No0P1Hso=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-quicktest/qt v1.101.0 h1:O1K29Txy5P2OK0dGo59b7b0LR6wKfIhttaAhHUyn7eI=
github.com/go-quicktest/qt v1.101.0/go.mod h1:14Bz/f7NwaXPtdYEgzsx46kqSxVwTbzVZsDC26tQJow=
github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=
github.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=
golang.org/x/exp v0.0.0-20230224173230-c95f2b4c22f2 h1:Jvc7gsqn21cJHCmAWx0LiimpP18LZmUxkT5Mp7EZ1mI=
golang.org/x/exp v0.0.0-20230224173230-c95f2b4c22f2/go.mod h1:CxIveKay+FTh1D0yPZemJVgC/95VzuuOLq5Qi4xnoYc=
golang.org/x/sys v0.15.0 h1:h48lPFYpsTvQJZF4EKyI4aLHaev3CxivZmv7yZig9pc=
golang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=

```

`headers/LICENSE.BSD-2-Clause`:

```BSD-2-Clause
Valid-License-Identifier: BSD-2-Clause
SPDX-URL: https://spdx.org/licenses/BSD-2-Clause.html
Usage-Guide:
  To use the BSD 2-clause "Simplified" License put the following SPDX
  tag/value pair into a comment according to the placement guidelines in
  the licensing rules documentation:
    SPDX-License-Identifier: BSD-2-Clause
License-Text:

Copyright (c) <year> <owner> . All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

```

`headers/binder_transaction_data.h`:

```h
typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef __u64 binder_uintptr_t;

typedef __u64 binder_size_t;

struct binder_transaction_data {
	union {
		__u32 handle;
		binder_uintptr_t ptr;
	} target;
	binder_uintptr_t cookie;
	__u32 code;
	__u32 flags;
	__kernel_pid_t sender_pid;
	__kernel_uid32_t sender_euid;
	binder_size_t data_size;
	binder_size_t offsets_size;
	union {
		struct {
			binder_uintptr_t buffer;
			binder_uintptr_t offsets;
		} ptr;
		__u8 buf[8];
	} data;
};

```

`headers/bpf_endian.h`:

```h
/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
#ifndef __BPF_ENDIAN__
#define __BPF_ENDIAN__

/*
 * Isolate byte #n and put it into byte #m, for __u##b type.
 * E.g., moving byte #6 (nnnnnnnn) into byte #1 (mmmmmmmm) for __u64:
 * 1) xxxxxxxx nnnnnnnn xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx mmmmmmmm xxxxxxxx
 * 2) nnnnnnnn xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx mmmmmmmm xxxxxxxx 00000000
 * 3) 00000000 00000000 00000000 00000000 00000000 00000000 00000000 nnnnnnnn
 * 4) 00000000 00000000 00000000 00000000 00000000 00000000 nnnnnnnn 00000000
 */
#define ___bpf_mvb(x, b, n, m) ((__u##b)(x) << (b-(n+1)*8) >> (b-8) << (m*8))

#define ___bpf_swab16(x) ((__u16)(			\
			  ___bpf_mvb(x, 16, 0, 1) |	\
			  ___bpf_mvb(x, 16, 1, 0)))

#define ___bpf_swab32(x) ((__u32)(			\
			  ___bpf_mvb(x, 32, 0, 3) |	\
			  ___bpf_mvb(x, 32, 1, 2) |	\
			  ___bpf_mvb(x, 32, 2, 1) |	\
			  ___bpf_mvb(x, 32, 3, 0)))

#define ___bpf_swab64(x) ((__u64)(			\
			  ___bpf_mvb(x, 64, 0, 7) |	\
			  ___bpf_mvb(x, 64, 1, 6) |	\
			  ___bpf_mvb(x, 64, 2, 5) |	\
			  ___bpf_mvb(x, 64, 3, 4) |	\
			  ___bpf_mvb(x, 64, 4, 3) |	\
			  ___bpf_mvb(x, 64, 5, 2) |	\
			  ___bpf_mvb(x, 64, 6, 1) |	\
			  ___bpf_mvb(x, 64, 7, 0)))

/* LLVM's BPF target selects the endianness of the CPU
 * it compiles on, or the user specifies (bpfel/bpfeb),
 * respectively. The used __BYTE_ORDER__ is defined by
 * the compiler, we cannot rely on __BYTE_ORDER from
 * libc headers, since it doesn't reflect the actual
 * requested byte order.
 *
 * Note, LLVM's BPF target has different __builtin_bswapX()
 * semantics. It does map to BPF_ALU | BPF_END | BPF_TO_BE
 * in bpfel and bpfeb case, which means below, that we map
 * to cpu_to_be16(). We could use it unconditionally in BPF
 * case, but better not rely on it, so that this header here
 * can be used from application and BPF program side, which
 * use different targets.
 */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
# define __bpf_ntohs(x)			__builtin_bswap16(x)
# define __bpf_htons(x)			__builtin_bswap16(x)
# define __bpf_constant_ntohs(x)	___bpf_swab16(x)
# define __bpf_constant_htons(x)	___bpf_swab16(x)
# define __bpf_ntohl(x)			__builtin_bswap32(x)
# define __bpf_htonl(x)			__builtin_bswap32(x)
# define __bpf_constant_ntohl(x)	___bpf_swab32(x)
# define __bpf_constant_htonl(x)	___bpf_swab32(x)
# define __bpf_be64_to_cpu(x)		__builtin_bswap64(x)
# define __bpf_cpu_to_be64(x)		__builtin_bswap64(x)
# define __bpf_constant_be64_to_cpu(x)	___bpf_swab64(x)
# define __bpf_constant_cpu_to_be64(x)	___bpf_swab64(x)
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
# define __bpf_ntohs(x)			(x)
# define __bpf_htons(x)			(x)
# define __bpf_constant_ntohs(x)	(x)
# define __bpf_constant_htons(x)	(x)
# define __bpf_ntohl(x)			(x)
# define __bpf_htonl(x)			(x)
# define __bpf_constant_ntohl(x)	(x)
# define __bpf_constant_htonl(x)	(x)
# define __bpf_be64_to_cpu(x)		(x)
# define __bpf_cpu_to_be64(x)		(x)
# define __bpf_constant_be64_to_cpu(x)  (x)
# define __bpf_constant_cpu_to_be64(x)  (x)
#else
# error "Fix your compiler's __BYTE_ORDER__?!"
#endif

#define bpf_htons(x)				\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_htons(x) : __bpf_htons(x))
#define bpf_ntohs(x)				\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_ntohs(x) : __bpf_ntohs(x))
#define bpf_htonl(x)				\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_htonl(x) : __bpf_htonl(x))
#define bpf_ntohl(x)				\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_ntohl(x) : __bpf_ntohl(x))
#define bpf_cpu_to_be64(x)			\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_cpu_to_be64(x) : __bpf_cpu_to_be64(x))
#define bpf_be64_to_cpu(x)			\
	(__builtin_constant_p(x) ?		\
	 __bpf_constant_be64_to_cpu(x) : __bpf_be64_to_cpu(x))

#endif /* __BPF_ENDIAN__ */

```

`headers/bpf_helper_defs.h`:

```h
/* This is auto-generated file. See bpf_doc.py for details. */

/* Forward declarations of BPF structs */
struct bpf_fib_lookup;
struct bpf_sk_lookup;
struct bpf_perf_event_data;
struct bpf_perf_event_value;
struct bpf_pidns_info;
struct bpf_redir_neigh;
struct bpf_sock;
struct bpf_sock_addr;
struct bpf_sock_ops;
struct bpf_sock_tuple;
struct bpf_spin_lock;
struct bpf_sysctl;
struct bpf_tcp_sock;
struct bpf_tunnel_key;
struct bpf_xfrm_state;
struct linux_binprm;
struct pt_regs;
struct sk_reuseport_md;
struct sockaddr;
struct tcphdr;
struct seq_file;
struct tcp6_sock;
struct tcp_sock;
struct tcp_timewait_sock;
struct tcp_request_sock;
struct udp6_sock;
struct unix_sock;
struct task_struct;
struct __sk_buff;
struct sk_msg_md;
struct xdp_md;
struct path;
struct btf_ptr;
struct inode;
struct socket;
struct file;
struct bpf_timer;

/*
 * bpf_map_lookup_elem
 *
 * 	Perform a lookup in *map* for an entry associated to *key*.
 *
 * Returns
 * 	Map value associated to *key*, or **NULL** if no entry was
 * 	found.
 */
static void *(*bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;

/*
 * bpf_map_update_elem
 *
 * 	Add or update the value of the entry associated to *key* in
 * 	*map* with *value*. *flags* is one of:
 *
 * 	**BPF_NOEXIST**
 * 		The entry for *key* must not exist in the map.
 * 	**BPF_EXIST**
 * 		The entry for *key* must already exist in the map.
 * 	**BPF_ANY**
 * 		No condition on the existence of the entry for *key*.
 *
 * 	Flag value **BPF_NOEXIST** cannot be used for maps of types
 * 	**BPF_MAP_TYPE_ARRAY** or **BPF_MAP_TYPE_PERCPU_ARRAY**  (all
 * 	elements always exist), the helper would return an error.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags) = (void *) 2;

/*
 * bpf_map_delete_elem
 *
 * 	Delete entry with *key* from *map*.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_map_delete_elem)(void *map, const void *key) = (void *) 3;

/*
 * bpf_probe_read
 *
 * 	For tracing programs, safely attempt to read *size* bytes from
 * 	kernel space address *unsafe_ptr* and store the data in *dst*.
 *
 * 	Generally, use **bpf_probe_read_user**\ () or
 * 	**bpf_probe_read_kernel**\ () instead.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_probe_read)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 4;

/*
 * bpf_ktime_get_ns
 *
 * 	Return the time elapsed since system boot, in nanoseconds.
 * 	Does not include time the system was suspended.
 * 	See: **clock_gettime**\ (**CLOCK_MONOTONIC**)
 *
 * Returns
 * 	Current *ktime*.
 */
static __u64 (*bpf_ktime_get_ns)(void) = (void *) 5;

/*
 * bpf_trace_printk
 *
 * 	This helper is a "printk()-like" facility for debugging. It
 * 	prints a message defined by format *fmt* (of size *fmt_size*)
 * 	to file *\/sys/kernel/debug/tracing/trace* from DebugFS, if
 * 	available. It can take up to three additional **u64**
 * 	arguments (as an eBPF helpers, the total number of arguments is
 * 	limited to five).
 *
 * 	Each time the helper is called, it appends a line to the trace.
 * 	Lines are discarded while *\/sys/kernel/debug/tracing/trace* is
 * 	open, use *\/sys/kernel/debug/tracing/trace_pipe* to avoid this.
 * 	The format of the trace is customizable, and the exact output
 * 	one will get depends on the options set in
 * 	*\/sys/kernel/debug/tracing/trace_options* (see also the
 * 	*README* file under the same directory). However, it usually
 * 	defaults to something like:
 *
 * 	::
 *
 * 		telnet-470   [001] .N.. 419421.045894: 0x00000001: <formatted msg>
 *
 * 	In the above:
 *
 * 		* ``telnet`` is the name of the current task.
 * 		* ``470`` is the PID of the current task.
 * 		* ``001`` is the CPU number on which the task is
 * 		  running.
 * 		* In ``.N..``, each character refers to a set of
 * 		  options (whether irqs are enabled, scheduling
 * 		  options, whether hard/softirqs are running, level of
 * 		  preempt_disabled respectively). **N** means that
 * 		  **TIF_NEED_RESCHED** and **PREEMPT_NEED_RESCHED**
 * 		  are set.
 * 		* ``419421.045894`` is a timestamp.
 * 		* ``0x00000001`` is a fake value used by BPF for the
 * 		  instruction pointer register.
 * 		* ``<formatted msg>`` is the message formatted with
 * 		  *fmt*.
 *
 * 	The conversion specifiers supported by *fmt* are similar, but
 * 	more limited than for printk(). They are **%d**, **%i**,
 * 	**%u**, **%x**, **%ld**, **%li**, **%lu**, **%lx**, **%lld**,
 * 	**%lli**, **%llu**, **%llx**, **%p**, **%s**. No modifier (size
 * 	of field, padding with zeroes, etc.) is available, and the
 * 	helper will return **-EINVAL** (but print nothing) if it
 * 	encounters an unknown specifier.
 *
 * 	Also, note that **bpf_trace_printk**\ () is slow, and should
 * 	only be used for debugging purposes. For this reason, a notice
 * 	block (spanning several lines) is printed to kernel logs and
 * 	states that the helper should not be used "for production use"
 * 	the first time this helper is used (or more precisely, when
 * 	**trace_printk**\ () buffers are allocated). For passing values
 * 	to user space, perf events should be preferred.
 *
 * Returns
 * 	The number of bytes written to the buffer, or a negative error
 * 	in case of failure.
 */
static long (*bpf_trace_printk)(const char *fmt, __u32 fmt_size, ...) = (void *) 6;

/*
 * bpf_get_prandom_u32
 *
 * 	Get a pseudo-random number.
 *
 * 	From a security point of view, this helper uses its own
 * 	pseudo-random internal state, and cannot be used to infer the
 * 	seed of other random functions in the kernel. However, it is
 * 	essential to note that the generator used by the helper is not
 * 	cryptographically secure.
 *
 * Returns
 * 	A random 32-bit unsigned value.
 */
static __u32 (*bpf_get_prandom_u32)(void) = (void *) 7;

/*
 * bpf_get_smp_processor_id
 *
 * 	Get the SMP (symmetric multiprocessing) processor id. Note that
 * 	all programs run with migration disabled, which means that the
 * 	SMP processor id is stable during all the execution of the
 * 	program.
 *
 * Returns
 * 	The SMP id of the processor running the program.
 */
static __u32 (*bpf_get_smp_processor_id)(void) = (void *) 8;

/*
 * bpf_skb_store_bytes
 *
 * 	Store *len* bytes from address *from* into the packet
 * 	associated to *skb*, at *offset*. *flags* are a combination of
 * 	**BPF_F_RECOMPUTE_CSUM** (automatically recompute the
 * 	checksum for the packet after storing the bytes) and
 * 	**BPF_F_INVALIDATE_HASH** (set *skb*\ **->hash**, *skb*\
 * 	**->swhash** and *skb*\ **->l4hash** to 0).
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_store_bytes)(struct __sk_buff *skb, __u32 offset, const void *from, __u32 len, __u64 flags) = (void *) 9;

/*
 * bpf_l3_csum_replace
 *
 * 	Recompute the layer 3 (e.g. IP) checksum for the packet
 * 	associated to *skb*. Computation is incremental, so the helper
 * 	must know the former value of the header field that was
 * 	modified (*from*), the new value of this field (*to*), and the
 * 	number of bytes (2 or 4) for this field, stored in *size*.
 * 	Alternatively, it is possible to store the difference between
 * 	the previous and the new values of the header field in *to*, by
 * 	setting *from* and *size* to 0. For both methods, *offset*
 * 	indicates the location of the IP checksum within the packet.
 *
 * 	This helper works in combination with **bpf_csum_diff**\ (),
 * 	which does not update the checksum in-place, but offers more
 * 	flexibility and can handle sizes larger than 2 or 4 for the
 * 	checksum to update.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_l3_csum_replace)(struct __sk_buff *skb, __u32 offset, __u64 from, __u64 to, __u64 size) = (void *) 10;

/*
 * bpf_l4_csum_replace
 *
 * 	Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the
 * 	packet associated to *skb*. Computation is incremental, so the
 * 	helper must know the former value of the header field that was
 * 	modified (*from*), the new value of this field (*to*), and the
 * 	number of bytes (2 or 4) for this field, stored on the lowest
 * 	four bits of *flags*. Alternatively, it is possible to store
 * 	the difference between the previous and the new values of the
 * 	header field in *to*, by setting *from* and the four lowest
 * 	bits of *flags* to 0. For both methods, *offset* indicates the
 * 	location of the IP checksum within the packet. In addition to
 * 	the size of the field, *flags* can be added (bitwise OR) actual
 * 	flags. With **BPF_F_MARK_MANGLED_0**, a null checksum is left
 * 	untouched (unless **BPF_F_MARK_ENFORCE** is added as well), and
 * 	for updates resulting in a null checksum the value is set to
 * 	**CSUM_MANGLED_0** instead. Flag **BPF_F_PSEUDO_HDR** indicates
 * 	the checksum is to be computed against a pseudo-header.
 *
 * 	This helper works in combination with **bpf_csum_diff**\ (),
 * 	which does not update the checksum in-place, but offers more
 * 	flexibility and can handle sizes larger than 2 or 4 for the
 * 	checksum to update.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_l4_csum_replace)(struct __sk_buff *skb, __u32 offset, __u64 from, __u64 to, __u64 flags) = (void *) 11;

/*
 * bpf_tail_call
 *
 * 	This special helper is used to trigger a "tail call", or in
 * 	other words, to jump into another eBPF program. The same stack
 * 	frame is used (but values on stack and in registers for the
 * 	caller are not accessible to the callee). This mechanism allows
 * 	for program chaining, either for raising the maximum number of
 * 	available eBPF instructions, or to execute given programs in
 * 	conditional blocks. For security reasons, there is an upper
 * 	limit to the number of successive tail calls that can be
 * 	performed.
 *
 * 	Upon call of this helper, the program attempts to jump into a
 * 	program referenced at index *index* in *prog_array_map*, a
 * 	special map of type **BPF_MAP_TYPE_PROG_ARRAY**, and passes
 * 	*ctx*, a pointer to the context.
 *
 * 	If the call succeeds, the kernel immediately runs the first
 * 	instruction of the new program. This is not a function call,
 * 	and it never returns to the previous program. If the call
 * 	fails, then the helper has no effect, and the caller continues
 * 	to run its subsequent instructions. A call can fail if the
 * 	destination program for the jump does not exist (i.e. *index*
 * 	is superior to the number of entries in *prog_array_map*), or
 * 	if the maximum number of tail calls has been reached for this
 * 	chain of programs. This limit is defined in the kernel by the
 * 	macro **MAX_TAIL_CALL_CNT** (not accessible to user space),
 * 	which is currently set to 33.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_tail_call)(void *ctx, void *prog_array_map, __u32 index) = (void *) 12;

/*
 * bpf_clone_redirect
 *
 * 	Clone and redirect the packet associated to *skb* to another
 * 	net device of index *ifindex*. Both ingress and egress
 * 	interfaces can be used for redirection. The **BPF_F_INGRESS**
 * 	value in *flags* is used to make the distinction (ingress path
 * 	is selected if the flag is present, egress path otherwise).
 * 	This is the only flag supported for now.
 *
 * 	In comparison with **bpf_redirect**\ () helper,
 * 	**bpf_clone_redirect**\ () has the associated cost of
 * 	duplicating the packet buffer, but this can be executed out of
 * 	the eBPF program. Conversely, **bpf_redirect**\ () is more
 * 	efficient, but it is handled through an action code where the
 * 	redirection happens only after the eBPF program has returned.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_clone_redirect)(struct __sk_buff *skb, __u32 ifindex, __u64 flags) = (void *) 13;

/*
 * bpf_get_current_pid_tgid
 *
 *
 * Returns
 * 	A 64-bit integer containing the current tgid and pid, and
 * 	created as such:
 * 	*current_task*\ **->tgid << 32 \|**
 * 	*current_task*\ **->pid**.
 */
static __u64 (*bpf_get_current_pid_tgid)(void) = (void *) 14;

/*
 * bpf_get_current_uid_gid
 *
 *
 * Returns
 * 	A 64-bit integer containing the current GID and UID, and
 * 	created as such: *current_gid* **<< 32 \|** *current_uid*.
 */
static __u64 (*bpf_get_current_uid_gid)(void) = (void *) 15;

/*
 * bpf_get_current_comm
 *
 * 	Copy the **comm** attribute of the current task into *buf* of
 * 	*size_of_buf*. The **comm** attribute contains the name of
 * 	the executable (excluding the path) for the current task. The
 * 	*size_of_buf* must be strictly positive. On success, the
 * 	helper makes sure that the *buf* is NUL-terminated. On failure,
 * 	it is filled with zeroes.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_get_current_comm)(void *buf, __u32 size_of_buf) = (void *) 16;

/*
 * bpf_get_cgroup_classid
 *
 * 	Retrieve the classid for the current task, i.e. for the net_cls
 * 	cgroup to which *skb* belongs.
 *
 * 	This helper can be used on TC egress path, but not on ingress.
 *
 * 	The net_cls cgroup provides an interface to tag network packets
 * 	based on a user-provided identifier for all traffic coming from
 * 	the tasks belonging to the related cgroup. See also the related
 * 	kernel documentation, available from the Linux sources in file
 * 	*Documentation/admin-guide/cgroup-v1/net_cls.rst*.
 *
 * 	The Linux kernel has two versions for cgroups: there are
 * 	cgroups v1 and cgroups v2. Both are available to users, who can
 * 	use a mixture of them, but note that the net_cls cgroup is for
 * 	cgroup v1 only. This makes it incompatible with BPF programs
 * 	run on cgroups, which is a cgroup-v2-only feature (a socket can
 * 	only hold data for one version of cgroups at a time).
 *
 * 	This helper is only available is the kernel was compiled with
 * 	the **CONFIG_CGROUP_NET_CLASSID** configuration option set to
 * 	"**y**" or to "**m**".
 *
 * Returns
 * 	The classid, or 0 for the default unconfigured classid.
 */
static __u32 (*bpf_get_cgroup_classid)(struct __sk_buff *skb) = (void *) 17;

/*
 * bpf_skb_vlan_push
 *
 * 	Push a *vlan_tci* (VLAN tag control information) of protocol
 * 	*vlan_proto* to the packet associated to *skb*, then update
 * 	the checksum. Note that if *vlan_proto* is different from
 * 	**ETH_P_8021Q** and **ETH_P_8021AD**, it is considered to
 * 	be **ETH_P_8021Q**.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_vlan_push)(struct __sk_buff *skb, __be16 vlan_proto, __u16 vlan_tci) = (void *) 18;

/*
 * bpf_skb_vlan_pop
 *
 * 	Pop a VLAN header from the packet associated to *skb*.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_vlan_pop)(struct __sk_buff *skb) = (void *) 19;

/*
 * bpf_skb_get_tunnel_key
 *
 * 	Get tunnel metadata. This helper takes a pointer *key* to an
 * 	empty **struct bpf_tunnel_key** of **size**, that will be
 * 	filled with tunnel metadata for the packet associated to *skb*.
 * 	The *flags* can be set to **BPF_F_TUNINFO_IPV6**, which
 * 	indicates that the tunnel is based on IPv6 protocol instead of
 * 	IPv4.
 *
 * 	The **struct bpf_tunnel_key** is an object that generalizes the
 * 	principal parameters used by various tunneling protocols into a
 * 	single struct. This way, it can be used to easily make a
 * 	decision based on the contents of the encapsulation header,
 * 	"summarized" in this struct. In particular, it holds the IP
 * 	address of the remote end (IPv4 or IPv6, depending on the case)
 * 	in *key*\ **->remote_ipv4** or *key*\ **->remote_ipv6**. Also,
 * 	this struct exposes the *key*\ **->tunnel_id**, which is
 * 	generally mapped to a VNI (Virtual Network Identifier), making
 * 	it programmable together with the **bpf_skb_set_tunnel_key**\
 * 	() helper.
 *
 * 	Let's imagine that the following code is part of a program
 * 	attached to the TC ingress interface, on one end of a GRE
 * 	tunnel, and is supposed to filter out all messages coming from
 * 	remote ends with IPv4 address other than 10.0.0.1:
 *
 * 	::
 *
 * 		int ret;
 * 		struct bpf_tunnel_key key = {};
 *
 * 		ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);
 * 		if (ret < 0)
 * 			return TC_ACT_SHOT;	// drop packet
 *
 * 		if (key.remote_ipv4 != 0x0a000001)
 * 			return TC_ACT_SHOT;	// drop packet
 *
 * 		return TC_ACT_OK;		// accept packet
 *
 * 	This interface can also be used with all encapsulation devices
 * 	that can operate in "collect metadata" mode: instead of having
 * 	one network device per specific configuration, the "collect
 * 	metadata" mode only requires a single device where the
 * 	configuration can be extracted from this helper.
 *
 * 	This can be used together with various tunnels such as VXLan,
 * 	Geneve, GRE or IP in IP (IPIP).
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_get_tunnel_key)(struct __sk_buff *skb, struct bpf_tunnel_key *key, __u32 size, __u64 flags) = (void *) 20;

/*
 * bpf_skb_set_tunnel_key
 *
 * 	Populate tunnel metadata for packet associated to *skb.* The
 * 	tunnel metadata is set to the contents of *key*, of *size*. The
 * 	*flags* can be set to a combination of the following values:
 *
 * 	**BPF_F_TUNINFO_IPV6**
 * 		Indicate that the tunnel is based on IPv6 protocol
 * 		instead of IPv4.
 * 	**BPF_F_ZERO_CSUM_TX**
 * 		For IPv4 packets, add a flag to tunnel metadata
 * 		indicating that checksum computation should be skipped
 * 		and checksum set to zeroes.
 * 	**BPF_F_DONT_FRAGMENT**
 * 		Add a flag to tunnel metadata indicating that the
 * 		packet should not be fragmented.
 * 	**BPF_F_SEQ_NUMBER**
 * 		Add a flag to tunnel metadata indicating that a
 * 		sequence number should be added to tunnel header before
 * 		sending the packet. This flag was added for GRE
 * 		encapsulation, but might be used with other protocols
 * 		as well in the future.
 *
 * 	Here is a typical usage on the transmit path:
 *
 * 	::
 *
 * 		struct bpf_tunnel_key key;
 * 		     populate key ...
 * 		bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);
 * 		bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);
 *
 * 	See also the description of the **bpf_skb_get_tunnel_key**\ ()
 * 	helper for additional information.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_set_tunnel_key)(struct __sk_buff *skb, struct bpf_tunnel_key *key, __u32 size, __u64 flags) = (void *) 21;

/*
 * bpf_perf_event_read
 *
 * 	Read the value of a perf event counter. This helper relies on a
 * 	*map* of type **BPF_MAP_TYPE_PERF_EVENT_ARRAY**. The nature of
 * 	the perf event counter is selected when *map* is updated with
 * 	perf event file descriptors. The *map* is an array whose size
 * 	is the number of available CPUs, and each cell contains a value
 * 	relative to one CPU. The value to retrieve is indicated by
 * 	*flags*, that contains the index of the CPU to look up, masked
 * 	with **BPF_F_INDEX_MASK**. Alternatively, *flags* can be set to
 * 	**BPF_F_CURRENT_CPU** to indicate that the value for the
 * 	current CPU should be retrieved.
 *
 * 	Note that before Linux 4.13, only hardware perf event can be
 * 	retrieved.
 *
 * 	Also, be aware that the newer helper
 * 	**bpf_perf_event_read_value**\ () is recommended over
 * 	**bpf_perf_event_read**\ () in general. The latter has some ABI
 * 	quirks where error and counter value are used as a return code
 * 	(which is wrong to do since ranges may overlap). This issue is
 * 	fixed with **bpf_perf_event_read_value**\ (), which at the same
 * 	time provides more features over the **bpf_perf_event_read**\
 * 	() interface. Please refer to the description of
 * 	**bpf_perf_event_read_value**\ () for details.
 *
 * Returns
 * 	The value of the perf event counter read from the map, or a
 * 	negative error code in case of failure.
 */
static __u64 (*bpf_perf_event_read)(void *map, __u64 flags) = (void *) 22;

/*
 * bpf_redirect
 *
 * 	Redirect the packet to another net device of index *ifindex*.
 * 	This helper is somewhat similar to **bpf_clone_redirect**\
 * 	(), except that the packet is not cloned, which provides
 * 	increased performance.
 *
 * 	Except for XDP, both ingress and egress interfaces can be used
 * 	for redirection. The **BPF_F_INGRESS** value in *flags* is used
 * 	to make the distinction (ingress path is selected if the flag
 * 	is present, egress path otherwise). Currently, XDP only
 * 	supports redirection to the egress interface, and accepts no
 * 	flag at all.
 *
 * 	The same effect can also be attained with the more generic
 * 	**bpf_redirect_map**\ (), which uses a BPF map to store the
 * 	redirect target instead of providing it directly to the helper.
 *
 * Returns
 * 	For XDP, the helper returns **XDP_REDIRECT** on success or
 * 	**XDP_ABORTED** on error. For other program types, the values
 * 	are **TC_ACT_REDIRECT** on success or **TC_ACT_SHOT** on
 * 	error.
 */
static long (*bpf_redirect)(__u32 ifindex, __u64 flags) = (void *) 23;

/*
 * bpf_get_route_realm
 *
 * 	Retrieve the realm or the route, that is to say the
 * 	**tclassid** field of the destination for the *skb*. The
 * 	identifier retrieved is a user-provided tag, similar to the
 * 	one used with the net_cls cgroup (see description for
 * 	**bpf_get_cgroup_classid**\ () helper), but here this tag is
 * 	held by a route (a destination entry), not by a task.
 *
 * 	Retrieving this identifier works with the clsact TC egress hook
 * 	(see also **tc-bpf(8)**), or alternatively on conventional
 * 	classful egress qdiscs, but not on TC ingress path. In case of
 * 	clsact TC egress hook, this has the advantage that, internally,
 * 	the destination entry has not been dropped yet in the transmit
 * 	path. Therefore, the destination entry does not need to be
 * 	artificially held via **netif_keep_dst**\ () for a classful
 * 	qdisc until the *skb* is freed.
 *
 * 	This helper is available only if the kernel was compiled with
 * 	**CONFIG_IP_ROUTE_CLASSID** configuration option.
 *
 * Returns
 * 	The realm of the route for the packet associated to *skb*, or 0
 * 	if none was found.
 */
static __u32 (*bpf_get_route_realm)(struct __sk_buff *skb) = (void *) 24;

/*
 * bpf_perf_event_output
 *
 * 	Write raw *data* blob into a special BPF perf event held by
 * 	*map* of type **BPF_MAP_TYPE_PERF_EVENT_ARRAY**. This perf
 * 	event must have the following attributes: **PERF_SAMPLE_RAW**
 * 	as **sample_type**, **PERF_TYPE_SOFTWARE** as **type**, and
 * 	**PERF_COUNT_SW_BPF_OUTPUT** as **config**.
 *
 * 	The *flags* are used to indicate the index in *map* for which
 * 	the value must be put, masked with **BPF_F_INDEX_MASK**.
 * 	Alternatively, *flags* can be set to **BPF_F_CURRENT_CPU**
 * 	to indicate that the index of the current CPU core should be
 * 	used.
 *
 * 	The value to write, of *size*, is passed through eBPF stack and
 * 	pointed by *data*.
 *
 * 	The context of the program *ctx* needs also be passed to the
 * 	helper.
 *
 * 	On user space, a program willing to read the values needs to
 * 	call **perf_event_open**\ () on the perf event (either for
 * 	one or for all CPUs) and to store the file descriptor into the
 * 	*map*. This must be done before the eBPF program can send data
 * 	into it. An example is available in file
 * 	*samples/bpf/trace_output_user.c* in the Linux kernel source
 * 	tree (the eBPF program counterpart is in
 * 	*samples/bpf/trace_output_kern.c*).
 *
 * 	**bpf_perf_event_output**\ () achieves better performance
 * 	than **bpf_trace_printk**\ () for sharing data with user
 * 	space, and is much better suitable for streaming data from eBPF
 * 	programs.
 *
 * 	Note that this helper is not restricted to tracing use cases
 * 	and can be used with programs attached to TC or XDP as well,
 * 	where it allows for passing data to user space listeners. Data
 * 	can be:
 *
 * 	* Only custom structs,
 * 	* Only the packet payload, or
 * 	* A combination of both.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_perf_event_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 25;

/*
 * bpf_skb_load_bytes
 *
 * 	This helper was provided as an easy way to load data from a
 * 	packet. It can be used to load *len* bytes from *offset* from
 * 	the packet associated to *skb*, into the buffer pointed by
 * 	*to*.
 *
 * 	Since Linux 4.7, usage of this helper has mostly been replaced
 * 	by "direct packet access", enabling packet data to be
 * 	manipulated with *skb*\ **->data** and *skb*\ **->data_end**
 * 	pointing respectively to the first byte of packet data and to
 * 	the byte after the last byte of packet data. However, it
 * 	remains useful if one wishes to read large quantities of data
 * 	at once from a packet into the eBPF stack.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_load_bytes)(const void *skb, __u32 offset, void *to, __u32 len) = (void *) 26;

/*
 * bpf_get_stackid
 *
 * 	Walk a user or a kernel stack and return its id. To achieve
 * 	this, the helper needs *ctx*, which is a pointer to the context
 * 	on which the tracing program is executed, and a pointer to a
 * 	*map* of type **BPF_MAP_TYPE_STACK_TRACE**.
 *
 * 	The last argument, *flags*, holds the number of stack frames to
 * 	skip (from 0 to 255), masked with
 * 	**BPF_F_SKIP_FIELD_MASK**. The next bits can be used to set
 * 	a combination of the following flags:
 *
 * 	**BPF_F_USER_STACK**
 * 		Collect a user space stack instead of a kernel stack.
 * 	**BPF_F_FAST_STACK_CMP**
 * 		Compare stacks by hash only.
 * 	**BPF_F_REUSE_STACKID**
 * 		If two different stacks hash into the same *stackid*,
 * 		discard the old one.
 *
 * 	The stack id retrieved is a 32 bit long integer handle which
 * 	can be further combined with other data (including other stack
 * 	ids) and used as a key into maps. This can be useful for
 * 	generating a variety of graphs (such as flame graphs or off-cpu
 * 	graphs).
 *
 * 	For walking a stack, this helper is an improvement over
 * 	**bpf_probe_read**\ (), which can be used with unrolled loops
 * 	but is not efficient and consumes a lot of eBPF instructions.
 * 	Instead, **bpf_get_stackid**\ () can collect up to
 * 	**PERF_MAX_STACK_DEPTH** both kernel and user frames. Note that
 * 	this limit can be controlled with the **sysctl** program, and
 * 	that it should be manually increased in order to profile long
 * 	user stacks (such as stacks for Java programs). To do so, use:
 *
 * 	::
 *
 * 		# sysctl kernel.perf_event_max_stack=<new value>
 *
 * Returns
 * 	The positive or null stack id on success, or a negative error
 * 	in case of failure.
 */
static long (*bpf_get_stackid)(void *ctx, void *map, __u64 flags) = (void *) 27;

/*
 * bpf_csum_diff
 *
 * 	Compute a checksum difference, from the raw buffer pointed by
 * 	*from*, of length *from_size* (that must be a multiple of 4),
 * 	towards the raw buffer pointed by *to*, of size *to_size*
 * 	(same remark). An optional *seed* can be added to the value
 * 	(this can be cascaded, the seed may come from a previous call
 * 	to the helper).
 *
 * 	This is flexible enough to be used in several ways:
 *
 * 	* With *from_size* == 0, *to_size* > 0 and *seed* set to
 * 	  checksum, it can be used when pushing new data.
 * 	* With *from_size* > 0, *to_size* == 0 and *seed* set to
 * 	  checksum, it can be used when removing data from a packet.
 * 	* With *from_size* > 0, *to_size* > 0 and *seed* set to 0, it
 * 	  can be used to compute a diff. Note that *from_size* and
 * 	  *to_size* do not need to be equal.
 *
 * 	This helper can be used in combination with
 * 	**bpf_l3_csum_replace**\ () and **bpf_l4_csum_replace**\ (), to
 * 	which one can feed in the difference computed with
 * 	**bpf_csum_diff**\ ().
 *
 * Returns
 * 	The checksum result, or a negative error code in case of
 * 	failure.
 */
static __s64 (*bpf_csum_diff)(__be32 *from, __u32 from_size, __be32 *to, __u32 to_size, __wsum seed) = (void *) 28;

/*
 * bpf_skb_get_tunnel_opt
 *
 * 	Retrieve tunnel options metadata for the packet associated to
 * 	*skb*, and store the raw tunnel option data to the buffer *opt*
 * 	of *size*.
 *
 * 	This helper can be used with encapsulation devices that can
 * 	operate in "collect metadata" mode (please refer to the related
 * 	note in the description of **bpf_skb_get_tunnel_key**\ () for
 * 	more details). A particular example where this can be used is
 * 	in combination with the Geneve encapsulation protocol, where it
 * 	allows for pushing (with **bpf_skb_get_tunnel_opt**\ () helper)
 * 	and retrieving arbitrary TLVs (Type-Length-Value headers) from
 * 	the eBPF program. This allows for full customization of these
 * 	headers.
 *
 * Returns
 * 	The size of the option data retrieved.
 */
static long (*bpf_skb_get_tunnel_opt)(struct __sk_buff *skb, void *opt, __u32 size) = (void *) 29;

/*
 * bpf_skb_set_tunnel_opt
 *
 * 	Set tunnel options metadata for the packet associated to *skb*
 * 	to the option data contained in the raw buffer *opt* of *size*.
 *
 * 	See also the description of the **bpf_skb_get_tunnel_opt**\ ()
 * 	helper for additional information.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_set_tunnel_opt)(struct __sk_buff *skb, void *opt, __u32 size) = (void *) 30;

/*
 * bpf_skb_change_proto
 *
 * 	Change the protocol of the *skb* to *proto*. Currently
 * 	supported are transition from IPv4 to IPv6, and from IPv6 to
 * 	IPv4. The helper takes care of the groundwork for the
 * 	transition, including resizing the socket buffer. The eBPF
 * 	program is expected to fill the new headers, if any, via
 * 	**skb_store_bytes**\ () and to recompute the checksums with
 * 	**bpf_l3_csum_replace**\ () and **bpf_l4_csum_replace**\
 * 	(). The main case for this helper is to perform NAT64
 * 	operations out of an eBPF program.
 *
 * 	Internally, the GSO type is marked as dodgy so that headers are
 * 	checked and segments are recalculated by the GSO/GRO engine.
 * 	The size for GSO target is adapted as well.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_change_proto)(struct __sk_buff *skb, __be16 proto, __u64 flags) = (void *) 31;

/*
 * bpf_skb_change_type
 *
 * 	Change the packet type for the packet associated to *skb*. This
 * 	comes down to setting *skb*\ **->pkt_type** to *type*, except
 * 	the eBPF program does not have a write access to *skb*\
 * 	**->pkt_type** beside this helper. Using a helper here allows
 * 	for graceful handling of errors.
 *
 * 	The major use case is to change incoming *skb*s to
 * 	**PACKET_HOST** in a programmatic way instead of having to
 * 	recirculate via **redirect**\ (..., **BPF_F_INGRESS**), for
 * 	example.
 *
 * 	Note that *type* only allows certain values. At this time, they
 * 	are:
 *
 * 	**PACKET_HOST**
 * 		Packet is for us.
 * 	**PACKET_BROADCAST**
 * 		Send packet to all.
 * 	**PACKET_MULTICAST**
 * 		Send packet to group.
 * 	**PACKET_OTHERHOST**
 * 		Send packet to someone else.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_change_type)(struct __sk_buff *skb, __u32 type) = (void *) 32;

/*
 * bpf_skb_under_cgroup
 *
 * 	Check whether *skb* is a descendant of the cgroup2 held by
 * 	*map* of type **BPF_MAP_TYPE_CGROUP_ARRAY**, at *index*.
 *
 * Returns
 * 	The return value depends on the result of the test, and can be:
 *
 * 	* 0, if the *skb* failed the cgroup2 descendant test.
 * 	* 1, if the *skb* succeeded the cgroup2 descendant test.
 * 	* A negative error code, if an error occurred.
 */
static long (*bpf_skb_under_cgroup)(struct __sk_buff *skb, void *map, __u32 index) = (void *) 33;

/*
 * bpf_get_hash_recalc
 *
 * 	Retrieve the hash of the packet, *skb*\ **->hash**. If it is
 * 	not set, in particular if the hash was cleared due to mangling,
 * 	recompute this hash. Later accesses to the hash can be done
 * 	directly with *skb*\ **->hash**.
 *
 * 	Calling **bpf_set_hash_invalid**\ (), changing a packet
 * 	prototype with **bpf_skb_change_proto**\ (), or calling
 * 	**bpf_skb_store_bytes**\ () with the
 * 	**BPF_F_INVALIDATE_HASH** are actions susceptible to clear
 * 	the hash and to trigger a new computation for the next call to
 * 	**bpf_get_hash_recalc**\ ().
 *
 * Returns
 * 	The 32-bit hash.
 */
static __u32 (*bpf_get_hash_recalc)(struct __sk_buff *skb) = (void *) 34;

/*
 * bpf_get_current_task
 *
 *
 * Returns
 * 	A pointer to the current task struct.
 */
static __u64 (*bpf_get_current_task)(void) = (void *) 35;

/*
 * bpf_probe_write_user
 *
 * 	Attempt in a safe way to write *len* bytes from the buffer
 * 	*src* to *dst* in memory. It only works for threads that are in
 * 	user context, and *dst* must be a valid user space address.
 *
 * 	This helper should not be used to implement any kind of
 * 	security mechanism because of TOC-TOU attacks, but rather to
 * 	debug, divert, and manipulate execution of semi-cooperative
 * 	processes.
 *
 * 	Keep in mind that this feature is meant for experiments, and it
 * 	has a risk of crashing the system and running programs.
 * 	Therefore, when an eBPF program using this helper is attached,
 * 	a warning including PID and process name is printed to kernel
 * 	logs.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_probe_write_user)(void *dst, const void *src, __u32 len) = (void *) 36;

/*
 * bpf_current_task_under_cgroup
 *
 * 	Check whether the probe is being run is the context of a given
 * 	subset of the cgroup2 hierarchy. The cgroup2 to test is held by
 * 	*map* of type **BPF_MAP_TYPE_CGROUP_ARRAY**, at *index*.
 *
 * Returns
 * 	The return value depends on the result of the test, and can be:
 *
 * 	* 0, if current task belongs to the cgroup2.
 * 	* 1, if current task does not belong to the cgroup2.
 * 	* A negative error code, if an error occurred.
 */
static long (*bpf_current_task_under_cgroup)(void *map, __u32 index) = (void *) 37;

/*
 * bpf_skb_change_tail
 *
 * 	Resize (trim or grow) the packet associated to *skb* to the
 * 	new *len*. The *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	The basic idea is that the helper performs the needed work to
 * 	change the size of the packet, then the eBPF program rewrites
 * 	the rest via helpers like **bpf_skb_store_bytes**\ (),
 * 	**bpf_l3_csum_replace**\ (), **bpf_l3_csum_replace**\ ()
 * 	and others. This helper is a slow path utility intended for
 * 	replies with control messages. And because it is targeted for
 * 	slow path, the helper itself can afford to be slow: it
 * 	implicitly linearizes, unclones and drops offloads from the
 * 	*skb*.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_change_tail)(struct __sk_buff *skb, __u32 len, __u64 flags) = (void *) 38;

/*
 * bpf_skb_pull_data
 *
 * 	Pull in non-linear data in case the *skb* is non-linear and not
 * 	all of *len* are part of the linear section. Make *len* bytes
 * 	from *skb* readable and writable. If a zero value is passed for
 * 	*len*, then the whole length of the *skb* is pulled.
 *
 * 	This helper is only needed for reading and writing with direct
 * 	packet access.
 *
 * 	For direct packet access, testing that offsets to access
 * 	are within packet boundaries (test on *skb*\ **->data_end**) is
 * 	susceptible to fail if offsets are invalid, or if the requested
 * 	data is in non-linear parts of the *skb*. On failure the
 * 	program can just bail out, or in the case of a non-linear
 * 	buffer, use a helper to make the data available. The
 * 	**bpf_skb_load_bytes**\ () helper is a first solution to access
 * 	the data. Another one consists in using **bpf_skb_pull_data**
 * 	to pull in once the non-linear parts, then retesting and
 * 	eventually access the data.
 *
 * 	At the same time, this also makes sure the *skb* is uncloned,
 * 	which is a necessary condition for direct write. As this needs
 * 	to be an invariant for the write part only, the verifier
 * 	detects writes and adds a prologue that is calling
 * 	**bpf_skb_pull_data()** to effectively unclone the *skb* from
 * 	the very beginning in case it is indeed cloned.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_pull_data)(struct __sk_buff *skb, __u32 len) = (void *) 39;

/*
 * bpf_csum_update
 *
 * 	Add the checksum *csum* into *skb*\ **->csum** in case the
 * 	driver has supplied a checksum for the entire packet into that
 * 	field. Return an error otherwise. This helper is intended to be
 * 	used in combination with **bpf_csum_diff**\ (), in particular
 * 	when the checksum needs to be updated after data has been
 * 	written into the packet through direct packet access.
 *
 * Returns
 * 	The checksum on success, or a negative error code in case of
 * 	failure.
 */
static __s64 (*bpf_csum_update)(struct __sk_buff *skb, __wsum csum) = (void *) 40;

/*
 * bpf_set_hash_invalid
 *
 * 	Invalidate the current *skb*\ **->hash**. It can be used after
 * 	mangling on headers through direct packet access, in order to
 * 	indicate that the hash is outdated and to trigger a
 * 	recalculation the next time the kernel tries to access this
 * 	hash or when the **bpf_get_hash_recalc**\ () helper is called.
 *
 */
static void (*bpf_set_hash_invalid)(struct __sk_buff *skb) = (void *) 41;

/*
 * bpf_get_numa_node_id
 *
 * 	Return the id of the current NUMA node. The primary use case
 * 	for this helper is the selection of sockets for the local NUMA
 * 	node, when the program is attached to sockets using the
 * 	**SO_ATTACH_REUSEPORT_EBPF** option (see also **socket(7)**),
 * 	but the helper is also available to other eBPF program types,
 * 	similarly to **bpf_get_smp_processor_id**\ ().
 *
 * Returns
 * 	The id of current NUMA node.
 */
static long (*bpf_get_numa_node_id)(void) = (void *) 42;

/*
 * bpf_skb_change_head
 *
 * 	Grows headroom of packet associated to *skb* and adjusts the
 * 	offset of the MAC header accordingly, adding *len* bytes of
 * 	space. It automatically extends and reallocates memory as
 * 	required.
 *
 * 	This helper can be used on a layer 3 *skb* to push a MAC header
 * 	for redirection into a layer 2 device.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_change_head)(struct __sk_buff *skb, __u32 len, __u64 flags) = (void *) 43;

/*
 * bpf_xdp_adjust_head
 *
 * 	Adjust (move) *xdp_md*\ **->data** by *delta* bytes. Note that
 * 	it is possible to use a negative value for *delta*. This helper
 * 	can be used to prepare the packet for pushing or popping
 * 	headers.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_xdp_adjust_head)(struct xdp_md *xdp_md, int delta) = (void *) 44;

/*
 * bpf_probe_read_str
 *
 * 	Copy a NUL terminated string from an unsafe kernel address
 * 	*unsafe_ptr* to *dst*. See **bpf_probe_read_kernel_str**\ () for
 * 	more details.
 *
 * 	Generally, use **bpf_probe_read_user_str**\ () or
 * 	**bpf_probe_read_kernel_str**\ () instead.
 *
 * Returns
 * 	On success, the strictly positive length of the string,
 * 	including the trailing NUL character. On error, a negative
 * 	value.
 */
static long (*bpf_probe_read_str)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 45;

/*
 * bpf_get_socket_cookie
 *
 * 	If the **struct sk_buff** pointed by *skb* has a known socket,
 * 	retrieve the cookie (generated by the kernel) of this socket.
 * 	If no cookie has been set yet, generate a new cookie. Once
 * 	generated, the socket cookie remains stable for the life of the
 * 	socket. This helper can be useful for monitoring per socket
 * 	networking traffic statistics as it provides a global socket
 * 	identifier that can be assumed unique.
 *
 * Returns
 * 	A 8-byte long unique number on success, or 0 if the socket
 * 	field is missing inside *skb*.
 */
static __u64 (*bpf_get_socket_cookie)(void *ctx) = (void *) 46;

/*
 * bpf_get_socket_uid
 *
 *
 * Returns
 * 	The owner UID of the socket associated to *skb*. If the socket
 * 	is **NULL**, or if it is not a full socket (i.e. if it is a
 * 	time-wait or a request socket instead), **overflowuid** value
 * 	is returned (note that **overflowuid** might also be the actual
 * 	UID value for the socket).
 */
static __u32 (*bpf_get_socket_uid)(struct __sk_buff *skb) = (void *) 47;

/*
 * bpf_set_hash
 *
 * 	Set the full hash for *skb* (set the field *skb*\ **->hash**)
 * 	to value *hash*.
 *
 * Returns
 * 	0
 */
static long (*bpf_set_hash)(struct __sk_buff *skb, __u32 hash) = (void *) 48;

/*
 * bpf_setsockopt
 *
 * 	Emulate a call to **setsockopt()** on the socket associated to
 * 	*bpf_socket*, which must be a full socket. The *level* at
 * 	which the option resides and the name *optname* of the option
 * 	must be specified, see **setsockopt(2)** for more information.
 * 	The option value of length *optlen* is pointed by *optval*.
 *
 * 	*bpf_socket* should be one of the following:
 *
 * 	* **struct bpf_sock_ops** for **BPF_PROG_TYPE_SOCK_OPS**.
 * 	* **struct bpf_sock_addr** for **BPF_CGROUP_INET4_CONNECT**
 * 	  and **BPF_CGROUP_INET6_CONNECT**.
 *
 * 	This helper actually implements a subset of **setsockopt()**.
 * 	It supports the following *level*\ s:
 *
 * 	* **SOL_SOCKET**, which supports the following *optname*\ s:
 * 	  **SO_RCVBUF**, **SO_SNDBUF**, **SO_MAX_PACING_RATE**,
 * 	  **SO_PRIORITY**, **SO_RCVLOWAT**, **SO_MARK**,
 * 	  **SO_BINDTODEVICE**, **SO_KEEPALIVE**.
 * 	* **IPPROTO_TCP**, which supports the following *optname*\ s:
 * 	  **TCP_CONGESTION**, **TCP_BPF_IW**,
 * 	  **TCP_BPF_SNDCWND_CLAMP**, **TCP_SAVE_SYN**,
 * 	  **TCP_KEEPIDLE**, **TCP_KEEPINTVL**, **TCP_KEEPCNT**,
 * 	  **TCP_SYNCNT**, **TCP_USER_TIMEOUT**, **TCP_NOTSENT_LOWAT**.
 * 	* **IPPROTO_IP**, which supports *optname* **IP_TOS**.
 * 	* **IPPROTO_IPV6**, which supports *optname* **IPV6_TCLASS**.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_setsockopt)(void *bpf_socket, int level, int optname, void *optval, int optlen) = (void *) 49;

/*
 * bpf_skb_adjust_room
 *
 * 	Grow or shrink the room for data in the packet associated to
 * 	*skb* by *len_diff*, and according to the selected *mode*.
 *
 * 	By default, the helper will reset any offloaded checksum
 * 	indicator of the skb to CHECKSUM_NONE. This can be avoided
 * 	by the following flag:
 *
 * 	* **BPF_F_ADJ_ROOM_NO_CSUM_RESET**: Do not reset offloaded
 * 	  checksum data of the skb to CHECKSUM_NONE.
 *
 * 	There are two supported modes at this time:
 *
 * 	* **BPF_ADJ_ROOM_MAC**: Adjust room at the mac layer
 * 	  (room space is added or removed below the layer 2 header).
 *
 * 	* **BPF_ADJ_ROOM_NET**: Adjust room at the network layer
 * 	  (room space is added or removed below the layer 3 header).
 *
 * 	The following flags are supported at this time:
 *
 * 	* **BPF_F_ADJ_ROOM_FIXED_GSO**: Do not adjust gso_size.
 * 	  Adjusting mss in this way is not allowed for datagrams.
 *
 * 	* **BPF_F_ADJ_ROOM_ENCAP_L3_IPV4**,
 * 	  **BPF_F_ADJ_ROOM_ENCAP_L3_IPV6**:
 * 	  Any new space is reserved to hold a tunnel header.
 * 	  Configure skb offsets and other fields accordingly.
 *
 * 	* **BPF_F_ADJ_ROOM_ENCAP_L4_GRE**,
 * 	  **BPF_F_ADJ_ROOM_ENCAP_L4_UDP**:
 * 	  Use with ENCAP_L3 flags to further specify the tunnel type.
 *
 * 	* **BPF_F_ADJ_ROOM_ENCAP_L2**\ (*len*):
 * 	  Use with ENCAP_L3/L4 flags to further specify the tunnel
 * 	  type; *len* is the length of the inner MAC header.
 *
 * 	* **BPF_F_ADJ_ROOM_ENCAP_L2_ETH**:
 * 	  Use with BPF_F_ADJ_ROOM_ENCAP_L2 flag to further specify the
 * 	  L2 type as Ethernet.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_adjust_room)(struct __sk_buff *skb, __s32 len_diff, __u32 mode, __u64 flags) = (void *) 50;

/*
 * bpf_redirect_map
 *
 * 	Redirect the packet to the endpoint referenced by *map* at
 * 	index *key*. Depending on its type, this *map* can contain
 * 	references to net devices (for forwarding packets through other
 * 	ports), or to CPUs (for redirecting XDP frames to another CPU;
 * 	but this is only implemented for native XDP (with driver
 * 	support) as of this writing).
 *
 * 	The lower two bits of *flags* are used as the return code if
 * 	the map lookup fails. This is so that the return value can be
 * 	one of the XDP program return codes up to **XDP_TX**, as chosen
 * 	by the caller. The higher bits of *flags* can be set to
 * 	BPF_F_BROADCAST or BPF_F_EXCLUDE_INGRESS as defined below.
 *
 * 	With BPF_F_BROADCAST the packet will be broadcasted to all the
 * 	interfaces in the map, with BPF_F_EXCLUDE_INGRESS the ingress
 * 	interface will be excluded when do broadcasting.
 *
 * 	See also **bpf_redirect**\ (), which only supports redirecting
 * 	to an ifindex, but doesn't require a map to do so.
 *
 * Returns
 * 	**XDP_REDIRECT** on success, or the value of the two lower bits
 * 	of the *flags* argument on error.
 */
static long (*bpf_redirect_map)(void *map, __u32 key, __u64 flags) = (void *) 51;

/*
 * bpf_sk_redirect_map
 *
 * 	Redirect the packet to the socket referenced by *map* (of type
 * 	**BPF_MAP_TYPE_SOCKMAP**) at index *key*. Both ingress and
 * 	egress interfaces can be used for redirection. The
 * 	**BPF_F_INGRESS** value in *flags* is used to make the
 * 	distinction (ingress path is selected if the flag is present,
 * 	egress path otherwise). This is the only flag supported for now.
 *
 * Returns
 * 	**SK_PASS** on success, or **SK_DROP** on error.
 */
static long (*bpf_sk_redirect_map)(struct __sk_buff *skb, void *map, __u32 key, __u64 flags) = (void *) 52;

/*
 * bpf_sock_map_update
 *
 * 	Add an entry to, or update a *map* referencing sockets. The
 * 	*skops* is used as a new value for the entry associated to
 * 	*key*. *flags* is one of:
 *
 * 	**BPF_NOEXIST**
 * 		The entry for *key* must not exist in the map.
 * 	**BPF_EXIST**
 * 		The entry for *key* must already exist in the map.
 * 	**BPF_ANY**
 * 		No condition on the existence of the entry for *key*.
 *
 * 	If the *map* has eBPF programs (parser and verdict), those will
 * 	be inherited by the socket being added. If the socket is
 * 	already attached to eBPF programs, this results in an error.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_sock_map_update)(struct bpf_sock_ops *skops, void *map, void *key, __u64 flags) = (void *) 53;

/*
 * bpf_xdp_adjust_meta
 *
 * 	Adjust the address pointed by *xdp_md*\ **->data_meta** by
 * 	*delta* (which can be positive or negative). Note that this
 * 	operation modifies the address stored in *xdp_md*\ **->data**,
 * 	so the latter must be loaded only after the helper has been
 * 	called.
 *
 * 	The use of *xdp_md*\ **->data_meta** is optional and programs
 * 	are not required to use it. The rationale is that when the
 * 	packet is processed with XDP (e.g. as DoS filter), it is
 * 	possible to push further meta data along with it before passing
 * 	to the stack, and to give the guarantee that an ingress eBPF
 * 	program attached as a TC classifier on the same device can pick
 * 	this up for further post-processing. Since TC works with socket
 * 	buffers, it remains possible to set from XDP the **mark** or
 * 	**priority** pointers, or other pointers for the socket buffer.
 * 	Having this scratch space generic and programmable allows for
 * 	more flexibility as the user is free to store whatever meta
 * 	data they need.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_xdp_adjust_meta)(struct xdp_md *xdp_md, int delta) = (void *) 54;

/*
 * bpf_perf_event_read_value
 *
 * 	Read the value of a perf event counter, and store it into *buf*
 * 	of size *buf_size*. This helper relies on a *map* of type
 * 	**BPF_MAP_TYPE_PERF_EVENT_ARRAY**. The nature of the perf event
 * 	counter is selected when *map* is updated with perf event file
 * 	descriptors. The *map* is an array whose size is the number of
 * 	available CPUs, and each cell contains a value relative to one
 * 	CPU. The value to retrieve is indicated by *flags*, that
 * 	contains the index of the CPU to look up, masked with
 * 	**BPF_F_INDEX_MASK**. Alternatively, *flags* can be set to
 * 	**BPF_F_CURRENT_CPU** to indicate that the value for the
 * 	current CPU should be retrieved.
 *
 * 	This helper behaves in a way close to
 * 	**bpf_perf_event_read**\ () helper, save that instead of
 * 	just returning the value observed, it fills the *buf*
 * 	structure. This allows for additional data to be retrieved: in
 * 	particular, the enabled and running times (in *buf*\
 * 	**->enabled** and *buf*\ **->running**, respectively) are
 * 	copied. In general, **bpf_perf_event_read_value**\ () is
 * 	recommended over **bpf_perf_event_read**\ (), which has some
 * 	ABI issues and provides fewer functionalities.
 *
 * 	These values are interesting, because hardware PMU (Performance
 * 	Monitoring Unit) counters are limited resources. When there are
 * 	more PMU based perf events opened than available counters,
 * 	kernel will multiplex these events so each event gets certain
 * 	percentage (but not all) of the PMU time. In case that
 * 	multiplexing happens, the number of samples or counter value
 * 	will not reflect the case compared to when no multiplexing
 * 	occurs. This makes comparison between different runs difficult.
 * 	Typically, the counter value should be normalized before
 * 	comparing to other experiments. The usual normalization is done
 * 	as follows.
 *
 * 	::
 *
 * 		normalized_counter = counter * t_enabled / t_running
 *
 * 	Where t_enabled is the time enabled for event and t_running is
 * 	the time running for event since last normalization. The
 * 	enabled and running times are accumulated since the perf event
 * 	open. To achieve scaling factor between two invocations of an
 * 	eBPF program, users can use CPU id as the key (which is
 * 	typical for perf array usage model) to remember the previous
 * 	value and do the calculation inside the eBPF program.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_perf_event_read_value)(void *map, __u64 flags, struct bpf_perf_event_value *buf, __u32 buf_size) = (void *) 55;

/*
 * bpf_perf_prog_read_value
 *
 * 	For en eBPF program attached to a perf event, retrieve the
 * 	value of the event counter associated to *ctx* and store it in
 * 	the structure pointed by *buf* and of size *buf_size*. Enabled
 * 	and running times are also stored in the structure (see
 * 	description of helper **bpf_perf_event_read_value**\ () for
 * 	more details).
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_perf_prog_read_value)(struct bpf_perf_event_data *ctx, struct bpf_perf_event_value *buf, __u32 buf_size) = (void *) 56;

/*
 * bpf_getsockopt
 *
 * 	Emulate a call to **getsockopt()** on the socket associated to
 * 	*bpf_socket*, which must be a full socket. The *level* at
 * 	which the option resides and the name *optname* of the option
 * 	must be specified, see **getsockopt(2)** for more information.
 * 	The retrieved value is stored in the structure pointed by
 * 	*opval* and of length *optlen*.
 *
 * 	*bpf_socket* should be one of the following:
 *
 * 	* **struct bpf_sock_ops** for **BPF_PROG_TYPE_SOCK_OPS**.
 * 	* **struct bpf_sock_addr** for **BPF_CGROUP_INET4_CONNECT**
 * 	  and **BPF_CGROUP_INET6_CONNECT**.
 *
 * 	This helper actually implements a subset of **getsockopt()**.
 * 	It supports the following *level*\ s:
 *
 * 	* **IPPROTO_TCP**, which supports *optname*
 * 	  **TCP_CONGESTION**.
 * 	* **IPPROTO_IP**, which supports *optname* **IP_TOS**.
 * 	* **IPPROTO_IPV6**, which supports *optname* **IPV6_TCLASS**.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_getsockopt)(void *bpf_socket, int level, int optname, void *optval, int optlen) = (void *) 57;

/*
 * bpf_override_return
 *
 * 	Used for error injection, this helper uses kprobes to override
 * 	the return value of the probed function, and to set it to *rc*.
 * 	The first argument is the context *regs* on which the kprobe
 * 	works.
 *
 * 	This helper works by setting the PC (program counter)
 * 	to an override function which is run in place of the original
 * 	probed function. This means the probed function is not run at
 * 	all. The replacement function just returns with the required
 * 	value.
 *
 * 	This helper has security implications, and thus is subject to
 * 	restrictions. It is only available if the kernel was compiled
 * 	with the **CONFIG_BPF_KPROBE_OVERRIDE** configuration
 * 	option, and in this case it only works on functions tagged with
 * 	**ALLOW_ERROR_INJECTION** in the kernel code.
 *
 * 	Also, the helper is only available for the architectures having
 * 	the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,
 * 	x86 architecture is the only one to support this feature.
 *
 * Returns
 * 	0
 */
static long (*bpf_override_return)(struct pt_regs *regs, __u64 rc) = (void *) 58;

/*
 * bpf_sock_ops_cb_flags_set
 *
 * 	Attempt to set the value of the **bpf_sock_ops_cb_flags** field
 * 	for the full TCP socket associated to *bpf_sock_ops* to
 * 	*argval*.
 *
 * 	The primary use of this field is to determine if there should
 * 	be calls to eBPF programs of type
 * 	**BPF_PROG_TYPE_SOCK_OPS** at various points in the TCP
 * 	code. A program of the same type can change its value, per
 * 	connection and as necessary, when the connection is
 * 	established. This field is directly accessible for reading, but
 * 	this helper must be used for updates in order to return an
 * 	error if an eBPF program tries to set a callback that is not
 * 	supported in the current kernel.
 *
 * 	*argval* is a flag array which can combine these flags:
 *
 * 	* **BPF_SOCK_OPS_RTO_CB_FLAG** (retransmission time out)
 * 	* **BPF_SOCK_OPS_RETRANS_CB_FLAG** (retransmission)
 * 	* **BPF_SOCK_OPS_STATE_CB_FLAG** (TCP state change)
 * 	* **BPF_SOCK_OPS_RTT_CB_FLAG** (every RTT)
 *
 * 	Therefore, this function can be used to clear a callback flag by
 * 	setting the appropriate bit to zero. e.g. to disable the RTO
 * 	callback:
 *
 * 	**bpf_sock_ops_cb_flags_set(bpf_sock,**
 * 		**bpf_sock->bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)**
 *
 * 	Here are some examples of where one could call such eBPF
 * 	program:
 *
 * 	* When RTO fires.
 * 	* When a packet is retransmitted.
 * 	* When the connection terminates.
 * 	* When a packet is sent.
 * 	* When a packet is received.
 *
 * Returns
 * 	Code **-EINVAL** if the socket is not a full TCP socket;
 * 	otherwise, a positive number containing the bits that could not
 * 	be set is returned (which comes down to 0 if all bits were set
 * 	as required).
 */
static long (*bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops *bpf_sock, int argval) = (void *) 59;

/*
 * bpf_msg_redirect_map
 *
 * 	This helper is used in programs implementing policies at the
 * 	socket level. If the message *msg* is allowed to pass (i.e. if
 * 	the verdict eBPF program returns **SK_PASS**), redirect it to
 * 	the socket referenced by *map* (of type
 * 	**BPF_MAP_TYPE_SOCKMAP**) at index *key*. Both ingress and
 * 	egress interfaces can be used for redirection. The
 * 	**BPF_F_INGRESS** value in *flags* is used to make the
 * 	distinction (ingress path is selected if the flag is present,
 * 	egress path otherwise). This is the only flag supported for now.
 *
 * Returns
 * 	**SK_PASS** on success, or **SK_DROP** on error.
 */
static long (*bpf_msg_redirect_map)(struct sk_msg_md *msg, void *map, __u32 key, __u64 flags) = (void *) 60;

/*
 * bpf_msg_apply_bytes
 *
 * 	For socket policies, apply the verdict of the eBPF program to
 * 	the next *bytes* (number of bytes) of message *msg*.
 *
 * 	For example, this helper can be used in the following cases:
 *
 * 	* A single **sendmsg**\ () or **sendfile**\ () system call
 * 	  contains multiple logical messages that the eBPF program is
 * 	  supposed to read and for which it should apply a verdict.
 * 	* An eBPF program only cares to read the first *bytes* of a
 * 	  *msg*. If the message has a large payload, then setting up
 * 	  and calling the eBPF program repeatedly for all bytes, even
 * 	  though the verdict is already known, would create unnecessary
 * 	  overhead.
 *
 * 	When called from within an eBPF program, the helper sets a
 * 	counter internal to the BPF infrastructure, that is used to
 * 	apply the last verdict to the next *bytes*. If *bytes* is
 * 	smaller than the current data being processed from a
 * 	**sendmsg**\ () or **sendfile**\ () system call, the first
 * 	*bytes* will be sent and the eBPF program will be re-run with
 * 	the pointer for start of data pointing to byte number *bytes*
 * 	**+ 1**. If *bytes* is larger than the current data being
 * 	processed, then the eBPF verdict will be applied to multiple
 * 	**sendmsg**\ () or **sendfile**\ () calls until *bytes* are
 * 	consumed.
 *
 * 	Note that if a socket closes with the internal counter holding
 * 	a non-zero value, this is not a problem because data is not
 * 	being buffered for *bytes* and is sent as it is received.
 *
 * Returns
 * 	0
 */
static long (*bpf_msg_apply_bytes)(struct sk_msg_md *msg, __u32 bytes) = (void *) 61;

/*
 * bpf_msg_cork_bytes
 *
 * 	For socket policies, prevent the execution of the verdict eBPF
 * 	program for message *msg* until *bytes* (byte number) have been
 * 	accumulated.
 *
 * 	This can be used when one needs a specific number of bytes
 * 	before a verdict can be assigned, even if the data spans
 * 	multiple **sendmsg**\ () or **sendfile**\ () calls. The extreme
 * 	case would be a user calling **sendmsg**\ () repeatedly with
 * 	1-byte long message segments. Obviously, this is bad for
 * 	performance, but it is still valid. If the eBPF program needs
 * 	*bytes* bytes to validate a header, this helper can be used to
 * 	prevent the eBPF program to be called again until *bytes* have
 * 	been accumulated.
 *
 * Returns
 * 	0
 */
static long (*bpf_msg_cork_bytes)(struct sk_msg_md *msg, __u32 bytes) = (void *) 62;

/*
 * bpf_msg_pull_data
 *
 * 	For socket policies, pull in non-linear data from user space
 * 	for *msg* and set pointers *msg*\ **->data** and *msg*\
 * 	**->data_end** to *start* and *end* bytes offsets into *msg*,
 * 	respectively.
 *
 * 	If a program of type **BPF_PROG_TYPE_SK_MSG** is run on a
 * 	*msg* it can only parse data that the (**data**, **data_end**)
 * 	pointers have already consumed. For **sendmsg**\ () hooks this
 * 	is likely the first scatterlist element. But for calls relying
 * 	on the **sendpage** handler (e.g. **sendfile**\ ()) this will
 * 	be the range (**0**, **0**) because the data is shared with
 * 	user space and by default the objective is to avoid allowing
 * 	user space to modify data while (or after) eBPF verdict is
 * 	being decided. This helper can be used to pull in data and to
 * 	set the start and end pointer to given values. Data will be
 * 	copied if necessary (i.e. if data was not linear and if start
 * 	and end pointers do not point to the same chunk).
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_msg_pull_data)(struct sk_msg_md *msg, __u32 start, __u32 end, __u64 flags) = (void *) 63;

/*
 * bpf_bind
 *
 * 	Bind the socket associated to *ctx* to the address pointed by
 * 	*addr*, of length *addr_len*. This allows for making outgoing
 * 	connection from the desired IP address, which can be useful for
 * 	example when all processes inside a cgroup should use one
 * 	single IP address on a host that has multiple IP configured.
 *
 * 	This helper works for IPv4 and IPv6, TCP and UDP sockets. The
 * 	domain (*addr*\ **->sa_family**) must be **AF_INET** (or
 * 	**AF_INET6**). It's advised to pass zero port (**sin_port**
 * 	or **sin6_port**) which triggers IP_BIND_ADDRESS_NO_PORT-like
 * 	behavior and lets the kernel efficiently pick up an unused
 * 	port as long as 4-tuple is unique. Passing non-zero port might
 * 	lead to degraded performance.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_bind)(struct bpf_sock_addr *ctx, struct sockaddr *addr, int addr_len) = (void *) 64;

/*
 * bpf_xdp_adjust_tail
 *
 * 	Adjust (move) *xdp_md*\ **->data_end** by *delta* bytes. It is
 * 	possible to both shrink and grow the packet tail.
 * 	Shrink done via *delta* being a negative integer.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_xdp_adjust_tail)(struct xdp_md *xdp_md, int delta) = (void *) 65;

/*
 * bpf_skb_get_xfrm_state
 *
 * 	Retrieve the XFRM state (IP transform framework, see also
 * 	**ip-xfrm(8)**) at *index* in XFRM "security path" for *skb*.
 *
 * 	The retrieved value is stored in the **struct bpf_xfrm_state**
 * 	pointed by *xfrm_state* and of length *size*.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	This helper is available only if the kernel was compiled with
 * 	**CONFIG_XFRM** configuration option.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_get_xfrm_state)(struct __sk_buff *skb, __u32 index, struct bpf_xfrm_state *xfrm_state, __u32 size, __u64 flags) = (void *) 66;

/*
 * bpf_get_stack
 *
 * 	Return a user or a kernel stack in bpf program provided buffer.
 * 	To achieve this, the helper needs *ctx*, which is a pointer
 * 	to the context on which the tracing program is executed.
 * 	To store the stacktrace, the bpf program provides *buf* with
 * 	a nonnegative *size*.
 *
 * 	The last argument, *flags*, holds the number of stack frames to
 * 	skip (from 0 to 255), masked with
 * 	**BPF_F_SKIP_FIELD_MASK**. The next bits can be used to set
 * 	the following flags:
 *
 * 	**BPF_F_USER_STACK**
 * 		Collect a user space stack instead of a kernel stack.
 * 	**BPF_F_USER_BUILD_ID**
 * 		Collect buildid+offset instead of ips for user stack,
 * 		only valid if **BPF_F_USER_STACK** is also specified.
 *
 * 	**bpf_get_stack**\ () can collect up to
 * 	**PERF_MAX_STACK_DEPTH** both kernel and user frames, subject
 * 	to sufficient large buffer size. Note that
 * 	this limit can be controlled with the **sysctl** program, and
 * 	that it should be manually increased in order to profile long
 * 	user stacks (such as stacks for Java programs). To do so, use:
 *
 * 	::
 *
 * 		# sysctl kernel.perf_event_max_stack=<new value>
 *
 * Returns
 * 	A non-negative value equal to or less than *size* on success,
 * 	or a negative error in case of failure.
 */
static long (*bpf_get_stack)(void *ctx, void *buf, __u32 size, __u64 flags) = (void *) 67;

/*
 * bpf_skb_load_bytes_relative
 *
 * 	This helper is similar to **bpf_skb_load_bytes**\ () in that
 * 	it provides an easy way to load *len* bytes from *offset*
 * 	from the packet associated to *skb*, into the buffer pointed
 * 	by *to*. The difference to **bpf_skb_load_bytes**\ () is that
 * 	a fifth argument *start_header* exists in order to select a
 * 	base offset to start from. *start_header* can be one of:
 *
 * 	**BPF_HDR_START_MAC**
 * 		Base offset to load data from is *skb*'s mac header.
 * 	**BPF_HDR_START_NET**
 * 		Base offset to load data from is *skb*'s network header.
 *
 * 	In general, "direct packet access" is the preferred method to
 * 	access packet data, however, this helper is in particular useful
 * 	in socket filters where *skb*\ **->data** does not always point
 * 	to the start of the mac header and where "direct packet access"
 * 	is not available.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_load_bytes_relative)(const void *skb, __u32 offset, void *to, __u32 len, __u32 start_header) = (void *) 68;

/*
 * bpf_fib_lookup
 *
 * 	Do FIB lookup in kernel tables using parameters in *params*.
 * 	If lookup is successful and result shows packet is to be
 * 	forwarded, the neighbor tables are searched for the nexthop.
 * 	If successful (ie., FIB lookup shows forwarding and nexthop
 * 	is resolved), the nexthop address is returned in ipv4_dst
 * 	or ipv6_dst based on family, smac is set to mac address of
 * 	egress device, dmac is set to nexthop mac address, rt_metric
 * 	is set to metric from route (IPv4/IPv6 only), and ifindex
 * 	is set to the device index of the nexthop from the FIB lookup.
 *
 * 	*plen* argument is the size of the passed in struct.
 * 	*flags* argument can be a combination of one or more of the
 * 	following values:
 *
 * 	**BPF_FIB_LOOKUP_DIRECT**
 * 		Do a direct table lookup vs full lookup using FIB
 * 		rules.
 * 	**BPF_FIB_LOOKUP_OUTPUT**
 * 		Perform lookup from an egress perspective (default is
 * 		ingress).
 *
 * 	*ctx* is either **struct xdp_md** for XDP programs or
 * 	**struct sk_buff** tc cls_act programs.
 *
 * Returns
 * 	* < 0 if any input argument is invalid
 * 	*   0 on success (packet is forwarded, nexthop neighbor exists)
 * 	* > 0 one of **BPF_FIB_LKUP_RET_** codes explaining why the
 * 	  packet is not forwarded or needs assist from full stack
 *
 * 	If lookup fails with BPF_FIB_LKUP_RET_FRAG_NEEDED, then the MTU
 * 	was exceeded and output params->mtu_result contains the MTU.
 */
static long (*bpf_fib_lookup)(void *ctx, struct bpf_fib_lookup *params, int plen, __u32 flags) = (void *) 69;

/*
 * bpf_sock_hash_update
 *
 * 	Add an entry to, or update a sockhash *map* referencing sockets.
 * 	The *skops* is used as a new value for the entry associated to
 * 	*key*. *flags* is one of:
 *
 * 	**BPF_NOEXIST**
 * 		The entry for *key* must not exist in the map.
 * 	**BPF_EXIST**
 * 		The entry for *key* must already exist in the map.
 * 	**BPF_ANY**
 * 		No condition on the existence of the entry for *key*.
 *
 * 	If the *map* has eBPF programs (parser and verdict), those will
 * 	be inherited by the socket being added. If the socket is
 * 	already attached to eBPF programs, this results in an error.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_sock_hash_update)(struct bpf_sock_ops *skops, void *map, void *key, __u64 flags) = (void *) 70;

/*
 * bpf_msg_redirect_hash
 *
 * 	This helper is used in programs implementing policies at the
 * 	socket level. If the message *msg* is allowed to pass (i.e. if
 * 	the verdict eBPF program returns **SK_PASS**), redirect it to
 * 	the socket referenced by *map* (of type
 * 	**BPF_MAP_TYPE_SOCKHASH**) using hash *key*. Both ingress and
 * 	egress interfaces can be used for redirection. The
 * 	**BPF_F_INGRESS** value in *flags* is used to make the
 * 	distinction (ingress path is selected if the flag is present,
 * 	egress path otherwise). This is the only flag supported for now.
 *
 * Returns
 * 	**SK_PASS** on success, or **SK_DROP** on error.
 */
static long (*bpf_msg_redirect_hash)(struct sk_msg_md *msg, void *map, void *key, __u64 flags) = (void *) 71;

/*
 * bpf_sk_redirect_hash
 *
 * 	This helper is used in programs implementing policies at the
 * 	skb socket level. If the sk_buff *skb* is allowed to pass (i.e.
 * 	if the verdict eBPF program returns **SK_PASS**), redirect it
 * 	to the socket referenced by *map* (of type
 * 	**BPF_MAP_TYPE_SOCKHASH**) using hash *key*. Both ingress and
 * 	egress interfaces can be used for redirection. The
 * 	**BPF_F_INGRESS** value in *flags* is used to make the
 * 	distinction (ingress path is selected if the flag is present,
 * 	egress otherwise). This is the only flag supported for now.
 *
 * Returns
 * 	**SK_PASS** on success, or **SK_DROP** on error.
 */
static long (*bpf_sk_redirect_hash)(struct __sk_buff *skb, void *map, void *key, __u64 flags) = (void *) 72;

/*
 * bpf_lwt_push_encap
 *
 * 	Encapsulate the packet associated to *skb* within a Layer 3
 * 	protocol header. This header is provided in the buffer at
 * 	address *hdr*, with *len* its size in bytes. *type* indicates
 * 	the protocol of the header and can be one of:
 *
 * 	**BPF_LWT_ENCAP_SEG6**
 * 		IPv6 encapsulation with Segment Routing Header
 * 		(**struct ipv6_sr_hdr**). *hdr* only contains the SRH,
 * 		the IPv6 header is computed by the kernel.
 * 	**BPF_LWT_ENCAP_SEG6_INLINE**
 * 		Only works if *skb* contains an IPv6 packet. Insert a
 * 		Segment Routing Header (**struct ipv6_sr_hdr**) inside
 * 		the IPv6 header.
 * 	**BPF_LWT_ENCAP_IP**
 * 		IP encapsulation (GRE/GUE/IPIP/etc). The outer header
 * 		must be IPv4 or IPv6, followed by zero or more
 * 		additional headers, up to **LWT_BPF_MAX_HEADROOM**
 * 		total bytes in all prepended headers. Please note that
 * 		if **skb_is_gso**\ (*skb*) is true, no more than two
 * 		headers can be prepended, and the inner header, if
 * 		present, should be either GRE or UDP/GUE.
 *
 * 	**BPF_LWT_ENCAP_SEG6**\ \* types can be called by BPF programs
 * 	of type **BPF_PROG_TYPE_LWT_IN**; **BPF_LWT_ENCAP_IP** type can
 * 	be called by bpf programs of types **BPF_PROG_TYPE_LWT_IN** and
 * 	**BPF_PROG_TYPE_LWT_XMIT**.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_lwt_push_encap)(struct __sk_buff *skb, __u32 type, void *hdr, __u32 len) = (void *) 73;

/*
 * bpf_lwt_seg6_store_bytes
 *
 * 	Store *len* bytes from address *from* into the packet
 * 	associated to *skb*, at *offset*. Only the flags, tag and TLVs
 * 	inside the outermost IPv6 Segment Routing Header can be
 * 	modified through this helper.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_lwt_seg6_store_bytes)(struct __sk_buff *skb, __u32 offset, const void *from, __u32 len) = (void *) 74;

/*
 * bpf_lwt_seg6_adjust_srh
 *
 * 	Adjust the size allocated to TLVs in the outermost IPv6
 * 	Segment Routing Header contained in the packet associated to
 * 	*skb*, at position *offset* by *delta* bytes. Only offsets
 * 	after the segments are accepted. *delta* can be as well
 * 	positive (growing) as negative (shrinking).
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_lwt_seg6_adjust_srh)(struct __sk_buff *skb, __u32 offset, __s32 delta) = (void *) 75;

/*
 * bpf_lwt_seg6_action
 *
 * 	Apply an IPv6 Segment Routing action of type *action* to the
 * 	packet associated to *skb*. Each action takes a parameter
 * 	contained at address *param*, and of length *param_len* bytes.
 * 	*action* can be one of:
 *
 * 	**SEG6_LOCAL_ACTION_END_X**
 * 		End.X action: Endpoint with Layer-3 cross-connect.
 * 		Type of *param*: **struct in6_addr**.
 * 	**SEG6_LOCAL_ACTION_END_T**
 * 		End.T action: Endpoint with specific IPv6 table lookup.
 * 		Type of *param*: **int**.
 * 	**SEG6_LOCAL_ACTION_END_B6**
 * 		End.B6 action: Endpoint bound to an SRv6 policy.
 * 		Type of *param*: **struct ipv6_sr_hdr**.
 * 	**SEG6_LOCAL_ACTION_END_B6_ENCAP**
 * 		End.B6.Encap action: Endpoint bound to an SRv6
 * 		encapsulation policy.
 * 		Type of *param*: **struct ipv6_sr_hdr**.
 *
 * 	A call to this helper is susceptible to change the underlying
 * 	packet buffer. Therefore, at load time, all checks on pointers
 * 	previously done by the verifier are invalidated and must be
 * 	performed again, if the helper is used in combination with
 * 	direct packet access.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_lwt_seg6_action)(struct __sk_buff *skb, __u32 action, void *param, __u32 param_len) = (void *) 76;

/*
 * bpf_rc_repeat
 *
 * 	This helper is used in programs implementing IR decoding, to
 * 	report a successfully decoded repeat key message. This delays
 * 	the generation of a key up event for previously generated
 * 	key down event.
 *
 * 	Some IR protocols like NEC have a special IR message for
 * 	repeating last button, for when a button is held down.
 *
 * 	The *ctx* should point to the lirc sample as passed into
 * 	the program.
 *
 * 	This helper is only available is the kernel was compiled with
 * 	the **CONFIG_BPF_LIRC_MODE2** configuration option set to
 * 	"**y**".
 *
 * Returns
 * 	0
 */
static long (*bpf_rc_repeat)(void *ctx) = (void *) 77;

/*
 * bpf_rc_keydown
 *
 * 	This helper is used in programs implementing IR decoding, to
 * 	report a successfully decoded key press with *scancode*,
 * 	*toggle* value in the given *protocol*. The scancode will be
 * 	translated to a keycode using the rc keymap, and reported as
 * 	an input key down event. After a period a key up event is
 * 	generated. This period can be extended by calling either
 * 	**bpf_rc_keydown**\ () again with the same values, or calling
 * 	**bpf_rc_repeat**\ ().
 *
 * 	Some protocols include a toggle bit, in case the button was
 * 	released and pressed again between consecutive scancodes.
 *
 * 	The *ctx* should point to the lirc sample as passed into
 * 	the program.
 *
 * 	The *protocol* is the decoded protocol number (see
 * 	**enum rc_proto** for some predefined values).
 *
 * 	This helper is only available is the kernel was compiled with
 * 	the **CONFIG_BPF_LIRC_MODE2** configuration option set to
 * 	"**y**".
 *
 * Returns
 * 	0
 */
static long (*bpf_rc_keydown)(void *ctx, __u32 protocol, __u64 scancode, __u32 toggle) = (void *) 78;

/*
 * bpf_skb_cgroup_id
 *
 * 	Return the cgroup v2 id of the socket associated with the *skb*.
 * 	This is roughly similar to the **bpf_get_cgroup_classid**\ ()
 * 	helper for cgroup v1 by providing a tag resp. identifier that
 * 	can be matched on or used for map lookups e.g. to implement
 * 	policy. The cgroup v2 id of a given path in the hierarchy is
 * 	exposed in user space through the f_handle API in order to get
 * 	to the same 64-bit id.
 *
 * 	This helper can be used on TC egress path, but not on ingress,
 * 	and is available only if the kernel was compiled with the
 * 	**CONFIG_SOCK_CGROUP_DATA** configuration option.
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_skb_cgroup_id)(struct __sk_buff *skb) = (void *) 79;

/*
 * bpf_get_current_cgroup_id
 *
 *
 * Returns
 * 	A 64-bit integer containing the current cgroup id based
 * 	on the cgroup within which the current task is running.
 */
static __u64 (*bpf_get_current_cgroup_id)(void) = (void *) 80;

/*
 * bpf_get_local_storage
 *
 * 	Get the pointer to the local storage area.
 * 	The type and the size of the local storage is defined
 * 	by the *map* argument.
 * 	The *flags* meaning is specific for each map type,
 * 	and has to be 0 for cgroup local storage.
 *
 * 	Depending on the BPF program type, a local storage area
 * 	can be shared between multiple instances of the BPF program,
 * 	running simultaneously.
 *
 * 	A user should care about the synchronization by himself.
 * 	For example, by using the **BPF_ATOMIC** instructions to alter
 * 	the shared data.
 *
 * Returns
 * 	A pointer to the local storage area.
 */
static void *(*bpf_get_local_storage)(void *map, __u64 flags) = (void *) 81;

/*
 * bpf_sk_select_reuseport
 *
 * 	Select a **SO_REUSEPORT** socket from a
 * 	**BPF_MAP_TYPE_REUSEPORT_SOCKARRAY** *map*.
 * 	It checks the selected socket is matching the incoming
 * 	request in the socket buffer.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_sk_select_reuseport)(struct sk_reuseport_md *reuse, void *map, void *key, __u64 flags) = (void *) 82;

/*
 * bpf_skb_ancestor_cgroup_id
 *
 * 	Return id of cgroup v2 that is ancestor of cgroup associated
 * 	with the *skb* at the *ancestor_level*.  The root cgroup is at
 * 	*ancestor_level* zero and each step down the hierarchy
 * 	increments the level. If *ancestor_level* == level of cgroup
 * 	associated with *skb*, then return value will be same as that
 * 	of **bpf_skb_cgroup_id**\ ().
 *
 * 	The helper is useful to implement policies based on cgroups
 * 	that are upper in hierarchy than immediate cgroup associated
 * 	with *skb*.
 *
 * 	The format of returned id and helper limitations are same as in
 * 	**bpf_skb_cgroup_id**\ ().
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_skb_ancestor_cgroup_id)(struct __sk_buff *skb, int ancestor_level) = (void *) 83;

/*
 * bpf_sk_lookup_tcp
 *
 * 	Look for TCP socket matching *tuple*, optionally in a child
 * 	network namespace *netns*. The return value must be checked,
 * 	and if non-**NULL**, released via **bpf_sk_release**\ ().
 *
 * 	The *ctx* should point to the context of the program, such as
 * 	the skb or socket (depending on the hook in use). This is used
 * 	to determine the base network namespace for the lookup.
 *
 * 	*tuple_size* must be one of:
 *
 * 	**sizeof**\ (*tuple*\ **->ipv4**)
 * 		Look for an IPv4 socket.
 * 	**sizeof**\ (*tuple*\ **->ipv6**)
 * 		Look for an IPv6 socket.
 *
 * 	If the *netns* is a negative signed 32-bit integer, then the
 * 	socket lookup table in the netns associated with the *ctx*
 * 	will be used. For the TC hooks, this is the netns of the device
 * 	in the skb. For socket hooks, this is the netns of the socket.
 * 	If *netns* is any other signed 32-bit value greater than or
 * 	equal to zero then it specifies the ID of the netns relative to
 * 	the netns associated with the *ctx*. *netns* values beyond the
 * 	range of 32-bit integers are reserved for future use.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	This helper is available only if the kernel was compiled with
 * 	**CONFIG_NET** configuration option.
 *
 * Returns
 * 	Pointer to **struct bpf_sock**, or **NULL** in case of failure.
 * 	For sockets with reuseport option, the **struct bpf_sock**
 * 	result is from *reuse*\ **->socks**\ [] using the hash of the
 * 	tuple.
 */
static struct bpf_sock *(*bpf_sk_lookup_tcp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 84;

/*
 * bpf_sk_lookup_udp
 *
 * 	Look for UDP socket matching *tuple*, optionally in a child
 * 	network namespace *netns*. The return value must be checked,
 * 	and if non-**NULL**, released via **bpf_sk_release**\ ().
 *
 * 	The *ctx* should point to the context of the program, such as
 * 	the skb or socket (depending on the hook in use). This is used
 * 	to determine the base network namespace for the lookup.
 *
 * 	*tuple_size* must be one of:
 *
 * 	**sizeof**\ (*tuple*\ **->ipv4**)
 * 		Look for an IPv4 socket.
 * 	**sizeof**\ (*tuple*\ **->ipv6**)
 * 		Look for an IPv6 socket.
 *
 * 	If the *netns* is a negative signed 32-bit integer, then the
 * 	socket lookup table in the netns associated with the *ctx*
 * 	will be used. For the TC hooks, this is the netns of the device
 * 	in the skb. For socket hooks, this is the netns of the socket.
 * 	If *netns* is any other signed 32-bit value greater than or
 * 	equal to zero then it specifies the ID of the netns relative to
 * 	the netns associated with the *ctx*. *netns* values beyond the
 * 	range of 32-bit integers are reserved for future use.
 *
 * 	All values for *flags* are reserved for future usage, and must
 * 	be left at zero.
 *
 * 	This helper is available only if the kernel was compiled with
 * 	**CONFIG_NET** configuration option.
 *
 * Returns
 * 	Pointer to **struct bpf_sock**, or **NULL** in case of failure.
 * 	For sockets with reuseport option, the **struct bpf_sock**
 * 	result is from *reuse*\ **->socks**\ [] using the hash of the
 * 	tuple.
 */
static struct bpf_sock *(*bpf_sk_lookup_udp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 85;

/*
 * bpf_sk_release
 *
 * 	Release the reference held by *sock*. *sock* must be a
 * 	non-**NULL** pointer that was returned from
 * 	**bpf_sk_lookup_xxx**\ ().
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_sk_release)(void *sock) = (void *) 86;

/*
 * bpf_map_push_elem
 *
 * 	Push an element *value* in *map*. *flags* is one of:
 *
 * 	**BPF_EXIST**
 * 		If the queue/stack is full, the oldest element is
 * 		removed to make room for this.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_map_push_elem)(void *map, const void *value, __u64 flags) = (void *) 87;

/*
 * bpf_map_pop_elem
 *
 * 	Pop an element from *map*.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_map_pop_elem)(void *map, void *value) = (void *) 88;

/*
 * bpf_map_peek_elem
 *
 * 	Get an element from *map* without removing it.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_map_peek_elem)(void *map, void *value) = (void *) 89;

/*
 * bpf_msg_push_data
 *
 * 	For socket policies, insert *len* bytes into *msg* at offset
 * 	*start*.
 *
 * 	If a program of type **BPF_PROG_TYPE_SK_MSG** is run on a
 * 	*msg* it may want to insert metadata or options into the *msg*.
 * 	This can later be read and used by any of the lower layer BPF
 * 	hooks.
 *
 * 	This helper may fail if under memory pressure (a malloc
 * 	fails) in these cases BPF programs will get an appropriate
 * 	error and BPF programs will need to handle them.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_msg_push_data)(struct sk_msg_md *msg, __u32 start, __u32 len, __u64 flags) = (void *) 90;

/*
 * bpf_msg_pop_data
 *
 * 	Will remove *len* bytes from a *msg* starting at byte *start*.
 * 	This may result in **ENOMEM** errors under certain situations if
 * 	an allocation and copy are required due to a full ring buffer.
 * 	However, the helper will try to avoid doing the allocation
 * 	if possible. Other errors can occur if input parameters are
 * 	invalid either due to *start* byte not being valid part of *msg*
 * 	payload and/or *pop* value being to large.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_msg_pop_data)(struct sk_msg_md *msg, __u32 start, __u32 len, __u64 flags) = (void *) 91;

/*
 * bpf_rc_pointer_rel
 *
 * 	This helper is used in programs implementing IR decoding, to
 * 	report a successfully decoded pointer movement.
 *
 * 	The *ctx* should point to the lirc sample as passed into
 * 	the program.
 *
 * 	This helper is only available is the kernel was compiled with
 * 	the **CONFIG_BPF_LIRC_MODE2** configuration option set to
 * 	"**y**".
 *
 * Returns
 * 	0
 */
static long (*bpf_rc_pointer_rel)(void *ctx, __s32 rel_x, __s32 rel_y) = (void *) 92;

/*
 * bpf_spin_lock
 *
 * 	Acquire a spinlock represented by the pointer *lock*, which is
 * 	stored as part of a value of a map. Taking the lock allows to
 * 	safely update the rest of the fields in that value. The
 * 	spinlock can (and must) later be released with a call to
 * 	**bpf_spin_unlock**\ (\ *lock*\ ).
 *
 * 	Spinlocks in BPF programs come with a number of restrictions
 * 	and constraints:
 *
 * 	* **bpf_spin_lock** objects are only allowed inside maps of
 * 	  types **BPF_MAP_TYPE_HASH** and **BPF_MAP_TYPE_ARRAY** (this
 * 	  list could be extended in the future).
 * 	* BTF description of the map is mandatory.
 * 	* The BPF program can take ONE lock at a time, since taking two
 * 	  or more could cause dead locks.
 * 	* Only one **struct bpf_spin_lock** is allowed per map element.
 * 	* When the lock is taken, calls (either BPF to BPF or helpers)
 * 	  are not allowed.
 * 	* The **BPF_LD_ABS** and **BPF_LD_IND** instructions are not
 * 	  allowed inside a spinlock-ed region.
 * 	* The BPF program MUST call **bpf_spin_unlock**\ () to release
 * 	  the lock, on all execution paths, before it returns.
 * 	* The BPF program can access **struct bpf_spin_lock** only via
 * 	  the **bpf_spin_lock**\ () and **bpf_spin_unlock**\ ()
 * 	  helpers. Loading or storing data into the **struct
 * 	  bpf_spin_lock** *lock*\ **;** field of a map is not allowed.
 * 	* To use the **bpf_spin_lock**\ () helper, the BTF description
 * 	  of the map value must be a struct and have **struct
 * 	  bpf_spin_lock** *anyname*\ **;** field at the top level.
 * 	  Nested lock inside another struct is not allowed.
 * 	* The **struct bpf_spin_lock** *lock* field in a map value must
 * 	  be aligned on a multiple of 4 bytes in that value.
 * 	* Syscall with command **BPF_MAP_LOOKUP_ELEM** does not copy
 * 	  the **bpf_spin_lock** field to user space.
 * 	* Syscall with command **BPF_MAP_UPDATE_ELEM**, or update from
 * 	  a BPF program, do not update the **bpf_spin_lock** field.
 * 	* **bpf_spin_lock** cannot be on the stack or inside a
 * 	  networking packet (it can only be inside of a map values).
 * 	* **bpf_spin_lock** is available to root only.
 * 	* Tracing programs and socket filter programs cannot use
 * 	  **bpf_spin_lock**\ () due to insufficient preemption checks
 * 	  (but this may change in the future).
 * 	* **bpf_spin_lock** is not allowed in inner maps of map-in-map.
 *
 * Returns
 * 	0
 */
static long (*bpf_spin_lock)(struct bpf_spin_lock *lock) = (void *) 93;

/*
 * bpf_spin_unlock
 *
 * 	Release the *lock* previously locked by a call to
 * 	**bpf_spin_lock**\ (\ *lock*\ ).
 *
 * Returns
 * 	0
 */
static long (*bpf_spin_unlock)(struct bpf_spin_lock *lock) = (void *) 94;

/*
 * bpf_sk_fullsock
 *
 * 	This helper gets a **struct bpf_sock** pointer such
 * 	that all the fields in this **bpf_sock** can be accessed.
 *
 * Returns
 * 	A **struct bpf_sock** pointer on success, or **NULL** in
 * 	case of failure.
 */
static struct bpf_sock *(*bpf_sk_fullsock)(struct bpf_sock *sk) = (void *) 95;

/*
 * bpf_tcp_sock
 *
 * 	This helper gets a **struct bpf_tcp_sock** pointer from a
 * 	**struct bpf_sock** pointer.
 *
 * Returns
 * 	A **struct bpf_tcp_sock** pointer on success, or **NULL** in
 * 	case of failure.
 */
static struct bpf_tcp_sock *(*bpf_tcp_sock)(struct bpf_sock *sk) = (void *) 96;

/*
 * bpf_skb_ecn_set_ce
 *
 * 	Set ECN (Explicit Congestion Notification) field of IP header
 * 	to **CE** (Congestion Encountered) if current value is **ECT**
 * 	(ECN Capable Transport). Otherwise, do nothing. Works with IPv6
 * 	and IPv4.
 *
 * Returns
 * 	1 if the **CE** flag is set (either by the current helper call
 * 	or because it was already present), 0 if it is not set.
 */
static long (*bpf_skb_ecn_set_ce)(struct __sk_buff *skb) = (void *) 97;

/*
 * bpf_get_listener_sock
 *
 * 	Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
 * 	**bpf_sk_release**\ () is unnecessary and not allowed.
 *
 * Returns
 * 	A **struct bpf_sock** pointer on success, or **NULL** in
 * 	case of failure.
 */
static struct bpf_sock *(*bpf_get_listener_sock)(struct bpf_sock *sk) = (void *) 98;

/*
 * bpf_skc_lookup_tcp
 *
 * 	Look for TCP socket matching *tuple*, optionally in a child
 * 	network namespace *netns*. The return value must be checked,
 * 	and if non-**NULL**, released via **bpf_sk_release**\ ().
 *
 * 	This function is identical to **bpf_sk_lookup_tcp**\ (), except
 * 	that it also returns timewait or request sockets. Use
 * 	**bpf_sk_fullsock**\ () or **bpf_tcp_sock**\ () to access the
 * 	full structure.
 *
 * 	This helper is available only if the kernel was compiled with
 * 	**CONFIG_NET** configuration option.
 *
 * Returns
 * 	Pointer to **struct bpf_sock**, or **NULL** in case of failure.
 * 	For sockets with reuseport option, the **struct bpf_sock**
 * 	result is from *reuse*\ **->socks**\ [] using the hash of the
 * 	tuple.
 */
static struct bpf_sock *(*bpf_skc_lookup_tcp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 99;

/*
 * bpf_tcp_check_syncookie
 *
 * 	Check whether *iph* and *th* contain a valid SYN cookie ACK for
 * 	the listening socket in *sk*.
 *
 * 	*iph* points to the start of the IPv4 or IPv6 header, while
 * 	*iph_len* contains **sizeof**\ (**struct iphdr**) or
 * 	**sizeof**\ (**struct ip6hdr**).
 *
 * 	*th* points to the start of the TCP header, while *th_len*
 * 	contains **sizeof**\ (**struct tcphdr**).
 *
 * Returns
 * 	0 if *iph* and *th* are a valid SYN cookie ACK, or a negative
 * 	error otherwise.
 */
static long (*bpf_tcp_check_syncookie)(void *sk, void *iph, __u32 iph_len, struct tcphdr *th, __u32 th_len) = (void *) 100;

/*
 * bpf_sysctl_get_name
 *
 * 	Get name of sysctl in /proc/sys/ and copy it into provided by
 * 	program buffer *buf* of size *buf_len*.
 *
 * 	The buffer is always NUL terminated, unless it's zero-sized.
 *
 * 	If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
 * 	copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
 * 	only (e.g. "tcp_mem").
 *
 * Returns
 * 	Number of character copied (not including the trailing NUL).
 *
 * 	**-E2BIG** if the buffer wasn't big enough (*buf* will contain
 * 	truncated name in this case).
 */
static long (*bpf_sysctl_get_name)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len, __u64 flags) = (void *) 101;

/*
 * bpf_sysctl_get_current_value
 *
 * 	Get current value of sysctl as it is presented in /proc/sys
 * 	(incl. newline, etc), and copy it as a string into provided
 * 	by program buffer *buf* of size *buf_len*.
 *
 * 	The whole value is copied, no matter what file position user
 * 	space issued e.g. sys_read at.
 *
 * 	The buffer is always NUL terminated, unless it's zero-sized.
 *
 * Returns
 * 	Number of character copied (not including the trailing NUL).
 *
 * 	**-E2BIG** if the buffer wasn't big enough (*buf* will contain
 * 	truncated name in this case).
 *
 * 	**-EINVAL** if current value was unavailable, e.g. because
 * 	sysctl is uninitialized and read returns -EIO for it.
 */
static long (*bpf_sysctl_get_current_value)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len) = (void *) 102;

/*
 * bpf_sysctl_get_new_value
 *
 * 	Get new value being written by user space to sysctl (before
 * 	the actual write happens) and copy it as a string into
 * 	provided by program buffer *buf* of size *buf_len*.
 *
 * 	User space may write new value at file position > 0.
 *
 * 	The buffer is always NUL terminated, unless it's zero-sized.
 *
 * Returns
 * 	Number of character copied (not including the trailing NUL).
 *
 * 	**-E2BIG** if the buffer wasn't big enough (*buf* will contain
 * 	truncated name in this case).
 *
 * 	**-EINVAL** if sysctl is being read.
 */
static long (*bpf_sysctl_get_new_value)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len) = (void *) 103;

/*
 * bpf_sysctl_set_new_value
 *
 * 	Override new value being written by user space to sysctl with
 * 	value provided by program in buffer *buf* of size *buf_len*.
 *
 * 	*buf* should contain a string in same form as provided by user
 * 	space on sysctl write.
 *
 * 	User space may write new value at file position > 0. To override
 * 	the whole sysctl value file position should be set to zero.
 *
 * Returns
 * 	0 on success.
 *
 * 	**-E2BIG** if the *buf_len* is too big.
 *
 * 	**-EINVAL** if sysctl is being read.
 */
static long (*bpf_sysctl_set_new_value)(struct bpf_sysctl *ctx, const char *buf, unsigned long buf_len) = (void *) 104;

/*
 * bpf_strtol
 *
 * 	Convert the initial part of the string from buffer *buf* of
 * 	size *buf_len* to a long integer according to the given base
 * 	and save the result in *res*.
 *
 * 	The string may begin with an arbitrary amount of white space
 * 	(as determined by **isspace**\ (3)) followed by a single
 * 	optional '**-**' sign.
 *
 * 	Five least significant bits of *flags* encode base, other bits
 * 	are currently unused.
 *
 * 	Base must be either 8, 10, 16 or 0 to detect it automatically
 * 	similar to user space **strtol**\ (3).
 *
 * Returns
 * 	Number of characters consumed on success. Must be positive but
 * 	no more than *buf_len*.
 *
 * 	**-EINVAL** if no valid digits were found or unsupported base
 * 	was provided.
 *
 * 	**-ERANGE** if resulting value was out of range.
 */
static long (*bpf_strtol)(const char *buf, unsigned long buf_len, __u64 flags, long *res) = (void *) 105;

/*
 * bpf_strtoul
 *
 * 	Convert the initial part of the string from buffer *buf* of
 * 	size *buf_len* to an unsigned long integer according to the
 * 	given base and save the result in *res*.
 *
 * 	The string may begin with an arbitrary amount of white space
 * 	(as determined by **isspace**\ (3)).
 *
 * 	Five least significant bits of *flags* encode base, other bits
 * 	are currently unused.
 *
 * 	Base must be either 8, 10, 16 or 0 to detect it automatically
 * 	similar to user space **strtoul**\ (3).
 *
 * Returns
 * 	Number of characters consumed on success. Must be positive but
 * 	no more than *buf_len*.
 *
 * 	**-EINVAL** if no valid digits were found or unsupported base
 * 	was provided.
 *
 * 	**-ERANGE** if resulting value was out of range.
 */
static long (*bpf_strtoul)(const char *buf, unsigned long buf_len, __u64 flags, unsigned long *res) = (void *) 106;

/*
 * bpf_sk_storage_get
 *
 * 	Get a bpf-local-storage from a *sk*.
 *
 * 	Logically, it could be thought of getting the value from
 * 	a *map* with *sk* as the **key**.  From this
 * 	perspective,  the usage is not much different from
 * 	**bpf_map_lookup_elem**\ (*map*, **&**\ *sk*) except this
 * 	helper enforces the key must be a full socket and the map must
 * 	be a **BPF_MAP_TYPE_SK_STORAGE** also.
 *
 * 	Underneath, the value is stored locally at *sk* instead of
 * 	the *map*.  The *map* is used as the bpf-local-storage
 * 	"type". The bpf-local-storage "type" (i.e. the *map*) is
 * 	searched against all bpf-local-storages residing at *sk*.
 *
 * 	*sk* is a kernel **struct sock** pointer for LSM program.
 * 	*sk* is a **struct bpf_sock** pointer for other program types.
 *
 * 	An optional *flags* (**BPF_SK_STORAGE_GET_F_CREATE**) can be
 * 	used such that a new bpf-local-storage will be
 * 	created if one does not exist.  *value* can be used
 * 	together with **BPF_SK_STORAGE_GET_F_CREATE** to specify
 * 	the initial value of a bpf-local-storage.  If *value* is
 * 	**NULL**, the new bpf-local-storage will be zero initialized.
 *
 * Returns
 * 	A bpf-local-storage pointer is returned on success.
 *
 * 	**NULL** if not found or there was an error in adding
 * 	a new bpf-local-storage.
 */
static void *(*bpf_sk_storage_get)(void *map, void *sk, void *value, __u64 flags) = (void *) 107;

/*
 * bpf_sk_storage_delete
 *
 * 	Delete a bpf-local-storage from a *sk*.
 *
 * Returns
 * 	0 on success.
 *
 * 	**-ENOENT** if the bpf-local-storage cannot be found.
 * 	**-EINVAL** if sk is not a fullsock (e.g. a request_sock).
 */
static long (*bpf_sk_storage_delete)(void *map, void *sk) = (void *) 108;

/*
 * bpf_send_signal
 *
 * 	Send signal *sig* to the process of the current task.
 * 	The signal may be delivered to any of this process's threads.
 *
 * Returns
 * 	0 on success or successfully queued.
 *
 * 	**-EBUSY** if work queue under nmi is full.
 *
 * 	**-EINVAL** if *sig* is invalid.
 *
 * 	**-EPERM** if no permission to send the *sig*.
 *
 * 	**-EAGAIN** if bpf program can try again.
 */
static long (*bpf_send_signal)(__u32 sig) = (void *) 109;

/*
 * bpf_tcp_gen_syncookie
 *
 * 	Try to issue a SYN cookie for the packet with corresponding
 * 	IP/TCP headers, *iph* and *th*, on the listening socket in *sk*.
 *
 * 	*iph* points to the start of the IPv4 or IPv6 header, while
 * 	*iph_len* contains **sizeof**\ (**struct iphdr**) or
 * 	**sizeof**\ (**struct ip6hdr**).
 *
 * 	*th* points to the start of the TCP header, while *th_len*
 * 	contains the length of the TCP header.
 *
 * Returns
 * 	On success, lower 32 bits hold the generated SYN cookie in
 * 	followed by 16 bits which hold the MSS value for that cookie,
 * 	and the top 16 bits are unused.
 *
 * 	On failure, the returned value is one of the following:
 *
 * 	**-EINVAL** SYN cookie cannot be issued due to error
 *
 * 	**-ENOENT** SYN cookie should not be issued (no SYN flood)
 *
 * 	**-EOPNOTSUPP** kernel configuration does not enable SYN cookies
 *
 * 	**-EPROTONOSUPPORT** IP packet version is not 4 or 6
 */
static __s64 (*bpf_tcp_gen_syncookie)(void *sk, void *iph, __u32 iph_len, struct tcphdr *th, __u32 th_len) = (void *) 110;

/*
 * bpf_skb_output
 *
 * 	Write raw *data* blob into a special BPF perf event held by
 * 	*map* of type **BPF_MAP_TYPE_PERF_EVENT_ARRAY**. This perf
 * 	event must have the following attributes: **PERF_SAMPLE_RAW**
 * 	as **sample_type**, **PERF_TYPE_SOFTWARE** as **type**, and
 * 	**PERF_COUNT_SW_BPF_OUTPUT** as **config**.
 *
 * 	The *flags* are used to indicate the index in *map* for which
 * 	the value must be put, masked with **BPF_F_INDEX_MASK**.
 * 	Alternatively, *flags* can be set to **BPF_F_CURRENT_CPU**
 * 	to indicate that the index of the current CPU core should be
 * 	used.
 *
 * 	The value to write, of *size*, is passed through eBPF stack and
 * 	pointed by *data*.
 *
 * 	*ctx* is a pointer to in-kernel struct sk_buff.
 *
 * 	This helper is similar to **bpf_perf_event_output**\ () but
 * 	restricted to raw_tracepoint bpf programs.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_skb_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 111;

/*
 * bpf_probe_read_user
 *
 * 	Safely attempt to read *size* bytes from user space address
 * 	*unsafe_ptr* and store the data in *dst*.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_probe_read_user)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 112;

/*
 * bpf_probe_read_kernel
 *
 * 	Safely attempt to read *size* bytes from kernel space address
 * 	*unsafe_ptr* and store the data in *dst*.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_probe_read_kernel)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 113;

/*
 * bpf_probe_read_user_str
 *
 * 	Copy a NUL terminated string from an unsafe user address
 * 	*unsafe_ptr* to *dst*. The *size* should include the
 * 	terminating NUL byte. In case the string length is smaller than
 * 	*size*, the target is not padded with further NUL bytes. If the
 * 	string length is larger than *size*, just *size*-1 bytes are
 * 	copied and the last byte is set to NUL.
 *
 * 	On success, returns the number of bytes that were written,
 * 	including the terminal NUL. This makes this helper useful in
 * 	tracing programs for reading strings, and more importantly to
 * 	get its length at runtime. See the following snippet:
 *
 * 	::
 *
 * 		SEC("kprobe/sys_open")
 * 		void bpf_sys_open(struct pt_regs *ctx)
 * 		{
 * 		        char buf[PATHLEN]; // PATHLEN is defined to 256
 * 		        int res = bpf_probe_read_user_str(buf, sizeof(buf),
 * 			                                  ctx->di);
 *
 * 			// Consume buf, for example push it to
 * 			// userspace via bpf_perf_event_output(); we
 * 			// can use res (the string length) as event
 * 			// size, after checking its boundaries.
 * 		}
 *
 * 	In comparison, using **bpf_probe_read_user**\ () helper here
 * 	instead to read the string would require to estimate the length
 * 	at compile time, and would often result in copying more memory
 * 	than necessary.
 *
 * 	Another useful use case is when parsing individual process
 * 	arguments or individual environment variables navigating
 * 	*current*\ **->mm->arg_start** and *current*\
 * 	**->mm->env_start**: using this helper and the return value,
 * 	one can quickly iterate at the right offset of the memory area.
 *
 * Returns
 * 	On success, the strictly positive length of the output string,
 * 	including the trailing NUL character. On error, a negative
 * 	value.
 */
static long (*bpf_probe_read_user_str)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 114;

/*
 * bpf_probe_read_kernel_str
 *
 * 	Copy a NUL terminated string from an unsafe kernel address *unsafe_ptr*
 * 	to *dst*. Same semantics as with **bpf_probe_read_user_str**\ () apply.
 *
 * Returns
 * 	On success, the strictly positive length of the string, including
 * 	the trailing NUL character. On error, a negative value.
 */
static long (*bpf_probe_read_kernel_str)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 115;

/*
 * bpf_tcp_send_ack
 *
 * 	Send out a tcp-ack. *tp* is the in-kernel struct **tcp_sock**.
 * 	*rcv_nxt* is the ack_seq to be sent out.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_tcp_send_ack)(void *tp, __u32 rcv_nxt) = (void *) 116;

/*
 * bpf_send_signal_thread
 *
 * 	Send signal *sig* to the thread corresponding to the current task.
 *
 * Returns
 * 	0 on success or successfully queued.
 *
 * 	**-EBUSY** if work queue under nmi is full.
 *
 * 	**-EINVAL** if *sig* is invalid.
 *
 * 	**-EPERM** if no permission to send the *sig*.
 *
 * 	**-EAGAIN** if bpf program can try again.
 */
static long (*bpf_send_signal_thread)(__u32 sig) = (void *) 117;

/*
 * bpf_jiffies64
 *
 * 	Obtain the 64bit jiffies
 *
 * Returns
 * 	The 64 bit jiffies
 */
static __u64 (*bpf_jiffies64)(void) = (void *) 118;

/*
 * bpf_read_branch_records
 *
 * 	For an eBPF program attached to a perf event, retrieve the
 * 	branch records (**struct perf_branch_entry**) associated to *ctx*
 * 	and store it in the buffer pointed by *buf* up to size
 * 	*size* bytes.
 *
 * Returns
 * 	On success, number of bytes written to *buf*. On error, a
 * 	negative value.
 *
 * 	The *flags* can be set to **BPF_F_GET_BRANCH_RECORDS_SIZE** to
 * 	instead return the number of bytes required to store all the
 * 	branch entries. If this flag is set, *buf* may be NULL.
 *
 * 	**-EINVAL** if arguments invalid or **size** not a multiple
 * 	of **sizeof**\ (**struct perf_branch_entry**\ ).
 *
 * 	**-ENOENT** if architecture does not support branch records.
 */
static long (*bpf_read_branch_records)(struct bpf_perf_event_data *ctx, void *buf, __u32 size, __u64 flags) = (void *) 119;

/*
 * bpf_get_ns_current_pid_tgid
 *
 * 	Returns 0 on success, values for *pid* and *tgid* as seen from the current
 * 	*namespace* will be returned in *nsdata*.
 *
 * Returns
 * 	0 on success, or one of the following in case of failure:
 *
 * 	**-EINVAL** if dev and inum supplied don't match dev_t and inode number
 * 	with nsfs of current task, or if dev conversion to dev_t lost high bits.
 *
 * 	**-ENOENT** if pidns does not exists for the current task.
 */
static long (*bpf_get_ns_current_pid_tgid)(__u64 dev, __u64 ino, struct bpf_pidns_info *nsdata, __u32 size) = (void *) 120;

/*
 * bpf_xdp_output
 *
 * 	Write raw *data* blob into a special BPF perf event held by
 * 	*map* of type **BPF_MAP_TYPE_PERF_EVENT_ARRAY**. This perf
 * 	event must have the following attributes: **PERF_SAMPLE_RAW**
 * 	as **sample_type**, **PERF_TYPE_SOFTWARE** as **type**, and
 * 	**PERF_COUNT_SW_BPF_OUTPUT** as **config**.
 *
 * 	The *flags* are used to indicate the index in *map* for which
 * 	the value must be put, masked with **BPF_F_INDEX_MASK**.
 * 	Alternatively, *flags* can be set to **BPF_F_CURRENT_CPU**
 * 	to indicate that the index of the current CPU core should be
 * 	used.
 *
 * 	The value to write, of *size*, is passed through eBPF stack and
 * 	pointed by *data*.
 *
 * 	*ctx* is a pointer to in-kernel struct xdp_buff.
 *
 * 	This helper is similar to **bpf_perf_eventoutput**\ () but
 * 	restricted to raw_tracepoint bpf programs.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_xdp_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 121;

/*
 * bpf_get_netns_cookie
 *
 * 	Retrieve the cookie (generated by the kernel) of the network
 * 	namespace the input *ctx* is associated with. The network
 * 	namespace cookie remains stable for its lifetime and provides
 * 	a global identifier that can be assumed unique. If *ctx* is
 * 	NULL, then the helper returns the cookie for the initial
 * 	network namespace. The cookie itself is very similar to that
 * 	of **bpf_get_socket_cookie**\ () helper, but for network
 * 	namespaces instead of sockets.
 *
 * Returns
 * 	A 8-byte long opaque number.
 */
static __u64 (*bpf_get_netns_cookie)(void *ctx) = (void *) 122;

/*
 * bpf_get_current_ancestor_cgroup_id
 *
 * 	Return id of cgroup v2 that is ancestor of the cgroup associated
 * 	with the current task at the *ancestor_level*. The root cgroup
 * 	is at *ancestor_level* zero and each step down the hierarchy
 * 	increments the level. If *ancestor_level* == level of cgroup
 * 	associated with the current task, then return value will be the
 * 	same as that of **bpf_get_current_cgroup_id**\ ().
 *
 * 	The helper is useful to implement policies based on cgroups
 * 	that are upper in hierarchy than immediate cgroup associated
 * 	with the current task.
 *
 * 	The format of returned id and helper limitations are same as in
 * 	**bpf_get_current_cgroup_id**\ ().
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_get_current_ancestor_cgroup_id)(int ancestor_level) = (void *) 123;

/*
 * bpf_sk_assign
 *
 * 	Helper is overloaded depending on BPF program type. This
 * 	description applies to **BPF_PROG_TYPE_SCHED_CLS** and
 * 	**BPF_PROG_TYPE_SCHED_ACT** programs.
 *
 * 	Assign the *sk* to the *skb*. When combined with appropriate
 * 	routing configuration to receive the packet towards the socket,
 * 	will cause *skb* to be delivered to the specified socket.
 * 	Subsequent redirection of *skb* via  **bpf_redirect**\ (),
 * 	**bpf_clone_redirect**\ () or other methods outside of BPF may
 * 	interfere with successful delivery to the socket.
 *
 * 	This operation is only valid from TC ingress path.
 *
 * 	The *flags* argument must be zero.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure:
 *
 * 	**-EINVAL** if specified *flags* are not supported.
 *
 * 	**-ENOENT** if the socket is unavailable for assignment.
 *
 * 	**-ENETUNREACH** if the socket is unreachable (wrong netns).
 *
 * 	**-EOPNOTSUPP** if the operation is not supported, for example
 * 	a call from outside of TC ingress.
 *
 * 	**-ESOCKTNOSUPPORT** if the socket type is not supported
 * 	(reuseport).
 */
static long (*bpf_sk_assign)(void *ctx, void *sk, __u64 flags) = (void *) 124;

/*
 * bpf_ktime_get_boot_ns
 *
 * 	Return the time elapsed since system boot, in nanoseconds.
 * 	Does include the time the system was suspended.
 * 	See: **clock_gettime**\ (**CLOCK_BOOTTIME**)
 *
 * Returns
 * 	Current *ktime*.
 */
static __u64 (*bpf_ktime_get_boot_ns)(void) = (void *) 125;

/*
 * bpf_seq_printf
 *
 * 	**bpf_seq_printf**\ () uses seq_file **seq_printf**\ () to print
 * 	out the format string.
 * 	The *m* represents the seq_file. The *fmt* and *fmt_size* are for
 * 	the format string itself. The *data* and *data_len* are format string
 * 	arguments. The *data* are a **u64** array and corresponding format string
 * 	values are stored in the array. For strings and pointers where pointees
 * 	are accessed, only the pointer values are stored in the *data* array.
 * 	The *data_len* is the size of *data* in bytes - must be a multiple of 8.
 *
 * 	Formats **%s**, **%p{i,I}{4,6}** requires to read kernel memory.
 * 	Reading kernel memory may fail due to either invalid address or
 * 	valid address but requiring a major memory fault. If reading kernel memory
 * 	fails, the string for **%s** will be an empty string, and the ip
 * 	address for **%p{i,I}{4,6}** will be 0. Not returning error to
 * 	bpf program is consistent with what **bpf_trace_printk**\ () does for now.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure:
 *
 * 	**-EBUSY** if per-CPU memory copy buffer is busy, can try again
 * 	by returning 1 from bpf program.
 *
 * 	**-EINVAL** if arguments are invalid, or if *fmt* is invalid/unsupported.
 *
 * 	**-E2BIG** if *fmt* contains too many format specifiers.
 *
 * 	**-EOVERFLOW** if an overflow happened: The same object will be tried again.
 */
static long (*bpf_seq_printf)(struct seq_file *m, const char *fmt, __u32 fmt_size, const void *data, __u32 data_len) = (void *) 126;

/*
 * bpf_seq_write
 *
 * 	**bpf_seq_write**\ () uses seq_file **seq_write**\ () to write the data.
 * 	The *m* represents the seq_file. The *data* and *len* represent the
 * 	data to write in bytes.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure:
 *
 * 	**-EOVERFLOW** if an overflow happened: The same object will be tried again.
 */
static long (*bpf_seq_write)(struct seq_file *m, const void *data, __u32 len) = (void *) 127;

/*
 * bpf_sk_cgroup_id
 *
 * 	Return the cgroup v2 id of the socket *sk*.
 *
 * 	*sk* must be a non-**NULL** pointer to a socket, e.g. one
 * 	returned from **bpf_sk_lookup_xxx**\ (),
 * 	**bpf_sk_fullsock**\ (), etc. The format of returned id is
 * 	same as in **bpf_skb_cgroup_id**\ ().
 *
 * 	This helper is available only if the kernel was compiled with
 * 	the **CONFIG_SOCK_CGROUP_DATA** configuration option.
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_sk_cgroup_id)(void *sk) = (void *) 128;

/*
 * bpf_sk_ancestor_cgroup_id
 *
 * 	Return id of cgroup v2 that is ancestor of cgroup associated
 * 	with the *sk* at the *ancestor_level*.  The root cgroup is at
 * 	*ancestor_level* zero and each step down the hierarchy
 * 	increments the level. If *ancestor_level* == level of cgroup
 * 	associated with *sk*, then return value will be same as that
 * 	of **bpf_sk_cgroup_id**\ ().
 *
 * 	The helper is useful to implement policies based on cgroups
 * 	that are upper in hierarchy than immediate cgroup associated
 * 	with *sk*.
 *
 * 	The format of returned id and helper limitations are same as in
 * 	**bpf_sk_cgroup_id**\ ().
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_sk_ancestor_cgroup_id)(void *sk, int ancestor_level) = (void *) 129;

/*
 * bpf_ringbuf_output
 *
 * 	Copy *size* bytes from *data* into a ring buffer *ringbuf*.
 * 	If **BPF_RB_NO_WAKEUP** is specified in *flags*, no notification
 * 	of new data availability is sent.
 * 	If **BPF_RB_FORCE_WAKEUP** is specified in *flags*, notification
 * 	of new data availability is sent unconditionally.
 * 	If **0** is specified in *flags*, an adaptive notification
 * 	of new data availability is sent.
 *
 * 	An adaptive notification is a notification sent whenever the user-space
 * 	process has caught up and consumed all available payloads. In case the user-space
 * 	process is still processing a previous payload, then no notification is needed
 * 	as it will process the newly added payload automatically.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_ringbuf_output)(void *ringbuf, void *data, __u64 size, __u64 flags) = (void *) 130;

/*
 * bpf_ringbuf_reserve
 *
 * 	Reserve *size* bytes of payload in a ring buffer *ringbuf*.
 * 	*flags* must be 0.
 *
 * Returns
 * 	Valid pointer with *size* bytes of memory available; NULL,
 * 	otherwise.
 */
static void *(*bpf_ringbuf_reserve)(void *ringbuf, __u64 size, __u64 flags) = (void *) 131;

/*
 * bpf_ringbuf_submit
 *
 * 	Submit reserved ring buffer sample, pointed to by *data*.
 * 	If **BPF_RB_NO_WAKEUP** is specified in *flags*, no notification
 * 	of new data availability is sent.
 * 	If **BPF_RB_FORCE_WAKEUP** is specified in *flags*, notification
 * 	of new data availability is sent unconditionally.
 * 	If **0** is specified in *flags*, an adaptive notification
 * 	of new data availability is sent.
 *
 * 	See 'bpf_ringbuf_output()' for the definition of adaptive notification.
 *
 * Returns
 * 	Nothing. Always succeeds.
 */
static void (*bpf_ringbuf_submit)(void *data, __u64 flags) = (void *) 132;

/*
 * bpf_ringbuf_discard
 *
 * 	Discard reserved ring buffer sample, pointed to by *data*.
 * 	If **BPF_RB_NO_WAKEUP** is specified in *flags*, no notification
 * 	of new data availability is sent.
 * 	If **BPF_RB_FORCE_WAKEUP** is specified in *flags*, notification
 * 	of new data availability is sent unconditionally.
 * 	If **0** is specified in *flags*, an adaptive notification
 * 	of new data availability is sent.
 *
 * 	See 'bpf_ringbuf_output()' for the definition of adaptive notification.
 *
 * Returns
 * 	Nothing. Always succeeds.
 */
static void (*bpf_ringbuf_discard)(void *data, __u64 flags) = (void *) 133;

/*
 * bpf_ringbuf_query
 *
 * 	Query various characteristics of provided ring buffer. What
 * 	exactly is queries is determined by *flags*:
 *
 * 	* **BPF_RB_AVAIL_DATA**: Amount of data not yet consumed.
 * 	* **BPF_RB_RING_SIZE**: The size of ring buffer.
 * 	* **BPF_RB_CONS_POS**: Consumer position (can wrap around).
 * 	* **BPF_RB_PROD_POS**: Producer(s) position (can wrap around).
 *
 * 	Data returned is just a momentary snapshot of actual values
 * 	and could be inaccurate, so this facility should be used to
 * 	power heuristics and for reporting, not to make 100% correct
 * 	calculation.
 *
 * Returns
 * 	Requested value, or 0, if *flags* are not recognized.
 */
static __u64 (*bpf_ringbuf_query)(void *ringbuf, __u64 flags) = (void *) 134;

/*
 * bpf_csum_level
 *
 * 	Change the skbs checksum level by one layer up or down, or
 * 	reset it entirely to none in order to have the stack perform
 * 	checksum validation. The level is applicable to the following
 * 	protocols: TCP, UDP, GRE, SCTP, FCOE. For example, a decap of
 * 	| ETH | IP | UDP | GUE | IP | TCP | into | ETH | IP | TCP |
 * 	through **bpf_skb_adjust_room**\ () helper with passing in
 * 	**BPF_F_ADJ_ROOM_NO_CSUM_RESET** flag would require one	call
 * 	to **bpf_csum_level**\ () with **BPF_CSUM_LEVEL_DEC** since
 * 	the UDP header is removed. Similarly, an encap of the latter
 * 	into the former could be accompanied by a helper call to
 * 	**bpf_csum_level**\ () with **BPF_CSUM_LEVEL_INC** if the
 * 	skb is still intended to be processed in higher layers of the
 * 	stack instead of just egressing at tc.
 *
 * 	There are three supported level settings at this time:
 *
 * 	* **BPF_CSUM_LEVEL_INC**: Increases skb->csum_level for skbs
 * 	  with CHECKSUM_UNNECESSARY.
 * 	* **BPF_CSUM_LEVEL_DEC**: Decreases skb->csum_level for skbs
 * 	  with CHECKSUM_UNNECESSARY.
 * 	* **BPF_CSUM_LEVEL_RESET**: Resets skb->csum_level to 0 and
 * 	  sets CHECKSUM_NONE to force checksum validation by the stack.
 * 	* **BPF_CSUM_LEVEL_QUERY**: No-op, returns the current
 * 	  skb->csum_level.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure. In the
 * 	case of **BPF_CSUM_LEVEL_QUERY**, the current skb->csum_level
 * 	is returned or the error code -EACCES in case the skb is not
 * 	subject to CHECKSUM_UNNECESSARY.
 */
static long (*bpf_csum_level)(struct __sk_buff *skb, __u64 level) = (void *) 135;

/*
 * bpf_skc_to_tcp6_sock
 *
 * 	Dynamically cast a *sk* pointer to a *tcp6_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct tcp6_sock *(*bpf_skc_to_tcp6_sock)(void *sk) = (void *) 136;

/*
 * bpf_skc_to_tcp_sock
 *
 * 	Dynamically cast a *sk* pointer to a *tcp_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct tcp_sock *(*bpf_skc_to_tcp_sock)(void *sk) = (void *) 137;

/*
 * bpf_skc_to_tcp_timewait_sock
 *
 * 	Dynamically cast a *sk* pointer to a *tcp_timewait_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct tcp_timewait_sock *(*bpf_skc_to_tcp_timewait_sock)(void *sk) = (void *) 138;

/*
 * bpf_skc_to_tcp_request_sock
 *
 * 	Dynamically cast a *sk* pointer to a *tcp_request_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct tcp_request_sock *(*bpf_skc_to_tcp_request_sock)(void *sk) = (void *) 139;

/*
 * bpf_skc_to_udp6_sock
 *
 * 	Dynamically cast a *sk* pointer to a *udp6_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct udp6_sock *(*bpf_skc_to_udp6_sock)(void *sk) = (void *) 140;

/*
 * bpf_get_task_stack
 *
 * 	Return a user or a kernel stack in bpf program provided buffer.
 * 	To achieve this, the helper needs *task*, which is a valid
 * 	pointer to **struct task_struct**. To store the stacktrace, the
 * 	bpf program provides *buf* with a nonnegative *size*.
 *
 * 	The last argument, *flags*, holds the number of stack frames to
 * 	skip (from 0 to 255), masked with
 * 	**BPF_F_SKIP_FIELD_MASK**. The next bits can be used to set
 * 	the following flags:
 *
 * 	**BPF_F_USER_STACK**
 * 		Collect a user space stack instead of a kernel stack.
 * 	**BPF_F_USER_BUILD_ID**
 * 		Collect buildid+offset instead of ips for user stack,
 * 		only valid if **BPF_F_USER_STACK** is also specified.
 *
 * 	**bpf_get_task_stack**\ () can collect up to
 * 	**PERF_MAX_STACK_DEPTH** both kernel and user frames, subject
 * 	to sufficient large buffer size. Note that
 * 	this limit can be controlled with the **sysctl** program, and
 * 	that it should be manually increased in order to profile long
 * 	user stacks (such as stacks for Java programs). To do so, use:
 *
 * 	::
 *
 * 		# sysctl kernel.perf_event_max_stack=<new value>
 *
 * Returns
 * 	A non-negative value equal to or less than *size* on success,
 * 	or a negative error in case of failure.
 */
static long (*bpf_get_task_stack)(struct task_struct *task, void *buf, __u32 size, __u64 flags) = (void *) 141;

/*
 * bpf_load_hdr_opt
 *
 * 	Load header option.  Support reading a particular TCP header
 * 	option for bpf program (**BPF_PROG_TYPE_SOCK_OPS**).
 *
 * 	If *flags* is 0, it will search the option from the
 * 	*skops*\ **->skb_data**.  The comment in **struct bpf_sock_ops**
 * 	has details on what skb_data contains under different
 * 	*skops*\ **->op**.
 *
 * 	The first byte of the *searchby_res* specifies the
 * 	kind that it wants to search.
 *
 * 	If the searching kind is an experimental kind
 * 	(i.e. 253 or 254 according to RFC6994).  It also
 * 	needs to specify the "magic" which is either
 * 	2 bytes or 4 bytes.  It then also needs to
 * 	specify the size of the magic by using
 * 	the 2nd byte which is "kind-length" of a TCP
 * 	header option and the "kind-length" also
 * 	includes the first 2 bytes "kind" and "kind-length"
 * 	itself as a normal TCP header option also does.
 *
 * 	For example, to search experimental kind 254 with
 * 	2 byte magic 0xeB9F, the searchby_res should be
 * 	[ 254, 4, 0xeB, 0x9F, 0, 0, .... 0 ].
 *
 * 	To search for the standard window scale option (3),
 * 	the *searchby_res* should be [ 3, 0, 0, .... 0 ].
 * 	Note, kind-length must be 0 for regular option.
 *
 * 	Searching for No-Op (0) and End-of-Option-List (1) are
 * 	not supported.
 *
 * 	*len* must be at least 2 bytes which is the minimal size
 * 	of a header option.
 *
 * 	Supported flags:
 *
 * 	* **BPF_LOAD_HDR_OPT_TCP_SYN** to search from the
 * 	  saved_syn packet or the just-received syn packet.
 *
 *
 * Returns
 * 	> 0 when found, the header option is copied to *searchby_res*.
 * 	The return value is the total length copied. On failure, a
 * 	negative error code is returned:
 *
 * 	**-EINVAL** if a parameter is invalid.
 *
 * 	**-ENOMSG** if the option is not found.
 *
 * 	**-ENOENT** if no syn packet is available when
 * 	**BPF_LOAD_HDR_OPT_TCP_SYN** is used.
 *
 * 	**-ENOSPC** if there is not enough space.  Only *len* number of
 * 	bytes are copied.
 *
 * 	**-EFAULT** on failure to parse the header options in the
 * 	packet.
 *
 * 	**-EPERM** if the helper cannot be used under the current
 * 	*skops*\ **->op**.
 */
static long (*bpf_load_hdr_opt)(struct bpf_sock_ops *skops, void *searchby_res, __u32 len, __u64 flags) = (void *) 142;

/*
 * bpf_store_hdr_opt
 *
 * 	Store header option.  The data will be copied
 * 	from buffer *from* with length *len* to the TCP header.
 *
 * 	The buffer *from* should have the whole option that
 * 	includes the kind, kind-length, and the actual
 * 	option data.  The *len* must be at least kind-length
 * 	long.  The kind-length does not have to be 4 byte
 * 	aligned.  The kernel will take care of the padding
 * 	and setting the 4 bytes aligned value to th->doff.
 *
 * 	This helper will check for duplicated option
 * 	by searching the same option in the outgoing skb.
 *
 * 	This helper can only be called during
 * 	**BPF_SOCK_OPS_WRITE_HDR_OPT_CB**.
 *
 *
 * Returns
 * 	0 on success, or negative error in case of failure:
 *
 * 	**-EINVAL** If param is invalid.
 *
 * 	**-ENOSPC** if there is not enough space in the header.
 * 	Nothing has been written
 *
 * 	**-EEXIST** if the option already exists.
 *
 * 	**-EFAULT** on failrue to parse the existing header options.
 *
 * 	**-EPERM** if the helper cannot be used under the current
 * 	*skops*\ **->op**.
 */
static long (*bpf_store_hdr_opt)(struct bpf_sock_ops *skops, const void *from, __u32 len, __u64 flags) = (void *) 143;

/*
 * bpf_reserve_hdr_opt
 *
 * 	Reserve *len* bytes for the bpf header option.  The
 * 	space will be used by **bpf_store_hdr_opt**\ () later in
 * 	**BPF_SOCK_OPS_WRITE_HDR_OPT_CB**.
 *
 * 	If **bpf_reserve_hdr_opt**\ () is called multiple times,
 * 	the total number of bytes will be reserved.
 *
 * 	This helper can only be called during
 * 	**BPF_SOCK_OPS_HDR_OPT_LEN_CB**.
 *
 *
 * Returns
 * 	0 on success, or negative error in case of failure:
 *
 * 	**-EINVAL** if a parameter is invalid.
 *
 * 	**-ENOSPC** if there is not enough space in the header.
 *
 * 	**-EPERM** if the helper cannot be used under the current
 * 	*skops*\ **->op**.
 */
static long (*bpf_reserve_hdr_opt)(struct bpf_sock_ops *skops, __u32 len, __u64 flags) = (void *) 144;

/*
 * bpf_inode_storage_get
 *
 * 	Get a bpf_local_storage from an *inode*.
 *
 * 	Logically, it could be thought of as getting the value from
 * 	a *map* with *inode* as the **key**.  From this
 * 	perspective,  the usage is not much different from
 * 	**bpf_map_lookup_elem**\ (*map*, **&**\ *inode*) except this
 * 	helper enforces the key must be an inode and the map must also
 * 	be a **BPF_MAP_TYPE_INODE_STORAGE**.
 *
 * 	Underneath, the value is stored locally at *inode* instead of
 * 	the *map*.  The *map* is used as the bpf-local-storage
 * 	"type". The bpf-local-storage "type" (i.e. the *map*) is
 * 	searched against all bpf_local_storage residing at *inode*.
 *
 * 	An optional *flags* (**BPF_LOCAL_STORAGE_GET_F_CREATE**) can be
 * 	used such that a new bpf_local_storage will be
 * 	created if one does not exist.  *value* can be used
 * 	together with **BPF_LOCAL_STORAGE_GET_F_CREATE** to specify
 * 	the initial value of a bpf_local_storage.  If *value* is
 * 	**NULL**, the new bpf_local_storage will be zero initialized.
 *
 * Returns
 * 	A bpf_local_storage pointer is returned on success.
 *
 * 	**NULL** if not found or there was an error in adding
 * 	a new bpf_local_storage.
 */
static void *(*bpf_inode_storage_get)(void *map, void *inode, void *value, __u64 flags) = (void *) 145;

/*
 * bpf_inode_storage_delete
 *
 * 	Delete a bpf_local_storage from an *inode*.
 *
 * Returns
 * 	0 on success.
 *
 * 	**-ENOENT** if the bpf_local_storage cannot be found.
 */
static int (*bpf_inode_storage_delete)(void *map, void *inode) = (void *) 146;

/*
 * bpf_d_path
 *
 * 	Return full path for given **struct path** object, which
 * 	needs to be the kernel BTF *path* object. The path is
 * 	returned in the provided buffer *buf* of size *sz* and
 * 	is zero terminated.
 *
 *
 * Returns
 * 	On success, the strictly positive length of the string,
 * 	including the trailing NUL character. On error, a negative
 * 	value.
 */
static long (*bpf_d_path)(struct path *path, char *buf, __u32 sz) = (void *) 147;

/*
 * bpf_copy_from_user
 *
 * 	Read *size* bytes from user space address *user_ptr* and store
 * 	the data in *dst*. This is a wrapper of **copy_from_user**\ ().
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (*bpf_copy_from_user)(void *dst, __u32 size, const void *user_ptr) = (void *) 148;

/*
 * bpf_snprintf_btf
 *
 * 	Use BTF to store a string representation of *ptr*->ptr in *str*,
 * 	using *ptr*->type_id.  This value should specify the type
 * 	that *ptr*->ptr points to. LLVM __builtin_btf_type_id(type, 1)
 * 	can be used to look up vmlinux BTF type ids. Traversing the
 * 	data structure using BTF, the type information and values are
 * 	stored in the first *str_size* - 1 bytes of *str*.  Safe copy of
 * 	the pointer data is carried out to avoid kernel crashes during
 * 	operation.  Smaller types can use string space on the stack;
 * 	larger programs can use map data to store the string
 * 	representation.
 *
 * 	The string can be subsequently shared with userspace via
 * 	bpf_perf_event_output() or ring buffer interfaces.
 * 	bpf_trace_printk() is to be avoided as it places too small
 * 	a limit on string size to be useful.
 *
 * 	*flags* is a combination of
 *
 * 	**BTF_F_COMPACT**
 * 		no formatting around type information
 * 	**BTF_F_NONAME**
 * 		no struct/union member names/types
 * 	**BTF_F_PTR_RAW**
 * 		show raw (unobfuscated) pointer values;
 * 		equivalent to printk specifier %px.
 * 	**BTF_F_ZERO**
 * 		show zero-valued struct/union members; they
 * 		are not displayed by default
 *
 *
 * Returns
 * 	The number of bytes that were written (or would have been
 * 	written if output had to be truncated due to string size),
 * 	or a negative error in cases of failure.
 */
static long (*bpf_snprintf_btf)(char *str, __u32 str_size, struct btf_ptr *ptr, __u32 btf_ptr_size, __u64 flags) = (void *) 149;

/*
 * bpf_seq_printf_btf
 *
 * 	Use BTF to write to seq_write a string representation of
 * 	*ptr*->ptr, using *ptr*->type_id as per bpf_snprintf_btf().
 * 	*flags* are identical to those used for bpf_snprintf_btf.
 *
 * Returns
 * 	0 on success or a negative error in case of failure.
 */
static long (*bpf_seq_printf_btf)(struct seq_file *m, struct btf_ptr *ptr, __u32 ptr_size, __u64 flags) = (void *) 150;

/*
 * bpf_skb_cgroup_classid
 *
 * 	See **bpf_get_cgroup_classid**\ () for the main description.
 * 	This helper differs from **bpf_get_cgroup_classid**\ () in that
 * 	the cgroup v1 net_cls class is retrieved only from the *skb*'s
 * 	associated socket instead of the current process.
 *
 * Returns
 * 	The id is returned or 0 in case the id could not be retrieved.
 */
static __u64 (*bpf_skb_cgroup_classid)(struct __sk_buff *skb) = (void *) 151;

/*
 * bpf_redirect_neigh
 *
 * 	Redirect the packet to another net device of index *ifindex*
 * 	and fill in L2 addresses from neighboring subsystem. This helper
 * 	is somewhat similar to **bpf_redirect**\ (), except that it
 * 	populates L2 addresses as well, meaning, internally, the helper
 * 	relies on the neighbor lookup for the L2 address of the nexthop.
 *
 * 	The helper will perform a FIB lookup based on the skb's
 * 	networking header to get the address of the next hop, unless
 * 	this is supplied by the caller in the *params* argument. The
 * 	*plen* argument indicates the len of *params* and should be set
 * 	to 0 if *params* is NULL.
 *
 * 	The *flags* argument is reserved and must be 0. The helper is
 * 	currently only supported for tc BPF program types, and enabled
 * 	for IPv4 and IPv6 protocols.
 *
 * Returns
 * 	The helper returns **TC_ACT_REDIRECT** on success or
 * 	**TC_ACT_SHOT** on error.
 */
static long (*bpf_redirect_neigh)(__u32 ifindex, struct bpf_redir_neigh *params, int plen, __u64 flags) = (void *) 152;

/*
 * bpf_per_cpu_ptr
 *
 * 	Take a pointer to a percpu ksym, *percpu_ptr*, and return a
 * 	pointer to the percpu kernel variable on *cpu*. A ksym is an
 * 	extern variable decorated with '__ksym'. For ksym, there is a
 * 	global var (either static or global) defined of the same name
 * 	in the kernel. The ksym is percpu if the global var is percpu.
 * 	The returned pointer points to the global percpu var on *cpu*.
 *
 * 	bpf_per_cpu_ptr() has the same semantic as per_cpu_ptr() in the
 * 	kernel, except that bpf_per_cpu_ptr() may return NULL. This
 * 	happens if *cpu* is larger than nr_cpu_ids. The caller of
 * 	bpf_per_cpu_ptr() must check the returned value.
 *
 * Returns
 * 	A pointer pointing to the kernel percpu variable on *cpu*, or
 * 	NULL, if *cpu* is invalid.
 */
static void *(*bpf_per_cpu_ptr)(const void *percpu_ptr, __u32 cpu) = (void *) 153;

/*
 * bpf_this_cpu_ptr
 *
 * 	Take a pointer to a percpu ksym, *percpu_ptr*, and return a
 * 	pointer to the percpu kernel variable on this cpu. See the
 * 	description of 'ksym' in **bpf_per_cpu_ptr**\ ().
 *
 * 	bpf_this_cpu_ptr() has the same semantic as this_cpu_ptr() in
 * 	the kernel. Different from **bpf_per_cpu_ptr**\ (), it would
 * 	never return NULL.
 *
 * Returns
 * 	A pointer pointing to the kernel percpu variable on this cpu.
 */
static void *(*bpf_this_cpu_ptr)(const void *percpu_ptr) = (void *) 154;

/*
 * bpf_redirect_peer
 *
 * 	Redirect the packet to another net device of index *ifindex*.
 * 	This helper is somewhat similar to **bpf_redirect**\ (), except
 * 	that the redirection happens to the *ifindex*' peer device and
 * 	the netns switch takes place from ingress to ingress without
 * 	going through the CPU's backlog queue.
 *
 * 	The *flags* argument is reserved and must be 0. The helper is
 * 	currently only supported for tc BPF program types at the ingress
 * 	hook and for veth device types. The peer device must reside in a
 * 	different network namespace.
 *
 * Returns
 * 	The helper returns **TC_ACT_REDIRECT** on success or
 * 	**TC_ACT_SHOT** on error.
 */
static long (*bpf_redirect_peer)(__u32 ifindex, __u64 flags) = (void *) 155;

/*
 * bpf_task_storage_get
 *
 * 	Get a bpf_local_storage from the *task*.
 *
 * 	Logically, it could be thought of as getting the value from
 * 	a *map* with *task* as the **key**.  From this
 * 	perspective,  the usage is not much different from
 * 	**bpf_map_lookup_elem**\ (*map*, **&**\ *task*) except this
 * 	helper enforces the key must be an task_struct and the map must also
 * 	be a **BPF_MAP_TYPE_TASK_STORAGE**.
 *
 * 	Underneath, the value is stored locally at *task* instead of
 * 	the *map*.  The *map* is used as the bpf-local-storage
 * 	"type". The bpf-local-storage "type" (i.e. the *map*) is
 * 	searched against all bpf_local_storage residing at *task*.
 *
 * 	An optional *flags* (**BPF_LOCAL_STORAGE_GET_F_CREATE**) can be
 * 	used such that a new bpf_local_storage will be
 * 	created if one does not exist.  *value* can be used
 * 	together with **BPF_LOCAL_STORAGE_GET_F_CREATE** to specify
 * 	the initial value of a bpf_local_storage.  If *value* is
 * 	**NULL**, the new bpf_local_storage will be zero initialized.
 *
 * Returns
 * 	A bpf_local_storage pointer is returned on success.
 *
 * 	**NULL** if not found or there was an error in adding
 * 	a new bpf_local_storage.
 */
static void *(*bpf_task_storage_get)(void *map, struct task_struct *task, void *value, __u64 flags) = (void *) 156;

/*
 * bpf_task_storage_delete
 *
 * 	Delete a bpf_local_storage from a *task*.
 *
 * Returns
 * 	0 on success.
 *
 * 	**-ENOENT** if the bpf_local_storage cannot be found.
 */
static long (*bpf_task_storage_delete)(void *map, struct task_struct *task) = (void *) 157;

/*
 * bpf_get_current_task_btf
 *
 * 	Return a BTF pointer to the "current" task.
 * 	This pointer can also be used in helpers that accept an
 * 	*ARG_PTR_TO_BTF_ID* of type *task_struct*.
 *
 * Returns
 * 	Pointer to the current task.
 */
static struct task_struct *(*bpf_get_current_task_btf)(void) = (void *) 158;

/*
 * bpf_bprm_opts_set
 *
 * 	Set or clear certain options on *bprm*:
 *
 * 	**BPF_F_BPRM_SECUREEXEC** Set the secureexec bit
 * 	which sets the **AT_SECURE** auxv for glibc. The bit
 * 	is cleared if the flag is not specified.
 *
 * Returns
 * 	**-EINVAL** if invalid *flags* are passed, zero otherwise.
 */
static long (*bpf_bprm_opts_set)(struct linux_binprm *bprm, __u64 flags) = (void *) 159;

/*
 * bpf_ktime_get_coarse_ns
 *
 * 	Return a coarse-grained version of the time elapsed since
 * 	system boot, in nanoseconds. Does not include time the system
 * 	was suspended.
 *
 * 	See: **clock_gettime**\ (**CLOCK_MONOTONIC_COARSE**)
 *
 * Returns
 * 	Current *ktime*.
 */
static __u64 (*bpf_ktime_get_coarse_ns)(void) = (void *) 160;

/*
 * bpf_ima_inode_hash
 *
 * 	Returns the stored IMA hash of the *inode* (if it's avaialable).
 * 	If the hash is larger than *size*, then only *size*
 * 	bytes will be copied to *dst*
 *
 * Returns
 * 	The **hash_algo** is returned on success,
 * 	**-EOPNOTSUP** if IMA is disabled or **-EINVAL** if
 * 	invalid arguments are passed.
 */
static long (*bpf_ima_inode_hash)(struct inode *inode, void *dst, __u32 size) = (void *) 161;

/*
 * bpf_sock_from_file
 *
 * 	If the given file represents a socket, returns the associated
 * 	socket.
 *
 * Returns
 * 	A pointer to a struct socket on success or NULL if the file is
 * 	not a socket.
 */
static struct socket *(*bpf_sock_from_file)(struct file *file) = (void *) 162;

/*
 * bpf_check_mtu
 *
 * 	Check packet size against exceeding MTU of net device (based
 * 	on *ifindex*).  This helper will likely be used in combination
 * 	with helpers that adjust/change the packet size.
 *
 * 	The argument *len_diff* can be used for querying with a planned
 * 	size change. This allows to check MTU prior to changing packet
 * 	ctx. Providing an *len_diff* adjustment that is larger than the
 * 	actual packet size (resulting in negative packet size) will in
 * 	principle not exceed the MTU, why it is not considered a
 * 	failure.  Other BPF-helpers are needed for performing the
 * 	planned size change, why the responsibility for catch a negative
 * 	packet size belong in those helpers.
 *
 * 	Specifying *ifindex* zero means the MTU check is performed
 * 	against the current net device.  This is practical if this isn't
 * 	used prior to redirect.
 *
 * 	On input *mtu_len* must be a valid pointer, else verifier will
 * 	reject BPF program.  If the value *mtu_len* is initialized to
 * 	zero then the ctx packet size is use.  When value *mtu_len* is
 * 	provided as input this specify the L3 length that the MTU check
 * 	is done against. Remember XDP and TC length operate at L2, but
 * 	this value is L3 as this correlate to MTU and IP-header tot_len
 * 	values which are L3 (similar behavior as bpf_fib_lookup).
 *
 * 	The Linux kernel route table can configure MTUs on a more
 * 	specific per route level, which is not provided by this helper.
 * 	For route level MTU checks use the **bpf_fib_lookup**\ ()
 * 	helper.
 *
 * 	*ctx* is either **struct xdp_md** for XDP programs or
 * 	**struct sk_buff** for tc cls_act programs.
 *
 * 	The *flags* argument can be a combination of one or more of the
 * 	following values:
 *
 * 	**BPF_MTU_CHK_SEGS**
 * 		This flag will only works for *ctx* **struct sk_buff**.
 * 		If packet context contains extra packet segment buffers
 * 		(often knows as GSO skb), then MTU check is harder to
 * 		check at this point, because in transmit path it is
 * 		possible for the skb packet to get re-segmented
 * 		(depending on net device features).  This could still be
 * 		a MTU violation, so this flag enables performing MTU
 * 		check against segments, with a different violation
 * 		return code to tell it apart. Check cannot use len_diff.
 *
 * 	On return *mtu_len* pointer contains the MTU value of the net
 * 	device.  Remember the net device configured MTU is the L3 size,
 * 	which is returned here and XDP and TC length operate at L2.
 * 	Helper take this into account for you, but remember when using
 * 	MTU value in your BPF-code.
 *
 *
 * Returns
 * 	* 0 on success, and populate MTU value in *mtu_len* pointer.
 *
 * 	* < 0 if any input argument is invalid (*mtu_len* not updated)
 *
 * 	MTU violations return positive values, but also populate MTU
 * 	value in *mtu_len* pointer, as this can be needed for
 * 	implementing PMTU handing:
 *
 * 	* **BPF_MTU_CHK_RET_FRAG_NEEDED**
 * 	* **BPF_MTU_CHK_RET_SEGS_TOOBIG**
 */
static long (*bpf_check_mtu)(void *ctx, __u32 ifindex, __u32 *mtu_len, __s32 len_diff, __u64 flags) = (void *) 163;

/*
 * bpf_for_each_map_elem
 *
 * 	For each element in **map**, call **callback_fn** function with
 * 	**map**, **callback_ctx** and other map-specific parameters.
 * 	The **callback_fn** should be a static function and
 * 	the **callback_ctx** should be a pointer to the stack.
 * 	The **flags** is used to control certain aspects of the helper.
 * 	Currently, the **flags** must be 0.
 *
 * 	The following are a list of supported map types and their
 * 	respective expected callback signatures:
 *
 * 	BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_PERCPU_HASH,
 * 	BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH,
 * 	BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY
 *
 * 	long (\*callback_fn)(struct bpf_map \*map, const void \*key, void \*value, void \*ctx);
 *
 * 	For per_cpu maps, the map_value is the value on the cpu where the
 * 	bpf_prog is running.
 *
 * 	If **callback_fn** return 0, the helper will continue to the next
 * 	element. If return value is 1, the helper will skip the rest of
 * 	elements and return. Other return values are not used now.
 *
 *
 * Returns
 * 	The number of traversed map elements for success, **-EINVAL** for
 * 	invalid **flags**.
 */
static long (*bpf_for_each_map_elem)(void *map, void *callback_fn, void *callback_ctx, __u64 flags) = (void *) 164;

/*
 * bpf_snprintf
 *
 * 	Outputs a string into the **str** buffer of size **str_size**
 * 	based on a format string stored in a read-only map pointed by
 * 	**fmt**.
 *
 * 	Each format specifier in **fmt** corresponds to one u64 element
 * 	in the **data** array. For strings and pointers where pointees
 * 	are accessed, only the pointer values are stored in the *data*
 * 	array. The *data_len* is the size of *data* in bytes - must be
 * 	a multiple of 8.
 *
 * 	Formats **%s** and **%p{i,I}{4,6}** require to read kernel
 * 	memory. Reading kernel memory may fail due to either invalid
 * 	address or valid address but requiring a major memory fault. If
 * 	reading kernel memory fails, the string for **%s** will be an
 * 	empty string, and the ip address for **%p{i,I}{4,6}** will be 0.
 * 	Not returning error to bpf program is consistent with what
 * 	**bpf_trace_printk**\ () does for now.
 *
 *
 * Returns
 * 	The strictly positive length of the formatted string, including
 * 	the trailing zero character. If the return value is greater than
 * 	**str_size**, **str** contains a truncated string, guaranteed to
 * 	be zero-terminated except when **str_size** is 0.
 *
 * 	Or **-EBUSY** if the per-CPU memory copy buffer is busy.
 */
static long (*bpf_snprintf)(char *str, __u32 str_size, const char *fmt, __u64 *data, __u32 data_len) = (void *) 165;

/*
 * bpf_sys_bpf
 *
 * 	Execute bpf syscall with given arguments.
 *
 * Returns
 * 	A syscall result.
 */
static long (*bpf_sys_bpf)(__u32 cmd, void *attr, __u32 attr_size) = (void *) 166;

/*
 * bpf_btf_find_by_name_kind
 *
 * 	Find BTF type with given name and kind in vmlinux BTF or in module's BTFs.
 *
 * Returns
 * 	Returns btf_id and btf_obj_fd in lower and upper 32 bits.
 */
static long (*bpf_btf_find_by_name_kind)(char *name, int name_sz, __u32 kind, int flags) = (void *) 167;

/*
 * bpf_sys_close
 *
 * 	Execute close syscall for given FD.
 *
 * Returns
 * 	A syscall result.
 */
static long (*bpf_sys_close)(__u32 fd) = (void *) 168;

/*
 * bpf_timer_init
 *
 * 	Initialize the timer.
 * 	First 4 bits of *flags* specify clockid.
 * 	Only CLOCK_MONOTONIC, CLOCK_REALTIME, CLOCK_BOOTTIME are allowed.
 * 	All other bits of *flags* are reserved.
 * 	The verifier will reject the program if *timer* is not from
 * 	the same *map*.
 *
 * Returns
 * 	0 on success.
 * 	**-EBUSY** if *timer* is already initialized.
 * 	**-EINVAL** if invalid *flags* are passed.
 * 	**-EPERM** if *timer* is in a map that doesn't have any user references.
 * 	The user space should either hold a file descriptor to a map with timers
 * 	or pin such map in bpffs. When map is unpinned or file descriptor is
 * 	closed all timers in the map will be cancelled and freed.
 */
static long (*bpf_timer_init)(struct bpf_timer *timer, void *map, __u64 flags) = (void *) 169;

/*
 * bpf_timer_set_callback
 *
 * 	Configure the timer to call *callback_fn* static function.
 *
 * Returns
 * 	0 on success.
 * 	**-EINVAL** if *timer* was not initialized with bpf_timer_init() earlier.
 * 	**-EPERM** if *timer* is in a map that doesn't have any user references.
 * 	The user space should either hold a file descriptor to a map with timers
 * 	or pin such map in bpffs. When map is unpinned or file descriptor is
 * 	closed all timers in the map will be cancelled and freed.
 */
static long (*bpf_timer_set_callback)(struct bpf_timer *timer, void *callback_fn) = (void *) 170;

/*
 * bpf_timer_start
 *
 * 	Set timer expiration N nanoseconds from the current time. The
 * 	configured callback will be invoked in soft irq context on some cpu
 * 	and will not repeat unless another bpf_timer_start() is made.
 * 	In such case the next invocation can migrate to a different cpu.
 * 	Since struct bpf_timer is a field inside map element the map
 * 	owns the timer. The bpf_timer_set_callback() will increment refcnt
 * 	of BPF program to make sure that callback_fn code stays valid.
 * 	When user space reference to a map reaches zero all timers
 * 	in a map are cancelled and corresponding program's refcnts are
 * 	decremented. This is done to make sure that Ctrl-C of a user
 * 	process doesn't leave any timers running. If map is pinned in
 * 	bpffs the callback_fn can re-arm itself indefinitely.
 * 	bpf_map_update/delete_elem() helpers and user space sys_bpf commands
 * 	cancel and free the timer in the given map element.
 * 	The map can contain timers that invoke callback_fn-s from different
 * 	programs. The same callback_fn can serve different timers from
 * 	different maps if key/value layout matches across maps.
 * 	Every bpf_timer_set_callback() can have different callback_fn.
 *
 *
 * Returns
 * 	0 on success.
 * 	**-EINVAL** if *timer* was not initialized with bpf_timer_init() earlier
 * 	or invalid *flags* are passed.
 */
static long (*bpf_timer_start)(struct bpf_timer *timer, __u64 nsecs, __u64 flags) = (void *) 171;

/*
 * bpf_timer_cancel
 *
 * 	Cancel the timer and wait for callback_fn to finish if it was running.
 *
 * Returns
 * 	0 if the timer was not active.
 * 	1 if the timer was active.
 * 	**-EINVAL** if *timer* was not initialized with bpf_timer_init() earlier.
 * 	**-EDEADLK** if callback_fn tried to call bpf_timer_cancel() on its
 * 	own timer which would have led to a deadlock otherwise.
 */
static long (*bpf_timer_cancel)(struct bpf_timer *timer) = (void *) 172;

/*
 * bpf_get_func_ip
 *
 * 	Get address of the traced function (for tracing and kprobe programs).
 *
 * Returns
 * 	Address of the traced function.
 */
static __u64 (*bpf_get_func_ip)(void *ctx) = (void *) 173;

/*
 * bpf_get_attach_cookie
 *
 * 	Get bpf_cookie value provided (optionally) during the program
 * 	attachment. It might be different for each individual
 * 	attachment, even if BPF program itself is the same.
 * 	Expects BPF program context *ctx* as a first argument.
 *
 * 	Supported for the following program types:
 * 		- kprobe/uprobe;
 * 		- tracepoint;
 * 		- perf_event.
 *
 * Returns
 * 	Value specified by user at BPF link creation/attachment time
 * 	or 0, if it was not specified.
 */
static __u64 (*bpf_get_attach_cookie)(void *ctx) = (void *) 174;

/*
 * bpf_task_pt_regs
 *
 * 	Get the struct pt_regs associated with **task**.
 *
 * Returns
 * 	A pointer to struct pt_regs.
 */
static long (*bpf_task_pt_regs)(struct task_struct *task) = (void *) 175;

/*
 * bpf_get_branch_snapshot
 *
 * 	Get branch trace from hardware engines like Intel LBR. The
 * 	hardware engine is stopped shortly after the helper is
 * 	called. Therefore, the user need to filter branch entries
 * 	based on the actual use case. To capture branch trace
 * 	before the trigger point of the BPF program, the helper
 * 	should be called at the beginning of the BPF program.
 *
 * 	The data is stored as struct perf_branch_entry into output
 * 	buffer *entries*. *size* is the size of *entries* in bytes.
 * 	*flags* is reserved for now and must be zero.
 *
 *
 * Returns
 * 	On success, number of bytes written to *buf*. On error, a
 * 	negative value.
 *
 * 	**-EINVAL** if *flags* is not zero.
 *
 * 	**-ENOENT** if architecture does not support branch records.
 */
static long (*bpf_get_branch_snapshot)(void *entries, __u32 size, __u64 flags) = (void *) 176;

/*
 * bpf_trace_vprintk
 *
 * 	Behaves like **bpf_trace_printk**\ () helper, but takes an array of u64
 * 	to format and can handle more format args as a result.
 *
 * 	Arguments are to be used as in **bpf_seq_printf**\ () helper.
 *
 * Returns
 * 	The number of bytes written to the buffer, or a negative error
 * 	in case of failure.
 */
static long (*bpf_trace_vprintk)(const char *fmt, __u32 fmt_size, const void *data, __u32 data_len) = (void *) 177;

/*
 * bpf_skc_to_unix_sock
 *
 * 	Dynamically cast a *sk* pointer to a *unix_sock* pointer.
 *
 * Returns
 * 	*sk* if casting is valid, or **NULL** otherwise.
 */
static struct unix_sock *(*bpf_skc_to_unix_sock)(void *sk) = (void *) 178;

/*
 * bpf_kallsyms_lookup_name
 *
 * 	Get the address of a kernel symbol, returned in *res*. *res* is
 * 	set to 0 if the symbol is not found.
 *
 * Returns
 * 	On success, zero. On error, a negative value.
 *
 * 	**-EINVAL** if *flags* is not zero.
 *
 * 	**-EINVAL** if string *name* is not the same size as *name_sz*.
 *
 * 	**-ENOENT** if symbol is not found.
 *
 * 	**-EPERM** if caller does not have permission to obtain kernel address.
 */
static long (*bpf_kallsyms_lookup_name)(const char *name, int name_sz, int flags, __u64 *res) = (void *) 179;

/*
 * bpf_find_vma
 *
 * 	Find vma of *task* that contains *addr*, call *callback_fn*
 * 	function with *task*, *vma*, and *callback_ctx*.
 * 	The *callback_fn* should be a static function and
 * 	the *callback_ctx* should be a pointer to the stack.
 * 	The *flags* is used to control certain aspects of the helper.
 * 	Currently, the *flags* must be 0.
 *
 * 	The expected callback signature is
 *
 * 	long (\*callback_fn)(struct task_struct \*task, struct vm_area_struct \*vma, void \*callback_ctx);
 *
 *
 * Returns
 * 	0 on success.
 * 	**-ENOENT** if *task->mm* is NULL, or no vma contains *addr*.
 * 	**-EBUSY** if failed to try lock mmap_lock.
 * 	**-EINVAL** for invalid **flags**.
 */
static long (*bpf_find_vma)(struct task_struct *task, __u64 addr, void *callback_fn, void *callback_ctx, __u64 flags) = (void *) 180;



```

`headers/bpf_helpers.h`:

```h
/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
#ifndef __BPF_HELPERS__
#define __BPF_HELPERS__

/*
 * Note that bpf programs need to include either
 * vmlinux.h (auto-generated from BTF) or linux/types.h
 * in advance since bpf_helper_defs.h uses such types
 * as __u64.
 */
#include "bpf_helper_defs.h"

#define __uint(name, val) int (*name)[val]
#define __type(name, val) typeof(val) *name
#define __array(name, val) typeof(val) *name[]

/*
 * Helper macro to place programs, maps, license in
 * different sections in elf_bpf file. Section names
 * are interpreted by libbpf depending on the context (BPF programs, BPF maps,
 * extern variables, etc).
 * To allow use of SEC() with externs (e.g., for extern .maps declarations),
 * make sure __attribute__((unused)) doesn't trigger compilation warning.
 */
#define SEC(name) \
	_Pragma("GCC diagnostic push")					    \
	_Pragma("GCC diagnostic ignored \"-Wignored-attributes\"")	    \
	__attribute__((section(name), used))				    \
	_Pragma("GCC diagnostic pop")					    \

/* Avoid 'linux/stddef.h' definition of '__always_inline'. */
#undef __always_inline
#define __always_inline inline __attribute__((always_inline))

#ifndef __noinline
#define __noinline __attribute__((noinline))
#endif
#ifndef __weak
#define __weak __attribute__((weak))
#endif

/*
 * Use __hidden attribute to mark a non-static BPF subprogram effectively
 * static for BPF verifier's verification algorithm purposes, allowing more
 * extensive and permissive BPF verification process, taking into account
 * subprogram's caller context.
 */
#define __hidden __attribute__((visibility("hidden")))

/* When utilizing vmlinux.h with BPF CO-RE, user BPF programs can't include
 * any system-level headers (such as stddef.h, linux/version.h, etc), and
 * commonly-used macros like NULL and KERNEL_VERSION aren't available through
 * vmlinux.h. This just adds unnecessary hurdles and forces users to re-define
 * them on their own. So as a convenience, provide such definitions here.
 */
#ifndef NULL
#define NULL ((void *)0)
#endif

#ifndef KERNEL_VERSION
#define KERNEL_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + ((c) > 255 ? 255 : (c)))
#endif

/*
 * Helper macros to manipulate data structures
 */
#ifndef offsetof
#define offsetof(TYPE, MEMBER)	((unsigned long)&((TYPE *)0)->MEMBER)
#endif
#ifndef container_of
#define container_of(ptr, type, member)				\
	({							\
		void *__mptr = (void *)(ptr);			\
		((type *)(__mptr - offsetof(type, member)));	\
	})
#endif

/*
 * Helper macro to throw a compilation error if __bpf_unreachable() gets
 * built into the resulting code. This works given BPF back end does not
 * implement __builtin_trap(). This is useful to assert that certain paths
 * of the program code are never used and hence eliminated by the compiler.
 *
 * For example, consider a switch statement that covers known cases used by
 * the program. __bpf_unreachable() can then reside in the default case. If
 * the program gets extended such that a case is not covered in the switch
 * statement, then it will throw a build error due to the default case not
 * being compiled out.
 */
#ifndef __bpf_unreachable
# define __bpf_unreachable()	__builtin_trap()
#endif

/*
 * Helper function to perform a tail call with a constant/immediate map slot.
 */
#if __clang_major__ >= 8 && defined(__bpf__)
static __always_inline void
bpf_tail_call_static(void *ctx, const void *map, const __u32 slot)
{
	if (!__builtin_constant_p(slot))
		__bpf_unreachable();

	/*
	 * Provide a hard guarantee that LLVM won't optimize setting r2 (map
	 * pointer) and r3 (constant map index) from _different paths_ ending
	 * up at the _same_ call insn as otherwise we won't be able to use the
	 * jmpq/nopl retpoline-free patching by the x86-64 JIT in the kernel
	 * given they mismatch. See also d2e4c1e6c294 ("bpf: Constant map key
	 * tracking for prog array pokes") for details on verifier tracking.
	 *
	 * Note on clobber list: we need to stay in-line with BPF calling
	 * convention, so even if we don't end up using r0, r4, r5, we need
	 * to mark them as clobber so that LLVM doesn't end up using them
	 * before / after the call.
	 */
	asm volatile("r1 = %[ctx]\n\t"
		     "r2 = %[map]\n\t"
		     "r3 = %[slot]\n\t"
		     "call 12"
		     :: [ctx]"r"(ctx), [map]"r"(map), [slot]"i"(slot)
		     : "r0", "r1", "r2", "r3", "r4", "r5");
}
#endif

/*
 * Helper structure used by eBPF C program
 * to describe BPF map attributes to libbpf loader
 */
struct bpf_map_def {
	unsigned int type;
	unsigned int key_size;
	unsigned int value_size;
	unsigned int max_entries;
	unsigned int map_flags;
};

enum libbpf_pin_type {
	LIBBPF_PIN_NONE,
	/* PIN_BY_NAME: pin maps by name (in /sys/fs/bpf by default) */
	LIBBPF_PIN_BY_NAME,
};

enum libbpf_tristate {
	TRI_NO = 0,
	TRI_YES = 1,
	TRI_MODULE = 2,
};

#define __kconfig __attribute__((section(".kconfig")))
#define __ksym __attribute__((section(".ksyms")))

#ifndef ___bpf_concat
#define ___bpf_concat(a, b) a ## b
#endif
#ifndef ___bpf_apply
#define ___bpf_apply(fn, n) ___bpf_concat(fn, n)
#endif
#ifndef ___bpf_nth
#define ___bpf_nth(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _a, _b, _c, N, ...) N
#endif
#ifndef ___bpf_narg
#define ___bpf_narg(...) \
	___bpf_nth(_, ##__VA_ARGS__, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#endif

#define ___bpf_fill0(arr, p, x) do {} while (0)
#define ___bpf_fill1(arr, p, x) arr[p] = x
#define ___bpf_fill2(arr, p, x, args...) arr[p] = x; ___bpf_fill1(arr, p + 1, args)
#define ___bpf_fill3(arr, p, x, args...) arr[p] = x; ___bpf_fill2(arr, p + 1, args)
#define ___bpf_fill4(arr, p, x, args...) arr[p] = x; ___bpf_fill3(arr, p + 1, args)
#define ___bpf_fill5(arr, p, x, args...) arr[p] = x; ___bpf_fill4(arr, p + 1, args)
#define ___bpf_fill6(arr, p, x, args...) arr[p] = x; ___bpf_fill5(arr, p + 1, args)
#define ___bpf_fill7(arr, p, x, args...) arr[p] = x; ___bpf_fill6(arr, p + 1, args)
#define ___bpf_fill8(arr, p, x, args...) arr[p] = x; ___bpf_fill7(arr, p + 1, args)
#define ___bpf_fill9(arr, p, x, args...) arr[p] = x; ___bpf_fill8(arr, p + 1, args)
#define ___bpf_fill10(arr, p, x, args...) arr[p] = x; ___bpf_fill9(arr, p + 1, args)
#define ___bpf_fill11(arr, p, x, args...) arr[p] = x; ___bpf_fill10(arr, p + 1, args)
#define ___bpf_fill12(arr, p, x, args...) arr[p] = x; ___bpf_fill11(arr, p + 1, args)
#define ___bpf_fill(arr, args...) \
	___bpf_apply(___bpf_fill, ___bpf_narg(args))(arr, 0, args)

/*
 * BPF_SEQ_PRINTF to wrap bpf_seq_printf to-be-printed values
 * in a structure.
 */
#define BPF_SEQ_PRINTF(seq, fmt, args...)			\
({								\
	static const char ___fmt[] = fmt;			\
	unsigned long long ___param[___bpf_narg(args)];		\
								\
	_Pragma("GCC diagnostic push")				\
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")	\
	___bpf_fill(___param, args);				\
	_Pragma("GCC diagnostic pop")				\
								\
	bpf_seq_printf(seq, ___fmt, sizeof(___fmt),		\
		       ___param, sizeof(___param));		\
})

/*
 * BPF_SNPRINTF wraps the bpf_snprintf helper with variadic arguments instead of
 * an array of u64.
 */
#define BPF_SNPRINTF(out, out_size, fmt, args...)		\
({								\
	static const char ___fmt[] = fmt;			\
	unsigned long long ___param[___bpf_narg(args)];		\
								\
	_Pragma("GCC diagnostic push")				\
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")	\
	___bpf_fill(___param, args);				\
	_Pragma("GCC diagnostic pop")				\
								\
	bpf_snprintf(out, out_size, ___fmt,			\
		     ___param, sizeof(___param));		\
})

#ifdef BPF_NO_GLOBAL_DATA
#define BPF_PRINTK_FMT_MOD
#else
#define BPF_PRINTK_FMT_MOD static const
#endif

#define __bpf_printk(fmt, ...)				\
({							\
	BPF_PRINTK_FMT_MOD char ____fmt[] = fmt;	\
	bpf_trace_printk(____fmt, sizeof(____fmt),	\
			 ##__VA_ARGS__);		\
})

/*
 * __bpf_vprintk wraps the bpf_trace_vprintk helper with variadic arguments
 * instead of an array of u64.
 */
#define __bpf_vprintk(fmt, args...)				\
({								\
	static const char ___fmt[] = fmt;			\
	unsigned long long ___param[___bpf_narg(args)];		\
								\
	_Pragma("GCC diagnostic push")				\
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")	\
	___bpf_fill(___param, args);				\
	_Pragma("GCC diagnostic pop")				\
								\
	bpf_trace_vprintk(___fmt, sizeof(___fmt),		\
			  ___param, sizeof(___param));		\
})

/* Use __bpf_printk when bpf_printk call has 3 or fewer fmt args
 * Otherwise use __bpf_vprintk
 */
#define ___bpf_pick_printk(...) \
	___bpf_nth(_, ##__VA_ARGS__, __bpf_vprintk, __bpf_vprintk, __bpf_vprintk,	\
		   __bpf_vprintk, __bpf_vprintk, __bpf_vprintk, __bpf_vprintk,		\
		   __bpf_vprintk, __bpf_vprintk, __bpf_printk /*3*/, __bpf_printk /*2*/,\
		   __bpf_printk /*1*/, __bpf_printk /*0*/)

/* Helper macro to print out debug messages */
#define bpf_printk(fmt, args...) ___bpf_pick_printk(args)(fmt, ##args)

#endif

```

`headers/bpf_tracing.h`:

```h
/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
#ifndef __BPF_TRACING_H__
#define __BPF_TRACING_H__

struct user_pt_regs {
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
};

/* Scan the ARCH passed in from ARCH env variable (see Makefile) */
#if defined(__TARGET_ARCH_x86)
	#define bpf_target_x86
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_s390)
	#define bpf_target_s390
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_arm)
	#define bpf_target_arm
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_arm64)
	#define bpf_target_arm64
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_mips)
	#define bpf_target_mips
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_powerpc)
	#define bpf_target_powerpc
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_sparc)
	#define bpf_target_sparc
	#define bpf_target_defined
#elif defined(__TARGET_ARCH_riscv)
	#define bpf_target_riscv
	#define bpf_target_defined
#else

/* Fall back to what the compiler says */
#if defined(__x86_64__)
	#define bpf_target_x86
	#define bpf_target_defined
#elif defined(__s390__)
	#define bpf_target_s390
	#define bpf_target_defined
#elif defined(__arm__)
	#define bpf_target_arm
	#define bpf_target_defined
#elif defined(__aarch64__)
	#define bpf_target_arm64
	#define bpf_target_defined
#elif defined(__mips__)
	#define bpf_target_mips
	#define bpf_target_defined
#elif defined(__powerpc__)
	#define bpf_target_powerpc
	#define bpf_target_defined
#elif defined(__sparc__)
	#define bpf_target_sparc
	#define bpf_target_defined
#elif defined(__riscv) && __riscv_xlen == 64
	#define bpf_target_riscv
	#define bpf_target_defined
#endif /* no compiler target */

#endif

#ifndef __BPF_TARGET_MISSING
#define __BPF_TARGET_MISSING "GCC error \"Must specify a BPF target arch via __TARGET_ARCH_xxx\""
#endif

#if defined(bpf_target_x86)

#if defined(__KERNEL__) || defined(__VMLINUX_H__)

#define PT_REGS_PARM1(x) ((x)->di)
#define PT_REGS_PARM2(x) ((x)->si)
#define PT_REGS_PARM3(x) ((x)->dx)
#define PT_REGS_PARM4(x) ((x)->cx)
#define PT_REGS_PARM5(x) ((x)->r8)
#define PT_REGS_RET(x) ((x)->sp)
#define PT_REGS_FP(x) ((x)->bp)
#define PT_REGS_RC(x) ((x)->ax)
#define PT_REGS_SP(x) ((x)->sp)
#define PT_REGS_IP(x) ((x)->ip)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), di)
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), si)
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), dx)
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), cx)
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), r8)
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), sp)
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((x), bp)
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), ax)
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), sp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), ip)

#else

#ifdef __i386__
/* i386 kernel is built with -mregparm=3 */
#define PT_REGS_PARM1(x) ((x)->eax)
#define PT_REGS_PARM2(x) ((x)->edx)
#define PT_REGS_PARM3(x) ((x)->ecx)
#define PT_REGS_PARM4(x) 0
#define PT_REGS_PARM5(x) 0
#define PT_REGS_RET(x) ((x)->esp)
#define PT_REGS_FP(x) ((x)->ebp)
#define PT_REGS_RC(x) ((x)->eax)
#define PT_REGS_SP(x) ((x)->esp)
#define PT_REGS_IP(x) ((x)->eip)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), eax)
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), edx)
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), ecx)
#define PT_REGS_PARM4_CORE(x) 0
#define PT_REGS_PARM5_CORE(x) 0
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), esp)
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((x), ebp)
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), eax)
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), esp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), eip)

#else

#define PT_REGS_PARM1(x) ((x)->rdi)
#define PT_REGS_PARM2(x) ((x)->rsi)
#define PT_REGS_PARM3(x) ((x)->rdx)
#define PT_REGS_PARM4(x) ((x)->rcx)
#define PT_REGS_PARM5(x) ((x)->r8)
#define PT_REGS_RET(x) ((x)->rsp)
#define PT_REGS_FP(x) ((x)->rbp)
#define PT_REGS_RC(x) ((x)->rax)
#define PT_REGS_SP(x) ((x)->rsp)
#define PT_REGS_IP(x) ((x)->rip)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), rdi)
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), rsi)
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), rdx)
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), rcx)
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), r8)
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), rsp)
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((x), rbp)
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), rax)
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), rsp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), rip)

#endif
#endif

#elif defined(bpf_target_s390)

/* s390 provides user_pt_regs instead of struct pt_regs to userspace */
struct pt_regs;
#define PT_REGS_S390 const volatile user_pt_regs
#define PT_REGS_PARM1(x) (((PT_REGS_S390 *)(x))->gprs[2])
#define PT_REGS_PARM2(x) (((PT_REGS_S390 *)(x))->gprs[3])
#define PT_REGS_PARM3(x) (((PT_REGS_S390 *)(x))->gprs[4])
#define PT_REGS_PARM4(x) (((PT_REGS_S390 *)(x))->gprs[5])
#define PT_REGS_PARM5(x) (((PT_REGS_S390 *)(x))->gprs[6])
#define PT_REGS_RET(x) (((PT_REGS_S390 *)(x))->gprs[14])
/* Works only with CONFIG_FRAME_POINTER */
#define PT_REGS_FP(x) (((PT_REGS_S390 *)(x))->gprs[11])
#define PT_REGS_RC(x) (((PT_REGS_S390 *)(x))->gprs[2])
#define PT_REGS_SP(x) (((PT_REGS_S390 *)(x))->gprs[15])
#define PT_REGS_IP(x) (((PT_REGS_S390 *)(x))->psw.addr)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[2])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[3])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[4])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[5])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[6])
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[14])
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[11])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[2])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), gprs[15])
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((PT_REGS_S390 *)(x), psw.addr)

#elif defined(bpf_target_arm)

#define PT_REGS_PARM1(x) ((x)->uregs[0])
#define PT_REGS_PARM2(x) ((x)->uregs[1])
#define PT_REGS_PARM3(x) ((x)->uregs[2])
#define PT_REGS_PARM4(x) ((x)->uregs[3])
#define PT_REGS_PARM5(x) ((x)->uregs[4])
#define PT_REGS_RET(x) ((x)->uregs[14])
#define PT_REGS_FP(x) ((x)->uregs[11]) /* Works only with CONFIG_FRAME_POINTER */
#define PT_REGS_RC(x) ((x)->uregs[0])
#define PT_REGS_SP(x) ((x)->uregs[13])
#define PT_REGS_IP(x) ((x)->uregs[12])

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), uregs[0])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), uregs[1])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), uregs[2])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), uregs[3])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), uregs[4])
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), uregs[14])
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((x), uregs[11])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), uregs[0])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), uregs[13])
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), uregs[12])

#elif defined(bpf_target_arm64)

/* arm64 provides struct user_pt_regs instead of struct pt_regs to userspace */
struct pt_regs;
#define PT_REGS_ARM64 const volatile struct user_pt_regs
#define PT_REGS_PARM1(x) (((PT_REGS_ARM64 *)(x))->regs[0])
#define PT_REGS_PARM2(x) (((PT_REGS_ARM64 *)(x))->regs[1])
#define PT_REGS_PARM3(x) (((PT_REGS_ARM64 *)(x))->regs[2])
#define PT_REGS_PARM4(x) (((PT_REGS_ARM64 *)(x))->regs[3])
#define PT_REGS_PARM5(x) (((PT_REGS_ARM64 *)(x))->regs[4])
#define PT_REGS_RET(x) (((PT_REGS_ARM64 *)(x))->regs[30])
/* Works only with CONFIG_FRAME_POINTER */
#define PT_REGS_FP(x) (((PT_REGS_ARM64 *)(x))->regs[29])
#define PT_REGS_RC(x) (((PT_REGS_ARM64 *)(x))->regs[0])
#define PT_REGS_SP(x) (((PT_REGS_ARM64 *)(x))->sp)
#define PT_REGS_IP(x) (((PT_REGS_ARM64 *)(x))->pc)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[0])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[1])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[2])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[3])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[4])
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[30])
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[29])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), regs[0])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), sp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((PT_REGS_ARM64 *)(x), pc)

#elif defined(bpf_target_mips)

#define PT_REGS_PARM1(x) ((x)->regs[4])
#define PT_REGS_PARM2(x) ((x)->regs[5])
#define PT_REGS_PARM3(x) ((x)->regs[6])
#define PT_REGS_PARM4(x) ((x)->regs[7])
#define PT_REGS_PARM5(x) ((x)->regs[8])
#define PT_REGS_RET(x) ((x)->regs[31])
#define PT_REGS_FP(x) ((x)->regs[30]) /* Works only with CONFIG_FRAME_POINTER */
#define PT_REGS_RC(x) ((x)->regs[2])
#define PT_REGS_SP(x) ((x)->regs[29])
#define PT_REGS_IP(x) ((x)->cp0_epc)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), regs[4])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), regs[5])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), regs[6])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), regs[7])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), regs[8])
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), regs[31])
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((x), regs[30])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), regs[2])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), regs[29])
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), cp0_epc)

#elif defined(bpf_target_powerpc)

#define PT_REGS_PARM1(x) ((x)->gpr[3])
#define PT_REGS_PARM2(x) ((x)->gpr[4])
#define PT_REGS_PARM3(x) ((x)->gpr[5])
#define PT_REGS_PARM4(x) ((x)->gpr[6])
#define PT_REGS_PARM5(x) ((x)->gpr[7])
#define PT_REGS_RC(x) ((x)->gpr[3])
#define PT_REGS_SP(x) ((x)->sp)
#define PT_REGS_IP(x) ((x)->nip)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), gpr[3])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), gpr[4])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), gpr[5])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), gpr[6])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), gpr[7])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), gpr[3])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), sp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), nip)

#elif defined(bpf_target_sparc)

#define PT_REGS_PARM1(x) ((x)->u_regs[UREG_I0])
#define PT_REGS_PARM2(x) ((x)->u_regs[UREG_I1])
#define PT_REGS_PARM3(x) ((x)->u_regs[UREG_I2])
#define PT_REGS_PARM4(x) ((x)->u_regs[UREG_I3])
#define PT_REGS_PARM5(x) ((x)->u_regs[UREG_I4])
#define PT_REGS_RET(x) ((x)->u_regs[UREG_I7])
#define PT_REGS_RC(x) ((x)->u_regs[UREG_I0])
#define PT_REGS_SP(x) ((x)->u_regs[UREG_FP])

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I0])
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I1])
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I2])
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I3])
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I4])
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I7])
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((x), u_regs[UREG_I0])
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((x), u_regs[UREG_FP])

/* Should this also be a bpf_target check for the sparc case? */
#if defined(__arch64__)
#define PT_REGS_IP(x) ((x)->tpc)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), tpc)
#else
#define PT_REGS_IP(x) ((x)->pc)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((x), pc)
#endif

#elif defined(bpf_target_riscv)

struct pt_regs;
#define PT_REGS_RV const volatile struct user_regs_struct
#define PT_REGS_PARM1(x) (((PT_REGS_RV *)(x))->a0)
#define PT_REGS_PARM2(x) (((PT_REGS_RV *)(x))->a1)
#define PT_REGS_PARM3(x) (((PT_REGS_RV *)(x))->a2)
#define PT_REGS_PARM4(x) (((PT_REGS_RV *)(x))->a3)
#define PT_REGS_PARM5(x) (((PT_REGS_RV *)(x))->a4)
#define PT_REGS_RET(x) (((PT_REGS_RV *)(x))->ra)
#define PT_REGS_FP(x) (((PT_REGS_RV *)(x))->s5)
#define PT_REGS_RC(x) (((PT_REGS_RV *)(x))->a5)
#define PT_REGS_SP(x) (((PT_REGS_RV *)(x))->sp)
#define PT_REGS_IP(x) (((PT_REGS_RV *)(x))->epc)

#define PT_REGS_PARM1_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a0)
#define PT_REGS_PARM2_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a1)
#define PT_REGS_PARM3_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a2)
#define PT_REGS_PARM4_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a3)
#define PT_REGS_PARM5_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a4)
#define PT_REGS_RET_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), ra)
#define PT_REGS_FP_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), fp)
#define PT_REGS_RC_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), a5)
#define PT_REGS_SP_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), sp)
#define PT_REGS_IP_CORE(x) BPF_CORE_READ((PT_REGS_RV *)(x), epc)

#endif

#if defined(bpf_target_powerpc)
#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = (ctx)->link; })
#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
#elif defined(bpf_target_sparc)
#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = PT_REGS_RET(ctx); })
#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
#elif defined(bpf_target_defined)
#define BPF_KPROBE_READ_RET_IP(ip, ctx)					    \
	({ bpf_probe_read_kernel(&(ip), sizeof(ip), (void *)PT_REGS_RET(ctx)); })
#define BPF_KRETPROBE_READ_RET_IP(ip, ctx)				    \
	({ bpf_probe_read_kernel(&(ip), sizeof(ip),			    \
			  (void *)(PT_REGS_FP(ctx) + sizeof(ip))); })
#endif

#if !defined(bpf_target_defined)

#define PT_REGS_PARM1(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM2(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM3(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM4(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM5(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_RET(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_FP(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_RC(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_SP(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_IP(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })

#define PT_REGS_PARM1_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM2_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM3_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM4_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_PARM5_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_RET_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_FP_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_RC_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_SP_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define PT_REGS_IP_CORE(x) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })

#define BPF_KPROBE_READ_RET_IP(ip, ctx) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })
#define BPF_KRETPROBE_READ_RET_IP(ip, ctx) ({ _Pragma(__BPF_TARGET_MISSING); 0l; })

#endif /* !defined(bpf_target_defined) */

#ifndef ___bpf_concat
#define ___bpf_concat(a, b) a ## b
#endif
#ifndef ___bpf_apply
#define ___bpf_apply(fn, n) ___bpf_concat(fn, n)
#endif
#ifndef ___bpf_nth
#define ___bpf_nth(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _a, _b, _c, N, ...) N
#endif
#ifndef ___bpf_narg
#define ___bpf_narg(...) \
	___bpf_nth(_, ##__VA_ARGS__, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#endif

#define ___bpf_ctx_cast0() ctx
#define ___bpf_ctx_cast1(x) ___bpf_ctx_cast0(), (void *)ctx[0]
#define ___bpf_ctx_cast2(x, args...) ___bpf_ctx_cast1(args), (void *)ctx[1]
#define ___bpf_ctx_cast3(x, args...) ___bpf_ctx_cast2(args), (void *)ctx[2]
#define ___bpf_ctx_cast4(x, args...) ___bpf_ctx_cast3(args), (void *)ctx[3]
#define ___bpf_ctx_cast5(x, args...) ___bpf_ctx_cast4(args), (void *)ctx[4]
#define ___bpf_ctx_cast6(x, args...) ___bpf_ctx_cast5(args), (void *)ctx[5]
#define ___bpf_ctx_cast7(x, args...) ___bpf_ctx_cast6(args), (void *)ctx[6]
#define ___bpf_ctx_cast8(x, args...) ___bpf_ctx_cast7(args), (void *)ctx[7]
#define ___bpf_ctx_cast9(x, args...) ___bpf_ctx_cast8(args), (void *)ctx[8]
#define ___bpf_ctx_cast10(x, args...) ___bpf_ctx_cast9(args), (void *)ctx[9]
#define ___bpf_ctx_cast11(x, args...) ___bpf_ctx_cast10(args), (void *)ctx[10]
#define ___bpf_ctx_cast12(x, args...) ___bpf_ctx_cast11(args), (void *)ctx[11]
#define ___bpf_ctx_cast(args...) \
	___bpf_apply(___bpf_ctx_cast, ___bpf_narg(args))(args)

/*
 * BPF_PROG is a convenience wrapper for generic tp_btf/fentry/fexit and
 * similar kinds of BPF programs, that accept input arguments as a single
 * pointer to untyped u64 array, where each u64 can actually be a typed
 * pointer or integer of different size. Instead of requring user to write
 * manual casts and work with array elements by index, BPF_PROG macro
 * allows user to declare a list of named and typed input arguments in the
 * same syntax as for normal C function. All the casting is hidden and
 * performed transparently, while user code can just assume working with
 * function arguments of specified type and name.
 *
 * Original raw context argument is preserved as well as 'ctx' argument.
 * This is useful when using BPF helpers that expect original context
 * as one of the parameters (e.g., for bpf_perf_event_output()).
 */
#define BPF_PROG(name, args...)						    \
name(unsigned long long *ctx);						    \
static __attribute__((always_inline)) typeof(name(0))			    \
____##name(unsigned long long *ctx, ##args);				    \
typeof(name(0)) name(unsigned long long *ctx)				    \
{									    \
	_Pragma("GCC diagnostic push")					    \
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")		    \
	return ____##name(___bpf_ctx_cast(args));			    \
	_Pragma("GCC diagnostic pop")					    \
}									    \
static __attribute__((always_inline)) typeof(name(0))			    \
____##name(unsigned long long *ctx, ##args)

struct pt_regs;

#define ___bpf_kprobe_args0() ctx
#define ___bpf_kprobe_args1(x) \
	___bpf_kprobe_args0(), (void *)PT_REGS_PARM1(ctx)
#define ___bpf_kprobe_args2(x, args...) \
	___bpf_kprobe_args1(args), (void *)PT_REGS_PARM2(ctx)
#define ___bpf_kprobe_args3(x, args...) \
	___bpf_kprobe_args2(args), (void *)PT_REGS_PARM3(ctx)
#define ___bpf_kprobe_args4(x, args...) \
	___bpf_kprobe_args3(args), (void *)PT_REGS_PARM4(ctx)
#define ___bpf_kprobe_args5(x, args...) \
	___bpf_kprobe_args4(args), (void *)PT_REGS_PARM5(ctx)
#define ___bpf_kprobe_args(args...) \
	___bpf_apply(___bpf_kprobe_args, ___bpf_narg(args))(args)

/*
 * BPF_KPROBE serves the same purpose for kprobes as BPF_PROG for
 * tp_btf/fentry/fexit BPF programs. It hides the underlying platform-specific
 * low-level way of getting kprobe input arguments from struct pt_regs, and
 * provides a familiar typed and named function arguments syntax and
 * semantics of accessing kprobe input paremeters.
 *
 * Original struct pt_regs* context is preserved as 'ctx' argument. This might
 * be necessary when using BPF helpers like bpf_perf_event_output().
 */
#define BPF_KPROBE(name, args...)					    \
name(struct pt_regs *ctx);						    \
static __attribute__((always_inline)) typeof(name(0))			    \
____##name(struct pt_regs *ctx, ##args);				    \
typeof(name(0)) name(struct pt_regs *ctx)				    \
{									    \
	_Pragma("GCC diagnostic push")					    \
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")		    \
	return ____##name(___bpf_kprobe_args(args));			    \
	_Pragma("GCC diagnostic pop")					    \
}									    \
static __attribute__((always_inline)) typeof(name(0))			    \
____##name(struct pt_regs *ctx, ##args)

#define ___bpf_kretprobe_args0() ctx
#define ___bpf_kretprobe_args1(x) \
	___bpf_kretprobe_args0(), (void *)PT_REGS_RC(ctx)
#define ___bpf_kretprobe_args(args...) \
	___bpf_apply(___bpf_kretprobe_args, ___bpf_narg(args))(args)

/*
 * BPF_KRETPROBE is similar to BPF_KPROBE, except, it only provides optional
 * return value (in addition to `struct pt_regs *ctx`), but no input
 * arguments, because they will be clobbered by the time probed function
 * returns.
 */
#define BPF_KRETPROBE(name, args...)					    \
name(struct pt_regs *ctx);						    \
static __attribute__((always_inline)) typeof(name(0))			    \
____##name(struct pt_regs *ctx, ##args);				    \
typeof(name(0)) name(struct pt_regs *ctx)				    \
{									    \
	_Pragma("GCC diagnostic push")					    \
	_Pragma("GCC diagnostic ignored \"-Wint-conversion\"")		    \
	return ____##name(___bpf_kretprobe_args(args));			    \
	_Pragma("GCC diagnostic pop")					    \
}									    \
static __always_inline typeof(name(0)) ____##name(struct pt_regs *ctx, ##args)

#endif

```

`headers/common.h`:

```h
// This is a compact version of `vmlinux.h` to be used in the examples using C code.

#pragma once

typedef unsigned char __u8;
typedef short int __s16;
typedef short unsigned int __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long int __s64;
typedef long long unsigned int __u64;
typedef __u8 u8;
typedef __s16 s16;
typedef __u16 u16;
typedef __s32 s32;
typedef __u32 u32;
typedef __s64 s64;
typedef __u64 u64;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __be32;
typedef __u64 __be64;
typedef __u32 __wsum;

#include "bpf_helpers.h"

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC                = 0,
	BPF_MAP_TYPE_HASH                  = 1,
	BPF_MAP_TYPE_ARRAY                 = 2,
	BPF_MAP_TYPE_PROG_ARRAY            = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY      = 4,
	BPF_MAP_TYPE_PERCPU_HASH           = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY          = 6,
	BPF_MAP_TYPE_STACK_TRACE           = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY          = 8,
	BPF_MAP_TYPE_LRU_HASH              = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH       = 10,
	BPF_MAP_TYPE_LPM_TRIE              = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS         = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS          = 13,
	BPF_MAP_TYPE_DEVMAP                = 14,
	BPF_MAP_TYPE_SOCKMAP               = 15,
	BPF_MAP_TYPE_CPUMAP                = 16,
	BPF_MAP_TYPE_XSKMAP                = 17,
	BPF_MAP_TYPE_SOCKHASH              = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE        = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY   = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE                 = 22,
	BPF_MAP_TYPE_STACK                 = 23,
	BPF_MAP_TYPE_SK_STORAGE            = 24,
	BPF_MAP_TYPE_DEVMAP_HASH           = 25,
	BPF_MAP_TYPE_STRUCT_OPS            = 26,
	BPF_MAP_TYPE_RINGBUF               = 27,
	BPF_MAP_TYPE_INODE_STORAGE         = 28,
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

typedef __u16 __sum16;

#define ETH_P_IP 0x0800

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

enum {
	BPF_ANY     = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST   = 2,
	BPF_F_LOCK  = 4,
};

/* BPF_FUNC_perf_event_output, BPF_FUNC_perf_event_read and
 * BPF_FUNC_perf_event_read_value flags.
 */
#define BPF_F_INDEX_MASK 0xffffffffULL
#define BPF_F_CURRENT_CPU BPF_F_INDEX_MASK

#if defined(__TARGET_ARCH_x86)
struct pt_regs {
	/*
	 * C ABI says these regs are callee-preserved. They aren't saved on kernel entry
	 * unless syscall needs a complete, fully filled "struct pt_regs".
	 */
	unsigned long r15;
	unsigned long r14;
	unsigned long r13;
	unsigned long r12;
	unsigned long rbp;
	unsigned long rbx;
	/* These regs are callee-clobbered. Always saved on kernel entry. */
	unsigned long r11;
	unsigned long r10;
	unsigned long r9;
	unsigned long r8;
	unsigned long rax;
	unsigned long rcx;
	unsigned long rdx;
	unsigned long rsi;
	unsigned long rdi;
	/*
	 * On syscall entry, this is syscall#. On CPU exception, this is error code.
	 * On hw interrupt, it's IRQ number:
	 */
	unsigned long orig_rax;
	/* Return frame for iretq */
	unsigned long rip;
	unsigned long cs;
	unsigned long eflags;
	unsigned long rsp;
	unsigned long ss;
	/* top of stack page */
};
#endif /* __TARGET_ARCH_x86 */

```

`headers/update.sh`:

```sh
#!/usr/bin/env bash

# Version of libbpf to fetch headers from
LIBBPF_VERSION=0.6.1

# The headers we want
prefix=libbpf-"$LIBBPF_VERSION"
headers=(
    "$prefix"/LICENSE.BSD-2-Clause
    "$prefix"/src/bpf_endian.h
    "$prefix"/src/bpf_helper_defs.h
    "$prefix"/src/bpf_helpers.h
    "$prefix"/src/bpf_tracing.h
)

# Fetch libbpf release and extract the desired headers
curl -sL "https://github.com/libbpf/libbpf/archive/refs/tags/v${LIBBPF_VERSION}.tar.gz" | \
    tar -xz --xform='s#.*/##' "${headers[@]}"

```

`main.go`:

```go
package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"log"
	"os"
	"os/signal"
	"syscall"
	"fmt"
	"flag"
	"encoding/json"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"

	"github.com/davecgh/go-spew/spew"
)

const ChunkSize = 0x400
const MaxChunks = 16

type Filter struct {
	Interface string `json:"interface"`
	Method    string `json:"method"`
}

type Config struct {
	PackageName  string          `json:"package_name"`
	Args         bool            `json:"args"`
	FileName     string          `json:"file_name"`
	CustomMethods MethodMappings `json:"customMethods"`
	Filters      []Filter        `json:"filters"`
}

func parseFlags() (Config, string) {
	var config Config
	var configFile string

	flag.StringVar(&configFile, "c", "", "specify the configuration file")
	flag.StringVar(&config.PackageName, "p", "", "specify the package name to trace")
	flag.BoolVar(&config.Args, "a", false, "whether to trace arguments")
	flag.StringVar(&config.FileName, "f", "", "specify the log output file")

	flag.Parse()

	return config, configFile
}

func parseConfigFile(filename string) (Config, error) {
	var config Config
	file, err := os.Open(filename)
	if err != nil {
		return config, err
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&config); err != nil {
		return config, err
	}

	return config, nil
}

func mergeConfigs(flagConfig, fileConfig Config) Config {
	if flagConfig.PackageName != "" {
		fileConfig.PackageName = flagConfig.PackageName
	}
	if flagConfig.Args {
		fileConfig.Args = flagConfig.Args
	}
	if flagConfig.FileName != "" {
		fileConfig.FileName = flagConfig.FileName
	}
	return fileConfig
}

func mergeChunks(chunks [][]byte) []byte {
	mergedData := make([]byte, 0, len(chunks)*ChunkSize)

    for _, chunk := range chunks {
        mergedData = append(mergedData, chunk...)
    }

    return mergedData
}

func shouldFilter(interfaceToken, methodName string, filters []Filter) bool {
	for _, filter := range filters {
		if filter.Interface == interfaceToken && (filter.Method == "" || filter.Method == methodName) {
			return true
		}
	}
	return false
}

func main() {

	// 解析命令行参数
	flagConfig, configFile := parseFlags()

	// 解析配置文件
	var fileConfig Config
	if configFile != "" {
		var err error
		fileConfig, err = parseConfigFile(configFile)
		if err != nil {
			log.Fatalf("读取配置文件失败: %v", err)
		}
	}
	
	// 合并命令行参数和配置文件参数
	conf := mergeConfigs(flagConfig, fileConfig)

	var logger *log.Logger
	if conf.FileName != "" {
		file, err := os.OpenFile(conf.FileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
		if err != nil {
			fmt.Println("无法打开日志文件:", err)
			return
		}
		defer file.Close()
		logger = log.New(file, "", log.Ldate|log.Ltime|log.Lshortfile)
	} else {
		// 如果未指定日志文件，则将日志输出到控制台
		logger = log.New(os.Stdout, "", log.Ldate|log.Ltime|log.Lshortfile)
	}

	// Name of the kernel function to trace.
	fn := "binder_transaction"

	// Subscribe to signals for terminating the program.
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

	// Load default method mappings from embedded JSON
	if err := LoadMethodMappings(methodsJSON); err != nil {
		logger.Fatal(err)
	}

	// Override default method mappings with custom methods from config file
	OverrideMethodMappings(conf.CustomMethods)

	if err := LoadPackageMappings(); err != nil {
		logger.Fatal(err)
	}

	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		logger.Fatal(err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		logger.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	var config_key uint32 = 0;
	config_value := bpfTraceConfig{};
	uid, err := GetUidByPackageName(conf.PackageName)
	if err != nil {
		uid = 0;
	}
	config_value.Uid = uint32(uid);
	if err := objs.TraceConfigMap.Put(config_key, config_value); err != nil {
		logger.Fatalf("写入 BPF 配置映射失败: %v", err)
	}

	// Open a Kprobe at the entry point of the kernel function and attach the
	// pre-compiled program. Each time the kernel function enters, the program
	// will emit an event containing pid and command of the execved task.
	kp, err := link.Kprobe(fn, objs.KprobeBinderTransaction, nil)
	if err != nil {
		logger.Fatalf("opening kprobe: %s", err)
	}
	defer kp.Close()

	// Open a ringbuf reader from userspace RINGBUF map described in the
	// eBPF C program.
	rd, err := ringbuf.NewReader(objs.TraceEventMap)
	if err != nil {
		logger.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when the process receives a signal, which will exit
	// the read loop.
	go func() {
		<-stopper

		if err := rd.Close(); err != nil {
			logger.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	logger.Println("Waiting for events..")

	// bpfEvent is generated by bpf2go.
	var event bpfTraceEvent
	var transactionBuffers = make(map[uint64][][]byte)
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				logger.Println("Received signal, exiting..")
				return
			}
			logger.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			logger.Printf("parsing ringbuf event: %s", err)
			continue
		}

		if _, exists := transactionBuffers[event.TransactionId]; !exists {
			var totalChunks = (event.DataSize + ChunkSize - 1) / ChunkSize
			transactionBuffers[event.TransactionId] = make([][]byte, totalChunks)
		}
		transactionBuffers[event.TransactionId][event.ChunkIndex] = append([]byte(nil), event.ChunkData[:]...)
		
		var complete = true
		for _, chunk := range transactionBuffers[event.TransactionId] {
			if chunk == nil {
				complete = false
				break
			}
		}
		
		if complete {
			completeData := mergeChunks(transactionBuffers[event.TransactionId])
			delete(transactionBuffers, event.TransactionId)

			if len(completeData) <= 16 {
				continue
			}
			if len(completeData) > ChunkSize*MaxChunks {
				continue
			}

			parcelData := completeData[:event.DataSize-1]

			interfaceToken, err := ExtractInterfaceName(parcelData)

			if err != nil {
				logger.Println("Error parsing parcel:", err)
				continue
			}

			methodName, err := GetMethodName(interfaceToken, int(event.Code))
			if err != nil {
				methodName = fmt.Sprintf("%d", event.Code)
			}

			if shouldFilter(interfaceToken, methodName, conf.Filters) {
				continue
			}

			packageName, err := GetPackageNameByUid(int(event.Uid))
			if err != nil {
				packageName = fmt.Sprintf("%d", event.Uid)
			}

			if conf.Args {
				logger.Printf("(pid:%d, uid:%d, package:%s) -> (interface:%s, method:%s)\n%s", event.Pid, event.Uid, packageName, interfaceToken, methodName, spew.Sdump(parcelData))
			} else {
				logger.Printf("(pid:%d, uid:%d, package:%s) -> (interface:%s, method:%s)\n", event.Pid, event.Uid, packageName, interfaceToken, methodName)
			}
		}
	}
}

```

`method_resolver.go`:

```go
package main

import (
	"encoding/json"
	"fmt"
	_ "embed"
)

//go:embed methods.json
var methodsJSON []byte

type MethodMappings map[string]map[string]string

var interfaceMethods = make(map[string]map[int]string)

// LoadMethodMappings 从嵌入的 JSON 数据加载方法映射
func LoadMethodMappings(jsonData []byte) error {
	var mappings MethodMappings
	if err := json.Unmarshal(jsonData, &mappings); err != nil {
		return fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	// 转换为 interfaceMethods 的格式
	for interfaceName, methods := range mappings {
		methodMap := make(map[int]string)
		for code, methodName := range methods {
			var codeInt int
			if _, err := fmt.Sscan(code, &codeInt); err != nil {
				return fmt.Errorf("invalid method code: %w", err)
			}
			methodMap[codeInt] = methodName
		}
		interfaceMethods[interfaceName] = methodMap
	}

	return nil
}

// OverrideMethodMappings 用于覆盖默认方法映射
func OverrideMethodMappings(customMethods MethodMappings) {
	for interfaceName, methods := range customMethods {
		if _, ok := interfaceMethods[interfaceName]; !ok {
			interfaceMethods[interfaceName] = make(map[int]string)
		}
		for code, methodName := range methods {
			var codeInt int
			if _, err := fmt.Sscan(code, &codeInt); err == nil {
				interfaceMethods[interfaceName][codeInt] = methodName
			}
		}
	}
}

func GetMethodName(interfaceName string, code int) (string, error) {
	if methods, ok := interfaceMethods[interfaceName]; ok {
		if methodName, ok := methods[code]; ok {
			return methodName, nil
		}
		return "", fmt.Errorf("method not found for code %d in interface %s", code, interfaceName)
	}
	return "", fmt.Errorf("interface %s not found", interfaceName)
}

```

`methods.json`:

```json
{
  "android.content.pm.IBackgroundInstallControlService": {
    "1": "android.content.pm.ParceledListSlice getBackgroundInstalledPackages(long, int)"
  },
  "android.net.nsd.INsdManager": {
    "1": "android.net.connectivity.android.net.nsd.INsdServiceConnector connect(android.net.connectivity.android.net.nsd.INsdManagerCallback, boolean)"
  },
  "android.system.keystore2.IKeystoreService": {
    "1": "android.system.keystore2.IKeystoreSecurityLevel getSecurityLevel(int)",
    "2": "android.system.keystore2.KeyEntryResponse getKeyEntry(android.system.keystore2.KeyDescriptor)",
    "3": "void updateSubcomponent(android.system.keystore2.KeyDescriptor, [B, [B)",
    "4": "[Landroid.system.keystore2.KeyDescriptor; listEntries(int, long)",
    "5": "void deleteKey(android.system.keystore2.KeyDescriptor)",
    "6": "android.system.keystore2.KeyDescriptor grant(android.system.keystore2.KeyDescriptor, int, int)",
    "7": "void ungrant(android.system.keystore2.KeyDescriptor, int)",
    "8": "int getNumberOfEntries(int, long)",
    "9": "[Landroid.system.keystore2.KeyDescriptor; listEntriesBatched(int, long, java.lang.String)"
  },
  "android.content.IContentService": {
    "1": "void unregisterContentObserver(android.database.IContentObserver)",
    "2": "void registerContentObserver(android.net.Uri, boolean, android.database.IContentObserver, int, int)",
    "3": "void notifyChange([Landroid.net.Uri;, android.database.IContentObserver, boolean, int, int, int, java.lang.String)",
    "4": "void requestSync(android.accounts.Account, java.lang.String, android.os.Bundle, java.lang.String)",
    "5": "void sync(android.content.SyncRequest, java.lang.String)",
    "6": "void syncAsUser(android.content.SyncRequest, int, java.lang.String)",
    "7": "void cancelSync(android.accounts.Account, java.lang.String, android.content.ComponentName)",
    "8": "void cancelSyncAsUser(android.accounts.Account, java.lang.String, android.content.ComponentName, int)",
    "9": "void cancelRequest(android.content.SyncRequest)",
    "10": "boolean getSyncAutomatically(android.accounts.Account, java.lang.String)",
    "11": "boolean getSyncAutomaticallyAsUser(android.accounts.Account, java.lang.String, int)",
    "12": "void setSyncAutomatically(android.accounts.Account, java.lang.String, boolean)",
    "13": "void setSyncAutomaticallyAsUser(android.accounts.Account, java.lang.String, boolean, int)",
    "14": "java.util.List getPeriodicSyncs(android.accounts.Account, java.lang.String, android.content.ComponentName)",
    "15": "void addPeriodicSync(android.accounts.Account, java.lang.String, android.os.Bundle, long)",
    "16": "void removePeriodicSync(android.accounts.Account, java.lang.String, android.os.Bundle)",
    "17": "int getIsSyncable(android.accounts.Account, java.lang.String)",
    "18": "int getIsSyncableAsUser(android.accounts.Account, java.lang.String, int)",
    "19": "void setIsSyncable(android.accounts.Account, java.lang.String, int)",
    "20": "void setIsSyncableAsUser(android.accounts.Account, java.lang.String, int, int)",
    "21": "void setMasterSyncAutomatically(boolean)",
    "22": "void setMasterSyncAutomaticallyAsUser(boolean, int)",
    "23": "boolean getMasterSyncAutomatically()",
    "24": "boolean getMasterSyncAutomaticallyAsUser(int)",
    "25": "java.util.List getCurrentSyncs()",
    "26": "java.util.List getCurrentSyncsAsUser(int)",
    "27": "[Landroid.content.SyncAdapterType; getSyncAdapterTypes()",
    "28": "[Landroid.content.SyncAdapterType; getSyncAdapterTypesAsUser(int)",
    "29": "[Ljava.lang.String; getSyncAdapterPackagesForAuthorityAsUser(java.lang.String, int)",
    "30": "java.lang.String getSyncAdapterPackageAsUser(java.lang.String, java.lang.String, int)",
    "31": "boolean isSyncActive(android.accounts.Account, java.lang.String, android.content.ComponentName)",
    "32": "android.content.SyncStatusInfo getSyncStatus(android.accounts.Account, java.lang.String, android.content.ComponentName)",
    "33": "android.content.SyncStatusInfo getSyncStatusAsUser(android.accounts.Account, java.lang.String, android.content.ComponentName, int)",
    "34": "boolean isSyncPending(android.accounts.Account, java.lang.String, android.content.ComponentName)",
    "35": "boolean isSyncPendingAsUser(android.accounts.Account, java.lang.String, android.content.ComponentName, int)",
    "36": "void addStatusChangeListener(int, android.content.ISyncStatusObserver)",
    "37": "void removeStatusChangeListener(android.content.ISyncStatusObserver)",
    "38": "void putCache(java.lang.String, android.net.Uri, android.os.Bundle, int)",
    "39": "android.os.Bundle getCache(java.lang.String, android.net.Uri, int)",
    "40": "void resetTodayStats()",
    "41": "void onDbCorruption(java.lang.String, java.lang.String, java.lang.String)"
  },
  "android.os.IStoraged": {
    "1": "void onUserStarted(int)",
    "2": "void onUserStopped(int)",
    "3": "int getRecentPerf()"
  },
  "android.content.res.IResourcesManager": {
    "1": "boolean dumpResources(java.lang.String, android.os.ParcelFileDescriptor, android.os.RemoteCallback)"
  },
  "android.hardware.fingerprint.IFingerprintService": {
    "1": "android.hardware.biometrics.ITestSession createTestSession(int, android.hardware.biometrics.ITestSessionCallback, java.lang.String)",
    "2": "[B dumpSensorServiceStateProto(int, boolean)",
    "3": "java.util.List getSensorPropertiesInternal(java.lang.String)",
    "4": "android.hardware.fingerprint.FingerprintSensorPropertiesInternal getSensorProperties(int, java.lang.String)",
    "5": "long authenticate(android.os.IBinder, long, android.hardware.fingerprint.IFingerprintServiceReceiver, android.hardware.fingerprint.FingerprintAuthenticateOptions)",
    "6": "long detectFingerprint(android.os.IBinder, android.hardware.fingerprint.IFingerprintServiceReceiver, android.hardware.fingerprint.FingerprintAuthenticateOptions)",
    "7": "void prepareForAuthentication(android.os.IBinder, long, android.hardware.biometrics.IBiometricSensorReceiver, android.hardware.fingerprint.FingerprintAuthenticateOptions, long, int, boolean)",
    "8": "void startPreparedClient(int, int)",
    "9": "void cancelAuthentication(android.os.IBinder, java.lang.String, java.lang.String, long)",
    "10": "void cancelFingerprintDetect(android.os.IBinder, java.lang.String, long)",
    "11": "void cancelAuthenticationFromService(int, android.os.IBinder, java.lang.String, long)",
    "12": "long enroll(android.os.IBinder, [B, int, android.hardware.fingerprint.IFingerprintServiceReceiver, java.lang.String, int)",
    "13": "void cancelEnrollment(android.os.IBinder, long)",
    "14": "void remove(android.os.IBinder, int, int, android.hardware.fingerprint.IFingerprintServiceReceiver, java.lang.String)",
    "15": "void removeAll(android.os.IBinder, int, android.hardware.fingerprint.IFingerprintServiceReceiver, java.lang.String)",
    "16": "void rename(int, int, java.lang.String)",
    "17": "java.util.List getEnrolledFingerprints(int, java.lang.String, java.lang.String)",
    "18": "boolean isHardwareDetectedDeprecated(java.lang.String, java.lang.String)",
    "19": "boolean isHardwareDetected(int, java.lang.String)",
    "20": "void generateChallenge(android.os.IBinder, int, int, android.hardware.fingerprint.IFingerprintServiceReceiver, java.lang.String)",
    "21": "void revokeChallenge(android.os.IBinder, int, int, java.lang.String, long)",
    "22": "boolean hasEnrolledFingerprintsDeprecated(int, java.lang.String, java.lang.String)",
    "23": "boolean hasEnrolledFingerprints(int, int, java.lang.String)",
    "24": "int getLockoutModeForUser(int, int)",
    "25": "void invalidateAuthenticatorId(int, int, android.hardware.biometrics.IInvalidationCallback)",
    "26": "long getAuthenticatorId(int, int)",
    "27": "void resetLockout(android.os.IBinder, int, int, [B, java.lang.String)",
    "28": "void addLockoutResetCallback(android.hardware.biometrics.IBiometricServiceLockoutResetCallback, java.lang.String)",
    "29": "boolean isClientActive()",
    "30": "void addClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)",
    "31": "void removeClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)",
    "32": "void registerAuthenticators(java.util.List)",
    "33": "void addAuthenticatorsRegisteredCallback(android.hardware.fingerprint.IFingerprintAuthenticatorsRegisteredCallback)",
    "34": "void onPointerDown(long, int, android.hardware.biometrics.fingerprint.PointerContext)",
    "35": "void onPointerUp(long, int, android.hardware.biometrics.fingerprint.PointerContext)",
    "36": "void onUiReady(long, int)",
    "37": "void setUdfpsOverlayController(android.hardware.fingerprint.IUdfpsOverlayController)",
    "38": "void setSidefpsController(android.hardware.fingerprint.ISidefpsController)",
    "39": "void setUdfpsOverlay(android.hardware.fingerprint.IUdfpsOverlay)",
    "40": "void registerBiometricStateListener(android.hardware.biometrics.IBiometricStateListener)",
    "41": "void onPowerPressed()",
    "42": "void scheduleWatchdog()"
  },
  "com.android.internal.widget.ILockSettings": {
    "1": "void setBoolean(java.lang.String, boolean, int)",
    "2": "void setLong(java.lang.String, long, int)",
    "3": "void setString(java.lang.String, java.lang.String, int)",
    "4": "boolean getBoolean(java.lang.String, boolean, int)",
    "5": "long getLong(java.lang.String, long, int)",
    "6": "java.lang.String getString(java.lang.String, java.lang.String, int)",
    "7": "boolean setLockCredential(com.android.internal.widget.LockscreenCredential, com.android.internal.widget.LockscreenCredential, int)",
    "8": "void resetKeyStore(int)",
    "9": "com.android.internal.widget.VerifyCredentialResponse checkCredential(com.android.internal.widget.LockscreenCredential, int, com.android.internal.widget.ICheckCredentialProgressCallback)",
    "10": "com.android.internal.widget.VerifyCredentialResponse verifyCredential(com.android.internal.widget.LockscreenCredential, int, int)",
    "11": "com.android.internal.widget.VerifyCredentialResponse verifyTiedProfileChallenge(com.android.internal.widget.LockscreenCredential, int, int)",
    "12": "com.android.internal.widget.VerifyCredentialResponse verifyGatekeeperPasswordHandle(long, long, int)",
    "13": "void removeGatekeeperPasswordHandle(long)",
    "14": "int getCredentialType(int)",
    "15": "int getPinLength(int)",
    "16": "boolean refreshStoredPinLength(int)",
    "17": "[B getHashFactor(com.android.internal.widget.LockscreenCredential, int)",
    "18": "void setSeparateProfileChallengeEnabled(int, boolean, com.android.internal.widget.LockscreenCredential)",
    "19": "boolean getSeparateProfileChallengeEnabled(int)",
    "20": "void registerStrongAuthTracker(android.app.trust.IStrongAuthTracker)",
    "21": "void unregisterStrongAuthTracker(android.app.trust.IStrongAuthTracker)",
    "22": "void requireStrongAuth(int, int)",
    "23": "void reportSuccessfulBiometricUnlock(boolean, int)",
    "24": "void scheduleNonStrongBiometricIdleTimeout(int)",
    "25": "void systemReady()",
    "26": "void userPresent(int)",
    "27": "int getStrongAuthForUser(int)",
    "28": "boolean hasPendingEscrowToken(int)",
    "29": "void initRecoveryServiceWithSigFile(java.lang.String, [B, [B)",
    "30": "android.security.keystore.recovery.KeyChainSnapshot getKeyChainSnapshot()",
    "31": "java.lang.String generateKey(java.lang.String)",
    "32": "java.lang.String generateKeyWithMetadata(java.lang.String, [B)",
    "33": "java.lang.String importKey(java.lang.String, [B)",
    "34": "java.lang.String importKeyWithMetadata(java.lang.String, [B, [B)",
    "35": "java.lang.String getKey(java.lang.String)",
    "36": "void removeKey(java.lang.String)",
    "37": "void setSnapshotCreatedPendingIntent(android.app.PendingIntent)",
    "38": "void setServerParams([B)",
    "39": "void setRecoveryStatus(java.lang.String, int)",
    "40": "java.util.Map getRecoveryStatus()",
    "41": "void setRecoverySecretTypes([I)",
    "42": "[I getRecoverySecretTypes()",
    "43": "[B startRecoverySessionWithCertPath(java.lang.String, java.lang.String, android.security.keystore.recovery.RecoveryCertPath, [B, [B, java.util.List)",
    "44": "java.util.Map recoverKeyChainSnapshot(java.lang.String, [B, java.util.List)",
    "45": "void closeSession(java.lang.String)",
    "46": "android.app.RemoteLockscreenValidationSession startRemoteLockscreenValidation()",
    "47": "android.app.RemoteLockscreenValidationResult validateRemoteLockscreen([B)",
    "48": "boolean hasSecureLockScreen()",
    "49": "boolean tryUnlockWithCachedUnifiedChallenge(int)",
    "50": "void removeCachedUnifiedChallenge(int)",
    "51": "boolean registerWeakEscrowTokenRemovedListener(com.android.internal.widget.IWeakEscrowTokenRemovedListener)",
    "52": "boolean unregisterWeakEscrowTokenRemovedListener(com.android.internal.widget.IWeakEscrowTokenRemovedListener)",
    "53": "long addWeakEscrowToken([B, int, com.android.internal.widget.IWeakEscrowTokenActivatedListener)",
    "54": "boolean removeWeakEscrowToken(long, int)",
    "55": "boolean isWeakEscrowTokenActive(long, int)",
    "56": "boolean isWeakEscrowTokenValid(long, [B, int)"
  },
  "android.app.IUriGrantsManager": {
    "1": "void takePersistableUriPermission(android.net.Uri, int, java.lang.String, int)",
    "2": "void releasePersistableUriPermission(android.net.Uri, int, java.lang.String, int)",
    "3": "void grantUriPermissionFromOwner(android.os.IBinder, int, java.lang.String, android.net.Uri, int, int, int)",
    "4": "android.content.pm.ParceledListSlice getGrantedUriPermissions(java.lang.String, int)",
    "5": "void clearGrantedUriPermissions(java.lang.String, int)",
    "6": "android.content.pm.ParceledListSlice getUriPermissions(java.lang.String, boolean, boolean)"
  },
  "android.app.IGameManagerService": {
    "1": "int getGameMode(java.lang.String, int)",
    "2": "void setGameMode(java.lang.String, int, int)",
    "3": "[I getAvailableGameModes(java.lang.String, int)",
    "4": "boolean isAngleEnabled(java.lang.String, int)",
    "5": "void notifyGraphicsEnvironmentSetup(java.lang.String, int)",
    "6": "void setGameState(java.lang.String, android.app.GameState, int)",
    "7": "android.app.GameModeInfo getGameModeInfo(java.lang.String, int)",
    "8": "void setGameServiceProvider(java.lang.String)",
    "9": "void updateResolutionScalingFactor(java.lang.String, int, float, int)",
    "10": "float getResolutionScalingFactor(java.lang.String, int, int)",
    "11": "void updateCustomGameModeConfiguration(java.lang.String, android.app.GameModeConfiguration, int)",
    "12": "void addGameModeListener(android.app.IGameModeListener)",
    "13": "void removeGameModeListener(android.app.IGameModeListener)"
  },
  "android.app.usage.IUsageStatsManager": {
    "1": "android.content.pm.ParceledListSlice queryUsageStats(int, long, long, java.lang.String, int)",
    "2": "android.content.pm.ParceledListSlice queryConfigurationStats(int, long, long, java.lang.String)",
    "3": "android.content.pm.ParceledListSlice queryEventStats(int, long, long, java.lang.String)",
    "4": "android.app.usage.UsageEvents queryEvents(long, long, java.lang.String)",
    "5": "android.app.usage.UsageEvents queryEventsForPackage(long, long, java.lang.String)",
    "6": "android.app.usage.UsageEvents queryEventsForUser(long, long, int, java.lang.String)",
    "7": "android.app.usage.UsageEvents queryEventsForPackageForUser(long, long, int, java.lang.String, java.lang.String)",
    "8": "void setAppInactive(java.lang.String, boolean, int)",
    "9": "boolean isAppStandbyEnabled()",
    "10": "boolean isAppInactive(java.lang.String, int, java.lang.String)",
    "11": "void onCarrierPrivilegedAppsChanged()",
    "12": "void reportChooserSelection(java.lang.String, int, java.lang.String, [Ljava.lang.String;, java.lang.String)",
    "13": "int getAppStandbyBucket(java.lang.String, java.lang.String, int)",
    "14": "void setAppStandbyBucket(java.lang.String, int, int)",
    "15": "android.content.pm.ParceledListSlice getAppStandbyBuckets(java.lang.String, int)",
    "16": "void setAppStandbyBuckets(android.content.pm.ParceledListSlice, int)",
    "17": "int getAppMinStandbyBucket(java.lang.String, java.lang.String, int)",
    "18": "void setEstimatedLaunchTime(java.lang.String, long, int)",
    "19": "void setEstimatedLaunchTimes(android.content.pm.ParceledListSlice, int)",
    "20": "void registerAppUsageObserver(int, [Ljava.lang.String;, long, android.app.PendingIntent, java.lang.String)",
    "21": "void unregisterAppUsageObserver(int, java.lang.String)",
    "22": "void registerUsageSessionObserver(int, [Ljava.lang.String;, long, long, android.app.PendingIntent, android.app.PendingIntent, java.lang.String)",
    "23": "void unregisterUsageSessionObserver(int, java.lang.String)",
    "24": "void registerAppUsageLimitObserver(int, [Ljava.lang.String;, long, long, android.app.PendingIntent, java.lang.String)",
    "25": "void unregisterAppUsageLimitObserver(int, java.lang.String)",
    "26": "void reportUsageStart(android.os.IBinder, java.lang.String, java.lang.String)",
    "27": "void reportPastUsageStart(android.os.IBinder, java.lang.String, long, java.lang.String)",
    "28": "void reportUsageStop(android.os.IBinder, java.lang.String, java.lang.String)",
    "29": "void reportUserInteraction(java.lang.String, int)",
    "30": "int getUsageSource()",
    "31": "void forceUsageSourceSettingRead()",
    "32": "long getLastTimeAnyComponentUsed(java.lang.String, java.lang.String)",
    "33": "android.app.usage.BroadcastResponseStatsList queryBroadcastResponseStats(java.lang.String, long, java.lang.String, int)",
    "34": "void clearBroadcastResponseStats(java.lang.String, long, java.lang.String, int)",
    "35": "void clearBroadcastEvents(java.lang.String, int)",
    "36": "java.lang.String getAppStandbyConstant(java.lang.String)"
  },
  "android.media.musicrecognition.IMusicRecognitionManager": {
    "1": "void beginRecognition(android.media.musicrecognition.RecognitionRequest, android.os.IBinder)"
  },
  "android.os.IPowerManager": {
    "1": "void acquireWakeLock(android.os.IBinder, int, java.lang.String, java.lang.String, android.os.WorkSource, java.lang.String, int, android.os.IWakeLockCallback)",
    "2": "void acquireWakeLockWithUid(android.os.IBinder, int, java.lang.String, java.lang.String, int, int, android.os.IWakeLockCallback)",
    "3": "void releaseWakeLock(android.os.IBinder, int)",
    "4": "void updateWakeLockUids(android.os.IBinder, [I)",
    "5": "void setPowerBoost(int, int)",
    "6": "void setPowerMode(int, boolean)",
    "7": "boolean setPowerModeChecked(int, boolean)",
    "8": "void updateWakeLockWorkSource(android.os.IBinder, android.os.WorkSource, java.lang.String)",
    "9": "void updateWakeLockCallback(android.os.IBinder, android.os.IWakeLockCallback)",
    "10": "boolean isWakeLockLevelSupported(int)",
    "11": "void userActivity(int, long, int, int)",
    "12": "void wakeUp(long, int, java.lang.String, java.lang.String)",
    "13": "void goToSleep(long, int, int)",
    "14": "void goToSleepWithDisplayId(int, long, int, int)",
    "15": "void nap(long)",
    "16": "float getBrightnessConstraint(int)",
    "17": "boolean isInteractive()",
    "18": "boolean isDisplayInteractive(int)",
    "19": "boolean areAutoPowerSaveModesEnabled()",
    "20": "boolean isPowerSaveMode()",
    "21": "android.os.PowerSaveState getPowerSaveState(int)",
    "22": "boolean setPowerSaveModeEnabled(boolean)",
    "23": "android.os.BatterySaverPolicyConfig getFullPowerSavePolicy()",
    "24": "boolean setFullPowerSavePolicy(android.os.BatterySaverPolicyConfig)",
    "25": "boolean setDynamicPowerSaveHint(boolean, int)",
    "26": "boolean setAdaptivePowerSavePolicy(android.os.BatterySaverPolicyConfig)",
    "27": "boolean setAdaptivePowerSaveEnabled(boolean)",
    "28": "int getPowerSaveModeTrigger()",
    "29": "void setBatteryDischargePrediction(android.os.ParcelDuration, boolean)",
    "30": "android.os.ParcelDuration getBatteryDischargePrediction()",
    "31": "boolean isBatteryDischargePredictionPersonalized()",
    "32": "boolean isDeviceIdleMode()",
    "33": "boolean isLightDeviceIdleMode()",
    "34": "boolean isLowPowerStandbySupported()",
    "35": "boolean isLowPowerStandbyEnabled()",
    "36": "void setLowPowerStandbyEnabled(boolean)",
    "37": "void setLowPowerStandbyActiveDuringMaintenance(boolean)",
    "38": "void forceLowPowerStandbyActive(boolean)",
    "39": "void setLowPowerStandbyPolicy(android.os.IPowerManager$LowPowerStandbyPolicy)",
    "40": "android.os.IPowerManager$LowPowerStandbyPolicy getLowPowerStandbyPolicy()",
    "41": "boolean isExemptFromLowPowerStandby()",
    "42": "boolean isReasonAllowedInLowPowerStandby(int)",
    "43": "boolean isFeatureAllowedInLowPowerStandby(java.lang.String)",
    "44": "void acquireLowPowerStandbyPorts(android.os.IBinder, java.util.List)",
    "45": "void releaseLowPowerStandbyPorts(android.os.IBinder)",
    "46": "java.util.List getActiveLowPowerStandbyPorts()",
    "47": "void reboot(boolean, java.lang.String, boolean)",
    "48": "void rebootSafeMode(boolean, boolean)",
    "49": "void shutdown(boolean, java.lang.String, boolean)",
    "50": "void crash(java.lang.String)",
    "51": "int getLastShutdownReason()",
    "52": "int getLastSleepReason()",
    "53": "void setStayOnSetting(int)",
    "54": "void boostScreenBrightness(long)",
    "55": "void acquireWakeLockAsync(android.os.IBinder, int, java.lang.String, java.lang.String, android.os.WorkSource, java.lang.String)",
    "56": "void releaseWakeLockAsync(android.os.IBinder, int)",
    "57": "void updateWakeLockUidsAsync(android.os.IBinder, [I)",
    "58": "boolean isScreenBrightnessBoosted()",
    "59": "void setAttentionLight(boolean, int)",
    "60": "void setDozeAfterScreenOff(boolean)",
    "61": "boolean isAmbientDisplayAvailable()",
    "62": "void suppressAmbientDisplay(java.lang.String, boolean)",
    "63": "boolean isAmbientDisplaySuppressedForToken(java.lang.String)",
    "64": "boolean isAmbientDisplaySuppressed()",
    "65": "boolean isAmbientDisplaySuppressedForTokenByApp(java.lang.String, int)",
    "66": "boolean forceSuspend()"
  },
  "android.media.midi.IMidiManager": {
    "1": "[Landroid.media.midi.MidiDeviceInfo; getDevices()",
    "2": "[Landroid.media.midi.MidiDeviceInfo; getDevicesForTransport(int)",
    "3": "void registerListener(android.os.IBinder, android.media.midi.IMidiDeviceListener)",
    "4": "void unregisterListener(android.os.IBinder, android.media.midi.IMidiDeviceListener)",
    "5": "void openDevice(android.os.IBinder, android.media.midi.MidiDeviceInfo, android.media.midi.IMidiDeviceOpenCallback)",
    "6": "void openBluetoothDevice(android.os.IBinder, android.bluetooth.BluetoothDevice, android.media.midi.IMidiDeviceOpenCallback)",
    "7": "void closeDevice(android.os.IBinder, android.os.IBinder)",
    "8": "android.media.midi.MidiDeviceInfo registerDeviceServer(android.media.midi.IMidiDeviceServer, int, int, [Ljava.lang.String;, [Ljava.lang.String;, android.os.Bundle, int, int)",
    "9": "void unregisterDeviceServer(android.media.midi.IMidiDeviceServer)",
    "10": "android.media.midi.MidiDeviceInfo getServiceDeviceInfo(java.lang.String, java.lang.String)",
    "11": "android.media.midi.MidiDeviceStatus getDeviceStatus(android.media.midi.MidiDeviceInfo)",
    "12": "void setDeviceStatus(android.media.midi.IMidiDeviceServer, android.media.midi.MidiDeviceStatus)",
    "13": "void updateTotalBytes(android.media.midi.IMidiDeviceServer, int, int)"
  },
  "android.app.tare.IEconomyManager": {
    "1": "int getEnabledMode()"
  },
  "android.net.IIpConnectivityMetrics": {
    "1": "int logEvent(android.net.ConnectivityMetricsEvent)",
    "2": "void logDefaultNetworkValidity(boolean)",
    "3": "void logDefaultNetworkEvent(android.net.Network, int, boolean, android.net.LinkProperties, android.net.NetworkCapabilities, android.net.Network, int, android.net.LinkProperties, android.net.NetworkCapabilities)",
    "4": "boolean addNetdEventCallback(int, android.net.INetdEventCallback)",
    "5": "boolean removeNetdEventCallback(int)"
  },
  "android.os.IStatsd": {
    "1": "void systemRunning()",
    "2": "void bootCompleted()",
    "3": "void statsCompanionReady()",
    "4": "void informAnomalyAlarmFired()",
    "5": "void informPollAlarmFired()",
    "6": "void informAlarmForSubscriberTriggeringFired()",
    "7": "void informDeviceShutdown()",
    "8": "void informAllUidData(android.os.ParcelFileDescriptor)",
    "9": "void informOnePackage(java.lang.String, int, long, java.lang.String, java.lang.String, [B)",
    "10": "void informOnePackageRemoved(java.lang.String, int)",
    "11": "[B getData(long, int)",
    "12": "[B getMetadata()",
    "13": "void addConfiguration(long, [B, int)",
    "14": "void setDataFetchOperation(long, android.os.IPendingIntentRef, int)",
    "15": "void removeDataFetchOperation(long, int)",
    "16": "[J setActiveConfigsChangedOperation(android.os.IPendingIntentRef, int)",
    "17": "void removeActiveConfigsChangedOperation(int)",
    "18": "void removeConfiguration(long, int)",
    "19": "void setBroadcastSubscriber(long, long, android.os.IPendingIntentRef, int)",
    "20": "void unsetBroadcastSubscriber(long, long, int)",
    "21": "void allPullersFromBootRegistered()",
    "22": "void registerPullAtomCallback(int, int, long, long, [I, android.os.IPullAtomCallback)",
    "23": "void registerNativePullAtomCallback(int, long, long, [I, android.os.IPullAtomCallback)",
    "24": "void unregisterPullAtomCallback(int, int)",
    "25": "void unregisterNativePullAtomCallback(int)",
    "26": "[J getRegisteredExperimentIds()",
    "27": "void updateProperties([Landroid.util.PropertyParcel;)",
    "28": "void querySql(java.lang.String, int, [B, android.os.IStatsQueryCallback, long, java.lang.String, int)",
    "29": "[J setRestrictedMetricsChangedOperation(long, java.lang.String, android.os.IPendingIntentRef, int)",
    "30": "void removeRestrictedMetricsChangedOperation(long, java.lang.String, int)",
    "31": "void addSubscription([B, android.os.IStatsSubscriptionCallback)",
    "32": "void removeSubscription(android.os.IStatsSubscriptionCallback)",
    "33": "void flushSubscription(android.os.IStatsSubscriptionCallback)"
  },
  "android.os.IRecoverySystem": {
    "1": "boolean allocateSpaceForUpdate(java.lang.String)",
    "2": "boolean uncrypt(java.lang.String, android.os.IRecoverySystemProgressListener)",
    "3": "boolean setupBcb(java.lang.String)",
    "4": "boolean clearBcb()",
    "5": "void rebootRecoveryWithCommand(java.lang.String)",
    "6": "boolean requestLskf(java.lang.String, android.content.IntentSender)",
    "7": "boolean clearLskf(java.lang.String)",
    "8": "boolean isLskfCaptured(java.lang.String)",
    "9": "int rebootWithLskfAssumeSlotSwitch(java.lang.String, java.lang.String)",
    "10": "int rebootWithLskf(java.lang.String, java.lang.String, boolean)"
  },
  "android.app.ILocaleManager": {
    "1": "void setApplicationLocales(java.lang.String, int, android.os.LocaleList, boolean)",
    "2": "android.os.LocaleList getApplicationLocales(java.lang.String, int)",
    "3": "android.os.LocaleList getSystemLocales()",
    "4": "void setOverrideLocaleConfig(java.lang.String, int, android.app.LocaleConfig)",
    "5": "android.app.LocaleConfig getOverrideLocaleConfig(java.lang.String, int)"
  },
  "android.os.IUserManager": {
    "1": "int getCredentialOwnerProfile(int)",
    "2": "int getProfileParentId(int)",
    "3": "android.content.pm.UserInfo createUserWithThrow(java.lang.String, java.lang.String, int)",
    "4": "android.content.pm.UserInfo preCreateUserWithThrow(java.lang.String)",
    "5": "android.content.pm.UserInfo createProfileForUserWithThrow(java.lang.String, java.lang.String, int, int, [Ljava.lang.String;)",
    "6": "android.content.pm.UserInfo createRestrictedProfileWithThrow(java.lang.String, int)",
    "7": "[Ljava.lang.String; getPreInstallableSystemPackages(java.lang.String)",
    "8": "void setUserEnabled(int)",
    "9": "void setUserAdmin(int)",
    "10": "void revokeUserAdmin(int)",
    "11": "void evictCredentialEncryptionKey(int)",
    "12": "boolean removeUser(int)",
    "13": "boolean removeUserEvenWhenDisallowed(int)",
    "14": "void setUserName(int, java.lang.String)",
    "15": "void setUserIcon(int, android.graphics.Bitmap)",
    "16": "android.os.ParcelFileDescriptor getUserIcon(int)",
    "17": "android.content.pm.UserInfo getPrimaryUser()",
    "18": "int getMainUserId()",
    "19": "int getPreviousFullUserToEnterForeground()",
    "20": "java.util.List getUsers(boolean, boolean, boolean)",
    "21": "java.util.List getProfiles(int, boolean)",
    "22": "[I getProfileIds(int, boolean)",
    "23": "boolean isUserTypeEnabled(java.lang.String)",
    "24": "boolean canAddMoreUsersOfType(java.lang.String)",
    "25": "int getRemainingCreatableUserCount(java.lang.String)",
    "26": "int getRemainingCreatableProfileCount(java.lang.String, int)",
    "27": "boolean canAddMoreProfilesToUser(java.lang.String, int, boolean)",
    "28": "boolean canAddMoreManagedProfiles(int, boolean)",
    "29": "android.content.pm.UserInfo getProfileParent(int)",
    "30": "boolean isSameProfileGroup(int, int)",
    "31": "boolean isHeadlessSystemUserMode()",
    "32": "boolean isUserOfType(int, java.lang.String)",
    "33": "android.content.pm.UserInfo getUserInfo(int)",
    "34": "android.content.pm.UserProperties getUserPropertiesCopy(int)",
    "35": "java.lang.String getUserAccount(int)",
    "36": "void setUserAccount(int, java.lang.String)",
    "37": "long getUserCreationTime(int)",
    "38": "int getUserSwitchability(int)",
    "39": "boolean isUserSwitcherEnabled(boolean, int)",
    "40": "boolean isRestricted(int)",
    "41": "boolean canHaveRestrictedProfile(int)",
    "42": "int getUserSerialNumber(int)",
    "43": "int getUserHandle(int)",
    "44": "int getUserRestrictionSource(java.lang.String, int)",
    "45": "java.util.List getUserRestrictionSources(java.lang.String, int)",
    "46": "android.os.Bundle getUserRestrictions(int)",
    "47": "boolean hasBaseUserRestriction(java.lang.String, int)",
    "48": "boolean hasUserRestriction(java.lang.String, int)",
    "49": "boolean hasUserRestrictionOnAnyUser(java.lang.String)",
    "50": "boolean isSettingRestrictedForUser(java.lang.String, int, java.lang.String, int)",
    "51": "void addUserRestrictionsListener(android.os.IUserRestrictionsListener)",
    "52": "void setUserRestriction(java.lang.String, boolean, int)",
    "53": "void setApplicationRestrictions(java.lang.String, android.os.Bundle, int)",
    "54": "android.os.Bundle getApplicationRestrictions(java.lang.String)",
    "55": "android.os.Bundle getApplicationRestrictionsForUser(java.lang.String, int)",
    "56": "void setDefaultGuestRestrictions(android.os.Bundle)",
    "57": "android.os.Bundle getDefaultGuestRestrictions()",
    "58": "int removeUserWhenPossible(int, boolean)",
    "59": "boolean markGuestForDeletion(int)",
    "60": "java.util.List getGuestUsers()",
    "61": "boolean isQuietModeEnabled(int)",
    "62": "android.os.UserHandle createUserWithAttributes(java.lang.String, java.lang.String, int, android.graphics.Bitmap, java.lang.String, java.lang.String, android.os.PersistableBundle)",
    "63": "void setSeedAccountData(int, java.lang.String, java.lang.String, android.os.PersistableBundle, boolean)",
    "64": "java.lang.String getSeedAccountName(int)",
    "65": "java.lang.String getSeedAccountType(int)",
    "66": "android.os.PersistableBundle getSeedAccountOptions(int)",
    "67": "void clearSeedAccountData(int)",
    "68": "boolean someUserHasSeedAccount(java.lang.String, java.lang.String)",
    "69": "boolean someUserHasAccount(java.lang.String, java.lang.String)",
    "70": "java.lang.String getProfileType(int)",
    "71": "boolean isDemoUser(int)",
    "72": "boolean isAdminUser(int)",
    "73": "boolean isPreCreated(int)",
    "74": "android.content.pm.UserInfo createProfileForUserEvenWhenDisallowedWithThrow(java.lang.String, java.lang.String, int, int, [Ljava.lang.String;)",
    "75": "boolean isUserUnlockingOrUnlocked(int)",
    "76": "int getUserIconBadgeResId(int)",
    "77": "int getUserBadgeResId(int)",
    "78": "int getUserBadgeNoBackgroundResId(int)",
    "79": "int getUserBadgeLabelResId(int)",
    "80": "int getUserBadgeColorResId(int)",
    "81": "int getUserBadgeDarkColorResId(int)",
    "82": "boolean hasBadge(int)",
    "83": "boolean isUserUnlocked(int)",
    "84": "boolean isUserRunning(int)",
    "85": "boolean isUserForeground(int)",
    "86": "boolean isUserVisible(int)",
    "87": "[I getVisibleUsers()",
    "88": "int getMainDisplayIdAssignedToUser()",
    "89": "boolean isUserNameSet(int)",
    "90": "boolean hasRestrictedProfiles(int)",
    "91": "boolean requestQuietModeEnabled(java.lang.String, boolean, int, android.content.IntentSender, int)",
    "92": "java.lang.String getUserName()",
    "93": "long getUserStartRealtime()",
    "94": "long getUserUnlockRealtime()",
    "95": "boolean setUserEphemeral(int, boolean)",
    "96": "void setBootUser(int)",
    "97": "int getBootUser()"
  },
  "android.os.IStatsCompanionService": {
    "1": "void statsdReady()",
    "2": "void setAnomalyAlarm(long)",
    "3": "void cancelAnomalyAlarm()",
    "4": "void setPullingAlarm(long)",
    "5": "void cancelPullingAlarm()",
    "6": "void setAlarmForSubscriberTriggering(long)",
    "7": "void cancelAlarmForSubscriberTriggering()",
    "8": "boolean checkPermission(java.lang.String, int, int)"
  },
  "android.content.integrity.IAppIntegrityManager": {
    "1": "void updateRuleSet(java.lang.String, android.content.pm.ParceledListSlice, android.content.IntentSender)",
    "2": "java.lang.String getCurrentRuleSetVersion()",
    "3": "java.lang.String getCurrentRuleSetProvider()",
    "4": "android.content.pm.ParceledListSlice getCurrentRules()",
    "5": "java.util.List getWhitelistedRuleProviders()"
  },
  "android.app.ISearchManager": {
    "1": "android.app.SearchableInfo getSearchableInfo(android.content.ComponentName)",
    "2": "java.util.List getSearchablesInGlobalSearch()",
    "3": "java.util.List getGlobalSearchActivities()",
    "4": "android.content.ComponentName getGlobalSearchActivity()",
    "5": "android.content.ComponentName getWebSearchActivity()",
    "6": "void launchAssist(int, android.os.Bundle)"
  },
  "android.app.wallpapereffectsgeneration.IWallpaperEffectsGenerationManager": {
    "1": "void generateCinematicEffect(android.app.wallpapereffectsgeneration.CinematicEffectRequest, android.app.wallpapereffectsgeneration.ICinematicEffectListener)",
    "2": "void returnCinematicEffectResponse(android.app.wallpapereffectsgeneration.CinematicEffectResponse)"
  },
  "android.app.IWallpaperManager": {
    "1": "android.os.ParcelFileDescriptor setWallpaper(java.lang.String, java.lang.String, android.graphics.Rect, boolean, android.os.Bundle, int, android.app.IWallpaperManagerCallback, int)",
    "2": "void setWallpaperComponentChecked(android.content.ComponentName, java.lang.String, int, int)",
    "3": "void setWallpaperComponent(android.content.ComponentName)",
    "4": "android.os.ParcelFileDescriptor getWallpaper(java.lang.String, android.app.IWallpaperManagerCallback, int, android.os.Bundle, int)",
    "5": "android.os.ParcelFileDescriptor getWallpaperWithFeature(java.lang.String, java.lang.String, android.app.IWallpaperManagerCallback, int, android.os.Bundle, int, boolean)",
    "6": "int getWallpaperIdForUser(int, int)",
    "7": "android.app.WallpaperInfo getWallpaperInfo(int)",
    "8": "android.app.WallpaperInfo getWallpaperInfoWithFlags(int, int)",
    "9": "android.os.ParcelFileDescriptor getWallpaperInfoFile(int)",
    "10": "void clearWallpaper(java.lang.String, int, int)",
    "11": "boolean hasNamedWallpaper(java.lang.String)",
    "12": "void setDimensionHints(int, int, java.lang.String, int)",
    "13": "int getWidthHint(int)",
    "14": "int getHeightHint(int)",
    "15": "void setDisplayPadding(android.graphics.Rect, java.lang.String, int)",
    "16": "java.lang.String getName()",
    "17": "void settingsRestored()",
    "18": "boolean isWallpaperSupported(java.lang.String)",
    "19": "boolean isSetWallpaperAllowed(java.lang.String)",
    "20": "boolean isWallpaperBackupEligible(int, int)",
    "21": "boolean setLockWallpaperCallback(android.app.IWallpaperManagerCallback)",
    "22": "android.app.WallpaperColors getWallpaperColors(int, int, int)",
    "23": "void removeOnLocalColorsChangedListener(android.app.ILocalWallpaperColorConsumer, java.util.List, int, int, int)",
    "24": "void addOnLocalColorsChangedListener(android.app.ILocalWallpaperColorConsumer, java.util.List, int, int, int)",
    "25": "void registerWallpaperColorsCallback(android.app.IWallpaperManagerCallback, int, int)",
    "26": "void unregisterWallpaperColorsCallback(android.app.IWallpaperManagerCallback, int, int)",
    "27": "void setInAmbientMode(boolean, long)",
    "28": "void notifyWakingUp(int, int, android.os.Bundle)",
    "29": "void notifyGoingToSleep(int, int, android.os.Bundle)",
    "30": "void setWallpaperDimAmount(float)",
    "31": "float getWallpaperDimAmount()",
    "32": "boolean lockScreenWallpaperExists()",
    "33": "boolean isStaticWallpaper(int)",
    "34": "boolean isLockscreenLiveWallpaperEnabled()",
    "35": "boolean isMultiCropEnabled()"
  },
  "android.location.ILocationManager": {
    "1": "android.location.Location getLastLocation(java.lang.String, android.location.LastLocationRequest, java.lang.String, java.lang.String)",
    "2": "android.os.ICancellationSignal getCurrentLocation(java.lang.String, android.location.LocationRequest, android.location.ILocationCallback, java.lang.String, java.lang.String, java.lang.String)",
    "3": "void registerLocationListener(java.lang.String, android.location.LocationRequest, android.location.ILocationListener, java.lang.String, java.lang.String, java.lang.String)",
    "4": "void unregisterLocationListener(android.location.ILocationListener)",
    "5": "void registerLocationPendingIntent(java.lang.String, android.location.LocationRequest, android.app.PendingIntent, java.lang.String, java.lang.String)",
    "6": "void unregisterLocationPendingIntent(android.app.PendingIntent)",
    "7": "void injectLocation(android.location.Location)",
    "8": "void requestListenerFlush(java.lang.String, android.location.ILocationListener, int)",
    "9": "void requestPendingIntentFlush(java.lang.String, android.app.PendingIntent, int)",
    "10": "void requestGeofence(android.location.Geofence, android.app.PendingIntent, java.lang.String, java.lang.String)",
    "11": "void removeGeofence(android.app.PendingIntent)",
    "12": "boolean geocoderIsPresent()",
    "13": "void getFromLocation(double, double, int, android.location.GeocoderParams, android.location.IGeocodeListener)",
    "14": "void getFromLocationName(java.lang.String, double, double, double, double, int, android.location.GeocoderParams, android.location.IGeocodeListener)",
    "15": "android.location.GnssCapabilities getGnssCapabilities()",
    "16": "int getGnssYearOfHardware()",
    "17": "java.lang.String getGnssHardwareModelName()",
    "18": "java.util.List getGnssAntennaInfos()",
    "19": "void registerGnssStatusCallback(android.location.IGnssStatusListener, java.lang.String, java.lang.String, java.lang.String)",
    "20": "void unregisterGnssStatusCallback(android.location.IGnssStatusListener)",
    "21": "void registerGnssNmeaCallback(android.location.IGnssNmeaListener, java.lang.String, java.lang.String, java.lang.String)",
    "22": "void unregisterGnssNmeaCallback(android.location.IGnssNmeaListener)",
    "23": "void addGnssMeasurementsListener(android.location.GnssMeasurementRequest, android.location.IGnssMeasurementsListener, java.lang.String, java.lang.String, java.lang.String)",
    "24": "void removeGnssMeasurementsListener(android.location.IGnssMeasurementsListener)",
    "25": "void injectGnssMeasurementCorrections(android.location.GnssMeasurementCorrections)",
    "26": "void addGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener, java.lang.String, java.lang.String, java.lang.String)",
    "27": "void removeGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener)",
    "28": "void addGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener, java.lang.String, java.lang.String, java.lang.String)",
    "29": "void removeGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener)",
    "30": "void addProviderRequestListener(android.location.provider.IProviderRequestListener)",
    "31": "void removeProviderRequestListener(android.location.provider.IProviderRequestListener)",
    "32": "int getGnssBatchSize()",
    "33": "void startGnssBatch(long, android.location.ILocationListener, java.lang.String, java.lang.String, java.lang.String)",
    "34": "void flushGnssBatch()",
    "35": "void stopGnssBatch()",
    "36": "boolean hasProvider(java.lang.String)",
    "37": "java.util.List getAllProviders()",
    "38": "java.util.List getProviders(android.location.Criteria, boolean)",
    "39": "java.lang.String getBestProvider(android.location.Criteria, boolean)",
    "40": "android.location.provider.ProviderProperties getProviderProperties(java.lang.String)",
    "41": "boolean isProviderPackage(java.lang.String, java.lang.String, java.lang.String)",
    "42": "java.util.List getProviderPackages(java.lang.String)",
    "43": "void setExtraLocationControllerPackage(java.lang.String)",
    "44": "java.lang.String getExtraLocationControllerPackage()",
    "45": "void setExtraLocationControllerPackageEnabled(boolean)",
    "46": "boolean isExtraLocationControllerPackageEnabled()",
    "47": "boolean isProviderEnabledForUser(java.lang.String, int)",
    "48": "boolean isLocationEnabledForUser(int)",
    "49": "void setLocationEnabledForUser(boolean, int)",
    "50": "boolean isAdasGnssLocationEnabledForUser(int)",
    "51": "void setAdasGnssLocationEnabledForUser(boolean, int)",
    "52": "boolean isAutomotiveGnssSuspended()",
    "53": "void setAutomotiveGnssSuspended(boolean)",
    "54": "void addTestProvider(java.lang.String, android.location.provider.ProviderProperties, java.util.List, java.lang.String, java.lang.String)",
    "55": "void removeTestProvider(java.lang.String, java.lang.String, java.lang.String)",
    "56": "void setTestProviderLocation(java.lang.String, android.location.Location, java.lang.String, java.lang.String)",
    "57": "void setTestProviderEnabled(java.lang.String, boolean, java.lang.String, java.lang.String)",
    "58": "android.location.LocationTime getGnssTimeMillis()",
    "59": "void sendExtraCommand(java.lang.String, java.lang.String, android.os.Bundle)",
    "60": "[Ljava.lang.String; getBackgroundThrottlingWhitelist()",
    "61": "android.os.PackageTagsList getIgnoreSettingsAllowlist()",
    "62": "android.os.PackageTagsList getAdasAllowlist()"
  },
  "android.media.metrics.IMediaMetricsManager": {
    "1": "void reportPlaybackMetrics(java.lang.String, android.media.metrics.PlaybackMetrics, int)",
    "2": "java.lang.String getPlaybackSessionId(int)",
    "3": "java.lang.String getRecordingSessionId(int)",
    "4": "void reportNetworkEvent(java.lang.String, android.media.metrics.NetworkEvent, int)",
    "5": "void reportPlaybackErrorEvent(java.lang.String, android.media.metrics.PlaybackErrorEvent, int)",
    "6": "void reportPlaybackStateEvent(java.lang.String, android.media.metrics.PlaybackStateEvent, int)",
    "7": "void reportTrackChangeEvent(java.lang.String, android.media.metrics.TrackChangeEvent, int)",
    "8": "java.lang.String getTranscodingSessionId(int)",
    "9": "java.lang.String getEditingSessionId(int)",
    "10": "java.lang.String getBundleSessionId(int)",
    "11": "void reportBundleMetrics(java.lang.String, android.os.PersistableBundle, int)",
    "12": "void releaseSessionId(java.lang.String, int)"
  },
  "android.content.IClipboard": {
    "1": "void setPrimaryClip(android.content.ClipData, java.lang.String, java.lang.String, int, int)",
    "2": "void setPrimaryClipAsPackage(android.content.ClipData, java.lang.String, java.lang.String, int, int, java.lang.String)",
    "3": "void clearPrimaryClip(java.lang.String, java.lang.String, int, int)",
    "4": "android.content.ClipData getPrimaryClip(java.lang.String, java.lang.String, int, int)",
    "5": "android.content.ClipDescription getPrimaryClipDescription(java.lang.String, java.lang.String, int, int)",
    "6": "boolean hasPrimaryClip(java.lang.String, java.lang.String, int, int)",
    "7": "void addPrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener, java.lang.String, java.lang.String, int, int)",
    "8": "void removePrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener, java.lang.String, java.lang.String, int, int)",
    "9": "boolean hasClipboardText(java.lang.String, java.lang.String, int, int)",
    "10": "java.lang.String getPrimaryClipSource(java.lang.String, java.lang.String, int, int)",
    "11": "boolean areClipboardAccessNotificationsEnabledForUser(int)",
    "12": "void setClipboardAccessNotificationsEnabledForUser(boolean, int)"
  },
  "android.app.smartspace.ISmartspaceManager": {
    "1": "void createSmartspaceSession(android.app.smartspace.SmartspaceConfig, android.app.smartspace.SmartspaceSessionId, android.os.IBinder)",
    "2": "void notifySmartspaceEvent(android.app.smartspace.SmartspaceSessionId, android.app.smartspace.SmartspaceTargetEvent)",
    "3": "void requestSmartspaceUpdate(android.app.smartspace.SmartspaceSessionId)",
    "4": "void registerSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId, android.app.smartspace.ISmartspaceCallback)",
    "5": "void unregisterSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId, android.app.smartspace.ISmartspaceCallback)",
    "6": "void destroySmartspaceSession(android.app.smartspace.SmartspaceSessionId)"
  },
  "com.android.internal.net.INetworkWatchlistManager": {
    "1": "boolean startWatchlistLogging()",
    "2": "boolean stopWatchlistLogging()",
    "3": "void reloadWatchlist()",
    "4": "void reportWatchlistIfNecessary()",
    "5": "[B getWatchlistConfigHash()"
  },
  "android.content.pm.ICrossProfileApps": {
    "1": "void startActivityAsUser(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.ComponentName, int, boolean, android.os.IBinder, android.os.Bundle)",
    "2": "void startActivityAsUserByIntent(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, int, android.os.IBinder, android.os.Bundle)",
    "3": "java.util.List getTargetUserProfiles(java.lang.String)",
    "4": "boolean canInteractAcrossProfiles(java.lang.String)",
    "5": "boolean canRequestInteractAcrossProfiles(java.lang.String)",
    "6": "void setInteractAcrossProfilesAppOp(int, java.lang.String, int)",
    "7": "boolean canConfigureInteractAcrossProfiles(int, java.lang.String)",
    "8": "boolean canUserAttemptToConfigureInteractAcrossProfiles(int, java.lang.String)",
    "9": "void resetInteractAcrossProfilesAppOps(int, java.util.List)",
    "10": "void clearInteractAcrossProfilesAppOps(int)"
  },
  "android.content.IRestrictionsManager": {
    "1": "android.os.Bundle getApplicationRestrictions(java.lang.String)",
    "2": "java.util.List getApplicationRestrictionsPerAdminForUser(int, java.lang.String)",
    "3": "boolean hasRestrictionsProvider()",
    "4": "void requestPermission(java.lang.String, java.lang.String, java.lang.String, android.os.PersistableBundle)",
    "5": "void notifyPermissionResponse(java.lang.String, android.os.PersistableBundle)",
    "6": "android.content.Intent createLocalApprovalIntent()"
  },
  "android.location.ICountryDetector": {
    "1": "android.location.Country detectCountry()",
    "2": "void addCountryListener(android.location.ICountryListener)",
    "3": "void removeCountryListener(android.location.ICountryListener)"
  },
  "android.nearby.INearbyManager": {
    "1": "int registerScanListener(android.nearby.ScanRequest, android.nearby.IScanListener, java.lang.String, java.lang.String)",
    "2": "void unregisterScanListener(android.nearby.IScanListener, java.lang.String, java.lang.String)",
    "3": "void startBroadcast(android.nearby.BroadcastRequestParcelable, android.nearby.IBroadcastListener, java.lang.String, java.lang.String)",
    "4": "void stopBroadcast(android.nearby.IBroadcastListener, java.lang.String, java.lang.String)",
    "5": "void queryOffloadCapability(android.nearby.aidl.IOffloadCallback)"
  },
  "android.os.IUpdateLock": {
    "1": "void acquireUpdateLock(android.os.IBinder, java.lang.String)",
    "2": "void releaseUpdateLock(android.os.IBinder)"
  },
  "android.app.adservices.IAdServicesManager": {
    "1": "android.app.adservices.consent.ConsentParcel getConsent(int)",
    "2": "void setConsent(android.app.adservices.consent.ConsentParcel)",
    "3": "void recordAdServicesDeletionOccurred(int)",
    "4": "boolean needsToHandleRollbackReconciliation(int)",
    "5": "void recordNotificationDisplayed()",
    "6": "boolean wasNotificationDisplayed()",
    "7": "void recordGaUxNotificationDisplayed()",
    "8": "boolean wasGaUxNotificationDisplayed()",
    "9": "void recordUserManualInteractionWithConsent(int)",
    "10": "int getUserManualInteractionWithConsent()",
    "11": "void recordBlockedTopic(java.util.List)",
    "12": "void removeBlockedTopic(android.app.adservices.topics.TopicParcel)",
    "13": "java.util.List retrieveAllBlockedTopics()",
    "14": "void clearAllBlockedTopics()",
    "15": "void recordDefaultConsent(boolean)",
    "16": "void recordTopicsDefaultConsent(boolean)",
    "17": "void recordFledgeDefaultConsent(boolean)",
    "18": "void recordMeasurementDefaultConsent(boolean)",
    "19": "void recordDefaultAdIdState(boolean)",
    "20": "boolean getDefaultConsent()",
    "21": "boolean getTopicsDefaultConsent()",
    "22": "boolean getFledgeDefaultConsent()",
    "23": "boolean getMeasurementDefaultConsent()",
    "24": "boolean getDefaultAdIdState()",
    "25": "java.lang.String getCurrentPrivacySandboxFeature()",
    "26": "void setCurrentPrivacySandboxFeature(java.lang.String)",
    "27": "java.util.List getKnownAppsWithConsent(java.util.List)",
    "28": "java.util.List getAppsWithRevokedConsent(java.util.List)",
    "29": "void setConsentForApp(java.lang.String, int, boolean)",
    "30": "void clearKnownAppsWithConsent()",
    "31": "void clearAllAppConsentData()",
    "32": "boolean isConsentRevokedForApp(java.lang.String, int)",
    "33": "boolean setConsentForAppIfNew(java.lang.String, int, boolean)",
    "34": "void clearConsentForUninstalledApp(java.lang.String, int)",
    "35": "boolean isAdIdEnabled()",
    "36": "void setAdIdEnabled(boolean)",
    "37": "boolean isU18Account()",
    "38": "void setU18Account(boolean)",
    "39": "boolean isEntryPointEnabled()",
    "40": "void setEntryPointEnabled(boolean)",
    "41": "boolean isAdultAccount()",
    "42": "void setAdultAccount(boolean)",
    "43": "boolean wasU18NotificationDisplayed()",
    "44": "void setU18NotificationDisplayed(boolean)"
  },
  "android.app.INotificationManager": {
    "1": "void cancelAllNotifications(java.lang.String, int)",
    "2": "void clearData(java.lang.String, int, boolean)",
    "3": "void enqueueTextToast(java.lang.String, android.os.IBinder, java.lang.CharSequence, int, boolean, int, android.app.ITransientNotificationCallback)",
    "4": "void enqueueToast(java.lang.String, android.os.IBinder, android.app.ITransientNotification, int, boolean, int)",
    "5": "void cancelToast(java.lang.String, android.os.IBinder)",
    "6": "void finishToken(java.lang.String, android.os.IBinder)",
    "7": "void enqueueNotificationWithTag(java.lang.String, java.lang.String, java.lang.String, int, android.app.Notification, int)",
    "8": "void cancelNotificationWithTag(java.lang.String, java.lang.String, java.lang.String, int, int)",
    "9": "boolean isInCall(java.lang.String, int)",
    "10": "void setShowBadge(java.lang.String, int, boolean)",
    "11": "boolean canShowBadge(java.lang.String, int)",
    "12": "boolean hasSentValidMsg(java.lang.String, int)",
    "13": "boolean isInInvalidMsgState(java.lang.String, int)",
    "14": "boolean hasUserDemotedInvalidMsgApp(java.lang.String, int)",
    "15": "void setInvalidMsgAppDemoted(java.lang.String, int, boolean)",
    "16": "boolean hasSentValidBubble(java.lang.String, int)",
    "17": "void setNotificationsEnabledForPackage(java.lang.String, int, boolean)",
    "18": "void setNotificationsEnabledWithImportanceLockForPackage(java.lang.String, int, boolean)",
    "19": "boolean areNotificationsEnabledForPackage(java.lang.String, int)",
    "20": "boolean areNotificationsEnabled(java.lang.String)",
    "21": "int getPackageImportance(java.lang.String)",
    "22": "boolean isImportanceLocked(java.lang.String, int)",
    "23": "java.util.List getAllowedAssistantAdjustments(java.lang.String)",
    "24": "boolean shouldHideSilentStatusIcons(java.lang.String)",
    "25": "void setHideSilentStatusIcons(boolean)",
    "26": "void setBubblesAllowed(java.lang.String, int, int)",
    "27": "boolean areBubblesAllowed(java.lang.String)",
    "28": "boolean areBubblesEnabled(android.os.UserHandle)",
    "29": "int getBubblePreferenceForPackage(java.lang.String, int)",
    "30": "void createNotificationChannelGroups(java.lang.String, android.content.pm.ParceledListSlice)",
    "31": "void createNotificationChannels(java.lang.String, android.content.pm.ParceledListSlice)",
    "32": "void createNotificationChannelsForPackage(java.lang.String, int, android.content.pm.ParceledListSlice)",
    "33": "android.content.pm.ParceledListSlice getConversations(boolean)",
    "34": "android.content.pm.ParceledListSlice getConversationsForPackage(java.lang.String, int)",
    "35": "android.content.pm.ParceledListSlice getNotificationChannelGroupsForPackage(java.lang.String, int, boolean)",
    "36": "android.app.NotificationChannelGroup getNotificationChannelGroupForPackage(java.lang.String, java.lang.String, int)",
    "37": "android.app.NotificationChannelGroup getPopulatedNotificationChannelGroupForPackage(java.lang.String, int, java.lang.String, boolean)",
    "38": "void updateNotificationChannelGroupForPackage(java.lang.String, int, android.app.NotificationChannelGroup)",
    "39": "void updateNotificationChannelForPackage(java.lang.String, int, android.app.NotificationChannel)",
    "40": "void unlockNotificationChannel(java.lang.String, int, java.lang.String)",
    "41": "void unlockAllNotificationChannels()",
    "42": "android.app.NotificationChannel getNotificationChannel(java.lang.String, int, java.lang.String, java.lang.String)",
    "43": "android.app.NotificationChannel getConversationNotificationChannel(java.lang.String, int, java.lang.String, java.lang.String, boolean, java.lang.String)",
    "44": "void createConversationNotificationChannelForPackage(java.lang.String, int, android.app.NotificationChannel, java.lang.String)",
    "45": "android.app.NotificationChannel getNotificationChannelForPackage(java.lang.String, int, java.lang.String, java.lang.String, boolean)",
    "46": "void deleteNotificationChannel(java.lang.String, java.lang.String)",
    "47": "android.content.pm.ParceledListSlice getNotificationChannels(java.lang.String, java.lang.String, int)",
    "48": "android.content.pm.ParceledListSlice getNotificationChannelsForPackage(java.lang.String, int, boolean)",
    "49": "int getNumNotificationChannelsForPackage(java.lang.String, int, boolean)",
    "50": "int getDeletedChannelCount(java.lang.String, int)",
    "51": "int getBlockedChannelCount(java.lang.String, int)",
    "52": "void deleteNotificationChannelGroup(java.lang.String, java.lang.String)",
    "53": "android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String, java.lang.String)",
    "54": "android.content.pm.ParceledListSlice getNotificationChannelGroups(java.lang.String)",
    "55": "boolean onlyHasDefaultChannel(java.lang.String, int)",
    "56": "boolean areChannelsBypassingDnd()",
    "57": "android.content.pm.ParceledListSlice getNotificationChannelsBypassingDnd(java.lang.String, int)",
    "58": "boolean isPackagePaused(java.lang.String)",
    "59": "void deleteNotificationHistoryItem(java.lang.String, int, long)",
    "60": "boolean isPermissionFixed(java.lang.String, int)",
    "61": "void silenceNotificationSound()",
    "62": "[Landroid.service.notification.StatusBarNotification; getActiveNotifications(java.lang.String)",
    "63": "[Landroid.service.notification.StatusBarNotification; getActiveNotificationsWithAttribution(java.lang.String, java.lang.String)",
    "64": "[Landroid.service.notification.StatusBarNotification; getHistoricalNotifications(java.lang.String, int, boolean)",
    "65": "[Landroid.service.notification.StatusBarNotification; getHistoricalNotificationsWithAttribution(java.lang.String, java.lang.String, int, boolean)",
    "66": "android.app.NotificationHistory getNotificationHistory(java.lang.String, java.lang.String)",
    "67": "void registerListener(android.service.notification.INotificationListener, android.content.ComponentName, int)",
    "68": "void unregisterListener(android.service.notification.INotificationListener, int)",
    "69": "void cancelNotificationFromListener(android.service.notification.INotificationListener, java.lang.String, java.lang.String, int)",
    "70": "void cancelNotificationsFromListener(android.service.notification.INotificationListener, [Ljava.lang.String;)",
    "71": "void snoozeNotificationUntilContextFromListener(android.service.notification.INotificationListener, java.lang.String, java.lang.String)",
    "72": "void snoozeNotificationUntilFromListener(android.service.notification.INotificationListener, java.lang.String, long)",
    "73": "void requestBindListener(android.content.ComponentName)",
    "74": "void requestUnbindListener(android.service.notification.INotificationListener)",
    "75": "void requestUnbindListenerComponent(android.content.ComponentName)",
    "76": "void requestBindProvider(android.content.ComponentName)",
    "77": "void requestUnbindProvider(android.service.notification.IConditionProvider)",
    "78": "void setNotificationsShownFromListener(android.service.notification.INotificationListener, [Ljava.lang.String;)",
    "79": "android.content.pm.ParceledListSlice getActiveNotificationsFromListener(android.service.notification.INotificationListener, [Ljava.lang.String;, int)",
    "80": "android.content.pm.ParceledListSlice getSnoozedNotificationsFromListener(android.service.notification.INotificationListener, int)",
    "81": "void clearRequestedListenerHints(android.service.notification.INotificationListener)",
    "82": "void requestHintsFromListener(android.service.notification.INotificationListener, int)",
    "83": "int getHintsFromListener(android.service.notification.INotificationListener)",
    "84": "int getHintsFromListenerNoToken()",
    "85": "void requestInterruptionFilterFromListener(android.service.notification.INotificationListener, int)",
    "86": "int getInterruptionFilterFromListener(android.service.notification.INotificationListener)",
    "87": "void setOnNotificationPostedTrimFromListener(android.service.notification.INotificationListener, int)",
    "88": "void setInterruptionFilter(java.lang.String, int)",
    "89": "void updateNotificationChannelGroupFromPrivilegedListener(android.service.notification.INotificationListener, java.lang.String, android.os.UserHandle, android.app.NotificationChannelGroup)",
    "90": "void updateNotificationChannelFromPrivilegedListener(android.service.notification.INotificationListener, java.lang.String, android.os.UserHandle, android.app.NotificationChannel)",
    "91": "android.content.pm.ParceledListSlice getNotificationChannelsFromPrivilegedListener(android.service.notification.INotificationListener, java.lang.String, android.os.UserHandle)",
    "92": "android.content.pm.ParceledListSlice getNotificationChannelGroupsFromPrivilegedListener(android.service.notification.INotificationListener, java.lang.String, android.os.UserHandle)",
    "93": "void applyEnqueuedAdjustmentFromAssistant(android.service.notification.INotificationListener, android.service.notification.Adjustment)",
    "94": "void applyAdjustmentFromAssistant(android.service.notification.INotificationListener, android.service.notification.Adjustment)",
    "95": "void applyAdjustmentsFromAssistant(android.service.notification.INotificationListener, java.util.List)",
    "96": "void unsnoozeNotificationFromAssistant(android.service.notification.INotificationListener, java.lang.String)",
    "97": "void unsnoozeNotificationFromSystemListener(android.service.notification.INotificationListener, java.lang.String)",
    "98": "android.content.ComponentName getEffectsSuppressor()",
    "99": "boolean matchesCallFilter(android.os.Bundle)",
    "100": "void cleanUpCallersAfter(long)",
    "101": "boolean isSystemConditionProviderEnabled(java.lang.String)",
    "102": "boolean isNotificationListenerAccessGranted(android.content.ComponentName)",
    "103": "boolean isNotificationListenerAccessGrantedForUser(android.content.ComponentName, int)",
    "104": "boolean isNotificationAssistantAccessGranted(android.content.ComponentName)",
    "105": "void setNotificationListenerAccessGranted(android.content.ComponentName, boolean, boolean)",
    "106": "void setNotificationAssistantAccessGranted(android.content.ComponentName, boolean)",
    "107": "void setNotificationListenerAccessGrantedForUser(android.content.ComponentName, int, boolean, boolean)",
    "108": "void setNotificationAssistantAccessGrantedForUser(android.content.ComponentName, int, boolean)",
    "109": "java.util.List getEnabledNotificationListenerPackages()",
    "110": "java.util.List getEnabledNotificationListeners(int)",
    "111": "android.content.ComponentName getAllowedNotificationAssistantForUser(int)",
    "112": "android.content.ComponentName getAllowedNotificationAssistant()",
    "113": "android.content.ComponentName getDefaultNotificationAssistant()",
    "114": "void setNASMigrationDoneAndResetDefault(int, boolean)",
    "115": "boolean hasEnabledNotificationListener(java.lang.String, int)",
    "116": "int getZenMode()",
    "117": "android.service.notification.ZenModeConfig getZenModeConfig()",
    "118": "android.app.NotificationManager$Policy getConsolidatedNotificationPolicy()",
    "119": "void setZenMode(int, android.net.Uri, java.lang.String)",
    "120": "void notifyConditions(java.lang.String, android.service.notification.IConditionProvider, [Landroid.service.notification.Condition;)",
    "121": "boolean isNotificationPolicyAccessGranted(java.lang.String)",
    "122": "android.app.NotificationManager$Policy getNotificationPolicy(java.lang.String)",
    "123": "void setNotificationPolicy(java.lang.String, android.app.NotificationManager$Policy)",
    "124": "boolean isNotificationPolicyAccessGrantedForPackage(java.lang.String)",
    "125": "void setNotificationPolicyAccessGranted(java.lang.String, boolean)",
    "126": "void setNotificationPolicyAccessGrantedForUser(java.lang.String, int, boolean)",
    "127": "android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String)",
    "128": "java.util.List getZenRules()",
    "129": "java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule, java.lang.String)",
    "130": "boolean updateAutomaticZenRule(java.lang.String, android.app.AutomaticZenRule)",
    "131": "boolean removeAutomaticZenRule(java.lang.String)",
    "132": "boolean removeAutomaticZenRules(java.lang.String)",
    "133": "int getRuleInstanceCount(android.content.ComponentName)",
    "134": "void setAutomaticZenRuleState(java.lang.String, android.service.notification.Condition)",
    "135": "[B getBackupPayload(int)",
    "136": "void applyRestore([B, int)",
    "137": "android.content.pm.ParceledListSlice getAppActiveNotifications(java.lang.String, int)",
    "138": "void setNotificationDelegate(java.lang.String, java.lang.String)",
    "139": "java.lang.String getNotificationDelegate(java.lang.String)",
    "140": "boolean canNotifyAsPackage(java.lang.String, java.lang.String, int)",
    "141": "boolean canUseFullScreenIntent(android.content.AttributionSource)",
    "142": "void setPrivateNotificationsAllowed(boolean)",
    "143": "boolean getPrivateNotificationsAllowed()",
    "144": "long pullStats(long, int, boolean, java.util.List)",
    "145": "android.service.notification.NotificationListenerFilter getListenerFilter(android.content.ComponentName, int)",
    "146": "void setListenerFilter(android.content.ComponentName, int, android.service.notification.NotificationListenerFilter)",
    "147": "void migrateNotificationFilter(android.service.notification.INotificationListener, int, java.util.List)",
    "148": "void setToastRateLimitingEnabled(boolean)"
  },
  "android.app.sdksandbox.ISdkSandboxManager": {
    "1": "void addSdkSandboxProcessDeathCallback(java.lang.String, long, android.app.sdksandbox.ISdkSandboxProcessDeathCallback)",
    "2": "void removeSdkSandboxProcessDeathCallback(java.lang.String, long, android.app.sdksandbox.ISdkSandboxProcessDeathCallback)",
    "3": "void loadSdk(java.lang.String, android.os.IBinder, java.lang.String, long, android.os.Bundle, android.app.sdksandbox.ILoadSdkCallback)",
    "4": "void unloadSdk(java.lang.String, java.lang.String, long)",
    "5": "void requestSurfacePackage(java.lang.String, java.lang.String, android.os.IBinder, int, int, int, long, android.os.Bundle, android.app.sdksandbox.IRequestSurfacePackageCallback)",
    "6": "java.util.List getSandboxedSdks(java.lang.String, long)",
    "7": "void syncDataFromClient(java.lang.String, long, android.app.sdksandbox.SharedPreferencesUpdate, android.app.sdksandbox.ISharedPreferencesSyncCallback)",
    "8": "void stopSdkSandbox(java.lang.String)",
    "9": "void logLatencyFromSystemServerToApp(java.lang.String, int)",
    "10": "android.os.IBinder getAdServicesManager()"
  },
  "android.os.IIncidentManager": {
    "1": "void reportIncident(android.os.IncidentReportArgs)",
    "2": "void reportIncidentToStream(android.os.IncidentReportArgs, android.os.IIncidentReportStatusListener, java.io.FileDescriptor)",
    "3": "void reportIncidentToDumpstate(java.io.FileDescriptor, android.os.IIncidentReportStatusListener)",
    "4": "void registerSection(int, java.lang.String, android.os.IIncidentDumpCallback)",
    "5": "void unregisterSection(int)",
    "6": "void systemRunning()",
    "7": "java.util.List getIncidentReportList(java.lang.String, java.lang.String)",
    "8": "android.os.IncidentManager$IncidentReport getIncidentReport(java.lang.String, java.lang.String, java.lang.String)",
    "9": "void deleteIncidentReports(java.lang.String, java.lang.String, java.lang.String)",
    "10": "void deleteAllIncidentReports(java.lang.String)"
  },
  "android.media.projection.IMediaProjectionManager": {
    "1": "boolean hasProjectionPermission(int, java.lang.String)",
    "2": "android.media.projection.IMediaProjection createProjection(int, java.lang.String, int, boolean)",
    "3": "android.media.projection.IMediaProjection getProjection(int, java.lang.String)",
    "4": "boolean isCurrentProjection(android.media.projection.IMediaProjection)",
    "5": "void requestConsentForInvalidProjection(android.media.projection.IMediaProjection)",
    "6": "android.media.projection.MediaProjectionInfo getActiveProjectionInfo()",
    "7": "void stopActiveProjection()",
    "8": "void notifyActiveProjectionCapturedContentResized(int, int)",
    "9": "void notifyActiveProjectionCapturedContentVisibilityChanged(boolean)",
    "10": "void addCallback(android.media.projection.IMediaProjectionWatcherCallback)",
    "11": "void removeCallback(android.media.projection.IMediaProjectionWatcherCallback)",
    "12": "boolean setContentRecordingSession(android.view.ContentRecordingSession, android.media.projection.IMediaProjection)",
    "13": "void setUserReviewGrantedConsentResult(int, android.media.projection.IMediaProjection)"
  },
  "android.os.ISystemConfig": {
    "1": "java.util.List getDisabledUntilUsedPreinstalledCarrierApps()",
    "2": "java.util.Map getDisabledUntilUsedPreinstalledCarrierAssociatedApps()",
    "3": "java.util.Map getDisabledUntilUsedPreinstalledCarrierAssociatedAppEntries()",
    "4": "[I getSystemPermissionUids(java.lang.String)",
    "5": "java.util.List getEnabledComponentOverrides(java.lang.String)",
    "6": "java.util.List getDefaultVrComponents()"
  },
  "android.companion.ICompanionDeviceManager": {
    "1": "void associate(android.companion.AssociationRequest, android.companion.IAssociationRequestCallback, java.lang.String, int)",
    "2": "java.util.List getAssociations(java.lang.String, int)",
    "3": "java.util.List getAllAssociationsForUser(int)",
    "4": "void legacyDisassociate(java.lang.String, java.lang.String, int)",
    "5": "void disassociate(int)",
    "6": "boolean hasNotificationAccess(android.content.ComponentName)",
    "7": "android.app.PendingIntent requestNotificationAccess(android.content.ComponentName, int)",
    "8": "boolean isDeviceAssociatedForWifiConnection(java.lang.String, java.lang.String, int)",
    "9": "void registerDevicePresenceListenerService(java.lang.String, java.lang.String, int)",
    "10": "void unregisterDevicePresenceListenerService(java.lang.String, java.lang.String, int)",
    "11": "boolean canPairWithoutPrompt(java.lang.String, java.lang.String, int)",
    "12": "void createAssociation(java.lang.String, java.lang.String, int, [B)",
    "13": "void addOnAssociationsChangedListener(android.companion.IOnAssociationsChangedListener, int)",
    "14": "void removeOnAssociationsChangedListener(android.companion.IOnAssociationsChangedListener, int)",
    "15": "void addOnTransportsChangedListener(android.companion.IOnTransportsChangedListener)",
    "16": "void removeOnTransportsChangedListener(android.companion.IOnTransportsChangedListener)",
    "17": "void sendMessage(int, [B, [I)",
    "18": "void addOnMessageReceivedListener(int, android.companion.IOnMessageReceivedListener)",
    "19": "void removeOnMessageReceivedListener(int, android.companion.IOnMessageReceivedListener)",
    "20": "void notifyDeviceAppeared(int)",
    "21": "void notifyDeviceDisappeared(int)",
    "22": "android.app.PendingIntent buildPermissionTransferUserConsentIntent(java.lang.String, int, int)",
    "23": "void startSystemDataTransfer(java.lang.String, int, int, android.companion.ISystemDataTransferCallback)",
    "24": "void attachSystemDataTransport(java.lang.String, int, int, android.os.ParcelFileDescriptor)",
    "25": "void detachSystemDataTransport(java.lang.String, int, int)",
    "26": "boolean isCompanionApplicationBound(java.lang.String, int)",
    "27": "android.app.PendingIntent buildAssociationCancellationIntent(java.lang.String, int)",
    "28": "void enableSystemDataSync(int, int)",
    "29": "void disableSystemDataSync(int, int)",
    "30": "void enableSecureTransport(boolean)"
  },
  "android.os.storage.IStorageManager": {
    "1": "void registerListener(android.os.storage.IStorageEventListener)",
    "2": "void unregisterListener(android.os.storage.IStorageEventListener)",
    "20": "void shutdown(android.os.storage.IStorageShutdownObserver)",
    "22": "void mountObb(java.lang.String, java.lang.String, android.os.storage.IObbActionListener, int, android.content.res.ObbInfo)",
    "23": "void unmountObb(java.lang.String, boolean, android.os.storage.IObbActionListener, int)",
    "24": "boolean isObbMounted(java.lang.String)",
    "25": "java.lang.String getMountedObbPath(java.lang.String)",
    "30": "[Landroid.os.storage.StorageVolume; getVolumeList(int, java.lang.String, int)",
    "35": "void mkdirs(java.lang.String, java.lang.String)",
    "42": "long lastMaintenance()",
    "43": "void runMaintenance()",
    "45": "[Landroid.os.storage.DiskInfo; getDisks()",
    "46": "[Landroid.os.storage.VolumeInfo; getVolumes(int)",
    "47": "[Landroid.os.storage.VolumeRecord; getVolumeRecords(int)",
    "48": "void mount(java.lang.String)",
    "49": "void unmount(java.lang.String)",
    "50": "void format(java.lang.String)",
    "51": "void partitionPublic(java.lang.String)",
    "52": "void partitionPrivate(java.lang.String)",
    "53": "void partitionMixed(java.lang.String, int)",
    "54": "void setVolumeNickname(java.lang.String, java.lang.String)",
    "55": "void setVolumeUserFlags(java.lang.String, int, int)",
    "56": "void forgetVolume(java.lang.String)",
    "57": "void forgetAllVolumes()",
    "58": "java.lang.String getPrimaryStorageUuid()",
    "59": "void setPrimaryStorageUuid(java.lang.String, android.content.pm.IPackageMoveObserver)",
    "60": "void benchmark(java.lang.String, android.os.IVoldTaskListener)",
    "61": "void setDebugFlags(int, int)"
  },
  "android.webkit.IWebViewUpdateService": {
    "1": "void notifyRelroCreationCompleted()",
    "2": "android.webkit.WebViewProviderResponse waitForAndGetProvider()",
    "3": "java.lang.String changeProviderAndSetting(java.lang.String)",
    "4": "[Landroid.webkit.WebViewProviderInfo; getValidWebViewPackages()",
    "5": "[Landroid.webkit.WebViewProviderInfo; getAllWebViewPackages()",
    "6": "java.lang.String getCurrentWebViewPackageName()",
    "7": "android.content.pm.PackageInfo getCurrentWebViewPackage()",
    "8": "boolean isMultiProcessEnabled()",
    "9": "void enableMultiProcess(boolean)"
  },
  "com.android.internal.view.IInputMethodManager": {
    "1": "void addClient(com.android.internal.inputmethod.IInputMethodClient, com.android.internal.inputmethod.IRemoteInputConnection, int)",
    "2": "android.view.inputmethod.InputMethodInfo getCurrentInputMethodInfoAsUser(int)",
    "3": "java.util.List getInputMethodList(int, int)",
    "4": "java.util.List getEnabledInputMethodList(int)",
    "5": "java.util.List getEnabledInputMethodSubtypeList(java.lang.String, boolean, int)",
    "6": "android.view.inputmethod.InputMethodSubtype getLastInputMethodSubtype(int)",
    "7": "boolean showSoftInput(com.android.internal.inputmethod.IInputMethodClient, android.os.IBinder, android.view.inputmethod.ImeTracker$Token, int, int, android.os.ResultReceiver, int)",
    "8": "boolean hideSoftInput(com.android.internal.inputmethod.IInputMethodClient, android.os.IBinder, android.view.inputmethod.ImeTracker$Token, int, android.os.ResultReceiver, int)",
    "9": "com.android.internal.inputmethod.InputBindResult startInputOrWindowGainedFocus(int, com.android.internal.inputmethod.IInputMethodClient, android.os.IBinder, int, int, int, android.view.inputmethod.EditorInfo, com.android.internal.inputmethod.IRemoteInputConnection, com.android.internal.inputmethod.IRemoteAccessibilityInputConnection, int, int, android.window.ImeOnBackInvokedDispatcher)",
    "10": "void showInputMethodPickerFromClient(com.android.internal.inputmethod.IInputMethodClient, int)",
    "11": "void showInputMethodPickerFromSystem(int, int)",
    "12": "boolean isInputMethodPickerShownForTest()",
    "13": "android.view.inputmethod.InputMethodSubtype getCurrentInputMethodSubtype(int)",
    "14": "void setAdditionalInputMethodSubtypes(java.lang.String, [Landroid.view.inputmethod.InputMethodSubtype;, int)",
    "15": "void setExplicitlyEnabledInputMethodSubtypes(java.lang.String, [I, int)",
    "16": "int getInputMethodWindowVisibleHeight(com.android.internal.inputmethod.IInputMethodClient)",
    "17": "void reportVirtualDisplayGeometryAsync(com.android.internal.inputmethod.IInputMethodClient, int, [F)",
    "18": "void reportPerceptibleAsync(android.os.IBinder, boolean)",
    "19": "void removeImeSurface()",
    "20": "void removeImeSurfaceFromWindowAsync(android.os.IBinder)",
    "21": "void startProtoDump([B, int, java.lang.String)",
    "22": "boolean isImeTraceEnabled()",
    "23": "void startImeTrace()",
    "24": "void stopImeTrace()",
    "25": "void startStylusHandwriting(com.android.internal.inputmethod.IInputMethodClient)",
    "26": "void prepareStylusHandwritingDelegation(com.android.internal.inputmethod.IInputMethodClient, int, java.lang.String, java.lang.String)",
    "27": "boolean acceptStylusHandwritingDelegation(com.android.internal.inputmethod.IInputMethodClient, int, java.lang.String, java.lang.String)",
    "28": "boolean isStylusHandwritingAvailableAsUser(int)",
    "29": "void addVirtualStylusIdForTestSession(com.android.internal.inputmethod.IInputMethodClient)",
    "30": "void setStylusWindowIdleTimeoutForTest(com.android.internal.inputmethod.IInputMethodClient, long)",
    "31": "com.android.internal.inputmethod.IImeTracker getImeTrackerService()"
  },
  "android.app.ondevicepersonalization.IOnDevicePersonalizationSystemService": {
    "1": "void onRequest(android.os.Bundle, android.app.ondevicepersonalization.IOnDevicePersonalizationSystemServiceCallback)"
  },
  "android.tracing.ITracingServiceProxy": {
    "1": "void notifyTraceSessionEnded(boolean)",
    "2": "void reportTrace(android.tracing.TraceReportParams)"
  },
  "android.os.INetworkManagementService": {
    "1": "void registerObserver(android.net.INetworkManagementEventObserver)",
    "2": "void unregisterObserver(android.net.INetworkManagementEventObserver)",
    "3": "[Ljava.lang.String; listInterfaces()",
    "4": "android.net.InterfaceConfiguration getInterfaceConfig(java.lang.String)",
    "5": "void setInterfaceConfig(java.lang.String, android.net.InterfaceConfiguration)",
    "6": "void clearInterfaceAddresses(java.lang.String)",
    "7": "void setInterfaceDown(java.lang.String)",
    "8": "void setInterfaceUp(java.lang.String)",
    "9": "void setInterfaceIpv6PrivacyExtensions(java.lang.String, boolean)",
    "10": "void disableIpv6(java.lang.String)",
    "11": "void enableIpv6(java.lang.String)",
    "12": "void setIPv6AddrGenMode(java.lang.String, int)",
    "13": "void addRoute(int, android.net.RouteInfo)",
    "14": "void removeRoute(int, android.net.RouteInfo)",
    "15": "void shutdown()",
    "16": "boolean getIpForwardingEnabled()",
    "17": "void setIpForwardingEnabled(boolean)",
    "18": "void startTethering([Ljava.lang.String;)",
    "19": "void startTetheringWithConfiguration(boolean, [Ljava.lang.String;)",
    "20": "void stopTethering()",
    "21": "boolean isTetheringStarted()",
    "22": "void tetherInterface(java.lang.String)",
    "23": "void untetherInterface(java.lang.String)",
    "24": "[Ljava.lang.String; listTetheredInterfaces()",
    "25": "[Ljava.lang.String; getDnsForwarders()",
    "26": "void startInterfaceForwarding(java.lang.String, java.lang.String)",
    "27": "void stopInterfaceForwarding(java.lang.String, java.lang.String)",
    "28": "void enableNat(java.lang.String, java.lang.String)",
    "29": "void disableNat(java.lang.String, java.lang.String)",
    "30": "void registerTetheringStatsProvider(android.net.ITetheringStatsProvider, java.lang.String)",
    "31": "void unregisterTetheringStatsProvider(android.net.ITetheringStatsProvider)",
    "32": "void tetherLimitReached(android.net.ITetheringStatsProvider)",
    "33": "android.net.NetworkStats getNetworkStatsTethering(int)",
    "34": "void setInterfaceQuota(java.lang.String, long)",
    "35": "void removeInterfaceQuota(java.lang.String)",
    "36": "void setInterfaceAlert(java.lang.String, long)",
    "37": "void removeInterfaceAlert(java.lang.String)",
    "38": "void setGlobalAlert(long)",
    "39": "void setUidOnMeteredNetworkDenylist(int, boolean)",
    "40": "void setUidOnMeteredNetworkAllowlist(int, boolean)",
    "41": "boolean setDataSaverModeEnabled(boolean)",
    "42": "void setUidCleartextNetworkPolicy(int, int)",
    "43": "boolean isBandwidthControlEnabled()",
    "44": "void setFirewallEnabled(boolean)",
    "45": "boolean isFirewallEnabled()",
    "46": "void setFirewallInterfaceRule(java.lang.String, boolean)",
    "47": "void setFirewallUidRule(int, int, int)",
    "48": "void setFirewallUidRules(int, [I, [I)",
    "49": "void setFirewallChainEnabled(int, boolean)",
    "50": "void allowProtect(int)",
    "51": "void denyProtect(int)",
    "52": "void addInterfaceToLocalNetwork(java.lang.String, java.util.List)",
    "53": "void removeInterfaceFromLocalNetwork(java.lang.String)",
    "54": "int removeRoutesFromLocalNetwork(java.util.List)",
    "55": "boolean isNetworkRestricted(int)"
  },
  "android.debug.IAdbManager": {
    "1": "void allowDebugging(boolean, java.lang.String)",
    "2": "void denyDebugging()",
    "3": "void clearDebuggingKeys()",
    "4": "void allowWirelessDebugging(boolean, java.lang.String)",
    "5": "void denyWirelessDebugging()",
    "6": "[Landroid.debug.FingerprintAndPairDevice; getPairedDevices()",
    "7": "void unpairDevice(java.lang.String)",
    "8": "void enablePairingByPairingCode()",
    "9": "void enablePairingByQrCode(java.lang.String, java.lang.String)",
    "10": "int getAdbWirelessPort()",
    "11": "void disablePairing()",
    "12": "boolean isAdbWifiSupported()",
    "13": "boolean isAdbWifiQrSupported()",
    "14": "void registerCallback(android.debug.IAdbCallback)",
    "15": "void unregisterCallback(android.debug.IAdbCallback)"
  },
  "android.devicelock.IDeviceLockService": {
    "1": "void lockDevice(android.devicelock.ILockUnlockDeviceCallback)",
    "2": "void unlockDevice(android.devicelock.ILockUnlockDeviceCallback)",
    "3": "void isDeviceLocked(android.devicelock.IIsDeviceLockedCallback)",
    "4": "void getDeviceId(android.devicelock.IGetDeviceIdCallback)",
    "5": "void getKioskApps(android.devicelock.IGetKioskAppsCallback)",
    "6": "void addFinancedDeviceKioskRole(java.lang.String, android.os.RemoteCallback)",
    "7": "void removeFinancedDeviceKioskRole(java.lang.String, android.os.RemoteCallback)",
    "8": "void setExemptFromActivityBackgroundStartRestriction(boolean, android.os.RemoteCallback)",
    "9": "void setExemptFromHibernation(java.lang.String, boolean, android.os.RemoteCallback)"
  },
  "android.health.connect.aidl.IHealthConnectService": {
    "1": "void grantHealthPermission(java.lang.String, java.lang.String, android.os.UserHandle)",
    "2": "void revokeHealthPermission(java.lang.String, java.lang.String, java.lang.String, android.os.UserHandle)",
    "3": "void revokeAllHealthPermissions(java.lang.String, java.lang.String, android.os.UserHandle)",
    "4": "java.util.List getGrantedHealthPermissions(java.lang.String, android.os.UserHandle)",
    "5": "long getHistoricalAccessStartDateInMilliseconds(java.lang.String, android.os.UserHandle)",
    "6": "void insertRecords(android.content.AttributionSource, android.health.connect.aidl.RecordsParcel, android.health.connect.aidl.IInsertRecordsResponseCallback)",
    "7": "void aggregateRecords(android.content.AttributionSource, android.health.connect.aidl.AggregateDataRequestParcel, android.health.connect.aidl.IAggregateRecordsResponseCallback)",
    "8": "void readRecords(android.content.AttributionSource, android.health.connect.aidl.ReadRecordsRequestParcel, android.health.connect.aidl.IReadRecordsResponseCallback)",
    "9": "void updateRecords(android.content.AttributionSource, android.health.connect.aidl.RecordsParcel, android.health.connect.aidl.IEmptyResponseCallback)",
    "10": "void getChangeLogToken(android.content.AttributionSource, android.health.connect.changelog.ChangeLogTokenRequest, android.health.connect.aidl.IGetChangeLogTokenCallback)",
    "11": "void getChangeLogs(android.content.AttributionSource, android.health.connect.changelog.ChangeLogsRequest, android.health.connect.aidl.IChangeLogsResponseCallback)",
    "12": "void deleteUsingFilters(android.content.AttributionSource, android.health.connect.aidl.DeleteUsingFiltersRequestParcel, android.health.connect.aidl.IEmptyResponseCallback)",
    "13": "void deleteUsingFiltersForSelf(android.content.AttributionSource, android.health.connect.aidl.DeleteUsingFiltersRequestParcel, android.health.connect.aidl.IEmptyResponseCallback)",
    "14": "void getCurrentPriority(java.lang.String, int, android.health.connect.aidl.IGetPriorityResponseCallback)",
    "15": "void updatePriority(java.lang.String, android.health.connect.aidl.UpdatePriorityRequestParcel, android.health.connect.aidl.IEmptyResponseCallback)",
    "16": "void setRecordRetentionPeriodInDays(int, android.os.UserHandle, android.health.connect.aidl.IEmptyResponseCallback)",
    "17": "int getRecordRetentionPeriodInDays(android.os.UserHandle)",
    "18": "void getContributorApplicationsInfo(android.health.connect.aidl.IApplicationInfoResponseCallback)",
    "19": "void queryAllRecordTypesInfo(android.health.connect.aidl.IRecordTypeInfoResponseCallback)",
    "20": "void queryAccessLogs(java.lang.String, android.health.connect.aidl.IAccessLogsResponseCallback)",
    "21": "void getActivityDates(android.health.connect.aidl.ActivityDatesRequestParcel, android.health.connect.aidl.IActivityDatesResponseCallback)",
    "22": "void startMigration(java.lang.String, android.health.connect.aidl.IMigrationCallback)",
    "23": "void finishMigration(java.lang.String, android.health.connect.aidl.IMigrationCallback)",
    "24": "void writeMigrationData(java.lang.String, android.health.connect.migration.MigrationEntityParcel, android.health.connect.aidl.IMigrationCallback)",
    "25": "void insertMinDataMigrationSdkExtensionVersion(java.lang.String, int, android.health.connect.aidl.IMigrationCallback)",
    "26": "void stageAllHealthConnectRemoteData(android.health.connect.restore.StageRemoteDataRequest, android.os.UserHandle, android.health.connect.aidl.IDataStagingFinishedCallback)",
    "27": "void getAllDataForBackup(android.health.connect.restore.StageRemoteDataRequest, android.os.UserHandle)",
    "28": "android.health.connect.restore.BackupFileNamesSet getAllBackupFileNames(boolean)",
    "29": "void deleteAllStagedRemoteData(android.os.UserHandle)",
    "30": "void updateDataDownloadState(int)",
    "31": "void getHealthConnectDataState(android.health.connect.aidl.IGetHealthConnectDataStateCallback)",
    "32": "void getHealthConnectMigrationUiState(android.health.connect.aidl.IGetHealthConnectMigrationUiStateCallback)"
  },
  "android.apphibernation.IAppHibernationService": {
    "1": "boolean isHibernatingForUser(java.lang.String, int)",
    "2": "void setHibernatingForUser(java.lang.String, int, boolean)",
    "3": "boolean isHibernatingGlobally(java.lang.String)",
    "4": "void setHibernatingGlobally(java.lang.String, boolean)",
    "5": "java.util.List getHibernatingPackagesForUser(int)",
    "6": "java.util.Map getHibernationStatsForUser(java.util.List, int)",
    "7": "boolean isOatArtifactDeletionEnabled()"
  },
  "android.security.IFileIntegrityService": {
    "1": "boolean isApkVeritySupported()",
    "2": "boolean isAppSourceCertificateTrusted([B, java.lang.String)"
  },
  "android.view.IGraphicsStats": {
    "1": "android.os.ParcelFileDescriptor requestBufferForProcess(java.lang.String, android.view.IGraphicsStatsCallback)"
  },
  "com.android.internal.app.procstats.IProcessStats": {
    "1": "[B getCurrentStats(java.util.List)",
    "2": "android.os.ParcelFileDescriptor getStatsOverTime(long)",
    "3": "int getCurrentMemoryState()",
    "4": "long getCommittedStats(long, int, boolean, java.util.List)",
    "5": "long getCommittedStatsMerged(long, int, boolean, java.util.List, com.android.internal.app.procstats.ProcessStats)",
    "6": "long getMinAssociationDumpDuration()"
  },
  "android.companion.virtual.IVirtualDeviceManager": {
    "1": "android.companion.virtual.IVirtualDevice createVirtualDevice(android.os.IBinder, java.lang.String, int, android.companion.virtual.VirtualDeviceParams, android.companion.virtual.IVirtualDeviceActivityListener, android.companion.virtual.IVirtualDeviceSoundEffectListener)",
    "2": "java.util.List getVirtualDevices()",
    "3": "int getDeviceIdForDisplayId(int)",
    "4": "boolean isValidVirtualDeviceId(int)",
    "5": "int getDevicePolicy(int, int)",
    "6": "int createVirtualDisplay(android.hardware.display.VirtualDisplayConfig, android.hardware.display.IVirtualDisplayCallback, android.companion.virtual.IVirtualDevice, java.lang.String)",
    "7": "int getAudioPlaybackSessionId(int)",
    "8": "int getAudioRecordingSessionId(int)",
    "9": "void playSoundEffect(int, int)"
  },
  "android.os.IStatsManagerService": {
    "1": "void setDataFetchOperation(long, android.app.PendingIntent, java.lang.String)",
    "2": "void removeDataFetchOperation(long, java.lang.String)",
    "3": "[J setActiveConfigsChangedOperation(android.app.PendingIntent, java.lang.String)",
    "4": "void removeActiveConfigsChangedOperation(java.lang.String)",
    "5": "void setBroadcastSubscriber(long, long, android.app.PendingIntent, java.lang.String)",
    "6": "void unsetBroadcastSubscriber(long, long, java.lang.String)",
    "7": "[J getRegisteredExperimentIds()",
    "8": "[B getMetadata(java.lang.String)",
    "9": "[B getData(long, java.lang.String)",
    "10": "void addConfiguration(long, [B, java.lang.String)",
    "11": "void removeConfiguration(long, java.lang.String)",
    "12": "void registerPullAtomCallback(int, long, long, [I, android.os.IPullAtomCallback)",
    "13": "void unregisterPullAtomCallback(int)",
    "14": "void querySql(java.lang.String, int, [B, android.os.IStatsQueryCallback, long, java.lang.String)",
    "15": "[J setRestrictedMetricsChangedOperation(android.app.PendingIntent, long, java.lang.String)",
    "16": "void removeRestrictedMetricsChangedOperation(long, java.lang.String)"
  },
  "android.service.dreams.IDreamManager": {
    "1": "void dream()",
    "2": "void awaken()",
    "3": "void setDreamComponents([Landroid.content.ComponentName;)",
    "4": "[Landroid.content.ComponentName; getDreamComponents()",
    "5": "android.content.ComponentName getDefaultDreamComponentForUser(int)",
    "6": "void testDream(int, android.content.ComponentName)",
    "7": "boolean isDreaming()",
    "8": "boolean isDreamingOrInPreview()",
    "9": "void finishSelf(android.os.IBinder, boolean)",
    "10": "void startDozing(android.os.IBinder, int, int)",
    "11": "void stopDozing(android.os.IBinder)",
    "12": "void forceAmbientDisplayEnabled(boolean)",
    "13": "[Landroid.content.ComponentName; getDreamComponentsForUser(int)",
    "14": "void setDreamComponentsForUser(int, [Landroid.content.ComponentName;)",
    "15": "void setSystemDreamComponent(android.content.ComponentName)",
    "16": "void registerDreamOverlayService(android.content.ComponentName)"
  },
  "android.os.IBatteryPropertiesRegistrar": {
    "1": "int getProperty(int, android.os.BatteryProperty)",
    "2": "void scheduleUpdate()"
  },
  "android.hardware.display.IDisplayManager": {
    "1": "android.view.DisplayInfo getDisplayInfo(int)",
    "2": "[I getDisplayIds(boolean)",
    "3": "boolean isUidPresentOnDisplay(int, int)",
    "4": "void registerCallback(android.hardware.display.IDisplayManagerCallback)",
    "5": "void registerCallbackWithEventMask(android.hardware.display.IDisplayManagerCallback, long)",
    "6": "void startWifiDisplayScan()",
    "7": "void stopWifiDisplayScan()",
    "8": "void connectWifiDisplay(java.lang.String)",
    "9": "void disconnectWifiDisplay()",
    "10": "void renameWifiDisplay(java.lang.String, java.lang.String)",
    "11": "void forgetWifiDisplay(java.lang.String)",
    "12": "void pauseWifiDisplay()",
    "13": "void resumeWifiDisplay()",
    "14": "android.hardware.display.WifiDisplayStatus getWifiDisplayStatus()",
    "15": "void setUserDisabledHdrTypes([I)",
    "16": "void setAreUserDisabledHdrTypesAllowed(boolean)",
    "17": "boolean areUserDisabledHdrTypesAllowed()",
    "18": "[I getUserDisabledHdrTypes()",
    "19": "void overrideHdrTypes(int, [I)",
    "20": "void requestColorMode(int, int)",
    "21": "int createVirtualDisplay(android.hardware.display.VirtualDisplayConfig, android.hardware.display.IVirtualDisplayCallback, android.media.projection.IMediaProjection, java.lang.String)",
    "22": "void resizeVirtualDisplay(android.hardware.display.IVirtualDisplayCallback, int, int, int)",
    "23": "void setVirtualDisplaySurface(android.hardware.display.IVirtualDisplayCallback, android.view.Surface)",
    "24": "void releaseVirtualDisplay(android.hardware.display.IVirtualDisplayCallback)",
    "25": "void setVirtualDisplayState(android.hardware.display.IVirtualDisplayCallback, boolean)",
    "26": "android.graphics.Point getStableDisplaySize()",
    "27": "android.content.pm.ParceledListSlice getBrightnessEvents(java.lang.String)",
    "28": "android.content.pm.ParceledListSlice getAmbientBrightnessStats()",
    "29": "void setBrightnessConfigurationForUser(android.hardware.display.BrightnessConfiguration, int, java.lang.String)",
    "30": "void setBrightnessConfigurationForDisplay(android.hardware.display.BrightnessConfiguration, java.lang.String, int, java.lang.String)",
    "31": "android.hardware.display.BrightnessConfiguration getBrightnessConfigurationForDisplay(java.lang.String, int)",
    "32": "android.hardware.display.BrightnessConfiguration getBrightnessConfigurationForUser(int)",
    "33": "android.hardware.display.BrightnessConfiguration getDefaultBrightnessConfiguration()",
    "34": "boolean isMinimalPostProcessingRequested(int)",
    "35": "void setTemporaryBrightness(int, float)",
    "36": "void setBrightness(int, float)",
    "37": "float getBrightness(int)",
    "38": "void setTemporaryAutoBrightnessAdjustment(float)",
    "39": "android.hardware.display.Curve getMinimumBrightnessCurve()",
    "40": "android.hardware.display.BrightnessInfo getBrightnessInfo(int)",
    "41": "int getPreferredWideGamutColorSpaceId()",
    "42": "void setUserPreferredDisplayMode(int, android.view.Display$Mode)",
    "43": "android.view.Display$Mode getUserPreferredDisplayMode(int)",
    "44": "android.view.Display$Mode getSystemPreferredDisplayMode(int)",
    "45": "void setHdrConversionMode(android.hardware.display.HdrConversionMode)",
    "46": "android.hardware.display.HdrConversionMode getHdrConversionModeSetting()",
    "47": "android.hardware.display.HdrConversionMode getHdrConversionMode()",
    "48": "[I getSupportedHdrOutputTypes()",
    "49": "void setShouldAlwaysRespectAppRequestedMode(boolean)",
    "50": "boolean shouldAlwaysRespectAppRequestedMode()",
    "51": "void setRefreshRateSwitchingType(int)",
    "52": "int getRefreshRateSwitchingType()",
    "53": "android.hardware.graphics.common.DisplayDecorationSupport getDisplayDecorationSupport(int)",
    "54": "void setDisplayIdToMirror(android.os.IBinder, int)",
    "55": "android.hardware.OverlayProperties getOverlaySupport()"
  },
  "android.view.IWindowManager": {
    "1": "boolean startViewServer(int)",
    "2": "boolean stopViewServer()",
    "3": "boolean isViewServerRunning()",
    "4": "android.view.IWindowSession openSession(android.view.IWindowSessionCallback)",
    "5": "boolean useBLAST()",
    "6": "void getInitialDisplaySize(int, android.graphics.Point)",
    "7": "void getBaseDisplaySize(int, android.graphics.Point)",
    "8": "void setForcedDisplaySize(int, int, int)",
    "9": "void clearForcedDisplaySize(int)",
    "10": "int getInitialDisplayDensity(int)",
    "11": "int getBaseDisplayDensity(int)",
    "12": "int getDisplayIdByUniqueId(java.lang.String)",
    "13": "void setForcedDisplayDensityForUser(int, int, int)",
    "14": "void clearForcedDisplayDensityForUser(int, int)",
    "15": "void setForcedDisplayScalingMode(int, int)",
    "16": "void setEventDispatching(boolean)",
    "17": "boolean isWindowToken(android.os.IBinder)",
    "18": "void addWindowToken(android.os.IBinder, int, int, android.os.Bundle)",
    "19": "void removeWindowToken(android.os.IBinder, int)",
    "20": "void setDisplayChangeWindowController(android.view.IDisplayChangeWindowController)",
    "21": "android.view.SurfaceControl addShellRoot(int, android.view.IWindow, int)",
    "22": "void setShellRootAccessibilityWindow(int, int, android.view.IWindow)",
    "23": "void overridePendingAppTransitionMultiThumbFuture(android.view.IAppTransitionAnimationSpecsFuture, android.os.IRemoteCallback, boolean, int)",
    "24": "void overridePendingAppTransitionRemote(android.view.RemoteAnimationAdapter, int)",
    "25": "void endProlongedAnimations()",
    "26": "void startFreezingScreen(int, int)",
    "27": "void stopFreezingScreen()",
    "28": "void disableKeyguard(android.os.IBinder, java.lang.String, int)",
    "29": "void reenableKeyguard(android.os.IBinder, int)",
    "30": "void exitKeyguardSecurely(android.view.IOnKeyguardExitResult)",
    "31": "boolean isKeyguardLocked()",
    "32": "boolean isKeyguardSecure(int)",
    "33": "void dismissKeyguard(com.android.internal.policy.IKeyguardDismissCallback, java.lang.CharSequence)",
    "34": "void addKeyguardLockedStateListener(com.android.internal.policy.IKeyguardLockedStateListener)",
    "35": "void removeKeyguardLockedStateListener(com.android.internal.policy.IKeyguardLockedStateListener)",
    "36": "void setSwitchingUser(boolean)",
    "37": "void closeSystemDialogs(java.lang.String)",
    "38": "float getAnimationScale(int)",
    "39": "[F getAnimationScales()",
    "40": "void setAnimationScale(int, float)",
    "41": "void setAnimationScales([F)",
    "42": "float getCurrentAnimatorScale()",
    "43": "void setInTouchMode(boolean, int)",
    "44": "void setInTouchModeOnAllDisplays(boolean)",
    "45": "boolean isInTouchMode(int)",
    "46": "void showStrictModeViolation(boolean)",
    "47": "void setStrictModeVisualIndicatorPreference(java.lang.String)",
    "48": "void refreshScreenCaptureDisabled()",
    "49": "int getDefaultDisplayRotation()",
    "50": "int watchRotation(android.view.IRotationWatcher, int)",
    "51": "void removeRotationWatcher(android.view.IRotationWatcher)",
    "52": "int registerProposedRotationListener(android.os.IBinder, android.view.IRotationWatcher)",
    "53": "int getPreferredOptionsPanelGravity(int)",
    "54": "void freezeRotation(int)",
    "55": "void thawRotation()",
    "56": "boolean isRotationFrozen()",
    "57": "void freezeDisplayRotation(int, int)",
    "58": "void thawDisplayRotation(int)",
    "59": "boolean isDisplayRotationFrozen(int)",
    "60": "void setFixedToUserRotation(int, int)",
    "61": "void setIgnoreOrientationRequest(int, boolean)",
    "62": "android.graphics.Bitmap screenshotWallpaper()",
    "63": "android.view.SurfaceControl mirrorWallpaperSurface(int)",
    "64": "boolean registerWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener, int)",
    "65": "void unregisterWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener, int)",
    "66": "void registerSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener, int)",
    "67": "void unregisterSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener, int)",
    "68": "boolean requestAssistScreenshot(android.app.IAssistDataReceiver)",
    "69": "void hideTransientBars(int)",
    "70": "void setRecentsVisibility(boolean)",
    "71": "void updateStaticPrivacyIndicatorBounds(int, [Landroid.graphics.Rect;)",
    "72": "void setNavBarVirtualKeyHapticFeedbackEnabled(boolean)",
    "73": "boolean hasNavigationBar(int)",
    "74": "void lockNow(android.os.Bundle)",
    "75": "boolean isSafeModeEnabled()",
    "76": "boolean clearWindowContentFrameStats(android.os.IBinder)",
    "77": "android.view.WindowContentFrameStats getWindowContentFrameStats(android.os.IBinder)",
    "78": "int getDockedStackSide()",
    "79": "void registerPinnedTaskListener(int, android.view.IPinnedTaskListener)",
    "80": "void requestAppKeyboardShortcuts(com.android.internal.os.IResultReceiver, int)",
    "81": "void getStableInsets(int, android.graphics.Rect)",
    "82": "void registerShortcutKey(long, com.android.internal.policy.IShortcutService)",
    "83": "void createInputConsumer(android.os.IBinder, java.lang.String, int, android.view.InputChannel)",
    "84": "boolean destroyInputConsumer(java.lang.String, int)",
    "85": "android.graphics.Region getCurrentImeTouchRegion()",
    "86": "void registerDisplayFoldListener(android.view.IDisplayFoldListener)",
    "87": "void unregisterDisplayFoldListener(android.view.IDisplayFoldListener)",
    "88": "[I registerDisplayWindowListener(android.view.IDisplayWindowListener)",
    "89": "void unregisterDisplayWindowListener(android.view.IDisplayWindowListener)",
    "90": "void startWindowTrace()",
    "91": "void stopWindowTrace()",
    "92": "void saveWindowTraceToFile()",
    "93": "boolean isWindowTraceEnabled()",
    "94": "void startTransitionTrace()",
    "95": "void stopTransitionTrace()",
    "96": "boolean isTransitionTraceEnabled()",
    "97": "int getWindowingMode(int)",
    "98": "void setWindowingMode(int, int)",
    "99": "int getRemoveContentMode(int)",
    "100": "void setRemoveContentMode(int, int)",
    "101": "boolean shouldShowWithInsecureKeyguard(int)",
    "102": "void setShouldShowWithInsecureKeyguard(int, boolean)",
    "103": "boolean shouldShowSystemDecors(int)",
    "104": "void setShouldShowSystemDecors(int, boolean)",
    "105": "int getDisplayImePolicy(int)",
    "106": "void setDisplayImePolicy(int, int)",
    "107": "void syncInputTransactions(boolean)",
    "108": "boolean isLayerTracing()",
    "109": "void setLayerTracing(boolean)",
    "110": "boolean mirrorDisplay(int, android.view.SurfaceControl)",
    "111": "void setDisplayWindowInsetsController(int, android.view.IDisplayWindowInsetsController)",
    "112": "void updateDisplayWindowRequestedVisibleTypes(int, int)",
    "113": "boolean getWindowInsets(int, android.os.IBinder, android.view.InsetsState)",
    "114": "java.util.List getPossibleDisplayInfo(int)",
    "115": "void showGlobalActions()",
    "116": "void setLayerTracingFlags(int)",
    "117": "void setActiveTransactionTracing(boolean)",
    "118": "void requestScrollCapture(int, android.os.IBinder, int, android.view.IScrollCaptureResponseListener)",
    "119": "void holdLock(android.os.IBinder, int)",
    "120": "[Ljava.lang.String; getSupportedDisplayHashAlgorithms()",
    "121": "android.view.displayhash.VerifiedDisplayHash verifyDisplayHash(android.view.displayhash.DisplayHash)",
    "122": "void setDisplayHashThrottlingEnabled(boolean)",
    "123": "android.content.res.Configuration attachWindowContextToDisplayArea(android.os.IBinder, int, int, android.os.Bundle)",
    "124": "void attachWindowContextToWindowToken(android.os.IBinder, android.os.IBinder)",
    "125": "android.content.res.Configuration attachToDisplayContent(android.os.IBinder, int)",
    "126": "void detachWindowContextFromWindowContainer(android.os.IBinder)",
    "127": "boolean registerCrossWindowBlurEnabledListener(android.view.ICrossWindowBlurEnabledListener)",
    "128": "void unregisterCrossWindowBlurEnabledListener(android.view.ICrossWindowBlurEnabledListener)",
    "129": "boolean isTaskSnapshotSupported()",
    "130": "int getImeDisplayId()",
    "131": "void setTaskSnapshotEnabled(boolean)",
    "132": "void setTaskTransitionSpec(android.view.TaskTransitionSpec)",
    "133": "void clearTaskTransitionSpec()",
    "134": "void registerTaskFpsCallback(int, android.window.ITaskFpsCallback)",
    "135": "void unregisterTaskFpsCallback(android.window.ITaskFpsCallback)",
    "136": "android.graphics.Bitmap snapshotTaskForRecents(int)",
    "137": "void setRecentsAppBehindSystemBars(boolean)",
    "138": "int getLetterboxBackgroundColorInArgb()",
    "139": "boolean isLetterboxBackgroundMultiColored()",
    "140": "void captureDisplay(int, android.window.ScreenCapture$CaptureArgs, android.window.ScreenCapture$ScreenCaptureListener)",
    "141": "boolean isGlobalKey(int)",
    "142": "boolean addToSurfaceSyncGroup(android.os.IBinder, boolean, android.window.ISurfaceSyncGroupCompletedListener, android.window.AddToSurfaceSyncGroupResult)",
    "143": "void markSurfaceSyncGroupReady(android.os.IBinder)",
    "144": "java.util.List notifyScreenshotListeners(int)"
  },
  "android.safetycenter.ISafetyCenterManager": {
    "1": "boolean isSafetyCenterEnabled()",
    "2": "void setSafetySourceData(java.lang.String, android.safetycenter.SafetySourceData, android.safetycenter.SafetyEvent, java.lang.String, int)",
    "3": "android.safetycenter.SafetySourceData getSafetySourceData(java.lang.String, java.lang.String, int)",
    "4": "void reportSafetySourceError(java.lang.String, android.safetycenter.SafetySourceErrorDetails, java.lang.String, int)",
    "5": "void refreshSafetySources(int, int)",
    "6": "void refreshSpecificSafetySources(int, int, java.util.List)",
    "7": "android.safetycenter.config.SafetyCenterConfig getSafetyCenterConfig()",
    "8": "android.safetycenter.SafetyCenterData getSafetyCenterData(java.lang.String, int)",
    "9": "void addOnSafetyCenterDataChangedListener(android.safetycenter.IOnSafetyCenterDataChangedListener, java.lang.String, int)",
    "10": "void removeOnSafetyCenterDataChangedListener(android.safetycenter.IOnSafetyCenterDataChangedListener, int)",
    "11": "void dismissSafetyCenterIssue(java.lang.String, int)",
    "12": "void executeSafetyCenterIssueAction(java.lang.String, java.lang.String, int)",
    "13": "void clearAllSafetySourceDataForTests()",
    "14": "void setSafetyCenterConfigForTests(android.safetycenter.config.SafetyCenterConfig)",
    "15": "void clearSafetyCenterConfigForTests()"
  },
  "android.os.incremental.IIncrementalService": {
    "1": "int openStorage(java.lang.String)",
    "2": "int createStorage(java.lang.String, android.content.pm.DataLoaderParamsParcel, int)",
    "3": "int createLinkedStorage(java.lang.String, int, int)",
    "4": "boolean startLoading(int, android.content.pm.DataLoaderParamsParcel, android.content.pm.IDataLoaderStatusListener, android.os.incremental.StorageHealthCheckParams, android.os.incremental.IStorageHealthListener, [Landroid.os.incremental.PerUidReadTimeouts;)",
    "5": "void onInstallationComplete(int)",
    "6": "int makeBindMount(int, java.lang.String, java.lang.String, int)",
    "7": "int deleteBindMount(int, java.lang.String)",
    "8": "int makeDirectory(int, java.lang.String)",
    "9": "int makeDirectories(int, java.lang.String)",
    "10": "int makeFile(int, java.lang.String, int, android.os.incremental.IncrementalNewFileParams, [B)",
    "11": "int makeFileFromRange(int, java.lang.String, java.lang.String, long, long)",
    "12": "int makeLink(int, java.lang.String, int, java.lang.String)",
    "13": "int unlink(int, java.lang.String)",
    "14": "int isFileFullyLoaded(int, java.lang.String)",
    "15": "int isFullyLoaded(int)",
    "16": "float getLoadingProgress(int)",
    "17": "[B getMetadataByPath(int, java.lang.String)",
    "18": "[B getMetadataById(int, [B)",
    "19": "void deleteStorage(int)",
    "20": "void disallowReadLogs(int)",
    "21": "boolean configureNativeBinaries(int, java.lang.String, java.lang.String, java.lang.String, boolean)",
    "22": "boolean waitForNativeBinariesExtraction(int)",
    "23": "boolean registerLoadingProgressListener(int, android.os.incremental.IStorageLoadingProgressListener)",
    "24": "boolean unregisterLoadingProgressListener(int)",
    "25": "android.os.PersistableBundle getMetrics(int)"
  },
  "android.os.IHintManager": {
    "1": "android.os.IHintSession createHintSession(android.os.IBinder, [I, long)",
    "2": "long getHintSessionPreferredRate()",
    "3": "void setHintSessionThreads(android.os.IHintSession, [I)",
    "4": "[I getHintSessionThreadIds(android.os.IHintSession)"
  },
  "android.view.translation.ITranslationManager": {
    "1": "void onTranslationCapabilitiesRequest(int, int, android.os.ResultReceiver, int)",
    "2": "void registerTranslationCapabilityCallback(android.os.IRemoteCallback, int)",
    "3": "void unregisterTranslationCapabilityCallback(android.os.IRemoteCallback, int)",
    "4": "void onSessionCreated(android.view.translation.TranslationContext, int, com.android.internal.os.IResultReceiver, int)",
    "5": "void updateUiTranslationState(int, android.view.translation.TranslationSpec, android.view.translation.TranslationSpec, java.util.List, android.os.IBinder, int, android.view.translation.UiTranslationSpec, int)",
    "6": "void registerUiTranslationStateCallback(android.os.IRemoteCallback, int)",
    "7": "void unregisterUiTranslationStateCallback(android.os.IRemoteCallback, int)",
    "8": "void getServiceSettingsActivity(com.android.internal.os.IResultReceiver, int)",
    "9": "void onTranslationFinished(boolean, android.os.IBinder, android.content.ComponentName, int)"
  },
  "com.android.internal.telephony.IMms": {
    "1": "void sendMessage(int, java.lang.String, android.net.Uri, java.lang.String, android.os.Bundle, android.app.PendingIntent, long, java.lang.String)",
    "2": "void downloadMessage(int, java.lang.String, java.lang.String, android.net.Uri, android.os.Bundle, android.app.PendingIntent, long, java.lang.String)",
    "3": "android.net.Uri importTextMessage(java.lang.String, java.lang.String, int, java.lang.String, long, boolean, boolean)",
    "4": "android.net.Uri importMultimediaMessage(java.lang.String, android.net.Uri, java.lang.String, long, boolean, boolean)",
    "5": "boolean deleteStoredMessage(java.lang.String, android.net.Uri)",
    "6": "boolean deleteStoredConversation(java.lang.String, long)",
    "7": "boolean updateStoredMessageStatus(java.lang.String, android.net.Uri, android.content.ContentValues)",
    "8": "boolean archiveStoredConversation(java.lang.String, long, boolean)",
    "9": "android.net.Uri addTextMessageDraft(java.lang.String, java.lang.String, java.lang.String)",
    "10": "android.net.Uri addMultimediaMessageDraft(java.lang.String, android.net.Uri)",
    "11": "void sendStoredMessage(int, java.lang.String, android.net.Uri, android.os.Bundle, android.app.PendingIntent)",
    "12": "void setAutoPersisting(java.lang.String, boolean)",
    "13": "boolean getAutoPersisting()"
  },
  "android.app.backup.IBackupManager": {
    "1": "void dataChangedForUser(int, java.lang.String)",
    "2": "void dataChanged(java.lang.String)",
    "3": "void clearBackupDataForUser(int, java.lang.String, java.lang.String)",
    "4": "void clearBackupData(java.lang.String, java.lang.String)",
    "5": "void initializeTransportsForUser(int, [Ljava.lang.String;, android.app.backup.IBackupObserver)",
    "6": "void agentConnectedForUser(int, java.lang.String, android.os.IBinder)",
    "7": "void agentConnected(java.lang.String, android.os.IBinder)",
    "8": "void agentDisconnectedForUser(int, java.lang.String)",
    "9": "void agentDisconnected(java.lang.String)",
    "10": "void restoreAtInstallForUser(int, java.lang.String, int)",
    "11": "void restoreAtInstall(java.lang.String, int)",
    "12": "void setBackupEnabledForUser(int, boolean)",
    "13": "void setFrameworkSchedulingEnabledForUser(int, boolean)",
    "14": "void setBackupEnabled(boolean)",
    "15": "void setAutoRestoreForUser(int, boolean)",
    "16": "void setAutoRestore(boolean)",
    "17": "boolean isBackupEnabledForUser(int)",
    "18": "boolean isBackupEnabled()",
    "19": "boolean setBackupPassword(java.lang.String, java.lang.String)",
    "20": "boolean hasBackupPassword()",
    "21": "void backupNowForUser(int)",
    "22": "void backupNow()",
    "23": "void adbBackup(int, android.os.ParcelFileDescriptor, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, [Ljava.lang.String;)",
    "24": "void fullTransportBackupForUser(int, [Ljava.lang.String;)",
    "25": "void adbRestore(int, android.os.ParcelFileDescriptor)",
    "26": "void acknowledgeFullBackupOrRestoreForUser(int, int, boolean, java.lang.String, java.lang.String, android.app.backup.IFullBackupRestoreObserver)",
    "27": "void acknowledgeFullBackupOrRestore(int, boolean, java.lang.String, java.lang.String, android.app.backup.IFullBackupRestoreObserver)",
    "28": "void updateTransportAttributesForUser(int, android.content.ComponentName, java.lang.String, android.content.Intent, java.lang.String, android.content.Intent, java.lang.CharSequence)",
    "29": "java.lang.String getCurrentTransportForUser(int)",
    "30": "java.lang.String getCurrentTransport()",
    "31": "android.content.ComponentName getCurrentTransportComponentForUser(int)",
    "32": "[Ljava.lang.String; listAllTransportsForUser(int)",
    "33": "[Ljava.lang.String; listAllTransports()",
    "34": "[Landroid.content.ComponentName; listAllTransportComponentsForUser(int)",
    "35": "[Ljava.lang.String; getTransportWhitelist()",
    "36": "java.lang.String selectBackupTransportForUser(int, java.lang.String)",
    "37": "java.lang.String selectBackupTransport(java.lang.String)",
    "38": "void selectBackupTransportAsyncForUser(int, android.content.ComponentName, android.app.backup.ISelectBackupTransportCallback)",
    "39": "android.content.Intent getConfigurationIntentForUser(int, java.lang.String)",
    "40": "android.content.Intent getConfigurationIntent(java.lang.String)",
    "41": "java.lang.String getDestinationStringForUser(int, java.lang.String)",
    "42": "java.lang.String getDestinationString(java.lang.String)",
    "43": "android.content.Intent getDataManagementIntentForUser(int, java.lang.String)",
    "44": "android.content.Intent getDataManagementIntent(java.lang.String)",
    "45": "java.lang.CharSequence getDataManagementLabelForUser(int, java.lang.String)",
    "46": "android.app.backup.IRestoreSession beginRestoreSessionForUser(int, java.lang.String, java.lang.String)",
    "47": "void opCompleteForUser(int, int, long)",
    "48": "void opComplete(int, long)",
    "49": "void setBackupServiceActive(int, boolean)",
    "50": "boolean isBackupServiceActive(int)",
    "51": "boolean isUserReadyForBackup(int)",
    "52": "long getAvailableRestoreTokenForUser(int, java.lang.String)",
    "53": "boolean isAppEligibleForBackupForUser(int, java.lang.String)",
    "54": "[Ljava.lang.String; filterAppsEligibleForBackupForUser(int, [Ljava.lang.String;)",
    "55": "int requestBackupForUser(int, [Ljava.lang.String;, android.app.backup.IBackupObserver, android.app.backup.IBackupManagerMonitor, int)",
    "56": "int requestBackup([Ljava.lang.String;, android.app.backup.IBackupObserver, android.app.backup.IBackupManagerMonitor, int)",
    "57": "void cancelBackupsForUser(int)",
    "58": "void cancelBackups()",
    "59": "android.os.UserHandle getUserForAncestralSerialNumber(long)",
    "60": "void setAncestralSerialNumber(long)",
    "61": "void excludeKeysFromRestore(java.lang.String, java.util.List)",
    "62": "void reportDelayedRestoreResult(java.lang.String, java.util.List)"
  },
  "android.os.IDeviceIdleController": {
    "1": "void addPowerSaveWhitelistApp(java.lang.String)",
    "2": "int addPowerSaveWhitelistApps(java.util.List)",
    "3": "void removePowerSaveWhitelistApp(java.lang.String)",
    "4": "void removeSystemPowerWhitelistApp(java.lang.String)",
    "5": "void restoreSystemPowerWhitelistApp(java.lang.String)",
    "6": "[Ljava.lang.String; getRemovedSystemPowerWhitelistApps()",
    "7": "[Ljava.lang.String; getSystemPowerWhitelistExceptIdle()",
    "8": "[Ljava.lang.String; getSystemPowerWhitelist()",
    "9": "[Ljava.lang.String; getUserPowerWhitelist()",
    "10": "[Ljava.lang.String; getFullPowerWhitelistExceptIdle()",
    "11": "[Ljava.lang.String; getFullPowerWhitelist()",
    "12": "[I getAppIdWhitelistExceptIdle()",
    "13": "[I getAppIdWhitelist()",
    "14": "[I getAppIdUserWhitelist()",
    "15": "[I getAppIdTempWhitelist()",
    "16": "boolean isPowerSaveWhitelistExceptIdleApp(java.lang.String)",
    "17": "boolean isPowerSaveWhitelistApp(java.lang.String)",
    "18": "void addPowerSaveTempWhitelistApp(java.lang.String, long, int, int, java.lang.String)",
    "19": "long addPowerSaveTempWhitelistAppForMms(java.lang.String, int, int, java.lang.String)",
    "20": "long addPowerSaveTempWhitelistAppForSms(java.lang.String, int, int, java.lang.String)",
    "21": "long whitelistAppTemporarily(java.lang.String, int, int, java.lang.String)",
    "22": "void exitIdle(java.lang.String)",
    "23": "int setPreIdleTimeoutMode(int)",
    "24": "void resetPreIdleTimeoutMode()"
  },
  "com.android.internal.graphics.fonts.IFontManager": {
    "1": "android.text.FontConfig getFontConfig()",
    "2": "int updateFontFamily(java.util.List, int)"
  },
  "android.os.image.IDynamicSystemService": {
    "1": "boolean startInstallation(java.lang.String)",
    "2": "int createPartition(java.lang.String, long, boolean)",
    "3": "boolean closePartition()",
    "4": "boolean finishInstallation()",
    "5": "android.gsi.GsiProgress getInstallationProgress()",
    "6": "boolean abort()",
    "7": "boolean isInUse()",
    "8": "boolean isInstalled()",
    "9": "boolean isEnabled()",
    "10": "boolean remove()",
    "11": "boolean setEnable(boolean, boolean)",
    "12": "boolean setAshmem(android.os.ParcelFileDescriptor, long)",
    "13": "boolean submitFromAshmem(long)",
    "14": "boolean getAvbPublicKey(android.gsi.AvbPublicKey)",
    "15": "long suggestScratchSize()"
  },
  "android.os.logcat.ILogcatManagerService": {
    "1": "void startThread(int, int, int, int)",
    "2": "void finishThread(int, int, int, int)"
  },
  "android.app.appsearch.aidl.IAppSearchManager": {
    "1": "void initialize(android.content.AttributionSource, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "2": "void setSchema(android.content.AttributionSource, java.lang.String, java.util.List, java.util.List, boolean, int, android.os.UserHandle, long, int, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "3": "void getSchema(android.content.AttributionSource, java.lang.String, java.lang.String, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "4": "void getNamespaces(android.content.AttributionSource, java.lang.String, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "5": "void putDocuments(android.content.AttributionSource, java.lang.String, android.app.appsearch.aidl.DocumentsParcel, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchBatchResultCallback)",
    "6": "void getDocuments(android.content.AttributionSource, java.lang.String, java.lang.String, java.lang.String, java.util.List, java.util.Map, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchBatchResultCallback)",
    "7": "void query(android.content.AttributionSource, java.lang.String, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "8": "void globalQuery(android.content.AttributionSource, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "9": "void getNextPage(android.content.AttributionSource, java.lang.String, long, int, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "10": "void invalidateNextPageToken(android.content.AttributionSource, long, android.os.UserHandle, long)",
    "11": "void writeQueryResultsToFile(android.content.AttributionSource, java.lang.String, android.os.ParcelFileDescriptor, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "12": "void putDocumentsFromFile(android.content.AttributionSource, java.lang.String, android.os.ParcelFileDescriptor, android.os.UserHandle, android.os.Bundle, long, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "13": "void searchSuggestion(android.content.AttributionSource, java.lang.String, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "14": "void reportUsage(android.content.AttributionSource, java.lang.String, java.lang.String, java.lang.String, java.lang.String, long, boolean, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "15": "void removeByDocumentId(android.content.AttributionSource, java.lang.String, java.lang.String, java.util.List, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchBatchResultCallback)",
    "16": "void removeByQuery(android.content.AttributionSource, java.lang.String, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "17": "void getStorageInfo(android.content.AttributionSource, java.lang.String, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchResultCallback)",
    "18": "void persistToDisk(android.content.AttributionSource, android.os.UserHandle, long)",
    "19": "android.app.appsearch.aidl.AppSearchResultParcel registerObserverCallback(android.content.AttributionSource, java.lang.String, android.os.Bundle, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchObserverProxy)",
    "20": "android.app.appsearch.aidl.AppSearchResultParcel unregisterObserverCallback(android.content.AttributionSource, java.lang.String, android.os.UserHandle, long, android.app.appsearch.aidl.IAppSearchObserverProxy)"
  },
  "com.android.internal.telephony.ICarrierConfigLoader": {
    "1": "android.os.PersistableBundle getConfigForSubId(int, java.lang.String)",
    "2": "android.os.PersistableBundle getConfigForSubIdWithFeature(int, java.lang.String, java.lang.String)",
    "3": "void overrideConfig(int, android.os.PersistableBundle, boolean)",
    "4": "void notifyConfigChangedForSubId(int)",
    "5": "void updateConfigForPhoneId(int, java.lang.String)",
    "6": "java.lang.String getDefaultCarrierServicePackageName()",
    "7": "android.os.PersistableBundle getConfigSubsetForSubIdWithFeature(int, java.lang.String, java.lang.String, [Ljava.lang.String;)"
  },
  "android.hardware.ISensorPrivacyManager": {
    "1": "boolean supportsSensorToggle(int, int)",
    "2": "void addSensorPrivacyListener(android.hardware.ISensorPrivacyListener)",
    "3": "void addToggleSensorPrivacyListener(android.hardware.ISensorPrivacyListener)",
    "4": "void removeSensorPrivacyListener(android.hardware.ISensorPrivacyListener)",
    "5": "void removeToggleSensorPrivacyListener(android.hardware.ISensorPrivacyListener)",
    "6": "boolean isSensorPrivacyEnabled()",
    "7": "boolean isCombinedToggleSensorPrivacyEnabled(int)",
    "8": "boolean isToggleSensorPrivacyEnabled(int, int)",
    "9": "void setSensorPrivacy(boolean)",
    "10": "void setToggleSensorPrivacy(int, int, int, boolean)",
    "11": "void setToggleSensorPrivacyForProfileGroup(int, int, int, boolean)",
    "12": "void suppressToggleSensorPrivacyReminders(int, int, android.os.IBinder, boolean)",
    "13": "boolean requiresAuthentication()",
    "14": "void showSensorUseDialog(int)"
  },
  "android.speech.tts.ITextToSpeechManager": {
    "1": "void createSession(java.lang.String, android.speech.tts.ITextToSpeechSessionCallback)"
  },
  "android.hardware.display.IColorDisplayManager": {
    "1": "boolean isDeviceColorManaged()",
    "2": "boolean setSaturationLevel(int)",
    "3": "boolean setAppSaturationLevel(java.lang.String, int)",
    "4": "boolean isSaturationActivated()",
    "5": "int getTransformCapabilities()",
    "6": "boolean isNightDisplayActivated()",
    "7": "boolean setNightDisplayActivated(boolean)",
    "8": "int getNightDisplayColorTemperature()",
    "9": "boolean setNightDisplayColorTemperature(int)",
    "10": "int getNightDisplayAutoMode()",
    "11": "int getNightDisplayAutoModeRaw()",
    "12": "boolean setNightDisplayAutoMode(int)",
    "13": "android.hardware.display.Time getNightDisplayCustomStartTime()",
    "14": "boolean setNightDisplayCustomStartTime(android.hardware.display.Time)",
    "15": "android.hardware.display.Time getNightDisplayCustomEndTime()",
    "16": "boolean setNightDisplayCustomEndTime(android.hardware.display.Time)",
    "17": "int getColorMode()",
    "18": "void setColorMode(int)",
    "19": "boolean isDisplayWhiteBalanceEnabled()",
    "20": "boolean setDisplayWhiteBalanceEnabled(boolean)",
    "21": "boolean isReduceBrightColorsActivated()",
    "22": "boolean setReduceBrightColorsActivated(boolean)",
    "23": "int getReduceBrightColorsStrength()",
    "24": "boolean setReduceBrightColorsStrength(int)",
    "25": "float getReduceBrightColorsOffsetFactor()"
  },
  "android.speech.IRecognitionServiceManager": {
    "1": "void createSession(android.content.ComponentName, android.os.IBinder, boolean, android.speech.IRecognitionServiceManagerCallback)",
    "2": "void setTemporaryComponent(android.content.ComponentName)"
  },
  "android.os.IStatsBootstrapAtomService": {
    "1": "void reportBootstrapAtom(android.os.StatsBootstrapAtom)"
  },
  "android.content.om.IOverlayManager": {
    "1": "java.util.Map getAllOverlays(int)",
    "2": "java.util.List getOverlayInfosForTarget(java.lang.String, int)",
    "3": "android.content.om.OverlayInfo getOverlayInfo(java.lang.String, int)",
    "4": "android.content.om.OverlayInfo getOverlayInfoByIdentifier(android.content.om.OverlayIdentifier, int)",
    "5": "boolean setEnabled(java.lang.String, boolean, int)",
    "6": "boolean setEnabledExclusive(java.lang.String, boolean, int)",
    "7": "boolean setEnabledExclusiveInCategory(java.lang.String, int)",
    "8": "boolean setPriority(java.lang.String, java.lang.String, int)",
    "9": "boolean setHighestPriority(java.lang.String, int)",
    "10": "boolean setLowestPriority(java.lang.String, int)",
    "11": "[Ljava.lang.String; getDefaultOverlayPackages()",
    "12": "void invalidateCachesForOverlay(java.lang.String, int)",
    "13": "void commit(android.content.om.OverlayManagerTransaction)"
  },
  "com.android.internal.os.IDropBoxManagerService": {
    "1": "void addData(java.lang.String, [B, int)",
    "2": "void addFile(java.lang.String, android.os.ParcelFileDescriptor, int)",
    "3": "boolean isTagEnabled(java.lang.String)",
    "4": "android.os.DropBoxManager$Entry getNextEntry(java.lang.String, long, java.lang.String)",
    "5": "android.os.DropBoxManager$Entry getNextEntryWithAttribution(java.lang.String, long, java.lang.String, java.lang.String)"
  },
  "android.net.IConnectivityManager": {
    "1": "android.net.Network getActiveNetwork()",
    "2": "android.net.Network getActiveNetworkForUid(int, boolean)",
    "3": "android.net.NetworkInfo getActiveNetworkInfo()",
    "4": "android.net.NetworkInfo getActiveNetworkInfoForUid(int, boolean)",
    "5": "android.net.NetworkInfo getNetworkInfo(int)",
    "6": "android.net.NetworkInfo getNetworkInfoForUid(android.net.Network, int, boolean)",
    "7": "[Landroid.net.NetworkInfo; getAllNetworkInfo()",
    "8": "android.net.Network getNetworkForType(int)",
    "9": "[Landroid.net.Network; getAllNetworks()",
    "10": "[Landroid.net.NetworkCapabilities; getDefaultNetworkCapabilitiesForUser(int, java.lang.String, java.lang.String)",
    "11": "boolean isNetworkSupported(int)",
    "12": "android.net.LinkProperties getActiveLinkProperties()",
    "13": "android.net.LinkProperties getLinkPropertiesForType(int)",
    "14": "android.net.LinkProperties getLinkProperties(android.net.Network)",
    "15": "android.net.LinkProperties getRedactedLinkPropertiesForPackage(android.net.LinkProperties, int, java.lang.String, java.lang.String)",
    "16": "android.net.NetworkCapabilities getNetworkCapabilities(android.net.Network, java.lang.String, java.lang.String)",
    "17": "android.net.NetworkCapabilities getRedactedNetworkCapabilitiesForPackage(android.net.NetworkCapabilities, int, java.lang.String, java.lang.String)",
    "18": "[Landroid.net.NetworkState; getAllNetworkState()",
    "19": "java.util.List getAllNetworkStateSnapshots()",
    "20": "boolean isActiveNetworkMetered()",
    "21": "boolean requestRouteToHostAddress(int, [B, java.lang.String, java.lang.String)",
    "22": "int getLastTetherError(java.lang.String)",
    "23": "[Ljava.lang.String; getTetherableIfaces()",
    "24": "[Ljava.lang.String; getTetheredIfaces()",
    "25": "[Ljava.lang.String; getTetheringErroredIfaces()",
    "26": "[Ljava.lang.String; getTetherableUsbRegexs()",
    "27": "[Ljava.lang.String; getTetherableWifiRegexs()",
    "28": "void reportInetCondition(int, int)",
    "29": "void reportNetworkConnectivity(android.net.Network, boolean)",
    "30": "android.net.ProxyInfo getGlobalProxy()",
    "31": "void setGlobalProxy(android.net.ProxyInfo)",
    "32": "android.net.ProxyInfo getProxyForNetwork(android.net.Network)",
    "33": "void setRequireVpnForUids(boolean, [Landroid.net.UidRange;)",
    "34": "void setLegacyLockdownVpnEnabled(boolean)",
    "35": "void setProvisioningNotificationVisible(boolean, int, java.lang.String)",
    "36": "void setAirplaneMode(boolean)",
    "37": "boolean requestBandwidthUpdate(android.net.Network)",
    "38": "int registerNetworkProvider(android.os.Messenger, java.lang.String)",
    "39": "void unregisterNetworkProvider(android.os.Messenger)",
    "40": "void declareNetworkRequestUnfulfillable(android.net.NetworkRequest)",
    "41": "android.net.Network registerNetworkAgent(android.net.INetworkAgent, android.net.NetworkInfo, android.net.LinkProperties, android.net.NetworkCapabilities, android.net.NetworkScore, android.net.NetworkAgentConfig, int)",
    "42": "android.net.NetworkRequest requestNetwork(int, android.net.NetworkCapabilities, int, android.os.Messenger, int, android.os.IBinder, int, int, java.lang.String, java.lang.String)",
    "43": "android.net.NetworkRequest pendingRequestForNetwork(android.net.NetworkCapabilities, android.app.PendingIntent, java.lang.String, java.lang.String)",
    "44": "void releasePendingNetworkRequest(android.app.PendingIntent)",
    "45": "android.net.NetworkRequest listenForNetwork(android.net.NetworkCapabilities, android.os.Messenger, android.os.IBinder, int, java.lang.String, java.lang.String)",
    "46": "void pendingListenForNetwork(android.net.NetworkCapabilities, android.app.PendingIntent, java.lang.String, java.lang.String)",
    "47": "void releaseNetworkRequest(android.net.NetworkRequest)",
    "48": "void setAcceptUnvalidated(android.net.Network, boolean, boolean)",
    "49": "void setAcceptPartialConnectivity(android.net.Network, boolean, boolean)",
    "50": "void setAvoidUnvalidated(android.net.Network)",
    "51": "void startCaptivePortalApp(android.net.Network)",
    "52": "void startCaptivePortalAppInternal(android.net.Network, android.os.Bundle)",
    "53": "boolean shouldAvoidBadWifi()",
    "54": "int getMultipathPreference(android.net.Network)",
    "55": "android.net.NetworkRequest getDefaultRequest()",
    "56": "int getRestoreDefaultNetworkDelay(int)",
    "57": "void factoryReset()",
    "58": "void startNattKeepalive(android.net.Network, int, android.net.connectivity.android.net.ISocketKeepaliveCallback, java.lang.String, int, java.lang.String)",
    "59": "void startNattKeepaliveWithFd(android.net.Network, android.os.ParcelFileDescriptor, int, int, android.net.connectivity.android.net.ISocketKeepaliveCallback, java.lang.String, java.lang.String, boolean, android.net.Network)",
    "60": "void startTcpKeepalive(android.net.Network, android.os.ParcelFileDescriptor, int, android.net.connectivity.android.net.ISocketKeepaliveCallback)",
    "61": "void stopKeepalive(android.net.connectivity.android.net.ISocketKeepaliveCallback)",
    "62": "[I getSupportedKeepalives()",
    "63": "java.lang.String getCaptivePortalServerUrl()",
    "64": "[B getNetworkWatchlistConfigHash()",
    "65": "int getConnectionOwnerUid(android.net.connectivity.android.net.ConnectionInfo)",
    "66": "void registerConnectivityDiagnosticsCallback(android.net.IConnectivityDiagnosticsCallback, android.net.NetworkRequest, java.lang.String)",
    "67": "void unregisterConnectivityDiagnosticsCallback(android.net.IConnectivityDiagnosticsCallback)",
    "68": "android.os.IBinder startOrGetTestNetworkService()",
    "69": "void simulateDataStall(int, long, android.net.Network, android.os.PersistableBundle)",
    "70": "void systemReady()",
    "71": "void registerNetworkActivityListener(android.net.connectivity.android.net.INetworkActivityListener)",
    "72": "void unregisterNetworkActivityListener(android.net.connectivity.android.net.INetworkActivityListener)",
    "73": "boolean isDefaultNetworkActive()",
    "74": "void registerQosSocketCallback(android.net.QosSocketInfo, android.net.connectivity.android.net.IQosCallback)",
    "75": "void unregisterQosCallback(android.net.connectivity.android.net.IQosCallback)",
    "76": "void setOemNetworkPreference(android.net.OemNetworkPreferences, android.net.connectivity.android.net.IOnCompleteListener)",
    "77": "void setProfileNetworkPreferences(android.os.UserHandle, java.util.List, android.net.connectivity.android.net.IOnCompleteListener)",
    "78": "int getRestrictBackgroundStatusByCaller()",
    "79": "void offerNetwork(int, android.net.NetworkScore, android.net.NetworkCapabilities, android.net.connectivity.android.net.INetworkOfferCallback)",
    "80": "void unofferNetwork(android.net.connectivity.android.net.INetworkOfferCallback)",
    "81": "void setTestAllowBadWifiUntil(long)",
    "82": "void updateMeteredNetworkAllowList(int, boolean)",
    "83": "void updateMeteredNetworkDenyList(int, boolean)",
    "84": "void setUidFirewallRule(int, int, int)",
    "85": "int getUidFirewallRule(int, int)",
    "86": "void setFirewallChainEnabled(int, boolean)",
    "87": "boolean getFirewallChainEnabled(int)",
    "88": "void replaceFirewallChain(int, [I)",
    "89": "android.os.IBinder getCompanionDeviceManagerProxyService()",
    "90": "void setVpnNetworkPreference(java.lang.String, [Landroid.net.UidRange;)",
    "91": "void setTestLowTcpPollingTimerForKeepalive(long)"
  },
  "android.permission.IPermissionChecker": {
    "1": "1",
    "2": "2",
    "3": "3"
  },
  "android.hardware.biometrics.IBiometricService": {
    "1": "android.hardware.biometrics.ITestSession createTestSession(int, android.hardware.biometrics.ITestSessionCallback, java.lang.String)",
    "2": "java.util.List getSensorProperties(java.lang.String)",
    "3": "long authenticate(android.os.IBinder, long, int, android.hardware.biometrics.IBiometricServiceReceiver, java.lang.String, android.hardware.biometrics.PromptInfo)",
    "4": "void cancelAuthentication(android.os.IBinder, java.lang.String, long)",
    "5": "int canAuthenticate(java.lang.String, int, int, int)",
    "6": "boolean hasEnrolledBiometrics(int, java.lang.String)",
    "7": "void registerAuthenticator(int, int, int, android.hardware.biometrics.IBiometricAuthenticator)",
    "8": "void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback)",
    "9": "void onReadyForAuthentication(long, int)",
    "10": "void invalidateAuthenticatorIds(int, int, android.hardware.biometrics.IInvalidationCallback)",
    "11": "[J getAuthenticatorIds(int)",
    "12": "void resetLockoutTimeBound(android.os.IBinder, java.lang.String, int, int, [B)",
    "13": "void resetLockout(int, [B)",
    "14": "int getCurrentStrength(int)",
    "15": "int getCurrentModality(java.lang.String, int, int, int)",
    "16": "int getSupportedModalities(int)"
  },
  "android.net.wifi.IWifiScanner": {
    "1": "android.os.Bundle getAvailableChannels(int, java.lang.String, java.lang.String, android.os.Bundle)",
    "2": "boolean isScanning()",
    "3": "boolean setScanningEnabled(boolean, int, java.lang.String)",
    "4": "void registerScanListener(android.net.wifi.IWifiScannerListener, java.lang.String, java.lang.String)",
    "5": "void unregisterScanListener(android.net.wifi.IWifiScannerListener, java.lang.String, java.lang.String)",
    "6": "void startBackgroundScan(android.net.wifi.IWifiScannerListener, android.net.wifi.WifiScanner$ScanSettings, android.os.WorkSource, java.lang.String, java.lang.String)",
    "7": "void stopBackgroundScan(android.net.wifi.IWifiScannerListener, java.lang.String, java.lang.String)",
    "8": "boolean getScanResults(java.lang.String, java.lang.String)",
    "9": "void startScan(android.net.wifi.IWifiScannerListener, android.net.wifi.WifiScanner$ScanSettings, android.os.WorkSource, java.lang.String, java.lang.String)",
    "10": "void stopScan(android.net.wifi.IWifiScannerListener, java.lang.String, java.lang.String)",
    "11": "java.util.List getSingleScanResults(java.lang.String, java.lang.String)",
    "12": "void startPnoScan(android.net.wifi.IWifiScannerListener, android.net.wifi.WifiScanner$ScanSettings, android.net.wifi.WifiScanner$PnoSettings, java.lang.String, java.lang.String)",
    "13": "void stopPnoScan(android.net.wifi.IWifiScannerListener, java.lang.String, java.lang.String)",
    "14": "void enableVerboseLogging(boolean)"
  },
  "android.view.autofill.IAutoFillManager": {
    "1": "void addClient(android.view.autofill.IAutoFillManagerClient, android.content.ComponentName, int, com.android.internal.os.IResultReceiver)",
    "2": "void removeClient(android.view.autofill.IAutoFillManagerClient, int)",
    "3": "void startSession(android.os.IBinder, android.os.IBinder, android.view.autofill.AutofillId, android.graphics.Rect, android.view.autofill.AutofillValue, int, boolean, int, android.content.ComponentName, boolean, com.android.internal.os.IResultReceiver)",
    "4": "void getFillEventHistory(com.android.internal.os.IResultReceiver)",
    "5": "void restoreSession(int, android.os.IBinder, android.os.IBinder, com.android.internal.os.IResultReceiver)",
    "6": "void updateSession(int, android.view.autofill.AutofillId, android.graphics.Rect, android.view.autofill.AutofillValue, int, int, int)",
    "7": "void setAutofillFailure(int, java.util.List, int)",
    "8": "void finishSession(int, int, int)",
    "9": "void cancelSession(int, int)",
    "10": "void setAuthenticationResult(android.os.Bundle, int, int, int)",
    "11": "void setHasCallback(int, int, boolean)",
    "12": "void disableOwnedAutofillServices(int)",
    "13": "void isServiceSupported(int, com.android.internal.os.IResultReceiver)",
    "14": "void isServiceEnabled(int, java.lang.String, com.android.internal.os.IResultReceiver)",
    "15": "void onPendingSaveUi(int, android.os.IBinder)",
    "16": "void getUserData(com.android.internal.os.IResultReceiver)",
    "17": "void getUserDataId(com.android.internal.os.IResultReceiver)",
    "18": "void setUserData(android.service.autofill.UserData)",
    "19": "void isFieldClassificationEnabled(com.android.internal.os.IResultReceiver)",
    "20": "void getAutofillServiceComponentName(com.android.internal.os.IResultReceiver)",
    "21": "void getAvailableFieldClassificationAlgorithms(com.android.internal.os.IResultReceiver)",
    "22": "void getDefaultFieldClassificationAlgorithm(com.android.internal.os.IResultReceiver)",
    "23": "void setAugmentedAutofillWhitelist(java.util.List, java.util.List, com.android.internal.os.IResultReceiver)"
  },
  "android.net.INetworkStatsService": {
    "1": "android.net.INetworkStatsSession openSession()",
    "2": "android.net.INetworkStatsSession openSessionForUsageStats(int, java.lang.String)",
    "3": "android.net.NetworkStats getDataLayerSnapshotForUid(int)",
    "4": "android.net.NetworkStats getUidStatsForTransport(int)",
    "5": "[Ljava.lang.String; getMobileIfaces()",
    "6": "void incrementOperationCount(int, int, int)",
    "7": "void notifyNetworkStatus([Landroid.net.Network;, [Landroid.net.NetworkStateSnapshot;, java.lang.String, [Landroid.net.UnderlyingNetworkInfo;)",
    "8": "void forceUpdate()",
    "9": "android.net.DataUsageRequest registerUsageCallback(java.lang.String, android.net.DataUsageRequest, android.net.connectivity.android.net.netstats.IUsageCallback)",
    "10": "void unregisterUsageRequest(android.net.DataUsageRequest)",
    "11": "long getUidStats(int, int)",
    "12": "long getIfaceStats(java.lang.String, int)",
    "13": "long getTotalStats(int)",
    "14": "android.net.netstats.provider.INetworkStatsProviderCallback registerNetworkStatsProvider(java.lang.String, android.net.netstats.provider.INetworkStatsProvider)",
    "15": "void noteUidForeground(int, boolean)",
    "16": "void advisePersistThreshold(long)",
    "17": "void setStatsProviderWarningAndLimitAsync(java.lang.String, long, long)"
  },
  "android.view.selectiontoolbar.ISelectionToolbarManager": {
    "1": "void showToolbar(android.view.selectiontoolbar.ShowInfo, android.view.selectiontoolbar.ISelectionToolbarCallback, int)",
    "2": "void hideToolbar(long, int)",
    "3": "void dismissToolbar(long, int)"
  },
  "android.app.job.IJobScheduler": {
    "1": "int schedule(java.lang.String, android.app.job.JobInfo)",
    "2": "int enqueue(java.lang.String, android.app.job.JobInfo, android.app.job.JobWorkItem)",
    "3": "int scheduleAsPackage(java.lang.String, android.app.job.JobInfo, java.lang.String, int, java.lang.String)",
    "4": "void cancel(java.lang.String, int)",
    "5": "void cancelAll()",
    "6": "void cancelAllInNamespace(java.lang.String)",
    "7": "java.util.Map getAllPendingJobs()",
    "8": "android.content.pm.ParceledListSlice getAllPendingJobsInNamespace(java.lang.String)",
    "9": "android.app.job.JobInfo getPendingJob(java.lang.String, int)",
    "10": "int getPendingJobReason(java.lang.String, int)",
    "11": "boolean canRunUserInitiatedJobs(java.lang.String)",
    "12": "boolean hasRunUserInitiatedJobsPermission(java.lang.String, int)",
    "13": "java.util.List getStartedJobs()",
    "14": "android.content.pm.ParceledListSlice getAllJobSnapshots()",
    "15": "void registerUserVisibleJobObserver(android.app.job.IUserVisibleJobObserver)",
    "16": "void unregisterUserVisibleJobObserver(android.app.job.IUserVisibleJobObserver)",
    "17": "void notePendingUserRequestedAppStop(java.lang.String, int, java.lang.String)"
  },
  "android.media.IMediaResourceMonitor": {
    "1": "void notifyResourceGranted(int, int)"
  },
  "android.hardware.input.IInputManager": {
    "1": "java.lang.String getVelocityTrackerStrategy()",
    "2": "android.view.InputDevice getInputDevice(int)",
    "3": "[I getInputDeviceIds()",
    "4": "boolean isInputDeviceEnabled(int)",
    "5": "void enableInputDevice(int)",
    "6": "void disableInputDevice(int)",
    "7": "boolean hasKeys(int, int, [I, [Z)",
    "8": "int getKeyCodeForKeyLocation(int, int)",
    "9": "void tryPointerSpeed(int)",
    "10": "boolean injectInputEvent(android.view.InputEvent, int)",
    "11": "boolean injectInputEventToTarget(android.view.InputEvent, int, int)",
    "12": "android.view.VerifiedInputEvent verifyInputEvent(android.view.InputEvent)",
    "13": "android.hardware.input.TouchCalibration getTouchCalibrationForInputDevice(java.lang.String, int)",
    "14": "void setTouchCalibrationForInputDevice(java.lang.String, int, android.hardware.input.TouchCalibration)",
    "15": "[Landroid.hardware.input.KeyboardLayout; getKeyboardLayouts()",
    "16": "[Landroid.hardware.input.KeyboardLayout; getKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)",
    "17": "android.hardware.input.KeyboardLayout getKeyboardLayout(java.lang.String)",
    "18": "java.lang.String getCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier)",
    "19": "void setCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier, java.lang.String)",
    "20": "[Ljava.lang.String; getEnabledKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)",
    "21": "void addKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier, java.lang.String)",
    "22": "void removeKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier, java.lang.String)",
    "23": "java.lang.String getKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier, int, android.view.inputmethod.InputMethodInfo, android.view.inputmethod.InputMethodSubtype)",
    "24": "void setKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier, int, android.view.inputmethod.InputMethodInfo, android.view.inputmethod.InputMethodSubtype, java.lang.String)",
    "25": "[Landroid.hardware.input.KeyboardLayout; getKeyboardLayoutListForInputDevice(android.hardware.input.InputDeviceIdentifier, int, android.view.inputmethod.InputMethodInfo, android.view.inputmethod.InputMethodSubtype)",
    "26": "void remapModifierKey(int, int)",
    "27": "void clearAllModifierKeyRemappings()",
    "28": "java.util.Map getModifierKeyRemapping()",
    "29": "void registerInputDevicesChangedListener(android.hardware.input.IInputDevicesChangedListener)",
    "30": "int isInTabletMode()",
    "31": "void registerTabletModeChangedListener(android.hardware.input.ITabletModeChangedListener)",
    "32": "int isMicMuted()",
    "33": "void vibrate(int, android.os.VibrationEffect, android.os.IBinder)",
    "34": "void vibrateCombined(int, android.os.CombinedVibration, android.os.IBinder)",
    "35": "void cancelVibrate(int, android.os.IBinder)",
    "36": "[I getVibratorIds(int)",
    "37": "boolean isVibrating(int)",
    "38": "boolean registerVibratorStateListener(int, android.os.IVibratorStateListener)",
    "39": "boolean unregisterVibratorStateListener(int, android.os.IVibratorStateListener)",
    "40": "android.hardware.input.IInputDeviceBatteryState getBatteryState(int)",
    "41": "void setPointerIconType(int)",
    "42": "void setCustomPointerIcon(android.view.PointerIcon)",
    "43": "void requestPointerCapture(android.os.IBinder, boolean)",
    "44": "android.view.InputMonitor monitorGestureInput(android.os.IBinder, java.lang.String, int)",
    "45": "void addPortAssociation(java.lang.String, int)",
    "46": "void removePortAssociation(java.lang.String)",
    "47": "void addUniqueIdAssociation(java.lang.String, java.lang.String)",
    "48": "void removeUniqueIdAssociation(java.lang.String)",
    "49": "[Landroid.hardware.input.InputSensorInfo; getSensorList(int)",
    "50": "boolean registerSensorListener(android.hardware.input.IInputSensorEventListener)",
    "51": "void unregisterSensorListener(android.hardware.input.IInputSensorEventListener)",
    "52": "boolean enableSensor(int, int, int, int)",
    "53": "void disableSensor(int, int)",
    "54": "boolean flushSensor(int, int)",
    "55": "java.util.List getLights(int)",
    "56": "android.hardware.lights.LightState getLightState(int, int)",
    "57": "void setLightStates(int, [I, [Landroid.hardware.lights.LightState;, android.os.IBinder)",
    "58": "void openLightSession(int, java.lang.String, android.os.IBinder)",
    "59": "void closeLightSession(int, android.os.IBinder)",
    "60": "void cancelCurrentTouch()",
    "61": "void registerBatteryListener(int, android.hardware.input.IInputDeviceBatteryListener)",
    "62": "void unregisterBatteryListener(int, android.hardware.input.IInputDeviceBatteryListener)",
    "63": "java.lang.String getInputDeviceBluetoothAddress(int)",
    "64": "void pilferPointers(android.os.IBinder)",
    "65": "void registerKeyboardBacklightListener(android.hardware.input.IKeyboardBacklightListener)",
    "66": "void unregisterKeyboardBacklightListener(android.hardware.input.IKeyboardBacklightListener)",
    "67": "android.hardware.input.HostUsiVersion getHostUsiVersionFromDisplayConfig(int)"
  },
  "android.media.IAudioPolicyService": {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "5": "5",
    "6": "6",
    "7": "7",
    "8": "8",
    "9": "9",
    "10": "10",
    "11": "11",
    "12": "12",
    "13": "13",
    "14": "14",
    "15": "15",
    "16": "16",
    "17": "17",
    "18": "18",
    "19": "19",
    "20": "20",
    "21": "21",
    "22": "22",
    "23": "23",
    "24": "24",
    "25": "25",
    "26": "26",
    "27": "27",
    "28": "28",
    "29": "29",
    "30": "30",
    "31": "31",
    "32": "32",
    "33": "33",
    "34": "34",
    "35": "35",
    "36": "36",
    "37": "37",
    "38": "38",
    "39": "39",
    "40": "40",
    "41": "41",
    "42": "42",
    "43": "43",
    "44": "44",
    "45": "45",
    "46": "46",
    "47": "47",
    "48": "48",
    "49": "49",
    "50": "50",
    "51": "51",
    "52": "52",
    "53": "53",
    "54": "54",
    "55": "55",
    "56": "56",
    "57": "57",
    "58": "58",
    "59": "59",
    "60": "60",
    "61": "61",
    "62": "62",
    "63": "63",
    "64": "64",
    "65": "65",
    "66": "66",
    "67": "67",
    "68": "68",
    "69": "69",
    "70": "70",
    "71": "71",
    "72": "72",
    "73": "73",
    "74": "74",
    "75": "75",
    "76": "76",
    "77": "77",
    "78": "78",
    "79": "79",
    "80": "80",
    "81": "81",
    "82": "82",
    "83": "83",
    "84": "84",
    "85": "85",
    "86": "86",
    "87": "87",
    "88": "88",
    "89": "89",
    "90": "90",
    "91": "91",
    "92": "92",
    "93": "93",
    "94": "94",
    "95": "95",
    "96": "96",
    "97": "97",
    "98": "98",
    "99": "99",
    "100": "100"
  },
  "android.net.INetworkScoreService": {
    "1": "boolean updateScores([Landroid.net.ScoredNetwork;)",
    "2": "boolean clearScores()",
    "3": "boolean setActiveScorer(java.lang.String)",
    "4": "void disableScoring()",
    "5": "void registerNetworkScoreCache(int, android.net.INetworkScoreCache, int)",
    "6": "void unregisterNetworkScoreCache(int, android.net.INetworkScoreCache)",
    "7": "boolean requestScores([Landroid.net.NetworkKey;)",
    "8": "boolean isCallerActiveScorer(int)",
    "9": "java.lang.String getActiveScorerPackage()",
    "10": "android.net.NetworkScorerAppData getActiveScorer()",
    "11": "java.util.List getAllValidScorers()"
  },
  "com.android.internal.telephony.ITelephonyRegistry": {
    "1": "void addOnSubscriptionsChangedListener(java.lang.String, java.lang.String, com.android.internal.telephony.IOnSubscriptionsChangedListener)",
    "2": "void addOnOpportunisticSubscriptionsChangedListener(java.lang.String, java.lang.String, com.android.internal.telephony.IOnSubscriptionsChangedListener)",
    "3": "void removeOnSubscriptionsChangedListener(java.lang.String, com.android.internal.telephony.IOnSubscriptionsChangedListener)",
    "4": "void listenWithEventList(boolean, boolean, int, java.lang.String, java.lang.String, com.android.internal.telephony.IPhoneStateListener, [I, boolean)",
    "5": "void notifyCallStateForAllSubs(int, java.lang.String)",
    "6": "void notifyCallState(int, int, int, java.lang.String)",
    "7": "void notifyServiceStateForPhoneId(int, int, android.telephony.ServiceState)",
    "8": "void notifySignalStrengthForPhoneId(int, int, android.telephony.SignalStrength)",
    "9": "void notifyMessageWaitingChangedForPhoneId(int, int, boolean)",
    "10": "void notifyCallForwardingChanged(boolean)",
    "11": "void notifyCallForwardingChangedForSubscriber(int, boolean)",
    "12": "void notifyDataActivity(int)",
    "13": "void notifyDataActivityForSubscriber(int, int)",
    "14": "void notifyDataConnectionForSubscriber(int, int, android.telephony.PreciseDataConnectionState)",
    "15": "void notifyCellLocationForSubscriber(int, android.telephony.CellIdentity)",
    "16": "void notifyCellInfo(java.util.List)",
    "17": "void notifyPreciseCallState(int, int, [I, [Ljava.lang.String;, [I, [I)",
    "18": "void notifyDisconnectCause(int, int, int, int)",
    "19": "void notifyCellInfoForSubscriber(int, java.util.List)",
    "20": "void notifySrvccStateChanged(int, int)",
    "21": "void notifySimActivationStateChangedForPhoneId(int, int, int, int)",
    "22": "void notifyOemHookRawEventForSubscriber(int, int, [B)",
    "23": "void notifySubscriptionInfoChanged()",
    "24": "void notifyOpportunisticSubscriptionInfoChanged()",
    "25": "void notifyCarrierNetworkChange(boolean)",
    "26": "void notifyCarrierNetworkChangeWithSubId(int, boolean)",
    "27": "void notifyUserMobileDataStateChangedForPhoneId(int, int, boolean)",
    "28": "void notifyDisplayInfoChanged(int, int, android.telephony.TelephonyDisplayInfo)",
    "29": "void notifyPhoneCapabilityChanged(android.telephony.PhoneCapability)",
    "30": "void notifyActiveDataSubIdChanged(int)",
    "31": "void notifyRadioPowerStateChanged(int, int, int)",
    "32": "void notifyEmergencyNumberList(int, int)",
    "33": "void notifyOutgoingEmergencyCall(int, int, android.telephony.emergency.EmergencyNumber)",
    "34": "void notifyOutgoingEmergencySms(int, int, android.telephony.emergency.EmergencyNumber)",
    "35": "void notifyCallQualityChanged(android.telephony.CallQuality, int, int, int)",
    "36": "void notifyMediaQualityStatusChanged(int, int, android.telephony.ims.MediaQualityStatus)",
    "37": "void notifyImsDisconnectCause(int, android.telephony.ims.ImsReasonInfo)",
    "38": "void notifyRegistrationFailed(int, int, android.telephony.CellIdentity, java.lang.String, int, int, int)",
    "39": "void notifyBarringInfoChanged(int, int, android.telephony.BarringInfo)",
    "40": "void notifyPhysicalChannelConfigForSubscriber(int, int, java.util.List)",
    "41": "void notifyDataEnabled(int, int, boolean, int)",
    "42": "void notifyAllowedNetworkTypesChanged(int, int, int, long)",
    "43": "void notifyLinkCapacityEstimateChanged(int, int, java.util.List)",
    "44": "void addCarrierPrivilegesCallback(int, com.android.internal.telephony.ICarrierPrivilegesCallback, java.lang.String, java.lang.String)",
    "45": "void removeCarrierPrivilegesCallback(com.android.internal.telephony.ICarrierPrivilegesCallback, java.lang.String)",
    "46": "void notifyCarrierPrivilegesChanged(int, java.util.List, [I)",
    "47": "void notifyCarrierServiceChanged(int, java.lang.String, int)",
    "48": "void addCarrierConfigChangeListener(com.android.internal.telephony.ICarrierConfigChangeListener, java.lang.String, java.lang.String)",
    "49": "void removeCarrierConfigChangeListener(com.android.internal.telephony.ICarrierConfigChangeListener, java.lang.String)",
    "50": "void notifyCarrierConfigChanged(int, int, int, int)",
    "51": "void notifyCallbackModeStarted(int, int, int)",
    "52": "void notifyCallbackModeStopped(int, int, int, int)"
  },
  "com.android.internal.app.IVoiceInteractionManagerService": {
    "1": "void showSession(android.os.Bundle, int, java.lang.String)",
    "2": "boolean deliverNewSession(android.os.IBinder, android.service.voice.IVoiceInteractionSession, com.android.internal.app.IVoiceInteractor)",
    "3": "boolean showSessionFromSession(android.os.IBinder, android.os.Bundle, int, java.lang.String)",
    "4": "boolean hideSessionFromSession(android.os.IBinder)",
    "5": "int startVoiceActivity(android.os.IBinder, android.content.Intent, java.lang.String, java.lang.String)",
    "6": "int startAssistantActivity(android.os.IBinder, android.content.Intent, java.lang.String, java.lang.String, android.os.Bundle)",
    "7": "void setKeepAwake(android.os.IBinder, boolean)",
    "8": "void closeSystemDialogs(android.os.IBinder)",
    "9": "void finish(android.os.IBinder)",
    "10": "void setDisabledShowContext(int)",
    "11": "int getDisabledShowContext()",
    "12": "int getUserDisabledShowContext()",
    "13": "android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel getKeyphraseSoundModel(int, java.lang.String)",
    "14": "int updateKeyphraseSoundModel(android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel)",
    "15": "int deleteKeyphraseSoundModel(int, java.lang.String)",
    "16": "void setModelDatabaseForTestEnabled(boolean, android.os.IBinder)",
    "17": "boolean isEnrolledForKeyphrase(int, java.lang.String)",
    "18": "android.hardware.soundtrigger.KeyphraseMetadata getEnrolledKeyphraseMetadata(java.lang.String, java.lang.String)",
    "19": "android.content.ComponentName getActiveServiceComponentName()",
    "20": "boolean showSessionForActiveService(android.os.Bundle, int, java.lang.String, com.android.internal.app.IVoiceInteractionSessionShowCallback, android.os.IBinder)",
    "21": "void hideCurrentSession()",
    "22": "void launchVoiceAssistFromKeyguard()",
    "23": "boolean isSessionRunning()",
    "24": "boolean activeServiceSupportsAssist()",
    "25": "boolean activeServiceSupportsLaunchFromKeyguard()",
    "26": "void onLockscreenShown()",
    "27": "void registerVoiceInteractionSessionListener(com.android.internal.app.IVoiceInteractionSessionListener)",
    "28": "void getActiveServiceSupportedActions(java.util.List, com.android.internal.app.IVoiceActionCheckCallback)",
    "29": "void setUiHints(android.os.Bundle)",
    "30": "void requestDirectActions(android.os.IBinder, int, android.os.IBinder, android.os.RemoteCallback, android.os.RemoteCallback)",
    "31": "void performDirectAction(android.os.IBinder, java.lang.String, android.os.Bundle, int, android.os.IBinder, android.os.RemoteCallback, android.os.RemoteCallback)",
    "32": "void setDisabled(boolean)",
    "33": "com.android.internal.app.IVoiceInteractionSoundTriggerSession createSoundTriggerSessionAsOriginator(android.media.permission.Identity, android.os.IBinder, android.hardware.soundtrigger.SoundTrigger$ModuleProperties)",
    "34": "java.util.List listModuleProperties(android.media.permission.Identity)",
    "35": "void updateState(android.os.PersistableBundle, android.os.SharedMemory, android.os.IBinder)",
    "36": "void initAndVerifyDetector(android.media.permission.Identity, android.os.PersistableBundle, android.os.SharedMemory, android.os.IBinder, com.android.internal.app.IHotwordRecognitionStatusCallback, int)",
    "37": "void destroyDetector(android.os.IBinder)",
    "38": "void shutdownHotwordDetectionService()",
    "39": "void enableVisualQueryDetection(com.android.internal.app.IVisualQueryDetectionAttentionListener)",
    "40": "void disableVisualQueryDetection()",
    "41": "void startPerceiving(android.service.voice.IVisualQueryDetectionVoiceInteractionCallback)",
    "42": "void stopPerceiving()",
    "43": "void startListeningFromMic(android.media.AudioFormat, android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback)",
    "44": "void stopListeningFromMic()",
    "45": "void startListeningFromExternalSource(android.os.ParcelFileDescriptor, android.media.AudioFormat, android.os.PersistableBundle, android.os.IBinder, android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback)",
    "46": "void triggerHardwareRecognitionEventForTest(android.hardware.soundtrigger.SoundTrigger$KeyphraseRecognitionEvent, com.android.internal.app.IHotwordRecognitionStatusCallback)",
    "47": "void startListeningVisibleActivityChanged(android.os.IBinder)",
    "48": "void stopListeningVisibleActivityChanged(android.os.IBinder)",
    "49": "void setSessionWindowVisible(android.os.IBinder, boolean)",
    "50": "void notifyActivityEventChanged(android.os.IBinder, int)"
  },
  "android.os.IHardwarePropertiesManager": {
    "1": "[F getDeviceTemperatures(java.lang.String, int, int)",
    "2": "[Landroid.os.CpuUsageInfo; getCpuUsages(java.lang.String)",
    "3": "[F getFanSpeeds(java.lang.String)"
  },
  "android.security.keymaster.IKeyAttestationApplicationIdProvider": {
    "1": "android.security.keymaster.KeyAttestationApplicationId getKeyAttestationApplicationId(int)"
  },
  "android.hardware.ISerialManager": {
    "1": "[Ljava.lang.String; getSerialPorts()",
    "2": "android.os.ParcelFileDescriptor openSerialPort(java.lang.String)"
  },
  "android.media.IMediaCommunicationService": {
    "1": "void notifySession2Created(android.media.Session2Token)",
    "2": "boolean isTrusted(java.lang.String, int, int)",
    "3": "android.media.MediaParceledListSlice getSession2Tokens(int)",
    "4": "void dispatchMediaKeyEvent(java.lang.String, android.view.KeyEvent, boolean)",
    "5": "void registerCallback(android.media.IMediaCommunicationServiceCallback, java.lang.String)",
    "6": "void unregisterCallback(android.media.IMediaCommunicationServiceCallback)"
  },
  "android.os.IServiceManager": {
    "1": "android.os.IBinder getService(java.lang.String)",
    "2": "android.os.IBinder checkService(java.lang.String)",
    "3": "void addService(java.lang.String, android.os.IBinder, boolean, int)",
    "4": "[Ljava.lang.String; listServices(int)",
    "5": "void registerForNotifications(java.lang.String, android.os.IServiceCallback)",
    "6": "void unregisterForNotifications(java.lang.String, android.os.IServiceCallback)",
    "7": "boolean isDeclared(java.lang.String)",
    "8": "[Ljava.lang.String; getDeclaredInstances(java.lang.String)",
    "9": "java.lang.String updatableViaApex(java.lang.String)",
    "10": "[Ljava.lang.String; getUpdatableNames(java.lang.String)",
    "11": "android.os.ConnectionInfo getConnectionInfo(java.lang.String)",
    "12": "void registerClientCallback(java.lang.String, android.os.IBinder, android.os.IClientCallback)",
    "13": "void tryUnregisterService(java.lang.String, android.os.IBinder)",
    "14": "[Landroid.os.ServiceDebugInfo; getServiceDebugInfo()"
  },
  "android.net.wifi.nl80211.IWificond": {
    "1": "android.net.wifi.nl80211.IApInterface createApInterface(java.lang.String)",
    "2": "android.net.wifi.nl80211.IClientInterface createClientInterface(java.lang.String)",
    "3": "boolean tearDownApInterface(java.lang.String)",
    "4": "boolean tearDownClientInterface(java.lang.String)",
    "5": "void tearDownInterfaces()",
    "6": "java.util.List GetClientInterfaces()",
    "7": "java.util.List GetApInterfaces()",
    "8": "[I getAvailable2gChannels()",
    "9": "[I getAvailable5gNonDFSChannels()",
    "10": "[I getAvailableDFSChannels()",
    "11": "[I getAvailable6gChannels()",
    "12": "[I getAvailable60gChannels()",
    "13": "void RegisterCallback(android.net.wifi.nl80211.IInterfaceEventCallback)",
    "14": "void UnregisterCallback(android.net.wifi.nl80211.IInterfaceEventCallback)",
    "15": "void registerWificondEventCallback(android.net.wifi.nl80211.IWificondEventCallback)",
    "16": "void unregisterWificondEventCallback(android.net.wifi.nl80211.IWificondEventCallback)",
    "17": "android.net.wifi.nl80211.DeviceWiphyCapabilities getDeviceWiphyCapabilities(java.lang.String)",
    "18": "void notifyCountryCodeChanged()"
  },
  "android.os.IPermissionController": {
    "1": "boolean checkPermission(java.lang.String, int, int)",
    "2": "int noteOp(java.lang.String, int, java.lang.String)",
    "3": "[Ljava.lang.String; getPackagesForUid(int)",
    "4": "boolean isRuntimePermission(java.lang.String)",
    "5": "int getPackageUid(java.lang.String, int)"
  },
  "com.android.internal.compat.IPlatformCompat": {
    "1": "void reportChange(long, android.content.pm.ApplicationInfo)",
    "2": "void reportChangeByPackageName(long, java.lang.String, int)",
    "3": "void reportChangeByUid(long, int)",
    "4": "boolean isChangeEnabled(long, android.content.pm.ApplicationInfo)",
    "5": "boolean isChangeEnabledByPackageName(long, java.lang.String, int)",
    "6": "boolean isChangeEnabledByUid(long, int)",
    "7": "void setOverrides(com.android.internal.compat.CompatibilityChangeConfig, java.lang.String)",
    "8": "void putAllOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesByPackageConfig)",
    "9": "void putOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverrideConfig, java.lang.String)",
    "10": "void setOverridesForTest(com.android.internal.compat.CompatibilityChangeConfig, java.lang.String)",
    "11": "boolean clearOverride(long, java.lang.String)",
    "12": "boolean clearOverrideForTest(long, java.lang.String)",
    "13": "void removeAllOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesToRemoveByPackageConfig)",
    "14": "void removeOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesToRemoveConfig, java.lang.String)",
    "15": "int enableTargetSdkChanges(java.lang.String, int)",
    "16": "int disableTargetSdkChanges(java.lang.String, int)",
    "17": "void clearOverrides(java.lang.String)",
    "18": "void clearOverridesForTest(java.lang.String)",
    "19": "com.android.internal.compat.CompatibilityChangeConfig getAppConfig(android.content.pm.ApplicationInfo)",
    "20": "[Lcom.android.internal.compat.CompatibilityChangeInfo; listAllChanges()",
    "21": "[Lcom.android.internal.compat.CompatibilityChangeInfo; listUIChanges()",
    "22": "com.android.internal.compat.IOverrideValidator getOverrideValidator()"
  },
  "android.credentials.ICredentialManager": {
    "1": "android.os.ICancellationSignal executeGetCredential(android.credentials.GetCredentialRequest, android.credentials.IGetCredentialCallback, java.lang.String)",
    "2": "android.os.ICancellationSignal executePrepareGetCredential(android.credentials.GetCredentialRequest, android.credentials.IPrepareGetCredentialCallback, android.credentials.IGetCredentialCallback, java.lang.String)",
    "3": "android.os.ICancellationSignal executeCreateCredential(android.credentials.CreateCredentialRequest, android.credentials.ICreateCredentialCallback, java.lang.String)",
    "4": "android.os.ICancellationSignal clearCredentialState(android.credentials.ClearCredentialStateRequest, android.credentials.IClearCredentialStateCallback, java.lang.String)",
    "5": "void setEnabledProviders(java.util.List, java.util.List, int, android.credentials.ISetEnabledProvidersCallback)",
    "6": "void registerCredentialDescription(android.credentials.RegisterCredentialDescriptionRequest, java.lang.String)",
    "7": "void unregisterCredentialDescription(android.credentials.UnregisterCredentialDescriptionRequest, java.lang.String)",
    "8": "boolean isEnabledCredentialProviderService(android.content.ComponentName, java.lang.String)",
    "9": "java.util.List getCredentialProviderServices(int, int)",
    "10": "java.util.List getCredentialProviderServicesForTesting(int)",
    "11": "boolean isServiceEnabled()"
  },
  "android.hardware.ICameraService": {
    "1": "int getNumberOfCameras(int)",
    "2": "android.hardware.CameraInfo getCameraInfo(int, boolean)",
    "3": "android.hardware.ICamera connect(android.hardware.ICameraClient, int, java.lang.String, int, int, int, boolean, boolean)",
    "4": "android.hardware.camera2.ICameraDeviceUser connectDevice(android.hardware.camera2.ICameraDeviceCallbacks, java.lang.String, java.lang.String, java.lang.String, int, int, int, boolean)",
    "5": "[Landroid.hardware.CameraStatus; addListener(android.hardware.ICameraServiceListener)",
    "6": "[Landroid.hardware.camera2.utils.ConcurrentCameraIdCombination; getConcurrentCameraIds()",
    "7": "boolean isConcurrentSessionConfigurationSupported([Landroid.hardware.camera2.utils.CameraIdAndSessionConfiguration;, int)",
    "8": "void removeListener(android.hardware.ICameraServiceListener)",
    "9": "android.hardware.camera2.impl.CameraMetadataNative getCameraCharacteristics(java.lang.String, int, boolean)",
    "10": "android.hardware.camera2.params.VendorTagDescriptor getCameraVendorTagDescriptor()",
    "11": "android.hardware.camera2.params.VendorTagDescriptorCache getCameraVendorTagCache()",
    "12": "java.lang.String getLegacyParameters(int)",
    "13": "boolean supportsCameraApi(java.lang.String, int)",
    "14": "boolean isHiddenPhysicalCamera(java.lang.String)",
    "15": "android.hardware.camera2.ICameraInjectionSession injectCamera(java.lang.String, java.lang.String, java.lang.String, android.hardware.camera2.ICameraInjectionCallback)",
    "16": "void setTorchMode(java.lang.String, boolean, android.os.IBinder)",
    "17": "void turnOnTorchWithStrengthLevel(java.lang.String, int, android.os.IBinder)",
    "18": "int getTorchStrengthLevel(java.lang.String)",
    "19": "void notifySystemEvent(int, [I)",
    "20": "void notifyDisplayConfigurationChange()",
    "21": "void notifyDeviceStateChange(long)",
    "22": "java.lang.String reportExtensionSessionStats(android.hardware.CameraExtensionSessionStats)"
  },
  "android.content.pm.IOtaDexopt": {
    "1": "void prepare()",
    "2": "void cleanup()",
    "3": "boolean isDone()",
    "4": "float getProgress()",
    "5": "void dexoptNextPackage()",
    "6": "java.lang.String nextDexoptCommand()"
  },
  "com.android.internal.app.ISoundTriggerService": {
    "1": "com.android.internal.app.ISoundTriggerSession attachAsOriginator(android.media.permission.Identity, android.hardware.soundtrigger.SoundTrigger$ModuleProperties, android.os.IBinder)",
    "2": "com.android.internal.app.ISoundTriggerSession attachAsMiddleman(android.media.permission.Identity, android.media.permission.Identity, android.hardware.soundtrigger.SoundTrigger$ModuleProperties, android.os.IBinder)",
    "3": "java.util.List listModuleProperties(android.media.permission.Identity)",
    "4": "void attachInjection(android.media.soundtrigger_middleware.ISoundTriggerInjection)",
    "5": "void setInPhoneCallState(boolean)"
  },
  "android.app.slice.ISliceManager": {
    "1": "void pinSlice(java.lang.String, android.net.Uri, [Landroid.app.slice.SliceSpec;, android.os.IBinder)",
    "2": "void unpinSlice(java.lang.String, android.net.Uri, android.os.IBinder)",
    "3": "boolean hasSliceAccess(java.lang.String)",
    "4": "[Landroid.app.slice.SliceSpec; getPinnedSpecs(android.net.Uri, java.lang.String)",
    "5": "[Landroid.net.Uri; getPinnedSlices(java.lang.String)",
    "6": "[B getBackupPayload(int)",
    "7": "void applyRestore([B, int)",
    "8": "void grantSlicePermission(java.lang.String, java.lang.String, android.net.Uri)",
    "9": "void revokeSlicePermission(java.lang.String, java.lang.String, android.net.Uri)",
    "10": "int checkSlicePermission(android.net.Uri, java.lang.String, int, int, [Ljava.lang.String;)",
    "11": "void grantPermissionFromUser(android.net.Uri, java.lang.String, java.lang.String, boolean)"
  },
  "android.hardware.biometrics.IAuthService": {
    "1": "android.hardware.biometrics.ITestSession createTestSession(int, android.hardware.biometrics.ITestSessionCallback, java.lang.String)",
    "2": "java.util.List getSensorProperties(java.lang.String)",
    "3": "java.lang.String getUiPackage()",
    "4": "long authenticate(android.os.IBinder, long, int, android.hardware.biometrics.IBiometricServiceReceiver, java.lang.String, android.hardware.biometrics.PromptInfo)",
    "5": "void cancelAuthentication(android.os.IBinder, java.lang.String, long)",
    "6": "int canAuthenticate(java.lang.String, int, int)",
    "7": "boolean hasEnrolledBiometrics(int, java.lang.String)",
    "8": "void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback)",
    "9": "void invalidateAuthenticatorIds(int, int, android.hardware.biometrics.IInvalidationCallback)",
    "10": "[J getAuthenticatorIds(int)",
    "11": "void resetLockoutTimeBound(android.os.IBinder, java.lang.String, int, int, [B)",
    "12": "void resetLockout(int, [B)",
    "13": "java.lang.CharSequence getButtonLabel(int, java.lang.String, int)",
    "14": "java.lang.CharSequence getPromptMessage(int, java.lang.String, int)",
    "15": "java.lang.CharSequence getSettingName(int, java.lang.String, int)"
  },
  "android.os.IIncidentCompanion": {
    "1": "void authorizeReport(int, java.lang.String, java.lang.String, java.lang.String, int, android.os.IIncidentAuthListener)",
    "2": "void cancelAuthorization(android.os.IIncidentAuthListener)",
    "3": "void sendReportReadyBroadcast(java.lang.String, java.lang.String)",
    "4": "java.util.List getPendingReports()",
    "5": "void approveReport(java.lang.String)",
    "6": "void denyReport(java.lang.String)",
    "7": "java.util.List getIncidentReportList(java.lang.String, java.lang.String)",
    "8": "android.os.IncidentManager$IncidentReport getIncidentReport(java.lang.String, java.lang.String, java.lang.String)",
    "9": "void deleteIncidentReports(java.lang.String, java.lang.String, java.lang.String)",
    "10": "void deleteAllIncidentReports(java.lang.String)"
  },
  "android.os.IDumpstate": {
    "1": "void preDumpUiData(java.lang.String)",
    "2": "void startBugreport(int, java.lang.String, java.io.FileDescriptor, java.io.FileDescriptor, int, int, android.os.IDumpstateListener, boolean)",
    "3": "void cancelBugreport(int, java.lang.String)",
    "4": "void retrieveBugreport(int, java.lang.String, java.io.FileDescriptor, java.lang.String, android.os.IDumpstateListener)"
  },
  "android.media.IAudioService": {
    "1": "int trackPlayer(android.media.PlayerBase$PlayerIdCard)",
    "2": "void playerAttributes(int, android.media.AudioAttributes)",
    "3": "void playerEvent(int, int, int)",
    "4": "void releasePlayer(int)",
    "5": "int trackRecorder(android.os.IBinder)",
    "6": "void recorderEvent(int, int)",
    "7": "void releaseRecorder(int)",
    "8": "void playerSessionId(int, int)",
    "9": "void portEvent(int, int, android.os.PersistableBundle)",
    "10": "void adjustStreamVolume(int, int, int, java.lang.String)",
    "11": "void adjustStreamVolumeWithAttribution(int, int, int, java.lang.String, java.lang.String)",
    "12": "void setStreamVolume(int, int, int, java.lang.String)",
    "13": "void setStreamVolumeWithAttribution(int, int, int, java.lang.String, java.lang.String)",
    "14": "void setDeviceVolume(android.media.VolumeInfo, android.media.AudioDeviceAttributes, java.lang.String)",
    "15": "android.media.VolumeInfo getDeviceVolume(android.media.VolumeInfo, android.media.AudioDeviceAttributes, java.lang.String)",
    "16": "void handleVolumeKey(android.view.KeyEvent, boolean, java.lang.String, java.lang.String)",
    "17": "boolean isStreamMute(int)",
    "18": "void forceRemoteSubmixFullVolume(boolean, android.os.IBinder)",
    "19": "boolean isMasterMute()",
    "20": "void setMasterMute(boolean, int, java.lang.String, int, java.lang.String)",
    "21": "int getStreamVolume(int)",
    "22": "int getStreamMinVolume(int)",
    "23": "int getStreamMaxVolume(int)",
    "24": "java.util.List getAudioVolumeGroups()",
    "25": "void setVolumeGroupVolumeIndex(int, int, int, java.lang.String, java.lang.String)",
    "26": "int getVolumeGroupVolumeIndex(int)",
    "27": "int getVolumeGroupMaxVolumeIndex(int)",
    "28": "int getVolumeGroupMinVolumeIndex(int)",
    "29": "int getLastAudibleVolumeForVolumeGroup(int)",
    "30": "boolean isVolumeGroupMuted(int)",
    "31": "void adjustVolumeGroupVolume(int, int, int, java.lang.String)",
    "32": "int getLastAudibleStreamVolume(int)",
    "33": "void setSupportedSystemUsages([I)",
    "34": "[I getSupportedSystemUsages()",
    "35": "java.util.List getAudioProductStrategies()",
    "36": "boolean isMicrophoneMuted()",
    "37": "boolean isUltrasoundSupported()",
    "38": "boolean isHotwordStreamSupported(boolean)",
    "39": "void setMicrophoneMute(boolean, java.lang.String, int, java.lang.String)",
    "40": "void setMicrophoneMuteFromSwitch(boolean)",
    "41": "void setRingerModeExternal(int, java.lang.String)",
    "42": "void setRingerModeInternal(int, java.lang.String)",
    "43": "int getRingerModeExternal()",
    "44": "int getRingerModeInternal()",
    "45": "boolean isValidRingerMode(int)",
    "46": "void setVibrateSetting(int, int)",
    "47": "int getVibrateSetting(int)",
    "48": "boolean shouldVibrate(int)",
    "49": "void setMode(int, android.os.IBinder, java.lang.String)",
    "50": "int getMode()",
    "51": "void playSoundEffect(int, int)",
    "52": "void playSoundEffectVolume(int, float)",
    "53": "boolean loadSoundEffects()",
    "54": "void unloadSoundEffects()",
    "55": "void reloadAudioSettings()",
    "56": "java.util.Map getSurroundFormats()",
    "57": "java.util.List getReportedSurroundFormats()",
    "58": "boolean setSurroundFormatEnabled(int, boolean)",
    "59": "boolean isSurroundFormatEnabled(int)",
    "60": "boolean setEncodedSurroundMode(int)",
    "61": "int getEncodedSurroundMode(int)",
    "62": "void setSpeakerphoneOn(android.os.IBinder, boolean)",
    "63": "boolean isSpeakerphoneOn()",
    "64": "void setBluetoothScoOn(boolean)",
    "65": "void setA2dpSuspended(boolean)",
    "66": "void setLeAudioSuspended(boolean)",
    "67": "boolean isBluetoothScoOn()",
    "68": "void setBluetoothA2dpOn(boolean)",
    "69": "boolean isBluetoothA2dpOn()",
    "70": "int requestAudioFocus(android.media.AudioAttributes, int, android.os.IBinder, android.media.IAudioFocusDispatcher, java.lang.String, java.lang.String, java.lang.String, int, android.media.audiopolicy.IAudioPolicyCallback, int)",
    "71": "int abandonAudioFocus(android.media.IAudioFocusDispatcher, java.lang.String, android.media.AudioAttributes, java.lang.String)",
    "72": "void unregisterAudioFocusClient(java.lang.String)",
    "73": "int getCurrentAudioFocus()",
    "74": "void startBluetoothSco(android.os.IBinder, int)",
    "75": "void startBluetoothScoVirtualCall(android.os.IBinder)",
    "76": "void stopBluetoothSco(android.os.IBinder)",
    "77": "void forceVolumeControlStream(int, android.os.IBinder)",
    "78": "void setRingtonePlayer(android.media.IRingtonePlayer)",
    "79": "android.media.IRingtonePlayer getRingtonePlayer()",
    "80": "int getUiSoundsStreamType()",
    "81": "java.util.List getIndependentStreamTypes()",
    "82": "int getStreamTypeAlias(int)",
    "83": "boolean isVolumeControlUsingVolumeGroups()",
    "84": "void registerStreamAliasingDispatcher(android.media.IStreamAliasingDispatcher, boolean)",
    "85": "void setNotifAliasRingForTest(boolean)",
    "86": "void setWiredDeviceConnectionState(android.media.AudioDeviceAttributes, int, java.lang.String)",
    "87": "android.media.AudioRoutesInfo startWatchingRoutes(android.media.IAudioRoutesObserver)",
    "88": "boolean isCameraSoundForced()",
    "89": "void setVolumeController(android.media.IVolumeController)",
    "90": "android.media.IVolumeController getVolumeController()",
    "91": "void notifyVolumeControllerVisible(android.media.IVolumeController, boolean)",
    "92": "boolean isStreamAffectedByRingerMode(int)",
    "93": "boolean isStreamAffectedByMute(int)",
    "94": "void disableSafeMediaVolume(java.lang.String)",
    "95": "void lowerVolumeToRs1(java.lang.String)",
    "96": "float getOutputRs2UpperBound()",
    "97": "void setOutputRs2UpperBound(float)",
    "98": "float getCsd()",
    "99": "void setCsd(float)",
    "100": "void forceUseFrameworkMel(boolean)",
    "101": "void forceComputeCsdOnAllDevices(boolean)",
    "102": "boolean isCsdEnabled()",
    "103": "int setHdmiSystemAudioSupported(boolean)",
    "104": "boolean isHdmiSystemAudioSupported()",
    "105": "java.lang.String registerAudioPolicy(android.media.audiopolicy.AudioPolicyConfig, android.media.audiopolicy.IAudioPolicyCallback, boolean, boolean, boolean, boolean, android.media.projection.IMediaProjection)",
    "106": "void unregisterAudioPolicyAsync(android.media.audiopolicy.IAudioPolicyCallback)",
    "107": "void unregisterAudioPolicy(android.media.audiopolicy.IAudioPolicyCallback)",
    "108": "int addMixForPolicy(android.media.audiopolicy.AudioPolicyConfig, android.media.audiopolicy.IAudioPolicyCallback)",
    "109": "int removeMixForPolicy(android.media.audiopolicy.AudioPolicyConfig, android.media.audiopolicy.IAudioPolicyCallback)",
    "110": "int setFocusPropertiesForPolicy(int, android.media.audiopolicy.IAudioPolicyCallback)",
    "111": "void setVolumePolicy(android.media.VolumePolicy)",
    "112": "boolean hasRegisteredDynamicPolicy()",
    "113": "void registerRecordingCallback(android.media.IRecordingConfigDispatcher)",
    "114": "void unregisterRecordingCallback(android.media.IRecordingConfigDispatcher)",
    "115": "java.util.List getActiveRecordingConfigurations()",
    "116": "void registerPlaybackCallback(android.media.IPlaybackConfigDispatcher)",
    "117": "void unregisterPlaybackCallback(android.media.IPlaybackConfigDispatcher)",
    "118": "java.util.List getActivePlaybackConfigurations()",
    "119": "int getFocusRampTimeMs(int, android.media.AudioAttributes)",
    "120": "int dispatchFocusChange(android.media.AudioFocusInfo, int, android.media.audiopolicy.IAudioPolicyCallback)",
    "121": "void playerHasOpPlayAudio(int, boolean)",
    "122": "void handleBluetoothActiveDeviceChanged(android.bluetooth.BluetoothDevice, android.bluetooth.BluetoothDevice, android.media.BluetoothProfileConnectionInfo)",
    "123": "void setFocusRequestResultFromExtPolicy(android.media.AudioFocusInfo, int, android.media.audiopolicy.IAudioPolicyCallback)",
    "124": "void registerAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)",
    "125": "void unregisterAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)",
    "126": "boolean isAudioServerRunning()",
    "127": "int setUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback, int, [I, [Ljava.lang.String;)",
    "128": "int removeUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback, int)",
    "129": "int setUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback, int, [I, [Ljava.lang.String;)",
    "130": "int removeUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback, int)",
    "131": "boolean hasHapticChannels(android.net.Uri)",
    "132": "boolean isCallScreeningModeSupported()",
    "133": "int setPreferredDevicesForStrategy(int, java.util.List)",
    "134": "int removePreferredDevicesForStrategy(int)",
    "135": "java.util.List getPreferredDevicesForStrategy(int)",
    "136": "int setDeviceAsNonDefaultForStrategy(int, android.media.AudioDeviceAttributes)",
    "137": "int removeDeviceAsNonDefaultForStrategy(int, android.media.AudioDeviceAttributes)",
    "138": "java.util.List getNonDefaultDevicesForStrategy(int)",
    "139": "java.util.List getDevicesForAttributes(android.media.AudioAttributes)",
    "140": "java.util.List getDevicesForAttributesUnprotected(android.media.AudioAttributes)",
    "141": "void addOnDevicesForAttributesChangedListener(android.media.AudioAttributes, android.media.IDevicesForAttributesCallback)",
    "142": "void removeOnDevicesForAttributesChangedListener(android.media.IDevicesForAttributesCallback)",
    "143": "int setAllowedCapturePolicy(int)",
    "144": "int getAllowedCapturePolicy()",
    "145": "void registerStrategyPreferredDevicesDispatcher(android.media.IStrategyPreferredDevicesDispatcher)",
    "146": "void unregisterStrategyPreferredDevicesDispatcher(android.media.IStrategyPreferredDevicesDispatcher)",
    "147": "void registerStrategyNonDefaultDevicesDispatcher(android.media.IStrategyNonDefaultDevicesDispatcher)",
    "148": "void unregisterStrategyNonDefaultDevicesDispatcher(android.media.IStrategyNonDefaultDevicesDispatcher)",
    "149": "void setRttEnabled(boolean)",
    "150": "void setDeviceVolumeBehavior(android.media.AudioDeviceAttributes, int, java.lang.String)",
    "151": "int getDeviceVolumeBehavior(android.media.AudioDeviceAttributes)",
    "152": "void setMultiAudioFocusEnabled(boolean)",
    "153": "int setPreferredDevicesForCapturePreset(int, java.util.List)",
    "154": "int clearPreferredDevicesForCapturePreset(int)",
    "155": "java.util.List getPreferredDevicesForCapturePreset(int)",
    "156": "void registerCapturePresetDevicesRoleDispatcher(android.media.ICapturePresetDevicesRoleDispatcher)",
    "157": "void unregisterCapturePresetDevicesRoleDispatcher(android.media.ICapturePresetDevicesRoleDispatcher)",
    "158": "void adjustStreamVolumeForUid(int, int, int, java.lang.String, int, int, android.os.UserHandle, int)",
    "159": "void adjustSuggestedStreamVolumeForUid(int, int, int, java.lang.String, int, int, android.os.UserHandle, int)",
    "160": "void setStreamVolumeForUid(int, int, int, java.lang.String, int, int, android.os.UserHandle, int)",
    "161": "boolean isMusicActive(boolean)",
    "162": "int getDeviceMaskForStream(int)",
    "163": "[I getAvailableCommunicationDeviceIds()",
    "164": "boolean setCommunicationDevice(android.os.IBinder, int)",
    "165": "int getCommunicationDevice()",
    "166": "void registerCommunicationDeviceDispatcher(android.media.ICommunicationDeviceDispatcher)",
    "167": "void unregisterCommunicationDeviceDispatcher(android.media.ICommunicationDeviceDispatcher)",
    "168": "boolean areNavigationRepeatSoundEffectsEnabled()",
    "169": "void setNavigationRepeatSoundEffectsEnabled(boolean)",
    "170": "boolean isHomeSoundEffectEnabled()",
    "171": "void setHomeSoundEffectEnabled(boolean)",
    "172": "boolean setAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes, long)",
    "173": "long getAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes)",
    "174": "long getMaxAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes)",
    "175": "int requestAudioFocusForTest(android.media.AudioAttributes, int, android.os.IBinder, android.media.IAudioFocusDispatcher, java.lang.String, java.lang.String, int, int, int)",
    "176": "int abandonAudioFocusForTest(android.media.IAudioFocusDispatcher, java.lang.String, android.media.AudioAttributes, java.lang.String)",
    "177": "long getFadeOutDurationOnFocusLossMillis(android.media.AudioAttributes)",
    "178": "void registerModeDispatcher(android.media.IAudioModeDispatcher)",
    "179": "void unregisterModeDispatcher(android.media.IAudioModeDispatcher)",
    "180": "int getSpatializerImmersiveAudioLevel()",
    "181": "boolean isSpatializerEnabled()",
    "182": "boolean isSpatializerAvailable()",
    "183": "boolean isSpatializerAvailableForDevice(android.media.AudioDeviceAttributes)",
    "184": "boolean hasHeadTracker(android.media.AudioDeviceAttributes)",
    "185": "void setHeadTrackerEnabled(boolean, android.media.AudioDeviceAttributes)",
    "186": "boolean isHeadTrackerEnabled(android.media.AudioDeviceAttributes)",
    "187": "boolean isHeadTrackerAvailable()",
    "188": "void registerSpatializerHeadTrackerAvailableCallback(android.media.ISpatializerHeadTrackerAvailableCallback, boolean)",
    "189": "void setSpatializerEnabled(boolean)",
    "190": "boolean canBeSpatialized(android.media.AudioAttributes, android.media.AudioFormat)",
    "191": "void registerSpatializerCallback(android.media.ISpatializerCallback)",
    "192": "void unregisterSpatializerCallback(android.media.ISpatializerCallback)",
    "193": "void registerSpatializerHeadTrackingCallback(android.media.ISpatializerHeadTrackingModeCallback)",
    "194": "void unregisterSpatializerHeadTrackingCallback(android.media.ISpatializerHeadTrackingModeCallback)",
    "195": "void registerHeadToSoundstagePoseCallback(android.media.ISpatializerHeadToSoundStagePoseCallback)",
    "196": "void unregisterHeadToSoundstagePoseCallback(android.media.ISpatializerHeadToSoundStagePoseCallback)",
    "197": "java.util.List getSpatializerCompatibleAudioDevices()",
    "198": "void addSpatializerCompatibleAudioDevice(android.media.AudioDeviceAttributes)",
    "199": "void removeSpatializerCompatibleAudioDevice(android.media.AudioDeviceAttributes)",
    "200": "void setDesiredHeadTrackingMode(int)",
    "201": "int getDesiredHeadTrackingMode()",
    "202": "[I getSupportedHeadTrackingModes()",
    "203": "int getActualHeadTrackingMode()",
    "204": "void setSpatializerGlobalTransform([F)",
    "205": "void recenterHeadTracker()",
    "206": "void setSpatializerParameter(int, [B)",
    "207": "void getSpatializerParameter(int, [B)",
    "208": "int getSpatializerOutput()",
    "209": "void registerSpatializerOutputCallback(android.media.ISpatializerOutputCallback)",
    "210": "void unregisterSpatializerOutputCallback(android.media.ISpatializerOutputCallback)",
    "211": "boolean isVolumeFixed()",
    "212": "android.media.VolumeInfo getDefaultVolumeInfo()",
    "213": "boolean isPstnCallAudioInterceptable()",
    "214": "void muteAwaitConnection([I, android.media.AudioDeviceAttributes, long)",
    "215": "void cancelMuteAwaitConnection(android.media.AudioDeviceAttributes)",
    "216": "android.media.AudioDeviceAttributes getMutingExpectedDevice()",
    "217": "void registerMuteAwaitConnectionDispatcher(android.media.IMuteAwaitConnectionCallback, boolean)",
    "218": "void setTestDeviceConnectionState(android.media.AudioDeviceAttributes, boolean)",
    "219": "void registerDeviceVolumeBehaviorDispatcher(boolean, android.media.IDeviceVolumeBehaviorDispatcher)",
    "220": "java.util.List getFocusStack()",
    "221": "boolean sendFocusLoss(android.media.AudioFocusInfo, android.media.audiopolicy.IAudioPolicyCallback)",
    "222": "void addAssistantServicesUids([I)",
    "223": "void removeAssistantServicesUids([I)",
    "224": "void setActiveAssistantServiceUids([I)",
    "225": "[I getAssistantServicesUids()",
    "226": "[I getActiveAssistantServiceUids()",
    "227": "void registerDeviceVolumeDispatcherForAbsoluteVolume(boolean, android.media.IAudioDeviceVolumeDispatcher, java.lang.String, android.media.AudioDeviceAttributes, java.util.List, boolean, int)",
    "228": "android.media.AudioHalVersionInfo getHalVersion()",
    "229": "int setPreferredMixerAttributes(android.media.AudioAttributes, int, android.media.AudioMixerAttributes)",
    "230": "int clearPreferredMixerAttributes(android.media.AudioAttributes, int)",
    "231": "void registerPreferredMixerAttributesDispatcher(android.media.IPreferredMixerAttributesDispatcher)",
    "232": "void unregisterPreferredMixerAttributesDispatcher(android.media.IPreferredMixerAttributesDispatcher)",
    "233": "boolean supportsBluetoothVariableLatency()",
    "234": "void setBluetoothVariableLatencyEnabled(boolean)",
    "235": "boolean isBluetoothVariableLatencyEnabled()"
  },
  "com.android.internal.app.IBatteryStats": {
    "1": "void noteStartSensor(int, int)",
    "2": "void noteStopSensor(int, int)",
    "3": "void noteStartVideo(int)",
    "4": "void noteStopVideo(int)",
    "5": "void noteStartAudio(int)",
    "6": "void noteStopAudio(int)",
    "7": "void noteResetVideo()",
    "8": "void noteResetAudio()",
    "9": "void noteFlashlightOn(int)",
    "10": "void noteFlashlightOff(int)",
    "11": "void noteStartCamera(int)",
    "12": "void noteStopCamera(int)",
    "13": "void noteResetCamera()",
    "14": "void noteResetFlashlight()",
    "15": "void noteWakeupSensorEvent(long, int, int)",
    "16": "java.util.List getBatteryUsageStats(java.util.List)",
    "17": "boolean isCharging()",
    "18": "long computeBatteryTimeRemaining()",
    "19": "long computeChargeTimeRemaining()",
    "20": "long computeBatteryScreenOffRealtimeMs()",
    "21": "long getScreenOffDischargeMah()",
    "22": "void noteEvent(int, java.lang.String, int)",
    "23": "void noteSyncStart(java.lang.String, int)",
    "24": "void noteSyncFinish(java.lang.String, int)",
    "25": "void noteJobStart(java.lang.String, int)",
    "26": "void noteJobFinish(java.lang.String, int, int)",
    "27": "void noteStartWakelock(int, int, java.lang.String, java.lang.String, int, boolean)",
    "28": "void noteStopWakelock(int, int, java.lang.String, java.lang.String, int)",
    "29": "void noteStartWakelockFromSource(android.os.WorkSource, int, java.lang.String, java.lang.String, int, boolean)",
    "30": "void noteChangeWakelockFromSource(android.os.WorkSource, int, java.lang.String, java.lang.String, int, android.os.WorkSource, int, java.lang.String, java.lang.String, int, boolean)",
    "31": "void noteStopWakelockFromSource(android.os.WorkSource, int, java.lang.String, java.lang.String, int)",
    "32": "void noteLongPartialWakelockStart(java.lang.String, java.lang.String, int)",
    "33": "void noteLongPartialWakelockStartFromSource(java.lang.String, java.lang.String, android.os.WorkSource)",
    "34": "void noteLongPartialWakelockFinish(java.lang.String, java.lang.String, int)",
    "35": "void noteLongPartialWakelockFinishFromSource(java.lang.String, java.lang.String, android.os.WorkSource)",
    "36": "void noteVibratorOn(int, long)",
    "37": "void noteVibratorOff(int)",
    "38": "void noteGpsChanged(android.os.WorkSource, android.os.WorkSource)",
    "39": "void noteGpsSignalQuality(int)",
    "40": "void noteScreenState(int)",
    "41": "void noteScreenBrightness(int)",
    "42": "void noteUserActivity(int, int)",
    "43": "void noteWakeUp(java.lang.String, int)",
    "44": "void noteInteractive(boolean)",
    "45": "void noteConnectivityChanged(int, java.lang.String)",
    "46": "void noteMobileRadioPowerState(int, long, int)",
    "47": "void notePhoneOn()",
    "48": "void notePhoneOff()",
    "49": "void notePhoneSignalStrength(android.telephony.SignalStrength)",
    "50": "void notePhoneDataConnectionState(int, boolean, int, int)",
    "51": "void notePhoneState(int)",
    "52": "void noteWifiOn()",
    "53": "void noteWifiOff()",
    "54": "void noteWifiRunning(android.os.WorkSource)",
    "55": "void noteWifiRunningChanged(android.os.WorkSource, android.os.WorkSource)",
    "56": "void noteWifiStopped(android.os.WorkSource)",
    "57": "void noteWifiState(int, java.lang.String)",
    "58": "void noteWifiSupplicantStateChanged(int, boolean)",
    "59": "void noteWifiRssiChanged(int)",
    "60": "void noteFullWifiLockAcquired(int)",
    "61": "void noteFullWifiLockReleased(int)",
    "62": "void noteWifiScanStarted(int)",
    "63": "void noteWifiScanStopped(int)",
    "64": "void noteWifiMulticastEnabled(int)",
    "65": "void noteWifiMulticastDisabled(int)",
    "66": "void noteFullWifiLockAcquiredFromSource(android.os.WorkSource)",
    "67": "void noteFullWifiLockReleasedFromSource(android.os.WorkSource)",
    "68": "void noteWifiScanStartedFromSource(android.os.WorkSource)",
    "69": "void noteWifiScanStoppedFromSource(android.os.WorkSource)",
    "70": "void noteWifiBatchedScanStartedFromSource(android.os.WorkSource, int)",
    "71": "void noteWifiBatchedScanStoppedFromSource(android.os.WorkSource)",
    "72": "void noteWifiRadioPowerState(int, long, int)",
    "73": "void noteNetworkInterfaceForTransports(java.lang.String, [I)",
    "74": "void noteNetworkStatsEnabled()",
    "75": "void noteDeviceIdleMode(int, java.lang.String, int)",
    "76": "void setBatteryState(int, int, int, int, int, int, int, int, long)",
    "77": "long getAwakeTimeBattery()",
    "78": "long getAwakeTimePlugged()",
    "79": "void noteBleScanStarted(android.os.WorkSource, boolean)",
    "80": "void noteBleScanStopped(android.os.WorkSource, boolean)",
    "81": "void noteBleScanReset()",
    "82": "void noteBleScanResults(android.os.WorkSource, int)",
    "83": "android.os.connectivity.CellularBatteryStats getCellularBatteryStats()",
    "84": "android.os.connectivity.WifiBatteryStats getWifiBatteryStats()",
    "85": "android.os.connectivity.GpsBatteryStats getGpsBatteryStats()",
    "86": "android.os.WakeLockStats getWakeLockStats()",
    "87": "android.os.BluetoothBatteryStats getBluetoothBatteryStats()",
    "88": "android.os.health.HealthStatsParceler takeUidSnapshot(int)",
    "89": "[Landroid.os.health.HealthStatsParceler; takeUidSnapshots([I)",
    "90": "void noteBluetoothControllerActivity(android.bluetooth.BluetoothActivityEnergyInfo)",
    "91": "void noteModemControllerActivity(android.telephony.ModemActivityInfo)",
    "92": "void noteWifiControllerActivity(android.os.connectivity.WifiActivityEnergyInfo)",
    "93": "boolean setChargingStateUpdateDelayMillis(int)",
    "94": "void setChargerAcOnline(boolean, boolean)",
    "95": "void setBatteryLevel(int, boolean)",
    "96": "void unplugBattery(boolean)",
    "97": "void resetBattery(boolean)",
    "98": "void suspendBatteryInput()"
  },
  "android.os.IProcessInfoService": {
    "1": "void getProcessStatesFromPids([I, [I)",
    "2": "void getProcessStatesAndOomScoresFromPids([I, [I, [I)"
  },
  "android.content.pm.IShortcutService": {
    "1": "boolean setDynamicShortcuts(java.lang.String, android.content.pm.ParceledListSlice, int)",
    "2": "boolean addDynamicShortcuts(java.lang.String, android.content.pm.ParceledListSlice, int)",
    "3": "void removeDynamicShortcuts(java.lang.String, java.util.List, int)",
    "4": "void removeAllDynamicShortcuts(java.lang.String, int)",
    "5": "boolean updateShortcuts(java.lang.String, android.content.pm.ParceledListSlice, int)",
    "6": "void requestPinShortcut(java.lang.String, android.content.pm.ShortcutInfo, android.content.IntentSender, int, com.android.internal.infra.AndroidFuture)",
    "7": "void createShortcutResultIntent(java.lang.String, android.content.pm.ShortcutInfo, int, com.android.internal.infra.AndroidFuture)",
    "8": "void disableShortcuts(java.lang.String, java.util.List, java.lang.CharSequence, int, int)",
    "9": "void enableShortcuts(java.lang.String, java.util.List, int)",
    "10": "int getMaxShortcutCountPerActivity(java.lang.String, int)",
    "11": "int getRemainingCallCount(java.lang.String, int)",
    "12": "long getRateLimitResetTime(java.lang.String, int)",
    "13": "int getIconMaxDimensions(java.lang.String, int)",
    "14": "void reportShortcutUsed(java.lang.String, java.lang.String, int)",
    "15": "void resetThrottling()",
    "16": "void onApplicationActive(java.lang.String, int)",
    "17": "[B getBackupPayload(int)",
    "18": "void applyRestore([B, int)",
    "19": "boolean isRequestPinItemSupported(int, int)",
    "20": "android.content.pm.ParceledListSlice getShareTargets(java.lang.String, android.content.IntentFilter, int)",
    "21": "boolean hasShareTargets(java.lang.String, java.lang.String, int)",
    "22": "void removeLongLivedShortcuts(java.lang.String, java.util.List, int)",
    "23": "android.content.pm.ParceledListSlice getShortcuts(java.lang.String, int, int)",
    "24": "void pushDynamicShortcut(java.lang.String, android.content.pm.ShortcutInfo, int)"
  },
  "android.service.gatekeeper.IGateKeeperService": {
    "1": "android.service.gatekeeper.GateKeeperResponse enroll(int, [B, [B, [B)",
    "2": "android.service.gatekeeper.GateKeeperResponse verify(int, [B, [B)",
    "3": "android.service.gatekeeper.GateKeeperResponse verifyChallenge(int, long, [B, [B)",
    "4": "long getSecureUserId(int)",
    "5": "void clearSecureUserId(int)",
    "6": "void reportDeviceSetupComplete()"
  },
  "android.se.omapi.ISecureElementService": {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "5": "5",
    "6": "6"
  },
  "com.android.internal.telephony.ITelephony": {
    "1": "void dial(java.lang.String)",
    "2": "void call(java.lang.String, java.lang.String)",
    "3": "boolean isRadioOn(java.lang.String)",
    "4": "boolean isRadioOnWithFeature(java.lang.String, java.lang.String)",
    "5": "boolean isRadioOnForSubscriber(int, java.lang.String)",
    "6": "boolean isRadioOnForSubscriberWithFeature(int, java.lang.String, java.lang.String)",
    "7": "void setCallComposerStatus(int, int)",
    "8": "int getCallComposerStatus(int)",
    "9": "boolean supplyPinForSubscriber(int, java.lang.String)",
    "10": "boolean supplyPukForSubscriber(int, java.lang.String, java.lang.String)",
    "11": "[I supplyPinReportResultForSubscriber(int, java.lang.String)",
    "12": "[I supplyPukReportResultForSubscriber(int, java.lang.String, java.lang.String)",
    "13": "boolean handlePinMmi(java.lang.String)",
    "14": "void handleUssdRequest(int, java.lang.String, android.os.ResultReceiver)",
    "15": "boolean handlePinMmiForSubscriber(int, java.lang.String)",
    "16": "void toggleRadioOnOff()",
    "17": "void toggleRadioOnOffForSubscriber(int)",
    "18": "boolean setRadio(boolean)",
    "19": "boolean setRadioForSubscriber(int, boolean)",
    "20": "boolean setRadioPower(boolean)",
    "21": "boolean requestRadioPowerOffForReason(int, int)",
    "22": "boolean clearRadioPowerOffForReason(int, int)",
    "23": "java.util.List getRadioPowerOffReasons(int, java.lang.String, java.lang.String)",
    "24": "void updateServiceLocation()",
    "25": "void updateServiceLocationWithPackageName(java.lang.String)",
    "26": "void enableLocationUpdates()",
    "27": "void disableLocationUpdates()",
    "28": "boolean enableDataConnectivity(java.lang.String)",
    "29": "boolean disableDataConnectivity(java.lang.String)",
    "30": "boolean isDataConnectivityPossible(int)",
    "31": "android.telephony.CellIdentity getCellLocation(java.lang.String, java.lang.String)",
    "32": "java.lang.String getNetworkCountryIsoForPhone(int)",
    "33": "java.util.List getNeighboringCellInfo(java.lang.String, java.lang.String)",
    "34": "int getCallState()",
    "35": "int getCallStateForSubscription(int, java.lang.String, java.lang.String)",
    "36": "int getDataActivity()",
    "37": "int getDataActivityForSubId(int)",
    "38": "int getDataState()",
    "39": "int getDataStateForSubId(int)",
    "40": "int getActivePhoneType()",
    "41": "int getActivePhoneTypeForSlot(int)",
    "42": "int getCdmaEriIconIndex(java.lang.String, java.lang.String)",
    "43": "int getCdmaEriIconIndexForSubscriber(int, java.lang.String, java.lang.String)",
    "44": "int getCdmaEriIconMode(java.lang.String, java.lang.String)",
    "45": "int getCdmaEriIconModeForSubscriber(int, java.lang.String, java.lang.String)",
    "46": "java.lang.String getCdmaEriText(java.lang.String, java.lang.String)",
    "47": "java.lang.String getCdmaEriTextForSubscriber(int, java.lang.String, java.lang.String)",
    "48": "boolean needsOtaServiceProvisioning()",
    "49": "boolean setVoiceMailNumber(int, java.lang.String, java.lang.String)",
    "50": "void setVoiceActivationState(int, int)",
    "51": "void setDataActivationState(int, int)",
    "52": "int getVoiceActivationState(int, java.lang.String)",
    "53": "int getDataActivationState(int, java.lang.String)",
    "54": "int getVoiceMessageCountForSubscriber(int, java.lang.String, java.lang.String)",
    "55": "boolean isConcurrentVoiceAndDataAllowed(int)",
    "56": "android.os.Bundle getVisualVoicemailSettings(java.lang.String, int)",
    "57": "java.lang.String getVisualVoicemailPackageName(java.lang.String, java.lang.String, int)",
    "58": "void enableVisualVoicemailSmsFilter(java.lang.String, int, android.telephony.VisualVoicemailSmsFilterSettings)",
    "59": "void disableVisualVoicemailSmsFilter(java.lang.String, int)",
    "60": "android.telephony.VisualVoicemailSmsFilterSettings getVisualVoicemailSmsFilterSettings(java.lang.String, int)",
    "61": "android.telephony.VisualVoicemailSmsFilterSettings getActiveVisualVoicemailSmsFilterSettings(int)",
    "62": "void sendVisualVoicemailSmsForSubscriber(java.lang.String, java.lang.String, int, java.lang.String, int, java.lang.String, android.app.PendingIntent)",
    "63": "void sendDialerSpecialCode(java.lang.String, java.lang.String)",
    "64": "int getNetworkTypeForSubscriber(int, java.lang.String, java.lang.String)",
    "65": "int getDataNetworkType(java.lang.String, java.lang.String)",
    "66": "int getDataNetworkTypeForSubscriber(int, java.lang.String, java.lang.String)",
    "67": "int getVoiceNetworkTypeForSubscriber(int, java.lang.String, java.lang.String)",
    "68": "boolean hasIccCard()",
    "69": "boolean hasIccCardUsingSlotIndex(int)",
    "70": "int getLteOnCdmaMode(java.lang.String, java.lang.String)",
    "71": "int getLteOnCdmaModeForSubscriber(int, java.lang.String, java.lang.String)",
    "72": "java.util.List getAllCellInfo(java.lang.String, java.lang.String)",
    "73": "void requestCellInfoUpdate(int, android.telephony.ICellInfoCallback, java.lang.String, java.lang.String)",
    "74": "void requestCellInfoUpdateWithWorkSource(int, android.telephony.ICellInfoCallback, java.lang.String, java.lang.String, android.os.WorkSource)",
    "75": "void setCellInfoListRate(int, int)",
    "76": "android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(com.android.internal.telephony.IccLogicalChannelRequest)",
    "77": "boolean iccCloseLogicalChannel(com.android.internal.telephony.IccLogicalChannelRequest)",
    "78": "java.lang.String iccTransmitApduLogicalChannelByPort(int, int, int, int, int, int, int, int, java.lang.String)",
    "79": "java.lang.String iccTransmitApduLogicalChannel(int, int, int, int, int, int, int, java.lang.String)",
    "80": "java.lang.String iccTransmitApduBasicChannelByPort(int, int, java.lang.String, int, int, int, int, int, java.lang.String)",
    "81": "java.lang.String iccTransmitApduBasicChannel(int, java.lang.String, int, int, int, int, int, java.lang.String)",
    "82": "[B iccExchangeSimIO(int, int, int, int, int, int, java.lang.String)",
    "83": "java.lang.String sendEnvelopeWithStatus(int, java.lang.String)",
    "84": "java.lang.String nvReadItem(int)",
    "85": "boolean nvWriteItem(int, java.lang.String)",
    "86": "boolean nvWriteCdmaPrl([B)",
    "87": "boolean resetModemConfig(int)",
    "88": "boolean rebootModem(int)",
    "89": "int getAllowedNetworkTypesBitmask(int)",
    "90": "boolean isTetheringApnRequiredForSubscriber(int)",
    "91": "void enableIms(int)",
    "92": "void disableIms(int)",
    "93": "void resetIms(int)",
    "94": "void registerMmTelFeatureCallback(int, com.android.ims.internal.IImsServiceFeatureCallback)",
    "95": "void unregisterImsFeatureCallback(com.android.ims.internal.IImsServiceFeatureCallback)",
    "96": "android.telephony.ims.aidl.IImsRegistration getImsRegistration(int, int)",
    "97": "android.telephony.ims.aidl.IImsConfig getImsConfig(int, int)",
    "98": "boolean setBoundImsServiceOverride(int, boolean, [I, java.lang.String)",
    "99": "boolean clearCarrierImsServiceOverride(int)",
    "100": "java.lang.String getBoundImsServicePackage(int, boolean, int)",
    "101": "void getImsMmTelFeatureState(int, com.android.internal.telephony.IIntegerConsumer)",
    "102": "void setNetworkSelectionModeAutomatic(int)",
    "103": "com.android.internal.telephony.CellNetworkScanResult getCellNetworkScanResults(int, java.lang.String, java.lang.String)",
    "104": "int requestNetworkScan(int, boolean, android.telephony.NetworkScanRequest, android.os.Messenger, android.os.IBinder, java.lang.String, java.lang.String)",
    "105": "void stopNetworkScan(int, int)",
    "106": "boolean setNetworkSelectionModeManual(int, com.android.internal.telephony.OperatorInfo, boolean)",
    "107": "long getAllowedNetworkTypesForReason(int, int)",
    "108": "boolean setAllowedNetworkTypesForReason(int, int, long)",
    "109": "boolean getDataEnabled(int)",
    "110": "boolean isUserDataEnabled(int)",
    "111": "boolean isDataEnabled(int)",
    "112": "void setDataEnabledForReason(int, int, boolean, java.lang.String)",
    "113": "boolean isDataEnabledForReason(int, int)",
    "114": "boolean isManualNetworkSelectionAllowed(int)",
    "115": "void setImsRegistrationState(boolean)",
    "116": "java.lang.String getCdmaMdn(int)",
    "117": "java.lang.String getCdmaMin(int)",
    "118": "void requestNumberVerification(android.telephony.PhoneNumberRange, long, com.android.internal.telephony.INumberVerificationCallback, java.lang.String)",
    "119": "int getCarrierPrivilegeStatus(int)",
    "120": "int getCarrierPrivilegeStatusForUid(int, int)",
    "121": "int checkCarrierPrivilegesForPackage(int, java.lang.String)",
    "122": "int checkCarrierPrivilegesForPackageAnyPhone(java.lang.String)",
    "123": "java.util.List getCarrierPackageNamesForIntentAndPhone(android.content.Intent, int)",
    "124": "boolean setLine1NumberForDisplayForSubscriber(int, java.lang.String, java.lang.String)",
    "125": "java.lang.String getLine1NumberForDisplay(int, java.lang.String, java.lang.String)",
    "126": "java.lang.String getLine1AlphaTagForDisplay(int, java.lang.String, java.lang.String)",
    "127": "[Ljava.lang.String; getMergedSubscriberIds(int, java.lang.String, java.lang.String)",
    "128": "[Ljava.lang.String; getMergedImsisFromGroup(int, java.lang.String)",
    "129": "boolean setOperatorBrandOverride(int, java.lang.String)",
    "130": "boolean setRoamingOverride(int, java.util.List, java.util.List, java.util.List, java.util.List)",
    "131": "int invokeOemRilRequestRaw([B, [B)",
    "132": "boolean needMobileRadioShutdown()",
    "133": "void shutdownMobileRadios()",
    "134": "int getRadioAccessFamily(int, java.lang.String)",
    "135": "void uploadCallComposerPicture(int, java.lang.String, java.lang.String, android.os.ParcelFileDescriptor, android.os.ResultReceiver)",
    "136": "void enableVideoCalling(boolean)",
    "137": "boolean isVideoCallingEnabled(java.lang.String, java.lang.String)",
    "138": "boolean canChangeDtmfToneLength(int, java.lang.String, java.lang.String)",
    "139": "boolean isWorldPhone(int, java.lang.String, java.lang.String)",
    "140": "boolean isTtyModeSupported()",
    "141": "boolean isRttSupported(int)",
    "142": "boolean isHearingAidCompatibilitySupported()",
    "143": "boolean isImsRegistered(int)",
    "144": "boolean isWifiCallingAvailable(int)",
    "145": "boolean isVideoTelephonyAvailable(int)",
    "146": "int getImsRegTechnologyForMmTel(int)",
    "147": "java.lang.String getDeviceId(java.lang.String)",
    "148": "java.lang.String getDeviceIdWithFeature(java.lang.String, java.lang.String)",
    "149": "java.lang.String getImeiForSlot(int, java.lang.String, java.lang.String)",
    "150": "java.lang.String getPrimaryImei(java.lang.String, java.lang.String)",
    "151": "java.lang.String getTypeAllocationCodeForSlot(int)",
    "152": "java.lang.String getMeidForSlot(int, java.lang.String, java.lang.String)",
    "153": "java.lang.String getManufacturerCodeForSlot(int)",
    "154": "java.lang.String getDeviceSoftwareVersionForSlot(int, java.lang.String, java.lang.String)",
    "155": "int getSubIdForPhoneAccountHandle(android.telecom.PhoneAccountHandle, java.lang.String, java.lang.String)",
    "156": "android.telecom.PhoneAccountHandle getPhoneAccountHandleForSubscriptionId(int)",
    "157": "void factoryReset(int, java.lang.String)",
    "158": "java.lang.String getSimLocaleForSubscriber(int)",
    "159": "void requestModemActivityInfo(android.os.ResultReceiver)",
    "160": "android.telephony.ServiceState getServiceStateForSubscriber(int, boolean, boolean, java.lang.String, java.lang.String)",
    "161": "android.net.Uri getVoicemailRingtoneUri(android.telecom.PhoneAccountHandle)",
    "162": "void setVoicemailRingtoneUri(java.lang.String, android.telecom.PhoneAccountHandle, android.net.Uri)",
    "163": "boolean isVoicemailVibrationEnabled(android.telecom.PhoneAccountHandle)",
    "164": "void setVoicemailVibrationEnabled(java.lang.String, android.telecom.PhoneAccountHandle, boolean)",
    "165": "java.util.List getPackagesWithCarrierPrivileges(int)",
    "166": "java.util.List getPackagesWithCarrierPrivilegesForAllPhones()",
    "167": "java.lang.String getAidForAppType(int, int)",
    "168": "java.lang.String getEsn(int)",
    "169": "java.lang.String getCdmaPrlVersion(int)",
    "170": "java.util.List getTelephonyHistograms()",
    "171": "int setAllowedCarriers(android.telephony.CarrierRestrictionRules)",
    "172": "android.telephony.CarrierRestrictionRules getAllowedCarriers()",
    "173": "int getSubscriptionCarrierId(int)",
    "174": "java.lang.String getSubscriptionCarrierName(int)",
    "175": "int getSubscriptionSpecificCarrierId(int)",
    "176": "java.lang.String getSubscriptionSpecificCarrierName(int)",
    "177": "int getCarrierIdFromMccMnc(int, java.lang.String, boolean)",
    "178": "void carrierActionSetRadioEnabled(int, boolean)",
    "179": "void carrierActionReportDefaultNetworkStatus(int, boolean)",
    "180": "void carrierActionResetAll(int)",
    "181": "void getCallForwarding(int, int, com.android.internal.telephony.ICallForwardingInfoCallback)",
    "182": "void setCallForwarding(int, android.telephony.CallForwardingInfo, com.android.internal.telephony.IIntegerConsumer)",
    "183": "void getCallWaitingStatus(int, com.android.internal.telephony.IIntegerConsumer)",
    "184": "void setCallWaitingStatus(int, boolean, com.android.internal.telephony.IIntegerConsumer)",
    "185": "java.util.List getClientRequestStats(java.lang.String, java.lang.String, int)",
    "186": "void setSimPowerStateForSlot(int, int)",
    "187": "void setSimPowerStateForSlotWithCallback(int, int, com.android.internal.telephony.IIntegerConsumer)",
    "188": "[Ljava.lang.String; getForbiddenPlmns(int, int, java.lang.String, java.lang.String)",
    "189": "int setForbiddenPlmns(int, int, java.util.List, java.lang.String, java.lang.String)",
    "190": "boolean getEmergencyCallbackMode(int)",
    "191": "android.telephony.SignalStrength getSignalStrength(int)",
    "192": "int getCardIdForDefaultEuicc(int, java.lang.String)",
    "193": "java.util.List getUiccCardsInfo(java.lang.String)",
    "194": "[Landroid.telephony.UiccSlotInfo; getUiccSlotsInfo(java.lang.String)",
    "195": "boolean switchSlots([I)",
    "196": "boolean setSimSlotMapping(java.util.List)",
    "197": "boolean isDataRoamingEnabled(int)",
    "198": "void setDataRoamingEnabled(int, boolean)",
    "199": "int getCdmaRoamingMode(int)",
    "200": "boolean setCdmaRoamingMode(int, int)",
    "201": "int getCdmaSubscriptionMode(int)",
    "202": "boolean setCdmaSubscriptionMode(int, int)",
    "203": "void setCarrierTestOverride(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "204": "void setCarrierServicePackageOverride(int, java.lang.String, java.lang.String)",
    "205": "int getCarrierIdListVersion(int)",
    "206": "void refreshUiccProfile(int)",
    "207": "int getNumberOfModemsWithSimultaneousDataConnections(int, java.lang.String, java.lang.String)",
    "208": "int getNetworkSelectionMode(int)",
    "209": "boolean isInEmergencySmsMode()",
    "210": "int getRadioPowerState(int, java.lang.String, java.lang.String)",
    "211": "void registerImsRegistrationCallback(int, android.telephony.ims.aidl.IImsRegistrationCallback)",
    "212": "void unregisterImsRegistrationCallback(int, android.telephony.ims.aidl.IImsRegistrationCallback)",
    "213": "void getImsMmTelRegistrationState(int, com.android.internal.telephony.IIntegerConsumer)",
    "214": "void getImsMmTelRegistrationTransportType(int, com.android.internal.telephony.IIntegerConsumer)",
    "215": "void registerMmTelCapabilityCallback(int, android.telephony.ims.aidl.IImsCapabilityCallback)",
    "216": "void unregisterMmTelCapabilityCallback(int, android.telephony.ims.aidl.IImsCapabilityCallback)",
    "217": "boolean isCapable(int, int, int)",
    "218": "boolean isAvailable(int, int, int)",
    "219": "void isMmTelCapabilitySupported(int, com.android.internal.telephony.IIntegerConsumer, int, int)",
    "220": "boolean isAdvancedCallingSettingEnabled(int)",
    "221": "void setAdvancedCallingSettingEnabled(int, boolean)",
    "222": "boolean isVtSettingEnabled(int)",
    "223": "void setVtSettingEnabled(int, boolean)",
    "224": "boolean isVoWiFiSettingEnabled(int)",
    "225": "void setVoWiFiSettingEnabled(int, boolean)",
    "226": "boolean isCrossSimCallingEnabledByUser(int)",
    "227": "void setCrossSimCallingEnabled(int, boolean)",
    "228": "boolean isVoWiFiRoamingSettingEnabled(int)",
    "229": "void setVoWiFiRoamingSettingEnabled(int, boolean)",
    "230": "void setVoWiFiNonPersistent(int, boolean, int)",
    "231": "int getVoWiFiModeSetting(int)",
    "232": "void setVoWiFiModeSetting(int, int)",
    "233": "int getVoWiFiRoamingModeSetting(int)",
    "234": "void setVoWiFiRoamingModeSetting(int, int)",
    "235": "void setRttCapabilitySetting(int, boolean)",
    "236": "boolean isTtyOverVolteEnabled(int)",
    "237": "java.util.Map getEmergencyNumberList(java.lang.String, java.lang.String)",
    "238": "boolean isEmergencyNumber(java.lang.String, boolean)",
    "239": "java.util.List getCertsFromCarrierPrivilegeAccessRules(int)",
    "240": "void registerImsProvisioningChangedCallback(int, android.telephony.ims.aidl.IImsConfigCallback)",
    "241": "void unregisterImsProvisioningChangedCallback(int, android.telephony.ims.aidl.IImsConfigCallback)",
    "242": "void registerFeatureProvisioningChangedCallback(int, android.telephony.ims.aidl.IFeatureProvisioningCallback)",
    "243": "void unregisterFeatureProvisioningChangedCallback(int, android.telephony.ims.aidl.IFeatureProvisioningCallback)",
    "244": "void setImsProvisioningStatusForCapability(int, int, int, boolean)",
    "245": "boolean getImsProvisioningStatusForCapability(int, int, int)",
    "246": "boolean getRcsProvisioningStatusForCapability(int, int, int)",
    "247": "void setRcsProvisioningStatusForCapability(int, int, int, boolean)",
    "248": "int getImsProvisioningInt(int, int)",
    "249": "java.lang.String getImsProvisioningString(int, int)",
    "250": "int setImsProvisioningInt(int, int, int)",
    "251": "int setImsProvisioningString(int, int, java.lang.String)",
    "252": "void startEmergencyCallbackMode()",
    "253": "void updateEmergencyNumberListTestMode(int, android.telephony.emergency.EmergencyNumber)",
    "254": "java.util.List getEmergencyNumberListTestMode()",
    "255": "int getEmergencyNumberDbVersion(int)",
    "256": "void notifyOtaEmergencyNumberDbInstalled()",
    "257": "void updateOtaEmergencyNumberDbFilePath(android.os.ParcelFileDescriptor)",
    "258": "void resetOtaEmergencyNumberDbFilePath()",
    "259": "boolean enableModemForSlot(int, boolean)",
    "260": "void setMultiSimCarrierRestriction(boolean)",
    "261": "int isMultiSimSupported(java.lang.String, java.lang.String)",
    "262": "void switchMultiSimConfig(int)",
    "263": "boolean doesSwitchMultiSimConfigTriggerReboot(int, java.lang.String, java.lang.String)",
    "264": "java.util.List getSlotsMapping(java.lang.String)",
    "265": "int getRadioHalVersion()",
    "266": "int getHalVersion(int)",
    "267": "java.lang.String getCurrentPackageName()",
    "268": "boolean isApplicationOnUicc(int, int)",
    "269": "boolean isModemEnabledForSlot(int, java.lang.String, java.lang.String)",
    "270": "boolean isDataEnabledForApn(int, int, java.lang.String)",
    "271": "boolean isApnMetered(int, int)",
    "272": "void setSystemSelectionChannels(java.util.List, int, com.android.internal.telephony.IBooleanConsumer)",
    "273": "java.util.List getSystemSelectionChannels(int)",
    "274": "boolean isMvnoMatched(int, int, java.lang.String)",
    "275": "void enqueueSmsPickResult(java.lang.String, java.lang.String, com.android.internal.telephony.IIntegerConsumer)",
    "276": "void showSwitchToManagedProfileDialog()",
    "277": "java.lang.String getMmsUserAgent(int)",
    "278": "java.lang.String getMmsUAProfUrl(int)",
    "279": "void setMobileDataPolicyEnabled(int, int, boolean)",
    "280": "boolean isMobileDataPolicyEnabled(int, int)",
    "281": "void setCepEnabled(boolean)",
    "282": "void notifyRcsAutoConfigurationReceived(int, [B, boolean)",
    "283": "boolean isIccLockEnabled(int)",
    "284": "int setIccLockEnabled(int, boolean, java.lang.String)",
    "285": "int changeIccLockPassword(int, java.lang.String, java.lang.String)",
    "286": "void requestUserActivityNotification()",
    "287": "void userActivity()",
    "288": "java.lang.String getManualNetworkSelectionPlmn(int)",
    "289": "boolean canConnectTo5GInDsdsMode()",
    "290": "java.util.List getEquivalentHomePlmns(int, java.lang.String, java.lang.String)",
    "291": "int setVoNrEnabled(int, boolean)",
    "292": "boolean isVoNrEnabled(int)",
    "293": "int setNrDualConnectivityState(int, int)",
    "294": "boolean isNrDualConnectivityEnabled(int)",
    "295": "boolean isRadioInterfaceCapabilitySupported(java.lang.String)",
    "296": "int sendThermalMitigationRequest(int, android.telephony.ThermalMitigationRequest, java.lang.String)",
    "297": "void bootstrapAuthenticationRequest(int, int, android.net.Uri, android.telephony.gba.UaSecurityProtocolIdentifier, boolean, android.telephony.IBootstrapAuthenticationCallback)",
    "298": "boolean setBoundGbaServiceOverride(int, java.lang.String)",
    "299": "java.lang.String getBoundGbaService(int)",
    "300": "boolean setGbaReleaseTimeOverride(int, int)",
    "301": "int getGbaReleaseTime(int)",
    "302": "void setRcsClientConfiguration(int, android.telephony.ims.RcsClientConfiguration)",
    "303": "boolean isRcsVolteSingleRegistrationCapable(int)",
    "304": "void registerRcsProvisioningCallback(int, android.telephony.ims.aidl.IRcsConfigCallback)",
    "305": "void unregisterRcsProvisioningCallback(int, android.telephony.ims.aidl.IRcsConfigCallback)",
    "306": "void triggerRcsReconfiguration(int)",
    "307": "void setRcsSingleRegistrationTestModeEnabled(boolean)",
    "308": "boolean getRcsSingleRegistrationTestModeEnabled()",
    "309": "void setDeviceSingleRegistrationEnabledOverride(java.lang.String)",
    "310": "boolean getDeviceSingleRegistrationEnabled()",
    "311": "boolean setCarrierSingleRegistrationEnabledOverride(int, java.lang.String)",
    "312": "void sendDeviceToDeviceMessage(int, int)",
    "313": "void setActiveDeviceToDeviceTransport(java.lang.String)",
    "314": "void setDeviceToDeviceForceEnabled(boolean)",
    "315": "boolean getCarrierSingleRegistrationEnabled(int)",
    "316": "boolean setImsFeatureValidationOverride(int, java.lang.String)",
    "317": "boolean getImsFeatureValidationOverride(int)",
    "318": "java.lang.String getMobileProvisioningUrl()",
    "319": "int removeContactFromEab(int, java.lang.String)",
    "320": "java.lang.String getContactFromEab(java.lang.String)",
    "321": "java.lang.String getCapabilityFromEab(java.lang.String)",
    "322": "boolean getDeviceUceEnabled()",
    "323": "void setDeviceUceEnabled(boolean)",
    "324": "android.telephony.ims.RcsContactUceCapability addUceRegistrationOverrideShell(int, java.util.List)",
    "325": "android.telephony.ims.RcsContactUceCapability removeUceRegistrationOverrideShell(int, java.util.List)",
    "326": "android.telephony.ims.RcsContactUceCapability clearUceRegistrationOverrideShell(int)",
    "327": "android.telephony.ims.RcsContactUceCapability getLatestRcsContactUceCapabilityShell(int)",
    "328": "java.lang.String getLastUcePidfXmlShell(int)",
    "329": "boolean removeUceRequestDisallowedStatus(int)",
    "330": "boolean setCapabilitiesRequestTimeout(int, long)",
    "331": "void setSignalStrengthUpdateRequest(int, android.telephony.SignalStrengthUpdateRequest, java.lang.String)",
    "332": "void clearSignalStrengthUpdateRequest(int, android.telephony.SignalStrengthUpdateRequest, java.lang.String)",
    "333": "android.telephony.PhoneCapability getPhoneCapability()",
    "334": "int prepareForUnattendedReboot()",
    "335": "void getSlicingConfig(android.os.ResultReceiver)",
    "336": "boolean isPremiumCapabilityAvailableForPurchase(int, int)",
    "337": "void purchasePremiumCapability(int, com.android.internal.telephony.IIntegerConsumer, int)",
    "338": "void registerImsStateCallback(int, int, com.android.internal.telephony.IImsStateCallback, java.lang.String)",
    "339": "void unregisterImsStateCallback(com.android.internal.telephony.IImsStateCallback)",
    "340": "android.telephony.CellIdentity getLastKnownCellIdentity(int, java.lang.String, java.lang.String)",
    "341": "boolean setModemService(java.lang.String)",
    "342": "java.lang.String getModemService()",
    "343": "boolean isProvisioningRequiredForCapability(int, int, int)",
    "344": "boolean isRcsProvisioningRequiredForCapability(int, int, int)",
    "345": "void setVoiceServiceStateOverride(int, boolean, java.lang.String)",
    "346": "java.lang.String getCarrierServicePackageNameForLogicalSlot(int)",
    "347": "void setRemovableEsimAsDefaultEuicc(boolean, java.lang.String)",
    "348": "boolean isRemovableEsimDefaultEuicc(java.lang.String)",
    "349": "android.content.ComponentName getDefaultRespondViaMessageApplication(int, boolean)",
    "350": "int getSimStateForSlotIndex(int)",
    "351": "void persistEmergencyCallDiagnosticData(java.lang.String, boolean, long, boolean, boolean)",
    "352": "void setNullCipherAndIntegrityEnabled(boolean)",
    "353": "boolean isNullCipherAndIntegrityPreferenceEnabled()",
    "354": "java.util.List getCellBroadcastIdRanges(int)",
    "355": "void setCellBroadcastIdRanges(int, java.util.List, com.android.internal.telephony.IIntegerConsumer)",
    "356": "boolean isDomainSelectionSupported()",
    "357": "void getCarrierRestrictionStatus(com.android.internal.telephony.IIntegerConsumer, java.lang.String)",
    "358": "void requestSatelliteEnabled(int, boolean, boolean, com.android.internal.telephony.IIntegerConsumer)",
    "359": "void requestIsSatelliteEnabled(int, android.os.ResultReceiver)",
    "360": "void requestIsDemoModeEnabled(int, android.os.ResultReceiver)",
    "361": "void requestIsSatelliteSupported(int, android.os.ResultReceiver)",
    "362": "void requestSatelliteCapabilities(int, android.os.ResultReceiver)",
    "363": "void startSatelliteTransmissionUpdates(int, com.android.internal.telephony.IIntegerConsumer, android.telephony.satellite.ISatelliteTransmissionUpdateCallback)",
    "364": "void stopSatelliteTransmissionUpdates(int, com.android.internal.telephony.IIntegerConsumer, android.telephony.satellite.ISatelliteTransmissionUpdateCallback)",
    "365": "android.os.ICancellationSignal provisionSatelliteService(int, java.lang.String, [B, com.android.internal.telephony.IIntegerConsumer)",
    "366": "void deprovisionSatelliteService(int, java.lang.String, com.android.internal.telephony.IIntegerConsumer)",
    "367": "int registerForSatelliteProvisionStateChanged(int, android.telephony.satellite.ISatelliteProvisionStateCallback)",
    "368": "void unregisterForSatelliteProvisionStateChanged(int, android.telephony.satellite.ISatelliteProvisionStateCallback)",
    "369": "void requestIsSatelliteProvisioned(int, android.os.ResultReceiver)",
    "370": "int registerForSatelliteModemStateChanged(int, android.telephony.satellite.ISatelliteStateCallback)",
    "371": "void unregisterForSatelliteModemStateChanged(int, android.telephony.satellite.ISatelliteStateCallback)",
    "372": "int registerForSatelliteDatagram(int, android.telephony.satellite.ISatelliteDatagramCallback)",
    "373": "void unregisterForSatelliteDatagram(int, android.telephony.satellite.ISatelliteDatagramCallback)",
    "374": "void pollPendingSatelliteDatagrams(int, com.android.internal.telephony.IIntegerConsumer)",
    "375": "void sendSatelliteDatagram(int, int, android.telephony.satellite.SatelliteDatagram, boolean, com.android.internal.telephony.IIntegerConsumer)",
    "376": "void requestIsSatelliteCommunicationAllowedForCurrentLocation(int, android.os.ResultReceiver)",
    "377": "void requestTimeForNextSatelliteVisibility(int, android.os.ResultReceiver)",
    "378": "void onDeviceAlignedWithSatellite(int, boolean)",
    "379": "boolean setSatelliteServicePackageName(java.lang.String)",
    "380": "boolean setSatelliteGatewayServicePackageName(java.lang.String)",
    "381": "boolean setSatelliteListeningTimeoutDuration(long)",
    "382": "boolean setSatellitePointingUiClassName(java.lang.String, java.lang.String)",
    "383": "boolean setSatelliteDeviceAlignedTimeoutDuration(long)",
    "384": "java.util.List getShaIdFromAllowList(java.lang.String, int)"
  },
  "com.android.internal.telephony.ISub": {
    "1": "java.util.List getAllSubInfoList(java.lang.String, java.lang.String)",
    "2": "android.telephony.SubscriptionInfo getActiveSubscriptionInfo(int, java.lang.String, java.lang.String)",
    "3": "android.telephony.SubscriptionInfo getActiveSubscriptionInfoForIccId(java.lang.String, java.lang.String, java.lang.String)",
    "4": "android.telephony.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int, java.lang.String, java.lang.String)",
    "5": "java.util.List getActiveSubscriptionInfoList(java.lang.String, java.lang.String)",
    "6": "int getActiveSubInfoCount(java.lang.String, java.lang.String)",
    "7": "int getActiveSubInfoCountMax()",
    "8": "java.util.List getAvailableSubscriptionInfoList(java.lang.String, java.lang.String)",
    "9": "java.util.List getAccessibleSubscriptionInfoList(java.lang.String)",
    "10": "void requestEmbeddedSubscriptionInfoListRefresh(int)",
    "11": "int addSubInfo(java.lang.String, java.lang.String, int, int)",
    "12": "boolean removeSubInfo(java.lang.String, int)",
    "13": "int setIconTint(int, int)",
    "14": "int setDisplayNameUsingSrc(java.lang.String, int, int)",
    "15": "int setDisplayNumber(java.lang.String, int)",
    "16": "int setDataRoaming(int, int)",
    "17": "int setOpportunistic(boolean, int, java.lang.String)",
    "18": "android.os.ParcelUuid createSubscriptionGroup([I, java.lang.String)",
    "19": "void setPreferredDataSubscriptionId(int, boolean, com.android.internal.telephony.ISetOpportunisticDataCallback)",
    "20": "int getPreferredDataSubscriptionId()",
    "21": "java.util.List getOpportunisticSubscriptions(java.lang.String, java.lang.String)",
    "22": "void removeSubscriptionsFromGroup([I, android.os.ParcelUuid, java.lang.String)",
    "23": "void addSubscriptionsIntoGroup([I, android.os.ParcelUuid, java.lang.String)",
    "24": "java.util.List getSubscriptionsInGroup(android.os.ParcelUuid, java.lang.String, java.lang.String)",
    "25": "int getSlotIndex(int)",
    "26": "int getSubId(int)",
    "27": "int getDefaultSubId()",
    "28": "int getPhoneId(int)",
    "29": "int getDefaultDataSubId()",
    "30": "void setDefaultDataSubId(int)",
    "31": "int getDefaultVoiceSubId()",
    "32": "void setDefaultVoiceSubId(int)",
    "33": "int getDefaultSmsSubId()",
    "34": "void setDefaultSmsSubId(int)",
    "35": "[I getActiveSubIdList(boolean)",
    "36": "void setSubscriptionProperty(int, java.lang.String, java.lang.String)",
    "37": "java.lang.String getSubscriptionProperty(int, java.lang.String, java.lang.String, java.lang.String)",
    "38": "boolean isSubscriptionEnabled(int)",
    "39": "int getEnabledSubscriptionId(int)",
    "40": "boolean isActiveSubId(int, java.lang.String, java.lang.String)",
    "41": "int getActiveDataSubscriptionId()",
    "42": "boolean canDisablePhysicalSubscription()",
    "43": "void setUiccApplicationsEnabled(boolean, int)",
    "44": "int setDeviceToDeviceStatusSharing(int, int)",
    "45": "int setDeviceToDeviceStatusSharingContacts(java.lang.String, int)",
    "46": "java.lang.String getPhoneNumber(int, int, java.lang.String, java.lang.String)",
    "47": "java.lang.String getPhoneNumberFromFirstAvailableSource(int, java.lang.String, java.lang.String)",
    "48": "void setPhoneNumber(int, int, java.lang.String, java.lang.String, java.lang.String)",
    "49": "int setUsageSetting(int, int, java.lang.String)",
    "50": "int setSubscriptionUserHandle(android.os.UserHandle, int)",
    "51": "android.os.UserHandle getSubscriptionUserHandle(int)",
    "52": "boolean isSubscriptionAssociatedWithUser(int, android.os.UserHandle)",
    "53": "java.util.List getSubscriptionInfoListAssociatedWithUser(android.os.UserHandle)",
    "54": "void restoreAllSimSpecificSettingsFromBackup([B)"
  },
  "android.net.vcn.IVcnManagementService": {
    "1": "void setVcnConfig(android.os.ParcelUuid, android.net.vcn.VcnConfig, java.lang.String)",
    "2": "void clearVcnConfig(android.os.ParcelUuid, java.lang.String)",
    "3": "java.util.List getConfiguredSubscriptionGroups(java.lang.String)",
    "4": "void addVcnUnderlyingNetworkPolicyListener(android.net.vcn.IVcnUnderlyingNetworkPolicyListener)",
    "5": "void removeVcnUnderlyingNetworkPolicyListener(android.net.vcn.IVcnUnderlyingNetworkPolicyListener)",
    "6": "android.net.vcn.VcnUnderlyingNetworkPolicy getUnderlyingNetworkPolicy(android.net.NetworkCapabilities, android.net.LinkProperties)",
    "7": "void registerVcnStatusCallback(android.os.ParcelUuid, android.net.vcn.IVcnStatusCallback, java.lang.String)",
    "8": "void unregisterVcnStatusCallback(android.net.vcn.IVcnStatusCallback)"
  },
  "android.app.usage.IStorageStatsManager": {
    "1": "boolean isQuotaSupported(java.lang.String, java.lang.String)",
    "2": "boolean isReservedSupported(java.lang.String, java.lang.String)",
    "3": "long getTotalBytes(java.lang.String, java.lang.String)",
    "4": "long getFreeBytes(java.lang.String, java.lang.String)",
    "5": "long getCacheBytes(java.lang.String, java.lang.String)",
    "6": "long getCacheQuotaBytes(java.lang.String, int, java.lang.String)",
    "7": "android.app.usage.StorageStats queryStatsForPackage(java.lang.String, java.lang.String, int, java.lang.String)",
    "8": "android.app.usage.StorageStats queryStatsForUid(java.lang.String, int, java.lang.String)",
    "9": "android.app.usage.StorageStats queryStatsForUser(java.lang.String, int, java.lang.String)",
    "10": "android.app.usage.ExternalStorageStats queryExternalStatsForUser(java.lang.String, int, java.lang.String)",
    "11": "android.content.pm.ParceledListSlice queryCratesForPackage(java.lang.String, java.lang.String, int, java.lang.String)",
    "12": "android.content.pm.ParceledListSlice queryCratesForUid(java.lang.String, int, java.lang.String)",
    "13": "android.content.pm.ParceledListSlice queryCratesForUser(java.lang.String, int, java.lang.String)"
  },
  "android.content.pm.IPackageManagerNative": {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "5": "5",
    "6": "6",
    "7": "7",
    "8": "8",
    "9": "9",
    "10": "10",
    "11": "11",
    "12": "12",
    "13": "13",
    "14": "14",
    "15": "15"
  },
  "android.app.timezonedetector.ITimeZoneDetectorService": {
    "1": "android.app.time.TimeZoneCapabilitiesAndConfig getCapabilitiesAndConfig()",
    "2": "void addListener(android.app.time.ITimeZoneDetectorListener)",
    "3": "void removeListener(android.app.time.ITimeZoneDetectorListener)",
    "4": "boolean updateConfiguration(android.app.time.TimeZoneConfiguration)",
    "5": "android.app.time.TimeZoneState getTimeZoneState()",
    "6": "boolean confirmTimeZone(java.lang.String)",
    "7": "boolean setManualTimeZone(android.app.timezonedetector.ManualTimeZoneSuggestion)",
    "8": "boolean suggestManualTimeZone(android.app.timezonedetector.ManualTimeZoneSuggestion)",
    "9": "void suggestTelephonyTimeZone(android.app.timezonedetector.TelephonyTimeZoneSuggestion)"
  },
  "android.permission.ILegacyPermissionManager": {
    "1": "int checkDeviceIdentifierAccess(java.lang.String, java.lang.String, java.lang.String, int, int)",
    "2": "int checkPhoneNumberAccess(java.lang.String, java.lang.String, java.lang.String, int, int)",
    "3": "void grantDefaultPermissionsToEnabledCarrierApps([Ljava.lang.String;, int)",
    "4": "void grantDefaultPermissionsToEnabledImsServices([Ljava.lang.String;, int)",
    "5": "void grantDefaultPermissionsToEnabledTelephonyDataServices([Ljava.lang.String;, int)",
    "6": "void revokeDefaultPermissionsFromDisabledTelephonyDataServices([Ljava.lang.String;, int)",
    "7": "void grantDefaultPermissionsToActiveLuiApp(java.lang.String, int)",
    "8": "void revokeDefaultPermissionsFromLuiApps([Ljava.lang.String;, int)",
    "9": "void grantDefaultPermissionsToCarrierServiceApp(java.lang.String, int)"
  },
  "android.app.people.IPeopleManager": {
    "1": "android.app.people.ConversationChannel getConversation(java.lang.String, int, java.lang.String)",
    "2": "android.content.pm.ParceledListSlice getRecentConversations()",
    "3": "void removeRecentConversation(java.lang.String, int, java.lang.String)",
    "4": "void removeAllRecentConversations()",
    "5": "boolean isConversation(java.lang.String, int, java.lang.String)",
    "6": "long getLastInteraction(java.lang.String, int, java.lang.String)",
    "7": "void addOrUpdateStatus(java.lang.String, int, java.lang.String, android.app.people.ConversationStatus)",
    "8": "void clearStatus(java.lang.String, int, java.lang.String, java.lang.String)",
    "9": "void clearStatuses(java.lang.String, int, java.lang.String)",
    "10": "android.content.pm.ParceledListSlice getStatuses(java.lang.String, int, java.lang.String)",
    "11": "void registerConversationListener(java.lang.String, int, java.lang.String, android.app.people.IConversationListener)",
    "12": "void unregisterConversationListener(android.app.people.IConversationListener)"
  },
  "android.content.pm.IDataLoaderManager": {
    "1": "boolean bindToDataLoader(int, android.content.pm.DataLoaderParamsParcel, long, android.content.pm.IDataLoaderStatusListener)",
    "2": "android.content.pm.IDataLoader getDataLoader(int)",
    "3": "void unbindFromDataLoader(int)"
  },
  "android.content.pm.IPackageManager": {
    "1": "void checkPackageStartable(java.lang.String, int)",
    "2": "boolean isPackageAvailable(java.lang.String, int)",
    "3": "android.content.pm.PackageInfo getPackageInfo(java.lang.String, long, int)",
    "4": "android.content.pm.PackageInfo getPackageInfoVersioned(android.content.pm.VersionedPackage, long, int)",
    "5": "int getPackageUid(java.lang.String, long, int)",
    "6": "[I getPackageGids(java.lang.String, long, int)",
    "7": "[Ljava.lang.String; currentToCanonicalPackageNames([Ljava.lang.String;)",
    "8": "[Ljava.lang.String; canonicalToCurrentPackageNames([Ljava.lang.String;)",
    "9": "android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String, long, int)",
    "10": "int getTargetSdkVersion(java.lang.String)",
    "11": "android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName, long, int)",
    "12": "boolean activitySupportsIntentAsUser(android.content.ComponentName, android.content.Intent, java.lang.String, int)",
    "13": "android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName, long, int)",
    "14": "android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName, long, int)",
    "15": "android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName, long, int)",
    "16": "boolean isProtectedBroadcast(java.lang.String)",
    "17": "int checkSignatures(java.lang.String, java.lang.String, int)",
    "18": "int checkUidSignatures(int, int)",
    "19": "java.util.List getAllPackages()",
    "20": "[Ljava.lang.String; getPackagesForUid(int)",
    "21": "java.lang.String getNameForUid(int)",
    "22": "[Ljava.lang.String; getNamesForUids([I)",
    "23": "int getUidForSharedUser(java.lang.String)",
    "24": "int getFlagsForUid(int)",
    "25": "int getPrivateFlagsForUid(int)",
    "26": "boolean isUidPrivileged(int)",
    "27": "android.content.pm.ResolveInfo resolveIntent(android.content.Intent, java.lang.String, long, int)",
    "28": "android.content.pm.ResolveInfo findPersistentPreferredActivity(android.content.Intent, int)",
    "29": "boolean canForwardTo(android.content.Intent, java.lang.String, int, int)",
    "30": "android.content.pm.ParceledListSlice queryIntentActivities(android.content.Intent, java.lang.String, long, int)",
    "31": "android.content.pm.ParceledListSlice queryIntentActivityOptions(android.content.ComponentName, [Landroid.content.Intent;, [Ljava.lang.String;, android.content.Intent, java.lang.String, long, int)",
    "32": "android.content.pm.ParceledListSlice queryIntentReceivers(android.content.Intent, java.lang.String, long, int)",
    "33": "android.content.pm.ResolveInfo resolveService(android.content.Intent, java.lang.String, long, int)",
    "34": "android.content.pm.ParceledListSlice queryIntentServices(android.content.Intent, java.lang.String, long, int)",
    "35": "android.content.pm.ParceledListSlice queryIntentContentProviders(android.content.Intent, java.lang.String, long, int)",
    "36": "android.content.pm.ParceledListSlice getInstalledPackages(long, int)",
    "37": "android.os.ParcelFileDescriptor getAppMetadataFd(java.lang.String, int)",
    "38": "android.content.pm.ParceledListSlice getPackagesHoldingPermissions([Ljava.lang.String;, long, int)",
    "39": "android.content.pm.ParceledListSlice getInstalledApplications(long, int)",
    "40": "android.content.pm.ParceledListSlice getPersistentApplications(int)",
    "41": "android.content.pm.ProviderInfo resolveContentProvider(java.lang.String, long, int)",
    "42": "void querySyncProviders(java.util.List, java.util.List)",
    "43": "android.content.pm.ParceledListSlice queryContentProviders(java.lang.String, int, long, java.lang.String)",
    "44": "android.content.pm.InstrumentationInfo getInstrumentationInfoAsUser(android.content.ComponentName, int, int)",
    "45": "android.content.pm.ParceledListSlice queryInstrumentationAsUser(java.lang.String, int, int)",
    "46": "void finishPackageInstall(int, boolean)",
    "47": "void setInstallerPackageName(java.lang.String, java.lang.String)",
    "48": "void relinquishUpdateOwnership(java.lang.String)",
    "49": "void setApplicationCategoryHint(java.lang.String, int, java.lang.String)",
    "50": "void deletePackageAsUser(java.lang.String, int, android.content.pm.IPackageDeleteObserver, int, int)",
    "51": "void deletePackageVersioned(android.content.pm.VersionedPackage, android.content.pm.IPackageDeleteObserver2, int, int)",
    "52": "void deleteExistingPackageAsUser(android.content.pm.VersionedPackage, android.content.pm.IPackageDeleteObserver2, int)",
    "53": "java.lang.String getInstallerPackageName(java.lang.String)",
    "54": "android.content.pm.InstallSourceInfo getInstallSourceInfo(java.lang.String, int)",
    "55": "void resetApplicationPreferences(int)",
    "56": "android.content.pm.ResolveInfo getLastChosenActivity(android.content.Intent, java.lang.String, int)",
    "57": "void setLastChosenActivity(android.content.Intent, java.lang.String, int, android.content.IntentFilter, int, android.content.ComponentName)",
    "58": "void addPreferredActivity(android.content.IntentFilter, int, [Landroid.content.ComponentName;, android.content.ComponentName, int, boolean)",
    "59": "void replacePreferredActivity(android.content.IntentFilter, int, [Landroid.content.ComponentName;, android.content.ComponentName, int)",
    "60": "void clearPackagePreferredActivities(java.lang.String)",
    "61": "int getPreferredActivities(java.util.List, java.util.List, java.lang.String)",
    "62": "void addPersistentPreferredActivity(android.content.IntentFilter, android.content.ComponentName, int)",
    "63": "void clearPackagePersistentPreferredActivities(java.lang.String, int)",
    "64": "void clearPersistentPreferredActivity(android.content.IntentFilter, int)",
    "65": "void addCrossProfileIntentFilter(android.content.IntentFilter, java.lang.String, int, int, int)",
    "66": "boolean removeCrossProfileIntentFilter(android.content.IntentFilter, java.lang.String, int, int, int)",
    "67": "void clearCrossProfileIntentFilters(int, java.lang.String)",
    "68": "[Ljava.lang.String; setDistractingPackageRestrictionsAsUser([Ljava.lang.String;, int, int)",
    "69": "[Ljava.lang.String; setPackagesSuspendedAsUser([Ljava.lang.String;, boolean, android.os.PersistableBundle, android.os.PersistableBundle, android.content.pm.SuspendDialogInfo, java.lang.String, int)",
    "70": "[Ljava.lang.String; getUnsuspendablePackagesForUser([Ljava.lang.String;, int)",
    "71": "boolean isPackageSuspendedForUser(java.lang.String, int)",
    "72": "android.os.Bundle getSuspendedPackageAppExtras(java.lang.String, int)",
    "73": "[B getPreferredActivityBackup(int)",
    "74": "void restorePreferredActivities([B, int)",
    "75": "[B getDefaultAppsBackup(int)",
    "76": "void restoreDefaultApps([B, int)",
    "77": "[B getDomainVerificationBackup(int)",
    "78": "void restoreDomainVerification([B, int)",
    "79": "android.content.ComponentName getHomeActivities(java.util.List)",
    "80": "void setHomeActivity(android.content.ComponentName, int)",
    "81": "void overrideLabelAndIcon(android.content.ComponentName, java.lang.String, int, int)",
    "82": "void restoreLabelAndIcon(android.content.ComponentName, int)",
    "83": "void setComponentEnabledSetting(android.content.ComponentName, int, int, int, java.lang.String)",
    "84": "void setComponentEnabledSettings(java.util.List, int, java.lang.String)",
    "85": "int getComponentEnabledSetting(android.content.ComponentName, int)",
    "86": "void setApplicationEnabledSetting(java.lang.String, int, int, int, java.lang.String)",
    "87": "int getApplicationEnabledSetting(java.lang.String, int)",
    "88": "void logAppProcessStartIfNeeded(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, int)",
    "89": "void flushPackageRestrictionsAsUser(int)",
    "90": "void setPackageStoppedState(java.lang.String, boolean, int)",
    "91": "void freeStorageAndNotify(java.lang.String, long, int, android.content.pm.IPackageDataObserver)",
    "92": "void freeStorage(java.lang.String, long, int, android.content.IntentSender)",
    "93": "void deleteApplicationCacheFiles(java.lang.String, android.content.pm.IPackageDataObserver)",
    "94": "void deleteApplicationCacheFilesAsUser(java.lang.String, int, android.content.pm.IPackageDataObserver)",
    "95": "void clearApplicationUserData(java.lang.String, android.content.pm.IPackageDataObserver, int)",
    "96": "void clearApplicationProfileData(java.lang.String)",
    "97": "void getPackageSizeInfo(java.lang.String, int, android.content.pm.IPackageStatsObserver)",
    "98": "[Ljava.lang.String; getSystemSharedLibraryNames()",
    "99": "android.content.pm.ParceledListSlice getSystemAvailableFeatures()",
    "100": "boolean hasSystemFeature(java.lang.String, int)",
    "101": "java.util.List getInitialNonStoppedSystemPackages()",
    "102": "void enterSafeMode()",
    "103": "boolean isSafeMode()",
    "104": "boolean hasSystemUidErrors()",
    "105": "void notifyPackageUse(java.lang.String, int)",
    "106": "void notifyDexLoad(java.lang.String, java.util.Map, java.lang.String)",
    "107": "void registerDexModule(java.lang.String, java.lang.String, boolean, android.content.pm.IDexModuleRegisterCallback)",
    "108": "boolean performDexOptMode(java.lang.String, boolean, java.lang.String, boolean, boolean, java.lang.String)",
    "109": "boolean performDexOptSecondary(java.lang.String, java.lang.String, boolean)",
    "110": "int getMoveStatus(int)",
    "111": "void registerMoveCallback(android.content.pm.IPackageMoveObserver)",
    "112": "void unregisterMoveCallback(android.content.pm.IPackageMoveObserver)",
    "113": "int movePackage(java.lang.String, java.lang.String)",
    "114": "int movePrimaryStorage(java.lang.String)",
    "115": "boolean setInstallLocation(int)",
    "116": "int getInstallLocation()",
    "117": "int installExistingPackageAsUser(java.lang.String, int, int, int, java.util.List)",
    "118": "void verifyPendingInstall(int, int)",
    "119": "void extendVerificationTimeout(int, int, long)",
    "120": "void verifyIntentFilter(int, int, java.util.List)",
    "121": "int getIntentVerificationStatus(java.lang.String, int)",
    "122": "boolean updateIntentVerificationStatus(java.lang.String, int, int)",
    "123": "android.content.pm.ParceledListSlice getIntentFilterVerifications(java.lang.String)",
    "124": "android.content.pm.ParceledListSlice getAllIntentFilters(java.lang.String)",
    "125": "android.content.pm.VerifierDeviceIdentity getVerifierDeviceIdentity()",
    "126": "boolean isFirstBoot()",
    "127": "boolean isDeviceUpgrading()",
    "128": "boolean isStorageLow()",
    "129": "boolean setApplicationHiddenSettingAsUser(java.lang.String, boolean, int)",
    "130": "boolean getApplicationHiddenSettingAsUser(java.lang.String, int)",
    "131": "void setSystemAppHiddenUntilInstalled(java.lang.String, boolean)",
    "132": "boolean setSystemAppInstallState(java.lang.String, boolean, int)",
    "133": "android.content.pm.IPackageInstaller getPackageInstaller()",
    "134": "boolean setBlockUninstallForUser(java.lang.String, boolean, int)",
    "135": "boolean getBlockUninstallForUser(java.lang.String, int)",
    "136": "android.content.pm.KeySet getKeySetByAlias(java.lang.String, java.lang.String)",
    "137": "android.content.pm.KeySet getSigningKeySet(java.lang.String)",
    "138": "boolean isPackageSignedByKeySet(java.lang.String, android.content.pm.KeySet)",
    "139": "boolean isPackageSignedByKeySetExactly(java.lang.String, android.content.pm.KeySet)",
    "140": "java.lang.String getPermissionControllerPackageName()",
    "141": "java.lang.String getSdkSandboxPackageName()",
    "142": "android.content.pm.ParceledListSlice getInstantApps(int)",
    "143": "[B getInstantAppCookie(java.lang.String, int)",
    "144": "boolean setInstantAppCookie(java.lang.String, [B, int)",
    "145": "android.graphics.Bitmap getInstantAppIcon(java.lang.String, int)",
    "146": "boolean isInstantApp(java.lang.String, int)",
    "147": "boolean setRequiredForSystemUser(java.lang.String, boolean)",
    "148": "void setUpdateAvailable(java.lang.String, boolean)",
    "149": "java.lang.String getServicesSystemSharedLibraryPackageName()",
    "150": "java.lang.String getSharedSystemSharedLibraryPackageName()",
    "151": "android.content.pm.ChangedPackages getChangedPackages(int, int)",
    "152": "boolean isPackageDeviceAdminOnAnyUser(java.lang.String)",
    "153": "int getInstallReason(java.lang.String, int)",
    "154": "android.content.pm.ParceledListSlice getSharedLibraries(java.lang.String, long, int)",
    "155": "android.content.pm.ParceledListSlice getDeclaredSharedLibraries(java.lang.String, long, int)",
    "156": "boolean canRequestPackageInstalls(java.lang.String, int)",
    "157": "void deletePreloadsFileCache()",
    "158": "android.content.ComponentName getInstantAppResolverComponent()",
    "159": "android.content.ComponentName getInstantAppResolverSettingsComponent()",
    "160": "android.content.ComponentName getInstantAppInstallerComponent()",
    "161": "java.lang.String getInstantAppAndroidId(java.lang.String, int)",
    "162": "android.content.pm.dex.IArtManager getArtManager()",
    "163": "void setHarmfulAppWarning(java.lang.String, java.lang.CharSequence, int)",
    "164": "java.lang.CharSequence getHarmfulAppWarning(java.lang.String, int)",
    "165": "boolean hasSigningCertificate(java.lang.String, [B, int)",
    "166": "boolean hasUidSigningCertificate(int, [B, int)",
    "167": "java.lang.String getDefaultTextClassifierPackageName()",
    "168": "java.lang.String getSystemTextClassifierPackageName()",
    "169": "java.lang.String getAttentionServicePackageName()",
    "170": "java.lang.String getRotationResolverPackageName()",
    "171": "java.lang.String getWellbeingPackageName()",
    "172": "java.lang.String getAppPredictionServicePackageName()",
    "173": "java.lang.String getSystemCaptionsServicePackageName()",
    "174": "java.lang.String getSetupWizardPackageName()",
    "175": "java.lang.String getIncidentReportApproverPackageName()",
    "176": "boolean isPackageStateProtected(java.lang.String, int)",
    "177": "void sendDeviceCustomizationReadyBroadcast()",
    "178": "java.util.List getInstalledModules(int)",
    "179": "android.content.pm.ModuleInfo getModuleInfo(java.lang.String, int)",
    "180": "int getRuntimePermissionsVersion(int)",
    "181": "void setRuntimePermissionsVersion(int, int)",
    "182": "void notifyPackagesReplacedReceived([Ljava.lang.String;)",
    "183": "void requestPackageChecksums(java.lang.String, boolean, int, int, java.util.List, android.content.pm.IOnChecksumsReadyListener, int)",
    "184": "android.content.IntentSender getLaunchIntentSenderForPackage(java.lang.String, java.lang.String, java.lang.String, int)",
    "185": "[Ljava.lang.String; getAppOpPermissionPackages(java.lang.String, int)",
    "186": "android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String, int)",
    "187": "boolean addPermission(android.content.pm.PermissionInfo)",
    "188": "boolean addPermissionAsync(android.content.pm.PermissionInfo)",
    "189": "void removePermission(java.lang.String)",
    "190": "int checkPermission(java.lang.String, java.lang.String, int)",
    "191": "void grantRuntimePermission(java.lang.String, java.lang.String, int)",
    "192": "int checkUidPermission(java.lang.String, int)",
    "193": "void setMimeGroup(java.lang.String, java.lang.String, java.util.List)",
    "194": "java.lang.String getSplashScreenTheme(java.lang.String, int)",
    "195": "void setSplashScreenTheme(java.lang.String, java.lang.String, int)",
    "196": "java.util.List getMimeGroup(java.lang.String, java.lang.String)",
    "197": "boolean isAutoRevokeWhitelisted(java.lang.String)",
    "198": "void makeProviderVisible(int, java.lang.String)",
    "199": "void makeUidVisible(int, int)",
    "200": "android.os.IBinder getHoldLockToken()",
    "201": "void holdLock(android.os.IBinder, int)",
    "202": "android.content.pm.PackageManager$Property getPropertyAsUser(java.lang.String, java.lang.String, java.lang.String, int)",
    "203": "android.content.pm.ParceledListSlice queryProperty(java.lang.String, int)",
    "204": "void setKeepUninstalledPackages(java.util.List)",
    "205": "[Z canPackageQuery(java.lang.String, [Ljava.lang.String;, int)",
    "206": "boolean waitForHandler(long, boolean)"
  },
  "android.net.INetworkPolicyManager": {
    "1": "void setUidPolicy(int, int)",
    "2": "void addUidPolicy(int, int)",
    "3": "void removeUidPolicy(int, int)",
    "4": "int getUidPolicy(int)",
    "5": "[I getUidsWithPolicy(int)",
    "6": "void registerListener(android.net.INetworkPolicyListener)",
    "7": "void unregisterListener(android.net.INetworkPolicyListener)",
    "8": "void setNetworkPolicies([Landroid.net.NetworkPolicy;)",
    "9": "[Landroid.net.NetworkPolicy; getNetworkPolicies(java.lang.String)",
    "10": "void snoozeLimit(android.net.NetworkTemplate)",
    "11": "void setRestrictBackground(boolean)",
    "12": "boolean getRestrictBackground()",
    "13": "int getRestrictBackgroundByCaller()",
    "14": "int getRestrictBackgroundStatus(int)",
    "15": "void setDeviceIdleMode(boolean)",
    "16": "void setWifiMeteredOverride(java.lang.String, int)",
    "17": "int getMultipathPreference(android.net.Network)",
    "18": "android.telephony.SubscriptionPlan getSubscriptionPlan(android.net.NetworkTemplate)",
    "19": "void notifyStatsProviderWarningOrLimitReached()",
    "20": "[Landroid.telephony.SubscriptionPlan; getSubscriptionPlans(int, java.lang.String)",
    "21": "void setSubscriptionPlans(int, [Landroid.telephony.SubscriptionPlan;, long, java.lang.String)",
    "22": "java.lang.String getSubscriptionPlansOwner(int)",
    "23": "void setSubscriptionOverride(int, int, int, [I, long, java.lang.String)",
    "24": "void factoryReset(java.lang.String)",
    "25": "boolean isUidNetworkingBlocked(int, boolean)",
    "26": "boolean isUidRestrictedOnMeteredNetworks(int)"
  },
  "android.os.IExternalVibratorService": {
    "1": "int onExternalVibrationStart(android.os.ExternalVibration)",
    "2": "void onExternalVibrationStop(android.os.ExternalVibration)"
  },
  "android.app.blob.IBlobStoreManager": {
    "1": "long createSession(android.app.blob.BlobHandle, java.lang.String)",
    "2": "android.app.blob.IBlobStoreSession openSession(long, java.lang.String)",
    "3": "android.os.ParcelFileDescriptor openBlob(android.app.blob.BlobHandle, java.lang.String)",
    "4": "void abandonSession(long, java.lang.String)",
    "5": "void acquireLease(android.app.blob.BlobHandle, int, java.lang.CharSequence, long, java.lang.String)",
    "6": "void releaseLease(android.app.blob.BlobHandle, java.lang.String)",
    "7": "void releaseAllLeases(java.lang.String)",
    "8": "long getRemainingLeaseQuotaBytes(java.lang.String)",
    "9": "void waitForIdle(android.os.RemoteCallback)",
    "10": "java.util.List queryBlobsForUser(int)",
    "11": "void deleteBlob(long)",
    "12": "java.util.List getLeasedBlobs(java.lang.String)",
    "13": "android.app.blob.LeaseInfo getLeaseInfo(android.app.blob.BlobHandle, java.lang.String)"
  },
  "android.app.search.ISearchUiManager": {
    "1": "void createSearchSession(android.app.search.SearchContext, android.app.search.SearchSessionId, android.os.IBinder)",
    "2": "void query(android.app.search.SearchSessionId, android.app.search.Query, android.app.search.ISearchCallback)",
    "3": "void notifyEvent(android.app.search.SearchSessionId, android.app.search.Query, android.app.search.SearchTargetEvent)",
    "4": "void registerEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId, android.app.search.ISearchCallback)",
    "5": "void unregisterEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId, android.app.search.ISearchCallback)",
    "6": "void destroySearchSession(android.app.search.SearchSessionId)"
  },
  "android.app.IAlarmManager": {
    "1": "void set(java.lang.String, int, long, long, long, int, android.app.PendingIntent, android.app.IAlarmListener, java.lang.String, android.os.WorkSource, android.app.AlarmManager$AlarmClockInfo)",
    "2": "boolean setTime(long)",
    "3": "void setTimeZone(java.lang.String)",
    "4": "void remove(android.app.PendingIntent, android.app.IAlarmListener)",
    "5": "void removeAll(java.lang.String)",
    "6": "long getNextWakeFromIdleTime()",
    "7": "android.app.AlarmManager$AlarmClockInfo getNextAlarmClock(int)",
    "8": "boolean canScheduleExactAlarms(java.lang.String)",
    "9": "boolean hasScheduleExactAlarm(java.lang.String, int)",
    "10": "int getConfigVersion()"
  },
  "android.app.IActivityTaskManager": {
    "1": "int startActivity(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle)",
    "2": "int startActivities(android.app.IApplicationThread, java.lang.String, java.lang.String, [Landroid.content.Intent;, [Ljava.lang.String;, android.os.IBinder, android.os.Bundle, int)",
    "3": "int startActivityAsUser(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, int)",
    "4": "boolean startNextMatchingActivity(android.os.IBinder, android.content.Intent, android.os.Bundle)",
    "5": "boolean startDreamActivity(android.content.Intent)",
    "6": "int startActivityIntentSender(android.app.IApplicationThread, android.content.IIntentSender, android.os.IBinder, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, int, android.os.Bundle)",
    "7": "android.app.WaitResult startActivityAndWait(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, int)",
    "8": "int startActivityWithConfig(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.content.res.Configuration, android.os.Bundle, int)",
    "9": "int startVoiceActivity(java.lang.String, java.lang.String, int, int, android.content.Intent, java.lang.String, android.service.voice.IVoiceInteractionSession, com.android.internal.app.IVoiceInteractor, int, android.app.ProfilerInfo, android.os.Bundle, int)",
    "10": "java.lang.String getVoiceInteractorPackageName(android.os.IBinder)",
    "11": "int startAssistantActivity(java.lang.String, java.lang.String, int, int, android.content.Intent, java.lang.String, android.os.Bundle, int)",
    "12": "int startActivityFromGameSession(android.app.IApplicationThread, java.lang.String, java.lang.String, int, int, android.content.Intent, int, int)",
    "13": "void startRecentsActivity(android.content.Intent, long, android.view.IRecentsAnimationRunner)",
    "14": "int startActivityFromRecents(int, android.os.Bundle)",
    "15": "int startActivityAsCaller(android.app.IApplicationThread, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, boolean, int)",
    "16": "boolean isActivityStartAllowedOnDisplay(int, android.content.Intent, java.lang.String, int)",
    "17": "void unhandledBack()",
    "18": "android.app.IActivityClientController getActivityClientController()",
    "19": "int getFrontActivityScreenCompatMode()",
    "20": "void setFrontActivityScreenCompatMode(int)",
    "21": "void setFocusedTask(int)",
    "22": "boolean removeTask(int)",
    "23": "void removeAllVisibleRecentTasks()",
    "24": "java.util.List getTasks(int, boolean, boolean, int)",
    "25": "void moveTaskToFront(android.app.IApplicationThread, java.lang.String, int, int, android.os.Bundle)",
    "26": "android.content.pm.ParceledListSlice getRecentTasks(int, int, int)",
    "27": "boolean isTopActivityImmersive()",
    "28": "android.app.ActivityManager$TaskDescription getTaskDescription(int)",
    "29": "void reportAssistContextExtras(android.os.IBinder, android.os.Bundle, android.app.assist.AssistStructure, android.app.assist.AssistContent, android.net.Uri)",
    "30": "void setFocusedRootTask(int)",
    "31": "android.app.ActivityTaskManager$RootTaskInfo getFocusedRootTaskInfo()",
    "32": "android.graphics.Rect getTaskBounds(int)",
    "33": "void focusTopTask(int)",
    "34": "void cancelRecentsAnimation(boolean)",
    "35": "void updateLockTaskPackages(int, [Ljava.lang.String;)",
    "36": "boolean isInLockTaskMode()",
    "37": "int getLockTaskModeState()",
    "38": "java.util.List getAppTasks(java.lang.String)",
    "39": "void startSystemLockTaskMode(int)",
    "40": "void stopSystemLockTaskMode()",
    "41": "void finishVoiceTask(android.service.voice.IVoiceInteractionSession)",
    "42": "int addAppTask(android.os.IBinder, android.content.Intent, android.app.ActivityManager$TaskDescription, android.graphics.Bitmap)",
    "43": "android.graphics.Point getAppTaskThumbnailSize()",
    "44": "void releaseSomeActivities(android.app.IApplicationThread)",
    "45": "android.graphics.Bitmap getTaskDescriptionIcon(java.lang.String, int)",
    "46": "void registerTaskStackListener(android.app.ITaskStackListener)",
    "47": "void unregisterTaskStackListener(android.app.ITaskStackListener)",
    "48": "void setTaskResizeable(int, int)",
    "49": "void resizeTask(int, android.graphics.Rect, int)",
    "50": "void moveRootTaskToDisplay(int, int)",
    "51": "void moveTaskToRootTask(int, int, boolean)",
    "52": "void removeRootTasksInWindowingModes([I)",
    "53": "void removeRootTasksWithActivityTypes([I)",
    "54": "java.util.List getAllRootTaskInfos()",
    "55": "android.app.ActivityTaskManager$RootTaskInfo getRootTaskInfo(int, int)",
    "56": "java.util.List getAllRootTaskInfosOnDisplay(int)",
    "57": "android.app.ActivityTaskManager$RootTaskInfo getRootTaskInfoOnDisplay(int, int, int)",
    "58": "void setLockScreenShown(boolean, boolean)",
    "59": "android.os.Bundle getAssistContextExtras(int)",
    "60": "boolean requestAssistContextExtras(int, android.app.IAssistDataReceiver, android.os.Bundle, android.os.IBinder, boolean, boolean)",
    "61": "boolean requestAutofillData(android.app.IAssistDataReceiver, android.os.Bundle, android.os.IBinder, int)",
    "62": "boolean isAssistDataAllowedOnCurrentActivity()",
    "63": "boolean requestAssistDataForTask(android.app.IAssistDataReceiver, int, java.lang.String, java.lang.String)",
    "64": "void keyguardGoingAway(int)",
    "65": "void suppressResizeConfigChanges(boolean)",
    "66": "android.window.IWindowOrganizerController getWindowOrganizerController()",
    "67": "boolean supportsLocalVoiceInteraction()",
    "68": "android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()",
    "69": "void cancelTaskWindowTransition(int)",
    "70": "android.window.TaskSnapshot getTaskSnapshot(int, boolean, boolean)",
    "71": "android.window.TaskSnapshot takeTaskSnapshot(int, boolean)",
    "72": "int getLastResumedActivityUserId()",
    "73": "boolean updateConfiguration(android.content.res.Configuration)",
    "74": "void updateLockTaskFeatures(int, int)",
    "75": "void registerRemoteAnimationForNextActivityStart(java.lang.String, android.view.RemoteAnimationAdapter, android.os.IBinder)",
    "76": "void registerRemoteAnimationsForDisplay(int, android.view.RemoteAnimationDefinition)",
    "77": "void alwaysShowUnsupportedCompileSdkWarning(android.content.ComponentName)",
    "78": "void setVrThread(int)",
    "79": "void setPersistentVrThread(int)",
    "80": "void stopAppSwitches()",
    "81": "void resumeAppSwitches()",
    "82": "void setActivityController(android.app.IActivityController, boolean)",
    "83": "void setVoiceKeepAwake(android.service.voice.IVoiceInteractionSession, boolean)",
    "84": "int getPackageScreenCompatMode(java.lang.String)",
    "85": "void setPackageScreenCompatMode(java.lang.String, int)",
    "86": "boolean getPackageAskScreenCompat(java.lang.String)",
    "87": "void setPackageAskScreenCompat(java.lang.String, boolean)",
    "88": "void clearLaunchParamsForPackages(java.util.List)",
    "89": "void onSplashScreenViewCopyFinished(int, android.window.SplashScreenView$SplashScreenViewParcelable)",
    "90": "void onPictureInPictureStateChanged(android.app.PictureInPictureUiState)",
    "91": "void detachNavigationBarFromApp(android.os.IBinder)",
    "92": "void setRunningRemoteTransitionDelegate(android.app.IApplicationThread)",
    "93": "android.window.BackNavigationInfo startBackNavigation(android.os.RemoteCallback, android.window.BackAnimationAdapter)",
    "94": "void registerScreenCaptureObserver(android.os.IBinder, android.app.IScreenCaptureObserver)",
    "95": "void unregisterScreenCaptureObserver(android.os.IBinder, android.app.IScreenCaptureObserver)"
  },
  "android.media.IResourceManagerService": {
    "1": "void config([Landroid.media.MediaResourcePolicyParcel;)",
    "2": "void addResource(android.media.ClientInfoParcel, android.media.IResourceManagerClient, [Landroid.media.MediaResourceParcel;)",
    "3": "void removeResource(android.media.ClientInfoParcel, [Landroid.media.MediaResourceParcel;)",
    "4": "void removeClient(android.media.ClientInfoParcel)",
    "5": "boolean reclaimResource(android.media.ClientInfoParcel, [Landroid.media.MediaResourceParcel;)",
    "6": "void overridePid(int, int)",
    "7": "void overrideProcessInfo(android.media.IResourceManagerClient, int, int, int)",
    "8": "void markClientForPendingRemoval(android.media.ClientInfoParcel)",
    "9": "void reclaimResourcesFromClientsPendingRemoval(int)",
    "10": "void notifyClientCreated(android.media.ClientInfoParcel)",
    "11": "void notifyClientStarted(android.media.ClientConfigParcel)",
    "12": "void notifyClientStopped(android.media.ClientConfigParcel)",
    "13": "void notifyClientConfigChanged(android.media.ClientConfigParcel)"
  },
  "android.scheduling.IRebootReadinessManager": {
    "1": "void markRebootPending(java.lang.String)",
    "2": "void cancelPendingReboot(java.lang.String)",
    "3": "boolean isReadyToReboot()",
    "4": "void addRequestRebootReadinessStatusListener(android.scheduling.IRequestRebootReadinessStatusListener)",
    "5": "void removeRequestRebootReadinessStatusListener(android.scheduling.IRequestRebootReadinessStatusListener)"
  },
  "android.app.timedetector.ITimeDetectorService": {
    "1": "android.app.time.TimeCapabilitiesAndConfig getCapabilitiesAndConfig()",
    "2": "void addListener(android.app.time.ITimeDetectorListener)",
    "3": "void removeListener(android.app.time.ITimeDetectorListener)",
    "4": "boolean updateConfiguration(android.app.time.TimeConfiguration)",
    "5": "android.app.time.TimeState getTimeState()",
    "6": "boolean confirmTime(android.app.time.UnixEpochTime)",
    "7": "boolean setManualTime(android.app.timedetector.ManualTimeSuggestion)",
    "8": "void suggestExternalTime(android.app.time.ExternalTimeSuggestion)",
    "9": "boolean suggestManualTime(android.app.timedetector.ManualTimeSuggestion)",
    "10": "void suggestTelephonyTime(android.app.timedetector.TelephonyTimeSuggestion)",
    "11": "android.app.time.UnixEpochTime latestNetworkTime()"
  },
  "android.hardware.devicestate.IDeviceStateManager": {
    "1": "android.hardware.devicestate.DeviceStateInfo getDeviceStateInfo()",
    "2": "void registerCallback(android.hardware.devicestate.IDeviceStateManagerCallback)",
    "3": "void requestState(android.os.IBinder, int, int)",
    "4": "void cancelStateRequest()",
    "5": "void requestBaseStateOverride(android.os.IBinder, int, int)",
    "6": "void cancelBaseStateOverride()",
    "7": "void onStateRequestOverlayDismissed(boolean)"
  },
  "android.net.ITetheringConnector": {
    "1": "void tether(java.lang.String, java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "2": "void untether(java.lang.String, java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "3": "void setUsbTethering(boolean, java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "4": "void startTethering(android.net.TetheringRequestParcel, java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "5": "void stopTethering(int, java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "6": "void requestLatestTetheringEntitlementResult(int, android.os.ResultReceiver, boolean, java.lang.String, java.lang.String)",
    "7": "void registerTetheringEventCallback(android.net.ITetheringEventCallback, java.lang.String)",
    "8": "void unregisterTetheringEventCallback(android.net.ITetheringEventCallback, java.lang.String)",
    "9": "void isTetheringSupported(java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "10": "void stopAllTethering(java.lang.String, java.lang.String, android.net.IIntResultListener)",
    "11": "void setPreferTestNetworks(boolean, android.net.IIntResultListener)"
  },
  "android.app.IActivityManager": {
    "1": "android.os.ParcelFileDescriptor openContentUri(java.lang.String)",
    "2": "void registerUidObserver(android.app.IUidObserver, int, int, java.lang.String)",
    "3": "void unregisterUidObserver(android.app.IUidObserver)",
    "4": "android.os.IBinder registerUidObserverForUids(android.app.IUidObserver, int, int, java.lang.String, [I)",
    "5": "void addUidToObserver(android.os.IBinder, java.lang.String, int)",
    "6": "void removeUidFromObserver(android.os.IBinder, java.lang.String, int)",
    "7": "boolean isUidActive(int, java.lang.String)",
    "8": "int getUidProcessState(int, java.lang.String)",
    "9": "int checkPermission(java.lang.String, int, int)",
    "10": "void logFgsApiBegin(int, int, int)",
    "11": "void logFgsApiEnd(int, int, int)",
    "12": "void logFgsApiStateChanged(int, int, int, int)",
    "13": "void handleApplicationCrash(android.os.IBinder, android.app.ApplicationErrorReport$ParcelableCrashInfo)",
    "14": "int startActivity(android.app.IApplicationThread, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle)",
    "15": "int startActivityWithFeature(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle)",
    "16": "void unhandledBack()",
    "17": "boolean finishActivity(android.os.IBinder, int, android.content.Intent, int)",
    "18": "android.content.Intent registerReceiver(android.app.IApplicationThread, java.lang.String, android.content.IIntentReceiver, android.content.IntentFilter, java.lang.String, int, int)",
    "19": "android.content.Intent registerReceiverWithFeature(android.app.IApplicationThread, java.lang.String, java.lang.String, java.lang.String, android.content.IIntentReceiver, android.content.IntentFilter, java.lang.String, int, int)",
    "20": "void unregisterReceiver(android.content.IIntentReceiver)",
    "21": "int broadcastIntent(android.app.IApplicationThread, android.content.Intent, java.lang.String, android.content.IIntentReceiver, int, java.lang.String, android.os.Bundle, [Ljava.lang.String;, int, android.os.Bundle, boolean, boolean, int)",
    "22": "int broadcastIntentWithFeature(android.app.IApplicationThread, java.lang.String, android.content.Intent, java.lang.String, android.content.IIntentReceiver, int, java.lang.String, android.os.Bundle, [Ljava.lang.String;, [Ljava.lang.String;, [Ljava.lang.String;, int, android.os.Bundle, boolean, boolean, int)",
    "23": "void unbroadcastIntent(android.app.IApplicationThread, android.content.Intent, int)",
    "24": "void finishReceiver(android.os.IBinder, int, java.lang.String, android.os.Bundle, boolean, int)",
    "25": "void attachApplication(android.app.IApplicationThread, long)",
    "26": "void finishAttachApplication(long)",
    "27": "java.util.List getTasks(int)",
    "28": "void moveTaskToFront(android.app.IApplicationThread, java.lang.String, int, int, android.os.Bundle)",
    "29": "int getTaskForActivity(android.os.IBinder, boolean)",
    "30": "android.app.ContentProviderHolder getContentProvider(android.app.IApplicationThread, java.lang.String, java.lang.String, int, boolean)",
    "31": "void publishContentProviders(android.app.IApplicationThread, java.util.List)",
    "32": "boolean refContentProvider(android.os.IBinder, int, int)",
    "33": "android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName)",
    "34": "android.content.ComponentName startService(android.app.IApplicationThread, android.content.Intent, java.lang.String, boolean, java.lang.String, java.lang.String, int)",
    "35": "int stopService(android.app.IApplicationThread, android.content.Intent, java.lang.String, int)",
    "36": "int bindService(android.app.IApplicationThread, android.os.IBinder, android.content.Intent, java.lang.String, android.app.IServiceConnection, long, java.lang.String, int)",
    "37": "int bindServiceInstance(android.app.IApplicationThread, android.os.IBinder, android.content.Intent, java.lang.String, android.app.IServiceConnection, long, java.lang.String, java.lang.String, int)",
    "38": "void updateServiceGroup(android.app.IServiceConnection, int, int)",
    "39": "boolean unbindService(android.app.IServiceConnection)",
    "40": "void publishService(android.os.IBinder, android.content.Intent, android.os.IBinder)",
    "41": "void setDebugApp(java.lang.String, boolean, boolean)",
    "42": "void setAgentApp(java.lang.String, java.lang.String)",
    "43": "void setAlwaysFinish(boolean)",
    "44": "boolean startInstrumentation(android.content.ComponentName, java.lang.String, int, android.os.Bundle, android.app.IInstrumentationWatcher, android.app.IUiAutomationConnection, int, java.lang.String)",
    "45": "void addInstrumentationResults(android.app.IApplicationThread, android.os.Bundle)",
    "46": "void finishInstrumentation(android.app.IApplicationThread, int, android.os.Bundle)",
    "47": "android.content.res.Configuration getConfiguration()",
    "48": "boolean updateConfiguration(android.content.res.Configuration)",
    "49": "boolean updateMccMncConfiguration(java.lang.String, java.lang.String)",
    "50": "boolean stopServiceToken(android.content.ComponentName, android.os.IBinder, int)",
    "51": "void setProcessLimit(int)",
    "52": "int getProcessLimit()",
    "53": "int checkUriPermission(android.net.Uri, int, int, int, int, android.os.IBinder)",
    "54": "[I checkUriPermissions(java.util.List, int, int, int, int, android.os.IBinder)",
    "55": "void grantUriPermission(android.app.IApplicationThread, java.lang.String, android.net.Uri, int, int)",
    "56": "void revokeUriPermission(android.app.IApplicationThread, java.lang.String, android.net.Uri, int, int)",
    "57": "void setActivityController(android.app.IActivityController, boolean)",
    "58": "void showWaitingForDebugger(android.app.IApplicationThread, boolean)",
    "59": "void signalPersistentProcesses(int)",
    "60": "android.content.pm.ParceledListSlice getRecentTasks(int, int, int)",
    "61": "void serviceDoneExecuting(android.os.IBinder, int, int, int)",
    "62": "android.content.IIntentSender getIntentSender(int, java.lang.String, android.os.IBinder, java.lang.String, int, [Landroid.content.Intent;, [Ljava.lang.String;, int, android.os.Bundle, int)",
    "63": "android.content.IIntentSender getIntentSenderWithFeature(int, java.lang.String, java.lang.String, android.os.IBinder, java.lang.String, int, [Landroid.content.Intent;, [Ljava.lang.String;, int, android.os.Bundle, int)",
    "64": "void cancelIntentSender(android.content.IIntentSender)",
    "65": "android.app.ActivityManager$PendingIntentInfo getInfoForIntentSender(android.content.IIntentSender)",
    "66": "boolean registerIntentSenderCancelListenerEx(android.content.IIntentSender, com.android.internal.os.IResultReceiver)",
    "67": "void unregisterIntentSenderCancelListener(android.content.IIntentSender, com.android.internal.os.IResultReceiver)",
    "68": "void enterSafeMode()",
    "69": "void noteWakeupAlarm(android.content.IIntentSender, android.os.WorkSource, int, java.lang.String, java.lang.String)",
    "70": "void removeContentProvider(android.os.IBinder, boolean)",
    "71": "void setRequestedOrientation(android.os.IBinder, int)",
    "72": "void unbindFinished(android.os.IBinder, android.content.Intent, boolean)",
    "73": "void setProcessImportant(android.os.IBinder, int, boolean, java.lang.String)",
    "74": "void setServiceForeground(android.content.ComponentName, android.os.IBinder, int, android.app.Notification, int, int)",
    "75": "int getForegroundServiceType(android.content.ComponentName, android.os.IBinder)",
    "76": "boolean moveActivityTaskToBack(android.os.IBinder, boolean)",
    "77": "void getMemoryInfo(android.app.ActivityManager$MemoryInfo)",
    "78": "java.util.List getProcessesInErrorState()",
    "79": "boolean clearApplicationUserData(java.lang.String, boolean, android.content.pm.IPackageDataObserver, int)",
    "80": "void stopAppForUser(java.lang.String, int)",
    "81": "boolean registerForegroundServiceObserver(android.app.IForegroundServiceObserver)",
    "82": "void forceStopPackage(java.lang.String, int)",
    "83": "void forceStopPackageEvenWhenStopping(java.lang.String, int)",
    "84": "boolean killPids([I, java.lang.String, boolean)",
    "85": "java.util.List getServices(int, int)",
    "86": "java.util.List getRunningAppProcesses()",
    "87": "android.os.IBinder peekService(android.content.Intent, java.lang.String, java.lang.String)",
    "88": "boolean profileControl(java.lang.String, int, boolean, android.app.ProfilerInfo, int)",
    "89": "boolean shutdown(int)",
    "90": "void stopAppSwitches()",
    "91": "void resumeAppSwitches()",
    "92": "boolean bindBackupAgent(java.lang.String, int, int, int)",
    "93": "void backupAgentCreated(java.lang.String, android.os.IBinder, int)",
    "94": "void unbindBackupAgent(android.content.pm.ApplicationInfo)",
    "95": "int handleIncomingUser(int, int, int, boolean, boolean, java.lang.String, java.lang.String)",
    "96": "void addPackageDependency(java.lang.String)",
    "97": "void killApplication(java.lang.String, int, int, java.lang.String, int)",
    "98": "void closeSystemDialogs(java.lang.String)",
    "99": "[Landroid.os.Debug$MemoryInfo; getProcessMemoryInfo([I)",
    "100": "void killApplicationProcess(java.lang.String, int)",
    "101": "boolean handleApplicationWtf(android.os.IBinder, java.lang.String, boolean, android.app.ApplicationErrorReport$ParcelableCrashInfo, int)",
    "102": "void killBackgroundProcesses(java.lang.String, int)",
    "103": "boolean isUserAMonkey()",
    "104": "java.util.List getRunningExternalApplications()",
    "105": "void finishHeavyWeightApp()",
    "106": "void handleApplicationStrictModeViolation(android.os.IBinder, int, android.os.StrictMode$ViolationInfo)",
    "107": "void registerStrictModeCallback(android.os.IBinder)",
    "108": "boolean isTopActivityImmersive()",
    "109": "void crashApplicationWithType(int, int, java.lang.String, int, java.lang.String, boolean, int)",
    "110": "void crashApplicationWithTypeWithExtras(int, int, java.lang.String, int, java.lang.String, boolean, int, android.os.Bundle)",
    "111": "void getMimeTypeFilterAsync(android.net.Uri, int, android.os.RemoteCallback)",
    "112": "boolean dumpHeap(java.lang.String, int, boolean, boolean, boolean, java.lang.String, android.os.ParcelFileDescriptor, android.os.RemoteCallback)",
    "113": "boolean isUserRunning(int, int)",
    "114": "void setPackageScreenCompatMode(java.lang.String, int)",
    "115": "boolean switchUser(int)",
    "116": "java.lang.String getSwitchingFromUserMessage()",
    "117": "java.lang.String getSwitchingToUserMessage()",
    "118": "void setStopUserOnSwitch(int)",
    "119": "boolean removeTask(int)",
    "120": "void registerProcessObserver(android.app.IProcessObserver)",
    "121": "void unregisterProcessObserver(android.app.IProcessObserver)",
    "122": "boolean isIntentSenderTargetedToPackage(android.content.IIntentSender)",
    "123": "void updatePersistentConfiguration(android.content.res.Configuration)",
    "124": "void updatePersistentConfigurationWithAttribution(android.content.res.Configuration, java.lang.String, java.lang.String)",
    "125": "[J getProcessPss([I)",
    "126": "void showBootMessage(java.lang.CharSequence, boolean)",
    "127": "void killAllBackgroundProcesses()",
    "128": "android.app.ContentProviderHolder getContentProviderExternal(java.lang.String, int, android.os.IBinder, java.lang.String)",
    "129": "void removeContentProviderExternal(java.lang.String, android.os.IBinder)",
    "130": "void removeContentProviderExternalAsUser(java.lang.String, android.os.IBinder, int)",
    "131": "void getMyMemoryState(android.app.ActivityManager$RunningAppProcessInfo)",
    "132": "boolean killProcessesBelowForeground(java.lang.String)",
    "133": "android.content.pm.UserInfo getCurrentUser()",
    "134": "int getCurrentUserId()",
    "135": "int getLaunchedFromUid(android.os.IBinder)",
    "136": "void unstableProviderDied(android.os.IBinder)",
    "137": "boolean isIntentSenderAnActivity(android.content.IIntentSender)",
    "138": "int startActivityAsUser(android.app.IApplicationThread, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, int)",
    "139": "int startActivityAsUserWithFeature(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, int)",
    "140": "int stopUser(int, boolean, android.app.IStopUserCallback)",
    "141": "int stopUserWithDelayedLocking(int, boolean, android.app.IStopUserCallback)",
    "142": "void registerUserSwitchObserver(android.app.IUserSwitchObserver, java.lang.String)",
    "143": "void unregisterUserSwitchObserver(android.app.IUserSwitchObserver)",
    "144": "[I getRunningUserIds()",
    "145": "void requestSystemServerHeapDump()",
    "146": "void requestBugReport(int)",
    "147": "void requestBugReportWithDescription(java.lang.String, java.lang.String, int)",
    "148": "void requestTelephonyBugReport(java.lang.String, java.lang.String)",
    "149": "void requestWifiBugReport(java.lang.String, java.lang.String)",
    "150": "void requestInteractiveBugReportWithDescription(java.lang.String, java.lang.String)",
    "151": "void requestInteractiveBugReport()",
    "152": "void requestFullBugReport()",
    "153": "void requestRemoteBugReport(long)",
    "154": "boolean launchBugReportHandlerApp()",
    "155": "java.util.List getBugreportWhitelistedPackages()",
    "156": "android.content.Intent getIntentForIntentSender(android.content.IIntentSender)",
    "157": "java.lang.String getLaunchedFromPackage(android.os.IBinder)",
    "158": "void killUid(int, int, java.lang.String)",
    "159": "void setUserIsMonkey(boolean)",
    "160": "void hang(android.os.IBinder, boolean)",
    "161": "java.util.List getAllRootTaskInfos()",
    "162": "void moveTaskToRootTask(int, int, boolean)",
    "163": "void setFocusedRootTask(int)",
    "164": "android.app.ActivityTaskManager$RootTaskInfo getFocusedRootTaskInfo()",
    "165": "void restart()",
    "166": "void performIdleMaintenance()",
    "167": "void appNotRespondingViaProvider(android.os.IBinder)",
    "168": "android.graphics.Rect getTaskBounds(int)",
    "169": "boolean setProcessMemoryTrimLevel(java.lang.String, int, int)",
    "170": "java.lang.String getTagForIntentSender(android.content.IIntentSender, java.lang.String)",
    "171": "boolean startUserInBackground(int)",
    "172": "boolean isInLockTaskMode()",
    "173": "int startActivityFromRecents(int, android.os.Bundle)",
    "174": "void startSystemLockTaskMode(int)",
    "175": "boolean isTopOfTask(android.os.IBinder)",
    "176": "void bootAnimationComplete()",
    "177": "void registerTaskStackListener(android.app.ITaskStackListener)",
    "178": "void unregisterTaskStackListener(android.app.ITaskStackListener)",
    "179": "void notifyCleartextNetwork(int, [B)",
    "180": "void setTaskResizeable(int, int)",
    "181": "void resizeTask(int, android.graphics.Rect, int)",
    "182": "int getLockTaskModeState()",
    "183": "void setDumpHeapDebugLimit(java.lang.String, int, long, java.lang.String)",
    "184": "void dumpHeapFinished(java.lang.String)",
    "185": "void updateLockTaskPackages(int, [Ljava.lang.String;)",
    "186": "void noteAlarmStart(android.content.IIntentSender, android.os.WorkSource, int, java.lang.String)",
    "187": "void noteAlarmFinish(android.content.IIntentSender, android.os.WorkSource, int, java.lang.String)",
    "188": "int getPackageProcessState(java.lang.String, java.lang.String)",
    "189": "boolean startBinderTracking()",
    "190": "boolean stopBinderTrackingAndDump(android.os.ParcelFileDescriptor)",
    "191": "void suppressResizeConfigChanges(boolean)",
    "192": "boolean unlockUser(int, [B, [B, android.os.IProgressListener)",
    "193": "boolean unlockUser2(int, android.os.IProgressListener)",
    "194": "void killPackageDependents(java.lang.String, int)",
    "195": "void makePackageIdle(java.lang.String, int)",
    "196": "void setDeterministicUidIdle(boolean)",
    "197": "int getMemoryTrimLevel()",
    "198": "boolean isVrModePackageEnabled(android.content.ComponentName)",
    "199": "void notifyLockedProfile(int)",
    "200": "void startConfirmDeviceCredentialIntent(android.content.Intent, android.os.Bundle)",
    "201": "void sendIdleJobTrigger()",
    "202": "int sendIntentSender(android.app.IApplicationThread, android.content.IIntentSender, android.os.IBinder, int, android.content.Intent, java.lang.String, android.content.IIntentReceiver, java.lang.String, android.os.Bundle)",
    "203": "boolean isBackgroundRestricted(java.lang.String)",
    "204": "void setRenderThread(int)",
    "205": "void setHasTopUi(boolean)",
    "206": "void cancelTaskWindowTransition(int)",
    "207": "void scheduleApplicationInfoChanged(java.util.List, int)",
    "208": "void setPersistentVrThread(int)",
    "209": "void waitForNetworkStateUpdate(long)",
    "210": "void backgroundAllowlistUid(int)",
    "211": "boolean startUserInBackgroundWithListener(int, android.os.IProgressListener)",
    "212": "void startDelegateShellPermissionIdentity(int, [Ljava.lang.String;)",
    "213": "void stopDelegateShellPermissionIdentity()",
    "214": "java.util.List getDelegatedShellPermissions()",
    "215": "android.os.ParcelFileDescriptor getLifeMonitor()",
    "216": "boolean startUserInForegroundWithListener(int, android.os.IProgressListener)",
    "217": "void appNotResponding(java.lang.String)",
    "218": "android.content.pm.ParceledListSlice getHistoricalProcessStartReasons(java.lang.String, int, int)",
    "219": "void setApplicationStartInfoCompleteListener(android.app.IApplicationStartInfoCompleteListener, int)",
    "220": "void removeApplicationStartInfoCompleteListener(int)",
    "221": "android.content.pm.ParceledListSlice getHistoricalProcessExitReasons(java.lang.String, int, int, int)",
    "222": "void killProcessesWhenImperceptible([I, java.lang.String)",
    "223": "void setActivityLocusContext(android.content.ComponentName, android.content.LocusId, android.os.IBinder)",
    "224": "void setProcessStateSummary([B)",
    "225": "boolean isAppFreezerSupported()",
    "226": "boolean isAppFreezerEnabled()",
    "227": "void killUidForPermissionChange(int, int, java.lang.String)",
    "228": "void resetAppErrors()",
    "229": "boolean enableAppFreezer(boolean)",
    "230": "boolean enableFgsNotificationRateLimit(boolean)",
    "231": "void holdLock(android.os.IBinder, int)",
    "232": "boolean startProfile(int)",
    "233": "boolean stopProfile(int)",
    "234": "android.content.pm.ParceledListSlice queryIntentComponentsForIntentSender(android.content.IIntentSender, int)",
    "235": "int getUidProcessCapabilities(int, java.lang.String)",
    "236": "void waitForBroadcastIdle()",
    "237": "void waitForBroadcastBarrier()",
    "238": "void forceDelayBroadcastDelivery(java.lang.String, long)",
    "239": "boolean isModernBroadcastQueueEnabled()",
    "240": "boolean isProcessFrozen(int)",
    "241": "int getBackgroundRestrictionExemptionReason(int)",
    "242": "boolean startUserInBackgroundVisibleOnDisplay(int, int, android.os.IProgressListener)",
    "243": "boolean startProfileWithListener(int, android.os.IProgressListener)",
    "244": "int restartUserInBackground(int, int)",
    "245": "[I getDisplayIdsForStartingVisibleBackgroundUsers()",
    "246": "boolean shouldServiceTimeOut(android.content.ComponentName, android.os.IBinder)",
    "247": "void registerUidFrozenStateChangedCallback(android.app.IUidFrozenStateChangedCallback)",
    "248": "void unregisterUidFrozenStateChangedCallback(android.app.IUidFrozenStateChangedCallback)",
    "249": "[I getUidFrozenState([I)"
  },
  "android.accounts.IAccountManager": {
    "1": "java.lang.String getPassword(android.accounts.Account)",
    "2": "java.lang.String getUserData(android.accounts.Account, java.lang.String)",
    "3": "[Landroid.accounts.AuthenticatorDescription; getAuthenticatorTypes(int)",
    "4": "[Landroid.accounts.Account; getAccountsForPackage(java.lang.String, int, java.lang.String)",
    "5": "[Landroid.accounts.Account; getAccountsByTypeForPackage(java.lang.String, java.lang.String, java.lang.String)",
    "6": "[Landroid.accounts.Account; getAccountsAsUser(java.lang.String, int, java.lang.String)",
    "7": "void hasFeatures(android.accounts.IAccountManagerResponse, android.accounts.Account, [Ljava.lang.String;, int, java.lang.String)",
    "8": "void getAccountByTypeAndFeatures(android.accounts.IAccountManagerResponse, java.lang.String, [Ljava.lang.String;, java.lang.String)",
    "9": "void getAccountsByFeatures(android.accounts.IAccountManagerResponse, java.lang.String, [Ljava.lang.String;, java.lang.String)",
    "10": "boolean addAccountExplicitly(android.accounts.Account, java.lang.String, android.os.Bundle, java.lang.String)",
    "11": "void removeAccountAsUser(android.accounts.IAccountManagerResponse, android.accounts.Account, boolean, int)",
    "12": "boolean removeAccountExplicitly(android.accounts.Account)",
    "13": "void copyAccountToUser(android.accounts.IAccountManagerResponse, android.accounts.Account, int, int)",
    "14": "void invalidateAuthToken(java.lang.String, java.lang.String)",
    "15": "java.lang.String peekAuthToken(android.accounts.Account, java.lang.String)",
    "16": "void setAuthToken(android.accounts.Account, java.lang.String, java.lang.String)",
    "17": "void setPassword(android.accounts.Account, java.lang.String)",
    "18": "void clearPassword(android.accounts.Account)",
    "19": "void setUserData(android.accounts.Account, java.lang.String, java.lang.String)",
    "20": "void updateAppPermission(android.accounts.Account, java.lang.String, int, boolean)",
    "21": "void getAuthToken(android.accounts.IAccountManagerResponse, android.accounts.Account, java.lang.String, boolean, boolean, android.os.Bundle)",
    "22": "void addAccount(android.accounts.IAccountManagerResponse, java.lang.String, java.lang.String, [Ljava.lang.String;, boolean, android.os.Bundle)",
    "23": "void addAccountAsUser(android.accounts.IAccountManagerResponse, java.lang.String, java.lang.String, [Ljava.lang.String;, boolean, android.os.Bundle, int)",
    "24": "void updateCredentials(android.accounts.IAccountManagerResponse, android.accounts.Account, java.lang.String, boolean, android.os.Bundle)",
    "25": "void editProperties(android.accounts.IAccountManagerResponse, java.lang.String, boolean)",
    "26": "void confirmCredentialsAsUser(android.accounts.IAccountManagerResponse, android.accounts.Account, android.os.Bundle, boolean, int)",
    "27": "boolean accountAuthenticated(android.accounts.Account)",
    "28": "void getAuthTokenLabel(android.accounts.IAccountManagerResponse, java.lang.String, java.lang.String)",
    "29": "void addSharedAccountsFromParentUser(int, int, java.lang.String)",
    "30": "void renameAccount(android.accounts.IAccountManagerResponse, android.accounts.Account, java.lang.String)",
    "31": "java.lang.String getPreviousName(android.accounts.Account)",
    "32": "void startAddAccountSession(android.accounts.IAccountManagerResponse, java.lang.String, java.lang.String, [Ljava.lang.String;, boolean, android.os.Bundle)",
    "33": "void startUpdateCredentialsSession(android.accounts.IAccountManagerResponse, android.accounts.Account, java.lang.String, boolean, android.os.Bundle)",
    "34": "void finishSessionAsUser(android.accounts.IAccountManagerResponse, android.os.Bundle, boolean, android.os.Bundle, int)",
    "35": "boolean someUserHasAccount(android.accounts.Account)",
    "36": "void isCredentialsUpdateSuggested(android.accounts.IAccountManagerResponse, android.accounts.Account, java.lang.String)",
    "37": "java.util.Map getPackagesAndVisibilityForAccount(android.accounts.Account)",
    "38": "boolean addAccountExplicitlyWithVisibility(android.accounts.Account, java.lang.String, android.os.Bundle, java.util.Map, java.lang.String)",
    "39": "boolean setAccountVisibility(android.accounts.Account, java.lang.String, int)",
    "40": "int getAccountVisibility(android.accounts.Account, java.lang.String)",
    "41": "java.util.Map getAccountsAndVisibilityForPackage(java.lang.String, java.lang.String)",
    "42": "void registerAccountListener([Ljava.lang.String;, java.lang.String)",
    "43": "void unregisterAccountListener([Ljava.lang.String;, java.lang.String)",
    "44": "boolean hasAccountAccess(android.accounts.Account, java.lang.String, android.os.UserHandle)",
    "45": "android.content.IntentSender createRequestAccountAccessIntentSenderAsUser(android.accounts.Account, java.lang.String, android.os.UserHandle)",
    "46": "void onAccountAccessed(java.lang.String)"
  },
  "android.hardware.face.IFaceService": {
    "1": "android.hardware.biometrics.ITestSession createTestSession(int, android.hardware.biometrics.ITestSessionCallback, java.lang.String)",
    "2": "[B dumpSensorServiceStateProto(int, boolean)",
    "3": "java.util.List getSensorPropertiesInternal(java.lang.String)",
    "4": "android.hardware.face.FaceSensorPropertiesInternal getSensorProperties(int, java.lang.String)",
    "5": "long authenticate(android.os.IBinder, long, android.hardware.face.IFaceServiceReceiver, android.hardware.face.FaceAuthenticateOptions)",
    "6": "long detectFace(android.os.IBinder, android.hardware.face.IFaceServiceReceiver, android.hardware.face.FaceAuthenticateOptions)",
    "7": "void prepareForAuthentication(boolean, android.os.IBinder, long, android.hardware.biometrics.IBiometricSensorReceiver, android.hardware.face.FaceAuthenticateOptions, long, int, boolean)",
    "8": "void startPreparedClient(int, int)",
    "9": "void cancelAuthentication(android.os.IBinder, java.lang.String, long)",
    "10": "void cancelFaceDetect(android.os.IBinder, java.lang.String, long)",
    "11": "void cancelAuthenticationFromService(int, android.os.IBinder, java.lang.String, long)",
    "12": "long enroll(int, android.os.IBinder, [B, android.hardware.face.IFaceServiceReceiver, java.lang.String, [I, android.view.Surface, boolean)",
    "13": "long enrollRemotely(int, android.os.IBinder, [B, android.hardware.face.IFaceServiceReceiver, java.lang.String, [I)",
    "14": "void cancelEnrollment(android.os.IBinder, long)",
    "15": "void remove(android.os.IBinder, int, int, android.hardware.face.IFaceServiceReceiver, java.lang.String)",
    "16": "void removeAll(android.os.IBinder, int, android.hardware.face.IFaceServiceReceiver, java.lang.String)",
    "17": "java.util.List getEnrolledFaces(int, int, java.lang.String)",
    "18": "boolean isHardwareDetected(int, java.lang.String)",
    "19": "void generateChallenge(android.os.IBinder, int, int, android.hardware.face.IFaceServiceReceiver, java.lang.String)",
    "20": "void revokeChallenge(android.os.IBinder, int, int, java.lang.String, long)",
    "21": "boolean hasEnrolledFaces(int, int, java.lang.String)",
    "22": "int getLockoutModeForUser(int, int)",
    "23": "void invalidateAuthenticatorId(int, int, android.hardware.biometrics.IInvalidationCallback)",
    "24": "long getAuthenticatorId(int, int)",
    "25": "void resetLockout(android.os.IBinder, int, int, [B, java.lang.String)",
    "26": "void addLockoutResetCallback(android.hardware.biometrics.IBiometricServiceLockoutResetCallback, java.lang.String)",
    "27": "void setFeature(android.os.IBinder, int, int, boolean, [B, android.hardware.face.IFaceServiceReceiver, java.lang.String)",
    "28": "void getFeature(android.os.IBinder, int, int, android.hardware.face.IFaceServiceReceiver, java.lang.String)",
    "29": "void registerAuthenticators(java.util.List)",
    "30": "void addAuthenticatorsRegisteredCallback(android.hardware.face.IFaceAuthenticatorsRegisteredCallback)",
    "31": "void registerBiometricStateListener(android.hardware.biometrics.IBiometricStateListener)",
    "32": "void scheduleWatchdog()"
  },
  "android.service.textclassifier.ITextClassifierService": {
    "1": "void onSuggestSelection(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.TextSelection$Request, android.service.textclassifier.ITextClassifierCallback)",
    "2": "void onClassifyText(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.TextClassification$Request, android.service.textclassifier.ITextClassifierCallback)",
    "3": "void onGenerateLinks(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.TextLinks$Request, android.service.textclassifier.ITextClassifierCallback)",
    "4": "void onSelectionEvent(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.SelectionEvent)",
    "5": "void onTextClassifierEvent(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.TextClassifierEvent)",
    "6": "void onCreateTextClassificationSession(android.view.textclassifier.TextClassificationContext, android.view.textclassifier.TextClassificationSessionId)",
    "7": "void onDestroyTextClassificationSession(android.view.textclassifier.TextClassificationSessionId)",
    "8": "void onDetectLanguage(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.TextLanguage$Request, android.service.textclassifier.ITextClassifierCallback)",
    "9": "void onSuggestConversationActions(android.view.textclassifier.TextClassificationSessionId, android.view.textclassifier.ConversationActions$Request, android.service.textclassifier.ITextClassifierCallback)",
    "10": "void onConnectedStateChanged(int)"
  },
  "android.os.IThermalService": {
    "1": "boolean registerThermalEventListener(android.os.IThermalEventListener)",
    "2": "boolean registerThermalEventListenerWithType(android.os.IThermalEventListener, int)",
    "3": "boolean unregisterThermalEventListener(android.os.IThermalEventListener)",
    "4": "[Landroid.os.Temperature; getCurrentTemperatures()",
    "5": "[Landroid.os.Temperature; getCurrentTemperaturesWithType(int)",
    "6": "boolean registerThermalStatusListener(android.os.IThermalStatusListener)",
    "7": "boolean unregisterThermalStatusListener(android.os.IThermalStatusListener)",
    "8": "int getCurrentThermalStatus()",
    "9": "[Landroid.os.CoolingDevice; getCurrentCoolingDevices()",
    "10": "[Landroid.os.CoolingDevice; getCurrentCoolingDevicesWithType(int)",
    "11": "float getThermalHeadroom(int)"
  },
  "android.app.prediction.IPredictionManager": {
    "1": "void createPredictionSession(android.app.prediction.AppPredictionContext, android.app.prediction.AppPredictionSessionId, android.os.IBinder)",
    "2": "void notifyAppTargetEvent(android.app.prediction.AppPredictionSessionId, android.app.prediction.AppTargetEvent)",
    "3": "void notifyLaunchLocationShown(android.app.prediction.AppPredictionSessionId, java.lang.String, android.content.pm.ParceledListSlice)",
    "4": "void sortAppTargets(android.app.prediction.AppPredictionSessionId, android.content.pm.ParceledListSlice, android.app.prediction.IPredictionCallback)",
    "5": "void registerPredictionUpdates(android.app.prediction.AppPredictionSessionId, android.app.prediction.IPredictionCallback)",
    "6": "void unregisterPredictionUpdates(android.app.prediction.AppPredictionSessionId, android.app.prediction.IPredictionCallback)",
    "7": "void requestPredictionUpdate(android.app.prediction.AppPredictionSessionId)",
    "8": "void onDestroyPredictionSession(android.app.prediction.AppPredictionSessionId)"
  },
  "com.android.internal.telephony.ISms": {
    "1": "java.util.List getAllMessagesFromIccEfForSubscriber(int, java.lang.String)",
    "2": "boolean updateMessageOnIccEfForSubscriber(int, java.lang.String, int, int, [B)",
    "3": "boolean copyMessageToIccEfForSubscriber(int, java.lang.String, int, [B, [B)",
    "4": "void sendDataForSubscriber(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, int, [B, android.app.PendingIntent, android.app.PendingIntent)",
    "5": "void sendTextForSubscriber(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, android.app.PendingIntent, android.app.PendingIntent, boolean, long)",
    "6": "void sendTextForSubscriberWithOptions(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, android.app.PendingIntent, android.app.PendingIntent, boolean, int, boolean, int)",
    "7": "void injectSmsPduForSubscriber(int, [B, java.lang.String, android.app.PendingIntent)",
    "8": "void sendMultipartTextForSubscriber(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.util.List, java.util.List, java.util.List, boolean, long)",
    "9": "void sendMultipartTextForSubscriberWithOptions(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.util.List, java.util.List, java.util.List, boolean, int, boolean, int)",
    "10": "boolean enableCellBroadcastForSubscriber(int, int, int)",
    "11": "boolean disableCellBroadcastForSubscriber(int, int, int)",
    "12": "boolean enableCellBroadcastRangeForSubscriber(int, int, int, int)",
    "13": "boolean disableCellBroadcastRangeForSubscriber(int, int, int, int)",
    "14": "int getPremiumSmsPermission(java.lang.String)",
    "15": "int getPremiumSmsPermissionForSubscriber(int, java.lang.String)",
    "16": "void setPremiumSmsPermission(java.lang.String, int)",
    "17": "void setPremiumSmsPermissionForSubscriber(int, java.lang.String, int)",
    "18": "boolean isImsSmsSupportedForSubscriber(int)",
    "19": "boolean isSmsSimPickActivityNeeded(int)",
    "20": "int getPreferredSmsSubscription()",
    "21": "java.lang.String getImsSmsFormatForSubscriber(int)",
    "22": "boolean isSMSPromptEnabled()",
    "23": "void sendStoredText(int, java.lang.String, java.lang.String, android.net.Uri, java.lang.String, android.app.PendingIntent, android.app.PendingIntent)",
    "24": "void sendStoredMultipartText(int, java.lang.String, java.lang.String, android.net.Uri, java.lang.String, java.util.List, java.util.List)",
    "25": "android.os.Bundle getCarrierConfigValuesForSubscriber(int)",
    "26": "java.lang.String createAppSpecificSmsToken(int, java.lang.String, android.app.PendingIntent)",
    "27": "java.lang.String createAppSpecificSmsTokenWithPackageInfo(int, java.lang.String, java.lang.String, android.app.PendingIntent)",
    "28": "void setStorageMonitorMemoryStatusOverride(int, boolean)",
    "29": "void clearStorageMonitorMemoryStatusOverride(int)",
    "30": "int checkSmsShortCodeDestination(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "31": "java.lang.String getSmscAddressFromIccEfForSubscriber(int, java.lang.String)",
    "32": "boolean setSmscAddressOnIccEfForSubscriber(java.lang.String, int, java.lang.String)",
    "33": "int getSmsCapacityOnIccForSubscriber(int)",
    "34": "boolean resetAllCellBroadcastRanges(int)"
  },
  "android.hardware.lights.ILightsManager": {
    "1": "java.util.List getLights()",
    "2": "android.hardware.lights.LightState getLightState(int)",
    "3": "void openSession(android.os.IBinder, int)",
    "4": "void closeSession(android.os.IBinder)",
    "5": "void setLightStates(android.os.IBinder, [I, [Landroid.hardware.lights.LightState;)"
  },
  "android.os.IInstalld": {
    "1": "void createUserData(java.lang.String, int, int, int)",
    "2": "void destroyUserData(java.lang.String, int, int)",
    "3": "void setFirstBoot()",
    "4": "android.os.CreateAppDataResult createAppData(android.os.CreateAppDataArgs)",
    "5": "[Landroid.os.CreateAppDataResult; createAppDataBatched([Landroid.os.CreateAppDataArgs;)",
    "6": "void reconcileSdkData(android.os.ReconcileSdkDataArgs)",
    "7": "void restoreconAppData(java.lang.String, java.lang.String, int, int, int, java.lang.String)",
    "8": "void migrateAppData(java.lang.String, java.lang.String, int, int)",
    "9": "void clearAppData(java.lang.String, java.lang.String, int, int, long)",
    "10": "void destroyAppData(java.lang.String, java.lang.String, int, int, long)",
    "11": "void fixupAppData(java.lang.String, int)",
    "12": "[J getAppSize(java.lang.String, [Ljava.lang.String;, int, int, int, [J, [Ljava.lang.String;)",
    "13": "[J getUserSize(java.lang.String, int, int, [I)",
    "14": "[J getExternalSize(java.lang.String, int, int, [I)",
    "15": "[Landroid.os.storage.CrateMetadata; getAppCrates(java.lang.String, [Ljava.lang.String;, int)",
    "16": "[Landroid.os.storage.CrateMetadata; getUserCrates(java.lang.String, int)",
    "17": "void setAppQuota(java.lang.String, int, int, long)",
    "18": "void moveCompleteApp(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, int, java.lang.String)",
    "19": "boolean dexopt(java.lang.String, int, java.lang.String, java.lang.String, int, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean, int, java.lang.String, java.lang.String, java.lang.String)",
    "20": "void controlDexOptBlocking(boolean)",
    "21": "boolean compileLayouts(java.lang.String, java.lang.String, java.lang.String, int)",
    "22": "void rmdex(java.lang.String, java.lang.String)",
    "23": "int mergeProfiles(int, java.lang.String, java.lang.String)",
    "24": "boolean dumpProfiles(int, java.lang.String, java.lang.String, java.lang.String, boolean)",
    "25": "boolean copySystemProfile(java.lang.String, int, java.lang.String, java.lang.String)",
    "26": "void clearAppProfiles(java.lang.String, java.lang.String)",
    "27": "void destroyAppProfiles(java.lang.String)",
    "28": "void deleteReferenceProfile(java.lang.String, java.lang.String)",
    "29": "boolean createProfileSnapshot(int, java.lang.String, java.lang.String, java.lang.String)",
    "30": "void destroyProfileSnapshot(java.lang.String, java.lang.String)",
    "31": "void rmPackageDir(java.lang.String, java.lang.String)",
    "32": "void freeCache(java.lang.String, long, int)",
    "33": "void linkNativeLibraryDirectory(java.lang.String, java.lang.String, java.lang.String, int)",
    "34": "void createOatDir(java.lang.String, java.lang.String, java.lang.String)",
    "35": "void linkFile(java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "36": "void moveAb(java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "37": "long deleteOdex(java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
    "38": "boolean reconcileSecondaryDexFile(java.lang.String, java.lang.String, int, [Ljava.lang.String;, java.lang.String, int)",
    "39": "[B hashSecondaryDexFile(java.lang.String, java.lang.String, int, java.lang.String, int)",
    "40": "void invalidateMounts()",
    "41": "boolean isQuotaSupported(java.lang.String)",
    "42": "boolean prepareAppProfile(java.lang.String, int, int, java.lang.String, java.lang.String, java.lang.String)",
    "43": "long snapshotAppData(java.lang.String, java.lang.String, int, int, int)",
    "44": "void restoreAppDataSnapshot(java.lang.String, java.lang.String, int, java.lang.String, int, int, int)",
    "45": "void destroyAppDataSnapshot(java.lang.String, java.lang.String, int, long, int, int)",
    "46": "void destroyCeSnapshotsNotSpecified(java.lang.String, int, [I)",
    "47": "void tryMountDataMirror(java.lang.String)",
    "48": "void onPrivateVolumeRemoved(java.lang.String)",
    "49": "void migrateLegacyObbData()",
    "50": "void cleanupInvalidPackageDirs(java.lang.String, int, int)",
    "51": "int getOdexVisibility(java.lang.String, java.lang.String, java.lang.String, java.lang.String)"
  },
  "android.app.IUiModeManager": {
    "1": "void addCallback(android.app.IUiModeManagerCallback)",
    "2": "void enableCarMode(int, int, java.lang.String)",
    "3": "void disableCarMode(int)",
    "4": "void disableCarModeByCallingPackage(int, java.lang.String)",
    "5": "int getCurrentModeType()",
    "6": "void setNightMode(int)",
    "7": "int getNightMode()",
    "8": "void setNightModeCustomType(int)",
    "9": "int getNightModeCustomType()",
    "10": "void setApplicationNightMode(int)",
    "11": "boolean isUiModeLocked()",
    "12": "boolean isNightModeLocked()",
    "13": "boolean setNightModeActivatedForCustomMode(int, boolean)",
    "14": "boolean setNightModeActivated(boolean)",
    "15": "long getCustomNightModeStart()",
    "16": "void setCustomNightModeStart(long)",
    "17": "long getCustomNightModeEnd()",
    "18": "void setCustomNightModeEnd(long)",
    "19": "boolean requestProjection(android.os.IBinder, int, java.lang.String)",
    "20": "boolean releaseProjection(int, java.lang.String)",
    "21": "void addOnProjectionStateChangedListener(android.app.IOnProjectionStateChangedListener, int)",
    "22": "void removeOnProjectionStateChangedListener(android.app.IOnProjectionStateChangedListener)",
    "23": "java.util.List getProjectingPackages(int)",
    "24": "int getActiveProjectionTypes()",
    "25": "float getContrast()"
  },
  "android.content.pm.ILauncherApps": {
    "1": "void addOnAppsChangedListener(java.lang.String, android.content.pm.IOnAppsChangedListener)",
    "2": "void removeOnAppsChangedListener(android.content.pm.IOnAppsChangedListener)",
    "3": "android.content.pm.ParceledListSlice getLauncherActivities(java.lang.String, java.lang.String, android.os.UserHandle)",
    "4": "android.content.pm.LauncherActivityInfoInternal resolveLauncherActivityInternal(java.lang.String, android.content.ComponentName, android.os.UserHandle)",
    "5": "void startSessionDetailsActivityAsUser(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.pm.PackageInstaller$SessionInfo, android.graphics.Rect, android.os.Bundle, android.os.UserHandle)",
    "6": "void startActivityAsUser(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.ComponentName, android.graphics.Rect, android.os.Bundle, android.os.UserHandle)",
    "7": "android.app.PendingIntent getActivityLaunchIntent(java.lang.String, android.content.ComponentName, android.os.UserHandle)",
    "8": "void showAppDetailsAsUser(android.app.IApplicationThread, java.lang.String, java.lang.String, android.content.ComponentName, android.graphics.Rect, android.os.Bundle, android.os.UserHandle)",
    "9": "boolean isPackageEnabled(java.lang.String, java.lang.String, android.os.UserHandle)",
    "10": "android.os.Bundle getSuspendedPackageLauncherExtras(java.lang.String, android.os.UserHandle)",
    "11": "boolean isActivityEnabled(java.lang.String, android.content.ComponentName, android.os.UserHandle)",
    "12": "android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String, java.lang.String, int, android.os.UserHandle)",
    "13": "android.content.pm.LauncherApps$AppUsageLimit getAppUsageLimit(java.lang.String, java.lang.String, android.os.UserHandle)",
    "14": "android.content.pm.ParceledListSlice getShortcuts(java.lang.String, android.content.pm.ShortcutQueryWrapper, android.os.UserHandle)",
    "15": "void getShortcutsAsync(java.lang.String, android.content.pm.ShortcutQueryWrapper, android.os.UserHandle, com.android.internal.infra.AndroidFuture)",
    "16": "void pinShortcuts(java.lang.String, java.lang.String, java.util.List, android.os.UserHandle)",
    "17": "boolean startShortcut(java.lang.String, java.lang.String, java.lang.String, java.lang.String, android.graphics.Rect, android.os.Bundle, int)",
    "18": "int getShortcutIconResId(java.lang.String, java.lang.String, java.lang.String, int)",
    "19": "android.os.ParcelFileDescriptor getShortcutIconFd(java.lang.String, java.lang.String, java.lang.String, int)",
    "20": "boolean hasShortcutHostPermission(java.lang.String)",
    "21": "boolean shouldHideFromSuggestions(java.lang.String, android.os.UserHandle)",
    "22": "android.content.pm.ParceledListSlice getShortcutConfigActivities(java.lang.String, java.lang.String, android.os.UserHandle)",
    "23": "android.content.IntentSender getShortcutConfigActivityIntent(java.lang.String, android.content.ComponentName, android.os.UserHandle)",
    "24": "android.app.PendingIntent getShortcutIntent(java.lang.String, java.lang.String, java.lang.String, android.os.Bundle, android.os.UserHandle)",
    "25": "void registerPackageInstallerCallback(java.lang.String, android.content.pm.IPackageInstallerCallback)",
    "26": "android.content.pm.ParceledListSlice getAllSessions(java.lang.String)",
    "27": "void registerShortcutChangeCallback(java.lang.String, android.content.pm.ShortcutQueryWrapper, android.content.pm.IShortcutChangeCallback)",
    "28": "void unregisterShortcutChangeCallback(java.lang.String, android.content.pm.IShortcutChangeCallback)",
    "29": "void cacheShortcuts(java.lang.String, java.lang.String, java.util.List, android.os.UserHandle, int)",
    "30": "void uncacheShortcuts(java.lang.String, java.lang.String, java.util.List, android.os.UserHandle, int)",
    "31": "java.lang.String getShortcutIconUri(java.lang.String, java.lang.String, java.lang.String, int)",
    "32": "java.util.Map getActivityOverrides(java.lang.String, int)",
    "33": "void registerDumpCallback(android.window.IDumpCallback)",
    "34": "void unRegisterDumpCallback(android.window.IDumpCallback)"
  },
  "com.android.internal.app.IAppOpsService": {
    "1": "int checkOperation(int, int, java.lang.String)",
    "2": "android.app.SyncNotedAppOp noteOperation(int, int, java.lang.String, java.lang.String, boolean, java.lang.String, boolean)",
    "3": "android.app.SyncNotedAppOp startOperation(android.os.IBinder, int, int, java.lang.String, java.lang.String, boolean, boolean, java.lang.String, boolean, int, int)",
    "4": "void finishOperation(android.os.IBinder, int, int, java.lang.String, java.lang.String)",
    "5": "void startWatchingMode(int, java.lang.String, com.android.internal.app.IAppOpsCallback)",
    "6": "void stopWatchingMode(com.android.internal.app.IAppOpsCallback)",
    "7": "int permissionToOpCode(java.lang.String)",
    "8": "int checkAudioOperation(int, int, int, java.lang.String)",
    "9": "boolean shouldCollectNotes(int)",
    "10": "void setCameraAudioRestriction(int)",
    "11": "void startWatchingModeWithFlags(int, java.lang.String, int, com.android.internal.app.IAppOpsCallback)",
    "12": "android.app.SyncNotedAppOp noteProxyOperation(int, android.content.AttributionSource, boolean, java.lang.String, boolean, boolean)",
    "13": "android.app.SyncNotedAppOp startProxyOperation(android.os.IBinder, int, android.content.AttributionSource, boolean, boolean, java.lang.String, boolean, boolean, int, int, int)",
    "14": "void finishProxyOperation(android.os.IBinder, int, android.content.AttributionSource, boolean)",
    "15": "int checkPackage(int, java.lang.String)",
    "16": "android.app.RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage()",
    "17": "com.android.internal.app.MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(java.lang.String, android.app.SyncNotedAppOp, java.lang.String)",
    "18": "java.util.List getPackagesForOps([I)",
    "19": "java.util.List getOpsForPackage(int, java.lang.String, [I)",
    "20": "void getHistoricalOps(int, java.lang.String, java.lang.String, java.util.List, int, int, long, long, int, android.os.RemoteCallback)",
    "21": "void getHistoricalOpsFromDiskRaw(int, java.lang.String, java.lang.String, java.util.List, int, int, long, long, int, android.os.RemoteCallback)",
    "22": "void offsetHistory(long)",
    "23": "void setHistoryParameters(int, long, int)",
    "24": "void addHistoricalOps(android.app.AppOpsManager$HistoricalOps)",
    "25": "void resetHistoryParameters()",
    "26": "void resetPackageOpsNoHistory(java.lang.String)",
    "27": "void clearHistory()",
    "28": "void rebootHistory(long)",
    "29": "java.util.List getUidOps(int, [I)",
    "30": "void setUidMode(int, int, int)",
    "31": "void setMode(int, int, java.lang.String, int)",
    "32": "void resetAllModes(int, java.lang.String)",
    "33": "void setAudioRestriction(int, int, int, int, [Ljava.lang.String;)",
    "34": "void setUserRestrictions(android.os.Bundle, android.os.IBinder, int)",
    "35": "void setUserRestriction(int, boolean, android.os.IBinder, int, android.os.PackageTagsList)",
    "36": "void removeUser(int)",
    "37": "void startWatchingActive([I, com.android.internal.app.IAppOpsActiveCallback)",
    "38": "void stopWatchingActive(com.android.internal.app.IAppOpsActiveCallback)",
    "39": "boolean isOperationActive(int, int, java.lang.String)",
    "40": "boolean isProxying(int, java.lang.String, java.lang.String, int, java.lang.String)",
    "41": "void startWatchingStarted([I, com.android.internal.app.IAppOpsStartedCallback)",
    "42": "void stopWatchingStarted(com.android.internal.app.IAppOpsStartedCallback)",
    "43": "void startWatchingNoted([I, com.android.internal.app.IAppOpsNotedCallback)",
    "44": "void stopWatchingNoted(com.android.internal.app.IAppOpsNotedCallback)",
    "45": "void startWatchingAsyncNoted(java.lang.String, com.android.internal.app.IAppOpsAsyncNotedCallback)",
    "46": "void stopWatchingAsyncNoted(java.lang.String, com.android.internal.app.IAppOpsAsyncNotedCallback)",
    "47": "java.util.List extractAsyncOps(java.lang.String)",
    "48": "int checkOperationRaw(int, int, java.lang.String, java.lang.String)",
    "49": "void reloadNonHistoricalState()",
    "50": "void collectNoteOpCallsForValidation(java.lang.String, int, java.lang.String, long)"
  },
  "android.app.contentsuggestions.IContentSuggestionsManager": {
    "1": "void provideContextImage(int, int, android.os.Bundle)",
    "2": "void provideContextBitmap(int, android.graphics.Bitmap, android.os.Bundle)",
    "3": "void suggestContentSelections(int, android.app.contentsuggestions.SelectionsRequest, android.app.contentsuggestions.ISelectionsCallback)",
    "4": "void classifyContentSelections(int, android.app.contentsuggestions.ClassificationsRequest, android.app.contentsuggestions.IClassificationsCallback)",
    "5": "void notifyInteraction(int, java.lang.String, android.os.Bundle)",
    "6": "void isEnabled(int, com.android.internal.os.IResultReceiver)",
    "7": "void resetTemporaryService(int)",
    "8": "void setTemporaryService(int, java.lang.String, int)",
    "9": "void setDefaultServiceEnabled(int, boolean)"
  },
  "android.os.ISystemUpdateManager": {
    "1": "android.os.Bundle retrieveSystemUpdateInfo()",
    "2": "void updateSystemUpdateInfo(android.os.PersistableBundle)"
  },
  "android.view.accessibility.IAccessibilityManager": {
    "1": "void interrupt(int)",
    "2": "void sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent, int)",
    "3": "long addClient(android.view.accessibility.IAccessibilityManagerClient, int)",
    "4": "boolean removeClient(android.view.accessibility.IAccessibilityManagerClient, int)",
    "5": "java.util.List getInstalledAccessibilityServiceList(int)",
    "6": "java.util.List getEnabledAccessibilityServiceList(int, int)",
    "7": "int addAccessibilityInteractionConnection(android.view.IWindow, android.os.IBinder, android.view.accessibility.IAccessibilityInteractionConnection, java.lang.String, int)",
    "8": "void removeAccessibilityInteractionConnection(android.view.IWindow)",
    "9": "void setPictureInPictureActionReplacingConnection(android.view.accessibility.IAccessibilityInteractionConnection)",
    "10": "void registerUiTestAutomationService(android.os.IBinder, android.accessibilityservice.IAccessibilityServiceClient, android.accessibilityservice.AccessibilityServiceInfo, int, int)",
    "11": "void unregisterUiTestAutomationService(android.accessibilityservice.IAccessibilityServiceClient)",
    "12": "android.os.IBinder getWindowToken(int, int)",
    "13": "void notifyAccessibilityButtonClicked(int, java.lang.String)",
    "14": "void notifyAccessibilityButtonVisibilityChanged(boolean)",
    "15": "void performAccessibilityShortcut(java.lang.String)",
    "16": "java.util.List getAccessibilityShortcutTargets(int)",
    "17": "boolean sendFingerprintGesture(int)",
    "18": "int getAccessibilityWindowId(android.os.IBinder)",
    "19": "long getRecommendedTimeoutMillis()",
    "20": "void registerSystemAction(android.app.RemoteAction, int)",
    "21": "void unregisterSystemAction(int)",
    "22": "void setWindowMagnificationConnection(android.view.accessibility.IWindowMagnificationConnection)",
    "23": "void associateEmbeddedHierarchy(android.os.IBinder, android.os.IBinder)",
    "24": "void disassociateEmbeddedHierarchy(android.os.IBinder)",
    "25": "int getFocusStrokeWidth()",
    "26": "int getFocusColor()",
    "27": "boolean isAudioDescriptionByDefaultEnabled()",
    "28": "void setSystemAudioCaptioningEnabled(boolean, int)",
    "29": "boolean isSystemAudioCaptioningUiEnabled(int)",
    "30": "void setSystemAudioCaptioningUiEnabled(boolean, int)",
    "31": "void setAccessibilityWindowAttributes(int, int, int, android.view.accessibility.AccessibilityWindowAttributes)",
    "32": "boolean registerProxyForDisplay(android.accessibilityservice.IAccessibilityServiceClient, int)",
    "33": "boolean unregisterProxyForDisplay(int)",
    "34": "void injectInputEventToInputFilter(android.view.InputEvent)",
    "35": "boolean startFlashNotificationSequence(java.lang.String, int, android.os.IBinder)",
    "36": "boolean stopFlashNotificationSequence(java.lang.String)",
    "37": "boolean startFlashNotificationEvent(java.lang.String, int, java.lang.String)",
    "38": "boolean isAccessibilityTargetAllowed(java.lang.String, int, int)",
    "39": "boolean sendRestrictedDialogIntent(java.lang.String, int, int)",
    "40": "android.view.accessibility.IAccessibilityManager$WindowTransformationSpec getWindowTransformationSpec(int)"
  },
  "android.os.IDeviceIdentifiersPolicyService": {
    "1": "java.lang.String getSerial()",
    "2": "java.lang.String getSerialForPackage(java.lang.String, java.lang.String)"
  },
  "com.android.internal.appwidget.IAppWidgetService": {
    "1": "android.content.pm.ParceledListSlice startListening(com.android.internal.appwidget.IAppWidgetHost, java.lang.String, int, [I)",
    "2": "void stopListening(java.lang.String, int)",
    "3": "int allocateAppWidgetId(java.lang.String, int)",
    "4": "void deleteAppWidgetId(java.lang.String, int)",
    "5": "void deleteHost(java.lang.String, int)",
    "6": "void deleteAllHosts()",
    "7": "android.widget.RemoteViews getAppWidgetViews(java.lang.String, int)",
    "8": "[I getAppWidgetIdsForHost(java.lang.String, int)",
    "9": "void setAppWidgetHidden(java.lang.String, int)",
    "10": "android.content.IntentSender createAppWidgetConfigIntentSender(java.lang.String, int, int)",
    "11": "void updateAppWidgetIds(java.lang.String, [I, android.widget.RemoteViews)",
    "12": "void updateAppWidgetOptions(java.lang.String, int, android.os.Bundle)",
    "13": "android.os.Bundle getAppWidgetOptions(java.lang.String, int)",
    "14": "void partiallyUpdateAppWidgetIds(java.lang.String, [I, android.widget.RemoteViews)",
    "15": "void updateAppWidgetProvider(android.content.ComponentName, android.widget.RemoteViews)",
    "16": "void updateAppWidgetProviderInfo(android.content.ComponentName, java.lang.String)",
    "17": "void notifyAppWidgetViewDataChanged(java.lang.String, [I, int)",
    "18": "android.content.pm.ParceledListSlice getInstalledProvidersForProfile(int, int, java.lang.String)",
    "19": "android.appwidget.AppWidgetProviderInfo getAppWidgetInfo(java.lang.String, int)",
    "20": "boolean hasBindAppWidgetPermission(java.lang.String, int)",
    "21": "void setBindAppWidgetPermission(java.lang.String, int, boolean)",
    "22": "boolean bindAppWidgetId(java.lang.String, int, int, android.content.ComponentName, android.os.Bundle)",
    "23": "boolean bindRemoteViewsService(java.lang.String, int, android.content.Intent, android.app.IApplicationThread, android.os.IBinder, android.app.IServiceConnection, long)",
    "24": "void notifyProviderInheritance([Landroid.content.ComponentName;)",
    "25": "[I getAppWidgetIds(android.content.ComponentName)",
    "26": "boolean isBoundWidgetPackage(java.lang.String, int)",
    "27": "boolean requestPinAppWidget(java.lang.String, android.content.ComponentName, android.os.Bundle, android.content.IntentSender)",
    "28": "boolean isRequestPinAppWidgetSupported()",
    "29": "void noteAppWidgetTapped(java.lang.String, int)"
  },
  "android.os.ISchedulingPolicyService": {
    "1": "int requestPriority(int, int, int, boolean)",
    "2": "int requestCpusetBoost(boolean, android.os.IBinder)"
  },
  "android.app.trust.ITrustManager": {
    "1": "void reportUnlockAttempt(boolean, int)",
    "2": "void reportUserRequestedUnlock(int, boolean)",
    "3": "void reportUserMayRequestUnlock(int)",
    "4": "void reportUnlockLockout(int, int)",
    "5": "void reportEnabledTrustAgentsChanged(int)",
    "6": "void registerTrustListener(android.app.trust.ITrustListener)",
    "7": "void unregisterTrustListener(android.app.trust.ITrustListener)",
    "8": "void reportKeyguardShowingChanged()",
    "9": "void setDeviceLockedForUser(int, boolean)",
    "10": "boolean isDeviceLocked(int, int)",
    "11": "boolean isDeviceSecure(int, int)",
    "12": "boolean isTrustUsuallyManaged(int)",
    "13": "void unlockedByBiometricForUser(int, android.hardware.biometrics.BiometricSourceType)",
    "14": "void clearAllBiometricRecognized(android.hardware.biometrics.BiometricSourceType, int)",
    "15": "boolean isActiveUnlockRunning(int)"
  },
  "android.bluetooth.IBluetoothManager": {
    "1": "android.bluetooth.IBluetooth registerAdapter(android.bluetooth.IBluetoothManagerCallback)",
    "2": "void unregisterAdapter(android.bluetooth.IBluetoothManagerCallback)",
    "3": "void registerStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)",
    "4": "void unregisterStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)",
    "5": "boolean enable(android.content.AttributionSource)",
    "6": "boolean enableNoAutoConnect(android.content.AttributionSource)",
    "7": "boolean disable(android.content.AttributionSource, boolean)",
    "8": "int getState()",
    "9": "android.bluetooth.IBluetoothGatt getBluetoothGatt()",
    "10": "boolean bindBluetoothProfileService(int, java.lang.String, android.bluetooth.IBluetoothProfileServiceConnection)",
    "11": "void unbindBluetoothProfileService(int, android.bluetooth.IBluetoothProfileServiceConnection)",
    "12": "java.lang.String getAddress(android.content.AttributionSource)",
    "13": "java.lang.String getName(android.content.AttributionSource)",
    "14": "boolean onFactoryReset(android.content.AttributionSource)",
    "15": "boolean isBleScanAlwaysAvailable()",
    "16": "boolean enableBle(android.content.AttributionSource, android.os.IBinder)",
    "17": "boolean disableBle(android.content.AttributionSource, android.os.IBinder)",
    "18": "boolean isBleAppPresent()",
    "19": "boolean isHearingAidProfileSupported()",
    "20": "int setBtHciSnoopLogMode(int)",
    "21": "int getBtHciSnoopLogMode()"
  },
  "com.android.internal.telephony.IPhoneSubInfo": {
    "1": "java.lang.String getDeviceId(java.lang.String)",
    "2": "java.lang.String getDeviceIdWithFeature(java.lang.String, java.lang.String)",
    "3": "java.lang.String getNaiForSubscriber(int, java.lang.String, java.lang.String)",
    "4": "java.lang.String getDeviceIdForPhone(int, java.lang.String, java.lang.String)",
    "5": "java.lang.String getImeiForSubscriber(int, java.lang.String, java.lang.String)",
    "6": "java.lang.String getDeviceSvn(java.lang.String, java.lang.String)",
    "7": "java.lang.String getDeviceSvnUsingSubId(int, java.lang.String, java.lang.String)",
    "8": "java.lang.String getSubscriberId(java.lang.String)",
    "9": "java.lang.String getSubscriberIdWithFeature(java.lang.String, java.lang.String)",
    "10": "java.lang.String getSubscriberIdForSubscriber(int, java.lang.String, java.lang.String)",
    "11": "java.lang.String getGroupIdLevel1ForSubscriber(int, java.lang.String, java.lang.String)",
    "12": "java.lang.String getIccSerialNumber(java.lang.String)",
    "13": "java.lang.String getIccSerialNumberWithFeature(java.lang.String, java.lang.String)",
    "14": "java.lang.String getIccSerialNumberForSubscriber(int, java.lang.String, java.lang.String)",
    "15": "java.lang.String getLine1Number(java.lang.String, java.lang.String)",
    "16": "java.lang.String getLine1NumberForSubscriber(int, java.lang.String, java.lang.String)",
    "17": "java.lang.String getLine1AlphaTag(java.lang.String, java.lang.String)",
    "18": "java.lang.String getLine1AlphaTagForSubscriber(int, java.lang.String, java.lang.String)",
    "19": "java.lang.String getMsisdn(java.lang.String, java.lang.String)",
    "20": "java.lang.String getMsisdnForSubscriber(int, java.lang.String, java.lang.String)",
    "21": "java.lang.String getVoiceMailNumber(java.lang.String, java.lang.String)",
    "22": "java.lang.String getVoiceMailNumberForSubscriber(int, java.lang.String, java.lang.String)",
    "23": "android.telephony.ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int, int, java.lang.String)",
    "24": "void setCarrierInfoForImsiEncryption(int, java.lang.String, android.telephony.ImsiEncryptionInfo)",
    "25": "void resetCarrierKeysForImsiEncryption(int, java.lang.String)",
    "26": "java.lang.String getVoiceMailAlphaTag(java.lang.String, java.lang.String)",
    "27": "java.lang.String getVoiceMailAlphaTagForSubscriber(int, java.lang.String, java.lang.String)",
    "28": "java.lang.String getIsimImpi(int)",
    "29": "java.lang.String getImsPrivateUserIdentity(int, java.lang.String, java.lang.String)",
    "30": "java.lang.String getIsimDomain(int)",
    "31": "[Ljava.lang.String; getIsimImpu(int)",
    "32": "java.util.List getImsPublicUserIdentities(int, java.lang.String, java.lang.String)",
    "33": "java.lang.String getIsimIst(int)",
    "34": "[Ljava.lang.String; getIsimPcscf(int)",
    "35": "java.lang.String getIccSimChallengeResponse(int, int, int, java.lang.String, java.lang.String, java.lang.String)",
    "36": "android.net.Uri getSmscIdentity(int, int)",
    "37": "java.lang.String getSimServiceTable(int, int)"
  },
  "android.security.attestationverification.IAttestationVerificationManagerService": {
    "1": "void verifyAttestation(android.security.attestationverification.AttestationProfile, int, android.os.Bundle, [B, com.android.internal.infra.AndroidFuture)",
    "2": "void verifyToken(android.security.attestationverification.VerificationToken, android.os.ParcelDuration, com.android.internal.infra.AndroidFuture)"
  },
  "android.net.IIpSecService": {
    "1": "android.net.IpSecSpiResponse allocateSecurityParameterIndex(java.lang.String, int, android.os.IBinder)",
    "2": "void releaseSecurityParameterIndex(int)",
    "3": "android.net.IpSecUdpEncapResponse openUdpEncapsulationSocket(int, android.os.IBinder)",
    "4": "void closeUdpEncapsulationSocket(int)",
    "5": "android.net.IpSecTunnelInterfaceResponse createTunnelInterface(java.lang.String, java.lang.String, android.net.Network, android.os.IBinder, java.lang.String)",
    "6": "void addAddressToTunnelInterface(int, android.net.LinkAddress, java.lang.String)",
    "7": "void removeAddressFromTunnelInterface(int, android.net.LinkAddress, java.lang.String)",
    "8": "void setNetworkForTunnelInterface(int, android.net.Network, java.lang.String)",
    "9": "void deleteTunnelInterface(int, java.lang.String)",
    "10": "android.net.IpSecTransformResponse createTransform(android.net.IpSecConfig, android.os.IBinder, java.lang.String)",
    "11": "void migrateTransform(int, java.lang.String, java.lang.String, java.lang.String)",
    "12": "void deleteTransform(int)",
    "13": "void applyTransportModeTransform(android.os.ParcelFileDescriptor, int, int)",
    "14": "void applyTunnelModeTransform(int, int, int, java.lang.String)",
    "15": "void removeTransportModeTransforms(android.os.ParcelFileDescriptor)"
  },
  "android.net.wifi.IWifiManager": {
    "1": "long getSupportedFeatures()",
    "2": "void getWifiActivityEnergyInfoAsync(android.net.wifi.IOnWifiActivityEnergyInfoListener)",
    "3": "void setNetworkSelectionConfig(android.net.wifi.WifiNetworkSelectionConfig)",
    "4": "void getNetworkSelectionConfig(android.net.wifi.IWifiNetworkSelectionConfigListener)",
    "5": "void setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean)",
    "6": "boolean isThirdPartyAppEnablingWifiConfirmationDialogEnabled()",
    "7": "void setScreenOnScanSchedule([I, [I)",
    "8": "void setOneShotScreenOnConnectivityScanDelayMillis(int)",
    "9": "com.android.wifi.x.com.android.modules.utils.ParceledListSlice getConfiguredNetworks(java.lang.String, java.lang.String, boolean)",
    "10": "com.android.wifi.x.com.android.modules.utils.ParceledListSlice getPrivilegedConfiguredNetworks(java.lang.String, java.lang.String, android.os.Bundle)",
    "11": "android.net.wifi.WifiConfiguration getPrivilegedConnectedNetwork(java.lang.String, java.lang.String, android.os.Bundle)",
    "12": "java.util.Map getAllMatchingFqdnsForScanResults(java.util.List)",
    "13": "void setSsidsAllowlist(java.lang.String, java.util.List)",
    "14": "java.util.List getSsidsAllowlist(java.lang.String)",
    "15": "java.util.Map getMatchingOsuProviders(java.util.List)",
    "16": "java.util.Map getMatchingPasspointConfigsForOsuProviders(java.util.List)",
    "17": "int addOrUpdateNetwork(android.net.wifi.WifiConfiguration, java.lang.String, android.os.Bundle)",
    "18": "android.net.wifi.WifiManager$AddNetworkResult addOrUpdateNetworkPrivileged(android.net.wifi.WifiConfiguration, java.lang.String)",
    "19": "boolean addOrUpdatePasspointConfiguration(android.net.wifi.hotspot2.PasspointConfiguration, java.lang.String)",
    "20": "boolean removePasspointConfiguration(java.lang.String, java.lang.String)",
    "21": "java.util.List getPasspointConfigurations(java.lang.String)",
    "22": "java.util.List getWifiConfigsForPasspointProfiles(java.util.List)",
    "23": "void queryPasspointIcon(long, java.lang.String)",
    "24": "int matchProviderWithCurrentNetwork(java.lang.String)",
    "25": "boolean removeNetwork(int, java.lang.String)",
    "26": "boolean removeNonCallerConfiguredNetworks(java.lang.String)",
    "27": "boolean enableNetwork(int, boolean, java.lang.String)",
    "28": "boolean disableNetwork(int, java.lang.String)",
    "29": "void allowAutojoinGlobal(boolean, java.lang.String, android.os.Bundle)",
    "30": "void queryAutojoinGlobal(android.net.wifi.IBooleanListener)",
    "31": "void allowAutojoin(int, boolean)",
    "32": "void allowAutojoinPasspoint(java.lang.String, boolean)",
    "33": "void setMacRandomizationSettingPasspointEnabled(java.lang.String, boolean)",
    "34": "void setPasspointMeteredOverride(java.lang.String, int)",
    "35": "boolean startScan(java.lang.String, java.lang.String)",
    "36": "java.util.List getScanResults(java.lang.String, java.lang.String)",
    "37": "void getChannelData(android.net.wifi.IListListener, java.lang.String, android.os.Bundle)",
    "38": "boolean disconnect(java.lang.String)",
    "39": "boolean reconnect(java.lang.String)",
    "40": "boolean reassociate(java.lang.String)",
    "41": "android.net.wifi.WifiInfo getConnectionInfo(java.lang.String, java.lang.String)",
    "42": "boolean setWifiEnabled(java.lang.String, boolean)",
    "43": "int getWifiEnabledState()",
    "44": "void registerDriverCountryCodeChangedListener(android.net.wifi.IOnWifiDriverCountryCodeChangedListener, java.lang.String, java.lang.String)",
    "45": "void unregisterDriverCountryCodeChangedListener(android.net.wifi.IOnWifiDriverCountryCodeChangedListener)",
    "46": "void addWifiNetworkStateChangedListener(android.net.wifi.IWifiNetworkStateChangedListener)",
    "47": "void removeWifiNetworkStateChangedListener(android.net.wifi.IWifiNetworkStateChangedListener)",
    "48": "java.lang.String getCountryCode(java.lang.String, java.lang.String)",
    "49": "void setOverrideCountryCode(java.lang.String)",
    "50": "void clearOverrideCountryCode()",
    "51": "void setDefaultCountryCode(java.lang.String)",
    "52": "boolean is24GHzBandSupported()",
    "53": "boolean is5GHzBandSupported()",
    "54": "boolean is6GHzBandSupported()",
    "55": "boolean is60GHzBandSupported()",
    "56": "boolean isWifiStandardSupported(int)",
    "57": "android.net.DhcpInfo getDhcpInfo(java.lang.String)",
    "58": "void setScanAlwaysAvailable(boolean, java.lang.String)",
    "59": "boolean isScanAlwaysAvailable()",
    "60": "boolean acquireWifiLock(android.os.IBinder, int, java.lang.String, android.os.WorkSource)",
    "61": "void updateWifiLockWorkSource(android.os.IBinder, android.os.WorkSource)",
    "62": "boolean releaseWifiLock(android.os.IBinder)",
    "63": "void initializeMulticastFiltering()",
    "64": "boolean isMulticastEnabled()",
    "65": "void acquireMulticastLock(android.os.IBinder, java.lang.String)",
    "66": "void releaseMulticastLock(java.lang.String)",
    "67": "void updateInterfaceIpState(java.lang.String, int)",
    "68": "boolean isDefaultCoexAlgorithmEnabled()",
    "69": "void setCoexUnsafeChannels(java.util.List, int)",
    "70": "void registerCoexCallback(android.net.wifi.ICoexCallback)",
    "71": "void unregisterCoexCallback(android.net.wifi.ICoexCallback)",
    "72": "boolean startSoftAp(android.net.wifi.WifiConfiguration, java.lang.String)",
    "73": "boolean startTetheredHotspot(android.net.wifi.SoftApConfiguration, java.lang.String)",
    "74": "boolean stopSoftAp()",
    "75": "boolean validateSoftApConfiguration(android.net.wifi.SoftApConfiguration)",
    "76": "int startLocalOnlyHotspot(android.net.wifi.ILocalOnlyHotspotCallback, java.lang.String, java.lang.String, android.net.wifi.SoftApConfiguration, android.os.Bundle)",
    "77": "void stopLocalOnlyHotspot()",
    "78": "void registerLocalOnlyHotspotSoftApCallback(android.net.wifi.ISoftApCallback, android.os.Bundle)",
    "79": "void unregisterLocalOnlyHotspotSoftApCallback(android.net.wifi.ISoftApCallback, android.os.Bundle)",
    "80": "void startWatchLocalOnlyHotspot(android.net.wifi.ILocalOnlyHotspotCallback)",
    "81": "void stopWatchLocalOnlyHotspot()",
    "82": "int getWifiApEnabledState()",
    "83": "android.net.wifi.WifiConfiguration getWifiApConfiguration()",
    "84": "android.net.wifi.SoftApConfiguration getSoftApConfiguration()",
    "85": "void queryLastConfiguredTetheredApPassphraseSinceBoot(android.net.wifi.IStringListener)",
    "86": "boolean setWifiApConfiguration(android.net.wifi.WifiConfiguration, java.lang.String)",
    "87": "boolean setSoftApConfiguration(android.net.wifi.SoftApConfiguration, java.lang.String)",
    "88": "void notifyUserOfApBandConversion(java.lang.String)",
    "89": "void enableTdls(java.lang.String, boolean)",
    "90": "void enableTdlsWithRemoteIpAddress(java.lang.String, boolean, android.net.wifi.IBooleanListener)",
    "91": "void enableTdlsWithMacAddress(java.lang.String, boolean)",
    "92": "void enableTdlsWithRemoteMacAddress(java.lang.String, boolean, android.net.wifi.IBooleanListener)",
    "93": "void isTdlsOperationCurrentlyAvailable(android.net.wifi.IBooleanListener)",
    "94": "void getMaxSupportedConcurrentTdlsSessions(android.net.wifi.IIntegerListener)",
    "95": "void getNumberOfEnabledTdlsSessions(android.net.wifi.IIntegerListener)",
    "96": "java.lang.String getCurrentNetworkWpsNfcConfigurationToken()",
    "97": "void enableVerboseLogging(int)",
    "98": "int getVerboseLoggingLevel()",
    "99": "void disableEphemeralNetwork(java.lang.String, java.lang.String)",
    "100": "void factoryReset(java.lang.String)",
    "101": "android.net.Network getCurrentNetwork()",
    "102": "[B retrieveBackupData()",
    "103": "void restoreBackupData([B)",
    "104": "[B retrieveSoftApBackupData()",
    "105": "android.net.wifi.SoftApConfiguration restoreSoftApBackupData([B)",
    "106": "void restoreSupplicantBackupData([B, [B)",
    "107": "void startSubscriptionProvisioning(android.net.wifi.hotspot2.OsuProvider, android.net.wifi.hotspot2.IProvisioningCallback)",
    "108": "void registerSoftApCallback(android.net.wifi.ISoftApCallback)",
    "109": "void unregisterSoftApCallback(android.net.wifi.ISoftApCallback)",
    "110": "void addWifiVerboseLoggingStatusChangedListener(android.net.wifi.IWifiVerboseLoggingStatusChangedListener)",
    "111": "void removeWifiVerboseLoggingStatusChangedListener(android.net.wifi.IWifiVerboseLoggingStatusChangedListener)",
    "112": "void addOnWifiUsabilityStatsListener(android.net.wifi.IOnWifiUsabilityStatsListener)",
    "113": "void removeOnWifiUsabilityStatsListener(android.net.wifi.IOnWifiUsabilityStatsListener)",
    "114": "void registerTrafficStateCallback(android.net.wifi.ITrafficStateCallback)",
    "115": "void unregisterTrafficStateCallback(android.net.wifi.ITrafficStateCallback)",
    "116": "void registerNetworkRequestMatchCallback(android.net.wifi.INetworkRequestMatchCallback)",
    "117": "void unregisterNetworkRequestMatchCallback(android.net.wifi.INetworkRequestMatchCallback)",
    "118": "int addNetworkSuggestions(java.util.List, java.lang.String, java.lang.String)",
    "119": "int removeNetworkSuggestions(java.util.List, java.lang.String, int)",
    "120": "java.util.List getNetworkSuggestions(java.lang.String)",
    "121": "[Ljava.lang.String; getFactoryMacAddresses()",
    "122": "void setDeviceMobilityState(int)",
    "123": "void startDppAsConfiguratorInitiator(android.os.IBinder, java.lang.String, java.lang.String, int, int, android.net.wifi.IDppCallback)",
    "124": "void startDppAsEnrolleeInitiator(android.os.IBinder, java.lang.String, android.net.wifi.IDppCallback)",
    "125": "void startDppAsEnrolleeResponder(android.os.IBinder, java.lang.String, int, android.net.wifi.IDppCallback)",
    "126": "void stopDppSession()",
    "127": "void updateWifiUsabilityScore(int, int, int)",
    "128": "void connect(android.net.wifi.WifiConfiguration, int, android.net.wifi.IActionListener, java.lang.String)",
    "129": "void save(android.net.wifi.WifiConfiguration, android.net.wifi.IActionListener, java.lang.String)",
    "130": "void forget(int, android.net.wifi.IActionListener)",
    "131": "void registerScanResultsCallback(android.net.wifi.IScanResultsCallback)",
    "132": "void unregisterScanResultsCallback(android.net.wifi.IScanResultsCallback)",
    "133": "void registerSuggestionConnectionStatusListener(android.net.wifi.ISuggestionConnectionStatusListener, java.lang.String, java.lang.String)",
    "134": "void unregisterSuggestionConnectionStatusListener(android.net.wifi.ISuggestionConnectionStatusListener, java.lang.String)",
    "135": "void addLocalOnlyConnectionStatusListener(android.net.wifi.ILocalOnlyConnectionStatusListener, java.lang.String, java.lang.String)",
    "136": "void removeLocalOnlyConnectionStatusListener(android.net.wifi.ILocalOnlyConnectionStatusListener, java.lang.String)",
    "137": "int calculateSignalLevel(int)",
    "138": "java.util.List getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(java.util.List)",
    "139": "boolean setWifiConnectedNetworkScorer(android.os.IBinder, android.net.wifi.IWifiConnectedNetworkScorer)",
    "140": "void clearWifiConnectedNetworkScorer()",
    "141": "void setExternalPnoScanRequest(android.os.IBinder, android.net.wifi.IPnoScanResultsCallback, java.util.List, [I, java.lang.String, java.lang.String)",
    "142": "void clearExternalPnoScanRequest()",
    "143": "void getLastCallerInfoForApi(int, android.net.wifi.ILastCallerListener)",
    "144": "java.util.Map getMatchingScanResults(java.util.List, java.util.List, java.lang.String, java.lang.String)",
    "145": "void setScanThrottleEnabled(boolean)",
    "146": "boolean isScanThrottleEnabled()",
    "147": "java.util.Map getAllMatchingPasspointProfilesForScanResults(java.util.List)",
    "148": "void setAutoWakeupEnabled(boolean)",
    "149": "boolean isAutoWakeupEnabled()",
    "150": "void startRestrictingAutoJoinToSubscriptionId(int)",
    "151": "void stopRestrictingAutoJoinToSubscriptionId()",
    "152": "void setCarrierNetworkOffloadEnabled(int, boolean, boolean)",
    "153": "boolean isCarrierNetworkOffloadEnabled(int, boolean)",
    "154": "void registerSubsystemRestartCallback(android.net.wifi.ISubsystemRestartCallback)",
    "155": "void unregisterSubsystemRestartCallback(android.net.wifi.ISubsystemRestartCallback)",
    "156": "void restartWifiSubsystem()",
    "157": "void addSuggestionUserApprovalStatusListener(android.net.wifi.ISuggestionUserApprovalStatusListener, java.lang.String)",
    "158": "void removeSuggestionUserApprovalStatusListener(android.net.wifi.ISuggestionUserApprovalStatusListener, java.lang.String)",
    "159": "void setEmergencyScanRequestInProgress(boolean)",
    "160": "void removeAppState(int, java.lang.String)",
    "161": "boolean setWifiScoringEnabled(boolean)",
    "162": "void flushPasspointAnqpCache(java.lang.String)",
    "163": "java.util.List getUsableChannels(int, int, int, java.lang.String, android.os.Bundle)",
    "164": "boolean isWifiPasspointEnabled()",
    "165": "void setWifiPasspointEnabled(boolean)",
    "166": "int getStaConcurrencyForMultiInternetMode()",
    "167": "boolean setStaConcurrencyForMultiInternetMode(int)",
    "168": "void notifyMinimumRequiredWifiSecurityLevelChanged(int)",
    "169": "void notifyWifiSsidPolicyChanged(int, java.util.List)",
    "170": "[Ljava.lang.String; getOemPrivilegedWifiAdminPackages()",
    "171": "void replyToP2pInvitationReceivedDialog(int, boolean, java.lang.String)",
    "172": "void replyToSimpleDialog(int, int)",
    "173": "void addCustomDhcpOptions(android.net.wifi.WifiSsid, [B, java.util.List)",
    "174": "void removeCustomDhcpOptions(android.net.wifi.WifiSsid, [B)",
    "175": "void reportCreateInterfaceImpact(java.lang.String, int, boolean, android.net.wifi.IInterfaceCreationInfoCallback)",
    "176": "int getMaxNumberOfChannelsPerRequest()",
    "177": "void addQosPolicies(java.util.List, android.os.IBinder, java.lang.String, android.net.wifi.IListListener)",
    "178": "void removeQosPolicies([I, java.lang.String)",
    "179": "void removeAllQosPolicies(java.lang.String)",
    "180": "void setLinkLayerStatsPollingInterval(int)",
    "181": "void getLinkLayerStatsPollingInterval(android.net.wifi.IIntegerListener)",
    "182": "void setMloMode(int, android.net.wifi.IBooleanListener)",
    "183": "void getMloMode(android.net.wifi.IIntegerListener)",
    "184": "void addWifiLowLatencyLockListener(android.net.wifi.IWifiLowLatencyLockListener)",
    "185": "void removeWifiLowLatencyLockListener(android.net.wifi.IWifiLowLatencyLockListener)",
    "186": "void getMaxMloAssociationLinkCount(android.net.wifi.IIntegerListener, android.os.Bundle)",
    "187": "void getMaxMloStrLinkCount(android.net.wifi.IIntegerListener, android.os.Bundle)",
    "188": "void getSupportedSimultaneousBandCombinations(android.net.wifi.IWifiBandsListener, android.os.Bundle)"
  },
  "android.hardware.usb.IUsbManager": {
    "1": "void getDeviceList(android.os.Bundle)",
    "2": "android.os.ParcelFileDescriptor openDevice(java.lang.String, java.lang.String)",
    "3": "android.hardware.usb.UsbAccessory getCurrentAccessory()",
    "4": "android.os.ParcelFileDescriptor openAccessory(android.hardware.usb.UsbAccessory)",
    "5": "void setDevicePackage(android.hardware.usb.UsbDevice, java.lang.String, int)",
    "6": "void setAccessoryPackage(android.hardware.usb.UsbAccessory, java.lang.String, int)",
    "7": "void addDevicePackagesToPreferenceDenied(android.hardware.usb.UsbDevice, [Ljava.lang.String;, android.os.UserHandle)",
    "8": "void addAccessoryPackagesToPreferenceDenied(android.hardware.usb.UsbAccessory, [Ljava.lang.String;, android.os.UserHandle)",
    "9": "void removeDevicePackagesFromPreferenceDenied(android.hardware.usb.UsbDevice, [Ljava.lang.String;, android.os.UserHandle)",
    "10": "void removeAccessoryPackagesFromPreferenceDenied(android.hardware.usb.UsbAccessory, [Ljava.lang.String;, android.os.UserHandle)",
    "11": "void setDevicePersistentPermission(android.hardware.usb.UsbDevice, int, android.os.UserHandle, boolean)",
    "12": "void setAccessoryPersistentPermission(android.hardware.usb.UsbAccessory, int, android.os.UserHandle, boolean)",
    "13": "boolean hasDevicePermission(android.hardware.usb.UsbDevice, java.lang.String)",
    "14": "boolean hasDevicePermissionWithIdentity(android.hardware.usb.UsbDevice, java.lang.String, int, int)",
    "15": "boolean hasAccessoryPermission(android.hardware.usb.UsbAccessory)",
    "16": "boolean hasAccessoryPermissionWithIdentity(android.hardware.usb.UsbAccessory, int, int)",
    "17": "void requestDevicePermission(android.hardware.usb.UsbDevice, java.lang.String, android.app.PendingIntent)",
    "18": "void requestAccessoryPermission(android.hardware.usb.UsbAccessory, java.lang.String, android.app.PendingIntent)",
    "19": "void grantDevicePermission(android.hardware.usb.UsbDevice, int)",
    "20": "void grantAccessoryPermission(android.hardware.usb.UsbAccessory, int)",
    "21": "boolean hasDefaults(java.lang.String, int)",
    "22": "void clearDefaults(java.lang.String, int)",
    "23": "boolean isFunctionEnabled(java.lang.String)",
    "24": "void setCurrentFunctions(long, int)",
    "25": "void setCurrentFunction(java.lang.String, boolean, int)",
    "26": "long getCurrentFunctions()",
    "27": "int getCurrentUsbSpeed()",
    "28": "int getGadgetHalVersion()",
    "29": "void setScreenUnlockedFunctions(long)",
    "30": "long getScreenUnlockedFunctions()",
    "31": "void resetUsbGadget()",
    "32": "void resetUsbPort(java.lang.String, int, android.hardware.usb.IUsbOperationInternal)",
    "33": "boolean enableUsbData(java.lang.String, boolean, int, android.hardware.usb.IUsbOperationInternal)",
    "34": "void enableUsbDataWhileDocked(java.lang.String, int, android.hardware.usb.IUsbOperationInternal)",
    "35": "int getUsbHalVersion()",
    "36": "android.os.ParcelFileDescriptor getControlFd(long)",
    "37": "java.util.List getPorts()",
    "38": "android.hardware.usb.UsbPortStatus getPortStatus(java.lang.String)",
    "39": "void setPortRoles(java.lang.String, int, int)",
    "40": "void enableLimitPowerTransfer(java.lang.String, boolean, int, android.hardware.usb.IUsbOperationInternal)",
    "41": "void enableContaminantDetection(java.lang.String, boolean)",
    "42": "void setUsbDeviceConnectionHandler(android.content.ComponentName)",
    "43": "boolean registerForDisplayPortEvents(android.hardware.usb.IDisplayPortAltModeInfoListener)",
    "44": "void unregisterForDisplayPortEvents(android.hardware.usb.IDisplayPortAltModeInfoListener)"
  },
  "android.media.IMediaRouterService": {
    "1": "void registerClientAsUser(android.media.IMediaRouterClient, java.lang.String, int)",
    "2": "void unregisterClient(android.media.IMediaRouterClient)",
    "3": "void registerClientGroupId(android.media.IMediaRouterClient, java.lang.String)",
    "4": "android.media.MediaRouterClientState getState(android.media.IMediaRouterClient)",
    "5": "boolean isPlaybackActive(android.media.IMediaRouterClient)",
    "6": "void setBluetoothA2dpOn(android.media.IMediaRouterClient, boolean)",
    "7": "void setDiscoveryRequest(android.media.IMediaRouterClient, int, boolean)",
    "8": "void setSelectedRoute(android.media.IMediaRouterClient, java.lang.String, boolean)",
    "9": "void requestSetVolume(android.media.IMediaRouterClient, java.lang.String, int)",
    "10": "void requestUpdateVolume(android.media.IMediaRouterClient, java.lang.String, int)",
    "11": "boolean verifyPackageExists(java.lang.String)",
    "12": "java.util.List getSystemRoutes()",
    "13": "android.media.RoutingSessionInfo getSystemSessionInfo()",
    "14": "void registerRouter2(android.media.IMediaRouter2, java.lang.String)",
    "15": "void unregisterRouter2(android.media.IMediaRouter2)",
    "16": "void setDiscoveryRequestWithRouter2(android.media.IMediaRouter2, android.media.RouteDiscoveryPreference)",
    "17": "void setRouteListingPreference(android.media.IMediaRouter2, android.media.RouteListingPreference)",
    "18": "void setRouteVolumeWithRouter2(android.media.IMediaRouter2, android.media.MediaRoute2Info, int)",
    "19": "void requestCreateSessionWithRouter2(android.media.IMediaRouter2, int, long, android.media.RoutingSessionInfo, android.media.MediaRoute2Info, android.os.Bundle)",
    "20": "void selectRouteWithRouter2(android.media.IMediaRouter2, java.lang.String, android.media.MediaRoute2Info)",
    "21": "void deselectRouteWithRouter2(android.media.IMediaRouter2, java.lang.String, android.media.MediaRoute2Info)",
    "22": "void transferToRouteWithRouter2(android.media.IMediaRouter2, java.lang.String, android.media.MediaRoute2Info)",
    "23": "void setSessionVolumeWithRouter2(android.media.IMediaRouter2, java.lang.String, int)",
    "24": "void releaseSessionWithRouter2(android.media.IMediaRouter2, java.lang.String)",
    "25": "java.util.List getRemoteSessions(android.media.IMediaRouter2Manager)",
    "26": "android.media.RoutingSessionInfo getSystemSessionInfoForPackage(android.media.IMediaRouter2Manager, java.lang.String)",
    "27": "void registerManager(android.media.IMediaRouter2Manager, java.lang.String)",
    "28": "void unregisterManager(android.media.IMediaRouter2Manager)",
    "29": "void setRouteVolumeWithManager(android.media.IMediaRouter2Manager, int, android.media.MediaRoute2Info, int)",
    "30": "void startScan(android.media.IMediaRouter2Manager)",
    "31": "void stopScan(android.media.IMediaRouter2Manager)",
    "32": "void requestCreateSessionWithManager(android.media.IMediaRouter2Manager, int, android.media.RoutingSessionInfo, android.media.MediaRoute2Info)",
    "33": "void selectRouteWithManager(android.media.IMediaRouter2Manager, int, java.lang.String, android.media.MediaRoute2Info)",
    "34": "void deselectRouteWithManager(android.media.IMediaRouter2Manager, int, java.lang.String, android.media.MediaRoute2Info)",
    "35": "void transferToRouteWithManager(android.media.IMediaRouter2Manager, int, java.lang.String, android.media.MediaRoute2Info)",
    "36": "void setSessionVolumeWithManager(android.media.IMediaRouter2Manager, int, java.lang.String, int)",
    "37": "void releaseSessionWithManager(android.media.IMediaRouter2Manager, int, java.lang.String)",
    "38": "boolean showMediaOutputSwitcher(java.lang.String)"
  },
  "android.permission.IPermissionManager": {
    "1": "android.content.pm.ParceledListSlice getAllPermissionGroups(int)",
    "2": "android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String, int)",
    "3": "android.content.pm.PermissionInfo getPermissionInfo(java.lang.String, java.lang.String, int)",
    "4": "android.content.pm.ParceledListSlice queryPermissionsByGroup(java.lang.String, int)",
    "5": "boolean addPermission(android.content.pm.PermissionInfo, boolean)",
    "6": "void removePermission(java.lang.String)",
    "7": "int getPermissionFlags(java.lang.String, java.lang.String, int)",
    "8": "void updatePermissionFlags(java.lang.String, java.lang.String, int, int, boolean, int)",
    "9": "void updatePermissionFlagsForAllApps(int, int, int)",
    "10": "void addOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)",
    "11": "void removeOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)",
    "12": "java.util.List getAllowlistedRestrictedPermissions(java.lang.String, int, int)",
    "13": "boolean addAllowlistedRestrictedPermission(java.lang.String, java.lang.String, int, int)",
    "14": "boolean removeAllowlistedRestrictedPermission(java.lang.String, java.lang.String, int, int)",
    "15": "void grantRuntimePermission(java.lang.String, java.lang.String, int)",
    "16": "void revokeRuntimePermission(java.lang.String, java.lang.String, int, java.lang.String)",
    "17": "void revokePostNotificationPermissionWithoutKillForTest(java.lang.String, int)",
    "18": "boolean shouldShowRequestPermissionRationale(java.lang.String, java.lang.String, int)",
    "19": "boolean isPermissionRevokedByPolicy(java.lang.String, java.lang.String, int)",
    "20": "java.util.List getSplitPermissions()",
    "21": "void startOneTimePermissionSession(java.lang.String, int, long, long)",
    "22": "void stopOneTimePermissionSession(java.lang.String, int)",
    "23": "java.util.List getAutoRevokeExemptionRequestedPackages(int)",
    "24": "java.util.List getAutoRevokeExemptionGrantedPackages(int)",
    "25": "boolean setAutoRevokeExempted(java.lang.String, boolean, int)",
    "26": "boolean isAutoRevokeExempted(java.lang.String, int)",
    "27": "void registerAttributionSource(android.content.AttributionSourceState)",
    "28": "boolean isRegisteredAttributionSource(android.content.AttributionSourceState)"
  },
  "android.app.admin.IDevicePolicyManager": {
    "1": "void setPasswordQuality(android.content.ComponentName, int, boolean)",
    "2": "int getPasswordQuality(android.content.ComponentName, int, boolean)",
    "3": "void setPasswordMinimumLength(android.content.ComponentName, int, boolean)",
    "4": "int getPasswordMinimumLength(android.content.ComponentName, int, boolean)",
    "5": "void setPasswordMinimumUpperCase(android.content.ComponentName, int, boolean)",
    "6": "int getPasswordMinimumUpperCase(android.content.ComponentName, int, boolean)",
    "7": "void setPasswordMinimumLowerCase(android.content.ComponentName, int, boolean)",
    "8": "int getPasswordMinimumLowerCase(android.content.ComponentName, int, boolean)",
    "9": "void setPasswordMinimumLetters(android.content.ComponentName, int, boolean)",
    "10": "int getPasswordMinimumLetters(android.content.ComponentName, int, boolean)",
    "11": "void setPasswordMinimumNumeric(android.content.ComponentName, int, boolean)",
    "12": "int getPasswordMinimumNumeric(android.content.ComponentName, int, boolean)",
    "13": "void setPasswordMinimumSymbols(android.content.ComponentName, int, boolean)",
    "14": "int getPasswordMinimumSymbols(android.content.ComponentName, int, boolean)",
    "15": "void setPasswordMinimumNonLetter(android.content.ComponentName, int, boolean)",
    "16": "int getPasswordMinimumNonLetter(android.content.ComponentName, int, boolean)",
    "17": "android.app.admin.PasswordMetrics getPasswordMinimumMetrics(int, boolean)",
    "18": "void setPasswordHistoryLength(android.content.ComponentName, int, boolean)",
    "19": "int getPasswordHistoryLength(android.content.ComponentName, int, boolean)",
    "20": "void setPasswordExpirationTimeout(android.content.ComponentName, java.lang.String, long, boolean)",
    "21": "long getPasswordExpirationTimeout(android.content.ComponentName, int, boolean)",
    "22": "long getPasswordExpiration(android.content.ComponentName, int, boolean)",
    "23": "boolean isActivePasswordSufficient(java.lang.String, int, boolean)",
    "24": "boolean isActivePasswordSufficientForDeviceRequirement()",
    "25": "boolean isPasswordSufficientAfterProfileUnification(int, int)",
    "26": "int getPasswordComplexity(boolean)",
    "27": "void setRequiredPasswordComplexity(java.lang.String, int, boolean)",
    "28": "int getRequiredPasswordComplexity(java.lang.String, boolean)",
    "29": "int getAggregatedPasswordComplexityForUser(int, boolean)",
    "30": "boolean isUsingUnifiedPassword(android.content.ComponentName)",
    "31": "int getCurrentFailedPasswordAttempts(java.lang.String, int, boolean)",
    "32": "int getProfileWithMinimumFailedPasswordsForWipe(int, boolean)",
    "33": "void setMaximumFailedPasswordsForWipe(android.content.ComponentName, java.lang.String, int, boolean)",
    "34": "int getMaximumFailedPasswordsForWipe(android.content.ComponentName, int, boolean)",
    "35": "boolean resetPassword(java.lang.String, int)",
    "36": "void setMaximumTimeToLock(android.content.ComponentName, java.lang.String, long, boolean)",
    "37": "long getMaximumTimeToLock(android.content.ComponentName, int, boolean)",
    "38": "void setRequiredStrongAuthTimeout(android.content.ComponentName, java.lang.String, long, boolean)",
    "39": "long getRequiredStrongAuthTimeout(android.content.ComponentName, int, boolean)",
    "40": "void lockNow(int, java.lang.String, boolean)",
    "41": "void wipeDataWithReason(java.lang.String, int, java.lang.String, boolean, boolean)",
    "42": "void setFactoryResetProtectionPolicy(android.content.ComponentName, java.lang.String, android.app.admin.FactoryResetProtectionPolicy)",
    "43": "android.app.admin.FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(android.content.ComponentName)",
    "44": "boolean isFactoryResetProtectionPolicySupported()",
    "45": "void sendLostModeLocationUpdate(com.android.internal.infra.AndroidFuture)",
    "46": "android.content.ComponentName setGlobalProxy(android.content.ComponentName, java.lang.String, java.lang.String)",
    "47": "android.content.ComponentName getGlobalProxyAdmin(int)",
    "48": "void setRecommendedGlobalProxy(android.content.ComponentName, android.net.ProxyInfo)",
    "49": "int setStorageEncryption(android.content.ComponentName, boolean)",
    "50": "boolean getStorageEncryption(android.content.ComponentName, int)",
    "51": "int getStorageEncryptionStatus(java.lang.String, int)",
    "52": "boolean requestBugreport(android.content.ComponentName)",
    "53": "void setCameraDisabled(android.content.ComponentName, java.lang.String, boolean, boolean)",
    "54": "boolean getCameraDisabled(android.content.ComponentName, java.lang.String, int, boolean)",
    "55": "void setScreenCaptureDisabled(android.content.ComponentName, java.lang.String, boolean, boolean)",
    "56": "boolean getScreenCaptureDisabled(android.content.ComponentName, int, boolean)",
    "57": "void setNearbyNotificationStreamingPolicy(int)",
    "58": "int getNearbyNotificationStreamingPolicy(int)",
    "59": "void setNearbyAppStreamingPolicy(int)",
    "60": "int getNearbyAppStreamingPolicy(int)",
    "61": "void setKeyguardDisabledFeatures(android.content.ComponentName, java.lang.String, int, boolean)",
    "62": "int getKeyguardDisabledFeatures(android.content.ComponentName, int, boolean)",
    "63": "void setActiveAdmin(android.content.ComponentName, boolean, int)",
    "64": "boolean isAdminActive(android.content.ComponentName, int)",
    "65": "java.util.List getActiveAdmins(int)",
    "66": "boolean packageHasActiveAdmins(java.lang.String, int)",
    "67": "void getRemoveWarning(android.content.ComponentName, android.os.RemoteCallback, int)",
    "68": "void removeActiveAdmin(android.content.ComponentName, int)",
    "69": "void forceRemoveActiveAdmin(android.content.ComponentName, int)",
    "70": "boolean hasGrantedPolicy(android.content.ComponentName, int, int)",
    "71": "void reportPasswordChanged(android.app.admin.PasswordMetrics, int)",
    "72": "void reportFailedPasswordAttempt(int, boolean)",
    "73": "void reportSuccessfulPasswordAttempt(int)",
    "74": "void reportFailedBiometricAttempt(int)",
    "75": "void reportSuccessfulBiometricAttempt(int)",
    "76": "void reportKeyguardDismissed(int)",
    "77": "void reportKeyguardSecured(int)",
    "78": "boolean setDeviceOwner(android.content.ComponentName, int, boolean)",
    "79": "android.content.ComponentName getDeviceOwnerComponent(boolean)",
    "80": "boolean hasDeviceOwner()",
    "81": "java.lang.String getDeviceOwnerName()",
    "82": "void clearDeviceOwner(java.lang.String)",
    "83": "int getDeviceOwnerUserId()",
    "84": "boolean setProfileOwner(android.content.ComponentName, int)",
    "85": "android.content.ComponentName getProfileOwnerAsUser(int)",
    "86": "android.content.ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(android.os.UserHandle)",
    "87": "boolean isSupervisionComponent(android.content.ComponentName)",
    "88": "java.lang.String getProfileOwnerName(int)",
    "89": "void setProfileEnabled(android.content.ComponentName)",
    "90": "void setProfileName(android.content.ComponentName, java.lang.String)",
    "91": "void clearProfileOwner(android.content.ComponentName)",
    "92": "boolean hasUserSetupCompleted()",
    "93": "boolean isOrganizationOwnedDeviceWithManagedProfile()",
    "94": "boolean checkDeviceIdentifierAccess(java.lang.String, int, int)",
    "95": "void setDeviceOwnerLockScreenInfo(android.content.ComponentName, java.lang.CharSequence)",
    "96": "java.lang.CharSequence getDeviceOwnerLockScreenInfo()",
    "97": "[Ljava.lang.String; setPackagesSuspended(android.content.ComponentName, java.lang.String, [Ljava.lang.String;, boolean)",
    "98": "boolean isPackageSuspended(android.content.ComponentName, java.lang.String, java.lang.String)",
    "99": "java.util.List listPolicyExemptApps()",
    "100": "boolean installCaCert(android.content.ComponentName, java.lang.String, [B)",
    "101": "void uninstallCaCerts(android.content.ComponentName, java.lang.String, [Ljava.lang.String;)",
    "102": "void enforceCanManageCaCerts(android.content.ComponentName, java.lang.String)",
    "103": "boolean approveCaCert(java.lang.String, int, boolean)",
    "104": "boolean isCaCertApproved(java.lang.String, int)",
    "105": "boolean installKeyPair(android.content.ComponentName, java.lang.String, [B, [B, [B, java.lang.String, boolean, boolean)",
    "106": "boolean removeKeyPair(android.content.ComponentName, java.lang.String, java.lang.String)",
    "107": "boolean hasKeyPair(java.lang.String, java.lang.String)",
    "108": "boolean generateKeyPair(android.content.ComponentName, java.lang.String, java.lang.String, android.security.keystore.ParcelableKeyGenParameterSpec, int, android.security.keymaster.KeymasterCertificateChain)",
    "109": "boolean setKeyPairCertificate(android.content.ComponentName, java.lang.String, java.lang.String, [B, [B, boolean)",
    "110": "void choosePrivateKeyAlias(int, android.net.Uri, java.lang.String, android.os.IBinder)",
    "111": "void setDelegatedScopes(android.content.ComponentName, java.lang.String, java.util.List)",
    "112": "java.util.List getDelegatedScopes(android.content.ComponentName, java.lang.String)",
    "113": "java.util.List getDelegatePackages(android.content.ComponentName, java.lang.String)",
    "114": "void setCertInstallerPackage(android.content.ComponentName, java.lang.String)",
    "115": "java.lang.String getCertInstallerPackage(android.content.ComponentName)",
    "116": "boolean setAlwaysOnVpnPackage(android.content.ComponentName, java.lang.String, boolean, java.util.List)",
    "117": "java.lang.String getAlwaysOnVpnPackage(android.content.ComponentName)",
    "118": "java.lang.String getAlwaysOnVpnPackageForUser(int)",
    "119": "boolean isAlwaysOnVpnLockdownEnabled(android.content.ComponentName)",
    "120": "boolean isAlwaysOnVpnLockdownEnabledForUser(int)",
    "121": "java.util.List getAlwaysOnVpnLockdownAllowlist(android.content.ComponentName)",
    "122": "void addPersistentPreferredActivity(android.content.ComponentName, java.lang.String, android.content.IntentFilter, android.content.ComponentName)",
    "123": "void clearPackagePersistentPreferredActivities(android.content.ComponentName, java.lang.String, java.lang.String)",
    "124": "void setDefaultSmsApplication(android.content.ComponentName, java.lang.String, java.lang.String, boolean)",
    "125": "void setDefaultDialerApplication(java.lang.String)",
    "126": "void setApplicationRestrictions(android.content.ComponentName, java.lang.String, java.lang.String, android.os.Bundle)",
    "127": "android.os.Bundle getApplicationRestrictions(android.content.ComponentName, java.lang.String, java.lang.String)",
    "128": "boolean setApplicationRestrictionsManagingPackage(android.content.ComponentName, java.lang.String)",
    "129": "java.lang.String getApplicationRestrictionsManagingPackage(android.content.ComponentName)",
    "130": "boolean isCallerApplicationRestrictionsManagingPackage(java.lang.String)",
    "131": "void setRestrictionsProvider(android.content.ComponentName, android.content.ComponentName)",
    "132": "android.content.ComponentName getRestrictionsProvider(int)",
    "133": "void setUserRestriction(android.content.ComponentName, java.lang.String, java.lang.String, boolean, boolean)",
    "134": "void setUserRestrictionGlobally(java.lang.String, java.lang.String)",
    "135": "android.os.Bundle getUserRestrictions(android.content.ComponentName, java.lang.String, boolean)",
    "136": "android.os.Bundle getUserRestrictionsGlobally(java.lang.String)",
    "137": "void addCrossProfileIntentFilter(android.content.ComponentName, java.lang.String, android.content.IntentFilter, int)",
    "138": "void clearCrossProfileIntentFilters(android.content.ComponentName, java.lang.String)",
    "139": "boolean setPermittedAccessibilityServices(android.content.ComponentName, java.util.List)",
    "140": "java.util.List getPermittedAccessibilityServices(android.content.ComponentName)",
    "141": "java.util.List getPermittedAccessibilityServicesForUser(int)",
    "142": "boolean isAccessibilityServicePermittedByAdmin(android.content.ComponentName, java.lang.String, int)",
    "143": "boolean setPermittedInputMethods(android.content.ComponentName, java.lang.String, java.util.List, boolean)",
    "144": "java.util.List getPermittedInputMethods(android.content.ComponentName, java.lang.String, boolean)",
    "145": "java.util.List getPermittedInputMethodsAsUser(int)",
    "146": "boolean isInputMethodPermittedByAdmin(android.content.ComponentName, java.lang.String, int, boolean)",
    "147": "boolean setPermittedCrossProfileNotificationListeners(android.content.ComponentName, java.util.List)",
    "148": "java.util.List getPermittedCrossProfileNotificationListeners(android.content.ComponentName)",
    "149": "boolean isNotificationListenerServicePermitted(java.lang.String, int)",
    "150": "android.content.Intent createAdminSupportIntent(java.lang.String)",
    "151": "android.os.Bundle getEnforcingAdminAndUserDetails(int, java.lang.String)",
    "152": "boolean setApplicationHidden(android.content.ComponentName, java.lang.String, java.lang.String, boolean, boolean)",
    "153": "boolean isApplicationHidden(android.content.ComponentName, java.lang.String, java.lang.String, boolean)",
    "154": "android.os.UserHandle createAndManageUser(android.content.ComponentName, java.lang.String, android.content.ComponentName, android.os.PersistableBundle, int)",
    "155": "boolean removeUser(android.content.ComponentName, android.os.UserHandle)",
    "156": "boolean switchUser(android.content.ComponentName, android.os.UserHandle)",
    "157": "int startUserInBackground(android.content.ComponentName, android.os.UserHandle)",
    "158": "int stopUser(android.content.ComponentName, android.os.UserHandle)",
    "159": "int logoutUser(android.content.ComponentName)",
    "160": "int logoutUserInternal()",
    "161": "int getLogoutUserId()",
    "162": "java.util.List getSecondaryUsers(android.content.ComponentName)",
    "163": "void acknowledgeNewUserDisclaimer(int)",
    "164": "boolean isNewUserDisclaimerAcknowledged(int)",
    "165": "void enableSystemApp(android.content.ComponentName, java.lang.String, java.lang.String)",
    "166": "int enableSystemAppWithIntent(android.content.ComponentName, java.lang.String, android.content.Intent)",
    "167": "boolean installExistingPackage(android.content.ComponentName, java.lang.String, java.lang.String)",
    "168": "void setAccountManagementDisabled(android.content.ComponentName, java.lang.String, java.lang.String, boolean, boolean)",
    "169": "[Ljava.lang.String; getAccountTypesWithManagementDisabled(java.lang.String)",
    "170": "[Ljava.lang.String; getAccountTypesWithManagementDisabledAsUser(int, java.lang.String, boolean)",
    "171": "void setSecondaryLockscreenEnabled(android.content.ComponentName, boolean)",
    "172": "boolean isSecondaryLockscreenEnabled(android.os.UserHandle)",
    "173": "void setPreferentialNetworkServiceConfigs(java.util.List)",
    "174": "java.util.List getPreferentialNetworkServiceConfigs()",
    "175": "void setLockTaskPackages(android.content.ComponentName, java.lang.String, [Ljava.lang.String;)",
    "176": "[Ljava.lang.String; getLockTaskPackages(android.content.ComponentName, java.lang.String)",
    "177": "boolean isLockTaskPermitted(java.lang.String)",
    "178": "void setLockTaskFeatures(android.content.ComponentName, java.lang.String, int)",
    "179": "int getLockTaskFeatures(android.content.ComponentName, java.lang.String)",
    "180": "void setGlobalSetting(android.content.ComponentName, java.lang.String, java.lang.String)",
    "181": "void setSystemSetting(android.content.ComponentName, java.lang.String, java.lang.String)",
    "182": "void setSecureSetting(android.content.ComponentName, java.lang.String, java.lang.String)",
    "183": "void setConfiguredNetworksLockdownState(android.content.ComponentName, java.lang.String, boolean)",
    "184": "boolean hasLockdownAdminConfiguredNetworks(android.content.ComponentName)",
    "185": "void setLocationEnabled(android.content.ComponentName, boolean)",
    "186": "boolean setTime(android.content.ComponentName, java.lang.String, long)",
    "187": "boolean setTimeZone(android.content.ComponentName, java.lang.String, java.lang.String)",
    "188": "void setMasterVolumeMuted(android.content.ComponentName, boolean)",
    "189": "boolean isMasterVolumeMuted(android.content.ComponentName)",
    "190": "void notifyLockTaskModeChanged(boolean, java.lang.String, int)",
    "191": "void setUninstallBlocked(android.content.ComponentName, java.lang.String, java.lang.String, boolean)",
    "192": "boolean isUninstallBlocked(java.lang.String)",
    "193": "void setCrossProfileCallerIdDisabled(android.content.ComponentName, boolean)",
    "194": "boolean getCrossProfileCallerIdDisabled(android.content.ComponentName)",
    "195": "boolean getCrossProfileCallerIdDisabledForUser(int)",
    "196": "void setCrossProfileContactsSearchDisabled(android.content.ComponentName, boolean)",
    "197": "boolean getCrossProfileContactsSearchDisabled(android.content.ComponentName)",
    "198": "boolean getCrossProfileContactsSearchDisabledForUser(int)",
    "199": "void startManagedQuickContact(java.lang.String, long, boolean, long, android.content.Intent)",
    "200": "void setManagedProfileCallerIdAccessPolicy(android.app.admin.PackagePolicy)",
    "201": "android.app.admin.PackagePolicy getManagedProfileCallerIdAccessPolicy()",
    "202": "boolean hasManagedProfileCallerIdAccess(int, java.lang.String)",
    "203": "void setCredentialManagerPolicy(android.app.admin.PackagePolicy)",
    "204": "android.app.admin.PackagePolicy getCredentialManagerPolicy()",
    "205": "void setManagedProfileContactsAccessPolicy(android.app.admin.PackagePolicy)",
    "206": "android.app.admin.PackagePolicy getManagedProfileContactsAccessPolicy()",
    "207": "boolean hasManagedProfileContactsAccess(int, java.lang.String)",
    "208": "void setBluetoothContactSharingDisabled(android.content.ComponentName, boolean)",
    "209": "boolean getBluetoothContactSharingDisabled(android.content.ComponentName)",
    "210": "boolean getBluetoothContactSharingDisabledForUser(int)",
    "211": "void setTrustAgentConfiguration(android.content.ComponentName, java.lang.String, android.content.ComponentName, android.os.PersistableBundle, boolean)",
    "212": "java.util.List getTrustAgentConfiguration(android.content.ComponentName, android.content.ComponentName, int, boolean)",
    "213": "boolean addCrossProfileWidgetProvider(android.content.ComponentName, java.lang.String, java.lang.String)",
    "214": "boolean removeCrossProfileWidgetProvider(android.content.ComponentName, java.lang.String, java.lang.String)",
    "215": "java.util.List getCrossProfileWidgetProviders(android.content.ComponentName, java.lang.String)",
    "216": "void setAutoTimeRequired(android.content.ComponentName, boolean)",
    "217": "boolean getAutoTimeRequired()",
    "218": "void setAutoTimeEnabled(android.content.ComponentName, java.lang.String, boolean)",
    "219": "boolean getAutoTimeEnabled(android.content.ComponentName, java.lang.String)",
    "220": "void setAutoTimeZoneEnabled(android.content.ComponentName, java.lang.String, boolean)",
    "221": "boolean getAutoTimeZoneEnabled(android.content.ComponentName, java.lang.String)",
    "222": "void setForceEphemeralUsers(android.content.ComponentName, boolean)",
    "223": "boolean getForceEphemeralUsers(android.content.ComponentName)",
    "224": "boolean isRemovingAdmin(android.content.ComponentName, int)",
    "225": "void setUserIcon(android.content.ComponentName, android.graphics.Bitmap)",
    "226": "void setSystemUpdatePolicy(android.content.ComponentName, java.lang.String, android.app.admin.SystemUpdatePolicy)",
    "227": "android.app.admin.SystemUpdatePolicy getSystemUpdatePolicy()",
    "228": "void clearSystemUpdatePolicyFreezePeriodRecord()",
    "229": "boolean setKeyguardDisabled(android.content.ComponentName, boolean)",
    "230": "boolean setStatusBarDisabled(android.content.ComponentName, java.lang.String, boolean)",
    "231": "boolean isStatusBarDisabled(java.lang.String)",
    "232": "boolean getDoNotAskCredentialsOnBoot()",
    "233": "void notifyPendingSystemUpdate(android.app.admin.SystemUpdateInfo)",
    "234": "android.app.admin.SystemUpdateInfo getPendingSystemUpdate(android.content.ComponentName)",
    "235": "void setPermissionPolicy(android.content.ComponentName, java.lang.String, int)",
    "236": "int getPermissionPolicy(android.content.ComponentName)",
    "237": "void setPermissionGrantState(android.content.ComponentName, java.lang.String, java.lang.String, java.lang.String, int, android.os.RemoteCallback)",
    "238": "int getPermissionGrantState(android.content.ComponentName, java.lang.String, java.lang.String, java.lang.String)",
    "239": "boolean isProvisioningAllowed(java.lang.String, java.lang.String)",
    "240": "int checkProvisioningPrecondition(java.lang.String, java.lang.String)",
    "241": "void setKeepUninstalledPackages(android.content.ComponentName, java.lang.String, java.util.List)",
    "242": "java.util.List getKeepUninstalledPackages(android.content.ComponentName, java.lang.String)",
    "243": "boolean isManagedProfile(android.content.ComponentName)",
    "244": "java.lang.String getWifiMacAddress(android.content.ComponentName, java.lang.String)",
    "245": "void reboot(android.content.ComponentName)",
    "246": "void setShortSupportMessage(android.content.ComponentName, java.lang.String, java.lang.CharSequence)",
    "247": "java.lang.CharSequence getShortSupportMessage(android.content.ComponentName, java.lang.String)",
    "248": "void setLongSupportMessage(android.content.ComponentName, java.lang.CharSequence)",
    "249": "java.lang.CharSequence getLongSupportMessage(android.content.ComponentName)",
    "250": "java.lang.CharSequence getShortSupportMessageForUser(android.content.ComponentName, int)",
    "251": "java.lang.CharSequence getLongSupportMessageForUser(android.content.ComponentName, int)",
    "252": "void setOrganizationColor(android.content.ComponentName, int)",
    "253": "void setOrganizationColorForUser(int, int)",
    "254": "void clearOrganizationIdForUser(int)",
    "255": "int getOrganizationColor(android.content.ComponentName)",
    "256": "int getOrganizationColorForUser(int)",
    "257": "void setOrganizationName(android.content.ComponentName, java.lang.String, java.lang.CharSequence)",
    "258": "java.lang.CharSequence getOrganizationName(android.content.ComponentName, java.lang.String)",
    "259": "java.lang.CharSequence getDeviceOwnerOrganizationName()",
    "260": "java.lang.CharSequence getOrganizationNameForUser(int)",
    "261": "int getUserProvisioningState(int)",
    "262": "void setUserProvisioningState(int, int)",
    "263": "void setAffiliationIds(android.content.ComponentName, java.util.List)",
    "264": "java.util.List getAffiliationIds(android.content.ComponentName)",
    "265": "boolean isCallingUserAffiliated()",
    "266": "boolean isAffiliatedUser(int)",
    "267": "void setSecurityLoggingEnabled(android.content.ComponentName, java.lang.String, boolean)",
    "268": "boolean isSecurityLoggingEnabled(android.content.ComponentName, java.lang.String)",
    "269": "android.content.pm.ParceledListSlice retrieveSecurityLogs(android.content.ComponentName, java.lang.String)",
    "270": "android.content.pm.ParceledListSlice retrievePreRebootSecurityLogs(android.content.ComponentName, java.lang.String)",
    "271": "long forceNetworkLogs()",
    "272": "long forceSecurityLogs()",
    "273": "boolean isUninstallInQueue(java.lang.String)",
    "274": "void uninstallPackageWithActiveAdmins(java.lang.String)",
    "275": "boolean isDeviceProvisioned()",
    "276": "boolean isDeviceProvisioningConfigApplied()",
    "277": "void setDeviceProvisioningConfigApplied()",
    "278": "void forceUpdateUserSetupComplete(int)",
    "279": "void setBackupServiceEnabled(android.content.ComponentName, boolean)",
    "280": "boolean isBackupServiceEnabled(android.content.ComponentName)",
    "281": "void setNetworkLoggingEnabled(android.content.ComponentName, java.lang.String, boolean)",
    "282": "boolean isNetworkLoggingEnabled(android.content.ComponentName, java.lang.String)",
    "283": "java.util.List retrieveNetworkLogs(android.content.ComponentName, java.lang.String, long)",
    "284": "boolean bindDeviceAdminServiceAsUser(android.content.ComponentName, android.app.IApplicationThread, android.os.IBinder, android.content.Intent, android.app.IServiceConnection, long, int)",
    "285": "java.util.List getBindDeviceAdminTargetUsers(android.content.ComponentName)",
    "286": "boolean isEphemeralUser(android.content.ComponentName)",
    "287": "long getLastSecurityLogRetrievalTime()",
    "288": "long getLastBugReportRequestTime()",
    "289": "long getLastNetworkLogRetrievalTime()",
    "290": "boolean setResetPasswordToken(android.content.ComponentName, java.lang.String, [B)",
    "291": "boolean clearResetPasswordToken(android.content.ComponentName, java.lang.String)",
    "292": "boolean isResetPasswordTokenActive(android.content.ComponentName, java.lang.String)",
    "293": "boolean resetPasswordWithToken(android.content.ComponentName, java.lang.String, java.lang.String, [B, int)",
    "294": "boolean isCurrentInputMethodSetByOwner()",
    "295": "android.content.pm.StringParceledListSlice getOwnerInstalledCaCerts(android.os.UserHandle)",
    "296": "void clearApplicationUserData(android.content.ComponentName, java.lang.String, android.content.pm.IPackageDataObserver)",
    "297": "void setLogoutEnabled(android.content.ComponentName, boolean)",
    "298": "boolean isLogoutEnabled()",
    "299": "java.util.List getDisallowedSystemApps(android.content.ComponentName, int, java.lang.String)",
    "300": "void transferOwnership(android.content.ComponentName, android.content.ComponentName, android.os.PersistableBundle)",
    "301": "android.os.PersistableBundle getTransferOwnershipBundle()",
    "302": "void setStartUserSessionMessage(android.content.ComponentName, java.lang.CharSequence)",
    "303": "void setEndUserSessionMessage(android.content.ComponentName, java.lang.CharSequence)",
    "304": "java.lang.CharSequence getStartUserSessionMessage(android.content.ComponentName)",
    "305": "java.lang.CharSequence getEndUserSessionMessage(android.content.ComponentName)",
    "306": "java.util.List setMeteredDataDisabledPackages(android.content.ComponentName, java.util.List)",
    "307": "java.util.List getMeteredDataDisabledPackages(android.content.ComponentName)",
    "308": "int addOverrideApn(android.content.ComponentName, android.telephony.data.ApnSetting)",
    "309": "boolean updateOverrideApn(android.content.ComponentName, int, android.telephony.data.ApnSetting)",
    "310": "boolean removeOverrideApn(android.content.ComponentName, int)",
    "311": "java.util.List getOverrideApns(android.content.ComponentName)",
    "312": "void setOverrideApnsEnabled(android.content.ComponentName, boolean)",
    "313": "boolean isOverrideApnEnabled(android.content.ComponentName)",
    "314": "boolean isMeteredDataDisabledPackageForUser(android.content.ComponentName, java.lang.String, int)",
    "315": "int setGlobalPrivateDns(android.content.ComponentName, int, java.lang.String)",
    "316": "int getGlobalPrivateDnsMode(android.content.ComponentName)",
    "317": "java.lang.String getGlobalPrivateDnsHost(android.content.ComponentName)",
    "318": "void setProfileOwnerOnOrganizationOwnedDevice(android.content.ComponentName, int, boolean)",
    "319": "void installUpdateFromFile(android.content.ComponentName, java.lang.String, android.os.ParcelFileDescriptor, android.app.admin.StartInstallingUpdateCallback)",
    "320": "void setCrossProfileCalendarPackages(android.content.ComponentName, java.util.List)",
    "321": "java.util.List getCrossProfileCalendarPackages(android.content.ComponentName)",
    "322": "boolean isPackageAllowedToAccessCalendarForUser(java.lang.String, int)",
    "323": "java.util.List getCrossProfileCalendarPackagesForUser(int)",
    "324": "void setCrossProfilePackages(android.content.ComponentName, java.util.List)",
    "325": "java.util.List getCrossProfilePackages(android.content.ComponentName)",
    "326": "java.util.List getAllCrossProfilePackages(int)",
    "327": "java.util.List getDefaultCrossProfilePackages()",
    "328": "boolean isManagedKiosk()",
    "329": "boolean isUnattendedManagedKiosk()",
    "330": "boolean startViewCalendarEventInManagedProfile(java.lang.String, long, long, long, boolean, int)",
    "331": "boolean setKeyGrantForApp(android.content.ComponentName, java.lang.String, java.lang.String, java.lang.String, boolean)",
    "332": "android.app.admin.ParcelableGranteeMap getKeyPairGrants(java.lang.String, java.lang.String)",
    "333": "boolean setKeyGrantToWifiAuth(java.lang.String, java.lang.String, boolean)",
    "334": "boolean isKeyPairGrantedToWifiAuth(java.lang.String, java.lang.String)",
    "335": "void setUserControlDisabledPackages(android.content.ComponentName, java.lang.String, java.util.List)",
    "336": "java.util.List getUserControlDisabledPackages(android.content.ComponentName, java.lang.String)",
    "337": "void setCommonCriteriaModeEnabled(android.content.ComponentName, java.lang.String, boolean)",
    "338": "boolean isCommonCriteriaModeEnabled(android.content.ComponentName)",
    "339": "int getPersonalAppsSuspendedReasons(android.content.ComponentName)",
    "340": "void setPersonalAppsSuspended(android.content.ComponentName, boolean)",
    "341": "long getManagedProfileMaximumTimeOff(android.content.ComponentName)",
    "342": "void setManagedProfileMaximumTimeOff(android.content.ComponentName, long)",
    "343": "void acknowledgeDeviceCompliant()",
    "344": "boolean isComplianceAcknowledgementRequired()",
    "345": "boolean canProfileOwnerResetPasswordWhenLocked(int)",
    "346": "void setNextOperationSafety(int, int)",
    "347": "boolean isSafeOperation(int)",
    "348": "java.lang.String getEnrollmentSpecificId(java.lang.String)",
    "349": "void setOrganizationIdForUser(java.lang.String, java.lang.String, int)",
    "350": "android.os.UserHandle createAndProvisionManagedProfile(android.app.admin.ManagedProfileProvisioningParams, java.lang.String)",
    "351": "void provisionFullyManagedDevice(android.app.admin.FullyManagedDeviceProvisioningParams, java.lang.String)",
    "352": "void finalizeWorkProfileProvisioning(android.os.UserHandle, android.accounts.Account)",
    "353": "void setDeviceOwnerType(android.content.ComponentName, int)",
    "354": "int getDeviceOwnerType(android.content.ComponentName)",
    "355": "void resetDefaultCrossProfileIntentFilters(int)",
    "356": "boolean canAdminGrantSensorsPermissions()",
    "357": "void setUsbDataSignalingEnabled(java.lang.String, boolean)",
    "358": "boolean isUsbDataSignalingEnabled(java.lang.String)",
    "359": "boolean isUsbDataSignalingEnabledForUser(int)",
    "360": "boolean canUsbDataSignalingBeDisabled()",
    "361": "void setMinimumRequiredWifiSecurityLevel(java.lang.String, int)",
    "362": "int getMinimumRequiredWifiSecurityLevel()",
    "363": "void setWifiSsidPolicy(java.lang.String, android.app.admin.WifiSsidPolicy)",
    "364": "android.app.admin.WifiSsidPolicy getWifiSsidPolicy(java.lang.String)",
    "365": "java.util.List listForegroundAffiliatedUsers()",
    "366": "void setDrawables(java.util.List)",
    "367": "void resetDrawables(java.util.List)",
    "368": "android.app.admin.ParcelableResource getDrawable(java.lang.String, java.lang.String, java.lang.String)",
    "369": "boolean isDpcDownloaded()",
    "370": "void setDpcDownloaded(boolean)",
    "371": "void setStrings(java.util.List)",
    "372": "void resetStrings(java.util.List)",
    "373": "android.app.admin.ParcelableResource getString(java.lang.String)",
    "374": "void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState()",
    "375": "boolean shouldAllowBypassingDevicePolicyManagementRoleQualification()",
    "376": "java.util.List getPolicyManagedProfiles(android.os.UserHandle)",
    "377": "void setApplicationExemptions(java.lang.String, java.lang.String, [I)",
    "378": "[I getApplicationExemptions(java.lang.String)",
    "379": "void setMtePolicy(int, java.lang.String)",
    "380": "int getMtePolicy(java.lang.String)",
    "381": "void setManagedSubscriptionsPolicy(android.app.admin.ManagedSubscriptionsPolicy)",
    "382": "android.app.admin.ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy()",
    "383": "android.app.admin.DevicePolicyState getDevicePolicyState()",
    "384": "void setOverrideKeepProfilesRunning(boolean)",
    "385": "boolean triggerDevicePolicyEngineMigration(boolean)",
    "386": "boolean isDeviceFinanced(java.lang.String)",
    "387": "java.lang.String getFinancedDeviceKioskRoleHolder(java.lang.String)",
    "388": "void calculateHasIncompatibleAccounts()"
  },
  "android.print.IPrintManager": {
    "1": "java.util.List getPrintJobInfos(int, int)",
    "2": "android.print.PrintJobInfo getPrintJobInfo(android.print.PrintJobId, int, int)",
    "3": "android.os.Bundle print(java.lang.String, android.print.IPrintDocumentAdapter, android.print.PrintAttributes, java.lang.String, int, int)",
    "4": "void cancelPrintJob(android.print.PrintJobId, int, int)",
    "5": "void restartPrintJob(android.print.PrintJobId, int, int)",
    "6": "void addPrintJobStateChangeListener(android.print.IPrintJobStateChangeListener, int, int)",
    "7": "void removePrintJobStateChangeListener(android.print.IPrintJobStateChangeListener, int)",
    "8": "void addPrintServicesChangeListener(android.print.IPrintServicesChangeListener, int)",
    "9": "void removePrintServicesChangeListener(android.print.IPrintServicesChangeListener, int)",
    "10": "java.util.List getPrintServices(int, int)",
    "11": "void setPrintServiceEnabled(android.content.ComponentName, boolean, int)",
    "12": "boolean isPrintServiceEnabled(android.content.ComponentName, int)",
    "13": "void addPrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener, int)",
    "14": "void removePrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener, int)",
    "15": "java.util.List getPrintServiceRecommendations(int)",
    "16": "void createPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver, int)",
    "17": "void startPrinterDiscovery(android.print.IPrinterDiscoveryObserver, java.util.List, int)",
    "18": "void stopPrinterDiscovery(android.print.IPrinterDiscoveryObserver, int)",
    "19": "void validatePrinters(java.util.List, int)",
    "20": "void startPrinterStateTracking(android.print.PrinterId, int)",
    "21": "android.graphics.drawable.Icon getCustomPrinterIcon(android.print.PrinterId, int)",
    "22": "void stopPrinterStateTracking(android.print.PrinterId, int)",
    "23": "void destroyPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver, int)",
    "24": "boolean getBindInstantServiceAllowed(int)",
    "25": "void setBindInstantServiceAllowed(int, boolean)"
  },
  "android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService": {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "5": "5"
  },
  "android.security.rkp.IRemoteProvisioning": {
    "1": "void getRegistration(java.lang.String, android.security.rkp.IGetRegistrationCallback)"
  },
  "android.app.IGrammaticalInflectionManager": {
    "1": "void setRequestedApplicationGrammaticalGender(java.lang.String, int, int)"
  },
  "android.hardware.ICameraServiceProxy": {
    "1": "void pingForUserUpdate()",
    "2": "void notifyCameraState(android.hardware.CameraSessionStats)",
    "3": "int getRotateAndCropOverride(java.lang.String, int, int)",
    "4": "int getAutoframingOverride(java.lang.String)",
    "5": "boolean isCameraDisabled(int)"
  },
  "android.net.IVpnManager": {
    "1": "boolean prepareVpn(java.lang.String, java.lang.String, int)",
    "2": "void setVpnPackageAuthorization(java.lang.String, int, int)",
    "3": "android.os.ParcelFileDescriptor establishVpn(com.android.internal.net.VpnConfig)",
    "4": "boolean addVpnAddress(java.lang.String, int)",
    "5": "boolean removeVpnAddress(java.lang.String, int)",
    "6": "boolean setUnderlyingNetworksForVpn([Landroid.net.Network;)",
    "7": "boolean provisionVpnProfile(com.android.internal.net.VpnProfile, java.lang.String)",
    "8": "void deleteVpnProfile(java.lang.String)",
    "9": "java.lang.String startVpnProfile(java.lang.String)",
    "10": "void stopVpnProfile(java.lang.String)",
    "11": "android.net.VpnProfileState getProvisionedVpnProfileState(java.lang.String)",
    "12": "boolean setAppExclusionList(int, java.lang.String, java.util.List)",
    "13": "java.util.List getAppExclusionList(int, java.lang.String)",
    "14": "boolean isAlwaysOnVpnPackageSupported(int, java.lang.String)",
    "15": "boolean setAlwaysOnVpnPackage(int, java.lang.String, boolean, java.util.List)",
    "16": "java.lang.String getAlwaysOnVpnPackage(int)",
    "17": "boolean isVpnLockdownEnabled(int)",
    "18": "java.util.List getVpnLockdownAllowlist(int)",
    "19": "boolean isCallerCurrentAlwaysOnVpnApp()",
    "20": "boolean isCallerCurrentAlwaysOnVpnLockdownApp()",
    "21": "void startLegacyVpn(com.android.internal.net.VpnProfile)",
    "22": "com.android.internal.net.LegacyVpnInfo getLegacyVpnInfo(int)",
    "23": "boolean updateLockdownVpn()",
    "24": "com.android.internal.net.VpnConfig getVpnConfig(int)",
    "25": "void factoryReset()"
  },
  "android.app.wearable.IWearableSensingManager": {
    "1": "void provideDataStream(android.os.ParcelFileDescriptor, android.os.RemoteCallback)",
    "2": "void provideData(android.os.PersistableBundle, android.os.SharedMemory, android.os.RemoteCallback)"
  },
  "com.android.internal.compat.IPlatformCompatNative": {
    "1": "void reportChangeByPackageName(long, java.lang.String, int)",
    "2": "void reportChangeByUid(long, int)",
    "3": "boolean isChangeEnabledByPackageName(long, java.lang.String, int)",
    "4": "boolean isChangeEnabledByUid(long, int)"
  },
  "android.view.contentcapture.IContentCaptureManager": {
    "1": "void startSession(android.os.IBinder, android.os.IBinder, android.content.ComponentName, int, int, com.android.internal.os.IResultReceiver)",
    "2": "void finishSession(int)",
    "3": "void getServiceComponentName(com.android.internal.os.IResultReceiver)",
    "4": "void removeData(android.view.contentcapture.DataRemovalRequest)",
    "5": "void shareData(android.view.contentcapture.DataShareRequest, android.view.contentcapture.IDataShareWriteAdapter)",
    "6": "void isContentCaptureFeatureEnabled(com.android.internal.os.IResultReceiver)",
    "7": "void getServiceSettingsActivity(com.android.internal.os.IResultReceiver)",
    "8": "void getContentCaptureConditions(java.lang.String, com.android.internal.os.IResultReceiver)",
    "9": "void resetTemporaryService(int)",
    "10": "void setTemporaryService(int, java.lang.String, int)",
    "11": "void setDefaultServiceEnabled(int, boolean)",
    "12": "void registerContentCaptureOptionsCallback(java.lang.String, android.view.contentcapture.IContentCaptureOptionsCallback)"
  },
  "com.android.internal.telecom.ITelecomService": {
    "1": "void showInCallScreen(boolean, java.lang.String, java.lang.String)",
    "2": "android.telecom.PhoneAccountHandle getDefaultOutgoingPhoneAccount(java.lang.String, java.lang.String, java.lang.String)",
    "3": "android.telecom.PhoneAccountHandle getUserSelectedOutgoingPhoneAccount(java.lang.String)",
    "4": "void setUserSelectedOutgoingPhoneAccount(android.telecom.PhoneAccountHandle)",
    "5": "android.content.pm.ParceledListSlice getCallCapablePhoneAccounts(boolean, java.lang.String, java.lang.String)",
    "6": "android.content.pm.ParceledListSlice getSelfManagedPhoneAccounts(java.lang.String, java.lang.String)",
    "7": "android.content.pm.ParceledListSlice getOwnSelfManagedPhoneAccounts(java.lang.String, java.lang.String)",
    "8": "android.content.pm.ParceledListSlice getPhoneAccountsSupportingScheme(java.lang.String, java.lang.String)",
    "9": "android.content.pm.ParceledListSlice getPhoneAccountsForPackage(java.lang.String)",
    "10": "android.telecom.PhoneAccount getPhoneAccount(android.telecom.PhoneAccountHandle, java.lang.String)",
    "11": "int getAllPhoneAccountsCount()",
    "12": "android.content.pm.ParceledListSlice getAllPhoneAccounts()",
    "13": "android.content.pm.ParceledListSlice getAllPhoneAccountHandles()",
    "14": "android.telecom.PhoneAccountHandle getSimCallManager(int, java.lang.String)",
    "15": "android.telecom.PhoneAccountHandle getSimCallManagerForUser(int, java.lang.String)",
    "16": "void registerPhoneAccount(android.telecom.PhoneAccount, java.lang.String)",
    "17": "void unregisterPhoneAccount(android.telecom.PhoneAccountHandle, java.lang.String)",
    "18": "void clearAccounts(java.lang.String)",
    "19": "boolean isVoiceMailNumber(android.telecom.PhoneAccountHandle, java.lang.String, java.lang.String, java.lang.String)",
    "20": "java.lang.String getVoiceMailNumber(android.telecom.PhoneAccountHandle, java.lang.String, java.lang.String)",
    "21": "java.lang.String getLine1Number(android.telecom.PhoneAccountHandle, java.lang.String, java.lang.String)",
    "22": "android.content.ComponentName getDefaultPhoneApp()",
    "23": "java.lang.String getDefaultDialerPackage(java.lang.String)",
    "24": "java.lang.String getDefaultDialerPackageForUser(int)",
    "25": "java.lang.String getSystemDialerPackage(java.lang.String)",
    "26": "android.telecom.TelecomAnalytics dumpCallAnalytics()",
    "27": "void silenceRinger(java.lang.String)",
    "28": "boolean isInCall(java.lang.String, java.lang.String)",
    "29": "boolean hasManageOngoingCallsPermission(java.lang.String)",
    "30": "boolean isInManagedCall(java.lang.String, java.lang.String)",
    "31": "boolean isRinging(java.lang.String)",
    "32": "int getCallState()",
    "33": "int getCallStateUsingPackage(java.lang.String, java.lang.String)",
    "34": "boolean endCall(java.lang.String)",
    "35": "void acceptRingingCall(java.lang.String)",
    "36": "void acceptRingingCallWithVideoState(java.lang.String, int)",
    "37": "void cancelMissedCallsNotification(java.lang.String)",
    "38": "boolean handlePinMmi(java.lang.String, java.lang.String)",
    "39": "boolean handlePinMmiForPhoneAccount(android.telecom.PhoneAccountHandle, java.lang.String, java.lang.String)",
    "40": "android.net.Uri getAdnUriForPhoneAccount(android.telecom.PhoneAccountHandle, java.lang.String)",
    "41": "boolean isTtySupported(java.lang.String, java.lang.String)",
    "42": "int getCurrentTtyMode(java.lang.String, java.lang.String)",
    "43": "void addNewIncomingCall(android.telecom.PhoneAccountHandle, android.os.Bundle, java.lang.String)",
    "44": "void addNewIncomingConference(android.telecom.PhoneAccountHandle, android.os.Bundle, java.lang.String)",
    "45": "void addNewUnknownCall(android.telecom.PhoneAccountHandle, android.os.Bundle)",
    "46": "void startConference(java.util.List, android.os.Bundle, java.lang.String)",
    "47": "void placeCall(android.net.Uri, android.os.Bundle, java.lang.String, java.lang.String)",
    "48": "boolean enablePhoneAccount(android.telecom.PhoneAccountHandle, boolean)",
    "49": "boolean setDefaultDialer(java.lang.String)",
    "50": "void stopBlockSuppression()",
    "51": "android.content.Intent createManageBlockedNumbersIntent(java.lang.String)",
    "52": "android.content.Intent createLaunchEmergencyDialerIntent(java.lang.String)",
    "53": "boolean isIncomingCallPermitted(android.telecom.PhoneAccountHandle, java.lang.String)",
    "54": "boolean isOutgoingCallPermitted(android.telecom.PhoneAccountHandle, java.lang.String)",
    "55": "void waitOnHandlers()",
    "56": "void acceptHandover(android.net.Uri, int, android.telecom.PhoneAccountHandle, java.lang.String)",
    "57": "void setTestEmergencyPhoneAccountPackageNameFilter(java.lang.String)",
    "58": "boolean isInEmergencyCall()",
    "59": "void handleCallIntent(android.content.Intent, java.lang.String)",
    "60": "void cleanupStuckCalls()",
    "61": "int cleanupOrphanPhoneAccounts()",
    "62": "void resetCarMode()",
    "63": "void setTestDefaultCallRedirectionApp(java.lang.String)",
    "64": "void requestLogMark(java.lang.String)",
    "65": "void setTestPhoneAcctSuggestionComponent(java.lang.String)",
    "66": "void setTestDefaultCallScreeningApp(java.lang.String)",
    "67": "void addOrRemoveTestCallCompanionApp(java.lang.String, boolean)",
    "68": "void setSystemDialer(android.content.ComponentName)",
    "69": "void setTestDefaultDialer(java.lang.String)",
    "70": "void setTestCallDiagnosticService(java.lang.String)",
    "71": "boolean isInSelfManagedCall(java.lang.String, android.os.UserHandle, java.lang.String)",
    "72": "void addCall(android.telecom.CallAttributes, com.android.internal.telecom.ICallEventCallback, java.lang.String, java.lang.String)"
  },
  "android.telephony.ims.aidl.IImsRcsController": {
    "1": "void registerImsRegistrationCallback(int, android.telephony.ims.aidl.IImsRegistrationCallback)",
    "2": "void unregisterImsRegistrationCallback(int, android.telephony.ims.aidl.IImsRegistrationCallback)",
    "3": "void getImsRcsRegistrationState(int, com.android.internal.telephony.IIntegerConsumer)",
    "4": "void getImsRcsRegistrationTransportType(int, com.android.internal.telephony.IIntegerConsumer)",
    "5": "void registerRcsAvailabilityCallback(int, android.telephony.ims.aidl.IImsCapabilityCallback)",
    "6": "void unregisterRcsAvailabilityCallback(int, android.telephony.ims.aidl.IImsCapabilityCallback)",
    "7": "boolean isCapable(int, int, int)",
    "8": "boolean isAvailable(int, int, int)",
    "9": "void requestCapabilities(int, java.lang.String, java.lang.String, java.util.List, android.telephony.ims.aidl.IRcsUceControllerCallback)",
    "10": "void requestAvailability(int, java.lang.String, java.lang.String, android.net.Uri, android.telephony.ims.aidl.IRcsUceControllerCallback)",
    "11": "int getUcePublishState(int)",
    "12": "boolean isUceSettingEnabled(int, java.lang.String, java.lang.String)",
    "13": "void setUceSettingEnabled(int, boolean)",
    "14": "void registerUcePublishStateCallback(int, android.telephony.ims.aidl.IRcsUcePublishStateCallback)",
    "15": "void unregisterUcePublishStateCallback(int, android.telephony.ims.aidl.IRcsUcePublishStateCallback)",
    "16": "boolean isSipDelegateSupported(int)",
    "17": "void createSipDelegate(int, android.telephony.ims.DelegateRequest, java.lang.String, android.telephony.ims.aidl.ISipDelegateConnectionStateCallback, android.telephony.ims.aidl.ISipDelegateMessageCallback)",
    "18": "void destroySipDelegate(int, android.telephony.ims.aidl.ISipDelegate, int)",
    "19": "void triggerNetworkRegistration(int, android.telephony.ims.aidl.ISipDelegate, int, java.lang.String)",
    "20": "void registerSipDialogStateCallback(int, com.android.internal.telephony.ISipDialogStateCallback)",
    "21": "void unregisterSipDialogStateCallback(int, com.android.internal.telephony.ISipDialogStateCallback)",
    "22": "void registerRcsFeatureCallback(int, com.android.ims.internal.IImsServiceFeatureCallback)",
    "23": "void unregisterImsFeatureCallback(com.android.ims.internal.IImsServiceFeatureCallback)"
  },
  "com.android.internal.textservice.ITextServicesManager": {
    "1": "android.view.textservice.SpellCheckerInfo getCurrentSpellChecker(int, java.lang.String)",
    "2": "android.view.textservice.SpellCheckerSubtype getCurrentSpellCheckerSubtype(int, boolean)",
    "3": "void getSpellCheckerService(int, java.lang.String, java.lang.String, com.android.internal.textservice.ITextServicesSessionListener, com.android.internal.textservice.ISpellCheckerSessionListener, android.os.Bundle, int)",
    "4": "void finishSpellCheckerService(int, com.android.internal.textservice.ISpellCheckerSessionListener)",
    "5": "boolean isSpellCheckerEnabled(int)",
    "6": "[Landroid.view.textservice.SpellCheckerInfo; getEnabledSpellCheckers(int)"
  },
  "android.system.suspend.internal.ISuspendControlServiceInternal": {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "5": "5"
  },
  "android.os.IVibratorManagerService": {
    "1": "[I getVibratorIds()",
    "2": "android.os.VibratorInfo getVibratorInfo(int)",
    "3": "boolean isVibrating(int)",
    "4": "boolean registerVibratorStateListener(int, android.os.IVibratorStateListener)",
    "5": "boolean unregisterVibratorStateListener(int, android.os.IVibratorStateListener)",
    "6": "boolean setAlwaysOnEffect(int, java.lang.String, int, android.os.CombinedVibration, android.os.VibrationAttributes)",
    "7": "void vibrate(int, int, java.lang.String, android.os.CombinedVibration, android.os.VibrationAttributes, java.lang.String, android.os.IBinder)",
    "8": "void cancelVibrate(int, android.os.IBinder)"
  },
  "android.media.session.ISessionManager": {
    "1": "android.media.session.ISession createSession(java.lang.String, android.media.session.ISessionCallback, java.lang.String, android.os.Bundle, int)",
    "2": "java.util.List getSessions(android.content.ComponentName, int)",
    "3": "android.media.session.MediaSession$Token getMediaKeyEventSession(java.lang.String)",
    "4": "java.lang.String getMediaKeyEventSessionPackageName(java.lang.String)",
    "5": "void dispatchMediaKeyEvent(java.lang.String, boolean, android.view.KeyEvent, boolean)",
    "6": "boolean dispatchMediaKeyEventToSessionAsSystemService(java.lang.String, android.view.KeyEvent, android.media.session.MediaSession$Token)",
    "7": "void dispatchVolumeKeyEvent(java.lang.String, java.lang.String, boolean, android.view.KeyEvent, int, boolean)",
    "8": "void dispatchVolumeKeyEventToSessionAsSystemService(java.lang.String, java.lang.String, android.view.KeyEvent, android.media.session.MediaSession$Token)",
    "9": "void dispatchAdjustVolume(java.lang.String, java.lang.String, int, int, int)",
    "10": "void addSessionsListener(android.media.session.IActiveSessionsListener, android.content.ComponentName, int)",
    "11": "void removeSessionsListener(android.media.session.IActiveSessionsListener)",
    "12": "void addSession2TokensListener(android.media.session.ISession2TokensListener, int)",
    "13": "void removeSession2TokensListener(android.media.session.ISession2TokensListener)",
    "14": "void registerRemoteSessionCallback(android.media.IRemoteSessionCallback)",
    "15": "void unregisterRemoteSessionCallback(android.media.IRemoteSessionCallback)",
    "16": "boolean isGlobalPriorityActive()",
    "17": "void addOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)",
    "18": "void removeOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)",
    "19": "void addOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener, java.lang.String)",
    "20": "void removeOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener)",
    "21": "void setOnVolumeKeyLongPressListener(android.media.session.IOnVolumeKeyLongPressListener)",
    "22": "void setOnMediaKeyListener(android.media.session.IOnMediaKeyListener)",
    "23": "boolean isTrusted(java.lang.String, int, int)",
    "24": "void setCustomMediaKeyDispatcher(java.lang.String)",
    "25": "void setCustomMediaSessionPolicyProvider(java.lang.String)",
    "26": "boolean hasCustomMediaKeyDispatcher(java.lang.String)",
    "27": "boolean hasCustomMediaSessionPolicyProvider(java.lang.String)",
    "28": "int getSessionPolicies(android.media.session.MediaSession$Token)",
    "29": "void setSessionPolicies(android.media.session.MediaSession$Token, int)"
  },
  "android.app.role.IRoleManager": {
    "1": "boolean isRoleAvailable(java.lang.String)",
    "2": "boolean isRoleHeld(java.lang.String, java.lang.String)",
    "3": "java.util.List getRoleHoldersAsUser(java.lang.String, int)",
    "4": "void addRoleHolderAsUser(java.lang.String, java.lang.String, int, int, android.os.RemoteCallback)",
    "5": "void removeRoleHolderAsUser(java.lang.String, java.lang.String, int, int, android.os.RemoteCallback)",
    "6": "void clearRoleHoldersAsUser(java.lang.String, int, int, android.os.RemoteCallback)",
    "7": "java.lang.String getDefaultApplicationAsUser(java.lang.String, int)",
    "8": "void setDefaultApplicationAsUser(java.lang.String, java.lang.String, int, int, android.os.RemoteCallback)",
    "9": "void addOnRoleHoldersChangedListenerAsUser(android.app.role.IOnRoleHoldersChangedListener, int)",
    "10": "void removeOnRoleHoldersChangedListenerAsUser(android.app.role.IOnRoleHoldersChangedListener, int)",
    "11": "boolean isBypassingRoleQualification()",
    "12": "void setBypassingRoleQualification(boolean)",
    "13": "void setRoleNamesFromController(java.util.List)",
    "14": "boolean addRoleHolderFromController(java.lang.String, java.lang.String)",
    "15": "boolean removeRoleHolderFromController(java.lang.String, java.lang.String)",
    "16": "java.util.List getHeldRolesFromController(java.lang.String)",
    "17": "java.lang.String getBrowserRoleHolder(int)",
    "18": "boolean setBrowserRoleHolder(java.lang.String, int)",
    "19": "java.lang.String getSmsRoleHolder(int)"
  },
  "android.content.pm.verify.domain.IDomainVerificationManager": {
    "1": "java.util.List queryValidVerificationPackageNames()",
    "2": "android.content.pm.verify.domain.DomainVerificationInfo getDomainVerificationInfo(java.lang.String)",
    "3": "android.content.pm.verify.domain.DomainVerificationUserState getDomainVerificationUserState(java.lang.String, int)",
    "4": "java.util.List getOwnersForDomain(java.lang.String, int)",
    "5": "int setDomainVerificationStatus(java.lang.String, android.content.pm.verify.domain.DomainSet, int)",
    "6": "void setDomainVerificationLinkHandlingAllowed(java.lang.String, boolean, int)",
    "7": "int setDomainVerificationUserSelection(java.lang.String, android.content.pm.verify.domain.DomainSet, boolean, int)"
  },
  "com.android.internal.os.IBinaryTransparencyService": {
    "1": "java.lang.String getSignedImageInfo()",
    "2": "void recordMeasurementsForAllPackages()",
    "3": "java.util.List collectAllApexInfo(boolean)",
    "4": "java.util.List collectAllUpdatedPreloadInfo(android.os.Bundle)",
    "5": "java.util.List collectAllSilentInstalledMbaInfo(android.os.Bundle)"
  },
  "android.net.wifi.p2p.IWifiP2pManager": {
    "1": "android.os.Messenger getMessenger(android.os.IBinder, java.lang.String, android.os.Bundle)",
    "2": "android.os.Messenger getP2pStateMachineMessenger()",
    "3": "void close(android.os.IBinder)",
    "4": "void setMiracastMode(int)",
    "5": "void checkConfigureWifiDisplayPermission()",
    "6": "long getSupportedFeatures()"
  },
  "android.os.IVold": {
    "1": "void setListener(android.os.IVoldListener)",
    "2": "void abortFuse()",
    "3": "void monitor()",
    "4": "void reset()",
    "5": "void shutdown()",
    "6": "void onUserAdded(int, int, int)",
    "7": "void onUserRemoved(int)",
    "8": "void onUserStarted(int)",
    "9": "void onUserStopped(int)",
    "10": "void addAppIds([Ljava.lang.String;, [I)",
    "11": "void addSandboxIds([I, [Ljava.lang.String;)",
    "12": "void onSecureKeyguardStateChanged(boolean)",
    "13": "void partition(java.lang.String, int, int)",
    "14": "void forgetPartition(java.lang.String, java.lang.String)",
    "15": "void mount(java.lang.String, int, int, android.os.IVoldMountCallback)",
    "16": "void unmount(java.lang.String)",
    "17": "void format(java.lang.String, java.lang.String)",
    "18": "void benchmark(java.lang.String, android.os.IVoldTaskListener)",
    "19": "void moveStorage(java.lang.String, java.lang.String, android.os.IVoldTaskListener)",
    "20": "void remountUid(int, int)",
    "21": "void remountAppStorageDirs(int, int, [Ljava.lang.String;)",
    "22": "void unmountAppStorageDirs(int, int, [Ljava.lang.String;)",
    "23": "void setupAppDir(java.lang.String, int)",
    "24": "void fixupAppDir(java.lang.String, int)",
    "25": "void ensureAppDirsCreated([Ljava.lang.String;, int)",
    "26": "java.lang.String createObb(java.lang.String, int)",
    "27": "void destroyObb(java.lang.String)",
    "28": "void fstrim(int, android.os.IVoldTaskListener)",
    "29": "void runIdleMaint(boolean, android.os.IVoldTaskListener)",
    "30": "void abortIdleMaint(android.os.IVoldTaskListener)",
    "31": "int getStorageLifeTime()",
    "32": "void setGCUrgentPace(int, int, float, float, int, int, int)",
    "33": "void refreshLatestWrite()",
    "34": "int getWriteAmount()",
    "35": "java.io.FileDescriptor mountAppFuse(int, int)",
    "36": "void unmountAppFuse(int, int)",
    "37": "void fbeEnable()",
    "38": "void initUser0()",
    "39": "void mountFstab(java.lang.String, java.lang.String, java.lang.String)",
    "40": "void encryptFstab(java.lang.String, java.lang.String, boolean, java.lang.String, java.lang.String)",
    "41": "void setStorageBindingSeed([B)",
    "42": "void createUserKey(int, int, boolean)",
    "43": "void destroyUserKey(int)",
    "44": "void setUserKeyProtection(int, java.lang.String)",
    "45": "[I getUnlockedUsers()",
    "46": "void unlockUserKey(int, int, java.lang.String)",
    "47": "void lockUserKey(int)",
    "48": "void prepareUserStorage(java.lang.String, int, int, int)",
    "49": "void destroyUserStorage(java.lang.String, int, int)",
    "50": "void prepareSandboxForApp(java.lang.String, int, java.lang.String, int)",
    "51": "void destroySandboxForApp(java.lang.String, java.lang.String, int)",
    "52": "void startCheckpoint(int)",
    "53": "boolean needsCheckpoint()",
    "54": "boolean needsRollback()",
    "55": "boolean isCheckpointing()",
    "56": "void abortChanges(java.lang.String, boolean)",
    "57": "void commitChanges()",
    "58": "void prepareCheckpoint()",
    "59": "void restoreCheckpoint(java.lang.String)",
    "60": "void restoreCheckpointPart(java.lang.String, int)",
    "61": "void markBootAttempt()",
    "62": "boolean supportsCheckpoint()",
    "63": "boolean supportsBlockCheckpoint()",
    "64": "boolean supportsFileCheckpoint()",
    "65": "void resetCheckpoint()",
    "66": "void earlyBootEnded()",
    "67": "java.lang.String createStubVolume(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, int)",
    "68": "void destroyStubVolume(java.lang.String)",
    "69": "java.io.FileDescriptor openAppFuseFile(int, int, int, int)",
    "70": "boolean incFsEnabled()",
    "71": "android.os.incremental.IncrementalFileSystemControlParcel mountIncFs(java.lang.String, java.lang.String, int, java.lang.String)",
    "72": "void unmountIncFs(java.lang.String)",
    "73": "void setIncFsMountOptions(android.os.incremental.IncrementalFileSystemControlParcel, boolean, boolean, java.lang.String)",
    "74": "void bindMount(java.lang.String, java.lang.String)",
    "75": "void destroyDsuMetadataKey(java.lang.String)"
  },
  "android.content.rollback.IRollbackManager": {
    "1": "android.content.pm.ParceledListSlice getAvailableRollbacks()",
    "2": "android.content.pm.ParceledListSlice getRecentlyCommittedRollbacks()",
    "3": "void commitRollback(int, android.content.pm.ParceledListSlice, java.lang.String, android.content.IntentSender)",
    "4": "void snapshotAndRestoreUserData(java.lang.String, [I, int, long, java.lang.String, int)",
    "5": "void reloadPersistedData()",
    "6": "void expireRollbackForPackage(java.lang.String)",
    "7": "int notifyStagedSession(int)",
    "8": "void blockRollbackManager(long)"
  },
  "com.android.internal.telephony.IOns": {
    "1": "boolean setEnable(boolean, java.lang.String)",
    "2": "boolean isEnabled(java.lang.String)",
    "3": "void setPreferredDataSubscriptionId(int, boolean, com.android.internal.telephony.ISetOpportunisticDataCallback, java.lang.String)",
    "4": "int getPreferredDataSubscriptionId(java.lang.String, java.lang.String)",
    "5": "void updateAvailableNetworks(java.util.List, com.android.internal.telephony.IUpdateAvailableNetworksCallback, java.lang.String)"
  },
  "android.net.IPacProxyManager": {
    "1": "void addListener(android.net.IPacProxyInstalledListener)",
    "2": "void removeListener(android.net.IPacProxyInstalledListener)",
    "3": "void setCurrentProxyScriptUrl(android.net.ProxyInfo)"
  },
  "com.android.internal.statusbar.IStatusBarService": {
    "1": "void expandNotificationsPanel()",
    "2": "void collapsePanels()",
    "3": "void togglePanel()",
    "4": "void disable(int, android.os.IBinder, java.lang.String)",
    "5": "void disableForUser(int, android.os.IBinder, java.lang.String, int)",
    "6": "void disable2(int, android.os.IBinder, java.lang.String)",
    "7": "void disable2ForUser(int, android.os.IBinder, java.lang.String, int)",
    "8": "[I getDisableFlags(android.os.IBinder, int)",
    "9": "void setIcon(java.lang.String, java.lang.String, int, int, java.lang.String)",
    "10": "void setIconVisibility(java.lang.String, boolean)",
    "11": "void removeIcon(java.lang.String)",
    "12": "void setImeWindowStatus(int, android.os.IBinder, int, int, boolean)",
    "13": "void expandSettingsPanel(java.lang.String)",
    "14": "com.android.internal.statusbar.RegisterStatusBarResult registerStatusBar(com.android.internal.statusbar.IStatusBar)",
    "15": "void onPanelRevealed(boolean, int)",
    "16": "void onPanelHidden()",
    "17": "void clearNotificationEffects()",
    "18": "void onNotificationClick(java.lang.String, com.android.internal.statusbar.NotificationVisibility)",
    "19": "void onNotificationActionClick(java.lang.String, int, android.app.Notification$Action, com.android.internal.statusbar.NotificationVisibility, boolean)",
    "20": "void onNotificationError(java.lang.String, java.lang.String, int, int, int, java.lang.String, int)",
    "21": "void onClearAllNotifications(int)",
    "22": "void onNotificationClear(java.lang.String, int, java.lang.String, int, int, com.android.internal.statusbar.NotificationVisibility)",
    "23": "void onNotificationVisibilityChanged([Lcom.android.internal.statusbar.NotificationVisibility;, [Lcom.android.internal.statusbar.NotificationVisibility;)",
    "24": "void onNotificationExpansionChanged(java.lang.String, boolean, boolean, int)",
    "25": "void onNotificationDirectReplied(java.lang.String)",
    "26": "void onNotificationSmartSuggestionsAdded(java.lang.String, int, int, boolean, boolean)",
    "27": "void onNotificationSmartReplySent(java.lang.String, int, java.lang.CharSequence, int, boolean)",
    "28": "void onNotificationSettingsViewed(java.lang.String)",
    "29": "void onNotificationBubbleChanged(java.lang.String, boolean, int)",
    "30": "void onBubbleMetadataFlagChanged(java.lang.String, int)",
    "31": "void hideCurrentInputMethodForBubbles()",
    "32": "void grantInlineReplyUriPermission(java.lang.String, android.net.Uri, android.os.UserHandle, java.lang.String)",
    "33": "void clearInlineReplyUriPermissions(java.lang.String)",
    "34": "void onNotificationFeedbackReceived(java.lang.String, android.os.Bundle)",
    "35": "void onGlobalActionsShown()",
    "36": "void onGlobalActionsHidden()",
    "37": "void shutdown()",
    "38": "void reboot(boolean)",
    "39": "void restart()",
    "40": "void addTile(android.content.ComponentName)",
    "41": "void remTile(android.content.ComponentName)",
    "42": "void clickTile(android.content.ComponentName)",
    "43": "void handleSystemKey(android.view.KeyEvent)",
    "44": "int getLastSystemKey()",
    "45": "void showPinningEnterExitToast(boolean)",
    "46": "void showPinningEscapeToast()",
    "47": "void showAuthenticationDialog(android.hardware.biometrics.PromptInfo, android.hardware.biometrics.IBiometricSysuiReceiver, [I, boolean, boolean, int, long, java.lang.String, long)",
    "48": "void onBiometricAuthenticated(int)",
    "49": "void onBiometricHelp(int, java.lang.String)",
    "50": "void onBiometricError(int, int, int)",
    "51": "void hideAuthenticationDialog(long)",
    "52": "void setBiometicContextListener(android.hardware.biometrics.IBiometricContextListener)",
    "53": "void setUdfpsRefreshRateCallback(android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback)",
    "54": "void showInattentiveSleepWarning()",
    "55": "void dismissInattentiveSleepWarning(boolean)",
    "56": "void startTracing()",
    "57": "void stopTracing()",
    "58": "boolean isTracing()",
    "59": "void suppressAmbientDisplay(boolean)",
    "60": "void requestTileServiceListeningState(android.content.ComponentName, int)",
    "61": "void requestAddTile(android.content.ComponentName, java.lang.CharSequence, android.graphics.drawable.Icon, int, com.android.internal.statusbar.IAddTileResultCallback)",
    "62": "void cancelRequestAddTile(java.lang.String)",
    "63": "void setNavBarMode(int)",
    "64": "int getNavBarMode()",
    "65": "void registerSessionListener(int, com.android.internal.statusbar.ISessionListener)",
    "66": "void unregisterSessionListener(int, com.android.internal.statusbar.ISessionListener)",
    "67": "void onSessionStarted(int, com.android.internal.logging.InstanceId)",
    "68": "void onSessionEnded(int, com.android.internal.logging.InstanceId)",
    "69": "void updateMediaTapToTransferSenderDisplay(int, android.media.MediaRoute2Info, com.android.internal.statusbar.IUndoMediaTransferCallback)",
    "70": "void updateMediaTapToTransferReceiverDisplay(int, android.media.MediaRoute2Info, android.graphics.drawable.Icon, java.lang.CharSequence)",
    "71": "void registerNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)",
    "72": "void unregisterNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)",
    "73": "void showRearDisplayDialog(int)"
  }
}
```

`package_resolver.go`:

```go
package main

import (
	"bufio"
	"fmt"
	"os/exec"
	"strings"
)
type PackageMappings map[int]string
type UidMappings map[string]int

var uidPackageMap = make(PackageMappings)
var packageUidMap = make(UidMappings)

// LoadPackageMappings 加载包名和UID的映射
func LoadPackageMappings() error {
	// 执行系统命令
	cmd := exec.Command("pm", "list", "packages", "-U")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to execute command: %w", err)
	}

	// 解析命令输出
	scanner := bufio.NewScanner(strings.NewReader(string(output)))
	for scanner.Scan() {
		line := scanner.Text()

		// 样例输出：package:com.example.app uid:10086
		parts := strings.Split(line, " ")
		if len(parts) != 2 {
			continue
		}
		packagePart := strings.TrimPrefix(parts[0], "package:")
		uidPart := strings.TrimPrefix(parts[1], "uid:")
		packageName := strings.TrimSpace(packagePart)
		var uid int
		if _, err := fmt.Sscan(uidPart, &uid); err != nil {
			return fmt.Errorf("failed to parse UID: %w", err)
		}
		uidPackageMap[uid] = packageName
		packageUidMap[packageName] = uid
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading command output: %w", err)
	}

	return nil
}

// GetPackageNameByUid 根据UID获取包名
func GetPackageNameByUid(uid int) (string, error) {
	if packageName, ok := uidPackageMap[uid]; ok {
		return packageName, nil
	}
	return "", fmt.Errorf("package name not found for UID %d", uid)
}

// GetUidByPackageName 根据包名获取UID
func GetUidByPackageName(packageName string) (int, error) {
	if uid, ok := packageUidMap[packageName]; ok {
		return uid, nil
	}
	return -1, fmt.Errorf("UID not found for package name %s", packageName)
}


```

`parcel_parser.go`:

```go
package main

import (
	"bytes"
	"encoding/binary"
	"io"
	"errors"
	"fmt"
)

// ReadUTF16String 从读取器中读取 UTF-16 字符串
func ReadUTF16String(r io.Reader, length uint32) (string, error) {
	buf := make([]byte, length*2) // UTF-16 每个字符占用 2 字节
	if _, err := io.ReadFull(r, buf); err != nil {
		return "", err
	}
	runes := make([]rune, length)
	for i := uint32(0); i < length; i++ {
		runes[i] = rune(binary.LittleEndian.Uint16(buf[i*2:]))
	}
	return string(runes), nil
}

// ExtractInterfaceName 从 Parcel 数据中提取接口名
func ExtractInterfaceName(data []byte) (string, error) {
	reader := bytes.NewReader(data)

	// 判断数据长度是否足够
	if len(data) < 16 {
		return "", errors.New("insufficient data length")
	}

	// 跳过头部的12字节
	if _, err := reader.Seek(12, io.SeekStart); err != nil {
		return "", fmt.Errorf("failed to skip header bytes: %w", err)
	}

	// 读取接口名长度（4 字节）
	var interfaceNameLength uint32
	if err := binary.Read(reader, binary.LittleEndian, &interfaceNameLength); err != nil {
		return "", err
	}

	// 判断剩余数据长度是否足够
	if int(interfaceNameLength)*2 > len(data)-16 {
		return "", errors.New("insufficient data length")
	}	

	// 读取接口名
	interfaceName, err := ReadUTF16String(reader, interfaceNameLength)
	if err != nil {
		return "", err
	}

	return interfaceName, nil
}

```