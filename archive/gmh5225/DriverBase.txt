Project Path: arc_gmh5225_DriverBase_joumlt94

Source Tree:

```txt
arc_gmh5225_DriverBase_joumlt94
├── CMakeLists.txt
├── Dependencies
│   ├── FindWDK
│   │   ├── LICENSE
│   │   ├── README.md
│   │   ├── cmake
│   │   │   └── FindWdk.cmake
│   │   └── samples
│   │       ├── CMakeLists.txt
│   │       ├── KmdfCppDriver
│   │       │   ├── CMakeLists.txt
│   │       │   └── Main.cpp
│   │       ├── KmdfCppLib
│   │       │   ├── CMakeLists.txt
│   │       │   ├── KmdfCppLib.cpp
│   │       │   └── KmdfCppLib.h
│   │       ├── MinifilterCppDriver
│   │       │   ├── CMakeLists.txt
│   │       │   └── Main.cpp
│   │       ├── WdmCppDriver
│   │       │   ├── CMakeLists.txt
│   │       │   └── Main.cpp
│   │       ├── WdmCppLib
│   │       │   ├── CMakeLists.txt
│   │       │   ├── WdmCppLib.cpp
│   │       │   └── WdmCppLib.h
│   │       ├── WdmDriver
│   │       │   ├── CMakeLists.txt
│   │       │   └── Main.c
│   │       └── WdmLib
│   │           ├── CMakeLists.txt
│   │           ├── WdmLib.c
│   │           └── WdmLib.h
│   └── obfusheader.h
├── README.MD
└── driver_entry.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.27)
project(DriverBase)

set(CMAKE_CXX_STANDARD 17)

# https://github.com/SergiusTheBest/FindWDK
list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/Dependencies/FindWDK/cmake")
find_package(WDK REQUIRED)

if (NOT WDK_FOUND)
    message(FATAL_ERROR "You MUST have the Windows Driver Kit to build this CMake project! Install it at https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk#download-icon-step-3-install-wdk")
endif ()

set(SOURCE_FILES driver_entry.cpp)
include_directories(${PROJECT_NAME} "${CMAKE_SOURCE_DIR}/Dependencies")

# The base for CLion drivers.
# Uncomment to modify WDK_WINVER
# set(WDK_WINVER "0x0601") # 0x0601 is the default.
message(STATUS "The driver will be built for Winver " ${WDK_WINVER})

wdk_add_driver(${PROJECT_NAME}
        EXCLUDE_FROM_ALL
        KMDF 1.15
        WINVER ${WDK_WINVER}
        ${SOURCE_FILES})
```

`Dependencies/FindWDK/LICENSE`:

```
Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

  Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`Dependencies/FindWDK/README.md`:

```md
# ORIGINAL REPOSITORY: https://github.com/SergiusTheBest/FindWDK

# FindWDK
CMake module for building drivers with Windows Development Kit (WDK) [![Build status](https://ci.appveyor.com/api/projects/status/o7cyircahkb6nv07/branch/master?svg=true)](https://ci.appveyor.com/project/SergiusTheBest/findwdk/branch/master) [![CI](https://github.com/SergiusTheBest/FindWDK/actions/workflows/ci.yml/badge.svg)](https://github.com/SergiusTheBest/FindWDK/actions/workflows/ci.yml)

- [Introduction](#introduction)
- [Usage](#usage)
  - [Kernel driver](#kernel-driver)
  - [Kernel library](#kernel-library)
  - [Linking to WDK libraries](#linking-to-wdk-libraries)
- [Samples](#samples)
- [License](#license)
- [Version history](#version-history)

# Introduction
FindWDK makes it possible to build kernel drivers and kernel libraries with Windows Development Kit (WDK) and CMake.

Requirements:
- WDK 8.0 and higher
- Visual Studio 2015 and higher
- CMake 3.0 and higher

# Usage
Add FindWDK to the module search path and call `find_package`:

```cmake
list(APPEND CMAKE_MODULE_PATH "<path_to_FindWDK>")
find_package(WDK REQUIRED)
```

FindWDK will search for the latest installed Windows Development Kit (WDK) and expose commands for creating kernel drivers and kernel libraries. Also the following variables will be defined:
- `WDK_FOUND` -- if false, do not try to use WDK
- `WDK_ROOT` -- where WDK is installed
- `WDK_VERSION` -- the version of the selected WDK
- `WDK_WINVER` -- the WINVER used for kernel drivers and libraries (default value is `0x0601` and can be changed per target or globally)
- `WDK_NTDDI_VERSION` -- the NTDDI_VERSION used for kernel drivers and libraries, if not set, the value will be automatically calculated by WINVER

`WDKContentRoot` environment variable overrides the default WDK search path.

## Kernel driver
The following command adds a kernel driver target called `<name>` to be built from the source files listed in the command invocation:

```cmake
wdk_add_driver(<name> 
    [EXCLUDE_FROM_ALL]
    [KMDF <kmdf_version>]
    [WINVER <winver_version>]
    [NTDDI_VERSION <ntddi_version>]
    source1 [source2 ...]
    )
```

Options:
- `EXCLUDE_FROM_ALL` -- exclude from the default build target
- `KMDF <kmdf_version>` -- use KMDF and set KMDF version
- `WINVER <winver_version>` -- use specific WINVER version
- `NTDDI_VERSION <ntddi_version>` -- use specific NTDDI_VERSION

Example:

```cmake
wdk_add_driver(KmdfCppDriver 
    KMDF 1.15 
    WINVER 0x0602
    Main.cpp
    )
```

## Kernel library
The following command adds a kernel library target called `<name>` to be built from the source files listed in the command invocation:

```cmake
wdk_add_library(<name> [STATIC | SHARED]
    [EXCLUDE_FROM_ALL]
    [KMDF <kmdf_version>]
    [WINVER <winver_version>]
    [NTDDI_VERSION <ntddi_version>]
    source1 [source2 ...]
    )
```

Options:
- `EXCLUDE_FROM_ALL` -- exclude from the default build target
- `KMDF <kmdf_version>` -- use KMDF and set KMDF version
- `WINVER <winver_version>` -- use specific WINVER version
- `NTDDI_VERSION <ntddi_version>` -- use specific NTDDI_VERSION
- `STATIC or SHARED` -- specify the type of library to be created

Example:

```cmake
wdk_add_library(KmdfCppLib STATIC 
    KMDF 1.15
    WINVER 0x0602
    KmdfCppLib.h 
    KmdfCppLib.cpp
    )
```

## Linking to WDK libraries
FindWDK creates imported targets for all WDK libraries. The naming pattern is `WDK::<UPPERCASED_LIBNAME>`. Linking a minifilter driver to `FltMgr.lib` is shown below:

```cmake
target_link_libraries(MinifilterCppDriver WDK::FLTMGR)
```

# Samples
Take a look at the [samples](samples) folder to see how WMD and KMDF drivers and libraries are built.

# License
FindWDK is licensed under the OSI-approved 3-clause BSD license. You can freely use it in your commercial or opensource software.

# Version history

## Version 1.0.2 (TBD)

## Version 1.0.1 (13 Mar 2018)
- New: Add ability to link to WDK libraries
- New: Add MinifilterCppDriver sample
- Fix: W4 warnings in C version of the driver, add missing /W4 /WX for C compiler

## Version 1.0.0 (03 Feb 2018)
- Initial public release

```

`Dependencies/FindWDK/cmake/FindWdk.cmake`:

```cmake
# Redistribution and use is allowed under the OSI-approved 3-clause BSD license.
# Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

#.rst:
# FindWDK
# ----------
#
# This module searches for the installed Windows Development Kit (WDK) and
# exposes commands for creating kernel drivers and kernel libraries.
#
# Output variables:
# - `WDK_FOUND` -- if false, do not try to use WDK
# - `WDK_ROOT` -- where WDK is installed
# - `WDK_VERSION` -- the version of the selected WDK
# - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries
#        (default value is `0x0601` and can be changed per target or globally)
# - `WDK_NTDDI_VERSION` -- the NTDDI_VERSION used for kernel drivers and libraries,
#                          if not set, the value will be automatically calculated by WINVER
#        (default value is left blank and can be changed per target or globally)
#
# Example usage:
#
#   find_package(WDK REQUIRED)
#
#   wdk_add_library(KmdfCppLib STATIC KMDF 1.15
#       KmdfCppLib.h
#       KmdfCppLib.cpp
#       )
#   target_include_directories(KmdfCppLib INTERFACE .)
#
#   wdk_add_driver(KmdfCppDriver KMDF 1.15
#       Main.cpp
#       )
#   target_link_libraries(KmdfCppDriver KmdfCppLib)
#

if(DEFINED ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES
        "$ENV{WDKContentRoot}/Include/*/km/ntddk.h" # WDK 10
        "$ENV{WDKContentRoot}/Include/km/ntddk.h" # WDK 8.0, 8.1
    )
else()
    file(GLOB WDK_NTDDK_FILES
        "C:/Program Files*/Windows Kits/*/Include/*/km/ntddk.h" # WDK 10
        "C:/Program Files*/Windows Kits/*/Include/km/ntddk.h" # WDK 8.0, 8.1
    )
endif()

if(WDK_NTDDK_FILES)
    if (NOT CMAKE_VERSION VERSION_LESS 3.18.0)
        list(SORT WDK_NTDDK_FILES COMPARE NATURAL) # sort to use the latest available WDK
    endif()
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if (NOT WDK_LATEST_NTDDK_FILE)
    return()
endif()

get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
if (NOT WDK_ROOT MATCHES ".*/[0-9][0-9.]*$") # WDK 10 has a deeper nesting level
    get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY) # go up once more
    set(WDK_LIB_VERSION "${WDK_VERSION}")
    set(WDK_INC_VERSION "${WDK_VERSION}")
else() # WDK 8.0, 8.1
    set(WDK_INC_VERSION "")
    foreach(VERSION winv6.3 win8 win7)
        if (EXISTS "${WDK_ROOT}/Lib/${VERSION}/")
            set(WDK_LIB_VERSION "${VERSION}")
            break()
        endif()
    endforeach()
    set(WDK_VERSION "${WDK_LIB_VERSION}")
endif()

message(STATUS "WDK_ROOT: " ${WDK_ROOT})
message(STATUS "WDK_VERSION: " ${WDK_VERSION})

set(WDK_WINVER "0x0601" CACHE STRING "Default WINVER for WDK targets")
set(WDK_NTDDI_VERSION "" CACHE STRING "Specified NTDDI_VERSION for WDK targets if needed")

set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")

set(WDK_COMPILE_FLAGS
    "/Zp8" # set struct alignment
    "/GF"  # enable string pooling
    "/GR-" # disable RTTI
    "/Gz" # __stdcall by default
    "/kernel"  # create kernel mode binary
    "/FIwarning.h" # disable warnings in WDK headers
    "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
    )

set(WDK_COMPILE_DEFINITIONS "WINNT=1")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

if(CMAKE_SIZEOF_VOID_P EQUAL 4)
    list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL")
    set(WDK_PLATFORM "x86")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
    set(WDK_PLATFORM "x64")
else()
    message(FATAL_ERROR "Unsupported architecture")
endif()

string(CONCAT WDK_LINK_FLAGS
    "/MANIFEST:NO " #
    "/DRIVER " #
    "/OPT:REF " #
    "/INCREMENTAL:NO " #
    "/OPT:ICF " #
    "/SUBSYSTEM:NATIVE " #
    "/MERGE:_TEXT=.text;_PAGE=PAGE " #
    "/NODEFAULTLIB " # do not link default CRT
    "/SECTION:INIT,d " #
    "/VERSION:10.0 " #
    )

# Generate imported targets for WDK lib files
file(GLOB WDK_LIBRARIES "${WDK_ROOT}/Lib/${WDK_LIB_VERSION}/km/${WDK_PLATFORM}/*.lib")
foreach(LIBRARY IN LISTS WDK_LIBRARIES)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED
            ../../../driver_entry.cpp
            ../../obfusheader.h)
    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES  ${LIBRARY})
endforeach(LIBRARY)
unset(WDK_LIBRARIES)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER;NTDDI_VERSION" "" ${ARGN})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
        )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")
    if(WDK_NTDDI_VERSION)
        target_compile_definitions(${_target} PRIVATE NTDDI_VERSION=${WDK_NTDDI_VERSION})
    endif()

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt"
        )

    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::BUFFEROVERFLOWK WDK::WMILIB)

    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        target_link_libraries(${_target} WDK::MEMCMP)
    endif()

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
        target_link_libraries(${_target}
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfDriverEntry.lib"
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfLdr.lib"
            )

        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry")
        endif()
    else()
        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
        endif()
    endif()
endfunction()

function(wdk_add_library _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER;NTDDI_VERSION" "" ${ARGN})

    add_library(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG};>_WIN32_WINNT=${WDK_WINVER}"
        )
    if(WDK_NTDDI_VERSION)
        target_compile_definitions(${_target} PRIVATE NTDDI_VERSION=${WDK_NTDDI_VERSION})
    endif()

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt"
        )

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
    endif()
endfunction()

```

`Dependencies/FindWDK/samples/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)

project(FindWdk)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /WX")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W4 /WX")

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../cmake")
find_package(WDK REQUIRED)

add_subdirectory(KmdfCppDriver)
add_subdirectory(KmdfCppLib)
add_subdirectory(MinifilterCppDriver)
add_subdirectory(WdmCppDriver)
add_subdirectory(WdmCppLib)
add_subdirectory(WdmDriver)
add_subdirectory(WdmLib)
```

`Dependencies/FindWDK/samples/KmdfCppDriver/CMakeLists.txt`:

```txt
wdk_add_driver(KmdfCppDriver
    KMDF 1.15
    Main.cpp
    )
target_link_libraries(KmdfCppDriver KmdfCppLib)
```

`Dependencies/FindWDK/samples/KmdfCppDriver/Main.cpp`:

```cpp
#include <wdm.h>
#include <wdf.h>
#include "KmdfCppLib.h"

#include <stdio.h>

EVT_WDF_DRIVER_UNLOAD evtDriverUnload;
VOID evtDriverUnload(_In_ WDFDRIVER /*driver*/)
{
    char msg[17];
    _snprintf_s(msg, 17, "%s", "Driver unloaded\n");

    DbgPrint(msg);
}

extern "C" DRIVER_INITIALIZE DriverEntry;
extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING registryPath)
{
    DbgPrint("Driver loaded\n");

    WDF_DRIVER_CONFIG config;
    WDF_DRIVER_CONFIG_INIT(&config, nullptr);
    config.EvtDriverUnload = evtDriverUnload;

    NTSTATUS status = WdfDriverCreate(driverObject, registryPath, WDF_NO_OBJECT_ATTRIBUTES, &config, WDF_NO_HANDLE);
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    UNICODE_STRING answer = {};
    WdfStringGetUnicodeString(getAnswer(), &answer);
    DbgPrint("The answer is %wZ\n", answer);

    return STATUS_SUCCESS;
}
```

`Dependencies/FindWDK/samples/KmdfCppLib/CMakeLists.txt`:

```txt
wdk_add_library(KmdfCppLib STATIC 
    KMDF 1.15
    KmdfCppLib.h 
    KmdfCppLib.cpp
    )
target_include_directories(KmdfCppLib INTERFACE .)
```

`Dependencies/FindWDK/samples/KmdfCppLib/KmdfCppLib.cpp`:

```cpp
#include "KmdfCppLib.h"

#include <stdio.h>

WDFSTRING getAnswer()
{
    static wchar_t answer[3];
    _snwprintf_s(answer, 3, L"%s", L"42");

    static const UNICODE_STRING str = RTL_CONSTANT_STRING(answer);

    WDFSTRING wdfstr = nullptr;
    NTSTATUS status = WdfStringCreate(&str, WDF_NO_OBJECT_ATTRIBUTES, &wdfstr);
    if (!NT_SUCCESS(status))
    {
        return nullptr;
    }

    return wdfstr;
}
```

`Dependencies/FindWDK/samples/KmdfCppLib/KmdfCppLib.h`:

```h
#pragma once
#include <wdm.h>
#include <wdf.h>

WDFSTRING getAnswer();
```

`Dependencies/FindWDK/samples/MinifilterCppDriver/CMakeLists.txt`:

```txt
wdk_add_driver(MinifilterCppDriver
    Main.cpp
    )
target_link_libraries(MinifilterCppDriver WDK::FLTMGR)
```

`Dependencies/FindWDK/samples/MinifilterCppDriver/Main.cpp`:

```cpp
#include <fltKernel.h>

PFLT_FILTER g_filterHandle = nullptr;

NTSTATUS FLTAPI instanceSetup(
    _In_ PCFLT_RELATED_OBJECTS          /*fltObjects*/,
    _In_ FLT_INSTANCE_SETUP_FLAGS       /*flags*/,
    _In_ DEVICE_TYPE                    /*volumeDeviceType*/,
    _In_ FLT_FILESYSTEM_TYPE            /*volumeFilesystemType*/
)
{
    return STATUS_SUCCESS;
}

NTSTATUS FLTAPI queryTeardown(
    _In_ PCFLT_RELATED_OBJECTS              /*fltObjects*/,
    _In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS  /*flags*/
)
{
    return STATUS_SUCCESS;
}

FLT_PREOP_CALLBACK_STATUS FLTAPI preCreate(
    _Inout_ PFLT_CALLBACK_DATA          /*data*/,
    _In_    PCFLT_RELATED_OBJECTS       /*fltObjects*/,
    _Outptr_result_maybenull_ PVOID*    /*completionContext*/
)
{
    DbgPrint("preCreate\n");

    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

NTSTATUS FLTAPI filterUnloadCallback(_In_ FLT_FILTER_UNLOAD_FLAGS)
{
    DbgPrint("filterUnloadCallback\n");

    FltUnregisterFilter(g_filterHandle);
    return STATUS_SUCCESS;
}

extern "C" DRIVER_INITIALIZE DriverEntry;
extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING /*registryPath*/)
{
    DbgPrint("Driver loaded\n");

    const FLT_CONTEXT_REGISTRATION contextRegistration[] =
    {
        { FLT_CONTEXT_END }
    };

    const FLT_OPERATION_REGISTRATION callbacksRegistration[] =
    {
        {
            IRP_MJ_CREATE,
            0,
            &preCreate,
            nullptr
        },

        { IRP_MJ_OPERATION_END }
    };

    const FLT_REGISTRATION filterRegistration =
    {
        sizeof(FLT_REGISTRATION),           // Size
        FLT_REGISTRATION_VERSION,           // Version
        0,                                  // Flags
        contextRegistration,                // Context
        callbacksRegistration,              // Operation callbacks
        filterUnloadCallback,               // Mini filter unload 
        &instanceSetup,                     // InstanceSetup
        &queryTeardown,                     // InstanceQueryTeardown
        nullptr,                            // InstanceTeardownStart
        nullptr,                            // InstanceTeardownComplete
        nullptr,                            // GenerateFileNameCallback
        nullptr,                            // NormalizeNameComponentCallback
        nullptr,                            // NormalizeContextCleanupCallback
        nullptr,                            // TransactionNotificationCallback
        nullptr                             // NormalizeNameComponentExCallback
    };
    
    NTSTATUS status = FltRegisterFilter(driverObject, &filterRegistration, &g_filterHandle);
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    status = FltStartFiltering(g_filterHandle);
    if (!NT_SUCCESS(status))
    {
        FltUnregisterFilter(g_filterHandle);
        return status;
    }

    return STATUS_SUCCESS;
}
```

`Dependencies/FindWDK/samples/WdmCppDriver/CMakeLists.txt`:

```txt
wdk_add_driver(WdmCppDriver
    Main.cpp
    )
target_link_libraries(WdmCppDriver WdmCppLib)
```

`Dependencies/FindWDK/samples/WdmCppDriver/Main.cpp`:

```cpp
#include <wdm.h>
#include "WdmCppLib.h"

DRIVER_UNLOAD driverUnload;
VOID driverUnload(_In_ PDRIVER_OBJECT /*driverObject*/)
{
    DbgPrint("Driver unloaded\n");
}

extern "C" DRIVER_INITIALIZE DriverEntry;
extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING /*registryPath*/)
{
    DbgPrint("Driver loaded\n");
    DbgPrint("The answer is %wZ\n", getAnswer());

    driverObject->DriverUnload = driverUnload;
    return STATUS_SUCCESS;
}
```

`Dependencies/FindWDK/samples/WdmCppLib/CMakeLists.txt`:

```txt
wdk_add_library(WdmCppLib STATIC 
    WdmCppLib.h 
    WdmCppLib.cpp
    )
target_include_directories(WdmCppLib INTERFACE .)
```

`Dependencies/FindWDK/samples/WdmCppLib/WdmCppLib.cpp`:

```cpp
#include "WdmCppLib.h"

PCUNICODE_STRING getAnswer()
{
    static const UNICODE_STRING str = RTL_CONSTANT_STRING(L"42");
    return &str;
}
```

`Dependencies/FindWDK/samples/WdmCppLib/WdmCppLib.h`:

```h
#pragma once
#include <wdm.h>

PCUNICODE_STRING getAnswer();
```

`Dependencies/FindWDK/samples/WdmDriver/CMakeLists.txt`:

```txt
wdk_add_driver(WdmDriver
    Main.c
    )
target_link_libraries(WdmDriver WdmLib)
```

`Dependencies/FindWDK/samples/WdmDriver/Main.c`:

```c
#include <wdm.h>
#include "WdmLib.h"

DRIVER_UNLOAD driverUnload;
VOID driverUnload(_In_ PDRIVER_OBJECT driverObject)
{
    UNREFERENCED_PARAMETER(driverObject);

    DbgPrint("Driver unloaded\n");
}

DRIVER_INITIALIZE DriverEntry;
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING registryPath)
{
    UNREFERENCED_PARAMETER(registryPath);

    DbgPrint("Driver loaded\n");
    DbgPrint("The answer is %wZ\n", getAnswer());

    driverObject->DriverUnload = driverUnload;
    return STATUS_SUCCESS;
}
```

`Dependencies/FindWDK/samples/WdmLib/CMakeLists.txt`:

```txt
wdk_add_library(WdmLib STATIC 
    WdmLib.h 
    WdmLib.c
    )
target_include_directories(WdmLib INTERFACE .)
```

`Dependencies/FindWDK/samples/WdmLib/WdmLib.c`:

```c
#include "WdmLib.h"

PCUNICODE_STRING getAnswer()
{
    static const UNICODE_STRING str = RTL_CONSTANT_STRING(L"42");
    return &str;
}
```

`Dependencies/FindWDK/samples/WdmLib/WdmLib.h`:

```h
#pragma once
#include <wdm.h>

PCUNICODE_STRING getAnswer();
```

`Dependencies/obfusheader.h`:

```h
/* *
   *  Made by ac3ss0r @ https://github.com/ac3ss0r/obfusheader.h
   *      Licensed under Apache-2.0.
   * */

#pragma once

// Settings (Just comment out whatever you need)
#define THREAD_LOCAL
// #define CFLOW
// #define FORCE_INLINE

// Without forceinline the compiler will mostly ignore inline methods
#ifdef FORCE_INLINE
#if defined(_MSC_VER)
#define INLINE __forceinline // Visual C++
#else
#define INLINE __attribute__((always_inline)) inline // GCC/G++/CLANG
#endif
#else
#define INLINE inline // Regular inline doesn't always inline
#endif

// __TIME__ && __COUNTER__ both used as a random provider (compile-time)
// 00:XX:XX -> __TIME__[3], __TIME__[4], __TIME__[6], __TIME__[7]
#define CTimeSeed ((__COUNTER__ ^ __TIME__[3]) * (__COUNTER__ ^ __TIME__[4]) +\
                  (__COUNTER__ ^ __TIME__[6]) * (__COUNTER__ ^ __TIME__[7]))
#define RND(Min, Max) (Min + (CTimeSeed % (Max - Min + 1)))

// Normal & threadlocal modes
#define OBF_KEY_NORMAL(x, type, size, key) []() {\
    constexpr static auto data = obf::obfuscator<type, size, key>(x);\
    return data;\
}()
#define OBF_KEY_THREADLOCAL(x, type, size, key) []() -> obf::decryptor<type, size, key>& {\
    constexpr static auto data = obf::obfuscator<type, size, key>(x);\
    thread_local auto decryptor = obf::decryptor<type, size, key>(data);\
    return decryptor;\
}()
#define OBF_NORMAL(x) OBF_KEY_NORMAL(x, obf::clean_type<decltype(obf::gettype(x))>, obf::getsize(x), (char)RND(1, 255))
#define OBF_THREADLOCAL(x) OBF_KEY_THREADLOCAL(x, obf::clean_type<decltype(obf::gettype(x))>, obf::getsize(x), (char)RND(1, 255))

#ifdef THREAD_LOCAL
#define OBF(x) (meta::decay_t<decltype(x)>) OBF_THREADLOCAL(x)
#else
#define OBF(x) (meta::decay_t<decltype(x)>) OBF_NORMAL(x)
#endif

// Call hidding is different on windows and linux (symbol-based)
#if defined(__linux__) || defined(__ANDROID__)
#include <dlfcn.h>
#define OBFUSCALL(mtd, def) ((def)(dlsym(RTLD_DEFAULT, OBF(mtd))))
#elif _WIN32

#include <windows.h>

#define OBFUSCALL(lib, mtd, def) ((def)(GetProcAddress(LoadLibrary(OBF(lib)), OBF(mtd))))
#endif

// This was created so the header works without type_traits (on gcc and other compilers)
// It basically replicates type_traits, it might look scary just skip it
namespace meta {

    template<class T, T v>
    struct integral_constant {
        static constexpr T value = v;
        using value_type = T;
        using type = integral_constant; // using injected-class-name
        constexpr operator value_type() const noexcept { return value; }

        constexpr value_type operator()() const noexcept { return value; } // since c++14
    };

    typedef integral_constant<bool, false> false_type;
    typedef integral_constant<bool, true> true_type;

    // primary template
    template<class>
    struct is_function : false_type {
    };

    // specialization for regular functions
    template<class Ret, class... Args>
    struct is_function<Ret(Args...)> : true_type {
    };

    // specialization for variadic functions such as std::printf
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...)> : true_type {
    };

    // specialization for function types that have cv-qualifiers
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) volatile> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const volatile> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) volatile> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const volatile> : true_type {
    };

    // specialization for function types that have ref-qualifiers
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) volatile &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const volatile &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) volatile &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const volatile &> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) volatile &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args...) const volatile &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) volatile &&> : true_type {
    };
    template<class Ret, class... Args>
    struct is_function<Ret(Args..., ...) const volatile &&> : true_type {
    };

    template<class T>
    struct is_array : false_type {
    };
    template<class T>
    struct is_array<T[]> : true_type {
    };
    template<class T, size_t N>
    struct is_array<T[N]> : true_type {
    };

    template<class T>
    struct remove_extent {
        using type = T;
    };
    template<class T>
    struct remove_extent<T[]> {
        using type = T;
    };
    template<class T, size_t N>
    struct remove_extent<T[N]> {
        using type = T;
    };

    template<class T>
    struct remove_reference {
        typedef T type;
    };
    template<class T>
    struct remove_reference<T &> {
        typedef T type;
    };
    template<class T>
    struct remove_reference<T &&> {
        typedef T type;
    };

    template<class T>
    struct remove_cv {
        typedef T type;
    };
    template<class T>
    struct remove_cv<const T> {
        typedef T type;
    };
    template<class T>
    struct remove_cv<volatile T> {
        typedef T type;
    };
    template<class T>
    struct remove_cv<const volatile T> {
        typedef T type;
    };

    template<class T>
    struct remove_const {
        typedef T type;
    };
    template<class T>
    struct remove_const<const T> {
        typedef T type;
    };

    template<class T>
    struct remove_volatile {
        typedef T type;
    };
    template<class T>
    struct remove_volatile<volatile T> {
        typedef T type;
    };

    template<class T>
    struct remove_all_extents {
        typedef T type;
    };
    template<class T>
    struct remove_all_extents<T[]> {
        typedef typename remove_all_extents<T>::type type;
    };
    template<class T, size_t N>
    struct remove_all_extents<T[N]> {
        typedef typename remove_all_extents<T>::type type;
    };

    template<bool B, class T, class F>
    struct conditional {
        using type = T;
    };
    template<class T, class F>
    struct conditional<false, T, F> {
        using type = F;
    };

    template<class T>
    struct type_identity {
        using type = T;
    }; // or use std::type_identity (since C++20)
    template<class T>
    auto try_add_pointer(int) -> type_identity<typename remove_reference<T>::type *>;  // usual case
    template<class T>
    auto try_add_pointer(...) -> type_identity<T>;  // unusual case (cannot form std::remove_reference<T>::type*)
    template<class T>
    struct add_pointer : decltype(try_add_pointer<T>(0)) {
    };

    // Helpers from C++14
    template<class T>
    using remove_cv_t = typename remove_cv<T>::type;
    template<class T>
    using remove_const_t = typename remove_const<T>::type;
    template<class T>
    using remove_volatile_t = typename remove_volatile<T>::type;
    template<class T>
    using remove_reference_t = typename remove_reference<T>::type;
    template<class T>
    using remove_all_extents_t = typename remove_all_extents<T>::type;

    template<class T>
    struct decay {
    private:
        typedef typename remove_reference<T>::type U;
    public:
        typedef typename conditional<
                is_array<U>::value,
                typename add_pointer<typename remove_extent<U>::type>::type,
                typename conditional<
                        is_function<U>::value,
                        typename add_pointer<U>::type,
                        typename remove_cv<U>::type
                >::type
        >::type type;
    };

    template<class T>
    using decay_t = typename decay<T>::type;
}

namespace obf {

    template<class _Ty>
    using clean_type = typename meta::remove_const_t<meta::remove_reference_t<_Ty>>;

    template<typename T, T value>
    static T ensure_threadlocal() {
        thread_local T v = value;
        return v;
    }

    template<typename T, T value>
    static constexpr T ensure_constexpr() { return value; }

    template<typename T, int size>
    constexpr size_t getsize(const T(&)[size]) { return size; }

    template<typename T>
    constexpr size_t getsize(T) { return 1; }

    template<typename T, size_t size>
    constexpr static T gettype(const T(&)[size]);

    template<typename T>
    constexpr static T gettype(T);

    // Decryption with control flow to confuse IDA/GHIDRA
    template<class T, char key, size_t size>
    INLINE void xord(T *data, int *stack, int *value) {
#ifdef CFLOW
        for (int i = 0; i < size; i++) {
            goto l_1;

            l_increase:
            *stack += 1; // -Wunused-value

            l_1:
            if (*stack == *value + 1) {
                data[i] = data[i] ^ (*value + 1);
                goto l_increase;
            }
            if (*stack == *value + 2) {
                data[i] = data[i] ^ (*value + 2);
                goto l_increase;
            }
            if (*stack == *value + 0) {
                data[i] = data[i] ^ (key + i); // real
                continue;
            }
            if (*stack == *value + 4) {
                data[i] = data[i] ^ (*value + 3);
                goto l_increase;
            }
            if (*stack == *value + 5) {
                data[i] = data[i] ^ (*value + 4);
                goto l_increase;
            }
        }
#else
        for (int i = 0; i < size; i++)
            data[i] = data[i] ^ (key + i); // no cflow
#endif
    }

    template<class T, size_t size, char key>
    class obfuscator {
    public:
        INLINE constexpr obfuscator(const T *data) {
            for (int i = 0; i < size; i++)
                m_data[i] = data[i] ^ (key + i);
        }

        INLINE constexpr obfuscator(const T data) {
            m_data[0] = data ^ key;
        }

        INLINE T *decrypt() {
            if (!decrypted) {
                xord<T, key, size>(m_data, &stack, &value);
            }
            decrypted = true;
            return m_data;
        }

        INLINE operator T *() {
            return decrypt();
        }

        INLINE operator T() {
            return decrypt()[0];
        }

        int stack = 0, value = 0;
        T result = NULL;

        bool decrypted = false;
        T m_data[size]{};
    };

    template<class T, size_t size, char key>
    class decryptor {
    public:
        INLINE decryptor(const obfuscator<T, size, key> data) {
            for (int i = 0; i < size; i++)
                m_data[i] = data.m_data[i];
        }

        INLINE T *decrypt() {
            if (!decrypted) {
                xord<T, key, size>(m_data, &stack, &value);
            }
            decrypted = true;
            return m_data;
        }

        INLINE operator T *() {
            return decrypt();
        }

        INLINE operator T() {
            return decrypt()[0];
        }

        int stack = 0, value = 0;
        T result = NULL;

        bool decrypted = false;
        T m_data[size]{};
    };
}
```

`README.MD`:

```MD
# DriverBase

This is a base (or template if you will) for a Kernel Mode Driver using Microsoft's __Kernel Mode Driver Framework__, a
framework used to build Kernel drivers on Windows.

The project is prepared to work on any Windows version, if you find the correct winver and modify the winver argument
given to the `wdk_add_driver` CMake function from the amazing [`FindWDK
project`](https://github.com/SergiusTheBest/FindWDK), which made this 10x less painful.

If you don't know, or just can't be asked to research how to modify this value with a correct one, refer
to [this page on MSDN](https://learn.microsoft.com/en-us/cpp/porting/modifying-winver-and-win32-winnt).

For obvious reasons, when working on Kernel Mode, the standard library is not included.

### Dependencies:

- [FindWDK](https://github.com/SergiusTheBest/FindWDK) [Used for basic CMake]
- [obfusheader.h](https://github.com/ac3ss0r/obfusheader.h) [Used for compile-time obfuscation]
```

`driver_entry.cpp`:

```cpp
#include <ntddk.h>
#include <wdf.h>

/*
 *  Note for future Maintainers/Developers:
 *      The reason we need to declare this as an extern C is to very literally
 *      tell the compiler to for gods sakes, to use C linkage when doing its linking magic!
 *      Else we won't compile. Leaving this if anyone questions the `extern "C"` part.
 *      - Dottik
 */

extern "C" DRIVER_INITIALIZE DriverEntry;

extern "C" NTSTATUS DriverEntry(
        _In_ PDRIVER_OBJECT pdriver_object,
        _In_ PUNICODE_STRING pregistry_path
) {
    DbgPrint("Hello, World!");
    return STATUS_SUCCESS;
}

```