Project Path: arc_gmh5225_injdrv_4i4cagod

Source Tree:

```txt
arc_gmh5225_injdrv_4i4cagod
├── LICENSE.txt
├── README.md
├── img
│   ├── KiUserApcDispatcher.png
│   ├── KiUserCallForwarder.png
│   ├── injection.png
│   └── injldr.png
├── include
│   ├── ntdll.h
│   └── phnt
├── inj.sln
└── src
    ├── DetoursNT
    ├── injdll
    │   ├── injdll.vcxproj
    │   ├── injdll.vcxproj.filters
    │   ├── main.cpp
    │   ├── wow64log.cpp
    │   └── wow64log.h
    ├── injdrv
    │   ├── injdrv.inf
    │   ├── injdrv.vcxproj
    │   ├── injdrv.vcxproj.filters
    │   └── main.c
    ├── injldr
    │   ├── injldr.vcxproj
    │   ├── injldr.vcxproj.filters
    │   ├── install.c
    │   ├── install.h
    │   └── main.c
    └── injlib
        ├── injlib.c
        ├── injlib.h
        ├── injlib.vcxproj
        ├── injlib.vcxproj.filters
        └── reparse.c

```

`LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2018 Petr Benes

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# injdrv

injdrv is a proof-of-concept Windows Driver for injecting DLL into user-mode processes using APC.

### Motivation

Even though [APCs][apc] are [undocumented to decent extent][inside-apc], the technique of using them to inject a DLL
into a user-mode process is not new and has been talked through many times. Such APC can be queued from regular
user-mode process (seen in [Cuckoo][apc-cuckoo]) as well as from kernel-mode driver (seen in [Blackbone][apc-blackbone]).

Despite its popularity, finding small, easy-to-understand and actually working projects demonstrating usage of this
technique isn't very easy. This project tries to fill this gap.

### Features

- Support for **Windows 7** up to **Windows 10**
- Support for **x86**, **x64**, **ARM32** & **ARM64** architectures
- Ability to inject **Wow64** processes
    - With DLL of the same architecture as the **injected process** (e.g. **x86 DLL into x86 Wow64 process**)
    - With DLL of the same architecture as the **OS** (e.g. **x64 DLL into Wow64 process on Windows x64**)
- DLL is injected in very early process initialization stage
    - Injection is performed from the `PsSetLoadImageNotifyRoutine` callback
    - Native processes (e.g. x86 on Windows x86, x64 on Windows x64, ...) are injected on next load of DLL after `ntdll.dll`
    - Wow64 processes are injected on next load of DLL after the Wow64-DLLs are loaded
- Because of that, injected DLL must depend only on `ntdll.dll`
- Demonstrative DLL performs hooking of few `ntdll.dll` functions
    - Achieved using [DetoursNT][DetoursNT]
- Detoured functions use `ETW` to trace hooked function calls

### Compilation

Because [DetoursNT][DetoursNT] project is attached as a git submodule, which itself carries the [Detours][Detours]
git submodule, you must not forget to fetch them:

`git clone --recurse-submodules git@github.com:wbenny/injdrv.git`

After that, compile this project using Visual Studio 2017. Solution file is included. The only required dependency
is [WDK][wdk].

### Implementation

When the driver is loaded, it'll register two callbacks:
- For process create/exit notification ([`PsSetCreateProcessNotifyRoutineEx`][MSDN-CreateProcessNotify])
- For image load notification ([`PsSetLoadImageNotifyRoutine`][MSDN-LoadImageNotify])

When a new process is created, the driver allocates small structure, which will hold information relevant to the process
injection, such as:
- Which DLLs are already loaded in the process
- Addresses of important functions (such as `LdrLoadDll` in `ntdll.dll`)

Start of a new Windows process is followed by mapping `ntdll.dll` into its address space and then ongoing load of DLLs
from the process's import table. In case of **Wow64** processes on Windows x64, the following libraries are loaded
immediately after native `ntdll.dll`: `wow64.dll`, `wow64cpu.dll`, `wow64win.dll` and second (Wow64) `ntdll.dll`.
The driver is notified about load of these DLLs and marks down this information.

When these DLLs are loaded, it is safe for the driver to queue the user-mode APC to the process, which will load our
DLL into the process.

### Challenges

Although such project might seem trivial to implement, there are some obstacles you might be facing along the way.
Here I will try to summarize some of them:

#### "Thunk"-method

_This method injects DLL of the same architecture as the process. This method is available on all architectures._

Injection of DLL requires a small allocation inside of the user-mode address space. This allocation
holds path to the DLL to be injected and a small thunk (shellcode), which basically calls `LdrLoadDll` with the DLL path as
a parameter. It is obvious that this memory requires `PAGE_EXECUTE_READ` protection, but the driver has to fill this
memory somehow - and `PAGE_EXECUTE_READWRITE` is unacceptable security concern.

It might be tempting to use `ZwAllocateVirtualMemory` and `ZwProtectVirtualMemory` but unfortunatelly, the second
function is exported only since Windows 8.1.

The solution used in this driver is to create section ([`ZwCreateSection`][MSDN-CreateSection]), map it
([`ZwMapViewOfSection`][MSDN-MapViewOfSection]) with `PAGE_READWRITE` protection, write the data, unmap it
([`ZwUnmapViewOfSection`][MSDN-UnmapViewOfSection]) and then map it again with `PAGE_EXECUTE_READ` protection.

With usage of sections another problem arises. Since this driver performs injection from the image load notification
callback - which is often called from the `NtMapViewOfSection` function - we'd be calling `MapViewOfSection`
recursively. This wouldn't be a problem, if mapping of the section wouldn't lock the `EPROCESS->AddressCreationLock`.
Because of that, we would end up in deadlock.

The solution used in this driver is to inject **kernel-mode APC** first, from which the `ZwMapViewOfSection` is called.
This kernel-mode APC is triggered right before the kernel-to-user-mode transition, so the internal `NtMapViewOfSection`
call won't be on the callstack anymore (and therefore, `AddressCreationLock` will be unlocked).

Injection of our DLL is triggered on first load of DLL which happens after all important system DLLs (mentioned above)
are already loaded.

In case of native processes, the codeflow is following:
- `process.exe` is created (process create notification)
- `process.exe` is loaded (image load notification)
- `ntdll.dll` is loaded (image load notification)
- `kernel32.dll` is loaded (image load notification + **injection happens here**)

In case of Wow64 processes, the codeflow is following:
- `process.exe` is created (process create notification)
- `process.exe` is loaded (image load notification)
- `ntdll.dll` is loaded (image load notification)
- `wow64.dll` is loaded (image load notification)
- `wow64cpu.dll` is loaded (image load notification)
- `wow64win.dll` is loaded (image load notification)
- `ntdll.dll` is loaded (image load notification - note, this is 32-bit ntdll.dll)
- `kernel32.dll` is loaded (image load notification + **injection happens here**)

<br>

> **NOTE:** Load of the `kernel32.dll` was used as an example. In fact, load of any DLL will trigger the injection.
> But in practice, `kernel32.dll` is loaded into **every Windows process**, even if:
> - it has no import table
> - it doesn't depend on `kernel32.dll`
> - it does depend only on `ntdll.dll` (covered in previous point, I just wanted to make that crystal-clear)
> - it is a console application
>
> Also note that the order of loaded DLLs mentioned above might not reflect the exact order the OS is performing.
>
> The only processes that won't be injected by this method are:
> - native processes (such as `csrss.exe`)
> - pico processes (such as applications running inside [Windows Subsystem for Linux][WSL])
> 
> Injection of these processes is not in the scope of this project.
>
> **NOTE:** On Windows 7, the Wow64 loads `kernel32.dll` and `user32.dll` (both native and Wow64) into the process.
> Unfortunatelly, this load is performed in the initialization of Wow64 (by `wow64!ProcessInit`), therefore on Windows 7
> we have to wait until these DLLs are loaded as well before injecting a Wow64 process.

The injected user-mode APC is then force-delivered by calling `KeTestAlertThread(UserMode)`. This call internally
checks if any user-mode APCs are queued and if so, sets the `Thread->ApcState.UserApcPending` variable to `TRUE`.
Because of this, the kernel immediately delivers this user-mode APC (by `KiDeliverApc`) on next transition from
kernel-mode to user-mode.

> If we happened to not force the delivery of the APC, the APC would've been delivered when the thread would be in
> the alertable state. (There are two alertable states per each thread, one for kernel-mode, one for user-mode;
> this paragraph is talking about `Thread->Alerted[UserMode] == TRUE`.) Luckily, this happens when the Windows loader
> in the `ntdll.dll` finishes its job and gives control to the application - particularly by calling `NtAlertThread`
> in the `LdrpInitialize` (or `_LdrpInitialize`) function.  So even if we happened to not force the APC, our DLL would
> still be injected before the main execution would take place.
>
> **NOTE:** This means that if we wouldn't force delivery of the APC on our own, the APC would be delivered **BEFORE**
> the `main`/`WinMain` is executed, but **AFTER** all [TLS callbacks][TLS-callbacks] are executed. This is because
> TLS callbacks are executed also in the early process initialization stage, within the `LdrpInitialize` function.
>
> This behavior is configurable in this project by the `ForceUserApc` variable (by default it's `TRUE`).
>
> **NOTE:** Some badly written drivers try to inject DLL into processes by queuing APC at wrong time. For example:
> - Queuing an APC for injecting DLL that **doesn't depend only on ntdll.dll** right when **ntdll.dll** is mapped
> - Queuing an APC for injecting DLL that **depends on kernel32.dll** right when **kernel32.dll** is mapped (but not loaded!)
>
> Such injection will actually work as long as someone won't try to forcefully deliver user-mode APCs. Because this
> driver triggers immediate deliver of user-mode APCs (**all of them**, you can't pick which should be delivered),
> it might happen that APC of other driver will be triggered. If such APC consisted, let's say, of calling
> `LoadLibraryA` from `kernel32.dll` and the `kernel32.dll` won't be fully loaded (just mapped), such APC would fail.
> And because this injection happens in early process initialization stage, this error would be considered critical
> and the process start would fail. Also because basically every process is being injected, if start of every process
> would fail, it would make the system very unusable.

The reason why our DLL is not injected immediately from the `ntdll.dll` image load callback is simple: the image
load callback is called when the DLL is mapped into the process - and at this stage, the DLL is not fully initialized.
The initialization takes place **after** this callback (in user-mode, obviously). If we would happen to inject
`LdrLoadDll` call before `ntdll.dll` is initialized, the call would fail somewhere in that function, because some
variable it relies on would not be initialized.

Injection of **Wow64** processes is handled via `PsWrapApcWow64Thread(&NormalContext, &NormalRoutine)` call. This
function essentially alters provided arguments in a way (not covered here) that `KiUserApcDispatcher` in native
`ntdll.dll` is able to recognize and handle such APCs differently. Handling of such APCs is internally resolved
by calling `Wow64ApcRoutine` (from `wow64.dll`). This function then emulates queuing of "32-bit APC" and resumes
its execution in `KiUserApcDispatcher` in the Wow64 `ntdll.dll`.

#### "Thunkless"-method

_This method injects x64 DLL into both x64 (native) and x86 (Wow64) processes. This method is available only on Windows x64._

Injection of **x64 DLL** into **Wow64** processes is tricky on its own, and **SentinelOne** wrote an excellent 3-part
blogpost series on how to achieve that:
- https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-1
- https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-2
- https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-3

In short, if you try to use the same approach as with "thunk"-method for injecting x64 DLL into Wow64 process,
you will run into problems with [Control Flow Guard][MSDN-CFG] on Windows 10.
- On x64 system, CFG maintains 2 bitmaps for Wow64 processes
  - One for "x86 address space" (used when checking execution of < 4GB memory)
  - One for "x64 address space" (used when checking execution of >= 4 GB memory)
- You cannot allocate memory in > 4GB range (even from the kernel-mode), because of [VAD][VAD] that reserves this
  memory range
  - You can theoretically unlink such VAD from `EPROCESS->VadRoot` and decrement `EPROCESS->VadCount`, but that's
    highly unrecommended
- That means, when you allocate memory inside of Wow64 process (even from the kernel-mode) or change its protection,
  the _x86 CFG bitmap_ is used.
- x64 `ntdll.dll` is mapped **above** 4GB, therefore, the `KiUserApcDispatcher` function is also located in > 4GB
  address.
- Before `KiUserApcDispatcher` calls (indirectly) the `NormalRoutine` provided to the `KeInitializeApc` function,
  it checks whether `NormalRoutine` can be executed via CFG
- Because `KiUserApcDispatcher` is called from > 4GB address, this CFG check is performed on _x64 CFG bitmap_, but
  this check will fail, because the allocated memory of ours is in < 4GB memory
  - You can theoreticaly work around this by disabling the CFG with various hacks, but that's also highly
    unrecommended
- `ZwProtectVirtualMemory` and even `ZwSetInformationVirtualMemory` won't help you, because these APIs will operate
  on _x86 CFG bitmap_ as well, if you feed them with < 4GB address

The solution outlined in the **SentinelOne** blogpost rests in calling `LdrLoadDll` of x64 `ntdll.dll` directly
from the user APC dispatcher - effectively, making `NormalRoutine` point to the address of the `LdrLoadDll`.
The issue here is that `PKNORMAL_ROUTINE` takes only 3 parameters, while `LdrLoadDll` takes 4.

```c
typedef
VOID
(NTAPI *PKNORMAL_ROUTINE) (
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  );

NTSTATUS
NTAPI
LdrLoadDll (
  _In_opt_ PWSTR SearchPath,
  _In_opt_ PULONG DllCharacteristics,
  _In_ PUNICODE_STRING DllName,
  _Out_ PVOID *BaseAddress
  );
```

  Note that 4th parameter of the `LdrLoadDll` **must** point to some valid address, where the `BaseAddress` will
  be stored. The devil is always in the details - the solution takes advance of "couple of lucky coincidences":
- `KiUserApcDispatcher` is a function expecting `RSP` to point to the `CONTEXT` structure
- From this structure, values `P1Home` ... `P4Home` are fetched:
  - `P1Home` (moved to `RCX`) represent `NormalContext`
  - `P2Home` (moved to `RDX`) represent `SystemArgument1`
  - `P3Home` (moved to `R8`) represent `SystemArgument2`
  - `P4Home` (moved to `RAX`) represent `NormalRoutine`
  - Also, `R9` is set to point to the `RSP` (the `CONTEXT` structure)
  - Note that `RCX`, `RDX`, `R8` and `R9` are used as first four function parameters in [Microsoft x64 calling convention][x64-abi]

  <p align="center">
    <img src="img/KiUserApcDispatcher.png" />
  </p>

- `KiUserApcDispatcher` calls `KiUserCallForwarder`
  - `KiUserCallForwarder` checks whether `RAX` points to valid execution target (in _x64 CFG bitmap_)
  - `KiUserCallForwarder` calls function pointed by `RAX` with parameters `RCX`, `RDX`, `R8` and `R9`
  - This is basically equivalent of calling APC's `PKNORMAL_ROUTINE`
    - `NormalRoutine(NormalContext, SystemArgument1, SystemArgument2)`
  - ...except that, because `R9` is set, it is in fact called like this:
    - `NormalRoutine(NormalContext, SystemArgument1, SystemArgument2, ContinueContext)`

  <p align="center">
    <img src="img/KiUserCallForwarder.png" />
  </p>

- Therefore, if we queue the user-mode APC like this:
  - `NormalRoutine` = address of `LdrLoadDll` in 64-bit `ntdll.dll`
  - `NormalContext` = `NULL` (translates to 1st param. of `LdrLoadDll` (`SearchPath`))
  - `SystemArgument1` = `NULL` (translates to 2nd param. of `LdrLoadDll` (`DllCharacteristics`))
  - `SystemArgument2` = pointer to `UNICODE_STRING DllName` (translates to 3rd param. of `LdrLoadDll` (`DllName`))
  - (as mentioned above, the 4th parameter (`BaseAddress`) will be provided automatically by the `KiUserApcDispatcher`)
- ...it will effectively result in the following call: `LdrLoadDll(NULL, 0, &DllName, &ContinueContext)`
- `LdrLoadDll` overwrites first 8 bytes of the `CONTEXT` structure, which happens to be its `P1Home` field
- It doesn't break anything, because this field has been already used (when fetching `NormalContext`) and is
  no longer accessed (not even by `ZwContinue`)

> **NOTE:** Not all function calls from x86 NTDLL end up in x64 NTDLL. This is because some functions are fully
> implemented on its own in both x86 and x64 NTDLL. This applies mainly on functions that does not require any
> syscall - i.e. `Rtl*` functions. For example, if you wanted to hook `RtlDecompressBuffer` in Wow64 process,
> hooking that function in x64 NTDLL wouldn't have any effect and such hooked function would be never called.
>
> **NOTE:** Because of differences in APC-dispatching mechanism, this method is not possible to use on **x86** or
> **ARM64** Windows.

#### "wow64log.dll reparse"-method

_This method injects native DLL into all processes. This method is available on all architectures._

When **Wow64** process is starting, the `wow64.dll` tries to load `wow64log.dll`. This DLL is never present in
regular Windows installation (it's probably used internally by Microsoft for debugging of the Wow64 subsystem).
Therefore, load of this DLL will normally fail. This isn't problem, though, because no critical functionality of
the Wow64 subsystem depends on it. If the load actually succeeds, it tries to find following exported functions
in the DLL:
- `Wow64LogInitialize`
- `Wow64LogMessageArgList`
- `Wow64LogSystemService`
- `Wow64LogTerminate`

If one of these functions is not exported by the DLL, the DLL is immediately unloaded.

If we drop custom `wow64log.dll` (which exports functions mentioned above) into the `%SystemRoot%\System32` directory,
it gets loaded into every **Wow64 process**.

For more details, this method is greatly described by [Walied Assar][wow64log]

The actual injection of **Wow64** processes by **injdrv** is handled via redirection of `wow64log.dll` path to the
path of our native DLL. This redirection is solved via filter driver, which registers `IRP_MJ_CREATE` pre-callback.
When this pre-callback detects that the `wow64log.dll` file is being opened, it replaces the path in the `FILE_OBJECT`
by using [`IoReplaceFileObjectName`][MSDN-IoReplaceFileObjectName] function and returning `STATUS_REPARSE` in the
`IO_STATUS_BLOCK`. The code of the filter driver is entirely based on [SimRep][SimRep] example found in Microsoft's
WDK examples.

> **NOTE:** Because native processes do not load `wow64.dll`, **injdrv** injects them using **"thunk"-method** when
> **"wow64log.dll reparse"-method** is selected.
>
> **NOTE:** Because `wow64.dll` itself is compiled for native architecture, the `wow64log.dll` must be also native.

#### Protected processes

Injection of protected processes is simply skipped, as it triggers code-integrity errors. Such processes are detected
by the `PsIsProtectedProcess` function. If you're curious about workaround of this issue (by temporarily unprotecting
these processes), you can peek into [Blackbone source code][blackbone-unprotect-process]. Keep in mind that
unprotecting protected processes requires manipulation with undocumented structures, which change dramatically
between Windows versions.

#### ETW logging

Finally, as mentioned in the beginning, the injected DLL performs logging of hooked functions with ETW.
Because functions such as `EventRegister`, `EventWriteString`, ... are located in the `advapi32.dll`, we can't
use them from our NTDLL-only dependent DLL. Luckily, ETW support is hardwired in the `ntdll.dll` too. In fact,
most of the `Event*` functions in the `advapi32.dll` are simply redirected to the `EtwEvent*` functions in `ntdll.dll`
without any change to the arguments! Therefore, we can simply mock the `Event*` functions and just include the
`<evntprov.h>` header:

```c
//
// Include support for ETW logging.
// Note that following functions are mocked, because they're
// located in advapi32.dll.  Fortunatelly, advapi32.dll simply
// redirects calls to these functions to the ntdll.dll.
//

#define EventActivityIdControl  EtwEventActivityIdControl
#define EventEnabled            EtwEventEnabled
#define EventProviderEnabled    EtwEventProviderEnabled
#define EventRegister           EtwEventRegister
#define EventSetInformation     EtwEventSetInformation
#define EventUnregister         EtwEventUnregister
#define EventWrite              EtwEventWrite
#define EventWriteEndScenario   EtwEventWriteEndScenario
#define EventWriteEx            EtwEventWriteEx
#define EventWriteStartScenario EtwEventWriteStartScenario
#define EventWriteString        EtwEventWriteString
#define EventWriteTransfer      EtwEventWriteTransfer

#include <evntprov.h>
```

...easy, wasn't it?

### Usage

> Following example is performed on **Windows 10 x64**

Enable [Test-Signing][test-signing] boot configuration option (note that you'll need administrative privileges to use
`bcdedit`) and reboot the machine:

```
bcdedit /set testsigning on
shutdown /r /t 0
```

Now open administrator command line and run following command:

`injldr -i`

The `-i` option installs the driver. After the driver is installed, it waits for newly created processes.
When a new process is created, it is hooked. Prepare some **x86** application, for example, [PuTTY][putty] and run it.
With **Process Explorer** we can check that indeed, our x64 DLL is injected in this x86 application.

<p align="center">
    <img src="img/injection.png" />
</p>

Also, immediately after `injldr` is started, it starts an ETW tracing session and prints out information
about called hooked functions:

<p align="center">
    <img src="img/injldr.png" />
</p>

You can exit `injldr` by pressing `Ctrl+C`. Now you can run `injldr` without any parameters to just start
the tracing session. If you wish to uninstall the driver, run `injldr -u`.

> This driver by default uses following injection methods:
> - `InjMethodThunk` on Windows x86
> - `InjMethodThunkless` on Windows x64
> - `InjMethodWow64LogReparse` on Windows ARM64
>
> Therefore, it always tries to inject native DLL into all processes, including Wow64 processes. If you wish to
> change this behavior and e.g. inject x86 DLL into x86 Wow64 process, set injection method to `InjMethodThunk`.
> Also, do not forget to compile `injdll` for the corresponding architectures and place it in the same directory
> as `injldr.exe`.

### License

This software is open-source under the MIT license. See the LICENSE.txt file in this repository.

Dependencies are licensed by their own licenses.

If you find this project interesting, you can buy me a coffee

```
  BTC 3GwZMNGvLCZMi7mjL8K6iyj6qGbhkVMNMF
  LTC MQn5YC7bZd4KSsaj8snSg4TetmdKDkeCYk
```

  [apc]: <https://docs.microsoft.com/en-us/windows/desktop/sync/asynchronous-procedure-calls>
  [inside-apc]: <http://www.drdobbs.com/inside-nts-asynchronous-procedure-call/184416590>
  [apc-cuckoo]: <https://github.com/cuckoosandbox/monitor/blob/7c5854fae12e1f01f56eab2db4008148c790cc7a/bin/inject.c#L375>
  [apc-blackbone]: <https://github.com/DarthTon/Blackbone/blob/master/src/BlackBoneDrv/Loader.c#L638>
  [Detours]: <https://github.com/Microsoft/Detours>
  [DetoursNT]: <https://github.com/wbenny/DetoursNT>
  [MSDN-CreateProcessNotify]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex>
  [MSDN-LoadImageNotify]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine>
  [MSDN-CreateSection]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-zwcreatesection>
  [MSDN-MapViewOfSection]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-zwmapviewofsection>
  [MSDN-UnmapViewOfSection]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-zwunmapviewofsection>
  [MSDN-CFG]: <https://docs.microsoft.com/en-us/windows/desktop/secbp/control-flow-guard>
  [VAD]: <https://resources.infosecinstitute.com/finding-enumerating-processes-within-memory-part-2/>
  [x64-abi]: <https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention>
  [blackbone-unprotect-process]: <https://github.com/DarthTon/Blackbone/blob/43bc59f68dc1e86347a76192ef3eadc0bf21af67/src/BlackBoneDrv/Inject.c#L144>
  [WSL]: <https://docs.microsoft.com/en-us/windows/wsl/faq>
  [TLS-callbacks]: <http://www.hexblog.com/?p=9>
  [test-signing]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option>
  [PuTTY]: <https://www.chiark.greenend.org.uk/~sgtatham/putty/>
  [wdk]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk>
  [MSDN-IoReplaceFileObjectName]: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-ioreplacefileobjectname>
  [SimRep]: <https://github.com/Microsoft/Windows-driver-samples/blob/master/filesys/miniFilter/simrep/simrep.c>
  [wow64log]: <http://waleedassar.blogspot.com/2013/01/wow64logdll.html>

```

`include/ntdll.h`:

```h
#ifndef _NTDLL_H
#define _NTDLL_H

//
// Remap definitions.
//

#ifdef NTDLL_NO_INLINE_INIT_STRING
#define PHNT_NO_INLINE_INIT_STRING
#endif

//
// Hack, because prototype in PH's headers and evntprov.h
// don't match.
//

#define EtwEventRegister __EtwEventRegisterIgnored

#include "phnt/phnt_windows.h"
#include "phnt/phnt.h"

#undef  EtwEventRegister

#endif

```

`inj.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27703.2000
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{01B84E09-7D4F-4415-95AD-C9291497D28C}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injdrv", "src\injdrv\injdrv.vcxproj", "{46A74761-6CFA-41AF-A536-47F08E2C7B48}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injdll", "src\injdll\injdll.vcxproj", "{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DetoursNT", "src\DetoursNT\DetoursNT\DetoursNT.vcxproj", "{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injldr", "src\injldr\injldr.vcxproj", "{A72DAEF5-C739-4E70-B57E-4310ABA03749}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injlib", "src\injlib\injlib.vcxproj", "{E2ABAE21-2862-4356-BA49-28C060878D76}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|ARM.ActiveCfg = Debug|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|ARM.Build.0 = Debug|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|ARM64.Build.0 = Debug|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x64.ActiveCfg = Debug|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x64.Build.0 = Debug|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x86.ActiveCfg = Debug|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Debug|x86.Build.0 = Debug|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|ARM.ActiveCfg = Release|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|ARM64.ActiveCfg = Release|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|ARM64.Build.0 = Release|ARM64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x64.ActiveCfg = Release|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x64.Build.0 = Release|x64
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x86.ActiveCfg = Release|Win32
		{46A74761-6CFA-41AF-A536-47F08E2C7B48}.Release|x86.Build.0 = Release|Win32
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|ARM.ActiveCfg = Debug|ARM
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|ARM.Build.0 = Debug|ARM
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|ARM64.Build.0 = Debug|ARM64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|x64.ActiveCfg = Debug|x64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|x64.Build.0 = Debug|x64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|x86.ActiveCfg = Debug|Win32
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Debug|x86.Build.0 = Debug|Win32
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|ARM.ActiveCfg = Release|ARM
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|ARM.Build.0 = Release|ARM
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|ARM64.ActiveCfg = Release|ARM64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|ARM64.Build.0 = Release|ARM64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|x64.ActiveCfg = Release|x64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|x64.Build.0 = Release|x64
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|x86.ActiveCfg = Release|Win32
		{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}.Release|x86.Build.0 = Release|Win32
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|ARM.ActiveCfg = Debug|ARM
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|ARM.Build.0 = Debug|ARM
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|ARM64.Build.0 = Debug|ARM64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|x64.ActiveCfg = Debug|x64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|x64.Build.0 = Debug|x64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|x86.ActiveCfg = Debug|Win32
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Debug|x86.Build.0 = Debug|Win32
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|ARM.ActiveCfg = Release|ARM
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|ARM.Build.0 = Release|ARM
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|ARM64.ActiveCfg = Release|ARM64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|ARM64.Build.0 = Release|ARM64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|x64.ActiveCfg = Release|x64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|x64.Build.0 = Release|x64
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|x86.ActiveCfg = Release|Win32
		{C78B9003-FC49-4BBF-8F29-52FAD48BB58A}.Release|x86.Build.0 = Release|Win32
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|ARM.ActiveCfg = Debug|ARM
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|ARM.Build.0 = Debug|ARM
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|ARM64.Build.0 = Debug|ARM64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|x64.ActiveCfg = Debug|x64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|x64.Build.0 = Debug|x64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|x86.ActiveCfg = Debug|Win32
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Debug|x86.Build.0 = Debug|Win32
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|ARM.ActiveCfg = Release|ARM
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|ARM.Build.0 = Release|ARM
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|ARM64.ActiveCfg = Release|ARM64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|ARM64.Build.0 = Release|ARM64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|x64.ActiveCfg = Release|x64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|x64.Build.0 = Release|x64
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|x86.ActiveCfg = Release|Win32
		{A72DAEF5-C739-4E70-B57E-4310ABA03749}.Release|x86.Build.0 = Release|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|ARM.ActiveCfg = Debug|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|ARM64.Build.0 = Debug|ARM64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|x64.ActiveCfg = Debug|x64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|x64.Build.0 = Debug|x64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|x86.ActiveCfg = Debug|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Debug|x86.Build.0 = Debug|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|ARM.ActiveCfg = Release|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|ARM64.ActiveCfg = Release|ARM64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|ARM64.Build.0 = Release|ARM64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|x64.ActiveCfg = Release|x64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|x64.Build.0 = Release|x64
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|x86.ActiveCfg = Release|Win32
		{E2ABAE21-2862-4356-BA49-28C060878D76}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B2F42D07-8CF5-40C5-924F-6EAB82D9ABF0}
	EndGlobalSection
EndGlobal

```

`src/injdll/injdll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- ProjectConfigurations -->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <!-- Common settings -->
  <PropertyGroup Label="Globals">
    <RootNamespace>injdll</RootNamespace>
    <ProjectGuid>{558C8AC2-041C-44AC-B41C-2DAB9277A3AB}</ProjectGuid>
    <VCProjectVersion>15.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup>
    <TargetName>$(ProjectName)$(PlatformShortName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <AdditionalIncludeDirectories>$(SolutionDir)include;$(SolutionDir)include\phnt;$(SolutionDir)src\DetoursNT\Detours\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <SupportJustMyCode>false</SupportJustMyCode>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>NtDllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <!-- Debug -->
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Release -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Release'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <FunctionLevelLinking>true</FunctionLevelLinking>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <!-- Targets -->
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <!-- Items -->
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="wow64log.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\DetoursNT\DetoursNT\DetoursNT.vcxproj">
      <Project>{c78b9003-fc49-4bbf-8f29-52fad48bb58a}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\ntdll.h" />
    <ClInclude Include="..\..\include\phnt\ntdbg.h" />
    <ClInclude Include="..\..\include\phnt\ntexapi.h" />
    <ClInclude Include="..\..\include\phnt\ntgdi.h" />
    <ClInclude Include="..\..\include\phnt\ntioapi.h" />
    <ClInclude Include="..\..\include\phnt\ntkeapi.h" />
    <ClInclude Include="..\..\include\phnt\ntldr.h" />
    <ClInclude Include="..\..\include\phnt\ntlpcapi.h" />
    <ClInclude Include="..\..\include\phnt\ntmisc.h" />
    <ClInclude Include="..\..\include\phnt\ntmmapi.h" />
    <ClInclude Include="..\..\include\phnt\ntnls.h" />
    <ClInclude Include="..\..\include\phnt\ntobapi.h" />
    <ClInclude Include="..\..\include\phnt\ntpebteb.h" />
    <ClInclude Include="..\..\include\phnt\ntpfapi.h" />
    <ClInclude Include="..\..\include\phnt\ntpnpapi.h" />
    <ClInclude Include="..\..\include\phnt\ntpoapi.h" />
    <ClInclude Include="..\..\include\phnt\ntpsapi.h" />
    <ClInclude Include="..\..\include\phnt\ntregapi.h" />
    <ClInclude Include="..\..\include\phnt\ntrtl.h" />
    <ClInclude Include="..\..\include\phnt\ntsam.h" />
    <ClInclude Include="..\..\include\phnt\ntseapi.h" />
    <ClInclude Include="..\..\include\phnt\ntsmss.h" />
    <ClInclude Include="..\..\include\phnt\nttmapi.h" />
    <ClInclude Include="..\..\include\phnt\nttp.h" />
    <ClInclude Include="..\..\include\phnt\ntwow64.h" />
    <ClInclude Include="..\..\include\phnt\ntxcapi.h" />
    <ClInclude Include="..\..\include\phnt\ntzwapi.h" />
    <ClInclude Include="..\..\include\phnt\phnt.h" />
    <ClInclude Include="..\..\include\phnt\phnt_ntdef.h" />
    <ClInclude Include="..\..\include\phnt\phnt_windows.h" />
    <ClInclude Include="..\..\include\phnt\subprocesstag.h" />
    <ClInclude Include="..\..\include\phnt\winsta.h" />
    <ClInclude Include="wow64log.h" />
  </ItemGroup>
</Project>
```

`src/injdll/injdll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\ntdll">
      <UniqueIdentifier>{40251b32-677c-4466-8e51-cd6f878b2f71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\ntdll\phnt">
      <UniqueIdentifier>{7fff6dd8-1c85-4070-bc54-273c39035c97}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wow64log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="wow64log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntdbg.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntexapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntgdi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntioapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntkeapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntldr.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntlpcapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntmisc.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntmmapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntnls.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntobapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntpebteb.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntpfapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntpnpapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntpoapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntpsapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntregapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntrtl.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntsam.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntseapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntsmss.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\nttmapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\nttp.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntwow64.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntxcapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\ntzwapi.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\phnt.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\phnt_ntdef.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\phnt_windows.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\subprocesstag.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\phnt\winsta.h">
      <Filter>Header Files\ntdll\phnt</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\ntdll.h">
      <Filter>Header Files\ntdll</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/injdll/main.cpp`:

```cpp
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1

#include "wow64log.h"

//
// Include NTDLL-related headers.
//
#define NTDLL_NO_INLINE_INIT_STRING
#include <ntdll.h>

#if defined(_M_IX86)
#  define ARCH_A          "x86"
#  define ARCH_W         L"x86"
#elif defined(_M_AMD64)
#  define ARCH_A          "x64"
#  define ARCH_W         L"x64"
#elif defined(_M_ARM)
#  define ARCH_A          "ARM32"
#  define ARCH_W         L"ARM32"
#elif defined(_M_ARM64)
#  define ARCH_A          "ARM64"
#  define ARCH_W         L"ARM64"
#else
#  error Unknown architecture
#endif


// size_t strlen(const char * str)
// {
//   const char *s;
//   for (s = str; *s; ++s) {}
//   return(s - str);
// }

//
// Include support for ETW logging.
// Note that following functions are mocked, because they're
// located in advapi32.dll.  Fortunatelly, advapi32.dll simply
// redirects calls to these functions to the ntdll.dll.
//

#define EventActivityIdControl  EtwEventActivityIdControl
#define EventEnabled            EtwEventEnabled
#define EventProviderEnabled    EtwEventProviderEnabled
#define EventRegister           EtwEventRegister
#define EventSetInformation     EtwEventSetInformation
#define EventUnregister         EtwEventUnregister
#define EventWrite              EtwEventWrite
#define EventWriteEndScenario   EtwEventWriteEndScenario
#define EventWriteEx            EtwEventWriteEx
#define EventWriteStartScenario EtwEventWriteStartScenario
#define EventWriteString        EtwEventWriteString
#define EventWriteTransfer      EtwEventWriteTransfer

#include <evntprov.h>

//
// Include Detours.
//

#include <detours.h>

//
// This is necessary for x86 builds because of SEH,
// which is used by Detours.  Look at loadcfg.c file
// in Visual Studio's CRT source codes for the original
// implementation.
//

#if defined(_M_IX86) || defined(_X86_)

EXTERN_C PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
EXTERN_C BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                             the count of table entries */
EXTERN_C
CONST
DECLSPEC_SELECTANY
IMAGE_LOAD_CONFIG_DIRECTORY
_load_config_used = {
    sizeof(_load_config_used),
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    (SIZE_T)__safe_se_handler_table,
    (SIZE_T)&__safe_se_handler_count,
};

#endif

//
// Unfortunatelly sprintf-like functions are not exposed
// by ntdll.lib, which we're linking against.  We have to
// load them dynamically.
//

using _snwprintf_fn_t = int (__cdecl*)(
  wchar_t *buffer,
  size_t count,
  const wchar_t *format,
  ...
  );

inline _snwprintf_fn_t _snwprintf = nullptr;

//
// ETW provider GUID and global provider handle.
//

//
// GUID:
//   {a4b4ba50-a667-43f5-919b-1e52a6d69bd5}
//

GUID ProviderGuid = {
  0xa4b4ba50, 0xa667, 0x43f5, { 0x91, 0x9b, 0x1e, 0x52, 0xa6, 0xd6, 0x9b, 0xd5 }
};

REGHANDLE ProviderHandle;

//
// Hooking functions and prototypes.
//

inline decltype(NtQuerySystemInformation)* OrigNtQuerySystemInformation = nullptr;

EXTERN_C
NTSTATUS
NTAPI
HookNtQuerySystemInformation(
  _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
  _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
  _In_ ULONG SystemInformationLength,
  _Out_opt_ PULONG ReturnLength
  )
{
  //
  // Log the function call.
  //

  WCHAR Buffer[128];
  _snwprintf(Buffer,
             RTL_NUMBER_OF(Buffer),
             L"NtQuerySystemInformation(%i, %p, %i)",
             SystemInformationClass,
             SystemInformation,
             SystemInformationLength);

  EtwEventWriteString(ProviderHandle, 0, 0, Buffer);

  //
  // Call original function.
  //

  return OrigNtQuerySystemInformation(SystemInformationClass,
                                      SystemInformation,
                                      SystemInformationLength,
                                      ReturnLength);
}

inline decltype(NtCreateThreadEx)* OrigNtCreateThreadEx = nullptr;

NTSTATUS
NTAPI
HookNtCreateThreadEx(
  _Out_ PHANDLE ThreadHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
  _In_ HANDLE ProcessHandle,
  _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
  _In_opt_ PVOID Argument,
  _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
  _In_ SIZE_T ZeroBits,
  _In_ SIZE_T StackSize,
  _In_ SIZE_T MaximumStackSize,
  _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
  )
{
  //
  // Log the function call.
  //

  WCHAR Buffer[128];
  _snwprintf(Buffer,
             RTL_NUMBER_OF(Buffer),
             L"NtCreateThreadEx(%p, %p)",
             ProcessHandle,
             StartRoutine);

  EtwEventWriteString(ProviderHandle, 0, 0, Buffer);

  //
  // Call original function.
  //

  return OrigNtCreateThreadEx(ThreadHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              ProcessHandle,
                              StartRoutine,
                              Argument,
                              CreateFlags,
                              ZeroBits,
                              StackSize,
                              MaximumStackSize,
                              AttributeList);
}

NTSTATUS
NTAPI
ThreadRoutine(
  _In_ PVOID ThreadParameter
  )
{
  LARGE_INTEGER Delay;
  Delay.QuadPart = -10 * 1000 * 100; // 100ms

  for (;;)
  {
    // EtwEventWriteString(ProviderHandle, 0, 0, L"NtDelayExecution(100ms)");

    NtDelayExecution(FALSE, &Delay);
  }
}

NTSTATUS
NTAPI
EnableDetours(
  VOID
  )
{
  DetourTransactionBegin();
  {
    OrigNtQuerySystemInformation = NtQuerySystemInformation;
    DetourAttach((PVOID*)&OrigNtQuerySystemInformation, HookNtQuerySystemInformation);

    OrigNtCreateThreadEx = NtCreateThreadEx;
    DetourAttach((PVOID*)&OrigNtCreateThreadEx, HookNtCreateThreadEx);
  }
  DetourTransactionCommit();

  return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
DisableDetours(
  VOID
  )
{
  DetourTransactionBegin();
  {
    DetourDetach((PVOID*)&OrigNtQuerySystemInformation, HookNtQuerySystemInformation);
    DetourDetach((PVOID*)&OrigNtCreateThreadEx, HookNtCreateThreadEx);
  }
  DetourTransactionCommit();

  return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
OnProcessAttach(
  _In_ PVOID ModuleHandle
  )
{
  //
  // First, resolve address of the _snwprintf function.
  //

  ANSI_STRING RoutineName;
  RtlInitAnsiString(&RoutineName, (PSTR)"_snwprintf");

  UNICODE_STRING NtdllPath;
  RtlInitUnicodeString(&NtdllPath, (PWSTR)L"ntdll.dll");

  HANDLE NtdllHandle;
  LdrGetDllHandle(NULL, 0, &NtdllPath, &NtdllHandle);
  LdrGetProcedureAddress(NtdllHandle, &RoutineName, 0, (PVOID*)&_snwprintf);

  //
  // Make us unloadable (by FreeLibrary calls).
  //

  LdrAddRefDll(LDR_ADDREF_DLL_PIN, ModuleHandle);

  //
  // Hide this DLL from the PEB.
  //

  PPEB Peb = NtCurrentPeb();
  PLIST_ENTRY ListEntry;

  for (ListEntry =   Peb->Ldr->InLoadOrderModuleList.Flink;
       ListEntry != &Peb->Ldr->InLoadOrderModuleList;
       ListEntry =   ListEntry->Flink)
  {
    PLDR_DATA_TABLE_ENTRY LdrEntry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

    //
    // ModuleHandle is same as DLL base address.
    //

    if (LdrEntry->DllBase == ModuleHandle)
    {
      RemoveEntryList(&LdrEntry->InLoadOrderLinks);
      RemoveEntryList(&LdrEntry->InInitializationOrderLinks);
      RemoveEntryList(&LdrEntry->InMemoryOrderLinks);
      RemoveEntryList(&LdrEntry->HashLinks);

      break;
    }
  }

  //
  // Create exports for Wow64Log* functions in
  // the PE header of this DLL.
  //

  Wow64LogCreateExports(ModuleHandle);


  //
  // Register ETW provider.
  //

  EtwEventRegister(&ProviderGuid,
                   NULL,
                   NULL,
                   &ProviderHandle);

  //
  // Create dummy thread - used for testing.
  //

  // RtlCreateUserThread(NtCurrentProcess(),
  //                     NULL,
  //                     FALSE,
  //                     0,
  //                     0,
  //                     0,
  //                     &ThreadRoutine,
  //                     NULL,
  //                     NULL,
  //                     NULL);

  //
  // Get command line of the current process and send it.
  //

  PWSTR CommandLine = Peb->ProcessParameters->CommandLine.Buffer;

  WCHAR Buffer[1024];
  _snwprintf(Buffer,
             RTL_NUMBER_OF(Buffer),
             L"Arch: %s, CommandLine: '%s'",
             ARCH_W,
             CommandLine);

  EtwEventWriteString(ProviderHandle, 0, 0, Buffer);

  //
  // Hook all functions.
  //

  return EnableDetours();
}

NTSTATUS
NTAPI
OnProcessDetach(
  _In_ HANDLE ModuleHandle
  )
{
  //
  // Unhook all functions.
  //

  return DisableDetours();
}

EXTERN_C
BOOL
NTAPI
NtDllMain(
  _In_ HANDLE ModuleHandle,
  _In_ ULONG Reason,
  _In_ LPVOID Reserved
  )
{
  switch (Reason)
  {
    case DLL_PROCESS_ATTACH:
      OnProcessAttach(ModuleHandle);
      break;

    case DLL_PROCESS_DETACH:
      OnProcessDetach(ModuleHandle);
      break;

    case DLL_THREAD_ATTACH:

      break;

    case DLL_THREAD_DETACH:

      break;
  }

  return TRUE;
}


```

`src/injdll/wow64log.cpp`:

```cpp
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1

#include "wow64log.h"

#if defined(_M_AMD64) || defined(_ARM64)

#  if defined(WOW64_LOG_FAKE_EXPORT_ENABLE)

#    define DECLSPEC_EXPORT
#    define WOW64_LOG_NUMBER_OF_FUNCTIONS  4

typedef struct _WOW64_LOG_FAKE_EXPORT_DIRECTORY
{
  IMAGE_EXPORT_DIRECTORY ExportDirectory;

  ULONG ExportTable   [WOW64_LOG_NUMBER_OF_FUNCTIONS];
  ULONG NameTable     [WOW64_LOG_NUMBER_OF_FUNCTIONS];
  SHORT OrdinalTable  [WOW64_LOG_NUMBER_OF_FUNCTIONS];
  CHAR  FunctionNames [WOW64_LOG_NUMBER_OF_FUNCTIONS][32];
} WOW64_LOG_FAKE_EXPORT_DIRECTORY, *PWOW64_LOG_FAKE_EXPORT_DIRECTORY;

WOW64_LOG_FAKE_EXPORT_DIRECTORY Wow64LogFakeExportDirectory;

#  else
#    define DECLSPEC_EXPORT                __declspec(dllexport)
#  endif

typedef ULONG (*WOW64_LOG_ARGUMENTS)[32];

typedef struct _WOW64_LOG_SERVICE
{
  PLDR_DATA_TABLE_ENTRY BtLdrEntry; // NULL on Win7
  WOW64_LOG_ARGUMENTS   Arguments;
  ULONG                 Reserved;
  ULONG                 ServiceNumber;
  NTSTATUS              Status;
  BOOLEAN               PostCall;
} WOW64_LOG_SERVICE, *PWOW64_LOG_SERVICE;

EXTERN_C
DECLSPEC_EXPORT
NTSTATUS
NTAPI
Wow64LogInitialize(
  VOID
  )
{
  return STATUS_SUCCESS;
}

EXTERN_C
DECLSPEC_EXPORT
NTSTATUS
NTAPI
Wow64LogMessageArgList(
  UCHAR Level,
  const CHAR* Format,
  va_list Args
  )
{
#if 0
#  define DPFLTR_ERROR_LEVEL    0
#  define DPFLTR_WARNING_LEVEL  1
#  define DPFLTR_TRACE_LEVEL    2
#  define DPFLTR_INFO_LEVEL     3

#  define DPFLTR_IHVDRIVER_ID   77

  vDbgPrintEx(DPFLTR_IHVDRIVER_ID,
              DPFLTR_ERROR_LEVEL,
              (PCH)Format,
              Args);
#else
  UNREFERENCED_PARAMETER(Level);
  UNREFERENCED_PARAMETER(Format);
  UNREFERENCED_PARAMETER(Args);
#endif

  return STATUS_SUCCESS;
}

EXTERN_C
DECLSPEC_EXPORT
NTSTATUS
NTAPI
Wow64LogSystemService(
  PWOW64_LOG_SERVICE ServiceParameters
  )
{
  UNREFERENCED_PARAMETER(ServiceParameters);

  return STATUS_SUCCESS;
}

EXTERN_C
DECLSPEC_EXPORT
NTSTATUS
NTAPI
Wow64LogTerminate(
  VOID
  )
{
  return STATUS_SUCCESS;
}

#else
  //
  // Force #undef of WOW64_LOG_FAKE_EXPORT_ENABLE on platforms
  // that don't support Wow64 (such as x86, ARM32).
  //
#   undef WOW64_LOG_FAKE_EXPORT_ENABLE
#endif

EXTERN_C
NTSTATUS
NTAPI
Wow64LogCreateExports(
  PVOID BaseAddress
  )
{
#if defined(WOW64_LOG_FAKE_EXPORT_ENABLE)

#  define RelVa(Address)                      (ULONG)((ULONG_PTR)Address - (ULONG_PTR)BaseAddress)

  PIMAGE_NT_HEADERS      NtHeaders            = RtlImageNtHeader(BaseAddress);
  PIMAGE_OPTIONAL_HEADER OptionalHeader       = &NtHeaders->OptionalHeader;
  PIMAGE_DATA_DIRECTORY  ExportDataDirectory  = &OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

  RTL_ASSERT(
    ExportDataDirectory->VirtualAddress == 0 &&
    ExportDataDirectory->Size == 0
  );

  NTSTATUS Status;

  PVOID  ExportDataDirectoryAddress = ExportDataDirectory;
  SIZE_T RegionSize = sizeof(IMAGE_DATA_DIRECTORY);
  ULONG  OldProtect;
  Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                  &ExportDataDirectoryAddress,
                                  &RegionSize,
                                  PAGE_READWRITE,
                                  &OldProtect);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  ExportDataDirectory->VirtualAddress = RelVa(&Wow64LogFakeExportDirectory);
  ExportDataDirectory->Size           = sizeof(Wow64LogFakeExportDirectory);

  Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                  &ExportDataDirectoryAddress,
                                  &RegionSize,
                                  OldProtect,
                                  &OldProtect);

  if (!NT_SUCCESS(Status))
  {
    //
    // Ignore...
    //
  }

  Wow64LogFakeExportDirectory.ExportDirectory.NumberOfFunctions       = WOW64_LOG_NUMBER_OF_FUNCTIONS;
  Wow64LogFakeExportDirectory.ExportDirectory.NumberOfNames           = WOW64_LOG_NUMBER_OF_FUNCTIONS;
  Wow64LogFakeExportDirectory.ExportDirectory.AddressOfFunctions      = RelVa(Wow64LogFakeExportDirectory.ExportTable);
  Wow64LogFakeExportDirectory.ExportDirectory.AddressOfNames          = RelVa(Wow64LogFakeExportDirectory.NameTable);
  Wow64LogFakeExportDirectory.ExportDirectory.AddressOfNameOrdinals   = RelVa(Wow64LogFakeExportDirectory.OrdinalTable);

  Wow64LogFakeExportDirectory.NameTable[0]                            = RelVa(Wow64LogFakeExportDirectory.FunctionNames[0]);
  Wow64LogFakeExportDirectory.NameTable[1]                            = RelVa(Wow64LogFakeExportDirectory.FunctionNames[1]);
  Wow64LogFakeExportDirectory.NameTable[2]                            = RelVa(Wow64LogFakeExportDirectory.FunctionNames[2]);
  Wow64LogFakeExportDirectory.NameTable[3]                            = RelVa(Wow64LogFakeExportDirectory.FunctionNames[3]);

  Wow64LogFakeExportDirectory.OrdinalTable[0]                         = 0;
  Wow64LogFakeExportDirectory.OrdinalTable[1]                         = 1;
  Wow64LogFakeExportDirectory.OrdinalTable[2]                         = 2;
  Wow64LogFakeExportDirectory.OrdinalTable[3]                         = 3;

  Wow64LogFakeExportDirectory.ExportTable[0]                          = RelVa(&Wow64LogInitialize);
  Wow64LogFakeExportDirectory.ExportTable[1]                          = RelVa(&Wow64LogMessageArgList);
  Wow64LogFakeExportDirectory.ExportTable[2]                          = RelVa(&Wow64LogSystemService);
  Wow64LogFakeExportDirectory.ExportTable[3]                          = RelVa(&Wow64LogTerminate);

  ANSI_STRING Wow64LogInitializeRoutineName;
  RtlInitAnsiString(&Wow64LogInitializeRoutineName, (PSTR)"Wow64LogInitialize");
  RtlCopyMemory(Wow64LogFakeExportDirectory.FunctionNames[0],
                Wow64LogInitializeRoutineName.Buffer,
                Wow64LogInitializeRoutineName.Length + 1);

  ANSI_STRING Wow64LogMessageArgListRoutineName;
  RtlInitAnsiString(&Wow64LogMessageArgListRoutineName, (PSTR)"Wow64LogMessageArgList");
  RtlCopyMemory(Wow64LogFakeExportDirectory.FunctionNames[1],
                Wow64LogMessageArgListRoutineName.Buffer,
                Wow64LogMessageArgListRoutineName.Length + 1);

  ANSI_STRING Wow64LogSystemServiceRoutineName;
  RtlInitAnsiString(&Wow64LogSystemServiceRoutineName, (PSTR)"Wow64LogSystemService");
  RtlCopyMemory(Wow64LogFakeExportDirectory.FunctionNames[2],
                Wow64LogSystemServiceRoutineName.Buffer,
                Wow64LogSystemServiceRoutineName.Length + 1);

  ANSI_STRING Wow64LogTerminateRoutineName;
  RtlInitAnsiString(&Wow64LogTerminateRoutineName, (PSTR)"Wow64LogTerminate");
  RtlCopyMemory(Wow64LogFakeExportDirectory.FunctionNames[3],
                Wow64LogTerminateRoutineName.Buffer,
                Wow64LogTerminateRoutineName.Length + 1);

#else

  UNREFERENCED_PARAMETER(BaseAddress);

#endif

  return STATUS_SUCCESS;
}

```

`src/injdll/wow64log.h`:

```h
#pragma once
#define NTDLL_NO_INLINE_INIT_STRING
#include <ntdll.h>

#ifdef __cplusplus
extern "C" {
#endif

//#define WOW64_LOG_FAKE_EXPORT_ENABLE

NTSTATUS
NTAPI
Wow64LogCreateExports(
  PVOID BaseAddress
  );

#ifdef __cplusplus
}
#endif

```

`src/injdrv/injdrv.inf`:

```inf
;
; injdrv.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=injdrv.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
injdrv_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
injdrv.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%injdrv.DeviceDesc%=injdrv_Device, Root\injdrv ; TODO: edit hw-id

[injdrv_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
injdrv.sys

;-------------- Service installation
[injdrv_Device.NT.Services]
AddService = injdrv,%SPSVCINST_ASSOCSERVICE%, injdrv_Service_Inst

; -------------- injdrv driver install sections
[injdrv_Service_Inst]
DisplayName    = %injdrv.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\injdrv.sys

;
;--- injdrv_Device Coinstaller installation ------
;

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "injdrv Installation Disk"
injdrv.DeviceDesc = "injdrv Device"
injdrv.SVCDESC = "injdrv Service"

```

`src/injdrv/injdrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- ProjectConfigurations -->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <!-- Common settings -->
  <PropertyGroup Label="Globals">
    <RootNamespace>injdrv</RootNamespace>
    <ProjectGuid>{46A74761-6CFA-41AF-A536-47F08E2C7B48}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <!--                     4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings) -->
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!-- Debug -->
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
  </ItemDefinitionGroup>
  <!-- Release -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!-- Targets -->
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <!-- Items -->
  <ItemGroup>
    <Inf Include="injdrv.inf">
      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug'">true</ExcludedFromBuild>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\injlib\injlib.vcxproj">
      <Project>{e2abae21-2862-4356-ba49-28c060878d76}</Project>
    </ProjectReference>
  </ItemGroup>
</Project>
```

`src/injdrv/injdrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="injdrv.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/injdrv/main.c`:

```c
#include "../injlib/injlib.h"

#include <ntddk.h>

//////////////////////////////////////////////////////////////////////////
// Helper functions.
//////////////////////////////////////////////////////////////////////////

//
// Taken from ReactOS, used by InjpInitializeDllPaths.
//

typedef union
{
  WCHAR Name[sizeof(ULARGE_INTEGER) / sizeof(WCHAR)];
  ULARGE_INTEGER Alignment;
} ALIGNEDNAME;

//
// DOS Device Prefix \??\
//

ALIGNEDNAME ObpDosDevicesShortNamePrefix = { { L'\\', L'?', L'?', L'\\' } };
UNICODE_STRING ObpDosDevicesShortName = {
  sizeof(ObpDosDevicesShortNamePrefix), // Length
  sizeof(ObpDosDevicesShortNamePrefix), // MaximumLength
  (PWSTR)&ObpDosDevicesShortNamePrefix  // Buffer
};

NTSTATUS
NTAPI
InjpJoinPath(
  _In_ PUNICODE_STRING Directory,
  _In_ PUNICODE_STRING Filename,
  _Inout_ PUNICODE_STRING FullPath
  )
{
  UNICODE_STRING UnicodeBackslash = RTL_CONSTANT_STRING(L"\\");

  BOOLEAN DirectoryEndsWithBackslash = Directory->Length > 0 &&
                                       Directory->Buffer[Directory->Length - 1] == L'\\';

  if (FullPath->MaximumLength < Directory->Length ||
      FullPath->MaximumLength - Directory->Length -
        (!DirectoryEndsWithBackslash ? 1 : 0) < Filename->Length)
  {
    return STATUS_DATA_ERROR;
  }

  RtlCopyUnicodeString(FullPath, Directory);

  if (!DirectoryEndsWithBackslash)
  {
    RtlAppendUnicodeStringToString(FullPath, &UnicodeBackslash);
  }

  RtlAppendUnicodeStringToString(FullPath, Filename);

  return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
InjCreateSettings(
  _In_ PUNICODE_STRING RegistryPath,
  _Inout_ PINJ_SETTINGS Settings
  )
{
  //
  // In the "ImagePath" key of the RegistryPath, there
  // is a full path of this driver file.  Fetch it.
  //

  NTSTATUS Status;

  UNICODE_STRING ValueName = RTL_CONSTANT_STRING(L"ImagePath");

  OBJECT_ATTRIBUTES ObjectAttributes;
  InitializeObjectAttributes(&ObjectAttributes,
                             RegistryPath,
                             OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                             NULL,
                             NULL);

  HANDLE KeyHandle;
  Status = ZwOpenKey(&KeyHandle,
                     KEY_READ,
                     &ObjectAttributes);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Save all information on stack - simply fail if path
  // is too long.
  //

  UCHAR KeyValueInformationBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(WCHAR) * 128];
  PKEY_VALUE_FULL_INFORMATION KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)KeyValueInformationBuffer;

  ULONG ResultLength;
  Status = ZwQueryValueKey(KeyHandle,
                           &ValueName,
                           KeyValueFullInformation,
                           KeyValueInformation,
                           sizeof(KeyValueInformationBuffer),
                           &ResultLength);

  ZwClose(KeyHandle);

  //
  // Check for succes.  Also check if the value is of expected
  // type and whether the path has a meaninful length.
  //

  if (!NT_SUCCESS(Status) ||
      KeyValueInformation->Type != REG_EXPAND_SZ ||
      KeyValueInformation->DataLength < sizeof(ObpDosDevicesShortNamePrefix))
  {
    return Status;
  }

  //
  // Save pointer to the fetched ImagePath value and test if
  // the path starts with "\??\" prefix - if so, skip it.
  //

  PWCHAR ImagePathValue = (PWCHAR)((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
  ULONG  ImagePathValueLength = KeyValueInformation->DataLength;

  if (*(PULONGLONG)(ImagePathValue) == ObpDosDevicesShortNamePrefix.Alignment.QuadPart)
  {
    ImagePathValue += ObpDosDevicesShortName.Length / sizeof(WCHAR);
    ImagePathValueLength -= ObpDosDevicesShortName.Length;
  }

  //
  // Cut the string by the last '\' character, leaving there
  // only the directory path.
  //

  PWCHAR LastBackslash = wcsrchr(ImagePathValue, L'\\');

  if (!LastBackslash)
  {
    return STATUS_DATA_ERROR;
  }

  *LastBackslash = UNICODE_NULL;

  UNICODE_STRING Directory;
  RtlInitUnicodeString(&Directory, ImagePathValue);

  //
  // Finally, fill all the buffers...
  //

#define INJ_DLL_X86_NAME    L"injdllx86.dll"
  UNICODE_STRING InjDllNameX86 = RTL_CONSTANT_STRING(INJ_DLL_X86_NAME);
  InjpJoinPath(&Directory, &InjDllNameX86, &Settings->DllPath[InjArchitectureX86]);
  InjDbgPrint("[injdrv]: DLL path (x86):   '%wZ'\n", &Settings->DllPath[InjArchitectureX86]);

#define INJ_DLL_X64_NAME    L"injdllx64.dll"
  UNICODE_STRING InjDllNameX64 = RTL_CONSTANT_STRING(INJ_DLL_X64_NAME);
  InjpJoinPath(&Directory, &InjDllNameX64, &Settings->DllPath[InjArchitectureX64]);
  InjDbgPrint("[injdrv]: DLL path (x64):   '%wZ'\n", &Settings->DllPath[InjArchitectureX64]);

#define INJ_DLL_ARM32_NAME  L"injdllARM.dll"
  UNICODE_STRING InjDllNameARM32 = RTL_CONSTANT_STRING(INJ_DLL_ARM32_NAME);
  InjpJoinPath(&Directory, &InjDllNameARM32, &Settings->DllPath[InjArchitectureARM32]);
  InjDbgPrint("[injdrv]: DLL path (ARM32): '%wZ'\n",   &Settings->DllPath[InjArchitectureARM32]);

#define INJ_DLL_ARM64_NAME  L"injdllARM64.dll"
  UNICODE_STRING InjDllNameARM64 = RTL_CONSTANT_STRING(INJ_DLL_ARM64_NAME);
  InjpJoinPath(&Directory, &InjDllNameARM64, &Settings->DllPath[InjArchitectureARM64]);
  InjDbgPrint("[injdrv]: DLL path (ARM64): '%wZ'\n",   &Settings->DllPath[InjArchitectureARM64]);

  return STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////
// DriverEntry and DriverDestroy.
//////////////////////////////////////////////////////////////////////////

VOID
NTAPI
DriverDestroy(
  _In_ PDRIVER_OBJECT DriverObject
  )
{
  UNREFERENCED_PARAMETER(DriverObject);

  PsRemoveLoadImageNotifyRoutine(&InjLoadImageNotifyRoutine);
  PsSetCreateProcessNotifyRoutineEx(&InjCreateProcessNotifyRoutineEx, TRUE);

  InjDestroy();
}

NTSTATUS
NTAPI
DriverEntry(
  _In_ PDRIVER_OBJECT DriverObject,
  _In_ PUNICODE_STRING RegistryPath
  )
{
  NTSTATUS Status;

  //
  // Register DriverUnload routine.
  //

  DriverObject->DriverUnload = &DriverDestroy;

  //
  // Create injection settings.
  //

  INJ_SETTINGS Settings;

  WCHAR BufferDllPathX86[128];
  Settings.DllPath[InjArchitectureX86].Length = 0;
  Settings.DllPath[InjArchitectureX86].MaximumLength = sizeof(BufferDllPathX86);
  Settings.DllPath[InjArchitectureX86].Buffer = BufferDllPathX86;

  WCHAR BufferDllPathX64[128];
  Settings.DllPath[InjArchitectureX64].Length = 0;
  Settings.DllPath[InjArchitectureX64].MaximumLength = sizeof(BufferDllPathX64);
  Settings.DllPath[InjArchitectureX64].Buffer = BufferDllPathX64;

  WCHAR BufferDllPathARM32[128];
  Settings.DllPath[InjArchitectureARM32].Length = 0;
  Settings.DllPath[InjArchitectureARM32].MaximumLength = sizeof(BufferDllPathARM32);
  Settings.DllPath[InjArchitectureARM32].Buffer = BufferDllPathARM32;

  WCHAR BufferDllPathARM64[128];
  Settings.DllPath[InjArchitectureARM64].Length = 0;
  Settings.DllPath[InjArchitectureARM64].MaximumLength = sizeof(BufferDllPathARM64);
  Settings.DllPath[InjArchitectureARM64].Buffer = BufferDllPathARM64;

  Status = InjCreateSettings(RegistryPath, &Settings);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

#if defined (_M_IX86)
  Settings.Method = InjMethodThunk;
#elif defined (_M_AMD64)
  Settings.Method = InjMethodThunkless;
#elif defined (_M_ARM64)
  Settings.Method = InjMethodWow64LogReparse;
#endif
  //
  // Initialize injection driver.
  //

  Status = InjInitialize(DriverObject, RegistryPath, &Settings);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Install CreateProcess and LoadImage notification routines.
  //

  Status = PsSetCreateProcessNotifyRoutineEx(&InjCreateProcessNotifyRoutineEx, FALSE);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  Status = PsSetLoadImageNotifyRoutine(&InjLoadImageNotifyRoutine);

  if (!NT_SUCCESS(Status))
  {
    PsSetCreateProcessNotifyRoutineEx(&InjCreateProcessNotifyRoutineEx, TRUE);
    return Status;
  }

  return STATUS_SUCCESS;
}

```

`src/injldr/injldr.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- ProjectConfigurations -->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <!-- Common settings -->
  <PropertyGroup Label="Globals">
    <RootNamespace>injldr</RootNamespace>
    <ProjectGuid>{A72DAEF5-C739-4E70-B57E-4310ABA03749}</ProjectGuid>
    <VCProjectVersion>15.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!-- Debug -->
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Release -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Release'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <!-- Targets -->
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <!-- Items -->
  <ItemGroup>
    <ClCompile Include="install.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="install.h" />
  </ItemGroup>
</Project>
```

`src/injldr/injldr.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="install.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="install.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/injldr/install.c`:

```c
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
#include "install.h"

#include <stdio.h>
#include <strsafe.h>

//
// Code taken from the Windows-driver-samples github repository.
// https://github.com/Microsoft/Windows-driver-samples/blob/master/general/event/exe/install.c
//

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

BOOLEAN
InstallDriver(
  _In_ SC_HANDLE  SchSCManager,
  _In_ LPCTSTR    DriverName,
  _In_ LPCTSTR    ServiceExe
  );

BOOLEAN
RemoveDriver(
  _In_ SC_HANDLE  SchSCManager,
  _In_ LPCTSTR    DriverName
  );

BOOLEAN
StartDriver(
  _In_ SC_HANDLE  SchSCManager,
  _In_ LPCTSTR    DriverName
  );

BOOLEAN
StopDriver(
  _In_ SC_HANDLE  SchSCManager,
  _In_ LPCTSTR    DriverName
  );

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

BOOLEAN
InstallDriver(
  _In_ SC_HANDLE  SchSCManager,
  _In_ LPCTSTR    DriverName,
  _In_ LPCTSTR    ServiceExe
  )
{
  SC_HANDLE   schService;
  DWORD       err;

  //
  // NOTE: This creates an entry for a standalone driver. If this
  //       is modified for use with a driver that requires a Tag,
  //       Group, and/or Dependencies, it may be necessary to
  //       query the registry for existing driver information
  //       (in order to determine a unique Tag, etc.).
  //

  //
  // Create a new a service object.
  //

  schService = CreateService(SchSCManager,           // handle of service control manager database
                             DriverName,             // address of name of service to start
                             DriverName,             // address of display name
                             SERVICE_ALL_ACCESS,     // type of access to service
                             SERVICE_KERNEL_DRIVER,  // type of service
                             SERVICE_DEMAND_START,   // when to start service
                             SERVICE_ERROR_NORMAL,   // severity if service fails to start
                             ServiceExe,             // address of name of binary file
                             NULL,                   // service does not belong to a group
                             NULL,                   // no tag requested
                             NULL,                   // no dependency names
                             NULL,                   // use LocalSystem account
                             NULL);                  // no password for service account

  if (schService == NULL)
  {
    err = GetLastError();

    if (err == ERROR_SERVICE_EXISTS)
    {
      //
      // Ignore this error.
      //
      return TRUE;
    }
    else if (err == ERROR_SERVICE_MARKED_FOR_DELETE)
    {
      //
      // Previous instance of the service is not fully deleted so sleep
      // and try again.
      //
      printf("Previous instance of the service is not fully deleted. Try again...\n");
      return FALSE;
    }
    else
    {
      printf("CreateService failed!  Error = %d \n", err);

      //
      // Indicate an error.
      //
      return  FALSE;
    }
  }

  //
  // Close the service object.
  //

  if (schService)
  {
    CloseServiceHandle(schService);
  }

  //
  // Indicate success.
  //

  return TRUE;
}

BOOLEAN
RemoveDriver(
  _In_ SC_HANDLE    SchSCManager,
  _In_ LPCTSTR      DriverName
  )
{
  SC_HANDLE   schService;
  BOOLEAN     rCode;

  //
  // Open the handle to the existing service.
  //

  schService = OpenService(SchSCManager,
                           DriverName,
                           SERVICE_ALL_ACCESS);

  if (schService == NULL)
  {
    printf("OpenService failed!  Error = %d \n", GetLastError());

    //
    // Indicate error.
    //

    return FALSE;
  }

  //
  // Mark the service for deletion from the service control manager database.
  //

  if (DeleteService(schService))
  {
    //
    // Indicate success.
    //

    rCode = TRUE;
  }
  else
  {
    printf("DeleteService failed!  Error = %d \n", GetLastError());

    //
    // Indicate failure.  Fall through to properly close the service handle.
    //

    rCode = FALSE;
  }

  //
  // Close the service object.
  //

  if (schService)
  {
    CloseServiceHandle(schService);
  }

  return rCode;
}

BOOLEAN
StartDriver(
  _In_ SC_HANDLE    SchSCManager,
  _In_ LPCTSTR      DriverName
  )
{
  SC_HANDLE   schService;
  DWORD       err;

  //
  // Open the handle to the existing service.
  //

  schService = OpenService(SchSCManager,
                           DriverName,
                           SERVICE_ALL_ACCESS);

  if (schService == NULL)
  {
    printf("OpenService failed!  Error = %d \n", GetLastError());

    //
    // Indicate failure.
    //

    return FALSE;
  }

  //
  // Start the execution of the service (i.e. start the driver).
  //

  if (!StartService(schService,     // service identifier
                    0,              // number of arguments
                    NULL))          // pointer to arguments
  {

    err = GetLastError();

    if (err == ERROR_SERVICE_ALREADY_RUNNING)
    {
      //
      // Ignore this error.
      //

      return TRUE;
    }
    else
    {
      printf("StartService failure! Error = %d \n", err);

      //
      // Indicate failure.  Fall through to properly close the service handle.
      //

      return FALSE;
    }
  }

  //
  // Close the service object.
  //

  if (schService)
  {
    CloseServiceHandle(schService);
  }

  return TRUE;
}

BOOLEAN
StopDriver(
  _In_ SC_HANDLE    SchSCManager,
  _In_ LPCTSTR      DriverName
  )
{
  BOOLEAN         rCode = TRUE;
  SC_HANDLE       schService;
  SERVICE_STATUS  serviceStatus;

  //
  // Open the handle to the existing service.
  //

  schService = OpenService(SchSCManager,
                           DriverName,
                           SERVICE_ALL_ACCESS);

  if (schService == NULL)
  {
    printf("OpenService failed!  Error = %d \n", GetLastError());

    return FALSE;
  }

  //
  // Request that the service stop.
  //

  if (ControlService(schService,
                     SERVICE_CONTROL_STOP,
                     &serviceStatus))
  {
    //
    // Indicate success.
    //

    rCode = TRUE;
  }
  else
  {
    printf("ControlService failed!  Error = %d \n", GetLastError());

    //
    // Indicate failure.  Fall through to properly close the service handle.
    //

    rCode = FALSE;
  }

  //
  // Close the service object.
  //

  if (schService)
  {
    CloseServiceHandle(schService);
  }

  return rCode;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

BOOLEAN
ManageDriver(
  _In_ LPCTSTR  DriverName,
  _In_ LPCTSTR  ServiceName,
  _In_ USHORT   Function
  )
{
  SC_HANDLE   schSCManager;

  BOOLEAN rCode = TRUE;

  //
  // Insure (somewhat) that the driver and service names are valid.
  //

  if (!DriverName || !ServiceName)
  {
    printf("Invalid Driver or Service provided to ManageDriver() \n");

    return FALSE;
  }

  //
  // Connect to the Service Control Manager and open the Services database.
  //

  schSCManager = OpenSCManager(NULL,                   // local machine
                               NULL,                   // local database
                               SC_MANAGER_ALL_ACCESS); // access required

  if (!schSCManager)
  {
    printf("Open SC Manager failed! Error = %d \n", GetLastError());

    return FALSE;
  }

  //
  // Do the requested function.
  //

  switch (Function)
  {
    case DRIVER_FUNC_INSTALL:

      //
      // Install the driver service.
      //

      if (InstallDriver(schSCManager,
                        DriverName,
                        ServiceName))
      {
        //
        // Start the driver service (i.e. start the driver).
        //

        rCode = StartDriver(schSCManager, DriverName);
      }
      else
      {
        //
        // Indicate an error.
        //

        rCode = FALSE;
      }

      break;

    case DRIVER_FUNC_REMOVE:

      //
      // Stop the driver.
      //

      StopDriver(schSCManager, DriverName);

      //
      // Remove the driver service.
      //

      RemoveDriver(schSCManager, DriverName);

      //
      // Ignore all errors.
      //

      rCode = TRUE;
      break;

    default:
      printf("Unknown ManageDriver() function. \n");

      rCode = FALSE;
      break;
  }

  //
  // Close handle to service control manager.
  //

  if (schSCManager)
  {
    CloseServiceHandle(schSCManager);
  }

  return rCode;
}

BOOLEAN
SetupDriverName(
  _Inout_updates_bytes_all_(BufferLength) PTCHAR DriverLocation,
  _In_ ULONG BufferLength
  )
{
  HANDLE fileHandle;
  DWORD driverLocLen = 0;

  //
  // Get the current directory.
  //

  driverLocLen = GetCurrentDirectory(BufferLength,
                                     DriverLocation);

  if (driverLocLen == 0)
  {
    printf("GetCurrentDirectory failed!  Error = %d \n", GetLastError());

    return FALSE;
  }

  //
  // Setup path name to driver file.
  //

  if (FAILED(StringCbCat(DriverLocation, BufferLength, TEXT("\\" DRIVER_NAME ".sys"))))
  {
    return FALSE;
  }

  //
  // Insure driver file is in the specified directory.
  //

  if ((fileHandle = CreateFile(DriverLocation,
                               GENERIC_READ,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL)) == INVALID_HANDLE_VALUE)
  {
    printf("%s.sys is not loaded.\n", DRIVER_NAME);

    //
    // Indicate failure.
    //

    return FALSE;
  }

  //
  // Close open file handle.
  //

  if (fileHandle)
  {
    CloseHandle(fileHandle);
  }

  //
  // Indicate success.
  //

  return TRUE;
}

```

`src/injldr/install.h`:

```h
#pragma once
#include <windows.h>

#define DRIVER_FUNC_INSTALL     0x01
#define DRIVER_FUNC_REMOVE      0x02

#define DRIVER_NAME             "injdrv"

BOOLEAN
ManageDriver(
  _In_ LPCTSTR  DriverName,
  _In_ LPCTSTR  ServiceName,
  _In_ USHORT   Function
  );

BOOLEAN
SetupDriverName(
  _Inout_updates_bytes_all_(BufferLength) PTCHAR DriverLocation,
  _In_ ULONG BufferLength
  );

```

`src/injldr/main.c`:

```c
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1

#include <stdio.h>
#include <windows.h>
#include <evntrace.h>
#include <evntcons.h>

#include "install.h"

//
// GUID:
//   {a4b4ba50-a667-43f5-919b-1e52a6d69bd5}
//

GUID ProviderGuid = {
  0xa4b4ba50, 0xa667, 0x43f5, { 0x91, 0x9b, 0x1e, 0x52, 0xa6, 0xd6, 0x9b, 0xd5 }
};

//
// GUID:
//   {53d82d11-cede-4dff-8eb4-f06631800128}
//

GUID SessionGuid = {
  0x53d82d11, 0xcede, 0x4dff, { 0x8e, 0xb4, 0xf0, 0x66, 0x31, 0x80, 0x1, 0x28 }
};

TCHAR SessionName[] = TEXT("InjSession");

VOID
WINAPI
TraceEventCallback(
  _In_ PEVENT_RECORD EventRecord
  )
{
  if (!EventRecord->UserData)
  {
    return;
  }

  //
  // TODO: Check that EventRecord contains only WCHAR string.
  //

  wprintf(L"[PID:%04X][TID:%04X] %s\n",
          EventRecord->EventHeader.ProcessId,
          EventRecord->EventHeader.ThreadId,
          (PWCHAR)EventRecord->UserData);
}

ULONG
NTAPI
TraceStart(
  VOID
  )
{
  //
  // Start new trace session.
  // For an awesome blogpost on ETW API, see:
  // https://caseymuratori.com/blog_0025
  //

  ULONG ErrorCode;

  TRACEHANDLE TraceSessionHandle = INVALID_PROCESSTRACE_HANDLE;

  BYTE Buffer[sizeof(EVENT_TRACE_PROPERTIES) + 4096];
  RtlZeroMemory(Buffer, sizeof(Buffer));

  PEVENT_TRACE_PROPERTIES EventTraceProperties = (PEVENT_TRACE_PROPERTIES)Buffer;
  EventTraceProperties->Wnode.BufferSize = sizeof(Buffer);
  EventTraceProperties->Wnode.ClientContext = 1; // Use QueryPerformanceCounter, see MSDN
  EventTraceProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
  EventTraceProperties->LogFileMode = PROCESS_TRACE_MODE_REAL_TIME;
  EventTraceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

  ErrorCode = StartTrace(&TraceSessionHandle, SessionName, EventTraceProperties);
  if (ErrorCode != ERROR_SUCCESS)
  {
    goto Exit;
  }

  //
  // Enable tracing of our provider.
  //

  ErrorCode = EnableTrace(TRUE, 0, 0, &ProviderGuid, TraceSessionHandle);
  if (ErrorCode != ERROR_SUCCESS)
  {
    goto Exit;
  }

  EVENT_TRACE_LOGFILE TraceLogfile = { 0 };
  TraceLogfile.LoggerName = SessionName;
  TraceLogfile.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_REAL_TIME;
  TraceLogfile.EventRecordCallback = &TraceEventCallback;

  //
  // Open real-time tracing session.
  //

  TRACEHANDLE TraceHandle = OpenTrace(&TraceLogfile);
  if (TraceHandle == INVALID_PROCESSTRACE_HANDLE)
  {
    //
    // Synthetic error code.
    //
    ErrorCode = ERROR_FUNCTION_FAILED;
    goto Exit;
  }

  //
  // Process trace events.  This call is blocking.
  //

  ErrorCode = ProcessTrace(&TraceHandle, 1, NULL, NULL);

Exit:
  if (TraceHandle)
  {
    CloseTrace(TraceHandle);
  }

  if (TraceSessionHandle)
  {
    CloseTrace(TraceSessionHandle);
  }

  RtlZeroMemory(Buffer, sizeof(Buffer));
  EventTraceProperties->Wnode.BufferSize = sizeof(Buffer);
  StopTrace(0, SessionName, EventTraceProperties);

  if (ErrorCode != ERROR_SUCCESS)
  {
    printf("Error: %08x\n", ErrorCode);
  }

  return ErrorCode;
}

VOID
NTAPI
TraceStop(
  VOID
  )
{
  BYTE Buffer[sizeof(EVENT_TRACE_PROPERTIES) + 4096];
  RtlZeroMemory(Buffer, sizeof(Buffer));

  PEVENT_TRACE_PROPERTIES EventTraceProperties = (PEVENT_TRACE_PROPERTIES)Buffer;
  EventTraceProperties->Wnode.BufferSize = sizeof(Buffer);

  StopTrace(0, SessionName, EventTraceProperties);
}

//////////////////////////////////////////////////////////////////////////

BOOLEAN
DoInstallUninstall(
  _In_ BOOLEAN Install
  )
{
  TCHAR driverLocation[MAX_PATH] = { 0 };

  //
  // The driver is not started yet so let us install the driver.
  // First setup full path to driver name.
  //

  if (!SetupDriverName(driverLocation, sizeof(driverLocation)))
  {
    return FALSE;
  }

  if (Install)
  {
    if (!ManageDriver(TEXT(DRIVER_NAME),
                      driverLocation,
                      DRIVER_FUNC_INSTALL))
    {
      printf("Unable to install driver.\n");

      //
      // Error - remove driver.
      //

      ManageDriver(TEXT(DRIVER_NAME),
                   driverLocation,
                   DRIVER_FUNC_REMOVE);

      return FALSE;
    }
  }
  else
  {
    //
    // Ignore errors.
    //

    ManageDriver(TEXT(DRIVER_NAME),
                 driverLocation,
                 DRIVER_FUNC_REMOVE);
  }

  return TRUE;
}

BOOL
WINAPI
CtrlCHandlerRoutine(
  _In_ DWORD dwCtrlType
  )
{
  if (dwCtrlType == CTRL_C_EVENT)
  {
    //
    // Ctrl+C was pressed, stop the trace session.
    //
    printf("Ctrl+C pressed, stopping trace session...\n");

    TraceStop();
  }

  return FALSE;
}

int main(int argc, char* argv[])
{
//   LoadLibrary(TEXT("injdllx64.dll"));
//
//   return 0;
//
  SetConsoleCtrlHandler(&CtrlCHandlerRoutine, TRUE);

  //
  // Stop any previous trace session (if exists).
  //

  TraceStop();

  //
  // Parse command-line parameters.
  //

  if (argc == 2)
  {
    TCHAR DriverLocation[MAX_PATH];
    SetupDriverName(DriverLocation, sizeof(DriverLocation));

    if (!strcmp(argv[1], "-i"))
    {
      printf("Installing driver...\n");

      if (DoInstallUninstall(TRUE))
      {
        printf("Driver installed!\n");
      }
      else
      {
        printf("Error!\n");
        return EXIT_FAILURE;
      }
    }
    else if (!strcmp(argv[1], "-u"))
    {
      printf("Uninstalling driver...\n");

      DoInstallUninstall(FALSE);

      return EXIT_SUCCESS;
    }
  }

  printf("Starting tracing session...\n");

  ULONG ErrorCode = TraceStart();

  return ErrorCode == ERROR_SUCCESS
    ? EXIT_SUCCESS
    : EXIT_FAILURE;
}

```

`src/injlib/injlib.c`:

```c
#include "injlib.h"

#include <ntddk.h>
#include <ntimage.h>

#if defined(_M_AMD64) || defined(_M_ARM64)
# define INJ_CONFIG_SUPPORTS_WOW64
#endif

//////////////////////////////////////////////////////////////////////////
// ke.h
//////////////////////////////////////////////////////////////////////////

typedef enum _KAPC_ENVIRONMENT
{
  OriginalApcEnvironment,
  AttachedApcEnvironment,
  CurrentApcEnvironment,
  InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef
VOID
(NTAPI *PKNORMAL_ROUTINE)(
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  );

typedef
VOID
(NTAPI *PKKERNEL_ROUTINE)(
  _In_ PKAPC Apc,
  _Inout_ PKNORMAL_ROUTINE* NormalRoutine,
  _Inout_ PVOID* NormalContext,
  _Inout_ PVOID* SystemArgument1,
  _Inout_ PVOID* SystemArgument2
  );

typedef
VOID
(NTAPI *PKRUNDOWN_ROUTINE) (
  _In_ PKAPC Apc
  );

NTKERNELAPI
VOID
NTAPI
KeInitializeApc(
  _Out_ PRKAPC Apc,
  _In_ PETHREAD Thread,
  _In_ KAPC_ENVIRONMENT Environment,
  _In_ PKKERNEL_ROUTINE KernelRoutine,
  _In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
  _In_opt_ PKNORMAL_ROUTINE NormalRoutine,
  _In_opt_ KPROCESSOR_MODE ApcMode,
  _In_opt_ PVOID NormalContext
  );

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertQueueApc(
  _Inout_ PRKAPC Apc,
  _In_opt_ PVOID SystemArgument1,
  _In_opt_ PVOID SystemArgument2,
  _In_ KPRIORITY Increment
  );

NTKERNELAPI
BOOLEAN
NTAPI
KeAlertThread(
  _Inout_ PKTHREAD Thread,
  _In_ KPROCESSOR_MODE AlertMode
  );

NTKERNELAPI
BOOLEAN
NTAPI
KeTestAlertThread(
  _In_ KPROCESSOR_MODE AlertMode
  );

//////////////////////////////////////////////////////////////////////////
// ps.h
//////////////////////////////////////////////////////////////////////////

NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(
  _In_ PEPROCESS Process
  );

NTKERNELAPI
PCHAR
NTAPI
PsGetProcessImageFileName(
  _In_ PEPROCESS Process
  );

NTKERNELAPI
BOOLEAN
NTAPI
PsIsProtectedProcess(
  _In_ PEPROCESS Process
  );

NTKERNELAPI
USHORT
NTAPI
PsWow64GetProcessMachine(
  _In_ PEPROCESS Process
  );

//////////////////////////////////////////////////////////////////////////
// ntrtl.h
//////////////////////////////////////////////////////////////////////////

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
  _In_ ULONG Flags,
  _In_ PUNICODE_STRING StringIn,
  _Out_ PUNICODE_STRING StringOut
  );

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
  _In_ PVOID BaseOfImage,
  _In_ BOOLEAN MappedAsImage,
  _In_ USHORT DirectoryEntry,
  _Out_ PULONG Size
  );

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define INJ_MEMORY_TAG ' jnI'

//////////////////////////////////////////////////////////////////////////
// Enumerations.
//////////////////////////////////////////////////////////////////////////

typedef enum _INJ_SYSTEM_DLL
{
  INJ_NOTHING_LOADED            = 0x0000,
  INJ_SYSARM32_NTDLL_LOADED     = 0x0001,
  INJ_SYCHPE32_NTDLL_LOADED     = 0x0002,
  INJ_SYSWOW64_NTDLL_LOADED     = 0x0004,
  INJ_SYSTEM32_NTDLL_LOADED     = 0x0008,
  INJ_SYSTEM32_WOW64_LOADED     = 0x0010,
  INJ_SYSTEM32_WOW64WIN_LOADED  = 0x0020,
  INJ_SYSTEM32_WOW64CPU_LOADED  = 0x0040,
  INJ_SYSTEM32_WOWARMHW_LOADED  = 0x0080,
  INJ_SYSTEM32_XTAJIT_LOADED    = 0x0100,
} INJ_SYSTEM_DLL;

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _INJ_SYSTEM_DLL_DESCRIPTOR
{
  UNICODE_STRING  DllPath;
  INJ_SYSTEM_DLL  Flag;
} INJ_SYSTEM_DLL_DESCRIPTOR, *PINJ_SYSTEM_DLL_DESCRIPTOR;

typedef struct _INJ_THUNK
{
  PVOID           Buffer;
  USHORT          Length;
} INJ_THUNK, *PINJ_THUNK;

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
InjpQueueApc(
  _In_ KPROCESSOR_MODE ApcMode,
  _In_ PKNORMAL_ROUTINE NormalRoutine,
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  );

VOID
NTAPI
InjpInjectApcNormalRoutine(
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  );

VOID
NTAPI
InjpInjectApcKernelRoutine(
  _In_ PKAPC Apc,
  _Inout_ PKNORMAL_ROUTINE* NormalRoutine,
  _Inout_ PVOID* NormalContext,
  _Inout_ PVOID* SystemArgument1,
  _Inout_ PVOID* SystemArgument2
  );

//
// reparse.c
//

NTSTATUS
NTAPI
SimRepInitialize(
  _In_ PDRIVER_OBJECT DriverObject,
  _In_ PUNICODE_STRING RegistryPath
  );

//////////////////////////////////////////////////////////////////////////
// Private constant variables.
//////////////////////////////////////////////////////////////////////////

ANSI_STRING LdrLoadDllRoutineName = RTL_CONSTANT_STRING("LdrLoadDll");

//
// Paths can have format "\Device\HarddiskVolume3\Windows\System32\ntdll.dll",
// so only the end of the string is compared.
//

INJ_SYSTEM_DLL_DESCRIPTOR InjpSystemDlls[] = {
  { RTL_CONSTANT_STRING(L"\\SysArm32\\ntdll.dll"),    INJ_SYSARM32_NTDLL_LOADED    },
  { RTL_CONSTANT_STRING(L"\\SyChpe32\\ntdll.dll"),    INJ_SYCHPE32_NTDLL_LOADED    },
  { RTL_CONSTANT_STRING(L"\\SysWow64\\ntdll.dll"),    INJ_SYSWOW64_NTDLL_LOADED    },
  { RTL_CONSTANT_STRING(L"\\System32\\ntdll.dll"),    INJ_SYSTEM32_NTDLL_LOADED    },
  { RTL_CONSTANT_STRING(L"\\System32\\wow64.dll"),    INJ_SYSTEM32_WOW64_LOADED    },
  { RTL_CONSTANT_STRING(L"\\System32\\wow64win.dll"), INJ_SYSTEM32_WOW64WIN_LOADED },
  { RTL_CONSTANT_STRING(L"\\System32\\wow64cpu.dll"), INJ_SYSTEM32_WOW64CPU_LOADED },
  { RTL_CONSTANT_STRING(L"\\System32\\wowarmhw.dll"), INJ_SYSTEM32_WOWARMHW_LOADED },
  { RTL_CONSTANT_STRING(L"\\System32\\xtajit.dll"),   INJ_SYSTEM32_XTAJIT_LOADED   },
};

//
// ;++
// ;
// ; VOID
// ; NTAPI
// ; ApcNormalRoutine(
// ;   _In_ PVOID NormalContext,
// ;   _In_ PVOID SystemArgument1,
// ;   _In_ PVOID SystemArgument2
// ;   )
// ;
// ; Routine Description:
// ;
// ;    This routine loads DLL specified in the NormalContext.
// ;
// ;    If native process is being injected, this function is called
// ;    from the ntdll.dll!KiUserApcDispatcher routine.
// ;
// ;    If Wow64 process is being injected, the following code-flow
// ;    is responsible for reaching this function:
// ;
// ;    - wow64.dll!Wow64ApcRoutine (set by PsWrapApcWow64Thread):
// ;      - Puts NormalRoutine, NormalContext, SystemArgument1 and
// ;        SystemArgument2 on the top of the stack, sets EIP to
// ;        KiUserApcDispatcher of Wow64 ntdll.dll.
// ;    - ntdll.dll!KiUserApcDispatcher (note this is Wow64 ntdll.dll)
// ;      - Pops NormalRoutine - our ApcNormalRoutine - from the stack
// ;        and calls it (note that NormalCountext, SystemArgument1 and
// ;        SystemArgument2 remain on the stack).
// ;
// ;    The shellcode is equivalent to this code - regardless of the
// ;    architecture:
// ;
// ;    VOID
// ;    NTAPI
// ;    ApcNormalRoutine(
// ;        _In_ PVOID NormalContext,    // LdrLoadDll routine address
// ;        _In_ PVOID SystemArgument1,  // DllPath
// ;        _In_ PVOID SystemArgument2   // DllPath length
// ;        )
// ;    {
// ;        UNICODE_STRING DllName;
// ;        PVOID          BaseAddress;
// ;
// ;        DllName.Length        = (USHORT)SystemArgument2;
// ;        DllName.MaximumLength = (USHORT)SystemArgument2;
// ;        DllName.Buffer        = (PWSTR) SystemArgument1;
// ;
// ;        ((PLDRLOADDLL_ROUTINE)NormalContext)(0, 0, &DllName, &BaseAddress);
// ;    }
// ;
// ;    // See: https://gcc.godbolt.org/z/1DDtuW
// ;
// ; Arguments:
// ;
// ;    NormalContext   - LdrLoadDll routine address.
// ;    SystemArgument1 - DLL path.
// ;    SystemArgument2 - Length of DLL path.
// ;
// ; Return Value:
// ;
// ;    None.
// ;
// ;--
//

UCHAR InjpThunkX86[] = {              //
  0x83, 0xec, 0x08,                   // sub    esp,0x8
  0x0f, 0xb7, 0x44, 0x24, 0x14,       // movzx  eax,[esp + 0x14]
  0x66, 0x89, 0x04, 0x24,             // mov    [esp],ax
  0x66, 0x89, 0x44, 0x24, 0x02,       // mov    [esp + 0x2],ax
  0x8b, 0x44, 0x24, 0x10,             // mov    eax,[esp + 0x10]
  0x89, 0x44, 0x24, 0x04,             // mov    [esp + 0x4],eax
  0x8d, 0x44, 0x24, 0x14,             // lea    eax,[esp + 0x14]
  0x50,                               // push   eax
  0x8d, 0x44, 0x24, 0x04,             // lea    eax,[esp + 0x4]
  0x50,                               // push   eax
  0x6a, 0x00,                         // push   0x0
  0x6a, 0x00,                         // push   0x0
  0xff, 0x54, 0x24, 0x1c,             // call   [esp + 0x1c]
  0x83, 0xc4, 0x08,                   // add    esp,0x8
  0xc2, 0x0c, 0x00,                   // ret    0xc
};                                    //

UCHAR InjpThunkX64[] = {              //
  0x48, 0x83, 0xec, 0x38,             // sub    rsp,0x38
  0x48, 0x89, 0xc8,                   // mov    rax,rcx
  0x66, 0x44, 0x89, 0x44, 0x24, 0x20, // mov    [rsp+0x20],r8w
  0x66, 0x44, 0x89, 0x44, 0x24, 0x22, // mov    [rsp+0x22],r8w
  0x4c, 0x8d, 0x4c, 0x24, 0x40,       // lea    r9,[rsp+0x40]
  0x48, 0x89, 0x54, 0x24, 0x28,       // mov    [rsp+0x28],rdx
  0x4c, 0x8d, 0x44, 0x24, 0x20,       // lea    r8,[rsp+0x20]
  0x31, 0xd2,                         // xor    edx,edx
  0x31, 0xc9,                         // xor    ecx,ecx
  0xff, 0xd0,                         // call   rax
  0x48, 0x83, 0xc4, 0x38,             // add    rsp,0x38
  0xc2, 0x00, 0x00,                   // ret    0x0
};                                    //

UCHAR InjpThunkARM32[] = {            //
  0x1f, 0xb5,                         // push   {r0-r4,lr}
  0xad, 0xf8, 0x08, 0x20,             // strh   r2,[sp,#8]
  0xad, 0xf8, 0x0a, 0x20,             // strh   r2,[sp,#0xA]
  0x03, 0x91,                         // str    r1,[sp,#0xC]
  0x02, 0xaa,                         // add    r2,sp,#8
  0x00, 0x21,                         // movs   r1,#0
  0x04, 0x46,                         // mov    r4,r0
  0x6b, 0x46,                         // mov    r3,sp
  0x00, 0x20,                         // movs   r0,#0
  0xa0, 0x47,                         // blx    r4
  0x1f, 0xbd,                         // pop    {r0-r4,pc}
};                                    //

UCHAR InjpThunkARM64[] = {            //
  0xfe, 0x0f, 0x1f, 0xf8,             // str    lr,[sp,#-0x10]!
  0xff, 0x83, 0x00, 0xd1,             // sub    sp,sp,#0x20
  0xe9, 0x03, 0x00, 0xaa,             // mov    x9,x0
  0xe2, 0x13, 0x00, 0x79,             // strh   w2,[sp,#8]
  0x00, 0x00, 0x80, 0xd2,             // mov    x0,#0
  0xe2, 0x17, 0x00, 0x79,             // strh   w2,[sp,#0xA]
  0xe2, 0x23, 0x00, 0x91,             // add    x2,sp,#8
  0xe1, 0x0b, 0x00, 0xf9,             // str    x1,[sp,#0x10]
  0x01, 0x00, 0x80, 0xd2,             // mov    x1,#0
  0xe3, 0x03, 0x00, 0x91,             // mov    x3,sp
  0x20, 0x01, 0x3f, 0xd6,             // blr    x9
  0xff, 0x83, 0x00, 0x91,             // add    sp,sp,#0x20
  0xfe, 0x07, 0x41, 0xf8,             // ldr    lr,[sp],#0x10
  0xc0, 0x03, 0x5f, 0xd6,             // ret
};                                    //

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

LIST_ENTRY      InjInfoListHead;

INJ_METHOD      InjMethod;

UNICODE_STRING  InjDllPath[InjArchitectureMax];

INJ_THUNK       InjThunk[InjArchitectureMax] = {
  { InjpThunkX86,   sizeof(InjpThunkX86)   },
  { InjpThunkX64,   sizeof(InjpThunkX64)   },
  { InjpThunkARM32, sizeof(InjpThunkARM32) },
  { InjpThunkARM64, sizeof(InjpThunkARM64) },
};

BOOLEAN         InjIsWindows7;

//////////////////////////////////////////////////////////////////////////
// Helper functions.
//////////////////////////////////////////////////////////////////////////

PVOID
NTAPI
RtlxFindExportedRoutineByName(
  _In_ PVOID DllBase,
  _In_ PANSI_STRING ExportName
  )
{
  //
  // RtlFindExportedRoutineByName is not exported by ntoskrnl until Win10.
  // Following code is borrowed from ReactOS.
  //

  PULONG NameTable;
  PUSHORT OrdinalTable;
  PIMAGE_EXPORT_DIRECTORY ExportDirectory;
  LONG Low = 0, Mid = 0, High, Ret;
  USHORT Ordinal;
  PVOID Function;
  ULONG ExportSize;
  PULONG ExportTable;

  //
  // Get the export directory.
  //

  ExportDirectory = RtlImageDirectoryEntryToData(DllBase,
                                                 TRUE,
                                                 IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                 &ExportSize);

  if (!ExportDirectory)
  {
    return NULL;
  }

  //
  // Setup name tables.
  //

  NameTable    = (PULONG) ((ULONG_PTR)DllBase + ExportDirectory->AddressOfNames);
  OrdinalTable = (PUSHORT)((ULONG_PTR)DllBase + ExportDirectory->AddressOfNameOrdinals);

  //
  // Do a binary search.
  //

  High = ExportDirectory->NumberOfNames - 1;
  while (High >= Low)
  {
    //
    // Get new middle value.
    //

    Mid = (Low + High) >> 1;

    //
    // Compare name.
    //

    Ret = strcmp(ExportName->Buffer, (PCHAR)DllBase + NameTable[Mid]);
    if (Ret < 0)
    {
      //
      // Update high.
      //
      High = Mid - 1;
    }
    else if (Ret > 0)
    {
      //
      // Update low.
      //
      Low = Mid + 1;
    }
    else
    {
      //
      // We got it.
      //
      break;
    }
  }

  //
  // Check if we couldn't find it.
  //

  if (High < Low)
  {
    return NULL;
  }

  //
  // Otherwise, this is the ordinal.
  //

  Ordinal = OrdinalTable[Mid];

  //
  // Validate the ordinal.
  //

  if (Ordinal >= ExportDirectory->NumberOfFunctions)
  {
    return NULL;
  }

  //
  // Resolve the address and write it.
  //

  ExportTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfFunctions);
  Function = (PVOID)((ULONG_PTR)DllBase + ExportTable[Ordinal]);

  //
  // We found it!
  //

  NT_ASSERT(
    (Function < (PVOID)ExportDirectory) ||
    (Function > (PVOID)((ULONG_PTR)ExportDirectory + ExportSize))
  );

  return Function;
}

BOOLEAN
NTAPI
RtlxSuffixUnicodeString(
  _In_ PUNICODE_STRING String1,
  _In_ PUNICODE_STRING String2,
  _In_ BOOLEAN CaseInSensitive
  )
{
  //
  // RtlSuffixUnicodeString is not exported by ntoskrnl until Win10.
  //

  return String2->Length >= String1->Length &&
         RtlCompareUnicodeStrings(String2->Buffer + (String2->Length - String1->Length) / sizeof(WCHAR),
                                  String1->Length / sizeof(WCHAR),
                                  String1->Buffer,
                                  String1->Length / sizeof(WCHAR),
                                  CaseInSensitive) == 0;

}

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
InjpQueueApc(
  _In_ KPROCESSOR_MODE ApcMode,
  _In_ PKNORMAL_ROUTINE NormalRoutine,
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  )
{
  //
  // Allocate memory for the KAPC structure.
  //

  PKAPC Apc = ExAllocatePoolWithTag(NonPagedPoolNx,
                                    sizeof(KAPC),
                                    INJ_MEMORY_TAG);

  if (!Apc)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  //
  // Initialize and queue the APC.
  //

  KeInitializeApc(Apc,                                  // Apc
                  PsGetCurrentThread(),                 // Thread
                  OriginalApcEnvironment,               // Environment
                  &InjpInjectApcKernelRoutine,          // KernelRoutine
                  NULL,                                 // RundownRoutine
                  NormalRoutine,                        // NormalRoutine
                  ApcMode,                              // ApcMode
                  NormalContext);                       // NormalContext

  BOOLEAN Inserted = KeInsertQueueApc(Apc,              // Apc
                                      SystemArgument1,  // SystemArgument1
                                      SystemArgument2,  // SystemArgument2
                                      0);               // Increment

  if (!Inserted)
  {
    ExFreePoolWithTag(Apc, INJ_MEMORY_TAG);
    return STATUS_UNSUCCESSFUL;
  }

  return STATUS_SUCCESS;
}

VOID
NTAPI
InjpInjectApcNormalRoutine(
  _In_ PVOID NormalContext,
  _In_ PVOID SystemArgument1,
  _In_ PVOID SystemArgument2
  )
{
  UNREFERENCED_PARAMETER(SystemArgument1);
  UNREFERENCED_PARAMETER(SystemArgument2);

  PINJ_INJECTION_INFO InjectionInfo = NormalContext;
  InjInject(InjectionInfo);
}

VOID
NTAPI
InjpInjectApcKernelRoutine(
  _In_ PKAPC Apc,
  _Inout_ PKNORMAL_ROUTINE* NormalRoutine,
  _Inout_ PVOID* NormalContext,
  _Inout_ PVOID* SystemArgument1,
  _Inout_ PVOID* SystemArgument2
  )
{
  UNREFERENCED_PARAMETER(NormalRoutine);
  UNREFERENCED_PARAMETER(NormalContext);
  UNREFERENCED_PARAMETER(SystemArgument1);
  UNREFERENCED_PARAMETER(SystemArgument2);

  //
  // Common kernel routine for both user-mode and
  // kernel-mode APCs queued by the InjpQueueApc
  // function.  Just release the memory of the APC
  // structure and return back.
  //

  ExFreePoolWithTag(Apc, INJ_MEMORY_TAG);
}

NTSTATUS
NTAPI
InjpInject(
  _In_ PINJ_INJECTION_INFO InjectionInfo,
  _In_ INJ_ARCHITECTURE Architecture,
  _In_ HANDLE SectionHandle,
  _In_ SIZE_T SectionSize
  )
{
  NTSTATUS Status;

  //
  // First, map this section with read-write access.
  //

  PVOID SectionMemoryAddress = NULL;
  Status = ZwMapViewOfSection(SectionHandle,
                              ZwCurrentProcess(),
                              &SectionMemoryAddress,
                              0,
                              SectionSize,
                              NULL,
                              &SectionSize,
                              ViewUnmap,
                              0,
                              PAGE_READWRITE);

  if (!NT_SUCCESS(Status))
  {
    goto Exit;
  }

  //
  // Code of the APC routine (ApcNormalRoutine defined in the
  // "shellcode" above) starts at the SectionMemoryAddress.
  // Copy the shellcode to the allocated memory.
  //

  PVOID ApcRoutineAddress = SectionMemoryAddress;
  RtlCopyMemory(ApcRoutineAddress,
                InjThunk[Architecture].Buffer,
                InjThunk[Architecture].Length);

  //
  // Fill the data of the ApcContext.
  //

  PWCHAR DllPath = (PWCHAR)((PUCHAR)SectionMemoryAddress + InjThunk[Architecture].Length);
  RtlCopyMemory(DllPath,
                InjDllPath[Architecture].Buffer,
                InjDllPath[Architecture].Length);

  //
  // Unmap the section and map it again, but now
  // with read-execute (no write) access.
  //

  ZwUnmapViewOfSection(ZwCurrentProcess(), SectionMemoryAddress);

  SectionMemoryAddress = NULL;
  Status = ZwMapViewOfSection(SectionHandle,
                              ZwCurrentProcess(),
                              &SectionMemoryAddress,
                              0,
                              PAGE_SIZE,
                              NULL,
                              &SectionSize,
                              ViewUnmap,
                              0,
                              PAGE_EXECUTE_READ);

  if (!NT_SUCCESS(Status))
  {
    goto Exit;
  }

  //
  // Reassign remapped address.
  //

  ApcRoutineAddress = SectionMemoryAddress;
  DllPath = (PWCHAR)((PUCHAR)SectionMemoryAddress + InjThunk[Architecture].Length);

  PVOID ApcContext   = (PVOID)InjectionInfo->LdrLoadDllRoutineAddress;
  PVOID ApcArgument1 = (PVOID)DllPath;
  PVOID ApcArgument2 = (PVOID)InjDllPath[Architecture].Length;

#if defined(INJ_CONFIG_SUPPORTS_WOW64)

  if (PsGetProcessWow64Process(PsGetCurrentProcess()))
  {
    //
    // The ARM32 ntdll.dll uses "BLX" instruction for calling the ApcRoutine.
    // This instruction can change the processor state (between Thumb & ARM),
    // based on the LSB (least significant bit).  If this bit is 0, the code
    // will run in the ARM instruction set.  If this bit is 1, the code will
    // run in Thumb instruction set.  Because Windows can run only in the Thumb
    // instruction set, we have to ensure this bit is set.  Otherwise, Windows
    // would raise STATUS_ILLEGAL_INSTRUCTION upon execution of the ApcRoutine.
    //

    if (Architecture == InjArchitectureARM32)
    {
      ApcRoutineAddress = (PVOID)((ULONG_PTR)ApcRoutineAddress | 1);
    }

    //
    // PsWrapApcWow64Thread essentially assigns wow64.dll!Wow64ApcRoutine
    // to the NormalRoutine.  This Wow64ApcRoutine (which is 64-bit code)
    // in turn calls KiUserApcDispatcher (in 32-bit ntdll.dll) which finally
    // calls our provided ApcRoutine.
    //

    PsWrapApcWow64Thread(&ApcContext, &ApcRoutineAddress);
  }

#endif

  PKNORMAL_ROUTINE ApcRoutine = (PKNORMAL_ROUTINE)(ULONG_PTR)ApcRoutineAddress;

  Status = InjpQueueApc(UserMode,
                        ApcRoutine,
                        ApcContext,
                        ApcArgument1,
                        ApcArgument2);

  if (!NT_SUCCESS(Status))
  {
    //
    // If injection failed for some reason, unmap the section.
    //

    ZwUnmapViewOfSection(ZwCurrentProcess(), SectionMemoryAddress);
  }

Exit:
  return Status;
}

NTSTATUS
NTAPI
InjpInjectX64NoThunk(
  _In_ PINJ_INJECTION_INFO InjectionInfo,
  _In_ INJ_ARCHITECTURE Architecture,
  _In_ HANDLE SectionHandle,
  _In_ SIZE_T SectionSize
  )
{
  NT_ASSERT(InjectionInfo->LdrLoadDllRoutineAddress);
  NT_ASSERT(Architecture == InjArchitectureX64);

  UNREFERENCED_PARAMETER(Architecture);

  NTSTATUS Status;

  PVOID SectionMemoryAddress = NULL;
  Status = ZwMapViewOfSection(SectionHandle,
                              ZwCurrentProcess(),
                              &SectionMemoryAddress,
                              0,
                              PAGE_SIZE,
                              NULL,
                              &SectionSize,
                              ViewUnmap,
                              0,
                              PAGE_READWRITE);

  if (!NT_SUCCESS(Status))
  {
    goto Exit;
  }

  //
  // Create the UNICODE_STRING structure and fill out the
  // full path of the DLL.
  //

  PUNICODE_STRING DllPath = (PUNICODE_STRING)(SectionMemoryAddress);
  PWCHAR DllPathBuffer = (PWCHAR)((PUCHAR)DllPath + sizeof(UNICODE_STRING));

  RtlCopyMemory(DllPathBuffer,
                InjDllPath[Architecture].Buffer,
                InjDllPath[Architecture].Length);

  RtlInitUnicodeString(DllPath, DllPathBuffer);

  Status = InjpQueueApc(UserMode,
                        (PKNORMAL_ROUTINE)(ULONG_PTR)InjectionInfo->LdrLoadDllRoutineAddress,
                        NULL,     // Translates to 1st param. of LdrLoadDll (SearchPath)
                        NULL,     // Translates to 2nd param. of LdrLoadDll (DllCharacteristics)
                        DllPath); // Translates to 3rd param. of LdrLoadDll (DllName)

  //
  // 4th param. of LdrLoadDll (BaseAddress) is actually an output parameter.
  //
  // When control is transferred to the KiUserApcDispatcher routine of the
  // 64-bit ntdll.dll, the RSP points to the CONTEXT structure which might
  // be eventually provided to the ZwContinue function (in case this APC
  // dispatch will be routed to the Wow64 subsystem).
  //
  // Also, the value of the RSP register is moved to the R9 register before
  // calling the KiUserCallForwarder function.  The KiUserCallForwarder
  // function actually passes this value of the R9 register down to the
  // NormalRoutine as a "hidden 4th parameter".
  //
  // Because LdrLoadDll writes to the provided address, it'll actually
  // result in overwrite of the CONTEXT.P1Home field (the first field of
  // the CONTEXT structure).
  //
  // Luckily for us, this field is only used in the very early stage of
  // the APC dispatch and can be overwritten without causing any troubles.
  //
  // For excellent explanation, see:
  // https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-2
  //

Exit:
  return Status;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
InjInitialize(
  _In_ PDRIVER_OBJECT DriverObject,
  _In_ PUNICODE_STRING RegistryPath,
  _In_ PINJ_SETTINGS Settings
  )
{
  NTSTATUS Status;

  //
  // Initialize injection info linked list.
  //

  InitializeListHead(&InjInfoListHead);

  ULONG Flags = RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE
              | RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING;

  for (ULONG Architecture = 0; Architecture < InjArchitectureMax; Architecture += 1)
  {
    Status = RtlDuplicateUnicodeString(Flags,
                                       &Settings->DllPath[Architecture],
                                       &InjDllPath[Architecture]);
    if (!NT_SUCCESS(Status))
    {
      goto Error;
    }
  }

  //
  // Check if we're running on Windows 7.
  //

  RTL_OSVERSIONINFOW VersionInformation = { 0 };
  VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
  RtlGetVersion(&VersionInformation);

  if (VersionInformation.dwMajorVersion == 6 &&
      VersionInformation.dwMinorVersion == 1)
  {
    InjDbgPrint("[injlib]: Current system is Windows 7\n");
    InjIsWindows7 = TRUE;
  }

  //
  // Default setting of the injection of Wow64 processes.
  //

#if defined(INJ_CONFIG_SUPPORTS_WOW64)
  InjMethod = Settings->Method;

#  if !defined(_M_AMD64)
  //
  // Thunkless method is available on x64.
  //

  if (InjMethod == InjMethodThunkless)
  {
    InjMethod = InjMethodThunk;
  }
#  endif

#else
  InjMethod = InjMethodThunk;
#endif

  InjDbgPrint("[injlib]: InjMethod: '%s'\n",
    InjMethod == InjMethodThunk           ? "InjMethodThunk"           :
    InjMethod == InjMethodThunkless       ? "InjMethodThunkLess"       :
    InjMethod == InjMethodWow64LogReparse ? "InjMethodWow64LogReparse" :
                                            "UNKNOWN"
    );

  if (InjMethod == InjMethodWow64LogReparse)
  {
    Status = SimRepInitialize(DriverObject, RegistryPath);
  }

  return Status;

Error:
  InjDestroy();
  return Status;
}

VOID
NTAPI
InjDestroy(
  VOID
  )
{
  //
  // Release memory of all injection-info entries.
  //

  PLIST_ENTRY NextEntry = InjInfoListHead.Flink;

  while (NextEntry != &InjInfoListHead)
  {
    PINJ_INJECTION_INFO InjectionInfo = CONTAINING_RECORD(NextEntry,
                                                          INJ_INJECTION_INFO,
                                                          ListEntry);
    NextEntry = NextEntry->Flink;

    ExFreePoolWithTag(InjectionInfo, INJ_MEMORY_TAG);
  }

  //
  // Release memory of all buffers.
  //

  for (ULONG Architecture = 0; Architecture < InjArchitectureMax; Architecture += 1)
  {
    RtlFreeUnicodeString(&InjDllPath[Architecture]);
  }
}

NTSTATUS
NTAPI
InjCreateInjectionInfo(
  _In_opt_ PINJ_INJECTION_INFO* InjectionInfo,
  _In_ HANDLE ProcessId
  )
{
  PINJ_INJECTION_INFO CapturedInjectionInfo;

  if (InjectionInfo && *InjectionInfo)
  {
    CapturedInjectionInfo = *InjectionInfo;
  }
  else
  {
    CapturedInjectionInfo = ExAllocatePoolWithTag(NonPagedPoolNx,
                                                  sizeof(INJ_INJECTION_INFO),
                                                  INJ_MEMORY_TAG);

    if (!CapturedInjectionInfo)
    {
      return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (InjectionInfo)
    {
      *InjectionInfo = CapturedInjectionInfo;
    }
  }

  RtlZeroMemory(CapturedInjectionInfo, sizeof(INJ_INJECTION_INFO));

  CapturedInjectionInfo->ProcessId = ProcessId;
  CapturedInjectionInfo->ForceUserApc = TRUE;
  CapturedInjectionInfo->Method = InjMethod;

  InsertTailList(&InjInfoListHead, &CapturedInjectionInfo->ListEntry);

  return STATUS_SUCCESS;
}

VOID
NTAPI
InjRemoveInjectionInfo(
  _In_ PINJ_INJECTION_INFO InjectionInfo,
  _In_ BOOLEAN FreeMemory
  )
{
  RemoveEntryList(&InjectionInfo->ListEntry);

  if (FreeMemory)
  {
    ExFreePoolWithTag(InjectionInfo, INJ_MEMORY_TAG);
  }
}

VOID
NTAPI
InjRemoveInjectionInfoByProcessId(
  _In_ HANDLE ProcessId,
  _In_ BOOLEAN FreeMemory
  )
{
  PINJ_INJECTION_INFO InjectionInfo = InjFindInjectionInfo(ProcessId);

  if (InjectionInfo)
  {
    InjRemoveInjectionInfo(InjectionInfo, FreeMemory);
  }
}

PINJ_INJECTION_INFO
NTAPI
InjFindInjectionInfo(
  _In_ HANDLE ProcessId
  )
{
  PLIST_ENTRY NextEntry = InjInfoListHead.Flink;

  while (NextEntry != &InjInfoListHead)
  {
    PINJ_INJECTION_INFO InjectionInfo = CONTAINING_RECORD(NextEntry,
                                                          INJ_INJECTION_INFO,
                                                          ListEntry);

    if (InjectionInfo->ProcessId == ProcessId)
    {
      return InjectionInfo;
    }

    NextEntry = NextEntry->Flink;
  }

  return NULL;
}

BOOLEAN
NTAPI
InjCanInject(
  _In_ PINJ_INJECTION_INFO InjectionInfo
  )
{
  //
  // DLLs that need to be loaded in the native process
  // (i.e.: x64 process on x64 Windows, x86 process on
  // x86 Windows) before we can safely load our DLL.
  //

  ULONG RequiredDlls = INJ_SYSTEM32_NTDLL_LOADED;

#if defined(INJ_CONFIG_SUPPORTS_WOW64)

  if (PsGetProcessWow64Process(PsGetCurrentProcess()))
  {
    //
    // DLLs that need to be loaded in the Wow64 process
    // before we can safely load our DLL.
    //

    RequiredDlls |= INJ_SYSTEM32_NTDLL_LOADED;
    RequiredDlls |= INJ_SYSTEM32_WOW64_LOADED;
    RequiredDlls |= INJ_SYSTEM32_WOW64WIN_LOADED;

#   if defined (_M_AMD64)

    RequiredDlls |= INJ_SYSTEM32_WOW64CPU_LOADED;
    RequiredDlls |= INJ_SYSWOW64_NTDLL_LOADED;

#   elif defined (_M_ARM64)

    switch (PsWow64GetProcessMachine(PsGetCurrentProcess()))
    {
      case IMAGE_FILE_MACHINE_I386:

        //
        // Emulated x86 processes can load either SyCHPE32\ntdll.dll or
        // SysWOW64\ntdll.dll - depending on whether "hybrid execution
        // mode" is enabled or disabled.
        //
        // PsWow64GetProcessNtdllType(Process) can provide this information,
        // by returning EPROCESS->Wow64Process.NtdllType.  Unfortunatelly,
        // that function is not exported and EPROCESS is not documented.
        //
        // The solution here is to pick the Wow64 NTDLL which is already
        // loaded and set it as "required".
        //

        RequiredDlls |= InjectionInfo->LoadedDlls & (
                        INJ_SYSWOW64_NTDLL_LOADED |
                        INJ_SYCHPE32_NTDLL_LOADED
                        );
        RequiredDlls |= INJ_SYSTEM32_XTAJIT_LOADED;
        break;

      case IMAGE_FILE_MACHINE_ARMNT:
        RequiredDlls |= INJ_SYSARM32_NTDLL_LOADED;
        RequiredDlls |= INJ_SYSTEM32_WOWARMHW_LOADED;
        break;

      case IMAGE_FILE_MACHINE_ARM64:
        break;
    }

#   endif

  }

#endif

  return (InjectionInfo->LoadedDlls & RequiredDlls) == RequiredDlls;
}

NTSTATUS
NTAPI
InjInject(
  _In_ PINJ_INJECTION_INFO InjectionInfo
  )
{
  NTSTATUS Status;

  //
  // Create memory space for injection-specific data,
  // such as path to the to-be-injected DLL.  Memory
  // of this section will be eventually mapped to the
  // injected process.
  //
  // Note that this memory is created using sections
  // instead of ZwAllocateVirtualMemory, mainly because
  // function ZwProtectVirtualMemory is not exported
  // by ntoskrnl.exe until Windows 8.1.  In case of
  // sections, the effect of memory protection change
  // is achieved by remaping the section with different
  // protection type.
  //

  OBJECT_ATTRIBUTES ObjectAttributes;
  InitializeObjectAttributes(&ObjectAttributes,
                             NULL,
                             OBJ_KERNEL_HANDLE,
                             NULL,
                             NULL);

  HANDLE SectionHandle;
  SIZE_T SectionSize = PAGE_SIZE;
  LARGE_INTEGER MaximumSize;
  MaximumSize.QuadPart = SectionSize;
  Status = ZwCreateSection(&SectionHandle,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,
                           &MaximumSize,
                           PAGE_EXECUTE_READWRITE,
                           SEC_COMMIT,
                           NULL);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  INJ_ARCHITECTURE Architecture = InjArchitectureMax;

  if (InjectionInfo->Method == InjMethodThunk ||
      InjectionInfo->Method == InjMethodWow64LogReparse)
  {
#if defined(_M_IX86)

    Architecture = InjArchitectureX86;

#elif defined(_M_AMD64)

    Architecture = PsGetProcessWow64Process(PsGetCurrentProcess())
      ? InjArchitectureX86
      : InjArchitectureX64;

#elif defined(_M_ARM64)

    switch (PsWow64GetProcessMachine(PsGetCurrentProcess()))
    {
      case IMAGE_FILE_MACHINE_I386:
        Architecture = InjArchitectureX86;
        break;

      case IMAGE_FILE_MACHINE_ARMNT:
        Architecture = InjArchitectureARM32;
        break;

      case IMAGE_FILE_MACHINE_ARM64:
        Architecture = InjArchitectureARM64;
        break;
    }

#endif

    NT_ASSERT(Architecture != InjArchitectureMax);

    InjpInject(InjectionInfo,
               Architecture,
               SectionHandle,
               SectionSize);
  }
#if defined(_M_AMD64)
  else if (InjectionInfo->Method == InjMethodThunkless)
  {
    Architecture = InjArchitectureX64;

    InjpInjectX64NoThunk(InjectionInfo,
                         Architecture,
                         SectionHandle,
                         SectionSize);
  }
#endif

  ZwClose(SectionHandle);

  if (NT_SUCCESS(Status) && InjectionInfo->ForceUserApc)
  {
    //
    // Sets CurrentThread->ApcState.UserApcPending to TRUE.
    // This causes the queued user APC to be triggered immediately
    // on next transition of this thread to the user-mode.
    //

    KeTestAlertThread(UserMode);
  }

  return Status;
}

//////////////////////////////////////////////////////////////////////////
// Notify routines.
//////////////////////////////////////////////////////////////////////////

VOID
NTAPI
InjCreateProcessNotifyRoutineEx(
  _Inout_ PEPROCESS Process,
  _In_ HANDLE ProcessId,
  _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
  )
{
  UNREFERENCED_PARAMETER(Process);

  if (CreateInfo)
  {
    InjCreateInjectionInfo(NULL, ProcessId);
  }
  else
  {
    InjRemoveInjectionInfoByProcessId(ProcessId, TRUE);
  }
}

VOID
NTAPI
InjLoadImageNotifyRoutine(
  _In_opt_ PUNICODE_STRING FullImageName,
  _In_ HANDLE ProcessId,
  _In_ PIMAGE_INFO ImageInfo
  )
{
  //
  // Check if current process is injected.
  //

  PINJ_INJECTION_INFO InjectionInfo = InjFindInjectionInfo(ProcessId);

  if (!InjectionInfo || InjectionInfo->IsInjected)
  {
    return;
  }

#if defined(INJ_CONFIG_SUPPORTS_WOW64)
  //
  // If reparse-injection is enabled and this process is
  // Wow64 process, then do not track load-images.
  //

  if (InjectionInfo->Method == InjMethodWow64LogReparse &&
      PsGetProcessWow64Process(PsGetCurrentProcess()))
  {
    return;
  }
#endif

  if (PsIsProtectedProcess(PsGetCurrentProcess()))
  {
    //
    // Protected processes throw code-integrity error when
    // they are injected.  Signing policy can be changed, but
    // it requires hacking with lots of internal and Windows-
    // version-specific structures.  Simly don't inject such
    // processes.
    //
    // See Blackbone project (https://github.com/DarthTon/Blackbone)
    // if you're interested how protection can be temporarily
    // disabled on such processes.  (Look for BBSetProtection).
    //

    InjDbgPrint("[injlib]: Ignoring protected process (PID: %u, Name: '%s')\n",
                (ULONG)(ULONG_PTR)ProcessId,
                PsGetProcessImageFileName(PsGetCurrentProcess()));

    InjRemoveInjectionInfoByProcessId(ProcessId, TRUE);

    return;
  }

  if (!InjCanInject(InjectionInfo))
  {
    //
    // This process is in early stage - important DLLs (such as
    // ntdll.dll - or wow64.dll in case of Wow64 process) aren't
    // properly initialized yet.  We can't inject the DLL until
    // they are.
    //
    // Check if any of the system DLLs we're interested in is being
    // currently loaded - if so, mark that information down into the
    // LoadedDlls field.
    //

    for (ULONG Index = 0; Index < RTL_NUMBER_OF(InjpSystemDlls); Index += 1)
    {
      PUNICODE_STRING SystemDllPath = &InjpSystemDlls[Index].DllPath;

      if (RtlxSuffixUnicodeString(SystemDllPath, FullImageName, TRUE))
      {
        PVOID LdrLoadDllRoutineAddress = RtlxFindExportedRoutineByName(ImageInfo->ImageBase,
                                                                       &LdrLoadDllRoutineName);

        ULONG DllFlag = InjpSystemDlls[Index].Flag;
        InjectionInfo->LoadedDlls |= DllFlag;

        switch (DllFlag)
        {
          //
          // In case of "thunk method", capture address of the LdrLoadDll
          // routine from the ntdll.dll (which is of the same architecture
          // as the process).
          //

          case INJ_SYSARM32_NTDLL_LOADED:
          case INJ_SYCHPE32_NTDLL_LOADED:
          case INJ_SYSWOW64_NTDLL_LOADED:
            if (InjectionInfo->Method != InjMethodThunkless)
            {
              InjectionInfo->LdrLoadDllRoutineAddress = LdrLoadDllRoutineAddress;
            }
            break;

          //
          // For "thunkless method", capture address of the LdrLoadDll
          // routine from the native ntdll.dll.
          //

          case INJ_SYSTEM32_NTDLL_LOADED:
            InjectionInfo->LdrLoadDllRoutineAddress = LdrLoadDllRoutineAddress;
            break;

          default:
            break;
        }

        //
        // Break the for-loop.
        //

        break;
      }
    }
  }
  else
  {
#if defined(INJ_CONFIG_SUPPORTS_WOW64)

    if (InjIsWindows7 &&
        InjectionInfo->Method == InjMethodThunk &&
        PsGetProcessWow64Process(PsGetCurrentProcess()))
    {
      //
      // On Windows 7, if we're injecting DLL into Wow64 process using
      // the "thunk method", we have additionaly postpone the load after
      // these system DLLs.
      //
      // This is because on Windows 7, these DLLs are loaded as part of
      // the wow64!ProcessInit routine, therefore the Wow64 subsystem
      // is not fully initialized to execute our injected Wow64ApcRoutine.
      //

      UNICODE_STRING System32Kernel32Path = RTL_CONSTANT_STRING(L"\\System32\\kernel32.dll");
      UNICODE_STRING SysWOW64Kernel32Path = RTL_CONSTANT_STRING(L"\\SysWOW64\\kernel32.dll");
      UNICODE_STRING System32User32Path   = RTL_CONSTANT_STRING(L"\\System32\\user32.dll");
      UNICODE_STRING SysWOW64User32Path   = RTL_CONSTANT_STRING(L"\\SysWOW64\\user32.dll");

      if (RtlxSuffixUnicodeString(&System32Kernel32Path, FullImageName, TRUE) ||
          RtlxSuffixUnicodeString(&SysWOW64Kernel32Path, FullImageName, TRUE) ||
          RtlxSuffixUnicodeString(&System32User32Path, FullImageName, TRUE) ||
          RtlxSuffixUnicodeString(&SysWOW64User32Path, FullImageName, TRUE))
      {
        InjDbgPrint("[injlib]: Postponing injection (%wZ)\n", FullImageName);
        return;
      }
    }

#endif

    //
    // All necessary DLLs are loaded - perform the injection.
    //
    // Note that injection is done via kernel-mode APC, because
    // InjInject calls ZwMapViewOfSection and MapViewOfSection
    // might be already on the callstack.  Because MapViewOfSection
    // locks the EPROCESS->AddressCreationLock, we would be risking
    // deadlock by calling InjInject directly.
    //

#if defined(INJ_CONFIG_SUPPORTS_WOW64)
    InjDbgPrint("[injlib]: Injecting (PID: %u, Wow64: %s, Name: '%s')\n",
                (ULONG)(ULONG_PTR)ProcessId,
                PsGetProcessWow64Process(PsGetCurrentProcess()) ? "TRUE" : "FALSE",
                PsGetProcessImageFileName(PsGetCurrentProcess()));
#else
    InjDbgPrint("[injlib]: Injecting (PID: %u, Name: '%s')\n",
                (ULONG)(ULONG_PTR)ProcessId,
                PsGetProcessImageFileName(PsGetCurrentProcess()));

#endif

    InjpQueueApc(KernelMode,
                 &InjpInjectApcNormalRoutine,
                 InjectionInfo,
                 NULL,
                 NULL);

    //
    // Mark that this process is injected.
    //

    InjectionInfo->IsInjected = TRUE;
  }
}

```

`src/injlib/injlib.h`:

```h
#pragma once
#include <ntddk.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#if DBG
#  define InjDbgPrint(Format, ...)  \
    DbgPrintEx(DPFLTR_IHVDRIVER_ID,         \
               DPFLTR_ERROR_LEVEL,          \
               Format,                      \
               __VA_ARGS__)
#else
#  define InjDbgPrint(Format, ...)
#endif

//////////////////////////////////////////////////////////////////////////
// Enumerations.
//////////////////////////////////////////////////////////////////////////

typedef enum _INJ_ARCHITECTURE
{
  InjArchitectureX86,
  InjArchitectureX64,
  InjArchitectureARM32,
  InjArchitectureARM64,
  InjArchitectureMax,

#if defined(_M_IX86)
  InjArchitectureNative = InjArchitectureX86
#elif defined (_M_AMD64)
  InjArchitectureNative = InjArchitectureX64
#elif defined (_M_ARM64)
  InjArchitectureNative = InjArchitectureARM64
#endif
} INJ_ARCHITECTURE;

typedef enum _INJ_METHOD
{
  //
  // Inject process by executing short "shellcode" which
  // calls LdrLoadDll.
  // This method always loads DLL of the same architecture
  // as the process.
  //

  InjMethodThunk,

  //
  // Inject process by directly setting LdrLoadDll as the
  // user-mode APC routine.
  // This method always loads x64 DLL into the process.
  //
  // N.B. Available only on x64.
  //

  InjMethodThunkless,

  //
  // Inject Wow64 process by redirecting path of the "wow64log.dll"
  // to the path of the "injdll".  Native processes are injected
  // as if the "thunk method" was selected (InjMethodThunk).
  //
  // This method always loads DLL of the same architecture
  // as the OS into the process.
  //

  InjMethodWow64LogReparse,
} INJ_METHOD;

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _INJ_SETTINGS
{
  //
  // Paths to the inject DLLs for each architecture.
  // Unsupported architectures (either by OS or the
  // method) can have empty string.
  //

  UNICODE_STRING  DllPath[InjArchitectureMax];

  //
  // Injection method.
  //

  INJ_METHOD      Method;
} INJ_SETTINGS, *PINJ_SETTINGS;

typedef struct _INJ_INJECTION_INFO
{
  LIST_ENTRY  ListEntry;

  //
  // Process ID.
  //

  HANDLE      ProcessId;

  //
  // Combination of INJ_SYSTEM_DLL flags indicating
  // which DLLs has been already loaded into this
  // process.
  //

  ULONG       LoadedDlls;

  //
  // If true, the process has been already injected.
  //

  BOOLEAN     IsInjected;

  //
  // If true, trigger of the queued user APC will be
  // immediately forced upon next kernel->user transition.
  //

  BOOLEAN     ForceUserApc;

  //
  // Address of LdrLoadDll routine within ntdll.dll
  // (which ntdll.dll is selected is based on the INJ_METHOD).
  //

  PVOID       LdrLoadDllRoutineAddress;

  //
  // Injection method.
  //

  INJ_METHOD  Method;
} INJ_INJECTION_INFO, *PINJ_INJECTION_INFO;

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
InjInitialize(
  _In_ PDRIVER_OBJECT DriverObject,
  _In_ PUNICODE_STRING RegistryPath,
  _In_ PINJ_SETTINGS Settings
  );

VOID
NTAPI
InjDestroy(
  VOID
  );

NTSTATUS
NTAPI
InjCreateInjectionInfo(
  _In_opt_ PINJ_INJECTION_INFO* InjectionInfo,
  _In_ HANDLE ProcessId
  );

VOID
NTAPI
InjRemoveInjectionInfo(
  _In_ PINJ_INJECTION_INFO InjectionInfo,
  _In_ BOOLEAN FreeMemory
  );

VOID
NTAPI
InjRemoveInjectionInfoByProcessId(
  _In_ HANDLE ProcessId,
  _In_ BOOLEAN FreeMemory
  );

PINJ_INJECTION_INFO
NTAPI
InjFindInjectionInfo(
  _In_ HANDLE ProcessId
  );

BOOLEAN
NTAPI
InjCanInject(
  _In_ PINJ_INJECTION_INFO InjectionInfo
  );

NTSTATUS
NTAPI
InjInject(
  _In_ PINJ_INJECTION_INFO InjectionInfo
  );

//////////////////////////////////////////////////////////////////////////
// Notify routines.
//////////////////////////////////////////////////////////////////////////

VOID
NTAPI
InjCreateProcessNotifyRoutineEx(
  _Inout_ PEPROCESS Process,
  _In_ HANDLE ProcessId,
  _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
  );

VOID
NTAPI
InjLoadImageNotifyRoutine(
  _In_opt_ PUNICODE_STRING FullImageName,
  _In_ HANDLE ProcessId,
  _In_ PIMAGE_INFO ImageInfo
  );

#ifdef __cplusplus
}
#endif

```

`src/injlib/injlib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- ProjectConfigurations -->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <!-- Common settings -->
  <PropertyGroup Label="Globals">
    <RootNamespace>injlib</RootNamespace>
    <ProjectGuid>{E2ABAE21-2862-4356-BA49-28C060878D76}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <DisableSpecificWarnings>4201;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <!--                     4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings) -->
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
    <Lib>
      <LinkTimeCodeGeneration Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">true</LinkTimeCodeGeneration>
    </Lib>
  </ItemDefinitionGroup>
  <!-- Debug -->
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
  </ItemDefinitionGroup>
  <!-- Release -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">FltMgr.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
    </Link>
    <Lib>
      <LinkTimeCodeGeneration Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">true</LinkTimeCodeGeneration>
    </Lib>
    <Lib>
      <LinkTimeCodeGeneration Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</LinkTimeCodeGeneration>
    </Lib>
    <Lib>
      <LinkTimeCodeGeneration Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</LinkTimeCodeGeneration>
    </Lib>
  </ItemDefinitionGroup>
  <!-- Targets -->
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <!-- Items -->
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="injlib.c" />
    <ClCompile Include="reparse.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="injlib.h" />
  </ItemGroup>
</Project>
```

`src/injlib/injlib.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="reparse.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="injlib.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="injlib.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/injlib/reparse.c`:

```c
#include <fltKernel.h>

#include "injlib.h"

//
// Code taken from the Windows-driver-samples github repository.
// https://github.com/Microsoft/Windows-driver-samples/blob/master/filesys/miniFilter/simrep/simrep.c
//

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define SIMREP_STRING_TAG            'tSpR'

#if DBG

#define DEBUG_TRACE_ERROR                               0x00000001  // Errors - whenever we return a failure code
#define DEBUG_TRACE_LOAD_UNLOAD                         0x00000002  // Loading/unloading of the filter
#define DEBUG_TRACE_INSTANCES                           0x00000004  // Attach / detach of instances

#define DEBUG_TRACE_REPARSE_OPERATIONS                  0x00000008  // Operations that are performed to determine if we should return STATUS_REPARSE
#define DEBUG_TRACE_REPARSED_OPERATIONS                 0x00000010  // Operations that return STATUS_REPARSE
#define DEBUG_TRACE_REPARSED_REISSUE                    0X00000020  // Operations that need to be reissued with an IRP.

#define DEBUG_TRACE_NAME_OPERATIONS                     0x00000040  // Operations involving name provider callbacks

#define DEBUG_TRACE_RENAME_REDIRECTION_OPERATIONS       0x00000080  // Operations involving rename or hardlink redirection

#define DEBUG_TRACE_ALL_IO                              0x00000100  // All IO operations tracked by this filter

#define DEBUG_TRACE_ALL                                 0xFFFFFFFF  // All flags

#define DebugTrace(Level, Data)                     \
/*  if ((Level) & Globals.DebugLevel) {          */ \
        DbgPrint Data;                              \
/*  }                                            */

#else

#define DebugTrace(Level, Data)             {NOTHING;}

#endif

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

//
//  Functions that provide string allocation support
//

_When_(return==0, _Post_satisfies_(String->Buffer != NULL))
NTSTATUS
NTAPI
SimRepAllocateUnicodeString (
    _Inout_ PUNICODE_STRING String
    );

VOID
NTAPI
SimRepFreeUnicodeString (
    _Inout_ PUNICODE_STRING String
    );

BOOLEAN
NTAPI
SimRepCompareMapping(
    _In_ PFLT_FILE_NAME_INFORMATION NameInfo,
    _In_ PUNICODE_STRING MappingPath,
    _In_ BOOLEAN IgnoreCase,
    _Out_opt_ PBOOLEAN ExactMatch
    );

NTSTATUS
NTAPI
SimRepMungeName(
    _In_ PFLT_FILE_NAME_INFORMATION NameInfo,
    _In_ PUNICODE_STRING SubPath,
    _In_ PUNICODE_STRING NewSubPath,
    _In_ BOOLEAN IgnoreCase,
    _In_ BOOLEAN ExactMatch,
    _Out_ PUNICODE_STRING MungedPath
    );

//
//  Functions that handle instance setup/cleanup
//

NTSTATUS
NTAPI
SimRepInstanceSetup (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
    );

NTSTATUS
NTAPI
SimRepInstanceQueryTeardown (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
    );

//
//  Functions that track operations on the volume
//

FLT_PREOP_CALLBACK_STATUS
NTAPI
SimRepPreCreate(
  _Inout_ PFLT_CALLBACK_DATA Cbd,
  _In_ PCFLT_RELATED_OBJECTS FltObjects,
  _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
  );

//
// Public functions.
//

NTSTATUS
NTAPI
SimRepInitialize(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    );

NTSTATUS
NTAPI
SimRepDestroy(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
    );

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

UNICODE_STRING OldName = RTL_CONSTANT_STRING(L"\\Windows\\System32\\wow64log.dll");
UNICODE_STRING NewName;  // Set up in SimRepInitialize

//
// Filter callback routines
//

FLT_OPERATION_REGISTRATION Callbacks[] = {
    { IRP_MJ_CREATE,
        FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO,
        SimRepPreCreate,
        NULL },

    { IRP_MJ_OPERATION_END }
};

//
// Filter registration data structure
//

FLT_REGISTRATION FilterRegistration = {
    sizeof( FLT_REGISTRATION ),                     //  Size
    FLT_REGISTRATION_VERSION,                       //  Version
    0,                                              //  Flags
    NULL,                                           //  Context
    Callbacks,                                      //  Operation callbacks
    SimRepDestroy,                                  //  Filters unload routine
    SimRepInstanceSetup,                            //  InstanceSetup routine
    SimRepInstanceQueryTeardown,                    //  InstanceQueryTeardown routine
    NULL,                                           //  InstanceTeardownStart routine
    NULL,                                           //  InstanceTeardownComplete routine
    NULL,                                           //  Filename generation support callback
    NULL,                                           //  Filename normalization support callback
    NULL,                                           //  Normalize name component cleanup callback
    NULL,                                           //  Transaction notification callback
    NULL                                            //  Filename normalization support callback
};

PFLT_FILTER Filter;

PDRIVER_UNLOAD PreviousDriverDestroy;
PDRIVER_OBJECT GlobalDriverObject;

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

_When_(return==0, _Post_satisfies_(String->Buffer != NULL))
NTSTATUS
NTAPI
SimRepAllocateUnicodeString (
    _Inout_ PUNICODE_STRING String
    )
/*++
Routine Description:
    This routine allocates a unicode string
Arguments:
    Size - the size in bytes needed for the string buffer
    String - supplies the size of the string to be allocated in the MaximumLength field
             return the unicode string
Return Value:
    STATUS_SUCCESS                  - success
    STATUS_INSUFFICIENT_RESOURCES   - failure
--*/
{

    PAGED_CODE();

    String->Buffer = ExAllocatePoolWithTag( NonPagedPool,
                                            String->MaximumLength,
                                            SIMREP_STRING_TAG );

    if (String->Buffer == NULL) {

        DebugTrace( DEBUG_TRACE_ERROR,
                    ("[SimRep]: Failed to allocate unicode string of size 0x%x\n",
                    String->MaximumLength) );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    String->Length = 0;

    return STATUS_SUCCESS;
}

VOID
NTAPI
SimRepFreeUnicodeString (
    _Inout_ PUNICODE_STRING String
    )
/*++
Routine Description:
    This routine frees a unicode string
Arguments:
    String - supplies the string to be freed
Return Value:
    None
--*/
{
    PAGED_CODE();

    if (String->Buffer) {

        ExFreePoolWithTag( String->Buffer,
                           SIMREP_STRING_TAG );
        String->Buffer = NULL;
    }

    String->Length = String->MaximumLength = 0;
    String->Buffer = NULL;
}

BOOLEAN
NTAPI
SimRepCompareMapping(
    _In_ PFLT_FILE_NAME_INFORMATION NameInfo,
    _In_ PUNICODE_STRING MappingPath,
    _In_ BOOLEAN IgnoreCase,
    _Out_opt_ PBOOLEAN ExactMatch
    )
/*++
Routine Description:
    This routine will compare the file specified by the
    name information structure to the given mapping path
    to determine if the file is the mapping path itself
    or a child of the mapping path.
Arguments:
    NameInfo - Pointer to the name information for the file.
    MappingPath - The mapping path to compare against.
    IgnoreCase - If TRUE do a case insenstive comparison.
    ExactMatch - If supplied receives TRUE if the name exactly
                 matches the mapping path.
Return Value:
    TRUE - the file matches the mapping path
    FALSE - the file is not in the mapping path
--*/
{
    UNICODE_STRING fileName;
    BOOLEAN match;
    BOOLEAN exactMatch;

    PAGED_CODE();

    //
    //  The NameInfo parameter is assumed to have been parsed
    //

    NT_ASSERT (FlagOn(NameInfo->NamesParsed, FLTFL_FILE_NAME_PARSED_FINAL_COMPONENT) &&
               FlagOn(NameInfo->NamesParsed, FLTFL_FILE_NAME_PARSED_EXTENSION) &&
               FlagOn(NameInfo->NamesParsed, FLTFL_FILE_NAME_PARSED_STREAM) &&
               FlagOn(NameInfo->NamesParsed, FLTFL_FILE_NAME_PARSED_PARENT_DIR));

    //
    //  Point filename to the name of the file, excluding the name of the volume
    //

    NT_ASSERT( NameInfo->Name.Buffer == NameInfo->Volume.Buffer );
    NT_ASSERT( NameInfo->Name.Length >= NameInfo->Volume.Length);

    match = FALSE;
    exactMatch = FALSE;
    fileName.Buffer = Add2Ptr( NameInfo->Name.Buffer, NameInfo->Volume.Length );
    fileName.MaximumLength = NameInfo->Name.Length - NameInfo->Volume.Length;
    fileName.Length = fileName.MaximumLength;

    //
    //  Check if the filename matches this mapping entry (is the mapping
    //  entry itself or some child directory of the mapping entry)
    //

    if (RtlPrefixUnicodeString( MappingPath, &fileName, IgnoreCase )) {

        if (fileName.Length == MappingPath->Length) {

            //
            //  This path is the mapping itself
            //

            match = TRUE;

            exactMatch = TRUE;

        } else if (fileName.Buffer[(MappingPath->Length/sizeof( WCHAR ))] == OBJ_NAME_PATH_SEPARATOR) {

            //
            //  This path is a child of the mapping
            //

            match = TRUE;
        }

        //
        //  No match here means the path simply overlaps the mapping like
        //  \a\b\c overlaps \a\b\cd.txt
        //

    }

    if (ARGUMENT_PRESENT( ExactMatch )) {
        *ExactMatch = exactMatch;
    }

    return match;
}

NTSTATUS
NTAPI
SimRepMungeName(
    _In_ PFLT_FILE_NAME_INFORMATION NameInfo,
    _In_ PUNICODE_STRING SubPath,
    _In_ PUNICODE_STRING NewSubPath,
    _In_ BOOLEAN IgnoreCase,
    _In_ BOOLEAN ExactMatch,
    _Out_ PUNICODE_STRING MungedPath
    )
/*++
Routine Description:
    This routine will create a new path by munginging a new subpath
    over and existing subpath.
Arguments:
    NameInfo - Pointer to the name information for the file.
    SubPath - The path to munge.
    IgnoreCase - If TRUE do a case insenstive comparison.
    ExactMatch - If TRUE only proceed if the whole path will be replaced
    MungedPath - A unicode string to received the munged path created. The
                 buffer of the string will be allocated in this function.
Return Value:
    STATUS_SUCCESS - the path was successfully munged
    STATUS_NOT_FOUND - the SubPath was not found or is not an exact match
    An appropriate NTSTATUS error otherwise.
--*/
{
    NTSTATUS status = STATUS_NOT_FOUND;
    BOOLEAN match;
    BOOLEAN exactMatch;
    USHORT length;

    PAGED_CODE();

    match = SimRepCompareMapping( NameInfo, SubPath, IgnoreCase, &exactMatch );

    if (match) {

        InjDbgPrint("[SimRep]: match=%i, exactMatch=%i\n", match, exactMatch);

        if (ExactMatch && !exactMatch) {

            goto SimRepMungeNameCleanup;
        }

        NT_ASSERT( NameInfo->Name.Length >= SubPath->Length );

        length = NameInfo->Name.Length - SubPath->Length + NewSubPath->Length;

        RtlInitUnicodeString( MungedPath, NULL );

        MungedPath->MaximumLength = (USHORT)length;

        status = SimRepAllocateUnicodeString( MungedPath );

        if (!NT_SUCCESS( status )) {

            goto SimRepMungeNameCleanup;
        }

        //
        //  Copy the volume portion of the name (part of the name preceding the matching part)
        //

        RtlCopyUnicodeString( MungedPath, &NameInfo->Volume );

        //
        //  Copy the new file name in place of the matching part of the name
        //

        status = RtlAppendUnicodeStringToString( MungedPath, NewSubPath );

        NT_ASSERT( NT_SUCCESS( status ) );

        //
        //  Copy the portion of the name following the matching part of the name
        //

        RtlCopyMemory( Add2Ptr( MungedPath->Buffer, NameInfo->Volume.Length + NewSubPath->Length ),
                       Add2Ptr( NameInfo->Name.Buffer, NameInfo->Volume.Length + SubPath->Length ),
                       NameInfo->Name.Length - NameInfo->Volume.Length - SubPath->Length );

        //
        //  Compute the final length of the new name
        //

        MungedPath->Length = length;

    }

SimRepMungeNameCleanup:

    return status;
}

NTSTATUS
NTAPI
SimRepInstanceSetup (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
    )
/*++
Routine Description:
    This routine is called whenever a new instance is created on a volume. This
    gives us a chance to decide if we need to attach to this volume or not.
    SimRep does not attach on automatic attachment, but will attach when asked
    manually.
Arguments:
    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.
    Flags - Flags describing the reason for this attach request.
Return Value:
    STATUS_SUCCESS - attach
    STATUS_FLT_DO_NOT_ATTACH - do not attach
--*/
{

    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );
    UNREFERENCED_PARAMETER( VolumeDeviceType );
    UNREFERENCED_PARAMETER( VolumeFilesystemType );

    PAGED_CODE();

    /*
    if ( FlagOn( Flags, FLTFL_INSTANCE_SETUP_AUTOMATIC_ATTACHMENT ) ) {

        //
        //  Do not automatically attach to a volume.
        //

        DebugTrace( DEBUG_TRACE_INSTANCES,
                    ("[Simrep]: Instance setup skipped (Volume = %p, Instance = %p)\n",
                    FltObjects->Volume,
                    FltObjects->Instance) );

        return STATUS_FLT_DO_NOT_ATTACH;
    }
    */

    //
    //  Attach on manual attachment.
    //

    DebugTrace( DEBUG_TRACE_INSTANCES,
                ("[SimRep]: Instance setup started (Volume = %p, Instance = %p)\n",
                 FltObjects->Volume,
                 FltObjects->Instance) );


    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
SimRepInstanceQueryTeardown (
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
    )
/*++
Routine Description:
    This is called when an instance is being manually deleted by a
    call to FltDetachVolume or FilterDetach thereby giving us a
    chance to fail that detach request. SimRep only implements it
    because otherwise calls to FltDetachVolume or FilterDetach would
    fail to detach.
Arguments:
    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance and its associated volume.
    Flags - Indicating where this detach request came from.
Return Value:
    Returns the status of this operation.
--*/
{
    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    DebugTrace( DEBUG_TRACE_INSTANCES,
                ("[SimRep]: Instance query teadown ended (Instance = %p)\n",
                 FltObjects->Instance) );

    return STATUS_SUCCESS;
}

FLT_PREOP_CALLBACK_STATUS
NTAPI
SimRepPreCreate (
    _Inout_ PFLT_CALLBACK_DATA Cbd,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID *CompletionContext
    )
/*++
Routine Description:
    This routine does the work for SimRep sample. SimRepPreCreate is called in
    the pre-operation path for IRP_MJ_CREATE and IRP_MJ_NETWORK_QUERY_OPEN.
    The function queries the requested file name for  the create and compares
    it to the mapping path. If the file is down the "old mapping path", the
    filter checks to see if the request is fast io based. If it is we cannot
    reparse the create because fast io does not support STATUS_REPARSE.
    Instead we return FLT_PREOP_DISALLOW_FASTIO to force the io to be reissued
    on the IRP path. If the create is IRP based, then we replace the file
    object's file name field with a new path based on the "new mapping path".
    This is pageable because it could not be called on the paging path
Arguments:
    Cbd - Pointer to the filter callbackData that is passed to us.
    FltObjects - Pointer to the FLT_RELATED_OBJECTS data structure containing
        opaque handles to this filter, instance, its associated volume and
        file object.
    CompletionContext - The context for the completion routine for this
        operation.
Return Value:
    The return value is the status of the operation.
--*/
{
    PFLT_FILE_NAME_INFORMATION nameInfo = NULL;
    NTSTATUS status;
    FLT_PREOP_CALLBACK_STATUS callbackStatus;
    UNICODE_STRING newFileName;

    UNREFERENCED_PARAMETER( FltObjects );
    UNREFERENCED_PARAMETER( CompletionContext );

    PAGED_CODE();

    DebugTrace( DEBUG_TRACE_ALL_IO,
                ("[SimRep]: SimRepPreCreate -> Enter (Cbd = %p, FileObject = %p)\n",
                 Cbd,
                 FltObjects->FileObject) );


    //
    // Initialize defaults
    //

    status = STATUS_SUCCESS;
    callbackStatus = FLT_PREOP_SUCCESS_NO_CALLBACK; // pass through - default is no post op callback

    RtlInitUnicodeString( &newFileName, NULL );

    //
    // We only registered for this irp, so thats all we better get!
    //

    NT_ASSERT( Cbd->Iopb->MajorFunction == IRP_MJ_CREATE );

    //
    //  Check if this is a paging file as we don't want to redirect
    //  the location of the paging file.
    //

    if (FlagOn( Cbd->Iopb->OperationFlags, SL_OPEN_PAGING_FILE )) {

        DebugTrace( DEBUG_TRACE_ALL_IO,
                    ("[SimRep]: SimRepPreCreate -> Ignoring paging file open (Cbd = %p, FileObject = %p)\n",
                     Cbd,
                     FltObjects->FileObject) );

        goto SimRepPreCreateCleanup;
    }

    //
    //  We are not allowing volume opens to be reparsed in the sample.
    //

    if (FlagOn( Cbd->Iopb->TargetFileObject->Flags, FO_VOLUME_OPEN )) {

        DebugTrace( DEBUG_TRACE_ALL_IO,
                    ("[SimRep]: SimRepPreCreate -> Ignoring volume open (Cbd = %p, FileObject = %p)\n",
                     Cbd,
                     FltObjects->FileObject) );

        goto SimRepPreCreateCleanup;

    }

    //
    //  SimRep does not honor the FILE_OPEN_REPARSE_POINT create option. For a
    //  symbolic the caller would pass this flag, for example, in order to open
    //  the link for deletion. There is no concept of deleting the mapping for
    //  this filter so it is not clear what the purpose of honoring this flag
    //  would be.
    //

    //
    //  Don't reparse an open by ID because it is not possible to determine create path intent.
    //

    if (FlagOn( Cbd->Iopb->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

        goto SimRepPreCreateCleanup;
    }

    /*
    if (FlagOn( Cbd->Iopb->OperationFlags, SL_OPEN_TARGET_DIRECTORY ) &&
        !Globals.RemapRenamesAndLinks) {

        //
        //  This is a prelude to a rename or hard link creation but the filter
        //  is NOT configured to filter these operations. To perform the operation
        //  successfully and in a consistent manner this create must not trigger
        //  a reparse. Pass through the create without attempting any redirection.
        //

        goto SimRepPreCreateCleanup;

    }
    */

    //  Get the name information.
    //

    if (FlagOn( Cbd->Iopb->OperationFlags, SL_OPEN_TARGET_DIRECTORY )) {

        //
        //  The SL_OPEN_TARGET_DIRECTORY flag indicates the caller is attempting
        //  to open the target of a rename or hard link creation operation. We
        //  must clear this flag when asking fltmgr for the name or the result
        //  will not include the final component. We need the full path in order
        //  to compare the name to our mapping.
        //

        ClearFlag( Cbd->Iopb->OperationFlags, SL_OPEN_TARGET_DIRECTORY );

        DebugTrace( DEBUG_TRACE_RENAME_REDIRECTION_OPERATIONS,
                    ("[SimRep]: SimRepPreCreate -> Clearing SL_OPEN_TARGET_DIRECTORY for %wZ (Cbd = %p, FileObject = %p)\n",
                     &nameInfo->Name,
                     Cbd,
                     FltObjects->FileObject) );


        //
        //  Get the filename as it appears below this filter. Note that we use
        //  FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY when querying the filename
        //  so that the filename as it appears below this filter does not end up
        //  in filter manager's name cache.
        //

        status = FltGetFileNameInformation( Cbd,
                                            FLT_FILE_NAME_OPENED | FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY,
                                            &nameInfo );

        //
        //  Restore the SL_OPEN_TARGET_DIRECTORY flag so the create will proceed
        //  for the target. The file systems depend on this flag being set in
        //  the target create in order for the subsequent SET_INFORMATION
        //  operation to proceed correctly.
        //

        SetFlag( Cbd->Iopb->OperationFlags, SL_OPEN_TARGET_DIRECTORY );


    } else {

        //
        //  Note that we use FLT_FILE_NAME_QUERY_DEFAULT when querying the
        //  filename. In the precreate the filename should not be in filter
        //  manager's name cache so there is no point looking there.
        //

        status = FltGetFileNameInformation( Cbd,
                                            FLT_FILE_NAME_OPENED |
                                            FLT_FILE_NAME_QUERY_DEFAULT,
                                            &nameInfo );
    }

    if (!NT_SUCCESS( status )) {

        DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS | DEBUG_TRACE_ERROR,
                    ("[SimRep]: SimRepPreCreate -> Failed to get name information (Cbd = %p, FileObject = %p)\n",
                     Cbd,
                     FltObjects->FileObject) );

        goto SimRepPreCreateCleanup;
    }


    DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS,
                ("[SimRep]: SimRepPreCreate -> Processing create for file %wZ (Cbd = %p, FileObject = %p)\n",
                 &nameInfo->Name,
                 Cbd,
                 FltObjects->FileObject) );

    //
    //  Parse the filename information
    //

    status = FltParseFileNameInformation( nameInfo );
    if (!NT_SUCCESS( status )) {

        DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS | DEBUG_TRACE_ERROR,
                    ("[SimRep]: SimRepPreCreate -> Failed to parse name information for file %wZ (Cbd = %p, FileObject = %p)\n",
                     &nameInfo->Name,
                     Cbd,
                     FltObjects->FileObject) );

        goto SimRepPreCreateCleanup;
    }

    //
    //  Munge the path from the old mapping to new mapping if the query overlaps
    //  the mapping path. Note: if the create is case sensitive this comparison
    //  must be as well.
    //

    status = SimRepMungeName( nameInfo,
                              &OldName,
                              &NewName,
                              !FlagOn( Cbd->Iopb->OperationFlags, SL_CASE_SENSITIVE ),
                              FALSE,
                              &newFileName);

    if (!NT_SUCCESS( status )) {

        if (status == STATUS_NOT_FOUND) {
            status = STATUS_SUCCESS;
        }

        goto SimRepPreCreateCleanup;
    }

    DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS,
                ("[SimRep]: SimRepPreCreate -> File name %wZ matches mapping. (Cbd = %p, FileObject = %p)\n"
                 "\tMapping.OldFileName = %wZ\n"
                 "\tMapping.NewFileName = %wZ\n",
                 &nameInfo->Name,
                 Cbd,
                 FltObjects->FileObject,
                 OldName,
                 NewName) );


    //
    //  Switch names
    //

    status = IoReplaceFileObjectName( Cbd->Iopb->TargetFileObject,
                                      newFileName.Buffer,
                                      newFileName.Length );

    if ( !NT_SUCCESS( status )) {

        DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS | DEBUG_TRACE_ERROR,
                    ("[SimRep]: SimRepPreCreate -> Failed to allocate string for file %wZ (Cbd = %p, FileObject = %p)\n",
                    &nameInfo->Name,
                    Cbd,
                    FltObjects->FileObject ));

        goto SimRepPreCreateCleanup;
    }

    //
    //  Set the status to STATUS_REPARSE
    //

    status = STATUS_REPARSE;


    DebugTrace( DEBUG_TRACE_REPARSE_OPERATIONS | DEBUG_TRACE_REPARSED_OPERATIONS,
                ("[SimRep]: SimRepPreCreate -> Returning STATUS_REPARSE for file %wZ. (Cbd = %p, FileObject = %p)\n"
                 "\tNewName = %wZ\n",
                 &nameInfo->Name,
                 Cbd,
                 FltObjects->FileObject,
                 &newFileName) );

SimRepPreCreateCleanup:

    //
    //  Release the references we have acquired
    //

    SimRepFreeUnicodeString( &newFileName );

    if (nameInfo != NULL) {

        FltReleaseFileNameInformation( nameInfo );
    }

    if (status == STATUS_REPARSE) {

        //
        //  Reparse the open
        //

        Cbd->IoStatus.Status = STATUS_REPARSE;
        Cbd->IoStatus.Information = IO_REPARSE;
        callbackStatus = FLT_PREOP_COMPLETE;

    } else if (!NT_SUCCESS( status )) {

        //
        //  An error occurred, fail the open
        //

        DebugTrace( DEBUG_TRACE_ERROR,
                    ("[SimRep]: SimRepPreCreate -> Failed with status 0x%x \n",
                    status) );

        Cbd->IoStatus.Status = status;
        callbackStatus = FLT_PREOP_COMPLETE;
    }

    DebugTrace( DEBUG_TRACE_ALL_IO,
                ("[SimRep]: SimRepPreCreate -> Exit (Cbd = %p, FileObject = %p)\n",
                 Cbd,
                 FltObjects->FileObject) );

    return callbackStatus;

}


//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

#define SIMREP_INSTANCE_NAME        L"Reparse"
#define SIMREP_INSTANCE_ALTITUDE    L"370040"

NTSTATUS
NTAPI
SimRepInitializeRegistry(
    _In_ PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;

    //
    // ...\CurrentControlSet\Services\[DriverName]\Instances
    //

    UNICODE_STRING InstancesSubkeyString = RTL_CONSTANT_STRING(L"\\Instances");
    UNICODE_STRING InstancesSubkeyPath;
    InstancesSubkeyPath.MaximumLength = RegistryPath->Length + InstancesSubkeyString.Length;
    Status = SimRepAllocateUnicodeString(&InstancesSubkeyPath);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorInstancesSubkeyPath;
    }

    RtlAppendUnicodeStringToString(&InstancesSubkeyPath, RegistryPath);
    RtlAppendUnicodeStringToString(&InstancesSubkeyPath, &InstancesSubkeyString);

    InitializeObjectAttributes(&ObjectAttributes,
                               &InstancesSubkeyPath,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    HANDLE InstancesSubkeyHandle;
    Status = ZwCreateKey(&InstancesSubkeyHandle,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorInstanceSubkeyHandle;
    }

    //
    // ...\CurrentControlSet\Services\[DriverName]\Instances\Reparse
    //

    UNICODE_STRING ReparseSubkeyString = RTL_CONSTANT_STRING(L"\\" SIMREP_INSTANCE_NAME);
    UNICODE_STRING ReparseSubkeyPath;
    ReparseSubkeyPath.MaximumLength = InstancesSubkeyPath.Length + ReparseSubkeyString.Length;
    Status = SimRepAllocateUnicodeString(&ReparseSubkeyPath);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorReparseSubkeyPath;
    }

    RtlAppendUnicodeStringToString(&ReparseSubkeyPath, &InstancesSubkeyPath);
    RtlAppendUnicodeStringToString(&ReparseSubkeyPath, &ReparseSubkeyString);


    InitializeObjectAttributes(&ObjectAttributes,
                               &ReparseSubkeyPath,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    HANDLE ReparseSubkeyHandle;
    Status = ZwCreateKey(&ReparseSubkeyHandle,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorReparseSubkeyHandle;
    }

    //
    // ...\CurrentControlSet\Services\[DriverName]\Instances\DefaultInstance
    //

    UNICODE_STRING DefaultInstanceString = RTL_CONSTANT_STRING(L"DefaultInstance");
    WCHAR DefaultInstanceValue[] = SIMREP_INSTANCE_NAME;

    Status = ZwSetValueKey(InstancesSubkeyHandle,
                           &DefaultInstanceString,
                           0,
                           REG_SZ,
                           DefaultInstanceValue,
                           sizeof(DefaultInstanceValue));

    if (!NT_SUCCESS(Status))
    {
        goto ErrorSetValueKey;
    }

    //
    // ...\CurrentControlSet\Services\[DriverName]\Instances\Reparse\Altitude
    //

    UNICODE_STRING AltitudeString = RTL_CONSTANT_STRING(L"Altitude");
    WCHAR AltitudeValue[] = SIMREP_INSTANCE_ALTITUDE;

    Status = ZwSetValueKey(ReparseSubkeyHandle,
                           &AltitudeString,
                           0,
                           REG_SZ,
                           AltitudeValue,
                           sizeof(AltitudeValue));

    if (!NT_SUCCESS(Status))
    {
        goto ErrorSetValueKey;
    }

    //
    // ...\CurrentControlSet\Services\[DriverName]\Instances\Reparse\Flags
    //

    UNICODE_STRING FlagsString = RTL_CONSTANT_STRING(L"Flags");
    ULONG FlagsValue = 0;

    Status = ZwSetValueKey(ReparseSubkeyHandle,
                           &FlagsString,
                           0,
                           REG_DWORD,
                           &FlagsValue,
                           sizeof(FlagsValue));

ErrorSetValueKey:
    ZwClose(ReparseSubkeyHandle);

ErrorReparseSubkeyHandle:
    ZwClose(InstancesSubkeyHandle);

ErrorInstanceSubkeyHandle:
    SimRepFreeUnicodeString(&ReparseSubkeyPath);

ErrorReparseSubkeyPath:
    SimRepFreeUnicodeString(&InstancesSubkeyPath);

ErrorInstancesSubkeyPath:
    return Status;
}

NTSTATUS
NTAPI
SimRepInitialize(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    PFLT_REGISTRATION Registration;

    //
    //  Set path to the native DLL.
    //

    extern UNICODE_STRING InjDllPath[InjArchitectureMax];

    PUNICODE_STRING NativeInjDllPath = &InjDllPath[InjArchitectureNative];

    if (NativeInjDllPath->Length == 0) {

        InjDbgPrint("[SimRep]: Invalid native DLL path!\n");

        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Initialize registry keys for the mini-filter.
    //

    status = SimRepInitializeRegistry(RegistryPath);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    //  Skip the drive name (such as "C:").
    //

    RtlInitUnicodeString(&NewName, InjDllPath[InjArchitectureNative].Buffer + 2);

    InjDbgPrint("[SimRep]: NewName = '%wZ'\n", &NewName);

    //
    //  Set default global configuration
    //

    Registration = &FilterRegistration;

    status = FltRegisterFilter( DriverObject,
                                Registration,
                                &Filter );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    PreviousDriverDestroy = DriverObject->DriverUnload;
    GlobalDriverObject = DriverObject;

    //
    //  Start filtering I/O
    //

    status = FltStartFiltering( Filter );

    if (!NT_SUCCESS( status )) {
        FltUnregisterFilter( Filter );
    }

    return status;
}

NTSTATUS
NTAPI
SimRepDestroy(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
    )
/*++
Routine Description:
    This is the unload routine for this filter driver. This is called
    when the minifilter is about to be unloaded. SimRep can unload
    easily because it does not own any IOs. When the filter is unloaded
    existing reparsed creates will continue to work, but new creates will
    not be reparsed. This is fine from the filter's perspective, but could
    result in unexpected bahavior for apps.
Arguments:
    Flags - Indicating if this is a mandatory unload.
Return Value:
    Returns the final status of this operation.
--*/
{
    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    DebugTrace( DEBUG_TRACE_LOAD_UNLOAD,
                ("[SimRep]: Unloading driver\n") );

    if (Filter) {
        FltUnregisterFilter( Filter );

        Filter = NULL;

        if (PreviousDriverDestroy) {

            PreviousDriverDestroy( GlobalDriverObject );
            PreviousDriverDestroy = NULL;
            GlobalDriverObject = NULL;

        }
    }

    return STATUS_SUCCESS;
}

```