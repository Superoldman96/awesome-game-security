Project Path: arc_gmh5225_hiearchy-eac_lfn9_mxq

Source Tree:

```txt
arc_gmh5225_hiearchy-eac_lfn9_mxq
├── README.md
├── bins
│   ├── EasyAntiCheat.sys
│   └── README.md
└── hierarchy-eac
    ├── context.asm
    ├── eac.cpp
    ├── eac.hpp
    ├── hde64.cpp
    ├── hde64.hpp
    ├── hierarchy-eac.inf
    ├── hierarchy-eac.vcxproj
    ├── hierarchy-eac.vcxproj.filters
    ├── hierarchy-eac.vcxproj.user
    ├── main.cpp
    ├── stdafx.hpp
    ├── table64.hpp
    ├── utils.cpp
    ├── utils.hpp
    ├── vm.cpp
    └── vm.hpp

```

`README.md`:

```md
# hiearchy-eac
Bypassing EasyAntiCheat.sys self-integrity by abusing call hierarchy

# Writeup
Full write up can be found [here](https://bright.engineer/posts/easyanticheat-integrity/)

```

`hierarchy-eac/context.asm`:

```asm
.code

extern is_reloc:proc
vm_is_reloc PROC
	
	push rax
	push rcx
	push rbx
	push rdx
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15

	mov rcx, rsp
	pushfq

	sub rsp, 20h
	call is_reloc
	add rsp, 20h

	popfq

	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rdx
	pop rbx
	pop rcx
	pop rax

	ret

vm_is_reloc ENDP
END

```

`hierarchy-eac/eac.cpp`:

```cpp
#include "eac.hpp"

uint8_t *eac_instance_t::get_image_base()
{
	return static_cast<uint8_t *>( image_base );
}

uint32_t eac_instance_t::get_img_size()
{
	return image_size;
}

uint8_t *eac_instance_t::get_raw_image()
{
	return static_cast<uint8_t *>( image_copy );
}

bool eac_instance_t::mem_in_bounds( uint8_t *address )
{
	if ( address >= get_image_base() && address <= &get_image_base()[get_img_size()] )
		return true;

	return false;
}

bool eac_instance_t::mem_in_scn( uint8_t *address, uint32_t scn_type )
{
	const auto rva = address - static_cast<uint8_t *>( image_base );
	const auto scn_headers = IMAGE_FIRST_SECTION( nt_headers );

	for ( auto i = 0U; i < nt_headers->FileHeader.NumberOfSections; ++i )
	{
		const auto *c_section = &scn_headers[i];
		if ( !( c_section->Characteristics & scn_type ) )
			continue;

		if ( rva >= c_section->VirtualAddress &&
			rva <= static_cast<uint64_t>( c_section->VirtualAddress ) + c_section->Misc.VirtualSize )
			return true;
	}

	return false;
}

PIMAGE_NT_HEADERS eac_instance_t::get_nt_headers()
{
	return this->nt_headers;
}

void eac_instance_t::init( void *base, uint32_t size )
{
	image_base = base;
	image_size = size;

	if ( !image_base || !image_size )
		return;

	image_copy = ExAllocatePool( NonPagedPoolNx, image_size );
	if ( !image_copy )
		return;

	memcpy( image_copy, image_base, image_size );
	nt_headers = utils::get_nt_headers( reinterpret_cast<uint64_t>( image_base ) );
}

```

`hierarchy-eac/eac.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

class eac_instance_t
{
private:
    void *image_base = 0;
    void *image_copy = 0;

    uint32_t image_size = 0;

    PIMAGE_NT_HEADERS nt_headers = 0;

public:
    uint8_t *get_image_base();
    uint8_t *get_raw_image();
    uint32_t get_img_size();

    PIMAGE_NT_HEADERS get_nt_headers();

    bool mem_in_bounds( uint8_t *address );
    bool mem_in_scn( uint8_t *address, uint32_t scn_type );

    void init( void *base, uint32_t size );
};

```

`hierarchy-eac/hde64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.hpp"
#include "table64.hpp"
#include <ntifs.h>

unsigned int hde64_disasm( const void *code, hde64s *hs )
{
    uint8_t x, c, *p = ( uint8_t * )code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    memset( hs, 0, sizeof( hde64s ) );

    for ( x = 16; x; x-- )
        switch ( c = *p++ )
        {
        case 0xf3:
            hs->p_rep = c;
            pref |= PRE_F3;
            break;
        case 0xf2:
            hs->p_rep = c;
            pref |= PRE_F2;
            break;
        case 0xf0:
            hs->p_lock = c;
            pref |= PRE_LOCK;
            break;
        case 0x26:
        case 0x2e:
        case 0x36:
        case 0x3e:
        case 0x64:
        case 0x65:
            hs->p_seg = c;
            pref |= PRE_SEG;
            break;
        case 0x66:
            hs->p_66 = c;
            pref |= PRE_66;
            break;
        case 0x67:
            hs->p_67 = c;
            pref |= PRE_67;
            break;
        default:
            goto pref_done;
        }
pref_done:

    hs->flags = ( uint32_t )pref << 23;

    if ( !pref )
        pref |= PRE_NONE;

    if ( ( c & 0xf0 ) == 0x40 )
    {
        hs->flags |= F_PREFIX_REX;
        if ( ( hs->rex_w = ( c & 0xf ) >> 3 ) && ( *p & 0xf8 ) == 0xb8 )
            op64++;
        hs->rex_r = ( c & 7 ) >> 2;
        hs->rex_x = ( c & 3 ) >> 1;
        hs->rex_b = c & 1;
        if ( ( ( c = *p++ ) & 0xf0 ) == 0x40 )
        {
            opcode = c;
            goto error_opcode;
        }
    }

    if ( ( hs->opcode = c ) == 0x0f )
    {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    }
    else if ( c >= 0xa0 && c <= 0xa3 )
    {
        op64++;
        if ( pref & PRE_67 )
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ];

    if ( cflags == C_ERROR )
    {
    error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ( ( opcode & -3 ) == 0x24 )
            cflags++;
    }

    x = 0;
    if ( cflags & C_GROUP )
    {
        uint16_t t;
        t = *( uint16_t * )( ht + ( cflags & 0x7f ) );
        cflags = ( uint8_t )t;
        x = ( uint8_t )( t >> 8 );
    }

    if ( hs->opcode2 )
    {
        ht = hde64_table + DELTA_PREFIXES;
        if ( ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ] & pref )
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if ( cflags & C_MODRM )
    {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = ( c & 0x3f ) >> 3;

        if ( x && ( ( x << m_reg ) & 0x80 ) )
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if ( !hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf )
        {
            uint8_t t = opcode - 0xd9;
            if ( m_mod == 3 )
            {
                ht = hde64_table + DELTA_FPU_MODRM + t * 8;
                t = ht[ m_reg ] << m_rm;
            }
            else
            {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[ t ] << m_reg;
            }
            if ( t & 0x80 )
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if ( pref & PRE_LOCK )
        {
            if ( m_mod == 3 )
            {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            }
            else
            {
                uint8_t *table_end, op = opcode;
                if ( hs->opcode2 )
                {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                }
                else
                {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for ( ; ht != table_end; ht++ )
                    if ( *ht++ == op )
                    {
                        if ( !( ( *ht << m_reg ) & 0x80 ) )
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            no_lock_error:;
            }
        }

        if ( hs->opcode2 )
        {
            switch ( opcode )
            {
            case 0x20:
            case 0x22:
                m_mod = 3;
                if ( m_reg > 4 || m_reg == 1 )
                    goto error_operand;
                else
                    goto no_error_operand;
            case 0x21:
            case 0x23:
                m_mod = 3;
                if ( m_reg == 4 || m_reg == 5 )
                    goto error_operand;
                else
                    goto no_error_operand;
            }
        }
        else
        {
            switch ( opcode )
            {
            case 0x8c:
                if ( m_reg > 5 )
                    goto error_operand;
                else
                    goto no_error_operand;
            case 0x8e:
                if ( m_reg == 1 || m_reg > 5 )
                    goto error_operand;
                else
                    goto no_error_operand;
            }
        }

        if ( m_mod == 3 )
        {
            uint8_t *table_end;
            if ( hs->opcode2 )
            {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof( hde64_table ) - DELTA_OP2_ONLY_MEM;
            }
            else
            {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for ( ; ht != table_end; ht += 2 )
                if ( *ht++ == opcode )
                {
                    if ( *ht++ & pref && !( ( *ht << m_reg ) & 0x80 ) )
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        }
        else if ( hs->opcode2 )
        {
            switch ( opcode )
            {
            case 0x50:
            case 0xd7:
            case 0xf7:
                if ( pref & ( PRE_NONE | PRE_66 ) )
                    goto error_operand;
                break;
            case 0xd6:
                if ( pref & ( PRE_F2 | PRE_F3 ) )
                    goto error_operand;
                break;
            case 0xc5:
                goto error_operand;
            }
            goto no_error_operand;
        }
        else
            goto no_error_operand;

    error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
    no_error_operand:

        c = *p++;
        if ( m_reg <= 1 )
        {
            if ( opcode == 0xf6 )
                cflags |= C_IMM8;
            else if ( opcode == 0xf7 )
                cflags |= C_IMM_P66;
        }

        switch ( m_mod )
        {
        case 0:
            if ( pref & PRE_67 )
            {
                if ( m_rm == 6 )
                    disp_size = 2;
            }
            else if ( m_rm == 5 )
                disp_size = 4;
            break;
        case 1:
            disp_size = 1;
            break;
        case 2:
            disp_size = 2;
            if ( !( pref & PRE_67 ) )
                disp_size <<= 1;
        }

        if ( m_mod != 3 && m_rm == 4 )
        {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = ( c & 0x3f ) >> 3;
            if ( ( hs->sib_base = c & 7 ) == 5 && !( m_mod & 1 ) )
                disp_size = 4;
        }

        p--;
        switch ( disp_size )
        {
        case 1:
            hs->flags |= F_DISP8;
            hs->disp.disp8 = *p;
            break;
        case 2:
            hs->flags |= F_DISP16;
            hs->disp.disp16 = *( uint16_t * )p;
            break;
        case 4:
            hs->flags |= F_DISP32;
            hs->disp.disp32 = *( uint32_t * )p;
        }
        p += disp_size;
    }
    else if ( pref & PRE_LOCK )
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if ( cflags & C_IMM_P66 )
    {
        if ( cflags & C_REL32 )
        {
            if ( pref & PRE_66 )
            {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *( uint16_t * )p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if ( op64 )
        {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *( uint64_t * )p;
            p += 8;
        }
        else if ( !( pref & PRE_66 ) )
        {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *( uint32_t * )p;
            p += 4;
        }
        else
            goto imm16_ok;
    }

    if ( cflags & C_IMM16 )
    {
    imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *( uint16_t * )p;
        p += 2;
    }
    if ( cflags & C_IMM8 )
    {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if ( cflags & C_REL32 )
    {
    rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *( uint32_t * )p;
        p += 4;
    }
    else if ( cflags & C_REL8 )
    {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

disasm_done:

    if ( ( hs->len = ( uint8_t )( p - ( uint8_t * )code ) ) > 15 )
    {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return ( unsigned int )hs->len;
}

```

`hierarchy-eac/hde64.hpp`:

```hpp
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

#pragma once
#include "stdafx.hpp"

#define F_MODRM 0x00000001
#define F_SIB 0x00000002
#define F_IMM8 0x00000004
#define F_IMM16 0x00000008
#define F_IMM32 0x00000010
#define F_IMM64 0x00000020
#define F_DISP8 0x00000040
#define F_DISP16 0x00000080
#define F_DISP32 0x00000100
#define F_RELATIVE 0x00000200
#define F_ERROR 0x00001000
#define F_ERROR_OPCODE 0x00002000
#define F_ERROR_LENGTH 0x00004000
#define F_ERROR_LOCK 0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ 0x01000000
#define F_PREFIX_REPX 0x02000000
#define F_PREFIX_REP 0x03000000
#define F_PREFIX_66 0x04000000
#define F_PREFIX_67 0x08000000
#define F_PREFIX_LOCK 0x10000000
#define F_PREFIX_SEG 0x20000000
#define F_PREFIX_REX 0x40000000
#define F_PREFIX_ANY 0x7f000000

#define PREFIX_SEGMENT_CS 0x2e
#define PREFIX_SEGMENT_SS 0x36
#define PREFIX_SEGMENT_DS 0x3e
#define PREFIX_SEGMENT_ES 0x26
#define PREFIX_SEGMENT_FS 0x64
#define PREFIX_SEGMENT_GS 0x65
#define PREFIX_LOCK 0xf0
#define PREFIX_REPNZ 0xf2
#define PREFIX_REPX 0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack( push, 1 )

typedef struct
{
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union
    {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;

    union
    {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;

    uint32_t flags;
} hde64s;

#pragma pack( pop )

#ifdef __cplusplus
extern "C"
{
#endif

    unsigned int hde64_disasm( const void *code, hde64s *hs );

#ifdef __cplusplus
}

#endif
#endif

```

`hierarchy-eac/hierarchy-eac.inf`:

```inf
;
; hierarchy-eac.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=hierarchy-eac.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
hierarchy-eac_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
hierarchy-eac.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%hierarchy-eac.DeviceDesc%=hierarchy-eac_Device, Root\hierarchy-eac ; TODO: edit hw-id

[hierarchy-eac_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
hierarchy-eac.sys

;-------------- Service installation
[hierarchy-eac_Device.NT.Services]
AddService = hierarchy-eac,%SPSVCINST_ASSOCSERVICE%, hierarchy-eac_Service_Inst

; -------------- hierarchy-eac driver install sections
[hierarchy-eac_Service_Inst]
DisplayName    = %hierarchy-eac.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\hierarchy-eac.sys

;
;--- hierarchy-eac_Device Coinstaller installation ------
;

[hierarchy-eac_Device.NT.CoInstallers]
AddReg=hierarchy-eac_Device_CoInstaller_AddReg
CopyFiles=hierarchy-eac_Device_CoInstaller_CopyFiles

[hierarchy-eac_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[hierarchy-eac_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[hierarchy-eac_Device.NT.Wdf]
KmdfService =  hierarchy-eac, hierarchy-eac_wdfsect
[hierarchy-eac_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "hierarchy-eac Installation Disk"
hierarchy-eac.DeviceDesc = "hierarchy-eac Device"
hierarchy-eac.SVCDESC = "hierarchy-eac Service"

```

`hierarchy-eac/hierarchy-eac.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E22E36FB-2598-45B9-A3AC-1B51EE8FD1B8}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>hierarchy_eac</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="hierarchy-eac.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hde64.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="eac.cpp" />
    <ClCompile Include="utils.cpp" />
    <ClCompile Include="vm.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="eac.hpp" />
    <ClInclude Include="hde64.hpp" />
    <ClInclude Include="stdafx.hpp" />
    <ClInclude Include="table64.hpp" />
    <ClInclude Include="utils.hpp" />
    <ClInclude Include="vm.hpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="context.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`hierarchy-eac/hierarchy-eac.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="hierarchy-eac.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="eac.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
    <ClCompile Include="hde64.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
    <ClCompile Include="vm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="eac.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="table64.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hde64.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vm.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="context.asm">
      <Filter>Resource Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`hierarchy-eac/hierarchy-eac.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`hierarchy-eac/main.cpp`:

```cpp
#include "stdafx.hpp"

eac_instance_t *g_eac_instance = nullptr;

long driver_entry( PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path )
{
    if ( !driver_object || !registry_path )
    {
        //
        // Driver is not meant to be manual mapped, add support for PsSetLoadImageNotify first...
        //

        return STATUS_UNSUCCESSFUL;
    }

    g_eac_instance = decltype( g_eac_instance )( ExAllocatePool( NonPagedPoolNx, sizeof( *g_eac_instance ) ) );
    driver_object->DriverUnload = []( PDRIVER_OBJECT object ) { PsRemoveLoadImageNotifyRoutine( vm::image_callback ); };

    return PsSetLoadImageNotifyRoutine( vm::image_callback );
}

```

`hierarchy-eac/stdafx.hpp`:

```hpp
#pragma once

using uint8_t = unsigned char;
using uint16_t = unsigned short;
using uint32_t = unsigned int;
using uint64_t = unsigned long long;

#include <cstdarg>
#include <ntifs.h>
#include <ntimage.h>

class eac_instance_t;
extern eac_instance_t *g_eac_instance;

//
// EAC_SHA1_CREATE_HASH -> E8 ? ? ? ? 48 8D 55 3F
// EAC_IS_RELOC -> 48 8B C4 48 89 58 08 48 89 68 10 48 89 70 18 48 89 78 20 41 54 41 55 41 56 41 57 48 63 05
//

#define EAC_SHA1_CREATE_HASH(base) static_cast<uint8_t*>(base)+0xF054 
#define EAC_IS_RELOC(base) static_cast<uint8_t *>(base)+ 0x33F8
#define CURRENT_THREAD_ID PsGetCurrentThreadId()

#include "hde64.hpp"
#include "utils.hpp"
#include "eac.hpp"
#include "vm.hpp"
```

`hierarchy-eac/table64.hpp`:

```hpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE 0x00
#define C_MODRM 0x01
#define C_IMM8 0x02
#define C_IMM16 0x04
#define C_IMM_P66 0x10
#define C_REL8 0x20
#define C_REL32 0x40
#define C_GROUP 0x80
#define C_ERROR 0xff

#define PRE_ANY 0x00
#define PRE_NONE 0x01
#define PRE_F2 0x02
#define PRE_F3 0x04
#define PRE_66 0x08
#define PRE_67 0x10
#define PRE_LOCK 0x20
#define PRE_SEG 0x40
#define PRE_ALL 0xff

#define DELTA_OPCODES 0x4a
#define DELTA_FPU_REG 0xfd
#define DELTA_FPU_MODRM 0x104
#define DELTA_PREFIXES 0x13c
#define DELTA_OP_LOCK_OK 0x1ae
#define DELTA_OP2_LOCK_OK 0x1c6
#define DELTA_OP_ONLY_MEM 0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
    0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xaa, 0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5, 0xb8, 0xc0, 0xc0, 0xc0,
    0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xac, 0xc0, 0xcc, 0xc0, 0xa1, 0xa1, 0xa1, 0xa1, 0xb1, 0xa5, 0xa5, 0xa6, 0xc0, 0xc0,
    0xd7, 0xda, 0xe0, 0xc0, 0xe4, 0xc0, 0xea, 0xea, 0xe0, 0xe0, 0x98, 0xc8, 0xee, 0xf1, 0xa5, 0xd3, 0xa5, 0xa5, 0xa1,
    0xea, 0x9e, 0xc0, 0xc0, 0xc2, 0xc0, 0xe6, 0x03, 0x7f, 0x11, 0x7f, 0x01, 0x7f, 0x01, 0x3f, 0x01, 0x01, 0xab, 0x8b,
    0x90, 0x64, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x92, 0x5b, 0x5b, 0x76, 0x90, 0x92, 0x92, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b,
    0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x6a, 0x73, 0x90, 0x5b, 0x52, 0x52, 0x52, 0x52, 0x5b, 0x5b, 0x5b, 0x5b,
    0x77, 0x7c, 0x77, 0x85, 0x5b, 0x5b, 0x70, 0x5b, 0x7a, 0xaf, 0x76, 0x76, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b,
    0x5b, 0x5b, 0x5b, 0x5b, 0x86, 0x01, 0x03, 0x01, 0x04, 0x03, 0xd5, 0x03, 0xd5, 0x03, 0xcc, 0x01, 0xbc, 0x03, 0xf0,
    0x03, 0x03, 0x04, 0x00, 0x50, 0x50, 0x50, 0x50, 0xff, 0x20, 0x20, 0x20, 0x20, 0x01, 0x01, 0x01, 0x01, 0xc4, 0x02,
    0x10, 0xff, 0xff, 0xff, 0x01, 0x00, 0x03, 0x11, 0xff, 0x03, 0xc4, 0xc6, 0xc8, 0x02, 0x10, 0x00, 0xff, 0xcc, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x01, 0xff, 0xff, 0xc0, 0xc2, 0x10, 0x11, 0x02, 0x03, 0x01,
    0x01, 0x01, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x10, 0x10, 0x10, 0x10,
    0x02, 0x10, 0x00, 0x00, 0xc6, 0xc8, 0x02, 0x02, 0x02, 0x02, 0x06, 0x00, 0x04, 0x00, 0x02, 0xff, 0x00, 0xc0, 0xc2,
    0x01, 0x01, 0x03, 0x03, 0x03, 0xca, 0x40, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x33, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xbf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xbf,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0xff, 0x40, 0x40, 0x40, 0x40, 0x41, 0x49, 0x40,
    0x40, 0x40, 0x40, 0x4c, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x4f, 0x44, 0x53, 0x40, 0x40, 0x40,
    0x44, 0x57, 0x43, 0x5c, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x40, 0x64, 0x66, 0x6e, 0x6b, 0x40, 0x40, 0x6a, 0x46, 0x40, 0x40, 0x44, 0x46, 0x40, 0x40, 0x5b, 0x44, 0x40, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x01, 0x06, 0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x00, 0x0a, 0x0a,
    0x00, 0x00, 0x00, 0x02, 0x07, 0x07, 0x06, 0x02, 0x0d, 0x06, 0x06, 0x06, 0x0e, 0x05, 0x05, 0x02, 0x02, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18,
    0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80, 0x01, 0x82, 0x01, 0x86, 0x00, 0xf6, 0xcf, 0xfe, 0x3f, 0xab, 0x00,
    0xb0, 0x00, 0xb1, 0x00, 0xb3, 0x00, 0xba, 0xf8, 0xbb, 0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc7, 0xbf, 0x62, 0xff, 0x00,
    0x8d, 0xff, 0x00, 0xc4, 0xff, 0x00, 0xc5, 0xff, 0x00, 0xff, 0xff, 0xeb, 0x01, 0xff, 0x0e, 0x12, 0x08, 0x00, 0x13,
    0x09, 0x00, 0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2b, 0x09, 0x00, 0xae, 0xff, 0x07, 0xb2, 0xff, 0x00, 0xb4, 0xff,
    0x00, 0xb5, 0xff, 0x00, 0xc3, 0x01, 0x00, 0xc7, 0xff, 0xbf, 0xe7, 0x08, 0x00, 0xf0, 0x02, 0x00 };

```

`hierarchy-eac/utils.cpp`:

```cpp
#include "utils.hpp"

namespace utils
{
    PIMAGE_NT_HEADERS const get_nt_headers( const uint64_t image_base )
    {
        if ( !image_base )
            return nullptr;

        const PIMAGE_DOS_HEADER dos_header = reinterpret_cast< PIMAGE_DOS_HEADER >( image_base );
        if ( dos_header->e_magic != IMAGE_DOS_SIGNATURE )
            return nullptr;

        const PIMAGE_NT_HEADERS nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS >( image_base + dos_header->e_lfanew );
        if ( nt_headers->Signature != IMAGE_NT_SIGNATURE )
            return nullptr;

        return nt_headers;
    }

    bool memcpy_safe( void *dest, void *src, uint32_t len )
    {
        //
        // Too lazy to handle 0x1000+ writes, because they require a for loop
        // and we don't even need them here
        // physical pages are not guaranteed to be contiguous...
        //

        if ( len > PAGE_SIZE )
            return false;

        if ( !dest || !src )
            return false;

        if ( !MmIsAddressValid( dest ) || !MmIsAddressValid( src ) )
            return false;

        auto dst = static_cast< uint8_t * >( dest );
        auto source = static_cast< uint8_t * >( src );
        if ( &dst[ len ] > &static_cast< uint8_t * >( PAGE_ALIGN( dst ) )[ PAGE_SIZE ] )
        {
            //
            // We cannot write into a single buffer due to page boundary issues...
            //

            while ( len )
            {

                const auto phys_addr = MmGetPhysicalAddress( dst );
                if ( !phys_addr.QuadPart )
                    return false;

                const auto next_page = &static_cast< uint8_t * >( PAGE_ALIGN( dst ) )[ PAGE_SIZE ];
                const auto map_len = min( len, next_page - dst );
                const auto map_dest = MmMapIoSpace( phys_addr, map_len, MmNonCached );
                if ( !map_dest )
                    return false;

                memcpy( map_dest, source, map_len );
                MmUnmapIoSpace( map_dest, map_len );

                len -= map_len;
                dst += map_len;
                source += map_len;
            }

            return true;
        }

        const auto phys_addr = MmGetPhysicalAddress( dest );
        if ( !phys_addr.QuadPart )
            return false;

        const auto dest_map = MmMapIoSpace( phys_addr, len, MmNonCached );
        if ( !dest_map )
            return false;

        memcpy( dest_map, src, len );
        MmUnmapIoSpace( dest_map, len );

        return true;
    }

    bool create_hook( uint8_t *address, void *target, void **p_original )
    {
        if ( !address || !target )
            return false;

        hde64s block;
        uint8_t instr_len = 0;
        while ( 14 > instr_len )
            instr_len += hde64_disasm( &address[ instr_len ], &block );

        uint8_t rel64_jmp[] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

        const auto p_trampoline =
            static_cast< uint8_t * >( ExAllocatePool( NonPagedPool, sizeof( rel64_jmp ) + instr_len ) );

        if ( !p_trampoline )
            return false;

        auto return_to = &address[ instr_len ];

        //
        // TODO: Support RIP-relative instructions when copying original instructions....
        //

        memcpy( p_trampoline, &address[ 0 ], instr_len );
        memcpy( &p_trampoline[ instr_len ], rel64_jmp, sizeof( rel64_jmp ) );
        memcpy( &p_trampoline[ instr_len + 6 ], &return_to, sizeof( void * ) );

        if ( p_original )
            *p_original = p_trampoline;

        memcpy( &rel64_jmp[ 6 ], &target, sizeof( void * ) );
        utils::memcpy_safe( address, rel64_jmp, sizeof( rel64_jmp ) );

        return true;
    }

    void kprint( const char *msg, ... )
    {
        va_list args;
        va_start( args, msg );

        vDbgPrintExWithPrefix( "", DPFLTR_IHVVIDEO_ID, 0, msg, args );
    }

} // namespace utils

```

`hierarchy-eac/utils.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace utils
{
    PIMAGE_NT_HEADERS const get_nt_headers( const uint64_t image_base );
    bool memcpy_safe( void *dest, void *src, uint32_t len );
    bool create_hook( uint8_t *address, void *target, void **p_original );
    void kprint( const char *msg, ... );
}

```

`hierarchy-eac/vm.cpp`:

```cpp
#include "vm.hpp"

namespace vm
{
    void *g_sha1_update = nullptr;
    void *g_is_reloc = nullptr;

    void is_reloc( context_t *context )
    {

        const auto address = reinterpret_cast< uint8_t * >( context->rcx );
        const auto read_addr = context->rcx;

        if ( g_eac_instance->mem_in_bounds( address ) && g_eac_instance->mem_in_scn( address, IMAGE_SCN_MEM_EXECUTE ) )
        {
            const auto rebased = reinterpret_cast< uint64_t >( address - g_eac_instance->get_image_base() +
                                                               g_eac_instance->get_raw_image() );

            //
            // To 'spoof' all driver reads, we use IoGetStackLimits to
            // get the start-end address of the stack then proceed to
            // iterate through the entire stack looking for instances of the target
            // address then modifying it to our 'cleaned' address
            //
            // Moreover, spoofing registers are necessary to make sure the address
            // is no longer reachable from the current registers
            //

            uint64_t stack_low = 0, stack_high = 0;
            IoGetStackLimits( &stack_low, &stack_high );

            while ( stack_low < stack_high )
            {
                const auto current_offset = reinterpret_cast< uint64_t * >( stack_low );
                if ( *current_offset == read_addr )
                    *current_offset = rebased;

                stack_low += sizeof( uint64_t );
            }

            const auto ctx_array = reinterpret_cast< uint64_t * >( context );
            for ( auto i = 0UL; i < sizeof( *context ); i++ )
            {
                if ( ctx_array[ i ] == read_addr )
                    ctx_array[ i ] = rebased;
            }

            const auto rva = read_addr - reinterpret_cast< uint64_t >( g_eac_instance->get_image_base() );
            if ( rva == reinterpret_cast< uint64_t >( PAGE_ALIGN( rva ) ) )
            {
                //
                // Only log if EAC is reading the start of a page to prevent excess logging....
                //

                utils::kprint( "is_reloc(tid: %i) reading -> EasyAntiCheat.sys+0x%x\n", CURRENT_THREAD_ID, rva );
            }
        }

        //
        // this isn't a traditional hook; we must call the original and update the result register
        // with the return value, otherwise we can expect undefined behavior...
        //

        context->rax = reinterpret_cast< bool ( * )( uint64_t ) >( g_is_reloc )( read_addr );
    }

    void *sha1_create_hash( void *sha1_ctx, uint8_t *address, uint64_t len )
    {

        if ( g_eac_instance->mem_in_bounds( address ) )
        {
            if ( g_eac_instance->mem_in_scn( address, IMAGE_SCN_MEM_EXECUTE ) )
            {
                {
                    utils::kprint( "Spoofing SHA1 read from(tid: %i) rva => 0x%x, len => 0x%04x!\n", CURRENT_THREAD_ID,
                                   address - g_eac_instance->get_image_base(), len );

                    address = ( address - g_eac_instance->get_image_base() ) + g_eac_instance->get_raw_image();
                }
            }
        }

        return reinterpret_cast< decltype( &sha1_create_hash ) >( g_sha1_update )( sha1_ctx, address, len );
    }

    void image_callback( PUNICODE_STRING image_name, HANDLE proc_id, PIMAGE_INFO image_info )
    {
        if ( image_name && image_name->Buffer && image_name->Length )
        {
            if ( !wcsstr( image_name->Buffer, L"EasyAntiCheat.sys" ) )
                return;

            utils::kprint( "EasyAntiCheat.sys loaded at base => 0x%p, size => 0x%x\n", image_info->ImageBase,
                           image_info->ImageSize );

            //
            // Initialize the copy of EasyAntiCheat.sys used for spoofing reads....
            //

            g_eac_instance->init( image_info->ImageBase, image_info->ImageSize );
            utils::kprint( "EasyAntiCheat.sys copy loaded at base => 0x%p\n", g_eac_instance->get_raw_image() );

            utils::create_hook( EAC_SHA1_CREATE_HASH( image_info->ImageBase ), &sha1_create_hash, &g_sha1_update );
            utils::create_hook( EAC_IS_RELOC( image_info->ImageBase ), &vm_is_reloc, &g_is_reloc );
        }
    }
} // namespace vm

```

`hierarchy-eac/vm.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

struct context_t
{
    uint64_t r15;
    uint64_t r14;
    uint64_t r13;
    uint64_t r12;
    uint64_t r11;
    uint64_t r10;
    uint64_t r9;
    uint64_t r8;
    uint64_t rdi;
    uint64_t rsi;
    uint64_t rdx;
    uint64_t rbx;
    uint64_t rcx;
    uint64_t rax;
};

namespace vm
{
    extern void *g_is_reloc;
    extern "C" void vm_is_reloc();
    extern "C" void is_reloc( context_t *context );

    void image_callback( PUNICODE_STRING image_name, HANDLE proc_id, PIMAGE_INFO image_info );
} // namespace vm

```