Project Path: arc_gmh5225_EFI_Driver_Access_khs957a4

Source Tree:

```txt
arc_gmh5225_EFI_Driver_Access_khs957a4
├── CRZEFI
│   ├── Makefile
│   ├── dummy.h
│   └── main.c
├── EFIClient
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── EFIClient.cpp
│   ├── EFIClient.vcxproj
│   └── EFIClient.vcxproj.filters
├── EFI_Driver_Access.sln
└── README.md

```

`CRZEFI/Makefile`:

```
ARCH            = $(shell uname -m | sed s,i[3456789]86,ia32,)

OBJS            = main.o
TARGET          = memory.efi

EFIINC          = /usr/include/efi
EFIINCS         = -I$(EFIINC) -I$(EFIINC)/$(ARCH) -I$(EFIINC)/protocol
LIB32           = /usr/lib32
LIB64           = /usr/lib

CFLAGS          = $(EFIINCS) -fno-stack-protector -fpic \
		  -fshort-wchar -mno-red-zone -Wall

ifeq ($(ARCH),x86_64)
  CFLAGS += -DEFI_FUNCTION_WRAPPER
  LIB           = $(LIB64)
  EFILIB        = $(LIB64)
endif

ifeq ($(ARCH),ia32)
  LIB           = $(LIB32)
  EFILIB        = $(LIB32)
endif

EFI_CRT_OBJS    = $(EFILIB)/crt0-efi-$(ARCH).o
EFI_LDS         = $(EFILIB)/elf_$(ARCH)_efi.lds

LDFLAGS         = -nostdlib -znocombreloc -T $(EFI_LDS) -shared \
		  -Bsymbolic -L $(EFILIB) -L $(LIB) $(EFI_CRT_OBJS) 

all: $(TARGET)

memory.so: $(OBJS)
	ld $(LDFLAGS) $(OBJS) -s -o $@ -lefi -lgnuefi

%.efi: %.so
	objcopy -j .text -j .sdata -j .data -j .dynamic \
		-j .dynsym  -j .rel -j .rela -j .reloc \
		--target=efi-rtdrv-$(ARCH) $^ $@

clean:
	rm -f memory.efi memory.so main.o *~
```

`CRZEFI/dummy.h`:

```h
// This header contains dummy functions to hook in runtime services table
// We want to do this since then, the function pointers are going to be pointing
// to somewhat similar memory location

static EFI_GET_TIME oGetTime;
EFIAPI EFI_STATUS HookedGetTime(EFI_TIME* time, EFI_TIME_CAPABILITIES* capabilities) 
{
    return oGetTime(time, capabilities);
}

static EFI_SET_TIME oSetTime;
EFIAPI EFI_STATUS HookedSetTime(EFI_TIME* time) 
{
    return oSetTime(time);
}

static EFI_GET_WAKEUP_TIME oGetWakeupTime;
EFIAPI EFI_STATUS HookedGetWakeupTime(BOOLEAN* enabled, BOOLEAN* pending, EFI_TIME* time) 
{
    return oGetWakeupTime(enabled, pending, time);
}

static EFI_SET_WAKEUP_TIME oSetWakeupTime;
EFIAPI EFI_STATUS HookedSetWakeupTime(BOOLEAN enable, EFI_TIME* time) 
{
    return oSetWakeupTime(enable, time);
}

static EFI_SET_VIRTUAL_ADDRESS_MAP oSetVirtualAddressMap;
EFIAPI EFI_STATUS HookedSetVirtualAddressMap(UINTN mapSize, UINTN descriptorSize, UINT32 version, EFI_MEMORY_DESCRIPTOR* virtualMap) 
{
    return oSetVirtualAddressMap(mapSize, descriptorSize, version, virtualMap);
}

static EFI_CONVERT_POINTER oConvertPointer;
EFIAPI EFI_STATUS HookedConvertPointer(UINTN debug, void** address) 
{
    return oConvertPointer(debug, address);
}

static EFI_GET_VARIABLE oGetVariable;
EFIAPI EFI_STATUS HookedGetVariable(CHAR16* variableName, EFI_GUID* vendorGuid, UINT32* attributes, UINTN* dataSize, void* data) 
{
    return oGetVariable(variableName, vendorGuid, attributes, dataSize, data);
}

static EFI_GET_NEXT_VARIABLE_NAME oGetNextVariableName;
EFIAPI EFI_STATUS HookedGetNextVariableName(UINTN* variableNameSize, CHAR16* variableName, EFI_GUID* vendorGuid) 
{
    return oGetNextVariableName(variableNameSize, variableName, vendorGuid);
}

/*static EFI_SET_VARIABLE oSetVariable;
EFIAPI EFI_STATUS HookedSetVariable(CHAR16* variableName, EFI_GUID* vendorGuid, UINT32 attributes, UINTN dataSize, void* data) 
{
    return oSetVariable(variableName, vendorGuid, attributes, dataSize, data);
}*/

static EFI_GET_NEXT_HIGH_MONO_COUNT oGetNextHighMonotonicCount;
EFIAPI EFI_STATUS HookedGetNextHighMonotonicCount(UINT32* highCount) 
{
    return oGetNextHighMonotonicCount(highCount);
}

static EFI_RESET_SYSTEM oResetSystem;
EFIAPI EFI_STATUS HookedResetSystem(EFI_RESET_TYPE resetType, EFI_STATUS resetStatus, UINTN dataSize, CHAR16* resetData) 
{
    return oResetSystem(resetType, resetStatus, dataSize, resetData);
}

static EFI_UPDATE_CAPSULE oUpdateCapsule;
EFIAPI EFI_STATUS HookedUpdateCapsule(EFI_CAPSULE_HEADER** capsuleHeaderArray, UINTN capsuleCount, EFI_PHYSICAL_ADDRESS scatterGatherList) 
{
    return oUpdateCapsule(capsuleHeaderArray, capsuleCount, scatterGatherList);
}

static EFI_QUERY_CAPSULE_CAPABILITIES oQueryCapsuleCapabilities;
EFIAPI EFI_STATUS HookedQueryCapsuleCapabilities(EFI_CAPSULE_HEADER** capsuleHeaderArray, UINTN capsuleCount, UINT64* maximumCapsuleSize, EFI_RESET_TYPE* resetType) 
{
    return oQueryCapsuleCapabilities(capsuleHeaderArray, capsuleCount, maximumCapsuleSize, resetType);
}

static EFI_QUERY_VARIABLE_INFO oQueryVariableInfo;
EFIAPI EFI_STATUS HookedQueryVariableInfo(UINT32 attributes, UINT64* maximumVariableStorageSize, UINT64* remainingVariableStorageSize, UINT64* maximumVariableSize) 
{
    return oQueryVariableInfo(attributes, maximumVariableStorageSize, remainingVariableStorageSize, maximumVariableSize);
}
```

`CRZEFI/main.c`:

```c
#define GNU_EFI_USE_MS_ABI 1
#define MicrosoftCallingType __attribute__((ms_abi))

#include <efi.h>
#include <efilib.h>
#include "dummy.h"

// Defines used to check if call is really coming from client
#define baseOperation 0x6256
#define VARIABLE_NAME L"keRdjvbgC"

//This is only to modify every command/magic key with only 1 def and don't need to go everywhere, the compiler will automatically parse the operation to number
#define COMMAND_MAGIC baseOperation*0x7346


// Dummy protocol struct
typedef struct _DummyProtocalData{
	UINTN blank;
} DummyProtocalData;

typedef unsigned long long ptr64;

// Struct containing data used to communicate with the client
typedef struct _MemoryCommand 
{
	int magic;
	int operation;
	ptr64 data[10];
} MemoryCommand;

// Functions (Windows only)
typedef int (MicrosoftCallingType *PsLookupProcessByProcessId)(
	void* ProcessId,
	void* OutPEProcess
);
typedef void* (MicrosoftCallingType *PsGetProcessSectionBaseAddress)(
	void* PEProcess
);
typedef int (MicrosoftCallingType *MmCopyVirtualMemory)(
	void* SourceProcess,
	void* SourceAddress,
	void* TargetProcess,
	void* TargetAddress,
	ptr64 BufferSize,
	char PreviousMode,
	void* ReturnSize
);

// Our protocol GUID (should be different for every driver)
static const EFI_GUID ProtocolGuid
	= { 0x2f84893e, 0xfd5e, 0x2038, {0x8d, 0x9e, 0x20, 0xa7, 0xaf, 0x9c, 0x32, 0xf1} };

// VirtualAddressMap GUID (gEfiEventVirtualAddressChangeGuid)
static const EFI_GUID VirtualGuid
	= { 0x13FA7698, 0xC831, 0x49C7, { 0x87, 0xEA, 0x8F, 0x43, 0xFC, 0xC2, 0x51, 0x96 }}; //we will remove later shouldn't be important

// ExitBootServices GUID (gEfiEventExitBootServicesGuid)
static const EFI_GUID ExitGuid
	= { 0x27ABF055, 0xB1B8, 0x4C26, { 0x80, 0x48, 0x74, 0x8F, 0x37, 0xBA, 0xA2, 0xDF }}; //we will remove later shouldn't be important

// Pointers to original functions
static EFI_SET_VARIABLE oSetVariable = NULL;

// Global declarations
static EFI_EVENT NotifyEvent = NULL;
static EFI_EVENT ExitEvent = NULL;
static BOOLEAN Virtual = FALSE;
static BOOLEAN Runtime = FALSE;

static PsLookupProcessByProcessId GetProcessByPid = (PsLookupProcessByProcessId)0;
static PsGetProcessSectionBaseAddress GetBaseAddress = (PsGetProcessSectionBaseAddress)0;
static MmCopyVirtualMemory MCopyVirtualMemory = (MmCopyVirtualMemory)0;

// Function that actually performs the r/w
EFI_STATUS
RunCommand(MemoryCommand* cmd) 
{
	// Check if the command has right magic
	// (just to be sure again)
	if (cmd->magic != COMMAND_MAGIC) 
	{
		return EFI_ACCESS_DENIED;
	}

	// Copy operation
	if (cmd->operation == baseOperation * 0x823) 
	{
		void* src_process_id = (void*)cmd->data[0];
		void* src_address = (void*)cmd->data[1];
		void* dest_process_id = (void*)cmd->data[2];
		void* dest_address = (void*)cmd->data[3];
		ptr64 size = cmd->data[4];
		void* resultAddr = (void*)cmd->data[5];
		
		if (src_process_id == (void*)4ULL){
			// Same as memcpy function
			CopyMem(dest_address, src_address, size);
		}
		else{
			void* SrcProc = 0;
			void* DstProc = 0;
			ptr64 size_out = 0;
			int status = 0;
			
			status = GetProcessByPid(src_process_id, &SrcProc);
			if (status < 0){
				*(ptr64*)resultAddr = status;
				return EFI_SUCCESS;
			}
			
			status = GetProcessByPid(dest_process_id, &DstProc);
			if (status < 0){
				*(ptr64*)resultAddr = status;
				return EFI_SUCCESS;
			}
				
			
			*(ptr64*)resultAddr = MCopyVirtualMemory(SrcProc, src_address, DstProc, dest_address, size, 1, &size_out);
			
			//NOTE: dereference SrcProc and DstProc or will be a big leak on reference count
		}
		return EFI_SUCCESS;
	}
	
	if (cmd->operation == baseOperation * 0x612) 
	{
		GetProcessByPid = (PsLookupProcessByProcessId)cmd->data[0];
		GetBaseAddress = (PsGetProcessSectionBaseAddress)cmd->data[1];
		MCopyVirtualMemory = (MmCopyVirtualMemory)cmd->data[2];
		ptr64 resultAddr = cmd->data[3];
		*(ptr64*)resultAddr = 1;
		return EFI_SUCCESS;
	}
	
	//Get Process Base Address
	if (cmd->operation == baseOperation * 0x289) 
	{
		void* pid = (void*)cmd->data[0];
		void* resultAddr = (void*)cmd->data[1];
		void* ProcessPtr = 0;
		
		//Find process by ID
		if (GetProcessByPid(pid, &ProcessPtr) < 0 || ProcessPtr == 0) {
			*(ptr64*)resultAddr = 0; // Process not found
			return EFI_SUCCESS;
		}
		
		//Find process Base Address
		*(ptr64*)resultAddr = (ptr64)GetBaseAddress(ProcessPtr); //Return Base Address
		
		//NOTE: dereference ProcessPtr or will be a big leak on reference count
		return EFI_SUCCESS;
	}

	// Invalid command
	return EFI_UNSUPPORTED;
}

// Hooked EFI function SetVariable()
// Can be called from Windows with NtSetSystemEnvironmentValueEx
EFI_STATUS
EFIAPI
HookedSetVariable(
	IN CHAR16 *VariableName,
	IN EFI_GUID *VendorGuid,
	IN UINT32 Attributes,
	IN UINTN DataSize,
	IN VOID *Data
	  ) 
{
	// Use our hook only after we are in virtual address-space
	if (Virtual && Runtime) 
	{       
		// Check of input is not null
		if (VariableName != NULL && VariableName[0] != CHAR_NULL && VendorGuid != NULL) 
		{                     
			// Check if variable name is same as our declared one
			// this is used to check if call is really from our program
			// running in the OS (client)
			if (StrnCmp(VariableName, VARIABLE_NAME, 
				(sizeof(VARIABLE_NAME) / sizeof(CHAR16)) - 1) == 0) 
			{              
				if (DataSize == 0 && Data == NULL)
				{
					// Skip no data
					return EFI_SUCCESS;
				}

				// Check if the data size is correct
				if (DataSize == sizeof(MemoryCommand)) 
				{
					// We did it!
					// Now we can call the magic function
					return RunCommand((MemoryCommand*)Data);
				}
			}
		}
	}
	
	// Call the original SetVariable() function
	return oSetVariable(VariableName, VendorGuid, Attributes, DataSize, Data);
}

// Event callback when SetVitualAddressMap() is called by OS
VOID
EFIAPI
SetVirtualAddressMapEvent(
	IN EFI_EVENT Event,
	IN VOID* Context
	)
{  
	// Convert orignal SetVariable address
	RT->ConvertPointer(0, (VOID**)&oSetVariable);

	// Convert all other addresses
	RT->ConvertPointer(0, (VOID**)&oGetTime);
	RT->ConvertPointer(0, (VOID**)&oSetTime);
	RT->ConvertPointer(0, (VOID**)&oGetWakeupTime);
	RT->ConvertPointer(0, (VOID**)&oSetWakeupTime);
	RT->ConvertPointer(0, (VOID**)&oSetVirtualAddressMap);
	RT->ConvertPointer(0, (VOID**)&oConvertPointer);
	RT->ConvertPointer(0, (VOID**)&oGetVariable);
	RT->ConvertPointer(0, (VOID**)&oGetNextVariableName);
	//RT->ConvertPointer(0, &oSetVariable);
	RT->ConvertPointer(0, (VOID**)&oGetNextHighMonotonicCount);
	RT->ConvertPointer(0, (VOID**)&oResetSystem);
	RT->ConvertPointer(0, (VOID**)&oUpdateCapsule);
	RT->ConvertPointer(0, (VOID**)&oQueryCapsuleCapabilities);
	RT->ConvertPointer(0, (VOID**)&oQueryVariableInfo);
	
	// Convert runtime services pointer
	RtLibEnableVirtualMappings();

	// Null and close the event so it does not get called again
	NotifyEvent = NULL;

	// We are now working in virtual address-space
	Virtual = TRUE;
}

// Event callback after boot process is started
VOID
EFIAPI
ExitBootServicesEvent(
	IN EFI_EVENT Event,
	IN VOID* Context
	)
{
	// This event is called only once so close it
	BS->CloseEvent(ExitEvent);
	ExitEvent = NULL;

	// Boot services are now not avaible
	BS = NULL;
	
	// We are booting the OS now
	Runtime = TRUE;

	// Print some text so we know it works (300iq)
	ST->ConOut->SetAttribute(ST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLUE);
	ST->ConOut->ClearScreen(ST->ConOut);
	Print(L"Driver seems to be working as expected! Windows is booting now...\n");
}

// Replaces service table pointer with desired one
// returns original
VOID*
SetServicePointer(
	IN OUT EFI_TABLE_HEADER *ServiceTableHeader,
	IN OUT VOID **ServiceTableFunction,
	IN VOID *NewFunction
	)
{
	// We don't want to fuck up the system
	if (ServiceTableFunction == NULL || NewFunction == NULL)
		return NULL;

	// Make sure boot services pointers are not null
	ASSERT(BS != NULL);
	ASSERT(BS->CalculateCrc32 != NULL);

	// Raise task priority level
	CONST EFI_TPL Tpl = BS->RaiseTPL(TPL_HIGH_LEVEL);

	// Swap the pointers
	// GNU-EFI and InterlockedCompareExchangePointer 
	// are not friends
	VOID* OriginalFunction = *ServiceTableFunction;
	*ServiceTableFunction = NewFunction;

	// Change the table CRC32 signature
	ServiceTableHeader->CRC32 = 0;
	BS->CalculateCrc32((UINT8*)ServiceTableHeader, ServiceTableHeader->HeaderSize, &ServiceTableHeader->CRC32);

	// Restore task priority level
	BS->RestoreTPL(Tpl);

	return OriginalFunction;
}

// EFI driver unload routine
static
EFI_STATUS
EFI_FUNCTION
efi_unload(IN EFI_HANDLE ImageHandle)
{
	// We don't want our driver to be unloaded 
	// until complete reboot
	return EFI_ACCESS_DENIED;
}

// EFI entry point
EFI_STATUS
efi_main(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable) 
{
	// Initialize internal GNU-EFI functions
	InitializeLib(ImageHandle, SystemTable);

	// Get handle to this image
	EFI_LOADED_IMAGE *LoadedImage = NULL;
	EFI_STATUS status = BS->OpenProtocol(ImageHandle, &LoadedImageProtocol,
										(void**)&LoadedImage, ImageHandle,
										NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
	
	// Return if protocol failed to open
	if (EFI_ERROR(status)) 
	{
		Print(L"Can't open protocol: %d\n", status);
		return status;
	}

	// Install our protocol interface
	// This is needed to keep our driver loaded
	DummyProtocalData dummy = { 0 };
	status = LibInstallProtocolInterfaces(
	  &ImageHandle, &ProtocolGuid,
	  &dummy, NULL);
	  
	// Return if interface failed to register
	if (EFI_ERROR(status)) 
	{
		Print(L"Can't register interface: %d\n", status);
		return status;
	}

	// Set our image unload routine
	LoadedImage->Unload = (EFI_IMAGE_UNLOAD)efi_unload;

	// Create global event for VirtualAddressMap
	status = BS->CreateEventEx(EVT_NOTIFY_SIGNAL,
								TPL_NOTIFY,
								SetVirtualAddressMapEvent,
								NULL,
								VirtualGuid,
								&NotifyEvent);

	// Return if event create failed
	if (EFI_ERROR(status)) 
	{
		Print(L"Can't create event (SetVirtualAddressMapEvent): %d\n", status);
		return status;
	}

	// Create global event for ExitBootServices
	status = BS->CreateEventEx(EVT_NOTIFY_SIGNAL,
								TPL_NOTIFY,
								ExitBootServicesEvent,
								NULL,
								ExitGuid,
								&ExitEvent);

	// Return if event create failed (yet again)
	if (EFI_ERROR(status)) 
	{
		Print(L"Can't create event (ExitBootServicesEvent): %d\n", status);
		return status;
	}

	// Hook SetVariable (should not fail)
	oSetVariable = (EFI_SET_VARIABLE)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetVariable, (VOID**)&HookedSetVariable);

	// Hook all the other runtime services functions
	oGetTime = (EFI_GET_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetTime, (VOID**)&HookedGetTime);
	oSetTime = (EFI_SET_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetTime, (VOID**)&HookedSetTime);
	oGetWakeupTime = (EFI_GET_WAKEUP_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetWakeupTime, (VOID**)&HookedGetWakeupTime);
	oSetWakeupTime = (EFI_SET_WAKEUP_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetWakeupTime, (VOID**)&HookedSetWakeupTime);
	oSetVirtualAddressMap = (EFI_SET_VIRTUAL_ADDRESS_MAP)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetVirtualAddressMap, (VOID**)&HookedSetVirtualAddressMap);
	oConvertPointer = (EFI_CONVERT_POINTER)SetServicePointer(&RT->Hdr, (VOID**)&RT->ConvertPointer, (VOID**)&HookedConvertPointer);
	oGetVariable = (EFI_GET_VARIABLE)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetVariable, (VOID**)&HookedGetVariable);
	oGetNextVariableName = (EFI_GET_NEXT_VARIABLE_NAME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetNextVariableName, (VOID**)&HookedGetNextVariableName);
	//oSetVariable = (EFI_SET_VARIABLE)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetVariable, (VOID**)&HookedSetVariable);
	oGetNextHighMonotonicCount = (EFI_GET_NEXT_HIGH_MONO_COUNT)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetNextHighMonotonicCount, (VOID**)&HookedGetNextHighMonotonicCount);
	oResetSystem = (EFI_RESET_SYSTEM)SetServicePointer(&RT->Hdr, (VOID**)&RT->ResetSystem, (VOID**)&HookedResetSystem);
	oUpdateCapsule = (EFI_UPDATE_CAPSULE)SetServicePointer(&RT->Hdr, (VOID**)&RT->UpdateCapsule, (VOID**)&HookedUpdateCapsule);
	oQueryCapsuleCapabilities = (EFI_QUERY_CAPSULE_CAPABILITIES)SetServicePointer(&RT->Hdr, (VOID**)&RT->QueryCapsuleCapabilities, (VOID**)&HookedQueryCapsuleCapabilities);
	oQueryVariableInfo = (EFI_QUERY_VARIABLE_INFO)SetServicePointer(&RT->Hdr, (VOID**)&RT->QueryVariableInfo, (VOID**)&HookedQueryVariableInfo);

	// Print confirmation text
	Print(L"\n");
	Print(L"       __ _                                  \n");
	Print(L"  ___ / _(_)___ _ __  ___ _ __  ___ _ _ _  _ \n");
	Print(L" / -_)  _| |___| '  \\/ -_) '  \\/ _ \\ '_| || |\n");
	Print(L" \\___|_| |_|   |_|_|_\\___|_|_|_\\___/_|  \\_, |\n");
	Print(L"                                        |__/ \n");
	Print(L"Made by: Samuel Tulach\n");
	Print(L"Direct Calling By: The CruZ\n");
	Print(L"Thanks to: @Mattiwatti (EfiGuard), Roderick W. Smith (rodsbooks.com)\n\n");
	Print(L"Driver has been loaded successfully. You can now boot to the OS.\n");
	Print(L"If you don't see a blue screen while booting disable Secure Boot!.\n");
	return EFI_SUCCESS;
}

```

`EFIClient/Driver.cpp`:

```cpp
#include "Driver.h"


HANDLE Driver::driverH = 0;
uintptr_t Driver::currentProcessId = 0;
GUID DummyGuid = { 2 }; //don't matter our var never will be saved

NTSTATUS SetSystemEnvironmentPrivilege(BOOLEAN Enable, PBOOLEAN WasEnabled)
{
	if (WasEnabled != nullptr)
		*WasEnabled = FALSE;

	BOOLEAN SeSystemEnvironmentWasEnabled;
	const NTSTATUS Status = RtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
		Enable,
		FALSE,
		&SeSystemEnvironmentWasEnabled);

	if (NT_SUCCESS(Status) && WasEnabled != nullptr)
		*WasEnabled = SeSystemEnvironmentWasEnabled;

	return Status;
}

void Driver::SendCommand(MemoryCommand* cmd)
{
	UNICODE_STRING VariableName = RTL_CONSTANT_STRING(VARIABLE_NAME);
	NtSetSystemEnvironmentValueEx(
		&VariableName,
		&DummyGuid,
		cmd,
		sizeof(MemoryCommand),
		ATTRIBUTES);
}


uintptr_t Driver::GetBaseAddress(uintptr_t pid) {
	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x289;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = pid;
	cmd.data[1] = (uintptr_t)&result;
	SendCommand(&cmd);
	return result;
}

NTSTATUS Driver::copy_memory(
	const uintptr_t	src_process_id,
	const uintptr_t src_address,
	const uintptr_t	dest_process_id,
	const uintptr_t	dest_address,
	const size_t	size) {
	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x823;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = (uintptr_t)src_process_id;
	cmd.data[1] = (uintptr_t)src_address;
	cmd.data[2] = (uintptr_t)dest_process_id;
	cmd.data[3] = (uintptr_t)dest_address;
	cmd.data[4] = (uintptr_t)size;
	cmd.data[5] = (uintptr_t)&result;
	SendCommand(&cmd);
	return (NTSTATUS)result;
}

uintptr_t GetKernelModuleExport(uintptr_t kernel_module_base, char* function_name)
{
	if (!kernel_module_base)
		return 0;

	IMAGE_DOS_HEADER dos_header = { 0 };
	IMAGE_NT_HEADERS64 nt_headers = { 0 };

	Driver::read_memory(4, kernel_module_base, (uintptr_t)&dos_header, sizeof(dos_header));

	if (dos_header.e_magic != IMAGE_DOS_SIGNATURE)
		return 0;

	Driver::read_memory(4, kernel_module_base + dos_header.e_lfanew, (uintptr_t)&nt_headers, sizeof(nt_headers));

	if (nt_headers.Signature != IMAGE_NT_SIGNATURE)
		return 0;

	const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	if (!export_base || !export_base_size)
		return 0;

	const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	Driver::read_memory(4, kernel_module_base + export_base, (uintptr_t)export_data, export_base_size);

	const auto delta = reinterpret_cast<uintptr_t>(export_data) - export_base;

	const auto name_table = reinterpret_cast<UINT32*>(export_data->AddressOfNames + delta);
	const auto ordinal_table = reinterpret_cast<UINT16*>(export_data->AddressOfNameOrdinals + delta);
	const auto function_table = reinterpret_cast<UINT32*>(export_data->AddressOfFunctions + delta);

	for (auto i = 0u; i < export_data->NumberOfNames; ++i)
	{
		char* current_function_name = (char*)(name_table[i] + delta);

		if (!_stricmp(current_function_name, function_name))
		{
			const auto function_ordinal = ordinal_table[i];
			const auto function_address = kernel_module_base + function_table[function_ordinal];

			if (function_address >= kernel_module_base + export_base && function_address <= kernel_module_base + export_base + export_base_size)
			{
				VirtualFree(export_data, 0, MEM_RELEASE);
				return 0; // No forwarded exports on 64bit?
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return function_address;
		}
	}

	VirtualFree(export_data, 0, MEM_RELEASE);
	return 0;
}

uintptr_t GetKernelModuleAddress(char* module_name)
{
	void* buffer = nullptr;
	DWORD buffer_size = 0;

	NTSTATUS status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), buffer, buffer_size, &buffer_size);

	while (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (buffer == 0) {
			return 0;
		}
		status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status))
	{
		VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}

	const PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)buffer;
	if (modules == nullptr) {
		VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}
	for (auto i = 0u; i < modules->NumberOfModules; ++i)
	{
		char* current_module_name = (char*)(modules->Modules[i].FullPathName + modules->Modules[i].OffsetToFileName);

		if (!_stricmp(current_module_name, module_name))
		{
			const uintptr_t result = (uintptr_t)(modules->Modules[i].ImageBase);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return result;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);
	return 0;
}

bool Driver::initialize() {
	currentProcessId = GetCurrentProcessId();
	BOOLEAN SeSystemEnvironmentWasEnabled;

	NTSTATUS status = SetSystemEnvironmentPrivilege(true, &SeSystemEnvironmentWasEnabled);

	if (!NT_SUCCESS(status)) {
		return false;
	}


	BYTE nstosname[] = { 'n','t','o','s','k','r','n','l','.','e','x','e',0 };
	uintptr_t kernelModuleAddress = GetKernelModuleAddress((char*)nstosname);
	memset(nstosname, 0, sizeof(nstosname));

	BYTE pbid[] = { 'P','s','L','o','o','k','u','p','P','r','o','c','e','s','s','B','y','P','r','o','c','e','s','s','I','d',0 };
	BYTE gba[] = { 'P','s','G','e','t','P','r','o','c','e','s','s','S','e','c','t','i','o','n','B','a','s','e','A','d','d','r','e','s','s',0 };
	BYTE mmcp[] = { 'M','m','C','o','p','y','V','i','r','t','u','a','l','M','e','m','o','r','y',0 };
	uintptr_t kernel_PsLookupProcessByProcessId = GetKernelModuleExport(kernelModuleAddress, (char*)pbid);
	uintptr_t kernel_PsGetProcessSectionBaseAddress = GetKernelModuleExport(kernelModuleAddress, (char*)gba);
	uintptr_t kernel_MmCopyVirtualMemory = GetKernelModuleExport(kernelModuleAddress, (char*)mmcp);
	memset(pbid, 0, sizeof(pbid));
	memset(gba, 0, sizeof(gba));
	memset(mmcp, 0, sizeof(mmcp));

	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x612;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = kernel_PsLookupProcessByProcessId;
	cmd.data[1] = kernel_PsGetProcessSectionBaseAddress;
	cmd.data[2] = kernel_MmCopyVirtualMemory;
	cmd.data[3] = (uintptr_t)&result;
	SendCommand(&cmd);
	return result;
}

NTSTATUS Driver::read_memory(
	const uintptr_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size) {
	return copy_memory(process_id, address, currentProcessId, buffer, size);
}

NTSTATUS Driver::write_memory(
	const uintptr_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size) {
	return copy_memory(currentProcessId, buffer, process_id, address, size);
}

```

`EFIClient/Driver.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")
#include <stdio.h>

#define baseOperation 0x6256

#define VARIABLE_NAME L"keRdjvbgC"
#define COMMAND_MAGIC baseOperation*0x7346

#define EFI_VARIABLE_NON_VOLATILE                          0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS                        0x00000004
#define EFI_VARIABLE_HARDWARE_ERROR_RECORD                 0x00000008
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define EFI_VARIABLE_APPEND_WRITE                          0x00000040
#define ATTRIBUTES (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS)

#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)s }

extern GUID DummyGuid;

extern "C"
{
	NTSYSAPI
		NTSTATUS
		NTAPI
		RtlAdjustPrivilege(
			_In_ ULONG Privilege,
			_In_ BOOLEAN Enable,
			_In_ BOOLEAN Client,
			_Out_ PBOOLEAN WasEnabled
		);

	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		NtSetSystemEnvironmentValueEx(
			_In_ PUNICODE_STRING VariableName,
			_In_ LPGUID VendorGuid,
			_In_reads_bytes_opt_(ValueLength) PVOID Value,
			_In_ ULONG ValueLength,
			_In_ ULONG Attributes
		);
}

typedef struct _MemoryCommand
{
	int magic;
	int operation;
	unsigned long long data[10];
} MemoryCommand;

constexpr auto STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

constexpr auto SystemModuleInformation = 11;
constexpr auto SystemHandleInformation = 16;
constexpr auto SystemExtendedHandleInformation = 64;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

uintptr_t GetKernelModuleAddress(char* module_name);
uintptr_t GetKernelModuleExport(uintptr_t kernel_module_base, char* function_name);
NTSTATUS SetSystemEnvironmentPrivilege(BOOLEAN Enable, PBOOLEAN WasEnabled);

namespace Driver
{
	bool	initialize();
	extern uintptr_t currentProcessId;
	extern HANDLE driverH;

	void SendCommand(MemoryCommand* cmd);
	NTSTATUS copy_memory(uintptr_t src_process_id, uintptr_t src_address, uintptr_t dest_process_id, uintptr_t dest_address, size_t size);
	NTSTATUS read_memory(uintptr_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	NTSTATUS write_memory(uintptr_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uintptr_t GetBaseAddress(uintptr_t pid);

	template <typename T>
	T read(const uintptr_t process_id, const uintptr_t address, PNTSTATUS out_status = 0)
	{
		T buffer{ };
		NTSTATUS status = read_memory(process_id, address, uintptr_t(&buffer), sizeof(T));
		if (out_status)
			*out_status = status;
		return buffer;
	}

	template <typename T>
	void write(const uintptr_t process_id, const uintptr_t address, const T& buffer, PNTSTATUS out_status = 0)
	{
		NTSTATUS status = write_memory(process_id, address, uintptr_t(&buffer), sizeof(T));
		if (out_status)
			*out_status = status;
	}
}

```

`EFIClient/EFIClient.cpp`:

```cpp
// EFIClient.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//

#include <iostream>
#include <sstream>
#include "Driver.h"

bool CheckDriverStatus() {
    int icheck = 82;
    NTSTATUS status = 0;

    uintptr_t BaseAddr = Driver::GetBaseAddress(GetCurrentProcessId());
    if (BaseAddr == 0) {
        return false;
    }

    int checked = Driver::read<int>(GetCurrentProcessId(), (uintptr_t)&icheck, &status);
    if (checked != icheck) {
        return false;
    }
    return true;
}


int main()
{
    if (!Driver::initialize() || !CheckDriverStatus()) {
        UNICODE_STRING VariableName = RTL_CONSTANT_STRING(VARIABLE_NAME);
        NtSetSystemEnvironmentValueEx(
            &VariableName,
            &DummyGuid,
            0,
            0,
            ATTRIBUTES);//delete var

        std::cout << "No EFI Driver found\n";
        system("pause");
        exit(1);
        return 1;
    }

    while (true) {
        system("cls");
        std::cout << "Hi Welcome to EFI Client\n";
        std::cout << "What do you want to do?\n";
        std::cout << "1 - Get process base address by PID\n";
        std::cout << "2 - Read process memory by PID\n";
        std::cout << "3 - Exit\n";
        int action;
        std::cin >> action;
        std::cin.clear();
        std::cin.ignore();
        if (action == 3) {
            std::cout << "Exiting Byee!\n";
            return 0;
        }
        int pid = 0;
        if (action == 1 || action == 2) {
            std::cout << "Process ID:\n";
            std::cin >> pid;
            std::cin.clear();
            std::cin.ignore();
        }


        if (action == 1) {
            uintptr_t BaseAddr = Driver::GetBaseAddress(pid);
            std::cout << "Base Address:\n" << std::hex << BaseAddr << "\n";
            system("pause");
        }
        else if (action == 2) {
            std::cout << "Address(Hex):\n";
            uintptr_t addr = 0;
            std::string addrData;
            std::cin >> addrData;
            std::cin.clear();
            std::cin.ignore();
            addr = std::stoull(addrData, nullptr, 16);
            std::cout << "Number of bytes:\n";
            size_t bytes;
            std::cin >> bytes;
            std::cin.clear();
            std::cin.ignore();

            BYTE* buffer = new BYTE[bytes];
            memset(buffer, 0, bytes);
            Driver::read_memory(pid, addr, (uintptr_t)&buffer[0], bytes);

            std::cout << "Readed:\n";
            for (size_t i = 0; i < bytes; i++) {
                printf("%02X ", buffer[i]);
            }
            printf("\n\n");

            delete[] buffer;

            system("pause");
        }
    }
}

```

`EFIClient/EFIClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>EFIClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="EFIClient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFIClient/EFIClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Archivos de recursos">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EFIClient.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="Driver.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EFI_Driver_Access.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29926.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EFIClient", "EFIClient\EFIClient.vcxproj", "{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}.Debug|x64.ActiveCfg = Debug|x64
		{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}.Debug|x64.Build.0 = Debug|x64
		{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}.Release|x64.ActiveCfg = Release|x64
		{99B3FDC3-4A24-497B-A0B4-B890EB6891C0}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8B76E1FF-41BC-4755-9BD7-D06A6064ECFB}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# EFI Driver Access
Efi Driver Access is a simply project to load a driver during system boot with the idea to give the user kernel access for read/write memory without restrictions

## CRZEFI
CRZEFI is the EFI Driver itself and is based on other publications like https://github.com/SamuelTulach/efi-memory

The difference of this one basically is that is prepared to call some windows kernel function directly for the user access

## EFIClient
EFIClient is a simply Console example for the usage of EFI Driver

One of the main examples where i use this driver is in: https://www.unknowncheats.me/forum/apex-legends/405983-direct-efi-aimbot-glow-hack.html

## Compilling
To compile EFIClient is easiest as you only need to install Visual Studio, open the project, and compile it

For the CRZEFI is very simple too but you must have a gcc compiler with gnu-efi, the easiest method to have this enviroment is install an ubuntu desktop/server somewhere and run the next commands:

    sudo apt install gnu-efi build-essential
    git clone https://github.com/TheCruZ/EFI_Driver_Access
    cd EFI_Driver_Access
    cd CRZEFI
    make

And it should generate a memory.efi file

## How To Use
You have to put in a USB Driver the edk2 efi shell: https://github.com/tianocore/edk2/releases in the path

    /EFI/Boot/bootx64.efi

and then leave the memory.efi somethere in the USB Driver for example in

    /memory.efi


Now you can bootup with you usb and load the efi file with the "load memory.efi" command (going first to the USB folder that can be FS0, FS1, FS2...) and then come back to your boot menu/bios to run windows normally, you will know that the memory.efi is working because will set blue background while windows system is loading


Have a fun and keep learning!
```