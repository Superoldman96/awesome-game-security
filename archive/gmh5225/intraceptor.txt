Project Path: arc_gmh5225_intraceptor_wz3_g12c

Source Tree:

```txt
arc_gmh5225_intraceptor_wz3_g12c
├── MinHook.h
├── README.md
├── commands.hpp
├── commands_id.hpp
├── driverceptor
│   ├── apc.txt
│   ├── driver.cpp
│   ├── driver_hooks.hpp
│   ├── driverceptor.inf
│   ├── driverceptor.vcxproj
│   ├── driverceptor.vcxproj.filters
│   ├── handles.hpp
│   ├── helpers.hpp
│   ├── kernel.hpp
│   ├── stdafx.hpp
│   └── tools.hpp
├── hooks.hpp
├── includes.hpp
├── intraceptor.sln
├── intraceptor.vcxproj
├── intraceptor.vcxproj.filters
├── libs
│   ├── libMinHook.x64.lib
│   └── libMinHook.x86.lib
├── main.cpp
├── testExe
│   ├── test.cpp
│   ├── testExe.vcxproj
│   └── testExe.vcxproj.filters
└── winstructs.hpp

```

`MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`README.md`:

```md
# intraceptor
Intraceptor intercept Windows NT API calls and redirect them to a kernel driver to bypass process/threads handle protections.

The current state of the project is semi-abandoned/not being worked ATM.

```

`commands.hpp`:

```hpp
#pragma once

#include <memory>
#include "commands_id.hpp"

class CCommand
{
private:
	HANDLE hDriver		= INVALID_HANDLE_VALUE;
	bool bInitialized	= false;
	NTSTATUS LastStatus = STATUS_SUCCESS;

	bool SendCmd( std::uint32_t dwIOCTL, std::uint64_t* Buffer, std::uint32_t Lenght )
	{
		IO_STATUS_BLOCK io{ };

		LastStatus = NtDeviceIoControlFile( 
			hDriver, nullptr, nullptr, nullptr, &io,
			dwIOCTL, Buffer, Lenght, Buffer, Lenght );

		return NT_SUCCESS( LastStatus );
	}

public:
	CCommand()
	{
		UNICODE_STRING us{ };
		RtlInitUnicodeString( &us, ( L"\\DosDevices\\Global\\KlhkCtrl" ) );

		OBJECT_ATTRIBUTES oa{ };
		InitializeObjectAttributes( &oa, &us, OBJ_CASE_INSENSITIVE, NULL, NULL );

		IO_STATUS_BLOCK io{ };
		const auto res = NtOpenFile( &hDriver, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &oa, &io, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE );
		if ( !NT_SUCCESS( res ) )
		{
			printf( "NtOpenFile failed 0x%X\n", res );
			getchar();
			return;
		}

		if ( hDriver == INVALID_HANDLE_VALUE || !hDriver  )
		{
			MessageBoxA( GetActiveWindow(), "Driver not found or loaded!", NULL, MB_ICONSTOP );
		}
		else
			bInitialized = true;
	}

	~CCommand()
	{
		if ( bInitialized )
			CloseHandle( hDriver );
	}

	bool Status() const
	{
		return bInitialized;
	}

	NTSTATUS GetLastNtError() const
	{
		return LastStatus;
	}

	bool AttachProcess( std::uint64_t ProcessId, std::uint64_t ThreadId, std::uint64_t* hProcess )
	{
		ATTACH_PROCESS cmd{ };
		cmd.ProcessId = ProcessId;
		cmd.ThreadId = ThreadId;

		const auto res = SendCmd( IOCTL_ATTACH_TO_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
		if ( res )
		{
			if ( hProcess )
				*hProcess = cmd.OutProcessHandle;
		}
		return res;
	}

	bool DetachProcess( std::uint64_t ProcessHandle )
	{
		DETACH_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;

		return SendCmd( IOCTL_DETACH_FROM_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool SuspendProcess( std::uint64_t ProcessHandle )
	{
		PROCESS_MISC cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.Suspend = TRUE;

		return SendCmd( IOCTL_SUSPEND_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool ResumeProcess( std::uint64_t ProcessHandle )
	{
		PROCESS_MISC cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.Suspend = FALSE;

		return SendCmd( IOCTL_RESUME_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool FlushInstructionCache( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint32_t Length )
	{
		FLUSHCACHE_MEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Length;

		return SendCmd( IOCTL_FLUSH_INSTRUCTION_CACHE, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool SetInformationProcess( std::uint64_t ProcessHandle, std::uint32_t InfoClass, std::uint64_t* ProcessInfo, std::uint32_t ProcessInfoLenght )
	{
		SETINFO_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.InformationClass = InfoClass;
		cmd.Buffer = ProcessInfo;
		cmd.Lenght = ProcessInfoLenght;

		return SendCmd( IOCTL_SET_INFORMATION_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool ReadProcessMemory( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t* Buffer, std::uint64_t Lenght, std::uint64_t* BytesReaded )
	{
		READMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Buffer = Buffer;
		cmd.Lenght = Lenght;
		cmd.BytesRead = BytesReaded;

		return SendCmd( IOCTL_READ_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool WriteProcessMemory( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t* Buffer, std::uint64_t Lenght, std::uint64_t* BytesWritten )
	{
		WRITEMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Buffer = Buffer;
		cmd.Lenght = Lenght;
		cmd.BytesWritten = BytesWritten;

		return SendCmd( IOCTL_WRITE_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	std::uint64_t VirtualAllocEx( std::uint64_t ProcessHandle, std::uint64_t BaseAddress, std::uint64_t Lenght, std::uint32_t Type, std::uint32_t Protect )
	{
		ALLOCMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.Type = Type;
		cmd.Protect = Protect;

		if ( SendCmd( IOCTL_ALLOCATE_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) ) )
			return cmd.BaseAddress;

		return NULL;
	}

	bool FlushMemory( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t Lenght, PIO_STATUS_BLOCK IoStatus )
	{
		FLUSHVIRTUAL_MEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.IoStatus = IoStatus;

		return SendCmd( IOCTL_FLUSH_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool VirtualLockEx( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t Lenght, std::uint32_t LockOption )
	{
		LOCKMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.Option = LockOption;

		return SendCmd( IOCTL_LOCK_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool VirtualUnlockEx( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t Lenght, std::uint32_t LockOption )
	{
		UNLOCKMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.Option = LockOption;

		return SendCmd( IOCTL_UNLOCK_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool VirtualFreeEx( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t Lenght, std::uint32_t Type )
	{
		FREEMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.Type = Type;

		return SendCmd( IOCTL_FREE_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool VirtualProtectEx( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint64_t Lenght, std::uint32_t NewAccess, std::uint32_t* OldAccess )
	{
		PROTECTMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.Lenght = Lenght;
		cmd.NewAccess = NewAccess;
		cmd.OldAccess = OldAccess;

		return SendCmd( IOCTL_PROTECT_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool VirtualQueryEx( std::uint64_t ProcessHandle, std::uint64_t* BaseAddress, std::uint32_t InformationClass, std::uint64_t* Buffer, std::uint64_t Length, std::uint32_t* ResultLength )
	{
		QUERYMEMORY_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.BaseAddress = BaseAddress;
		cmd.InformationClass = InformationClass;
		cmd.Buffer = Buffer;
		cmd.Lenght = Length;
		cmd.ResultLength = ResultLength;

		return SendCmd( IOCTL_QUERY_MEMORY_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool QueryInformationProcess( std::uint64_t ProcessHandle, std::uint32_t InformationClass, std::uint64_t* Buffer, std::uint32_t Length, std::uint32_t* ResultLength )
	{
		QUERYINFO_PROCESS cmd{ };
		cmd.ProcessHandle = ProcessHandle;
		cmd.InformationClass = InformationClass;
		cmd.Buffer = Buffer;
		cmd.Lenght = Length;
		cmd.ResultLength = ResultLength;

		return SendCmd( IOCTL_QUERY_INFO_PROCESS, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool QuerySystemInformationEx( std::uint32_t InformationClass, std::uint64_t* InputBuffer, std::uint32_t InputBufferLenght, std::uint64_t* SystemInfo, std::uint32_t SystemInfoLenght, std::uint32_t* ResultLength )
	{
		QUERY_SYSTEMINFOEX cmd{ };
		cmd.InformationClass = InformationClass;
		cmd.InputBuffer = InputBuffer;
		cmd.InputBufferLenght = InputBufferLenght;
		cmd.SystemInfo = SystemInfo;
		cmd.SystemInfoLenght = SystemInfoLenght;
		cmd.ResultLength = ResultLength;

		return SendCmd( IOCTL_QUERY_SYSTEM_INFO_EX, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool OpenThread( std::uint64_t ThreadId, std::uint64_t ProcessId, std::uint64_t* hThreadHandle )
	{
		OPEN_THREAD_PROCESS cmd{ };
		cmd.ProcessId = ProcessId;
		cmd.ThreadId = ThreadId;

		const auto res = SendCmd( IOCTL_OPEN_THREAD, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
		if ( res )
		{
			if ( hThreadHandle )
				*hThreadHandle = cmd.OutThreadHandle;
		}
		return res;
	}

	bool GetThreadContext( std::uint64_t ThreadHandle, PCONTEXT pCtx )
	{
		GET_CONTEXT_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.Context = pCtx;

		return SendCmd( IOCTL_GET_CONTEXT_THREAD, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool SetThreadContext( std::uint64_t ThreadHandle, PCONTEXT pCtx )
	{
		SET_CONTEXT_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.Context = pCtx;

		return SendCmd( IOCTL_SET_CONTEXT_THREAD, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool ResumeThread( std::uint64_t ThreadHandle, std::uint32_t* ResumeCount )
	{
		RESUME_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.Count = ResumeCount;

		return SendCmd( IOCTL_RESUME_THREAD, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool SuspendThread( std::uint64_t ThreadHandle, std::uint32_t* SuspendCount )
	{
		SUSPEND_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.Count = SuspendCount;

		return SendCmd( IOCTL_SUSPEND_THREAD, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool QueryThreadInformation( std::uint64_t ThreadHandle, std::uint32_t InfoClass, std::uint64_t* ThreadInfo, std::uint32_t ThreadInfoLenght, std::uint32_t* ResultLenght )
	{
		QUERYINFO_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.ThreadInfo = ThreadInfo;
		cmd.ThreadInfoLenght = ThreadInfoLenght;
		cmd.ResultLenght = ResultLenght;
		cmd.InformationClass = InfoClass;

		return SendCmd( IOCTL_QUERY_THREAD_INFO, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	bool SetThreadInformation( std::uint64_t ThreadHandle, std::uint32_t InfoClass, std::uint64_t* ThreadInfo, std::uint32_t ThreadInfoLenght )
	{
		SETINFO_THREAD_PROCESS cmd{ };
		cmd.ThreadHandleValue = ThreadHandle;
		cmd.ThreadInfo = ThreadInfo;
		cmd.ThreadInfoLenght = ThreadInfoLenght;
		cmd.InformationClass = InfoClass;

		return SendCmd( IOCTL_SET_THREAD_INFO, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}

	void WaitForSingleObject( std::uint64_t ObjectId, BOOL Alertable, PLARGE_INTEGER Timeout )
	{
		WAIT_OBJECT_PROCESS cmd{ };
		cmd.ObjectValue = ObjectId;
		cmd.Alertable = Alertable;
		cmd.Timeout = Timeout;

		SendCmd( IOCTL_WAIT_FOR_OBJECT, reinterpret_cast< std::uint64_t* >( &cmd ), sizeof( cmd ) );
	}
};

extern std::unique_ptr< CCommand > g_cmdDriver;
```

`commands_id.hpp`:

```hpp
#pragma once

#include <cstdint>

#define CEPTOR_VALID_HANDLE( h )	( ( ( ( std::uint64_t )h >> 20 ) & 0xFFF ) == 0xF0F )

enum IoControlCodes : std::uint32_t
{
	IOCTL_ATTACH_TO_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0000, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_READ_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0001, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_WRITE_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0002, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_QUERY_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ),  //-
	IOCTL_QUERY_INFO_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ),  //-
	IOCTL_QUERY_SYSTEM_INFO_EX = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_SET_INFORMATION_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0006, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_FLUSH_INSTRUCTION_CACHE = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0007, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_FLUSH_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0008, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_ALLOCATE_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0009, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_FREE_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0010, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_LOCK_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0011, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_UNLOCK_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0012, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_PROTECT_MEMORY_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0013, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //-
	IOCTL_OPEN_THREAD = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0014, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_QUERY_THREAD_INFO = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0015, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_SET_THREAD_INFO = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0016, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_GET_CONTEXT_THREAD = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0017, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_SET_CONTEXT_THREAD = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0018, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_RESUME_THREAD = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0019, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_SUSPEND_THREAD = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0020, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_WAIT_FOR_OBJECT = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0021, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ), //
	IOCTL_SUSPEND_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0022, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ),
	IOCTL_RESUME_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0023, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ),
	IOCTL_DETACH_FROM_PROCESS = CTL_CODE( FILE_DEVICE_UNKNOWN, 0x0024, METHOD_BUFFERED, FILE_SPECIAL_ACCESS ) //-
};

typedef struct _ATTACH_PROCESS
{
	std::uint64_t ProcessId;
	std::uint64_t ThreadId;
	std::uint64_t OutProcessHandle;

} ATTACH_PROCESS, * PATTACH_PROCESS;

typedef struct _DETACH_PROCESS
{
	std::uint64_t ProcessHandle;

} DETACH_PROCESS, * PDETACH_PROCESS;

typedef struct _ALLOCMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t BaseAddress;
	std::uint64_t Lenght;
	std::uint32_t Type;
	std::uint32_t Protect;

} ALLOCMEMORY_PROCESS, * PALLOCMEMORY_PROCESS;

typedef struct _FREEMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t Lenght;
	std::uint32_t Type;

} FREEMEMORY_PROCESS, * PFREEMEMORY_PROCESS;

typedef struct _LOCKMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t Lenght;
	std::uint32_t Option;

} LOCKMEMORY_PROCESS, * PLOCKMEMORY_PROCESS;

typedef struct _UNLOCKMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t Lenght;
	std::uint32_t Option;

} UNLOCKMEMORY_PROCESS, * PUNLOCKMEMORY_PROCESS;

typedef struct _READMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t* Buffer;
	std::uint64_t Lenght;
	std::uint64_t* BytesRead;

} READMEMORY_PROCESS, * PREADMEMORY_PROCESS;

typedef struct _WRITEMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t* Buffer;
	std::uint64_t Lenght;
	std::uint64_t* BytesWritten;

} WRITEMEMORY_PROCESS, * PWRITEMEMORY_PROCESS;

typedef struct _FLUSHCACHE_MEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint32_t Lenght;

} FLUSHCACHE_MEMORY_PROCESS, * PFLUSHCACHE_MEMORY_PROCESS;

typedef struct _FLUSHVIRTUAL_MEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t Lenght;
	PIO_STATUS_BLOCK IoStatus;

} FLUSHVIRTUAL_MEMORY_PROCESS, * PFLUSHVIRTUAL_MEMORY_PROCESS;

typedef struct _PROTECTMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint64_t Lenght;
	std::uint32_t NewAccess;
	std::uint32_t* OldAccess;

} PROTECTMEMORY_PROCESS, * PPROTECTMEMORY_PROCESS;

typedef struct _QUERYMEMORY_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint64_t* BaseAddress;
	std::uint32_t InformationClass;
	std::uint64_t* Buffer;
	std::uint64_t Lenght;
	std::uint32_t* ResultLength;

} QUERYMEMORY_PROCESS, * PQUERYMEMORY_PROCESS;

typedef struct _QUERYINFO_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint32_t InformationClass;
	std::uint64_t* Buffer;
	std::uint32_t Lenght;
	std::uint32_t* ResultLength;

} QUERYINFO_PROCESS, * PQUERYINFO_PROCESS;

typedef struct _SETINFO_PROCESS
{
	std::uint64_t ProcessHandle;
	std::uint32_t InformationClass;
	std::uint64_t* Buffer;
	std::uint32_t Lenght;

} SETINFO_PROCESS, * PSETINFO_PROCESS;

typedef struct _QUERY_SYSTEMINFOEX
{
	std::uint32_t InformationClass;
	std::uint64_t* InputBuffer;
	std::uint32_t InputBufferLenght;
	std::uint64_t* SystemInfo;
	std::uint32_t SystemInfoLenght;
	std::uint32_t* ResultLength;

} QUERY_SYSTEMINFOEX, * PQUERY_SYSTEMINFOEX;

typedef struct _OPEN_THREAD_PROCESS
{
	std::uint64_t ProcessId;
	std::uint64_t ThreadId;
	std::uint64_t OutThreadHandle;

} OPEN_THREAD_PROCESS, * POPEN_THREAD_PROCESS;

typedef struct _SET_CONTEXT_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	PCONTEXT Context;
	PCONTEXT Wow64Context;

} SET_CONTEXT_THREAD_PROCESS, * PSET_CONTEXT_THREAD_PROCESS;

typedef struct _GET_CONTEXT_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	PCONTEXT Context;
	PCONTEXT Wow64Context;

} GET_CONTEXT_THREAD_PROCESS, * PGET_CONTEXT_THREAD_PROCESS;

typedef struct _SUSPEND_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	std::uint32_t* Count;

} SUSPEND_THREAD_PROCESS, * PSUSPEND_THREAD_PROCESS;

typedef struct _RESUME_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	std::uint32_t* Count;

} RESUME_THREAD_PROCESS, * PRESUME_THREAD_PROCESS;

typedef struct _QUERYINFO_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	std::uint32_t InformationClass;
	std::uint64_t* ThreadInfo;
	std::uint32_t ThreadInfoLenght;
	std::uint32_t* ResultLenght;

} QUERYINFO_THREAD_PROCESS, * PQUERYINFO_THREAD_PROCESS;

typedef struct _SETINFO_THREAD_PROCESS
{
	std::uint64_t ThreadHandleValue;
	std::uint32_t InformationClass;
	std::uint64_t* ThreadInfo;
	std::uint32_t ThreadInfoLenght;

} SETINFO_THREAD_PROCESS, * PSETINFO_THREAD_PROCESS;

typedef struct _WAIT_OBJECT_PROCESS
{
	std::uint64_t ObjectValue;
	BOOLEAN Alertable;
	PLARGE_INTEGER Timeout;

} WAIT_OBJECT_PROCESS, * PWAIT_OBJECT_PROCESS;

typedef struct _PROCESS_MISC
{
	std::uint64_t ProcessHandle;
	BOOLEAN Suspend;

} PROCESS_MISC, * PPROCESS_MISC;
```

`driverceptor/apc.txt`:

```txt
typedef struct _THREAD_CONTEXT_ARGS
{
	BOOLEAN Query;
	THREADINFOCLASS InfoClass;
	PVOID ThreadInfo;
	ULONG ThreadInfoLenght;
	PULONG ReturnLenght;
	NTSTATUS Status;
} THREAD_CONTEXT_ARGS, * PTHREAD_CONTEXT_ARGS;

VOID NTAPI ApcExcInThreadCtx( PVOID Arg1, PVOID Arg2, PVOID Arg3 )
{
	UNREFERENCED_PARAMETER( Arg3 );

	HANDLE Event = HANDLE( Arg1 );
	PTHREAD_CONTEXT_ARGS Args = PTHREAD_CONTEXT_ARGS( Arg2 );

	DBGPRINT( "%s %d : ApcExcInThreadCtx - Event: 0x%p - Args: 0x%p", __FUNCTION__, __LINE__, Event, Args );

	if ( Args )
	{
		if ( Args->Query == TRUE )
		{
			Args->Status = ZwQueryInformationThread(
				NtCurrentThread(),
				Args->InfoClass,
				Args->ThreadInfo,
				Args->ThreadInfoLenght,
				Args->ReturnLenght );
		}
		else
		{
			Args->Status = ZwSetInformationThread(
				NtCurrentThread(),
				Args->InfoClass,
				Args->ThreadInfo,
				Args->ThreadInfoLenght );
		}

		DBGPRINT( "%s %d : ApcExcInThreadCtx - Status: 0x%X", __FUNCTION__, __LINE__, Args->Status );
	}

	auto Status = ZwSetEvent( Event, nullptr );
	DBGPRINT( "%s %d : ApcExcInThreadCtx - ZwSetEvent = 0x%X.", __FUNCTION__, __LINE__, Status );
}

VOID KernelApcInjectCallback(
	PKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
)
{
	UNREFERENCED_PARAMETER( SystemArgument1 );
	UNREFERENCED_PARAMETER( SystemArgument2 );
	UNREFERENCED_PARAMETER( Apc );
	UNREFERENCED_PARAMETER( NormalContext );

	//DPRINT( "BlackBone: %s: Called. NormalRoutine = 0x%p\n", __FUNCTION__, *NormalRoutine );

	// Skip execution
	if ( PsIsThreadTerminating( PsGetCurrentThread() ) )
		*NormalRoutine = NULL;

	DBGPRINT( "%s %d : KernelApcInjectCallback called - NormalRoutine = 0x%p", __FUNCTION__, __LINE__, *NormalRoutine );

	// Fix Wow64 APC
	//if ( PsGetCurrentProcessWow64Process() != NULL )
	//	PsWrapApcWow64Thread( NormalContext, ( PVOID* )NormalRoutine );
	//ExFreePoolWithTag( Apc, BB_POOL_TAG );
}

VOID KernelApcPrepareCallback(
	PKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
)
{
	UNREFERENCED_PARAMETER( Apc );
	UNREFERENCED_PARAMETER( NormalRoutine );
	UNREFERENCED_PARAMETER( NormalContext );
	UNREFERENCED_PARAMETER( SystemArgument1 );
	UNREFERENCED_PARAMETER( SystemArgument2 );

	DBGPRINT( "%s %d : KernelApcPrepareCallback called", __FUNCTION__, __LINE__ );

	// Alert current thread
	KeTestAlertThread( UserMode );
}

/*HANDLE hSyncEvent{ };

					Status = ZwCreateEvent( &hSyncEvent, GENERIC_READ, nullptr, NotificationEvent, FALSE );
					if ( NT_SUCCESS( Status ) )
					{
						ExAcquireFastMutex( &ExpThreadContextQueryMutex );

						DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO - KTHREAD: 0x%p", __FUNCTION__, __LINE__, Entry->Thread );

						BOOLEAN bSkip = IsSkippabbleThread( Entry->Thread, Entry->Wow64 );
						DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO - Should Skip? %d", __FUNCTION__, __LINE__, bSkip );

						if ( bSkip == FALSE )
						{
							auto Apc = PKAPC( AllocateZeroPool( sizeof( KAPC ) ) );
							KeInitializeApc(
								Apc,
								Entry->Thread,
								OriginalApcEnvironment,
								&KernelApcInjectCallback,
								nullptr,
								ApcExcInThreadCtx,
								UserMode,
								hSyncEvent );

							auto PrepareApc = PKAPC( AllocateZeroPool( sizeof( KAPC ) ) );
							KeInitializeApc(
								PrepareApc, Entry->Thread,
								OriginalApcEnvironment, &KernelApcPrepareCallback,
								NULL, NULL, KernelMode, NULL
							);

							const auto ApcBuffer = PTHREAD_CONTEXT_ARGS( AllocateZeroPool( sizeof( THREAD_CONTEXT_ARGS ) ) );
							if ( ApcBuffer )
							{
								ULONG ResultLen = NULL;

								ApcBuffer->Query = TRUE;
								ApcBuffer->Status = STATUS_TIMEOUT;
								ApcBuffer->InfoClass = THREADINFOCLASS( Buffer->InformationClass );
								ApcBuffer->ThreadInfo = Buffer->ThreadInfo;
								ApcBuffer->ThreadInfoLenght = Buffer->ThreadInfoLenght;
								ApcBuffer->ReturnLenght = &ResultLen;

								if ( KeInsertQueueApc( Apc, ApcBuffer, nullptr, 0 ) )
								{
									KeInsertQueueApc( PrepareApc, NULL, NULL, 0 );

									DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO inserted APC.", __FUNCTION__, __LINE__ );
									Status = ZwWaitForSingleObject( hSyncEvent, FALSE, nullptr );
									ZwClose( hSyncEvent );
								}
								else
									DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO failed to insert APC.", __FUNCTION__, __LINE__ );

								if ( NT_SUCCESS( Status ) )
								{
									if ( Buffer->ResultLenght )
										*Buffer->ResultLenght = ResultLen;

									Status = ApcBuffer->Status;
								}

								ExFreePool( Buffer );
							}
						}

						ExReleaseFastMutex( &ExpThreadContextQueryMutex );
					}*/
```

`driverceptor/driver.cpp`:

```cpp
#include "stdafx.hpp"

PDRIVER_DISPATCH	g_originalDispatcher	= nullptr;
PDRIVER_OBJECT		g_driverObject			= nullptr;

NTSTATUS IoControl( PDEVICE_OBJECT DeviceObject, PIRP Irp )
{
	UNREFERENCED_PARAMETER( DeviceObject );

	NTSTATUS Status = 1337;
	ULONG OutputLenght = 0;

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation( Irp );
	const ULONG InputLenght = stack->Parameters.DeviceIoControl.InputBufferLength;

	//	DBGPRINT( "%s %d : Recieved Ioctl 0x%X", __FUNCTION__, __LINE__, stack->Parameters.DeviceIoControl.IoControlCode );

	switch ( stack->Parameters.DeviceIoControl.IoControlCode )
	{

	case IOCTL_ATTACH_TO_PROCESS:
	{
		const auto Buffer = PATTACH_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( ATTACH_PROCESS ) )
		{
			auto TargetPid = HANDLE( Buffer->ProcessId );
			auto TargetTid = HANDLE( Buffer->ThreadId );

			if ( TargetPid && CEPTOR_VALID_HANDLE( TargetPid ) )
			{
				Status = STATUS_INVALID_HANDLE;
				goto exit;
			}

			if ( TargetPid || TargetTid )
			{
				auto List = InsertHandleListEntry( );
				if ( List )
				{
					Status = PsLookupProcessByProcessId( TargetPid, &List->Process );

					if ( NT_SUCCESS( Status ) )
					{
						Status = STATUS_PROCESS_IS_TERMINATING;

						if ( AcquireProcessSync( List->Process ) )
						{
							Buffer->OutProcessHandle = std::uint64_t( List->HandleValue );

							List->ProcessId = TargetPid;

							if ( List->Process )
								List->Wow64 = ( PsGetProcessWow64Process( List->Process ) != NULL );

							//DBGPRINT( "%s %d : IOCTL_ATTACH_TO_PROCESS - ProcessHandle: 0x%llX - returned 0x%X", __FUNCTION__, __LINE__, Buffer->OutProcessHandle, Status );
							Status = STATUS_SUCCESS;
							ReleaseProcessSync( List->Process );
						}
						else
						{
							ObDereferenceObject( List->Process );
							RemoveHandleListEntry( List );
						}
					}
					else
						RemoveHandleListEntry( List );
				}
			}

		exit:
			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_ATTACH_TO_PROCESS PID = 0x%p, TID = 0x%p, status: 0x%X", __FUNCTION__, __LINE__, TargetPid, TargetTid, Status );

			OutputLenght = sizeof( ATTACH_PROCESS );
		}
		break;
	}

	case IOCTL_DETACH_FROM_PROCESS:
	{
		const auto Buffer = PDETACH_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( DETACH_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( Entry->Process )
					{
						ObDereferenceObject( Entry->Process );
						Entry->Process = nullptr;
					}

					if ( Entry->Thread )
					{
						ObDereferenceObject( Entry->Thread );
						Entry->Thread = nullptr;
					}

					RemoveHandleListEntry( Entry );
					Status = STATUS_SUCCESS;
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_DETACH_FROM_PROCESS - ProcessHandle: 0x%llX - returned 0x%X", __FUNCTION__, __LINE__, Buffer->ProcessHandle, Status );

			OutputLenght = sizeof( DETACH_PROCESS );
		}
		break;
	}

	case IOCTL_READ_MEMORY_PROCESS:
	{
		const auto Buffer = PREADMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( READMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					SIZE_T SizeBuf	= Buffer->Lenght;
					PVOID Address	= Buffer->BaseAddress;
					PVOID Buf		= Buffer->Buffer;

					if ( SizeBuf > 0 )
					{
						SIZE_T numberOfBytesRead = 0;

						Status = MmCopyVirtualMemory(
							Entry->Process, Address,
							PsGetCurrentProcess(),
							Buf,
							SizeBuf,
							ExGetPreviousMode(),
							&numberOfBytesRead
						);

						if ( numberOfBytesRead )
						{
							if ( Buffer->BytesRead )
								*Buffer->BytesRead = numberOfBytesRead;
						}
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_READ_MEMORY_PROCESS PID = 0x%p, ( Base = 0x%p, Buffer = 0x%p, Lenght = 0x%llX ) returned 0x%X", __FUNCTION__, __LINE__, HandleValue , Buffer->BaseAddress, Buffer->Buffer, Buffer->Lenght, Status );

			OutputLenght = sizeof( READMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_WRITE_MEMORY_PROCESS:
	{
		const auto Buffer = PWRITEMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( WRITEMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					SIZE_T Lenght = SIZE_T( Buffer->Lenght );
					SIZE_T BytesWritten = NULL;
					Status = MmCopyVirtualMemory( PsGetCurrentProcess(), Buffer->Buffer, Entry->Process, Buffer->BaseAddress, Lenght, ExGetPreviousMode(), &BytesWritten );

					if ( BytesWritten )
					{
						if ( Buffer->BytesWritten )
							*Buffer->BytesWritten = BytesWritten;
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_WRITE_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( WRITEMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_QUERY_MEMORY_PROCESS:
	{
		const auto Buffer = PQUERYMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( QUERYMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					ULONG InformationClass = ULONG( Buffer->InformationClass );
					SIZE_T Lenght = SIZE_T( Buffer->Lenght );
					SIZE_T RetLenght = NULL;

					auto MemoryInformation = PVOID( AllocateZeroPool( Lenght ) );
					if ( MemoryInformation )
					{
						if ( AcquireProcessSync( Entry->Process ) )
						{
							KAPC_STATE apc{ };
							KeStackAttachProcess( Entry->Process, &apc );
							Status = ZwQueryVirtualMemory(
								NtCurrentProcess(),
								BaseAddress,
								MEMORY_INFORMATION_CLASS( InformationClass ),
								MemoryInformation,
								Lenght,
								&RetLenght );
							KeUnstackDetachProcess( &apc );

							ReleaseProcessSync( Entry->Process );
						}

						if ( NT_SUCCESS( Status ) && RetLenght )
						{
							if( InformationClass == 2 /*MemoryMappedFilenameInformation*/ )
								AdjustRelativePointers( ( std::uint8_t *)MemoryInformation, ( std::uint8_t* )Buffer->Buffer, RetLenght );

							RtlCopyMemory( PVOID( Buffer->Buffer ), MemoryInformation, RetLenght );
						}

						ExFreePool( MemoryInformation );
					}

					if ( Buffer->ResultLength )
						*Buffer->ResultLength = RetLenght & 0xFFFFFFFF;
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_QUERY_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( QUERYMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_QUERY_INFO_PROCESS:
	{
		const auto Buffer = PQUERYINFO_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( QUERYINFO_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					ULONG InformationClass = ULONG( Buffer->InformationClass );
					ULONG Lenght = Buffer->Lenght;
					ULONG RetLenght = NULL;

					auto ProcessInformation = PVOID( AllocateZeroPool( Lenght ) );
					if ( ProcessInformation )
					{
						if ( AcquireProcessSync( Entry->Process ) )
						{
							KAPC_STATE apc{ };
							KeStackAttachProcess( Entry->Process, &apc );

							Status = ZwQueryInformationProcess(
								NtCurrentProcess(),
								PROCESSINFOCLASS( InformationClass ),
								ProcessInformation,
								Lenght,
								&RetLenght );

							KeUnstackDetachProcess( &apc );

							if ( Buffer->ResultLength )
								*Buffer->ResultLength = RetLenght;

							ReleaseProcessSync( Entry->Process );
						}

						if ( NT_SUCCESS( Status ) )
						{
							AdjustRelativePointers( reinterpret_cast< std::uint8_t* >( ProcessInformation ), reinterpret_cast< std::uint8_t* >( Buffer->Buffer ), Lenght );
							RtlCopyMemory( PVOID( Buffer->Buffer ), ProcessInformation, Lenght );
						}

						ExFreePool( ProcessInformation );
						//					DBGPRINT( "%s %d : IOCTL_QUERY_INFO_PROCESS - InfoClass: %d, ProcessInfo = 0x%p, Lenght = 0x%X", __FUNCTION__, __LINE__, InformationClass, Buffer->Buffer, Lenght );	
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_QUERY_INFO_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( QUERYINFO_PROCESS );
		}
		break;
	}

	case IOCTL_QUERY_SYSTEM_INFO_EX:
	{
		const auto Buffer = PQUERY_SYSTEMINFOEX( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( QUERY_SYSTEMINFOEX ) )
		{
			ULONG RetLenght = NULL;
			SYSTEM_INFORMATION_CLASS InfoClass = SYSTEM_INFORMATION_CLASS( Buffer->InformationClass );

			ULONG InputBuffLen = Buffer->InputBufferLenght;
			ULONG SysInfoLen = Buffer->SystemInfoLenght;

			auto SystemInfo = PVOID( AllocateZeroPool( SysInfoLen ) );
			if ( SystemInfo )
			{
				switch ( InfoClass )
				{
				case SystemSupportedProcessArchitectures:
				{
					if ( CEPTOR_VALID_HANDLE( Buffer->InputBuffer ) )
					{
						auto HandleValue = HANDLE( Buffer->InputBuffer );

						if ( HandleValue )
						{
							auto Entry = FindHandleListEntry( HandleValue );
							if ( Entry )
							{
								auto processHandle = NtCurrentProcess();

								if ( AcquireProcessSync( Entry->Process ) )
								{
									KAPC_STATE apc{ };
									KeStackAttachProcess( Entry->Process, &apc );

									Status =
										ZwQuerySystemInformationEx(
											InfoClass,
											&processHandle,
											InputBuffLen,
											SystemInfo,
											SysInfoLen,
											&RetLenght );

									KeUnstackDetachProcess( &apc );

									if ( Buffer->ResultLength )
										*Buffer->ResultLength = RetLenght;

									ReleaseProcessSync( Entry->Process );
								}

								if ( NT_SUCCESS( Status ) )
									RtlCopyMemory( PVOID( Buffer->SystemInfo ), SystemInfo, SysInfoLen );
							}
						}

						//	DBGPRINT( "%s %d : IOCTL_QUERY_SYSTEM_INFO_EX - Special - returned 0x%X", __FUNCTION__, __LINE__, Status );
					}
					//else
					//	DBGPRINT( "%s %d : IOCTL_QUERY_SYSTEM_INFO_EX - SystemSupportedProcessArchitectures - Ptr: 0x%p", __FUNCTION__, __LINE__, Buffer->InputBuffer );

					break;
				}

				default:
				{
					Status = ZwQuerySystemInformationEx(
						InfoClass,
						Buffer->InputBuffer,
						Buffer->InputBufferLenght,
						SystemInfo,
						SysInfoLen,
						&RetLenght );

					if ( Buffer->ResultLength )
						*Buffer->ResultLength = RetLenght;

					if ( NT_SUCCESS( Status ) )
						RtlCopyMemory( PVOID( Buffer->SystemInfo ), SystemInfo, SysInfoLen );

					break;
				}
				}

				ExFreePool( SystemInfo );
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_QUERY_SYSTEM_INFO_EX returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( QUERY_SYSTEMINFOEX );
		}
		break;
	}

	case IOCTL_SET_INFORMATION_PROCESS:
	{
		const auto Buffer = PSETINFO_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( SETINFO_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					ULONG InformationClass = ULONG( Buffer->InformationClass );
					ULONG Lenght = Buffer->Lenght;

					auto ProcessInfo = PVOID( AllocateZeroPool( Lenght ) );
					if ( ProcessInfo )
					{
						RtlCopyMemory( ProcessInfo, PVOID( Buffer->Buffer ), Lenght );

						if ( AcquireProcessSync( Entry->Process ) )
						{
							KAPC_STATE apc{ };
							KeStackAttachProcess( Entry->Process, &apc );
							Status = ZwSetInformationProcess( NtCurrentProcess(), PROCESSINFOCLASS( InformationClass ), ProcessInfo, Lenght );
							KeUnstackDetachProcess( &apc );

							ReleaseProcessSync( Entry->Process );
						}

						ExFreePool( ProcessInfo );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_SET_INFORMATION_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( SETINFO_PROCESS );
		}
		break;
	}

	case IOCTL_FLUSH_INSTRUCTION_CACHE:
	{
		const auto Buffer = PFLUSHCACHE_MEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( FLUSHCACHE_MEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( AcquireProcessSync( Entry->Process ) )
					{
						PVOID BaseAddress = PVOID( Buffer->BaseAddress );
						ULONG Lenght = ULONG( Buffer->Lenght );

						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwFlushInstructionCache( NtCurrentProcess(), &BaseAddress, Lenght );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_FLUSH_INSTRUCTION_CACHE returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( FLUSHCACHE_MEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_FLUSH_MEMORY_PROCESS:
	{
		const auto Buffer = PFLUSHVIRTUAL_MEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( FLUSHVIRTUAL_MEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );

					auto IoStatus = PIO_STATUS_BLOCK( AllocateZeroPool( sizeof( IO_STATUS_BLOCK ) ) );
					if ( IoStatus )
					{
						if ( AcquireProcessSync( Entry->Process ) )
						{
							KAPC_STATE apc{ };
							KeStackAttachProcess( Entry->Process, &apc );
							Status = ZwFlushVirtualMemory( NtCurrentProcess(), &BaseAddress, &RegionSize, IoStatus );
							KeUnstackDetachProcess( &apc );

							ReleaseProcessSync( Entry->Process );
						}

						if ( NT_SUCCESS( Status ) && Buffer->IoStatus && MmIsAddressValid( Buffer->IoStatus ) )
							RtlCopyMemory( Buffer->IoStatus, IoStatus, sizeof( IO_STATUS_BLOCK ) );

						ExFreePool( IoStatus );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_FLUSH_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( FLUSHVIRTUAL_MEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_ALLOCATE_MEMORY_PROCESS:
	{
		auto Buffer = PALLOCMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( ALLOCMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );
					ULONG Type = Buffer->Type;
					ULONG Protect = Buffer->Protect;

					if ( AcquireProcessSync( Entry->Process ) )
					{
						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwAllocateVirtualMemory( NtCurrentProcess(), &BaseAddress, NULL, &RegionSize, Type, Protect );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}

					if ( NT_SUCCESS( Status ) )
						Buffer->BaseAddress = std::uint64_t( BaseAddress );
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_ALLOCATE_MEMORY_PROCESS - Base: 0x%llX - returned 0x%X", __FUNCTION__, __LINE__, Buffer->BaseAddress, Status );

			OutputLenght = sizeof( ALLOCMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_FREE_MEMORY_PROCESS:
	{
		const auto Buffer = PFREEMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( FREEMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );
					ULONG Type = Buffer->Type;

					if ( AcquireProcessSync( Entry->Process ) )
					{
						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwFreeVirtualMemory( NtCurrentProcess(), &BaseAddress, &RegionSize, Type );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_FREE_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( FREEMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_LOCK_MEMORY_PROCESS:
	{
		const auto Buffer = PLOCKMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( LOCKMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );
					ULONG Option = ULONG( Buffer->Option );

					if ( AcquireProcessSync( Entry->Process ) )
					{
						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwLockVirtualMemory( NtCurrentProcess(), &BaseAddress, &RegionSize, Option );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_LOCK_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( LOCKMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_UNLOCK_MEMORY_PROCESS:
	{
		const auto Buffer = PUNLOCKMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( UNLOCKMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );
					ULONG Option = ULONG( Buffer->Option );

					if ( AcquireProcessSync( Entry->Process ) )
					{
						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwUnlockVirtualMemory( NtCurrentProcess(), &BaseAddress, &RegionSize, Option );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_UNLOCK_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( UNLOCKMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_PROTECT_MEMORY_PROCESS:
	{
		const auto Buffer = PPROTECTMEMORY_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( PROTECTMEMORY_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ProcessHandle );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					PVOID BaseAddress = PVOID( Buffer->BaseAddress );
					SIZE_T RegionSize = SIZE_T( Buffer->Lenght );
					ULONG NewAccess = ULONG( Buffer->NewAccess );
					ULONG OldAccess = NULL;

					if ( AcquireProcessSync( Entry->Process ) )
					{
						KAPC_STATE apc{ };
						KeStackAttachProcess( Entry->Process, &apc );
						Status = ZwProtectVirtualMemory( NtCurrentProcess(), &BaseAddress, &RegionSize, NewAccess, &OldAccess );
						KeUnstackDetachProcess( &apc );

						ReleaseProcessSync( Entry->Process );
					}

					if ( Buffer->OldAccess )
						*Buffer->OldAccess = OldAccess;
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_PROTECT_MEMORY_PROCESS returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( PROTECTMEMORY_PROCESS );
		}
		break;
	}

	case IOCTL_OPEN_THREAD:
	{
		const auto Buffer = POPEN_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( OPEN_THREAD_PROCESS ) )
		{
			auto TargetProcessId = HANDLE( Buffer->ProcessId );
			auto TargetThreadId = HANDLE( Buffer->ThreadId );

			auto List = InsertHandleListEntry( );
			if ( List )
			{
				if ( TargetThreadId && TargetProcessId )
				{
					CLIENT_ID cid{ };
					cid.UniqueProcess = TargetProcessId;
					cid.UniqueThread = TargetThreadId;

					Status = PsLookupProcessThreadByCid( &cid, &List->Process, &List->Thread );
					if ( NT_SUCCESS( Status ) )
					{
						Status = STATUS_THREAD_IS_TERMINATING;

						if ( AcquireThreadSync( List->Thread ) )
						{
							List->ProcessId = TargetProcessId;
							List->Wow64 = ( PsGetProcessWow64Process( List->Process ) != NULL );
							Buffer->OutThreadHandle = std::uint64_t( List->HandleValue );
						}
						else
						{
							ObDereferenceObject( List->Process );
							ObDereferenceObject( List->Thread );
							RemoveHandleListEntry( List );
						}
					}
					else
						RemoveHandleListEntry( List );
				}
				else if ( TargetThreadId && !TargetProcessId )
				{
					Status = PsLookupThreadByThreadId( TargetThreadId, &List->Thread );
					if ( NT_SUCCESS( Status )  )
					{
						Status = STATUS_THREAD_IS_TERMINATING;

						if ( AcquireThreadSync( List->Thread ) )
						{
							List->Process = PsGetThreadProcess( List->Thread );
							List->ProcessId = TargetProcessId;
							List->Wow64 = ( PsGetProcessWow64Process( List->Process ) != NULL );
							Buffer->OutThreadHandle = std::uint64_t( List->HandleValue );
						}
						else
						{
							ObDereferenceObject( List->Thread );
							RemoveHandleListEntry( List );
						}
					}
					else
						RemoveHandleListEntry( List );
				}
				else
					Status = STATUS_INVALID_PARAMETER;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_OPEN_THREAD - returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( OPEN_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_SET_CONTEXT_THREAD:
	{
		const auto Buffer = PSET_CONTEXT_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( SET_CONTEXT_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( AcquireThreadSync( Entry->Thread ) )
					{
						if ( !Entry->Wow64 )
							Status = PsSetContextThread( Entry->Thread, Buffer->Context, UserMode );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_SET_CONTEXT_THREAD returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( SET_CONTEXT_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_GET_CONTEXT_THREAD:
	{
		const auto Buffer = PGET_CONTEXT_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( GET_CONTEXT_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( AcquireThreadSync( Entry->Thread ) )
					{
						if ( !Entry->Wow64 )
							Status = PsGetContextThread( Entry->Thread, Buffer->Context, UserMode );
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_GET_CONTEXT_THREAD returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( GET_CONTEXT_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_SUSPEND_THREAD:
	{
		const auto Buffer = PSUSPEND_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( SUSPEND_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					ULONG Count = NULL;

					if ( AcquireThreadSync( Entry->Thread ) )
					{
						if ( !Entry->Wow64 )
							Status = PsSuspendThread( Entry->Thread, &Count );

						if ( Buffer->Count )
							*Buffer->Count = Count;
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_SUSPEND_THREAD returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( SUSPEND_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_RESUME_THREAD:
	{
		const auto Buffer = PRESUME_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( RESUME_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					ULONG Count = NULL;

					if ( AcquireThreadSync( Entry->Thread ) )
					{
						if ( !Entry->Wow64 )
							Status = PsResumeThread( Entry->Thread, &Count );

						if ( Buffer->Count )
							*Buffer->Count = Count;
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_RESUME_THREAD returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( RESUME_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_QUERY_THREAD_INFO:
	{
		const auto Buffer = PQUERYINFO_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( QUERYINFO_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( AcquireThreadSync( Entry->Thread ) )
					{
						PUCHAR tebBaseAddress = PUCHAR( PsGetThreadTeb( Entry->Thread ) );

						if ( Entry->Wow64 )
							tebBaseAddress += 0x2000;

						KeEnterGuardedRegion();

						std::uint8_t info[ THREAD_INFO_SIZE ] = { 0 };
						memcpy( info, PsGetCurrentThread(), THREAD_INFO_SIZE );

						for ( ULONG i = 0; i < ARRAYSIZE( THREAD_INFO_SECTIONS ); i += 2 )
						{
							ULONG start = THREAD_INFO_SECTIONS[ i ];
							ULONG end = THREAD_INFO_SECTIONS[ i + 1 ];
							memcpy( ( std::uint8_t* )PsGetCurrentThread() + start, ( std::uint8_t* )Entry->Thread + start, end - start );
						}

						ULONG ResultLen = NULL;

						Status = ZwQueryInformationThread(
							NtCurrentThread(),
							THREADINFOCLASS( Buffer->InformationClass ),
							Buffer->ThreadInfo,
							Buffer->ThreadInfoLenght,
							&ResultLen
						);

						if ( Buffer->ResultLenght )
							*Buffer->ResultLenght = ResultLen;

						if (
							NT_SUCCESS( Status ) &&
							Buffer->InformationClass == ThreadBasicInformation &&
							Buffer->ThreadInfo &&
							Buffer->ThreadInfoLenght >= sizeof( PTHREAD_BASIC_INFORMATION ) )
						{
							auto tbi = PTHREAD_BASIC_INFORMATION( Buffer->ThreadInfo );
							tbi->TebBaseAddress = tebBaseAddress;

							//	DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO - Copy TEB = 0x%p 0x%p", __FUNCTION__, __LINE__, tbi->TebBaseAddress, tebBaseAddress );
						}
						else
							Status = STATUS_INVALID_PARAMETER;

						for ( ULONG i = 0; i < ARRAYSIZE( THREAD_INFO_SECTIONS ); i += 2 )
						{
							ULONG start = THREAD_INFO_SECTIONS[ i ];
							ULONG end = THREAD_INFO_SECTIONS[ i + 1 ];
							ULONG len = end - start;

							memcpy( ( std::uint8_t* )Entry->Thread + start, ( std::uint8_t* )PsGetCurrentThread() + start, len );
							memcpy( ( std::uint8_t* )PsGetCurrentThread() + start, ( std::uint8_t* )info + start, len );
						}

						KeLeaveGuardedRegion();
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_QUERY_THREAD_INFO returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( QUERYINFO_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_SET_THREAD_INFO:
	{
		const auto Buffer = PSETINFO_THREAD_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( SETINFO_THREAD_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ThreadHandleValue );

			if ( HandleValue )
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( AcquireThreadSync( Entry->Thread ) )
					{
						KeEnterGuardedRegion();

						switch ( Buffer->InformationClass )
						{

						case ThreadZeroTlsCell:
							Status = STATUS_NOT_IMPLEMENTED;
							break;

						case ThreadIdealProcessor:
						{
							if ( !Buffer->ThreadInfo )
							{
								Status = STATUS_INVALID_PARAMETER;
								break;
							}

							if ( Buffer->ThreadInfoLenght != sizeof( ULONG ) )
							{
								Status = STATUS_INFO_LENGTH_MISMATCH;
								break;
							}

							ULONG idealProcessor = 0;
							RtlCopyMemory( PVOID( Buffer->ThreadInfo ), &idealProcessor, sizeof( idealProcessor ) );

							Status = KeSetIdealProcessorThread( Entry->Thread, ( UCHAR )idealProcessor );
							break;
						}

						default:
							if ( NT_SUCCESS( Status = PsSuspendThread( Entry->Thread, 0 ) ) )
							{
								std::uint8_t info[ THREAD_INFO_SIZE ] = { 0 };
								memcpy( info, PsGetCurrentThread(), THREAD_INFO_SIZE );

								for ( ULONG i = 0; i < ARRAYSIZE( THREAD_INFO_SECTIONS ); i += 2 )
								{
									ULONG start = THREAD_INFO_SECTIONS[ i ];
									ULONG end = THREAD_INFO_SECTIONS[ i + 1 ];
									memcpy( ( std::uint8_t* )PsGetCurrentThread() + start, ( std::uint8_t* )Entry->Thread + start, end - start );
								}

								Status = ZwSetInformationThread(
									NtCurrentThread(),
									THREADINFOCLASS( Buffer->InformationClass ),
									Buffer->ThreadInfo,
									Buffer->ThreadInfoLenght );

								for ( ULONG i = 0; i < ARRAYSIZE( THREAD_INFO_SECTIONS ); i += 2 )
								{
									ULONG start = THREAD_INFO_SECTIONS[ i ];
									ULONG end = THREAD_INFO_SECTIONS[ i + 1 ];
									ULONG len = end - start;

									memcpy( ( std::uint8_t* )Entry->Thread + start, ( std::uint8_t* )PsGetCurrentThread() + start, len );
									memcpy( ( std::uint8_t* )PsGetCurrentThread() + start, ( std::uint8_t* )info + start, len );
								}

								PsResumeThread( Entry->Thread, 0 );
							}

							break;
						}

						KeLeaveGuardedRegion();
					}
				}
				else
					Status = STATUS_NOT_FOUND;
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_SET_THREAD_INFO returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( SETINFO_THREAD_PROCESS );
		}
		break;
	}

	case IOCTL_WAIT_FOR_OBJECT:
	{
		const auto Buffer = PWAIT_OBJECT_PROCESS( Irp->AssociatedIrp.SystemBuffer );
		if ( Buffer && InputLenght >= sizeof( WAIT_OBJECT_PROCESS ) )
		{
			auto HandleValue = HANDLE( Buffer->ObjectValue );

			HANDLE hHandle{ };

			if ( !CEPTOR_VALID_HANDLE( HandleValue ) )
			{
				PEPROCESS Process = nullptr;
				Status = PsLookupProcessByProcessId( HandleValue, &Process );
				if ( !NT_SUCCESS( Status ) )
				{
					PETHREAD Thread = nullptr;
					Status = PsLookupThreadByThreadId( HandleValue, &Thread );
					if ( NT_SUCCESS( Status ) )
					{
						Status = ObOpenObjectByPointer( Thread, 0, 0, SYNCHRONIZE, *PsThreadType, KernelMode, &hHandle );
						ObDereferenceObject( Thread );
					}
				}
				else
				{
					Status = ObOpenObjectByPointer( Process, 0, 0, SYNCHRONIZE, *PsProcessType, KernelMode, &hHandle );
					ObDereferenceObject( Process );
				}
				//	DBGPRINT( "%s %d : IOCTL_WAIT_FOR_OBJECT - NON Ceptor handle returned 0x%X", __FUNCTION__, __LINE__, Status );
			}
			else
			{
				auto Entry = FindHandleListEntry( HandleValue );
				if ( Entry )
				{
					if ( Entry->Thread )
					{
						if ( AcquireThreadSync( Entry->Thread ) )
						{
							Status = ObOpenObjectByPointer( Entry->Thread, 0, 0, SYNCHRONIZE, *PsThreadType, KernelMode, &hHandle );
						}
					}
					else if ( Entry->Process )
					{
						if ( AcquireProcessSync( Entry->Process ) )
						{
							Status = ObOpenObjectByPointer( Entry->Process, 0, 0, SYNCHRONIZE, *PsProcessType, KernelMode, &hHandle );
							ReleaseProcessSync( Entry->Process );
						}
					}
					//	DBGPRINT( "%s %d : IOCTL_WAIT_FOR_OBJECT - Ceptor found and returned 0x%X", __FUNCTION__, __LINE__, Status );
				}
				//else
				//	DBGPRINT( "%s %d : IOCTL_WAIT_FOR_OBJECT Handle: 0x%p not found.", __FUNCTION__, __LINE__, HandleValue );
			}

			if ( NT_SUCCESS( Status ) )
			{
				Status = ZwWaitForSingleObject( hHandle, Buffer->Alertable, Buffer->Timeout );
				ZwClose( hHandle );
			}

			if ( !NT_SUCCESS( Status ) )
				DBGPRINT( "%s %d : IOCTL_WAIT_FOR_OBJECT returned 0x%X", __FUNCTION__, __LINE__, Status );

			OutputLenght = sizeof( WAIT_OBJECT_PROCESS );
		}
		break;
	}

	}

	if ( Status != 1337 )
	{
		Irp->IoStatus.Status = Status;
		Irp->IoStatus.Information = OutputLenght;
		IoCompleteRequest( Irp, IO_NO_INCREMENT );
		//DBGPRINT( "%s %d : Completed request status 0x%X - SystemBuffer: 0x%p", __FUNCTION__, __LINE__, Status, Irp->AssociatedIrp.SystemBuffer );
		return Status;
	}
	//else if ( Status == 1337 )
	//	DBGPRINT( "%s %d : Something was invalid, return len: %d", __FUNCTION__, __LINE__, OutputLenght );

	return g_originalDispatcher( DeviceObject, Irp );
}

NTSTATUS IoCompletedReq( PDEVICE_OBJECT DeviceObject, PIRP irp )
{
	UNREFERENCED_PARAMETER( DeviceObject );

	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest( irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

void HijackDispatcher()
{
	UNICODE_STRING driver_name = RTL_CONSTANT_STRING( L"\\Driver\\klhk" );

	auto status = ObReferenceObjectByName(
		&driver_name,
		OBJ_CASE_INSENSITIVE,
		nullptr,
		0,
		*IoDriverObjectType,
		KernelMode,
		nullptr,
		( PVOID* )&g_driverObject
	);

	if ( !g_driverObject || !NT_SUCCESS( status ) )
	{
		DBGPRINT( "%s %d : ObReferenceObjectByName returned 0x%08X driver_object: 0x%016X", __FUNCTION__, __LINE__, status, g_driverObject );
		return;
	}

	//g_driverObject->DeviceObject->Flags |= DO_BUFFERED_IO;
	g_originalDispatcher = g_driverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ];
	InterlockedExchangePointer( ( volatile PVOID* )&g_driverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ], &IoControl );

	DBGPRINT( "Swapped dispatcher from 0x%llX to 0x%llX", g_originalDispatcher, g_driverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] );
}

void DriverUnload( PDRIVER_OBJECT DriverObject )
{
	UNREFERENCED_PARAMETER( DriverObject );

	if ( g_originalDispatcher && g_driverObject )
	{
		DBGPRINT( "Restored dispatcher from 0x%llX to 0x%llX", g_driverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ], g_originalDispatcher );

		InterlockedExchangePointer( ( volatile PVOID* )&g_driverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ], g_originalDispatcher );
		ObDereferenceObject( g_driverObject );
	}
}

extern "C" NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath )
{
	UNREFERENCED_PARAMETER( RegistryPath );

	KeInitializeSpinLock( &__HANDLES_LOCK );
	__HANDLES_LIST_HEAD = InitializeHandleList();

	*( PVOID* )&PsResumeThread	= resolve_call( FindPattern( "ntoskrnl.exe", "PAGE", PUCHAR( "\xE8\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\x4C\x24\x00\xE8\x00\x00\x00\x00\x90\x48\x85\xDB" ), "x????x????xxxx?x????xxxx" ) );
	*( PVOID* )&PsSuspendThread = resolve_call( FindPattern( "ntoskrnl.exe", "PAGE", PUCHAR( "\xE8\x00\x00\x00\x00\x48\x8B\xD7\x48\x8B\xCE\xE8\x00\x00\x00\x00\x48\x8B\xF8" ), "x????xxxxxxx????xxx" ) );

	auto sig = FindPattern( "ntoskrnl.exe", "PAGE", PUCHAR( "\x8A\x88\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xF6\xD8" ), "xx????x????xx" );
	if ( sig )
	{
		while ( *sig != 0xE8 )
			++sig;

		*( PVOID* )&KeTestAlertThread = resolve_call( sig );
	}

	DriverObject->DriverUnload = DriverUnload;
	HijackDispatcher();

	return STATUS_SUCCESS;
}
```

`driverceptor/driver_hooks.hpp`:

```hpp
#pragma once

f_NtCreateFile                o_NtCreateFile = nullptr;
f_NtOpenProcess               o_NtOpenProcess = nullptr;
f_NtQuerySystemInformation    o_NtQuerySystemInformation = nullptr;
f_NtQueryInformationProcess   o_NtQueryInformationProcess = nullptr;
f_NtLoadDriver                o_NtLoadDriver = nullptr;
f_NtGdiBitBlt                 o_NtGdiBitBlt = nullptr;
f_NtUserFindWindowEx          o_NtUserFindWindowEx = nullptr;
f_NtUserBuildHwndList         o_NtUserBuildHwndList = nullptr;
f_NtUserGetForegroundWindow   o_NtUserGetForegroundWindow = nullptr;
f_NtUserGetThreadState        o_NtUserGetThreadState = nullptr;
f_NtUserSetWindowsHookEx      o_NtUserSetWindowsHookEx = nullptr;
f_NtUserSetWinEventHook       o_NtUserSetWinEventHook = nullptr;
f_NtUserGetClassName          o_NtUserGetClassName = nullptr;
f_NtUserInternalGetWindowText o_NtUserInternalGetWindowText = nullptr;
f_NtUserInternalGetWindowIcon o_NtUserInternalGetWindowIcon = nullptr;

//ZwRaiseException 
```

`driverceptor/driverceptor.inf`:

```inf
;
; driverceptor.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=driverceptor.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="driverceptor Source Disk"

```

`driverceptor/driverceptor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>driverceptor</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(CRT_IncludePath);$(KM_IncludePath);$(KIT_SHARED_IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(VC_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="driverceptor.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver_hooks.hpp" />
    <ClInclude Include="handles.hpp" />
    <ClInclude Include="helpers.hpp" />
    <ClInclude Include="kernel.hpp" />
    <ClInclude Include="stdafx.hpp" />
    <ClInclude Include="tools.hpp" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="apc.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driverceptor/driverceptor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="driverceptor.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver_hooks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tools.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="handles.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helpers.hpp">
      <Filter>Driver Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Text Include="apc.txt">
      <Filter>Header Files</Filter>
    </Text>
  </ItemGroup>
</Project>
```

`driverceptor/handles.hpp`:

```hpp
#pragma once

typedef struct _HANDLES_LIST_ENTRY
{
	PETHREAD Thread;
	PEPROCESS Process;
	LIST_ENTRY Entry;
	HANDLE HandleValue;
	HANDLE ProcessId;
	BOOLEAN Wow64;

} HANDLES_LIST_ENTRY, * PHANDLES_LIST_ENTRY;

volatile LONG		__HANDLES_VALUE = 0xF0F00000;
PHANDLES_LIST_ENTRY __HANDLES_LIST_HEAD = nullptr;
KSPIN_LOCK			__HANDLES_LOCK;

PHANDLES_LIST_ENTRY InitializeHandleList()
{
	const auto List = PHANDLES_LIST_ENTRY( AllocateZeroPool( sizeof( HANDLES_LIST_ENTRY ) ) );
	if ( !List )
		return nullptr;

	DBGPRINT( "Initialized list head at 0x%p", List );
	InitializeListHead( &List->Entry );
	return List;
}

PHANDLES_LIST_ENTRY InsertHandleListEntry()
{
	const auto Entry = PHANDLES_LIST_ENTRY( AllocateZeroPool( sizeof( HANDLES_LIST_ENTRY ) ) );
	if ( !Entry )
		return nullptr;

	KIRQL oldIrql;
	KeAcquireSpinLock( &__HANDLES_LOCK, &oldIrql );
	Entry->HandleValue = ULongToHandle( InterlockedIncrement( &__HANDLES_VALUE ) );
	InsertTailList( &__HANDLES_LIST_HEAD->Entry, &Entry->Entry );
	KeReleaseSpinLock( &__HANDLES_LOCK, oldIrql );

	return Entry;
}

void RemoveHandleListEntry( PHANDLES_LIST_ENTRY Entry )
{
	if ( !Entry )
		return;

	KIRQL oldIrql;
	KeAcquireSpinLock( &__HANDLES_LOCK, &oldIrql );
	RemoveEntryList( &Entry->Entry );
	KeReleaseSpinLock( &__HANDLES_LOCK, oldIrql );
	ExFreePool( Entry );
}

PHANDLES_LIST_ENTRY FindHandleListEntry( HANDLE HandleValue )
{
	if ( IsListEmpty( &__HANDLES_LIST_HEAD->Entry ) )
		return nullptr;

	PHANDLES_LIST_ENTRY Found = nullptr;
	PLIST_ENTRY ListEntry = nullptr;

	KIRQL oldIrql;
	KeAcquireSpinLock( &__HANDLES_LOCK, &oldIrql );
	for
		(
			ListEntry = __HANDLES_LIST_HEAD->Entry.Flink;
			ListEntry != &__HANDLES_LIST_HEAD->Entry;
			ListEntry = ListEntry->Flink
			)
	{
		auto Data = CONTAINING_RECORD( ListEntry, HANDLES_LIST_ENTRY, Entry );

		if ( Data->HandleValue == HandleValue )
			Found = Data;

		if ( Found )
			break;
	}
	KeReleaseSpinLock( &__HANDLES_LOCK, oldIrql );
	return Found;
}

void ClearHandleList()
{
	// TODO..
}
```

`driverceptor/helpers.hpp`:

```hpp
#pragma once

inline PVOID AllocateZeroPool( SIZE_T size )
{
	auto PoolPtr = ExAllocatePool( NonPagedPool, size );

	if ( PoolPtr )
		RtlZeroMemory( PoolPtr, size );

	return PoolPtr;
}

inline VOID AdjustRelativePointers( std::uint8_t* buffer, std::uint8_t* target, SIZE_T size )
{
	if ( size < sizeof( PVOID ) ) {
		return;
	}

	for ( SIZE_T i = 0; i <= size - sizeof( PVOID ); i += sizeof( ULONG ) )
	{
		PVOID* ptr = ( PVOID* )( buffer + i );
		SIZE_T offset = ( std::uint8_t* ) * ptr - buffer;

		if ( offset < size ) {
			*ptr = target + offset;
			i += sizeof( ULONG );
		}
	}
}

__forceinline bool AcquireProcessSync( PEPROCESS Process )
{
	return ( PsGetProcessExitProcessCalled( Process ) == FALSE && NT_SUCCESS( PsAcquireProcessExitSynchronization( Process ) ) );
}

__forceinline void ReleaseProcessSync( PEPROCESS Process )
{
	PsReleaseProcessExitSynchronization( Process );
}

__forceinline bool AcquireThreadSync( PETHREAD Thread )
{
	return ( PsIsThreadTerminating( Thread ) == FALSE && PsGetThreadExitStatus( Thread ) == STATUS_PENDING );
}
```

`driverceptor/kernel.hpp`:

```hpp
#pragma once

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT, * PKAPC_ENVIRONMENT;

typedef enum _SYSTEM_INFORMATION_CLASS 
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	SystemSupportedProcessArchitectures = 0xb5,
} SYSTEM_INFORMATION_CLASS;

typedef struct _THREAD_BASIC_INFORMATION 
{
	NTSTATUS                ExitStatus;
	PVOID                   TebBaseAddress;
	CLIENT_ID               ClientId;
	KAFFINITY               AffinityMask;
	KPRIORITY               Priority;
	KPRIORITY               BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef VOID( NTAPI* PKNORMAL_ROUTINE )(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID( NTAPI* PKKERNEL_ROUTINE )(
	PRKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
	);

typedef VOID( NTAPI* PKRUNDOWN_ROUTINE )( PRKAPC Apc );

EXTERN_C
{
	NTSYSCALLAPI POBJECT_TYPE * IoDriverObjectType;

NTSYSCALLAPI BOOLEAN NTAPI
KeInsertQueueApc(
	IN  PRKAPC Apc,
	IN  PVOID SystemArgument1,
	IN  PVOID SystemArgument2,
	IN  KPRIORITY Increment
);

NTSYSCALLAPI VOID NTAPI
KeInitializeApc(
	IN  PRKAPC Apc,
	IN  PRKTHREAD Thread,
	IN  KAPC_ENVIRONMENT Environment,
	IN  PKKERNEL_ROUTINE KernelRoutine,
	IN  PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
	IN  PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
	IN  KPROCESSOR_MODE ApcMode OPTIONAL,
	IN  PVOID NormalContext OPTIONAL
);

NTSYSCALLAPI NTSTATUS NTAPI ZwQueryInformationThread(
	_In_      HANDLE          ThreadHandle,
	_In_      THREADINFOCLASS ThreadInformationClass,
	_In_      PVOID           ThreadInformation,
	_In_      ULONG           ThreadInformationLength,
	_Out_opt_ PULONG          ReturnLength
);

NTSYSCALLAPI NTSTATUS NTAPI
PsGetContextThread(
	__in PETHREAD Thread,
	__inout PCONTEXT ThreadContext,
	__in KPROCESSOR_MODE Mode
);

NTSYSCALLAPI NTSTATUS NTAPI
PsSetContextThread(
	__in PETHREAD Thread,
	__in PCONTEXT ThreadContext,
	__in KPROCESSOR_MODE Mode
);

NTKERNELAPI NTSTATUS NTAPI PsLookupProcessThreadByCid( PCLIENT_ID ClientId, PEPROCESS* Process, PETHREAD* Thread );

NTKERNELAPI PPEB NTAPI PsGetProcessPeb( IN PEPROCESS Process );
NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process( IN PEPROCESS Process );

NTKERNELAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader( PVOID Base );

NTKERNELAPI
NTSTATUS
NTAPI


ZwFlushInstructionCache(



	IN HANDLE               ProcessHandle,
	IN PVOID                BaseAddress,
	IN ULONG                NumberOfBytesToFlush );

NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(


	IN HANDLE               ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN OUT PSIZE_T           NumberOfBytesToProtect,
	IN ULONG                NewAccessProtection,
	OUT PULONG              OldAccessProtection );


NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(


	IN HANDLE               ProcessHandle,
	IN PVOID* BaseAddress,
	IN OUT PSIZE_T           NumberOfBytesToUnlock,
	IN ULONG                LockType );

NTSYSAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
	IN HANDLE               ProcessHandle,
	IN PVOID* BaseAddress,
	IN OUT PSIZE_T           NumberOfBytesToLock,
	IN ULONG                LockOption );

	NTSYSCALLAPI NTSTATUS NTAPI MmCopyVirtualMemory( PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize );
NTSYSCALLAPI NTSTATUS NTAPI ObReferenceObjectByName( PUNICODE_STRING ObjectName, ULONG Attributes, PACCESS_STATE AccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext OPTIONAL, PVOID* Object );
NTSYSCALLAPI NTSTATUS NTAPI ZwQueryInformationProcess(
	_In_      HANDLE           ProcessHandle,
	_In_      PROCESSINFOCLASS ProcessInformationClass,
	_Out_     PVOID            ProcessInformation,
	_In_      ULONG            ProcessInformationLength,
	_Out_opt_ PULONG           ReturnLength
);

NTSYSCALLAPI NTSTATUS NTAPI ZwSetInformationProcess( __in HANDLE 	ProcessHandle,
	__in PROCESSINFOCLASS 	ProcessInformationClass,
	__in_bcount( ProcessInformationLength ) PVOID 	ProcessInformation,
	__in ULONG 	ProcessInformationLength
);

NTSYSCALLAPI NTSTATUS
ZwQuerySystemInformationEx(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID InputBuffer,
	ULONG InputBufferLength,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	ULONG* ReturnLength );

NTSYSAPI NTSTATUS			NTAPI ZwQuerySystemInformation( SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG );

NTKERNELAPI PVOID NTAPI PsGetThreadTeb( PETHREAD Thread );

NTKERNELAPI BOOLEAN NTAPI PsGetProcessExitProcessCalled( PEPROCESS Process );

EXTERN_C
NTSTATUS
NTAPI
PsAcquireProcessExitSynchronization(
	_In_ PEPROCESS Process
);

EXTERN_C
VOID
NTAPI
PsReleaseProcessExitSynchronization(
	_In_ PEPROCESS Process
);
};

NTSTATUS( NTAPI* PsResumeThread ) ( IN PETHREAD pEThread, OUT PULONG PreviousCount ) = nullptr;
NTSTATUS( NTAPI* PsSuspendThread )( IN PETHREAD pEThread, OUT PULONG PreviousSuspendCount ) = nullptr;
BOOLEAN( NTAPI* KeTestAlertThread)( IN  KPROCESSOR_MODE AlertMode ) = nullptr;

#define THREAD_INFO_SIZE (0x6E4)
static ULONG THREAD_INFO_SECTIONS[] = { 0x78, 0x7C, 0xC3, 0xC5, 0x220, 0x228, 0x233, 0x234, 0x240, 0x250, 0x28C, 0x290, 0x2DC, 0x2E0, 0x5D8, 0x618, 0x680, 0x6A8, 0x6BC, THREAD_INFO_SIZE };

```

`driverceptor/stdafx.hpp`:

```hpp
#pragma once

#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <wdm.h>

#include "..\commands_id.hpp"
#include "kernel.hpp"
#include "tools.hpp"

#ifdef _DEBUG
#define DBGPRINT( s, ... ) DbgPrintEx( 0, 0, "[ Ceptor ] " s "\n", __VA_ARGS__ );
#else
#define DBGPRINT( s, ... ) ( s )
#endif

#include "helpers.hpp"
#include "handles.hpp"
```

`driverceptor/tools.hpp`:

```hpp
#pragma once

#include <ntimage.h>

template <typename T = uint8_t*>
inline T resolve_jxx( uint8_t* address )
{
	return reinterpret_cast< T >( address + *reinterpret_cast< int8_t* >( address + 1 ) + 2 );
}

template <typename T = uint8_t*>
inline T resolve_call( uint8_t* address )
{
	return reinterpret_cast< T >( address + *reinterpret_cast< int32_t* >( address + 1 ) + 5 );
}

template <typename T = uint8_t*>
inline T resolve_mov( uint8_t* address )
{
	return reinterpret_cast< T >( address + *reinterpret_cast< int32_t* >( address + 3 ) + 7 );
}

inline BOOLEAN FindModuleByName( LPCSTR modname, SIZE_T* base = nullptr, SIZE_T* size = nullptr )
{
	if ( !modname )
		return FALSE;

	ULONG bytes = 0;

	auto Status = ZwQuerySystemInformation( SystemModuleInformation, NULL, bytes, &bytes );
	if ( !bytes )
		return FALSE;

	const auto info = PRTL_PROCESS_MODULES( ExAllocatePool( NonPagedPool, bytes ) );

	Status = ZwQuerySystemInformation( SystemModuleInformation, info, bytes, &bytes );
	if ( !NT_SUCCESS( Status ) )
	{
		ExFreePool( info );
		return FALSE;
	}

	BOOLEAN bResult = FALSE;

	for ( ULONG i = 0; i < info->NumberOfModules; i++ )
	{
		const auto pModule = &info->Modules[ i ];

		if ( strstr( PCHAR( pModule->FullPathName ), modname ) )
		{
			if ( base )
				*base = SIZE_T( pModule->ImageBase );

			if ( size )
				*size = SIZE_T( pModule->ImageSize );

			bResult = true;
			break;
		}
	}

	if ( info )
		ExFreePool( info );

	return bResult;
}

inline BOOLEAN bDataCompare( const UCHAR* pData, const UCHAR* bMask, const char* szMask )
{
	for ( ; *szMask; ++szMask, ++pData, ++bMask )
		if ( *szMask == 'x' && *pData != *bMask )
			return 0;

	return ( *szMask ) == 0;
}

inline PUCHAR FindPattern( LPCSTR modname, LPCSTR secname, UCHAR* bMask, const char* szMask )
{
	SIZE_T base = NULL;

	if ( !modname || !secname || !bMask || !szMask )
		return nullptr;

	if ( !FindModuleByName( modname, &base ) )
		return nullptr;

	if ( !base )
		return nullptr;

	auto nth = RtlImageNtHeader( PVOID( base ) );
	if ( !nth )
		return nullptr;

	PIMAGE_SECTION_HEADER pSection = nullptr;

	auto sec = IMAGE_FIRST_SECTION( nth );
	for ( auto i = 0; i < nth->FileHeader.NumberOfSections; i++, sec++ )
	{
		if ( !_strnicmp( reinterpret_cast< char* >( sec->Name ), secname, IMAGE_SIZEOF_SHORT_NAME ) )
		{
			pSection = sec;
			break;
		}
	}

	if ( pSection )
	{
		auto dwAddress = ( SIZE_T )( base + pSection->VirtualAddress );

		for ( auto i = 0ul; i < pSection->Misc.VirtualSize; ++i )
		{
			if ( bDataCompare( ( UCHAR* )( dwAddress + i ), bMask, szMask ) )
				return PUCHAR( dwAddress + i );
		}
	}
	return nullptr;
}
```

`hooks.hpp`:

```hpp
#pragma once

//
// CloseHandle
//
NTSTATUS( NTAPI* oNtClose )( HANDLE );

NTSTATUS NTAPI hk_NtClose( HANDLE Handle )
{
	if ( CEPTOR_VALID_HANDLE( Handle ) && g_cmdDriver->DetachProcess( uint64_t( Handle ) ) )
	{
		printf( "[ ! ] NtClose - closed handle = 0x%llX\n", uint64_t( Handle ) );
		return STATUS_SUCCESS;
	}

	return oNtClose( Handle );
}

//
// OpenProcess
//
NTSTATUS( NTAPI* oNtOpenProcess )( PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, CLIENT_ID* );

NTSTATUS NTAPI hk_NtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, CLIENT_ID* ClientId )
{
	if ( ProcessHandle && ClientId && ClientId->UniqueProcess != ULongToHandle( GetCurrentProcessId() ) )
	{
		uint64_t Handle = NULL;
		if ( g_cmdDriver->AttachProcess( uint64_t( ClientId->UniqueProcess ), uint64_t( ClientId->UniqueThread ), &Handle ) )
		{
			*ProcessHandle = PHANDLE( Handle );
			printf( "[ ! ] NtOpenProcess on TID: 0x%p, PID: 0x%p - opened handle = 0x%p\n", ClientId->UniqueThread, ClientId->UniqueProcess, *ProcessHandle );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtOpenProcess - TID: 0x%p, PID: 0x%p - returned 0x%X\n", ClientId->UniqueThread, ClientId->UniqueProcess, g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtOpenProcess( ProcessHandle, DesiredAccess, ObjectAttributes, ClientId );
}

//
// ReadProcessMemory
//
NTSTATUS( NTAPI* oNtReadVirtualMemory )( HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T );

NTSTATUS NTAPI hk_NtReadVirtualMemory( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T NumberOfBytesToRead, PSIZE_T NumberOfBytesReaded )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->ReadProcessMemory(
			uint64_t( ProcessHandle ),
			reinterpret_cast< uint64_t* >( BaseAddress ),
			reinterpret_cast< uint64_t* >( Buffer ),
			NumberOfBytesToRead,
			NumberOfBytesReaded )
			)
		{
			//	printf( "[ ! ] NtReadVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtReadVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtReadVirtualMemory( ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded );
}

//
// WriteProcessMemory
//
NTSTATUS( NTAPI* oNtWriteVirtualMemory )( HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T );

NTSTATUS NTAPI hk_NtWriteVirtualMemory( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T NumberOfBytesToWrite, PSIZE_T NumberOfBytesWritten )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->WriteProcessMemory(
			uint64_t( ProcessHandle ),
			reinterpret_cast< uint64_t* >( BaseAddress ),
			reinterpret_cast< uint64_t* >( Buffer ),
			NumberOfBytesToWrite,
			NumberOfBytesWritten )
			)
		{
			//	printf( "[ ! ] NtWriteVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtWriteVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtWriteVirtualMemory( ProcessHandle, BaseAddress, Buffer, NumberOfBytesToWrite, NumberOfBytesWritten );
}

//
// VirtualQueryEx
//
NTSTATUS( NTAPI* oNtQueryVirtualMemory )( HANDLE, PVOID, MEMORY_INFORMATION_CLASS, PVOID, SIZE_T, PSIZE_T );

NTSTATUS NTAPI hk_NtQueryVirtualMemory( HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID Buffer, SIZE_T Length, PSIZE_T ResultLength )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->VirtualQueryEx(
			uint64_t( ProcessHandle ),
			reinterpret_cast< uint64_t* >( BaseAddress ),
			MemoryInformationClass,
			reinterpret_cast< uint64_t* >( Buffer ),
			Length,
			reinterpret_cast< uint32_t* >( ResultLength ) )
			)
		{
			//	printf( "[ ! ] NtQueryVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtQueryVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtQueryVirtualMemory( ProcessHandle, BaseAddress, MemoryInformationClass, Buffer, Length, ResultLength );
}

//
// VirtualAllocEx
//
NTSTATUS( NTAPI* oNtAllocateVirtualMemory )( HANDLE, PVOID*, ULONG, PSIZE_T, ULONG, ULONG );

NTSTATUS NTAPI hk_NtAllocateVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && RegionSize )
	{
		std::uint64_t AllocBase = g_cmdDriver->VirtualAllocEx(
			uint64_t( ProcessHandle ),
			std::uint64_t( *BaseAddress ),
			*RegionSize,
			AllocationType,
			Protect
		);

		if ( AllocBase )
		{
			*BaseAddress = PVOID( AllocBase );
			//	printf( "[ ! ] NtAllocateVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtAllocateVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtAllocateVirtualMemory( ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect );
}

//
// VirtualFreeEx
//
NTSTATUS( NTAPI* oNtFreeVirtualMemory )( HANDLE, PVOID*, PSIZE_T, ULONG );

NTSTATUS NTAPI hk_NtFreeVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && RegionSize )
	{
		if ( g_cmdDriver->VirtualFreeEx(
			uint64_t( ProcessHandle ),
			reinterpret_cast< std::uint64_t* >( *BaseAddress ),
			*RegionSize,
			FreeType )
			)
		{
			//	printf( "[ ! ] NtFreeVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtFreeVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtFreeVirtualMemory( ProcessHandle, BaseAddress, RegionSize, FreeType );
}

//
// VirtualProtectEx
// 
NTSTATUS( NTAPI* oNtProtectVirtualMemory )( HANDLE, PVOID*, PSIZE_T, ULONG, PULONG );

NTSTATUS NTAPI hk_NtProtectVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && NumberOfBytesToProtect )
	{
		std::uint32_t OldAccess{ };

		if ( g_cmdDriver->VirtualProtectEx(
			uint64_t( ProcessHandle ),
			reinterpret_cast< std::uint64_t* >( *BaseAddress ),
			*NumberOfBytesToProtect,
			NewAccessProtection,
			&OldAccess )
			)
		{
			if ( OldAccessProtection )
				*OldAccessProtection = OldAccess;

			//	printf( "[ ! ] NtProtectVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtProtectVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtProtectVirtualMemory( ProcessHandle, BaseAddress, NumberOfBytesToProtect, NewAccessProtection, OldAccessProtection );
}

//
// VirtualLockEx
//
NTSTATUS( NTAPI* oNtLockVirtualMemory )( HANDLE, PVOID*, PSIZE_T, ULONG );

NTSTATUS NTAPI hk_NtLockVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG LockOption )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && RegionSize )
	{
		if ( g_cmdDriver->VirtualLockEx(
			uint64_t( ProcessHandle ),
			reinterpret_cast< std::uint64_t* >( *BaseAddress ),
			*RegionSize,
			LockOption )
			)
		{
			//	printf( "[ ! ] NtLockVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtLockVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtLockVirtualMemory( ProcessHandle, BaseAddress, RegionSize, LockOption );
}

//
// VirtualUnlockEx
//
NTSTATUS( NTAPI* oNtUnlockVirtualMemory )( HANDLE, PVOID*, PSIZE_T, ULONG );

NTSTATUS NTAPI hk_NtUnlockVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG LockOption )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && RegionSize )
	{
		if ( g_cmdDriver->VirtualUnlockEx(
			uint64_t( ProcessHandle ),
			reinterpret_cast< std::uint64_t* >( *BaseAddress ),
			*RegionSize,
			LockOption )
			)
		{
			//	printf( "[ ! ] NtUnlockVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtUnlockVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtUnlockVirtualMemory( ProcessHandle, BaseAddress, RegionSize, LockOption );
}

//
// FlushInstructionCache
//
NTSTATUS( NTAPI* oNtFlushInstructionCache )( HANDLE, PVOID, ULONG );

NTSTATUS NTAPI hk_NtFlushInstructionCache( HANDLE processHandle, PVOID baseAddress, ULONG numberOfBytesToFlush )
{
	if ( processHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( processHandle ) && baseAddress )
	{
		if ( g_cmdDriver->FlushInstructionCache(
			uint64_t( processHandle ),
			reinterpret_cast< std::uint64_t* >( baseAddress ),
			numberOfBytesToFlush )
			)
		{
			//	printf( "[ ! ] NtFlushInstructionCache - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtFlushInstructionCache returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtFlushInstructionCache( processHandle, baseAddress, numberOfBytesToFlush );
}

//
// NtSetInformationProcess
//
NTSTATUS( NTAPI* oNtSetInformationProcess )( HANDLE, PROCESSINFOCLASS, PVOID, ULONG );

NTSTATUS NTAPI hk_NtSetInformationProcess( HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && ProcessInformation && ProcessInformationLength > 0 )
	{
		if ( g_cmdDriver->SetInformationProcess(
			uint64_t( ProcessHandle ),
			ProcessInformationClass,
			reinterpret_cast< std::uint64_t* >( ProcessInformation ),
			ProcessInformationLength )
			)
		{
			//	printf( "[ ! ] NtSetInformationProcess - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtSetInformationProcess returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtSetInformationProcess( ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength );
}

//
// NtFlushVirtualMemory
//
NTSTATUS( NTAPI* oNtFlushVirtualMemory )( HANDLE, PVOID*, PSIZE_T, PIO_STATUS_BLOCK );

NTSTATUS NTAPI hk_NtFlushVirtualMemory( HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK ioStatus )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) && BaseAddress && RegionSize && ioStatus )
	{
		if ( g_cmdDriver->FlushMemory(
			uint64_t( ProcessHandle ),
			reinterpret_cast< std::uint64_t* >( *BaseAddress ),
			*RegionSize,
			ioStatus )
			)
		{
			//	printf( "[ ! ] NtFlushVirtualMemory - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtFlushVirtualMemory returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtFlushVirtualMemory( ProcessHandle, BaseAddress, RegionSize, ioStatus );
}

//
// SuspendProcess
//
NTSTATUS( NTAPI* oNtSuspendProcess )( HANDLE );

NTSTATUS NTAPI hk_NtSuspendProcess( HANDLE ProcessHandle )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->SuspendProcess( uint64_t( ProcessHandle ) ) )
		{
			//printf( "[ ! ] NtSuspendProcess - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtSuspendProcess returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtSuspendProcess( ProcessHandle );
}

//
// ResumeProcess
//
NTSTATUS( NTAPI* oNtResumeProcess )( HANDLE );

NTSTATUS NTAPI hk_NtResumeProcess( HANDLE ProcessHandle )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->ResumeProcess( uint64_t( ProcessHandle ) ) )
		{
			//	printf( "[ ! ] NtResumeProcess - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtResumeProcess returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtResumeProcess( ProcessHandle );
}

NTSTATUS( NTAPI* oNtOpenThread )( PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, CLIENT_ID* );

NTSTATUS NTAPI hk_NtOpenThread( PHANDLE threadHandle, ACCESS_MASK accessMask, POBJECT_ATTRIBUTES objectAttributes, CLIENT_ID* clientId )
{
	if ( threadHandle &&
		clientId &&
		clientId->UniqueThread != ULongToHandle( GetCurrentThreadId() ) &&
		clientId->UniqueProcess != GetCurrentProcess() )
	{
		std::uint64_t OutThreadHandle{ };

		if ( g_cmdDriver->OpenThread(
			uint64_t( clientId->UniqueThread ),
			uint64_t( clientId->UniqueProcess ),
			&OutThreadHandle )
			)
		{
			*threadHandle = PHANDLE( OutThreadHandle );
			printf( "[ ! ] NtOpenThread on TID: 0x%p - opened handle = 0x%p\n", clientId->UniqueThread, *threadHandle );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtOpenThread ( Thread = 0x%p, Process = 0x%p ) returned 0x%X\n", clientId->UniqueThread, clientId->UniqueProcess, g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtOpenThread( threadHandle, accessMask, objectAttributes, clientId );
}

NTSTATUS( NTAPI* oNtQueryInformationThread )( HANDLE, THREADINFOCLASS, PVOID, ULONG, PULONG );

NTSTATUS NTAPI hk_NtQueryInformationThread( HANDLE threadHandle, THREADINFOCLASS threadInformationClass, PVOID threadInformation, ULONG threadInformationLength, PULONG returnLength )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		std::uint32_t ReturnLen = NULL;

		if ( g_cmdDriver->QueryThreadInformation(
			uint64_t( threadHandle ),
			threadInformationClass,
			reinterpret_cast< std::uint64_t* >( threadInformation ),
			threadInformationLength,
			&ReturnLen )
			)
		{
			if ( returnLength )
				*returnLength = ReturnLen;

			//	printf( "[ ! ] NtQueryInformationThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtQueryInformationThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtQueryInformationThread( threadHandle, threadInformationClass, threadInformation, threadInformationLength, returnLength );
}

NTSTATUS( NTAPI* oNtSetInformationThread )( HANDLE, THREADINFOCLASS, PVOID, ULONG );

NTSTATUS NTAPI hk_NtSetInformationThread( HANDLE threadHandle, THREADINFOCLASS threadInformationClass, PVOID threadInformation, ULONG threadInformationLength )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		if ( g_cmdDriver->SetThreadInformation(
			uint64_t( threadHandle ),
			threadInformationClass,
			reinterpret_cast< std::uint64_t* >( threadInformation ),
			threadInformationLength )
			)
		{
			//printf( "[ ! ] NtSetInformationThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtSetInformationThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtSetInformationThread( threadHandle, threadInformationClass, threadInformation, threadInformationLength );
}

NTSTATUS( NTAPI* oNtGetContextThread )( HANDLE, PCONTEXT );

NTSTATUS NTAPI hk_NtGetContextThread( HANDLE threadHandle, PCONTEXT context )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		if ( g_cmdDriver->GetThreadContext(
			uint64_t( threadHandle ),
			context )
			)
		{
			//printf( "[ ! ] NtGetContextThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtGetContextThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtGetContextThread( threadHandle, context );
}

NTSTATUS( NTAPI* oNtSetContextThread )( HANDLE, PCONTEXT );

NTSTATUS NTAPI hk_NtSetContextThread( HANDLE threadHandle, PCONTEXT context )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		if ( g_cmdDriver->SetThreadContext(
			uint64_t( threadHandle ),
			context )
			)
		{
			//printf( "[ ! ] NtSetContextThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtSetContextThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtSetContextThread( threadHandle, context );
}

NTSTATUS( NTAPI* oNtResumeThread )( HANDLE, PULONG );

NTSTATUS NTAPI hk_NtResumeThread( HANDLE threadHandle, PULONG suspendCount )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		std::uint32_t Count = NULL;
		if ( g_cmdDriver->ResumeThread(
			uint64_t( threadHandle ),
			&Count )
			)
		{
			if ( suspendCount )
				*suspendCount = Count;

			//printf( "[ ! ] NtResumeThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtResumeThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtResumeThread( threadHandle, suspendCount );
}

NTSTATUS( NTAPI* oNtSuspendThread )( HANDLE, PULONG );

NTSTATUS NTAPI hk_NtSuspendThread( HANDLE threadHandle, PULONG previousSuspendCount )
{
	if ( threadHandle != GetCurrentThread() && CEPTOR_VALID_HANDLE( threadHandle ) )
	{
		std::uint32_t Count = NULL;
		if ( g_cmdDriver->SuspendThread(
			uint64_t( threadHandle ),
			&Count )
			)
		{
			if ( previousSuspendCount )
				*previousSuspendCount = Count;

			//printf( "[ ! ] NtSuspendThread - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtSuspendThread returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtSuspendThread( threadHandle, previousSuspendCount );
}

//
// Query Information Process
//
NTSTATUS( NTAPI* oNtQueryInformationProcess )( HANDLE, PROCESS_INFORMATION_CLASS, PVOID, ULONG, PULONG );

NTSTATUS NTAPI hk_NtQueryInformationProcess( HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength )
{
	if ( ProcessHandle != GetCurrentProcess() && CEPTOR_VALID_HANDLE( ProcessHandle ) )
	{
		if ( g_cmdDriver->QueryInformationProcess(
			uint64_t( ProcessHandle ),
			ProcessInformationClass,
			reinterpret_cast< uint64_t* >( ProcessInformation ),
			ProcessInformationLength,
			reinterpret_cast< uint32_t* >( ReturnLength ) )
			)
		{
			//printf( "[ ! ] NtQueryInformationProcess - success!\n" );
			return STATUS_SUCCESS;
		}
		else
		{
			printf( "[ ! ] NtQueryInformationProcess returned 0x%X\n", g_cmdDriver->GetLastNtError() );
			return g_cmdDriver->GetLastNtError();
		}
	}
	return oNtQueryInformationProcess( ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength );
}

NTSTATUS( NTAPI* oNtQuerySystemInformationEx )( SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PVOID, ULONG, PULONG );

NTSTATUS NTAPI hk_NtQuerySystemInformationEx( SYSTEM_INFORMATION_CLASS systemInformationClass, PVOID inputBuffer, ULONG inputBufferLength, PVOID systemInformation, ULONG systemInformationLength, PULONG returnLength )
{
	switch ( systemInformationClass )
	{
	case 0xb5: //SystemSupportedProcessArchitectures
		if ( inputBuffer && inputBufferLength >= sizeof( HANDLE ) && CEPTOR_VALID_HANDLE( inputBuffer ) )
		{
			std::uint32_t ResLength = NULL;

			if ( g_cmdDriver->QuerySystemInformationEx(
				systemInformationClass,
				reinterpret_cast< uint64_t* >( inputBuffer ),
				inputBufferLength,
				reinterpret_cast< uint64_t* >( systemInformation ),
				systemInformationLength,
				&ResLength )
				)
			{
				if ( returnLength )
					*returnLength = ResLength;

				//printf( "[ ! ] NtQuerySystemInformationEx - success!\n" );
				return STATUS_SUCCESS;
			}
			else
			{
				printf( "[ ! ] NtQuerySystemInformationEx returned 0x%X\n", g_cmdDriver->GetLastNtError() );
				return g_cmdDriver->GetLastNtError();
			}
		}
		break;
	}
	return oNtQuerySystemInformationEx( systemInformationClass, inputBuffer, inputBufferLength, systemInformation, systemInformationLength, returnLength );
}

//
// WaitForSingleObject
//
NTSTATUS( NTAPI* oNtWaitForSingleObject )( HANDLE, BOOLEAN, PLARGE_INTEGER );

NTSTATUS NTAPI hk_NtWaitForSingleObject( HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout )
{
	auto Status = oNtWaitForSingleObject( Handle, Alertable, Timeout );
	if ( !NT_SUCCESS( Status ) )
		printf( "[ ! ] NtWaitForSingleObject - Handle: 0x%p, Status: 0x%X!\n", Handle, Status );

	return Status;
	/*if ( NT_SUCCESS( Status ) )
		return Status;

	if ( CEPTOR_VALID_HANDLE( Handle ) )
	{
		printf( "[ ! ] NtWaitForSingleObject - 0x%p!\n", Handle );

		g_cmdDriver->WaitForSingleObject(
			uint64_t( Handle ),
			Alertable,
			Timeout
		);

		return g_cmdDriver->GetLastNtError();
	}
	else
	{
		auto HandleId = GetThreadId( Handle );

		if ( HandleId )
			printf( "[ ! ] NtWaitForSingleObject - ThreadId: %d!\n", HandleId );
		else
			HandleId = GetProcessId( Handle );

		if ( HandleId )
		{
			printf( "[ ! ] NtWaitForSingleObject - ProcessId: %d!\n", HandleId );

			g_cmdDriver->WaitForSingleObject(
				uint64_t( HandleId ),
				Alertable,
				Timeout
			);

			return g_cmdDriver->GetLastNtError();
		}
		else
			printf( "[ ! ] NtWaitForSingleObject - Unknown: 0x%p!\n", Handle );
	}

	return oNtWaitForSingleObject( Handle, Alertable, Timeout );*/
}
```

`includes.hpp`:

```hpp
#pragma once

#include <windows.h>
#include <winternl.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS              ((NTSTATUS)0x00000000L)
#endif

#ifdef _WIN64
#pragma comment( lib, "libMinHook.x64.lib" )
#else
#pragma comment( lib, "libMinHook.x86.lib" )
#endif

#pragma comment( lib, "ntdll" )

#include "winstructs.hpp"
#include "commands.hpp"
#include "hooks.hpp"

#include "MinHook.h"
```

`intraceptor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "intraceptor", "intraceptor.vcxproj", "{003D6992-9564-480B-A507-E7E0B71AAB2E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driverceptor", "driverceptor\driverceptor.vcxproj", "{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testExe", "testExe\testExe.vcxproj", "{E48713C6-7294-4CDA-B597-FBD9AADD7283}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{003D6992-9564-480B-A507-E7E0B71AAB2E}.Debug|x64.ActiveCfg = Debug|x64
		{003D6992-9564-480B-A507-E7E0B71AAB2E}.Debug|x64.Build.0 = Debug|x64
		{003D6992-9564-480B-A507-E7E0B71AAB2E}.Release|x64.ActiveCfg = Release|x64
		{003D6992-9564-480B-A507-E7E0B71AAB2E}.Release|x64.Build.0 = Release|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Debug|x64.ActiveCfg = Debug|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Debug|x64.Build.0 = Debug|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Debug|x64.Deploy.0 = Debug|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Release|x64.ActiveCfg = Release|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Release|x64.Build.0 = Release|x64
		{A958D6FF-0ABC-4655-B7D6-E641F276FCA7}.Release|x64.Deploy.0 = Release|x64
		{E48713C6-7294-4CDA-B597-FBD9AADD7283}.Debug|x64.ActiveCfg = Debug|x64
		{E48713C6-7294-4CDA-B597-FBD9AADD7283}.Debug|x64.Build.0 = Debug|x64
		{E48713C6-7294-4CDA-B597-FBD9AADD7283}.Release|x64.ActiveCfg = Release|x64
		{E48713C6-7294-4CDA-B597-FBD9AADD7283}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7BE9A443-4462-4181-9AF0-6447C38AD3DF}
	EndGlobalSection
EndGlobal

```

`intraceptor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{003d6992-9564-480b-a507-e7e0b71aab2e}</ProjectGuid>
    <RootNamespace>intraceptor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>.\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>.\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>.\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>.\libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="commands.hpp" />
    <ClInclude Include="commands_id.hpp" />
    <ClInclude Include="hooks.hpp" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="winstructs.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`intraceptor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="winstructs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="commands.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="commands_id.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`main.cpp`:

```cpp
#include "includes.hpp"

std::unique_ptr< CCommand > g_cmdDriver = nullptr;

DWORD WINAPI StartThread( PVOID )
{
	while ( !GetModuleHandleA( "ntdll.dll" ) )
		Sleep( 150 );

	MH_Initialize();

	g_cmdDriver = std::make_unique< CCommand >();

	if ( AttachConsole( GetCurrentProcessId() ) != ERROR_ACCESS_DENIED )
	{
		AllocConsole();
		FILE* f = nullptr;
		freopen_s( &f, "CONIN$", "r", stdin );
		freopen_s( &f, "CONOUT$", "w", stderr );
		freopen_s( &f, "CONOUT$", "w", stdout );
	}

	printf( "g_cmdDriver->Status: %d\n", g_cmdDriver->Status() );

	HMODULE ntdll = LoadLibraryA( "ntdll.dll" );

	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtClose" ) ), &hk_NtClose, reinterpret_cast< PVOID* >( &oNtClose ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtWaitForSingleObject" ) ), &hk_NtWaitForSingleObject, reinterpret_cast< PVOID* >( &oNtWaitForSingleObject ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtOpenProcess" ) ), &hk_NtOpenProcess, reinterpret_cast< PVOID* >( &oNtOpenProcess ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtReadVirtualMemory" ) ), &hk_NtReadVirtualMemory, reinterpret_cast< PVOID* >( &oNtReadVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtWriteVirtualMemory" ) ), &hk_NtWriteVirtualMemory, reinterpret_cast< PVOID* >( &oNtWriteVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtQueryVirtualMemory" ) ), &hk_NtQueryVirtualMemory, reinterpret_cast< PVOID* >( &oNtQueryVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtAllocateVirtualMemory" ) ), &hk_NtAllocateVirtualMemory, reinterpret_cast< PVOID* >( &oNtAllocateVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtFreeVirtualMemory" ) ), &hk_NtFreeVirtualMemory, reinterpret_cast< PVOID* >( &oNtFreeVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtProtectVirtualMemory" ) ), &hk_NtProtectVirtualMemory, reinterpret_cast< PVOID* >( &oNtProtectVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtQueryInformationProcess" ) ), &hk_NtQueryInformationProcess, reinterpret_cast< PVOID* >( &oNtQueryInformationProcess ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtSuspendProcess" ) ), &hk_NtSuspendProcess, reinterpret_cast< PVOID* >( &oNtSuspendProcess ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtResumeProcess" ) ), &hk_NtResumeProcess, reinterpret_cast< PVOID* >( &oNtResumeProcess ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtQuerySystemInformationEx" ) ), &hk_NtQuerySystemInformationEx, reinterpret_cast< PVOID* >( &oNtQuerySystemInformationEx ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtSetInformationProcess" ) ), &hk_NtSetInformationProcess, reinterpret_cast< PVOID* >( &oNtSetInformationProcess ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtFlushInstructionCache" ) ), &hk_NtFlushInstructionCache, reinterpret_cast< PVOID* >( &oNtFlushInstructionCache ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtFlushVirtualMemory" ) ), &hk_NtFlushVirtualMemory, reinterpret_cast< PVOID* >( &oNtFlushVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtLockVirtualMemory" ) ), &hk_NtLockVirtualMemory, reinterpret_cast< PVOID* >( &oNtLockVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtUnlockVirtualMemory" ) ), &hk_NtUnlockVirtualMemory, reinterpret_cast< PVOID* >( &oNtUnlockVirtualMemory ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtOpenThread" ) ), &hk_NtOpenThread, reinterpret_cast< PVOID* >( &oNtOpenThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtQueryInformationThread" ) ), &hk_NtQueryInformationThread, reinterpret_cast< PVOID* >( &oNtQueryInformationThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtSetInformationThread" ) ), &hk_NtSetInformationThread, reinterpret_cast< PVOID* >( &oNtSetInformationThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtGetContextThread" ) ), &hk_NtGetContextThread, reinterpret_cast< PVOID* >( &oNtGetContextThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtSetContextThread" ) ), &hk_NtSetContextThread, reinterpret_cast< PVOID* >( &oNtSetContextThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtSuspendThread" ) ), &hk_NtSuspendThread, reinterpret_cast< PVOID* >( &oNtSuspendThread ) );//
	MH_CreateHook( PVOID( GetProcAddress( ntdll, "NtResumeThread" ) ), &hk_NtResumeThread, reinterpret_cast< PVOID* >( &oNtResumeThread ) );//

	MH_EnableHook( MH_ALL_HOOKS );

	return EXIT_SUCCESS;
}

EXTERN_C __declspec( dllexport ) BOOL WINAPI DllMain( HMODULE hDll, DWORD dwReason, PVOID )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		CreateThread( nullptr, NULL, StartThread, nullptr, NULL, nullptr );
	}
	return TRUE;
}
```

`testExe/test.cpp`:

```cpp
#include <Windows.h>
#include <cstdio>
#include <winternl.h>
#include <cstdint>
#include <TlHelp32.h>

#pragma comment( lib, "ntdll" )

#define CEPTOR_VALID_HANDLE( h )	( ( ( ( std::uint64_t )h >> 20 ) & 0xFFF ) == 0xF0F )

DWORD FindProcess( const wchar_t* szName )
{
	HANDLE hSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if ( !hSnap )
		return 0;

	DWORD ProcessId = NULL;

	PROCESSENTRY32 pe32{ };
	pe32.dwSize = sizeof( pe32 );

	Process32First( hSnap, &pe32 );
	do
	{
		if ( !wcscmp( pe32.szExeFile, szName ) )
		{
			ProcessId = pe32.th32ProcessID;
			break;
		}
	} while ( Process32Next( hSnap, &pe32 ) );

	return ProcessId;
}

DWORD WINAPI Worker( PVOID )
{
	while ( true )
	{
		Sleep( 60 * 1000 );
		printf( "Thread finished\n" );
		ExitThread( 0 );
	}
	return 0;
}

int main()
{
	auto hModule = LoadLibraryA( "intraceptor.dll" );
	if ( !hModule )
	{
		printf( "LoadLibrary returned %d\n", GetLastError() );
		getchar();
		return 1;
	}

	Sleep( 2500 );

	printf( "Trying to attach into explorer.exe\n" );
	ULONG ExplorerPID = FindProcess( L"explorer.exe" );
	printf( "Explorer PID: 0x%X\n", ExplorerPID );

	HANDLE hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, ExplorerPID );
	if ( hProcess )
	{
		printf( "Process Handle: 0x%p\n", hProcess );

		//
		// NtQueryInformationProcess
		//
		PROCESS_BASIC_INFORMATION pbi{ };
		DWORD pbiLen = 0;
		NtQueryInformationProcess( hProcess, PROCESSINFOCLASS::ProcessBasicInformation, &pbi, sizeof( pbi ), &pbiLen );

		printf( "PEB: 0x%p\n", pbi.PebBaseAddress );

		//
		// VirtualAllocEx
		//
		auto Addr = VirtualAllocEx( hProcess, nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
		printf( "Addr: 0x%p\n", Addr );

		//
		// RPM
		//
		ULONG AddrVal = 10;
		ReadProcessMemory( hProcess, Addr, &AddrVal, sizeof( AddrVal ), nullptr );

		printf( "Addr: 0x%X\n", AddrVal );

		//
		// WPM
		//
		if ( WriteProcessMemory( hProcess, Addr, "\xAD\xED\xEF", 4, nullptr ) )
			printf( "Write success!\n" );

		//
		// RPM 2
		//
		ReadProcessMemory( hProcess, Addr, &AddrVal, sizeof( AddrVal ), nullptr );

		printf( "Addr: 0x%X\n", AddrVal );

		//
		// VirtualProtectEx
		//
		DWORD dwOld = 0;
		VirtualProtectEx( hProcess, Addr, 0x1000, PAGE_EXECUTE_READWRITE, &dwOld );

		//
		// VirtualQueryEx
		//
		MEMORY_BASIC_INFORMATION mbi{ };
		if ( VirtualQueryEx( hProcess, Addr, &mbi, sizeof( mbi ) ) )
			printf( "AllocationBase: 0x%p\n", mbi.AllocationBase );
		
		//
		// VirtualFreeEx
		//
		VirtualFreeEx( hProcess, Addr, 0, MEM_RELEASE );

		//
		// CreateThread
		//
		DWORD ThreadId = 0;
		CreateThread( nullptr, NULL, Worker, nullptr, NULL, &ThreadId );
		printf( "ThreadId: %d\n", ThreadId );

		//
		// OpenThread
		//
		HANDLE hThread = OpenThread( THREAD_ALL_ACCESS, FALSE, ThreadId );
		if ( hThread )
		{
			printf( "Thread Handle: 0x%p\n", hThread );

			CONTEXT ctx{ };
			ctx.ContextFlags = CONTEXT_ALL;

			SuspendThread( hThread );
			GetThreadContext( hThread, &ctx );
			printf( "Rip = 0x%llX\n", ctx.Rip );
			SetThreadContext( hThread, &ctx );
			ResumeThread( hThread );

			auto Res = WaitForSingleObject( hThread, INFINITE );
			printf( "WaitForSingleObject res: %d\n", Res );

			CloseHandle( hThread );
		}

		CloseHandle( hProcess );
	}

	Sleep( INFINITE );
	return 0;
}
```

`testExe/testExe.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e48713c6-7294-4cda-b597-fbd9aadd7283}</ProjectGuid>
    <RootNamespace>testExe</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="test.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`testExe/testExe.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="test.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`winstructs.hpp`:

```hpp
#pragma once

typedef enum _MEMORY_INFORMATION_CLASS 
{
    MemoryBasicInformation
} MEMORY_INFORMATION_CLASS;

```