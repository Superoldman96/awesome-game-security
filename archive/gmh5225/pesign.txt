Project Path: arc_gmh5225_pesign_hsyxqz1t

Source Tree:

```txt
arc_gmh5225_pesign_hsyxqz1t
├── CODE_OF_CONDUCT.md
├── COPYING
├── Make.coverity
├── Make.defaults
├── Make.deps
├── Make.efirules
├── Make.rules
├── Make.scan-build
├── Make.version
├── Makefile
├── README.md
├── TODO
├── include
│   ├── Makefile
│   └── libdpe
│       ├── Makefile
│       ├── libdpe.h
│       └── pe.h
├── libdpe
│   ├── Makefile
│   ├── common.h
│   ├── compiler.h
│   ├── endian.h
│   ├── fix_coverity.h
│   ├── libdpe.c
│   ├── libdpe_priv.h
│   ├── pe_addcert.c
│   ├── pe_allocspace.c
│   ├── pe_begin.c
│   ├── pe_end.c
│   ├── pe_error.c
│   ├── pe_getdatadir.c
│   ├── pe_getpehdr.c
│   ├── pe_getscn.c
│   ├── pe_getshdr.c
│   ├── pe_nextscn.c
│   ├── pe_opthdr.c
│   ├── pe_rawfile.c
│   ├── pe_readall.c
│   ├── pe_update.c
│   ├── pe_updatefile.c
│   └── pe_updatenull.c
├── src
│   ├── Makefile
│   ├── actions.c
│   ├── actions.h
│   ├── authvar.1.mdoc
│   ├── authvar.c
│   ├── authvar.h
│   ├── authvar_context.c
│   ├── authvar_context.h
│   ├── certdb.c
│   ├── certdb.h
│   ├── certs
│   │   ├── Makefile
│   │   └── make-certs
│   ├── client.c
│   ├── cms_common.c
│   ├── cms_common.h
│   ├── cms_pe_common.c
│   ├── compiler.h
│   ├── content_info.c
│   ├── content_info.h
│   ├── content_info_priv.h
│   ├── daemon.c
│   ├── daemon.h
│   ├── efikeygen.1.mdoc
│   ├── efikeygen.c
│   ├── endian.h
│   ├── err.h
│   ├── errno-guard.c
│   ├── errno-guard.h
│   ├── file_kmod.c
│   ├── file_kmod.h
│   ├── file_pe.c
│   ├── fix_coverity.h
│   ├── hex.h
│   ├── list.h
│   ├── macros.pesign
│   ├── oid.c
│   ├── oid.h
│   ├── password.c
│   ├── password.h
│   ├── pesigcheck.1.mdoc
│   ├── pesigcheck.c
│   ├── pesigcheck.h
│   ├── pesigcheck_context.c
│   ├── pesigcheck_context.h
│   ├── pesign-client.1.mdoc
│   ├── pesign-groups
│   ├── pesign-rpmbuild-helper.in
│   ├── pesign-users
│   ├── pesign.1.mdoc
│   ├── pesign.c
│   ├── pesign.h
│   ├── pesign.popt
│   ├── pesign.service.in
│   ├── pesign.sysvinit.in
│   ├── pesign_context.c
│   ├── pesign_context.h
│   ├── pesign_kmod.c
│   ├── pesign_standalone.h
│   ├── pesum.1.mdoc
│   ├── pesum.c
│   ├── signed_data.c
│   ├── signed_data.h
│   ├── signer_info.c
│   ├── signer_info.h
│   ├── text.c
│   ├── text.h
│   ├── tmpfiles.conf.in
│   ├── ucs2.c
│   ├── ucs2.h
│   ├── util.c
│   ├── util.h
│   ├── valgrind.supp
│   ├── varfile.c
│   ├── varfile.h
│   ├── wincert.c
│   └── wincert.h
└── util
    ├── Makefile
    ├── cert.csr
    ├── clearpk.c
    ├── dumpsb.c
    ├── pjones.cer
    ├── pkpub.cer
    ├── privkey.pem
    ├── sb.h
    ├── setupsb.c
    └── shelliface.h

```

`CODE_OF_CONDUCT.md`:

```md

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
rharwood AT redhat DOT com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available
at [https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations


```

`COPYING`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`Make.coverity`:

```coverity
include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

COV_EMAIL=$(call get-config,coverity.email)
COV_TOKEN=$(call get-config,coverity.token)
COV_URL=$(call get-config,coverity.url)
COV_FILE=$(NAME)-coverity-$(VERSION)-$(COMMIT_ID).tar.bz2

cov-int : clean
	cov-build --dir cov-int make all

cov-clean :
	@rm -vf $(NAME)-coverity-*.tar.*
	@if [ -d cov-int ]; then rm -rf cov-int && echo "removed 'cov-int'"; fi

cov-file : | $(COV_FILE)

$(COV_FILE) : cov-int
	tar caf $@ cov-int

cov-upload :
	@if [ -n "$(COV_URL)" ] &&					\
	    [ -n "$(COV_TOKEN)" ] &&					\
	    [ -n "$(COV_EMAIL)" ] ;					\
	then								\
		echo curl --form token=$(COV_TOKEN) --form email="$(COV_EMAIL)" --form file=@"$(COV_FILE)" --form version=$(VERSION).1 --form description="$(COMMIT_ID)" "$(COV_URL)" ; \
		curl --form token=$(COV_TOKEN) --form email="$(COV_EMAIL)" --form file=@"$(COV_FILE)" --form version=$(VERSION).1 --form description="$(COMMIT_ID)" "$(COV_URL)" ; \
	else								\
		echo Coverity output is in $(COV_FILE) ;		\
	fi

coverity : cov-file cov-upload

clean : | cov-clean

.PHONY : coverity cov-upload cov-clean cov-file

```

`Make.defaults`:

```defaults
NAME	= pesign
COMMIT_ID ?= $(shell git log -1 --pretty=%H 2>/dev/null || echo master)
prefix	?= /usr/
prefix	:= $(abspath $(prefix))/
libdir	?= $(prefix)lib64/
libdatadir ?= $(prefix)lib/
libexecdir ?= $(prefix)libexec/
datadir	?= $(prefix)share/
mandir	?= $(datadir)man/
includedir ?= $(prefix)include/
bindir	?= $(prefix)bin/
rundir  ?= /run/
rundir	:= $(abspath $(rundir))/
pcdir	?= $(libdir)pkgconfig/
docdir	?= $(prefix)share/doc/
DESTDIR	?=
INSTALLROOT = $(DESTDIR)

INSTALL	?= install
CROSS_COMPILE	?=
EFI_ARCHES ?= aa64 ia32 x64

enabled = $(if $(filter undefined,$(origin $(1))),$(3),$(2))

HOSTARCH   = $(shell uname -m | sed s,i[3456789]86,ia32,)
ARCH	   := $(shell uname -m | sed 's,i[3456789]86,ia32,;s,arm.*,arm,')


PKG_CONFIG ?= $(CROSS_COMPILE)pkg-config
CC	:= $(if $(filter default,$(origin CC)),$(CROSS_COMPILE)gcc,$(CC))
CCLD	:= $(if $(filter undefined,$(origin CCLD)),$(CC),$(CCLD))
CFLAGS	?= -O2 -g3 -pipe -fPIE -fstack-protector-all \
	-fstack-clash-protection \
	$(if $(filter x86_64 ia32,$(ARCH)),-fcf-protection=full,)
DIAGFLAGS ?= $(call enabled,ENABLE_GCC_ANALYZER,-fmessage-length=0 \
	     -fdiagnostics-color=always \
	     -fdiagnostics-format=text \
	     -fdiagnostics-show-cwe \
	     -fanalyzer) \
	     $(call enabled,ENABLE_LEAK_CHECKER,-Wno-analyzer-malloc-leak,)
AS	?= $(CROSS_COMPILE)as
AR	?= $(CROSS_COMPILE)$(if $(filter $(CC),clang),llvm-ar,$(notdir $(CC))-ar)
RANLIB	?= $(CROSS_COMPILE)$(if $(filter $(CC),clang),llvm-ranlib,$(notdir $(CC))-ranlib)
OBJCOPY	?= $(CROSS_COMPILE)objcopy
LD	?= $(CROSS_COMPILE)ld
INSTALL	?= $(CROSS_COMPILE)install

PKGS	= efivar nspr nss nss-util uuid

SOFLAGS	?= -shared
clang_cflags =
gcc_cflags = -Wmaybe-uninitialized -grecord-gcc-switches \
             $(call enabled,ENABLE_LEAK_CHECKER,$(call enabled,ENABLE_LEAK_CHECKER_LTO,-flto,),) \
	     $(DIAGFLAGS)
ifneq (,$(wildcard /usr/lib/gcc/x86_64-redhat-linux/*/plugin/annobin.so))
  gcc_cflags += -fplugin=annobin
endif

cflags	= $(CFLAGS) $(ARCH3264) \
	-Wall -Wextra -Wsign-compare -Wno-unused-result \
	-Wno-unused-function -Wno-missing-field-initializers \
	$(call enabled,ENABLE_LEAK_CHECKER,-Wno-analyzer-malloc-leak,) \
	-Werror -Wno-error=cpp -Wno-free-nonheap-object \
	-std=gnu11 -fshort-wchar -fPIC -fno-strict-aliasing \
	-D_GNU_SOURCE -DCONFIG_$(ARCH) -I${TOPDIR}/include \
	'-DRUNDIR="$(rundir)"' \
	$(if $(filter $(CC),clang),$(clang_cflags), ) \
	$(if $(filter $(CC),gcc),$(gcc_cflags), ) \
	$(call pkg-config-cflags)
clang_ccldflags =
gcc_ccldflags = -fno-merge-constants \
	-fvar-tracking -fvar-tracking-assignments -fkeep-inline-functions \
	-Wl,--fatal-warnings,--no-allow-shlib-undefined,--default-symver \
	-Wl,-O2 -Wl,--no-undefined-version -Wl,-z,relro,-z,now \
	-Wl,--no-add-needed,--no-copy-dt-needed-entries,--as-needed -pie
ifeq ($(ARCH),arm)
  gcc_ccldflags += -Wl,--no-wchar-size-warning
endif
ccldflags = $(cflags) $(CCLDFLAGS) $(LDFLAGS) \
	$(if $(filter $(CCLD),clang),$(clang_ccldflags),) \
	$(if $(filter $(CCLD),gcc),$(gcc_ccldflags),) \
	$(call pkg-config-ccldflags)
efi_cflags = $(cflags)
ASFLAGS	?= $(ARCH3264)
CPPFLAGS ?= -D_FORTIFY_SOURCE=2 -D_GLIBCXX_ASSERTIONS
RANLIBFLAGS	?= $(if $(filter $(CC),gcc),-D)
ARFLAGS ?= $(if $(filter $(CC),gcc),-Dcvqs)$(if $(filter $(CC),clang),-cqvs)

LDLIBS	= $(foreach lib,$(LIBS),-l$(lib)) $(call pkg-config-ldlibs)

ifeq ($(ARCH),ia64)
  efi_cflags += -mfixed-range=f32-f127
endif

ifeq ($(ARCH), ia32)
  ifeq ($(HOSTARCH), x86_64)
    ARCH3264 := -m32
  endif
endif

ifeq ($(ARCH), x86_64)
  efi_cflags += -mno-red-zone
  ifeq ($(HOSTARCH), ia32)
    ARCH3264 := -m64
  endif
endif

# Docs are enabled by default. Set ENABLE_DOCS=0 to disable
# building/installing docs.
ENABLE_DOCS ?= 1

```

`Make.deps`:

```deps
SRCDIR = $(realpath .)
TOPDIR = $(realpath ..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

.%.d : %.c
	$(CC) $(cflags) $(CPPFLAGS) -MM -MG -MF $@ $^

.%.d : %.S
	$(CC) $(cflags) $(CPPFLAGS) -MM -MG -MF $@ $^

SOURCES ?=
deps :
	echo SOURCES=$(SOURCES)
deps : $(call deps-of,$(filter-out %.h,$(SOURCES)))

```

`Make.efirules`:

```efirules
default : all

.PHONY: default all deps clean install test

include $(TOPDIR)/Make.version

%.efi : %.so
	$(OBJCOPY) -j .text -j .sdata -j .data -j .dynamic -j .dynsym -j .rel \
		   -j .rela -j .reloc --target=$(FORMAT) $*.so $@

%.so: %.o
	$(LD) $(LDFLAGS) -o $@ $^ $(LIBS)

%.o: %.c
	$(CC) $(INCDIR) $(CFLAGS) $(CPPFLAGS) -D__UEFI__ -c $< -o $@

%.S: %.c
	$(CC) $(INCDIR) $(CFLAGS) $(CPPFLAGS) -D__UEFI__ -S $< -o $@

%.E: %.c
	$(CC) $(INCDIR) $(CFLAGS) $(CPPFLAGS) -D__UEFI__ -E $< -o $@

```

`Make.rules`:

```rules
default : all

.PHONY: default all deps clean install install_systemd install_sysvinit test

include $(TOPDIR)/Make.version

all : deps

deps :

clean :

install :

install_systemd :

install_sysvinit :

test :

%.a :
	$(AR) $(ARFLAGS) $@ $^
	$(RANLIB) $(RANLIBFLAGS) $@

% : %.o
	$(CCLD) $(ccldflags) $(CPPFLAGS) -o $@ $^ $(LDLIBS)

%.so : 
	$(CCLD) $(ccldflags) $(CPPFLAGS) $(SOFLAGS) \
		-Wl,-soname,$@.0.$(MAJOR_VERSION) \
		-o $@ $^ $(LDLIBS)

%.o: %.c
	$(CC) $(cflags) $(CPPFLAGS) -c -o $@ $(filter %.c %.o %.S,$^)

%.S: %.c
	$(CC) $(cflags) $(CPPFLAGS) -S $< -o $@

%.E: %.c
	$(CC) $(cflags) $(CPPFLAGS) -E $< -o $@

%.c : %.h

.%.d :

define substitute-version =
	sed							\
		-e "s,@@VERSION@@,$(VERSION),g"			\
		-e "s,@@LIBDIR@@,$(libdir),g"			\
		-e "s,@@LIBEXECDIR@@,$(libexecdir),g"		\
		-e "s,@@RUNDIR@@,$(rundir),g"			\
		-e "s,@@EFI_ARCHES@@,$(EFI_ARCHES),g"		\
		$(1) > $(2)
endef

%.1 : %.1.mdoc
	@mandoc -man -T man -Ios=Linux $^ > $@

% : %.in
	@$(call substitute-version,$<,$@)

%.pc : %.pc.in
	@$(call substitute-version,$<,$@)

%.spec : %.spec.in
	@$(call substitute-version,$<,$@)

%.service : %.service.in
	@$(call substitute-version,$<,$@)

%.sysvinit : %.sysvinit.in
	@$(call substitute-version,$<,$@)

pkg-config-cflags = \
	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --cflags $(PKGS); fi)
pkg-config-ldflags = \
	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --libs-only-L --libs-only-other $(PKGS) ; fi)
pkg-config-ldlibs = \
	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --libs-only-l $(PKGS) ; fi)

objects-of = \
	$(patsubst %.c,%.o,$(1))

define deps-of =
	$(foreach src,$(filter %.c,$(1)),$(patsubst %.c,.%.d,$(src))) \
	$(foreach src,$(filter %.S,$(1)),$(patsubst %.S,.%.d,$(src)))
endef

$(TOPDIR)/libdpe/%.a $(TOPDIR)/libdpe/% :
	$(MAKE) -C $(TOPDIR)/libdpe $(notdir $@)

define get-config =
$(shell git config --local --get "$(NAME).$(1)")
endef

define removes
	if [ -n "$(TARGETS)" ]; then rm -rfv $(TARGETS) ; fi
	rm -rfv *.o *.a *.so .*.d
	rm -rfv {vg,}core.[0123456789]*
endef

define descend
	set -e ; for x in $(SUBDIRS) ; do \
		$(MAKE) -C $$x $@ ; \
	done
endef

```

`Make.scan-build`:

```scan-build
SCAN_BUILD ?= $(shell x=$$(which --skip-alias --skip-functions scan-build 2>/dev/null) ; [ -n "$$x" ] && echo 1)
ifeq ($(SCAN_BUILD),)
	SCAN_BUILD_ERROR = $(error scan-build not found)
endif

SCAN_CC = $(CROSS_COMPILE)clang
SCAN_AR = $(CROSS_COMPILE)llvm-ar
SCAN_ARFLAGS=-cqvs
SCAN_RANLIB = $(CROSS_COMPILE)llvm-ranlib

scan-test : ; $(SCAN_BUILD_ERROR)

scan-clean : clean
	@if [ -d scan-results ]; then rm -rf scan-results && echo "removed 'scan-results'"; fi

scan-build : | scan-test
scan-build : clean
	scan-build -o scan-results make $(DASHJ) \
		AR=$(SCAN_AR) ARFLAGS=$(SCAN_ARFLAGS) \
		RANLIB=$(SCAN_RANLIB) CC=$(SCAN_CC) \
		all

scan-build-all : | scan-test
scan-build-all : clean
	scan-build -o scan-results make $(DASHJ) \
		AR=$(SCAN_AR) ARFLAGS=$(SCAN_ARFLAGS) \
		RANLIB=$(SCAN_RANLIB) CC=$(SCAN_CC) \
		all

.PHONY : scan-build scan-clean

# vim:ft=make

```

`Make.version`:

```version
MAJOR_VERSION = 116
VERSION = $(MAJOR_VERSION)

```

`Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath .)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults
include $(TOPDIR)/Make.coverity
include $(TOPDIR)/Make.scan-build

SUBDIRS := include libdpe src

install :
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(docdir)/pesign-$(VERSION)/
	$(INSTALL) -pm 644 COPYING $(INSTALLROOT)$(docdir)/pesign-$(VERSION)/
	@$(call descend)

install_systemd install_sysvinit : install
	@$(call descend)

distclean : | clean

clean :
	@$(call removes)
	@$(call descend)

clean deps all : | Make.version

deps all :
	@$(call descend)

$(SUBDIRS) :
	$(MAKE) -C $@ all

.PHONY: $(SUBDIRS)

GITTAG = $(VERSION)

test-archive:
	@rm -rf /tmp/pesign-$(VERSION) /tmp/pesign-$(VERSION)-tmp
	@mkdir -p /tmp/pesign-$(VERSION)-tmp
	@git archive --format=tar $(shell git branch | awk '/^*/ { print $$2 }') | ( cd /tmp/pesign-$(VERSION)-tmp/ ; tar x )
	@git diff | ( cd /tmp/pesign-$(VERSION)-tmp/ ; patch -s -p1 -b -z .gitdiff )
	@mv /tmp/pesign-$(VERSION)-tmp/ /tmp/pesign-$(VERSION)/
	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/pesign-$(VERSION).tar.bz2 pesign-$(VERSION)
	@rm -rf /tmp/pesign-$(VERSION)
	@echo "The archive is in pesign-$(VERSION).tar.bz2"

tag:
	git tag -s $(GITTAG) refs/heads/main

archive: tag
	@rm -rf /tmp/pesign-$(VERSION) /tmp/pesign-$(VERSION)-tmp
	@mkdir -p /tmp/pesign-$(VERSION)-tmp
	@git archive --format=tar $(GITTAG) | ( cd /tmp/pesign-$(VERSION)-tmp/ ; tar x )
	@mv /tmp/pesign-$(VERSION)-tmp/ /tmp/pesign-$(VERSION)/
	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/pesign-$(VERSION).tar.bz2 pesign-$(VERSION)
	@rm -rf /tmp/pesign-$(VERSION)
	@echo "The archive is in pesign-$(VERSION).tar.bz2"

valgrind : all
	valgrind --leak-check=full --track-origins=yes ./src/pesign -f -s -t 'Secure Boot Signer' -c 'Certificate for Digital Signature' -i shimx64.efi -o shimx64.signed.efi --pwfile pwfile

strace : all
	strace -tt -s 1024 -v -f -o pesign.strace -o /dev/stdout ./src/pesign -f -s -t 'Secure Boot Signer' -c 'Certificate for Digital Signature' -i shimx64.efi -o shimx64.signed.efi --pwfile pwfile

gdb : all
	echo run -f -s -t \'Secure Boot Signer\' -c \'Certificate for Digital Signature\' -i shimx64.efi -o shimx64.signed.efi --pwfile pwfile | copy
	gdb ./src/pesign

```

`README.md`:

```md
# pesign + efikeygen

Signing tools for PE-COFF binaries.  Compliant with the PE and Authenticode
specifications.

(These serve a similar purpose to Microsoft's
[SignTool.exe](http://msdn.microsoft.com/en-us/library/8s9b9yaz%28v=vs.80%29.aspx),
except for Linux.)

## Examples

Generate a key for use with pesign, stored on disk:

```
efikeygen -d /etc/pki/pesign -S -TYPE -c 'CN=Your Name Key' -n 'Custom Secureboot'
```

(where TYPE is m if you're only signing kernel modules, and k otherwise).

For more complex and secure use cases (e.g., hardware tokens), see
efikeygen man page (`man efikeygen`).

Sign a UEFI application using that key:

```
pesign -i grubx64.efi -o grubx64.efi.signed -c 'Custom Secureboot' -s
```

Show signatures on a UEFI application:

```
pesign -i grubx64.efi.signed -S
```

For more signing/verification operations, see the pesign man page (`man
pesign`).

```

`TODO`:

```
Stuff that needs to get done:

In no particular order, this stuff still needs to be done (or is in progress):

1) file i/o
 a) get an in-memory representation via mmap *done*
 b) render in-memory representation back to disk also via mmap *done-ish*
2) signatures
 a) read hash from stand-alone file *done*
 b) write hash to stand-alone file *done*
 c) verify hash from stand-alone file
 d) read cert from file *done*
 e) create hash/digest of file *done*
 f) create new signature (aka "sign the hash")
  i) generate SpcContentInfo *done*
  ii) sign it *done*
 g) create cert table *done for the very basic (ms-supported) case*
 h) find cert table *eh*
 i) implant cert in table *eh*
3) make hash algorithm configurable
4) test suite
5) test suite
6) docs
7) efikeygen - random serial number + check for dupes against local nss db

See also: https://github.com/rhboot/pesign/issues/milestones


```

`include/Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath ..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

SUBDIRS = libdpe

clean all install :
	for x in $(SUBDIRS) ; do \
		$(MAKE) -C $$x $@ ; \
	done

$(SUBDIRS) :
	$(MAKE) -C $@ all

.PHONY: $(SUBDIRS)

```

`include/libdpe/Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath ../..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

#install:
#	$(INSTALL) -d -m 755 $(INSTALLROOT)$(PREFIX)/include/libdpe/
#	$(INSTALL) -m 644 *.h $(INSTALLROOT)$(PREFIX)/include/libdpe/

```

`include/libdpe/libdpe.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * libdpe.h - types for libdpe
 * Copyright 2011-2020 Peter Jones <pjones@redhat.com>
 * Copyright 2011 Red Hat, Inc.
 */
#ifndef LIBDPE_H
#define LIBDPE_H 1

#include <sys/types.h>

#include <libdpe/pe.h>

typedef enum {
	PE_K_NONE,
	PE_K_MZ,
	PE_K_PE_OBJ,
	PE_K_PE_EXE,
	PE_K_PE_ROM,
	PE_K_PE64_OBJ,
	PE_K_PE64_EXE,
	PE_K_NUM /* terminating entry */
} Pe_Kind;

typedef enum {
	PE_C_NULL,
	PE_C_READ,
	PE_C_RDWR,
	PE_C_WRITE,
	PE_C_CLR,
	PE_C_SET,
	PE_C_FDDONE,
	PE_C_FDREAD,
	PE_C_READ_MMAP,
	PE_C_RDWR_MMAP,
	PE_C_WRITE_MMAP,
	PE_C_READ_MMAP_PRIVATE,
	PE_C_EMPTY,
	PE_C_NUM /* last entry */
} Pe_Cmd;

typedef enum {
	PE_DATA_DIR_EXPORTS = 1,
	PE_DATA_DIR_IMPORTS,
	PE_DATA_DIR_RESOURCES,
	PE_DATA_DIR_EXCEPTIONS,
	PE_DATA_DIR_CERTIFICATES,
	PE_DATA_DIR_BASE_RELOCATIONS,
	PE_DATA_DIR_DEBUG,
	PE_DATA_DIR_ARCH,
	PE_DATA_DIR_GLOBAL_POINTER,
	PE_DATA_TLS,
	PE_DATA_LOAD_CONFIG,
	PE_DATA_BOUND_IMPORT,
	PE_DATA_IMPORT_ADDRESS,
	PE_DATA_DELAY_IMPORTS,
	PE_DATA_CLR_RUNTIME_HEADER,
	PE_DATA_RESERVED,
	PE_DATA_NUM /* last entry */
} Pe_DataDir_Type;

typedef struct Pe Pe;
typedef struct Pe_Scn Pe_Scn;

extern Pe *pe_begin(int fildes, Pe_Cmd cmd, Pe *ref);
extern Pe *pe_clone(Pe *pe, Pe_Cmd cmd);
extern Pe *pe_memory(char *image, size_t size);
extern int pe_end(Pe *pe);
extern loff_t pe_update(Pe *pe, Pe_Cmd cmd);
extern Pe_Kind pe_kind(Pe *Pe) __attribute__ ((__pure__));
extern Pe_Scn *pe_nextscn(Pe *pe, Pe_Scn *scn);
extern Pe_Scn *pe_getscn(Pe *pe, size_t idx);
extern struct section_header *pe_getshdr(Pe_Scn *scn, struct section_header *dst);
extern struct pe_hdr *pe_getpehdr(Pe *pe, struct pe_hdr *pehdr);
extern char *pe_rawfile(Pe *pe, size_t *ptr);
extern int pe_getdatadir(Pe *pe, data_directory **dd);
extern void *pe_getopthdr(Pe *pe);
extern int32_t pe_get_file_alignment(Pe *pe);
extern int32_t pe_get_scn_alignment(Pe *pe);
extern int pe_set_image_size(Pe *pe);

extern int pe_extend_file(Pe *pe, size_t size, uint32_t *new_space, int align);
extern int pe_freespace(Pe *pe, uint32_t offset, size_t size);
extern int pe_shorten_file(Pe *pe, size_t size);

extern int pe_clearcert(Pe *pe);
extern int pe_alloccert(Pe *pe, size_t len);
extern int pe_populatecert(Pe *pe, void *cert, size_t len);

extern int pe_errno(void);
extern const char *pe_errmsg(int error);

#endif /* LIBDPE_H */

```

`include/libdpe/pe.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pe.h - types and magic for PE binaries
 * Copyright 2011-2020 Peter Jones <pjones@redhat.com>
 * Copyright 2011 Red Hat, Inc.
 */
#ifndef PE_H
#define PE_H 1

#include <stdint.h>

#define MZ_MAGIC	0x5a4d	/* "MZ" */

struct mz_hdr {
	uint16_t magic;		/* MZ_MAGIC */
	uint16_t lbsize;	/* size of last used block */
	uint16_t blocks;	/* pages in file, 0x3 */
	uint16_t relocs;	/* relocations */
	uint16_t hdrsize;	/* header size in "paragraphs" */
	uint16_t min_extra_pps;	/* .bss */
	uint16_t max_extra_pps;	/* runtime limit for the arena size */
	uint16_t ss;		/* relative stack segment */
	uint16_t sp;		/* initial %sp register */
	uint16_t checksum;	/* word checksum */
	uint16_t ip;		/* initial %ip register */
	uint16_t cs;		/* initial %cs relative to load segment */
	uint16_t reloc_table_offset;	/* offset of the first relocation */
	uint16_t overlay_num;	/* overlay number.  set to 0. */
	uint16_t reserved0[4];	/* reserved */
	uint16_t oem_id;	/* oem identifier */
	uint16_t oem_info;	/* oem specific */
	uint16_t reserved1[10];	/* reserved */
	uint32_t peaddr;	/* address of pe header */
	char message[64];	/* message to print */
};

struct mz_reloc {
	uint16_t offset;
	uint16_t segment;
};

#define PE_MAGIC		0x00004550	/* "PE\0\0" */
#define PE_OPT_MAGIC_PE32	0x010b
#define PE_OPT_MAGIC_PE32_ROM	0x0107
#define PE_OPT_MAGIC_PE32PLUS	0x020b

/* machine type */
#define	IMAGE_FILE_MACHINE_UNKNOWN	0x0000
#define	IMAGE_FILE_MACHINE_AM33		0x01d3
#define	IMAGE_FILE_MACHINE_AMD64	0x8664
#define	IMAGE_FILE_MACHINE_ARM		0x01c0
#define	IMAGE_FILE_MACHINE_ARMV7	0x01c4
#define	IMAGE_FILE_MACHINE_EBC		0x0ebc
#define	IMAGE_FILE_MACHINE_I386		0x014c
#define	IMAGE_FILE_MACHINE_IA64		0x0200
#define	IMAGE_FILE_MACHINE_M32R		0x9041
#define	IMAGE_FILE_MACHINE_MIPS16	0x0266
#define	IMAGE_FILE_MACHINE_MIPSFPU	0x0366
#define	IMAGE_FILE_MACHINE_MIPSFPU16	0x0466
#define	IMAGE_FILE_MACHINE_POWERPC	0x01f0
#define	IMAGE_FILE_MACHINE_POWERPCFP	0x01f1
#define	IMAGE_FILE_MACHINE_R4000	0x0166
#define	IMAGE_FILE_MACHINE_SH3		0x01a2
#define	IMAGE_FILE_MACHINE_SH3DSP	0x01a3
#define	IMAGE_FILE_MACHINE_SH3E		0x01a4
#define	IMAGE_FILE_MACHINE_SH4		0x01a6
#define	IMAGE_FILE_MACHINE_SH5		0x01a8
#define	IMAGE_FILE_MACHINE_THUMB	0x01c2
#define	IMAGE_FILE_MACHINE_WCEMIPSV2	0x0169

/* flags */
#define IMAGE_FILE_RELOCS_STRIPPED           0x0001
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008
#define IMAGE_FILE_AGGRESSIVE_WS_TRIM        0x0010
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020
#define IMAGE_FILE_16BIT_MACHINE             0x0040
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080
#define IMAGE_FILE_32BIT_MACHINE             0x0100
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800
#define IMAGE_FILE_SYSTEM                    0x1000
#define IMAGE_FILE_DLL                       0x2000
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000

struct pe_hdr {
	uint32_t magic;		/* PE magic */
	uint16_t machine;	/* machine type */
	uint16_t sections;	/* number of sections */
	uint32_t timestamp;	/* time_t */
	uint32_t symbol_table;	/* symbol table offset */
	uint32_t symbols;	/* number of symbols */
	uint16_t opt_hdr_size;	/* size of optional header */
	uint16_t flags;		/* flags */
};

struct pe_symtab_entry {
	uint8_t name[8];	/* symbol name */
	uint32_t value;		/* depends */
	uint16_t section;	/* section number */
	uint16_t type;		/* 0x20 for function, 0x0 for not function */
	uint8_t storage_class;	/* storage class */
	uint8_t n_aux_symbols;	/* how many more records this one uses... */
} __attribute__((__packed__)) __attribute__((__aligned__(1)));

#define IMAGE_FILE_OPT_ROM_MAGIC	0x107
#define IMAGE_FILE_OPT_PE32_MAGIC	0x10b
#define IMAGE_FILE_OPT_PE32_PLUS_MAGIC	0x20b

#define IMAGE_SUBSYSTEM_UNKNOWN			 0
#define IMAGE_SUBSYSTEM_NATIVE			 1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI		 2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI		 3
#define IMAGE_SUBSYSTEM_POSIX_CUI		 7
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI		 9
#define IMAGE_SUBSYSTEM_EFI_APPLICATION		10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER	12
#define IMAGE_SUBSYSTEM_EFI_ROM_IMAGE		13
#define IMAGE_SUBSYSTEM_XBOX			14

#define IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE          0x0040
#define IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY       0x0080
#define IMAGE_DLL_CHARACTERISTICS_NX_COMPAT             0x0100
#define IMAGE_DLL_CHARACTERISTICS_NO_ISOLATION          0x0200
#define IMAGE_DLL_CHARACTERISTICS_NO_SEH                0x0400
#define IMAGE_DLL_CHARACTERISTICS_NO_BIND               0x0800
#define IMAGE_DLL_CHARACTERISTICS_WDM_DRIVER            0x2000
#define IMAGE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000

/* the fact that pe32 isn't padded where pe32+ is 64-bit means union won't
 * work right.  vomit. */
struct pe32_opt_hdr {
	/* "standard" header */
	uint16_t magic;		/* file type */
	uint8_t ld_major;	/* linker major version */
	uint8_t ld_minor;	/* linker minor version */
	uint32_t text_size;	/* size of text section(s) */
	uint32_t data_size;	/* size of data section(s) */
	uint32_t bss_size;	/* size of bss section(s) */
	uint32_t entry_point;	/* file offset of entry point */
	uint32_t code_base;	/* relative code addr in ram */
	uint32_t data_base;	/* relative data addr in ram */
	/* "windows" header */
	uint32_t image_base;	/* preferred load address */
	uint32_t section_align;	/* alignment in bytes */
	uint32_t file_align;	/* file alignment in bytes */
	uint16_t os_major;	/* major OS version */
	uint16_t os_minor;	/* minor OS version */
	uint16_t image_major;	/* major image version */
	uint16_t image_minor;	/* minor image version */
	uint16_t subsys_major;	/* major subsystem version */
	uint16_t subsys_minor;	/* minor subsystem version */
	uint32_t win32_version;	/* reserved, must be 0 */
	uint32_t image_size;	/* image size */
	uint32_t header_size;	/* header size rounded up to
				   file_align */
	uint32_t csum;		/* checksum */
	uint16_t subsys;	/* subsystem */
	uint16_t dll_flags;	/* more flags! */
	uint32_t stack_size_req;/* amt of stack requested */
	uint32_t stack_size;	/* amt of stack required */
	uint32_t heap_size_req;	/* amt of heap requested */
	uint32_t heap_size;	/* amt of heap required */
	uint32_t loader_flags;	/* reserved, must be 0 */
	uint32_t data_dirs;	/* number of data dir entries */
};

struct pe32plus_opt_hdr {
	uint16_t magic;		/* file type */
	uint8_t major;		/* linker major version */
	uint8_t minor;		/* linker minor version */
	uint32_t text_size;	/* size of text section(s) */
	uint32_t data_size;	/* size of data section(s) */
	uint32_t bss_size;	/* size of bss section(s) */
	uint32_t entry_point;	/* file offset of entry point */
	uint32_t code_base;	/* relative code addr in ram */
	/* "windows" header */
	uint64_t image_base;	/* preferred load address */
	uint32_t section_align;	/* alignment in bytes */
	uint32_t file_align;	/* file alignment in bytes */
	uint16_t os_major;	/* major OS version */
	uint16_t os_minor;	/* minor OS version */
	uint16_t image_major;	/* major image version */
	uint16_t image_minor;	/* minor image version */
	uint16_t subsys_major;	/* major subsystem version */
	uint16_t subsys_minor;	/* minor subsystem version */
	uint32_t win32_version;	/* reserved, must be 0 */
	uint32_t image_size;	/* image size */
	uint32_t header_size;	/* header size rounded up to
				   file_align */
	uint32_t csum;		/* checksum */
	uint16_t subsys;	/* subsystem */
	uint16_t dll_flags;	/* more flags! */
	uint64_t stack_size_req;/* amt of stack requested */
	uint64_t stack_size;	/* amt of stack required */
	uint64_t heap_size_req;	/* amt of heap requested */
	uint64_t heap_size;	/* amt of heap required */
	uint32_t loader_flags;	/* reserved, must be 0 */
	uint32_t data_dirs;	/* number of data dir entries */
};

typedef struct _data_dirent {
	uint32_t virtual_address;	/* relative to load address */
	uint32_t size;
} data_dirent;

typedef struct _data_directory {
	data_dirent exports;		/* .edata */
	data_dirent imports;		/* .idata */
	data_dirent resources;		/* .rsrc */
	data_dirent exceptions;		/* .pdata */
	data_dirent certs;		/* certs */
	data_dirent base_relocations;	/* .reloc */
	data_dirent debug;		/* .debug */
	data_dirent arch;		/* reservered */
	data_dirent global_ptr;		/* global pointer reg.  Size=0 */
	data_dirent tls;		/* .tls */
	data_dirent load_config;	/* load configuration structure */
	data_dirent bound_imports;	/* no idea */
	data_dirent import_addrs;	/* import address table */
	data_dirent delay_imports;	/* delay-load import table */
	data_dirent clr_runtime_hdr;	/* .cor (object only) */
	data_dirent reserved;
} data_directory;

struct section_header {
	char name[8];			/* name or "/12\0" string tbl offset */
	uint32_t virtual_size;		/* size of loaded section in ram */
	uint32_t virtual_address;	/* relative virtual address */
	uint32_t raw_data_size;		/* size of the section */
	uint32_t data_addr;		/* file pointer to first page of sec */
	uint32_t relocs;		/* file pointer to relocation entries */
	uint32_t line_numbers;		/* line numbers! */
	uint16_t num_relocs;		/* number of relocations */
	uint16_t num_lin_numbers;	/* srsly. */
	uint32_t flags;
};

/* they actually defined 0x00000000 as well, but I think we'll skip that one. */
#define IMAGE_SCN_RESERVED_0	0x00000001
#define IMAGE_SCN_RESERVED_1	0x00000002
#define IMAGE_SCN_RESERVED_2	0x00000004
#define IMAGE_SCN_TYPE_NO_PAD	0x00000008 /* don't pad - obsolete */
#define IMAGE_SCN_RESERVED_3	0x00000010
#define IMAGE_SCN_CNT_CODE	0x00000020 /* .text */
#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 /* .data */
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 /* .bss */
#define IMAGE_SCN_LNK_OTHER	0x00000100 /* reserved */
#define IMAGE_SCN_LNK_INFO	0x00000200 /* .drectve comments */
#define IMAGE_SCN_RESERVED_4	0x00000400
#define IMAGE_SCN_LNK_REMOVE	0x00000800 /* .o only - scn to be rm'd*/
#define IMAGE_SCN_LNK_COMDAT	0x00001000 /* .o only - COMDAT data */
#define IMAGE_SCN_RESERVED_5	0x00002000 /* spec omits this */
#define IMAGE_SCN_RESERVED_6	0x00004000 /* spec omits this */
#define IMAGE_SCN_GPREL		0x00008000 /* global pointer referenced data */
/* spec lists 0x20000 twice, I suspect they meant 0x10000 for one of them */
#define IMAGE_SCN_MEM_PURGEABLE	0x00010000 /* reserved for "future" use */
#define IMAGE_SCN_16BIT		0x00020000 /* reserved for "future" use */
#define IMAGE_SCN_LOCKED	0x00040000 /* reserved for "future" use */
#define IMAGE_SCN_PRELOAD	0x00080000 /* reserved for "future" use */
/* and here they just stuck a 1-byte integer in the middle of a bitfield */
#define IMAGE_SCN_ALIGN_1BYTES	0x00100000 /* it does what it says on the box */
#define IMAGE_SCN_ALIGN_2BYTES	0x00200000
#define IMAGE_SCN_ALIGN_4BYTES	0x00300000
#define IMAGE_SCN_ALIGN_8BYTES	0x00400000
#define IMAGE_SCN_ALIGN_16BYTES	0x00500000
#define IMAGE_SCN_ALIGN_32BYTES	0x00600000
#define IMAGE_SCN_ALIGN_64BYTES	0x00700000
#define IMAGE_SCN_ALIGN_128BYTES 0x00800000
#define IMAGE_SCN_ALIGN_256BYTES 0x00900000
#define IMAGE_SCN_ALIGN_512BYTES 0x00a00000
#define IMAGE_SCN_ALIGN_1024BYTES 0x00b00000
#define IMAGE_SCN_ALIGN_2048BYTES 0x00c00000
#define IMAGE_SCN_ALIGN_4096BYTES 0x00d00000
#define IMAGE_SCN_ALIGN_8192BYTES 0x00e00000
#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000 /* extended relocations */
#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000 /* scn can be discarded */
#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000 /* cannot be cached */
#define IMAGE_SCN_MEM_NOT_PAGED	0x08000000 /* not pageable */
#define IMAGE_SCN_MEM_SHARED	0x10000000 /* can be shared */
#define IMAGE_SCN_MEM_EXECUTE	0x20000000 /* can be executed as code */
#define IMAGE_SCN_MEM_READ	0x40000000 /* readable */
#define IMAGE_SCN_MEM_WRITE	0x80000000 /* writeable */

typedef enum {
	IMAGE_REL_AMD64_ABSOLUTE = 0,
	IMAGE_REL_AMD64_ADDR64,
	IMAGE_REL_AMD64_ADDR32,
	IMAGE_REL_AMD64_ADDR32N,
	IMAGE_REL_AMD64_REL32,
	IMAGE_REL_AMD64_REL32_1,
	IMAGE_REL_AMD64_REL32_2,
	IMAGE_REL_AMD64_REL32_3,
	IMAGE_REL_AMD64_REL32_4,
	IMAGE_REL_AMD64_REL32_5,
	IMAGE_REL_AMD64_SECTION,
	IMAGE_REL_AMD64_SECREL,
	IMAGE_REL_AMD64_SECREL7,
	IMAGE_REL_AMD64_TOKEN,
	IMAGE_REL_AMD64_SREL32,
	IMAGE_REL_AMD64_PAIR,
	IMAGE_REL_AMD64_SSPAN32,
} x64_coff_reloc_type;

typedef enum {
	IMAGE_REL_ARM_ABSOLUTE,
	IMAGE_REL_ARM_ADDR32,
	IMAGE_REL_ARM_ADDR32N,
	IMAGE_REL_ARM_BRANCH2,
	IMAGE_REL_ARM_BRANCH1,
	IMAGE_REL_ARM_SECTION,
	IMAGE_REL_ARM_SECREL,
} arm_coff_reloc_type;

typedef enum {
	IMAGE_REL_SH3_ABSOLUTE,
	IMAGE_REL_SH3_DIRECT16,
	IMAGE_REL_SH3_DIRECT32,
	IMAGE_REL_SH3_DIRECT8,
	IMAGE_REL_SH3_DIRECT8_WORD,
	IMAGE_REL_SH3_DIRECT8_LONG,
	IMAGE_REL_SH3_DIRECT4,
	IMAGE_REL_SH3_DIRECT4_WORD,
	IMAGE_REL_SH3_DIRECT4_LONG,
	IMAGE_REL_SH3_PCREL8_WORD,
	IMAGE_REL_SH3_PCREL8_LONG,
	IMAGE_REL_SH3_PCREL12_WORD,
	IMAGE_REL_SH3_STARTOF_SECTION,
	IMAGE_REL_SH3_SIZEOF_SECTION,
	IMAGE_REL_SH3_SECTION,
	IMAGE_REL_SH3_SECREL,
	IMAGE_REL_SH3_DIRECT32_NB,
	IMAGE_REL_SH3_GPREL4_LONG,
	IMAGE_REL_SH3_TOKEN,
	IMAGE_REL_SHM_PCRELPT,
	IMAGE_REL_SHM_REFLO,
	IMAGE_REL_SHM_REFHALF,
	IMAGE_REL_SHM_RELLO,
	IMAGE_REL_SHM_RELHALF,
	IMAGE_REL_SHM_PAIR,
	IMAGE_REL_SHM_NOMODE,
} sh_coff_reloc_type;

typedef enum {
	IMAGE_REL_PPC_ABSOLUTE,
	IMAGE_REL_PPC_ADDR64,
	IMAGE_REL_PPC_ADDR32,
	IMAGE_REL_PPC_ADDR24,
	IMAGE_REL_PPC_ADDR16,
	IMAGE_REL_PPC_ADDR14,
	IMAGE_REL_PPC_REL24,
	IMAGE_REL_PPC_REL14,
	IMAGE_REL_PPC_ADDR32N,
	IMAGE_REL_PPC_SECREL,
	IMAGE_REL_PPC_SECTION,
	IMAGE_REL_PPC_SECREL16,
	IMAGE_REL_PPC_REFHI,
	IMAGE_REL_PPC_REFLO,
	IMAGE_REL_PPC_PAIR,
	IMAGE_REL_PPC_SECRELLO,
	IMAGE_REL_PPC_GPREL,
	IMAGE_REL_PPC_TOKEN,
} ppc_coff_reloc_type;

typedef enum {
	IMAGE_REL_I386_ABSOLUTE,
	IMAGE_REL_I386_DIR16,
	IMAGE_REL_I386_REL16,
	IMAGE_REL_I386_DIR32,
	IMAGE_REL_I386_DIR32NB,
	IMAGE_REL_I386_SEG12,
	IMAGE_REL_I386_SECTION,
	IMAGE_REL_I386_SECREL,
	IMAGE_REL_I386_TOKEN,
	IMAGE_REL_I386_SECREL7,
	IMAGE_REL_I386_REL32,
} x86_coff_reloc_type;

typedef enum {
	IMAGE_REL_IA64_ABSOLUTE,
	IMAGE_REL_IA64_IMM14,
	IMAGE_REL_IA64_IMM22,
	IMAGE_REL_IA64_IMM64,
	IMAGE_REL_IA64_DIR32,
	IMAGE_REL_IA64_DIR64,
	IMAGE_REL_IA64_PCREL21B,
	IMAGE_REL_IA64_PCREL21M,
	IMAGE_REL_IA64_PCREL21F,
	IMAGE_REL_IA64_GPREL22,
	IMAGE_REL_IA64_LTOFF22,
	IMAGE_REL_IA64_SECTION,
	IMAGE_REL_IA64_SECREL22,
	IMAGE_REL_IA64_SECREL64I,
	IMAGE_REL_IA64_SECREL32,
	IMAGE_REL_IA64_DIR32NB,
	IMAGE_REL_IA64_SREL14,
	IMAGE_REL_IA64_SREL22,
	IMAGE_REL_IA64_SREL32,
	IMAGE_REL_IA64_UREL32,
	IMAGE_REL_IA64_PCREL60X,
	IMAGE_REL_IA64_PCREL60B,
	IMAGE_REL_IA64_PCREL60F,
	IMAGE_REL_IA64_PCREL60I,
	IMAGE_REL_IA64_PCREL60M,
	IMAGE_REL_IA64_IMMGPREL6,
	IMAGE_REL_IA64_TOKEN,
	IMAGE_REL_IA64_GPREL32,
	IMAGE_REL_IA64_ADDEND,
} ia64_coff_reloc_type;

struct coff_reloc {
	uint32_t virtual_address;
	uint32_t symbol_table_index;
	union {
		x64_coff_reloc_type x64_type;
		arm_coff_reloc_type arm_type;
		sh_coff_reloc_type sh_type;
		ppc_coff_reloc_type ppc_type;
		x86_coff_reloc_type x86_type;
		ia64_coff_reloc_type ia64_type;
		uint16_t data;
	};
};

#endif /* PE_H */

```

`libdpe/Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath ..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

LIBTARGETS=libdpe.so
STATICLIBTARGETS=libdpe.a
TARGETS=$(LIBTARGETS) $(STATICLIBTARGETS)

LIBDPE_SOURCES = $(sort $(wildcard *.c))
ALL_SOURCES=$(LIBDPE_SOURCES)
-include $(call deps-of,$(ALL_SOURCES))

all : deps $(TARGETS)

libdpe.a : $(call objects-of,$(LIBDPE_SOURCES))
libdpe.a : LIBS=pthread
# libdpe.a : | $(wildcard *.h) $(wildcard $(TOPDIR)/include/libdpe/*.h)
libdpe.so : $(call objects-of,$(LIBDPE_SOURCES))
libdpe.so : LIBS=pthread
# libdpe.so : | $(wildcard *.h) $(wildcard $(TOPDIR)/include/libdpe/*.h)

deps : $(ALL_SOURCES)
	$(MAKE) -f $(TOPDIR)/Make.deps deps SOURCES="$(ALL_SOURCES)"

clean :
	@rm -rfv *~ *.o *.a *.so *.so.* .*.d

#install :
#	$(INSTALL) -d -m 755 $(DESTDIR)$(libdir)
#	$(foreach x,$(LIBTARGETS), \
#		$(INSTALL) -m 755 $(x) $(DESTDIR)$(libdir)/$(x).$(VERSION) ;\
#		ln -fs $(x).$(VERSION) $(DESTDIR)$(libdir)/$(x).$(MAJOR_VERSION) ;\
#		ln -fs $(x).$(VERSION) $(DESTDIR)$(libdir)/$(x); )
#	$(foreach x,$(STATICLIBTARGETS), \
#		$(INSTALL) -m 644 $(x) $(DESTDIR)$(libdir)/$(x); )

.SECONDARY : $(foreach x,$(LIBTARGETS),$(x).$(VERSION) $(x).$(MAJOR_VERSION))

```

`libdpe/common.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * common.h - common types and helpers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef LIBDPE_COMMON_H
#define LIBDPE_COMMON_H 1

#include "fix_coverity.h"

#include <stdlib.h>
#include <sys/mman.h>

#define pwrite_retry(fd, buf,  len, off) \
	TEMP_FAILURE_RETRY (pwrite (fd, buf, len, off))
#define write_retry(fd, buf, n) \
	TEMP_FAILURE_RETRY (write (fd, buf, n))
#define pread_retry(fd, buf,  len, off) \
	TEMP_FAILURE_RETRY (pread (fd, buf, len, off))

#define is_64_bit(pe) ((pe)->flags & IMAGE_FILE_32BIT_MACHINE)

#define xfree(x) ({if (x) { free(x); x = NULL; }})
#define xmunmap(addr, size) ({if (addr) { munmap(addr,size); addr = NULL; }})

#include <stdio.h>

static inline void * UNUSED
compute_mem_addr(Pe *pe, off_t offset)
{
	/* XXX this might not work when we're not mmapped */
	return (char *)pe->map_address + le32_to_cpu(offset);
}

static inline uint32_t UNUSED
compute_file_addr(Pe *pe, void *addr)
{
	/* XXX this might not work when we're not mmapped */
	return cpu_to_le32((char *)addr - ((char *)pe->map_address));
}

static inline size_t UNUSED
get_shnum(void *map_address, size_t maxsize UNUSED)
{
	size_t result = 0;
	void *buf = (void *)map_address;
	struct mz_hdr *mz = (struct mz_hdr *)buf;

	if (mz == NULL)
		return (size_t)-1l;

	off_t hdr = (off_t)le32_to_cpu(mz->peaddr);
	struct pe_hdr *pe = (struct pe_hdr *)(buf + hdr);

	uint16_t sections = pe->sections;

	result = le16_to_cpu(sections);

	return result;
}

static inline Pe_Kind UNUSED
determine_kind(void *buf, size_t len UNUSED)
{
	Pe_Kind retval = PE_K_NONE;
	uint16_t mz_magic = MZ_MAGIC;
	struct mz_hdr *mz = (struct mz_hdr *)buf;

	if (cmp_le16(&mz->magic, &mz_magic))
		return retval;

	retval = PE_K_MZ;

	off_t hdr = (off_t)le32_to_cpu(mz->peaddr);
	struct pe_hdr *pe = (struct pe_hdr *)(buf + hdr);
	uint32_t pe_magic = PE_MAGIC;

	if (cmp_le32(&pe->magic, &pe_magic))
		return retval;

	if (pe->flags & IMAGE_FILE_EXECUTABLE_IMAGE) {
		if (le32_to_cpu(pe->opt_hdr_size) == 0) {
			/* this PE header is invalid, so return PE_K_MZ */
			return retval;
		}

		struct pe32_opt_hdr *peo =
			(struct pe32_opt_hdr *)(buf + hdr + sizeof(*pe));

		/* if we don't have an optional header, fall back to testing
		 * our machine type list... */
		switch (le16_to_cpu(peo->magic)) {
			case PE_OPT_MAGIC_PE32:
				retval = PE_K_PE_EXE;
				break;
			case PE_OPT_MAGIC_PE32_ROM:
				retval = PE_K_PE_ROM;
				break;
			case PE_OPT_MAGIC_PE32PLUS:
				retval = PE_K_PE64_EXE;
				break;
			default:
				/* some magic we don't know?  Guess based on
				 * machine type */
				retval = is_64_bit(pe)
					? PE_K_PE64_EXE : PE_K_PE_EXE;
				break;
		}
	} else {
		/* this is an object file */
		retval = is_64_bit(pe) ? PE_K_PE64_OBJ : PE_K_PE_OBJ;
	}

	return retval;
}

#undef choose_kind
#undef is_64_bit

static inline Pe * UNUSED
allocate_pe(int fildes, void *map_address, size_t maxsize,
	Pe_Cmd cmd, Pe *parent, Pe_Kind kind, size_t extra)
{
	Pe *result = (Pe *) calloc(1, sizeof (Pe) + extra);
	if (result == NULL) {
		__libpe_seterrno(PE_E_NOMEM);
	} else {
		result->kind = kind;
		result->ref_count = 1;
		result->cmd = cmd;
		result->fildes = fildes;
		result->maximum_size = maxsize;
		result->map_address = map_address;
		result->parent = parent;
	}

	return result;
}

/* We often have to update a flag iff a value changed.  Make this
 * convenient.  */
#define update_if_changed(var, exp, flag)				\
	({								\
		__typeof__ (var) *_var = &(var);			\
		__typeof__ (exp) _exp = (exp);				\
		if (*_var != _exp) {					\
			*_var = _exp;					\
			(flag) |= PE_F_DIRTY;				\
		}							\
	})

#endif /* LIBDPE_COMMON_H */

```

`libdpe/compiler.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * compiler.h - borrow the compiler.h from pesign
 * Copyright Peter Jones <pjones@redhat.com>
 */
#ifndef LIBDPE_COMPILER_H_
#define LIBDPE_COMPILER_H_

#include "../src/compiler.h"

#endif /* !LIBDPE_COMPILER_H_ */
// vim:fenc=utf-8:tw=75:et

```

`libdpe/endian.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * endian.h - helpers for cross-endian data access
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef ENDIAN_H
#define ENDIAN_H

#include <endian.h>
#include <stdint.h>
#include <string.h>

#if __BYTE_ORDER == __LITTLE_ENDIAN
#define cpu_to_le16(x) (x)
#define cpu_to_le32(x) (x)
#define cpu_to_le64(x) (x)
#define le16_to_cpu(x) (x)
#define le32_to_cpu(x) (x)
#define le64_to_cpu(x) (x)
#define cpu_to_be16(x) __builtin_bswap16(x)
#define cpu_to_be32(x) __builtin_bswap32(x)
#define cpu_to_be64(x) __builtin_bswap64(x)
#define be16_to_cpu(x) __builtin_bswap16(x)
#define be32_to_cpu(x) __builtin_bswap32(x)
#define be64_to_cpu(x) __builtin_bswap64(x)
#else
#define cpu_to_be16(x) (x)
#define cpu_to_be32(x) (x)
#define cpu_to_be64(x) (x)
#define be16_to_cpu(x) (x)
#define be32_to_cpu(x) (x)
#define be64_to_cpu(x) (x)
#define cpu_to_le16(x) __builtin_bswap16(x)
#define cpu_to_le32(x) __builtin_bswap32(x)
#define cpu_to_le64(x) __builtin_bswap64(x)
#define le16_to_cpu(x) __builtin_bswap16(x)
#define le32_to_cpu(x) __builtin_bswap32(x)
#define le64_to_cpu(x) __builtin_bswap64(x)
#endif

static inline uint32_t UNUSED
SwapBytes32(uint32_t x)
{
	return __builtin_bswap32(x);
}

static inline int UNUSED
cmp_le16(uint16_t *ledata, uint16_t *cpudata)
{
	uint16_t tmp = le16_to_cpu(*ledata);
	return memcmp(&tmp, cpudata, sizeof(*cpudata));
}

static inline int UNUSED
cmp_le32(uint32_t *ledata, uint32_t *cpudata)
{
	uint32_t tmp = le32_to_cpu(*ledata);
	return memcmp(&tmp, cpudata, sizeof(*cpudata));
}

#endif /* ENDIAN_H */
/* vim:set shiftwidth=8 softtabstop=8: */

```

`libdpe/fix_coverity.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * fix_coverity.h - coverity is a piece of junk and this helps
 * Copyright Peter Jones <pjones@redhat.com>
 */
#ifndef FIX_COVERITY_H
#define FIX_COVERITY_H

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#ifndef __COVERITY_GCC_VERSION_AT_LEAST
#define __COVERITY_GCC_VERSION_AT_LEAST(x, y) 0
#define FAKE__COVERITY_GCC_VERSION_AT_LEAST__
#endif /* __COVERITY_GCC_VERSION_AT_LEAST */

/* With gcc 7 on x86_64 (at least), coverity pretends to be GCC but
 * accidentally doesn't create all of the types GCC would.
 *
 * In glibc's headers, bits/floatn.h has:
 *
 * #if (defined __x86_64__                                              \
 *   ? __GNUC_PREREQ (4, 3)                                             \
 *   : (defined __GNU__ ? __GNUC_PREREQ (4, 5) : __GNUC_PREREQ (4, 4)))
 * # define __HAVE_FLOAT128 1
 * #else
 * # define __HAVE_FLOAT128 0
 * #endif
 *
 * and stdlib.h has:
 *
 * #if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)
 * slash* Likewise for the '_Float128' format  *slash
 * extern _Float128 strtof128 (const char *__restrict __nptr,
 *                       char **__restrict __endptr)
 *      __THROW __nonnull ((1));
 * #endif
 *
 * Which then causes cov-emit to lose its shit:
 *
 * "/usr/include/stdlib.h", line 133: error #20: identifier "_Float128" is
 *           undefined
 *   extern _Float128 strtof128 (const char *__restrict __nptr,
 *          ^
 * "/usr/include/stdlib.h", line 190: error #20: identifier "_Float128" is
 *           undefined
 *                         _Float128 __f)
 *                         ^
 * "/usr/include/stdlib.h", line 236: error #20: identifier "_Float128" is
 *           undefined
 *   extern _Float128 strtof128_l (const char *__restrict __nptr,
 *          ^
 *
 * And then you'll notice something like this later on:
 * [WARNING] Emitted 0 C/C++ compilation units (0%) successfully
 *
 * 0 C/C++ compilation units (0%) are ready for analysis
 *  For more details, please look at:
 *     /home/pjones/devel/github.com/dbxtool/master/cov-int/build-log.txt
 *
 * You would think that if you're writing something that pretends to be
 * gcc, and you've got a "build a configuration by running shit through gcc
 * and looking at the output" stage (which they do), you would run "gcc -da
 * -fdump-tree-all -c -o foo.o foo.c" on an empty file and snarf up all the
 * types defined in the foo.c.001t.tu output.  Apparently, they do not.
 *
 * Anyway, even just defining the type doesn't always work in the face of
 * how _Complex is defined, so we cheat a bit here.  Be prepared to vomit.
 */
#ifdef __x86_64__
#if __COVERITY_GCC_VERSION_AT_LEAST(7, 0)
#if 0
typedef float _Float128 __attribute__((__mode__(__TF__)));
typedef __complex__ float __cfloat128 __attribute__ ((__mode__ (__TC__)));
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
#else
#include <unistd.h>
#define __cplusplus 201103L
#include <bits/floatn.h>
#undef __cplusplus
#endif
#endif
#endif

#ifdef FAKE__COVERITY_GCC_VERSION_AT_LEAST__
#undef FAKE__COVERITY_GCC_VERSION_AT_LEAST
#undef __COVERITY_GCC_VERSION_AT_LEAST
#endif

#endif /* !FIX_COVERITY_H */
// vim:fenc=utf-8:tw=75

```

`libdpe/libdpe.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * libdpe.c - miscelanious PE access functions
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <stdio.h>

#include "libdpe_priv.h"

Pe *pe_clone(Pe *pe UNUSED,
	     Pe_Cmd cmd UNUSED)
{
	return NULL;
}

Pe *pe_memory(char *image UNUSED,
	      size_t size UNUSED)
{
	return NULL;
}

Pe_Kind pe_kind(Pe *pe)
{
	return pe == NULL ? PE_K_NONE : pe->kind;
}

```

`libdpe/libdpe_priv.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * libdpe_priv.h - private types and helpers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef LIBDPE_PRIV_H
#define LIBDPE_PRIV_H 1

#include <errno.h>
#include <libdpe/libdpe.h>

#include "compiler.h"
#include "endian.h"

enum {
	PE_F_DIRTY = 0x1,
	PE_F_MMAPPED = 0x40,
	PE_F_MALLOCED = 0x80,
	PE_F_FILEDATA = 0x100,
};

enum {
	PE_E_NOERROR = 0,
	PE_E_UNKNOWN_ERROR,
	PE_E_INVALID_HANDLE,
	PE_E_NOMEM,
	PE_E_INVALID_FILE,
	PE_E_WRITE_ERROR,
	PE_E_INVALID_INDEX,
	PE_E_INVALID_OP,
	PE_E_INVALID_CMD,
	PE_E_INVALID_OPERAND,
	PE_E_WRONG_ORDER_PEHDR,
	PE_E_FD_DISABLED,
	PE_E_FD_MISMATCH,
	PE_E_UPDATE_RO,
	PE_E_NUM /* terminating entry */
};

extern void __libpe_seterrno(int value);

struct Pe_Scn {
	size_t index;
	struct Pe *pe;
	struct section_header *shdr;
	unsigned int shdr_flags;
	unsigned int flags;

	char *rawdata_base;
	char *data_base;

	struct Pe_ScnList *list;
};

typedef struct Pe_ScnList
{
	unsigned int cnt;
	unsigned int max;
	struct Pe_ScnList *next;
	struct Pe_Scn data[0];
} Pe_ScnList;

struct Pe {
	/* Address to which the file was mapped.  NULL if not mapped. */
	char *map_address;

	Pe *parent;
	Pe *next;

	/* command used to create this object */
	Pe_Cmd cmd;
	Pe_Kind kind;

	int fildes;
	size_t maximum_size;

	int flags;

	int ref_count;

	union {
		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			void *reserved0;
			void *reserved1;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe;

		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			void *reserved0;
			void *reserved1;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe32_obj;

		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			void *reserved0;
			void *reserved1;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe32_rom;

		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			struct pe32_opt_hdr *opthdr;
			data_directory *datadir;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe32_exe;

		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			void *reserved0;
			void *reserved1;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe32plus_obj;

		struct {
			struct mz_hdr *mzhdr;
			struct pe_hdr *pehdr;
			struct pe32plus_opt_hdr *opthdr;
			data_directory *datadir;
			struct section_header *shdr;

			Pe_ScnList *scns_last;
			unsigned int scnincr;

			Pe_ScnList scns;
		} pe32plus_exe;
	} state;
};

#include "common.h"

extern off_t __pe_updatemmap(Pe *pe, size_t shnum);
extern int __pe_updatefile(Pe *pe, size_t shnum);
extern off_t __pe_updatenull(Pe *pe, size_t shnum);
extern char *__libpe_readall(Pe *pe);

#endif /* LIBDPE_PRIV_H */

```

`libdpe/pe_addcert.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_addcert.c - helpers to manage the PE cert directory
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <unistd.h>

#include "libdpe_priv.h"

int
pe_clearcert(Pe *pe)
{
	int rc;
	data_directory *dd = NULL;

	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	rc = pe_getdatadir(pe, &dd);
	if (rc < 0)
		return rc;

	if (dd->certs.virtual_address != 0) {
		pe_freespace(pe, dd->certs.virtual_address, dd->certs.size);
		memset(&dd->certs, '\0', sizeof (dd->certs));
	}

	return 0;
}

int
pe_alloccert(Pe *pe, size_t size)
{
	int rc;
	data_directory *dd = NULL;

	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	pe_clearcert(pe);

	uint32_t new_space = 0;
	rc = pe_extend_file(pe, size, &new_space, 8);
	if (rc < 0)
		return rc;

	rc = pe_getdatadir(pe, &dd);
	if (rc < 0)
		return rc;

	void *addr = compute_mem_addr(pe, new_space);
	/* We leave the whole list empty until finalize...*/
	memset(addr, '\0', size);

	dd->certs.virtual_address = compute_file_addr(pe, addr);
	dd->certs.size += size;

	return 0;
}

int
pe_populatecert(Pe *pe, void *cert, size_t size)
{
	int rc;
	data_directory *dd = NULL;

	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	rc = pe_getdatadir(pe, &dd);
	if (rc < 0)
		return rc;

	if (size != dd->certs.size)
		return -1;

	void *mem = compute_mem_addr(pe, dd->certs.virtual_address);
	if (!mem)
		return -1;

	memcpy(mem, cert, size);

	uint64_t max_size = pe->maximum_size;
	uint32_t new_space;
	uint32_t page_size = sysconf(_SC_PAGESIZE);

	pe_extend_file(pe, 0, &new_space, page_size);
	uint64_t new_max_size = pe->maximum_size;
	mem = compute_mem_addr(pe, 0);
	msync(mem, new_max_size, MS_SYNC);
	new_max_size -= max_size;
	pe_shorten_file(pe, new_max_size);

	return 0;
}

```

`libdpe/pe_allocspace.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_allocspace.c - allocate space in the PE binary
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>

#define adjust(x,y) ((x) = (typeof (x))(((uint8_t *)(x)) + (y)))
static void
pe_fix_addresses(Pe *pe, int64_t offset)
{
	pe->map_address += offset;

	adjust(pe->state.pe.mzhdr, offset);
	adjust(pe->state.pe.pehdr, offset);
	adjust(pe->state.pe.reserved0, offset);
	adjust(pe->state.pe.reserved1, offset);
	adjust(pe->state.pe.shdr, offset);

	size_t scncnt = get_shnum(pe->map_address, pe->maximum_size);
	/* in general this means we couldn't identify any sections, so
	 * they must not need to be fixed up. */
	if (scncnt == (size_t)-1l)
		return;

	for (size_t cnt = 0; cnt < scncnt; cnt++) {
		pe->state.pe.scns.data[cnt].shdr =
			&pe->state.pe.shdr[cnt];

		adjust(pe->state.pe.scns.data[cnt].rawdata_base, offset);
		adjust(pe->state.pe.scns.data[cnt].data_base, offset);
	}
}
#undef adjust

#define align(val, align) (((val) + (align) -1 ) & (- (align)))

int
pe_set_image_size(Pe *pe)
{
	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	uint32_t image_size = 0;
	struct pe_hdr *pehdr = pe->state.pe.pehdr;
	struct pe32plus_opt_hdr *opthdr = pe->state.pe32plus_exe.opthdr;

	Pe_Scn *scn = NULL;
	struct section_header shdr = { "", 0, }, tmp_shdr;
	if (pehdr->sections < 1)
		return -1;

	for (int i = 0; i < pehdr->sections; i++) {
		scn = pe_nextscn(pe, scn);
		if (scn == NULL)
			break;
		pe_getshdr(scn, &tmp_shdr);
		if (tmp_shdr.virtual_size > 0)
			memcpy (&shdr, &tmp_shdr, sizeof(shdr));
	}

	int falign = pe_get_file_alignment(pe);
	int salign = pe_get_scn_alignment(pe);
	image_size = shdr.virtual_address - opthdr->image_base +
		align(align(shdr.virtual_size, falign), salign);

	pe->state.pe32plus_exe.opthdr->image_size = image_size;
	return 0;
}

int
pe_extend_file(Pe *pe, size_t size, uint32_t *new_space, int align)
{
	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	void *new = NULL;

	if (align)
		align = ALIGNMENT_PADDING(pe->maximum_size, align);
	int extra = size + align;

	int rc = ftruncate(pe->fildes, pe->maximum_size + extra);
	if (rc < 0)
		return -1;

	new = mremap(pe->map_address, pe->maximum_size,
		pe->maximum_size + extra, MREMAP_MAYMOVE);
	if (new == MAP_FAILED) {
		__libpe_seterrno (PE_E_NOMEM);
		return -1;
	}
	if (new != pe->map_address)
		pe_fix_addresses(pe, (uint8_t *)new-(uint8_t *)pe->map_address);

	char *addr = compute_mem_addr(pe, pe->maximum_size);
	memset(addr, '\0', extra);

	*new_space = compute_file_addr(pe, addr + align);

	pe->maximum_size = pe->maximum_size + extra;

	return 0;
}

int
pe_shorten_file(Pe *pe, size_t size)
{
	void *new = NULL;

	if (!pe) {
		errno = EINVAL;
		return -1;
	}
	new = mremap(pe->map_address, pe->maximum_size,
		pe->maximum_size - size, 0);
	if (new == MAP_FAILED) {
		__libpe_seterrno (PE_E_NOMEM);
		return -1;
	}

	int rc = ftruncate(pe->fildes, pe->maximum_size - size);
	if (rc < 0)
		return -1;

	pe->maximum_size -= size;
	return 0;
}

int
pe_freespace(Pe *pe, uint32_t offset, size_t size)
{
	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	void *addr = compute_mem_addr(pe, offset);
	memset(addr, '\0', size);

	if (offset + size == pe->maximum_size)
		pe_shorten_file(pe, size);

	/* XXX PJFIX TODO: this should actually de-allocate the space, *if*
	 * it's the certificate list, when it isn't at the end of the file,
	 * too. */

	return 0;
}

```

`libdpe/pe_begin.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_begin.c - read the PE objects from the media
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "libdpe_priv.h"

static inline Pe *
file_read_pe_obj(int fildes UNUSED,
		 void *map_address UNUSED,
		 unsigned char *p_ident UNUSED,
		 size_t maxsize UNUSED,
		 Pe_Cmd cmd UNUSED,
		 Pe *parent UNUSED)
{
	return NULL;
}

static inline Pe *
file_read_pe_exe(int fildes, void *map_address, unsigned char *p_ident,
		 size_t maxsize, Pe_Cmd cmd UNUSED,
		 Pe *parent)
{
	Pe_Kind kind = determine_kind(p_ident, maxsize);
	size_t scncnt = get_shnum(map_address, maxsize);
	if (scncnt == (size_t) -1l) {
		/* Could not determine the number of sections. */
		return NULL;
	}

	if (scncnt > SIZE_MAX / sizeof(Pe_Scn) + sizeof (struct section_header))
		return NULL;

	const size_t scnmax = (scncnt ?: (cmd == PE_C_RDWR || cmd == PE_C_RDWR_MMAP) ? 1: 0);
	Pe *pe = allocate_pe(fildes, map_address, maxsize, cmd, parent,
			kind, scnmax * sizeof (Pe_Scn));
	if (pe == NULL)
		return NULL;

	pe->state.pe32_obj.mzhdr = (struct mz_hdr *) ((char *)map_address);

	pe->state.pe32_obj.pehdr = (struct pe_hdr *)((char *)map_address +
		 (off_t)le32_to_cpu(pe->state.pe32_obj.mzhdr->peaddr));

	assert((unsigned int)scncnt == scncnt);
	pe->state.pe32_obj.scns.cnt = scncnt;
	pe->state.pe32_obj.scns.max = scnmax;

	pe->state.pe32_obj.scnincr = 10;

	size_t ddsize = 0;

	switch (kind) {
		case PE_K_PE_OBJ:
			pe->state.pe32_obj.shdr = (struct section_header *)
				((char *)pe->state.pe32_obj.pehdr +
				sizeof (struct pe_hdr));
			break;
		case PE_K_PE_EXE:
			pe->state.pe32_exe.opthdr = (struct pe32_opt_hdr *)
				((char *)pe->state.pe32_exe.pehdr +
				sizeof (struct pe_hdr));
			pe->state.pe32_exe.datadir = (data_directory *)
				((char *)pe->state.pe32_exe.opthdr +
				sizeof (struct pe32_opt_hdr));
			ddsize = le32_to_cpu(
					pe->state.pe32_exe.opthdr->data_dirs);
			pe->state.pe32_exe.shdr = (struct section_header *)
				((char *)pe->state.pe32_exe.datadir +
				(sizeof (data_dirent) * ddsize));
			break;
		case PE_K_PE64_OBJ:
			pe->state.pe32plus_obj.shdr = (struct section_header *)
				((char *)pe->state.pe32plus_obj.pehdr +
				sizeof (struct pe_hdr));
			break;
		case PE_K_PE64_EXE:
			pe->state.pe32plus_exe.opthdr =
				(struct pe32plus_opt_hdr *)
					((char *)pe->state.pe32plus_exe.pehdr +
					sizeof (struct pe_hdr));
			pe->state.pe32plus_exe.datadir = 
				(data_directory *)
					((char *)pe->state.pe32plus_exe.opthdr +
					sizeof (struct pe32plus_opt_hdr));
			ddsize = le32_to_cpu(
				pe->state.pe32plus_exe.opthdr->data_dirs);
			pe->state.pe32plus_exe.shdr = (struct section_header *)
				((char *)pe->state.pe32plus_exe.datadir +
				(sizeof (data_dirent) * ddsize));
			break;
		default:
			break;
	}

	for (size_t cnt = 0; cnt < scncnt; cnt++) {
		pe->state.pe.scns.data[cnt].index = cnt;
		pe->state.pe.scns.data[cnt].pe = pe;
		pe->state.pe.scns.data[cnt].shdr =
			&pe->state.pe.shdr[cnt];

		uint32_t raw_data_size =
			le32_to_cpu(pe->state.pe.shdr[cnt].raw_data_size);
		uint32_t data_addr =
			le32_to_cpu(pe->state.pe.shdr[cnt].data_addr);

		if (data_addr < maxsize &&
				maxsize - data_addr <= raw_data_size)
			pe->state.pe.scns.data[cnt].rawdata_base =
				pe->state.pe.scns.data[cnt].data_base = 
				((char *)map_address + data_addr);
		pe->state.pe.scns.data[cnt].list = &pe->state.pe.scns;
	}

	return pe;
}

Pe *
__libpe_read_mmapped_file(int fildes, void *map_address, size_t maxsize,
			Pe_Cmd cmd, Pe *parent)
{
	unsigned char *p_ident = (unsigned char *) map_address;

	Pe_Kind kind = determine_kind (p_ident, maxsize);

	switch (kind) {
		case PE_K_PE_OBJ:
		case PE_K_PE64_OBJ:
			return file_read_pe_obj(fildes, map_address, p_ident,
						maxsize, cmd, parent);
		case PE_K_PE64_EXE:
		case PE_K_PE_EXE:
			return file_read_pe_exe(fildes, map_address, p_ident,
						maxsize, cmd, parent);
		case PE_K_MZ:
			errno = ENOSYS;
			return NULL;
		default:
			break;
	}

	return allocate_pe(fildes, map_address, maxsize, cmd, parent,
		PE_K_NONE, 0);
}

static Pe *
read_unmmapped_file(int fildes, size_t maxsize, Pe_Cmd cmd, Pe *parent)
{
	union {
		struct {
			struct mz_hdr mz;
			struct pe_hdr pe;
			union {
				struct pe32_opt_hdr opt_hdr_32;
				struct pe32plus_opt_hdr opt_hdr_64;
			};
		};
		unsigned char raw[sizeof(struct mz_hdr)
				  + sizeof(struct pe_hdr)
				  + sizeof(struct pe32plus_opt_hdr)];
	} mem;

	ssize_t nread = pread_retry (fildes, &mem.mz, sizeof(mem.mz), 0);
	if (nread == -1)
		return NULL;

	/* this handles MZ-only binaries wrong, but who cares, really? */
	off_t peaddr = le32_to_cpu(mem.mz.peaddr);
	ssize_t prev_nread = nread;
	nread += pread_retry (fildes, &mem.pe, sizeof(mem.pe), peaddr);
	if (nread == prev_nread)
		return NULL;
	mem.mz.peaddr = cpu_to_le32(offsetof(typeof(mem), pe));

	Pe_Kind kind = determine_kind(&mem, nread);

	switch (kind) {
		case PE_K_PE_OBJ:
			return file_read_pe_obj(fildes, NULL, mem.raw, maxsize,
						cmd, parent);
		case PE_K_PE_EXE:
			return file_read_pe_exe(fildes, NULL, mem.raw, maxsize,
						cmd, parent);
		default:
			break;
	}

	return allocate_pe(fildes, NULL, maxsize, cmd, parent, PE_K_NONE, 0);
}

static Pe *
read_file(int fildes, size_t maxsize, Pe_Cmd cmd, Pe *parent)
{
	void *map_address = NULL;
	int use_mmap = (cmd == PE_C_READ_MMAP ||
			cmd == PE_C_RDWR_MMAP ||
			cmd == PE_C_WRITE_MMAP ||
			cmd == PE_C_READ_MMAP_PRIVATE);

	if (use_mmap) {
		if (parent == NULL) {
			if (maxsize == ~((size_t) 0)) {
				struct stat st;

				if (fstat(fildes, &st) == 0 &&
						(sizeof(size_t) >=
							sizeof(st.st_size)||
						st.st_size <= ~((size_t)0)))
					maxsize = (size_t) st.st_size;
			}

			map_address = mmap(NULL, maxsize,
					cmd == PE_C_READ_MMAP
						? PROT_READ
						: PROT_READ|PROT_WRITE,
					cmd == PE_C_READ_MMAP_PRIVATE
						|| cmd == PE_C_READ_MMAP
						? MAP_PRIVATE : MAP_SHARED,
					fildes, 0);
			if (map_address == MAP_FAILED)
				map_address = NULL;
		} else {
			assert (maxsize != ~((size_t)0));

			map_address = parent->map_address;
		}
	}

	if (map_address != NULL) {
		assert(map_address != MAP_FAILED);

		struct Pe *result = __libpe_read_mmapped_file(fildes,
						map_address, maxsize,
						cmd, parent);

		if (result == NULL && (parent == NULL ||
				parent->map_address != map_address))
			munmap(map_address, maxsize);
		else if (parent == NULL)
			result->flags |= PE_F_MMAPPED;

		return result;
	}

	return read_unmmapped_file(fildes, maxsize, cmd, parent);
}

static struct Pe *
write_file (int fd, Pe_Cmd cmd)
{
#define NSCNSALLOC	10
	Pe *result = allocate_pe(fd, NULL, 0, cmd, NULL, PE_K_PE_EXE,
				NSCNSALLOC * sizeof (Pe_Scn));

	if (result != NULL) {
		result->flags = PE_F_DIRTY;

		result->state.pe.scnincr = NSCNSALLOC;
		result->state.pe.scns_last = &result->state.pe.scns;
		result->state.pe.scns.max = NSCNSALLOC;
	}

	return result;
}

static Pe *
dup_pe(int fildes, Pe_Cmd cmd UNUSED, Pe *ref)
{
	if (fildes == -1) {
		fildes = ref->fildes;
	}

	if (ref->fildes != -1 && fildes != ref->fildes) {
		__libpe_seterrno(PE_E_FD_MISMATCH);
		return NULL;
	}

	if (ref->cmd != PE_C_READ && ref->cmd != PE_C_READ_MMAP &&
			ref->cmd != PE_C_WRITE && ref->cmd != PE_C_WRITE_MMAP &&
			ref->cmd != PE_C_RDWR && ref->cmd != PE_C_RDWR_MMAP &&
			ref->cmd != PE_C_READ_MMAP_PRIVATE) {
		__libpe_seterrno(PE_E_INVALID_OP);
		return NULL;
	}

	/* for now, just increment the refcount and return the same object */
	ref->ref_count++;

	return ref;
}

Pe *
pe_begin(int fildes, Pe_Cmd cmd, Pe *ref)
{
	Pe *retval = NULL;

	if (fcntl(fildes, F_GETFL) == -1 && errno == EBADF) {
		__libpe_seterrno(PE_E_INVALID_FILE);
		return NULL;
	}

	switch (cmd) {
		case PE_C_NULL:
			break;

		case PE_C_READ_MMAP_PRIVATE:
			if (ref != NULL && ref->cmd != PE_C_READ_MMAP_PRIVATE) {
				__libpe_seterrno(PE_E_INVALID_CMD);
				break;
			}
			/* fall through */
		case PE_C_READ:
		case PE_C_READ_MMAP:
			if (ref != NULL)
				retval = dup_pe(fildes, cmd, ref);
			else
				retval = read_file(fildes, ~((size_t)0), cmd,
						NULL);
			break;
		case PE_C_RDWR:
		case PE_C_RDWR_MMAP:
			if (ref != NULL) {
				if (ref->cmd != PE_C_RDWR &&
						ref->cmd != PE_C_RDWR_MMAP &&
						ref->cmd != PE_C_WRITE &&
						ref->cmd != PE_C_WRITE_MMAP) {
					__libpe_seterrno(PE_E_INVALID_CMD);
					retval = NULL;
				}
			} else {
				retval = read_file(fildes, ~((size_t) 0), cmd,
						NULL);
			}
			break;
		case PE_C_WRITE:
		case PE_C_WRITE_MMAP:
			retval = write_file(fildes, cmd);
			break;
		default:
			__libpe_seterrno(PE_E_INVALID_CMD);
			break;
	}

	return retval;
}

```

`libdpe/pe_end.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_end.c - save our results and finalize the PE binary
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <assert.h>

#include "libdpe_priv.h"

int
pe_end(Pe *pe)
{
	Pe *parent = NULL;

	if (pe == NULL) {
		/* This is allowed and is a no-op. */
		return 0;
	}

	if (pe->ref_count != 0 && --pe->ref_count != 0) {
		int result = pe->ref_count;
		return result;
	}

	parent = pe->parent;

	switch (pe->kind) {
	case PE_K_NONE:
	case PE_K_MZ:
		break;
	case PE_K_PE_OBJ:
	case PE_K_PE_EXE:
	case PE_K_PE_ROM:
	case PE_K_PE64_OBJ:
	case PE_K_PE64_EXE:
		{
			Pe_ScnList *list = &pe->state.pe.scns;
			do {
				size_t cnt = list->max;
		
				while (cnt-- > 0) {
					Pe_Scn *scn = &list->data[cnt];
		
					if ((scn->shdr_flags & PE_F_MALLOCED))
						xfree(scn->shdr);
		
					if (scn->data_base != scn->rawdata_base)
						xfree(scn->data_base);
		
					if (pe->map_address == NULL)
						xfree(scn->rawdata_base);
				}
		
				Pe_ScnList *oldp = list;
				list = list->next;
				assert(list == NULL || oldp->cnt == oldp->max);
				if (oldp != &pe->state.pe.scns)
					xfree(oldp);
			} while (list);
		}
		break;
	case PE_K_NUM:
	default:
		break;
	}

	if (pe->map_address != NULL && parent == NULL) {
		if (pe->flags & PE_F_MALLOCED)
			xfree(pe->map_address);
		else if (pe->flags & PE_F_MMAPPED)
			xmunmap(pe->map_address, pe->maximum_size);
	}
	xfree(pe);

	return (parent != NULL && parent->ref_count ? pe_end(parent) : 0);
}

```

`libdpe/pe_error.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_error.c - error handling for libdpe
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <stdio.h>
#include <assert.h>

#include "libdpe_priv.h"

static int global_error;

int
pe_errno (void)
{
	int result = global_error;
	global_error = PE_E_NOERROR;
	return result;
}

static const char msgstr[] =
{
#define PE_E_NOERROR_IDX 0
	"no error"
	"\0"
#define PE_E_UNKNOWN_ERROR_IDX \
	(PE_E_NOERROR_IDX + sizeof "no error")
	"unknown error"
	"\0"
#define PE_E_INVALID_HANDLE_IDX \
	(PE_E_UNKNOWN_ERROR_IDX + sizeof "unknown error")
	"invalid 'Pe' handle"
	"\0"
#define PE_E_NOMEM_IDX \
	(PE_E_INVALID_HANDLE_IDX + sizeof "invalid 'Pe' handle")
	"out of memory"
	"\0"
#define PE_E_INVALID_FILE_IDX \
	(PE_E_NOMEM_IDX + sizeof "out of memory")
	"invalid file descriptor"
	"\0"
#define PE_E_WRITE_ERROR_IDX \
	(PE_E_INVALID_FILE_IDX + sizeof "invalid file descriptor")
	"cannot write data to file"
	"\0"
#define PE_E_INVALID_INDEX_IDX \
	(PE_E_WRITE_ERROR_IDX + sizeof "cannot write data to file")
	"invalid section index"
	"\0"
#define PE_E_INVALID_OP_IDX \
	(PE_E_INVALID_INDEX_IDX + sizeof "invalid section index")
	"invalid operation"
	"\0"
#define PE_E_INVALID_CMD_IDX \
	(PE_E_INVALID_OP_IDX + sizeof "invalid operation")
	"invalid command"
	"\0"
#define PE_E_INVALID_OPERAND_IDX \
	(PE_E_INVALID_CMD_IDX + sizeof "invalid command")
	"invalid operand"
	"\0"
#define PE_E_WRONG_ORDER_PEHDR_IDX \
	(PE_E_INVALID_OPERAND_IDX + sizeof "invalid operand")
	"executable header not created first"
	"\0"
#define PE_E_FD_DISABLED_IDX \
	(PE_E_WRONG_ORDER_PEHDR_IDX + sizeof "executable header not created first")
	"file descriptor disabled"
	"\0"
#define PE_E_FD_MISMATCH_IDX \
	(PE_E_FD_DISABLED_IDX + sizeof "file descriptor disabled")
	"file descriptor mismatch"
	"\0"
#define PE_E_UPDATE_RO_IDX \
	(PE_E_FD_MISMATCH_IDX + sizeof "file descriptor mismatch")
	"update() for write on read-only file"
};

static const uint16_t msgidx[PE_E_NUM] =
{
	[PE_E_NOERROR] = PE_E_NOERROR_IDX,
	[PE_E_UNKNOWN_ERROR] = PE_E_UNKNOWN_ERROR_IDX,
	[PE_E_INVALID_HANDLE] = PE_E_INVALID_HANDLE_IDX,
	[PE_E_NOMEM] = PE_E_NOMEM_IDX,
	[PE_E_INVALID_FILE] = PE_E_INVALID_FILE_IDX,
	[PE_E_WRITE_ERROR] = PE_E_WRITE_ERROR_IDX,
	[PE_E_INVALID_INDEX] = PE_E_INVALID_INDEX_IDX,
	[PE_E_INVALID_OP] = PE_E_INVALID_OP_IDX,
	[PE_E_INVALID_CMD] = PE_E_INVALID_CMD_IDX,
	[PE_E_INVALID_OPERAND] = PE_E_INVALID_OPERAND_IDX,
	[PE_E_WRONG_ORDER_PEHDR] = PE_E_WRONG_ORDER_PEHDR_IDX,
	[PE_E_FD_DISABLED] = PE_E_FD_DISABLED_IDX,
	[PE_E_FD_MISMATCH] = PE_E_FD_MISMATCH_IDX,
	[PE_E_UPDATE_RO] = PE_E_UPDATE_RO_IDX,
};
#define nmsgidx ((int) (sizeof (msgidx) / sizeof (msgidx[0])))

void __libpe_seterrno(int value)
{
	global_error = value >= 0 && value <= nmsgidx
			? value : PE_E_UNKNOWN_ERROR;
}

const char *
pe_errmsg(int error)
{
	int last_error = global_error;

	if (error == 0) {
		assert(msgidx[last_error] < sizeof(msgstr));
		return last_error != 0 ? msgstr + msgidx[last_error] : NULL;
	} else if (error < -1 || error >= nmsgidx) {
		return msgstr + PE_E_UNKNOWN_ERROR_IDX;
	}

	assert (msgidx[error == -1 ? last_error : error] < sizeof (msgstr));
	return msgstr + msgidx[error == -1 ? last_error : error];
}

```

`libdpe/pe_getdatadir.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_getdatadir.c - find the data directory
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

int
pe_getdatadir(Pe *pe, data_directory **dd)
{
	int rc = -1;

	if (!pe || !dd) {
		__libpe_seterrno(PE_E_INVALID_INDEX);
		return rc;
	}

	switch (pe->kind) {
	case PE_K_PE_EXE: {
		*dd = pe->state.pe32_exe.datadir;
		rc = 0;
		break;
	}
	case PE_K_PE64_EXE: {
		*dd = pe->state.pe32plus_exe.datadir;
		rc = 0;
		break;
	}
	case PE_K_PE_OBJ:
	case PE_K_PE64_OBJ:
	case PE_K_PE_ROM:
	default:
		break;
	}

	return rc;
}

```

`libdpe/pe_getpehdr.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_getpehdr - helpers to find the PE file header
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

struct pe_hdr *
pe_getpehdr(Pe *pe, struct pe_hdr *dest)
{
	if (pe == NULL)
		return NULL;
	memcpy(dest, pe->state.pe.pehdr, sizeof(*dest));
	return dest;
}

```

`libdpe/pe_getscn.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_getscn.c - PE section access
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

Pe_Scn *
pe_getscn(Pe *pe, size_t idx)
{
	if (pe == NULL)
		return NULL;

	switch (pe->kind) {
	case PE_K_PE_OBJ:
	case PE_K_PE_EXE:
	case PE_K_PE_ROM:
	case PE_K_PE64_OBJ:
	case PE_K_PE64_EXE:
		break;
	default:
		__libpe_seterrno(PE_E_INVALID_HANDLE);
		return NULL;
	}

	Pe_Scn *result = NULL;

	Pe_ScnList *runp = &pe->state.pe.scns;

	while (1) {
		if (idx < runp->max) {
			if (idx < runp->cnt)
				result = &runp->data[idx];
			else
				__libpe_seterrno(PE_E_INVALID_INDEX);
			break;
		}

		idx -= runp->max;

		runp = runp->next;
		if (runp == NULL) {
			__libpe_seterrno(PE_E_INVALID_INDEX);
			break;
		}
	}

	return result;
}

```

`libdpe/pe_getshdr.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_getshdr - helpers for PE section headers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

struct section_header *
pe_getshdr(Pe_Scn *scn, struct section_header *dst)
{
	struct section_header *result = NULL;

	if (scn == NULL)
		return NULL;

	if (dst == NULL) {
		__libpe_seterrno(PE_E_INVALID_OPERAND);
		return NULL;
	}

	result = memcpy(dst, scn->shdr, sizeof(*dst));

	return result;
}

```

`libdpe/pe_nextscn.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_nextscn.c - PE section iteration
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <assert.h>

#include "libdpe_priv.h"

Pe_Scn *
pe_nextscn(Pe *pe, Pe_Scn *scn)
{
	Pe_Scn *result = NULL;

	if (pe == NULL)
		return NULL;

	if (scn == NULL) {
		if (pe->state.pe.scns.cnt > 0)
			result = &pe->state.pe.scns.data[0];
	} else {
		Pe_ScnList *list = scn->list;

		if (scn + 1 < &list->data[list->cnt]) {
			result = scn + 1;
		} else if (scn + 1 == &list->data[list->max] &&
				(list = list->next) != NULL) {
			assert(list->cnt > 0);
			result = &list->data[0];
		}
	}

	return result;
}

```

`libdpe/pe_opthdr.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_opthdr.c - helpers for the PE optional headers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

void *
pe_getopthdr(Pe *pe)
{
	switch (pe_kind(pe)) {
	case PE_K_PE_EXE:
		return pe->state.pe32_exe.opthdr;
	case PE_K_PE64_EXE:
		return pe->state.pe32plus_exe.opthdr;
	default:
		return NULL;
	}
}

int32_t
pe_get_file_alignment(Pe *pe)
{
	struct pe32_opt_hdr *pe32opthdr = NULL;
	struct pe32plus_opt_hdr *pe64opthdr = NULL;

	switch (pe_kind(pe)) {
	case PE_K_PE_EXE: {
		void *opthdr = pe_getopthdr(pe);
		pe32opthdr = opthdr;
		return pe32opthdr ? (int32_t)pe32opthdr->file_align : -1;
	}
	case PE_K_PE64_EXE: {
		void *opthdr = pe_getopthdr(pe);
		pe64opthdr = opthdr;
		return pe64opthdr ? (int32_t)pe64opthdr->file_align : -1;
		break;
	}
	default:
		break;
	}
	return -1;
}

int32_t
pe_get_scn_alignment(Pe *pe)
{
	struct pe32_opt_hdr *pe32opthdr = NULL;
	struct pe32plus_opt_hdr *pe64opthdr = NULL;

	switch (pe_kind(pe)) {
	case PE_K_PE_EXE: {
		void *opthdr = pe_getopthdr(pe);
		pe32opthdr = opthdr;
		return pe32opthdr ? (int32_t)pe32opthdr->section_align : -1;
	}
	case PE_K_PE64_EXE: {
		void *opthdr = pe_getopthdr(pe);
		pe64opthdr = opthdr;
		return pe64opthdr ? (int32_t)pe64opthdr->section_align : -1;
		break;
	}
	default:
		break;
	}
	return -1;
}


```

`libdpe/pe_rawfile.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_rawfile.c - I really don't remember.
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

char *
pe_rawfile(Pe *pe, size_t *size)
{
	char *result;

	if (pe == NULL) {
		__libpe_seterrno(PE_E_INVALID_HANDLE);
error_out:
		if (size != NULL)
			*size = 0;
		return NULL;
	}

	if (pe->map_address == NULL && __libpe_readall(pe) == NULL)
		goto error_out;

	if (size != NULL)
		*size = pe->maximum_size;

	result = (char *)pe->map_address;

	return result;
}

```

`libdpe/pe_readall.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_readall.c - not implemented
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

char *
__libpe_readall(Pe *pe UNUSED)
{
	return NULL;
}

```

`libdpe/pe_update.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_update.c - routes to update the PE binary
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

static off_t
write_file(Pe *pe, off_t size, size_t shnum)
{
	struct stat st;
	if (fstat(pe->fildes, &st) != 0) {
		__libpe_seterrno(PE_E_WRITE_ERROR);
		return -1;
	}

	if (pe->parent == NULL && (pe->maximum_size == ~((size_t)0) ||
			(size_t)size > pe->maximum_size) &&
			ftruncate(pe->fildes, size) != 0) {
		__libpe_seterrno(PE_E_WRITE_ERROR);
		return -1;
	}

	if (pe->map_address == NULL && pe->cmd == PE_C_WRITE_MMAP) {
		pe->map_address = mmap(NULL, size, PROT_READ|PROT_WRITE,
					MAP_SHARED, pe->fildes, 0);
		if (pe->map_address == MAP_FAILED)
			pe->map_address = NULL;
	}

	if (pe->map_address != NULL) {
		if (__pe_updatemmap(pe, shnum) != 0)
			size = -1;
	} else {
		if (__pe_updatefile(pe, shnum) != 0)
			size = -1;
	}

	if (size != -1 && pe->parent == NULL &&
			pe->maximum_size != ~((size_t)0) &&
			(size_t)size < pe->maximum_size &&
			ftruncate(pe->fildes, size) != 0) {
		__libpe_seterrno(PE_E_WRITE_ERROR);
		size = -1;
	}

	if (size != -1 && (st.st_mode & (S_ISUID | S_ISGID)) &&
			(fchmod(pe->fildes, st.st_mode) != 0)) {
		__libpe_seterrno(PE_E_WRITE_ERROR);
		size = -1;
	}

	if (size != -1 && pe->parent == NULL)
		pe->maximum_size = size;

	return size;
}

loff_t
pe_update(Pe *pe, Pe_Cmd cmd)
{
	if (cmd != PE_C_NULL && cmd != PE_C_WRITE && cmd != PE_C_WRITE_MMAP) {
		__libpe_seterrno(PE_E_INVALID_CMD);
		return -1;
	}

	if (pe == NULL)
		return -1;

	if (pe->kind != PE_K_PE_EXE && pe->kind != PE_K_PE64_EXE &&
			pe->kind != PE_K_PE_OBJ && pe->kind != PE_K_PE64_OBJ &&
			pe->kind != PE_K_PE_ROM) {
		__libpe_seterrno(PE_E_INVALID_HANDLE);
		return -1;
	}

	size_t shnum = (pe->state.pe.scns_last->cnt == 0
		? 0
		: 1 + pe->state.pe.scns_last->data[
					pe->state.pe.scns_last->cnt - 1].index);

	off_t size = __pe_updatenull(pe, shnum);

	if (size != -1 && (cmd == PE_C_WRITE || cmd == PE_C_WRITE_MMAP)) {
		if (pe->cmd != PE_C_RDWR && pe->cmd != PE_C_RDWR_MMAP &&
				pe->cmd != PE_C_WRITE &&
				pe->cmd != PE_C_WRITE_MMAP) {
			__libpe_seterrno(PE_E_UPDATE_RO);
			size = -1;
		} else if (pe->fildes == -1) {
			__libpe_seterrno(PE_E_FD_DISABLED);
			size = -1;
		} else {
			size = write_file(pe, size, shnum);
		}
	}

	return size;
}

```

`libdpe/pe_updatefile.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pe_updatefile.c
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include "libdpe_priv.h"

#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>

static struct section_header * UNUSED
__get_last_section(Pe *pe)
{
	Pe_Scn *scn = NULL;
	Pe_Scn *ret = NULL;

	while ((scn = pe_nextscn(pe, scn)) != NULL) {
		if (!ret) {
			ret = scn;
			continue;
		}

		if (ret->shdr->virtual_address < scn->shdr->virtual_address)
			ret = scn;
	}
	if (ret)
		return ret->shdr;

	return NULL;
}

static int
compare_sections (const void *a, const void *b)
{
	const Pe_Scn **scna = (const Pe_Scn **)a;
	const Pe_Scn **scnb = (const Pe_Scn **)b;
	int rc;

	if ((*scna)->shdr->virtual_address > (*scnb)->shdr->virtual_address)
		return 1;
	if ((*scnb)->shdr->virtual_address > (*scna)->shdr->virtual_address)
		return -1;

	if ((*scna)->shdr->data_addr > (*scnb)->shdr->data_addr)
		return 1;
	if ((*scnb)->shdr->data_addr > (*scna)->shdr->data_addr)
		return -1;

	rc = strcmp((*scna)->shdr->name, (*scnb)->shdr->name);
	if (rc != 0)
		return rc;

	if ((*scna)->shdr->virtual_size > (*scnb)->shdr->virtual_size)
		return 1;
	if ((*scnb)->shdr->virtual_size > (*scna)->shdr->virtual_size)
		return -1;

	if ((*scna)->shdr->raw_data_size > (*scnb)->shdr->raw_data_size)
		return 1;
	if ((*scnb)->shdr->raw_data_size > (*scna)->shdr->raw_data_size)
		return -1;

	return 0;
}

static void UNUSED
sort_sections (Pe_Scn **scns, Pe_ScnList *list)
{
	Pe_Scn **scnp = scns;
	do {
		for (size_t cnt = 0; cnt < list->cnt; ++cnt)
			*scnp++ = &list->data[cnt];
	} while ((list = list->next) != NULL);

	qsort(scns, scnp-scns, sizeof(*scns), compare_sections);
}

off_t
__pe_updatemmap(Pe *pe, size_t shnum UNUSED)
{
	/* This needs to write back the whole file:
	 * 1) mz/pe/pe-o headers
	 * 2) section headers and sections
	 * 3) data directory table and data directories
	 *
	 * We also need to check if the signature is valid and if not,
	 * make sure it's not in the data directory.
	 */

	struct mz_hdr *mzhdr = pe->state.pe.mzhdr;
	struct pe_hdr *pehdr = pe->state.pe.pehdr;

	if (pe->flags & PE_F_DIRTY) {
		off_t offset = 0;
		memcpy(pe->map_address + offset, mzhdr, sizeof(*mzhdr));

		offset += le32_to_cpu(mzhdr->peaddr);
		memcpy(pe->map_address + offset, pehdr, sizeof(*pehdr));
	}

	/* it's not dirty any more, so clear the flag. */
	pe->flags &= ~PE_F_DIRTY;

	/* flush back to disk */
	char *msync_start = ((char *) pe->map_address
		+ (~(sysconf(_SC_PAGESIZE) -1 )));

	data_directory *dd = NULL;
	int rc = pe_getdatadir(pe, &dd);
	if (rc < 0) {
		/* XXX set an error here */
		return -1;
	}

	char *msync_end = (char *)dd + sizeof(*dd);
	msync(msync_start, msync_end - msync_start, MS_SYNC);

	/* TODO: this is not done yet. */
	//struct section_header *sh = __get_last_section(pe);

	size_t dd_size = sizeof (*dd) / sizeof (dd->exports);
	data_dirent *dde = &dd->exports;
	for (unsigned int i = 0; i < dd_size; i++, dde++) {
		if (dde->size != 0) {
			char *addr = compute_mem_addr(pe, dde->virtual_address);
			msync(addr, dde->size, MS_SYNC);
		}
	}

	return 0;
}

int
__pe_updatefile(Pe *pe UNUSED,
		size_t shnum UNUSED)
{
	__libpe_seterrno(PE_E_UNKNOWN_ERROR);
	return 1;
}

```

`libdpe/pe_updatenull.c`:

```c
/// SPDX-License-Identifier: GPLv2
/*
 * pe_updatenull.c - not implemented, really.
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "libdpe_priv.h"

static int
pe_default_mzhdr(Pe *pe, struct mz_hdr *mzhdr)
{
	/* Always write the mz magic */
	uint16_t mz_magic = cpu_to_le16(MZ_MAGIC);
	update_if_changed(mzhdr->magic, mz_magic, pe->flags);

	/* XXX FIXME: write a real MZ header */
	/* print "the only way to win is not to play" */
	return 0;
}

static int
pe_default_pehdr(Pe *pe, struct pe_hdr *pehdr,
		 size_t shnum UNUSED)
{
	/* Always write the pe magic */
	uint32_t pe_magic = cpu_to_le32(PE_MAGIC);
	update_if_changed(pehdr->magic, pe_magic, pe->flags);

	return 0;
}

off_t
__pe_updatenull(Pe *pe UNUSED,
		       size_t shnum UNUSED)
{
	return 0;
}

```

`src/Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath ..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.defaults

BINTARGETS=authvar client efikeygen pesigcheck pesign \
	   pesign-rpmbuild-helper pesum
CFGTARGETS=tmpfiles.conf
SVCTARGETS=pesign.sysvinit pesign.service
MAN1TARGETS=authvar.1 efikeygen.1 pesigcheck.1 pesign-client.1 pesign.1

TARGETS=$(BINTARGETS) $(SVCTARGETS) $(CFGTARGETS)
ifeq ($(ENABLE_DOCS), 1)
TARGETS += $(MAN1TARGETS)
endif

all : deps $(TARGETS)

COMMON_SOURCES = cms_common.c content_info.c \
		 errno-guard.c \
		 oid.c \
		 password.c \
		 signed_data.c signer_info.c \
		 text.c \
		 ucs2.c util.c
COMMON_PE_SOURCES = wincert.c cms_pe_common.c
AUTHVAR_SOURCES = authvar.c authvar_context.c
CLIENT_SOURCES = pesign_context.c actions.c client.c
EFIKEYGEN_SOURCES = efikeygen.c
PESIGCHECK_SOURCES = pesigcheck.c pesigcheck_context.c certdb.c
PESIGN_SOURCES = pesign.c pesign_context.c actions.c daemon.c \
		 file_pe.c file_kmod.c pesign_kmod.c
PESUM_SOURCES = pesum.c pesign_context.c actions.c \
		file_pe.c file_kmod.c pesign_kmod.c

ALL_SOURCES=$(COMMON_SOURCES) $(AUTHVAR_SORUCES) $(CLIENT_SOURCES) \
	$(EFIKEYGEN_SOURCES) $(PESIGCHECK_SOURCES) $(PESIGN_SOURCES) \
	$(PESUM_SOURCES)
-include $(call deps-of,$(ALL_SOURCES))

authvar : $(call objects-of,$(AUTHVAR_SOURCES) $(COMMON_SOURCES))
# authvar : LDLIBS+=$(TOPDIR)/libdpe/libdpe.a
authvar : PKGS=efivar nss nspr popt

client : $(call objects-of,$(CLIENT_SOURCES) $(COMMON_SOURCES) $(COMMON_PE_SOURCES))
client : LDLIBS+=$(TOPDIR)/libdpe/libdpe.a
client : PKGS=efivar nss nspr popt

efikeygen : $(call objects-of,$(EFIKEYGEN_SOURCES) $(COMMON_SOURCES))
efikeygen : PKGS=efivar nss nspr popt uuid

pesigcheck : $(call objects-of,$(PESIGCHECK_SOURCES) $(COMMON_SOURCES) $(COMMON_PE_SOURCES))
pesigcheck : LDLIBS+=$(TOPDIR)/libdpe/libdpe.a
pesigcheck : PKGS=efivar nss nspr popt

pesign : $(call objects-of,$(PESIGN_SOURCES) $(COMMON_SOURCES) $(COMMON_PE_SOURCES))
pesign : LDLIBS+=$(TOPDIR)/libdpe/libdpe.a
pesign : PKGS=efivar nss nspr popt

pesum : $(call objects-of,$(PESUM_SOURCES) $(COMMON_SOURCES) $(COMMON_PE_SOURCES))
pesum : LDLIBS+=$(TOPDIR)/libdpe/libdpe.a
pesum : PKGS=efivar nss nspr popt

deps : PKGS=efivar nss nspr popt uuid
deps : $(ALL_SOURCES)
	$(MAKE) -f $(TOPDIR)/Make.deps \
		SOURCES="$(ALL_SOURCES)" \
		PKGS="$(PKGS)" \
		deps

clean :
	@rm -rfv $(TARGETS)
	@$(call removes)

install_systemd: pesign.service
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(libdatadir)tmpfiles.d/
	$(INSTALL) -m 644 tmpfiles.conf $(INSTALLROOT)$(libdatadir)tmpfiles.d/pesign.conf
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(libdatadir)systemd/system/
	$(INSTALL) -m 644 pesign.service $(INSTALLROOT)$(libdatadir)systemd/system/

install_sysvinit: pesign.sysvinit
	$(INSTALL) -d -m 755 $(INSTALLROOT)/etc/rc.d/init.d/
	$(INSTALL) -m 755 pesign.sysvinit $(INSTALLROOT)/etc/rc.d/init.d/pesign

install :
	$(INSTALL) -d -m 700 $(INSTALLROOT)/etc/pki/pesign/
	$(INSTALL) -d -m 700 $(INSTALLROOT)/etc/pki/pesign-rh-test/
	$(INSTALL) -d -m 770 $(INSTALLROOT)$(rundir)pesign/
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(bindir)
	$(INSTALL) -m 755 authvar $(INSTALLROOT)$(bindir)
	$(INSTALL) -m 755 pesign $(INSTALLROOT)$(bindir)
	$(INSTALL) -m 755 pesum $(INSTALLROOT)$(bindir)
	$(INSTALL) -m 755 client $(INSTALLROOT)$(bindir)pesign-client
	$(INSTALL) -m 755 efikeygen $(INSTALLROOT)$(bindir)
	$(INSTALL) -m 755 pesigcheck $(INSTALLROOT)$(bindir)
	$(INSTALL) -d -m 755 $(INSTALLROOT)/etc/popt.d/
	$(INSTALL) -m 644 pesign.popt $(INSTALLROOT)/etc/popt.d/
ifeq ($(ENABLE_DOCS), 1)
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(mandir)man1/
	$(INSTALL) -m 644 $(MAN1TARGETS) $(INSTALLROOT)$(mandir)man1/
endif
	$(INSTALL) -d -m 755 $(INSTALLROOT)/etc/rpm/
	$(INSTALL) -m 644 macros.pesign $(INSTALLROOT)/etc/rpm/
	$(INSTALL) -d -m 755 $(INSTALLROOT)$(libexecdir)/pesign/
	$(INSTALL) -m 755 pesign-rpmbuild-helper $(INSTALLROOT)$(libexecdir)/pesign/
	$(INSTALL) -d -m 700 $(INSTALLROOT)/etc/pesign
	$(INSTALL) -m 600 pesign-users $(INSTALLROOT)/etc/pesign/users
	$(INSTALL) -m 600 pesign-groups $(INSTALLROOT)/etc/pesign/groups

.PHONY: all deps clean install

```

`src/actions.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * actions.c - pesign's main actions
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <syslog.h>

#include "pesign.h"

#include <prerror.h>

#include <nss.h>
#include <secport.h>
#include <secpkcs7.h>
#include <secder.h>
#include <base64.h>
#include <pk11pub.h>
#include <secerr.h>

static int saw_content;

static void
handle_bytes(void *arg UNUSED,
	     const char *buf UNUSED,
	     unsigned long len UNUSED)
{
	saw_content = 1;
}

static PRBool
decryption_allowed(SECAlgorithmID *algid UNUSED,
		   PK11SymKey *key UNUSED)
{
	return PR_TRUE;
}

void
insert_signature(cms_context *cms, int signum)
{
	SECItem *sig = &cms->newsig;

	if (signum == -1)
		signum = cms->num_signatures;

	SECItem **signatures = realloc(cms->signatures,
		sizeof (SECItem *) * (cms->num_signatures + 1));
	if (!signatures) {
err:
		cms->log(cms, LOG_ERR,
			 "insert signature: could not allocate memory: %m");
		exit(1);
	}
	cms->signatures = signatures;
	if (signum != cms->num_signatures) {
		memmove(cms->signatures[signum+1],
			cms->signatures[signum],
			sizeof(SECItem) * (cms->num_signatures - signum));
	}

	SECItem *newsig = malloc(sizeof (*newsig));
	if (!newsig)
		goto err;

	memcpy(newsig, sig, sizeof (*newsig));
	newsig->data = malloc(sig->len);
	if (!newsig->data)
		goto err;
	memcpy(newsig->data, sig->data, newsig->len);
	cms->signatures[signum] = newsig;
	cms->num_signatures++;

	free(cms->newsig.data);
	memset(&cms->newsig, '\0', sizeof (cms->newsig));
}

int
list_signatures(pesign_context *ctx)
{
	cert_iter iter;

	int rc = cert_iter_init(&iter, ctx->inpe);
	if (rc < 0) {
		printf("No certificate list found.\n");
		return rc;
	}

	void *data;
	ssize_t datalen;
	int nsigs = 0;

	while (1) {
		rc = next_cert(&iter, &data, &datalen);
		if (rc <= 0)
			break;

		SEC_PKCS7DecoderContext *dc = NULL;
		saw_content = 0;
		dc = SEC_PKCS7DecoderStart(handle_bytes, NULL, NULL, NULL,
					NULL, NULL, decryption_allowed);

		if (dc == NULL) {
			fprintf(stderr, "SEC_PKCS7DecoderStart failed\n");
			exit(1);
		}

		SECStatus status = SEC_PKCS7DecoderUpdate(dc, data, datalen);

		if (status != SECSuccess) {
			fprintf(stderr, "Found invalid certificate\n");
			continue;
		}

		SEC_PKCS7ContentInfo *cinfo = SEC_PKCS7DecoderFinish(dc);

		if (cinfo == NULL) {
			fprintf(stderr, "Found invalid certificate\n");
			continue;
		}

		nsigs++;
		printf("---------------------------------------------\n");
		printf("certificate address is %p\n", data);
		printf("Content was%s encrypted.\n",
			SEC_PKCS7ContentIsEncrypted(cinfo) ? "" : " not");
		if (SEC_PKCS7ContentIsSigned(cinfo)) {
			char *signer_cname, *signer_ename;
			SECItem *signing_time;

			if (saw_content) {
				printf("Signature is ");
				PORT_SetError(0);
				if (SEC_PKCS7VerifySignature(cinfo,
						certUsageEmailSigner,
						PR_FALSE)) {
					printf("valid.\n");
				} else {
					printf("invalid (Reason: 0x%08x).\n",
						(uint32_t)PORT_GetError());
				}
			} else {
				printf("Content is detached; signature cannot "
					"be verified.\n");
			}

			signer_cname = SEC_PKCS7GetSignerCommonName(cinfo);
			if (signer_cname != NULL) {
				printf("The signer's common name is %s\n",
					signer_cname);
				PORT_Free(signer_cname);
			} else {
				printf("No signer common name.\n");
			}

			signer_ename = SEC_PKCS7GetSignerEmailAddress(cinfo);
			if (signer_ename != NULL) {
				printf("The signer's email address is %s\n",
					signer_ename);
				PORT_Free(signer_ename);
			} else {
				printf("No signer email address.\n");
			}

			signing_time = SEC_PKCS7GetSigningTime(cinfo);
			if (signing_time != NULL) {
				char *signing_time_str = DER_TimeChoiceDayToAscii(signing_time);
				printf("Signing time: %s\n", signing_time_str);
				PORT_Free(signing_time_str);
			} else {
				printf("No signing time included.\n");
			}

			printf("There were%s certs or crls included.\n",
				SEC_PKCS7ContainsCertsOrCrls(cinfo) ? "" : " no");

			SEC_PKCS7DestroyContentInfo(cinfo);
		}
	}
	if (nsigs) {
		printf("---------------------------------------------\n");
	} else {
		printf("No signatures found.\n");
	}
	return rc;
}

static const char *sig_begin_marker ="-----BEGIN AUTHENTICODE SIGNATURE-----\n";
static const char *sig_end_marker = "\n-----END AUTHENTICODE SIGNATURE-----\n";

void
export_pubkey(pesign_context *p_ctx)
{
	cms_context *ctx = p_ctx->cms_ctx;
	int rc;

	SECItem derPublicKey = ctx->cert->derPublicKey;
	rc = write(p_ctx->outkeyfd, derPublicKey.data, derPublicKey.len);
	close(p_ctx->outkeyfd);
	if (rc >= 0 && (unsigned long)rc == derPublicKey.len)
		exit(0);
	exit(1);
}

void
export_cert(pesign_context *p_ctx)
{
	cms_context *ctx = p_ctx->cms_ctx;
	int rc;

	SECItem derCert = ctx->cert->derCert;
	rc = write(p_ctx->outcertfd, derCert.data, derCert.len);
	close(p_ctx->outcertfd);
	if (rc >= 0 && (unsigned long)rc == derCert.len)
		exit(0);
	exit(1);
}

ssize_t
export_signature(cms_context *cms, int fd, int ascii_armor)
{
	ssize_t ret = 0;
	int rc = 0;

	SECItem *sig = &cms->newsig;

	unsigned char *data = sig->data;
	int datalen = sig->len;
	if (ascii_armor) {
		char *ascii = BTOA_DataToAscii(data, datalen);
		if (!ascii) {
			cms->log(cms, LOG_ERR, "error exporting signature");
failure:
			close(fd);
			return -1;
		}

		rc = write(fd, sig_begin_marker, strlen(sig_begin_marker));
		if (rc < 0) {
			cms->log(cms, LOG_ERR, "error exporting signature: %m");
			goto failure;
		}
		ret += rc;

		rc = write(fd, ascii, strlen(ascii));
		if (rc < 0) {
			cms->log(cms, LOG_ERR, "error exporting signature: %m");
			goto failure;
		}
		ret += rc;

		rc = write(fd, sig_end_marker, strlen(sig_end_marker));
		if (rc < 0) {
			cms->log(cms, LOG_ERR, "error exporting signature: %m");
			goto failure;
		}
		ret += rc;

		PORT_Free(ascii);
	} else {
		rc = write(fd, data, datalen);
		if (rc < 0) {
			cms->log(cms, LOG_ERR, "error exporting signature: %m");
			goto failure;
		}
		ret += rc;
	}
	return ret;
}

void
parse_signature(pesign_context *ctx)
{
	int rc;
	char *sig;
	size_t siglen = 0;

	rc = read_file(ctx->insigfd, &sig, &siglen);
	if (rc < 0)
		liberr(1, "pesign: could not read signature");

	unsigned char *der;
	unsigned int derlen;

	/* XXX FIXME: ignoring length for now */
	char *base64 = strstr(sig, sig_begin_marker);
	if (base64) {
		base64 += strlen(sig_begin_marker);
		char *end = strstr(base64, sig_end_marker);
		if (!end)
			liberr(1, "pesign: Invalid signature");

		derlen = end - base64;
		base64[derlen] = '\0';

		unsigned char *dertmp;
		dertmp = ATOB_AsciiToData(base64, &derlen);

		der = xcalloc(1, derlen);
		memmove(der, dertmp, derlen);
		PORT_Free(dertmp);
	} else {
		der = xcalloc(1, siglen);
		memmove(der, sig, siglen);
		derlen = siglen;
	}
	free(sig);

	ctx->cms_ctx->newsig.data = der;
	ctx->cms_ctx->newsig.len = derlen;

#if 0
	SEC_PKCS7DecoderContext *dc = NULL;
	saw_content = 0;
	dc = SEC_PKCS7DecoderStart(handle_bytes, NULL, NULL, NULL, NULL, NULL,
				decryption_allowed);
	if (dc == NULL) {
decoder_error:
		fprintf(stderr, "pesign: Invalid signature.\n");
		PORT_Free(der);
		exit(1);
	}

	SECStatus status = SEC_PKCS7DecoderUpdate(dc, (char *)der, derlen);
	if (status != SECSuccess)
		goto decoder_error;

	SEC_PKCS7ContentInfo *cinfo = SEC_PKCS7DecoderFinish(dc);
	if (!cinfo)
		goto decoder_error;

	ctx->cinfo = cinfo;
	PORT_Free(der);
#endif
}

void
import_raw_signature(pesign_context *pctx)
{
	if (pctx->rawsigfd < 0 || pctx->insattrsfd < 0) {
		fprintf(stderr, "pesign: raw signature and signed attributes "
			"must both be imported.\n");
		exit(1);
	}

	cms_context *ctx = pctx->cms_ctx;

	ctx->raw_signature = SECITEM_AllocItem(ctx->arena, NULL, 0);
	ctx->raw_signature->type = siBuffer;
	int rc = read_file(pctx->rawsigfd,
				(char **)&ctx->raw_signature->data,
				(size_t *)&ctx->raw_signature->len);
	if (rc < 0) {
		fprintf(stderr, "pesign: could not read raw signature: %m\n");
		exit(1);
	}

	ctx->raw_signed_attrs = SECITEM_AllocItem(ctx->arena, NULL, 0);
	ctx->raw_signed_attrs->type = siBuffer;
	rc = read_file(pctx->insattrsfd,
				(char **)&ctx->raw_signed_attrs->data,
				(size_t *)&ctx->raw_signed_attrs->len);
	if (rc < 0) {
		fprintf(stderr, "pesign: could not read raw signed attributes"
				": %m\n");
		exit(1);
	}
}

int
generate_sattr_blob(pesign_context *ctx)
{
	int rc;
	SECItem sa;
	SpcContentInfo ci;

	memset(&ci, '\0', sizeof (ci));
	rc = generate_spc_content_info(ctx->cms_ctx, &ci);
	if (rc < 0) {
		fprintf(stderr, "Could not generate content info: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}

	rc = generate_signed_attributes(ctx->cms_ctx, &sa);
	if (rc < 0) {
		fprintf(stderr, "Could not generate signed attributes: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}

	return write(ctx->outsattrsfd, sa.data, sa.len);
}

void
check_signature_space(pesign_context *ctx)
{
	ssize_t available = available_cert_space(ctx->outpe);
	ssize_t target = ctx->cms_ctx->newsig.len + sizeof (win_certificate_header_t);

	target += ALIGNMENT_PADDING(target, 8);

	if (available >= target)
		return;

	fprintf(stderr, "Could not add new signature: insufficient space.\n");
	exit(1);
}

void
allocate_signature_space(Pe *pe, ssize_t sigspace)
{
	int rc;

	rc = pe_alloccert(pe, sigspace);
	if (rc < 0) {
		fprintf(stderr, "Could not allocate space for signature: %m\n");
		exit(1);
	}
}

void
remove_signature(pesign_context *p_ctx)
{
	cms_context *ctx = p_ctx->cms_ctx;

	free(ctx->signatures[p_ctx->signum]->data);
	free(ctx->signatures[p_ctx->signum]);
	if (p_ctx->signum != ctx->num_signatures - 1)
		memmove(&ctx->signatures[p_ctx->signum],
			&ctx->signatures[p_ctx->signum+1],
			sizeof(SECItem*) *
				(ctx->num_signatures - p_ctx->signum - 1));

	ctx->num_signatures--;
}

```

`src/actions.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * actions.h - helpers for our high-level actions
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_CRYPTO_H
#define PESIGN_CRYPTO_H 1

#include <cert.h>
#include <secpkcs7.h>

#include "wincert.h"

extern int list_signatures(pesign_context *ctx);
extern void check_signature_space(pesign_context *ctx);
extern void allocate_signature_space(Pe *pe, ssize_t sigspace);
extern ssize_t export_signature(cms_context *cms, int fd, int ascii_armor);
extern void import_raw_signature(pesign_context *pctx);
extern void remove_signature(pesign_context *ctx);
extern void export_pubkey(pesign_context *ctx);
extern void export_cert(pesign_context *ctx);
extern int generate_sattr_blob(pesign_context *pctx);
extern void parse_signature(pesign_context *ctx);
extern void insert_signature(cms_context *cms, int signum);

#endif /* PESIGN_CRYPTO_H */

```

`src/authvar.1.mdoc`:

```mdoc
.Dd $Mdocdate: Jun 4 2020$
.Dt AUTHVAR 1
.Os Linux
.Sh NAME
.Nm authvar
.Nd handles authenticated variables for pesign
.Sh SYNOPSIS
.Nm
.Bk -words
.Ao
.Fl a |
.Fl c |
.Fl s
.Ac
.Ek
.Bk -words
.Cm Fl N Ar {guid}
.Cm Fl n Ar name
.Ek
.Bk -words
.Ao
.Fl v Ar value |
.Fl f Ar file
.Ac
.Ek
.Bk -words
.Op Fl t Ar time
.Op Fl d Ar directory
.Op Fl S Ar nickname
.Op Fl i Ar file
.Op Fl e Ar file
.Ek
.Sh DESCRIPTION
.Nm
is a command line utility for handling authenticated UEFI variables.
.Sh OPTIONS
.Bl -tag
.It Fl a | Fl Fl append
Append to variable
.It Fl c | Fl Fl clear
Clear variable
.It Fl s | Fl Fl set
set variable
.It Fl N Ao {guid} | namespace Ac | Fl Fl namespace Ao {guid} | namespace Ac
Variable is in
.Ar namespace
or
.Ar {guid}
.Po
default:
.Pa global
.Pc

Use
.Fl N Ar help
to list namespaces.
.It Fl n Ar name | Fl Fl name Ar name
Variable
.Ar name
.It Fl v Ar value | Fl Fl value Ar value
Set or append
.Ar value
to variable
.It Fl f Ar file | Fl Fl valuefile Ar file
Read value from
.Ar file
.It Fl t Ar time | Fl Fl timestamp Ar time
Timestamp for the variable
.Po
default:
.Pa now
.Pc
.It Fl d Ar directory | Fl Fl certdir Ar directory
Specify nss certificate database
.Ar directory
.Po
default:
.Pa /etc/pki/pesign
.Pc
.It Fl S Ar nickname | Fl Fl sign Ar nickname
Sign variable with certificate
.Ar nickname
from the NSS database
.It Fl i Ar file | Fl Fl import Ar file
Import variable from
.Ar file
.It Fl e Ar file | Fl Fl export Ar file
Export variable to
.Ar file
instead of setting it in firmware
.Sh STANDARDS
.Rs
.%A B. Kaliski
.%R RFC 2315
.%B PKCS #7: Cryptographic Message Syntax v1.5
.%I Internet Engineering Task Force
.%D March 1998
.%U https://tools.ietf.org/html/rfc2315\ \&
.Re

.Rs
.%A K. Moriarty
.%A M. Nyström
.%A S. Parkinson
.%A A. Rusch
.%A M. Scott
.%R RFC 7292
.%B PKCS #12: Personal Information Exchange Syntax v1.1
.%I Internet Engineering Task Force
.%D July 2014
.%U https://tools.ietf.org/html/rfc7292\ \&
.Re

.Rs
.%A PKCS11 Technical Committee
.%B PKCS#11: Cryptographic Token Interface Standard
.%I OASIS
.%U https://www.cryptsoft.com/pkcs11doc/\ \&
.Re

.Rs
.%A UEFI Specification Working Group
.%B Unified Extensible Firmware Interface (UEFI) Specification Version 2.8
.%I Unified Extensible Firmware Interface Forum
.%D March 2019
.%U https://uefi.org/specifications\ \&
.Re
.Sh "SEE ALSO"
.Xr pesign 1 ,
.Xr certutil 1
.Sh AUTHORS
.An Peter Jones

```

`src/authvar.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * authvar.c - main entry for the authvar utility
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <errno.h>
#include <popt.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>

#include <efivar.h>
#include <prerror.h>
#include <nss.h>

#include "authvar.h"

#define NO_FLAGS		0x00
#define GENERATE_APPEND		0x01
#define GENERATE_CLEAR		0x02
#define GENERATE_SET		0x04
#define SIGN			0x08
#define IMPORT			0x10
#define EXPORT			0x20
#define SET			0x40
#define SHOW_SIGNATURE_SUPPORT	0x80

#define FLAG_LIST_END		0x100

static struct {
	int flag;
	const char *name;
} flag_names[] = {
	{GENERATE_APPEND, "append" },
	{GENERATE_CLEAR, "clear" },
	{GENERATE_SET, "set" },
	{SIGN, "sign" },
	{IMPORT, "import" },
	{EXPORT, "export" },
	{SET, "set_firmware" },
	{FLAG_LIST_END, NULL },
};

static void
print_flag_name(FILE *f, int flag)
{
	for (int i = 0; flag_names[i].flag != FLAG_LIST_END; i++) {
		if (flag_names[i].flag & flag)
			fprintf(f, "%s ", flag_names[i].name);
	}
}

static void
check_name(authvar_context *ctx)
{
	conderrx(!ctx->name || !*ctx->name, 1, "no name specified.");
}

static void
check_value(authvar_context *ctx, int needed)
{
	if ((!ctx->value || !*ctx->value) &&
			(!ctx->valuefile || !*ctx->valuefile)) {
		if (needed)
			warnx("no value specified.");
		else
			return;
		exit(1);
	}
	if (ctx->value && *ctx->value && ctx->valuefile && *ctx->valuefile) {
		conderrx(needed, 1,
			 "--value and --valuefile cannot be used together.");
		errx(1, "command does not take a value.");
	}

	if (ctx->value) {
		ctx->value_size = strlen(ctx->value);
	}
}

static void
open_input(authvar_context *ctx)
{
	struct stat sb;
	int rc;

	if (!ctx->valuefile)
		return;

	ctx->valuefd = open(ctx->valuefile, O_RDONLY|O_CLOEXEC);
	conderr(ctx->valuefd < 0, 1, "Error opening valuefile");

	rc = fstat(ctx->valuefd, &sb);
	conderr(rc < 0, 1, "Error mapping valuefile");

	ctx->value_size = sb.st_size;

	ctx->value = (char *)mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE,
			     ctx->valuefd, 0);
	conderr(ctx->value == MAP_FAILED, 1, "Error mapping valuefile");
}

#define EFIVAR_DIR "/sys/firmware/efi/efivars/"

static void
generate_efivars_filename(authvar_context *ctx)
{
	char *guid = NULL;
	int rc = efi_guid_to_str(&ctx->guid, &guid);
	conderr(rc < 0, 1, "Couldn't convert guid to string");

	char *filename = NULL;
	rc = asprintf(&filename, "/sys/firmware/efi/efivars/%s-%s", ctx->name, guid);
	conderr(rc < 0, 1, "can't make string");

	free(guid);
	ctx->exportfile = filename;
}

static void
open_output(authvar_context *ctx)
{
	int flags;
	mode_t mode;

	if (!ctx->exportfile) {
		generate_efivars_filename(ctx);
		ctx->to_firmware = 1;
	} else if (access(ctx->exportfile, F_OK) == 0) {
		errx(1, "\"%s\" exists", ctx->exportfile);
	}

	flags = O_CREAT|O_RDWR|O_CLOEXEC;
	mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
	ctx->exportfd = open(ctx->exportfile, flags, mode);
	conderr(ctx->exportfd < 0, 1, "Error opening exportfile");
}

static int
find_namespace_guid(authvar_context *ctx)
{
	int rc;
	efi_guid_t guid;

	rc = efi_name_to_guid(ctx->namespace, &guid);
	if (rc < 0)
		return rc;
	memcpy(&ctx->guid, &guid, sizeof (guid));
	return 0;
}

static void
set_timestamp(authvar_context *ctx, const char *time_str)
{
	time_t t;
	struct tm tm;

	memset(&tm, 0, sizeof(struct tm));
	if (time_str) {
		/* Accept the string like "2001-11-12 18:31:01" */
		strptime(time_str, "%Y-%m-%d %H:%M:%S", &tm);
	} else {
		time(&t);
		gmtime_r(&t, &tm);
	}

	ctx->timestamp.year = tm.tm_year + 1900;
	ctx->timestamp.month = tm.tm_mon + 1;
	ctx->timestamp.day = tm.tm_mday;
	ctx->timestamp.hour = tm.tm_hour;
	ctx->timestamp.minute = tm.tm_min;
	ctx->timestamp.second = tm.tm_sec;

	ctx->timestamp.pad1 = 0;
	ctx->timestamp.nanosecond = 0;
	ctx->timestamp.timezone = 0;
	ctx->timestamp.daylight = 0;
	ctx->timestamp.pad2 = 0;
}

static int
show_signature_support(void)
{
	int rc;
	uint8_t *data = NULL;
	size_t data_size = 0;
	uint32_t attrs = 0;
	efi_guid_t *guids;

	rc = efi_get_variable(efi_guid_global, "SignatureSupport",
			      &data, &data_size, &attrs);
	if (rc < 0) {
		warn("Could not read \"SignatureSupport\" variable");
		return rc;
	}
	if (data_size == 0)
		return 0;
	if (data_size % sizeof(efi_guid_t) != 0) {
		warnx("Invalid size %zd for \"SignatureSupport\" variable",
		      data_size);
		errno = EINVAL;
		return -1;
	}

	guids = (efi_guid_t *)data;
	for (size_t i = 0; i < data_size / sizeof(efi_guid_t); i++) {
		char *id_guid = NULL;

		rc = efi_guid_to_id_guid(&guids[i], &id_guid);
		if (rc < 0)
			continue;

		printf("%s\n", id_guid);
		free(id_guid);
	}
	free(data);
	return 0;
}

static long *verbose;

long verbosity(void)
{
	if (!verbose)
		return 0;
	return *verbose;
}

int
main(int argc, char *argv[])
{
	int rc;
	authvar_context ctx = { 0, };
	authvar_context *ctxp = &ctx;
	char *time_str = NULL;
	char *tokenname = "NSS Certificate DB";
	char *origtoken = tokenname;
	char *certdir = "/etc/pki/pesign";
	SECStatus status;

	int action = 0;

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	rc = authvar_context_init(ctxp);
	conderr(rc < 0, 1, "Could not initialize context");

	poptContext optCon;
	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesign" },
		{.longName = "append",
		 .shortName = 'a',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = GENERATE_APPEND,
		 .descrip = "append to variable" },
		{.longName = "certdir",
		 .shortName = 'd',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &certdir,
		 .descrip = "specify nss certificate database directory",
		 .argDescrip = "<certificate directory path>" },
		{.longName = "clear",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = GENERATE_CLEAR,
		 .descrip = "clear variable" },
		{.longName = "set",
		 .shortName = 's',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = GENERATE_SET,
		 .descrip = "set variable" },
		{.longName = "namespace",
		 .shortName = 'N',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &ctx.namespace,
		 .descrip = "specified variable is in <namespace> or <guid>" ,
		 .argDescrip = "{<namespace>|<guid>}" },
		{.longName = "list-supported-sigs",
		 .shortName = 'l',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = SHOW_SIGNATURE_SUPPORT,
		 .descrip = "list supported signature types" },
		{.longName = "guid",
		 .shortName = 'g',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctx.namespace,
		 .descrip = "specified variable is in <namespace> or <guid>",
		 .argDescrip = "{<namespace>|<guid>}" },
		{.longName = "name",
		 .shortName = 'n',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.name,
		 .descrip = "variable name",
		 .argDescrip = "<name>" },
		{.longName = "timestamp",
		 .shortName = 't',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &time_str,
		 .descrip = "timestamp for the variable",
		 .argDescrip = "<time>" },
		{.longName = "value",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.value,
		 .descrip = "value to set or append",
		 .argDescrip = "<value>" },
		{.longName = "valuefile",
		 .shortName = 'f',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.valuefile,
		 .descrip = "read value from <file>",
		 .argDescrip = "<file>" },
		{.longName = "import",
		 .shortName = 'i',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.importfile,
		 .descrip = "import variable from <file>",
		 .argDescrip = "<file>" },
		{.longName = "export",
		 .shortName = 'e',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.exportfile,
		 .descrip = "export variable to <file> instead of firmware",
		 .argDescrip = "<file>" },
		{.longName = "sign",
		 .shortName = 'S',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.cms_ctx->certname,
		 .descrip = "sign variable with certificate <nickname>",
		 .argDescrip = "<nickname>" },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctxp->verbose,
		 .val = 1,
		 .descrip = "be more verbose" },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctxp->verbose,
		 .val = 2,
		 .descrip = "be very verbose" },
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	optCon = poptGetContext("authvar", argc, (const char **)argv,
				options, 0);

	rc = poptReadDefaultConfig(optCon, 0);
	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
		errx(1, "poptReadDefaultConfig failed: %s", poptStrerror(rc));

	while ((rc = poptGetNextOpt(optCon)) > 0)
		;

	conderrx(rc < -1, 1, "Invalid argument: %s: %s",
		 poptBadOption(optCon, 0), poptStrerror(rc));

	conderrx(poptPeekArg(optCon), 1,
		 "Invalid Argument: \"%s\"", poptPeekArg(optCon));

	poptFreeContext(optCon);

	if (ctx.importfile)
		action |= IMPORT;
	if (ctx.exportfile)
		action |= EXPORT;
	if (!(action & (IMPORT|EXPORT)) && action != SHOW_SIGNATURE_SUPPORT)
		action |= SET;

	if ((action & GENERATE_APPEND) || (action & GENERATE_CLEAR) ||
	    (action & GENERATE_SET)) {
		if (!ctx.cms_ctx->certname || !*ctx.cms_ctx->certname)
			errx(1, "Require a certificate to sign");
	}

	rc = find_namespace_guid(ctxp);
	conderrx(rc < 0, 1, "unable to find guid for \"%s\"", ctx.namespace);

	set_timestamp(ctxp, time_str);

	if (ctx.cms_ctx->certname && *ctx.cms_ctx->certname)
		action |= SIGN;

	/* Initialize the NSS db */
	if ((action & GENERATE_APPEND) || (action & GENERATE_CLEAR) ||
	    (action & GENERATE_SET)    || (action & SIGN))
		status = NSS_Init(certdir);
	else
		status = NSS_NoDB_Init(NULL);
	conderrx(status != SECSuccess, 1, "Could not initialize nss: %s",
		 PORT_ErrorToString(PORT_GetError()));

	status = register_oids(ctxp->cms_ctx);
	conderrx(status != SECSuccess, 1, "Could not register OIDs");

	ctxp->cms_ctx->tokenname = tokenname ?
		PORT_ArenaStrdup(ctxp->cms_ctx->arena, tokenname) : NULL;
	conderrx(tokenname && !ctxp->cms_ctx->tokenname, 1,
		 "could not allocate token name: %s",
		 PORT_ErrorToString(PORT_GetError()));

	if (tokenname != origtoken)
		free(tokenname);

	if (action & SIGN) {
		rc = find_certificate(ctx.cms_ctx, 1);
		conderrx(rc < 0, 1, "Could not find certificate for \"%s\"",
			 ctx.cms_ctx->certname);
	}

	switch (action) {
	case NO_FLAGS:
		errx(1, "No action specified");
		break;
	case SHOW_SIGNATURE_SUPPORT:
		rc = show_signature_support();
		conderrx(rc < 0, 1, "could not show support signatures");
		break;
	case GENERATE_APPEND|EXPORT|SIGN:
	case GENERATE_APPEND|SET|SIGN:
		check_name(ctxp);
		check_value(ctxp, 1);
		open_input(ctxp);
		ctxp->attr |= EFI_VARIABLE_APPEND_WRITE;
		ctxp->timestamp.day = 0;
		ctxp->timestamp.month = 0;

		rc = generate_descriptor(ctxp);
		conderrx(rc < 0, 1, "unable to generate descriptor");

		open_output(ctxp);
		write_authvar(ctxp);
		break;
	case GENERATE_CLEAR|EXPORT|SIGN:
	case GENERATE_CLEAR|SET|SIGN:
		check_name(ctxp);
		check_value(ctxp, 0);

		rc = generate_descriptor(ctxp);
		conderrx(rc < 0, 1, "unable to generate descriptor");

		open_output(ctxp);
		write_authvar(ctxp);
		break;
	case GENERATE_SET|EXPORT|SIGN:
	case GENERATE_SET|SET|SIGN:
		check_name(ctxp);
		check_value(ctxp, 1);
		open_input(ctxp);

		rc = generate_descriptor(ctxp);
		conderrx(rc < 0, 1, "unable to generate descriptor");

		open_output(ctxp);
		write_authvar(ctxp);
		break;
	case IMPORT|SET:
	case IMPORT|SIGN|SET:
		warnx("not implemented");
		/* fallthrough. */
	case IMPORT|SIGN|EXPORT:
	default:
		fprintf(stderr, "authvar: invalid flags: ");
		print_flag_name(stderr, action);
		fprintf(stderr, "\n");
		exit(1);
	}

	authvar_context_fini(ctxp);
	if (time_str)
		xfree(time_str);

	NSS_Shutdown();

	return 0;
}

```

`src/authvar.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * authvar.h - helper header for authvar
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef AUTHVAR_H
#define AUTHVAR_H 1

#include <efivar.h>
#include <efisec.h>

#include <libdpe/libdpe.h>
#include <libdpe/pe.h>

#include "util.h"
#include "cms_common.h"
#include "wincert.h"
#include "authvar_context.h"
#include "endian.h"
#include "ucs2.h"
#include "varfile.h"
#include "signed_data.h"
#include "oid.h"

#endif /* AUTHVAR_H */

```

`src/authvar_context.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * authvar_context.c - context setup and teardown for authvar
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <unistd.h>
#include <stddef.h>
#include <sys/mman.h>

#include <prerror.h>
#include <nss.h>
#include <pk11pub.h>
#include <secport.h>
#include <secerr.h>

#include "authvar.h"

static char *default_namespace="global";

int
authvar_context_init(authvar_context *ctx)
{
	memset(ctx, '\0', sizeof (*ctx));

	ctx->namespace = default_namespace;

	int rc = cms_context_alloc(&ctx->cms_ctx);
	ctx->attr = EFI_VARIABLE_NON_VOLATILE |
		    EFI_VARIABLE_RUNTIME_ACCESS |
		    EFI_VARIABLE_BOOTSERVICE_ACCESS |
		    EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS;
	ctx->exportfd = -1;

	return rc;
}

void
authvar_context_fini(authvar_context *ctx)
{
	if (!ctx)
		return;

	cms_context_fini(ctx->cms_ctx);

	if (ctx->name) {
		xfree(ctx->name);
	}

	if (ctx->valuefile) {
		munmap(ctx->value, ctx->value_size);
		ctx->value = NULL;

		close(ctx->valuefd);
		ctx->valuefd = -1;
		ctx->value_size = 0;

		xfree(ctx->valuefile);
		ctx->valuefile = NULL;
	} else if (ctx->value) {
		xfree(ctx->value);
		ctx->value = NULL;
		ctx->value_size = 0;
	}

	if (ctx->exportfd >= 0) {
		close(ctx->exportfd);
		ctx->exportfd = -1;
	}
}

int
generate_descriptor(authvar_context *ctx)
{
	win_certificate_uefi_guid_t *authinfo;
	SECItem sd_der;
	char *name_ptr;
	uint8_t *buf, *ptr;
	size_t buf_len;
	uint64_t offset;
	efi_char16_t *wptr;
	int rc;

	/* prepare buffer for varname, vendor_guid, attr, timestamp, value */
	buf_len = strlen(ctx->name)*sizeof(efi_char16_t) + sizeof(efi_guid_t) +
		  sizeof(uint32_t) + sizeof(efi_time_t) + ctx->value_size;
	buf = calloc(1, buf_len);
	if (!buf)
		return -1;

	ptr = buf;
	name_ptr = ctx->name;
	while (*name_ptr != '\0') {
		wptr = (efi_char16_t *)ptr;
		*wptr = *name_ptr;
		name_ptr++;
		ptr += sizeof(efi_char16_t);
	}

	memcpy(ptr, &ctx->guid, sizeof(efi_guid_t));
	ptr += sizeof(efi_guid_t);

	memcpy(ptr, &ctx->attr, sizeof(uint32_t));
	ptr += sizeof(uint32_t);

	memcpy(ptr, &ctx->timestamp, sizeof(efi_time_t));
	ptr += sizeof(efi_time_t);

	memcpy(ptr, ctx->value, ctx->value_size);

	ctx->cms_ctx->authbuf_len = buf_len;
	ctx->cms_ctx->authbuf = buf;

	/* XXX set the value to get SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION
	   from digest_get_signature_oid(). */
	ctx->cms_ctx->selected_digest = 0;

	/* sign the digest */
	memset(&sd_der, '\0', sizeof(sd_der));
	rc = generate_authvar_signed_data(ctx->cms_ctx, &sd_der);
	ctx->cms_ctx->authbuf = NULL;
	ctx->cms_ctx->authbuf_len = 0;
	free(buf);

	if (rc < 0)
		cmsreterr(-1, ctx->cms_ctx, "could not create signed data");

        offset = offsetof(win_certificate_uefi_guid_t, data);

	authinfo = calloc(offset + sd_der.len, 1);
	if (!authinfo)
		cmsreterr(-1, ctx->cms_ctx, "could not allocate authinfo");

	authinfo->hdr.length = sd_der.len + (uint32_t)offset;
	authinfo->hdr.revision = WIN_CERT_REVISION_2_0;
	authinfo->hdr.cert_type = WIN_CERT_TYPE_EFI_GUID;
	authinfo->type = efi_guid_pkcs7_cert;
	memcpy(&authinfo->data, sd_der.data, sd_der.len);

	ctx->authinfo = authinfo;

	return 0;
}

int
write_authvar(authvar_context *ctx)
{
	efi_variable_authentication_2_t *descriptor;
	void *buffer, *ptr;
	size_t buf_len, des_len, remain;
	ssize_t wlen;

	if (!ctx->authinfo)
		cmsreterr(-1, ctx->cms_ctx, "Not a valid authvar");

	des_len = sizeof(efi_variable_authentication_2_t)
                  + ctx->authinfo->hdr.length
                  - sizeof(win_certificate_uefi_guid_t);
	buf_len = sizeof(ctx->attr) + des_len + ctx->value_size;

	buffer = calloc(buf_len, 1);
	if (!buffer)
		cmsreterr(-1, ctx->cms_ctx, "could not allocate buffer");
	ptr = buffer;

	/* The attribute of the variable */
	memcpy(ptr, &ctx->attr, sizeof(ctx->attr));
	ptr += sizeof(ctx->attr);

	/* EFI_VARIABLE_AUTHENTICATION_2 */
	descriptor = (efi_variable_authentication_2_t *)ptr;
	memcpy(&descriptor->timestamp, &ctx->timestamp, sizeof(efi_time_t));
	memcpy(&descriptor->auth_info, ctx->authinfo, ctx->authinfo->hdr.length);
	ptr += des_len;

	/* Data */
	if (ctx->value_size > 0)
		memcpy(ptr, ctx->value, ctx->value_size);

	if (!ctx->to_firmware) {
		ftruncate(ctx->exportfd, buf_len);
		lseek(ctx->exportfd, 0, SEEK_SET);
	}

	remain = buf_len;
	do {
		wlen = write(ctx->exportfd, buffer, remain);
		if (wlen < 0) {
                        free(buffer);
			cmsreterr(-1, ctx->cms_ctx, "failed to write authvar");
                }
		remain -= wlen;
	} while (remain > 0);

        free(buffer);
	return 0;
}

```

`src/authvar_context.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * authvar_context.h - context setup and teardown for authvar
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef AUTHVAR_CONTEXT_H
#define AUTHVAR_CONTEXT_H 1

#include <efivar.h>
#include <efisec.h>

typedef struct {
	long verbose;

	char *namespace;
	efi_guid_t guid;
	char *name;
	uint32_t attr;

	char  *value;
	char  *valuefile;
	int    valuefd;
	size_t value_size;

	efi_time_t timestamp;

	char *importfile;
	int   inmportfd;

	char *exportfile;
	int   exportfd;
	uint8_t to_firmware;

	win_certificate_uefi_guid_t *authinfo;

	cms_context *cms_ctx;
} authvar_context;

extern int authvar_context_init(authvar_context *ctx);
extern void authvar_context_fini(authvar_context *ctx);
extern int generate_descriptor(authvar_context *ctx);
extern int write_authvar(authvar_context *ctx);

#endif /* AUTHVAR_CONTEXT_H */

```

`src/certdb.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * certdb.c - helpers to manage the EFI security databases
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <fcntl.h>
#include <libgen.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#include <nss.h>
#include <prerror.h>
#include <cert.h>
#include <pkcs7t.h>
#include <pk11pub.h>

#include "pesigcheck.h"

static int
add_db_file(pesigcheck_context *ctx, db_specifier which, const char *dbfile,
	    db_f_type type)
{
	dblist *db = calloc(1, sizeof (dblist));
	int errno_guard;

	if (!db)
		return -1;

	db->type = type;
	db->fd = open(dbfile, O_RDONLY);
	set_errno_guard_with_override(&errno_guard);
	if (db->fd < 0) {
		free(db);
		return -1;
	}

	char *path = strdup(dbfile);
	if (!path) {
		override_errno_guard(&errno_guard, errno);
		free(db);
		return -1;
	}

	db->path = basename(path);
	db->path = strdup(db->path);
	free(path);
	if (!db->path) {
		override_errno_guard(&errno_guard, errno);
		close(db->fd);
		free(db);
		return -1;
	}

	struct stat sb;
	int rc = fstat(db->fd, &sb);
	if (rc < 0) {
		override_errno_guard(&errno_guard, errno);
		close(db->fd);
		free(db->path);
		free(db);
		return -1;
	}
	db->size = sb.st_size;

	db->map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, db->fd, 0);
	if (db->map == MAP_FAILED) {
		db->map = NULL;
		size_t sz = 0;
		rc = read_file(db->fd, (char **)&db->map, &sz);
		if (rc < 0) {
			override_errno_guard(&errno_guard, errno);
			close(db->fd);
			free(db->path);
			free(db);
			return -1;
		}
	}

	EFI_SIGNATURE_LIST *certlist;
	EFI_SIGNATURE_DATA *cert;
	efi_guid_t efi_x509 = efi_guid_x509_cert;

	switch (type) {
	case DB_FILE:
		db->data = db->map;
		db->datalen = db->size;
		break;
	case DB_EFIVAR:
		/* skip the first 4 bytes (EFI attributes) */
		db->data = db->map + 4;
		db->datalen = db->size - 4;
		break;
	case DB_CERT:
		db->datalen = db->size + sizeof(EFI_SIGNATURE_LIST) +
			      sizeof(efi_guid_t);
		db->data = calloc(1, db->datalen);
		if (!db->data) {
			override_errno_guard(&errno_guard, errno);
			return -1;
		}

		certlist = (EFI_SIGNATURE_LIST *)db->data;
		memcpy((void *)&certlist->SignatureType, &efi_x509, sizeof(efi_guid_t));
		certlist->SignatureListSize = db->datalen;
		certlist->SignatureHeaderSize = 0;
		certlist->SignatureSize = db->size + sizeof(efi_guid_t);

		cert = (EFI_SIGNATURE_DATA *)(db->data + sizeof(EFI_SIGNATURE_LIST));
		memcpy((void *)cert->SignatureData, db->map, db->size);
		break;
	default:
		break;
	}

	dblist **tmp = which == DB ? &ctx->db : &ctx->dbx;

	db->next = *tmp;
	*tmp = db;

	override_errno_guard(&errno_guard, 0);
	return 0;
}

int
add_cert_db(pesigcheck_context *ctx, const char *filename)
{
	return add_db_file(ctx, DB, filename, DB_FILE);
}

int
add_cert_dbx(pesigcheck_context *ctx, const char *filename)
{
	return add_db_file(ctx, DBX, filename, DB_FILE);
}

int
add_cert_file(pesigcheck_context *ctx, const char *filename)
{
	return add_db_file(ctx, DB, filename, DB_CERT);
}

#define DB_PATH "/sys/firmware/efi/efivars/db-d719b2cb-3d3a-4596-a3bc-dad00e67656f"
#define MOK_PATH "/sys/firmware/efi/efivars/MokListRT-605dab50-e046-4300-abb6-3dd810dd8b23"
#define DBX_PATH "/sys/firmware/efi/efivars/dbx-d719b2cb-3d3a-4596-a3bc-dad00e67656f"
#define MOKX_PATH "/sys/firmware/efi/efivars/MokListXRT-605dab50-e046-4300-abb6-3dd810dd8b23"

void
init_cert_db(pesigcheck_context *ctx, int use_system_dbs)
{
	int rc = 0;

	if (!use_system_dbs)
		return;

	rc = add_db_file(ctx, DB, DB_PATH, DB_EFIVAR);
	if (rc < 0 && errno != ENOENT) {
		fprintf(stderr, "pesigcheck: Could not add key database "
			"\"%s\": %m\n", DB_PATH);
		exit(1);
	}

	rc = add_db_file(ctx, DB, MOK_PATH, DB_EFIVAR);
	if (rc < 0 && errno != ENOENT) {
		fprintf(stderr, "pesigcheck: Could not add key database "
			"\"%s\": %m\n", MOK_PATH);
		exit(1);
	}

	if (ctx->db == NULL) {
		fprintf(stderr, "pesigcheck: warning: "
			"No key database available\n");
	}

	rc = add_db_file(ctx, DBX, DBX_PATH, DB_EFIVAR);
	if (rc < 0 && errno != ENOENT) {
		fprintf(stderr, "pesigcheck: Could not add revocation "
			"database \"%s\": %m\n", DBX_PATH);
		exit(1);
	}

	rc = add_db_file(ctx, DBX, MOKX_PATH, DB_EFIVAR);
	if (rc < 0 && errno != ENOENT) {
		fprintf(stderr, "pesigcheck: Could not add key database "
			"\"%s\": %m\n", MOKX_PATH);
		exit(1);
	}

	if (ctx->dbx == NULL) {
		fprintf(stderr, "pesigcheck: warning: "
			"No key recovation database available\n");
	}
}

typedef db_status (*checkfn)(pesigcheck_context *ctx, SECItem *sig,
			     efi_guid_t *sigtype, SECItem *pkcs7sig);

static db_status
check_db(db_specifier which, pesigcheck_context *ctx, checkfn check,
	 void *data, ssize_t datalen, SECItem *match)
{
	SECItem pkcs7sig, sig;
	dblist *dbl = which == DB ? ctx->db : ctx->dbx;
	db_status found = NOT_FOUND;

	pkcs7sig.data = data;
	pkcs7sig.len = datalen;
	pkcs7sig.type = siBuffer;

	sig.type = siBuffer;

	while (dbl) {
		printf("Searching %s %s\n", which == DB ? "db" : "dbx",
		       dbl->path);
		EFI_SIGNATURE_LIST *certlist;
		EFI_SIGNATURE_DATA *cert;
		size_t dbsize = dbl->datalen;
		unsigned long certcount;

		certlist = dbl->data;
		while (dbsize > 0 && dbsize >= certlist->SignatureListSize) {
			certcount = (certlist->SignatureListSize -
				     certlist->SignatureHeaderSize)
				    / certlist->SignatureSize;
			cert = (EFI_SIGNATURE_DATA *)((uint8_t *)certlist +
				sizeof(EFI_SIGNATURE_LIST) +
				certlist->SignatureHeaderSize);

			for (unsigned int i = 0; i < certcount; i++) {
				sig.data = cert->SignatureData;
				sig.len = certlist->SignatureSize
					  - sizeof(efi_guid_t);
				found = check(ctx, &sig,
					      &certlist->SignatureType,
					      &pkcs7sig);
				if (found == FOUND) {
					if (match)
						memcpy(match, &sig,
						       sizeof(sig));
					return FOUND;
				}
				cert = (EFI_SIGNATURE_DATA *)((uint8_t *)cert +
				        certlist->SignatureSize);
			}

			dbsize -= certlist->SignatureListSize;
			certlist = (EFI_SIGNATURE_LIST *)((uint8_t *)certlist +
			            certlist->SignatureListSize);
		}
		dbl = dbl->next;
	}
	return NOT_FOUND;
}

static db_status
check_hash(pesigcheck_context *ctx, SECItem *sig, efi_guid_t *sigtype,
	   SECItem *pkcs7sig UNUSED)
{
	efi_guid_t efi_sha256 = efi_guid_sha256;
	efi_guid_t efi_sha1 = efi_guid_sha1;
	void *digest_data;
	struct digest *digests = ctx->cms_ctx->digests;
	unsigned int selected_digest;
	size_t size;

	if (memcmp(sigtype, &efi_sha256, sizeof(efi_guid_t)) == 0) {
		selected_digest = DIGEST_PARAM_SHA256;
	} else if (memcmp(sigtype, &efi_sha1, sizeof(efi_guid_t)) == 0) {
		selected_digest = DIGEST_PARAM_SHA1;
	} else {
		return NOT_FOUND;
	}

	digest_data = digests[selected_digest].pe_digest->data;
	size = digest_params[selected_digest].size;
	if (memcmp (digest_data, sig->data, size) == 0) {
		ctx->cms_ctx->selected_digest = selected_digest;
		return FOUND;
	}

	return NOT_FOUND;
}

db_status
check_db_hash(db_specifier which, pesigcheck_context *ctx)
{
	return check_db(which, ctx, check_hash, NULL, 0, NULL);
}

static void
find_cert_times(SEC_PKCS7ContentInfo *cinfo,
		PRTime *notBefore, PRTime *notAfter)
{
	CERTCertDBHandle *defaultdb, *certdb;
	SEC_PKCS7SignedData *sdp;
	CERTCertificate **certs = NULL;
	SECItem **rawcerts;
	int i, certcount;
	SECStatus rv;

	if (cinfo->contentTypeTag->offset != SEC_OID_PKCS7_SIGNED_DATA) {
err:
		*notBefore = 0;
		*notAfter = 0x7fffffffffffffff;
		return;
	}

	sdp = cinfo->content.signedData;
	rawcerts = sdp->rawCerts;

	defaultdb = CERT_GetDefaultCertDB();

	certdb = defaultdb;
	if (certdb == NULL)
		goto err;

	certcount = 0;
	if (rawcerts != NULL) {
		for (; rawcerts[certcount] != NULL; certcount++)
			;
	}
	rv = CERT_ImportCerts(certdb, certUsageObjectSigner, certcount,
			      rawcerts, &certs, PR_FALSE, PR_FALSE, NULL);
	if (rv != SECSuccess)
		goto err;

	for (i = 0; i < certcount; i++) {
		PRTime nb = 0, na = 0x7fffffffffff;
		CERT_GetCertTimes(certs[i], &nb, &na);
		if (*notBefore < nb)
			*notBefore = nb;
		if (*notAfter > na)
			*notAfter = na;
	}

	CERT_DestroyCertArray(certs, certcount);
}

static db_status
check_cert(pesigcheck_context *ctx, SECItem *sig, efi_guid_t *sigtype,
	   SECItem *pkcs7sig)
{
	SEC_PKCS7ContentInfo *cinfo = NULL;
	CERTCertificate *cert = NULL;
	CERTCertTrust trust;
	SECItem *content, *digest = NULL;
	PK11Context *pk11ctx = NULL;
	SECOidData *oid;
	PRBool result;
	SECStatus rv;
	db_status status = NOT_FOUND;
	PRTime atTime = PR_Now();
	SECItem *eTime;
	PRTime earlyNow = 0, lateNow = 0x7fffffffffffffff;
	PRTime notBefore, notAfter;

	efi_guid_t efi_x509 = efi_guid_x509_cert;

	if (memcmp(sigtype, &efi_x509, sizeof(efi_guid_t)) != 0)
		return NOT_FOUND;

	cinfo = SEC_PKCS7DecodeItem(pkcs7sig, NULL, NULL, NULL, NULL, NULL,
				    NULL, NULL);
	if (!cinfo)
		goto out;

	notBefore = earlyNow;
	notAfter = lateNow;
	find_cert_times(cinfo, &notBefore, &notAfter);
	if (earlyNow < notBefore)
		earlyNow = notBefore;
	if (lateNow > notAfter)
		lateNow = notAfter;

	// atTime = determine_reasonable_time(cert);
	eTime = SEC_PKCS7GetSigningTime(cinfo);
	if (eTime != NULL) {
		if (DER_DecodeTimeChoice (&atTime, eTime) == SECSuccess) {
			if (earlyNow < atTime)
				earlyNow = atTime;
			if (lateNow > atTime)
				lateNow = atTime;
		}
	}

	if (lateNow < earlyNow)
		printf("Signature has impossible time constraint: %lld <= %lld\n",
		       earlyNow / 1000000LL, lateNow / 1000000LL);
	atTime = earlyNow / 2 + lateNow / 2;

	cinfo = SEC_PKCS7DecodeItem(pkcs7sig, NULL, NULL, NULL, NULL, NULL,
				    NULL, NULL);
	if (!cinfo)
		goto out;

	/* Generate the digest of contentInfo */
	/* XXX support only sha256 for now */
	digest = SECITEM_AllocItem(NULL, NULL, 32);
	if (digest == NULL)
		goto out;

	content = cinfo->content.signedData->contentInfo.content.data;
	oid = SECOID_FindOIDByTag(SEC_OID_SHA256);
	if (oid == NULL)
		goto out;
	pk11ctx = PK11_CreateDigestContext(oid->offset);
	if (ctx == NULL)
		goto out;
	if (PK11_DigestBegin(pk11ctx) != SECSuccess)
		goto out;
	/*   Skip the SEQUENCE tag */
	if (PK11_DigestOp(pk11ctx, content->data + 2, content->len - 2) != SECSuccess)
		goto out;
	if (PK11_DigestFinal(pk11ctx, digest->data, &digest->len, 32) != SECSuccess)
		goto out;

	/* Import the trusted certificate */
	cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), sig, "Temp CA",
				       PR_FALSE, PR_TRUE);
	if (!cert) {
		fprintf(stderr, "Unable to create cert: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		goto out;
	}

	rv = CERT_DecodeTrustString(&trust, ",,CP");
	if (rv != SECSuccess) {
		fprintf(stderr, "Unable to decode trust string: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		goto out;
	}

	rv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), cert, &trust);
	if (rv != SECSuccess) {
		fprintf(stderr, "Failed to change cert trust: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		goto out;
	}

	/* Verify the signature */
	result = SEC_PKCS7VerifyDetachedSignatureAtTime(cinfo,
						certUsageObjectSigner,
						digest, HASH_AlgSHA256,
						PR_FALSE, atTime);
	if (!result) {
		fprintf(stderr, "%s\n",	PORT_ErrorToString(PORT_GetError()));
		goto out;
	}

	status = FOUND;
out:
	if (cinfo)
		SEC_PKCS7DestroyContentInfo(cinfo);
	if (cert)
		CERT_DestroyCertificate(cert);
	if (pk11ctx)
		PK11_DestroyContext(pk11ctx, PR_TRUE);
	if (digest)
		SECITEM_FreeItem(digest, PR_FALSE);

	return status;
}

db_status
check_db_cert(db_specifier which, pesigcheck_context *ctx,
	      void *data, ssize_t datalen, SECItem *match)
{
	return check_db(which, ctx, check_cert, data, datalen, match);
}

```

`src/certdb.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * certdb.h - decls for our UEFI security databases
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef CERTDB_H
#define CERTDB_H 1

typedef enum {
	DB = 0,
	DBX = 1
} db_specifier;

typedef enum {
	FOUND = 0,
	NOT_FOUND = 1
} db_status;

typedef struct {
	efi_guid_t	SignatureOwner;
	uint8_t		SignatureData[1];
} EFI_SIGNATURE_DATA;

typedef struct {
	efi_guid_t	SignatureType;
	uint32_t	SignatureListSize;
	uint32_t	SignatureHeaderSize;
	uint32_t	SignatureSize;
} EFI_SIGNATURE_LIST;

extern db_status check_db_hash(db_specifier which, pesigcheck_context *ctx);
extern db_status check_db_cert(db_specifier which, pesigcheck_context *ctx,
				void *data, ssize_t datalen, SECItem *match);

extern void init_cert_db(pesigcheck_context *ctx, int use_system_dbs);
extern int add_cert_db(pesigcheck_context *ctx, const char *filename);
extern int add_cert_dbx(pesigcheck_context *ctx, const char *filename);
extern int add_cert_file(pesigcheck_context *ctx, const char *filename);

#endif /* CERTDB_H */

```

`src/certs/Makefile`:

```
NICKNAME := $(shell whoami)
EMAIL := ${NICKNAME}@localhost

all : clean
	./make-certs ${NICKNAME} ${EMAIL} all codesign 1.3.6.1.4.1.311.10.3.1
	@rm -rvf /etc/pki/pesign/*
	certutil -A -n 'my CA' -d /etc/pki/pesign -t CT,CT,CT -i ca.crt
	pk12util -d /etc/pki/pesign/ -i ${NICKNAME}.p12
	certutil -d /etc/pki/pesign/ -A -i ${NICKNAME}.crt -n ${NICKNAME} -t u

clean :
	@rm -vf *.c?? *.p?? *.k?? *.txt *.old *.attr *.db  *.srl


```

`src/certs/make-certs`:

```
#!/bin/bash -e
#
#  Generate a root CA cert for signing, and then a subject cert.
#  Usage: make-certs.sh hostname [user[@domain]] [more ...]
#  For testing only, probably still has some bugs in it.
#

DOMAIN=example.com
DAYS=365
KEYTYPE=RSA
KEYSIZE=2048
DIGEST=SHA256
CRLHOURS=24
CRLDAYS=

# Cleanup temporary files at exit.
touch openssl.cnf
newcertdir=`mktemp -d`
cleanup() {
	test -f openssl.cnf   && rm -f openssl.cnf
	test -f ca.txt        && rm -f ca.txt
	test -f ocsp.txt      && rm -f ocsp.txt
	test -n "$newcertdir" && rm -fr "$newcertdir"
}
trap cleanup EXIT

# The first argument is either a common name value or a flag indicating that
# we're doing something other than issuing a cert.
commonname="$1"
refresh_crl=false
revoke_cert=false
ocsp_serve=false
if test "x$commonname" = "x-refresh_crl" ; then
	refresh_crl=true
	commonname="$1"
fi
if test "x$commonname" = "x-revoke" ; then
	revoke_cert=true
	shift
	commonname="$1"
fi
if test "x$commonname" = "x-ocsp" ; then
	ocsp_serve=true
	commonname="$1"
fi
if test "x$commonname" = x ; then
	echo Usage: `basename $0` 'commonname' user'[@domain]' '[more [...]]'
	echo Usage: `basename $0` -revoke 'commonname'
	echo Usage: `basename $0` -ocsp
	echo Usage: `basename $0` -refresh-crl
	echo More:
	echo -e \\tKey usage: "[sign|signing|encrypt|encryption|all]"
	echo -e \\tAuthority Access Info OCSP responder: "ocsp:URI"
	echo -e \\tCRL distribution point: "crl:URI"
	echo -e \\tSubject Alternative Name:
	echo -e \\t\\tHostname: "*"
	echo -e \\t\\tIP address: w.x.y.z
	echo -e \\t\\tEmail address: "*@*.com/edu/net/org/local"
	echo -e \\t\\tKerberos principal name: "*@*.COM/EDU/NET/ORG/LOCAL"
	echo -e \\tExtended key usage:
	echo -e \\t\\t1....
	echo -e \\t\\t2....
	echo -e \\t\\tid-kp-server-auth \| tls-server
	echo -e \\t\\tid-kp-client-auth \| tls-client
	echo -e \\t\\tid-kp-email-protection \| email
	echo -e \\t\\tid-ms-kp-sc-logon \| id-ms-sc-logon
	echo -e \\t\\tid-pkinit-kp-client-auth \| id-pkinit-client
	echo -e \\t\\tid-pkinit-kp-kdc \| id-pkinit-kdc
	echo -e \\t\\tca \| CA
	exit 1
fi

# Choose a user name part for email attributes.
GIVENUSER=$2
test x"$GIVENUSER" = x && GIVENUSER=$USER
echo "$GIVENUSER" | grep -q @ || GIVENUSER="$GIVENUSER"@$DOMAIN
DOMAIN=`echo "$GIVENUSER" | cut -f2- -d@`

shift || true
shift || true

# Done already?
done=:

keygen() {
	case "$KEYTYPE" in
	DSA)
		openssl dsaparam -out "$1".param $KEYSIZE
		openssl gendsa "$1".param
		;;
	RSA|*)
		#openssl genrsa $KEYSIZE -passout pass:qweqwe
		openssl genrsa $KEYSIZE
		#openssl genrsa $KEYSIZE -nodes
		;;
	esac
}

# Set some defaults.
CA=FALSE
if test -s ca.crldp.uri.txt ; then
	crlval="`cat ca.crldp.uri.txt`"
	crl="URI:$crlval"
fi
if test -s ca.ocsp.uri.txt ; then
	aiaval="`cat ca.ocsp.uri.txt`"
	aia="OCSP;URI:$aiaval"
fi
if test -s ca.domain.txt ; then
	domval="`cat ca.domain.txt`"
	if test -n "$domval" ; then
		DOMAIN="$domval"
	fi
fi

# Parse the arguments which indicate what sort of information we want.
while test $# -gt 0 ; do
	type=
	value="$1"
	case "$value" in
	RSA|rsa)
		KEYTYPE=RSA
		;;
	DSA|dsa)
		KEYTYPE=DSA
		;;
	OCSP:*|ocsp:*)
		aiaval=`echo "$value" | cut -f2- -d:`
		aia="OCSP;URI:$aiaval"
		;;
	CRL:*|crl:*)
		crlval=`echo "$value" | cut -f2- -d:`
		crl="URI:$crlval"
		;;
	signing|sign)
		keyusage="${keyusage:+${keyusage},}nonRepudiation,digitalSignature"
		;;
	encryption|encrypt)
		keyusage="${keyusage:+${keyusage},}keyEncipherment,dataEncipherment"
		;;
	all)
		keyusage="digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment,keyAgreement,keyCertSign,cRLSign,encipherOnly,decipherOnly"
		;;
	ca|CA)
		CA=TRUE
		keyusage="${keyusage:+${keyusage},}nonRepudiation,digitalSignature,keyEncipherment,dataEncipherment,keyAgreement,keyCertSign,cRLSign"
		;;
	1.*|2.*|id-*|tls-*|email|mail|codesign)
		ekuval=`echo "$value" | tr '[A-Z]' '[a-z]' | sed 's,\-,,g'`
		case "$ekuval" in
		idkpserverauth|tlsserver) ekuval=1.3.6.1.5.5.7.3.1;;
		idkpclientauth|tlsclient) ekuval=1.3.6.1.5.5.7.3.2;;
		idkpemailprotection|email|mail) ekuval=1.3.6.1.5.5.7.3.4;;
		idkpcodesign|codesign) ekuval=1.3.6.1.5.5.7.3.3;;
		idmskpsclogon|idmssclogon) ekuval=1.3.6.1.4.1.311.20.2.2;;
		idpkinitkpclientauth|idpkinitclient) ekuval=1.3.6.1.5.2.3.4;;
		idpkinitkpkdc|idpkinitkdc) ekuval=1.3.6.1.5.2.3.5;;
		esac
		if test -z "$eku" ; then
			eku="$ekuval"
		else
			eku="$eku,$ekuval"
		fi
		;;
	*@*.COM|*@*.EDU|*@*.NET|*@*.ORG|*@*.LOCAL)
		luser=`echo "$value" | tr '[A-Z]' '[a-z]'`
		if test "$luser" = "$value" ; then
			luser=
		fi
		type="otherName:1.3.6.1.5.2.2;SEQUENCE:$value,${luser:+otherName:1.3.6.1.4.1.311.20.2.3;UTF8:${luser},}otherName:1.3.6.1.4.1.311.20.2.3;UTF8"
		unset luser
		principals="$principals $value"
		;;
	*@*.com|*@*.edu|*@*.net|*@*.org|*@*.local)            type=email;;
	[0-9]*.[0-9]*.[0-9]*.[0-9]*)                          type=IP;;
	*)                                                    type=DNS;;
	esac
	if test -n "$type" ; then
		newvalue="${type}:$value"
		if test -z "$altnames" ; then
			altnames="${newvalue}"
		else
			altnames="${altnames},${newvalue}"
		fi
	fi
	shift
done

# Build the configuration file, including bits on how to construct the CA
# certificate, an OCSP responder certificate, and the issued certificate.
cat > openssl.cnf <<- EOF
[ca]
default_ca = issuer

[issuer]
private_key = `pwd`/ca.key
certificate = `pwd`/ca.crt
database = `pwd`/ca.db
serial = `pwd`/ca.srl
default_md = $DIGEST
new_certs_dir = $newcertdir
policy = no_policy

[no_policy]

[req_oids]
domainComponent = 0.9.2342.19200300.100.1.25

[req_ca]
prompt = no
oid_section = req_oids
distinguished_name = req_ca_name
default_md = $DIGEST
subjectKeyIdentifier=hash

[req_ca_name]
C=US
#stateOrProvinceName=SomeState
localityName=SomeCity
O=SomeOrg
EOF
#echo $DOMAIN | awk 'BEGIN {FS="."}{for(i=NF;i>0;i--){print NF-i ".domainComponent="$i;}}' >> openssl.cnf
cat >> openssl.cnf <<- EOF
#commonName = Test Certifying CA

[v3_ca]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always
#authorityKeyIdentifier=keyid:always,issuer:always
keyUsage=nonRepudiation,digitalSignature,keyEncipherment,dataEncipherment,keyAgreement,keyCertSign,cRLSign
basicConstraints=critical,CA:TRUE
nsComment="Testing CA Certificate"
EOF
if test -n "$aia" ; then
	echo "authorityInfoAccess = ${aia}" >> openssl.cnf
	echo -n "$aiaval" > ca.ocsp.uri.txt
fi
if test -n "$crl" ; then
	echo "crlDistributionPoints = ${crl}" >> openssl.cnf
	echo -n "$crlval" > ca.crldp.uri.txt
fi
echo "$DOMAIN" > ca.domain.txt
cat >> openssl.cnf <<- EOF

[req_ocsp]
prompt = no
oid_section = req_oids
distinguished_name = req_ocsp_name
default_md = $DIGEST

[req_ocsp_name]
C=US
#stateOrProvinceName=SomeState
localityName=SomeOrg
O=SomeOrg
EOF
#echo $DOMAIN | awk 'BEGIN {FS="."}{for(i=NF;i>0;i--){print NF-i ".domainComponent="$i;}}' >> openssl.cnf
cat >> openssl.cnf <<- EOF
#commonName = OCSP Signer for Test Certifying CA

[v3_ocsp]
subjectKeyIdentifier=hash
#authorityKeyIdentifier=keyid:always,issuer:always
authorityKeyIdentifier=keyid:always
keyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment,keyAgreement,keyCertSign,cRLSign
extendedKeyUsage=1.3.6.1.5.5.7.3.9
#basicConstraints=CA:FALSE
basicConstraints=CA:TRUE
nsComment="Testing OCSP Certificate"
1.3.6.1.5.5.7.48.1.5=ASN1:NULL
EOF
if test -n "$aia" ; then
	echo "authorityInfoAccess = ${aia}" >> openssl.cnf
fi
if test -n "$crl" ; then
	echo "crlDistributionPoints = ${crl}" >> openssl.cnf
fi
cat >> openssl.cnf <<- EOF

[req_issued]
prompt = no
oid_section = req_oids
distinguished_name = req_issued_name
default_md = $DIGEST

[req_issued_name]
C=US
#stateOrProvinceName=SomeState
localityName=SomeCity
O=SomeOrg
EOF
#echo $DOMAIN | awk 'BEGIN {FS="."}{for(i=NF;i>0;i--){print NF-i ".domainComponent="$i;}}' >> openssl.cnf
#mail = $GIVENUSER
cat >> openssl.cnf <<- EOF
commonName = $commonname

[v3_issued]
#certificatePolicies=2.5.29.32.0${eku:+,${eku}}
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always
#authorityKeyIdentifier=keyid:always,issuer:always
EOF
if test -n "$aia" ; then
	echo "authorityInfoAccess = ${aia}" >> openssl.cnf
fi
if test -n "$crl" ; then
	echo "crlDistributionPoints = ${crl}" >> openssl.cnf
fi
if test -n "$keyusage" ; then
	echo "keyUsage = critical,${keyusage}" >> openssl.cnf
fi
if test -n "$altnames" ; then
	echo "subjectAltName = ${altnames}" >> openssl.cnf
fi
if test -n "$eku" ; then
	echo "extendedKeyUsage = ${eku}" >> openssl.cnf
	:
fi
if test "x$CA" = xTRUE ; then
	echo "basicConstraints=critical,CA:TRUE" >> openssl.cnf
	echo 'nsComment="Testing CA Certificate for '"$commonname"'"' >> openssl.cnf
else
	echo "basicConstraints=CA:FALSE" >> openssl.cnf
	echo 'nsComment="Testing Certificate for '"$commonname"'"' >> openssl.cnf
fi
for value in $principals; do
	user=`echo "$value" | cut -f1 -d@`
	realm=`echo "$value" | cut -f2- -d@`
	echo "" >> openssl.cnf
	echo "[$value]" >> openssl.cnf
	echo "realm=EXPLICIT:0,GeneralString:$realm" >> openssl.cnf
	echo "kerberosname=EXPLICIT:1,SEQUENCE:krb5$user" >> openssl.cnf

	echo "" >> openssl.cnf
	echo "[krb5$user]" >> openssl.cnf
	echo "nametype=EXPLICIT:0,INTEGER:1" >> openssl.cnf
	echo "namelist=EXPLICIT:1,SEQUENCE:krb5basic$user" >> openssl.cnf

	echo "[krb5basic$user]" >> openssl.cnf
	count=0
	for part in `echo "$user" | sed 's,/, ,g'` ; do
		echo "$count.part=GeneralString:$part" >> openssl.cnf
		count=`expr "$count" + 1`
	done
done

# Create the data files for a new CA.
if ! test -s ca.srl ; then
	(dd if=/dev/urandom bs=8 count=1 2> /dev/null) | od -t x1c | head -n 1 | awk '{$1="00";OFS="";print}' > ca.srl
else
	echo "You already have a ca.srl file; not replacing."
fi
if ! test -s ca.db ; then
	touch ca.db
else
	echo "You already have a ca.db file; not replacing."
fi
if ! test -s ca.db.attr ; then
	touch ca.db.attr
else
	echo "You already have a ca.db.attr file; not replacing."
fi

# If we need a CA key, generate one.
if ! test -s ca.key ; then
	umask=`umask -p`
	umask 077
	keygen ca > ca.key 2> /dev/null
	$umask
else
	echo "You already have a ca.key file; not replacing."
	done=echo
fi

# If we need a CA certificate, generate one.
if ! test -s ca.crt ; then
	sed -i -e 's,^\[req_ca\]$,\[req\],g' `pwd`/openssl.cnf
	openssl req -config `pwd`/openssl.cnf -new -key ca.key > ca.csr 2> /dev/null
	sed -i -e 's,^\[req\]$,\[req_ca\],g' `pwd`/openssl.cnf
	openssl x509 -extfile `pwd`/openssl.cnf -CAserial ca.srl -signkey ca.key -extensions v3_ca -req -in ca.csr -days $DAYS -out ca.crt ; : 2> /dev/null
	openssl x509 -noout -text -in ca.crt > ca.txt
	cat ca.crt >> ca.txt
	cat ca.txt > ca.crt
	rm ca.txt
	cat ca.crt > ca.chain.crt
else
	echo "You already have a ca.crt file; not replacing."
	done=echo
fi

# If we need an OCSP key, generate one.
if ! test -s ocsp.key ; then
	umask=`umask -p`
	umask 077
	keygen ocsp > ocsp.key 2> /dev/null
	$umask
else
	echo "You already have an ocsp.key file; not replacing."
	done=echo
fi

# Generate the OCSP signing cert.  Set the X.509v3 basic constraints and EKU.
if ! test -s ocsp.crt ; then
	sed -i -e 's,^\[req_ocsp\]$,\[req\],g' `pwd`/openssl.cnf
	openssl req -config `pwd`/openssl.cnf -new -key ocsp.key > ocsp.csr 2> /dev/null
	sed -i -e 's,^\[req\]$,\[req_ocsp\],g' `pwd`/openssl.cnf
	openssl ca -batch -config `pwd`/openssl.cnf -extensions v3_ocsp -preserveDN -in ocsp.csr -days $DAYS -out ocsp.crt 2> /dev/null
	openssl x509 -noout -text -in ocsp.crt > ocsp.txt
	cat ocsp.crt >> ocsp.txt
	cat ocsp.txt >  ocsp.crt
	rm ocsp.txt
else
	echo "You already have an ocsp.crt file; not replacing."
	done=echo
fi

# If we were told to revoke the certificate with the specified common name,
# do so.
if $revoke_cert ; then
	openssl ca -config `pwd`/openssl.cnf -revoke "$commonname".crt
fi

# Always refresh the CRL.
openssl ca -config `pwd`/openssl.cnf -gencrl ${CRLHOURS:+-crlhours ${CRLHOURS}} ${CRLDAYS:+-crldays ${CRLDAYS}} -out ca.crl.pem
openssl crl -in ca.crl.pem -outform der -out ca.crl
openssl crl -in ca.crl -inform der -noout -text > ca.crl.pem
openssl crl -in ca.crl -inform der >> ca.crl.pem

# If we were told to start up the mini OCSP server, do so.
if $ocsp_serve ; then
	openssl ocsp -text -index `pwd`/ca.db -CA `pwd`/ca.crt -rsigner `pwd`/ocsp.crt -rkey `pwd`/ocsp.key -rother `pwd`/ocsp.crt -port "`cut -f3 -d/ ca.ocsp.uri.txt | sed -r 's,(^[^:]*),0.0.0.0,g'`"
	exit 0
fi

# If we're just here to do a revocation or refresh the CRL, we're done.
if $revoke_cert || $refresh_crl ; then
	exit 0
fi

# Create a new serial number and whatnot if this is a new sub-CA.
if test "x$CA" = xTRUE ; then
	if ! test -d "$commonname" ; then
		mkdir "$commonname"
	fi
	if ! test -s "$commonname/ca.srl" ; then
		(dd if=/dev/urandom bs=8 count=1 2> /dev/null) | od -t x1c | head -n 1 | awk '{$1="00";OFS="";print}' > "$commonname/ca.srl"
	else
		echo "You already have a $commonname/ca.srl file; not replacing."
	fi
	if test -n "$aia" ; then
		echo -n "$aiaval" > "$commonname/ca.ocsp.uri.txt"
	fi
	if test -n "$crl" ; then
		echo -n "$crlval" > "$commonname/ca.crldp.uri.txt"
	fi
	echo "$DOMAIN" > "$commonname/ca.domain.txt"
	touch "$commonname/ca.db" "$commonname/ca.db.attr"
	cert="$commonname/ca.crt"
	csr="$commonname/ca.csr"
	key="$commonname/ca.key"
	pem="$commonname/ca.pem"
	pfx="$commonname/ca.p12"
	ln -s ../`basename $0` "$commonname"/
else
	cert="$commonname.crt"
	csr="$commonname.csr"
	key="$commonname.key"
	pem="$commonname.pem"
	pfx="$commonname.p12"
fi

# Generate the subject's certificate.  Set the X.509v3 basic constraints.
if ! test -s "$cert" ; then
	# Generate another key, unless we have a key or CSR.
	if ! test -s "$key" && ! test -s "$csr" ; then
		umask=`umask -p`
		umask 077
		keygen "$commonname" > "$key" 2> /dev/null
		$umask
	else
		echo "You already have a $key or $csr file; not replacing."
		done=echo
	fi

	if ! test -s "$csr" ; then
		sed -i -e 's,^\[req_issued\]$,\[req\],g' `pwd`/openssl.cnf
		openssl req -config `pwd`/openssl.cnf -new -key "$key" > "$csr" 2> /dev/null
		sed -i -e 's,^\[req\]$,\[req_issued\],g' `pwd`/openssl.cnf
	fi
	openssl ca -batch -config `pwd`/openssl.cnf -extensions v3_issued -preserveDN -in "$csr" -days $DAYS -out "$cert" 2> /dev/null
	openssl x509 -noout -text -in "$cert" > "$cert.txt"
	cat "$cert" >> "$cert.txt"
	cat "$cert.txt" > "$cert"
	rm -f "$cert.txt"
else
	echo "You already have a $cert file; not replacing."
	done=echo
fi

if test -s ca.chain.crt ; then
	chain=ca.chain.crt
else
	chain=ca.crt
fi
if test "x$CA" = xTRUE ; then
	cat "$chain" "$cert" > "$commonname/ca.chain.crt"
fi

# Create ca.pem and the subject's name.pem for the benefit of applications
# which expect both the private key and the certificate in one file.
umask=`umask -p`
umask 077
if ! test -s ca.pem ; then
	cat ca.key ca.crt > ca.pem
else
	echo "You already have a ca.pem file; not replacing."
	done=echo
fi
if ! test -s "$pem" ; then
	cat "$key" "$cert" > "$pem"
else
	echo "You already have a $pem file; not replacing."
	done=echo
fi
if ! test -s "$pfx" ; then
	#openssl pkcs12 -export -inkey "$key" -in "$cert" -name "$commonname" -out "$pfx" -nodes -passout pass:qweqwe
	openssl pkcs12 -export -inkey "$key" -in "$cert" -name "$commonname" -out "$pfx" -nodes
else
	echo "You already have a $pfx file; not replacing."
	done=echo
fi
$umask
$done

echo CA certificate:
openssl x509 -noout -issuer  -in ca.crt | sed s,=\ ,\ ,g
openssl x509 -noout -subject -in ca.crt | sed s,=\ ,\ ,g
echo
echo End entity certificate:
openssl x509 -noout -issuer  -in "$cert" | sed s,=\ ,\ ,g
openssl x509 -noout -subject -in "$cert" | sed s,=\ ,\ ,g
openssl x509 -noout -serial  -in "$cert" | sed s,=,\ ,g
echo
echo PKCS12 bag:
openssl pkcs12 -in "$pfx" -nodes -nokeys -nocerts -info
#openssl pkcs12 -in "$pfx" -nodes -nokeys -nocerts -info -passin pass:qweqwe
echo
echo Verifying:
echo + openssl verify -CAfile "$chain" "$cert"
openssl verify -CAfile "$chain" "$cert"

```

`src/client.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * client.c - main entry for the pesign-client utility
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <popt.h>
#include <pwd.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>

#include "pesign.h"

#define NO_FLAGS		0x00
#define UNLOCK_TOKEN		0x01
#define KILL_DAEMON		0x02
#define SIGN_BINARY		0x04
#define IS_TOKEN_UNLOCKED	0x08
#define FLAG_LIST_END		0x10

static struct {
	int flag;
	const char *name;
} flag_names[] = {
	{UNLOCK_TOKEN, "unlock"},
	{KILL_DAEMON, "kill"},
	{SIGN_BINARY, "sign"},
	{IS_TOKEN_UNLOCKED, "is-unlocked"},
	{FLAG_LIST_END, NULL},
};

static void
print_flag_name(FILE *f, int flag)
{
	for (int i = 0; flag_names[i].flag != FLAG_LIST_END; i++) {
		if (flag_names[i].flag == flag)
			fprintf(f, "%s ", flag_names[i].name);
	}
}

static int
connect_to_server_helper(const char * const sockpath)
{
	int rc = access(sockpath, R_OK);
	if (rc != 0) {
		warn("could not access socket \"%s\"", sockpath);
		return rc;
	}

	struct sockaddr_un addr_un = {
		.sun_family = AF_UNIX,
	};
	strncpy(addr_un.sun_path, sockpath, sizeof(addr_un.sun_path));
	addr_un.sun_path[sizeof(addr_un.sun_path)-1] = '\0';

	int sd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sd < 0) {
		warn("could not open socket \"%s\"", sockpath);
		return sd;
	}

	socklen_t len = strlen(addr_un.sun_path) +
			sizeof(addr_un.sun_family);

	rc = connect(sd, (struct sockaddr *)&addr_un, len);
	if (rc < 0) {
		warn("could not connect to daemon");
		return sd;
	}

	return sd;
}

static int
connect_to_server(void)
{
	int rc, i;
	const char * const sockets[] = {
		RUNDIR "/pesign/socket",
		"/run/pesign/socket",
		"/var/run/pesign/socket",
		NULL
	};

	for (i = 0; sockets[i] != NULL; i++) {
		rc = connect_to_server_helper(sockets[i]);
		if (rc >= 0)
			return rc;
	}

	exit(1);
}

static int32_t
check_response(int sd, char **srvmsg);

static int
check_cmd_version(int sd, uint32_t command, char *name, int32_t version, bool do_exit)
{
	struct msghdr msg;
	struct iovec iov[1];
	pesignd_msghdr pm;

	pm.version = PESIGND_VERSION;
	pm.command = CMD_GET_CMD_VERSION;
	pm.size = sizeof(command);
	iov[0].iov_base = &pm;
	iov[0].iov_len = sizeof(pm);

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	ssize_t n;
	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "check-cmd-version: sendmsg failed: %m\n");
		exit(1);
	}

	iov[0].iov_base = &command;
	iov[0].iov_len = sizeof(command);

	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	n = sendmsg(sd, &msg, 0);
	if (n < 0)
		err(1, "check-cmd-version: sendmsg failed");

	char *srvmsg = NULL;
	int32_t rc = check_response(sd, &srvmsg);

	if (srvmsg)
		free(srvmsg);

	if (do_exit && rc < 0)
		errx(1, "command \"%s\" not known by server", name);
	if (do_exit && rc != version)
		errx(1, "command \"%s\": client version %#x, server version %#x",
			name, version, rc);

	if (rc < 0)
		return rc;
	return rc == version;
}

static void
send_kill_daemon(int sd)
{
	struct msghdr msg;
	struct iovec iov;
	pesignd_msghdr pm;

	check_cmd_version(sd, CMD_KILL_DAEMON, "kill-daemon", 0, true);

	pm.version = PESIGND_VERSION;
	pm.command = CMD_KILL_DAEMON;
	pm.size = 0;

	iov.iov_base = &pm;
	iov.iov_len = sizeof(pm);

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	ssize_t n;

	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: kill daemon failed: %m\n");
		exit(1);
	}
}

static int32_t
check_response(int sd, char **srvmsg)
{
	ssize_t n;
	struct msghdr msg;
	struct iovec iov;
	char buffer[1024];

	pesignd_msghdr *pm;

	msg.msg_name = NULL;
	msg.msg_namelen = 0;

	memset(&msg, '\0', sizeof(msg));
	memset(buffer, '\0', sizeof(buffer));

	iov.iov_base = buffer;
	iov.iov_len = 1023;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	n = recvmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: could not get response from "
			"server: %m\n");
		exit(1);
	}

	pm = (pesignd_msghdr *)buffer;

	if (pm->version != PESIGND_VERSION) {
		fprintf(stderr, "pesign-client: got version %#x, "
			"expected version %#x\n", pm->version, PESIGND_VERSION);
		exit(1);
	}

	if (pm->command != CMD_RESPONSE) {
		fprintf(stderr, "pesign-client: got unexpected response: %d\n",
			pm->command);
		exit(1);
	}

	pesignd_cmd_response *resp = (pesignd_cmd_response *)((uint8_t *)pm +
					offsetof(pesignd_msghdr, size) +
					sizeof(pm->size));

	if (resp->rc == 0)
		return 0;

	*srvmsg = strdup((char *)resp->errmsg);
	return resp->rc;
}

static char *
get_token_pin(int pinfd, char *pinfile, char *envname)
{
	char *pin = NULL;
	FILE *pinf = NULL;

	errno = 0;
	/* validate that the fd we got is real... */
	if (pinfd >= 0) {
		pinf = fdopen(pinfd, "r");
		if (!pinf) {
			if (errno != EBADF)
				close(pinfd);
			return NULL;
		}

		ssize_t n = getline(&pin, 0, pinf);
		if (n < 0 || !pin) {
			fclose(pinf);
			close(pinfd);
			return NULL;
		}

		char *c = strchrnul(pin, '\n');
		*c = '\0';

		fclose(pinf);
		close(pinfd);
		return pin;
	} else if (pinfile) {
		pinf = fopen(pinfile, "r");
		if (!pinf)
			return NULL;

		size_t len;
		ssize_t n = getline(&pin, &len, pinf);
		if (n < 0 || !pin) {
			fclose(pinf);
			return NULL;
		}

		char *c = strchrnul(pin, '\n');
		*c = '\0';

		fclose(pinf);
		return pin;
	} else {
		pin = getenv(envname);
		if (pin)
			return strdup(pin);
	}

	pin = readpw(NULL, PR_FALSE, NULL);
	return pin;
}

static void
unlock_token(int sd, char *tokenname, char *pin)
{
	struct msghdr msg;
	struct iovec iov[2];
	pesignd_msghdr pm;

	uint32_t size0 = pesignd_string_size(tokenname);

	uint32_t size1 = pesignd_string_size(pin);

	check_cmd_version(sd, CMD_UNLOCK_TOKEN, "unlock-token", 0, true);

	pm.version = PESIGND_VERSION;
	pm.command = CMD_UNLOCK_TOKEN;
	pm.size = size0 + size1;
	iov[0].iov_base = &pm;
	iov[0].iov_len = sizeof (pm);

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	ssize_t n;
	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: unlock token: sendmsg failed: "
			"%m\n");
		exit(1);
	}

	uint8_t *buffer = NULL;
	buffer = calloc(1, size0 + size1);
	if (!buffer) {
		fprintf(stderr, "pesign-client: could not allocate memory: "
			"%m\n");
		exit(1);
	}

	pesignd_string *tn = (pesignd_string *)buffer;
	pesignd_string_set(tn, tokenname);
	iov[0].iov_base = tn;
	iov[0].iov_len = size0;

	pesignd_string *tp = pesignd_string_next(tn);
	pesignd_string_set(tp, pin);

	iov[1].iov_base = tp;
	iov[1].iov_len = size1;

	msg.msg_iov = iov;
	msg.msg_iovlen = 2;

	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: unlock token: sendmsg failed: "
			"%m\n");
		exit(1);
	}

	char *srvmsg = NULL;
	int rc = check_response(sd, &srvmsg);
	if (rc < 0) {
		fprintf(stderr, "pesign-client: %s\n",
			srvmsg);
		exit(1);
	}

	free(buffer);

	/*
	 * This can't happen, because srvmsg is only allocated if
	 * check_response() would return an error, but scan-build gets
	 * confused and I'm tired of trying to convince it. --pj
	 */
	if (srvmsg)
		free(srvmsg);
}

static void
is_token_unlocked(int sd, char *tokenname)
{
	struct msghdr msg;
	struct iovec iov[1];
	pesignd_msghdr pm;

	uint32_t size0 = pesignd_string_size(tokenname);

	check_cmd_version(sd, CMD_IS_TOKEN_UNLOCKED, "is-token-unlocked", 0, true);

	pm.version = PESIGND_VERSION;
	pm.command = CMD_IS_TOKEN_UNLOCKED;
	pm.size = size0;
	iov[0].iov_base = &pm;
	iov[0].iov_len = sizeof (pm);

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	ssize_t n;
	n = sendmsg(sd, &msg, 0);
	if (n < 0)
		err(1, "is_token_unlocked: sendmsg failed");

	uint8_t *buffer = NULL;
	buffer = calloc(1, size0);
	if (!buffer)
		err(1, "is_token_unlocked: Could not allocate memory");

	pesignd_string *tn = (pesignd_string *)buffer;
	pesignd_string_set(tn, tokenname);
	iov[0].iov_base = tn;
	iov[0].iov_len = size0;

	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	n = sendmsg(sd, &msg, 0);
	if (n < 0)
		err(1, "is_token_unlocked: sendmsg failed");

	char *srvmsg = NULL;
	int rc = check_response(sd, &srvmsg);
	if (rc < 0)
		errx(1, "%s", srvmsg);
	printf("token \"%s\" is %slocked\n", tokenname, rc == 1 ? "" : "un");

	free(buffer);

	/*
	 * This can't happen, because srvmsg is only allocated if
	 * check_response() would return an error, but scan-build gets
	 * confused and I'm tired of trying to convince it. --pj
	 */
	if (srvmsg)
		free(srvmsg);

}

static void
send_fd(int sd, int fd)
{
	struct msghdr msg;
	struct iovec iov;
	char buf[2] = "\0";

	memset(&msg, '\0', sizeof(msg));

	iov.iov_base = buf;
	iov.iov_len = sizeof(buf);

	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	size_t controllen = CMSG_SPACE(sizeof(int));
	struct cmsghdr *cm = malloc(controllen);
	if (!cm) {
		fprintf(stderr, "pesign-client: could not allocate memory: "
			"%m\n");
		exit(1);
	}

	msg.msg_control = cm;
	msg.msg_controllen = controllen;

	struct cmsghdr *cme;

	cme = CMSG_FIRSTHDR(&msg);
	cme->cmsg_len = CMSG_LEN(sizeof(int));
	cme->cmsg_level = SOL_SOCKET;
	cme->cmsg_type = SCM_RIGHTS;
	*(int *)CMSG_DATA(cme) = fd;

	ssize_t n;
	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: sign: sendmsg failed: "
			"%m\n");
		exit(1);
	}
}

static void
sign(int sd, char *infile, char *outfile, char *tokenname, char *certname,
	int attached, uint32_t format)
{
	int rc;
	bool add_file_type;

	int infd = open(infile, O_RDONLY);
	if (infd < 0) {
		fprintf(stderr, "pesign-client: could not open input file "
			"\"%s\": %m\n", infile);
		exit(1);
	}

	int outfd = open(outfile, O_RDWR|O_CREAT, 0600);
	if (outfd < 0) {
		fprintf(stderr, "pesign-client: could not open output file "
			"\"%s\": %m\n", outfile);
		exit(1);
	}

	struct msghdr msg;
	struct iovec iov[3];

	uint32_t size0 = pesignd_string_size(tokenname);
	uint32_t size1 = pesignd_string_size(certname);

	pesignd_msghdr *pm;
	pm = calloc(1, sizeof(*pm));
	if (!pm) {
oom:
		fprintf(stderr, "pesign-client: could not allocate memory: "
			"%m\n");
		exit(1);
	}

	rc = check_cmd_version(sd,
			       attached ? CMD_SIGN_ATTACHED_WITH_FILE_TYPE
					: CMD_SIGN_DETACHED_WITH_FILE_TYPE,
			       attached ? "sign-attached" : "sign-detached",
			       0, format == FORMAT_KERNEL_MODULE);
	if (rc >= 0) {
		add_file_type = true;
	} else {
		add_file_type = false;
		check_cmd_version(sd, attached ? CMD_SIGN_ATTACHED
					       : CMD_SIGN_DETACHED,
				  attached ? "sign-attached" : "sign-detached",
				  0, true);
	}

	pm->version = PESIGND_VERSION;
	pm->command = attached ? (add_file_type ? CMD_SIGN_ATTACHED_WITH_FILE_TYPE
						: CMD_SIGN_ATTACHED)
			       : (add_file_type ? CMD_SIGN_DETACHED_WITH_FILE_TYPE
						: CMD_SIGN_DETACHED);
	pm->size = size0 + size1 + (add_file_type ? sizeof(format) : 0);
	iov[0].iov_base = pm;
	iov[0].iov_len = sizeof (*pm);

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;

	ssize_t n;
	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: sign: sendmsg failed: "
			"%m\n");
		exit(1);
	}

	char *buffer;
	buffer = malloc(pm->size);
	if (!buffer)
		goto oom;

	int pos = 0;

	if (add_file_type) {
		iov[pos].iov_base = &format;
		iov[pos].iov_len = sizeof(format);
		pos++;
	}

	pesignd_string *tn = (pesignd_string *)buffer;
	pesignd_string_set(tn, tokenname);
	iov[pos].iov_base = tn;
	iov[pos].iov_len = size0;
	pos++;

	pesignd_string *cn = pesignd_string_next(tn);
	pesignd_string_set(cn, certname);
	iov[pos].iov_base = cn;
	iov[pos].iov_len = size1;

	msg.msg_iov = iov;
	msg.msg_iovlen = add_file_type ? 3 : 2;

	n = sendmsg(sd, &msg, 0);
	if (n < 0) {
		fprintf(stderr, "pesign-client: sign: sendmsg failed: "
			"%m\n");
		exit(1);
	}
	free(buffer);

	send_fd(sd, infd);
	send_fd(sd, outfd);

	char *srvmsg = NULL;
	rc = check_response(sd, &srvmsg);
	if (rc < 0) {
		fprintf(stderr, "pesign-client: signing failed: \"%s\"\n",
			srvmsg);
		exit(1);
	}

	/*
	 * This can't happen, because srvmsg is only allocated if
	 * check_response() would return an error, but scan-build gets
	 * confused and I'm tired of trying to convince it. --pj
	 */
	if (srvmsg)
		free(srvmsg);

	close(infd);
	close(outfd);

	return;
}

static long verbose;
long verbosity(void)
{
        return verbose;
}

int
main(int argc, char *argv[])
{
	char *tokenname = "NSS Certificate DB";
	char *certname = NULL;
	poptContext optCon;
	int rc;
	int action = NO_FLAGS;
	char *infile = NULL;
	char *outfile = NULL;
	char *exportfile = NULL;
	int attached = 1;
	int pinfd = -1;
	char *pinfile = NULL;
	char *tokenpin = NULL;
	file_format file_format = FORMAT_PE_BINARY;

	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesign" },
		{.longName = "token",
		 .shortName = 't',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &tokenname,
		 .descrip = "NSS token holding signing key",
		 .argDescrip = "<token>" },
		{.longName = "certificate",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &certname,
		 .descrip = "NSS certificate name",
		 .argDescrip = "<nickname>" },
		{.longName = "unlock",
		 .shortName = 'u',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = UNLOCK_TOKEN,
		 .descrip = "unlock nss token" },
		{.longName = "is-unlocked",
		 .shortName = 'q',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = IS_TOKEN_UNLOCKED,
		 .descrip = "query if an nss token is unlocked" },
		{.longName = "kill",
		 .shortName = 'k',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = KILL_DAEMON,
		 .descrip = "kill running daemon" },
		{.longName = "sign",
		 .shortName = 's',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &action,
		 .val = SIGN_BINARY,
		 .descrip = "sign binary" },
		{.longName = "infile",
		 .shortName = 'i',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &infile,
		 .descrip = "input filename",
		 .argDescrip = "<infile>" },
		{.longName = "outfile",
		 .shortName = 'o',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &outfile,
		 .descrip = "output filename",
		 .argDescrip = "<outfile>" },
		{.longName = "export",
		 .shortName = 'e',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &exportfile,
		 .descrip = "create detached signature",
		 .argDescrip = "<outfile>" },
		{.longName = "pinfd",
		 .shortName = 'f',
		 .argInfo = POPT_ARG_INT,
		 .arg = &pinfd,
		 .val = -1,
		 .descrip = "read file descriptor for pin information",
		 .argDescrip = "<file descriptor>" },
		{.longName = "pinfile",
		 .shortName = 'F',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &pinfile,
		 .descrip = "read named file for pin information",
		 .argDescrip = "<pin file name>" },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &verbose,
		 .val = 1,
		 .descrip = "be more verbose" },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &verbose,
		 .val = 2,
		 .descrip = "be very verbose" },
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	optCon = poptGetContext("pesign", argc, (const char **)argv, options,0);

	rc = poptReadDefaultConfig(optCon, 0);
	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT)) {
		fprintf(stderr,
			"pesign-client: poptReadDefaultConfig failed: %s\n",
			poptStrerror(rc));
		exit(1);
	}

	while ((rc = poptGetNextOpt(optCon)) > 0)
		;

	if (rc < -1) {
		fprintf(stderr, "pesign-client: Invalid argument: %s: %s\n",
			poptBadOption(optCon, 0), poptStrerror(rc));
		exit(1);
	}

	if (poptPeekArg(optCon)) {
		fprintf(stderr, "pesign-client: Invalid Argument: \"%s\"\n",
			poptPeekArg(optCon));
		exit(1);
	}

	if (action == NO_FLAGS) {
		poptPrintUsage(optCon, stdout, 0);
		poptFreeContext(optCon);
		exit(0);
	}

	if (action & SIGN_BINARY && (!outfile && !exportfile)) {
		fprintf(stderr, "pesign-client: neither --outfile nor --export "
			"specified\n");
		exit(1);
	}

	if (outfile && exportfile) {
		fprintf(stderr, "pesign-client: both --outfile and --export "
			"specified\n");
		exit(1);
	}
	if (exportfile) {
		outfile = exportfile;
		attached = 0;
	}

	poptFreeContext(optCon);

	int sd = -1;

	if (infile) {
		char *ext = strrchr(infile, '.');
		if (ext && strcmp(ext, ".ko") == 0)
			file_format = FORMAT_KERNEL_MODULE;
	}

	switch (action) {
	case UNLOCK_TOKEN:
		tokenpin = get_token_pin(pinfd, pinfile, "PESIGN_TOKEN_PIN");
		if (tokenpin == NULL) {
			if (errno)
				fprintf(stderr, "pesign-client: could not "
					"get token pin: %m\n");
			else
				fprintf(stderr, "pesign-client: no token pin "
					"specified");
			exit(1);
		}
		sd = connect_to_server();
		unlock_token(sd, tokenname, tokenpin);
		free(tokenpin);
		break;
	case IS_TOKEN_UNLOCKED:
		sd = connect_to_server();
		is_token_unlocked(sd, tokenname);
		break;
	case KILL_DAEMON:
		sd = connect_to_server();
		send_kill_daemon(sd);
		break;
	case SIGN_BINARY:
		if (!infile) {
			fprintf(stderr, "pesign-client: no input file "
				"specified\n");
			exit(1);
		}
		if (!outfile) {
			fprintf(stderr, "pesign-client: no output file "
				"specified\n");
			exit(1);
		}
		if (!certname) {
			fprintf(stderr, "pesign-client: no certificate name "
				"specified\n");
			exit(1);
		}
		sd = connect_to_server();
		sign(sd, infile, outfile, tokenname, certname, attached, file_format);
		break;
	default:
		fprintf(stderr, "Incompatible flags (0x%08x): ", action);
		for (int i = 1; i < FLAG_LIST_END; i <<= 1) {
			if (action & i)
				print_flag_name(stderr, i);
		}
		fprintf(stderr, "\n");
		exit(1);
	}

	return 0;
}

```

`src/cms_common.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * cms_common.c - Implement the common parts pf PKCS7 that we need
 *                regardless of the target file type.
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <syslog.h>

#include "pesign.h"

#include <prerror.h>
#include <nss.h>
#include <secport.h>
#include <secpkcs7.h>
#include <secder.h>
#include <keyhi.h>
#include <base64.h>
#include <pk11pub.h>
#include <secerr.h>
#include <certt.h>

#include "hex.h"

/*
 * Note that cms->selected_digest defaults to 0, which means the first
 * entry of this array is the default digest.
 */
const struct digest_param digest_params[] = {
	[DIGEST_PARAM_SHA256] = {
		.name = "sha256",
		.digest_tag = SEC_OID_SHA256,
		.signature_tag = SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION,
		.digest_encryption_tag = SEC_OID_PKCS1_RSA_ENCRYPTION,
		.efi_guid = &efi_guid_sha256,
		.size = 32
	},
#if 1
	[DIGEST_PARAM_SHA1] = {
		.name = "sha1",
		.digest_tag = SEC_OID_SHA1,
		.signature_tag = SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION,
		.digest_encryption_tag = SEC_OID_PKCS1_RSA_ENCRYPTION,
		.efi_guid = &efi_guid_sha1,
		.size = 20
	},
#endif
};
const unsigned int n_digest_params = sizeof (digest_params) / sizeof (digest_params[0]);

SECOidTag
digest_get_digest_oid(cms_context *cms)
{
	unsigned int i = cms->selected_digest;
	return digest_params[i].digest_tag;
}

SECOidTag
digest_get_encryption_oid(cms_context *cms)
{
	unsigned int i = cms->selected_digest;
	return digest_params[i].digest_encryption_tag;
}

SECOidTag
digest_get_signature_oid(cms_context *cms)
{
	unsigned int i = cms->selected_digest;
	return digest_params[i].signature_tag;
}

int
digest_get_digest_size(cms_context *cms)
{
	unsigned int i = cms->selected_digest;
	return digest_params[i].size;
}

void
teardown_digests(cms_context *ctx)
{
	struct digest *digests = ctx->digests;

	if (!digests)
		return;

	for (unsigned int i = 0; i < n_digest_params; i++) {
		if (digests[i].pk11ctx) {
			PK11_Finalize(digests[i].pk11ctx);
			PK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);
		}
		if (digests[i].pe_digest) {
			/* XXX sure seems like we should be freeing it here,
			 * but that's segfaulting, and we know it'll get
			 * cleaned up with PORT_FreeArena a couple of lines
			 * down.
			 */
			digests[i].pe_digest = NULL;
		}
	}
	PORT_Free(digests);
	ctx->digests = NULL;
}

static int PRINTF(3, 4)
cms_common_log(cms_context *ctx UNUSED, int priority,
	       char *fmt, ...)
{
	va_list ap;
	FILE *out = priority & LOG_ERR ? stderr : stdout;

	va_start(ap, fmt);
	int rc = vfprintf(out, fmt, ap);
	fprintf(out, "\n");

	va_end(ap);
	return rc;
}

int
cms_context_init(cms_context *cms)
{
	memset(cms, '\0', sizeof (*cms));

	cms->log = cms_common_log;

	cms->arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
	if (!cms->arena)
		cnreterr(-1, cms, "could not create cryptographic arena");

	cms->selected_digest = DEFAULT_DIGEST_PARAM;

	INIT_LIST_HEAD(&cms->pk12_ins);
	cms->pk12_out.fd = -1;
	cms->db_out = cms->dbx_out = cms->dbt_out = -1;

	return 0;
}

void
cms_context_fini(cms_context *cms)
{
	struct list_head *n, *pos;

	if (cms->cert) {
		CERT_DestroyCertificate(cms->cert);
		cms->cert = NULL;
	}

	switch (cms->pwdata.source) {
	case PW_SOURCE_INVALID:
	case PW_PROMPT:
	case PW_DEVICE:
	case PW_FROMFILEDB:
	case PW_FROMENV:
	case PW_FROMFILE:
	case PW_FROMFD:
	case PW_SOURCE_MAX:
		break;
	case PW_DATABASE:
		xfree(cms->pwdata.data);
		break;
	case PW_PLAINTEXT:
		if (cms->pwdata.data) {
			memset(cms->pwdata.data, 0, strlen(cms->pwdata.data));
			xfree(cms->pwdata.data);
		}
		break;
	}
	cms->pwdata.source = PW_SOURCE_INVALID;
	cms->pwdata.orig_source = PW_SOURCE_INVALID;

	if (cms->privkey) {
		free(cms->privkey);
		cms->privkey = NULL;
	}

	if (cms->db_out >= 0)
		fsync(cms->db_out);
	xclose(cms->db_out);
	if (cms->dbx_out >= 0)
		fsync(cms->dbx_out);
	xclose(cms->dbx_out);
	if (cms->dbt_out >= 0)
		fsync(cms->dbt_out);
	xclose(cms->dbt_out);
	list_for_each_safe(pos, n, &cms->pk12_ins) {
		pk12_file_t *file = list_entry(pos, pk12_file_t, list);

		xfree(file->path);
		if (file->fd >= 0) {
			/*
			 * This may or may not be writable...
			 */
			fsync(file->fd);
			errno = 0;
		}
		xclose(file->fd);
		xfree(file->pw);
	}
	xclose(cms->pk12_out.fd);
	xfree(cms->pk12_out.path);
	xfree(cms->pk12_out.pw);

	/* These were freed when the arena was destroyed */
	if (cms->tokenname)
		cms->tokenname = NULL;
	if (cms->certname)
		cms->certname = NULL;

	if (cms->newsig.data) {
		free_poison(cms->newsig.data, cms->newsig.len);
		free(cms->newsig.data);
		memset(&cms->newsig, '\0', sizeof (cms->newsig));
	}

	cms->selected_digest = DEFAULT_DIGEST_PARAM;

	if (cms->ci_digest) {
		free_poison(cms->ci_digest->data, cms->ci_digest->len);
		/* XXX sure seems like we should be freeing it here, but
		 * that's segfaulting, and we know it'll get cleaned up with
		 * PORT_FreeArena a couple of lines down.
		 */
		cms->ci_digest = NULL;
	}

	teardown_digests(cms);

	if (cms->raw_signed_attrs) {
		free_poison(cms->raw_signed_attrs->data,
				cms->raw_signed_attrs->len);
		/* XXX sure seems like we should be freeing it here, but
		 * that's segfaulting, and we know it'll get cleaned up with
		 * PORT_FreeArena a couple of lines down.
		 */
		cms->raw_signed_attrs = NULL;
	}

	if (cms->raw_signature) {
		free_poison(cms->raw_signature->data,
				cms->raw_signature->len);
		/* XXX sure seems like we should be freeing it here, but
		 * that's segfaulting, and we know it'll get cleaned up with
		 * PORT_FreeArena a couple of lines down.
		 */
		cms->raw_signature = NULL;
	}

	for (int i = 0; i < cms->num_signatures; i++) {
		free(cms->signatures[i]->data);
		free(cms->signatures[i]);
	}

	xfree(cms->signatures);
	cms->num_signatures = 0;

	if (cms->authbuf) {
		xfree(cms->authbuf);
		cms->authbuf_len = 0;
	}

	PORT_FreeArena(cms->arena, PR_TRUE);
	memset(cms, '\0', sizeof(*cms));
	xfree(cms);
}

int
cms_context_alloc(cms_context **cmsp)
{
	cms_context *cms = calloc(1, sizeof (*cms));
	if (!cms)
		return -1;

	int rc = cms_context_init(cms);
	if (rc < 0) {
		set_errno_guard();
		xfree(cms);
		cms = NULL;
		return -1;
	}
	*cmsp = cms;
	return 0;
}

void cms_set_pw_callback(cms_context *cms, PK11PasswordFunc func)
{
	cms->func = func;
}

void cms_set_pw_data(cms_context *cms, secuPWData *pwdata)
{
	ingress();

	switch (cms->pwdata.source) {
	case PW_SOURCE_INVALID:
	case PW_PROMPT:
	case PW_DEVICE:
	case PW_SOURCE_MAX:
		break;

	case PW_FROMFD:
		if (cms->pwdata.intdata >= 0 &&
		    !(pwdata && pwdata->source == PW_FROMFD &&
		      cms->pwdata.intdata == pwdata->intdata))
			close(cms->pwdata.intdata);
		break;

	case PW_FROMFILEDB:
	case PW_FROMENV:
	case PW_FROMFILE:
	case PW_PLAINTEXT:
		if (cms->pwdata.data) {
			memset(cms->pwdata.data, 0, strlen(cms->pwdata.data));
			xfree(cms->pwdata.data);
		}
		break;

	case PW_DATABASE:
		xfree(cms->pwdata.data);
		break;
	}

	if (!pwdata) {
		cms->pwdata.source = PW_SOURCE_INVALID;
		dbgprintf("pwdata:NULL");
	} else {
		memmove(&cms->pwdata, pwdata, sizeof(*pwdata));
		dbgprintf("pwdata:%p", pwdata);
		dbgprintf("pwdata->source:%d", pwdata->source);
		dbgprintf("pwdata->data:%p (\"%s\")", pwdata->data,
			  pwdata->data ? pwdata->data : "(null)");
	}

	egress();
}

int
set_digest_parameters(cms_context *cms, char *name)
{
	if (strcmp(name, "help")) {
		for (unsigned int i = 0; i < n_digest_params; i++) {
			if (!strcmp(name, digest_params[i].name)) {
				cms->selected_digest = i;
				return 0;
			}
		}
	} else {
		printf("Supported digests: ");
		for (unsigned int i = 0; digest_params[i].name != NULL; i++) {
			printf("%s ", digest_params[i].name);
		}
		printf("\n");
	}
	return -1;
}

struct validity_cbdata {
	cms_context *cms;
	PK11SlotListElement *psle;
	PK11SlotInfo *slot;
	CERTCertificate *cert;
};

static SECStatus
is_valid_cert(CERTCertificate *cert, void *data)
{
	struct validity_cbdata *cbd = (struct validity_cbdata *)data;
	PK11SlotInfo *slot = cbd->slot;
	SECKEYPrivateKey *privkey = NULL;
	int errnum;

	errnum = PORT_GetError();
	if (errnum == SEC_ERROR_EXTENSION_NOT_FOUND) {
		dbgprintf("Got SEC_ERROR_EXTENSION_NOT_FOUND; clearing");
		PORT_SetError(0);
		errnum = 0;
	}
	if (cert == NULL) {
		if (!errnum)
			PORT_SetError(SEC_ERROR_UNKNOWN_CERT);
		return SECFailure;
	}

	privkey = PK11_FindPrivateKeyFromCert(slot, cert, cbd->cms);
	if (privkey != NULL) {
		if (cbd->cert)
			CERT_DestroyCertificate(cbd->cert);
		cbd->cert = CERT_DupCertificate(cert);
		CERT_DestroyCertificate(cert);
		SECKEY_DestroyPrivateKey(privkey);
		PORT_SetError(0);
		return SECSuccess;
	}
	return SECFailure;
}

static SECStatus
is_valid_cert_without_private_key(CERTCertificate *cert, void *data)
{
	struct validity_cbdata *cbd = (struct validity_cbdata *)data;
	PK11SlotInfo *slot = cbd->slot;
	SECKEYPrivateKey *privkey = NULL;
	int errnum;

	errnum = PORT_GetError();
	if (errnum == SEC_ERROR_EXTENSION_NOT_FOUND) {
		dbgprintf("Got SEC_ERROR_EXTENSION_NOT_FOUND; clearing");
		PORT_SetError(0);
		errnum = 0;
	}
	if (cert == NULL) {
		if (!errnum)
			PORT_SetError(SEC_ERROR_UNKNOWN_CERT);
		return SECFailure;
	}

	privkey = PK11_FindPrivateKeyFromCert(slot, cert, cbd->cms);
	if (privkey == NULL) {
		if (cbd->cert)
			CERT_DestroyCertificate(cbd->cert);
		PORT_SetError(0);
		cbd->cert = CERT_DupCertificate(cert);
		CERT_DestroyCertificate(cert);
		return SECSuccess;
	} else {
		SECKEY_DestroyPrivateKey(privkey);
		CERT_DestroyCertificate(cert);
	}
	return SECFailure;
}

int
is_issuer_of(CERTCertificate *c0, CERTCertificate *c1)
{
	if (c0->derSubject.len != c1->derIssuer.len)
		return 0;

	if (memcmp(c0->derSubject.data, c1->derIssuer.data, c0->derSubject.len))
		return 0;
	return 1;
}

/* This is the dumbest function ever, but we need it anyway, because nss
 * is garbage. */
static void
PK11_DestroySlotListElement(PK11SlotList *slots, PK11SlotListElement **psle)
{
	while (psle && *psle)
		*psle = PK11_GetNextSafe(slots, *psle, PR_FALSE);
}

static inline void
unescape_html_in_place(char *s)
{
	size_t sz = strlen(s) + 1;
	size_t pos = 0;
	char *s1;

	dbgprintf("unescaping pos:%zd sz:%zd \"%s\"", pos, sz, s);
	do {
		s1 = strchrnul(&s[pos], '%');
		if (s1[0] == '\0')
			break;
		dbgprintf("s1 is \"%s\"", s1);
		if ((size_t)(s1 - s) < (size_t)(sz - 3)) {
			int c;

			c = (hexchar_to_bin(s1[1]) << 4)
			    | (hexchar_to_bin(s1[2]) & 0xf);
			dbgprintf("replacing %%%c%c with 0x%02hhx", s1[1], s1[2], (char)c);
			s1[0] = c;
			memmove(&s1[1], &s1[3], sz - (&s1[3] - s));
			sz -= 2;
			pos = &s1[1] - s;
			dbgprintf("new pos:%zd sz:%zd s:\"%s\"", pos, sz, s);
		}
	} while (pos < sz);
}

static inline void
resolve_pkcs11_token_in_place(char *tokenname)
{
	char *ntn = tokenname;
	size_t pos = 0;

	while (*ntn) {
		char *cp = strchrnul(ntn, ';');
		char c = *cp;
		*cp = '\0';

		dbgprintf("ntn:\"%s\"", ntn);
		if (!strncmp(&ntn[pos], "token=", 6)) {
			ntn += 6;
			memmove(tokenname, ntn, cp - ntn + 1);
			break;
		}

		*cp = c;
		ntn = cp + (c ? 1 : 0);
	}
	unescape_html_in_place(tokenname);
	dbgprintf("token name is \"%s\"", tokenname);
}

#define resolve_token_name(tn) ({					\
	char *s_ = tn;							\
	if (!strncmp(tn, "pkcs11:", 7))	{				\
		dbgprintf("provided token name is pkcs11 uri; parsing");\
		s_ = strdupa(tn+7);					\
		resolve_pkcs11_token_in_place(s_);			\
	}								\
	s_;								\
})

int
unlock_nss_token(cms_context *cms)
{
	char *tokenname = resolve_token_name(cms->tokenname);

	dbgprintf("setting password function to %s",
		  cms->func ? "cms->func" : "SECU_GetModulePassword");
	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);

	PK11SlotList *slots = NULL;
	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
	if (!slots)
		cnreterr(-1, cms, "could not get pk11 token list");

	PK11SlotListElement *psle = NULL;
	psle = PK11_GetFirstSafe(slots);
	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get pk11 safe");
	}

	while (psle) {
		if (!strcmp(tokenname, PK11_GetTokenName(psle->slot)))
			break;

		psle = PK11_GetNextSafe(slots, psle, PR_FALSE);
	}

	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		nssreterr(-1, "Could not find token \"%s\"", tokenname);
	}

	SECStatus status;
	if (PK11_NeedLogin(psle->slot) &&
			!PK11_IsLoggedIn(psle->slot, cms)) {
		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
		if (status != SECSuccess) {
			save_port_err() {
				int err = PORT_GetError();
				PK11_DestroySlotListElement(slots, &psle);
				PK11_FreeSlotList(slots);
				cms->log(cms, LOG_ERR,
					 "authentication failed for token \"%s\": %s",
					 tokenname, PORT_ErrorToString(err));
			}
			return -1;
		}
	}

	PK11_DestroySlotListElement(slots, &psle);
	PK11_FreeSlotList(slots);
	return 0;
}

int
find_certificate(cms_context *cms, int needs_private_key)
{
	char *tokenname = resolve_token_name(cms->tokenname);

	struct validity_cbdata cbd;
	if (!cms->certname || !*cms->certname) {
		cms->log(cms, LOG_ERR, "no certificate name specified");
		return -1;
	}

	dbgprintf("setting password function to %s",
		  cms->func ? "cms->func" : "SECU_GetModulePassword");
	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);

	PK11SlotList *slots = NULL;
	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
	if (!slots)
		cnreterr(-1, cms, "could not get pk11 token list");

	PK11SlotListElement *psle = NULL;
	psle = PK11_GetFirstSafe(slots);
	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get pk11 safe");
	}

	while (psle) {
		dbgprintf("looking for token \"%s\", got \"%s\"",
			  tokenname, PK11_GetTokenName(psle->slot));
		if (!strcmp(tokenname, PK11_GetTokenName(psle->slot))) {
			dbgprintf("found token \"%s\"", tokenname);
			break;
		}

		psle = PK11_GetNextSafe(slots, psle, PR_FALSE);
	}

	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		nssreterr(-1, "Could not find token \"%s\"", tokenname);
	}

	int errnum;
	SECStatus status;
	if ((needs_private_key || !PK11_IsFriendly(psle->slot)) &&
	    (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms))) {
		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
		if (status != SECSuccess) {
			save_port_err() {
				errnum = PORT_GetError();
				PK11_DestroySlotListElement(slots, &psle);
				PK11_FreeSlotList(slots);
				cms->log(cms, LOG_ERR,
					 "authentication failed for token \"%s\": %s",
					 tokenname, PORT_ErrorToString(errnum));
			}
			return -1;
		}
	}

	CERTCertList *certlist = NULL;
	certlist = PK11_ListCertsInSlot(psle->slot);
	if (!certlist) {
		save_port_err() {
			PK11_DestroySlotListElement(slots, &psle);
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get certificate list");
	}

	SECItem nickname = {
		.data = (void *)cms->certname,
		.len = strlen(cms->certname) + 1,
		.type = siUTF8String,
	};

	cms->psle = psle;

	cbd.cms = cms;
	cbd.psle = psle;
	cbd.slot = psle->slot;
	cbd.cert = NULL;

	PORT_SetError(SEC_ERROR_UNKNOWN_CERT);
	if (needs_private_key) {
		status = PK11_TraverseCertsForNicknameInSlot(&nickname,
					psle->slot, is_valid_cert, &cbd);
		errnum = PORT_GetError();
		if (errnum)
			dbgprintf("PK11_TraverseCertsForNicknameInSlot():%s:%s",
				  PORT_ErrorToName(errnum),
				  PORT_ErrorToString(errnum));
	} else {
		status = PK11_TraverseCertsForNicknameInSlot(&nickname,
					psle->slot,
					is_valid_cert_without_private_key,
					&cbd);
		errnum = PORT_GetError();
		if (errnum)
			dbgprintf("PK11_TraverseCertsForNicknameInSlot():%s:%s",
				PORT_ErrorToName(errnum),
				PORT_ErrorToString(errnum));
	}
	dbgprintf("status:%d cbd.cert:%p", status, cbd.cert);
	if (status == SECSuccess && cbd.cert != NULL) {
		if (cms->cert)
			CERT_DestroyCertificate(cms->cert);
		cms->cert = CERT_DupCertificate(cbd.cert);
	} else {
		errnum = PORT_GetError();
		dbgprintf("token traversal %s; cert %sfound:%s:%s",
			  status == SECSuccess ? "succeeded" : "failed",
			  cbd.cert == NULL ? "not" : "",
			  PORT_ErrorToName(errnum),
			  PORT_ErrorToString(errnum));
	}

	save_port_err() {
		dbgprintf("Destroying cert list");
		CERT_DestroyCertList(certlist);
		dbgprintf("Destroying slot list element");
		PK11_DestroySlotListElement(slots, &psle);
		dbgprintf("Destroying slot list");
		PK11_FreeSlotList(slots);
		cms->psle = NULL;
	}
	if (status != SECSuccess || cms->cert == NULL)
		cnreterr(-1, cms, "could not find certificate");

	return 0;
}

int
find_slot_for_token(cms_context *cms, PK11SlotInfo **slot)
{
	if (!cms->tokenname) {
		cms->log(cms, LOG_ERR, "no token name specified");
		return -1;
	}

	char *tokenname = resolve_token_name(cms->tokenname);

	dbgprintf("setting password function to %s",
		  cms->func ? "cms->func" : "SECU_GetModulePassword");
	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);

	PK11SlotList *slots = NULL;
	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
	if (!slots)
		cnreterr(-1, cms, "could not get pk11 token list");

	PK11SlotListElement *psle = NULL;
	psle = PK11_GetFirstSafe(slots);
	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get pk11 safe");
	}

	while (psle) {
		if (!strcmp(tokenname, PK11_GetTokenName(psle->slot)))
			break;

		psle = PK11_GetNextSafe(slots, psle, PR_FALSE);
	}

	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		nssreterr(-1, "Could not find token \"%s\"", tokenname);
	}

	SECStatus status;
	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {
		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
		if (status != SECSuccess) {
			save_port_err() {
				int err = PORT_GetError();
				PK11_DestroySlotListElement(slots, &psle);
				PK11_FreeSlotList(slots);
				cms->log(cms, LOG_ERR,
					 "authentication failed for token \"%s\": %s",
					 tokenname, PORT_ErrorToString(err));
			}
			return -1;
		}
	}
	*slot = psle->slot;

	PK11_DestroySlotListElement(slots, &psle);
	PK11_FreeSlotList(slots);
	return 0;
}

int
find_certificate_by_callback(cms_context *cms,
			     find_cert_match_t *match, void *cbdata,
			     CERTCertificate **cert)
{
	char *tokenname = resolve_token_name(cms->tokenname);

	if (!match) {
		cms->log(cms, LOG_ERR, "no certificate match callback not specified");
		return -1;
	}
	if (!cbdata) {
		cms->log(cms, LOG_ERR, "no certificate callback data not specified");
		return -1;
	}

	dbgprintf("setting password function to %s",
		  cms->func ? "cms->func" : "SECU_GetModulePassword");
	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);

	PK11SlotList *slots = NULL;
	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
	if (!slots)
		cnreterr(-1, cms, "could not get pk11 token list");

	PK11SlotListElement *psle = NULL;
	psle = PK11_GetFirstSafe(slots);
	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get pk11 safe");
	}

	while (psle) {
		if (!strcmp(tokenname, PK11_GetTokenName(psle->slot)))
			break;

		psle = PK11_GetNextSafe(slots, psle, PR_FALSE);
	}

	if (!psle) {
		save_port_err() {
			PK11_FreeSlotList(slots);
			cms->log(cms, LOG_ERR, "could not find token \"%s\"",
				 tokenname);
		}
		return -1;
	}

	SECStatus status;
	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {
		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
		if (status != SECSuccess) {
			save_port_err() {
				int err = PORT_GetError();
				PK11_DestroySlotListElement(slots, &psle);
				PK11_FreeSlotList(slots);
				cms->log(cms, LOG_ERR,
					 "authentication failed for token \"%s\": %s",
					 tokenname, PORT_ErrorToString(err));
			}
			return -1;
		}
	}

	CERTCertList *certlist = NULL;
	certlist = PK11_ListCertsInSlot(psle->slot);
	if (!certlist) {
		save_port_err() {
			PK11_DestroySlotListElement(slots, &psle);
			PK11_FreeSlotList(slots);
		}
		cnreterr(-1, cms, "could not get certificate list");
	}

	CERTCertListNode *node = NULL;
	for_each_cert(certlist, tmpnode) {
		/* If we're looking up the issuer of some cert, and the
		 * issuer isn't in the database, we'll get back what is
		 * essentially a template that's in NSS's cache waiting to
		 * be filled out.  We can't use that, it'll just cause
		 * CERT_DupCertificate() to segfault. */
		if (!tmpnode || !tmpnode->cert
		    || !tmpnode->cert->derCert.data
		    || !tmpnode->cert->derCert.len
		    || !tmpnode->cert->derIssuer.data
		    || !tmpnode->cert->derIssuer.len
		    || !tmpnode->cert->serialNumber.data
		    || !tmpnode->cert->serialNumber.len)
			continue;

		int rc = match(tmpnode->cert, cbdata);
		if (rc == 1) {
			node = tmpnode;
			break;
		}
	}

	if (!node) {
		PK11_DestroySlotListElement(slots, &psle);
		PK11_FreeSlotList(slots);
		CERT_DestroyCertList(certlist);
		cnreterr(-1, cms, "Could not find certificate");
	}

	*cert = CERT_DupCertificate(node->cert);

	PK11_DestroySlotListElement(slots, &psle);
	PK11_FreeSlotList(slots);
	CERT_DestroyCertList(certlist);

	return 0;

}

static int
match_subject(CERTCertificate *cert, void *cbdatap)
{
	if (!cert->subjectName)
		return 0;

	if (!strcmp(cert->subjectName, (char *)cbdatap))
		return 1;

	return 0;
}

int
find_named_certificate(cms_context *cms, char *name, CERTCertificate **cert)
{
	if (!name)
		cnreterr(-1, cms, "no subject name specified");

	return find_certificate_by_callback(cms, match_subject, name, cert);
}

static int
match_issuer_and_serial(CERTCertificate *cert, void *cbdatap)
{
	CERTIssuerAndSN *ias = cbdatap;
	bool found = false;

	if (ias->derIssuer.len == cert->derIssuer.len &&
	    ias->derIssuer.len != 0) {
		if (memcmp(ias->derIssuer.data, cert->derIssuer.data,
			   ias->derIssuer.len))
			return 0;
		found = true;
	}

	if (!found) {
		SECComparison seccomp;

		seccomp = CERT_CompareName(&ias->issuer, &cert->issuer);
		if (seccomp != SECEqual)
			return 0;
	}

	if (ias->serialNumber.len != cert->serialNumber.len)
		return 0;

	if (memcmp(ias->serialNumber.data, cert->serialNumber.data,
		   ias->serialNumber.len))
		return 0;

	return 1;
}

int
find_certificate_by_issuer_and_sn(cms_context *cms,
				  CERTIssuerAndSN *ias,
				  CERTCertificate **cert)
{
	if (!ias)
		cnreterr(-1, cms, "invalid issuer and serial number");

	return find_certificate_by_callback(cms, match_issuer_and_serial, ias, cert);
}

int
generate_string(cms_context *cms, SECItem *der, char *str)
{
	SECItem input;

	input.data = (void *)str;
	input.len = strlen(str);
	input.type = siBMPString;

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, der, &input,
						SEC_PrintableStringTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode string");
	return 0;
}

int
generate_time(cms_context *cms, SECItem *encoded, time_t when)
{
	static char timebuf[32];
	SECItem whenitem = {.type = SEC_ASN1_UTC_TIME,
			 .data = (unsigned char *)timebuf,
			 .len = 0
	};
	struct tm *tm;

	tm = gmtime(&when);

	whenitem.len = snprintf(timebuf, 32, "%02d%02d%02d%02d%02d%02dZ",
		tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
		tm->tm_hour, tm->tm_min, tm->tm_sec);
	if (whenitem.len == 32)
		cnreterr(-1, cms, "could not encode timestamp");

	if (SEC_ASN1EncodeItem(cms->arena, encoded, &whenitem,
			SEC_UTCTimeTemplate) == NULL)
		cnreterr(-1, cms, "could not encode timestamp");
	return 0;
}

static SEC_ASN1Template EmptySequenceTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = 0
	},
	{ 0, }
};

int
generate_empty_sequence(cms_context *cms, SECItem *encoded)
{
	SECItem empty = {.type = SEC_ASN1_SEQUENCE,
			 .data = NULL,
			 .len = 0
	};
	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, encoded, &empty,
							EmptySequenceTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode empty sequence");
	return 0;
}

static SEC_ASN1Template ContextSpecificSequence[] = {
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | SEC_ASN1_EXPLICIT,
	.offset = 0,
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem),
	},
	{ 0 }
};

int
make_context_specific(cms_context *cms, int ctxt, SECItem *encoded,
			SECItem *original)
{
	void *rv;
	ContextSpecificSequence[0].kind = SEC_ASN1_EXPLICIT |
					  SEC_ASN1_CONTEXT_SPECIFIC | ctxt;

	rv = SEC_ASN1EncodeItem(cms->arena, encoded, original,
				ContextSpecificSequence);
	if (rv == NULL)
		cnreterr(-1, cms, "could not encode context specific data");
	return 0;
}

static SEC_ASN1Template EKUOidSequence[] = {
	{
	.kind = SEC_ASN1_OBJECT_ID,
	.offset = 0,
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem),
	},
	{ 0 }
};

int
make_eku_oid(cms_context *cms, SECItem *encoded, SECOidTag oid_tag)
{
	void *rv;
	SECOidData *oid_data;

	oid_data = SECOID_FindOIDByTag(oid_tag);
	if (!oid_data)
		cnreterr(-1, cms, "could not encode eku oid data");

	rv = SEC_ASN1EncodeItem(cms->arena, encoded, &oid_data->oid,
				EKUOidSequence);
	if (rv == NULL)
		cnreterr(-1, cms, "could not encode eku oid data");

	encoded->type = siBuffer;
	return 0;
}

int
generate_octet_string(cms_context *cms, SECItem *encoded, SECItem *original)
{
	if (content_is_empty(original->data, original->len)) {
		cms->log(cms, LOG_ERR, "content is empty, not encoding");
		return -1;
	}
	if (SEC_ASN1EncodeItem(cms->arena, encoded, original,
			SEC_OctetStringTemplate) == NULL)
		cnreterr(-1, cms, "could not encode octet string");

	return 0;
}

int
generate_object_id(cms_context *cms, SECItem *der, SECOidTag tag)
{
	SECOidData *oid;

	oid = SECOID_FindOIDByTag(tag);
	if (!oid)
		cnreterr(-1, cms, "could not find OID");

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, der, &oid->oid,
						SEC_ObjectIDTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode ODI");
	return 0;
}

int
generate_algorithm_id(cms_context *cms, SECAlgorithmID *idp, SECOidTag tag)
{
	SECAlgorithmID id;

	if (!idp)
		return -1;

	SECOidData *oiddata;
	oiddata = SECOID_FindOIDByTag(tag);
	if (!oiddata) {
		PORT_SetError(SEC_ERROR_INVALID_ALGORITHM);
		return -1;
	}
	if (SECITEM_CopyItem(cms->arena, &id.algorithm, &oiddata->oid))
		return -1;

	SECITEM_AllocItem(cms->arena, &id.parameters, 2);
	if (id.parameters.data == NULL)
		goto err;
	id.parameters.data[0] = SEC_ASN1_NULL;
	id.parameters.data[1] = 0;
	id.parameters.type = siBuffer;

	memcpy(idp, &id, sizeof (id));
	return 0;

err:
	SECITEM_FreeItem(&id.algorithm, PR_FALSE);
	return -1;
}

int
encode_algorithm_id(cms_context *cms, SECItem *der, SECOidTag tag)
{
	SECAlgorithmID id;

	int rc = generate_algorithm_id(cms, &id, tag);
	if (rc < 0)
		return rc;

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, der, &id,
						SECOID_AlgorithmIDTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode Algorithm ID");

	return 0;
}

typedef struct {
	/* L"<<<Obsolete>>>" no nul */
	SECItem unicode;
} SpcString;

/* Generate DER for SpcString, which is always "<<<Obsolete>>>" in UCS-2.
 * Irony abounds. Needs to decode like this:
 *        [0]  (28)
 *           00 3c 00 3c 00 3c 00 4f 00 62 00 73 00 6f 00
 *           6c 00 65 00 74 00 65 00 3e 00 3e 00 3e
 */
static SEC_ASN1Template SpcStringTemplate[] = {
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0,
	.offset = offsetof(SpcString, unicode),
	.sub = &SEC_BMPStringTemplate,
	.size = sizeof (SECItem),
	},
	{ 0, }
};

int
generate_spc_string(cms_context *cms, SECItem *ssp, char *str, int len)
{
	SpcString ss;
	memset(&ss, '\0', sizeof (ss));

	SECITEM_AllocItem(cms->arena, &ss.unicode, len);
	if (len != 0) {
		if (!ss.unicode.data)
			cnreterr(-1, cms, "could not allocate memory");

		memcpy(ss.unicode.data, str, len);
	}
	ss.unicode.type = siBMPString;

	if (SEC_ASN1EncodeItem(cms->arena, ssp, &ss, SpcStringTemplate) == NULL)
		cnreterr(-1, cms, "could not encode SpcString");

	return 0;
}

/* Generate the SpcLink DER. Awesomely, this needs to decode as:
 *                      C-[2]  (30)
 * That is all.
 */
SEC_ASN1Template SpcLinkTemplate[] = {
	{
	.kind = SEC_ASN1_CHOICE,
	.offset = offsetof(SpcLink, type),
	.sub = NULL,
	.size = sizeof (SpcLink)
	},
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_EXPLICIT,
	.offset = offsetof(SpcLink, url),
	.sub = &SEC_AnyTemplate,
	.size = SpcLinkTypeUrl,
	},
	{
	.kind = SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_CONTEXT_SPECIFIC | 2,
	.offset = offsetof(SpcLink, file),
	.sub = &SpcStringTemplate,
	.size = SpcLinkTypeFile,
	},
	{ 0, }
};

int
generate_spc_link(cms_context *cms, SpcLink *slp, SpcLinkType link_type,
		void *link_data, size_t link_data_size)
{
	SpcLink sl;
	memset(&sl, '\0', sizeof (sl));

	sl.type = link_type;
	switch (sl.type) {
	case SpcLinkTypeFile: {
		int rc = generate_spc_string(cms, &sl.file, link_data,
					link_data_size);
		if (rc < 0)
			return rc;
		break;
	}
	case SpcLinkTypeUrl:
		sl.url.type = siBuffer;
		sl.url.data = link_data;
		sl.url.len = link_data_size;
		break;
	default:
		cms->log(cms, LOG_ERR, "Invalid SpcLinkType");
		return -1;
	};

	memcpy(slp, &sl, sizeof (sl));
	return 0;
}

int
generate_digest_begin(cms_context *cms)
{
	struct digest *digests = NULL;

	if (cms->digests) {
		digests = cms->digests;
	} else {
		digests = PORT_ZAlloc(n_digest_params * sizeof (*digests));
		if (digests == NULL)
			cnreterr(-1, cms, "could not allocate digest context");
	}

	for (unsigned int i = 0; i < n_digest_params; i++) {
		digests[i].pk11ctx = PK11_CreateDigestContext(
						digest_params[i].digest_tag);
		if (!digests[i].pk11ctx)
			cngotoerr(err, cms, "could not create digest context");

		PK11_DigestBegin(digests[i].pk11ctx);
	}

	cms->digests = digests;
	return 0;

err:
	for (unsigned int i = 0; i < n_digest_params; i++) {
		if (digests[i].pk11ctx)
			PK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);
	}

	free(digests);
	return -1;
}

void
generate_digest_step(cms_context *cms, void *data, size_t len)
{
	for (unsigned int i = 0; i < n_digest_params; i++)
		PK11_DigestOp(cms->digests[i].pk11ctx, data, len);
}

int
generate_digest_finish(cms_context *cms)
{
	void *mark = PORT_ArenaMark(cms->arena);

	for (unsigned int i = 0; i < n_digest_params; i++) {
		SECItem *digest = PORT_ArenaZAlloc(cms->arena,sizeof (SECItem));
		if (digest == NULL)
			cngotoerr(err, cms, "could not allocate memory");

		digest->type = siBuffer;
		digest->len = digest_params[i].size;
		digest->data = PORT_ArenaZAlloc(cms->arena, digest_params[i].size);
		if (digest->data == NULL)
			cngotoerr(err, cms, "could not allocate memory");

		PK11_DigestFinal(cms->digests[i].pk11ctx,
			digest->data, &digest->len, digest_params[i].size);
		PK11_Finalize(cms->digests[i].pk11ctx);
		PK11_DestroyContext(cms->digests[i].pk11ctx, PR_TRUE);
		cms->digests[i].pk11ctx = NULL;
		/* XXX sure seems like we should be freeing it here,
		 * but that's segfaulting, and we know it'll get
		 * cleaned up with PORT_FreeArena a couple of lines
		 * down.
		 */
		cms->digests[i].pe_digest = digest;
	}

	PORT_ArenaUnmark(cms->arena, mark);
	return 0;
err:
	for (unsigned int i = 0; i < n_digest_params; i++) {
		if (cms->digests[i].pk11ctx)
			PK11_DestroyContext(cms->digests[i].pk11ctx, PR_TRUE);
	}
	PORT_ArenaRelease(cms->arena, mark);
	return -1;
}

/* before you run this, you'll need to enroll your CA with:
 * certutil -A -n 'my CA' -d /etc/pki/pesign -t CT,CT,CT -i ca.crt
 * And you'll need to enroll the private key like this:
 * pk12util -d /etc/pki/pesign/ -i Peter\ Jones.p12
 */
int
generate_signature(cms_context *cms)
{
	int rc = 0;
	int i = cms->selected_digest;

	if (cms->digests[i].pe_digest == NULL)
		cnreterr(-1, cms, "PE digest has not been allocated");

	if (content_is_empty(cms->digests[i].pe_digest->data,
			cms->digests[i].pe_digest->len))
		cnreterr(-1, cms, "PE binary has not been digested");

	SECItem sd_der;
	memset(&sd_der, '\0', sizeof(sd_der));
	rc = generate_spc_signed_data(cms, &sd_der);
	if (rc < 0)
		cnreterr(-1, cms, "could not create signed data");

	memcpy(&cms->newsig, &sd_der, sizeof (cms->newsig));
	cms->newsig.data = malloc(sd_der.len);
	if (!cms->newsig.data)
		cnreterr(-1, cms, "could not allocate signed data");
	memcpy(cms->newsig.data, sd_der.data, sd_der.len);
	return 0;
}

typedef struct {
	SECItem start;
	SECItem end;
} Validity;

static SEC_ASN1Template ValidityTemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof (Validity),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(Validity, start),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(Validity, end),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{ 0 }
};

int
generate_validity(cms_context *cms, SECItem *der, time_t start, time_t end)
{
	Validity validity;
	int rc;

	rc = generate_time(cms, &validity.start, start);
	if (rc < 0)
		return rc;

	rc = generate_time(cms, &validity.end, end);
	if (rc < 0)
		return rc;

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, der, &validity, ValidityTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode validity");
	return 0;
}

static SEC_ASN1Template SetTemplate = {
	.kind = SEC_ASN1_SET_OF,
	.offset = 0,
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem **)
	};

int
wrap_in_set(cms_context *cms, SECItem *der, SECItem **items)
{
	void *ret;

	ret = SEC_ASN1EncodeItem(cms->arena, der, &items, &SetTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode set");
	return 0;
}

static SEC_ASN1Template SeqTemplateTemplate = {
	.kind = SEC_ASN1_ANY,
	.offset = 0,
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem),
	};

static SEC_ASN1Template SeqTemplateHeader = {
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (SECItem)
	};

int
wrap_in_seq(cms_context *cms, SECItem *der, SECItem *items, int num_items)
{
	void *ret;

	void *mark = PORT_ArenaMark(cms->arena);

	SEC_ASN1Template tmpl[num_items+2];

	memcpy(&tmpl[0], &SeqTemplateHeader, sizeof(*tmpl));
	tmpl[0].size = sizeof (SECItem) * num_items;

	for (int i = 0; i < num_items; i++) {
		memcpy(&tmpl[i+1], &SeqTemplateTemplate, sizeof(SEC_ASN1Template));
		tmpl[i+1].offset = (i) * sizeof (SECItem);
	}
	memset(&tmpl[num_items + 1], '\0', sizeof(SEC_ASN1Template));

	int rc = 0;
	ret = SEC_ASN1EncodeItem(cms->arena, der, items, tmpl);
	if (ret == NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cnreterr(-1, cms, "could not encode set");
	}
	PORT_ArenaUnmark(cms->arena, mark);
	return rc;
}

typedef struct {
	SECItem oid;
	SECItem string;
} CommonName;

static SEC_ASN1Template CommonNameTemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof (CommonName),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(CommonName, oid),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(CommonName, string),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{ 0 }
};

int
generate_common_name(cms_context *cms, SECItem *der, char *cn_str)
{
	CommonName cn;
	SECItem cn_item;
	int rc;

	rc = generate_object_id(cms, &cn.oid, SEC_OID_AVA_COMMON_NAME);
	if (rc < 0)
		return rc;
	rc = generate_string(cms, &cn.string, cn_str);
	if (rc < 0)
		return rc;

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, &cn_item, &cn, CommonNameTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode common name");

	SECItem cn_set;
	SECItem *items[2] = {&cn_item, NULL};
	rc = wrap_in_set(cms, &cn_set, items);
	if (rc < 0)
		return rc;
	rc = wrap_in_seq(cms, der, &cn_set, 1);
	if (rc < 0)
		return rc;
	return 0;
}

typedef struct {
	SECItem type;
	SECItem value;
} ava;

static const SEC_ASN1Template AVATemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof (ava),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(ava, type),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(ava, value),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{ 0 }
};

/* I can't figure out how to get a CERTName out in a non-rediculous form, so
 * we wind up encoding the whole thing manually :/ */
static int
generate_ava(cms_context *cms, SECItem *der, CERTAVA *certava)
{
	ava ava;

	SECOidData *oid;

	void *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
	if (arena == NULL)
		cnreterr(-1, cms, "could not create arena");

	void *real_arena = cms->arena;
	cms->arena = arena;

	oid = SECOID_FindOID(&certava->type);
	if (!oid) {
		save_port_err() {
			PORT_FreeArena(arena, PR_TRUE);
		}
		cms->arena = real_arena;
		cnreterr(-1, cms, "could not find OID");
	}

	int rc = generate_object_id(cms, &ava.type, oid->offset);
	if (rc < 0) {
		PORT_FreeArena(arena, PR_TRUE);
		cms->arena = real_arena;
		return -1;
	}

	memcpy(&ava.value, &certava->value, sizeof (ava.value));

	void *ret;
	SECItem tmp;
	ret = SEC_ASN1EncodeItem(arena, &tmp, &ava, AVATemplate);
	if (ret == NULL) {
		save_port_err() {
			PORT_FreeArena(arena, PR_TRUE);
		}
		cms->arena = real_arena;
		cnreterr(-1, cms, "could not encode AVA");
	}

	der->type = tmp.type;
	der->len = tmp.len;
	der->data = PORT_ArenaAlloc(real_arena, tmp.len);
	if (!der->data) {
		save_port_err() {
			PORT_FreeArena(arena, PR_TRUE);
		}
		cms->arena = real_arena;
		cnreterr(-1, cms, "could not allocate AVA");
	}
	memcpy(der->data, tmp.data, tmp.len);
	PORT_FreeArena(arena, PR_TRUE);
	cms->arena = real_arena;

	return 0;
}

int
generate_name(cms_context *cms, SECItem *der, CERTName *certname)
{
	void *marka = PORT_ArenaMark(cms->arena);
	CERTRDN **rdns = certname->rdns;
	CERTRDN *rdn;

	int num_items = 0;
	int rc = 0;

	while (rdns && (rdn = *rdns++) != NULL) {
		CERTAVA **avas = rdn->avas;
		while (avas && ((*avas++) != NULL))
			num_items++;
	}

	if (num_items == 0) {
		PORT_ArenaRelease(cms->arena, marka);
		cnreterr(-1, cms, "No name items to encode");
	}

	SECItem items[num_items];

	int i = 0;
	rdns = certname->rdns;
	while (rdns && (rdn = *rdns++) != NULL) {
		CERTAVA **avas = rdn->avas;
		CERTAVA *ava;
		while (avas && (ava = *avas++) != NULL) {
			SECItem avader;
			rc = generate_ava(cms, &avader, ava);
			if (rc < 0) {
				PORT_ArenaRelease(cms->arena, marka);
				return -1;
			}

			SECItem *list[2] = {
				&avader,
				NULL,
			};
			rc = wrap_in_set(cms, &items[i], list);
			if (rc < 0) {
				PORT_ArenaRelease(cms->arena, marka);
				return -1;
			}
			i++;
		}
	}
	wrap_in_seq(cms, der, &items[0], num_items);
	PORT_ArenaUnmark(cms->arena, marka);

	return 0;
}

typedef struct {
	SECItem oid;
	SECItem url;
} AuthInfo;

static SEC_ASN1Template AuthInfoTemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof (AuthInfo),
	},
	{.kind = SEC_ASN1_OBJECT_ID,
	 .offset = offsetof(AuthInfo, oid),
	 .sub = &SEC_ObjectIDTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(AuthInfo, url),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{ 0 }
};

static SEC_ASN1Template AuthInfoWrapperTemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof (AuthInfo),
	},
	{.kind = SEC_ASN1_OBJECT_ID,
	 .offset = offsetof(AuthInfo, oid),
	 .sub = &SEC_ObjectIDTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(AuthInfo, url),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{ 0 }
};

int
generate_auth_info(cms_context *cms, SECItem *der, char *url)
{
	AuthInfo ai;

	SECOidData *oid = SECOID_FindOIDByTag(SEC_OID_PKIX_CA_ISSUERS);
	if (!oid)
		cnreterr(-1, cms, "could not get CA issuers OID");

	memcpy(&ai.oid, &oid->oid, sizeof (ai.oid));

	SECItem urlitem = {
		.data = (unsigned char *)url,
		.len = strlen(url),
		.type = siBuffer
	};
	int rc = make_context_specific(cms, 6, &ai.url, &urlitem);
	if (rc < 0)
		return rc;

	void *ret;
	SECItem unwrapped;
	ret = SEC_ASN1EncodeItem(cms->arena, &unwrapped, &ai, AuthInfoTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode CA Issuers");

	rc = wrap_in_seq(cms, der, &unwrapped, 1);
	if (rc < 0)
		return rc;
	return 0;

	/* I've no idea how to get SEC_ASN1EncodeItem to spit out the thing
	 * we actually want here.  So once again, just force the data to
	 * look correct :( */
	if (unwrapped.len < 12)
		cnreterr(-1, cms,
			 "generated CA Issuers Info cannot possibly be valid");

	unwrapped.data[12] = 0x86;
	unwrapped.type = siBuffer;

	AuthInfo wrapper;
	oid = SECOID_FindOIDByTag(SEC_OID_X509_AUTH_INFO_ACCESS);
	if (!oid)
		cnreterr(-1, cms, "could not find Auth Info Access OID");

	memcpy(&wrapper.oid, &oid->oid, sizeof (ai.oid));

	wrap_in_seq(cms, &wrapper.url, &unwrapped, 1);

	ret = SEC_ASN1EncodeItem(cms->arena, der, &wrapper,
					AuthInfoWrapperTemplate);
	if (ret == NULL)
		cnreterr(-1, cms, "could not encode CA Issuers OID");

	return 0;
}

int
generate_keys(cms_context *cms, PK11SlotInfo *slot,
		SECKEYPrivateKey **privkey, SECKEYPublicKey **pubkey,
		int key_bits, unsigned long exponent)
{
	PK11RSAGenParams rsaparams = {
		.keySizeInBits = key_bits,
		.pe = exponent,
	};

	SECStatus rv;
	rv = PK11_Authenticate(slot, PR_TRUE, cms);
	if (rv != SECSuccess)
		cnreterr(-1, cms, "could not authenticate with pk11 service");

	void *params = &rsaparams;
	*privkey = PK11_GenerateKeyPair(slot, CKM_RSA_PKCS_KEY_PAIR_GEN,
					params, pubkey, PR_TRUE, PR_TRUE,
					cms);
	if (!*privkey)
		cnreterr(-1, cms, "could not generate RSA keypair");
	return 0;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/cms_common.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * cms_common.h - decls for common parts pf PKCS7 that we need
 *                regardless of the target file type.
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef CMS_COMMON_H
#define CMS_COMMON_H 1

#include <cert.h>
#include <secpkcs7.h>

#include <errno.h>
#include <efivar.h>
#include <signal.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "util.h"
#include "password.h"

#define save_port_err() \
	for (error_t saved_errno_0_ = 0, saved_errno_1_ = PORT_GetError(); saved_errno_0_ < 1; saved_errno_0_++, PORT_SetError(saved_errno_1_))

#define for_each_cert(cl, node) \
	for (CERTCertListNode *node = CERT_LIST_HEAD(cl); !CERT_LIST_END(node, cl); node = CERT_LIST_NEXT(node))

#define cmsreterr(rv, cms, fmt, args...) ({			\
		(cms)->log((cms), LOG_ERR, "%s:%s:%d: " fmt,	\
			__FILE__, __func__, __LINE__ - 2,	\
			## args);				\
		return rv;					\
	})
#define cmsgotoerr(errlabel, cms, fmt, args...) ({		\
		(cms)->log((cms), LOG_ERR, "%s:%s:%d: " fmt,	\
			__FILE__, __func__, __LINE__ - 2,	\
			## args);				\
		goto errlabel;					\
	})
#define cnreterr(rv, cms, fmt, args...) ({				\
		(cms)->log((cms), LOG_ERR, "%s:%s:%d: " fmt ":%s:%s",	\
			__FILE__, __func__, __LINE__ - 2, ## args,	\
			PORT_ErrorToName(PORT_GetError()),		\
			PORT_ErrorToString(PORT_GetError()));		\
		return rv;						\
	})
#define cngotoerr(errlabel, cms, fmt, args...) ({			\
		(cms)->log((cms), LOG_ERR, "%s:%s:%d: " fmt ":%s:%s",	\
			__FILE__, __func__, __LINE__ - 2, ## args,	\
			PORT_ErrorToName(PORT_GetError()),		\
			PORT_ErrorToString(PORT_GetError()));		\
		goto errlabel;						\
	})

struct digest {
	PK11Context *pk11ctx;
	SECItem *pe_digest;
};

#define DIGEST_PARAM_SHA256	0
#define DIGEST_PARAM_SHA1	1
#define DEFAULT_DIGEST_PARAM	DIGEST_PARAM_SHA256

struct digest_param {
	char *name;
	SECOidTag digest_tag;
	SECOidTag signature_tag;
	SECOidTag digest_encryption_tag;
	const efi_guid_t *efi_guid;
	int size;
};

extern const struct digest_param digest_params[2];
extern const unsigned int n_digest_params;

typedef struct pk12_file {
	char *path;
	int fd;
	char *pw;
	struct list_head list;
} pk12_file_t;

struct token_pass {
	char *token;
	char *pass;
};

struct pw_database {
	struct token_pass *phrases;
	size_t nphrases;
};

typedef enum {
	// used only for bounds checking
	PW_SOURCE_INVALID = 0,
	// prompt the user (pwdata->data is NULL)
	PW_PROMPT = 1,
	// prompt the user to use a device (pwdata->data is NULL)
	PW_DEVICE = 2,
	// pwdata->data is plain text
	PW_PLAINTEXT = 3,
	// pwdata->data is a filename for a database
	PW_FROMFILEDB = 4,
	// pwdata->data is the database data
	PW_DATABASE = 5,
	// pwdata->data is the name of an environment variable
	PW_FROMENV = 6,
	// pwdata->data is the path of a file
	PW_FROMFILE = 7,
	// pwdata->intdata is a file descriptor
	PW_FROMFD = 8,

	// used only for bounds checking
	PW_SOURCE_MAX
} pw_source_t;

typedef struct {
	pw_source_t source;
	pw_source_t orig_source;

	struct pw_database pwdb;
	char *data;
	long intdata;
} secuPWData;

struct cms_context;

typedef int (*cms_common_logger)(struct cms_context *, int priority,
		char *fmt, ...) PRINTF(3, 4);

typedef struct cms_context {
	PRArenaPool *arena;
	void *privkey;

	char *tokenname;
	char *certname;
	CERTCertificate *cert;
	PK11SlotListElement *psle;
	PK11PasswordFunc func;
	secuPWData pwdata;

	list_t pk12_ins;
	pk12_file_t pk12_out;
	int db_out, dbx_out, dbt_out;

	struct digest *digests;
	unsigned int selected_digest;
	int omit_vendor_cert;

	SECItem newsig;

	SECItem *ci_digest;

	SECItem *raw_signed_attrs;
	SECItem *raw_signature;

	int num_signatures;
	SECItem **signatures;

	int authbuf_len;
	void *authbuf;

	cms_common_logger log;
	void *log_priv;
} cms_context;

typedef enum {
	SpcLinkYouHaveFuckedThisUp = 0,
	SpcLinkTypeUrl = 1,
	SpcLinkTypeFile = 2,
} SpcLinkType;

typedef struct {
	SpcLinkType type;
	union {
		SECItem url;
		SECItem file;
	};
} SpcLink;
extern SEC_ASN1Template SpcLinkTemplate[];

extern int cms_context_alloc(cms_context **ctxp);
extern int cms_context_init(cms_context *ctx);
extern void cms_context_fini(cms_context *ctx);

extern void teardown_digests(cms_context *ctx);

extern int generate_octet_string(cms_context *ctx, SECItem *encoded,
				SECItem *original);
extern int generate_object_id(cms_context *ctx, SECItem *encoded,
				SECOidTag tag);
extern int generate_empty_sequence(cms_context *ctx, SECItem *encoded);
extern int generate_time(cms_context *ctx, SECItem *encoded, time_t when);
extern int generate_string(cms_context *cms, SECItem *der, char *str);
extern int wrap_in_set(cms_context *cms, SECItem *der, SECItem **items);
extern int wrap_in_seq(cms_context *cms, SECItem *der,
			SECItem *items, int num_items);
extern int make_context_specific(cms_context *cms, int ctxt, SECItem *encoded,
			SECItem *original);
extern int make_eku_oid(cms_context *cms, SECItem *encoded, SECOidTag oid_tag);
extern int generate_validity(cms_context *cms, SECItem *der, time_t start,
				time_t end);
extern int generate_common_name(cms_context *cms, SECItem *der, char *cn);
extern int generate_auth_info(cms_context *cms, SECItem *der, char *url);
extern int generate_algorithm_id(cms_context *ctx, SECAlgorithmID *idp,
				SECOidTag tag);
extern int generate_spc_link(cms_context *cms, SpcLink *slp,
				SpcLinkType link_type, void *link_data,
				size_t link_data_size);

extern int generate_spc_string(cms_context *cms, SECItem *ssp, char *str,
				int len);

extern int generate_digest(cms_context *cms, Pe *pe, int padded);
extern int generate_signature(cms_context *ctx);
extern int unlock_nss_token(cms_context *ctx);
extern int find_certificate(cms_context *ctx, int needs_private_key);
extern int generate_keys(cms_context *cms, PK11SlotInfo *slot,
		SECKEYPrivateKey **privkey, SECKEYPublicKey **pubkey,
		int key_bits, unsigned long exponent);
extern int is_issuer_of(CERTCertificate *c0, CERTCertificate *c1);

typedef int (find_cert_match_t)(CERTCertificate *cert, void *cbdata);
extern int find_certificate_by_callback(cms_context *cms,
					find_cert_match_t *match, void *cbdata,
					CERTCertificate **cert);

extern int find_named_certificate(cms_context *cms, char *name,
				CERTCertificate **cert);
extern int find_certificate_by_issuer_and_sn(cms_context *cms,
					     CERTIssuerAndSN *ias,
					     CERTCertificate **cert);

extern int find_slot_for_token(cms_context *cms, PK11SlotInfo **slot);

extern SECOidTag digest_get_digest_oid(cms_context *cms);
extern SECOidTag digest_get_encryption_oid(cms_context *cms);
extern SECOidTag digest_get_signature_oid(cms_context *cms);
extern int digest_get_digest_size(cms_context *cms);
extern void cms_set_pw_callback(cms_context *cms, PK11PasswordFunc func);
extern void cms_set_pw_data(cms_context *cms, secuPWData *pwdata);

extern int set_digest_parameters(cms_context *ctx, char *name);

extern int generate_digest_begin(cms_context *cms);
extern void generate_digest_step(cms_context *cms, void *data, size_t len);
extern int generate_digest_finish(cms_context *cms);

#endif /* CMS_COMMON_H */
// vim:fenc=utf-8:tw=75:noet

```

`src/cms_pe_common.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * cms_pe_common.c - common decls for the PE CMS implementation
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <syslog.h>

#include "pesign.h"

#include <prerror.h>
#include <nss.h>
#include <secport.h>
#include <secpkcs7.h>
#include <secder.h>
#include <keyhi.h>
#include <base64.h>
#include <pk11pub.h>
#include <secerr.h>
#include <certt.h>

static int
check_pointer_and_size(cms_context *cms, Pe *pe, void *ptr, size_t size)
{
	void *map = NULL;
	size_t map_size = 0;
	unsigned long p, m;

	map = pe_rawfile(pe, &map_size);
	if (!map || map_size < 1)
		cmsreterr(0, cms, "mmap is %p mmap size is %zd end is %p",
			  map, map_size, (void *)((uintptr_t)map + map_size));

	p = (unsigned long)(uintptr_t)ptr;
	m = (unsigned long)(uintptr_t)map;

	if (p < m)
		cmsreterr(0, cms, "pointer %p is below mmap at %p", ptr, map);

	if (p + size > m + map_size)
		cmsreterr(0, cms,
			  "pointer %p is above mmap end at %p (%lu is %lu bytes past EOF at %zu)",
			  (void *)((uintptr_t)p + size),
			  (void *)((uintptr_t)m + map_size),
			  p + size - m,
			  p + size - (m + map_size),
			  map_size);

	return 1;
}

static void *
get_strtab(cms_context *cms, Pe *pe)
{
	static void *ret = NULL;
	uint32_t *ptr;
	intptr_t intret = 0;
	struct pe_hdr pehdr;
	void *map = NULL;
	size_t map_size = 0;

	if (ret)
		return ret;

	if (pe_getpehdr(pe, &pehdr) == NULL)
		pereterr(NULL, "invalid PE file header");

	map = pe_rawfile(pe, &map_size);
	if (!map || map_size < 1)
		return 0;

	if (pehdr.symbol_table == 0)
		return NULL;

	intret = (intptr_t)pehdr.symbol_table;
	intret += pehdr.symbols * sizeof(struct pe_symtab_entry);

	ptr = (uint32_t *)((intptr_t)map + intret);
	if (!check_pointer_and_size(cms, pe, ptr, 4))
		pereterr(NULL, "invalid string table start");

	if (!check_pointer_and_size(cms, pe, ptr, *ptr))
		pereterr(NULL, "invalid string table size");
	ret = ptr;
	return ret;
}

static char *
get_str(cms_context *cms, Pe *pe, char *strnum)
{
	size_t sz;
	unsigned long num;
	char *strtab;
	uint32_t strtabsz;

	/* no idea what the real max size for these is, so... we're not going
	 * to have 4B strings, and this can't be the end of the binary, so
	 * this is big enough. */
	sz = strnlen(strnum, 11);
	if (sz == 11)
		return NULL;

	errno = 0;
	num = strtoul(strnum, NULL, 10);
	if (errno != 0)
		return NULL;

	strtab = get_strtab(cms, pe);
	if (!strtab)
		return NULL;

	strtabsz = *(uint32_t *)strtab;
	if (num >= strtabsz)
		return NULL;

	if (strnlen(&strtab[num], strtabsz - num) > strtabsz - num - 1)
		return NULL;

	return &strtab[num];
}

int
generate_digest(cms_context *cms, Pe *pe, int padded)
{
	void *hash_base;
	size_t hash_size;
	struct pe32_opt_hdr *pe32opthdr = NULL;
	struct pe32plus_opt_hdr *pe64opthdr = NULL;
	unsigned long hashed_bytes = 0;
	void *opthdr;
	int rc = -1;

	if (!pe) {
		cms->log(cms, LOG_ERR, "no output pe ready");
		return -1;
	}

	rc = generate_digest_begin(cms);
	if (rc < 0)
		return rc;

	struct pe_hdr pehdr;
	if (pe_getpehdr(pe, &pehdr) == NULL)
		pereterr(-1, "invalid PE file header");

	void *map = NULL;
	size_t map_size = 0;

	/* 1. Load the image header into memory - should be done
	 * 2. Initialize SHA hash context. */
	map = pe_rawfile(pe, &map_size);
	if (!map)
		cmsreterr(-1, cms, "could not get raw output file address");

	/* 3. Calculate the distance from the base of the image header to the
	 * image checksum.
	 * 4. Hash the image header from start to the beginning of the
	 * checksum. */
	hash_base = map;

	opthdr = pe_getopthdr(pe);
	if (opthdr == NULL)
		cmsgotoerr(error, cms, "PE header is invalid");

	switch (pe_kind(pe)) {
	case PE_K_PE_EXE: {
		pe32opthdr = opthdr;
		hash_size = (uintptr_t)&pe32opthdr->csum - (uintptr_t)hash_base;
		break;
	}
	case PE_K_PE64_EXE: {
		pe64opthdr = opthdr;
		hash_size = (uintptr_t)&pe64opthdr->csum - (uintptr_t)hash_base;
		break;
	}
	default:
		goto error;
	}
	if (!check_pointer_and_size(cms, pe, hash_base, hash_size))
		cmsgotoerr(error, cms, "PE header is invalid");
	dbgprintf("beginning of hash");
	dbgprintf("digesting %tx + %zx", hash_base - map, hash_size);
	generate_digest_step(cms, hash_base, hash_size);

	/* 5. Skip over the image checksum
	 * 6. Get the address of the beginning of the cert dir entry
	 * 7. Hash from the end of the csum to the start of the cert dirent. */
	hash_base += hash_size;
	hash_base += pe32opthdr ? sizeof(pe32opthdr->csum)
				: sizeof(pe64opthdr->csum);
	data_directory *dd;

	rc = pe_getdatadir(pe, &dd);
	if (rc < 0 || !dd || !check_pointer_and_size(cms, pe, dd, sizeof(*dd)))
		cmsgotoerr(error, cms, "PE data directory is invalid");

	hash_size = (uintptr_t)&dd->certs - (uintptr_t)hash_base;
	if (!check_pointer_and_size(cms, pe, hash_base, hash_size))
		cmsgotoerr(error, cms, "PE data directory is invalid");

	generate_digest_step(cms, hash_base, hash_size);
	dbgprintf("digesting %tx + %zx", hash_base - map, hash_size);

	/* 8. Skip over the crt dir
	 * 9. Hash everything up to the end of the image header. */
	hash_base = &dd->base_relocations;
	hash_size = (pe32opthdr ? pe32opthdr->header_size
				: pe64opthdr->header_size) -
		((uintptr_t)&dd->base_relocations - (uintptr_t)map);

	if (!check_pointer_and_size(cms, pe, hash_base, hash_size))
		cmsgotoerr(error, cms, "PE relocations table is invalid");

	generate_digest_step(cms, hash_base, hash_size);
	dbgprintf("digesting %tx + %zx", hash_base - map, hash_size);

	/* 10. Set SUM_OF_BYTES_HASHED to the size of the header. */
	hashed_bytes = pe32opthdr ? pe32opthdr->header_size
				: pe64opthdr->header_size;

	struct section_header *shdrs = calloc(pehdr.sections, sizeof (*shdrs));
	if (!shdrs)
		goto error;
	Pe_Scn *scn = NULL;
	for (int i = 0; i < pehdr.sections; i++) {
		scn = pe_nextscn(pe, scn);
		if (scn == NULL)
			break;
		pe_getshdr(scn, &shdrs[i]);
	}
	sort_shdrs(shdrs, pehdr.sections - 1);

	for (int i = 0; i < pehdr.sections; i++) {
		if (shdrs[i].raw_data_size == 0)
			continue;

		hash_base = (void *)((uintptr_t)map + shdrs[i].data_addr);
		hash_size = shdrs[i].raw_data_size;

		if (!check_pointer_and_size(cms, pe, hash_base, hash_size))
			cmsgotoerr(error_shdrs, cms,
				   "PE section \"%s\" has invalid address",
				   shdrs[i].name);

		if (cms->omit_vendor_cert) {
			char *name = shdrs[i].name;
			if (name && name[0] == '/')
				name = get_str(cms, pe, name + 1);
			dbgprintf("section:\"%s\"", name ? name : "(null)");
			if (name && !strcmp(name, ".vendor_cert")) {
				dbgprintf("skipping .vendor_cert section");
				hashed_bytes += hash_size;
				continue;
			}
		}

		generate_digest_step(cms, hash_base, hash_size);
		dbgprintf("digesting %tx + %zx", hash_base - map, hash_size);

		hashed_bytes += hash_size;
	}

	if (map_size > hashed_bytes) {
		hash_base = (void *)((uintptr_t)map + hashed_bytes);
		hash_size = map_size - dd->certs.size - hashed_bytes;

		if (!check_pointer_and_size(cms, pe, hash_base, hash_size))
			cmsgotoerr(error_shdrs, cms,
				   "PE has invalid trailing data");

		if (hash_size % 8 != 0 && padded) {
			size_t tmp_size = hash_size +
					  ALIGNMENT_PADDING(hash_size, 8);
			uint8_t tmp_array[tmp_size];
			memset(tmp_array, '\0', tmp_size);
			memcpy(tmp_array, hash_base, hash_size);
			generate_digest_step(cms, tmp_array, tmp_size);
			dbgprintf("digesting %tx + %zx", (ptrdiff_t)tmp_array,
				tmp_size);
		} else {
			generate_digest_step(cms, hash_base, hash_size);
			dbgprintf("digesting %tx + %zx", hash_base - map,
				hash_size);
		}
	}
	dbgprintf("end of hash");

	rc = generate_digest_finish(cms);
	if (rc < 0)
		goto error_shdrs;

	if (shdrs) {
		free(shdrs);
		shdrs = NULL;
	}

	return 0;

error_shdrs:
	if (shdrs)
		free(shdrs);
error:
	return -1;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/compiler.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * compiler.h - a bunch of helpers for compiler-related stuff
 * Copyright Peter Jones <pjones@redhat.com>
 */
#ifndef COMPILER_H_
#define COMPILER_H_

#include <sys/cdefs.h>

#define UNUSED __attribute__((__unused__))
#define HIDDEN __attribute__((__visibility__ ("hidden")))
#define PUBLIC __attribute__((__visibility__ ("default")))
#define DESTRUCTOR __attribute__((destructor))
#define CONSTRUCTOR __attribute__((constructor))
#define ALIAS(x) __attribute__((weak, alias (#x)))
#define NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#define PRINTF(...) __attribute__((__format__(printf, __VA_ARGS__)))
#define FLATTEN __attribute__((__flatten__))
#define PACKED __attribute__((__packed__))
#define VERSION(sym, ver) __asm__(".symver " # sym "," # ver)
#define NORETURN __attribute__((__noreturn__))
#define ALIGNED(n) __attribute__((__aligned__(n)))
#define CLEANUP_FUNC(x) __attribute__((__cleanup__(x)))

#ifndef __CONCAT
#define __CONCAT(a, b) a ## b
#endif
#define __CONCAT3(a, b, c) a ## b ## c
#define CONCATENATE(a, b) __CONCAT(a, b)
#define CAT(a, b) __CONCAT(a, b)
#define CAT3(a, b, c) __CONCAT3(a, b, c)
#define STRING(x) __STRING(x)

#define WRITE_ONCE(var, val) \
        (*((volatile typeof(val) *)(&(var))) = (val))

#define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))

#define likely(x)	__builtin_expect(!!(x), 1)
#define unlikely(x)	__builtin_expect(!!(x), 0)

/* Are two types/vars the same type (ignoring qualifiers)? */
#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))

/* Compile time object size, -1 for unknown */
#ifndef __compiletime_object_size
# define __compiletime_object_size(obj) -1
#endif
#ifndef __compiletime_warning
# define __compiletime_warning(message)
#endif
#ifndef __compiletime_error
# define __compiletime_error(message)
#endif

#define __compiletime_assert(condition, msg, prefix, suffix)		\
	do {								\
		extern void prefix ## suffix(void) __compiletime_error(msg); \
		if (!(condition))					\
			prefix ## suffix();				\
	} while (0)

#define _compiletime_assert(condition, msg, prefix, suffix) \
	__compiletime_assert(condition, msg, prefix, suffix)

/**
 * compiletime_assert - break build and emit msg if condition is false
 * @condition: a compile-time constant condition to check
 * @msg:       a message to emit if condition is false
 *
 * In tradition of POSIX assert, this macro will break the build if the
 * supplied condition is *false*, emitting the supplied error message if the
 * compiler has support to do so.
 */
#define compiletime_assert(condition, msg) \
	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

/**
 * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
 *		      error message.
 * @condition: the condition which the compiler should know is false.
 *
 * See BUILD_BUG_ON for description.
 */
#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)

#define __ALIGN_MASK(x, mask)   (((x) + (mask)) & ~(mask))
#define __ALIGN(x, a)           __ALIGN_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)             __ALIGN((x), (a))
#define ALIGN_DOWN(x, a)        __ALIGN((x) - ((a) - 1), (a))

#define ALIGNMENT_PADDING(value, align) ((align - (value % align)) % align)
#define ALIGN_UP(value, align) ((value) + ALIGNMENT_PADDING(value, align))

#endif /* !COMPILER_H_ */
// vim:fenc=utf-8:tw=75:noet

```

`src/content_info.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * content_info.c - implement the authenticode content_info structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "pesign.h"

#include <stddef.h>
#include <syslog.h>

#include <prerror.h>
#include <cms.h>
#include <pk11pub.h>

#include "content_info_priv.h"

/* This generates to the DER for a SpcPeImageData, which includes the two
 * DER chunks generated above. Output is basically:
 *
 *       C-Sequence (37)
 *          Bit String (1)
 *            00
 *          C-[0]  (32)
 *             C-[2]  (30)
 *                [0]  (28)
 *                   00 3c 00 3c 00 3c 00 4f 00 62 00 73 00
 *                   6f 00 6c 00 65 00 74 00 65 00 3e 00 3e
 *                   00 3e
 * The Bit String output is a cheap hack; I can't figure out how to get the
 * length right using DER_BIT_STRING in the template; it always comes out as
 * 07 00 instead of just 00. So instead, since it's /effectively/ constant,
 * I just picked DER_NULL since it'll always come out to the right size, and
 * then manually bang DER_BIT_STRING into the type in the encoded output.
 * I'm so sorry. -- pjones
 */
SEC_ASN1Template SpcPeImageDataTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (SpcPeImageData),
	},
	{
	.kind = SEC_ASN1_NULL,
	.offset = offsetof(SpcPeImageData, flags),
	.sub = NULL,
	.size = 1
	},
	{
	.kind = SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_EXPLICIT,
	.offset = offsetof(SpcPeImageData, link),
	.sub = &SpcLinkTemplate,
	.size = sizeof (SpcLink),
	},
	{ 0, }
};

static int
generate_spc_pe_image_data(cms_context *cms, SECItem *spidp)
{
	SpcPeImageData spid;

	SECITEM_AllocItem(cms->arena, &spid.flags, 1);
	if (!spid.flags.data)
		return -1;
	spid.flags.data[0] = 0;

	char obsolete[28] = "";
	int rc;
	rc = generate_spc_link(cms, &spid.link, SpcLinkTypeFile, obsolete, 0);
	if (rc < 0)
		return rc;

	if (SEC_ASN1EncodeItem(cms->arena, spidp, &spid,
			SpcPeImageDataTemplate) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode SpcPeImageData: %s",
			PORT_ErrorToString(PORT_GetError()));
		return -1;
	}

	/* XXX OMG FIX THIS */
	/* manually bang it from NULL to BIT STRING because I can't figure out
	 * how to make the fucking templates work right for the bitstring size
	 */
	spidp->data[2] = DER_BIT_STRING;
	return 0;
}

SEC_ASN1Template SpcAttributeTypeAndOptionalValueTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (SpcAttributeTypeAndOptionalValue)
	},
	{
	.kind = SEC_ASN1_OBJECT_ID,
	.offset = offsetof(SpcAttributeTypeAndOptionalValue, contentType),
	.sub = &SEC_ObjectIDTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_OPTIONAL |
		SEC_ASN1_ANY,
	.offset = offsetof(SpcAttributeTypeAndOptionalValue, value),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem),
	},
	{ 0, }
};

/* Generate DER for SpcAttributeTypeAndValue, which is basically just
 * a DER_SEQUENCE containing the OID 1.3.6.1.4.1.311.2.1.15
 * (SPC_PE_IMAGE_DATA_OBJID) and the SpcPeImageData.
 */
static int
generate_spc_attribute_yadda_yadda(cms_context *cms, SECItem *ataovp)
{
	SpcAttributeTypeAndOptionalValue ataov;
	memset(&ataov, '\0', sizeof (ataov));

	int rc;

	rc = get_ms_oid_secitem(SPC_PE_IMAGE_DATA_OBJID, &ataov.contentType);
	if (rc < 0) {
		cms->log(cms, LOG_ERR, "could not get SPC_PE_IMAGE_DATA_OBJID");
		return -1;
	}

	rc = generate_spc_pe_image_data(cms, &ataov.value);
	if (rc < 0)
		return rc;

	if (SEC_ASN1EncodeItem(cms->arena, ataovp, &ataov,
			SpcAttributeTypeAndOptionalValueTemplate) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode "
			"SpcAttributeTypeAndOptionalValue: %s",
			PORT_ErrorToString(PORT_GetError()));

		return -1;
	}
	return 0;
}

/* Generate the DigestInfo, which is a sequence containing a AlgorithmID
 * and an Octet String of the binary's hash in that algorithm. For some
 * reason this is the only place I could really get template chaining to
 * work right. It's probably my on defficiency.
 */
SEC_ASN1Template DigestInfoTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = 0
	},
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(DigestInfo, digestAlgorithm),
	.sub = &SECOID_AlgorithmIDTemplate,
	.size = sizeof (SECAlgorithmID),
	},
	{
	.kind = SEC_ASN1_OCTET_STRING,
	.offset = offsetof(DigestInfo, digest),
	.sub = NULL,
	.size = sizeof (SECItem)
	},
	{ 0, }
};

static int
generate_spc_digest_info(cms_context *cms, SECItem *dip)
{
	DigestInfo di;
	memset(&di, '\0', sizeof (di));

	if (generate_algorithm_id(cms, &di.digestAlgorithm,
			digest_get_digest_oid(cms)) < 0)
		return -1;
	unsigned int i = cms->selected_digest;
	memcpy(&di.digest, cms->digests[i].pe_digest, sizeof (di.digest));

	if (content_is_empty(di.digest.data, di.digest.len)) {
		cms->log(cms, LOG_ERR, "got empty digest");
		return -1;
	}

	if (SEC_ASN1EncodeItem(cms->arena, dip, &di,
						DigestInfoTemplate) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode DigestInfo: %s",
			PORT_ErrorToString(PORT_GetError()));
		return -1;
	}
	return 0;
}

/* Generate DER for SpcIndirectDataContent. It's just a DER_SEQUENCE that
 * holds the digestInfo above and the SpcAttributeTypeAndValue, also above.
 * Sequences, all the way down.
 *
 * This also generates the actual DER for SpcContentInfo, and is a public
 * function. SpcContentInfo is another sequence that holds a OID,
 * 1.3.6.1.4.1.311.2.1.4 (SPC_INDIRECT_DATA_OBJID) and then a reference to
 * the generated SpcIndirectDataContent structure.
 */
SEC_ASN1Template SpcIndirectDataContentTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = 0,
	},
	{
	.kind = SEC_ASN1_ANY |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SpcIndirectDataContent, data),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_ANY |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SpcIndirectDataContent, messageDigest),
	.sub = &DigestInfoTemplate,
	.size = sizeof (SECItem)
	},
	{ 0, }
};

static int
generate_spc_indirect_data_content(cms_context *cms, SECItem *idcp)
{
	SpcIndirectDataContent idc;
	memset(&idc, '\0', sizeof (idc));
	int rc;

	rc = generate_spc_attribute_yadda_yadda(cms, &idc.data);
	if (rc < 0)
		return rc;

	rc = generate_spc_digest_info(cms, &idc.messageDigest);
	if (rc < 0) {
		SECITEM_FreeItem(&idc.data, PR_FALSE);
		return rc;
	}

	if (SEC_ASN1EncodeItem(cms->arena, idcp, &idc,
			SpcIndirectDataContentTemplate) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode "
			"SpcIndirectDataContent: %s",
			PORT_ErrorToString(PORT_GetError()));
		return -1;
	}
	return 0;
}

const SEC_ASN1Template SpcContentInfoTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (SpcContentInfo)
	},
	{
	.kind = SEC_ASN1_OBJECT_ID,
	.offset = offsetof(SpcContentInfo, contentType),
	.sub = NULL,
	.size = 0,
	},
	{
	.kind = SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SpcContentInfo, content),
	.sub = &SEC_OctetStringTemplate,
	.size = sizeof (SECItem),
	},
	{ 0, }
};

static int
generate_cinfo_digest(cms_context *cms, SpcContentInfo *cip)
{
	/* I have exactly no idea why the thing I need to digest is 2 bytes
	 * in to the content data, but the hash winds up identical to what
	 * Microsoft is embedding in their binaries if I do, so I'm calling
	 * that "correct", where "correct" means "there's not enough booze
	 * in the world."
	 */
	SECItem encoded = {
		.type = cip->content.type,
		.data = cip->content.data + 2,
		.len = cip->content.len - 2
	};
	
	PK11Context *ctx = NULL;
	SECOidData *oid = SECOID_FindOIDByTag(digest_get_digest_oid(cms));
	if (oid == NULL)
		return -1;

	cms->ci_digest = SECITEM_AllocItem(cms->arena, NULL,
					digest_get_digest_size(cms));
	if (!cms->ci_digest)
		goto err;

	ctx = PK11_CreateDigestContext(oid->offset);
	if (ctx == NULL)
		goto err;

	if (PK11_DigestBegin(ctx) != SECSuccess)
		goto err;
	if (PK11_DigestOp(ctx, encoded.data, encoded.len) != SECSuccess)
		goto err;
	if (PK11_DigestFinal(ctx, cms->ci_digest->data,
				&cms->ci_digest->len,
				digest_get_digest_size(cms)) != SECSuccess)
		goto err;

	if (content_is_empty(cms->ci_digest->data, cms->ci_digest->len)) {
		cms->log(cms, LOG_ERR, "generated empty digest");
		goto err;
	}

	if ((long long)cms->ci_digest->len > digest_get_digest_size(cms))
		goto err;

	PK11_DestroyContext(ctx, PR_TRUE);
#if 0
	SECITEM_FreeItem(&encoded, PR_FALSE);
#endif
	return 0;
err:
	if (ctx)
		PK11_DestroyContext(ctx, PR_TRUE);
#if 0
	if (cms->ci_digest)
		SECITEM_FreeItem(cms->ci_digest, PR_TRUE);
	if (encoded.data)
		SECITEM_FreeItem(&encoded, PR_FALSE);
#endif
	return -1;
}

int
generate_spc_content_info(cms_context *cms, SpcContentInfo *cip)
{
	if (!cip)
		return -1;

	SpcContentInfo ci;
	memset(&ci, '\0', sizeof (ci));

	int rc;
	rc = get_ms_oid_secitem(SPC_INDIRECT_DATA_OBJID, &ci.contentType);
	if (rc < 0) {
		cms->log(cms, LOG_ERR, "could not get OID for "
			"SPC_INDIRECT_DATA_OBJID");
		return rc;
	}

	rc = generate_spc_indirect_data_content(cms, &ci.content);
	if (rc < 0)
		return rc;

	memcpy(cip, &ci, sizeof *cip);

	rc = generate_cinfo_digest(cms, cip);
	if (rc < 0)
		return rc;

	return 0;
}

int
generate_authvar_content_info(cms_context *cms, SpcContentInfo *cip)
{
	SECOidData *oid;

	if (!cip)
		return -1;

	SpcContentInfo ci;
	memset(&ci, '\0', sizeof (ci));

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS7_DATA);
	if (oid == NULL) {
		cms->log(cms, LOG_ERR, "could not get OID for "
			"SEC_OID_PKCS7_DATA");
		return -1;
	}
	if (SECITEM_CopyItem(cms->arena, &ci.contentType, &oid->oid))
		return -1;

	ci.content.len = 0;
	ci.content.data = NULL;

	memcpy(cip, &ci, sizeof *cip);

	return 0;
}

void
free_spc_content_info(cms_context *cms UNUSED,
		      SpcContentInfo *cip UNUSED)
{
#if 0
	SECITEM_FreeItem(&cip->contentType, PR_TRUE);
	SECITEM_FreeItem(&cip->content, PR_TRUE);
#endif
}

/* There's nothing else here. */

```

`src/content_info.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * content_info.h - types and decls to implement the authenticode
 *                  content_info structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef CONTENT_INFO_H
#define CONTENT_INFO_H 1

#include <secder.h>
#include <secoid.h>
#include <secasn1.h>

#include <stdint.h>

struct SpcContentInfo {
	SECItem contentType;
	SECItem content;
};
typedef struct SpcContentInfo SpcContentInfo;
extern const SEC_ASN1Template SpcContentInfoTemplate[];

extern int generate_spc_content_info(cms_context *cms, SpcContentInfo *cip);
extern void free_spc_content_info(cms_context *cms, SpcContentInfo *cip);
extern int register_content_info(void);
extern int generate_authvar_content_info(cms_context *cms, SpcContentInfo *cip);

#endif /* CONTENT_INFO_H */

```

`src/content_info_priv.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * content_info_priv.h - private types and decls to implement the authenticode
 *                       content_info structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef CONTENT_INFO_PRIV_H
#define CONTENT_INFO_PRIV_H 1

typedef struct {
	SECItem flags;
} SpcPeImageFlags;
extern SEC_ASN1Template SpcAttributeTypeAndOptionalValueTemplate[];

typedef struct {
	SECItem flags;
	SpcLink link;
} SpcPeImageData;

typedef struct _SpcAttributeTypeAndOptionalValue {
	SECItem contentType;
	SECItem value;
} SpcAttributeTypeAndOptionalValue;

typedef struct {
	SECAlgorithmID digestAlgorithm;
	SECItem digest;
} DigestInfo;
extern SEC_ASN1Template DigestInfoTemplate[];

typedef struct {
	SECItem data;
	SECItem messageDigest;
} SpcIndirectDataContent;
extern SEC_ASN1Template SpcIndirectDataContentTemplate[];

#endif /* CONTENT_INFO_PRIV_H */

```

`src/daemon.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * daemon.c - pesign's signing daemon
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <syslog.h>
#include <unistd.h>
#include <grp.h>

#include "pesign.h"
#include "file_kmod.h"

#include <prerror.h>
#include <nss.h>

static int should_exit = 0;

typedef struct {
	cms_context *cms;
	cms_context *backup_cms;
	uid_t uid;
	gid_t gid;
	pid_t pid;
	int sd;
	int priority;
	char *errstr;
	uint8_t **tokennames;
	int ntokennames;
} context;

static void
steal_from_cms(cms_context *old, cms_context *new)
{
	new->tokenname = old->tokenname;
	new->certname = old->certname;

	new->selected_digest = old->selected_digest;

	new->log = old->log;
	new->log_priv = old->log_priv;
}

static void
hide_stolen_goods_from_cms(cms_context *new,
			   cms_context *old UNUSED)
{
	new->tokenname = NULL;
	new->certname = NULL;
}

static void
send_response(context *ctx, cms_context *cms, struct pollfd *pollfd, int32_t rc)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;
	int msglen = ctx->errstr ? strlen(ctx->errstr) + 1 : 0;

	iov.iov_len = sizeof(pesignd_msghdr) + sizeof(pesignd_cmd_response)
			+ msglen;

	void *buffer = calloc(1, iov.iov_len);
	if (!buffer) {
		cms->log(cms, ctx->priority|LOG_ERR,
			"could not allocate memory: %m");
		exit(1);
	}

	iov.iov_base = buffer;

	pesignd_msghdr *pm = buffer;
	pesignd_cmd_response *resp = (pesignd_cmd_response *)((uint8_t *)pm +
					offsetof(pesignd_msghdr, size) +
					sizeof (pm->size));

	pm->version = PESIGND_VERSION;
	pm->command = CMD_RESPONSE;
	pm->size = sizeof(resp->rc) + msglen;

	memset(&msg, '\0', sizeof(msg));
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	resp->rc = rc;
	if (ctx->errstr)
		memcpy(resp->errmsg, ctx->errstr, msglen);

	n = sendmsg(pollfd->fd, &msg, 0);
	if (n < 0)
		cms->log(cms, ctx->priority|LOG_WARNING,
			"could not send response to client: %m");

	free(buffer);
}

static void
handle_kill_daemon(context *ctx UNUSED,
		   struct pollfd *pollfd UNUSED,
		   socklen_t size UNUSED)
{
	should_exit = 1;
}

static int
cmpstringp(const void *p1, const void *p2)
{
	return strcmp(*(char * const *)p1, *(char * const *)p2);
}

static int
add_token_to_authenticated_list(context *ctx, uint8_t *tokenname)
{
	char *tmp;
	uint8_t **newtokennames = realloc(ctx->tokennames,
					sizeof (uint8_t *)
					* (ctx->ntokennames+1));
	if (!newtokennames)
		return -1;
	ctx->tokennames = newtokennames;

	tmp = strdup((char *)tokenname);
	if (!tmp)
		return -1;

	newtokennames[ctx->ntokennames++] = (uint8_t *)tmp;

	qsort(newtokennames, ctx->ntokennames, sizeof (char *), cmpstringp);
	return 0;
}

static void
handle_unlock_token(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;
	char *pin = NULL;

	int rc = cms_context_alloc(&ctx->cms);
	if (rc < 0) {
		send_response(ctx, ctx->backup_cms, pollfd, rc);
		return;
	}

	steal_from_cms(ctx->backup_cms, ctx->cms);

	char *buffer = malloc(size);
	if (!buffer) {
oom:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unable to allocate memory: %m");
		exit(1);
	}

	memset(&msg, '\0', sizeof(msg));

	iov.iov_base = buffer;
	iov.iov_len = size;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);

	pesignd_string *tn = (pesignd_string *)buffer;
	if (n < (long long)sizeof(tn->size)) {
malformed:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unlock-token: invalid data");
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"possible exploit attempt. closing.");
		close(pollfd->fd);
		return;
	}
	n -= sizeof(tn->size);
	if ((size_t)n < tn->size)
		goto malformed;
	n -= tn->size;

	if (tn->value[tn->size - 1] != '\0')
		goto malformed;

	pesignd_string *tp = pesignd_string_next(tn);
	if ((size_t)n < sizeof(tp->size))
		goto malformed;
	n -= sizeof(tp->size);
	if ((size_t)n < tp->size)
		goto malformed;
	n -= tp->size;

	if (tn->value[tn->size - 1] != '\0')
		goto malformed;

	if (n != 0)
		goto malformed;

	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
		"unlocking token \"%s\"", tn->value);

	/* authenticating with nss frees this ... best API ever. */
	ctx->cms->tokenname = PORT_ArenaStrdup(ctx->cms->arena,
						(char *)tn->value);
	if (!ctx->cms->tokenname)
		goto oom;

	pin = strndup((char *)tp->value, tp->size);
	if (!pin)
		goto oom;

	secuPWData pwdata;

	memset(&pwdata, 0, sizeof(pwdata));
	pwdata.source = pwdata.orig_source = PW_PLAINTEXT;
	pwdata.data = pin;
	pwdata.intdata = -1;

	cms_set_pw_callback(ctx->cms, get_password_passthrough);
	cms_set_pw_data(ctx->cms, &pwdata);

	rc = unlock_nss_token(ctx->cms);

	cms_set_pw_callback(ctx->cms, get_password_fail);
	cms_set_pw_data(ctx->cms, NULL);

	if (rc == -1)
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not find token \"%s\"", tn->value);
	else if (rc == 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
			"authentication succeeded for token \"%s\"",
			tn->value);
		rc = add_token_to_authenticated_list(ctx, tn->value);
		if (rc < 0)
			ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
				"couldn't add token to internal list: %m");
	}

	send_response(ctx, ctx->cms, pollfd, rc);
	free(buffer);

	hide_stolen_goods_from_cms(ctx->cms, ctx->backup_cms);
	cms_context_fini(ctx->cms);
}

static void
handle_is_token_unlocked(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;

	int rc = cms_context_alloc(&ctx->cms);
	if (rc < 0) {
		send_response(ctx, ctx->backup_cms, pollfd, rc);
		return;
	}

	steal_from_cms(ctx->backup_cms, ctx->cms);

	char *buffer = malloc(size);
	if (!buffer) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unable to allocate memory: %m");
		exit(1);
	}

	memset(&msg, '\0', sizeof(msg));

	iov.iov_base = buffer;
	iov.iov_len = size;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);

	pesignd_string *tn = (pesignd_string *)buffer;
	if (n < (long long)sizeof(tn->size)) {
malformed:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unlock-token: invalid data");
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"possible exploit attempt. closing.");
		close(pollfd->fd);
		return;
	}
	n -= sizeof(tn->size);
	if ((size_t)n < tn->size)
		goto malformed;
	n -= tn->size;

	if (tn->value[tn->size - 1] != '\0')
		goto malformed;

	if (n != 0)
		goto malformed;

	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
		"querying token \"%s\"", tn->value);

	char *key = (char *)tn->value;
	char *tokenname;

	tokenname = bsearch(&key, ctx->tokennames, ctx->ntokennames,
				sizeof (char *), cmpstringp);
	send_response(ctx, ctx->cms, pollfd, tokenname == NULL ? 1 : 0);

	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
			"token \"%s\" is %sunlocked", tn->value,
			tokenname == NULL ? "not " : "");

	free(buffer);

	hide_stolen_goods_from_cms(ctx->cms, ctx->backup_cms);
	cms_context_fini(ctx->cms);
}

static void
handle_get_cmd_version(context *ctx, struct pollfd *pollfd, socklen_t size);

static void
socket_get_fd(context *ctx, int sd, int *fd)
{
	struct msghdr msg;
	struct iovec iov;
	char buf[2];

	size_t controllen = CMSG_SPACE(sizeof(int));
	struct cmsghdr *cm = malloc(controllen);
	if (!cm) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unable to allocate memory: %m");
		exit(1);
	}

	memset(&msg, '\0', sizeof(msg));
	iov.iov_base = buf;
	iov.iov_len = 2;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = cm;
	msg.msg_controllen = controllen;

	ssize_t n;
	n = recvmsg(sd, &msg, MSG_WAITALL);
	if (n < 0) {
malformed:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unlock-token: invalid data");
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"possible exploit attempt. closing.");
		close(sd);
		return;
	}

	struct cmsghdr *cme = CMSG_FIRSTHDR(&msg);

	if (cme == NULL)
		goto malformed;

	if (cme->cmsg_level != SOL_SOCKET)
		goto malformed;

	if (cme->cmsg_type != SCM_RIGHTS)
		goto malformed;

	*fd = *((int *)CMSG_DATA(cme));

	free(cm);
}

static int
set_up_inpe(context *ctx, int fd, Pe **pe)
{
	*pe = pe_begin(fd, PE_C_READ_MMAP, NULL);
	if (!*pe)
		*pe = pe_begin(fd, PE_C_READ, NULL);
	if (!*pe) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not parse PE binary: %s",
			pe_errmsg(pe_errno()));
		return -1;
	}

	int rc = parse_signatures(&ctx->cms->signatures,
				  &ctx->cms->num_signatures, *pe);
	if (rc < 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not parse signature list");
		pe_end(*pe);
		*pe = NULL;
		return -1;
	}
	return 0;
}

static int
set_up_outpe(context *ctx, int fd, Pe *inpe, Pe **outpe)
{
	size_t size;
	char *addr;

	addr = pe_rawfile(inpe, &size);

	off_t offset = lseek(fd, 0, SEEK_SET);
	if (offset < 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not read output file: %m");
		return -1;
	}

	int rc = ftruncate(fd, size);
	if (rc < 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not extend output file: %m");
		return -1;
	}
	rc = write(fd, addr, size);
	if (rc < 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not write to output file: %m");
		return -1;
	}

	*outpe = pe_begin(fd, PE_C_RDWR_MMAP, NULL);
	if (!*outpe)
		*outpe = pe_begin(fd, PE_C_RDWR, NULL);
	if (!*outpe) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not set up output: %s",
			pe_errmsg(pe_errno()));
		return -1;
	}

	pe_clearcert(*outpe);
	return 0;
}

static int
sign_pe(context *ctx, int infd, int outfd, int attached)
{
	Pe *inpe = NULL;

	int rc = set_up_inpe(ctx, infd, &inpe);
	if (rc < 0)
		goto finish;

	if (attached) {
		Pe *outpe = NULL;
		rc = set_up_outpe(ctx, outfd, inpe, &outpe);
		if (rc < 0)
			goto finish;

		rc = generate_digest(ctx->cms, outpe, 1);
		if (rc < 0) {
err_attached:
			pe_end(outpe);
			ftruncate(outfd, 0);
			goto finish;
		}
		ssize_t sigspace = calculate_signature_space(ctx->cms, outpe);
		if (sigspace < 0)
			goto err_attached;
		allocate_signature_space(outpe, sigspace);
		rc = generate_digest(ctx->cms, outpe, 1);
		if (rc < 0)
			goto err_attached;
		rc = generate_signature(ctx->cms);
		if (rc < 0)
			goto err_attached;
		insert_signature(ctx->cms, ctx->cms->num_signatures);
		finalize_signatures(ctx->cms->signatures,
				ctx->cms->num_signatures, outpe);
		pe_end(outpe);
	} else {
		ftruncate(outfd, 0);
		rc = generate_digest(ctx->cms, inpe, 1);
		if (rc < 0) {
err_detached:
			ftruncate(outfd, 0);
			goto finish;
		}
		rc = generate_signature(ctx->cms);
		if (rc < 0)
			goto err_detached;
		rc = export_signature(ctx->cms, outfd, 0);
		if (rc >= 0)
			ftruncate(outfd, rc);
		else if (rc < 0)
			goto err_detached;
	}

finish:
	if (inpe)
		pe_end(inpe);

	return rc;
}

static int
sign_kmod(context *ctx, int infd, int outfd, int attached)
{
	unsigned char *map;
	struct stat statbuf;
	ssize_t sig_len;
	int rc;

	rc = fstat(infd, &statbuf);
	if (rc != 0) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not stat input file: %m");
		return rc;
	}

	map = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, infd, 0);
	if (map == MAP_FAILED) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"could not map input file: %m");
		return -1;

	}

	rc = kmod_generate_digest(ctx->cms, map, statbuf.st_size);
	if (rc < 0)
		goto out;

	if (attached) {
		rc = write_file(outfd, map, statbuf.st_size);
		if (rc) {
			ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
				"could not write module data: %m");
			goto out;
		}
	}

	sig_len = kmod_write_signature(ctx->cms, outfd);
	if (sig_len < 0) {
		rc = sig_len;
		goto out;
	}

	rc = kmod_write_sig_info(ctx->cms, outfd, sig_len);

out:
	munmap(map, statbuf.st_size);
	return rc;
}

static void
handle_signing(context *ctx, struct pollfd *pollfd, socklen_t size,
	       int attached, bool with_file_type)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;
	char *buffer = malloc(size);
	uint32_t file_format;

	if (!buffer) {
oom:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unable to allocate memory: %m");
		exit(1);
	}

	memset(&msg, '\0', sizeof(msg));

	iov.iov_base = buffer;
	iov.iov_len = size;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);

	if (with_file_type) {
		file_format = *((uint32_t *) buffer);
		n -= sizeof(uint32_t);
	} else {
		file_format = FORMAT_PE_BINARY;
	}

	pesignd_string *tn = (pesignd_string *)(buffer + sizeof(uint32_t));
	if (n < (long long)sizeof(tn->size)) {
malformed:
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"handle_signing: invalid data");
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"possible exploit attempt. closing.");
		close(pollfd->fd);
		return;
	}

	n -= sizeof(tn->size);
	if ((size_t)n < tn->size)
		goto malformed;
	n -= tn->size;

	/* authenticating with nss frees these ... best API ever. */
	ctx->cms->tokenname = PORT_ArenaStrdup(ctx->cms->arena,
						(char *)tn->value);
	if (!ctx->cms->tokenname)
		goto oom;

	if ((size_t)n < sizeof(tn->size))
		goto malformed;
	pesignd_string *cn = pesignd_string_next(tn);
	n -= sizeof(cn->size);
	if ((size_t)n < cn->size)
		goto malformed;

	ctx->cms->certname = PORT_ArenaStrdup(ctx->cms->arena,
						(char *)cn->value);
	if (!ctx->cms->certname)
		goto oom;

	n -= cn->size;
	if (n != 0)
		goto malformed;

	int infd=-1;
	socket_get_fd(ctx, pollfd->fd, &infd);

	int outfd=-1;
	socket_get_fd(ctx, pollfd->fd, &outfd);

	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
		"attempting to sign with key \"%s:%s\"",
		tn->value, cn->value);
	free(buffer);

	int rc = find_certificate(ctx->cms, 1);
	if (rc < 0) {
		goto finish;
	}

	switch (file_format) {
	case FORMAT_PE_BINARY:
		rc = sign_pe(ctx, infd, outfd, attached);
		break;
	case FORMAT_KERNEL_MODULE:
		rc = sign_kmod(ctx, infd, outfd, attached);
		break;
	default:
		rc = -1;
		break;
	}

	if (rc < 0)
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			      "unrecognised format %d", file_format);

finish:
	close(infd);
	close(outfd);

	send_response(ctx, ctx->cms, pollfd, rc);
	teardown_digests(ctx->cms);
}

static inline void
handle_sign_helper(context *ctx, struct pollfd *pollfd, socklen_t size,
		   int attached, bool with_file_type)
{
	int rc = cms_context_alloc(&ctx->cms);
	if (rc < 0)
		return;

	steal_from_cms(ctx->backup_cms, ctx->cms);

	handle_signing(ctx, pollfd, size, attached, with_file_type);

	hide_stolen_goods_from_cms(ctx->cms, ctx->backup_cms);
	cms_context_fini(ctx->cms);
}

static void
handle_sign_attached(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	handle_sign_helper(ctx, pollfd, size, 1, false);
}

static void
handle_sign_attached_with_file_type(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	handle_sign_helper(ctx, pollfd, size, 1, true);
}

static void
handle_sign_detached(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	handle_sign_helper(ctx, pollfd, size, 0, false);
}

static void
handle_sign_detached_with_file_type(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	handle_sign_helper(ctx, pollfd, size, 0, true);
}

static void
#if 0
NORETURN
#endif
handle_invalid_input(pesignd_cmd cmd, context *ctx,
		     struct pollfd *pollfd UNUSED,
		     socklen_t size UNUSED)
{
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"got unexpected command 0x%x", cmd);
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"possible exploit attempt");
}

typedef void (*cmd_handler)(context *ctx, struct pollfd *pollfd,
				socklen_t size);

typedef struct {
	pesignd_cmd cmd;
	cmd_handler func;
	char *name;
	int32_t version;
} cmd_table_t;

cmd_table_t cmd_table[] = {
		{ CMD_KILL_DAEMON, handle_kill_daemon, "kill-daemon", 0 },
		{ CMD_UNLOCK_TOKEN, handle_unlock_token, "unlock-token", 0 },
		{ CMD_SIGN_ATTACHED, handle_sign_attached, "sign-attached", 0 },
		{ CMD_SIGN_DETACHED, handle_sign_detached, "sign-detached", 0 },
		{ CMD_SIGN_ATTACHED_WITH_FILE_TYPE,
		  handle_sign_attached_with_file_type,
		  "sign-attached-with-file-type", 0 },
		{ CMD_SIGN_DETACHED_WITH_FILE_TYPE,
		  handle_sign_detached_with_file_type,
		  "sign-detached-with-file-type", 0 },
		{ CMD_RESPONSE, NULL, "response",  0 },
		{ CMD_IS_TOKEN_UNLOCKED, handle_is_token_unlocked,
			"is-token-unlocked", 0 },
		{ CMD_GET_CMD_VERSION, handle_get_cmd_version,
			"get-cmd-version", 0 },
		{ CMD_LIST_END, NULL, "list-end", 0 }
	};

static void
handle_get_cmd_version(context *ctx, struct pollfd *pollfd, socklen_t size)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;

	int rc = cms_context_alloc(&ctx->cms);
	if (rc < 0) {
		send_response(ctx, ctx->backup_cms, pollfd, rc);
		return;
	}

	steal_from_cms(ctx->backup_cms, ctx->cms);

	char *buffer = malloc(size);
	if (!buffer) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unable to allocate memory: %m");
		exit(1);
	}

	memset(&msg, '\0', sizeof(msg));

	iov.iov_base = buffer;
	iov.iov_len = size;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);

	int32_t version = -1;
	uint32_t command;

	if (n < (long long)sizeof(command)) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"unlock-token: invalid data");
		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,
			"possible exploit attempt. closing.");
		close(pollfd->fd);
		return;
	}

	memcpy(&command, buffer, sizeof (command));
	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
			"searching for command %d", command);

	for (int i = 0; cmd_table[i].cmd != CMD_LIST_END; i++) {
		if (cmd_table[i].cmd == command) {
			ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
					"cmd-version: found command \"%s\" "
					"version %d",
					cmd_table[i].name,
					cmd_table[i].version);
			version = cmd_table[i].version;
			break;
		}
	}

	if (version == -1) {
		ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE,
				"cmd-version: could not find command %d",
				command);
	}
	send_response(ctx, ctx->cms, pollfd, version);

	free(buffer);

	hide_stolen_goods_from_cms(ctx->cms, ctx->backup_cms);
	cms_context_fini(ctx->cms);
}

static int
handle_event(context *ctx, struct pollfd *pollfd)
{
	struct msghdr msg;
	struct iovec iov;
	ssize_t n;
	pesignd_msghdr pm;

	msg.msg_name = NULL;
	msg.msg_namelen = 0;

	iov.iov_base = &pm;
	iov.iov_len = sizeof(pm);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	char control[1024];
	msg.msg_controllen = 1024;
	msg.msg_control = control;

	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);
	if (n < 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_WARNING,
			"recvmsg failed: %m");
		return n;
	}

	/* if recvmsg returned 0, we're not going to get any valid data. */
	/* This *probably* means we were hung up on. */
	if (n == 0)
		return n;

	if (n < (long long)sizeof (pm)) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"got message with invalid size %zu", n);
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"possible exploit attempt.  closing.");
		close(pollfd->fd);
		return -1;
	}

	if (pm.version != PESIGND_VERSION) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"got version %#x, expected version %#x",
			pm.version, PESIGND_VERSION);
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"possible exploit attempt.  closing.");
		close(pollfd->fd);
		return -1;
	}

	for (int i = 0; cmd_table[i].cmd != CMD_LIST_END; i++) {
		if (cmd_table[i].cmd == pm.command) {
			if (cmd_table[i].func == NULL) {
				handle_invalid_input(pm.command, ctx, pollfd,
							pm.size);
				close(pollfd->fd);
			}
			cmd_table[i].func(ctx, pollfd, pm.size);
			return 0;
		}
	}

	handle_invalid_input(pm.command, ctx, pollfd, pm.size);
	close(pollfd->fd);
	return 0;
}

static void
do_shutdown(context *ctx, int nsockets, struct pollfd *pollfds)
{
	unlink(SOCKPATH);
	unlink(PIDFILE);

	for (int i = 0; i < ctx->ntokennames; i++)
		free(ctx->tokennames[i]);
	if (ctx->tokennames)
		free(ctx->tokennames);
	ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_NOTICE,
			"pesignd exiting (pid %d)", getpid());

	xfree(ctx->errstr);

	for (int i = 0; i < nsockets; i++)
		close(pollfds[i].fd);
	free(pollfds);
}

static int
handle_events(context *ctx)
{
	int rc;
	int nsockets = 1;

	struct pollfd *pollfds = calloc(1, sizeof(struct pollfd));

	if (!pollfds) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"could not allocate memory: %m");
		exit(1);
	}

	pollfds[0].fd = ctx->sd;
	pollfds[0].events = POLLIN|POLLPRI|POLLHUP;

	while (1) {
		if (should_exit != 0) {
shutdown:
			do_shutdown(ctx, nsockets, pollfds);
			return 0;
		}
		rc = ppoll(pollfds, nsockets, NULL, NULL);
		if (should_exit != 0)
			goto shutdown;
		if (rc < 0) {
			ctx->backup_cms->log(ctx->backup_cms,
				ctx->priority|LOG_WARNING,
				"ppoll: %m");
			continue;
		}

		if (pollfds[0].revents & POLLIN) {
			nsockets++;
			struct pollfd *newpollfds = realloc(pollfds,
				nsockets * sizeof(struct pollfd));

			if (!newpollfds) {
				ctx->backup_cms->log(ctx->backup_cms,
					ctx->priority|LOG_ERR,
					"could not allocate memory: %m");
				exit(1);
			}
			pollfds = newpollfds;

			struct sockaddr_un remote;
			socklen_t len = sizeof(remote);
			pollfds[nsockets-1].fd = accept(pollfds[0].fd, &remote,
							&len);
			pollfds[nsockets-1].events = POLLIN|POLLPRI|POLLHUP;
			pollfds[nsockets-1].revents = pollfds[0].revents;
		}
		for (int i = 1; i < nsockets; i++) {
			if (pollfds[i].revents & (POLLHUP|POLLNVAL)) {
				close(pollfds[i].fd);
				if (i == nsockets-1) {
					nsockets--;
					continue;
				}
				for (int j = i; j < nsockets - 1; j++) {
					pollfds[j].fd = pollfds[j+1].fd;
					pollfds[j].events =
						pollfds[j].events;
					pollfds[j].revents =
						pollfds[j].revents;
				}
				nsockets--;
				i--;
				continue;
			}

			if (pollfds[i].revents & (POLLIN|POLLPRI))
				handle_event(ctx, &pollfds[i]);
		}
	}
	return 0;
}

static int
get_uid_and_gid(context *ctx, char **homedir)
{
	struct passwd *passwd;

	passwd = getpwnam("pesign");

	if (!passwd)
		return -1;

	ctx->uid = passwd->pw_uid;
	ctx->gid = passwd->pw_gid;

	if (ctx->uid == 0 || ctx->gid == 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"cowardly refusing to start with uid = %d and gid = %d",
			ctx->uid, ctx->gid);
		errno = EINVAL;
		return -1;
	}

	*homedir = passwd->pw_dir;

	return 0;
}

static void
quit_handler(int signal UNUSED)
{
	should_exit = 1;
}

static int
set_up_socket(context *ctx)
{
	int sd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sd < 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"unable to create socket: %m");
		exit(1);
	}

	struct sockaddr_un addr_un = {
		.sun_family = AF_UNIX,
		.sun_path = SOCKPATH,
	};

	int rc = bind(sd, &addr_un, sizeof(addr_un));
	if (rc < 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"unable to bind to \"%s\": %m",
			addr_un.sun_path);
		exit(1);
	}
	rc = chmod(SOCKPATH, 0660);
	if (rc < 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"could not set permissions for \"%s\": %m",
			SOCKPATH);
		exit(1);
	}

	rc = listen(sd, 5);
	if (rc < 0) {
		ctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,
			"unable to listen on socket: %m");
		exit(1);
	}


	ctx->sd = sd;
	return 0;
}

static void
check_socket(context *ctx UNUSED)
{
	errno = 0;
	int rc = access(SOCKPATH, R_OK);
	if (rc == 0) {
		struct sockaddr_un addr_un = {
			.sun_family = AF_UNIX,
			.sun_path = SOCKPATH,
		};

		int sd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
		if (sd < 0) {
			fprintf(stderr, "unable to create socket: %m");
			exit(1);
		}

		socklen_t len = strlen(addr_un.sun_path) +
				sizeof(addr_un.sun_family);

		rc = connect(sd, (struct sockaddr *)&addr_un, len);
		if (rc < 0) {
			close(sd);
			unlink(SOCKPATH);
			return;
		}

		struct sockaddr_un remote;
		socklen_t size = sizeof(remote);
		rc = getpeername(sd, &remote, &size);
		if (rc < 0) {
			close(sd);
			return;
		} else {
			fprintf(stderr, "already running");
			exit(1);
		}
	} else {
		/* It could be something other than EEXIST, but it really
		 * doesn't matter since the daemon isn't running.  Blindly
		 * remove it. */
		unlink(SOCKPATH);
	}
}

static int PRINTF(3, 4)
daemon_logger(cms_context *cms, int priority, char *fmt, ...)
{
	context *ctx = (context *)cms->log_priv;
	va_list ap;
	int rc = 0;

	if (ctx->errstr)
		xfree(ctx->errstr);

	va_start(ap, fmt);
	if (priority & LOG_ERR) {
		va_list aq;

		va_copy(aq, ap);
		rc = vasprintf(&ctx->errstr, fmt, aq);
		va_end(aq);
	}

	vsyslog(ctx->priority | priority, fmt, ap);
	va_end(ap);
	return rc;
}

static void
write_pid_file(int pid)
{
	int fd = open(PIDFILE, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	if (fd < 0) {
err:
		fprintf(stderr, "couldn't open pidfile: %m\n");
		exit(1);
	}
	char *pidstr = NULL;
	int rc = asprintf(&pidstr, "%d\n", pid);
	if (rc < 0)
		goto err;

	rc = write(fd, pidstr, strlen(pidstr)+1);
	if (rc < 0)
		goto err;

	free(pidstr);
	close(fd);
}

int
daemonize(cms_context *cms_ctx, char *certdir, int do_fork)
{
	int rc = 0;
	context ctx = {
		.backup_cms = cms_ctx,
		.priority = do_fork ? LOG_PID
				    : LOG_PID|LOG_PERROR,
	};

	ctx.backup_cms = cms_ctx;
	ctx.backup_cms->log_priv = &ctx;
	ctx.sd = -1;

	if (getuid() != 0) {
		fprintf(stderr, "pesignd must be started as root");
		exit(1);
	}

	check_socket(&ctx);

	openlog("pesignd", LOG_PID, LOG_DAEMON);

	if (do_fork) {
		pid_t pid;

		if ((pid = fork())) {
			sleep(2);
			return 0;
		}
	}
	ctx.pid = getpid();
	write_pid_file(ctx.pid);
	ctx.backup_cms->log(ctx.backup_cms, ctx.priority|LOG_NOTICE,
		"pesignd starting (pid %d)", ctx.pid);
	daemon_logger(ctx.backup_cms, ctx.priority|LOG_NOTICE,
		"pesignd starting (pid %d)", ctx.pid);

	SECStatus status = NSS_Init(certdir);
	int error = errno;
	if (status != SECSuccess) {
		char *globpattern = NULL;
		rc = asprintf(&globpattern, "%s/cert*.db",
			      certdir);
		if (rc > 0) {
			glob_t globbuf;
			memset(&globbuf, 0, sizeof(globbuf));
			rc = glob(globpattern, GLOB_ERR, NULL,
				  &globbuf);
			if (rc != 0) {
				errno = error;
				ctx.backup_cms->log(ctx.backup_cms,
					ctx.priority|LOG_NOTICE,
					"Could not open NSS database (\"%s\"): %m",
					PORT_ErrorToString(PORT_GetError()));
				exit(1);
			}
		}
	}
	if (status != SECSuccess) {
		errno = error;
		ctx.backup_cms->log(ctx.backup_cms, ctx.priority|LOG_NOTICE,
				    "Could not initialize nss.\n"
				    "NSS says \"%s\" errno says \"%m\"\n",
				    PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}

	status = register_oids(ctx.backup_cms);
	if (status != SECSuccess) {
		ctx.backup_cms->log(ctx.backup_cms, ctx.priority|LOG_NOTICE,
			"Could not register OIDs\n");
		exit(1);
	}

	if (do_fork) {
		int fd = open("/dev/zero", O_RDONLY);
		if (fd < 0) {
			ctx.backup_cms->log(ctx.backup_cms,
					ctx.priority|LOG_ERR,
					"could not open /dev/zero: %m");
			exit(1);
		}
		close(STDIN_FILENO);
		rc = dup2(fd, STDIN_FILENO);
		if (rc < 0) {
			ctx.backup_cms->log(ctx.backup_cms,
				ctx.priority|LOG_ERR,
				"could not set up standard input: %m");
			exit(1);
		}
		close(fd);

		fd = open("/dev/null", O_WRONLY);
		if (fd < 0) {
			ctx.backup_cms->log(ctx.backup_cms,
					ctx.priority|LOG_ERR,
					"could not open /dev/null: %m");
			exit(1);
		}
		close(STDOUT_FILENO);
		rc = dup2(fd, STDOUT_FILENO);
		if (rc < 0) {
			ctx.backup_cms->log(ctx.backup_cms,
				ctx.priority|LOG_ERR,
				"could not set up standard output: %m");
			exit(1);
		}

		close(STDERR_FILENO);
		rc = dup2(fd, STDERR_FILENO);
		if (rc < 0) {
			ctx.backup_cms->log(ctx.backup_cms,
				ctx.priority|LOG_ERR,
				"could not set up standard error: %m");
			exit(1);
		}
		close(fd);
	}

	prctl(PR_SET_NAME, "pesignd", 0, 0, 0);

	setsid();

	if (do_fork) {
		struct sigaction sa = {
			.sa_handler = quit_handler,
		};
		sigaction(SIGQUIT, &sa, NULL);
		sigaction(SIGINT, &sa, NULL);
		sigaction(SIGTERM, &sa, NULL);
	}

	char *homedir = NULL;

	rc = get_uid_and_gid(&ctx, &homedir);
	if (rc < 0) {
		ctx.backup_cms->log(ctx.backup_cms, ctx.priority|LOG_ERR,
			"could not get group and user information "
			"for pesign: %m");
		exit(1);
	}

	chdir(homedir ? homedir : "/");

	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(ctx.gid) != 0 || setgroups(0, NULL)) {
			ctx.backup_cms->log(ctx.backup_cms,
				ctx.priority|LOG_ERR,
				"unable to drop group privileges: %m");
			exit(1);
		}
		if (setuid(ctx.uid) != 0) {
			ctx.backup_cms->log(ctx.backup_cms,
				ctx.priority|LOG_ERR,
				"unable to drop user privileges: %m");
			exit(1);
		}
	}

	set_up_socket(&ctx);

	cms_set_pw_callback(ctx.backup_cms, get_password_fail);
	cms_set_pw_data(ctx.backup_cms, NULL);
	if (do_fork)
		ctx.backup_cms->log = daemon_logger;

	rc = handle_events(&ctx);

	status = NSS_Shutdown();
	if (status != SECSuccess) {
		ctx.backup_cms->log(ctx.backup_cms, ctx.priority|LOG_ERR,
			"NSS_Shutdown failed: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}
	return rc;
}

```

`src/daemon.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * daemon.h - types and decls for our signing daemon
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef DAEMON_H
#define DAEMON_H 1

extern int daemonize(cms_context *ctx, char *certdir, int do_fork);

typedef struct {
	uint32_t version;
	uint32_t command;
	uint32_t size;
} pesignd_msghdr;

typedef struct  {
	int32_t rc;
	uint8_t errmsg[];
} pesignd_cmd_response;

typedef struct {
	uint32_t size;
	uint8_t value[];
} pesignd_string;

typedef enum {
	CMD_KILL_DAEMON,
	CMD_UNLOCK_TOKEN,
	CMD_SIGN_ATTACHED,
	CMD_SIGN_DETACHED,
	CMD_RESPONSE,
	CMD_IS_TOKEN_UNLOCKED,
	CMD_GET_CMD_VERSION,
	CMD_SIGN_ATTACHED_WITH_FILE_TYPE,
	CMD_SIGN_DETACHED_WITH_FILE_TYPE,
	CMD_LIST_END
} pesignd_cmd;

#define PESIGND_VERSION 0x2a9edaf0
#define SOCKPATH	RUNDIR "/pesign/socket"
#define PIDFILE		RUNDIR "/pesign.pid"

static inline uint32_t UNUSED
pesignd_string_size(char *buffer)
{
	pesignd_string *s;
	return sizeof(s->size) + (buffer ? strlen(buffer) : 0) + 1;
}

static inline void UNUSED
pesignd_string_set(pesignd_string *str, char *value)
{
	str->size = (value ? strlen(value) : 0) + 1;
	if (value)
		strcpy((char *)str->value, value);
	else
		str->value[0] = '\0';
}

static inline pesignd_string * UNUSED
pesignd_string_next(pesignd_string *str)
{
	char *buffer = (char *)str;
	buffer += sizeof(str->size) + str->size;
	return (pesignd_string *)buffer;
}

#endif /* DAEMON_H */

```

`src/efikeygen.1.mdoc`:

```mdoc
.Dd $Mdocdate: Jun 3 2020$
.Dt EFIKEYGEN 1
.Os Linux
.Sh NAME
.Nm efikeygen
.Nd tool for generating keys for PE image signing for UEFI Secure Boot
.Sh SYNOPSIS
.Nm efikeygen
.Bk -words
.Ao
.Fl C |
.Fl k |
.Fl m
.Ac
.Ek
.Bk -words
.Ao
.Cm Fl S |
.Cm Fl Fl signer Ar nickname
.Ac
.Ek
.Cm Fl n Ar nickname
.Cm Fl c Ar common_name
.Op Fl u Ar url
.Op Fl s Ar serial
.Op Fl d Ar directory
.Op Fl t Ar token
.Ek
.Sh DESCRIPTION
.Nm
is a command line tool for generating keys and certificates to be used with
pesign.  These are standard X.509 certificates, and can potentially be
generated with any certificate creation tool.
.Nm
generates certificates with sensible options set for a key to be used for PE
image signing for UEFI Secure Boot.

.Sh OPTIONS
.Bl -tag
.It Fl C | Fl Fl ca
Create a CA certificate
.It Fl k | Fl Fl kernel
Create a kernel signing certificate
.Pp
Not to be used for CA certificates
.It Fl m | Fl Fl module
Create a module signing certificate
.Pp
Not to be used for CA certificates
.It Fl S | Fl Fl self-sign
Create a self-signed certificate
.It Fl Fl signer Ar nickname
Use the NSS certificate referred to by
.Ar nickname
as the issuing certificate
.It Fl n Ar nickname | Fl nickname Ar nickname
Set the new certificate nickname in the NSS database to
.Ar nickname
.It Fl c Ar common_name | Fl Fl common-name Ar common_name
The X.509 Common Name for the generated certificate.  This should be in
rfc2253 syntax, i.e.:\p
.Qq CN=John Doe,OU=editing,O=New York Times,L=New York,ST=NY,C=US
.It Fl u Ar url | Fl Fl url Ar url
URL for information regarding this certificate and objects signed with it.
.It Fl s Ar serial | Fl Fl serial Ar serial
Serial number for use with this key.  A certificate is identified by its
signer and its serial number, so it's best not to ever re-use this value
with the same signer.  By default, this value will be generated at random.
It is not recommended to use this option to override that.
.It Fl d Ar directory | Fl Fl dbdir Ar directory
The directory for the NSS key database\p
.Po
default:
.Pa /etc/pki/pesign
.Pc
.It Fl t Ar token | Fl Fl token Ar token
The NSS token name to use\p
.Po
default:
.Pa pkcs11:token=NSS%20Certificate%20DB
.Pc
.El
.Sh EXAMPLES
.Ss YubiKey


Here's how you create both a CA certificate and keypair and a kernel signing
certificate and keypair, and import them into yubikey PIV devices:

Generate some keys:

.Bd -literal -offset 1 -compact
# Create a new CA key
host:~$ \fBefikeygen -C -n my-ca -S \e
        -c "CN=CA Person,OU=My Org's CA,O=My Org" \e
        -u https://myorg.example.com/ca/\fR

# Create a kernel signing key
host:~$ \fBefikeygen -n my-signer --signer my-ca -k \e
        -c "CN=Secure Boot Signer,OU=My Org's CA,O=My Org" \e
        -u https://myorg.example.com/ca/\fR
.Ed

Save the CA to a yubikey:

.Bd -literal -offset 1 -compact
# Save it in a PKCS-12 bundle\p
host:~$ \fBpk12util -d /etc/pki/pesign -o myca.pk12 -n my-ca\fR\p
Enter password for PKCS12 file: \fB<type a password here>\fR\p
Re-enter password: \fB<type it again here>\fR\p
pk12util: PKCS12 EXPORT SUCCESSFUL

# Import the key into the yubikey
host:~$ \fByubico-piv-tool -s 9c -a import-key -K PKCS12 \e
        -c -i myca.pk12\fR\p
Enter PEM pass phrase: \fB<type the same password here>\fR\p
Successfully imported a new private key.\p

# Import the certificate into the yubikey\p
host:~$ \fByubico-piv-tool -s 9c -a import-certificate \e
        -K PKCS12 -i myca.pk12\fR
Enter PEM pass phrase: \fB<type the same password here>\fR\p
Successfully imported a new certificate.\p

# Remove the CA cert from the NSS database\p
host:~$ \fBcertutil -d /etc/pki/pesign -D -n my-ca\fR\p
.Ed

Now switch yubikeys and import the kernel signer onto another one

.Bd -literal -offset 1 -compact
# Save it in a PKCS-12 bundle\p
host:~$ \fBpk12util -d /etc/pki/pesign -o mysigner.pk12 -n my-signer\fR\p
Enter password for PKCS12 file: \fB<type a password here>\fR\p
Re-enter password: \fB<type it again here>\fR\p
pk12util: PKCS12 EXPORT SUCCESSFUL\p

# Import the key into the yubikey\p
host:~$ \fByubico-piv-tool -s 9c -a import-key -K PKCS12 \e\p
        -i mysigner.pk12\fR\p
Enter PEM pass phrase: \fB<type the same password here>\fR\p
Successfully imported a new private key.\p

# Import the certificate into the yubikey\p
host:~$ \fByubico-piv-tool -s 9c -a import-certificate \e\p
        -K PKCS12 -i mysigner.pk12\fR\p
Enter PEM pass phrase: \fB<type it again here>\fR\p
Successfully imported a new certificate.\p

# Remove the kernel signer from the NSS database\p
host:~$ \fBcertutil -d /etc/pki/pesign -D -n my-signer\fR
.Ed

Once you have done this, you are prepared to sign binaries:

.Bd -literal -offset 1 -compact
# On each of these prompts, you have to enter the PIN for\p
# the Yubikey.  This and the strange choice of names are\p
# because PKCS-11 is horrible.  I'm sorry.\p
host:~$ \fBpesign -s -t 'Secure Boot Signer' \e\p
        -c "Certificate for Digital Signature" \e\p
        -i shimx64.efi -o shimx64.signed.efi\fR\p
Enter Password or Pin for "Secure Boot Signer": \fB<type the PIN here>\fR\p
Enter passphrase for private key: \fB<type it again here>\fR\p
Enter passphrase for private key: \fB<type it again here>\fR\p
.Ed

Now verify that it worked:

.Bd -literal -offset 1 -compact
host:~$ \fBpesign -i shimx64.signed.efi -l\fR\p
---------------------------------------------\p
certificate address is 0x7fbbae061468\p
Content was not encrypted.\p
Content is detached; signature cannot be verified.\p
The signer's common name is Secure Boot Signer\p
No signer email address.\p
Signing time: Wed May 15, 2019\p
There were certs or crls included.\p
---------------------------------------------\p
.Ed

Yay!
.Ss OpenSC (smart card)
Here's how you create both a CA certificate and keypair
and a kernel signing certificate and keypair, and import
them into CardOS Smart Card devices supported by OpenSC:

Optionally, format the card and initialize its PKCS15 data:

.Bd -literal -offset 1 -compact
# Format the card
host:~$ \fBcardos-tool -f\fR\p
Using reader with a card: Generic Smart Card Reader Interface [Smart Card Reader Interface] (20070818000000000) 00 00\p
card in administrative state, ok\p

# Initialize the card's PKCS15 data, set the Security Officer PIN and unlock
# code.\p
host:~$ \fBpkcs15-init -CT --so-pin $SOPIN --so-puk $SOPUK\fR\p
Using reader with a card: Generic Smart Card Reader Interface [Smart Card Reader Interface] (20070818000000000) 00 00\p

# Initialize the user PIN and unlock code, and label the token\p
host:~$ \fBpkcs15-init -P -a 1 --pin $PIN --puk $PUK \e\p
        --so-pin $SOPIN --so-puk $SOPUK \e\p
        --label "myorg-sb-ca"\fR\p
Using reader with a card: Generic Smart Card Reader Interface [Smart Card Reader Interface] (20070818000000000) 00 00\p
.Ed

Generate keys and certificates:

.Bd -literal -offset 1 -compact
# Create a new CA key and certificate\p
host:~$ \fBefikeygen -C -n my-ca -S \e\p
        -c "CN=My Org's Secure Boot CA,OU=My Org's CA,O=My Org" \e\p
        -u https://myorg.example.com/ca/\fR

# Create a kernel signing key and cert\p
host:~$ \fBefikeygen -n my-signer --signer my-ca -k \e\p
        -c "CN=My Org's SB Signer,OU=My Org's CA,O=My Org"\e\p
        -u https://myorg.example.com/ca/\fR
.Ed

Get them onto the Smart Card

.Bd -literal -offset 1 -compact
# Save the CA key and certificate in a PKCS-12 bundle\p
host:~$ \fBpk12util -d /etc/pki/pesign -o my-ca.p12 -n my-ca\fB\p
Enter password for PKCS12 file: \fB<enter a password here>\fR\p
Re-enter password: \fB<type it again here>\fR\p
pk12util: PKCS12 EXPORT SUCCESSFUL

# Import the PKCS-12 bundle onto the card\p
host:~$ \fBpkcs15-init --store-private-key my-ca.p12 \e\p
        --format pkcs12 --auth-id 01 \e\p
        --pin $PIN --so-pin $SOPIN --so-puk $SOPUK\fR\p
Using reader with a card: Generic Smart Card Reader Interface [Smart Card Reader Interface] (20070818000000000) 00 00\p
Importing 1 certificates:\p
   0: /CN=My Org's Secure Boot CA\p

# List the contents:\p
host:~$ \fBpkcs11-tool --module opensc-pkcs11.so -l --pin $PIN -O\fR\p
Using slot 1 with a present token (0x1)\p
Private Key Object; RSA\p
  label:      Private Key\p
  ID:         de61fac87e0315352e7b9a487377ace2f6354d9b\p
  Usage:      sign\p
Certificate Object, type = X.509 cert\p
  label:      /CN=My Org's Secure Boot CA\p
  ID:         de61fac87e0315352e7b9a487377ace2f6354d9b\p
Public Key Object; RSA 2048 bits\p
  label:      /CN=My Org's Secure Boot CA\p
  ID:         de61fac87e0315352e7b9a487377ace2f6354d9b\p
  Usage:      encrypt, verify

# Check and make sure nss can see the card\p
host:~$ \fBmodutil -dbdir /etc/pki/pesign/ -list\fR\p
Listing of PKCS #11 Modules\p
-----------------------------------------------------------\p
  1. NSS Internal PKCS #11 Module\p
     slots: 2 slots attached\p
    status: loaded\p

     slot: NSS Internal Cryptographic Services\p
    token: NSS Generic Crypto Services\p

     slot: NSS User Private Key and Certificate Services\p
    token: NSS Certificate DB\p

  2. opensc-pkcs11\p
    library name: /usr/lib64/pkcs11/opensc-pkcs11.so\p
     slots: 2 slots attached\p
    status: loaded\p

     slot: Virtual hotplug slot\p
    token:\p

     slot: Generic Smart Card Reader Interface [Smart Card Read...\p
    token: OpenSC Card (myorg-sb-ca)\p
-----------------------------------------------------------\p

# Check and make sure NSS can see the certificate:\p
host:~$ \fBcertutil -d /etc/pki/pesign -L \e\p
        -h "OpenSC Card (myorg-sb-ca)"\fR\p
Certificate Nickname                             Trust Attributes\p
                                                 SSL,S/MIME,JAR/XPI\p

Enter Password or Pin for "OpenSC Card (myorg-sb-ca)": \fB<type the PIN here>\fR\p
OpenSC Card (myorg-sb-ca):/CN=My Org's Secure Boot CA    u,u,u\p

# Remove the CA from the NSS database\p
host:~$ \fBcertutil -d /etc/pki/pesign -D -n my-ca\fR\p
.Ed

Remember to switch cards and do the same thing with the signer, just as in the
YubiKey example, then sign a binary with the signing key on a Smart Card and
verify that it worked:

.Bd -literal -offset 1 -compact
# Sign the binary.  On each of these prompts, you have to enter\p
# the PIN for the Smart Card.  This and the strange choice of\p
# names are because PKCS-11 is horrible.  I'm sorry.\p
host:~$ \fBpesign -s -t "OpenSC Card(myorg-sb-signer)" \e\p
        -c "OpenSC Card (myorg-sb-signer):/CN=My Org's SB Signer"\e\p
        -i shimx64.efi -o shimx64.signed.efi\fR\p
Enter Password or Pin for "My Org's SB Signer": \fB<type the PIN here>\fR\p
Enter passphrase for private key: \fB<type the PIN here>\fR\p
Enter passphrase for private key: \fB<type the PIN here>\fR\p

# Verify that it worked:\p
host:~$ \fBpesign -i shimx64.signed.efi -l\fR\p
---------------------------------------------\p
certificate address is 0x7fbbae061468\p
Content was not encrypted.\p
Content is detached; signature cannot be verified.\p
The signer's common name is My Org's SB Signer\p
No signer email address.\p
Signing time: Wed Jun 2, 2020\p
There were certs or crls included.\p
---------------------------------------------\p
.Ed

Yay!
.Sh STANDARDS
.Rs
.%A B. Kaliski
.%R RFC 2315
.%B PKCS #7: Cryptographic Message Syntax v1.5
.%I Internet Engineering Task Force
.%D March 1998
.%U https://tools.ietf.org/html/rfc2315\ \&
.Re

.Rs
.%A K. Moriarty
.%A M. Nyström
.%A S. Parkinson
.%A A. Rusch
.%A M. Scott
.%R RFC 7292
.%B PKCS #12: Personal Information Exchange Syntax v1.1
.%I Internet Engineering Task Force
.%D July 2014
.%U https://tools.ietf.org/html/rfc7292\ \&
.Re

.Rs
.%A PKCS11 Technical Committee
.%B PKCS#11: Cryptographic Token Interface Standard
.%I OASIS
.%U https://www.cryptsoft.com/pkcs11doc/
.Re
.Sh SEE ALSO
.Xr certutil 1 ,
.Xr modutil 1 ,
.Xr opensc-tool 1 ,
.Xr pesign 1 ,
.Xr pk12util 1 ,
.Xr pkcs15-init 1 ,
.Xr yubico-piv-tool 1 ,
.Sh AUTHORS
.An Peter Jones

```

`src/efikeygen.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * efikeygen.c - key generation with reasonable defaults for Secure Boot
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <fcntl.h>
#include <inttypes.h>
#include <limits.h>
#include <popt.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#include <uuid/uuid.h>

#include <prtypes.h>
#include <prerror.h>
#include <prprf.h>

#include <nss.h>
#include <base64.h>
#include <cert.h>
#include <cryptohi.h>
#include <keyhi.h>
#include <secder.h>
#include <secerr.h>
#include <secport.h>
#include <secpkcs7.h>
#include <secoidt.h>
#include <pk11pub.h>

#include <libdpe/libdpe.h>

#include "util.h"
#include "cms_common.h"
#include "errno-guard.h"
#include "oid.h"
#include "password.h"

enum {
	MODSIGN_EKU_NONE,
	MODSIGN_EKU_KERNEL,
	MODSIGN_EKU_MODULE,
	MODSIGN_EKU_KEK,
	MODSIGN_EKU_CA
};

typedef struct {
	SECItem data;
	SECAlgorithmID keytype;
	SECItem sig;
} SignedCert;

static SEC_ASN1Template SignedCertTemplate[] = {
	{.kind = SEC_ASN1_SEQUENCE,
	 .offset = 0,
	 .sub = NULL,
	 .size = sizeof(SignedCert),
	},
	{.kind = SEC_ASN1_ANY,
	 .offset = offsetof(SignedCert, data),
	 .sub = &SEC_AnyTemplate,
	 .size = sizeof (SECItem),
	},
	{.kind = SEC_ASN1_INLINE,
	 .offset = offsetof(SignedCert, keytype),
	 .sub = &SECOID_AlgorithmIDTemplate,
	 .size = sizeof (SECAlgorithmID),
	},
	{.kind = SEC_ASN1_OCTET_STRING,
	 .offset = offsetof(SignedCert, sig),
	 .sub = NULL,
	 .size = sizeof (SECItem),
	},
	{ 0, }
};

static int
add_trust(cms_context *cms, CERTIssuerAndSN *ias,
	  const char *truststr)
{
	int rc;
	CERTCertificate *cert;
	CERTCertTrust trust;
	SECStatus status;

	memset(&trust, 0, sizeof(trust));

	status = CERT_DecodeTrustString(&trust, truststr);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not decode trust string");

	rc = find_certificate_by_issuer_and_sn(cms, ias, &cert);
	if (rc < 0)
		cmsreterr(-1, cms, "Could not find certificate");

	status = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), cert, &trust);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not set trust for certificate");

	CERT_DestroyCertificate(cert);

	return 0;
}

static int
bundle_signature(cms_context *cms, SECItem *sigder, SECItem *data,
		SECOidTag oid, SECItem *signature)
{
	SignedCert cert = {
		.data = {.data = data->data,
			 .len = data->len,
			 .type = data->type
		},
		.sig = {.data = NULL,
			.len = signature->len + 1,
			.type = signature->type
		}
	};

	cert.sig.data = PORT_ArenaZAlloc(cms->arena, signature->len + 1);
	if (!cert.sig.data)
		cmsreterr(-1, cms, "Could not allocate signature bundle");

	memcpy((void *)cert.sig.data + 1, signature->data, signature->len);

	int rc = generate_algorithm_id(cms, &cert.keytype, oid);
	if (rc < 0)
		return -1;

	void *ret;
	ret = SEC_ASN1EncodeItem(NULL, sigder, &cert, SignedCertTemplate);
	if (ret == NULL)
		errx(1, "could not encode certificate: %s",
			PORT_ErrorToString(PORT_GetError()));

	//Note: offset is signature size + 5 bytes for DER encoding
	sigder->data[sigder->len - (signature->len + 5)] = DER_BIT_STRING;

	return 0;
}

static int
add_subject_key_id(cms_context *cms, void *extHandle, SECKEYPublicKey *pubkey)
{
	SECItem *pubkey_der = PK11_DEREncodePublicKey(pubkey);
	if (!pubkey_der)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	SECItem *encoded = PK11_MakeIDFromPubKey(pubkey_der);
	SECITEM_FreeItem(pubkey_der, PR_TRUE);
	if (!encoded)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	/* for some reason PK11_MakeIDFromPubKey() doesn't generate the final
	 * wrapper for this... */
	SECItem wrapped = { 0 };
	int rc = generate_octet_string(cms, &wrapped, encoded);
	SECITEM_FreeItem(encoded, PR_TRUE);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	SECStatus status;
	status = CERT_AddExtension(extHandle, SEC_OID_X509_SUBJECT_KEY_ID,
					&wrapped, PR_FALSE, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	return 0;
}

static int
add_auth_key_id(cms_context *cms, void *extHandle, SECKEYPublicKey *pubkey)
{
	SECItem *pubkey_der = PK11_DEREncodePublicKey(pubkey);
	if (!pubkey_der)
		cmsreterr(-1, cms, "could not encode CA Key ID extension");

	SECItem *encoded = PK11_MakeIDFromPubKey(pubkey_der);
	SECITEM_FreeItem(pubkey_der, PR_TRUE);
	if (!encoded)
		cmsreterr(-1, cms, "could not encode CA Key ID extension");

	SECItem cspecific = { 0 };
	int rc = make_context_specific(cms, 0, &cspecific, encoded);
	SECITEM_FreeItem(encoded, PR_TRUE);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	/* for some reason PK11_MakeIDFromPubKey() doesn't generate the final
	 * wrapper for this... */
	SECItem wrapped = { 0 };
	rc = wrap_in_seq(cms, &wrapped, &cspecific, 1);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode subject key id extension");

	SECStatus status;
	status = CERT_AddExtension(extHandle, SEC_OID_X509_AUTH_KEY_ID,
					&wrapped, PR_FALSE, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode CA Key ID extension");
	return 0;
}


static int
add_key_usage(cms_context *cms, void *extHandle, int is_ca, bool is_kek)
{
	SECCertificateUsage usage;
	SECItem bitStringValue;

	if (is_ca) {
		usage = KU_DIGITAL_SIGNATURE |
			KU_KEY_CERT_SIGN |
			KU_CRL_SIGN;
	} else if (is_kek) {
		usage = KU_KEY_ENCIPHERMENT |
			KU_DATA_ENCIPHERMENT |
			KU_DIGITAL_SIGNATURE;
	} else {
		return 0;
	}

	bitStringValue.data = (unsigned char *)&usage;
	bitStringValue.len = sizeof (usage);

	SECStatus status;
	status = CERT_EncodeAndAddBitStrExtension(extHandle,
				SEC_OID_X509_KEY_USAGE,
				&bitStringValue, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode key usage extension");

	return 0;
}

#if 0
static int
add_cert_type(cms_context *cms, void *extHandle, int is_ca)
{
	SECItem bitStringValue;
	int type = NS_CERT_TYPE_APP;

	if (is_ca)
		type |= NS_CERT_TYPE_SSL_CA |
			NS_CERT_TYPE_EMAIL_CA |
			NS_CERT_TYPE_OBJECT_SIGNING_CA;
	bitStringValue.data = (unsigned char *)&type;
	bitStringValue.len = sizeof (type);

	SECStatus status;
	status = CERT_EncodeAndAddBitStrExtension(extHandle,
				SEC_OID_NS_CERT_EXT_CERT_TYPE,
				&bitStringValue, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode certificate type extension");

	return 0;
}
#endif

static int
add_basic_constraints(cms_context *cms, void *extHandle, int is_ca)
{
	CERTBasicConstraints basicConstraint;
	basicConstraint.pathLenConstraint = CERT_UNLIMITED_PATH_CONSTRAINT;
	basicConstraint.isCA = is_ca ? PR_TRUE : PR_FALSE;

	SECStatus status;

	SECItem encoded;

	status = CERT_EncodeBasicConstraintValue(cms->arena, &basicConstraint,
					&encoded);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode basic constraints");

	status = CERT_AddExtension(extHandle, SEC_OID_X509_BASIC_CONSTRAINTS,
					&encoded, PR_TRUE, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode basic constraints");

	return 0;
}

static int
add_extended_key_usage(cms_context *cms, int modsign_eku, void *extHandle)
{
	SECItem values[3];
	SECItem wrapped = { 0 };
	SECStatus status;
	SECOidTag tag;
	int rc;
	size_t nvals = 0;

	if (modsign_eku == MODSIGN_EKU_CA
	    || modsign_eku == MODSIGN_EKU_KEK)
		return 0;

	if (modsign_eku != MODSIGN_EKU_KERNEL
	    && modsign_eku != MODSIGN_EKU_MODULE)
		cmsreterr(-1, cms, "could not encode extended key usage");

	rc = make_eku_oid(cms, &values[nvals++], SEC_OID_EXT_KEY_USAGE_CODE_SIGN);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode extended key usage");

#if 0
	tag = find_ms_oid_tag(SPC_UEFI_SB_CA);
	rc = make_eku_oid(cms, &values[nvals++], tag);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode extended key usage");
#endif

	if (modsign_eku == MODSIGN_EKU_MODULE) {
		tag = find_ms_oid_tag(SHIM_EKU_MODULE_SIGNING_ONLY);
		rc = make_eku_oid(cms, &values[nvals++], tag);
		if (rc < 0)
			cmsreterr(-1, cms, "could not encode extended key usage");
	}

	rc = wrap_in_seq(cms, &wrapped, values, nvals);
	if (rc < 0)
		cmsreterr(-1, cms, "could not encode extended key usage");

	status = CERT_AddExtension(extHandle, SEC_OID_X509_EXT_KEY_USAGE,
					&wrapped, PR_FALSE, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode extended key usage");

	return 0;
}

static int
add_auth_info(cms_context *cms, void *extHandle, char *url)
{
	SECItem value;
	int rc;

	rc = generate_auth_info(cms, &value, url);
	if (rc < 0)
		return rc;

	SECStatus status;

	status = CERT_AddExtension(extHandle, SEC_OID_X509_AUTH_INFO_ACCESS,
				&value, PR_FALSE, PR_TRUE);
	if (status != SECSuccess)
		cmsreterr(-1, cms, "could not encode key authority information "
				"access extension");

	return 0;
}

static int
add_extensions_to_crq(cms_context *cms, CERTCertificateRequest *crq,
			int is_ca, bool is_kek, int is_self_signed,
			SECKEYPublicKey *pubkey, SECKEYPublicKey *spubkey,
			char *url, int modsign_eku)
{
	void *mark = PORT_ArenaMark(cms->arena);

	void *extHandle;
	int rc;
	extHandle = CERT_StartCertificateRequestAttributes(crq);
	if (!extHandle)
		cmsreterr(-1, cms, "could not generate certificate extensions");

	rc = add_subject_key_id(cms, extHandle, pubkey);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate extensions");

	rc = add_basic_constraints(cms, extHandle, is_ca);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate "
				"extensions");

	rc = add_key_usage(cms, extHandle, is_ca, is_kek);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate extensions");

	rc = add_extended_key_usage(cms, modsign_eku, extHandle);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate extensions");

#if 0
	rc = add_cert_type(cms, extHandle, is_ca);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate extensions");
#endif

	if (is_self_signed)
		rc = add_auth_key_id(cms, extHandle, pubkey);
	else
		rc = add_auth_key_id(cms, extHandle, spubkey);
	if (rc < 0)
		cmsreterr(-1, cms, "could not generate certificate extensions");

	if (url) {
		rc = add_auth_info(cms, extHandle, url);
		if (rc < 0)
			cmsreterr(-1, cms,
				"could not generate certificate extensions");
	}

	CERT_FinishExtensions(extHandle);
	CERT_FinishCertificateRequestAttributes(crq);
	PORT_ArenaRelease(cms->arena, mark);
	PORT_ArenaUnmark(cms->arena, mark);
	return 0;
}

static int
populate_extensions(cms_context *cms, CERTCertificate *cert,
			CERTCertificateRequest *crq)
{
	CERTAttribute *attr = NULL;
	SECOidData *oid;

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS9_EXTENSION_REQUEST);

	for (int i = 0; crq->attributes[i]; i++) {
		attr = crq->attributes[i];
		if (attr->attrType.len != oid->oid.len)
			continue;
		if (!memcmp(attr->attrType.data, oid->oid.data, oid->oid.len))
			break;
		attr = NULL;
	}

	if (!attr)
		cmsreterr(-1, cms, "could not find extension request");

	SECStatus rv;
	rv = SEC_QuickDERDecodeItem(cms->arena, &cert->extensions,
				CERT_SequenceOfCertExtensionTemplate,
				*attr->attrValue);
	if (rv != SECSuccess)
		cmsreterr(-1, cms, "could not decode certificate extensions");
	return 0;
}

static int
get_pubkey_from_file(char *pubfile, SECKEYPublicKey **pubkey)
{
	SECItem pubkey_item = {
		.type = siBuffer,
		.data = NULL,
		.len = -1
	};

	int pubfd = open(pubfile, O_RDONLY);
	if (pubfd < 0)
		libreterr(-1, "could not open \"%s\"", pubfile);

	char *data = NULL;
	size_t *len = (size_t *)&pubkey_item.len;

	int rc = read_file(pubfd, &data, len);
	if (rc < 0)
		libreterr(-1, "could not read public key");

	pubkey_item.data = (unsigned char *)data;
	*pubkey = SECKEY_ImportDERPublicKey(&pubkey_item, CKK_RSA);
	if (!*pubkey)
		nssreterr(-1, "could not decode public key");

	return 0;
}

static int
get_signer_private_key(cms_context *cms, SECKEYPrivateKey **privkey)
{
	secuPWData pwdata_val = { 0, 0 };
	void *pwdata = &pwdata_val;
	SECKEYPrivateKey *sprivkey;
	sprivkey = PK11_FindKeyByAnyCert(cms->cert, pwdata);
	if (!sprivkey)
		cmsreterr(-1, cms, "could not find private key");

	*privkey = sprivkey;
	return 0;
}

static int
get_signer_public_key(cms_context *cms, SECKEYPublicKey **pubkey)
{
	SECKEYPublicKey *spubkey;
	spubkey = CERT_ExtractPublicKey(cms->cert);
	if (!spubkey)
		cmsreterr(-1, cms, "could not find public key");

	*pubkey = spubkey;
	return 0;
}

/* Of course this doesn't exist in 1990's crypto library. */
SECItem *
SEC_ASN1EncodeLongLong(PRArenaPool *poolp, SECItem *dest,
				unsigned long long value)
{
	unsigned long copy;
	unsigned char sign;
	int len = 0;

	copy = value;
	do {
		len++;
		sign = (unsigned char)(copy & 0x80);
		copy >>= 8;
	} while (copy);

	if (sign)
		len++;

	dest = SECITEM_AllocItem(poolp, dest, len);
	if (dest == NULL)
		return NULL;

	memset(dest->data, '\0', len);

	dest->len = len;
	while (len) {
		dest->data[--len] = value & 0xff;
		value >>= 8;
	}

	return dest;
}

static const struct {
	mode_t mode;
	int idx;
	char c;
} modebits[] = {
	{S_IRUSR, 0, 'r'},
	{S_IWUSR, 1, 'w'},
	{S_IXUSR, 2, 'x'},
	{S_ISUID, 2, 's'},
	{S_IXUSR|S_ISUID, 2, 'S'},
	{S_IRGRP, 3, 'r'},
	{S_IWGRP, 4, 'w'},
	{S_IXGRP, 5, 'x'},
	{S_ISGID, 5, 's'},
	{S_IXGRP|S_ISGID, 5, 'S'},
	{S_IROTH, 6, 'r'},
	{S_IWOTH, 7, 'w'},
	{S_IXOTH, 8, 'x'},
	{S_ISVTX, 8, 't'},
	{S_IXOTH|S_ISVTX, 8, 'T'},
	{0, 0, 0}
};

static void
format_file_mode(mode_t mode, char modestr[10])
{
	for (unsigned int i = 0; modebits[i].mode != 0; i++) {
		mode_t mask = ~modebits[i].mode;
		if (~(mode & mask) == modebits[i].mode)
			modestr[modebits[i].idx] = modebits[i].c;
	}
}

static void
enforce_file_mode(mode_t badmask, const char * filename, int fd)
{
	struct stat statbuf;
	xpfstat(filename, fd, &statbuf);
	if (!(statbuf.st_mode & badmask))
		return;

	char filemode[] = "---------";

	close(fd);
	format_file_mode(statbuf.st_mode, filemode);
	errx(1, "Password file \"%s\" has unsafe file mode %s; not proceeding.",
	     filename, filemode);
}

static void
get_pw_env(pk12_file_t *file, const char *arg)
{
	if (!file)
		errx(1, "--pk12-pw-env must be paired with --pk12-in or --pk12-out");
	file->pw = secure_getenv(arg);
	if (file->pw == NULL)
		errx(1, "Environment variable \"%s\" is not set.", arg);
	file->pw = xstrdup(file->pw);
	if (!file->pw)
		err(1, "Could not allocate memory");
}

static void
get_pw_file(pk12_file_t *file, const char *arg)
{
	int fd;
	int rc;
	int errno_guard;
	char *pw = NULL;
	size_t pwsize = 0;

	if (!file)
		errx(1, "--pk12-pw-file must be paired with --pk12-in or --pk12-out");

	fd = xopen(arg, O_RDONLY);
	enforce_file_mode(0077, arg, fd);
	rc = read_file(fd, &pw, &pwsize);
	errno = 0;
	set_errno_guard_with_override(&errno_guard);

	close(fd);

	if (rc < 0)
		err(1, "Could not read \"%s\"", arg);
	for (ssize_t i = pwsize; i >= 0; i--) {
		switch (pw[i]) {
		case '\r':
		case '\n':
			pw[i] = '\0';
			/* fall through */
		case '\0':
			continue;
		default:
			break;
		}
	}
	file->pw = pw;
}

void
popt_callback(poptContext con UNUSED,
	      enum poptCallbackReason reason UNUSED,
	      const struct poptOption *opt,
	      const char *arg, const void *data)
{
	cms_context *cms = (cms_context *)data;
	static pk12_file_t *prev = NULL;
	pk12_file_t *file = NULL;

	if (!opt)
		return;

	switch (opt->shortName) {
	case '\0':
		if (!strcmp(opt->longName, "pk12-pw-env")) {
			get_pw_env(prev, arg);
		} else if (!strcmp(opt->longName, "pk12-pw-file")) {
			get_pw_file(prev, arg);
		} else {
			errx(1,
			     "Unknown option \"%s\" - how did it come to this?",
			     opt->longName);
		}
		break;

	case 'P':
		file = xcalloc(1, sizeof(*file));
		file->path = xstrdup(arg);
		file->fd = xopen(arg, O_RDONLY);
		list_add(&file->list, &cms->pk12_ins);
		prev = file;
		break;

	case 'O':
		file = &cms->pk12_out;
		if (file->path)
			errx(1, "pk12 output is already set to \"%s\"", file->path);
		file->path = xstrdup(arg);
		file->fd = xopen(arg, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0600);
		prev = file;
		break;

	default:
		errx(1, "How did it come to this?");
	}
}

static long verbose = 0;

long verbosity(void)
{
	return verbose;
}

struct algorithm {
	char name[16];
	int key_bits;
	unsigned long exponent;
};

struct algorithm algorithms[] = {
	{.name = "rsa2048",
	 .key_bits = 2048,
	 .exponent = 0x010001ul,
	},
	{.name = "rsa3072",
	 .key_bits = 3072,
	 .exponent = 0x010001ul,
	},
	{.name = "rsa4096",
	 .key_bits = 4096,
	 .exponent = 0x010001ul,
	},
	{.name = "",
	 .key_bits = 0,
	 .exponent = 0,
	}
};

int main(int argc, char *argv[])
{
	int is_ca = 0;
	int is_self_signed = -1;
	int modsign_eku = MODSIGN_EKU_NONE;
	char *orig_tokenname = "NSS Certificate DB";
	char *tokenname = orig_tokenname;
	char *signer = NULL;
	char *nickname = NULL;
	char *pubfile = NULL;
	char *cn = NULL;
	char *url = NULL;
	char *serial_str = NULL;
	char *issuer = NULL;
	char *orig_dbdir = "/etc/pki/pesign";
	char *dbdir = orig_dbdir;
	char *db_path = NULL, *dbx_path = NULL, *dbt_path = NULL;
	char *kek_nickname = NULL;
	unsigned long long serial = ULLONG_MAX;
	uuid_t serial_uuid;
	int rc;
	SECStatus status;
	char *not_valid_before = NULL, *not_valid_after = NULL;
	PRTime not_before = PR_Now();
	PRTime not_after;
	PRStatus prstatus;
	void *frees[50] = { NULL, };
	int nfrees = 0;
	int key_bits = 2048;
	unsigned long exponent = 0x010001ul;
	char *orig_algo = "rsa2048";
	char *algo = orig_algo;

	cms_context *cms = NULL;

	poptContext optCon;
	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesign" },
		/* global nss-ish things */
		{.longName = "dbdir",
		 .shortName = 'd',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &dbdir,
		 .descrip = "Directory for nss database",
		 .argDescrip = "<directory>"},
		{.longName = "token",
		 .shortName = 't',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &tokenname,
		 .descrip = "NSS token holding signing key",
		 .argDescrip = "<token>" },
		{.longName = "signer",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &signer,
		 .descrip = "Nickname for signing certificate",
		 .argDescrip = "<signer>" },

		/* type of thing we're creating */
		{.longName = "ca",
		 .shortName = 'C',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &is_ca,
		 .val = 1,
		 .descrip = "Generate a CA certificate" },
		{.longName = "self-sign",
		 .shortName = 'S',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &is_self_signed,
		 .val = 1,
		 .descrip = "Generate a self-signed certificate" },

		/* stuff about the generated key */
		{.longName = "algorithm",
		 .shortName = 'a',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &algo,
		 .descrip = "Algorithm for keys",
		 .argDescrip = "<algorithm>" },
		{.longName = "kek",
		 .shortName = 'K',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &modsign_eku,
		 .val = MODSIGN_EKU_KEK,
		 .descrip = "Generate a key to use as KEK" },
		{.longName = "kernel",
		 .shortName = 'k',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &modsign_eku,
		 .val = MODSIGN_EKU_KERNEL,
		 .descrip = "Generate a kernel-signing certificate" },
		{.longName = "module",
		 .shortName = 'm',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
		 .arg = &modsign_eku,
		 .val = MODSIGN_EKU_MODULE,
		 .descrip = "Generate a module-signing certificate" },
		{.longName = "nickname",
		 .shortName = 'n',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &nickname,
		 .descrip = "Generated certificate's nickname",
		 .argDescrip = "<nickname>" },
		{.longName = "common-name",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &cn,
		 .descrip = "Common Name for generated certificate",
		 .argDescrip = "<cn>" },
		{.longName = "url",
		 .shortName = 'u',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &url,
		 .descrip = "Issuer URL",
		 .argDescrip = "<url>" },
		{.longName = "serial",
		 .shortName = 's',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &serial_str,
		 .descrip = "Serial number (default: random)",
		 .argDescrip = "<serial>" },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &verbose,
		 .val = 1,
		 .descrip = "Be more verbose" },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &verbose,
		 .val = 2,
		 .descrip = "Be very verbose" },

		/* hidden things */
		{.longName = "pubkey",
		 .shortName = 'p',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &pubfile,
		 .descrip = "Use public key from file",
		 .argDescrip = "<pubkey>" },
		{.longName = "issuer-cn",
		 .shortName = 'i',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &issuer,
		 .descrip = "Issuer Common Name",
		 .argDescrip = "<issuer-cn>" },
		{.longName = "not-valid-before",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &not_valid_before,
		 .descrip = "\"Not Valid Before\" date",
		 .argDescrip = "<date>",
		},
		{.longName = "not-valid-after",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &not_valid_after,
		 .descrip = "\"Not Valid After\" date",
		 .argDescrip = "<date>",
		},

		/*
		 * The features below here are hidden because they're not
		 * really ready for consumption yet.
		 */
		{.longName = "pk12-in",
		 .shortName = 'P',
		 .argInfo = POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = (void *)popt_callback,
		 .descrip = (void *)cms,
		 .argDescrip = "<keydb.pk12>"},
		{.longName = "pk12-out",
		 .shortName = 'O',
		 .argInfo = POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = (void *)popt_callback,
		 .descrip = (void *)cms,
		 .argDescrip = "<out.pk12>"},
		{.longName = "pk12-pw-file",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = (void *)popt_callback,
		 .descrip = (void *)cms,
		 .argDescrip = "<file.pw>"},
		{.longName = "pk12-pw-env",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_CALLBACK|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = (void *)popt_callback,
		 .descrip = (void *)cms,
		 .argDescrip = "<ENVIRONMENT VARIABLE NAME>"},
		{.longName = "kek-nickname",
		 .shortName = 'K',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &kek_nickname,
		 .descrip = "Nickname of the KEK signing key (defaults to same as signer)",
		 .argDescrip = "<KEK nickname>"},
		{.longName = "make-efi-db",
		 .shortName = 'D',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &db_path,
		 .descrip = "File to store a signed DB append in",
		 .argDescrip = "<db.bin>"},
		{.longName = "make-efi-dbx",
		 .shortName = 'X',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &dbx_path,
		 .descrip = "File to store a signed DBX append in",
		 .argDescrip = "<dbx.bin>"},
		{.longName = "make-efi-dbt",
		 .shortName = 'T',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &dbt_path,
		 .descrip = "File to store a signed DBT append in",
		 .argDescrip = "<dbt.bin>"},

		/* automatic stuff */
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	rc = cms_context_alloc(&cms);
	if (rc < 0)
		liberr(1, "could not allocate cms context");

	optCon = poptGetContext("pesign", argc, (const char **)argv, options,0);

	rc = poptReadDefaultConfig(optCon, 0);
	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
		errx(1, "poptReadDefaultConfig failed: %s",
			poptStrerror(rc));

	while ((rc = poptGetNextOpt(optCon)) > 0) {
		switch (rc) {
		case 'a': frees[nfrees++] = algo; break;
		case 'c': frees[nfrees++] = cn; break;
		case 'D': frees[nfrees++] = db_path; break;
		case 'd': frees[nfrees++] = dbdir; break;
		case 'i': frees[nfrees++] = issuer; break;
		case 'K': frees[nfrees++] = kek_nickname; break;
		case 'n': frees[nfrees++] = nickname; break;
		case 'p': frees[nfrees++] = pubfile; break;
		case 's': frees[nfrees++] = serial_str; break;
		case 'T': frees[nfrees++] = dbt_path; break;
		case 't': frees[nfrees++] = tokenname; break;
		case 'u': frees[nfrees++] = url; break;
		case 'X': frees[nfrees++] = dbx_path; break;
		default: printf("rc is '%c' (0x%02hhx)\n", rc, rc); break;
		}
	}

	if (rc < -1)
		errx(1, "invalid argument: %s: %s",
			poptBadOption(optCon, 0), poptStrerror(rc));

	if (poptPeekArg(optCon))
		errx(1, "invalid Argument: \"%s\"",
			poptPeekArg(optCon));

	poptFreeContext(optCon);

	if (strcmp(algo, "help") == 0) {
		printf("Supported algorithms:");
		for (int i = 0; algorithms[i].name[0] != '\0'; i++)
			printf(" %s", algorithms[i].name);
		printf("\n");
		exit(0);
	}

	/*
	 * Scenarios that are okay (x == valid combination)
	 *
	 *		is_ca   is_self_signed  pubkey	modules	kernel
	 * i_c		x       x               x	o	o
	 * i_s_s	x       x               o	o	o
	 * pubkey	x       o               x	x	x
	 * modules	o	x		x	x	x
	 * kernel	o	x		x	x	x
	 */

	if (is_self_signed == -1)
		is_self_signed = is_ca && !signer ? 1 : 0;

	if (is_self_signed && signer)
		errx(1, "--self-sign and --signer cannot be "
			"used at the same time.");

	if (is_self_signed && pubfile)
		errx(1, "--self-sign and --pubkey cannot be "
			"used at the same time.");

	if (!cn)
		errx(1, "--common-name must be specified");

	if (!is_self_signed && !signer)
		errx(1, "signing certificate is required");

	for (int i=0; true; i++) {
		if (strcmp(algorithms[i].name, "") == 0)
			errx(1, "invalid algorithm: \"%s\"", algo);
		if (strcmp(algorithms[i].name, algo) == 0) {
			key_bits = algorithms[i].key_bits;
			exponent = algorithms[i].exponent;
			break;
		}
	}

	cms->tokenname = tokenname;
	cms->certname = signer;

	if (is_ca) {
		if (modsign_eku != MODSIGN_EKU_NONE)
			errx(1, "CA certificates cannot have kernel or module signing credentials.");
		modsign_eku = MODSIGN_EKU_CA;
	} else if (modsign_eku != MODSIGN_EKU_KERNEL
		   && modsign_eku != MODSIGN_EKU_MODULE
		   && modsign_eku != MODSIGN_EKU_KEK) {
		errx(1, "either --kernel or --module must be used");
	}

	if (!strcmp(dbdir, "-") && list_empty(&cms->pk12_ins) && !is_self_signed)
		errx(1, "'--dbdir -' requires either --pk12-in or --self-sign.");

	secuPWData pwdata;
	memset(&pwdata, 0, sizeof(pwdata));
	pwdata.source = pwdata.orig_source = PW_PROMPT;
	cms_set_pw_data(cms, &pwdata);

	PK11_SetPasswordFunc(cms->func ? cms->func : readpw);
	if (strcmp(dbdir, "-")) {
		if (cms->pk12_out.fd >= 0)
			status = NSS_Init(dbdir);
		else
			status = NSS_InitReadWrite(dbdir);
	} else {
		status = NSS_NoDB_Init(dbdir);
	}
	if (status != SECSuccess)
		nsserr(1, "could not initialize NSS");
	atexit((void (*)(void))NSS_Shutdown);

	SECKEYPublicKey *spubkey = NULL;
	SECKEYPrivateKey *sprivkey = NULL;

	SECKEYPublicKey *pubkey = NULL;
	SECKEYPrivateKey *privkey = NULL;

	status = register_oids(cms);
	if (status != SECSuccess)
		nsserr(1, "Could not register OIDs");

	PK11SlotInfo *slot = NULL;
	if (pubfile) {
		rc = get_pubkey_from_file(pubfile, &pubkey);
	} else {
		rc = find_slot_for_token(cms, &slot);
		if (rc < 0)
			nsserr(1, "could not find NSS slot for token \"%s\"",
				cms->tokenname);

		rc = generate_keys(cms, slot, &privkey, &pubkey, key_bits,
				   exponent);
	}
	if (rc < 0)
		exit(1);

	CERTName *issuer_name = NULL;
	if (issuer) {
		issuer_name = CERT_AsciiToName(issuer);
	} else if (is_self_signed) {
		issuer_name = CERT_AsciiToName(cn);
	} else {
		rc = find_certificate(cms, 1);
		if (rc < 0)
			nsserr(1, "could not find signing certificate "
				"\"%s:%s\"", cms->tokenname, cms->certname);
		issuer_name = &cms->cert->subject;
	}
	if (!issuer_name)
		nsserr(1, "could not find issuer name");

	if (is_self_signed) {
		spubkey = pubkey;
		sprivkey = privkey;
	} else {
		rc = find_certificate(cms, 1);
		if (rc < 0)
			exit(1);

		rc = get_signer_private_key(cms, &sprivkey);
		if (rc < 0)
			exit(1);

		rc = get_signer_public_key(cms, &spubkey);
		if (rc < 0)
			exit(1);
	}

	errno = 0;
	if (serial_str) {
		serial = strtoull(serial_str, NULL, 0);
		if (errno == ERANGE && serial == ULLONG_MAX)
			liberr(1, "invalid serial number");
	}

	if (not_valid_before) {
		unsigned long timeul;
		char *endptr;

		errno = 0;
		timeul = strtoul(not_valid_before, &endptr, 0);
		dbgprintf("not_valid_before:%lu", timeul);
		if (errno == 0 && endptr && *endptr == 0) {
			dbgprintf("not_valid_before:%lu", timeul);
			not_before = (PRTime)timeul * PR_USEC_PER_SEC;
		} else {
			prstatus = PR_ParseTimeString(not_valid_before,
						PR_TRUE, &not_before);
			conderrx(prstatus != PR_SUCCESS, 1,
				 "could not parse date \"%s\"",
				 not_valid_before);
		}
		dbgprintf("not_before:%"PRId64, not_before);
	}

	if (not_valid_after) {
		unsigned long timeul;
		char *endptr;

		errno = 0;
		dbgprintf("not_valid_after:%s", not_valid_after);
		timeul = strtoul(not_valid_after, &endptr, 0);
		dbgprintf("not_valid_after:%lu", timeul);
		if (errno == 0 && endptr && *endptr == 0) {
			dbgprintf("not_valid_after:%lu", timeul);
			not_after = (PRTime)timeul * PR_USEC_PER_SEC;
		} else {
			prstatus = PR_ParseTimeString(not_valid_after, PR_TRUE,
						      &not_after);
			conderrx(prstatus != PR_SUCCESS, 1,
				 "could not parse date \"%s\"",
				 not_valid_after);
		}
	} else {
		// Mon Jan 19 03:14:07 GMT 2037, aka 0x7fffffff minus 1 year.
		time_t time = 0x7ffffffful - 60ul * 60 * 24 * 365;
		dbgprintf("not_valid_after:%lu", time);
		not_after = (PRTime)time * PR_USEC_PER_SEC;
	}
	dbgprintf("not_after:%"PRId64, not_after);

	CERTValidity *validity = NULL;
	validity = CERT_CreateValidity(not_before, not_after);
	if (!validity)
		nsserr(1, "could not generate validity");

	CERTName *name = CERT_AsciiToName(cn);
	if (!name)
		nsserr(1, "could not generate certificate name");

	CERTSubjectPublicKeyInfo *spki = NULL;
	spki = SECKEY_CreateSubjectPublicKeyInfo(pubkey);
	if (!spki)
		nsserr(1, "could not generate public key information");

	SECItem *attributes = NULL;

	CERTCertificateRequest *crq = NULL;
	crq = CERT_CreateCertificateRequest(name, spki, &attributes);

	rc = add_extensions_to_crq(cms, crq, is_ca,
				   modsign_eku == MODSIGN_EKU_KEK,
				   is_self_signed, pubkey,
				   spubkey, url, modsign_eku);
	if (rc < 0)
		exit(1);

	CERTCertificate *cert = NULL;
	cert = CERT_CreateCertificate(0, issuer_name, validity, crq);
	*(cert->version.data) = 2;
	cert->version.len = 1;

	cert->subjectName = cn;
	cert->issuerName = is_self_signed ? cn : issuer;

	cert->serialNumber.data = NULL;
	cert->serialNumber.len = 0;

	memcpy(&cert->issuer, issuer_name, sizeof (cert->issuer));
	memcpy(&cert->subject, name, sizeof (cert->subject));

	if (serial == ULLONG_MAX && serial_str == NULL) {
		uuid_clear(serial_uuid);
		if (!uuid_is_null(serial_uuid))
			liberr(1, "Null serial number wasn't null");
		uuid_generate_random(serial_uuid);
		if (uuid_is_null(serial_uuid))
			liberr(1, "Random serial number was null");

		if (serial_uuid[0] & 0x80) {
			int type = cert->serialNumber.type;
			SECItem *ret;
			ret = SECITEM_AllocItem(cms->arena, &cert->serialNumber,
				sizeof(serial_uuid) + 1);
			if (!ret)
				nsserr(1, "Could not allocate serial number");
			cert->serialNumber.data[0] = '\0';
			memcpy(cert->serialNumber.data + 1, serial_uuid,
				sizeof (serial_uuid));
			cert->serialNumber.type = type;
		} else {
			cert->serialNumber.data = serial_uuid;
			cert->serialNumber.len = sizeof (serial_uuid);
		}
	} else {
		SECItem *ret = SEC_ASN1EncodeLongLong(cms->arena,
					&cert->serialNumber,
					serial);
		if (!ret)
			nsserr(1, "Could not allocate serial number");
	}

	rc = populate_extensions(cms, cert, crq);
	if (rc < 0)
		exit(1);

	rc = generate_algorithm_id(cms, &cert->signature, SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION);
	if (rc < 0)
		nsserr(1, "could not generate certificate type OID");

	SECItem certder;
	memset(&certder, '\0', sizeof (certder));

	void *ret;
	ret = SEC_ASN1EncodeItem(cms->arena, &certder, cert,
		CERT_CertificateTemplate);
	if (ret == NULL)
		nsserr(1, "could not encode certificate");

	if (is_self_signed) {
		cms->cert = cert;
#if 0
		status = SEC_QuickDERDecodeItem(cms->arena, &cms->cert,
			CERT_CertificateTemplate, &certder);
		if (status != SECSuccess)
			nsserr(1, "could not decode certificate");
#endif
	}

	SECOidData *oid;
	oid = SECOID_FindOIDByTag(SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION);
	if (!oid)
		nsserr(1, "could not find OID for SHA256+RSA");

	SECItem signature;
	status = SEC_SignData(&signature, certder.data, certder.len,
				sprivkey, oid->offset);
	if (status != SECSuccess)
		nsserr(1, "could not create signature");

	SECItem sigder = { 0, };
	bundle_signature(cms, &sigder, &certder,
				SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION,
				&signature);

	status = PK11_ImportDERCert(slot, &sigder, CK_INVALID_HANDLE, nickname,
				PR_FALSE);
	if (status != SECSuccess)
		nsserr(1, "could not import signature");

	CERTIssuerAndSN ias;
	memcpy(&ias.derIssuer, &cert->derIssuer, sizeof(ias.derIssuer));
	memcpy(&ias.issuer, &cert->issuer, sizeof(ias.issuer));
	memcpy(&ias.serialNumber, &cert->serialNumber, sizeof(ias.serialNumber));

	add_trust(cms, &ias, is_ca ? ",,CTu" : ",,u");

	SECITEM_FreeItem(&sigder, PR_FALSE);
	SECITEM_FreeItem(&signature, PR_FALSE);

	if (privkey != sprivkey)
		SECKEY_DestroyPrivateKey(sprivkey);
	SECKEY_DestroyPrivateKey(privkey);
	if (pubkey != spubkey)
		SECKEY_DestroyPublicKey(spubkey);
	SECKEY_DestroyPublicKey(pubkey);

	SECKEY_DestroySubjectPublicKeyInfo(spki);

	if (issuer || is_self_signed)
		CERT_DestroyName(issuer_name);
	CERT_DestroyName(name);
	CERT_DestroyValidity(validity);

	CERT_DestroyCertificateRequest(crq);

	cms_context_fini(cms);

	NSS_Shutdown();

	if (signer)
		free(signer);
	if (not_valid_before)
		free(not_valid_before);
	if (not_valid_after)
		free(not_valid_after);

	for (int i = 0; i < nfrees; i++)
		free(frees[i]);

	return 0;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/endian.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * endian.h - endian swizzling helpers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef ENDIAN_H
#define ENDIAN_H

#include <endian.h>

#if __BYTE_ORDER == __LITTLE_ENDIAN
#define cpu_to_le16(x) (x)
#define cpu_to_le32(x) (x)
#define cpu_to_le64(x) (x)
#define le16_to_cpu(x) (x)
#define le32_to_cpu(x) (x)
#define le64_to_cpu(x) (x)
#define cpu_to_be16(x) __builtin_bswap16(x)
#define cpu_to_be32(x) __builtin_bswap32(x)
#define cpu_to_be64(x) __builtin_bswap64(x)
#define be16_to_cpu(x) __builtin_bswap16(x)
#define be32_to_cpu(x) __builtin_bswap32(x)
#define be64_to_cpu(x) __builtin_bswap64(x)
#else
#define cpu_to_be16(x) (x)
#define cpu_to_be32(x) (x)
#define cpu_to_be64(x) (x)
#define be16_to_cpu(x) (x)
#define be32_to_cpu(x) (x)
#define be64_to_cpu(x) (x)
#define cpu_to_le16(x) __builtin_bswap16(x)
#define cpu_to_le32(x) __builtin_bswap32(x)
#define cpu_to_le64(x) __builtin_bswap64(x)
#define le16_to_cpu(x) __builtin_bswap16(x)
#define le32_to_cpu(x) __builtin_bswap32(x)
#define le64_to_cpu(x) __builtin_bswap64(x)
#endif

#endif /* ENDIAN_H */
/* vim:set shiftwidth=8 softtabstop=8: */

```

`src/err.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _LINUX_ERR_H
#define _LINUX_ERR_H

#include <stdbool.h>
#include <asm/errno.h>

#include "compiler.h"

/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a normal
 * pointer with the same return value.
 *
 * This should be a per-architecture thing, to allow different
 * error and pointer decisions.
 */
#define MAX_ERRNO	4095

#ifndef __ASSEMBLY__

#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)

static inline void * ERR_PTR(long error)
{
	return (void *) error;
}

static inline long PTR_ERR(const void *ptr)
{
	return (long) ptr;
}

static inline bool IS_ERR(const void *ptr)
{
	return IS_ERR_VALUE((unsigned long)ptr);
}

static inline bool IS_ERR_OR_NULL(const void *ptr)
{
	return unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);
}

/**
 * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type
 * @ptr: The pointer to cast.
 *
 * Explicitly cast an error-valued pointer to another pointer type in such a
 * way as to make it clear that's what's going on.
 */
static inline void * ERR_CAST(const void *ptr)
{
	/* cast away the const */
	return (void *) ptr;
}

static inline int PTR_ERR_OR_ZERO(const void *ptr)
{
	if (IS_ERR(ptr))
		return PTR_ERR(ptr);
	else
		return 0;
}

/* Deprecated */
#define PTR_RET(p) PTR_ERR_OR_ZERO(p)

#endif

#endif /* _LINUX_ERR_H */

```

`src/errno-guard.c`:

```c
/*
 * errno-guard.c
 * Copyright 2019 Peter Jones <pjones@redhat.com>
 *
 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <errno.h>
#include <stdio.h>

#include "compiler.h"
#include "errno-guard.h"

__thread int errno_guards_[ERRNO_GUARD_ENTRIES_];
__thread int errno_guard_no_ = -1;

void
clean_up_errno_guard_(int *handle)
{
	if (*handle < 0
	    || *handle >= ERRNO_GUARD_ENTRIES_
	    || *handle > errno_guard_no_)
		return;

	if (errno_guards_[*handle] >= 0) {
		errno = errno_guards_[*handle];
		errno_guard_no_ = *handle - 1;
	}
	*handle = -1;
}

int
set_up_errno_guard_(int *handle)
{
	int guard_var = ++errno_guard_no_;

	if (guard_var < ERRNO_GUARD_ENTRIES_)
		errno_guards_[guard_var] = errno;

	if (handle)
		*handle = guard_var;
	return guard_var;
}

int
override_errno_guard(int *handle, int error)
{
	if (handle == NULL
	    || *handle < 0
	    || *handle >= ERRNO_GUARD_ENTRIES_)
		return -1;

	if (*handle > errno_guard_no_) {
		*handle = -1;
		return -1;
	}

	errno = error;
	errno_guard_no_ = *handle;

	return *handle;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/errno-guard.h`:

```h
/*
 * errno-guard.h
 * Copyright 2019 Peter Jones <pjones@redhat.com>
 */

#ifndef ERRNO_GUARD_H_
#define ERRNO_GUARD_H_

#define ERRNO_GUARD_ENTRIES_ ((int)(4096 / sizeof(int)))

extern __thread int errno_guards_[ERRNO_GUARD_ENTRIES_];
extern __thread int errno_guard_no_;

extern void clean_up_errno_guard_(int *handle);
extern int set_up_errno_guard_(int *handle);

#define guard_errno_(handle, guard_var) \
	CLEANUP_FUNC(clean_up_errno_guard_) UNUSED int guard_var = set_up_errno_guard_(handle)
#define errno_guard_var_ CAT(CAT(CAT(CAT(errno_guard_,__LINE__),_),__COUNTER__),_)

extern int override_errno_guard(int *handle, int error);
#define set_errno_guard() guard_errno_(NULL, errno_guard_var_)
#define set_errno_guard_with_override(handle) guard_errno_(handle, errno_guard_var_)

#endif /* !ERRNO_GUARD_H_ */
// vim:fenc=utf-8:tw=75:noet

```

`src/file_kmod.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * file_kmod.c - our kmod file type helpers.
 * Copyright 2017 Endless Mobile, Inc.
 *
 * Author(s): Daniel Drake <drake@endlessm.com>
 */
#include "fix_coverity.h"

#include <stdint.h>

#include "pesign.h"

#include <prerror.h>

int
kmod_generate_digest(cms_context *cms, unsigned char *addr, size_t len)
{
	int rc;

	rc = generate_digest_begin(cms);
	if (rc < 0) {
		cms->log(cms, LOG_ERR, "failed to begin digest: %d", rc);
		return rc;
	}

	generate_digest_step(cms, addr, len);

	rc = generate_digest_finish(cms);
	if (rc < 0) {
		cms->log(cms, LOG_ERR, "failed to finish digest: %d", rc);
		return rc;
	}

	return 0;
}

struct write_sig_info {
	int outfd;
	int rc;
	size_t sig_len;
};

static void
kmod_signature_out(void *arg, const char *buf, unsigned long len)
{
	struct write_sig_info *info = (struct write_sig_info *) arg;
	int rc;

	rc = write_file(info->outfd, buf, len);
	if (rc < 0) {
		info->rc = rc;
		return;
	}

	info->sig_len += len;
}

ssize_t
kmod_write_signature(cms_context *cms, int outfd)
{
	SEC_PKCS7ContentInfo *cinfo;
	SECItem *digest = cms->digests[cms->selected_digest].pe_digest;
	SECStatus rv;
	struct write_sig_info info = {
		.outfd = outfd,
	};
	ssize_t rc = -1;

	cinfo = SEC_PKCS7CreateSignedData(cms->cert,
					  certUsageObjectSigner, NULL,
					  digest_get_digest_oid(cms),
					  digest, NULL, NULL);
	if (!cinfo) {
		cms->log(cms, LOG_ERR, "failed to create signed data: %s (%s)",
			 PORT_ErrorToString(PORT_GetError()),
			 PORT_ErrorToName(PORT_GetError()));
		return -1;
	}

	rv = SEC_PKCS7Encode(cinfo, kmod_signature_out, &info, NULL, NULL,
			     NULL);
	if (rv != SECSuccess) {
		cms->log(cms, LOG_ERR, "failed to encode signed data: %d", rv);
		goto out;
	}

	if (info.rc != 0) {
		cms->log(cms, LOG_ERR, "Signed data encode error %d", info.rc);
		rc = info.rc;
		goto out;
	}

	rc = info.sig_len;

out:
	SEC_PKCS7DestroyContentInfo(cinfo);
	return rc;
}

static const char magic_number[] = "~Module signature appended~\n";
#define PKEY_ID_PKCS7 2

struct module_signature {
	uint8_t algo;		/* Public-key crypto algorithm [0] */
	uint8_t hash;		/* Digest algorithm [0] */
	uint8_t id_type;	/* Key identifier type [PKEY_ID_PKCS7] */
	uint8_t signer_len;	/* Length of signer's name [0] */
	uint8_t key_id_len;	/* Length of key identifier [0] */
	uint8_t __pad[3];
	uint32_t sig_len;	/* Length of signature data */
};

int
kmod_write_sig_info(cms_context *cms, int fd, uint32_t sig_len)
{
	struct module_signature sig_info = { .id_type = PKEY_ID_PKCS7 };

	sig_info.sig_len = htonl(sig_len);
	if (write_file(fd, &sig_info, sizeof(sig_info)) < 0) {
		cms->log(cms, LOG_ERR, "failed to write sig_info: %m");
		return -1;
	}

	if (write_file(fd, magic_number, sizeof(magic_number) - 1) < 0) {
		cms->log(cms, LOG_ERR, "failed to write magic: %m");
		return -1;
	}

	return 0;
}

```

`src/file_kmod.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * file_kmod.h - decls for our kmod file type helpers.
 * Copyright 2017 Endless Mobile, Inc.
 *
 * Author(s): Daniel Drake <drake@endlessm.com>
 */
#ifndef KMOD_COMMON_H
#define KMOD_COMMON_H 1

#include <stdint.h>
#include "pesign_context.h"

int kmod_generate_digest(cms_context *cms, unsigned char *addr, size_t len);
ssize_t kmod_write_signature(cms_context *cms, int outfd);
int kmod_write_sig_info(cms_context *cms, int fd, uint32_t sig_len);

#endif


```

`src/file_pe.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * file_pe.c - decls for our PE file type helpers.
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <prerror.h>
#include <err.h>

#include "pesign.h"
#include "pesign_standalone.h"

static void
open_input(pesign_context *ctx)
{
	conderrx(!ctx->infile, 1, "No input file specified.");

	struct stat statbuf;
	ctx->infd = open(ctx->infile, O_RDONLY|O_CLOEXEC);
	stat(ctx->infile, &statbuf);
	ctx->outmode = statbuf.st_mode;

	conderr(ctx->infd < 0, 1, "Error opening input");

	Pe_Cmd cmd = ctx->infd == STDIN_FILENO ? PE_C_READ : PE_C_READ_MMAP;
	ctx->inpe = pe_begin(ctx->infd, cmd, NULL);
	conderrx(!ctx->inpe, 1, "could not load input file \"%s\": %s",
		 ctx->infile, pe_errmsg(pe_errno()));

	int rc = parse_signatures(&ctx->cms_ctx->signatures,
				  &ctx->cms_ctx->num_signatures, ctx->inpe);
	conderrx(rc < 0, 1, "could not parse signature list in EFI binary");
}

static void
close_input(pesign_context *ctx)
{
	pe_end(ctx->inpe);
	ctx->inpe = NULL;

	close(ctx->infd);
	ctx->infd = -1;
}

static void
close_output(pesign_context *ctx)
{
	Pe_Cmd cmd = ctx->outfd == STDOUT_FILENO ? PE_C_RDWR : PE_C_RDWR_MMAP;

	finalize_signatures(ctx->cms_ctx->signatures,
				ctx->cms_ctx->num_signatures, ctx->outpe);
	pe_update(ctx->outpe, cmd);
	pe_end(ctx->outpe);
	ctx->outpe = NULL;

	close(ctx->outfd);
	ctx->outfd = -1;
}

static void
open_output(pesign_context *ctx)
{
	conderrx(!ctx->outfile, 1, "No output file specified.");

	if (access(ctx->outfile, F_OK) == 0 && ctx->force == 0)
		errx(1, "\"%s\" exists and --force was not given.",
		     ctx->outfile);

	ctx->outfd = open(ctx->outfile, O_RDWR|O_CREAT|O_TRUNC|O_CLOEXEC,
			ctx->outmode);
	conderr(ctx->outfd < 0, 1, "Error opening \"%s\" for output",
		ctx->outfile);

	size_t size;
	char *addr;

	addr = pe_rawfile(ctx->inpe, &size);

	ftruncate(ctx->outfd, size);
	lseek(ctx->outfd, 0, SEEK_SET);
	write(ctx->outfd, addr, size);

	Pe_Cmd cmd = ctx->outfd == STDOUT_FILENO ? PE_C_RDWR : PE_C_RDWR_MMAP;
	ctx->outpe = pe_begin(ctx->outfd, cmd, NULL);
	conderrx(!ctx->outpe, 1, "could not load output file \"%s\": %s",
		 ctx->outfile, pe_errmsg(pe_errno()));

	pe_clearcert(ctx->outpe);
}

define_input_file(rawsig, rawsig, "raw signature");
define_input_file(sattr, insattrs, "signed attributes");
define_output_file(sattr, outsattrs, "signed attributes");
define_input_file(sig, insig, "signature");
define_output_file(sig, outsig, "signature");
define_output_file(pubkey, outkey, "pubkey");
define_output_file(cert, outcert, "certificate");

static void
check_inputs(pesign_context *ctx)
{
	conderrx(!ctx->infile, 1, "No input file specified.");
	conderrx(!ctx->outfile, 1, "No output file specified.");

	conderrx(!strcmp(ctx->infile, ctx->outfile), 1,
		 "in-place file editing is not yet supported.");
}

static void
print_digest(pesign_context *pctx)
{
	if (!pctx)
		return;

	cms_context *ctx = pctx->cms_ctx;
	if (!ctx)
		return;

	int j = ctx->selected_digest;
	for (unsigned int i = 0; i < ctx->digests[j].pe_digest->len; i++)
		printf("%02x",
			(unsigned char)ctx->digests[j].pe_digest->data[i]);
	printf(" %s\n", pctx->infile);
}

void
pe_handle_action(pesign_context *ctxp, int action, int padding)
{
	ssize_t sigspace = 0;
	int perr;
	int rc;

	switch (action) {
		/* in this case we have the actual binary signature and the
		 * signing cert, but not the pkcs7ish certificate that goes
		 * with it.
		 */
		case IMPORT_RAW_SIGNATURE|IMPORT_SATTRS:
			check_inputs(ctxp);
			rc = find_certificate(ctxp->cms_ctx, 0);
			conderrx(rc < 0, 1, "Could not find certificate %s\n",
				 ctxp->cms_ctx->certname);
			open_rawsig_input(ctxp);
			open_sattr_input(ctxp);
			import_raw_signature(ctxp);
			close_sattr_input(ctxp);
			close_rawsig_input(ctxp);

			open_input(ctxp);
			open_output(ctxp);
			close_input(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->outpe, 1);
			if (rc < 0)
				err(1, "generate_digest() failed");
			sigspace = calculate_signature_space(ctxp->cms_ctx,
								ctxp->outpe);
			allocate_signature_space(ctxp->outpe, sigspace);
			generate_signature(ctxp->cms_ctx);
			insert_signature(ctxp->cms_ctx, ctxp->signum);
			close_output(ctxp);
			break;
		case EXPORT_SATTRS:
			open_input(ctxp);
			open_sattr_output(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->inpe, 1);
			if (rc < 0)
				err(1, "generate_digest() failed");
			generate_sattr_blob(ctxp);
			close_sattr_output(ctxp);
			close_input(ctxp);
			break;
		/* add a signature from a file */
		case IMPORT_SIGNATURE:
			check_inputs(ctxp);
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures + 1,
				 1, "Invalid signature number.");
			open_input(ctxp);
			open_output(ctxp);
			close_input(ctxp);
			open_sig_input(ctxp);
			parse_signature(ctxp);
			sigspace = get_sigspace_extend_amount(ctxp->cms_ctx,
					ctxp->outpe, &ctxp->cms_ctx->newsig);
			allocate_signature_space(ctxp->outpe, sigspace);
			check_signature_space(ctxp);
			insert_signature(ctxp->cms_ctx, ctxp->signum);
			close_sig_input(ctxp);
			close_output(ctxp);
			break;
		case EXPORT_PUBKEY:
			rc = find_certificate(ctxp->cms_ctx, 1);
			conderrx(rc < 0, 1, "Could not find certificate %s",
				 ctxp->cms_ctx->certname);
			open_pubkey_output(ctxp);
			export_pubkey(ctxp);
			break;
		case EXPORT_CERT:
			rc = find_certificate(ctxp->cms_ctx, 0);
			conderrx(rc < 0, 1, "Could not find certificate %s",
				 ctxp->cms_ctx->certname);
			open_cert_output(ctxp);
			export_cert(ctxp);
			break;
		/* find a signature in the binary and save it to a file */
		case EXPORT_SIGNATURE:
			open_input(ctxp);
			open_sig_output(ctxp);
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures,
				 1, "Invalid signature number.");
			if (ctxp->signum < 0)
				ctxp->signum = 0;
			conderrx(ctxp->signum >= ctxp->cms_ctx->num_signatures,
				 1, "No valid signature #%d.", ctxp->signum);
			memcpy(&ctxp->cms_ctx->newsig,
				ctxp->cms_ctx->signatures[ctxp->signum],
				sizeof (ctxp->cms_ctx->newsig));
			export_signature(ctxp->cms_ctx, ctxp->outsigfd, ctxp->ascii);
			close_input(ctxp);
			close_sig_output(ctxp);
			memset(&ctxp->cms_ctx->newsig, '\0',
				sizeof (ctxp->cms_ctx->newsig));
			break;
		/* remove a signature from the binary */
		case REMOVE_SIGNATURE:
			check_inputs(ctxp);
			open_input(ctxp);
			open_output(ctxp);
			close_input(ctxp);
			if (ctxp->signum < 0)
				ctxp->signum = 0;
			if (ctxp->signum >= ctxp->cms_ctx->num_signatures) {
				warnx("Invalid signature number %d.",
				      ctxp->signum);
				errx(1, "Must be between 0 and %d.",
				     ctxp->cms_ctx->num_signatures - 1);
			}
			remove_signature(ctxp);
			close_output(ctxp);
			break;
		/* list signatures in the binary */
		case LIST_SIGNATURES:
			open_input(ctxp);
			list_signatures(ctxp);
			break;
		case GENERATE_DIGEST|PRINT_DIGEST|OMIT_VENDOR_CERT:
			open_input(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->inpe, padding);
			if (rc < 0)
				err(1, "generate_digest() failed");
			print_digest(ctxp);
			break;
		case GENERATE_DIGEST|PRINT_DIGEST:
			open_input(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->inpe, padding);
			if (rc < 0)
				err(1, "generate_digest() failed");
			print_digest(ctxp);
			break;
		/* generate a signature and save it in a separate file */
		case EXPORT_SIGNATURE|GENERATE_SIGNATURE:
			perr = PORT_GetError();
			dbgprintf("PORT_GetError():%s:%s",
				  PORT_ErrorToName(perr), PORT_ErrorToString(perr));
			PORT_SetError(0);
			rc = find_certificate(ctxp->cms_ctx, 1);
			conderrx(rc < 0, 1, "Could not find certificate %s",
				 ctxp->cms_ctx->certname);
			open_input(ctxp);
			open_sig_output(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->inpe, 1);
			if (rc < 0)
				err(1, "generate_digest() failed");
			generate_signature(ctxp->cms_ctx);
			export_signature(ctxp->cms_ctx, ctxp->outsigfd, ctxp->ascii);
			break;
		/* generate a signature and embed it in the binary */
		case IMPORT_SIGNATURE|GENERATE_SIGNATURE:
			check_inputs(ctxp);
			perr = PORT_GetError();
			dbgprintf("PORT_GetError():%s:%s",
				  PORT_ErrorToName(perr), PORT_ErrorToString(perr));
			rc = find_certificate(ctxp->cms_ctx, 1);
			conderrx(rc < 0, 1, "Could not find certificate %s",
				 ctxp->cms_ctx->certname);
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures + 1,
				 1, "Invalid signature number.");
			open_input(ctxp);
			open_output(ctxp);
			close_input(ctxp);
			rc = generate_digest(ctxp->cms_ctx, ctxp->outpe, 1);
			if (rc < 0)
				err(1, "generate_digest() failed");
			sigspace = calculate_signature_space(ctxp->cms_ctx,
							     ctxp->outpe);
			allocate_signature_space(ctxp->outpe, sigspace);
			rc = generate_digest(ctxp->cms_ctx, ctxp->outpe, 1);
			if (rc < 0)
				err(1, "generate_digest() failed");
			generate_signature(ctxp->cms_ctx);
			insert_signature(ctxp->cms_ctx, ctxp->signum);
			close_output(ctxp);
			break;
		default:
			fprintf(stderr, "%s: Incompatible flags (0x%08x): ",
				program_invocation_short_name, action);
			for (int i = 1; i < FLAG_LIST_END; i <<= 1) {
				if (action & i)
					print_flag_name(stderr, i);
			}
			fprintf(stderr, "\n");
			exit(1);
	}
}

// vim:fenc=utf-8:tw=75:noet

```

`src/fix_coverity.h`:

```h
/*
 * fix_coverity.h
 * Copyright Peter Jones <pjones@redhat.com>
 *
 * Distributed under terms of the GPLv3 license.
 */

#ifndef FIX_COVERITY_H
#define FIX_COVERITY_H

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#ifndef __COVERITY_GCC_VERSION_AT_LEAST
#define __COVERITY_GCC_VERSION_AT_LEAST(x, y) 0
#define FAKE__COVERITY_GCC_VERSION_AT_LEAST__
#endif /* __COVERITY_GCC_VERSION_AT_LEAST */

/* With gcc 7 on x86_64 (at least), coverity pretends to be GCC but
 * accidentally doesn't create all of the types GCC would.
 *
 * In glibc's headers, bits/floatn.h has:
 *
 * #if (defined __x86_64__                                              \
 *   ? __GNUC_PREREQ (4, 3)                                             \
 *   : (defined __GNU__ ? __GNUC_PREREQ (4, 5) : __GNUC_PREREQ (4, 4)))
 * # define __HAVE_FLOAT128 1
 * #else
 * # define __HAVE_FLOAT128 0
 * #endif
 *
 * and stdlib.h has:
 *
 * #if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)
 * slash* Likewise for the '_Float128' format  *slash
 * extern _Float128 strtof128 (const char *__restrict __nptr,
 *                       char **__restrict __endptr)
 *      __THROW __nonnull ((1));
 * #endif
 *
 * Which then causes cov-emit to lose its shit:
 *
 * "/usr/include/stdlib.h", line 133: error #20: identifier "_Float128" is
 *           undefined
 *   extern _Float128 strtof128 (const char *__restrict __nptr,
 *          ^
 * "/usr/include/stdlib.h", line 190: error #20: identifier "_Float128" is
 *           undefined
 *                         _Float128 __f)
 *                         ^
 * "/usr/include/stdlib.h", line 236: error #20: identifier "_Float128" is
 *           undefined
 *   extern _Float128 strtof128_l (const char *__restrict __nptr,
 *          ^
 *
 * And then you'll notice something like this later on:
 * [WARNING] Emitted 0 C/C++ compilation units (0%) successfully
 *
 * 0 C/C++ compilation units (0%) are ready for analysis
 *  For more details, please look at:
 *     /home/pjones/devel/github.com/dbxtool/master/cov-int/build-log.txt
 *
 * You would think that if you're writing something that pretends to be
 * gcc, and you've got a "build a configuration by running shit through gcc
 * and looking at the output" stage (which they do), you would run "gcc -da
 * -fdump-tree-all -c -o foo.o foo.c" on an empty file and snarf up all the
 * types defined in the foo.c.001t.tu output.  Apparently, they do not.
 *
 * Anyway, even just defining the type doesn't always work in the face of
 * how _Complex is defined, so we cheat a bit here.  Be prepared to vomit.
 */
#ifdef __x86_64__
#if __COVERITY_GCC_VERSION_AT_LEAST(7, 0)
#if 0
typedef float _Float128 __attribute__((__mode__(__TF__)));
typedef __complex__ float __cfloat128 __attribute__ ((__mode__ (__TC__)));
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
#else
#include <unistd.h>
#define __cplusplus 201103L
#include <bits/floatn.h>
#undef __cplusplus
#endif
#endif
#endif

#ifdef FAKE__COVERITY_GCC_VERSION_AT_LEAST__
#undef FAKE__COVERITY_GCC_VERSION_AT_LEAST
#undef __COVERITY_GCC_VERSION_AT_LEAST
#endif

#endif /* !FIX_COVERITY_H */
// vim:fenc=utf-8:tw=75
```

`src/hex.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * hex.h - hexidecimal conversion helpers
 * Copyright Peter Jones <pjones@redhat.com>
 */
#ifndef HEX_H_
#define HEX_H_

static inline uint8_t hexchar_to_bin(char hex)
{
	if (hex >= '0' && hex <= '9')
		return hex - '0';
	if (hex >= 'A' && hex <= 'F')
		return hex - 'A' + 10;
	if (hex >= 'a' && hex <= 'f')
		return hex - 'a' + 10;
	return -1;
}

static inline int
hex_to_bin(const char *hex, uint8_t *out, size_t size)
{
	for (size_t i = 0, j = 0; j < size; i+= 2, j++) {
		uint8_t val;

		val = hexchar_to_bin(hex[i]);
		if (val > 15)
			goto out_of_range;
		out[j] = (val & 0xf) << 4;

		val = hexchar_to_bin(hex[i+1]);
		if (val > 15)
			goto out_of_range;
		out[j] |= val & 0xf;
	}

	errno = 0;
	return 0;
out_of_range:
	errno = ERANGE;
	return -1;
}

#endif /* !HEX_H_ */
// vim:fenc=utf-8:tw=75:noet

```

`src/list.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
/* Copied from the Linux kernel, in linux/include/linux/list.h */

#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#include <stdbool.h>

#include "compiler.h"
#include "err.h"

# define POISON_POINTER_DELTA 0
/*
 * These are non-NULL pointers that will result in page faults
 * under normal circumstances, used to verify that nobody uses
 * non-initialized list entries.
 */
#define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)

/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
			 !__same_type(*(ptr), void),			\
			 "pointer type mismatch in container_of()");	\
	((type *)(__mptr - offsetof(type, member))); })

/**
 * container_of_safe - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.
 */
#define container_of_safe(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
			 !__same_type(*(ptr), void),			\
			 "pointer type mismatch in container_of()");	\
	IS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :			\
		((type *)(__mptr - offsetof(type, member))); })



/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions ("__xxx") are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */

struct list_head {
	struct list_head *next, *prev;
};

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next, **pprev;
};

typedef struct list_head list_t;

#define LIST_HEAD_INIT(name) { &(name), &(name) }

#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

#define INIT_LIST_HEAD(ptr) ({ (ptr)->next = (ptr); (ptr)->prev = (ptr); })

/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head * new,
	struct list_head * prev,
	struct list_head * next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	WRITE_ONCE(prev->next, new);
}

/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
}


/**
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
}

/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
	WRITE_ONCE(prev->next, next);
}

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del_entry(entry);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
}

/**
 * list_replace - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
	new->next->prev = new;
	new->prev = old->prev;
	new->prev->next = new;
}

static inline void list_replace_init(struct list_head *old,
				     struct list_head *new)
{
	list_replace(old, new);
	INIT_LIST_HEAD(old);
}

/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
	__list_del_entry(entry);
	INIT_LIST_HEAD(entry);
}

/**
 * list_move - delete from one list and add as another's head
 * @list: the entry to move
 * @head: the head that will precede our entry
 */
static inline void list_move(struct list_head *list, struct list_head *head)
{
	__list_del_entry(list);
	list_add(list, head);
}

/**
 * list_move_tail - delete from one list and add as another's tail
 * @list: the entry to move
 * @head: the head that will follow our entry
 */
static inline void list_move_tail(struct list_head *list,
				  struct list_head *head)
{
	__list_del_entry(list);
	list_add_tail(list, head);
}

/**
 * list_bulk_move_tail - move a subsection of a list to its tail
 * @head: the head that will follow our entry
 * @first: first entry to move
 * @last: last entry to move, can be the same as first
 *
 * Move all entries between @first and including @last before @head.
 * All three entries must belong to the same linked list.
 */
static inline void list_bulk_move_tail(struct list_head *head,
				       struct list_head *first,
				       struct list_head *last)
{
	first->prev->next = last->next;
	last->next->prev = first->prev;

	head->prev->next = first;
	first->prev = head->prev;

	last->next = head;
	head->prev = last;
}

/**
 * list_is_first -- tests whether @ list is the first entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */
static inline int list_is_first(const struct list_head *list,
				const struct list_head *head)
{
	return list->prev == head;
}

/**
 * list_is_last - tests whether @list is the last entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */
static inline int list_is_last(const struct list_head *list,
			       const struct list_head *head)
{
	return list->next == head;
}

/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return READ_ONCE(head->next) == head;
}

/**
 * list_empty_careful - tests whether a list is empty and not being modified
 * @head: the list to test
 *
 * Description:
 * tests whether a list is empty _and_ checks that no other CPU might be
 * in the process of modifying either member (next or prev)
 *
 * NOTE: using list_empty_careful() without synchronization
 * can only be safe if the only activity that can happen
 * to the list entry is list_del_init(). Eg. it cannot be used
 * if another CPU could re-list_add() it.
 */
static inline int list_empty_careful(const struct list_head *head)
{
	struct list_head *next = head->next;
	return (next == head) && (next == head->prev);
}

/**
 * list_rotate_left - rotate the list to the left
 * @head: the head of the list
 */
static inline void list_rotate_left(struct list_head *head)
{
	struct list_head *first;

	if (!list_empty(head)) {
		first = head->next;
		list_move_tail(first, head);
	}
}

/**
 * list_is_singular - tests whether a list has just one entry.
 * @head: the list to test.
 */
static inline int list_is_singular(const struct list_head *head)
{
	return !list_empty(head) && (head->next == head->prev);
}

static inline void __list_cut_position(struct list_head *list,
		struct list_head *head, struct list_head *entry)
{
	struct list_head *new_first = entry->next;
	list->next = head->next;
	list->next->prev = list;
	list->prev = entry;
	entry->next = list;
	head->next = new_first;
	new_first->prev = head;
}

/**
 * list_cut_position - cut a list into two
 * @list: a new list to add all removed entries
 * @head: a list with entries
 * @entry: an entry within head, could be the head itself
 *	and if so we won't cut the list
 *
 * This helper moves the initial part of @head, up to and
 * including @entry, from @head to @list. You should
 * pass on @entry an element you know is on @head. @list
 * should be an empty list or a list you do not care about
 * losing its data.
 *
 */
static inline void list_cut_position(struct list_head *list,
		struct list_head *head, struct list_head *entry)
{
	if (list_empty(head))
		return;
	if (list_is_singular(head) &&
		(head->next != entry && head != entry))
		return;
	if (entry == head)
		INIT_LIST_HEAD(list);
	else
		__list_cut_position(list, head, entry);
}

/**
 * list_cut_before - cut a list into two, before given entry
 * @list: a new list to add all removed entries
 * @head: a list with entries
 * @entry: an entry within head, could be the head itself
 *
 * This helper moves the initial part of @head, up to but
 * excluding @entry, from @head to @list.  You should pass
 * in @entry an element you know is on @head.  @list should
 * be an empty list or a list you do not care about losing
 * its data.
 * If @entry == @head, all entries on @head are moved to
 * @list.
 */
static inline void list_cut_before(struct list_head *list,
				   struct list_head *head,
				   struct list_head *entry)
{
	if (head->next == entry) {
		INIT_LIST_HEAD(list);
		return;
	}
	list->next = head->next;
	list->next->prev = list;
	list->prev = entry->prev;
	list->prev->next = list;
	head->next = entry;
	entry->prev = head;
}

static inline void __list_splice(const struct list_head *list,
				 struct list_head *prev,
				 struct list_head *next)
{
	struct list_head *first = list->next;
	struct list_head *last = list->prev;

	first->prev = prev;
	prev->next = first;

	last->next = next;
	next->prev = last;
}

/**
 * list_splice - join two lists, this is designed for stacks
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice(const struct list_head *list,
				struct list_head *head)
{
	if (!list_empty(list))
		__list_splice(list, head, head->next);
}

/**
 * list_splice_tail - join two lists, each list being a queue
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice_tail(struct list_head *list,
				struct list_head *head)
{
	if (!list_empty(list))
		__list_splice(list, head->prev, head);
}

/**
 * list_splice_init - join two lists and reinitialise the emptied list.
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 *
 * The list at @list is reinitialised
 */
static inline void list_splice_init(struct list_head *list,
				    struct list_head *head)
{
	if (!list_empty(list)) {
		__list_splice(list, head, head->next);
		INIT_LIST_HEAD(list);
	}
}

/**
 * list_splice_tail_init - join two lists and reinitialise the emptied list
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 *
 * Each of the lists is a queue.
 * The list at @list is reinitialised
 */
static inline void list_splice_tail_init(struct list_head *list,
					 struct list_head *head)
{
	if (!list_empty(list)) {
		__list_splice(list, head->prev, head);
		INIT_LIST_HEAD(list);
	}
}

/**
 * list_entry - get the struct for this entry
 * @ptr:	the &struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)

/**
 * list_first_entry - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_first_entry(ptr, type, member) \
	list_entry((ptr)->next, type, member)

/**
 * list_last_entry - get the last element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_last_entry(ptr, type, member) \
	list_entry((ptr)->prev, type, member)

/**
 * list_first_entry_or_null - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note that if the list is empty, it returns NULL.
 */
#define list_first_entry_or_null(ptr, type, member) ({ \
	struct list_head *head__ = (ptr); \
	struct list_head *pos__ = READ_ONCE(head__->next); \
	pos__ != head__ ? list_entry(pos__, type, member) : NULL; \
})

/**
 * list_next_entry - get the next element in list
 * @pos:	the type * to cursor
 * @member:	the name of the list_head within the struct.
 */
#define list_next_entry(pos, member) \
	list_entry((pos)->member.next, typeof(*(pos)), member)

/**
 * list_prev_entry - get the prev element in list
 * @pos:	the type * to cursor
 * @member:	the name of the list_head within the struct.
 */
#define list_prev_entry(pos, member) \
	list_entry((pos)->member.prev, typeof(*(pos)), member)

/**
 * list_for_each	-	iterate over a list
 * @pos:	the &struct list_head to use as a loop cursor.
 * @head:	the head for your list.
 */
#define list_for_each(pos, head) \
	for (pos = (head)->next; pos != (head); pos = pos->next)

/**
 * list_for_each_prev	-	iterate over a list backwards
 * @pos:	the &struct list_head to use as a loop cursor.
 * @head:	the head for your list.
 */
#define list_for_each_prev(pos, head) \
	for (pos = (head)->prev; pos != (head); pos = pos->prev)

/**
 * list_for_each_safe - iterate over a list safe against removal of list entry
 * @pos:	the &struct list_head to use as a loop cursor.
 * @n:		another &struct list_head to use as temporary storage
 * @head:	the head for your list.
 */
#define list_for_each_safe(pos, n, head) \
	for (pos = (head)->next, n = pos->next; pos != (head); \
		pos = n, n = pos->next)

/**
 * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry
 * @pos:	the &struct list_head to use as a loop cursor.
 * @n:		another &struct list_head to use as temporary storage
 * @head:	the head for your list.
 */
#define list_for_each_prev_safe(pos, n, head) \
	for (pos = (head)->prev, n = pos->prev; \
	     pos != (head); \
	     pos = n, n = pos->prev)

/**
 * list_for_each_entry	-	iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry(pos, head, member)				\
	for (pos = list_first_entry(head, typeof(*pos), member);	\
	     &pos->member != (head);					\
	     pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_reverse - iterate backwards over list of given type.
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry_reverse(pos, head, member)			\
	for (pos = list_last_entry(head, typeof(*pos), member);		\
	     &pos->member != (head); 					\
	     pos = list_prev_entry(pos, member))

/**
 * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
 * @pos:	the type * to use as a start point
 * @head:	the head of the list
 * @member:	the name of the list_head within the struct.
 *
 * Prepares a pos entry for use as a start point in list_for_each_entry_continue().
 */
#define list_prepare_entry(pos, head, member) \
	((pos) ? : list_entry(head, typeof(*pos), member))

/**
 * list_for_each_entry_continue - continue iteration over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Continue to iterate over list of given type, continuing after
 * the current position.
 */
#define list_for_each_entry_continue(pos, head, member) 		\
	for (pos = list_next_entry(pos, member);			\
	     &pos->member != (head);					\
	     pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_continue_reverse - iterate backwards from the given point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Start to iterate over list of given type backwards, continuing after
 * the current position.
 */
#define list_for_each_entry_continue_reverse(pos, head, member)		\
	for (pos = list_prev_entry(pos, member);			\
	     &pos->member != (head);					\
	     pos = list_prev_entry(pos, member))

/**
 * list_for_each_entry_from - iterate over list of given type from the current point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type, continuing from current position.
 */
#define list_for_each_entry_from(pos, head, member) 			\
	for (; &pos->member != (head);					\
	     pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_from_reverse - iterate backwards over list of given type
 *                                    from the current point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate backwards over list of given type, continuing from current position.
 */
#define list_for_each_entry_from_reverse(pos, head, member)		\
	for (; &pos->member != (head);					\
	     pos = list_prev_entry(pos, member))

/**
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry_safe(pos, n, head, member)			\
	for (pos = list_first_entry(head, typeof(*pos), member),	\
		n = list_next_entry(pos, member);			\
	     &pos->member != (head); 					\
	     pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_continue - continue list iteration safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type, continuing after current point,
 * safe against removal of list entry.
 */
#define list_for_each_entry_safe_continue(pos, n, head, member) 		\
	for (pos = list_next_entry(pos, member), 				\
		n = list_next_entry(pos, member);				\
	     &pos->member != (head);						\
	     pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_from - iterate over list from current point safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type from current point, safe against
 * removal of list entry.
 */
#define list_for_each_entry_safe_from(pos, n, head, member) 			\
	for (n = list_next_entry(pos, member);					\
	     &pos->member != (head);						\
	     pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate backwards over list of given type, safe against removal
 * of list entry.
 */
#define list_for_each_entry_safe_reverse(pos, n, head, member)		\
	for (pos = list_last_entry(head, typeof(*pos), member),		\
		n = list_prev_entry(pos, member);			\
	     &pos->member != (head); 					\
	     pos = n, n = list_prev_entry(n, member))

/**
 * list_safe_reset_next - reset a stale list_for_each_entry_safe loop
 * @pos:	the loop cursor used in the list_for_each_entry_safe loop
 * @n:		temporary storage used in list_for_each_entry_safe
 * @member:	the name of the list_head within the struct.
 *
 * list_safe_reset_next is not safe to use in general if the list may be
 * modified concurrently (eg. the lock is dropped in the loop body). An
 * exception to this is if the cursor element (pos) is pinned in the list,
 * and list_safe_reset_next is called after re-taking the lock and before
 * completing the current iteration of the loop body.
 */
#define list_safe_reset_next(pos, n, member)				\
	n = list_next_entry(pos, member)

/*
 * Count the number of items in a list
 */
static inline int list_count_entries(struct list_head *head)
{
	struct list_head *pos;
	int n = 0;
	list_for_each(pos, head)
		n++;
	return n;
}

/*
 * Sort a list with cmp()
 * creates a temporary array on the heap
 */
static inline int
list_sort(struct list_head *head,
	  int (*cmp)(const void *a, const void *b, void *state),
	  void *state)
{
	struct list_head **array = NULL, *pos;
	unsigned int nmemb = 0;

	/*
	 * This always allocates in page-sized units to avoid realloc actually
	 * doing anything most of the time.  On 64-bit machines we'll do an
	 * allocation for every 512 entries.
	 */
	const size_t pgcnt = 4096 / sizeof(void *);

	array = calloc(ALIGN_UP(1, pgcnt), sizeof(void *));
	if (!array)
		return -1;

	list_for_each(pos, head) {
		struct list_head **new_array;
		size_t newmemb = ALIGN_UP(nmemb + 1, pgcnt);

		new_array = reallocarray(array, newmemb, sizeof(*new_array));
		if (!new_array) {
			if (array)
				free(array);
			return -1;
		}
		array = new_array;
		array[nmemb++] = pos;
	}

	qsort_r(array, nmemb, sizeof(*array), cmp, state);

	INIT_LIST_HEAD(head);
	for (unsigned int i = 0; i < nmemb; i++) {
		INIT_LIST_HEAD(array[i]);
		list_add(array[i], head);
	}
	free(array);

	return 0;
}

/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1).
 */

#define HLIST_HEAD_INIT { .first = NULL }
#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
	h->next = NULL;
	h->pprev = NULL;
}

static inline int hlist_unhashed(const struct hlist_node *h)
{
	return !h->pprev;
}

static inline int hlist_empty(const struct hlist_head *h)
{
	return !READ_ONCE(h->first);
}

static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n->next;
	struct hlist_node **pprev = n->pprev;

	WRITE_ONCE(*pprev, next);
	if (next)
		next->pprev = pprev;
}

static inline void hlist_del(struct hlist_node *n)
{
	__hlist_del(n);
	n->next = LIST_POISON1;
	n->pprev = LIST_POISON2;
}

static inline void hlist_del_init(struct hlist_node *n)
{
	if (!hlist_unhashed(n)) {
		__hlist_del(n);
		INIT_HLIST_NODE(n);
	}
}

static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
	struct hlist_node *first = h->first;
	n->next = first;
	if (first)
		first->pprev = &n->next;
	WRITE_ONCE(h->first, n);
	n->pprev = &h->first;
}

/* next must be != NULL */
static inline void hlist_add_before(struct hlist_node *n,
					struct hlist_node *next)
{
	n->pprev = next->pprev;
	n->next = next;
	next->pprev = &n->next;
	WRITE_ONCE(*(n->pprev), n);
}

static inline void hlist_add_behind(struct hlist_node *n,
				    struct hlist_node *prev)
{
	n->next = prev->next;
	WRITE_ONCE(prev->next, n);
	n->pprev = &prev->next;

	if (n->next)
		n->next->pprev  = &n->next;
}

/* after that we'll appear to be on some hlist and hlist_del will work */
static inline void hlist_add_fake(struct hlist_node *n)
{
	n->pprev = &n->next;
}

static inline bool hlist_fake(struct hlist_node *h)
{
	return h->pprev == &h->next;
}

/*
 * Check whether the node is the only node of the head without
 * accessing head:
 */
static inline bool
hlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)
{
	return !n->next && n->pprev == &h->first;
}

/*
 * Move a list from one list head to another. Fixup the pprev
 * reference of the first entry if it exists.
 */
static inline void hlist_move_list(struct hlist_head *old,
				   struct hlist_head *new)
{
	new->first = old->first;
	if (new->first)
		new->first->pprev = &new->first;
	old->first = NULL;
}

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)

#define hlist_for_each(pos, head) \
	for (pos = (head)->first; pos ; pos = pos->next)

#define hlist_for_each_safe(pos, n, head) \
	for (pos = (head)->first; pos && ({ n = pos->next; 1; }); \
	     pos = n)

#define hlist_entry_safe(ptr, type, member) \
	({ typeof(ptr) ____ptr = (ptr); \
	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
	})

/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
 * @pos:	the type * to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_continue(pos, member)			\
	for (pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_from - iterate over a hlist continuing from current point
 * @pos:	the type * to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_from(pos, member)				\
	for (; pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:	the type * to use as a loop cursor.
 * @n:		another &struct hlist_node to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_safe(pos, n, head, member) 		\
	for (pos = hlist_entry_safe((head)->first, typeof(*pos), member);\
	     pos && ({ n = pos->member.next; 1; });			\
	     pos = hlist_entry_safe(n, typeof(*pos), member))

#endif

```

`src/macros.pesign`:

```pesign
# macros for use with pesign
#
# this makes it possible to invoke your build as:
# rpmbuild --define 'pe_signing_token test2' --define "pe_signing_cert signing key for test2" -ba shim.spec
# and then in the spec do:
# %pesign -s -i shim.orig -o shim.efi
# And magically get the right thing.

%__pesign_token %{nil}%{?pe_signing_token:--token "%{pe_signing_token}"}
%__pesign_cert %{!?pe_signing_cert:"Red Hat Test Certificate"}%{?pe_signing_cert:"%{pe_signing_cert}"}

%__pesign_client_token %{!?pe_signing_token:"OpenSC Card (Fedora Signer)"}%{?pe_signing_token:"%{pe_signing_token}"}
%__pesign_client_cert %{!?pe_signing_cert:"/CN=Fedora Secure Boot Signer"}%{?pe_signing_cert:"%{pe_signing_cert}"}

%_pesign /usr/bin/pesign
%_pesign_client /usr/bin/pesign-client

# -i <input filename>
# -o <output filename>
# -C <output cert filename>
# -e <output sattr filename>
# -c <input certificate filename>	# rhel only
# -n <input certificate name>		# rhel only
# -a <input ca cert filename>		# rhel only
# -s 					# perform signing
%pesign(i:o:C:e:c:n:a:s)						\
  %{_libexecdir}/pesign/pesign-rpmbuild-helper				\\\
    "%{_target_cpu}"							\\\
    "%{_pesign}"							\\\
    "%{_pesign_client}"							\\\
    %{?__pesign_client_token:--client-token %{__pesign_client_token}}	\\\
    %{?__pesign_client_cert:--client-cert %{__pesign_client_cert}}	\\\
    %{?__pesign_token:%{__pesign_token}}				\\\
    %{?__pesign_cert:--cert %{__pesign_cert}}				\\\
    %{?_buildhost:--hostname "%{_buildhost}"}				\\\
    %{?vendor:--vendor "%{vendor}"}					\\\
    %{?rhel:--rhelver "%{rhel}"}					\\\
    %{?centos:--rhelver "%{centos}"}					\\\
    %{?-n:--rhelcert %{-n*}}%{?!-n:--rhelcert %{__pesign_cert}}	\\\
    %{?-a:--rhelcafile "%{-a*}"}					\\\
    %{?-c:--rhelcertfile "%{-c*}"}					\\\
    %{?-C:--certout "%{-C*}"}						\\\
    %{?-e:--sattrout "%{-e*}"}						\\\
    %{?-i:--in "%{-i*}"}						\\\
    %{?-o:--out "%{-o*}"}						\\\
    %{?-s:--sign}							\\\
    ;									\
%{nil}

```

`src/oid.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * oid.c - helpers for OID usage
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <stdint.h>
#include <syslog.h>

#include <prerror.h>
#include <seccomon.h>
#include <secitem.h>
#include <secoid.h>

#include "pesign.h"

static uint8_t oiddata[] = {
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0b,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0f,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x15,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x15, 0x01,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x92, 0x08, 0x10, 0x01, 0x02,
	0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x50, 0x02, 0x01
};

#define OID(num, desc_s, oidtype, length, value)		\
	{ num, .sod = {						\
		.desc = desc_s, .oid = {			\
			.type = oidtype,			\
			.data = value,				\
			.len = length }				\
		}						\
	}

static struct {
	ms_oid_t oid;
	SECOidData sod;
} oids[] = {
	OID(SPC_INDIRECT_DATA_OBJID, "Indirect Data", siDEROID, 10,
		&oiddata[0]),
	OID(SPC_STATEMENT_TYPE_OBJID, "Statement Type", siDEROID, 10,
		&oiddata[10]),
	OID(SPC_PE_IMAGE_DATA_OBJID, "PE Image Data", siDEROID, 10,
		&oiddata[20]),
	OID(SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID, "Individual Key", siDEROID,
		10, &oiddata[30]),
	OID(szOID_CERTSRV_CA_VERSION, "Certification server CA version",
		siAsciiString, 9, &oiddata[40]),
	OID(SHIM_EKU_MODULE_SIGNING_ONLY,
		"Certificate is used for kernel modules only", siDEROID, 10,
		&oiddata[49]),
	OID(SPC_UEFI_SB_CA, "UEFI Secure Boot CA", siDEROID, 10, &oiddata[59]),
	{ .oid = END_OID_LIST }
};

#undef OID

SECStatus
register_oids(cms_context *cms)
{
	int err = PORT_GetError();
	PORT_SetError(0);
	for (int i = 0; oids[i].oid != END_OID_LIST; i++) {
		SECOidTag rc;
		rc = SECOID_AddEntry(&oids[i].sod);
		oids[i].sod.offset = rc;
		if (rc == SEC_OID_UNKNOWN) {
			cmsreterr(SECFailure, cms,
				  "SECOid_AddEntry() failed: %s",
				  PORT_ErrorToString(PORT_GetError()));
		} else {
		}
	}

	/*
	 * SECOID_AddEntry() leaves the error status that it
	 * used to look it up set.  This is very annoying.
	 */
	PORT_SetError(err);
	return SECSuccess;
}

SECOidTag
find_ms_oid_tag(ms_oid_t moid)
{
	if (moid >= END_OID_LIST || moid < 0)
		return SEC_OID_UNKNOWN;

	return oids[moid].sod.offset;
}

int get_ms_oid_secitem(ms_oid_t moid, SECItem *si)
{
	if (moid >= END_OID_LIST || moid < 0)
		return -1;
	memcpy(si, &oids[moid].sod.oid, sizeof (*si));

	return 0;
}

```

`src/oid.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * oid.h - helpers for OID usage
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef OID_H
#define OID_H 1

typedef enum {
	SPC_INDIRECT_DATA_OBJID,		/* 1.3.6.1.4.1.311.2.1.4 */
	SPC_STATEMENT_TYPE_OBJID,		/* 1.3.6.1.4.1.311.2.1.11 */
	SPC_PE_IMAGE_DATA_OBJID,		/* 1.3.6.1.4.1.311.2.1.15 */
	SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID,	/* 1.3.6.1.4.1.311.2.1.21 */
	szOID_CERTSRV_CA_VERSION,		/* 1.3.6.1.4.1.311.21.1 */
	SHIM_EKU_MODULE_SIGNING_ONLY,		/* 1.3.6.1.4.1.2312.16.1.2 */
	SPC_UEFI_SB_CA,				/* 1.3.6.1.4.1.311.80.2.1 */
	END_OID_LIST
} ms_oid_t;

extern SECStatus register_oids(cms_context *cms);
extern SECOidTag find_ms_oid_tag(ms_oid_t moid);
extern int get_ms_oid_secitem(ms_oid_t moid, SECItem *si);

#endif /* OID_H */

```

`src/password.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * password.c - cursed NSS password access helpers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "pesign.h"

#include <seccomon.h>
#include <secerr.h>
#include <secitem.h>
#include <secport.h>
#include <pk11pub.h>

#include <prtypes.h>
#include <prerror.h>
#include <prprf.h>

#include "list.h"

static const char * const pw_source_names[] = {
	[PW_SOURCE_INVALID] = "PW_SOURCE_INVALID",
	[PW_PROMPT] = "PW_PROMPT",
	[PW_DEVICE] = "PW_DEVICE",
	[PW_PLAINTEXT] = "PW_PLAINTEXT",
	[PW_FROMFILEDB] = "PW_FROMFILEDB",
	[PW_DATABASE] = "PW_DATABASE",
	[PW_FROMENV] = "PW_FROMENV",
	[PW_FROMFILE] = "PW_FROMFILE",
	[PW_FROMFD] = "PW_FROMFD",

	[PW_SOURCE_MAX] = "PW_SOURCE_MAX"
};

static void
print_prompt(FILE *in, FILE *out, char *prompt)
{
	int infd = fileno(in);
	struct termios tio;

	ingress();
	if (!isatty(infd))
		return;

	if (out) {
		fprintf(out, "%s", prompt);
		fflush(out);
	}

	tcgetattr(infd, &tio);
	tio.c_lflag &= ~ECHO;
	tcsetattr(infd, TCSAFLUSH, &tio);
	egress();
}

static inline char *
get_env(const char *name)
{
	char *value;

	value = secure_getenv(name);
	if (value)
		value = strdup(value);
	return value;
}

static int
read_password(FILE *in, FILE *out, char *buf, size_t bufsz)
{
	int infd = fileno(in);
	struct termios tio;
	char *ret;
	int len;

	ingress();
	ret = fgets(buf, bufsz, in);

	if (isatty(infd)) {
		if (out) {
			fprintf(out, "\n");
			fflush(out);
		}

		tcgetattr(infd, &tio);
		tio.c_lflag |= ECHO;
		tcsetattr(infd, TCSAFLUSH, &tio);
	}
	if (ret == NULL)
		return -1;

	len = strlen(buf);
	while (len > 0 && (buf[len-1] == '\r' || buf[len-1] == '\n')) {
		buf[len-1] = '\0';
		len--;
	}
	if (len == 0)
		return -1;

	egress();
	return 0;
}

static PRBool
check_password(char *cp)
{
	unsigned int i;

	ingress();
	if (cp == NULL) {
		egress();
		return PR_FALSE;
	}

	for (i = 0; cp[i] != 0; i++) {
		if (!isprint(cp[i])) {
			egress();
			return PR_FALSE;
		}
	}
	if (i == 0) {
		egress();
		return PR_FALSE;
	}
	egress();
	return PR_TRUE;
}

static char *
get_password(FILE *input, FILE *output, char *prompt, PRBool (*ok)(char *))
{
	int infd = fileno(input);
	char phrase[200];
	size_t size = sizeof(phrase);

	ingress();
	memset(phrase, 0, size);

	while(true) {
		int rc;

		if (prompt)
			print_prompt(input, output, prompt);
		rc = read_password(input, output, phrase, size);
		if (rc < 0)
			return NULL;

		if (!ok)
			break;

		if ((*ok)(phrase))
			break;

		if (!isatty(infd))
			return NULL;
		fprintf(output, "Password does not meet requirements.\n");
		fflush(output);
	}

	egress();
	return (char *)PORT_Strdup(phrase);
}

static char *
SECU_GetPasswordString(void *arg UNUSED, char *prompt)
{
	char *ret;
	ingress();
	ret = get_password(stdin, stdout, prompt, NULL);
	dbgprintf("password:\"%s\"", ret ? ret : "(null)");
	egress();
	return ret;
}

static int token_pass_cmp(const void *tp0p, const void *tp1p)
{
	const struct token_pass * const tp0 = (const struct token_pass * const)tp0p;
	const struct token_pass * const tp1 = (const struct token_pass * const)tp1p;
	int rc;

	if (!tp1->token || !tp0->token)
		return tp1->token - tp0->token;
	rc = strcmp(tp0->token, tp1->token);
	if (rc == 0)
		rc = strcmp(tp0->pass, tp1->pass);
	return rc;
}

static int
parse_pwfile_line(char *start, struct token_pass *tp)
{
	size_t span, escspan;
	char *line = start;
	size_t offset = 0;

	span = strspn(line, whitespace_and_eol_chars);
	dbgprintf("whitespace span is %zd", span);
	if (span == 0 && line[span] == '\0')
		return -1;
	line += span;

	tp->token = NULL;
	tp->pass = line;

	offset = 0;
	do {
		span = strcspn(line + offset, whitespace_and_eol_chars);
		escspan = strescspn(line + offset);
		if (escspan < span)
			offset += escspan + 2;
	} while(escspan < span);
	span += offset;
	dbgprintf("non-whitespace span is %zd", span);

	if (line[span] == '\0') {
		dbgprintf("returning %td", (line + span) - start);
		return (line + span) - start;
	}
	line[span] = '\0';

	line += span + 1;
	span = strspn(line, whitespace_and_eol_chars);
	dbgprintf("whitespace span is %zd", span);
	line += span;
	tp->token = tp->pass;
	tp->pass = line;

	offset = 0;
	do {
		span = strcspn(line + offset, whitespace_and_eol_chars);
		escspan = strescspn(line + offset);
		if (escspan < span)
			offset += escspan + 2;
	} while(escspan < span);
	span += offset;
	dbgprintf("non-whitespace span is %zd", span);
	if (line[span] != '\0')
		line[span++] = '\0';

	resolve_escapes(tp->token);
	dbgprintf("Setting token pass %p to { %p, %p }", tp, tp->token, tp->pass);
	dbgprintf("token:\"%s\"", tp->token);
	dbgprintf("pass:\"%s\"", tp->pass);
	dbgprintf("returning %td", (line + span) - start);
	return (line + span) - start;
}

static char *
SECU_FilePasswd(PK11SlotInfo *slot, PRBool retry, void *arg)
{
	cms_context *cms = (cms_context *)arg;
	int fd;
	char *file = NULL;
	char *token_name = slot ? PK11_GetTokenName(slot) : NULL;
	struct token_pass *phrases = NULL;
	size_t nphrases = 0;
	char *phrase = NULL;
	char *start;
	char *ret = NULL;
	char *path;

	ingress();
	dbgprintf("token_name: %s", token_name);
	if (cms->pwdata.source != PW_FROMFILEDB) {
		cms->log(cms, LOG_ERR,
			 "Got to %s() but no file is specified.\n",
			 __func__);
		goto err;
	}
	path = cms->pwdata.data;

	if (!path || retry)
		goto err;

	phrases = calloc(1, sizeof(struct token_pass));
	if (!phrases)
		goto err;

	fd = open(path, O_RDONLY|O_CLOEXEC);
	if (fd < 0) {
		goto err_phrases;
	} else {
		size_t file_len = 0;
		int rc;
		rc = read_file(fd, &file, &file_len);
		set_errno_guard();
		close(fd);

		if (rc < 0 || file_len < 1)
			goto err_file;
		file[file_len-1] = '\0';
		dbgprintf("file_len:%zd", file_len);
		dbgprintf("file:\"%s\"", file);

		unbreak_line_continuations(file, file_len);
	}

	start = file;
	while (start && start[0]) {
		size_t span;
		struct token_pass *new_phrases;
		int rc;
		char c;

		/* Workaround for -fanalzer/reallocarray() bug
		 * https://bugzilla.redhat.com/show_bug.cgi?id=2047926 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wanalyzer-mismatching-deallocation"
		new_phrases = reallocarray(phrases, nphrases + 1, sizeof(struct token_pass));
		if (!new_phrases)
			goto err_phrases;
		phrases = new_phrases;
		memset(&new_phrases[nphrases], 0, sizeof(struct token_pass));
#pragma GCC diagnostic pop

		span = strspn(start, whitespace_and_eol_chars);
		dbgprintf("whitespace span is %zd", span);
		start += span;
		span = strcspn(start, eol_chars);
		dbgprintf("non-whitespace span is %zd", span);

		c = start[span];
		start[span] = '\0';
		dbgprintf("file:\"%s\"", file);
		rc = parse_pwfile_line(start, &phrases[nphrases++]);
		dbgprintf("parse_pwfile_line returned %d", rc);
		if (rc < 0)
			goto err_phrases;

		if (c != '\0')
			span++;
		start += span;
		dbgprintf("start is file[%td] == '\\x%02hhx'", start - file,
			start[0]);
	}

	qsort(phrases, nphrases, sizeof(struct token_pass), token_pass_cmp);
	cms->pwdata.source = PW_DATABASE;
	xfree(cms->pwdata.data);
	cms->pwdata.pwdb.phrases = phrases;
	cms->pwdata.pwdb.nphrases = nphrases;

	for (size_t i = 0; i < nphrases; i++) {
		if (phrases[i].token == NULL || phrases[i].token[0] == '\0'
		    || (token_name && !strcmp(token_name, phrases[i].token))) {
			phrase = phrases[i].pass;
			break;
		}
	}

	if (phrase) {
		ret = PORT_Strdup(phrase);
		if (!ret)
			errno = ENOMEM;
	}

err_file:
	xfree(file);
err_phrases:
	xfree(phrases);
err:
	dbgprintf("ret:\"%s\"", ret ? ret : "(null)");
	egress();
	return ret;
}

char *
get_password_passthrough(PK11SlotInfo *slot UNUSED, PRBool retry, void *arg)
{
	cms_context *cms;
	secuPWData *pwdata;

	dbgprintf("ctx:%p", arg);

	if (retry || !arg)
		return NULL;

	cms = (cms_context *)arg;
	pwdata = &cms->pwdata;

	if (pwdata->source != PW_PLAINTEXT)
		return NULL;

	char *ret = strdup(pwdata->data);
	if (!ret)
		err(1, "Could not allocate memory");

	return ret;
}

char *
get_password_fail(PK11SlotInfo *slot UNUSED,
		  PRBool retry UNUSED,
		  void *arg UNUSED)
{
	return NULL;
}

static bool
can_prompt_again(secuPWData *pwdata)
{
	if (pwdata->orig_source == PW_PROMPT)
		return true;

	if (pwdata->source == PW_DEVICE)
		return true;

	return false;
}

char *
SECU_GetModulePassword(PK11SlotInfo *slot, PRBool retry, void *arg)
{
	char *prompt = NULL;
	cms_context *cms = (cms_context *)arg;
	secuPWData *pwdata;
	secuPWData pwxtrn = { .source = PW_DEVICE, .orig_source = PW_DEVICE, .data = NULL };
	char *pw;
	int rc;
	FILE *in;

	ingress();

	if (PK11_ProtectedAuthenticationPath(slot)) {
		dbgprintf("prompting for PW_DEVICE data");
		pwdata = &pwxtrn;
	} else {
		dbgprintf("using pwdata from cms");
		pwdata = &cms->pwdata;
	}

	if (pwdata->source <= PW_SOURCE_INVALID ||
	    pwdata->source >= PW_SOURCE_MAX ||
	    pwdata->orig_source <= PW_SOURCE_INVALID ||
	    pwdata->orig_source >= PW_SOURCE_MAX) {
		dbgprintf("pwdata is invalid");
		return NULL;
	}

	dbgprintf("pwdata:%p retry:%d", pwdata, retry);
	dbgprintf("pwdata->source:%s (%d) orig:%s (%d)",
		  pw_source_names[pwdata->source], pwdata->source,
		  pw_source_names[pwdata->orig_source], pwdata->orig_source);
	dbgprintf("pwdata->data:%p (\"%s\")", pwdata->data,
		  pwdata->data ? pwdata->data : "(null)");
	dbgprintf("pwdata->intdata:%ld", pwdata->intdata);

	if (retry) {
		warnx("Incorrect password/PIN entered.");
		if (!can_prompt_again(pwdata)) {
			egress();
			return NULL;
		}
	}

	switch (pwdata->source) {
	case PW_PROMPT:
		rc = asprintf(&prompt, "Enter Password or Pin for \"%s\":",
			      PK11_GetTokenName(slot));
		if (rc < 0)
			return NULL;
		pw = SECU_GetPasswordString(NULL, prompt);
		if (!pw)
			return NULL;
		free(prompt);

		pwdata->source = PW_PLAINTEXT;
		egress();
		return pw;

	case PW_DEVICE:
		rc = asprintf(&prompt,
			      "Press Enter, then enter PIN for \"%s\" on external device.\n",
			      PK11_GetTokenName(slot));
		if (rc < 0)
			return NULL;
		pw = SECU_GetPasswordString(NULL, prompt);
		free(prompt);
		return pw;

	case PW_FROMFILEDB:
	case PW_DATABASE:
		dbgprintf("pwdata->source:%s", pw_source_names[pwdata->source]);
		/* Instead of opening and closing the file every time, get the pw
		 * once, then keep it in memory (duh).
		 */
		pw = SECU_FilePasswd(slot, retry, cms);
		/* it's already been dup'ed */
		egress();
		return pw;

	case PW_FROMENV:
		dbgprintf("pwdata->source:PW_FROMENV");
		if (!pwdata || !pwdata->data)
			break;
		pw = get_env(pwdata->data);
		dbgprintf("env:%s pw:%s", pwdata->data, pw ? pw : "(null)");
		pwdata->data = pw;
		pwdata->source = PW_PLAINTEXT;
		goto PW_PLAINTEXT;

	case PW_FROMFILE:
		dbgprintf("pwdata->source:PW_FROMFILE");
		in = fopen(pwdata->data, "r");
		if (!in)
			return NULL;
		pw = get_password(in, NULL, NULL, NULL);
		fclose(in);
		pwdata->source = PW_PLAINTEXT;
		pwdata->data = pw;
		goto PW_PLAINTEXT;

	case PW_FROMFD:
		dbgprintf("pwdata->source:PW_FROMFD");
		rc = pwdata->intdata;
		in = fdopen(pwdata->intdata, "r");
		if (!in)
			return NULL;
		pw = get_password(in, NULL, NULL, NULL);
		fclose(in);
		close(rc);
		pwdata->source = PW_PLAINTEXT;
		pwdata->data = pw;
		pwdata->intdata = -1;
		goto PW_PLAINTEXT;

	PW_PLAINTEXT:
	case PW_PLAINTEXT:
		egress();
		if (pwdata && pwdata->data)
			return strdup(pwdata->data);
		return NULL;

	default:
		break;
	}

	warnx("Password check failed: No password found.");
	egress();
	return NULL;
}

#if 0
#warning investigate killing readpw
#endif
char *
readpw(PK11SlotInfo *slot UNUSED,
       PRBool retry UNUSED,
       void *arg UNUSED)
{
	struct termios sio, tio;
	char line[LINE_MAX], *p;
	char *ret;

	ingress();
	memset(line, '\0', sizeof (line));

	if (tcgetattr(fileno(stdin), &sio) < 0) {
		warnx("Could not read password from standard input.");
		return NULL;
	}
	tio = sio;
	tio.c_lflag &= ~ECHO;
	if (tcsetattr(fileno(stdin), 0, &tio) < 0) {
		warnx("Could not read password from standard input.");
		return NULL;
	}

	fprintf(stdout, "Enter passphrase for private key: ");
	fflush(stdout);
	ret = fgets(line, sizeof(line), stdin);
	set_errno_guard();
	tcsetattr(fileno(stdin), 0, &sio);
	fprintf(stdout, "\n");
	fflush(stdout);
	if (ret == NULL)
		return NULL;

	p = line + strcspn(line, "\r\n");
	if (p == NULL)
		p = line + strcspn(line, "\n");
	if (p != NULL)
		*p = '\0';

	ret = strdup(line);
	memset(line, '\0', sizeof (line));
	if (!ret) {
		warnx("Could not read passphrase.");
		return NULL;
	}
	egress();
	return ret;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/password.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * password.h - cursed NSS password access helpers
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PASSWORD_H
#define PASSWORD_H

extern char *SECU_GetModulePassword(PK11SlotInfo *slot, PRBool retry, void *arg);
extern char *get_password_passthrough(PK11SlotInfo *slot, PRBool retry, void *arg);
extern char *get_password_fail(PK11SlotInfo *slot, PRBool retry, void *arg);
extern char *readpw(PK11SlotInfo *slot, PRBool retry, void *arg);

#endif /* PASSWORD_H */

```

`src/pesigcheck.1.mdoc`:

```mdoc
.Dd $Mdocdate: Jun 4 2020$
.Dt PESIGCHECK 1
.Os Linux
.Sh NAME
.Nm pesigcheck
.Nd tool for verifying UEFI applications
.Sh SYNOPSIS
.Nm pesigcheck
.Cm Fl i Ar file
.Op Fl n
.Op Fl D Ar file
.Op Fl X Ar file
.Op Fl c Ar file
.Op Fl q
.Op Fl v
.Sh DESCRIPTION
.Nm
is a command line tool for verifying the signature of UEFI applications.
.Sh OPTIONS
.Bl -tag
.It Fl i Ar file | Fl Fl in Ar file
PE binary
.Ar file
to be checked
.It Fl n | Fl Fl no-system-db
inhibit the use of DB and DBX from the running system
.It Fl D Ar file | Fl Fl dbfile Ar file
EFI Signature List or EFI variable
.Ar file
to be used as the allowed security database

may be used more than once
.It Fl X Ar file | Fl Fl dbxfile Ar file
EFI Signature List or EFI variable
.Ar file
to be used as the blacklisted security database

may be used more than once
.It Fl c Ar file | Fl Fl certfile Ar file
DER-encoded certificate
Ar file
to be added to the allowed security database

may be used more than once
.It Fl q | Fl Fl quiet
be quieter
.It Fl v | Fl Fl verbose
be more verbose
.El
.Sh STANDARDS
.Rs
.%A UEFI Specification Working Group
.%B Unified Extensible Firmware Interface (UEFI) Specification Version 2.8
.%I Unified Extensible Firmware Interface Forum
.%D March 2019
.%U https://uefi.org/specifications\ \&
.Re
.Sh SEE ALSO
.Xr authvar 1 ,
.Xr pesign 1 ,
.Xr efisigdb 1
.Sh AUTHORS
.An Peter Jones

```

`src/pesigcheck.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesigcheck.c - a PE signature checker
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <nss.h>

#include <popt.h>

#include <prerror.h>
#include <cert.h>
#include <pkcs7t.h>
#include <pk11pub.h>

#include "pesigcheck.h"

static void
open_input(pesigcheck_context *ctx)
{
	if (!ctx->infile) {
		fprintf(stderr, "pesigcheck: No input file specified.\n");
		exit(1);
	}

	ctx->infd = open(ctx->infile, O_RDONLY|O_CLOEXEC);

	if (ctx->infd < 0) {
		fprintf(stderr, "pesigcheck: Error opening input: %m\n");
		exit(1);
	}

	Pe_Cmd cmd = ctx->infd == STDIN_FILENO ? PE_C_READ : PE_C_READ_MMAP;
	ctx->inpe = pe_begin(ctx->infd, cmd, NULL);
	if (!ctx->inpe) {
		fprintf(stderr, "pesigcheck: could not load input file: %s\n",
			pe_errmsg(pe_errno()));
		exit(1);
	}

	int rc = parse_signatures(&ctx->cms_ctx->signatures,
					&ctx->cms_ctx->num_signatures,
					ctx->inpe);
	if (rc < 0) {
		fprintf(stderr, "pesigcheck: could not parse signature list in "
			"EFI binary\n");
		exit(1);
	}
}

static void
close_input(pesigcheck_context *ctx)
{
	pe_end(ctx->inpe);
	ctx->inpe = NULL;

	close(ctx->infd);
	ctx->infd = -1;
}

static void
check_inputs(pesigcheck_context *ctx)
{
	if (!ctx->infile) {
		fprintf(stderr, "pesign: No input file specified.\n");
		exit(1);
	}
}

static int
cert_matches_digest(pesigcheck_context *ctx, void *data, ssize_t datalen,
		    SECItem *digest_out)
{
	SECItem sig, *pe_digest, *content;
	uint8_t *digest;
	SEC_PKCS7ContentInfo *cinfo = NULL;
	int ret = -1;

	sig.data = data;
	sig.len = datalen;
	sig.type = siBuffer;

	cinfo = SEC_PKCS7DecodeItem(&sig, NULL, NULL, NULL, NULL, NULL,
				    NULL, NULL);

	if (!SEC_PKCS7ContentIsSigned(cinfo))
		goto out;

	/* TODO Find out the digest type in spc_content */
	pe_digest = ctx->cms_ctx->digests[0].pe_digest;
	content = cinfo->content.signedData->contentInfo.content.data;
	digest = content->data + content->len - pe_digest->len;
	if (digest_out) {
		digest_out->data = malloc(pe_digest->len);
		if (!digest_out->data)
			goto out;
		digest_out->len = pe_digest->len;
		digest_out->type = pe_digest->type;
		memcpy(digest_out->data, digest, pe_digest->len);
	}
	if (memcmp(pe_digest->data, digest, pe_digest->len) != 0)
		goto out;

	ret = 0;
out:
	if (cinfo)
		SEC_PKCS7DestroyContentInfo(cinfo);

	return ret;
}

struct reason {
	enum {
		WHITELISTED = 0,
		INVALID = 1,
		BLACKLISTED = 2,
		NO_WHITELIST = 3,
	} reason;
	enum {
		NONE = 0,
		DIGEST = 1,
		SIGNATURE = 2,
	} type;
	union {
		struct {
			SECItem digest;
		};
		struct {
			SECItem sig;
			SECItem db_cert;
		};
	};
};

static void
print_digest(SECItem *digest)
{
	char buf[digest->len * 2 + 2];

	for (unsigned int i = 0; i < digest->len; i++)
		snprintf(buf + i * 2, digest->len * 2, "%02x",
			 digest->data[i]);
	buf[digest->len * 2] = '\0';
	printf("%s\n", buf);
}

static void
print_certificate(SECItem *cert)
{
	printf("put a breakpoint at %s:%d\n", __FILE__, __LINE__);
	printf("cert: %p\n", cert);
}

static void
print_signatures(SECItem *database_cert, SECItem *signature)
{
	printf("put a breakpoint at %s:%d\n", __FILE__, __LINE__);
	print_certificate(database_cert);
	print_certificate(signature);
}

static void
print_reason(struct reason *reason)
{
	switch (reason->reason) {
	case WHITELISTED:
		printf("Whitelist entry: ");
		if (reason->type == DIGEST)
			print_digest(&reason->digest);
		else if (reason->type == SIGNATURE)
			print_signatures(&reason->sig, &reason->db_cert);
		else
			errx(1, "Unknown data type %d\n", reason->type);
		break;
	case INVALID:
		if (reason->type == DIGEST) {
			printf("Invalid digest: ");
			print_digest(&reason->digest);
		} else if (reason->type == SIGNATURE) {
			printf("Invalid signature: ");
			print_signatures(&reason->sig, &reason->db_cert);
		} else {
			errx(1, "Unknown data type %d\n", reason->type);
		}
		break;
	case BLACKLISTED:
		if (reason->type == DIGEST) {
			printf("Invalid digest: ");
			print_digest(&reason->digest);
		} else if (reason->type == SIGNATURE) {
			printf("Invalid signature: ");
			print_signatures(&reason->sig, &reason->db_cert);
		} else {
			errx(1, "Unknown data type %d\n", reason->type);
		}
		break;
	case NO_WHITELIST:
		if (reason->type == NONE)
			printf("No matching whitelist entry.\n");
		else
			errx(1, "Invalid data type %d\n", reason->type);
		break;
	default:
		errx(1, "Unknown reason type %d\n", reason->reason);
		break;
	}
}

static void
get_digest(pesigcheck_context *ctx, SECItem *digest)
{
	struct cms_context *cms = ctx->cms_ctx;
	struct digest *cms_digest = &cms->digests[cms->selected_digest];

	memcpy(digest, cms_digest->pe_digest, sizeof (*digest));
}

static int
check_signature(pesigcheck_context *ctx, int *nreasons,
		struct reason **reasons)
{
	bool has_valid_cert = false;
	bool is_invalid = false;
	struct reason *reasonps = NULL, *reason;
	int num_reasons = 16;
	int nreason = 0;
	int rc = 0;
	int ret = -1;

	cert_iter iter;

	reasonps = calloc(512, sizeof(struct reason));
	if (!reasonps)
		err(1, "check_signature");

	generate_digest(ctx->cms_ctx, ctx->inpe, 1);

	if (check_db_hash(DBX, ctx) == FOUND) {
		reason = &reasonps[nreason];
		reason->reason = BLACKLISTED;
		reason->type = DIGEST;
		get_digest(ctx, &reason->digest);
		nreason += 1;
		is_invalid = true;
	}

	if (check_db_hash(DB, ctx) == FOUND) {
		reason = &reasonps[nreason];
		reason->reason = WHITELISTED;
		reason->type = DIGEST;
		get_digest(ctx, &reason->digest);
		nreason += 1;
		has_valid_cert = true;
	}

	rc = cert_iter_init(&iter, ctx->inpe);
	if (rc < 0)
		goto err;

	void *data;
	ssize_t datalen;

	while (1) {
		/*
		 * Make sure we always have enough for this iteration of the
		 * loop, plus one "NO_WHITELIST" entry at the end.
		 */
		if (nreason >= num_reasons - 4) {
			struct reason *new_reasons;

			num_reasons += 16;

			new_reasons = calloc(num_reasons, sizeof(struct reason));
			if (!new_reasons)
				err(1, "check_signature");
			reasonps = new_reasons;
		}

		rc = next_cert(&iter, &data, &datalen);
		if (rc <= 0)
			break;

		reason = &reasonps[nreason];
		if (cert_matches_digest(ctx, data, datalen,
					&reason->digest) < 0) {
			reason->reason = INVALID;
			reason->type = DIGEST;
			nreason += 1;
			is_invalid = true;
		}

		reason = &reasonps[nreason];
		if (check_db_cert(DBX, ctx, data, datalen,
				  &reason->db_cert) == FOUND) {
			reason->reason = INVALID;
			reason->type = SIGNATURE;
			reason->sig.data = data;
			reason->sig.len = datalen;
			nreason += 1;
			is_invalid = true;
		}

		reason = &reasonps[nreason];
		if (check_db_cert(DB, ctx, data, datalen,
				  &reason->db_cert) == FOUND) {
			reason->reason = WHITELISTED;
			reason->type = SIGNATURE;
			reason->sig.data = data;
			reason->sig.len = datalen;
			nreason += 1;
			has_valid_cert = true;
		}
	}

err:
	if (has_valid_cert != true) {
		if (is_invalid != true) {
			reason = &reasonps[nreason];
			reason->reason = NO_WHITELIST;
			reason->type = NONE;
			nreason += 1;
		}
		is_invalid = true;
	}

	if (is_invalid == false)
		ret = 0;

	if (nreasons && reasons) {
		*nreasons = nreason;
		*reasons = reasonps;
	} else {
		free(reasonps);
	}

	return ret;
}

void
callback(poptContext con UNUSED,
	 enum poptCallbackReason reason UNUSED,
	 const struct poptOption *opt,
	 const char *arg, const void *data)
{
	pesigcheck_context *ctx = (pesigcheck_context *)data;
	int rc = 0;
	if (!opt)
		return;
	if (opt->shortName == 'D') {
		rc = add_cert_db(ctx, arg);
	} else if (opt->shortName == 'X') {
		rc = add_cert_dbx(ctx, arg);
	} else if (opt->shortName == 'c') {
		rc = add_cert_file(ctx, arg);
	}
	if (rc != 0) {
		fprintf(stderr, "Could not add %s from file \"%s\": %m\n",
			opt->shortName == 'D' ? "DB" : "DBX", arg);
		exit(1);
	}
}

static long *verbose;

long verbosity(void)
{
	if (!verbose)
		return 0;
	return *verbose;
}

int
main(int argc, char *argv[])
{
	int rc;

	pesigcheck_context ctx, *ctxp = &ctx;

	struct reason *reasons = NULL;
	int nreasons = 0;

	char *dbfile = NULL;
	char *dbxfile = NULL;
	char *certfile = NULL;
	int use_system_dbs = 1;

	SECStatus status;

	poptContext optCon;
	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesign" },
		{.longName = "dbfile",
		 .shortName = 'D',
		 .argInfo = POPT_ARG_CALLBACK|POPT_CBFLAG_POST,
		 .arg = (void *)callback,
		 .descrip = (void *)ctxp },
		{.longName = "dbxfile",
		 .shortName = 'X',
		 .argInfo = POPT_ARG_CALLBACK|POPT_CBFLAG_POST,
		 .arg = (void *)callback,
		 .descrip = (void *)ctxp },
		{.longName = "certfile",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_CALLBACK|POPT_CBFLAG_POST,
		 .arg = (void *)callback,
		 .descrip = (void *)ctxp },
		{.longName = "in",
		 .shortName = 'i',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctx.infile,
		 .descrip = "specify input file",
		 .argDescrip = "<infile>"},
		{.longName = "quiet",
		 .shortName = 'q',
		 .argInfo = POPT_BIT_SET,
		 .arg = &ctx.quiet,
		 .val = 1,
		 .descrip = "return only; no text output." },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctx.verbose,
		 .val = 1,
		 .descrip = "print reasons for success and failure." },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctxp->verbose,
		 .val = 2,
		 .descrip = "be very verbose" },
		{.longName = "no-system-db",
		 .shortName = 'n',
		 .argInfo = POPT_ARG_INT,
		 .arg = &use_system_dbs,
		 .descrip = "inhibit the use of DB and DBX from the running system" },
		{.longName = "dbfile",
		 .shortName = 'D',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &dbfile,
		 .descrip = "use file for allowed certificate list",
		 .argDescrip = "<dbfile>" },
		{.longName = "dbxfile",
		 .shortName = 'X',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &dbxfile,
		 .descrip = "use file for disallowed certificate list",
		 .argDescrip = "<dbxfile>" },
		{.longName = "certfile",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &certfile,
		 .descrip = "import certfile (in DER encoding) for allowed certificate",
		 .argDescrip = "<certfile>" },
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	rc = pesigcheck_context_init(ctxp);
	if (rc < 0) {
		fprintf(stderr, "pesigcheck: Could not initialize context: %m\n");
		exit(1);
	}
	verbose = &ctxp->verbose;

	optCon = poptGetContext("pesigcheck", argc, (const char **)argv,
				options,0);

	while ((rc = poptGetNextOpt(optCon)) > 0)
		;

	if (rc < -1) {
		fprintf(stderr, "pesigcheck: Invalid argument: %s: %s\n",
			poptBadOption(optCon, 0), poptStrerror(rc));
		exit(1);
	}

	if (poptPeekArg(optCon)) {
		fprintf(stderr, "pesigcheck: Invalid Argument: \"%s\"\n",
				poptPeekArg(optCon));
		exit(1);
	}

	poptFreeContext(optCon);

	check_inputs(ctxp);
	open_input(ctxp);

	init_cert_db(ctxp, use_system_dbs);

	status = NSS_NoDB_Init(NULL);
	if (status != SECSuccess) {
		fprintf(stderr, "Could not initialize nss: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}

	rc = check_signature(ctxp, &nreasons, &reasons);

	if (!ctx.quiet && ctx.verbose) {
		for (int i = 0; i < nreasons; i++)
			print_reason(&reasons[i]);
	}
	if (!ctx.quiet)
		printf("pesigcheck: \"%s\" is %s.\n", ctx.infile,
			rc >= 0 ? "valid" : "invalid");

	if (reasons)
		free(reasons);

	close_input(ctxp);
	pesigcheck_context_fini(&ctx);

	NSS_Shutdown();

	return (rc < 0);
}

// vim:fenc=utf-8:tw=75:noet

```

`src/pesigcheck.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pesigcheck.h - helper header for pesigcheck
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_H
#define PESIGN_H 1

#include <efisec.h>

#include <libdpe/libdpe.h>
#include <libdpe/pe.h>

#include "util.h"
#include "cms_common.h"
#include "pesigcheck_context.h"
#include "certdb.h"

#include "endian.h"
#include "errno-guard.h"
#include "oid.h"
#include "wincert.h"
#include "content_info.h"
#include "signer_info.h"
#include "signed_data.h"
#include "password.h"

#endif /* PESIGN_H */

```

`src/pesigcheck_context.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesigcheck_context.c - context setup and teardown for pesigcheck
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <sys/mman.h>
#include <unistd.h>

#include "pesigcheck.h"

#include <nss.h>
#include <secitem.h>

int
pesigcheck_context_new(pesigcheck_context **ctx)
{
	pesigcheck_context *context = NULL;
	int rc = 0;

	if (ctx == NULL)
		return -1;

	context = malloc(sizeof (*context));
	if (!context)
		return -1;

	pesigcheck_context_init(context);
	context->flags |= pesigcheck_C_ALLOCATED;

	*ctx = context;
	return rc;
}

int
pesigcheck_context_init(pesigcheck_context *ctx)
{
	if (!ctx)
		return -1;
	memset(ctx, '\0', sizeof (*ctx));

	ctx->infd = -1;

	int rc = cms_context_alloc(&ctx->cms_ctx);
	if (rc < 0)
		return rc;

	return 0;
}

void
pesigcheck_context_fini(pesigcheck_context *ctx)
{
	if (!ctx)
		return;

	cms_context_fini(ctx->cms_ctx);

	xfree(ctx->infile);

	if (ctx->inpe) {
		pe_end(ctx->inpe);
		ctx->inpe = NULL;
	}

	if (!(ctx->flags & pesigcheck_C_ALLOCATED))
		pesigcheck_context_init(ctx);

	while (ctx->db) {
		dblist *db = ctx->db;

		if (db->type == DB_CERT)
			free(db->data);
		munmap(db->map, db->size);
		close(db->fd);
		ctx->db = db->next;
		free(db->path);
		free(db);
	}
	while (ctx->dbx) {
		dblist *db = ctx->dbx;

		if (db->type == DB_CERT)
			free(db->data);
		munmap(db->map, db->size);
		free(db->path);
		close(db->fd);
		ctx->dbx = db->next;
		free(db);
	}
	while (ctx->hashes) {
		hashlist *hashes = ctx->hashes;
		free(hashes->data);
		ctx->hashes = hashes->next;
		free(hashes);
	}
}

void
pesigcheck_context_free_private(pesigcheck_context **ctx_ptr)
{
	pesigcheck_context *ctx;
	if (!ctx_ptr || !*ctx_ptr)
		return;

	ctx = *ctx_ptr;
	pesigcheck_context_fini(ctx);

	if (ctx->flags & pesigcheck_C_ALLOCATED)
		xfree(*ctx_ptr);
}

```

`src/pesigcheck_context.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pesigcheck_context.h - context setup and teardown for pesigcheck
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef pesigcheck_CONTEXT_H
#define pesigcheck_CONTEXT_H 1

#include <cert.h>
#include <efivar.h>
#include <secpkcs7.h>

enum {
	pesigcheck_C_ALLOCATED = 1,
};

typedef enum {
	DB_FILE,
	DB_EFIVAR,
	DB_CERT,
} db_f_type;

struct dblist {
	db_f_type type;
	char *path;
	int fd;
	struct dblist *next;
	size_t size;
	void *map;
	size_t datalen;
	void *data;
};

typedef struct dblist dblist;

struct hashlist {
	efi_guid_t *hash_type;
	void *data;
	size_t datalen;
	struct hashlist *next;
};
typedef struct hashlist hashlist;

typedef struct pesigcheck_context {
	int flags;

	char *infile;
	int infd;
	Pe *inpe;

	int quiet;
	long verbose;

	hashlist *hashes;

	dblist *db;
	dblist *dbx;

	cms_context *cms_ctx;
} pesigcheck_context;

extern int pesigcheck_context_new(pesigcheck_context **ctx);
extern void pesigcheck_context_free_private(pesigcheck_context **ctx_ptr);
extern int pesigcheck_context_init(pesigcheck_context *ctx);
extern void pesigcheck_context_fini(pesigcheck_context *ctx);
#define pesigcheck_context_free(ctx) pesigcheck_context_free_private(&(ctx))

#endif /* pesigcheck_CONTEXT_H */

```

`src/pesign-client.1.mdoc`:

```mdoc
.Dd $Mdocdate: Jun 4 2020$
.Dt PESIGN-CLIENT 1
.Os Linux
.Sh NAME
.Nm pesign-client
.Nd tool for signing UEFI applications with a \fBpesign\fR server
.Sh SYNOPSIS
.Nm pesign-client
.Bk -words
.Op Fl i Ar file
.Op Fl o Ar file
.Op Fl e Ar file
.Op Fl t Ar token
.Op Fl c Ar nickname
.Ao
.Op Fl k |
.Op Fl q |
.Op Fl s |
.Op Fl u
.Ac
.Op Fl f Ar fd
.Op Fl F Ar file
.Ek
.Sh DESCRIPTION
.Nm
is a command line tool for manipulating signatures and cryptographic digests of UEFI applications.
.Sh OPTIONS
.Bl -tag
.It Fl i Ar file | Fl Fl infile Ar file
The input binary
.Ar file
to be signed with
.Fl Fl sign
.It Fl o Ar file | Fl Fl outfile Ar file
The output binary
.Ar file
to be signed with
.Fl Fl sign
.It Fl e Ar file | Fl Fl export Ar file
Export signature from 
.Fl Fl sign
to
.Ar file
.It Fl t Ar token | Fl Fl token Ar token
Sign using NSS token
.Ar token
.It Fl c Ar nickname | Fl Fl certificate Ar nickname
Sign using NSS certificate
.Ar nickname
.It Fl k | Fl Fl kill
Kill the \fBpesign\fR server
.It Fl q | Fl Fl is-unlocked
Query the lock status of the token specified by
.Fl Fl token
.It Fl s | Fl Fl sign
Sign the file specified by
.Fl Fl infile
.It Fl u | Fl Fl unlock
Unlock the token specified with
.Fl Fl token
using the PIN read from
.Fl Fl pinfd
or
.Fl Fl pinfile ,
or specified by
.Ev PESIGN_TOKEN_PIN
.It Fl f Ar fd | Fl Fl pinfd Ar fd
File descriptor to read the PIN from for
.Fl Fl unlock
.It Fl F Ar file | Fl Fl pinfile Ar file
File to read the PIN from for unlock
.El
.Sh ENVIRONMENT
.Bl -tag
.It Ev PESIGN_TOKEN_PIN
PIN for use with
.Fl Fl unlock
for the token specified by
.Fl fl token
.El
.Sh "SEE ALSO"
.Xr pesign 1 ,
.Xr certutil 1
.Sh AUTHORS
.An Peter Jones

```

`src/pesign-groups`:

```
pesign

```

`src/pesign-rpmbuild-helper.in`:

```in
#!/bin/bash
# shellcheck shell=bash

set -eu
set -x

usage() {
    local status="${1}" && shift
    local out
    if [[ "${status}" -eq 0 ]] ; then
	out=/dev/stdout
    else
	out=/dev/stderr
    fi

    if [[ $# -gt 0 ]] ; then
	echo "${0}: error: $*" >>"${out}"
    fi
    echo "usage: ${0} TARGET_CPU PESIGN_BINARY PESIGN_CLIENT_BINARY [OPTIONS]" >>"${out}"
    exit "${status}"
}

is_efi_arch() {
    local arch="${1}"
    local arches=(@@EFI_ARCHES@@)
    local x
    for x in "${arches[@]}" ; do
	if [[ "${arch}" = "${x}" ]] ; then
	    return 0
	fi
    done
    return 1
}

error_on_empty() {
    local f="${1}"
    if [[ ! -s "${f}" ]] ; then
	if [[ -e "${f}" ]] ; then
	    rm -f "${f}"
	fi
	echo "${0}: error: empty result file \"${f}\"">>/dev/stderr
	exit 1
    fi
}

main() {
    if [[ $# -lt 3 ]] ; then
	usage 1 not enough arguments
    fi
    local target_cpu="${1}" && shift
    local bin="${1}" && shift
    local client="${1}" && shift

    local rhelcafile="" || :
    local rhelcertfile="" || :

    local certout=() || :
    local sattrout=() || :
    local input=() || :
    local output=() || :
    local client_token=() || :
    local client_cert=() || :
    local token=() || :
    local cert=() || :
    local rhelcert=() || :
    local rhelver=0 || :
    local sign="" || :
    local arch="" || :
    local vendor="" || :
    local HOSTNAME="" || :

    while [[ $# -ge 2 ]] ; do
	case " ${1} " in
	" --rhelcafile ")
	    rhelcafile="${2}"
	    ;;
	" --rhelcertfile ")
	    rhelcertfile="${2}"
	    ;;
	" --hostname ")
	    HOSTNAME="${2}"
	    ;;
	" --certout ")
	    certout[0]=-C
	    certout[1]="${2}"
	    ;;
	" --sattrout ")
	    sattrout[0]=-e
	    sattrout[1]="${2}"
	    ;;
	" --client-token ")
	    client_token[0]=-t
	    client_token[1]="${2}"
	    ;;
	" --client-cert ")
	    client_cert[0]=-c
	    client_cert[1]="${2}"
	    ;;
	" --token ")
	    token[0]=-t
	    token[1]="${2}"
	    ;;
	" --cert ")
	    cert[0]=-c
	    cert[1]="${2}"
	    ;;
	" --rhelcert ")
	    rhelcert[0]=-c
	    rhelcert[1]="${2}"
	    ;;
	" --in ")
	    input[0]=-i
	    input[1]="${2}"
	    ;;
	" --out ")
	    output[0]=-o
	    output[1]="${2}"
	    ;;
	" --rhelver ")
	    rhelver="${2}"
	    ;;
	" --vendor ")
	    vendor="${2}"
	    ;;
	*)
	    break
	    ;;
	esac
	shift
	shift
    done
    if [[ $# -ge 1 ]] && [[ "${1}" = --sign ]] ; then
	sign=-s
	shift
    fi
    if [[ $# -ge 1 ]] ; then
	echo "$# extra unparsed arguments!">>/dev/stderr
	echo "Cowardly refusing to run">>/dev/stderr
	exit 1
    fi

    if [[ -z "${target_cpu}" ]] ; then
	target_cpu="$(uname -m)"
    fi

    target_cpu="${target_cpu/i?86/ia32}"
    target_cpu="${target_cpu/x86_64/x64}"
    target_cpu="${target_cpu/aarch64/aa64}"
    target_cpu="${target_cpu/arm*/arm/}"

    local nssdir=/etc/pki/pesign
    if [[ "${#cert[@]}" -eq 2 ]] &&
       [[ "${cert[1]}" == "Red Hat Test Certificate" ]] ; then
	nssdir=/etc/pki/pesign-rh-test
    fi

    # is_efi_arch is ultimately returning "is pesign configured to sign these
    # using the rpm macro", so if it isn't, we're just copying the input to
    # the output
    if [[ -x "${bin}" ]] && ! is_efi_arch "${target_cpu}" ; then
	if [[ -n "${input[*]}" ]] && [[ -n "${output[*]}" ]] ; then
	    cp -v "${input[1]}" "${output[1]}"
	elif [[ -n "${input[*]}" ]] && [[ -n "${sattrout[*]}" ]] ; then
	    touch "${sattrout[1]}"
	fi

	# if there's a 0-sized output file, delete it and error out
	error_on_empty "${output[1]}"
	return 0
    fi

    local inplace=0 || :
    if [[ -n "${input[*]}" ]] && [[ -z "${output[*]}" ]] \
       || [[ "${input[1]}" = "${output[1]}" ]]; then
        inplace=1
        output[0]=-o
        output[1]="$(mktemp -u pesign-XXXXXXX.efi)"
    fi

    USERNAME="${USERNAME:-$(id -un)}"

    local socket="" || :
    if [[ -S /run/pesign/socket ]] ; then
        socket=/run/pesign/socket
    elif [[ -S /var/run/pesign/socket ]]; then
        socket=/var/run/pesign/socket
    elif grep -q ID=fedora /etc/os-release \
       && [[ "${rhelver}" -lt 7 ]] \
       && [[ "${USERNAME}" = "mockbuild" ]] \
       && [[ "${vendor}" = "Fedora Project" ]] \
       && [[ "${HOSTNAME}" =~ bkernel.* ]]
    then
        echo "Warning: no pesign socket even though user is ${USERNAME}" 1>&2
        echo "Warning: if this is a non-scratch koji build, this is wrong" 1>&2
        ls -ld /run/pesign /var/run/pesign 1>&2 ||:
        ls -l /run/pesign/socket /var/run/pesign/socket 1>&2 ||:
        getfacl /run/pesign /run/pesign/socket /var/run/pesign /var/run/pesign/socket 1>&2 ||:
        getfacl -n /run/pesign /run/pesign/socket /var/run/pesign /var/run/pesign/socket 1>&2 ||:
    fi

    if [[ "${rhelver}" -ge 7 ]] && which rpm-sign >&/dev/null ; then
	nssdir="$(mktemp -p "${PWD}" -d)"
	echo > "${nssdir}/pwfile"
	certutil -N -d "${nssdir}" -f "${nssdir}/pwfile"
	certutil -A -n "ca" -t "CTu,CTu,CTu" -i "${rhelcafile}" -d "${nssdir}"
	certutil -A -n "signer" -t "CTu,CTu,CTu" -i "${rhelcertfile}" -d "${nssdir}"
	sattrs="$(mktemp -p "${PWD}" --suffix=.der)"
	"${bin}" -E "${sattrs}" --certdir "${nssdir}" \
	    "${input[@]}" --force
	rpm-sign --key "${rhelcert[1]}" --rsadgstsign "${sattrs}"
	"${bin}" -R "${sattrs}.sig" -I "${sattrs}" \
	    --certdir "${nssdir}" -c signer \
	    "${input[@]}" "${output[@]}"
	rm -rf "${sattrs}" "${sattrs}.sig" "${nssdir}"
    elif [[ -n "${socket}" ]] ; then
	### welcome haaaaack city
	if [[ "${client_token[1]}" = "OpenSC Card (Fedora Signer)" ]] ; then
	    if [[ "${input[1]}" =~ (/|^)vmlinuz($|[_.-]) ]] \
	       || [[ "${input[1]}" =~ (/|^)bzImage($|[_.-]) ]] ; then
		if [[ "${rhelcertfile}" =~ redhatsecureboot501.* ]] \
		   || [[ "${rhelcertfile}" =~ redhatsecureboot401.* ]] \
		   || [[ "${rhelcertfile}" =~ centossecureboot201.* ]] ; then
		    client_cert[1]=kernel-signer
		elif [[ "${rhelcertfile}" =~ redhatsecureboot502.* ]] \
		   || [[ "${rhelcertfile}" =~ centossecureboot202.* ]] ; then
		    client_cert[1]=grub2-signer
		elif [[ "${rhelcertfile}" =~ redhatsecureboot503.* ]] \
		   || [[ "${rhelcertfile}" =~ centossecureboot203.* ]] ; then
		    client_cert[1]=fwupd-signer
		fi
	    fi
	fi
	"${client}" "${client_token[@]}" "${client_cert[@]}"    \
	    "${sattrout[@]}" "${certout[@]}"	\
	    ${sign} "${input[@]}" "${output[@]}"
    else
	"${bin}" --certdir "${nssdir}" "${token[@]}"	\
	    "${cert[@]}" ${sign} "${sattrout[@]}"	\
	    "${certout[@]}"    "${input[@]}" "${output[@]}"
    fi

    # if there's a 0-sized output file, delete it and error out
    if [[ "${#output[@]}" -eq 2 ]] ; then
	error_on_empty "${output[1]}"
    fi

    if [[ "$inplace" -eq 1 ]] ; then
	chmod 644 "${output[1]}"
	mv "${output[1]}" "${input[1]}"
    fi
}

main "${@}"

# vim:filetype=sh:fenc=utf-8:tw=78:sts=4:sw=4

```

`src/pesign-users`:

```
pesign

```

`src/pesign.1.mdoc`:

```mdoc
.Dd $Mdocdate: Apr 11 2023$
.Dt PESIGN 1
.Os Linux
.Sh NAME
.Nm pesign
.Nd tool for signing UEFI applications
.Sh SYNOPSIS
.Nm
.Bk -words
.Cm Fl i Ar file
.Op Fl o Ar file
.Op Fl f
.Op Fl n Ar directory
.Op Fl t Ar token
.Op Fl c Ar nickname
.Op Fl u Ar number
.Op Fl m Ar file
.Op Fl e Ar file
.Op Fl I Ar file
.Op Fl E Ar file
.Op Fl R Ar file
.Op Fl K Ar file
.Op Fl C Ar file
.Op Fl a
.Op Fl l
.Op Fl S
.Op Fl v
.Op Fl Fl pinfile Ar file | Fl Fl pwfile Ar file
.Ek
\&
.Ao
.Fl s
|
.Fl D Op Fl N
|
.Fl r
|
.Ek
.Bk -words
.Fl h
.Op Fl d Ar digest
.Op Fl P | Fl p
.Ek
.Ac
.Sh DESCRIPTION
.Nm
is a command line tool for manipulating signatures and cryptographic digests of
UEFI applications.
.Sh OPTIONS
.Bl -tag
.It Fl i Ar file | Fl Fl in Ar file
Input PE
.Ar file
for signing
.It Fl o Ar file | Fl Fl out Ar file
Output PE
.Ar file
for signing
.It Fl f | Fl Fl force
Overwrite existing file specified with
.Fl Fl out
.It Fl n Ar directory | Fl Fl certdir Ar directory
Use the NSS Database in
.Ar directory
.Po
default:
.Pa /etc/pki/pesign
.Pc
.It Fl t Ar token | Fl Fl token Ar token
Use the NSS token named
.Ar token
.It Fl c Ar nickname | Fl Fl certificate Ar nickname
Use the certificate called
.Ar nickname
in the NSS Database
.It Fl u Ar number | Fl Fl signature-number Ar number
Signature number, indexed from 0, for use with
.Fl Fl remove-signature\fR,
.Fl Fl export-signature\fR,
or
.Fl Fl show-signature
.Po
default: \fI0\fR
.Pc
.It Fl m Ar file | Fl Fl import-signature Ar file
Import \fBAuthenticode\fR signature from
.Ar file
.It Fl e Ar file | Fl Fl export-signature Ar file
Export \fBAuthenticode\fR signature to
.Ar file
.It Fl I Ar file | Fl Fl import-signed-attributes Ar file
Import \fBPKCS-7\fR \fISignedAttributes\fR (with no signature) from
.Ar file
.It Fl E Ar file | Fl Fl export-signed-attributes Ar file
Export \fBPKCS-7\fR \fISignedAttributes\fR (with no signature) to
.Ar file
.It Fl R Ar file | Fl Fl import-raw-signature Ar file
Import signature digest from
.Ar file
.It Fl K Ar file | Fl Fl export-pubkey Ar file
Export public key from the NSS Database specified by
.Fl Fl token
and
.Fl Fl certificate
to
.Ar file
.It Fl C Ar file | Fl Fl export-cert Ar file
Export certificate from the NSS Database specified by
.Fl Fl token
and
.Fl Fl certificate
to
.Ar file
.It Fl a | Fl Fl ascii-armor
When exporting certificates, encode them in \fIascii-armor\fR
.It Fl l | Fl Fl list-signatures
List signatures
.It Fl S | Fl Fl show-signature
Show information about signatures
.It Fl v | Fl Fl verbose
Be more verbose
.It Fl s | Fl Fl sign
Create a new signature
.It Fl D | Fl Fl daemonize
Run as a daemon
.It Fl N | Fl Fl nofork
Do not fork when daemonizing
.Po
daemon runs in foreground
.Pc
.It Fl r | Fl Fl remove-signature
Remove signature
.It Fl h | Fl Fl hash
Display the \fBAuthenticode\fR hash of the binary
.It Fl d Ar digest | Fl Fl digest-type Ar digest
Use the cryptographic
.Ar digest
with
.Fl Fl hash
.Po
use
.Ar help
to list options
.Pc
.Po
default: \fIsha256\fR
.Pc
.It Fl P | Fl Fl padding | Fl p | Fl Fl nopadding
Do or do not pad the binary according to \fBPE 9.3\fR rules before signing or hashing
.Po
default:
.Fl Fl padding
.Pc

Padding is recommended (and in many circumstances required) even for binaries
which predate the current PE spec, and is enabled by default as of pesign 113.
.It Fl Fl pinfile Ar file | Fl Fl pwfile Ar file
Read token's password from
.Ar file
rather than from interactive prompt.

.Po
the same can be accomplished by exporting the environment variable
.Ev PESIGN_TOKEN_PIN
.Pc
.El
.Sh EXAMPLES

Keep in mind that the following examples assume that
.Pa /etc/pki/pesign
is the certificate database. To make use of it as a regular user, add yourself to the
.Ar pesign
Unix group with

.Bd -literal -offset 1 -compact
sudo usermod -a -G pesign $USER
.Ed

.Ss Signing with the certificate and private key in individual files


If you have a certificate file and private key file, the following steps
may be used to sign a PE image:

.Bd -literal -offset 1 -compact
# Create a pkcs12 file from private key and certificate file.\p
host:~$ \fBopenssl pkcs12 -export -out foo_key.p12 \e
        -inkey signing_key.pem -in xyz_cert.x509.pem\fR

# Import pkcs12 file into pesign db\p
host:~$ \fBpk12util -i foo_key.p12 -d /etc/pki/pesign\fR

# Do the signing\p
host:~$ \fBpesign -c my-signing-cert -s \e
        -i foo.unsigned.efi -o foo.signed.efi\fR
.Ed

Please note that this is just an example, and that recommended best practice
is to always store private keys in a \fIFIPS 140-2\fR Hardware Security
Module (HSM), level 2 or higher.
.Ss Signing using an HSM


If you have a key pair in your HSM and your HSM vendor provides a PKCS-11 library, you can use it with NSS directly:

.Bd -literal -offset 1 -compact
# Add the HSM PKCS-11 library to the NSS database\p
host:~$ \fBmodutil -dbdir /etc/pki/pesign -add vendor-engine \e
        -libfile /usr/lib64/pkcs11/vendor-engine.so\fR
WARNING: Performing this operation while the browser is running
could cause corruption of your security databases. If the browser
is currently running, you should exit browser before continuing
this operation. Type\p
\(aqq <enter>\(aq to abort, or <enter> to continue: \fB<type enter here>\fR

Module "vendor-engine" added to database.

# List the added module\p
host:~$ \fBmodutil -dbdir /etc/pki/pesign -list\fR
-----------------------------------------------------------
  1. NSS Internal PKCS #11 Module
	   uri: pkcs11:library-manufacturer=Mozilla%20Foundation;library-description=NSS%20Internal%20Crypto%20Services;library-version=3.52
	 slots: 2 slots attached
	status: loaded

	 slot: NSS Internal Cryptographic Services
	token: NSS Generic Crypto Services
	  uri: pkcs11:token=NSS%20Generic%20Crypto%20Services;manufacturer=Mozilla%20Foundation;serial=0000000000000000;model=NSS%203

	 slot: NSS User Private Key and Certificate Services
	token: NSS Certificate DB
	  uri: pkcs11:token=NSS%20Certificate%20DB;manufacturer=Mozilla%20Foundation;serial=0000000000000000;model=NSS%203

  2. opensc-pkcs11.so
	library name: /usr/lib64/pkcs11/opensc-pkcs11.so
	   uri: pkcs11:library-manufacturer=OpenSC%20Project;library-description=OpenSC%20smartcard%20framework;library-version=0.20
	 slots: 1 slot attached
	status: loaded

	 slot: Generic Smart Card Reader Interface [Smart Card Reader Interf...
	token: OpenSC Card (myorg-sb-signer)
	  uri: pkcs11:token=OpenSC%20Card%20(myorg-sb-signer);manufacturer=OpenSC%20Project;serial=56516a130f35;model=PKCS%2315
-----------------------------------------------------------

# List certs in tokens\p
host:~$ \fBcertutil -d /etc/pki/pesign \e
        -h "OpenSC Card (myorg-sb-signer)" -L\fR
Certificate Nickname                             Trust Attributes\p
                                                 SSL,S/MIME,JAR/XPI\p

Enter Password or Pin for "OpenSC Card (myorg-sb-signer)": \fB<type the PIN here>\fR\p
OpenSC Card (myorg-sb-signer):/CN=My Org's SB Signer    u,u,u\p

# Sign with private key in HSM
host:~$ \fBpesign -t "OpenSC Card (myorg-sb-signer)" \e
        -c "OpenSC Card (myorg-sb-signer):/CN=My Org's SB Signer" \e
        -s -i foo.unsigned.efi -o foo.efi\fR
.Ed
.Ss Example with OpenDNSSEC's SoftHSM


The OpenDNSSEC project provides a software implementation of a generic
cryptographic device with a PKCS#11 interface - SoftHSM.

.Rs
.%B SoftHSM
.%I OpenDNSSEC
.%U https://www.opendnssec.org/softhsm/ \&
.Re

This project may come in handy as one can practice how HSMs work without the
need to have a physical HSM.

In this example we'll initialize one token, generate a CA certificate directly
in it and make pesign ask it for the generated object to sign a shimx64 binary.

Please note that this is just an example and was written purely for
demonstration purposes. Use hardware tokens, strong passwords and don't store
these in plaintext directly in filesystem.

https://www.opendnssec.org/softhsm/

.Bd -literal -offset 1 -compact
# Initialize a SoftHSM token\p
host:~$ \fBmkdir -p $HOME/.config/softhsm2/tokens\fR
host:~$ \fBecho "directories.tokendir = $HOME/.config/softhsm2/tokens" > $HOME/.config/softhsm2/softhsm2.conf\fR
host:~$ \fBsofthsm2-util --init-token --label HSM --so-pin Secret.123 --pin Secret.123 --free\fR

# Store this PIN in a file\p
host:~$ \fBcat ~/pwfile.txt\fR
Secret.123

# Generate a CA directly in this token\p
host:~$ \fBefikeygen -t HSM -d /etc/pki/pesign -n example \e
        --ca --self-sign --common-name "CN=example,OU=example,O=example" --kernel\fR

# Confirm the certificate is really in there\p
host:~$ \fBcertutil -d /etc/pki/pesign -h HSM -L\fR

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

Enter Password or Pin for "HSM": \fB<type the PIN 'Secret.123' here>\fR\p
HSM:example                                                  u,u,u\p

# Do the signing\p
host:~$ \fBpesign -t HSM -n /etc/pki/pesign -c example \e
        -i ~/shimx64.efi.unsigned -o ~/shimx64.efi.signed \e
        --pinfile ~/pwfile.txt -s\fR

.Ed
.Ss Signing using an HSM with an OpenSSL Engine


If you have a key pair in your HSM but can't access it directly, but do have
access to the openssl command line tool configured with your vendor's
libraries, you can still use
.Nm
to sign your PE binaries:

.Bd -literal -offset 1 -compact

# Import the public certificate into the NSS Database\p
host:~$ \fBcertutil -d /etc/pki/pesign -A -n myorg-sb-signer \e
        -t ,,u -i myorg-sb-signer.cer\fR

# Export the PKCS-7 SignedAttributes section pesign generates\p
host:~$ \fBpesign -i foo.unsigned.efi -E foo.sattrs.bin\fR

# Generate a signature using OpenSSL\p
host:~$ \fBopenssl dgst -sha256 -sign $KEY \e
        --keyform ENGINE --engine $ENGINEID \e
        -out foo.sattrs.sig foo.sattrs.bin\fR

# Import the signature with the original SignedAttributes into
# the PE binary
host:~$ \fBpesign -c myorg-sb-signer \e
        -R foo.sattrs.sig -I foo.sattrs.bin \e
        -i foo.unsigned.efi -o foo.efi
.Sh STANDARDS
.Rs
.%A B. Kaliski
.%R RFC 2315
.%B PKCS #7: Cryptographic Message Syntax v1.5
.%I Internet Engineering Task Force
.%D March 1998
.%U https://tools.ietf.org/html/rfc2315\ \&
.Re

.Rs
.%A K. Moriarty
.%A M. Nyström
.%A S. Parkinson
.%A A. Rusch
.%A M. Scott
.%R RFC 7292
.%B PKCS #12: Personal Information Exchange Syntax v1.1
.%I Internet Engineering Task Force
.%D July 2014
.%U https://tools.ietf.org/html/rfc7292\ \&
.Re

.Rs
.%A PKCS11 Technical Committee
.%B PKCS#11: Cryptographic Token Interface Standard
.%I OASIS
.%U https://www.cryptsoft.com/pkcs11doc/
.Re

.Rs
.%A M. Nyström
.%B PKCS #15—A Cryptographic-Token Information Format Standard
.%I RSA Laboratories
.%D 1999
.%U https://www.usenix.org/legacy/events/smartcard99/full_papers/nystrom/nystrom.pdf\ \&
.Re

.Rs
.%B Portable Executable
.%I Microsoft
.%D August 26, 2019
.%U https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\ \&
.Re

.Rs
.%B Windows Authenticode Portable Executable Signature Format
.%I Microsoft
.%D March 21, 2008
.%U https://web.archive.org/web/20130518222430/http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx\ \&
.Re

.Rs
.%R FIPS 140-2
.%B Federal Information Processing Standard 140-2
.%Q National Institute of Standards and Technology
.%I United States Department of Commerce
.%U http://csrc.nist.gov/publications/PubsFIPS.html\ \&
.Re
.Sh SEE ALSO
.Xr certutil 1 ,
.Xr efikeygen 1 ,
.Xr modutil 1 ,
.Xr opensc-tool 1 ,
.Xr openssl 1ssl ,
.Xr openssl-dgst 1ssl ,
.Xr pesign-client 1 ,
.Xr pk12util 1 ,
.Xr pkcs15-init 1 ,
.LP
.Sh AUTHORS
.An Peter Jones
.An Vikas Charak \fR(examples)
.An Kamil Aronowski \fR(fixes and improvements)

```

`src/pesign.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesign.c - a PE signing utility
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <err.h>
#include <glob.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <nss.h>

#include <popt.h>

#include <prerror.h>
#include <cert.h>
#include <pkcs7t.h>

#include "pesign.h"
#include "pesign_standalone.h"

static struct {
	int flag;
	const char *name;
} flag_names[] = {
	{DAEMONIZE, "daemonize"},
	{GENERATE_DIGEST, "hash"},
	{GENERATE_SIGNATURE, "sign"},
	{IMPORT_RAW_SIGNATURE, "import-raw-sig"},
	{IMPORT_SIGNATURE, "import-sig"},
	{IMPORT_SATTRS, "import-sattrs" },
	{EXPORT_SATTRS, "export-sattrs" },
	{EXPORT_SIGNATURE, "export-sig"},
	{EXPORT_PUBKEY, "export-pubkey"},
	{EXPORT_CERT, "export-cert"},
	{REMOVE_SIGNATURE, "remove"},
	{LIST_SIGNATURES, "list"},
	{FLAG_LIST_END, NULL},
};

void
print_flag_name(FILE *f, int flag)
{
	for (int i = 0; flag_names[i].flag != FLAG_LIST_END; i++) {
		if (flag_names[i].flag == flag)
			fprintf(f, "%s ", flag_names[i].name);
	}
}

static long *verbose;

long verbosity(void)
{
	if (!verbose)
		return 0;
	return *verbose;
}

enum {
	POPT_RET_PWDB = 0x40000001,
	POPT_RET_ENV = 0x40000002,
	POPT_RET_PINFD = 0x40000003,
	POPT_RET_PINFILE = 0x40000004,
};

int
main(int argc, char *argv[])
{
	int rc;

	pesign_context *ctxp;
	file_format fmt = FORMAT_PE_BINARY;

	int list = 0;
	int remove = 0;
	int daemon = 0;
	int fork = 1;
	int padding = 1;
	int need_db = 0;
	int check_vendor_cert = 1;

	char *digest_name = "sha256";
	char *orig_digest_name = digest_name;
	char *tokenname = "NSS Certificate DB";
	char *origtoken = tokenname;
	char *certname = NULL;
	char *certdir = "/etc/pki/pesign";
	char *orig_certdir = certdir;
	char *signum = NULL;

	secuPWData pwdata;

	memset(&pwdata, 0, sizeof(pwdata));
	pwdata.intdata = -1;

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	rc = pesign_context_new(&ctxp);
	if (rc < 0) {
		fprintf(stderr, "Could not initialize context: %m\n");
		exit(1);
	}
	verbose = &ctxp->verbose;

	poptContext optCon;
	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesign" },
		{.longName = "in",
		 .shortName = 'i',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctxp->infile,
		 .descrip = "specify input file",
		 .argDescrip = "<infile>"},
		{.longName = "out",
		 .shortName = 'o',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctxp->outfile,
		 .descrip = "specify output file",
		 .argDescrip = "<outfile>" },
		{.longName = "certificate",
		 .shortName = 'c',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &certname,
		 .descrip = "specify certificate nickname",
		 .argDescrip = "<certificate nickname>" },
		{.longName = "certdir",
		 .shortName = 'n',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &certdir,
		 .descrip = "specify nss certificate database directory",
		 .argDescrip = "<certificate directory path>" },
		{.longName = "force",
		 .shortName = 'f',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &ctxp->force,
		 .val = 1,
		 .descrip = "force overwriting of output file" },
		{.longName = "sign",
		 .shortName = 's',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &ctxp->sign,
		 .val = 1,
		 .descrip = "create a new signature" },
		{.longName = "hash",
		 .shortName = 'h',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &ctxp->hash,
		 .val = 1,
		 .descrip = "hash binary" },
		{.longName = "digest-type",
		 .shortName = 'd',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &digest_name,
		 .descrip = "digest type to use for pe hash" },
		{.longName = "digest_type",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &digest_name,
		 .descrip = "digest type to use for pe hash" },
		{.longName = "import-signature",
		 .shortName = 'm',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->insig,
		 .descrip = "<insig>" },
		{.longName = "import-signed-certificate",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->insig,
		 .descrip = "<insig>" },
		{.longName = "export-signed-attributes",
		 .shortName = 'E',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->outsattrs,
		 .descrip = "export signed attributes to file",
		 .argDescrip = "<signed_attributes_file>" },
		{.longName = "import-signed-attributes",
		 .shortName = 'I',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->insattrs,
		 .descrip = "import signed attributes from file",
		 .argDescrip = "<signed_attributes_file>" },
		{.longName = "import-raw-signature",
		 .shortName = 'R',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->rawsig,
		 .descrip = "import raw signature from file",
		 .argDescrip = "<inraw>" },
		{.longName = "signature-number",
		 .shortName = 'u',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &signum,
		 .descrip = "specify which signature to operate on","<sig-number>"},
		{.longName = "list-signatures",
		 .shortName = 'l',
		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &list,
		 .val = 1,
		 .descrip = "list signatures" },
		{.longName = "token",
		 .shortName = 't',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &tokenname,
		 .descrip = "NSS token holding signing key" },
		{.longName = "nss-token",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &tokenname,
		 .descrip = "NSS token holding signing key" },
		{.longName = "show-signature",
		 .shortName = 'S',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &list,
		 .val = 1,
		 .descrip = "show signature" },
		{.longName = "remove-signature",
		 .shortName = 'r',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &remove,
		 .val = 1,
		 .descrip = "remove signature" },
		{.longName = "export-signature",
		 .shortName = 'e',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &ctxp->outsig,
		 .descrip = "export signature to file",
		 .argDescrip = "<outsig>" },
		{.longName = "export-pubkey",
		 .shortName = 'K',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctxp->outkey,
		 .descrip = "export pubkey to file",
		 .argDescrip = "<outkey>" },
		{.longName = "export-cert",
		 .shortName = 'C',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &ctxp->outcert,
		 .descrip = "export signing cert to file",
		 .argDescrip = "<outcert>" },
		{.longName = "ascii-armor",
		 .shortName = 'a',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &ctxp->ascii,
		 .val = 1,
		 .descrip = "use ascii armoring" },
		{.longName = "daemonize",
		 .shortName = 'D',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &daemon,
		 .val = 1,
		 .descrip = "run as a daemon process" },
		{.longName = "nofork",
		 .shortName = 'N',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &fork,
		 .descrip = "don't fork when daemonizing" },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctxp->verbose,
		 .val = 1,
		 .descrip = "be more verbose" },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &ctxp->verbose,
		 .val = 2,
		 .descrip = "be very verbose" },
		{.longName = "pinfd",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_INT,
		 .arg = &pwdata.intdata,
		 .val = POPT_RET_PINFD,
		 .descrip = "read file descriptor for pin information",
		 .argDescrip = "<file descriptor>" },
		{.longName = "pinfile",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &pwdata.data,
		 .val = POPT_RET_PINFILE,
		 .descrip = "read named file for pin information",
		 .argDescrip = "<pin file name>" },
		{.longName = "pinenv",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING,
		 .arg = &pwdata.data,
		 .val = POPT_RET_ENV,
		 .descrip = "read file descriptor for pin information",
		 .argDescrip = "<file descriptor>" },
		{.longName = "padding",
		 .shortName = 'P',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &padding,
		 .val = 1,
		 .descrip = "pad data section (default)" },
		{.longName = "nopadding",
		 .shortName = 'p',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &padding,
		 .val = 0,
		 .descrip = "do not pad the data section" },
		{.longName = "no-vendor-cert",
		 .shortName = 'V',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &check_vendor_cert,
		 .val = 0,
		 .descrip = "do not hash the .vendor_cert section." },
		{.longName = "pwfile",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &pwdata.data,
		 .val = POPT_RET_PWDB,
		 .descrip = "file to read passwords from.",
		 .argDescrip = "<pwfile>" },
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	optCon = poptGetContext("pesign", argc, (const char **)argv, options,0);

	rc = poptReadDefaultConfig(optCon, 0);
	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT)) {
		fprintf(stderr, "pesign: poptReadDefaultConfig failed: %s\n",
		poptStrerror(rc));
		exit(1);
	}

	while ((rc = poptGetNextOpt(optCon)) > 0) {
		switch (rc) {
		case POPT_RET_PWDB:
			dbgprintf("POPT_RET_PWDB:\"%s\"", pwdata.data ? pwdata.data : "(null)");
			if (pwdata.source != PW_SOURCE_INVALID)
				errx(1, "only one password/pin method can be used at a time");
			if (pwdata.data == NULL)
				errx(1, "--pwfile requires a file name as an argument");
			pwdata.source = PW_FROMFILEDB;
			pwdata.data = strdup(pwdata.data);
			pwdata.intdata = -1;
			if (!pwdata.data)
				err(1, "could not allocate memory");
			continue;

		case POPT_RET_ENV:
			dbgprintf("POPT_RET_ENV:\"%s\"", pwdata.data ? pwdata.data : "(null)");
			if (pwdata.source != PW_SOURCE_INVALID)
				errx(1, "only one password/pin method can be used at a time");
			if (pwdata.data == NULL)
				errx(1, "--pinenv requires an environment variable name as an argument");
			pwdata.source = PW_FROMENV;
			pwdata.data = strdup(pwdata.data);
			pwdata.intdata = -1;
			if (!pwdata.data)
				err(1, "could not allocate memory");
			continue;

		case POPT_RET_PINFD:
			dbgprintf("POPT_RET_PINFD:\"%s\"", pwdata.data ? pwdata.data : "(null)");
			if (pwdata.source != PW_SOURCE_INVALID)
				errx(1, "only one password/pin method can be used at a time");
			if (pwdata.data == NULL)
				errx(1, "--pinfd requires a file descriptor as an argument");
			errno = 0;
			pwdata.source = PW_FROMFD;
			pwdata.intdata = strtol(pwdata.data, NULL, 0);
			if ((pwdata.intdata == LONG_MIN || pwdata.intdata == LONG_MAX) && errno != 0)
				err(1, "file descriptor needed, got \"%s\"", pwdata.data ? pwdata.data : "(null)");
			pwdata.data = NULL;
			continue;

		case POPT_RET_PINFILE:
			dbgprintf("POPT_RET_PINFILE:\"%s\"", pwdata.data ? pwdata.data : "(null)");
			if (pwdata.source != PW_SOURCE_INVALID)
				errx(1, "only one password/pin method can be used at a time");
			if (pwdata.data == NULL)
				errx(1, "--pinfile requires a file name as an argument");
			pwdata.source = PW_FROMFILE;
			pwdata.data = strdup(pwdata.data);
			pwdata.intdata = -1;
			if (!pwdata.data)
				err(1, "could not allocate memory");
			continue;
		}
	}

	dbgprintf("pwdata.source:%d %schecking for PESIGN_TOKEN_PIN",
		pwdata.source,
		pwdata.source == PW_SOURCE_INVALID ? "" : "not ");
	if (pwdata.source == PW_SOURCE_INVALID && secure_getenv("PESIGN_TOKEN_PIN")) {
		pwdata.source = PW_FROMENV;
		pwdata.data = strdup(secure_getenv("PESIGN_TOKEN_PIN"));
		if (!pwdata.data)
			err(1, "could not allocate memory");
	} else if (pwdata.source == PW_SOURCE_INVALID) {
		pwdata.source = PW_PROMPT;
	}
	pwdata.orig_source = pwdata.source;

	if (rc < -1) {
		fprintf(stderr, "pesign: Invalid argument: %s: %s\n",
			poptBadOption(optCon, 0), poptStrerror(rc));
		exit(1);
	}

	if (poptPeekArg(optCon)) {
		fprintf(stderr, "pesign: Invalid Argument: \"%s\"\n",
				poptPeekArg(optCon));
		exit(1);
	}

	poptFreeContext(optCon);

	if (signum) {
		errno = 0;
		ctxp->signum = strtol(signum, NULL, 0);
		if (errno != 0) {
			fprintf(stderr, "invalid signature number: %m\n");
			exit(1);
		}
		free(signum);
	}

	int action = 0;
	if (daemon)
		action |= DAEMONIZE;

	if (ctxp->rawsig) {
		action |= IMPORT_RAW_SIGNATURE;
		need_db = 1;
	}

	if (ctxp->insattrs)
		action |= IMPORT_SATTRS;

	if (ctxp->outsattrs)
		action |= EXPORT_SATTRS;

	if (ctxp->insig)
		action |= IMPORT_SIGNATURE;

	if (ctxp->outkey) {
		action |= EXPORT_PUBKEY;
		need_db = 1;
	}

	if (ctxp->outcert) {
		action |= EXPORT_CERT;
		need_db = 1;
	}

	if (ctxp->outsig)
		action |= EXPORT_SIGNATURE;

	if (remove != 0)
		action |= REMOVE_SIGNATURE;

	if (list != 0)
		action |= LIST_SIGNATURES;

	if (ctxp->sign) {
		action |= GENERATE_SIGNATURE;
		if (!(action & EXPORT_SIGNATURE))
			action |= IMPORT_SIGNATURE;
		need_db = 1;
	}

	if (ctxp->hash)
		action |= GENERATE_DIGEST|PRINT_DIGEST;

	if (!check_vendor_cert) {
		action |= OMIT_VENDOR_CERT;
	}

	if (!daemon) {
		SECStatus status;
		int error = 0;
		if (need_db) {
			status = NSS_Init(certdir);
			if (status != SECSuccess) {
				char *globpattern = NULL;
				error = errno;
				rc = asprintf(&globpattern, "%s/cert*.db",
					      certdir);
				if (rc > 0) {
					glob_t globbuf;
					memset(&globbuf, 0, sizeof(globbuf));
					rc = glob(globpattern, GLOB_ERR, NULL,
						  &globbuf);
					if (rc != 0) {
						err(1, "Could not open NSS database (\"%s\")",
						     PORT_ErrorToString(PORT_GetError()));
					}
				}
			}
		} else
			status = NSS_NoDB_Init(NULL);
		if (status != SECSuccess) {
			errno = error;
			errx(1, "Could not initialize nss.\n"
			        "NSS says \"%s\" errno says \"%m\"\n",
			     PORT_ErrorToString(PORT_GetError()));
		}
		/*
		 * At this point there is *often* an error set, but we
		 * should not get here if it was really an error; one
		 * example is PR_LOAD_LIBRARY_ERROR is often set by PKCS11
		 * modules that aren't present or whose physical token
		 * devices aren't available.
		 *
		 * Clear it.
		 */
		PORT_SetError(0);

		status = register_oids(ctxp->cms_ctx);
		if (status != SECSuccess) {
			fprintf(stderr, "Could not register OIDs\n");
			exit(1);
		}
	}

	rc = set_digest_parameters(ctxp->cms_ctx, digest_name);
	int is_help  = strcmp(digest_name, "help") ? 0 : 1;
	if (rc < 0) {
		if (!is_help) {
			fprintf(stderr, "Digest \"%s\" not found.\n",
				digest_name);
		}
		exit(!is_help);
	}

	if (pwdata.source != PW_DEVICE)
		cms_set_pw_data(ctxp->cms_ctx, &pwdata);

	ctxp->cms_ctx->omit_vendor_cert = !check_vendor_cert;

	ctxp->cms_ctx->tokenname = tokenname ?
		PORT_ArenaStrdup(ctxp->cms_ctx->arena, tokenname) : NULL;
	if (tokenname && !ctxp->cms_ctx->tokenname) {
		fprintf(stderr, "could not allocate token name: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}
	if (tokenname != origtoken)
		free(tokenname);

	ctxp->cms_ctx->certname = certname ?
		PORT_ArenaStrdup(ctxp->cms_ctx->arena, certname) : NULL;
	if (certname && !ctxp->cms_ctx->certname) {
		fprintf(stderr, "could not allocate certificate name: %s\n",
			PORT_ErrorToString(PORT_GetError()));
		exit(1);
	}
	if (certname)
		free(certname);
	if (digest_name && digest_name != orig_digest_name)
		free(digest_name);

	if (ctxp->sign) {
		if (!ctxp->cms_ctx->certname) {
			fprintf(stderr, "pesign: signing requested but no "
				"certificate nickname provided\n");
			exit(1);
		}
	}

	if (ctxp->infile) {
		char *ext = strrchr(ctxp->infile, '.');
		if (ext && strcmp(ext, ".ko") == 0)
			fmt = FORMAT_KERNEL_MODULE;
	}

	switch (action) {
		case NO_FLAGS:
			fprintf(stderr, "pesign: Nothing to do.\n");
			exit(0);
			break;
		case DAEMONIZE:
			rc = daemonize(ctxp->cms_ctx, certdir, fork);
			break;
		default:
			switch (fmt) {
				case FORMAT_PE_BINARY:
					pe_handle_action(ctxp, action, padding);
					break;
				case FORMAT_KERNEL_MODULE:
					kmod_handle_action(ctxp, action);
					break;
			}
	}
	if (certdir && certdir != orig_certdir)
		free(certdir);
	pesign_context_free(ctxp);

	if (!daemon) {
		SECStatus status = NSS_Shutdown();
		if (status != SECSuccess) {
			fprintf(stderr, "could not shut down NSS: %s",
				PORT_ErrorToString(PORT_GetError()));
			exit(1);
		}
	}

	return (rc < 0);
}

// vim:fenc=utf-8:tw=75:noet

```

`src/pesign.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pesign.h - helper header for pesign
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_H
#define PESIGN_H 1

#include "fix_coverity.h"

#include <efivar.h>
#include <efisec.h>

#include <libdpe/libdpe.h>
#include <libdpe/pe.h>

#include "util.h"
#include "text.h"
#include "cms_common.h"
#include "pesign_context.h"

#include "daemon.h"
#include "actions.h"
#include "errno-guard.h"
#include "endian.h"
#include "errno-guard.h"
#include "oid.h"
#include "wincert.h"
#include "content_info.h"
#include "signer_info.h"
#include "signed_data.h"
#include "password.h"

#endif /* PESIGN_H */

```

`src/pesign.popt`:

```popt
pesign alias --cert --certificate
pesign alias --certficate --certificate
pesign alias --daemon --daemonize
pesign alias --ascii --ascii-armor

```

`src/pesign.service.in`:

```in
[Unit]
Description=Pesign signing daemon

[Service]
PrivateTmp=true
PIDFile=@@RUNDIR@@/pesign.pid
ExecStart=/usr/bin/pesign --daemonize --nofork

[Install]
WantedBy=multi-user.target

```

`src/pesign.sysvinit.in`:

```in
#! /bin/sh
#
# pesign	This starts the pesign PE signing daemon
#
# chkconfig: - 50 50
# processname: /usr/bin/pesign
# pidfile: @@RUNDIR@@pesign.pid
### BEGIN INIT INFO 
# Provides: pesign
# Default-Start:
# Default-Stop:
# Short-Description: The pesign PE signing daemon
# Description: The pesign PE signing daemon
### END INIT INFO

. /etc/init.d/functions
[ -f /usr/bin/pesign ] || exit 1

RETVAL=0

start(){
    echo -n "Starting pesign: "
    mkdir @@RUNDIR@@pesign 2>/dev/null &&
        chown pesign:pesign @@RUNDIR@@pesign &&
        chmod 0770 @@RUNDIR@@pesign
    daemon /usr/bin/pesign --daemonize
    RETVAL=$?
    echo
    touch /var/lock/subsys/pesign
}

stop(){
    echo -n "Stopping pesign: "
    killproc -p @@RUNDIR@@pesign.pid pesignd
    RETVAL=$?
    echo
    rm -f /var/lock/subsys/pesign
}

restart(){
    stop
    start
}

reload(){
    stop
    start
}

condrestart(){
    [ -e /var/lock/subsys/pesign ] && restart
}

# See how we were called.
case "$1" in
    start)
	start
	;;
    stop)
	stop
	;;
    status)
	status /usr/bin/pesign
	;;
    restart)
	restart
	;;
    reload)
	reload
	;;
    force-reload)
	reload
	;;
    condrestart)
	condrestart
	;;
    try-restart)
	condrestart
	;;
    *)
	echo "Usage: pesign {start|stop|status|restart|condrestart|reload}"
	RETVAL=1
esac

exit $RETVAL

```

`src/pesign_context.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesign_context.c - context setup and teardown for pesign
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <unistd.h>

#include "pesign.h"

#include <nss.h>
#include <secitem.h>

int
pesign_context_new(pesign_context **ctx)
{
	pesign_context *context = NULL;
	int rc = 0;

	if (ctx == NULL)
		return -1;

	context = malloc(sizeof (*context));
	if (!context)
		return -1;

	rc = pesign_context_init(context);
	if (rc < 0) {
		free(context);
		return rc;
	}
	context->flags |= PESIGN_C_ALLOCATED;

	*ctx = context;
	return rc;
}

int
pesign_context_init(pesign_context *ctx)
{
	if (!ctx)
		return -1;
	memset(ctx, '\0', sizeof (*ctx));

	ctx->infd = -1;
	ctx->outfd = -1;
	ctx->outmode = 0644;

	ctx->rawsigfd = -1;
	ctx->insattrsfd = -1;
	ctx->outsattrsfd = -1;

	ctx->insigfd = -1;
	ctx->outsigfd = -1;
	ctx->outkeyfd = -1;
	ctx->outcertfd = -1;

	ctx->signum = -1;

	ctx->ascii = 0;
	ctx->sign = 0;
	ctx->hash = 0;

	int rc = cms_context_alloc(&ctx->cms_ctx);
	if (rc < 0)
		return rc;

	return 0;
}

void
pesign_context_fini(pesign_context *ctx)
{
	if (!ctx)
		return;

	if (ctx->cms_ctx) {
		cms_context_fini(ctx->cms_ctx);
		ctx->cms_ctx = NULL;
	}

	if (ctx->outpe) {
		pe_end(ctx->outpe);
		ctx->outpe = NULL;
	}

	if (ctx->inpe) {
		pe_end(ctx->inpe);
		ctx->inpe = NULL;
	}

	xfree(ctx->outfile);
	xfree(ctx->infile);

	xfree(ctx->rawsig);
	xfree(ctx->insattrs);
	xfree(ctx->outsattrs);

	xfree(ctx->insig);
	xfree(ctx->outsig);

	xfree(ctx->outkey);
	xfree(ctx->outcert);

	if (ctx->rawsigfd >= 0) {
		close(ctx->rawsigfd);
		ctx->rawsigfd = -1;
	}
	if (ctx->insattrsfd >= 0) {
		close(ctx->insattrsfd);
		ctx->insattrsfd = -1;
	}
	if (ctx->outsattrsfd >= 0) {
		close(ctx->outsattrsfd);
		ctx->outsattrsfd = -1;
	}

	if (ctx->insigfd >= 0) {
		close(ctx->insigfd);
		ctx->insigfd = -1;
	}

	if (ctx->outsigfd >= 0) {
		close(ctx->outsigfd);
		ctx->outsigfd = -1;
	}

	if (ctx->outkeyfd >= 0) {
		close(ctx->outkeyfd);
		ctx->outkeyfd = -1;
	}

	if (ctx->outcertfd >= 0) {
		close(ctx->outcertfd);
		ctx->outcertfd = -1;
	}

	if (ctx->cinfo) {
		SEC_PKCS7DestroyContentInfo(ctx->cinfo);
		ctx->cinfo = NULL;
	}

	if (ctx->outfd >= 0) {
		close(ctx->outfd);
		ctx->outfd = -1;
	}

	if (ctx->infd >= 0) {
		close(ctx->infd);
		ctx->infd = -1;
	}

	ctx->signum = -1;

	if (!(ctx->flags & PESIGN_C_ALLOCATED))
		pesign_context_init(ctx);

}

void
pesign_context_free_private(pesign_context **ctx_ptr)
{
	pesign_context *ctx;
	if (!ctx_ptr || !*ctx_ptr)
		return;

	ctx = *ctx_ptr;
	pesign_context_fini(ctx);

	if (ctx->flags & PESIGN_C_ALLOCATED)
		xfree(*ctx_ptr);
}

```

`src/pesign_context.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pesign_context.h - context setup and teardown for pesign
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_CONTEXT_H
#define PESIGN_CONTEXT_H 1

#include <cert.h>
#include <secpkcs7.h>

enum {
	PESIGN_C_ALLOCATED = 1,
};

typedef enum {
	FORMAT_PE_BINARY,
	FORMAT_KERNEL_MODULE,
} file_format;

typedef struct {
	union {
		int infd;
		int inkmodfd;
	};
	union {
		int outfd;
		int outkmodfd;
	};
	union {
		char *infile;
		char *inkmod;
	};
	union {
		char *outfile;
		char *outkmod;
	};
	size_t inlength;
	mode_t outmode;

	int force;
	long verbose;

	char *rawsig;
	int rawsigfd;
	char *insattrs;
	int insattrsfd;
	char *outsattrs;
	int outsattrsfd;

	char *insig;
	int insigfd;
	SEC_PKCS7ContentInfo *cinfo;
	char *outsig;
	int outsigfd;

	char *outkey;
	int outkeyfd;

	char *outcert;
	int outcertfd;

	Pe *inpe;
	Pe *outpe;

	cms_context *cms_ctx;

	int flags;

	int signum;

	int ascii;
	int sign;
	int hash;
} pesign_context;

extern int pesign_context_new(pesign_context **ctx);
extern void pesign_context_free_private(pesign_context **ctx_ptr);
extern int pesign_context_init(pesign_context *ctx);
extern void pesign_context_fini(pesign_context *ctx);
#define pesign_context_free(ctx) pesign_context_free_private(&(ctx))

#endif /* PESIGN_CONTEXT_H */

```

`src/pesign_kmod.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesign_kmod.c - implement kmod signing
 * Copyright 2017 Endless Mobile, Inc.
 *
 * Author(s): Daniel Drake <drake@endlessm.com>
 */

#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

#include "pesign.h"
#include "pesign_standalone.h"
#include "file_kmod.h"

define_input_file(kmod, inkmod, "kmod");
define_output_file(kmod, outkmod, "kmod");
define_output_file(sig, outsig, "signature");
define_input_file(sig, insig, "signature");

static void
import_sig_input(pesign_context *ctx)
{
	unsigned char *map;
	struct stat statbuf;
	int rc;

	open_sig_input(ctx);

	rc = fstat(ctx->insigfd, &statbuf);
	conderr(rc < 0, 1, "Could not fstat signature file \"%s\"",
		ctx->insig);

	/* Copy original module data */

	map = mmap(NULL, ctx->inlength, PROT_READ, MAP_PRIVATE, ctx->infd, 0);
	conderr(map == MAP_FAILED, 1, "Could not map kmod input file \"%s\"", ctx->inkmod);

	rc = write_file(ctx->outfd, map, ctx->inlength);
	conderr(rc < 0, 1, "Failed to write module data to \"%s\"", ctx->outkmod);

	munmap(map, ctx->inlength);

	/* Append signature to output. */

	map = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, ctx->insigfd,
		   0);
	conderr(map == MAP_FAILED, 1, "Could not map signature input \"%s\"",
		ctx->insig);

	rc = write_file(ctx->outfd, map, statbuf.st_size);
	conderr(rc < 0, 1, "Error writing output");

	munmap(map, statbuf.st_size);
}

static void
handle_signing(pesign_context *ctx, int outfd, int attached)
{
	int	rc;
	unsigned char *inmap;
	ssize_t sig_len;

	inmap = mmap(NULL, ctx->inlength, PROT_READ, MAP_PRIVATE, ctx->infd, 0);
	conderr(inmap == MAP_FAILED, 1, "Could not map input kmod file \"%s\"", ctx->inkmod);

	rc = kmod_generate_digest(ctx->cms_ctx, inmap, ctx->inlength);
	if (rc < 0)
		exit(1);

	if (attached) {
		rc = write_file(outfd, inmap, ctx->inlength);
		conderr(rc < 0, 1, "Failed to write module data to \"%s\"", ctx->outkmod);
	}
	munmap(inmap, ctx->inlength);

	sig_len = kmod_write_signature(ctx->cms_ctx, outfd);
	if (sig_len < 0)
		exit(1);

	if (kmod_write_sig_info(ctx->cms_ctx, outfd, sig_len) < 0)
		exit(1);
}

void
kmod_handle_action(pesign_context *ctxp, int action)
{
	int rc;

	switch (action) {
		/* generate a signature and embed it in the module */
		case IMPORT_SIGNATURE|GENERATE_SIGNATURE:
			rc = find_certificate(ctxp->cms_ctx, 1);
			conderrx(rc < 0, 1, "Could not find certificate \"%s\"",
				 ctxp->cms_ctx->certname);
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures + 1,
				 1, "Invalid signature number.");

			open_kmod_input(ctxp);
			proxy_fd_mode(ctxp->inkmodfd, ctxp->inkmod,
				      &ctxp->outmode, &ctxp->inlength);
			open_kmod_output(ctxp);
			handle_signing(ctxp, ctxp->outfd, 1);
			close_kmod_output(ctxp);
			close_kmod_input(ctxp);
			break;

		/* generate a signature and save it in a separate file */
		case EXPORT_SIGNATURE|GENERATE_SIGNATURE:
			rc = find_certificate(ctxp->cms_ctx, 1);
			conderrx(rc < 0, 1, "Could not find certificate \"%s\"",
				 ctxp->cms_ctx->certname);
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures + 1,
				 1, "Invalid signature number.");

			open_kmod_input(ctxp);
			proxy_fd_mode(ctxp->inkmodfd, ctxp->inkmod,
				      &ctxp->outmode, &ctxp->inlength);
			open_sig_output(ctxp);
			handle_signing(ctxp, ctxp->outsigfd, 0);
			close_sig_output(ctxp);
			close_kmod_input(ctxp);
			break;

		/* add a signature from a file */
		case IMPORT_SIGNATURE:
			conderrx(ctxp->signum > ctxp->cms_ctx->num_signatures + 1,
				 1, "Invalid signature number.");
			open_kmod_input(ctxp);
			proxy_fd_mode(ctxp->inkmodfd, ctxp->inkmod,
				      &ctxp->outmode, &ctxp->inlength);
			open_kmod_output(ctxp);
			import_sig_input(ctxp);
			close_kmod_input(ctxp);
			close_kmod_output(ctxp);
			break;

		default:
			fprintf(stderr, "%s: Incompatible flags (0x%08x): ",
				program_invocation_short_name, action);
			for (int i = 1; i < FLAG_LIST_END; i <<= 1) {
				if (action & i)
					print_flag_name(stderr, i);
			}
			fprintf(stderr, "\n");
			exit(1);
	}
}

// vim:fenc=utf-8:tw=75:noet

```

`src/pesign_standalone.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * pesign_standalone.h - decls for the standalone pesign tool
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_STANDALONE_H
#define PESIGN_STANDADLONE_H 1

#define NO_FLAGS		0x00
#define GENERATE_DIGEST		0x01
#define GENERATE_SIGNATURE	0x02
#define IMPORT_RAW_SIGNATURE	0x04
#define IMPORT_SIGNATURE	0x08
#define IMPORT_SATTRS		0x10
#define EXPORT_SATTRS		0x20
#define EXPORT_SIGNATURE	0x40
#define REMOVE_SIGNATURE	0x80
#define LIST_SIGNATURES		0x100
#define PRINT_DIGEST		0x200
#define EXPORT_PUBKEY		0x400
#define EXPORT_CERT		0x800
#define DAEMONIZE		0x1000
#define OMIT_VENDOR_CERT	0x2000
#define FLAG_LIST_END		0x4000

void print_flag_name(FILE *f, int flag);
void pe_handle_action(pesign_context *ctxp, int action, int padding);
void kmod_handle_action(pesign_context *ctxp, int action);

#endif /* PESIGN_STANDALONE_H */

```

`src/pesum.1.mdoc`:

```mdoc
.Dd $Mdocdate: Mar 11 2022$
.Dt PESUM 1
.Os Linux
.Sh NAME
.Nm pesum
.Nd tool for generating Authenticode digests
.Sh SYNOPSIS
.Nm
.Bk -words
.Ar file0.efi
.Op Ar file1.efi ...
.Sh DESCRIPTION
.Nm
is a command line tool to generate Authenticode digests of PE binaries.
.Sh EXAMPLES
.Ss Getting the Authenticode digest of some files
host:$ \fBpesum shimx64.efi grubx64.efi\fR
8c5806e66bb5b052ebf860e1722474269cff3dde588610df21dbe8cf12c08390\ shimx64.efi
546a71319c22da1d81879383c4c74be06d1c374bdecfafc9fcc80bd541802bfc\ grubx64.efi
.Sh STANDARDS
.Rs
.%B Portable Executable
.%I Microsoft
.%D August 26, 2019
.%U https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\ \&
.Re

.Rs
.%B Windows Authenticode Portable Executable Signature Format
.%I Microsoft
.%D March 21, 2008
.%U https://web.archive.org/web/20130518222430/http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx\ \&
.Re
.Sh SEE ALSO
.Xr pesign 1
.LP
.Sh AUTHORS
.An Peter Jones

```

`src/pesum.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * pesum.c - pesum command line tool
 * Copyright Peter Jones <pjones@redhat.com>
 */

#include "fix_coverity.h"

#include <err.h>
#include <popt.h>

#include <nss.h>
#include <prerror.h>

#include "pesign.h"
#include "pesign_standalone.h"

static struct {
	int flag;
	const char *name;
} flag_names[] = {
	{DAEMONIZE, "daemonize"},
	{GENERATE_DIGEST, "hash"},
	{GENERATE_SIGNATURE, "sign"},
	{IMPORT_RAW_SIGNATURE, "import-raw-sig"},
	{IMPORT_SIGNATURE, "import-sig"},
	{IMPORT_SATTRS, "import-sattrs" },
	{EXPORT_SATTRS, "export-sattrs" },
	{EXPORT_SIGNATURE, "export-sig"},
	{EXPORT_PUBKEY, "export-pubkey"},
	{EXPORT_CERT, "export-cert"},
	{REMOVE_SIGNATURE, "remove"},
	{LIST_SIGNATURES, "list"},
	{FLAG_LIST_END, NULL},
};

void
print_flag_name(FILE *f, int flag)
{
	for (int i = 0; flag_names[i].flag != FLAG_LIST_END; i++) {
		if (flag_names[i].flag == flag)
			fprintf(f, "%s ", flag_names[i].name);
	}
}

static long *verbose;

long
verbosity(void)
{
	if (!verbose)
		return 0;
	return *verbose;
}

int
main(int argc, char *argv[])
{
	int rc;
	SECStatus status;

	char *digest_name = "sha256";
	char *orig_digest_name = digest_name;
	int padding = 1;
	long verbose_cmd_line = 0;
	const char *infile;

	int action = GENERATE_DIGEST|PRINT_DIGEST;
	file_format fmt = FORMAT_PE_BINARY;

	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);

	verbose = &verbose_cmd_line;

	poptContext optCon;
	struct poptOption options[] = {
		{.argInfo = POPT_ARG_INTL_DOMAIN,
		 .arg = "pesum" },
		{.longName = "verbose",
		 .shortName = 'v',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &verbose_cmd_line,
		 .val = 1,
		 .descrip = "be more verbose" },
		{.longName = "debug",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_VAL|POPT_ARG_LONG|POPT_ARGFLAG_OPTIONAL,
		 .arg = &verbose_cmd_line,
		 .val = 2,
		 .descrip = "be very verbose" },
		{.longName = "digest-type",
		 .shortName = 'd',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_SHOW_DEFAULT,
		 .arg = &digest_name,
		 .descrip = "digest type to use for pe hash" },
		{.longName = "digest_type",
		 .shortName = '\0',
		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
		 .arg = &digest_name,
		 .descrip = "digest type to use for pe hash" },
		{.longName = "padding",
		 .shortName = 'P',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &padding,
		 .val = 1,
		 .descrip = "pad data section (default)" },
		{.longName = "nopadding",
		 .shortName = 'p',
		 .argInfo = POPT_ARG_VAL,
		 .arg = &padding,
		 .val = 0,
		 .descrip = "do not pad the data section" },
		POPT_AUTOALIAS
		POPT_AUTOHELP
		POPT_TABLEEND
	};

	optCon = poptGetContext("pesum", argc, (const char **)argv, options,0);

	rc = poptReadDefaultConfig(optCon, 0);
	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
		errx(1, "poptReadDefaultConfig failed: %s", poptStrerror(rc));

	while ((rc = poptGetNextOpt(optCon)) > 0) {
		;
	}

	if (rc < -1)
		errx(1, "Invalid argument: %s: %s",
		     poptBadOption(optCon, 0), poptStrerror(rc));

	if (!poptPeekArg(optCon))
		errx(1, "nothing to do");

	status = NSS_NoDB_Init(NULL);
	if (status != SECSuccess)
		errx(1, "Could not initialize nss.\n"
		        "NSS says \"%s\" errno says \"%m\"\n",
			PORT_ErrorToString(PORT_GetError()));

	while ((infile = poptGetArg(optCon)) != NULL) {
		pesign_context *ctxp = NULL;

		char *ext = strrchr(infile, '.');
		if (ext && strcmp(ext, ".ko") == 0)
			fmt = FORMAT_KERNEL_MODULE;

		rc = pesign_context_new(&ctxp);
		if (rc < 0)
			err(1, "Could not initialize context");

		ctxp->verbose = verbose_cmd_line;

		ctxp->hash = 1;
		ctxp->infile = strdup(infile);
		if (!ctxp->infile)
			err(1, "Could not allocate memory");

		rc = set_digest_parameters(ctxp->cms_ctx, digest_name);
		int is_help = strcmp(digest_name, "help") ? 0 : 1;
		if (rc < 0) {
			if (!is_help) {
				fprintf(stderr, "Digest \"%s\" not found.\n",
					digest_name);
			}
			exit(!is_help);
		}

		errno = 0;
		switch (fmt) {
			case FORMAT_PE_BINARY:
				pe_handle_action(ctxp, action, padding);
				break;
			case FORMAT_KERNEL_MODULE:
				kmod_handle_action(ctxp, action);
				break;
		}

		pesign_context_free(ctxp);
	}

	poptFreeContext(optCon);

	if (digest_name && digest_name != orig_digest_name)
		free(digest_name);

	status = NSS_Shutdown();
	if (status != SECSuccess)
		errx(1, "could not shut down NSS: %s",
		     PORT_ErrorToString(PORT_GetError()));

	return 0;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/signed_data.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * signed_data.c - implement the authenticode signed_data structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "pesign.h"

#include <prerror.h>
#include <nss.h>

static int
generate_algorithm_id_list(cms_context *cms, SECAlgorithmID ***algorithm_list_p)
{
	SECAlgorithmID **algorithms = NULL;
	int err = 0;

	algorithms = PORT_ArenaZAlloc(cms->arena, sizeof (SECAlgorithmID *) *
						  2);
	if (!algorithms)
		return -1;

	algorithms[0] = PORT_ArenaZAlloc(cms->arena, sizeof(SECAlgorithmID));
	if (!algorithms[0]) {
		err = PORT_GetError();
		goto err_list;
	}

	if (generate_algorithm_id(cms, algorithms[0],
			digest_get_digest_oid(cms)) < 0) {
		err = PORT_GetError();
		goto err_item;
	}

	*algorithm_list_p = algorithms;
	return 0;
err_item:
	PORT_ZFree(algorithms[0], sizeof (SECAlgorithmID));
err_list:
	PORT_ZFree(algorithms, sizeof (SECAlgorithmID *) * 2);
	PORT_SetError(err);
	return -1;
}

void
free_algorithm_list(cms_context *cms UNUSED,
		    SECAlgorithmID **algorithm_list)
{
	if (!algorithm_list)
		return;

#if 0
	for (int i = 0; algorithm_list[i] != NULL; i++) {
		PORT_ZFree(algorithm_list[i], sizeof (SECAlgorithmID));
	}
	PORT_ZFree(algorithm_list, sizeof (SECAlgorithmID *) * 2);
#endif
}

static int
generate_certificate_list(cms_context *cms, SECItem ***certificate_list_p)
{
	SECItem **certificates = NULL;
	void *mark = PORT_ArenaMark(cms->arena);

	certificates = PORT_ArenaZAlloc(cms->arena, sizeof (SECItem *) * 3);
	if (!certificates) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cmsreterr(-1, cms, "could not allocate certificate list");
	}
	int i = 0;

	certificates[i] = PORT_ArenaZAlloc(cms->arena, sizeof (SECItem));
	if (!certificates[i]) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cmsreterr(-1, cms, "could not allocate certificate entry");
	}
	SECITEM_CopyItem(cms->arena, certificates[i++], &cms->cert->derCert);

	if (!is_issuer_of(cms->cert, cms->cert)) {
		CERTCertificate *signer = NULL;
		int rc = find_named_certificate(cms, cms->cert->issuerName,
						&signer);
		if (rc == 0 && signer &&
				signer->derCert.len && signer->derCert.data) {
			if (signer->derCert.len != cms->cert->derCert.len ||
					memcmp(signer->derCert.data,
						cms->cert->derCert.data,
						signer->derCert.len)) {
				certificates[i] = PORT_ArenaZAlloc(cms->arena,
							sizeof (SECItem));
				if (!certificates[i]) {
					save_port_err() {
						PORT_ArenaRelease(cms->arena, mark);
					}
					cmsreterr(-1, cms,"could not allocate "
						"certificate entry");
				}
				SECITEM_CopyItem(cms->arena, certificates[i++],
						&signer->derCert);
			}
			CERT_DestroyCertificate(signer);
		}
	}

	*certificate_list_p = certificates;
	PORT_ArenaUnmark(cms->arena, mark);
	return 0;
}

typedef enum {
	PE_SIGNER_INFO,
	AUTHVAR_SIGNER_INFO,
	END_SIGNER_INFO_LIST
} SignerInfoType;

int
generate_signerInfo_list(cms_context *cms, SpcSignerInfo ***signerInfo_list_p, SignerInfoType type)
{
	SpcSignerInfo **signerInfo_list;
	int err = 0;
	int rc;

	if (!signerInfo_list_p)
		return -1;

	signerInfo_list = PORT_ArenaZAlloc(cms->arena,
					sizeof (SpcSignerInfo *) * 2);
	if (!signerInfo_list)
		return -1;

	signerInfo_list[0] = PORT_ArenaZAlloc(cms->arena,
						sizeof (SpcSignerInfo));
	if (!signerInfo_list[0]) {
		err = PORT_GetError();
		goto err_list;
	}

	if (type == PE_SIGNER_INFO)
		rc = generate_spc_signer_info(cms, signerInfo_list[0]);
	else if (type == AUTHVAR_SIGNER_INFO)
		rc = generate_authvar_signer_info(cms, signerInfo_list[0]);
	else
		goto err_item;
	if (rc < 0) {
		err = PORT_GetError();
		goto err_item;
	}

	*signerInfo_list_p = signerInfo_list;
	return 0;
err_item:
#if 0
	PORT_ZFree(signerInfo_list[0], sizeof (SpcSignerInfo));
#endif
err_list:
#if 0
	PORT_ZFree(signerInfo_list, sizeof (SpcSignerInfo *) * 2);
#endif
	PORT_SetError(err);
	return -1;
}

typedef struct {
	SECItem version;
	SECAlgorithmID **algorithms;
	SpcContentInfo cinfo;
	SECItem **certificates;
	SECItem **crls;
	SpcSignerInfo **signerInfos;
} SignedData;

SEC_ASN1Template SignedDataTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (SignedData)
	},
	{
	.kind = SEC_ASN1_INTEGER,
	.offset = offsetof(SignedData, version),
	.sub = &SEC_IntegerTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_SET_OF,
	.offset = offsetof(SignedData, algorithms),
	.sub = &SECOID_AlgorithmIDTemplate,
	.size = sizeof (SECItem),
	},
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(SignedData, cinfo),
	.sub = &SpcContentInfoTemplate,
	.size = sizeof (SpcContentInfo),
	},
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SignedData, certificates),
	.sub = &SEC_SetOfAnyTemplate,
	.size = sizeof(SECItem**),
	},
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 1 |
		SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SignedData, crls),
	.sub = &SEC_SetOfAnyTemplate,
	.size = sizeof (SECItem **),
	},
	{
	.kind = SEC_ASN1_SET_OF,
	.offset = offsetof(SignedData, signerInfos),
	.sub = &SpcSignerInfoTemplate,
	.size = 0,
	},
	{ 0, }
};

typedef struct {
	SECItem contentType;
	SECItem content;
} ContentInfo;

SEC_ASN1Template ContentInfoTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (ContentInfo),
	},
	{
	.kind = SEC_ASN1_OBJECT_ID,
	.offset = offsetof(ContentInfo, contentType),
	.sub = &SEC_ObjectIDTemplate,
	.size = sizeof (SECItem),
	},
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_EXPLICIT,
	.offset = offsetof(ContentInfo, content),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem),
	},
	{ 0, }
};

int
generate_spc_signed_data(cms_context *cms, SECItem *sdp)
{
	SignedData sd;

	if (!sdp)
		return -1;

	memset(&sd, '\0', sizeof (sd));
	void *mark = PORT_ArenaMark(cms->arena);

	if (SEC_ASN1EncodeInteger(cms->arena, &sd.version, 1) == NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cms->ci_digest = NULL;
		cmsreterr(-1, cms, "could not encode integer");
	}

	if (generate_algorithm_id_list(cms, &sd.algorithms) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		cms->ci_digest = NULL;
		return -1;
	}

	if (generate_spc_content_info(cms, &sd.cinfo) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		cms->ci_digest = NULL;
		return -1;
	}

	if (generate_certificate_list(cms, &sd.certificates) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		cms->ci_digest = NULL;
		return -1;
	}

	sd.crls = NULL;

	if (generate_signerInfo_list(cms, &sd.signerInfos, PE_SIGNER_INFO) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		cms->ci_digest = NULL;
		return -1;
	}

	SECItem encoded = { 0, };
	if (SEC_ASN1EncodeItem(cms->arena, &encoded, &sd, SignedDataTemplate)
			== NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cms->ci_digest = NULL;
		cmsreterr(-1, cms, "could not encode SignedData");
	}

	ContentInfo sdw;
	memset(&sdw, '\0', sizeof (sdw));

	SECOidData *oid = SECOID_FindOIDByTag(SEC_OID_PKCS7_SIGNED_DATA);

	memcpy(&sdw.contentType, &oid->oid, sizeof (sdw.contentType));
	memcpy(&sdw.content, &encoded, sizeof (sdw.content));

	SECItem wrapper = { 0, };
	if (SEC_ASN1EncodeItem(cms->arena, &wrapper, &sdw,
			ContentInfoTemplate) == NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cms->ci_digest = NULL;
		cmsreterr(-1, cms, "could not encode SignedData");
	}

	memcpy(sdp, &wrapper, sizeof(*sdp));
	PORT_ArenaUnmark(cms->arena, mark);
	return 0;
}

int
generate_authvar_signed_data(cms_context *cms, SECItem *sdp)
{
	SignedData sd;

	if (!sdp)
		return -1;

	memset(&sd, '\0', sizeof (sd));
	void *mark = PORT_ArenaMark(cms->arena);

	if (SEC_ASN1EncodeInteger(cms->arena, &sd.version, 1) == NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cmsreterr(-1, cms, "could not encode integer");
	}

	if (generate_algorithm_id_list(cms, &sd.algorithms) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		return -1;
	}

	if (generate_authvar_content_info(cms, &sd.cinfo) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		return -1;
	}

	if (generate_certificate_list(cms, &sd.certificates) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		return -1;
	}

	sd.crls = NULL;

	if (generate_signerInfo_list(cms, &sd.signerInfos, AUTHVAR_SIGNER_INFO) < 0) {
		PORT_ArenaRelease(cms->arena, mark);
		return -1;
	}

	SECItem encoded = { 0, };
	if (SEC_ASN1EncodeItem(cms->arena, &encoded, &sd, SignedDataTemplate)
			== NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cmsreterr(-1, cms, "could not encode SignedData");
	}

	ContentInfo sdw;
	memset(&sdw, '\0', sizeof (sdw));

	SECOidData *oid = SECOID_FindOIDByTag(SEC_OID_PKCS7_SIGNED_DATA);

	memcpy(&sdw.contentType, &oid->oid, sizeof (sdw.contentType));
	memcpy(&sdw.content, &encoded, sizeof (sdw.content));

	SECItem wrapper = { 0, };
	if (SEC_ASN1EncodeItem(cms->arena, &wrapper, &sdw,
			ContentInfoTemplate) == NULL) {
		save_port_err() {
			PORT_ArenaRelease(cms->arena, mark);
		}
		cmsreterr(-1, cms, "could not encode SignedData");
	}

	memcpy(sdp, &wrapper, sizeof(*sdp));
	PORT_ArenaUnmark(cms->arena, mark);
	return 0;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/signed_data.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * signed_data.h - types and decls to implement the authenticode
 *                 signed_data structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef SIGNED_DATA_H
#define SIGNED_DATA_H 1

extern int generate_spc_signed_data(cms_context *cms, SECItem *sdp);
extern int generate_authvar_signed_data(cms_context *cms, SECItem *sdp);

#endif /* SIGNED_DATA_H */

```

`src/signer_info.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * signer_info.c - implement the authenticode signer_info structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "pesign.h"

#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include <prerror.h>
#include <cms.h>
#include <cryptohi.h>
#include <keyhi.h>
#include <pk11pub.h>

SEC_ASN1Template AttributeTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (Attribute)
	},
	{
	.kind = SEC_ASN1_OBJECT_ID,
	.offset = offsetof(Attribute, attrType),
	.sub = &SEC_ObjectIDTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_SET_OF,
	.offset = offsetof(Attribute, attrValues),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem **)
	},
	{ 0, }
};

SEC_ASN1Template AttributeSetTemplate[] = {
	{
	.kind = SEC_ASN1_SET_OF,
	.offset = 0,
	.sub = AttributeTemplate,
	.size = 0
	},
};

SEC_ASN1Template SignedAttributesTemplate[] = {
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0,
	.offset = 0,
	.sub = &AttributeSetTemplate,
	.size = 0
	}
};

int
generate_signed_attributes(cms_context *cms, SECItem *sattrs)
{
	Attribute *attrs[5];
	memset(attrs, '\0', sizeof (attrs));

	SECItem encoded;
	SECOidTag tag;
	SECOidData *oid;

	/* build the first attribute, which says we have no S/MIME
	 * capabilities whatsoever */
	attrs[0] = PORT_ArenaZAlloc(cms->arena, sizeof (Attribute));
	if (!attrs[0])
		goto err;

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS9_SMIME_CAPABILITIES);
	attrs[0]->attrType = oid->oid;

	SECItem *smime_caps[2] = { NULL, NULL};
	if (generate_empty_sequence(cms, &encoded) < 0)
		goto err;
	smime_caps[0] = SECITEM_ArenaDupItem(cms->arena, &encoded);
	attrs[0]->attrValues = smime_caps;

	/* build the second attribute, which says that this is
	 * a PKCS9 content blob thingy */
	attrs[1] = PORT_ArenaZAlloc(cms->arena, sizeof (Attribute));
	if (!attrs[1])
		goto err;

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS9_CONTENT_TYPE);
	attrs[1]->attrType = oid->oid;

	SECItem *content_types[2] = { NULL, NULL };
	tag = find_ms_oid_tag(SPC_INDIRECT_DATA_OBJID);
	if (tag == SEC_OID_UNKNOWN)
		goto err;
	if (generate_object_id(cms, &encoded, tag) < 0)
		goto err;
	content_types[0] = SECITEM_ArenaDupItem(cms->arena, &encoded);
	if (!content_types[0])
		goto err;
	attrs[1]->attrValues = content_types;

	/* build the third attribute.  This is our signing time. */
	attrs[2] = PORT_ArenaZAlloc(cms->arena, sizeof (Attribute));
	if (!attrs[2])
		goto err;

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS9_SIGNING_TIME);
	attrs[2]->attrType = oid->oid;

	SECItem *signing_time[2] = { NULL, NULL };
	if (generate_time(cms, &encoded, time(NULL)) < 0)
		goto err;
	signing_time[0] = SECITEM_ArenaDupItem(cms->arena, &encoded);
	if (!signing_time[0])
		goto err;
	attrs[2]->attrValues = signing_time;

	/* build the fourth attribute, which is our PKCS9 message
	 * digest (which is a SHA-whatever selected and generated elsewhere */
	attrs[3] = PORT_ArenaZAlloc(cms->arena, sizeof (Attribute));
	if (!attrs[3])
		goto err;

	oid = SECOID_FindOIDByTag(SEC_OID_PKCS9_MESSAGE_DIGEST);
	attrs[3]->attrType = oid->oid;

	SECItem *digest_values[2] = { NULL, NULL };
	if (generate_octet_string(cms, &encoded, cms->ci_digest) < 0)
		goto err;
	digest_values[0] = SECITEM_ArenaDupItem(cms->arena, &encoded);
	if (!digest_values[0])
		goto err;
	attrs[3]->attrValues = digest_values;

	Attribute **attrtmp = attrs;
	if (SEC_ASN1EncodeItem(cms->arena, sattrs, &attrtmp,
				AttributeSetTemplate) == NULL)
		goto err;
	return 0;
err:
	return -1;
}

static int
sign_blob(cms_context *cms, SECItem *sigitem, SECItem *sign_content)
{
	sign_content = SECITEM_ArenaDupItem(cms->arena, sign_content);
	if (!sign_content)
		return -1;

	if (content_is_empty(sign_content->data, sign_content->len)) {
		cms->log(cms, LOG_ERR, "not signing empty digest");
		return -1;
	}

	SECOidData *oid = SECOID_FindOIDByTag(digest_get_signature_oid(cms));
	if (!oid)
		goto err;

	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
	SECKEYPrivateKey *privkey = PK11_FindKeyByAnyCert(cms->cert, cms);
	if (!privkey) {
		cms->log(cms, LOG_ERR, "could not get private key: %s",
			PORT_ErrorToString(PORT_GetError()));
		goto err;
	}

	SECItem *signature, tmp;
	memset (&tmp, '\0', sizeof (tmp));

	SECStatus status;
	status = SEC_SignData(&tmp, sign_content->data, sign_content->len,
			privkey, oid->offset);
	SECKEY_DestroyPrivateKey(privkey);
	privkey = NULL;

	if (status != SECSuccess) {
		cms->log(cms, LOG_ERR, "error signing data: %s",
			PORT_ErrorToString(PORT_GetError()));
		PORT_Free(tmp.data);
		return -1;
	}

	/* SEC_SignData awesomely allocates a SECItem and its contents for
	 * the signature, meaning they're not in our nss arena.  Fix it. */
	signature = SECITEM_AllocItem(cms->arena, NULL, tmp.len);
	if (!signature) {
		cms->log(cms, LOG_ERR, "error signing data: %s",
			PORT_ErrorToString(PORT_GetError()));
		return -1;
	}
	memcpy(signature->data, tmp.data, tmp.len);
	PORT_Free(tmp.data);

	if (status != SECSuccess) {
		cms->log(cms, LOG_ERR, "error signing data: %s",
			PORT_ErrorToString(PORT_GetError()));
		return -1;
	}
	memcpy(sigitem, signature, sizeof(*sigitem));

	//SECITEM_FreeItem(sign_content, PR_TRUE);
	return 0;
err:
	//SECITEM_FreeItem(sign_content, PR_TRUE);
	return -1;
}

static int
generate_unsigned_attributes(cms_context *cms, SECItem *uattrs)
{
	Attribute *attrs[1];
	memset(attrs, '\0', sizeof (attrs));

	Attribute **attrtmp = attrs;
	if (SEC_ASN1EncodeItem(cms->arena, uattrs, &attrtmp,
				AttributeSetTemplate) == NULL)
		goto err;
	return 0;
err:
	return -1;
}

SEC_ASN1Template IssuerAndSerialNumberTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = sizeof (IssuerAndSerialNumber)
	},
	{
	.kind = SEC_ASN1_ANY,
	.offset = offsetof(IssuerAndSerialNumber, issuer),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_INTEGER,
	.offset = offsetof(IssuerAndSerialNumber, serial),
	.sub = &SEC_IntegerTemplate,
	.size = sizeof (SECItem)
	},
	{ 0, }
};

SEC_ASN1Template SignerIdentifierTemplate[] = {
	/* we don't /really/ ever need signerType ==
	 * signerTypeSubjectKeyIdentifier */
#if 0
	{
	.kind = SEC_ASN1_CHOICE,
	.offset = offsetof(SignerIdentifier, signerType),
	.sub = NULL,
	.size = sizeof (SignerIdentifier)
	},
#endif
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(SignerIdentifier, signerValue.iasn),
	.sub = &IssuerAndSerialNumberTemplate,
	.size = signerTypeIssuerAndSerialNumber,
	},
#if 0
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_EXPLICIT |
		SEC_ASN1_CONSTRUCTED,
	.offset = offsetof(SignerIdentifier, signerValue.subjectKeyID),
	.sub = &SEC_OctetStringTemplate,
	.size = signerTypeSubjectKeyIdentifier,
	},
#endif
	{ 0, }
};

SEC_ASN1Template SpcSignerInfoTemplate[] = {
	{
	.kind = SEC_ASN1_SEQUENCE,
	.offset = 0,
	.sub = NULL,
	.size = 0,
	},
	{
	.kind = SEC_ASN1_INTEGER,
	.offset = offsetof(SpcSignerInfo, CMSVersion),
	.sub = &SEC_IntegerTemplate,
	.size = sizeof (SECItem),
	},
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(SpcSignerInfo, sid),
	.sub = &SignerIdentifierTemplate,
	.size = sizeof (SignerIdentifier),
	},
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(SpcSignerInfo, digestAlgorithm),
	.sub = &SECOID_AlgorithmIDTemplate,
	.size = sizeof (SECAlgorithmID)
	},
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
		SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_OPTIONAL,
	.offset = offsetof(SpcSignerInfo, signedAttrs),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_INLINE,
	.offset = offsetof(SpcSignerInfo, signatureAlgorithm),
	.sub = &SECOID_AlgorithmIDTemplate,
	.size = sizeof (SECItem)
	},
	{
	.kind = SEC_ASN1_OCTET_STRING,
	.offset = offsetof(SpcSignerInfo, signature),
	.sub = &SEC_OctetStringTemplate,
	.size = sizeof (SECItem)
	},
#if 0
	{
	.kind = SEC_ASN1_CONTEXT_SPECIFIC | 1 |
		SEC_ASN1_CONSTRUCTED |
		SEC_ASN1_OPTIONAL |
		SEC_ASN1_EXPLICIT,
	.offset = offsetof(SpcSignerInfo, unsignedAttrs),
	.sub = &SEC_AnyTemplate,
	.size = sizeof (SECItem)
	},
#endif
	{ 0, }
};

int
generate_spc_signer_info(cms_context *cms, SpcSignerInfo *sip)
{
	if (!sip)
		return -1;

	SpcSignerInfo si;
	memset(&si, '\0', sizeof (si));

	if (SEC_ASN1EncodeInteger(cms->arena, &si.CMSVersion, 1) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode CMSVersion: %s",
			PORT_ErrorToString(PORT_GetError()));
		goto err;
	}

	si.sid.signerType = signerTypeIssuerAndSerialNumber;
	si.sid.signerValue.iasn.issuer = cms->cert->derIssuer;
	si.sid.signerValue.iasn.serial = cms->cert->serialNumber;

	if (generate_algorithm_id(cms, &si.digestAlgorithm,
			digest_get_digest_oid(cms)) < 0)
		goto err;


	if (cms->raw_signature) {
		memcpy(&si.signedAttrs, cms->raw_signed_attrs,
			sizeof (si.signedAttrs));
		memcpy(&si.signature, cms->raw_signature, sizeof(si.signature));
	} else {
		if (generate_signed_attributes(cms, &si.signedAttrs) < 0)
			goto err;

		if (sign_blob(cms, &si.signature, &si.signedAttrs) < 0)
			goto err;
	}

	si.signedAttrs.data[0] = SEC_ASN1_CONTEXT_SPECIFIC | 0 |
				SEC_ASN1_CONSTRUCTED;

	if (generate_algorithm_id(cms, &si.signatureAlgorithm,
				digest_get_encryption_oid(cms)) < 0)
		goto err;

	if (generate_unsigned_attributes(cms, &si.unsignedAttrs) < 0)
		goto err;

	memcpy(sip, &si, sizeof(si));
	return 0;
err:
	return -1;
}

int
generate_authvar_signer_info(cms_context *cms, SpcSignerInfo *sip)
{
	SpcSignerInfo si;
	SECItem buf;

	if (!sip)
		return -1;

	memset(&si, '\0', sizeof (si));

	if (SEC_ASN1EncodeInteger(cms->arena, &si.CMSVersion, 1) == NULL) {
		cms->log(cms, LOG_ERR, "could not encode CMSVersion: %s",
			PORT_ErrorToString(PORT_GetError()));
		goto err;
	}

	si.sid.signerType = signerTypeIssuerAndSerialNumber;
	si.sid.signerValue.iasn.issuer = cms->cert->derIssuer;
	si.sid.signerValue.iasn.serial = cms->cert->serialNumber;

	if (generate_algorithm_id(cms, &si.digestAlgorithm,
			digest_get_digest_oid(cms)) < 0)
		goto err;

	si.signedAttrs.len = 0;
	si.signedAttrs.data = NULL;

	buf.len = cms->authbuf_len;
	buf.data = cms->authbuf;
	if (sign_blob(cms, &si.signature, &buf) < 0)
		goto err;

	if (generate_algorithm_id(cms, &si.signatureAlgorithm,
				digest_get_encryption_oid(cms)) < 0)
		goto err;

	si.unsignedAttrs.len = 0;
	si.unsignedAttrs.data = NULL;

	memcpy(sip, &si, sizeof(si));
	return 0;
err:
	return -1;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/signer_info.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * signer_info.h - types and decls to implement the authenticode
 *                 signer_info structure
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef SIGNER_INFO
#define SIGNER_INFO 1

typedef struct {
	SECItem issuer;
	SECItem serial;
} IssuerAndSerialNumber;
extern SEC_ASN1Template IssuerAndSerialNumberTemplate[];

enum SignerType {
	signerTypeIssuerAndSerialNumber = 1,
	signerTypeSubjectKeyIdentifier = 2,
};

typedef struct {
	int signerType; /* actually the enum above, but enum ABI ew. */
	struct {
		IssuerAndSerialNumber iasn;
		SECItem subjectKeyID;
	} signerValue;
} SignerIdentifier;
extern SEC_ASN1Template SignerIdentifierTemplate[];

typedef struct {
	SECItem attrType;
	SECItem **attrValues;
} Attribute;
extern SEC_ASN1Template AttributeTemplate[];

typedef struct {
	SECItem attributes;
} AttributeSet;
extern SEC_ASN1Template AttributeSetTemplate[];

typedef struct {
	SECItem CMSVersion;
	SignerIdentifier sid;
	SECAlgorithmID digestAlgorithm;
	SECItem signedAttrs;
	SECAlgorithmID signatureAlgorithm;
	SECItem signature;
	SECItem unsignedAttrs;
} SpcSignerInfo;
extern SEC_ASN1Template SpcSignerInfoTemplate[];

extern int generate_signed_attributes(cms_context *cms, SECItem *sattrs);
extern int generate_spc_signer_info(cms_context *cms, SpcSignerInfo *sip);
extern int generate_authvar_signer_info(cms_context *cms, SpcSignerInfo *sip);

#endif /* SIGNER_INFO */

```

`src/text.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * text.c - helpers for text strings
 * Copyright Peter Jones <pjones@redhat.com>
 */
#include "compiler.h"
#include "text.h"

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

const char * const eol_chars = "\f\r\v\n";
// static const char * const whitespace_chars = "\t ";
const char * const whitespace_and_eol_chars = "\t \f\r\v\n";

// static const char * const binary_digits = "01";
static const char * const octal_digits = "01234567";
// static const char * const decimal_digits = "0123456789";
static const char * const hex_digits = "0123456789abcdefABCDEF";

static const char * const cnt_nl = "\\\n";
static const char * const cnt_lfnl = "\\\r\n";
static const char * const cnt_lf = "\\\r";
static const char * const cnt_ff = "\\\f";
static const char * const cnt_vt = "\\\v";

static const char * const line_continuation_strs[] = {
	cnt_nl,
	cnt_lfnl,
	cnt_lf,
	cnt_ff,
	cnt_vt,
	NULL
};

/*
 * unbreak_line_coninutations: remove all line continuations
 * @buf:	the buffer to operate on
 * @bufsz:	the size of the buffer
 */
void
unbreak_line_continuations(char *buf, size_t bufsz)
{
	char *to = buf;
	bool found = true;

	while (found) {
		found = false;

		for (unsigned int i = 0; line_continuation_strs[i]; i++) {
			size_t cntsz = strlen(line_continuation_strs[i]);
			char *needle = strstr(to, line_continuation_strs[i]);
			char *from;
			size_t sz;

			if (!needle)
				continue;

			found = true;
			from = needle + cntsz;
			sz = bufsz - (from - buf);

			to = needle;
			memmove(to, from, sz);
		}
	}
}

/*
 * stresccspn:	calculate the number of bytes which do not contain escape
 *		sequences.
 * @buf:	the buffer to search
 *
 * Returns the size of the initial segment of buf which does not contain
 * any escape sequences.  If no escape sequence is found, buf[return] will
 * point to the NUL terminator.
 */
size_t stresccspn(const char * const buf)
{
	size_t span = strcspn(buf, "\\");

	return span;
}

/*
 * escape_func: parse the value for one single escape character
 * @delimiter:	the delimiter as to which kind of escape sequence this is
 *		(i.e. 'x' for \x1abc)
 * @buf:	the buffer being parsed
 * @val:	the parsed value is placed in val
 * @valsz:	how many bytes of val are meaningful
 *
 * Returns the number of bytes of buf to advance to skip the escape
 * sequence, including the delimiter character but not the initial escape
 * character.  If the initial segment of buf is not an escape sequence,
 * *valsz and the return value will both be 0.
 */
typedef size_t (*escape_func)(uint32_t delimiter, const char * const buf,
			      char val[9], size_t *valsz);

static size_t
simple_escape_sequence(uint32_t delimiter, const char * const buf UNUSED,
		       char val[9], size_t *valsz)
{
	val[0] = delimiter & 0xffu;
	*valsz = 1;

	return 1;
}

static size_t
digits_escape_sequence(uint32_t delimiter, const char * const buf,
		       char val[2], size_t *valsz)
{
	size_t span;
	unsigned long long ul;
	char tmpbuf[4] = { 0, };
	int base;

	if (delimiter == 'x') {
		span = strspn(buf, hex_digits);
		base = 16;
		if (span > 2)
			span = 2;
		strncpy(tmpbuf, buf, span);
	} else {
		span = strspn(buf, octal_digits);
		base = 8;
		if (span > 2)
			span = 2;
		tmpbuf[0] = delimiter & 0xffu;
		strncpy(&tmpbuf[1], buf, span);
		span += 1;
	}
	if (span == 0) {
		val[0] = delimiter & 0xffu;
		*valsz = 1;
		return 1;
	}

	tmpbuf[span+1] = '\0';
	ul = strtoul(tmpbuf, NULL, base);

	val[0] = ul & 0xffu;
	*valsz = 1;

	return span;
}

struct escape_handler {
	const char * const escapes;
	escape_func func;
};
static struct escape_handler escape_handlers[] = {
	{.escapes = " \"\'\?\a\b\f\n\r\t\v\\",
	 .func = simple_escape_sequence },
	{.escapes = "x01234567",
	 .func = digits_escape_sequence },
	{.escapes = 0,
	 .func = NULL }
};

/*
 * parse_escape: parses one escape string
 * @buf:	the buffer being parsed
 * @val:	the parsed value is placed in val
 * @valsz:	how many bytes of val are meaningful
 *
 * Returns the number of bytes of buf to advance to skip the escape
 * sequence.  If the initial segment of buf is not an escape sequence,
 * *valsz and the return value will both be 0.
 */
static size_t
parse_escape(const char * const buf, char val[9], size_t *valsz)
{
	struct escape_handler *eh = NULL;

	if (buf[0] != '\\')
		return 0;

	for(size_t i = 0; escape_handlers[i].escapes != 0; i++) {
		char *match;
		eh = &escape_handlers[i];

		match = strchrnul(eh->escapes, buf[1]);
		if (match[0] != buf[1])
			continue;
	}
	if (eh && eh->func)
		return eh->func(buf[1], &buf[2], val, valsz);
	return 0;
}

/*
 * strescspn:	calculate the size of an escape sequence.
 * @buf:	a NUL-terminated utf-8 buffer.
 *
 * returns the number of bytes which are part of a single escape sequence.
 * If no escape sequnce can be parsed, returns 0.
 */
size_t strescspn(const char * const buf)
{
	size_t advance = 0, valsz = 0;
	char val[9] = { 0, };

	if (!buf[0] || buf[0] != '\\')
		return 0;

	advance = parse_escape(&buf[1], val, &valsz);
	if (advance == 0) {
		/*
		 * If we come to illegal escape values like "\\xzz" then
		 * we just use the delimiter character (in this case 'x'),
		 * so the span here is 2.
		 */
		return 2;
	}
	return valsz + 1;
}

/*
 * resolve_escapes: parse all instances of escape sequences in buf
 * @buf:	the buffer to operate on
 *
 * Returns the size of buf once escape sequnces have been replaced.
 */
size_t
resolve_escapes(char *buf)
{
	size_t to = 0;
	for (size_t from = 0; buf[from]; from++) {
		size_t advance, valsz = 0;
		char val[9];
		if (buf[from] != '\\') {
			buf[to++] = buf[from];
			continue;
		}

		advance = parse_escape(&buf[from], val, &valsz);
		if (advance == 0) {
			/*
			 * If we come to illegal escape values like "\\xzz"
			 * then just move the '\\' out of the way...
			 */
			buf[to++] = buf[++from];
			continue;
		}

		for (size_t j = 0; j < valsz; j++)
			buf[to+j] = val[j];
		to += advance + 1;
	}
	buf[to++] = '\0';
	return to;
}

// vim:fenc=utf-8:tw=75:noet

```

`src/text.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * text.c - helpers for text strings
 * Copyright Peter Jones <pjones@redhat.com>
 */
#ifndef TEXT_H_
#define TEXT_H_

#include <unistd.h>

/*
 * Characters that can be considered whitespace or end-of-line markers.
 */
extern const char * const eol_chars;
extern const char * const whitespace_and_eol_chars;

/*
 * unbreak_line_coninutations: remove all line continuations
 * @buf:	the buffer to operate on
 * @bufsz:	the size of the buffer
 */
extern void unbreak_line_continuations(char *buf, size_t bufsz);

/*
 * strescspn:	calculate the size of an escape sequence.
 * @buf:	a NUL-terminated utf-8 buffer.
 *
 * returns the number of bytes which are part of a single escape sequence.
 * If no escape sequnce can be parsed, returns 0.
 */
extern size_t strescspn(const char * const buf);

/*
 * stresccspn:	calculate the number of bytes which do not contain escape
 *		sequences.
 * @buf:	the buffer to search
 *
 * Returns the size of the initial segment of buf which does not contain
 * any escape sequences.  If no escape sequence is found, buf[return] will
 * point to the NUL terminator.
 */
extern size_t stresccspn(const char * const buf);

/*
 * resolve_escapes: parse all instances of escape sequences in buf
 * @buf:	the buffer to operate on
 *
 * Returns the size of buf once escape sequnces have been replaced.
 */
extern size_t resolve_escapes(char *buf);

#endif /* !TEXT_H_ */
// vim:fenc=utf-8:tw=75:noet

```

`src/tmpfiles.conf.in`:

```in
D @@RUNDIR@@pesign 0770 pesign pesign -

```

`src/ucs2.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * ucs2.c - helpers for 16-bit unicode chatacters
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "fix_coverity.h"

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "ucs2.h"

size_t ucs2_strlen(const uint16_t *s)
{
	size_t i;
	for (i = 0; s[i] != L'\0'; i++)
		;
	return i;
}

uint16_t *ucs2_strdup(const uint16_t *s)
{
	size_t len = ucs2_strlen(s);
	uint16_t *ret = calloc(len, sizeof (*ret));

	if (!ret)
		return NULL;

	memcpy(ret, s, len * sizeof (*ret));
	return ret;
}

extern uint16_t *ascii_to_ucs2(const char *s)
{
	uint16_t *ret = NULL;
	size_t size = strlen(s) + 1;

	ret = calloc(2, size);
	if (!ret)
		return NULL;
	for (unsigned int i = 0; i < size; i++)
		ret[i] = s[i];
	return ret;
}

```

`src/ucs2.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * ucs2.h - helpers for 16-bit unicode
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef UCS2_H
#define UCS2_H 1

extern size_t ucs2_strlen(const uint16_t *s);
extern uint16_t *ucs2_strdup(const uint16_t *s);
extern uint16_t *ascii_to_ucs2(const char *s);

#endif /* UCS2_H */

```

`src/util.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * util.c - utility functions and data that can't go in a header
 * Copyright Peter Jones <pjones@redhat.com>
 */

#include <unistd.h>

#include "compiler.h"
#include "util.h"

size_t HIDDEN page_size;

void CONSTRUCTOR
set_up_global_constants(void)
{
	page_size = sysconf(_SC_PAGE_SIZE);
}

// vim:fenc=utf-8:tw=75:noet

```

`src/util.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * util.h - a den of scum and miscellany
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_UTIL_H
#define PESIGN_UTIL_H 1

#include <err.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include <libdpe/pe.h>

#include "compiler.h"
#include "list.h"

#ifndef RUNDIR
#define RUNDIR "/run"
#endif

extern size_t HIDDEN page_size;

#define xfree(x) ({ if (x) { free(x); x = NULL; } })
#define xclose(fd) ({ if ((fd) >= 0) { close(fd); (fd) = -1; } })
#define xopen(path, flags, args...) ({ int fd_ = open(path, flags, ## args); if (fd_ < 0) liberr(1, "Could not open file \"%s\"", arg); fd_; })
#define xrealloc(o, s) ({ void *o_ = realloc(o, s); if (!o_) liberr(1, "Could not allocate %zd bytes", (size_t)s); o_; })
#define xcalloc(n, s) ({ void *p_ = calloc(n, s); if (!p_) liberr(1, "Could not allocate %lu entries of %lu bytes", (unsigned long)n, (unsigned long)s); p_; })
#define xstrdup(s) ({ void *p_ = strdup(s); if (!p_) liberr(1, "Could not allocate memory"); p_; })
#define xpfstat(path, fd, sb) ({ int rc_ = fstat(fd, sb); if (rc_ < 0) liberr(1, "Could not stat \"%s\"", path); })

#define saved_errno_0_ CONCATENATE(CONCATENATE(error_,__LINE__),_0_)
#define saved_errno_1_ CONCATENATE(CONCATENATE(error_,__LINE__),_1_)
#define save_pe_errno() \
	for (int saved_errno_0_ = 0, saved_errno_1_ = pe_errno(); saved_errno_0_ < 1; saved_errno_0_++, __libdpe_seterrno(saved_errno_1_))

#define conderr(cond, val, fmt, args...) ({				\
		if (cond)						\
			err(val, fmt, ## args);				\
	})
#define conderrx(cond, val, fmt, args...) ({				\
		if (cond)						\
			errx(val, fmt, ## args);			\
	})

#define condwarn(cond, fmt, args...) ({					\
		if (cond)						\
			warn(fmt, ## args);				\
	})
#define condwarnx(cond, fmt, args...) ({				\
		if (cond)						\
			warnx(fmt, ## args);				\
	})

#define nsserr(rv, fmt, args...) ({					\
		errx((rv), "%s:%s:%d: " fmt ": %s",			\
			__FILE__, __func__, __LINE__ - 2, ##args,	\
			PORT_ErrorToString(PORT_GetError()));		\
	})
#define condnsserr(cond, rv, fmt, args...) ({				\
		if ((cond))						\
			nsserr(rv, fmt, ## args);			\
	})
#define nssreterr(rv, fmt, args...) ({					\
		fprintf(stderr, "%s:%s:%d: " fmt ": %s\n",		\
			__FILE__, __func__, __LINE__ - 2, ##args,	\
			PORT_ErrorToString(PORT_GetError()));		\
		return rv;						\
	})
#define condnssreterr(cond, rv, fmt, args...) ({			\
		if ((cond))						\
			nssreterr(rv, fmt, ## args);			\
	})
#define liberr(rv, fmt, args...) ({					\
		err((rv), "%s:%s:%d: " fmt,				\
			__FILE__, __func__, __LINE__ - 2, ##args);	\
	})
#define libreterr(rv, fmt, args...) ({					\
		fprintf(stderr, "%s:%s:%d: " fmt ": %m\n",		\
			__FILE__, __func__, __LINE__ - 2, ##args);	\
		return rv;						\
	})
#define peerr(rv, fmt, args...) ({					\
		errx((rv), "%s:%s:%d: " fmt ": %s",			\
			__FILE__, __func__, __LINE__ - 2, ##args,	\
			pe_errmsg(pe_errno()));				\
	})
#define pereterr(rv, fmt, args...) ({					\
		fprintf(stderr, "%s:%s:%d: " fmt ": %s\n",		\
			__FILE__, __func__, __LINE__ - 2, ##args,	\
			pe_errmsg(pe_errno()));				\
		return rv;						\
	})

static inline int UNUSED
read_file(int fd, char **bufp, size_t *lenptr) {
    size_t alloced = 0, size = 0;
    ssize_t i = 0;
    char * buf = NULL;

    do {
	size += i;
	if ((size + (page_size >> 2)) > alloced) {
	    alloced += page_size;
	    buf = xrealloc(buf, ALIGN_UP(alloced + 1, page_size));
	}
    } while ((i = read(fd, buf + size, page_size >> 2)) > 0);

    if (i < 0) {
        free(buf);
	return -1;
    }

    *bufp = buf;
    *lenptr = size;

    return 0;
}

static inline int UNUSED
write_file(int fd, const void *data, size_t len)
{
	int rc;
	size_t written = 0;

	while (written < len) {
		rc = write(fd, ((unsigned char *) data) + written,
			   len - written);
		if (rc < 0) {
			if (errno == EINTR)
				continue;
			return rc;
		}
		written += rc;
	}

	return 0;
}

static int
compare_shdrs (const void *a, const void *b)
{
	const struct section_header *shdra = (const struct section_header *)a;
	const struct section_header *shdrb = (const struct section_header *)b;
	int rc;

	if (shdra->data_addr > shdrb->data_addr)
		return 1;
	if (shdrb->data_addr > shdra->data_addr)
		return -1;

	if (shdra->virtual_address > shdrb->virtual_address)
		return 1;
	if (shdrb->virtual_address > shdra->virtual_address)
		return -1;

	rc = strcmp(shdra->name, shdrb->name);
	if (rc != 0)
		return rc;

	if (shdra->virtual_size > shdrb->virtual_size)
		return 1;
	if (shdrb->virtual_size > shdra->virtual_size)
		return -1;

	if (shdra->raw_data_size > shdrb->raw_data_size)
		return 1;
	if (shdrb->raw_data_size > shdra->raw_data_size)
		return -1;

	return 0;
}

static void UNUSED
sort_shdrs (struct section_header *shdrs, size_t sections)
{
	qsort(shdrs, sections, sizeof(*shdrs), compare_shdrs);
}

static void UNUSED
free_poison(void  *addrv, ssize_t len)
{
	uint8_t *addr = addrv;
	char poison_pills[] = "\xa5\x5a";
	for (int x = 0; x < len; x++)
		addr[x] = poison_pills[x % 2];
}

static int UNUSED
content_is_empty(uint8_t *data, ssize_t len)
{
	if (len < 1)
		return 1;

	for (int i = 0; i < len; i++)
		if (data[i] != 0)
			return 0;
	return 1;
}

#define define_input_file(fname, name, descr)                           \
        static void                                                     \
        CAT3(open_, fname, _input)(pesign_context *ctx)                 \
        {                                                               \
                conderrx(!ctx->name, 1,                                 \
                         "No input file specified for %s",              \
                         descr);                                        \
                ctx->CAT(name, fd) =                                    \
                        open(ctx->name, O_RDONLY|O_CLOEXEC);            \
                conderr(ctx->CAT(name, fd) < 0, 1,                      \
                        "Error opening %s file \"%s\" for input",       \
                        descr, ctx->name);                              \
        }                                                               \
        static void                                                     \
        CAT3(close_, fname, _input)(pesign_context *ctx)                \
        {                                                               \
                close(ctx->CAT(name, fd));                              \
                ctx->CAT(name, fd) = -1;                                \
        }

#define define_output_file(fname, name, descr)                          \
        static void                                                     \
        CAT3(open_, fname, _output)(pesign_context *ctx)                \
        {                                                               \
                conderrx(!ctx->name, 1,                                 \
                         "No output file specified for %s.",            \
                         descr);                                        \
                                                                        \
                if (access(ctx->name, F_OK) == 0 && ctx->force == 0)    \
                        errx(1,                                         \
                             "\"%s\" exists and --force was not given.",\
                             ctx->name);                                \
                                                                        \
                ctx->CAT(name, fd) =                                    \
                        open(ctx->name,                                 \
                             O_RDWR|O_CREAT|O_TRUNC|O_CLOEXEC,          \
                             ctx->outmode);                             \
                conderr(ctx->CAT(name, fd) < 0, 1,                      \
                        "Error opening %s file \"%s\" for output",      \
                        descr, ctx->name);                              \
        }                                                               \
        static void                                                     \
        CAT3(close_, fname, _output)(pesign_context *ctx)               \
        {                                                               \
                close(ctx->CAT(name,fd));                               \
                ctx->CAT(name,fd) = -1;                                 \
        }

static inline void
proxy_fd_mode(int fd, char *infile, mode_t *outmode, size_t *inlength)
{
	struct stat statbuf;
	int rc;

	rc = fstat(fd, &statbuf);
	conderr(rc < 0, 1, "Could not fstat \"%s\"", infile);
	if (outmode)
		*outmode = statbuf.st_mode;
	if (inlength)
		*inlength = statbuf.st_size;
}

extern long verbosity(void);

#define dbgprintf_(tv, file, func, line, fmt, args...) ({	\
		struct timeval tv;				\
		gettimeofday(&tv, NULL);			\
		warnx("%ld.%lu %s:%s():%d: " fmt,		\
		      tv.tv_sec, tv.tv_usec,			\
		      file, func, line, ##args);		\
	})
#if defined(PESIGN_DEBUG)
#define dbgprintf(fmt, args...)					\
	dbgprintf_(CAT(CAT(CAT(tv_,__COUNTER__),__LINE__),_),	\
		   __FILE__, __func__, __LINE__ - 2, fmt, ##args)
#else
#define dbgprintf(fmt, args...) ({						\
		if (verbosity() > 1)						\
			dbgprintf_(CAT(CAT(CAT(tv_,__COUNTER__),__LINE__),_),	\
				 __FILE__, __func__, __LINE__ - 3,		\
				 fmt, ##args);					\
		0;								\
	})
#endif
#define ingress() dbgprintf("ingress");
#define egress() dbgprintf("egress");

#endif /* PESIGN_UTIL_H */
// vim:fenc=utf-8:tw=75:noet

```

`src/valgrind.supp`:

```supp
{
   <insert_a_suppression_name_here>
   Memcheck:Param
   socketcall.sendto(msg)
   fun:send
   fun:MessageSend
   fun:MessageSendWithHeader
   fun:SCardConnect
   fun:CKYCardConnection_Connect
   fun:_ZN4Slot14connectToTokenEv
   fun:_ZN4Slot17refreshTokenStateEv
   fun:_ZN4Slot14isTokenPresentEv
   fun:_ZN8SlotList11getSlotListEhPmS0_
   fun:C_GetSlotList
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
}
{
   <insert_a_suppression_name_here>
   Memcheck:Cond
   fun:SCardStatus
   fun:CKYCardConnection_GetStatus
   fun:_ZN4Slot23cardStateMayHaveChangedEv
   fun:_ZN4Slot17refreshTokenStateEv
   fun:_ZN4Slot14isTokenPresentEv
   fun:_ZN8SlotList11getSlotListEhPmS0_
   fun:C_GetSlotList
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:NSSRWLock_New_Util
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PORT_Alloc_Util
   fun:PK11_ReadMechanismList
   fun:PK11_InitToken
   fun:PK11_InitSlot
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_MonitorLock_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:NSSRWLock_New_Util
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PR_NewCondVar
   fun:NSSRWLock_New_Util
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PR_NewCondVar
   fun:NSSRWLock_New_Util
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewMonitor
   fun:PKIX_PL_MonitorLock_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PORT_ZAlloc_Util
   fun:PORT_NewArena_Util
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:error_get_my_stack
   fun:nss_ClearErrorStack
   fun:NSSArena_Create
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:NSSArena_Create
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:nssList_Create
   fun:nssList_Clone
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:NSSArena_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssTokenObjectCache_Create
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PORT_ZAlloc_Util
   fun:PORT_NewArena_Util
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PORT_NewArena_Util
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PK11_NewSlotInfo
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PK11_NewSlotInfo
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:NSSArena_Create
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:NSSRWLock_New_Util
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssList_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssTokenObjectCache_Create
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:nssList_Create
   fun:nssList_Clone
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssList_Create
   fun:nssList_Clone
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:NSSArena_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssCertificateStore_Create
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Mutex_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PKIX_PL_Object_Alloc
   fun:PKIX_PL_MonitorLock_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewMonitor
   fun:PKIX_PL_MonitorLock_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:nssSlot_CreateFromPK11SlotInfo
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PKIX_PL_Malloc
   fun:pkix_pl_PrimHashTable_Create
   fun:PKIX_PL_HashTable_Create
   fun:PKIX_Initialize
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateCertificate
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateItem
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nss_arena_hash_alloc_table
   fun:PL_NewHashTable
   fun:nssHash_Create
   fun:nssHash_CreateString
   fun:nssTrustDomain_InitializeCache
   fun:NSSTrustDomain_Create
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:PORT_NewArena_Util
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssArena_Create
   fun:nssSlot_CreateFromPK11SlotInfo
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:PR_NewLock
   fun:nssSlot_CreateFromPK11SlotInfo
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:PORT_ArenaAlloc_Util
   fun:secmod_NewModule
   fun:SECMOD_CreateModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PORT_Alloc_Util
   fun:PK11_NewSlotInfo
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:PORT_ArenaAlloc_Util
   fun:legacy_ReadSecmodDB
   fun:sftkdb_ReadSecmodDB
   fun:NSC_ModuleDBFunc
   fun:SECMOD_GetModuleSpecList
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:PORT_ArenaAlloc_Util
   fun:PORT_ArenaZAlloc_Util
   fun:nsslowcert_GetVersionNumber
   fun:nsslowcert_OpenCertDB
   fun:legacy_Open
   fun:sftk_DBInit
   fun:SFTK_SlotReInit
   fun:SFTK_SlotInit
   fun:nsc_CommonInitialize
   fun:NSC_Initialize
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:PORT_ArenaAlloc_Util
   fun:nsslowcert_GetVersionNumber
   fun:nsslowcert_OpenCertDB
   fun:legacy_Open
   fun:sftk_DBInit
   fun:SFTK_SlotReInit
   fun:SFTK_SlotInit
   fun:nsc_CommonInitialize
   fun:NSC_Initialize
   fun:secmod_ModuleInit
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:PORT_ArenaAlloc_Util
   fun:PORT_ArenaZAlloc_Util
   fun:SEC_ASN1EncoderStart_Util
   fun:SEC_ASN1Encode_Util
   fun:SEC_ASN1EncodeItem_Util
   fun:lg_GetMetaData
   fun:sftkdb_HasPasswordSet
   fun:SFTK_SlotReInit
   fun:SFTK_SlotInit
   fun:nsc_CommonInitialize
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:nss_zalloc_arena_locked
   fun:nss_ZAlloc
   fun:nssList_Create
   fun:nssList_Clone
   fun:nssList_CreateIterator
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:nss_zalloc_arena_locked
   fun:nss_ZAlloc
   fun:nssCryptoContext_Create
   fun:nssTrustDomain_CreateCryptoContext
   fun:NSSTrustDomain_CreateCryptoContext
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:nss_zalloc_arena_locked
   fun:nss_ZAlloc
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   fun:PL_ArenaAllocate
   fun:nss_zalloc_arena_locked
   fun:nss_ZAlloc
   fun:nssSlot_CreateFromPK11SlotInfo
   fun:nssToken_CreateFromPK11SlotInfo
   fun:STAN_InitTokenForSlotInfo
   fun:STAN_LoadDefaultNSS3TrustDomain
   fun:nss_Init
   fun:NSS_Init
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:calloc
   fun:nss_ZAlloc
   fun:nssArena_Create
   fun:nssList_Create
   fun:nssTrustDomain_UpdateCachedTokenCerts
   fun:PK11_DoPassword
   fun:PK11_Authenticate
   fun:unlock_nss_token
   fun:handle_unlock_token
   fun:handle_event
   fun:handle_events
   fun:daemonize
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:_Znwm
   obj:*
   fun:secmod_ModuleInit
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:daemonize
   fun:main
}
{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   obj:*
   obj:*
   obj:*
   fun:secmod_ModuleInit
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_InitModules
   fun:nss_Init
   fun:NSS_Init
   fun:daemonize
}

{
   <insert_a_suppression_name_here>
   Memcheck:Leak
   fun:malloc
   obj:*
   obj:*
   obj:*
   obj:*
   obj:*
   obj:*
   fun:secmod_ModuleInit
   fun:secmod_LoadPKCS11Module
   fun:SECMOD_LoadModule
   fun:SECMOD_LoadModule
   fun:nss_Init
}

```

`src/varfile.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * varfile.c - implement storing variables in files
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "authvar.h"

struct variable_operation {
	uint8_t operation;
	efi_guid_t vendor_guid;
	uint32_t attributes;
	uint64_t name_size;
	uint64_t data_size;
	uint16_t *name;
	uint8_t *data;
};

struct variable_file {
	uint8_t magic[8]; /* always "EFIVARS" with a nul */
	uint16_t version;
	uint32_t num_vops;
	struct variable_operation **vops;
};

#define EFIVARS_MAGIC	"EFIVARS"
#define EFIVARS_VERSION	1

static int
vop_valid(struct variable_operation *vop)
{
	efi_guid_t empty_guid = {0,0,0,{0,0,0,0,0,0,0,0}};

	if (!memcmp(&empty_guid, &vop->vendor_guid, sizeof(empty_guid)))
not_ready:
		return 0;

	if (vop->name_size == 0)
		goto not_ready;

	if (vop->data_size == 0)
		goto not_ready;

	if (vop->attributes == 0)
		goto not_ready;

	if (vop->operation == APPEND &&
			!(vop->attributes & EFI_VARIABLE_APPEND_WRITE))
		goto not_ready;

	if (vop->operation != APPEND &&
			(vop->attributes & EFI_VARIABLE_APPEND_WRITE))
		goto not_ready;

	return 1;
}

#if 0
static int
is_ready(variable_file *vf)
{
	if (vf->num_vops == 0)
		return 0;

	for (int i; i < vf->num_vops; i++) {
		struct variable_operation *vop = vf->vops[i];

		if (!vop_valid(vop))
			return 0;

		if (!vop->data || !vop->name)
			return 0;

		if (vop->data[0] == L'\0')
			return 0;
	}
	return 1;
}
#endif

variable_file *
alloc_variable_file(void)
{
	variable_file *vf;

	vf = calloc(1, sizeof(*vf));
	memcpy(vf->magic, EFIVARS_MAGIC, sizeof(EFIVARS_MAGIC));
	vf->version = cpu_to_le16(EFIVARS_VERSION);
	vf->num_vops = 0;

	return 0;
}

int
add_variable_op(variable_file *vf, uint8_t operation, efi_guid_t guid,
	uint16_t *name, uint32_t attributes, uint64_t data_size, uint8_t *data)
{
	struct variable_operation *newvop = NULL, vop = {
		.operation = operation,
		.vendor_guid = guid,
		.attributes = attributes,
		.name_size = ucs2_strlen(name),
		.name = NULL,
		.data_size = data_size,
		.data = NULL,
	};

	if (!vop_valid(&vop))
		return -1;

	vop.name = ucs2_strdup(vop.name);
	if (!vop.name)
		return -1;

	vop.data = malloc(vop.data_size);
	if (!vop.data)
		goto err;

	newvop = malloc(sizeof (vop));
	if (!newvop)
		goto err;

	memcpy(newvop, &vop, sizeof (vop));

	struct variable_operation **vops = NULL;

	vops = realloc(vf->vops, (vf->num_vops + 1) * sizeof (newvop));
	if (!vops)
		goto err;

	vops[vf->num_vops] = newvop;
	vf->vops = vops;
	vf->num_vops++;

	return 0;
err:
	if (vop.name)
		free(vop.name);
	if (vop.data)
		free(vop.data);
	if (newvop)
		free(newvop);
	return -1;
}

int
realize_variable_file(variable_file *vf, void **data, size_t *len)
{
	return -1;
}

void
free_variable_file(variable_file *vf)
{
	for (int i = 0; i < vf->num_vops; i++) {
		struct variable_operation *vop = vf->vops[i];

		if (vop->name)
			free(vop->name);
		if (vop->data)
			free(vop->data);
		free(vop);

		vf->vops[i] = NULL;
	}
	if (vf->num_vops)
		free(vf->vops);
	free(vf);
}

```

`src/varfile.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * varfile.h - types and headers for helpers to store variables in files
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef VARFILE_H
#define VARFILE_H 1

enum {
	CREATE,
	APPEND,
	DELETE
};

typedef struct variable_file variable_file;

extern int add_variable_op(variable_file *vf, uint8_t operation,
	efi_guid_t guid, uint16_t *name, uint32_t attributes,
	uint64_t data_size, uint8_t *data);
extern variable_file *alloc_variable_file(void);
extern int realize_variable_file(variable_file *, void **data, size_t *len);
extern void free_variable_file(variable_file *vf);

#endif /* VARFILE_H */

```

`src/wincert.c`:

```c
// SPDX-License-Identifier: GPLv2
/*
 * wincert.c - implement the PE authenticode certification database
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#include "pesign.h"

typedef win_certificate_pkcs_signed_data_t cert_list_entry_t;

/*
 * gcc's leak checker simply cannot believe that this code does not leak the
 * allocation for data, either (bizarrely) on every iteration of the loop that
 * fills it or when generate_cert_list() returns, even though the trace it
 * gives you stops right before the call to free()
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wanalyzer-malloc-leak"
static int
generate_cert_list(SECItem **signatures, int num_signatures,
		   void **cert_list, size_t *cert_list_size)
{
	size_t cl_size = 0;
	for (int i = 0; i < num_signatures; i++) {
		cl_size += sizeof (win_certificate_header_t);
		cl_size += signatures[i]->len;
		cl_size += ALIGNMENT_PADDING(cl_size, 8);
	}

	uint8_t *data = calloc(cl_size, sizeof(uint8_t));
	if (!data)
		return -1;

	*cert_list = (void *)data;
	*cert_list_size = cl_size;

	for (int i = 0; i < num_signatures; i++) {
		/* pe-coff 8.2 adds some text that says each cert list
		 * entry is 8-byte aligned, so that means we need to align
		 * them here. */
		cert_list_entry_t *cle = (cert_list_entry_t *)data;
		cle->hdr.length = signatures[i]->len +
			sizeof (win_certificate_header_t);
		cle->hdr.revision = WIN_CERT_REVISION_2_0;
		cle->hdr.cert_type = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
		memcpy(&cle->data[0], signatures[i]->data,
					signatures[i]->len);
		data += sizeof (win_certificate_header_t) + signatures[i]->len;
		data += ALIGNMENT_PADDING(signatures[i]->len, 8);
	}

	return 0;
}

static int
implant_cert_list(Pe *pe, void *cert_list, size_t cert_list_size)
{
	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	int rc = pe_alloccert(pe, cert_list_size);
	if (rc < 0)
		return rc;

	return pe_populatecert(pe, cert_list, cert_list_size);
}

int
finalize_signatures(SECItem **sigs, int num_sigs, Pe *pe)
{
	void *clist = NULL;
	size_t clist_size = 0;

	if (num_sigs == 0) {
		return 0;
	}

	if (!pe || num_sigs < 0) {
		errno = EINVAL;
		return -1;
	}

	if (generate_cert_list(sigs, num_sigs,
				&clist, &clist_size) < 0)
		return -1;

	if (clist_size > 0) {
		if (implant_cert_list(pe, clist, clist_size) < 0) {
			free(clist);
			return -1;
		}
	}
	free(clist);
	return 0;
}
#pragma GCC diagnostic pop

int
cert_iter_init(cert_iter *iter, Pe *pe)
{
	if (!pe) {
		errno = EINVAL;
		return -1;
	}

	iter->pe = pe;
	iter->n = 0;
	iter->certs = 0;
	iter->size = -1;

	data_directory *dd;

	int rc = pe_getdatadir(pe, &dd);
	if (rc < 0)
		return -1;

	void *map;
	size_t map_size;

	map = pe_rawfile(pe, &map_size);
	if (!map)
		return -1;

	iter->certs = map + dd->certs.virtual_address;
	if (dd->certs.virtual_address) {
		iter->size = dd->certs.size;
	}

	return rc;
}

int
next_cert(cert_iter *iter, void **cert, ssize_t *cert_size)
{
	if (!iter)
		return -1;
	if (!iter->certs)
		return -1;

	if (iter->n >= iter->size) {
done:
		*cert = NULL;
		*cert_size = -1;
		return 0;
	}

	size_t n = iter->n;
	void *certs = iter->certs;
	size_t size = iter->size;

	void *map = NULL;
	size_t map_size = 0;

	map = pe_rawfile(iter->pe, &map_size);
	if (!map || map_size < 1)
		return 0;

	while (1) {
		win_certificate_header_t *tmpcert;
		if (n + sizeof (*tmpcert) >= size)
			goto done;

		tmpcert = (win_certificate_header_t *)((uint8_t *)certs + n);

		if ((intptr_t)tmpcert > (intptr_t)((intptr_t)map + map_size))
			return -1;

		/* length _includes_ the size of the structure. */
		uint32_t length = le32_to_cpu(tmpcert->length);

		if (length < sizeof (*tmpcert))
			return -1;

		n += sizeof (*tmpcert);
		length -= sizeof (*tmpcert);

		if (n + length > size)
			goto done;

		if (length == 0)
			continue;

		uint16_t rev = le16_to_cpu(tmpcert->revision);
		if (rev != WIN_CERT_REVISION_2_0)
			continue;

		if (cert)
			*cert = (uint8_t *)tmpcert + sizeof(*tmpcert);
		if (cert_size)
			*cert_size = length;

		iter->n += sizeof (*tmpcert) + length;
		iter->n += ALIGNMENT_PADDING(iter->n, 8);

		return 1;
	}
}

static ssize_t
get_current_sigspace_size(Pe *pe)
{
	data_directory *dd;

	int rc = pe_getdatadir(pe, &dd);
	if (rc < 0) {
		fprintf(stderr, "Could not get data directory: %m\n");
		exit(1);
	}

	return dd->certs.size;
}

static ssize_t
get_current_sigspace_in_use(Pe *pe)
{
	cert_iter iter;
	int rc = cert_iter_init(&iter, pe);
	if (rc < 0)
		return -1;

	ssize_t foundsize = 0;

	intptr_t prevdata = 0;
	ssize_t prevdatalen = 0;

	while (1) {
		intptr_t data = 0;
		ssize_t datalen = 0;
		rc = next_cert(&iter, (void **)&data, &datalen);
		if (rc <= 0) {
			if (prevdata != 0)
				foundsize = (prevdata + prevdatalen) -
						(intptr_t)iter.certs;
			break;
		}
		prevdata = data;
		prevdatalen = datalen;
	}

	return foundsize;
}

static ssize_t
get_total_sigspace_size(cms_context *cms, Pe *pe, SECItem *sig)
{
	ssize_t ret = 0;
	/* first, see if we need some padding to make the original structure
	 * in the data directory */
	if (cms->num_signatures == 0) {
		void *map = NULL;
		size_t map_size = 0;
		map = pe_rawfile(pe, &map_size);
		if (!map || map_size < 1) {
			fprintf(stderr, "Could not get raw PE map: %m\n");
			exit(1);
		}

		ret += ALIGNMENT_PADDING(map_size, 8);
	}

	/* if there is a previous dd->certs, we need to find out if any is
	 * spare room in it */
	ssize_t in_use = get_current_sigspace_in_use(pe);
	if (in_use > 0) {
		in_use += ALIGNMENT_PADDING(in_use, 8);
		ret += in_use;
	}

	/* at this point ret is any amount of padding we need plus any number
	 * of previous entries.  Add the amount for this entry, which *doesn't*
	 * yet include any padding. */
	ret += sizeof(win_certificate_header_t);
	ret += sig->len;

	/* and finally, the spec actually says:
	 * | Notice that certificates always start on an octaword boundary.
	 * | If a certificate is not an even number of octawords long, it
	 * | is zero padded to the next octaword boundary. However, the length
	 * | of the certificate does not include this padding and so any
	 * | certificate navigation software must be sure to round up to the
	 * | next octaword to locate another certificate.
	 * which sort of accidentally says we pad if we need to, whether or
	 * not there's anythign coming next.  A+ writing here.
	 */
	ret += ALIGNMENT_PADDING(ret, 8);
	return ret;
}

ssize_t
available_cert_space(Pe *pe)
{
	return get_current_sigspace_size(pe) -
		get_current_sigspace_in_use(pe);
}

ssize_t
calculate_signature_space(cms_context *cms, Pe *pe)
{
	SECItem sig = { 0, };

	int rc = generate_spc_signed_data(cms, &sig);
	if (rc < 0) {
		fprintf(stderr, "Could not generate signed data: %m\n");
		exit(1);
	}

	ssize_t ret = get_total_sigspace_size(cms, pe, &sig);
	free_poison(sig.data, sig.len);
	return ret;
}

ssize_t
get_sigspace_extend_amount(cms_context *cms, Pe *pe, SECItem *sig)
{
	ssize_t total = get_total_sigspace_size(cms, pe, sig);
	return total - get_current_sigspace_size(pe);
}

int
parse_signatures(SECItem ***sigs, int *num_sigs, Pe *pe)
{
	cert_iter iter;
	int rc = cert_iter_init(&iter, pe);
	if (rc < 0)
		return -1;

	void *data;
	ssize_t datalen;
	int nsigs = 0;

	while (1) {
		rc = next_cert(&iter, &data, &datalen);
		if (rc <= 0)
			break;
		nsigs++;
	}

	if (nsigs == 0) {
		*num_sigs = 0;
		*sigs = NULL;
		return 0;
	}

	SECItem **signatures = calloc(nsigs, sizeof (SECItem *));
	if (!signatures)
		return -1;

	rc = cert_iter_init(&iter, pe);
	if (rc < 0)
		goto err;

	int i = 0;
	while (1) {
		rc = next_cert(&iter, &data, &datalen);
		if (rc <= 0)
			break;

		signatures[i] = calloc(1, sizeof (SECItem));
		if (!signatures[i])
			goto err;

		signatures[i]->data = calloc(1, datalen);
		if (!signatures[i]->data)
			goto err;

		memcpy(signatures[i]->data, data, datalen);
		signatures[i]->len = datalen;
		signatures[i]->type = siBuffer;
		i++;
	}

	*num_sigs = nsigs;
	*sigs = signatures;

	return 0;
err:
	if (signatures) {
		for (i = 0; i < nsigs; i++) {
			if (signatures[i]) {
				if (signatures[i]->data) /* <-- see below */
					free(signatures[i]->data);
				free(signatures[i]);
				/*
				 * in gcc-10.1.1-1.fc32 , -fanalyzer believes the test
				 * above is a use-after free.  I really don't see how,
				 * but this somehow convinces it there's nothing wrong
				 * there.
				 */
				signatures[i] = NULL;
			}
		}
		free(signatures);
	}
	return -1;
}

```

`src/wincert.h`:

```h
// SPDX-License-Identifier: GPLv2
/*
 * wincert.h - types and headers to iterate the certificates in authenticode
 *             signatures
 * Copyright Peter Jones <pjones@redhat.com>
 * Copyright Red Hat, Inc.
 */
#ifndef PESIGN_WINCERT_H
#define PESIGN_WINCERT_H 1

#include <efisec.h>

typedef struct cert_iter {
	Pe *pe;
	size_t n;
	void *certs;
	size_t size;
} cert_iter;

extern int cert_iter_init(cert_iter *iter, Pe *pe);
extern int next_cert(cert_iter *iter, void **cert, ssize_t *cert_size);
extern ssize_t available_cert_space(Pe *pe);
extern ssize_t calculate_signature_space(cms_context *cms, Pe *pe);
extern int parse_signatures(SECItem ***sigs, int *num_sigs, Pe *pe);
extern int finalize_signatures(SECItem **sigs, int num_sigs, Pe *pe);
extern size_t get_reserved_sig_space(cms_context *cms, Pe *pe);
extern ssize_t get_sigspace_extend_amount(cms_context *cms, Pe *pe, SECItem *sig);

#endif /* PESIGN_WINCERT_H */

```

`util/Makefile`:

```
SRCDIR = $(realpath .)
TOPDIR = $(realpath ..)

include $(TOPDIR)/Make.version
include $(TOPDIR)/Make.rules
include $(TOPDIR)/Make.efirules
include $(TOPDIR)/Make.defaults

FORMAT=efi-app-$(HOSTARCH)
LDFLAGS = -nostdlib -T $(LIBDIR)/gnuefi/elf_$(HOSTARCH)_efi.lds -shared -Bsymbolic $(LIBDIR)/gnuefi/crt0-efi-$(HOSTARCH).o -L$(LIBDIR)
LIBS=-lefi -lgnuefi $(shell $(CC) -print-libgcc-file-name)
CCLDFLAGS =
BUILDFLAGS = -I/usr/include/efi/ -I/usr/include/efi/$(HOSTARCH)/ -I/usr/include/efi/protocol -fpic -fshort-wchar -fno-reorder-functions -fno-strict-aliasing -fno-merge-constants -mno-red-zone -Wimplicit-function-declaration

TARGETS = setupsb.efi dumpsb.efi clearpk.efi

all : $(TARGETS)

clean : 
	@rm -rfv *.o *.a *.so .*.d $(TARGETS)

install :
	$(INSTALL) -d -m 755 $(INSTALLROOT)/boot/efi/EFI/redhat/
	$(INSTALL) -m 755 *.efi $(INSTALLROOT)/boot/efi/EFI/redhat/

install_systemd:

install_sysvinit:

.PHONY: all clean install

include $(TOPDIR)/Make.efirules

```

`util/cert.csr`:

```csr
-----BEGIN CERTIFICATE REQUEST-----
MIICuDCCAaACAQAwczELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDU1hc3NhY2h1c2V0
dHMxEjAQBgNVBAcMCUNhbWJyaWRnZTEWMBQGA1UECgwNUmVkIEhhdCwgSW5jLjEg
MB4GCSqGSIb3DQEJARYRcGpvbmVzQHJlZGhhdC5jb20wggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQDRJoSrtSJ+Fi/2GKkq50ldqVCzcVFp+I5cqmh6a9A3
HcXYKj+08T3SL2KP1ymKJqjG0ZpCgeISTZsPRejJEn9dqud/EUIUJZIGYMZl1A52
DaE+7JMjySB+zRAwkjISaCh19SbG/849b4OZVrMTU9bOJo4jxagWCyKEYpmTr2ss
P9Aa70LVShcz2emCDzLlUB7T3c1c04CJwdiCDMscFgIJMwz1cPTMUJ6DJ4h9qA5t
ZA5C/AzMd+AzL8Hx3bPQIMdTEFc6/FjSLIzy5MwjuoYcDQIJtt04Q0sDMEStVm//
27NDkixtdQnAZWNU3qs20MfTzMa74Dez5unq0I5oR9yVAgMBAAGgADANBgkqhkiG
9w0BAQUFAAOCAQEAc+3CGvd7yemFNPZ3BvASwtApqvV3bpKSSaQEAtoi6yyp9WLZ
GrBTxl/wvQpVktQhtirHSQIQICo0x42CrFecAfixTtDgjhfwg+8WYn/hR7Bb+i32
+o4AJs5rCaQhFZIGgeCKrvVHYOMG8Pcd23lY301GVhnVNs/pvoKxO98d3o4tA4nx
ZC1noVSova1D05QKRcwaJjLRsk6Woam5USq6ZxMjVQ4hHLyGNc71MI7CxHU6RFw9
8jztCYSQ+1LveaUVwrjodGmV3yc4BGK0BA+941XTP4pbRgV2Q8G0xhhBYup8Mrpi
al+ewbBX4uAhlrimX2j8THDyP2wgImfsH5XD3g==
-----END CERTIFICATE REQUEST-----

```

`util/clearpk.c`:

```c

#include <efi.h>
#include <efilib.h>

#include "sb.h"

EFI_STATUS
efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
	EFI_STATUS rc;

	InitializeLib(image, systab);

	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
				EFI_PLATFORM_KEY_NAME,
				&EfiGlobalVariable,
				EFI_VARIABLE_NON_VOLATILE,
				0, NULL);
	Print(L"rc: 0x%x\n", (int)rc);
	return rc;
}


```

`util/dumpsb.c`:

```c
#include <efi.h>
#include <efilib.h>

#include "shelliface.h"
#include "sb.h"

static void
dumphex(UINT8 *data, UINTN data_size)
{
	int i, j;
	for (i = 0, j = 0; i < data_size; i++, j++) {
		Print(L"%02x ", data[i]);
		if (j == 15) {
			j = -1;
			Print(L"\n");
		}
	}
	if (j != -1)
		Print(L"\n");
}

static void
dumpvar(EFI_SYSTEM_TABLE *systab, EFI_GUID *guid, CHAR16 *name)
{
	char *data = NULL;
	UINTN data_size = 0;

	Print(L"Dumping ");
	Print(name);
	Print(L"\n");
	data = LibGetVariableAndSize(name, guid, &data_size);
	dumphex(data, data_size);
	FreePool(data);
}

EFI_STATUS
show_signature_support(EFI_SYSTEM_TABLE *systab, UINTN showguid)
{
	EFI_STATUS rc = EFI_SUCCESS;
	char *data = NULL;
	UINTN data_size = 0;
	UINTN found = 0;
	EFI_GUID *guid;
	int i, j;

	struct {
		EFI_GUID *guid;
		CHAR16 *name;
		int required;
	} hashes[] = {
		{ &gEfiCertSha1Guid, L"SHA-1", 1 },
		{ &gEfiCertSha256Guid, L"SHA-256", 0 },
		{ &gEfiCertRsa2048Guid, L"RSA-2048", 0 },
		{ &gEfiCertRsa2048Sha1Guid, L"RSA-2048 + SHA-1", 0 },
		{ &gEfiCertRsa2048Sha256Guid, L"RSA-2048 + SHA-256", 0 },
		{ &gEfiCertX509Guid, L"X509", 1 },
		{ &gEfiCertPkcs7Guid, L"PKCS-7", 0 },
		{ NULL, L"" }
	};

	data = LibGetVariableAndSize(L"SignatureSupport", &EfiGlobalVariable,
				&data_size);
	guid = (EFI_GUID *)data;
	Print(L"Supported hashes:\n");
	for (i = 0; i < data_size / sizeof(*guid); i++, guid++) {
		found = 0;
		for (j = 0; hashes[j].guid != NULL; j++) {
			if (!CompareMem(hashes[j].guid, guid, sizeof(*guid))) {
 				if (showguid)
					Print(L"        %s (%g)\n", hashes[j].name, guid);
				else
					Print(L"        %s\n", hashes[j].name);
				hashes[j].required = 0;
				found = 1;
				continue;
			}
		}
		if (!found) {
			Print(L"        Unknown hash (%g)\n", guid);
		}
	}

	for (j = 0; hashes[j].guid != NULL; j++) {
		if (hashes[j].required) {
			Print(L"ERROR: Did not find required hash \"%s\"\n",
				hashes[j].name);
			rc = EFI_NOT_FOUND;
		}
	}

	FreePool(data);
	return rc;
}


static EFI_STATUS
get_args(EFI_HANDLE image, UINTN *argc, CHAR16 ***argv)
{
	EFI_STATUS rc;
	EFI_SHELL_INTERFACE *shell;
	EFI_GUID gEfiShellInterfaceGuid = EFI_SHELL_INTERFACE_GUID;

	rc = uefi_call_wrapper(BS->OpenProtocol, 6,
				image,
				&gEfiShellInterfaceGuid,
				(VOID **)&shell, image, NULL,
				EFI_OPEN_PROTOCOL_GET_PROTOCOL);

	if (EFI_ERROR(rc))
		return rc;

	*argc = shell->Argc;
	*argv = shell->Argv;
	uefi_call_wrapper(BS->CloseProtocol, 4, image,
			&gEfiShellInterfaceGuid,
			image, NULL);
	return EFI_SUCCESS;
}


static void
usage(void)
{
	Print(L"Usage: dumpsb [ -s | --showguid ]\n");
}



EFI_STATUS
efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
        UINTN argc;
        CHAR16 **argv;
	EFI_STATUS rc = EFI_SUCCESS;
	int i;
	UINTN showguid = 0;

	InitializeLib(image, systab);

        rc = get_args(image, &argc, &argv);
	if (EFI_ERROR(rc)) {
		Print(L"ERROR: Parsing command line arguments: %d\n", rc);
		return rc;
	}

        if (argc == 2) {
		if (!StrCmp(argv[1], L"help") ||
			!StrCmp(argv[1], L"/help") ||
			!StrCmp(argv[1], L"--help") ||
			!StrCmp(argv[1], L"-?")) {
				usage();
				return EFI_SUCCESS;
		} else if (!StrCmp(argv[1], L"/showguid") ||
			!StrCmp(argv[1], L"--showguid") ||
			!StrCmp(argv[1], L"-s")) {
				showguid = 1;
		} else {
			usage();
			return EFI_INVALID_PARAMETER;
		}
        }

	rc = show_signature_support(systab, showguid);
	dumpvar(systab, &EfiGlobalVariable, L"SetupMode");
	dumpvar(systab, &EfiGlobalVariable, L"SecureBoot");
	dumpvar(systab, &EfiGlobalVariable, EFI_PLATFORM_KEY_NAME);
	dumpvar(systab, &EfiGlobalVariable, EFI_KEY_EXCHANGE_KEY_NAME);
	dumpvar(systab, &gEfiImageSecurityDatabaseGuid,	EFI_IMAGE_SECURITY_DATABASE);
	dumpvar(systab, &gEfiImageSecurityDatabaseGuid,	EFI_IMAGE_SECURITY_DATABASE1);

	return rc;
}

```

`util/pkpub.cer`:

```cer
Ñ&„«µ"~/ö©*çI]©P³qQiøŽ\ªhzkÐ7ÅØ*?´ñ=Ò/b×)Š&¨ÆÑšBâM›EèÉ]ªçB%’`ÆeÔv¡>ì“#É ~Í0’2h(uõ&ÆÿÎ=oƒ™V³SÖÎ&Ž#Å¨"„b™“¯k,?ÐïBÕJ3Ùé‚2åPÓÝÍ\Ó€‰ÁØ‚Ë	3õpôÌPžƒ'ˆ}¨mdBüÌwà3/ÁñÝ³Ð ÇSW:üXÒ,ŒòäÌ#º†	¶Ý8CK0D­VoÿÛ³C’,mu	ÀecTÞ«6ÐÇÓÌÆ»à7³æéêÐŽhGÜ•
```

`util/privkey.pem`:

```pem
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA0SaEq7UifhYv9hipKudJXalQs3FRafiOXKpoemvQNx3F2Co/
tPE90i9ij9cpiiaoxtGaQoHiEk2bD0XoyRJ/XarnfxFCFCWSBmDGZdQOdg2hPuyT
I8kgfs0QMJIyEmgodfUmxv/OPW+DmVazE1PWziaOI8WoFgsihGKZk69rLD/QGu9C
1UoXM9npgg8y5VAe093NXNOAicHYggzLHBYCCTMM9XD0zFCegyeIfagObWQOQvwM
zHfgMy/B8d2z0CDHUxBXOvxY0iyM8uTMI7qGHA0CCbbdOENLAzBErVZv/9uzQ5Is
bXUJwGVjVN6rNtDH08zGu+A3s+bp6tCOaEfclQIDAQABAoIBAGjvK2c+9PRPy3Zs
fwugiSWt2mh9dTx20W5arRqm1wugK3A+GkJ9OugmkAvdBuFibhF6fivaIIPQXfi2
uYmQd0iWg5k0HnQfOXlrun7CexLt2bXJWjV9JomX9wR3hRnJGmu8ON1k4KPgPCWF
40jSKpa5r1zxQVj18zZ6hdUcEOhcnyZl709PPDUeZ6RYgQgK6Wa9vu1Cj4monpH3
nYWaq+Hm1RN3A2L4zDaayx/aCHnlI/nY2lLf+OcaSbAlzrBcreKf/hKJ4armWbD4
f7LPWNyg7/hPzhmXWS59Iqnc1+JwVfs14MYkf/rN1NQ/OYUO7hVRNkgj90RzPzFg
imdMGcECgYEA916ATnAoAeNgQheNKoKgFSazKJkBdrj9fDCzNteFDhfisc9S2od4
a6/z/6s2H0fgIK9gHl/VwOAOqmtkuenEuvabjiPmI5ZdafHU3cTP/rzQ+ts/3G0C
Mcxknd2XmQgWyxuZMeXMfYJ3aGaHENM5lupDHv4/SZVi1ryC+FkXceUCgYEA2HKl
7HOoK+fS0S4jCX6dfyglx7jyqWttgohwkv1BhRgGwCxWbtY3flO+CxYn1+Yumyhk
7KS//WbtO7mkz4dtHsuS7xR8mG6sMqqX4wJULMNGHRSiQckWHZ08lM+j6z1PE1bB
9SJhaMycZa/wlc0TKy4aiKRgufu1xgUsbcUU1PECgYEAppCScr6goczaBwbWvjYg
1r0tS/vi+W9M+C/OrPHoHPpGYhZJIu6vTku3T4OYuO1r5HZSkYFUbEAyf9w6gdj/
6Cify9EuaO4ZznnRLNcWet/nE9NIKAOaw69uXMJWDuxcdL0LpYan8CdGghzve4vP
Lmhlc9wc/05AtHlQ8ysCV2UCgYAvZLssEQ8LvhENOHr3gz/dLd9H4hlQO3OZF2L+
7HFCQUaJIawzTLiN8qw0JT/IKGCgHLIsls5rH/RmFXoe7tpX2d9sdiHqBqGx3mSv
kjz4KDHcAD6fBPbQuTMgqm6L/bqo02BY2pRVrCe6pFGbm3HNDKVGsidz0ce1ekCG
MJclIQKBgBU/tp1rW8bdBAwL0+DyWv7n5eeVQVKEpyJMn/eXuOPksLnsAIK7xDTa
h5P103vcNyq/QJLARUt6a2chfhSZ4GnRgtsgpeUvrqZji2sUOVGL0Vm/SAPSfB7K
yp3l7vl/dkQLm5T3mMAvhPoSLzFGDQmeX1Y9oblwBY7pb2UDT5eX
-----END RSA PRIVATE KEY-----

```

`util/sb.h`:

```h
#ifndef SB_H
#define SB_H 1

struct _WIN_CERTIFICATE {
	UINT32	dwLength;
	UINT16	wRevision;
	UINT16	wCertificateType;
	//UINT8	bCertficate[];
} ALIGNED(1);

typedef struct _WIN_CERTIFICATE WIN_CERTIFICATE;

#define EFI_CERT_TYPE_RSA2048_SHA256_GUID \
  { 0xa7717414, 0xc616, 0x4977, {0x94,0x20,0x84,0x47,0x12,0xa7,0x35,0xbf }}

typedef struct {
	EFI_GUID	HashType;
	UINT8		PublicKey[256];
	UINT8		Signature[256];
} EFI_CERT_BLOCK_RSA_2048_SHA256;

struct _WIN_CERTIFICATE_UEFI_GUID {
	WIN_CERTIFICATE	Hdr;
	EFI_GUID	CertType;
	//UINT8		CertData[];
} ALIGNED(1);

typedef struct _WIN_CERTIFICATE_UEFI_GUID WIN_CERTIFICATE_UEFI_GUID;

struct _EFI_VARIABLE_AUTHENTICATION {
	UINT64				MonotonicCount;
	WIN_CERTIFICATE_UEFI_GUID	AuthInfo;
} ALIGNED(1);

typedef struct _EFI_VARIABLE_AUTHENTICATION EFI_VARIABLE_AUTHENTICATION;

struct _EFI_VARIABLE_AUTHENTICATION_2 {
	EFI_TIME			TimeStamp;
	WIN_CERTIFICATE_UEFI_GUID	AuthInfo;
} ALIGNED(1);

typedef struct _EFI_VARIABLE_AUTHENTICATION_2 EFI_VARIABLE_AUTHENTICATION_2;

struct _EFI_SIGNATURE_DATA {
	EFI_GUID	SignatureOwner; /* 16 */
//	UINT8		SignatureData[];
} ALIGNED(1);

typedef struct _EFI_SIGNATURE_DATA EFI_SIGNATURE_DATA;

struct _EFI_SIGNATURE_LIST {
	EFI_GUID	SignatureType;		/* 16 */
	UINT32		SignatureListSize;	/* 4 */
	UINT32		SignatureHeaderSize;	/* 4 */
	UINT32		SignatureSize;		/* 4 */
} ALIGNED(1);

typedef struct _EFI_SIGNATURE_LIST EFI_SIGNATURE_LIST;

#define EFI_IMAGE_SECURITY_DATABASE_GUID \
  { 0xd719b2cb, 0x3d3a, 0x4596, {0xa3,0xbc,0xda,0xd0,0x0e,0x67,0x65,0x6f }}
EFI_GUID gEfiImageSecurityDatabaseGuid = EFI_IMAGE_SECURITY_DATABASE_GUID;

#define EFI_CERT_SHA256_GUID \
  { 0xc1c41626, 0x504c, 0x4092, {0xac,0xa9,0x41,0xf9,0x36,0x93,0x43,0x28 }}
EFI_GUID gEfiCertSha256Guid = EFI_CERT_SHA256_GUID;

#define EFI_CERT_RSA2048_GUID \
  { 0x3c5766e8, 0x269c, 0x4e34, {0xaa,0x14,0xed,0x77,0x6e,0x85,0xb3,0xb6 }}
EFI_GUID gEfiCertRsa2048Guid = EFI_CERT_RSA2048_GUID;

#define EFI_CERT_RSA2048_SHA256_GUID \
  { 0xe2b36190, 0x879b, 0x4a3d, {0xad,0x8d,0xf2,0xe7,0xbb,0xa3,0x27,0x84 }}
EFI_GUID gEfiCertRsa2048Sha256Guid = EFI_CERT_RSA2048_SHA256_GUID;

#define EFI_CERT_SHA1_GUID \
  { 0x826ca512, 0xcf10, 0x4ac9, {0xb1,0x87,0xbe,0x01,0x49,0x66,0x31,0xbd }}
EFI_GUID gEfiCertSha1Guid = EFI_CERT_SHA1_GUID;

#define EFI_CERT_RSA2048_SHA1_GUID \
  { 0x67f8444f, 0x8743, 0x48f1, {0xa3,0x28,0x1e,0xaa,0xb8,0x73,0x60,0x80 }}
EFI_GUID gEfiCertRsa2048Sha1Guid = EFI_CERT_RSA2048_SHA1_GUID;

#define EFI_CERT_X509_GUID \
  { 0xa5c059a1, 0x94e4, 0x4aa7, {0x87,0xb5,0xab,0x15,0x5c,0x2b,0xf0,0x72 }}
EFI_GUID gEfiCertX509Guid = EFI_CERT_X509_GUID;

#define EFI_CERT_TYPE_PKCS7_GUID \
  { 0x4aafd29d, 0x68df, 0x49ee, {0x8a,0xa9,0x34,0x7d,0x37,0x56,0x65,0xa7 }}
EFI_GUID gEfiCertPkcs7Guid = EFI_CERT_TYPE_PKCS7_GUID;

#define EFI_IMAGE_SECURITY_DATABASE L"db"
#define EFI_IMAGE_SECURITY_DATABASE1 L"dbx"
#define EFI_SETUP_MODE_NAME L"SetupMode"
#define EFI_PLATFORM_KEY_NAME L"PK"
#define EFI_KEY_EXCHANGE_KEY_NAME L"KEK"
#define EFI_SIGNATURE_SUPPORT_NAME L"SignatureSupport"
#define EFI_SECURE_BOOT_MODE_NAME L"SecureBoot"

#define SECURE_BOOT_MODE_ENABLE 1
#define SECURE_BOOT_MODE_DISABLE 0

#define SETUP_MODE 1
#define USER_MODE 0

#endif /* SB_H */

```

`util/setupsb.c`:

```c

#include <efi.h>
#include <efilib.h>

#include "shelliface.h"
#include "sb.h"

/* XXX probably shouldn't ship defaulting to this */
EFI_GUID rh_guid = {0x0abba7dc, 0xe516, 0x4167, {0xbb,0xf5,0x4d,0x9d,0x1c,0x73,0x94,0x16}};

/* XXX this needs to be moved into gnu-efi */
EFI_GUID gEfiShellInterfaceGuid = EFI_SHELL_INTERFACE_GUID;

/* XXX this needs to be moved into gnu-efi */
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS			0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS	0x00000020
#define EFI_VARIABLE_APPEND_WRITE				0x00000040

/* XXX this needs to be moved into gnu-efi */
#define EFI_SHELL_DEVICE_PATH_MAP \
 {0x47c7b225, 0xc42a, 0x11d2, {0x8e,0x57,0x0,0xa0,0xc9,0x69,0x72,0x3b}}
EFI_GUID gEfiShellDevPathMap = EFI_SHELL_DEVICE_PATH_MAP;

static void UNUSED
dumphex(UINT8 *data, UINTN data_size)
{
	int i, j;
	for (i = 0, j = 0; i < data_size; i++, j++) {
		Print(L"%02x ", data[i]);
		if (j == 15) {
			j = -1;
			Print(L"\n");
		}
	}
	if (j != -1)
		Print(L"\n");
}

static void UNUSED
dumphex_str(CHAR16 *data, UINTN data_size)
{
	int i, j;
	for (i = 0, j = 0; i < data_size; i+=2, j++) {
		Print(L"%c%c ", data[i], data[i+1]);
		if (j == 15) {
			j = -1;
			Print(L"\n");
		}
	}
	if (j != -1)
		Print(L"\n");
}

static EFI_STATUS
get_args(EFI_HANDLE image, UINTN *argc, CHAR16 ***argv)
{
	EFI_STATUS rc;
	EFI_SHELL_INTERFACE *shell;

	rc = uefi_call_wrapper(BS->OpenProtocol, 6, 
				image, 
				&gEfiShellInterfaceGuid,
				(VOID **)&shell, image, NULL,
				EFI_OPEN_PROTOCOL_GET_PROTOCOL);

	if (EFI_ERROR(rc))
		return rc;

	*argc = shell->Argc;
	*argv = shell->Argv;
	uefi_call_wrapper(BS->CloseProtocol, 4, image,
			&gEfiShellInterfaceGuid,
			image, NULL);
	return EFI_SUCCESS;
}

static int
pk_is_populated(void)
{
	char *data = NULL;
	UINTN data_size = 0;

	data = LibGetVariableAndSize(EFI_PLATFORM_KEY_NAME, &EfiGlobalVariable,
		&data_size);
	FreePool(data);
	if (!data || data_size == 0)
		return 0;
	return 1;
}

static int
kek_is_populated(void)
{
	char *data = NULL;
	UINTN data_size = 0;

	data = LibGetVariableAndSize(EFI_KEY_EXCHANGE_KEY_NAME,
		&EfiGlobalVariable, &data_size);
	FreePool(data);
	if (!data || data_size == 0)
		return 0;
	return 1;
}

static int
db_is_populated(void)
{
	char *data = NULL;
	UINTN data_size = 0;

	data = LibGetVariableAndSize(EFI_IMAGE_SECURITY_DATABASE,
		&gEfiImageSecurityDatabaseGuid, &data_size);
	FreePool(data);
	if (!data || data_size == 0)
		return 0;
	return 1;
}

#if 0 /* doesn't appear necessary */
static int
dbx_is_populated(void)
{
	char *data = NULL;
	UINTN data_size = 0;

	data = LibGetVariableAndSize(EFI_IMAGE_SECURITY_DATABASE1,
		&gEfiImageSecurityDatabaseGuid, &data_size);
	FreePool(data);
	if (!data || data_size == 0)
		return 0;
	return 1;
}
#endif

static EFI_STATUS
make_variable(UINT8 *hash, UINTN hash_size,
		EFI_GUID owner, EFI_GUID signature_type,
		VOID **data, UINTN *data_size)
{
	if (!data || !data_size)
		return EFI_INVALID_PARAMETER;

	struct {
		EFI_SIGNATURE_LIST sl;
		EFI_SIGNATURE_DATA sd;
		UINT8 cert[hash_size];
	} ALIGNED(1) PACKED *var;

	var = AllocatePool(sizeof(*var));
	if (!var)
		return EFI_OUT_OF_RESOURCES;

	var->sl.SignatureType = signature_type;
	var->sl.SignatureListSize = sizeof(*var);
	var->sl.SignatureHeaderSize = 0;
	var->sl.SignatureSize = sizeof(EFI_SIGNATURE_DATA) + hash_size;

	var->sd.SignatureOwner = owner;
	CopyMem(var->cert, hash, hash_size);

	*data = var;
	*data_size = sizeof(*var);

	return EFI_SUCCESS;
}

static void
usage(void)
{
	Print(L"Usage: setupbs COMMAND \n");
	Print(L"  COMMAND := { set KEY SET_OPTIONS |\n"
	      L"               append KEY SET_OPTIONS |\n"
	      L"               clear KEY CLEAR_OPTIONS |\n"
	      L"               help }\n");
	Print(L"  KEY := { pk | kek | db | dbx }\n");
	Print(L"  SET_OPTIONS := [ --force ] { HASH | FILE }\n");
	Print(L"  HASH := --hash SIG_TYPE <hash>\n");
	Print(L"  FILE := --file SIG_TYPE <filename>\n");
	Print(L"  SIG_TYPE := sha1 sha256 rsa2048 x509\n");
	Print(L"  CLEAR_OPTIONS := [ --force ]\n");
}

static int
has_force(UINTN argc, CHAR16 **argv)
{
	int i;
	for (i = 0; i < argc; i++) {
		if (!StrCmp(argv[i], L"--force"))
			return 1;
	}
	return 0;
}

static inline int
hex_to_ord(CHAR16 x)
{
	char y = x & 0xff;
	int c = y >= 'a' ? 'a'-0xa
			 : y >= 'A' ? 'A'-0xa
			 	    : '0';
	y -= c;
	
	if (y < 0 && y > 0xf)
		return -1;
	return y;
}

static struct {
	CHAR16 *name;
	EFI_GUID guid;
	UINTN size;
} hashes[] = {
	{ L"SHA1", EFI_CERT_SHA1_GUID, 20 },
	{ L"SHA256", EFI_CERT_SHA256_GUID, 32 },
	{ L"RSA2048", EFI_CERT_RSA2048_GUID, 256 },
	{ L"X509", EFI_CERT_X509_GUID, -1 },
	{ NULL, }
};

static EFI_STATUS
get_hash(UINTN argc, CHAR16 **argv, EFI_GUID *sig_type_guid,
	UINT8 **hashp, UINTN *hash_sizep)
{
	int i;

	UINT8 *hash = NULL;
	UINTN hash_size = 0;

	EFI_GUID hash_guid;
	UINTN expected_hash_size = 0;

	if (!hashp || !hash_sizep)
		return EFI_INVALID_PARAMETER;

	for (i = 1; i < argc; i++) {
		if (!StrCmp(argv[i], L"--hash")) {
			if (argc <= i+2) {
				Print(L"argc is %d and we need %d\n",
					argc, i+2);
				return EFI_INVALID_PARAMETER;
			}

			StrUpr(argv[i+1]);
			int j;
			for (j = 0; hashes[j].name != NULL; j++) {
				if (!StrCmp(hashes[j].name, argv[i+1])) {
					hash_guid = hashes[j].guid;
					expected_hash_size = hashes[j].size;
					break;
				}
			}

			if (!expected_hash_size) {
				Print(L"Unknown hash %s\n", argv[i+1]);
				return EFI_UNSUPPORTED;
			}

			CHAR16 *text = argv[i+2];
			int text_len = StrLen(text);

			hash_size = text_len / 2;
			if (hash_size != expected_hash_size) {
				Print(L"Hash size was expected to be %d, but was actually %d\n", expected_hash_size, hash_size);
				return EFI_INVALID_PARAMETER;
			}


			hash = AllocatePool(hash_size);
			int k;
			for (j = 0, k = 0; j < hash_size; j++, k+=2) {
				int x = hex_to_ord(text[k]);
				int y = hex_to_ord(text[k+1]);

				if (x < 0 || y < 0) {
					Print(L"Coding error: {%d,%d} should both be positive\n", x, y);
					FreePool(hash);
					return EFI_INVALID_PARAMETER;
				}
				hash[j] = (x << 4) | y;
			}

			*sig_type_guid = hash_guid;
			*hashp = hash;
			*hash_sizep = hash_size;
			return EFI_SUCCESS;
		}
	}
	return EFI_NOT_FOUND;
}

static EFI_STATUS
get_file(UINTN argc, CHAR16 **argv, EFI_GUID *sig_type_guid,
		UINT8 **hashp, UINTN *hash_sizep)
{
	return EFI_UNSUPPORTED;
}

static EFI_STATUS
set_pk(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	EFI_STATUS rc;
	UINT8 *hash = NULL;
	UINTN hash_size = 0;
	EFI_GUID sig_type_guid;

	rc = get_hash(argc, argv, &sig_type_guid, &hash, &hash_size);
	if (rc == EFI_NOT_FOUND) {
		rc = get_file(argc, argv, &sig_type_guid, &hash, &hash_size);
		if (rc == EFI_NOT_FOUND)
			return EFI_INVALID_PARAMETER;
	}
	if (EFI_ERROR(rc))
		return rc;

	if (!CompareMem(&sig_type_guid, &gEfiCertRsa2048Guid,
			sizeof(sig_type_guid))) {
		Print(L"PK must be an RSA2048 Modulus.\n");
		return EFI_INVALID_PARAMETER;
	}

	UINTN flags = EFI_VARIABLE_NON_VOLATILE |
				EFI_VARIABLE_RUNTIME_ACCESS |
				EFI_VARIABLE_BOOTSERVICE_ACCESS;
			
#if 0 /* this is what you'd expect */
	VOID *data = NULL;
	UINTN data_size = 0;

	rc = make_variable(hash, hash_size, rh_guid,
		sig_type_guid, &data, &data_size);

	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
			EFI_PLATFORM_KEY_NAME, &EfiGlobalVariable, 
			flags, data_size, data);
	FreePool(data);
#else /* this is what you get */
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
			EFI_PLATFORM_KEY_NAME, &EfiGlobalVariable, 
			flags, hash_size, hash);
#endif

	FreePool(hash);

	return rc;
}

static EFI_STATUS
set_db_helper(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image,
		UINTN argc, CHAR16 **argv,
		EFI_GUID *vendor_guid, CHAR16 *dbname,
		int append)
{
	EFI_STATUS rc;
	UINT8 *hash = NULL;
	UINTN hash_size = 0;
	EFI_GUID sig_type_guid;

	rc = get_hash(argc, argv, &sig_type_guid, &hash, &hash_size);
	if (rc == EFI_NOT_FOUND) {
		rc = get_file(argc, argv, &sig_type_guid, &hash, &hash_size);
		if (rc == EFI_NOT_FOUND)
			return EFI_INVALID_PARAMETER;
	}
	if (EFI_ERROR(rc))
		return rc;

	VOID *data = NULL;
	UINTN data_size = 0;

	rc = make_variable(hash, hash_size, rh_guid,
		sig_type_guid, &data, &data_size);

	UINTN flags = EFI_VARIABLE_NON_VOLATILE |
				EFI_VARIABLE_RUNTIME_ACCESS |
				EFI_VARIABLE_BOOTSERVICE_ACCESS;
	if (append)
		flags |= EFI_VARIABLE_APPEND_WRITE;
			
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
			dbname, vendor_guid, flags, data_size, data);
	FreePool(data);
	FreePool(hash);

	return rc;
}

static EFI_STATUS
set_db(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	return set_db_helper(systab, image, argc, argv,
				&gEfiImageSecurityDatabaseGuid,
				EFI_IMAGE_SECURITY_DATABASE, 0);
}

static EFI_STATUS
set_dbx(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	return set_db_helper(systab, image, argc, argv,
				&gEfiImageSecurityDatabaseGuid,
				EFI_IMAGE_SECURITY_DATABASE1, 0);
}

static EFI_STATUS
set_kek(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	return set_db_helper(systab, image, argc, argv,
				&EfiGlobalVariable,
				EFI_KEY_EXCHANGE_KEY_NAME, 0);
}

static EFI_STATUS
append_db(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{

	return set_db_helper(systab, image, argc, argv,
				&gEfiImageSecurityDatabaseGuid,
				EFI_IMAGE_SECURITY_DATABASE, 1);
}

static EFI_STATUS
append_dbx(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	return set_db_helper(systab, image, argc, argv,
				&gEfiImageSecurityDatabaseGuid,
				EFI_IMAGE_SECURITY_DATABASE1, 1);
}

static EFI_STATUS
append_kek(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	return set_db_helper(systab, image, argc, argv,
				&EfiGlobalVariable,
				EFI_KEY_EXCHANGE_KEY_NAME, 1);
}

static EFI_STATUS
append_pk(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	Print(L"PK Can only be one entry.\n");
	return EFI_UNSUPPORTED;
}

static EFI_STATUS
clear_pk(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	EFI_STATUS rc;
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
		EFI_PLATFORM_KEY_NAME, &EfiGlobalVariable,
		EFI_VARIABLE_NON_VOLATILE|EFI_VARIABLE_RUNTIME_ACCESS|
			EFI_VARIABLE_BOOTSERVICE_ACCESS,
		0, NULL);
	if (rc == EFI_NOT_FOUND)
		rc = EFI_SUCCESS;
	return rc;
}

static EFI_STATUS
clear_db(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	EFI_STATUS rc;

	if (pk_is_populated() && !kek_is_populated() && !has_force(argc,argv)) {
		Print(L"Cowardly refusing to clear db with PK set "
			L"and no KEK\n");
		return EFI_UNSUPPORTED;
	}
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
		EFI_IMAGE_SECURITY_DATABASE, &gEfiImageSecurityDatabaseGuid,
		EFI_VARIABLE_NON_VOLATILE|EFI_VARIABLE_RUNTIME_ACCESS|
			EFI_VARIABLE_BOOTSERVICE_ACCESS,
		0, NULL);
	if (rc == EFI_NOT_FOUND)
		rc = EFI_SUCCESS;
	return rc;
}

static EFI_STATUS
clear_dbx(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	EFI_STATUS rc;
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
		EFI_IMAGE_SECURITY_DATABASE1, &gEfiImageSecurityDatabaseGuid,
		EFI_VARIABLE_NON_VOLATILE|EFI_VARIABLE_RUNTIME_ACCESS|
			EFI_VARIABLE_BOOTSERVICE_ACCESS,
		0, NULL);
	if (rc == EFI_NOT_FOUND)
		rc = EFI_SUCCESS;
	return rc;
}

static EFI_STATUS
clear_kek(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv)
{
	EFI_STATUS rc;
	if (pk_is_populated() && !db_is_populated() && !has_force(argc,argv)) {
		Print(L"Cowardly refusing to clear KEK with PK set "
			L"and no DB entries\n");
		return EFI_UNSUPPORTED;
	}
	rc = uefi_call_wrapper(systab->RuntimeServices->SetVariable, 5,
		EFI_KEY_EXCHANGE_KEY_NAME, &EfiGlobalVariable,
		EFI_VARIABLE_NON_VOLATILE|EFI_VARIABLE_RUNTIME_ACCESS|
			EFI_VARIABLE_BOOTSERVICE_ACCESS,
		0, NULL);
	if (rc == EFI_NOT_FOUND)
		rc = EFI_SUCCESS;
	return rc;
}

struct {
	CHAR16 *name;
	CHAR16 *db;
	EFI_STATUS (*handler)(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv);
} actions[] = {
	{ L"set", L"pk", set_pk},
	{ L"set", L"kek", set_kek},
	{ L"set", L"db", set_db},
	{ L"set", L"dbx", set_dbx},
	{ L"append", L"PK", append_pk},
	{ L"append", L"kek", append_kek},
	{ L"append", L"db", append_db},
	{ L"append", L"dbx", append_dbx},
	{ L"clear", L"pk", clear_pk},
	{ L"clear", L"kek", clear_kek},
	{ L"clear", L"db", clear_db},
	{ L"clear", L"dbx", clear_dbx},
	{ NULL, NULL, NULL},
};

typedef EFI_STATUS (*handler)(EFI_SYSTEM_TABLE *systab, EFI_HANDLE image, UINTN argc, CHAR16 **argv);

EFI_STATUS
efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
	UINTN argc;
	CHAR16 **argv;
	EFI_STATUS rc = EFI_SUCCESS;

	InitializeLib(image, systab);

	rc = get_args(image, &argc, &argv);
	if (EFI_ERROR(rc)) {
		Print(L"Error: %d\n", rc);
		return rc;
	}

	if (argc == 1) {
		Print(L"Too few arguments.\n");
show_usage:
		usage();
		return EFI_INVALID_PARAMETER;
	}

	if (argc == 2) {
		if (!StrCmp(argv[1], L"help") ||
				!StrCmp(argv[1], L"/help") ||
				!StrCmp(argv[1], L"--help") ||
				!StrCmp(argv[1], L"-?")) {
			usage();
			return EFI_SUCCESS;
		}
		goto show_usage;
	}

	int i = 1;

	rc = EFI_INVALID_PARAMETER;
	int j;

	for(j = 0; actions[j].name != NULL; j++ ) {
		if (!StrCmp(actions[j].name, argv[i]) &&
				!StrCmp(actions[j].db, argv[i+1])) {
			rc = actions[j].handler(systab, image, argc-i, argv+i);
			break;
		}
	}
	if (rc == EFI_UNSUPPORTED || rc == EFI_INVALID_PARAMETER)
		goto show_usage;

	if (EFI_ERROR(rc))
		Print(L"Error: %d\n", rc);
	return rc;
}

```

`util/shelliface.h`:

```h
#ifndef SHELLIFACE_H
#define SHELLIFACE_H 1

/* this whole file needs to be moved into gnu-efi */

#define EFI_SHELL_INTERFACE_GUID \
 { 0x47c7b223, 0xc42a, 0x11d2, {0x8e,0x57,0x00,0xa0,0xc9,0x69,0x72,0x3b } }

typedef enum {
	ARG_NO_ATTRIB         = 0x0,
	ARG_IS_QUOTED         = 0x1,
	ARG_PARTIALLY_QUOTED  = 0x2,
	ARG_FIRST_HALF_QUOTED = 0x4,
	ARG_FIRST_CHAR_IS_ESC = 0x8
} EFI_SHELL_ARG_INFO_TYPES;

struct _EFI_SHELL_ARG_INFO {
	UINT32 Attributes;
} PACKED ALIGNED(1);

typedef struct _EFI_SHELL_ARG_INFO EFI_SHELL_ARG_INFO;

struct _EFI_SHELL_INTERFACE {
	EFI_HANDLE		ImageHandle;
	EFI_LOADED_IMAGE	*Info;

	CHAR16			**Argv;
	UINTN			Argc;

	CHAR16			**RedirArgv;
	UINTN			RedirArgc;

	EFI_FILE		*StdIn;
	EFI_FILE		*StdOut;
	EFI_FILE		*StdErr;

	EFI_SHELL_ARG_INFO	*ArgInfo;

	BOOLEAN			EchoOn;
} PACKED ALIGNED(1);

typedef struct _EFI_SHELL_INTERFACE EFI_SHELL_INTERFACE;

extern EFI_GUID gEfiShellInterfaceGuid;

#endif /* SHELLIFACE_H */

```