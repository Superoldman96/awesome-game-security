Project Path: arc_gmh5225_darken-anticheat_jcpvthch

Source Tree:

```txt
arc_gmh5225_darken-anticheat_jcpvthch
├── LICENSE
├── README.md
├── darken-anticheat.sln
├── global-shared
│   ├── communication_types.h
│   ├── generic_types.h
│   └── string_encryption.h
├── kernel
│   ├── darken-anticheat-kernel.inf
│   ├── darken-anticheat-kernel.vcxproj
│   ├── darken-anticheat-kernel.vcxproj.filters
│   ├── ext
│   │   ├── ia32
│   │   │   └── ia32.h
│   │   └── portable_executable
│   │       ├── data_directory.cpp
│   │       ├── data_directory.hpp
│   │       ├── dos_header.cpp
│   │       ├── dos_header.hpp
│   │       ├── export_directory.cpp
│   │       ├── export_directory.hpp
│   │       ├── file_header.hpp
│   │       ├── image.cpp
│   │       ├── image.hpp
│   │       ├── imports_directory.cpp
│   │       ├── imports_directory.hpp
│   │       ├── nt_headers.cpp
│   │       ├── nt_headers.hpp
│   │       ├── optional_header.hpp
│   │       ├── pe_crt
│   │       │   ├── crt_memory.cpp
│   │       │   ├── crt_memory.hpp
│   │       │   ├── crt_string.cpp
│   │       │   ├── crt_string.hpp
│   │       │   ├── crt_type_traits.hpp
│   │       │   └── crt_types.hpp
│   │       ├── relocations_directory.cpp
│   │       ├── relocations_directory.hpp
│   │       └── section_header.hpp
│   └── src
│       ├── context
│       │   ├── context.cpp
│       │   └── context.h
│       ├── crypto
│       │   ├── crypto.cpp
│       │   ├── crypto.h
│       │   └── crypto_def.h
│       ├── detections
│       │   ├── handles
│       │   │   ├── permission_stripping.cpp
│       │   │   └── permission_stripping.h
│       │   ├── hypervisor
│       │   │   ├── reserved_msr_usage.cpp
│       │   │   └── reserved_msr_usage.h
│       │   ├── integrity
│       │   │   ├── data_section_integrity.cpp
│       │   │   ├── data_section_integrity.h
│       │   │   ├── integrity.cpp
│       │   │   └── integrity.h
│       │   ├── patchguard
│       │   │   ├── patchguard.h
│       │   │   └── patchguard_assembler.asm
│       │   ├── process
│       │   │   ├── process_thread.cpp
│       │   │   └── process_thread.h
│       │   └── system
│       │       ├── non_maskable_interrupts.cpp
│       │       ├── non_maskable_interrupts.h
│       │       ├── system_thread.cpp
│       │       └── system_thread.h
│       ├── imports
│       │   ├── imports.cpp
│       │   ├── imports.h
│       │   └── imports_def.h
│       ├── log.h
│       ├── main.cpp
│       ├── memory
│       │   ├── memory.cpp
│       │   ├── memory.h
│       │   ├── page_tables.cpp
│       │   ├── page_tables.h
│       │   └── page_tables_def.h
│       ├── offsets
│       │   ├── offsets.cpp
│       │   └── offsets.h
│       ├── os
│       │   ├── callbacks
│       │   │   └── handles
│       │   │       ├── handles.cpp
│       │   │       └── handles.h
│       │   ├── hvl
│       │   │   ├── enlightenments.cpp
│       │   │   └── enlightenments.h
│       │   └── ntkrnl
│       │       ├── ntkrnl.cpp
│       │       └── ntkrnl.h
│       └── structures
│           ├── _peb.h
│           ├── kaffinity_ex.h
│           ├── kldr_data_table_entry.h
│           ├── ldr_data_table_entry.h
│           ├── ldr_dll_load_reason.h
│           ├── machine_frame.h
│           ├── peb_ldr_data.h
│           └── virtual_address.h
├── protected-process
│   ├── darken-anticheat-protected-process.vcxproj
│   ├── darken-anticheat-protected-process.vcxproj.filters
│   └── src
│       └── main.cpp
├── user-process
│   ├── darken-anticheat-user-process.vcxproj
│   ├── darken-anticheat-user-process.vcxproj.filters
│   ├── src
│   │   ├── main.cpp
│   │   └── protected_process
│   │       ├── protected_process.cpp
│   │       └── protected_process.h
│   └── vcpkg.json
└── user-shared
    ├── detections
    │   ├── anti_debug
    │   │   ├── anti_debug.cpp
    │   │   └── anti_debug.h
    │   ├── detections.h
    │   ├── hypervisor
    │   │   ├── hypervisor.cpp
    │   │   └── hypervisor.h
    │   ├── modules
    │   │   ├── modules.cpp
    │   │   └── modules.h
    │   ├── patchguard
    │   │   ├── patchguard.cpp
    │   │   └── patchguard.h
    │   ├── process
    │   │   ├── process.cpp
    │   │   └── process.h
    │   └── threads
    │       ├── threads.cpp
    │       └── threads.h
    ├── driver
    │   ├── driver.cpp
    │   └── driver.h
    ├── imports.h
    └── utilities
        ├── datatype
        │   ├── datatype.cpp
        │   └── datatype.h
        ├── filesystem
        │   ├── filesystem.cpp
        │   └── filesystem.h
        ├── pe
        │   ├── pe.cpp
        │   └── pe.h
        └── system
            ├── system.cpp
            ├── system.h
            └── system_def.h

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    Darken Anticheat
    Copyright (C) 2023 noahswtf

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    Darken Anticheat Copyright (C) 2023 noahswtf
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`README.md`:

```md
# Darken Anticheat
Open source anticheat for protecting your software against tampering and reverse engineering.

# What does the anti-cheat do?

The anti-cheat monitors both the operating system's kernel as well as the protected usermode processes to find any illegitimate code execution or tampering. The ways in which the anti-cheat does so are described below.

# Current features
- Detects loaded dlls which are not digitally signed.
- Detects loaded kernel modules which are not digitally signed.
- Strips permissions of handles that are attempted to be opened to any of our protected processes.
- Detects system threads which have a start address outside of any legitimate kernel module.
- Detects system threads which are attached to any of our protected processes.
- Detects process threads which have a start address outside of any legitimate module in the respective protected process.
- Detects debugger being attached via the PEB's `BeingDebugged` byte.
- Force-triggering PatchGuard (KPP) checks to run (causes bugcheck to occur if there are any violations of PatchGuard's checks).
- Causing bugcheck if PatchGuard (KPP) is disabled / has an invalid context.
- Checking usage of reserved MSRs (model specific registers).
- Sending non maskable interrupts and analyzing the rip to detect execution outside of valid kernel modules.
- Resolving all of our driver imports manually.
- Integrity check of ntoskrnl's .text section.
- Integrity check of rest of kernel drivers' .text section.
- Detects all kernel modules' data sections' PTEs being set to executable.

# Windows versions supported

I have tested the anticheat on Windows 10 22H2 and Windows 11 24H2, but I have implemented offsets for each build from Windows 10 1507 -> Windows 11 24H2, so the anticheat should in theory function for all the Windows 10 and Windows 11 versions currently released to the public.

# Credits
- [papstuc](https://github.com/papstuc) for the [nocrt portable executable library used](https://github.com/papstuc/nocrt_portable_executable).
- [jonomango](https://github.com/jonomango), [Satoshi Tanda](https://github.com/tandasat), and [Petr Beneš](https://github.com/wbenny) for their contributions to the [ia32-doc](https://github.com/tandasat/ia32-doc) project.

# Licensing
This project has been placed under the [GNU General Public License](LICENSE), if there are any specific enquiries regarding usage, please contact the founder of the project [noahware](https://github.com/noahware).
```

`darken-anticheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33723.286
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "darken-anticheat-kernel", "kernel\darken-anticheat-kernel.vcxproj", "{1764A165-33D4-4F60-A56D-1705C2774009}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "darken-anticheat-user-process", "user-process\darken-anticheat-user-process.vcxproj", "{B7F6045D-9539-42C1-90AD-0876124E489D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "darken-anticheat-protected-process", "protected-process\darken-anticheat-protected-process.vcxproj", "{883E7FCB-4C56-455E-8E43-1A8C408F0E49}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM.ActiveCfg = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM.Build.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM.Deploy.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM64.Build.0 = Debug|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x64.ActiveCfg = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x64.Build.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x64.Deploy.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x86.ActiveCfg = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x86.Build.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Debug|x86.Deploy.0 = Debug|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM.ActiveCfg = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM.Build.0 = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM.Deploy.0 = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM64.ActiveCfg = Release|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM64.Build.0 = Release|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|ARM64.Deploy.0 = Release|ARM64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x64.ActiveCfg = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x64.Build.0 = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x64.Deploy.0 = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x86.ActiveCfg = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x86.Build.0 = Release|x64
		{1764A165-33D4-4F60-A56D-1705C2774009}.Release|x86.Deploy.0 = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|ARM.ActiveCfg = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|ARM.Build.0 = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|ARM64.ActiveCfg = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|ARM64.Build.0 = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|x64.ActiveCfg = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|x64.Build.0 = Debug|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|x86.ActiveCfg = Debug|Win32
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Debug|x86.Build.0 = Debug|Win32
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|ARM.ActiveCfg = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|ARM.Build.0 = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|ARM64.ActiveCfg = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|ARM64.Build.0 = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|x64.ActiveCfg = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|x64.Build.0 = Release|x64
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|x86.ActiveCfg = Release|Win32
		{B7F6045D-9539-42C1-90AD-0876124E489D}.Release|x86.Build.0 = Release|Win32
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|ARM.ActiveCfg = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|ARM.Build.0 = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|ARM64.ActiveCfg = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|ARM64.Build.0 = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|x64.ActiveCfg = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|x64.Build.0 = Debug|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|x86.ActiveCfg = Debug|Win32
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Debug|x86.Build.0 = Debug|Win32
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|ARM.ActiveCfg = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|ARM.Build.0 = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|ARM64.ActiveCfg = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|ARM64.Build.0 = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|x64.ActiveCfg = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|x64.Build.0 = Release|x64
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|x86.ActiveCfg = Release|Win32
		{883E7FCB-4C56-455E-8E43-1A8C408F0E49}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {46D179DF-CD9D-4F15-A172-C88934543FBC}
	EndGlobalSection
EndGlobal

```

`global-shared/communication_types.h`:

```h
#pragma once

#ifdef _DARKEN_KERNEL
#include "generic_types.h"
#else
#include <cstdint>
#endif

namespace communication
{
	struct s_protected_processes
	{
		uint64_t anticheat_usermode_id;
		uint64_t protected_process_id;
	};

	struct s_is_suspicious_process_thread_present
	{
		uint64_t process_id;
	};

	enum e_control_code : uint32_t
	{
		test = 1,
		initialise_protected_processes,
		is_suspicious_system_thread_present,
		is_suspicious_process_thread_present,
		check_reserved_msr_usage,
		trigger_patchguard_bugcheck,
		send_and_analyze_non_maskable_interrupts,
		validate_ntoskrnl_integrity,
		validate_kernel_drivers_integrity,
		is_any_driver_data_section_executable
	};

	enum class e_detection_status : uint8_t
	{
		runtime_error,
		flagged,
		clean
	};

	struct s_call_info
	{
		e_detection_status detection_status = e_detection_status::runtime_error;

		union
		{
			s_protected_processes protected_processes = { };
			s_is_suspicious_process_thread_present is_suspicious_process_thread_present;
		};
	};
}

```

`global-shared/generic_types.h`:

```h
#pragma once

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
typedef unsigned short wchar_t;

```

`global-shared/string_encryption.h`:

```h
#pragma once

// todo; implement
#define d_encrypt_string(s) s

```

`kernel/darken-anticheat-kernel.inf`:

```inf
;
; darken-anticheat-kernel.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=darken-anticheat-kernel.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
darken-anticheat-kernel_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
darken-anticheat-kernel.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%darken-anticheat-kernel.DeviceDesc%=darken-anticheat-kernel_Device, Root\darken-anticheat-kernel ; TODO: edit hw-id

[darken-anticheat-kernel_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
darken-anticheat-kernel.sys

;-------------- Service installation
[darken-anticheat-kernel_Device.NT.Services]
AddService = darken-anticheat-kernel,%SPSVCINST_ASSOCSERVICE%, darken-anticheat-kernel_Service_Inst

; -------------- darken-anticheat-kernel driver install sections
[darken-anticheat-kernel_Service_Inst]
DisplayName    = %darken-anticheat-kernel.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\darken-anticheat-kernel.sys

;
;--- darken-anticheat-kernel_Device Coinstaller installation ------
;

[darken-anticheat-kernel_Device.NT.CoInstallers]
AddReg=darken-anticheat-kernel_Device_CoInstaller_AddReg
CopyFiles=darken-anticheat-kernel_Device_CoInstaller_CopyFiles

[darken-anticheat-kernel_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[darken-anticheat-kernel_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[darken-anticheat-kernel_Device.NT.Wdf]
KmdfService =  darken-anticheat-kernel, darken-anticheat-kernel_wdfsect
[darken-anticheat-kernel_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "darken-anticheat-kernel Installation Disk"
darken-anticheat-kernel.DeviceDesc = "darken-anticheat-kernel Device"
darken-anticheat-kernel.SVCDESC = "darken-anticheat-kernel Service"

```

`kernel/darken-anticheat-kernel.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1764A165-33D4-4F60-A56D-1705C2774009}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>darken_anticheat_kernel</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(SolutionDir)global-shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(SolutionDir)global-shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;DEBUG;_DARKEN_KERNEL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;_DARKEN_KERNEL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="darken-anticheat-kernel.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ext\portable_executable\data_directory.cpp" />
    <ClCompile Include="ext\portable_executable\dos_header.cpp" />
    <ClCompile Include="ext\portable_executable\export_directory.cpp" />
    <ClCompile Include="ext\portable_executable\image.cpp" />
    <ClCompile Include="ext\portable_executable\imports_directory.cpp" />
    <ClCompile Include="ext\portable_executable\nt_headers.cpp" />
    <ClCompile Include="ext\portable_executable\pe_crt\crt_memory.cpp" />
    <ClCompile Include="ext\portable_executable\pe_crt\crt_string.cpp" />
    <ClCompile Include="ext\portable_executable\relocations_directory.cpp" />
    <ClCompile Include="src\context\context.cpp" />
    <ClCompile Include="src\crypto\crypto.cpp" />
    <ClCompile Include="src\detections\handles\permission_stripping.cpp" />
    <ClCompile Include="src\detections\hypervisor\reserved_msr_usage.cpp" />
    <ClCompile Include="src\detections\integrity\integrity.cpp" />
    <ClCompile Include="src\detections\integrity\data_section_integrity.cpp" />
    <ClCompile Include="src\detections\system\non_maskable_interrupts.cpp" />
    <ClCompile Include="src\imports\imports.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\memory\memory.cpp" />
    <ClCompile Include="src\memory\page_tables.cpp" />
    <ClCompile Include="src\offsets\offsets.cpp" />
    <ClCompile Include="src\detections\process\process_thread.cpp" />
    <ClCompile Include="src\detections\system\system_thread.cpp" />
    <ClCompile Include="src\os\callbacks\handles\handles.cpp" />
    <ClCompile Include="src\os\hvl\enlightenments.cpp" />
    <ClCompile Include="src\os\ntkrnl\ntkrnl.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ext\ia32\ia32.h" />
    <ClInclude Include="ext\portable_executable\data_directory.hpp" />
    <ClInclude Include="ext\portable_executable\dos_header.hpp" />
    <ClInclude Include="ext\portable_executable\export_directory.hpp" />
    <ClInclude Include="ext\portable_executable\file_header.hpp" />
    <ClInclude Include="ext\portable_executable\image.hpp" />
    <ClInclude Include="ext\portable_executable\imports_directory.hpp" />
    <ClInclude Include="ext\portable_executable\nt_headers.hpp" />
    <ClInclude Include="ext\portable_executable\optional_header.hpp" />
    <ClInclude Include="ext\portable_executable\pe_crt\crt_memory.hpp" />
    <ClInclude Include="ext\portable_executable\pe_crt\crt_string.hpp" />
    <ClInclude Include="ext\portable_executable\pe_crt\crt_types.hpp" />
    <ClInclude Include="ext\portable_executable\pe_crt\crt_type_traits.hpp" />
    <ClInclude Include="ext\portable_executable\relocations_directory.hpp" />
    <ClInclude Include="ext\portable_executable\section_header.hpp" />
    <ClInclude Include="src\context\context.h" />
    <ClInclude Include="src\crypto\crypto.h" />
    <ClInclude Include="src\crypto\crypto_def.h" />
    <ClInclude Include="src\detections\handles\permission_stripping.h" />
    <ClInclude Include="src\detections\hypervisor\reserved_msr_usage.h" />
    <ClInclude Include="src\detections\integrity\integrity.h" />
    <ClInclude Include="src\detections\integrity\data_section_integrity.h" />
    <ClInclude Include="src\detections\system\non_maskable_interrupts.h" />
    <ClInclude Include="src\imports\imports.h" />
    <ClInclude Include="src\imports\imports_def.h" />
    <ClInclude Include="src\log.h" />
    <ClInclude Include="src\memory\memory.h" />
    <ClInclude Include="src\memory\page_tables.h" />
    <ClInclude Include="src\memory\page_tables_def.h" />
    <ClInclude Include="src\offsets\offsets.h" />
    <ClInclude Include="src\detections\patchguard\patchguard.h" />
    <ClInclude Include="src\detections\process\process_thread.h" />
    <ClInclude Include="src\os\callbacks\handles\handles.h" />
    <ClInclude Include="src\os\hvl\enlightenments.h" />
    <ClInclude Include="src\structures\kaffinity_ex.h" />
    <ClInclude Include="src\structures\kldr_data_table_entry.h" />
    <ClInclude Include="src\structures\machine_frame.h" />
    <ClInclude Include="src\structures\virtual_address.h" />
    <ClInclude Include="src\structures\ldr_data_table_entry.h" />
    <ClInclude Include="src\structures\ldr_dll_load_reason.h" />
    <ClInclude Include="src\structures\peb_ldr_data.h" />
    <ClInclude Include="src\structures\_peb.h" />
    <ClInclude Include="src\detections\system\system_thread.h" />
    <ClInclude Include="src\os\ntkrnl\ntkrnl.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\detections\patchguard\patchguard_assembler.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`kernel/darken-anticheat-kernel.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="darken-anticheat-kernel.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\handles\permission_stripping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\system\system_thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\os\ntkrnl\ntkrnl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\offsets\offsets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\process\process_thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\hypervisor\reserved_msr_usage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\pe_crt\crt_memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\pe_crt\crt_string.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\data_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\dos_header.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\export_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\image.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\imports_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\nt_headers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\relocations_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\imports\imports.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\context\context.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\crypto\crypto.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\memory\page_tables.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\memory\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\system\non_maskable_interrupts.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\os\hvl\enlightenments.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\integrity\integrity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\os\callbacks\handles\handles.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\detections\integrity\data_section_integrity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\detections\handles\permission_stripping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\system\system_thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\os\ntkrnl\ntkrnl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\offsets\offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\kldr_data_table_entry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\patchguard\patchguard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\process\process_thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\_peb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\peb_ldr_data.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\ldr_data_table_entry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\ldr_dll_load_reason.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\hypervisor\reserved_msr_usage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\pe_crt\crt_memory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\pe_crt\crt_string.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\pe_crt\crt_type_traits.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\pe_crt\crt_types.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\data_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\dos_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\export_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\file_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\image.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\imports_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\nt_headers.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\optional_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\relocations_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\section_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\imports\imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\context\context.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\crypto\crypto.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\imports\imports_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\memory\page_tables.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\ia32\ia32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\memory\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\virtual_address.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\system\non_maskable_interrupts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\kaffinity_ex.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\machine_frame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\os\hvl\enlightenments.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\memory\page_tables_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\crypto\crypto_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\integrity\integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\os\callbacks\handles\handles.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\detections\integrity\data_section_integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\detections\patchguard\patchguard_assembler.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`kernel/ext/ia32/ia32.h`:

```h
#pragma once
#include <generic_types.h>

#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

/**
 * @defgroup intel_manual \
 *           Intel Manual
 * @{
 */
 /**
  * @defgroup control_registers \
  *           Control registers
  * @{
  */
typedef union {
    struct {
        uint64_t protection_enable : 1;
        uint64_t monitor_coprocessor : 1;
        uint64_t emulate_fpu : 1;
        uint64_t task_switched : 1;
        uint64_t extension_type : 1;
        uint64_t numeric_error : 1;
        uint64_t reserved_1 : 10;
        uint64_t write_protect : 1;
        uint64_t reserved_2 : 1;
        uint64_t alignment_mask : 1;
        uint64_t reserved_3 : 10;
        uint64_t not_write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t paging_enable : 1;
    };

    uint64_t flags;
} cr0;

typedef union {
    struct {
        uint64_t reserved_1 : 3;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t reserved_2 : 7;
        uint64_t address_of_page_directory : 36;
    };

    uint64_t flags;
} cr3;

typedef union {
    struct {
        uint64_t virtual_mode_extensions : 1;
        uint64_t protected_mode_virtual_interrupts : 1;
        uint64_t timestamp_disable : 1;
        uint64_t debugging_extensions : 1;
        uint64_t page_size_extensions : 1;
        uint64_t physical_address_extension : 1;
        uint64_t machine_check_enable : 1;
        uint64_t page_global_enable : 1;
        uint64_t performance_monitoring_counter_enable : 1;
        uint64_t os_fxsave_fxrstor_support : 1;
        uint64_t os_xmm_exception_support : 1;
        uint64_t usermode_instruction_prevention : 1;
        uint64_t linear_addresses_57_bit : 1;
        uint64_t vmx_enable : 1;
        uint64_t smx_enable : 1;
        uint64_t reserved_1 : 1;
        uint64_t fsgsbase_enable : 1;
        uint64_t pcid_enable : 1;
        uint64_t os_xsave : 1;
        uint64_t key_locker_enable : 1;
        uint64_t smep_enable : 1;
        uint64_t smap_enable : 1;
        uint64_t protection_key_enable : 1;
        uint64_t control_flow_enforcement_enable : 1;
        uint64_t protection_key_for_supervisor_mode_enable : 1;
    };

    uint64_t flags;
} cr4;

typedef union {
    struct {
        uint64_t task_priority_level : 4;
        uint64_t reserved : 60;
    };

    uint64_t flags;
} cr8;

/**
 * @}
 */

 /**
  * @defgroup debug_registers \
  *           Debug registers
  * @{
  */
typedef union {
    struct {
        uint64_t breakpoint_condition : 4;
        uint64_t reserved_1 : 9;
        uint64_t debug_register_access_detected : 1;
        uint64_t single_instruction : 1;
        uint64_t task_switch : 1;
        uint64_t restricted_transactional_memory : 1;
    };

    uint64_t flags;
} dr6;

typedef union {
    struct {
        uint64_t local_breakpoint_0 : 1;
        uint64_t global_breakpoint_0 : 1;
        uint64_t local_breakpoint_1 : 1;
        uint64_t global_breakpoint_1 : 1;
        uint64_t local_breakpoint_2 : 1;
        uint64_t global_breakpoint_2 : 1;
        uint64_t local_breakpoint_3 : 1;
        uint64_t global_breakpoint_3 : 1;
        uint64_t local_exact_breakpoint : 1;
        uint64_t global_exact_breakpoint : 1;
        uint64_t reserved_1 : 1;
        uint64_t restricted_transactional_memory : 1;
        uint64_t reserved_2 : 1;
        uint64_t general_detect : 1;
        uint64_t reserved_3 : 2;
        uint64_t read_write_0 : 2;
        uint64_t length_0 : 2;
        uint64_t read_write_1 : 2;
        uint64_t length_1 : 2;
        uint64_t read_write_2 : 2;
        uint64_t length_2 : 2;
        uint64_t read_write_3 : 2;
        uint64_t length_3 : 2;
    };

    uint64_t flags;
} dr7;

/**
 * @}
 */

 /**
  * @defgroup cpuid \
  *           CPUID
  * @{
  */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct {
    uint32_t max_cpuid_input_value;
    uint32_t ebx_value_genu;
    uint32_t ecx_value_ntel;
    uint32_t edx_value_inei;
} cpuid_eax_00;

#define CPUID_VERSION_INFO                                           0x00000001
typedef struct {
    union {
        struct {
            uint32_t stepping_id : 4;
            uint32_t model : 4;
            uint32_t family_id : 4;
            uint32_t processor_type : 2;
            uint32_t reserved_1 : 2;
            uint32_t extended_model_id : 4;
            uint32_t extended_family_id : 8;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t brand_index : 8;
            uint32_t clflush_line_size : 8;
            uint32_t max_addressable_ids : 8;
            uint32_t initial_apic_id : 8;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t streaming_simd_extensions_3 : 1;
            uint32_t pclmulqdq_instruction : 1;
            uint32_t ds_area_64bit_layout : 1;
            uint32_t monitor_mwait_instruction : 1;
            uint32_t cpl_qualified_debug_store : 1;
            uint32_t virtual_machine_extensions : 1;
            uint32_t safer_mode_extensions : 1;
            uint32_t enhanced_intel_speedstep_technology : 1;
            uint32_t thermal_monitor_2 : 1;
            uint32_t supplemental_streaming_simd_extensions_3 : 1;
            uint32_t l1_context_id : 1;
            uint32_t silicon_debug : 1;
            uint32_t fma_extensions : 1;
            uint32_t cmpxchg16b_instruction : 1;
            uint32_t xtpr_update_control : 1;
            uint32_t perfmon_and_debug_capability : 1;
            uint32_t reserved_1 : 1;
            uint32_t process_context_identifiers : 1;
            uint32_t direct_cache_access : 1;
            uint32_t sse41_support : 1;
            uint32_t sse42_support : 1;
            uint32_t x2apic_support : 1;
            uint32_t movbe_instruction : 1;
            uint32_t popcnt_instruction : 1;
            uint32_t tsc_deadline : 1;
            uint32_t aesni_instruction_extensions : 1;
            uint32_t xsave_xrstor_instruction : 1;
            uint32_t osx_save : 1;
            uint32_t avx_support : 1;
            uint32_t half_precision_conversion_instructions : 1;
            uint32_t rdrand_instruction : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t floating_point_unit_on_chip : 1;
            uint32_t virtual_8086_mode_enhancements : 1;
            uint32_t debugging_extensions : 1;
            uint32_t page_size_extension : 1;
            uint32_t timestamp_counter : 1;
            uint32_t rdmsr_wrmsr_instructions : 1;
            uint32_t physical_address_extension : 1;
            uint32_t machine_check_exception : 1;
            uint32_t cmpxchg8b_instruction : 1;
            uint32_t apic_on_chip : 1;
            uint32_t reserved_1 : 1;
            uint32_t sysenter_sysexit_instructions : 1;
            uint32_t memory_type_range_registers : 1;
            uint32_t page_global_bit : 1;
            uint32_t machine_check_architecture : 1;
            uint32_t conditional_move_instructions : 1;
            uint32_t page_attribute_table : 1;
            uint32_t page_size_extension_36bit : 1;
            uint32_t processor_serial_number : 1;
            uint32_t clflush_instruction : 1;
            uint32_t reserved_2 : 1;
            uint32_t debug_store : 1;
            uint32_t thermal_control_msrs_for_acpi : 1;
            uint32_t mmx_support : 1;
            uint32_t fxsave_fxrstor_instructions : 1;
            uint32_t sse_support : 1;
            uint32_t sse2_support : 1;
            uint32_t self_snoop : 1;
            uint32_t hyper_threading_technology : 1;
            uint32_t thermal_monitor : 1;
            uint32_t reserved_3 : 1;
            uint32_t pending_break_enable : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_01;

#define CPUID_CACHE_PARAMS                                           0x00000004
typedef struct {
    union {
        struct {
            uint32_t cache_type_field : 5;
            uint32_t cache_level : 3;
            uint32_t self_initializing_cache_level : 1;
            uint32_t fully_associative_cache : 1;
            uint32_t reserved_1 : 4;
            uint32_t max_addressable_ids_for_logical_processors_sharing_this_cache : 12;
            uint32_t max_addressable_ids_for_processor_cores_in_physical_package : 6;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t system_coherency_line_size : 12;
            uint32_t physical_line_partitions : 10;
            uint32_t ways_of_associativity : 10;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t number_of_sets : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t write_back_invalidate : 1;
            uint32_t cache_inclusiveness : 1;
            uint32_t complex_cache_indexing : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_04;

#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct {
    union {
        struct {
            uint32_t smallest_monitor_line_size : 16;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t largest_monitor_line_size : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t enumeration_of_monitor_mwait_extensions : 1;
            uint32_t supports_treating_interrupts_as_break_event_for_mwait : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t number_of_c0_sub_c_states : 4;
            uint32_t number_of_c1_sub_c_states : 4;
            uint32_t number_of_c2_sub_c_states : 4;
            uint32_t number_of_c3_sub_c_states : 4;
            uint32_t number_of_c4_sub_c_states : 4;
            uint32_t number_of_c5_sub_c_states : 4;
            uint32_t number_of_c6_sub_c_states : 4;
            uint32_t number_of_c7_sub_c_states : 4;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_05;

#define CPUID_THERMAL_POWER_MANAGEMENT                               0x00000006
typedef struct {
    union {
        struct {
            uint32_t temperature_sensor_supported : 1;
            uint32_t intel_turbo_boost_technology_available : 1;
            uint32_t apic_timer_always_running : 1;
            uint32_t reserved_1 : 1;
            uint32_t power_limit_notification : 1;
            uint32_t clock_modulation_duty : 1;
            uint32_t package_thermal_management : 1;
            uint32_t hwp_base_registers : 1;
            uint32_t hwp_notification : 1;
            uint32_t hwp_activity_window : 1;
            uint32_t hwp_energy_performance_preference : 1;
            uint32_t hwp_package_level_request : 1;
            uint32_t reserved_2 : 1;
            uint32_t hdc : 1;
            uint32_t intel_turbo_boost_max_technology_3_available : 1;
            uint32_t hwp_capabilities : 1;
            uint32_t hwp_peci_override : 1;
            uint32_t flexible_hwp : 1;
            uint32_t fast_access_mode_for_hwp_request_msr : 1;
            uint32_t reserved_3 : 1;
            uint32_t ignoring_idle_logical_processor_hwp_request : 1;
            uint32_t reserved_4 : 2;
            uint32_t intel_thread_director : 1;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t number_of_interrupt_thresholds_in_thermal_sensor : 4;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t hardware_coordination_feedback_capability : 1;
            uint32_t reserved_1 : 2;
            uint32_t number_of_intel_thread_director_classes : 1;
            uint32_t reserved_2 : 4;
            uint32_t performance_energy_bias_preference : 8;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_06;

#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct {
    union {
        struct {
            uint32_t number_of_sub_leaves : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t fsgsbase : 1;
            uint32_t ia32_tsc_adjust_msr : 1;
            uint32_t sgx : 1;
            uint32_t bmi1 : 1;
            uint32_t hle : 1;
            uint32_t avx2 : 1;
            uint32_t fdp_excptn_only : 1;
            uint32_t smep : 1;
            uint32_t bmi2 : 1;
            uint32_t enhanced_rep_movsb_stosb : 1;
            uint32_t invpcid : 1;
            uint32_t rtm : 1;
            uint32_t rdt_m : 1;
            uint32_t deprecates : 1;
            uint32_t mpx : 1;
            uint32_t rdt : 1;
            uint32_t avx512f : 1;
            uint32_t avx512dq : 1;
            uint32_t rdseed : 1;
            uint32_t adx : 1;
            uint32_t smap : 1;
            uint32_t avx512_ifma : 1;
            uint32_t reserved_1 : 1;
            uint32_t clflushopt : 1;
            uint32_t clwb : 1;
            uint32_t intel : 1;
            uint32_t avx512pf : 1;
            uint32_t avx512er : 1;
            uint32_t avx512cd : 1;
            uint32_t sha : 1;
            uint32_t avx512bw : 1;
            uint32_t avx512vl : 1;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t prefetchwt1 : 1;
            uint32_t avx512_vbmi : 1;
            uint32_t umip : 1;
            uint32_t pku : 1;
            uint32_t ospke : 1;
            uint32_t waitpkg : 1;
            uint32_t avx512_vbmi2 : 1;
            uint32_t cet_ss : 1;
            uint32_t gfni : 1;
            uint32_t vaes : 1;
            uint32_t vpclmulqdq : 1;
            uint32_t avx512_vnni : 1;
            uint32_t avx512_bitalg : 1;
            uint32_t tme_en : 1;
            uint32_t avx512_vpopcntdq : 1;
            uint32_t reserved_1 : 1;
            uint32_t la57 : 1;
            uint32_t mawau : 5;
            uint32_t rdpid : 1;
            uint32_t kl : 1;
            uint32_t reserved_2 : 1;
            uint32_t cldemote : 1;
            uint32_t reserved_3 : 1;
            uint32_t movdiri : 1;
            uint32_t movdir64b : 1;
            uint32_t reserved_4 : 1;
            uint32_t sgx_lc : 1;
            uint32_t pks : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved_1 : 2;
            uint32_t avx512_4vnniw : 1;
            uint32_t avx512_4fmaps : 1;
            uint32_t fast_short_rep_mov : 1;
            uint32_t reserved_2 : 3;
            uint32_t avx512_vp2intersect : 1;
            uint32_t reserved_3 : 1;
            uint32_t md_clear : 1;
            uint32_t reserved_4 : 3;
            uint32_t serialize : 1;
            uint32_t hybrid : 1;
            uint32_t reserved_5 : 2;
            uint32_t pconfig : 1;
            uint32_t reserved_6 : 1;
            uint32_t cet_ibt : 1;
            uint32_t reserved_7 : 5;
            uint32_t ibrs_ibpb : 1;
            uint32_t stibp : 1;
            uint32_t l1d_flush : 1;
            uint32_t ia32_arch_capabilities : 1;
            uint32_t ia32_core_capabilities : 1;
            uint32_t ssbd : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_07;

#define CPUID_DIRECT_CACHE_ACCESS_INFO                               0x00000009
typedef struct {
    union {
        struct {
            uint32_t ia32_platform_dca_cap : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_09;

#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct {
    union {
        struct {
            uint32_t version_id_of_architectural_performance_monitoring : 8;
            uint32_t number_of_performance_monitoring_counter_per_logical_processor : 8;
            uint32_t bit_width_of_performance_monitoring_counter : 8;
            uint32_t ebx_bit_vector_length : 8;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t core_cycle_event_not_available : 1;
            uint32_t instruction_retired_event_not_available : 1;
            uint32_t reference_cycles_event_not_available : 1;
            uint32_t last_level_cache_reference_event_not_available : 1;
            uint32_t last_level_cache_misses_event_not_available : 1;
            uint32_t branch_instruction_retired_event_not_available : 1;
            uint32_t branch_mispredict_retired_event_not_available : 1;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t number_of_fixed_function_performance_counters : 5;
            uint32_t bit_width_of_fixed_function_performance_counters : 8;
            uint32_t reserved_1 : 2;
            uint32_t any_thread_deprecation : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0a;

#define CPUID_EXTENDED_TOPOLOGY                                      0x0000000B
typedef struct {
    union {
        struct {
            uint32_t x2apic_id_to_unique_topology_id_shift : 5;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t number_of_logical_processors_at_this_level_type : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t level_number : 8;
            uint32_t level_type : 8;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t x2apic_id : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0b;

/**
 * @defgroup cpuid_eax_0d \
 *           EAX = 0x0D
 * @{
 */
#define CPUID_EXTENDED_STATE                                         0x0000000D
typedef struct {
    union {
        struct {
            uint32_t x87_state : 1;
            uint32_t sse_state : 1;
            uint32_t avx_state : 1;
            uint32_t mpx_state : 2;
            uint32_t avx_512_state : 3;
            uint32_t used_for_ia32_xss_1 : 1;
            uint32_t pkru_state : 1;
            uint32_t reserved_1 : 3;
            uint32_t used_for_ia32_xss_2 : 1;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t max_size_required_by_enabled_features_in_xcr0 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t max_size_of_xsave_xrstor_save_area : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t xcr0_supported_bits : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t reserved_1 : 1;
            uint32_t supports_xsavec_and_compacted_xrstor : 1;
            uint32_t supports_xgetbv_with_ecx_1 : 1;
            uint32_t supports_xsave_xrstor_and_ia32_xss : 1;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t size_of_xsave_aread : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t used_for_xcr0_1 : 8;
            uint32_t pt_state : 1;
            uint32_t used_for_xcr0_2 : 1;
            uint32_t reserved_1 : 1;
            uint32_t cet_user_state : 1;
            uint32_t cet_supervisor_state : 1;
            uint32_t hdc_state : 1;
            uint32_t reserved_2 : 1;
            uint32_t lbr_state : 1;
            uint32_t hwp_state : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t supported_upper_ia32_xss_bits : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_01;

typedef struct {
    union {
        struct {
            uint32_t ia32_platform_dca_cap : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t ecx_2 : 1;
            uint32_t ecx_1 : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_0f \
  *           EAX = 0x0F
  * @{
  */
#define CPUID_INTEL_RDT_MONITORING                                   0x0000000F
typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t rmid_max_range : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved_1 : 1;
            uint32_t supports_l3_cache_intel_rdt_monitoring : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0f_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t conversion_factor : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t rmid_max_range : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t supports_l3_occupancy_monitoring : 1;
            uint32_t supports_l3_total_bandwidth_monitoring : 1;
            uint32_t supports_l3_local_bandwidth_monitoring : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0f_ecx_01;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_10 \
  *           EAX = 0x10
  * @{
  */
#define CPUID_INTEL_RDT_ALLOCATION                                   0x00000010
typedef struct {
    union {
        struct {
            uint32_t ia32_platform_dca_cap : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved_1 : 1;
            uint32_t supports_l3_cache_allocation_technology : 1;
            uint32_t supports_l2_cache_allocation_technology : 1;
            uint32_t supports_memory_bandwidth_allocation : 1;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t length_of_capacity_bit_mask : 5;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t ebx_0 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved_1 : 2;
            uint32_t code_and_data_priorization_technology_supported : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t highest_cos_number_supported : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_01;

typedef struct {
    union {
        struct {
            uint32_t length_of_capacity_bit_mask : 5;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t ebx_0 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t highest_cos_number_supported : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_02;

typedef struct {
    union {
        struct {
            uint32_t max_mba_throttling_value : 12;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved_1 : 2;
            uint32_t response_of_delay_is_linear : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t highest_cos_number_supported : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_03;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_12 \
  *           EAX = 0x12
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
typedef struct {
    union {
        struct {
            uint32_t sgx1 : 1;
            uint32_t sgx2 : 1;
            uint32_t reserved_1 : 3;
            uint32_t sgx_enclv_advanced : 1;
            uint32_t sgx_encls_advanced : 1;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t miscselect : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t max_enclave_size_not64 : 8;
            uint32_t max_enclave_size_64 : 8;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t valid_secs_attributes_0 : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t valid_secs_attributes_1 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t valid_secs_attributes_2 : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t valid_secs_attributes_3 : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_01;

typedef struct {
    union {
        struct {
            uint32_t sub_leaf_type : 4;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t zero : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t zero : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t zero : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_0;

typedef struct {
    union {
        struct {
            uint32_t sub_leaf_type : 4;
            uint32_t reserved_1 : 8;
            uint32_t epc_base_physical_address_1 : 20;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t epc_base_physical_address_2 : 20;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t epc_section_property : 4;
            uint32_t reserved_1 : 8;
            uint32_t epc_size_1 : 20;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t epc_size_2 : 20;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_1;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_14 \
  *           EAX = 0x14
  * @{
  */
#define CPUID_INTEL_PROCESSOR_TRACE                                  0x00000014
typedef struct {
    union {
        struct {
            uint32_t max_sub_leaf : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t flag0 : 1;
            uint32_t flag1 : 1;
            uint32_t flag2 : 1;
            uint32_t flag3 : 1;
            uint32_t flag4 : 1;
            uint32_t flag5 : 1;
            uint32_t flag6 : 1;
            uint32_t flag7 : 1;
            uint32_t flag8 : 1;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t flag0 : 1;
            uint32_t flag1 : 1;
            uint32_t flag2 : 1;
            uint32_t flag3 : 1;
            uint32_t reserved_1 : 27;
            uint32_t flag31 : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_14_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t number_of_configurable_address_ranges_for_filtering : 3;
            uint32_t reserved_1 : 13;
            uint32_t bitmap_of_supported_mtc_period_encodings : 16;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t bitmap_of_supported_cycle_threshold_value_encodings : 16;
            uint32_t bitmap_of_supported_configurable_psb_frequency_encodings : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_14_ecx_01;

/**
 * @}
 */

#define CPUID_TIME_STAMP_COUNTER                                     0x00000015
typedef struct {
    union {
        struct {
            uint32_t denominator : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t numerator : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t nominal_frequency : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_15;

#define CPUID_PROCESSOR_FREQUENCY                                    0x00000016
typedef struct {
    union {
        struct {
            uint32_t procesor_base_frequency_mhz : 16;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t processor_maximum_frequency_mhz : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t bus_frequency_mhz : 16;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_16;

/**
 * @defgroup cpuid_eax_17 \
 *           EAX = 0x17
 * @{
 */
#define CPUID_SOC_VENDOR                                             0x00000017
typedef struct {
    union {
        struct {
            uint32_t max_soc_id_index : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t soc_vendor_id : 16;
            uint32_t is_vendor_scheme : 1;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t project_id : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t stepping_id : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t soc_vendor_brand_string : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t soc_vendor_brand_string : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t soc_vendor_brand_string : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t soc_vendor_brand_string : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_01_03;

typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_18 \
  *           EAX = 0x18
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS           0x00000018
typedef struct {
    union {
        struct {
            uint32_t max_sub_leaf : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t page_entries_4kb_supported : 1;
            uint32_t page_entries_2mb_supported : 1;
            uint32_t page_entries_4mb_supported : 1;
            uint32_t page_entries_1gb_supported : 1;
            uint32_t reserved_1 : 4;
            uint32_t partitioning : 3;
            uint32_t reserved_2 : 5;
            uint32_t ways_of_associativity_00 : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t number_of_sets : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t translation_cache_type_field : 5;
            uint32_t translation_cache_level : 3;
            uint32_t fully_associative_structure : 1;
            uint32_t reserved_1 : 5;
            uint32_t max_addressable_ids_for_logical_processors : 12;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_18_ecx_00;

typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t page_entries_4kb_supported : 1;
            uint32_t page_entries_2mb_supported : 1;
            uint32_t page_entries_4mb_supported : 1;
            uint32_t page_entries_1gb_supported : 1;
            uint32_t reserved_1 : 4;
            uint32_t partitioning : 3;
            uint32_t reserved_2 : 5;
            uint32_t ways_of_associativity_01 : 16;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t number_of_sets : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t translation_cache_type_field : 5;
            uint32_t translation_cache_level : 3;
            uint32_t fully_associative_structure : 1;
            uint32_t reserved_1 : 5;
            uint32_t max_addressable_ids_for_logical_processors : 12;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_18_ecx_01p;

/**
 * @}
 */

#define CPUID_EXTENDED_FUNCTION                                      0x80000000
typedef struct {
    union {
        struct {
            uint32_t max_extended_functions : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000000;

#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t lahf_sahf_available_in_64_bit_mode : 1;
            uint32_t reserved_1 : 4;
            uint32_t lzcnt : 1;
            uint32_t reserved_2 : 2;
            uint32_t prefetchw : 1;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved_1 : 11;
            uint32_t syscall_sysret_available_in_64_bit_mode : 1;
            uint32_t reserved_2 : 8;
            uint32_t execute_disable_bit_available : 1;
            uint32_t reserved_3 : 5;
            uint32_t pages_1gb_available : 1;
            uint32_t rdtscp_available : 1;
            uint32_t reserved_4 : 1;
            uint32_t ia64_available : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000001;

#define CPUID_BRAND_STRING1                                          0x80000002
#define CPUID_BRAND_STRING2                                          0x80000003
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct {
    union {
        struct {
            uint32_t processor_brand_string_1 : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t processor_brand_string_2 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t processor_brand_string_3 : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t processor_brand_string_4 : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000002;

typedef struct {
    union {
        struct {
            uint32_t processor_brand_string_5 : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t processor_brand_string_6 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t processor_brand_string_7 : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t processor_brand_string_8 : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000003;

typedef struct {
    union {
        struct {
            uint32_t processor_brand_string_9 : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t processor_brand_string_10 : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t processor_brand_string_11 : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t processor_brand_string_12 : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000004;

typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000005;

#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t cache_line_size_in_bytes : 8;
            uint32_t reserved_1 : 4;
            uint32_t l2_associativity_field : 4;
            uint32_t cache_size_in_1k_units : 16;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000006;

#define CPUID_EXTENDED_TIME_STAMP_COUNTER                            0x80000007
typedef struct {
    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved_1 : 8;
            uint32_t invariant_tsc_available : 1;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000007;

#define CPUID_EXTENDED_VIRT_PHYS_ADDRESS_SIZE                        0x80000008
typedef struct {
    union {
        struct {
            uint32_t number_of_physical_address_bits : 8;
            uint32_t number_of_linear_address_bits : 8;
        };

        uint32_t flags;
    } eax;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ebx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } ecx;

    union {
        struct {
            uint32_t reserved : 32;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000008;

/**
 * @}
 */

 /**
  * @defgroup model_specific_registers \
  *           Model Specific Registers
  * @{
  */
  /**
   * @defgroup ia32_p5_mc \
   *           IA32_P5_MC_(x)
   * @{
   */
#define IA32_P5_MC_ADDR                                              0x00000000
#define IA32_P5_MC_TYPE                                              0x00000001
   /**
    * @}
    */

#define IA32_MONITOR_FILTER_SIZE                                     0x00000006
#define IA32_TIME_STAMP_COUNTER                                      0x00000010
#define IA32_PLATFORM_ID                                             0x00000017
typedef union {
    struct {
        uint64_t reserved_1 : 50;
        uint64_t platform_id : 3;
    };

    uint64_t flags;
} ia32_platform_id_register;

#define IA32_APIC_BASE                                               0x0000001B
typedef union {
    struct {
        uint64_t reserved_1 : 8;
        uint64_t bsp_flag : 1;
        uint64_t reserved_2 : 1;
        uint64_t enable_x2apic_mode : 1;
        uint64_t apic_global_enable : 1;
        uint64_t apic_base : 36;
    };

    uint64_t flags;
} ia32_apic_base_register;

#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union {
    struct {
        uint64_t lock_bit : 1;
        uint64_t enable_vmx_inside_smx : 1;
        uint64_t enable_vmx_outside_smx : 1;
        uint64_t reserved_1 : 5;
        uint64_t senter_local_function_enables : 7;
        uint64_t senter_global_enable : 1;
        uint64_t reserved_2 : 1;
        uint64_t sgx_launch_control_enable : 1;
        uint64_t sgx_global_enable : 1;
        uint64_t reserved_3 : 1;
        uint64_t lmce_on : 1;
    };

    uint64_t flags;
} ia32_feature_control_register;

#define IA32_TSC_ADJUST                                              0x0000003B
typedef struct {
    uint64_t thread_adjust;
} ia32_tsc_adjust_register;

#define IA32_SPEC_CTRL                                               0x00000048
typedef union {
    struct {
        uint64_t ibrs : 1;
        uint64_t stibp : 1;
        uint64_t ssbd : 1;
    };

    uint64_t flags;
} ia32_spec_ctrl_register;

#define IA32_PRED_CMD                                                0x00000049
typedef union {
    struct {
        uint64_t ibpb : 1;
    };

    uint64_t flags;
} ia32_pred_cmd_register;

#define IA32_BIOS_UPDT_TRIG                                          0x00000079
#define IA32_BIOS_SIGN_ID                                            0x0000008B
typedef union {
    struct {
        uint64_t reserved : 32;
        uint64_t microcode_update_signature : 32;
    };

    uint64_t flags;
} ia32_bios_sign_id_register;

/**
 * @defgroup ia32_sgxlepubkeyhash \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */

#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union {
    struct {
        uint64_t valid : 1;
        uint64_t reserved_1 : 1;
        uint64_t smi_unblocking_by_vmxoff : 1;
        uint64_t reserved_2 : 9;
        uint64_t mseg_base : 20;
    };

    uint64_t flags;
} ia32_smm_monitor_ctl_register;

typedef struct {
    uint32_t mseg_header_revision;
    uint32_t monitor_features;

#define IA32_STM_FEATURES_IA32E                                      0x00000001
    uint32_t gdtr_limit;
    uint32_t gdtr_base_offset;
    uint32_t cs_selector;
    uint32_t eip_offset;
    uint32_t esp_offset;
    uint32_t cr3_offset;
} ia32_mseg_header;

#define IA32_SMBASE                                                  0x0000009E
/**
 * @defgroup ia32_pmc \
 *           IA32_PMC(n)
 * @{
 */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
 /**
  * @}
  */

#define IA32_MPERF                                                   0x000000E7
typedef struct {
    uint64_t c0_mcnt;
} ia32_mperf_register;

#define IA32_APERF                                                   0x000000E8
typedef struct {
    uint64_t c0_acnt;
} ia32_aperf_register;

#define IA32_MTRRCAP                                                 0x000000FE
typedef union {
    struct {
        uint64_t variable_range_registers_count : 8;
        uint64_t fixed_range_registers_supported : 1;
        uint64_t reserved_1 : 1;
        uint64_t write_combining : 1;
        uint64_t system_management_range_register : 1;
    };

    uint64_t flags;
} ia32_mtrrcap_register;

#define IA32_ARCH_CAPABILITIES                                       0x0000010A
typedef union {
    struct {
        uint64_t rdcl_no : 1;
        uint64_t ibrs_all : 1;
        uint64_t rsba : 1;
        uint64_t skip_l1dfl_vmentry : 1;
        uint64_t ssb_no : 1;
        uint64_t mds_no : 1;
        uint64_t if_pschange_mc_no : 1;
        uint64_t tsx_ctrl : 1;
        uint64_t taa_no : 1;
    };

    uint64_t flags;
} ia32_arch_capabilities_register;

#define IA32_FLUSH_CMD                                               0x0000010B
typedef union {
    struct {
        uint64_t l1d_flush : 1;
    };

    uint64_t flags;
} ia32_flush_cmd_register;

#define IA32_TSX_CTRL                                                0x00000122
typedef union {
    struct {
        uint64_t rtm_disable : 1;
        uint64_t tsx_cpuid_clear : 1;
    };

    uint64_t flags;
} ia32_tsx_ctrl_register;

#define IA32_SYSENTER_CS                                             0x00000174
typedef union {
    struct {
        uint64_t cs_selector : 16;
        uint64_t not_used_1 : 16;
        uint64_t not_used_2 : 32;
    };

    uint64_t flags;
} ia32_sysenter_cs_register;

#define IA32_SYSENTER_ESP                                            0x00000175
#define IA32_SYSENTER_EIP                                            0x00000176
#define IA32_MCG_CAP                                                 0x00000179
typedef union {
    struct {
        uint64_t count : 8;
        uint64_t mcg_ctl_p : 1;
        uint64_t mcg_ext_p : 1;
        uint64_t mcp_cmci_p : 1;
        uint64_t mcg_tes_p : 1;
        uint64_t reserved_1 : 4;
        uint64_t mcg_ext_cnt : 8;
        uint64_t mcg_ser_p : 1;
        uint64_t reserved_2 : 1;
        uint64_t mcg_elog_p : 1;
        uint64_t mcg_lmce_p : 1;
    };

    uint64_t flags;
} ia32_mcg_cap_register;

#define IA32_MCG_STATUS                                              0x0000017A
typedef union {
    struct {
        uint64_t ripv : 1;
        uint64_t eipv : 1;
        uint64_t mcip : 1;
        uint64_t lmce_s : 1;
    };

    uint64_t flags;
} ia32_mcg_status_register;

#define IA32_MCG_CTL                                                 0x0000017B
/**
 * @defgroup ia32_perfevtsel \
 *           IA32_PERFEVTSEL(n)
 * @{
 */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union {
    struct {
        uint64_t event_select : 8;
        uint64_t u_mask : 8;
        uint64_t usr : 1;
        uint64_t os : 1;
        uint64_t edge : 1;
        uint64_t pc : 1;
        uint64_t intr : 1;
        uint64_t any_thread : 1;
        uint64_t en : 1;
        uint64_t inv : 1;
        uint64_t cmask : 8;
    };

    uint64_t flags;
} ia32_perfevtsel_register;

/**
 * @}
 */

#define IA32_PERF_STATUS                                             0x00000198
typedef union {
    struct {
        uint64_t current_performance_state_value : 16;
    };

    uint64_t flags;
} ia32_perf_status_register;

#define IA32_PERF_CTL                                                0x00000199
typedef union {
    struct {
        uint64_t target_performance_state_value : 16;
        uint64_t reserved_1 : 16;
        uint64_t ida_engage : 1;
    };

    uint64_t flags;
} ia32_perf_ctl_register;

#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union {
    struct {
        uint64_t extended_on_demand_clock_modulation_duty_cycle : 1;
        uint64_t on_demand_clock_modulation_duty_cycle : 3;
        uint64_t on_demand_clock_modulation_enable : 1;
    };

    uint64_t flags;
} ia32_clock_modulation_register;

#define IA32_THERM_INTERRUPT                                         0x0000019B
typedef union {
    struct {
        uint64_t high_temperature_interrupt_enable : 1;
        uint64_t low_temperature_interrupt_enable : 1;
        uint64_t prochot_interrupt_enable : 1;
        uint64_t forcepr_interrupt_enable : 1;
        uint64_t critical_temperature_interrupt_enable : 1;
        uint64_t reserved_1 : 3;
        uint64_t threshold1_value : 7;
        uint64_t threshold1_interrupt_enable : 1;
        uint64_t threshold2_value : 7;
        uint64_t threshold2_interrupt_enable : 1;
        uint64_t power_limit_notification_enable : 1;
    };

    uint64_t flags;
} ia32_therm_interrupt_register;

#define IA32_THERM_STATUS                                            0x0000019C
typedef union {
    struct {
        uint64_t thermal_status : 1;
        uint64_t thermal_status_log : 1;
        uint64_t prochot_forcepr_event : 1;
        uint64_t prochot_forcepr_log : 1;
        uint64_t critical_temperature_status : 1;
        uint64_t critical_temperature_status_log : 1;
        uint64_t thermal_threshold1_status : 1;
        uint64_t thermal_threshold1_log : 1;
        uint64_t thermal_threshold2_status : 1;
        uint64_t thermal_threshold2_log : 1;
        uint64_t power_limitation_status : 1;
        uint64_t power_limitation_log : 1;
        uint64_t current_limit_status : 1;
        uint64_t current_limit_log : 1;
        uint64_t cross_domain_limit_status : 1;
        uint64_t cross_domain_limit_log : 1;
        uint64_t digital_readout : 7;
        uint64_t reserved_1 : 4;
        uint64_t resolution_in_degrees_celsius : 4;
        uint64_t reading_valid : 1;
    };

    uint64_t flags;
} ia32_therm_status_register;

#define IA32_MISC_ENABLE                                             0x000001A0
typedef union {
    struct {
        uint64_t fast_strings_enable : 1;
        uint64_t reserved_1 : 2;
        uint64_t automatic_thermal_control_circuit_enable : 1;
        uint64_t reserved_2 : 3;
        uint64_t performance_monitoring_available : 1;
        uint64_t reserved_3 : 3;
        uint64_t branch_trace_storage_unavailable : 1;
        uint64_t processor_event_based_sampling_unavailable : 1;
        uint64_t reserved_4 : 3;
        uint64_t enhanced_intel_speedstep_technology_enable : 1;
        uint64_t reserved_5 : 1;
        uint64_t enable_monitor_fsm : 1;
        uint64_t reserved_6 : 3;
        uint64_t limit_cpuid_maxval : 1;
        uint64_t xtpr_message_disable : 1;
        uint64_t reserved_7 : 10;
        uint64_t xd_bit_disable : 1;
    };

    uint64_t flags;
} ia32_misc_enable_register;

#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union {
    struct {
        uint64_t power_policy_preference : 4;
    };

    uint64_t flags;
} ia32_energy_perf_bias_register;

#define IA32_PACKAGE_THERM_STATUS                                    0x000001B1
typedef union {
    struct {
        uint64_t thermal_status : 1;
        uint64_t thermal_status_log : 1;
        uint64_t prochot_event : 1;
        uint64_t prochot_log : 1;
        uint64_t critical_temperature_status : 1;
        uint64_t critical_temperature_status_log : 1;
        uint64_t thermal_threshold1_status : 1;
        uint64_t thermal_threshold1_log : 1;
        uint64_t thermal_threshold2_status : 1;
        uint64_t thermal_threshold2_log : 1;
        uint64_t power_limitation_status : 1;
        uint64_t power_limitation_log : 1;
        uint64_t reserved_1 : 4;
        uint64_t digital_readout : 7;
    };

    uint64_t flags;
} ia32_package_therm_status_register;

#define IA32_PACKAGE_THERM_INTERRUPT                                 0x000001B2
typedef union {
    struct {
        uint64_t high_temperature_interrupt_enable : 1;
        uint64_t low_temperature_interrupt_enable : 1;
        uint64_t prochot_interrupt_enable : 1;
        uint64_t reserved_1 : 1;
        uint64_t overheat_interrupt_enable : 1;
        uint64_t reserved_2 : 3;
        uint64_t threshold1_value : 7;
        uint64_t threshold1_interrupt_enable : 1;
        uint64_t threshold2_value : 7;
        uint64_t threshold2_interrupt_enable : 1;
        uint64_t power_limit_notification_enable : 1;
    };

    uint64_t flags;
} ia32_package_therm_interrupt_register;

#define IA32_DEBUGCTL                                                0x000001D9
typedef union {
    struct {
        uint64_t lbr : 1;
        uint64_t btf : 1;
        uint64_t reserved_1 : 4;
        uint64_t tr : 1;
        uint64_t bts : 1;
        uint64_t btint : 1;
        uint64_t bts_off_os : 1;
        uint64_t bts_off_usr : 1;
        uint64_t freeze_lbrs_on_pmi : 1;
        uint64_t freeze_perfmon_on_pmi : 1;
        uint64_t enable_uncore_pmi : 1;
        uint64_t freeze_while_smm : 1;
        uint64_t rtm_debug : 1;
    };

    uint64_t flags;
} ia32_debugctl_register;

#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union {
    struct {
        uint64_t type : 8;
        uint64_t reserved_1 : 4;
        uint64_t smrr_physical_base_address : 20;
    };

    uint64_t flags;
} ia32_smrr_physbase_register;

#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union {
    struct {
        uint64_t reserved_1 : 11;
        uint64_t enable_range_mask : 1;
        uint64_t smrr_address_range_mask : 20;
    };

    uint64_t flags;
} ia32_smrr_physmask_register;

#define IA32_PLATFORM_DCA_CAP                                        0x000001F8
#define IA32_CPU_DCA_CAP                                             0x000001F9
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union {
    struct {
        uint64_t dca_active : 1;
        uint64_t transaction : 2;
        uint64_t dca_type : 4;
        uint64_t dca_queue_size : 4;
        uint64_t reserved_1 : 2;
        uint64_t dca_delay : 4;
        uint64_t reserved_2 : 7;
        uint64_t sw_block : 1;
        uint64_t reserved_3 : 1;
        uint64_t hw_block : 1;
    };

    uint64_t flags;
} ia32_dca_0_cap_register;

/**
 * @defgroup ia32_mtrr_physbase \
 *           IA32_MTRR_PHYSBASE(n)
 * @{
 */
typedef union {
    struct {
        uint64_t type : 8;
        uint64_t reserved_1 : 4;
        uint64_t physical_addres_base : 36;
    };

    uint64_t flags;
} ia32_mtrr_physbase_register;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_physmask \
  *           IA32_MTRR_PHYSMASK(n)
  * @{
  */
typedef union {
    struct {
        uint64_t reserved_1 : 11;
        uint64_t valid : 1;
        uint64_t physical_addres_mask : 36;
    };

    uint64_t flags;
} ia32_mtrr_physmask_register;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_fix \
  *           IA32_MTRR_FIX(x)
  * @{
  */
  /**
   * @defgroup ia32_mtrr_fix64k \
   *           IA32_MTRR_FIX64K(x)
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup ia32_mtrr_fix16k \
     *           IA32_MTRR_FIX16K(x)
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup ia32_mtrr_fix4k \
       *           IA32_MTRR_FIX4K(x)
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)
#define IA32_MTRR_VARIABLE_COUNT                                     0x0000000A
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
        /**
         * @}
         */

#define IA32_PAT                                                     0x00000277
typedef union {
    struct {
        uint64_t pa0 : 3;
        uint64_t reserved_1 : 5;
        uint64_t pa1 : 3;
        uint64_t reserved_2 : 5;
        uint64_t pa2 : 3;
        uint64_t reserved_3 : 5;
        uint64_t pa3 : 3;
        uint64_t reserved_4 : 5;
        uint64_t pa4 : 3;
        uint64_t reserved_5 : 5;
        uint64_t pa5 : 3;
        uint64_t reserved_6 : 5;
        uint64_t pa6 : 3;
        uint64_t reserved_7 : 5;
        uint64_t pa7 : 3;
    };

    uint64_t flags;
} ia32_pat_register;

/**
 * @defgroup ia32_mc_ctl2 \
 *           IA32_MC(i)_CTL2
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union {
    struct {
        uint64_t corrected_error_count_threshold : 15;
        uint64_t reserved_1 : 15;
        uint64_t cmci_en : 1;
    };

    uint64_t flags;
} ia32_mc_ctl2_register;

/**
 * @}
 */

#define IA32_MTRR_DEF_TYPE                                           0x000002FF
typedef union {
    struct {
        uint64_t default_memory_type : 3;
        uint64_t reserved_1 : 7;
        uint64_t fixed_range_mtrr_enable : 1;
        uint64_t mtrr_enable : 1;
    };

    uint64_t flags;
} ia32_mtrr_def_type_register;

/**
 * @defgroup ia32_fixed_ctr \
 *           IA32_FIXED_CTR(n)
 * @{
 */
#define IA32_FIXED_CTR0                                              0x00000309
#define IA32_FIXED_CTR1                                              0x0000030A
#define IA32_FIXED_CTR2                                              0x0000030B
 /**
  * @}
  */

#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union {
    struct {
        uint64_t lbr_format : 6;
        uint64_t pebs_trap : 1;
        uint64_t pebs_save_arch_regs : 1;
        uint64_t pebs_record_format : 4;
        uint64_t freeze_while_smm_is_supported : 1;
        uint64_t full_width_counter_write : 1;
    };

    uint64_t flags;
} ia32_perf_capabilities_register;

#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union {
    struct {
        uint64_t en0_os : 1;
        uint64_t en0_usr : 1;
        uint64_t any_thread0 : 1;
        uint64_t en0_pmi : 1;
        uint64_t en1_os : 1;
        uint64_t en1_usr : 1;
        uint64_t any_thread1 : 1;
        uint64_t en1_pmi : 1;
        uint64_t en2_os : 1;
        uint64_t en2_usr : 1;
        uint64_t any_thread2 : 1;
        uint64_t en2_pmi : 1;
    };

    uint64_t flags;
} ia32_fixed_ctr_ctrl_register;

#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union {
    struct {
        uint64_t ovf_pmc0 : 1;
        uint64_t ovf_pmc1 : 1;
        uint64_t ovf_pmc2 : 1;
        uint64_t ovf_pmc3 : 1;
        uint64_t reserved_1 : 28;
        uint64_t ovf_fixedctr0 : 1;
        uint64_t ovf_fixedctr1 : 1;
        uint64_t ovf_fixedctr2 : 1;
        uint64_t reserved_2 : 20;
        uint64_t trace_topa_pmi : 1;
        uint64_t reserved_3 : 2;
        uint64_t lbr_frz : 1;
        uint64_t ctr_frz : 1;
        uint64_t asci : 1;
        uint64_t ovf_uncore : 1;
        uint64_t ovf_buf : 1;
        uint64_t cond_chgd : 1;
    };

    uint64_t flags;
} ia32_perf_global_status_register;

#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef union {
    struct {
        uint64_t en_pmcn : 32;
        uint64_t en_fixed_ctrn : 32;
    };

    uint64_t flags;
} ia32_perf_global_ctrl_register;

#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union {
    struct {
        uint64_t clear_ovf_pmcn : 32;
        uint64_t clear_ovf_fixed_ctrn : 3;
        uint64_t reserved_1 : 20;
        uint64_t clear_trace_topa_pmi : 1;
        uint64_t reserved_2 : 2;
        uint64_t clear_lbr_frz : 1;
        uint64_t clear_ctr_frz : 1;
        uint64_t clear_asci : 1;
        uint64_t clear_ovf_uncore : 1;
        uint64_t clear_ovf_buf : 1;
        uint64_t clear_cond_chgd : 1;
    };

    uint64_t flags;
} ia32_perf_global_status_reset_register;

#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union {
    struct {
        uint64_t ovf_pmcn : 32;
        uint64_t ovf_fixed_ctrn : 3;
        uint64_t reserved_1 : 20;
        uint64_t trace_topa_pmi : 1;
        uint64_t reserved_2 : 2;
        uint64_t lbr_frz : 1;
        uint64_t ctr_frz : 1;
        uint64_t asci : 1;
        uint64_t ovf_uncore : 1;
        uint64_t ovf_buf : 1;
    };

    uint64_t flags;
} ia32_perf_global_status_set_register;

#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union {
    struct {
        uint64_t ia32_perfevtseln_in_use : 32;
        uint64_t ia32_fixed_ctrn_in_use : 3;
        uint64_t reserved_1 : 28;
        uint64_t pmi_in_use : 1;
    };

    uint64_t flags;
} ia32_perf_global_inuse_register;

#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union {
    struct {
        uint64_t enable_pebs : 1;
        uint64_t reservedormodelspecific1 : 3;
        uint64_t reserved_1 : 28;
        uint64_t reservedormodelspecific2 : 4;
    };

    uint64_t flags;
} ia32_pebs_enable_register;

/**
 * @defgroup ia32_mc_ctl \
 *           IA32_MC(i)_CTL
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup ia32_mc_status \
   *           IA32_MC(i)_STATUS
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup ia32_mc_addr \
     *           IA32_MC(i)_ADDR
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup ia32_mc_misc \
       *           IA32_MC(i)_MISC
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */

#define IA32_VMX_BASIC                                               0x00000480
typedef union {
    struct {
        uint64_t vmcs_revision_id : 31;
        uint64_t must_be_zero : 1;
        uint64_t vmcs_size_in_bytes : 13;
        uint64_t reserved_1 : 3;
        uint64_t vmcs_physical_address_width : 1;
        uint64_t dual_monitor : 1;
        uint64_t memory_type : 4;
        uint64_t ins_outs_vmexit_information : 1;
        uint64_t true_controls : 1;
    };

    uint64_t flags;
} ia32_vmx_basic_register;

#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union {
    struct {
        uint64_t external_interrupt_exiting : 1;
        uint64_t reserved_1 : 2;
        uint64_t nmi_exiting : 1;
        uint64_t reserved_2 : 1;
        uint64_t virtual_nmis : 1;
        uint64_t activate_vmx_preemption_timer : 1;
        uint64_t process_posted_interrupts : 1;
    };

    uint64_t flags;
} ia32_vmx_pinbased_ctls_register;

#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union {
    struct {
        uint64_t reserved_1 : 2;
        uint64_t interrupt_window_exiting : 1;
        uint64_t use_tsc_offsetting : 1;
        uint64_t reserved_2 : 3;
        uint64_t hlt_exiting : 1;
        uint64_t reserved_3 : 1;
        uint64_t invlpg_exiting : 1;
        uint64_t mwait_exiting : 1;
        uint64_t rdpmc_exiting : 1;
        uint64_t rdtsc_exiting : 1;
        uint64_t reserved_4 : 2;
        uint64_t cr3_load_exiting : 1;
        uint64_t cr3_store_exiting : 1;
        uint64_t activate_tertiary_controls : 1;
        uint64_t reserved_5 : 1;
        uint64_t cr8_load_exiting : 1;
        uint64_t cr8_store_exiting : 1;
        uint64_t use_tpr_shadow : 1;
        uint64_t nmi_window_exiting : 1;
        uint64_t mov_dr_exiting : 1;
        uint64_t unconditional_io_exiting : 1;
        uint64_t use_io_bitmaps : 1;
        uint64_t reserved_6 : 1;
        uint64_t monitor_trap_flag : 1;
        uint64_t use_msr_bitmaps : 1;
        uint64_t monitor_exiting : 1;
        uint64_t pause_exiting : 1;
        uint64_t activate_secondary_controls : 1;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls_register;

#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union {
    struct {
        uint64_t reserved_1 : 2;
        uint64_t save_debug_controls : 1;
        uint64_t reserved_2 : 6;
        uint64_t host_address_space_size : 1;
        uint64_t reserved_3 : 2;
        uint64_t load_ia32_perf_global_ctrl : 1;
        uint64_t reserved_4 : 2;
        uint64_t acknowledge_interrupt_on_exit : 1;
        uint64_t reserved_5 : 2;
        uint64_t save_ia32_pat : 1;
        uint64_t load_ia32_pat : 1;
        uint64_t save_ia32_efer : 1;
        uint64_t load_ia32_efer : 1;
        uint64_t save_vmx_preemption_timer_value : 1;
        uint64_t clear_ia32_bndcfgs : 1;
        uint64_t conceal_vmx_from_pt : 1;
        uint64_t clear_ia32_rtit_ctl : 1;
        uint64_t clear_ia32_lbr_ctl : 1;
        uint64_t reserved_6 : 1;
        uint64_t load_ia32_cet_state : 1;
        uint64_t load_ia32_pkrs : 1;
        uint64_t reserved_7 : 1;
        uint64_t activate_secondary_controls : 1;
    };

    uint64_t flags;
} ia32_vmx_exit_ctls_register;

#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union {
    struct {
        uint64_t reserved_1 : 2;
        uint64_t load_debug_controls : 1;
        uint64_t reserved_2 : 6;
        uint64_t ia32e_mode_guest : 1;
        uint64_t entry_to_smm : 1;
        uint64_t deactivate_dual_monitor_treatment : 1;
        uint64_t reserved_3 : 1;
        uint64_t load_ia32_perf_global_ctrl : 1;
        uint64_t load_ia32_pat : 1;
        uint64_t load_ia32_efer : 1;
        uint64_t load_ia32_bndcfgs : 1;
        uint64_t conceal_vmx_from_pt : 1;
        uint64_t load_ia32_rtit_ctl : 1;
        uint64_t reserved_4 : 1;
        uint64_t load_cet_state : 1;
        uint64_t load_ia32_lbr_ctl : 1;
        uint64_t load_ia32_pkrs : 1;
    };

    uint64_t flags;
} ia32_vmx_entry_ctls_register;

#define IA32_VMX_MISC                                                0x00000485
typedef union {
    struct {
        uint64_t preemption_timer_tsc_relationship : 5;
        uint64_t store_efer_lma_on_vmexit : 1;
        uint64_t activity_states : 3;
        uint64_t reserved_1 : 5;
        uint64_t intel_pt_available_in_vmx : 1;
        uint64_t rdmsr_can_read_ia32_smbase_msr_in_smm : 1;
        uint64_t cr3_target_count : 9;
        uint64_t max_number_of_msr : 3;
        uint64_t smm_monitor_ctl_b2 : 1;
        uint64_t vmwrite_vmexit_info : 1;
        uint64_t zero_length_instruction_vmentry_injection : 1;
        uint64_t reserved_2 : 1;
        uint64_t mseg_id : 32;
    };

    uint64_t flags;
} ia32_vmx_misc_register;

#define IA32_VMX_CR0_FIXED0                                          0x00000486
#define IA32_VMX_CR0_FIXED1                                          0x00000487
#define IA32_VMX_CR4_FIXED0                                          0x00000488
#define IA32_VMX_CR4_FIXED1                                          0x00000489
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union {
    struct {
        uint64_t access_type : 1;
        uint64_t highest_index_value : 9;
        uint64_t field_type : 2;
        uint64_t reserved_1 : 1;
        uint64_t field_width : 2;
    };

    uint64_t flags;
} ia32_vmx_vmcs_enum_register;

#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union {
    struct {
        uint64_t virtualize_apic_accesses : 1;
        uint64_t enable_ept : 1;
        uint64_t descriptor_table_exiting : 1;
        uint64_t enable_rdtscp : 1;
        uint64_t virtualize_x2apic_mode : 1;
        uint64_t enable_vpid : 1;
        uint64_t wbinvd_exiting : 1;
        uint64_t unrestricted_guest : 1;
        uint64_t apic_register_virtualization : 1;
        uint64_t virtual_interrupt_delivery : 1;
        uint64_t pause_loop_exiting : 1;
        uint64_t rdrand_exiting : 1;
        uint64_t enable_invpcid : 1;
        uint64_t enable_vm_functions : 1;
        uint64_t vmcs_shadowing : 1;
        uint64_t enable_encls_exiting : 1;
        uint64_t rdseed_exiting : 1;
        uint64_t enable_pml : 1;
        uint64_t ept_violation : 1;
        uint64_t conceal_vmx_from_pt : 1;
        uint64_t enable_xsaves : 1;
        uint64_t reserved_1 : 1;
        uint64_t mode_based_execute_control_for_ept : 1;
        uint64_t sub_page_write_permissions_for_ept : 1;
        uint64_t pt_uses_guest_physical_addresses : 1;
        uint64_t use_tsc_scaling : 1;
        uint64_t enable_user_wait_pause : 1;
        uint64_t reserved_2 : 1;
        uint64_t enable_enclv_exiting : 1;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls2_register;

#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union {
    struct {
        uint64_t execute_only_pages : 1;
        uint64_t reserved_1 : 5;
        uint64_t page_walk_length_4 : 1;
        uint64_t reserved_2 : 1;
        uint64_t memory_type_uncacheable : 1;
        uint64_t reserved_3 : 5;
        uint64_t memory_type_write_back : 1;
        uint64_t reserved_4 : 1;
        uint64_t pde_2mb_pages : 1;
        uint64_t pdpte_1gb_pages : 1;
        uint64_t reserved_5 : 2;
        uint64_t invept : 1;
        uint64_t ept_accessed_and_dirty_flags : 1;
        uint64_t advanced_vmexit_ept_violations_information : 1;
        uint64_t supervisor_shadow_stack : 1;
        uint64_t reserved_6 : 1;
        uint64_t invept_single_context : 1;
        uint64_t invept_all_contexts : 1;
        uint64_t reserved_7 : 5;
        uint64_t invvpid : 1;
        uint64_t reserved_8 : 7;
        uint64_t invvpid_individual_address : 1;
        uint64_t invvpid_single_context : 1;
        uint64_t invvpid_all_contexts : 1;
        uint64_t invvpid_single_context_retain_globals : 1;
        uint64_t reserved_9 : 4;
        uint64_t max_hlat_prefix_size : 6;
    };

    uint64_t flags;
} ia32_vmx_ept_vpid_cap_register;

/**
 * @defgroup ia32_vmx_true_ctls \
 *           IA32_VMX_TRUE_(x)_CTLS
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union {
    struct {
        uint64_t allowed_0_settings : 32;
        uint64_t allowed_1_settings : 32;
    };

    uint64_t flags;
} ia32_vmx_true_ctls_register;

/**
 * @}
 */

#define IA32_VMX_VMFUNC                                              0x00000491
typedef union {
    struct {
        uint64_t eptp_switching : 1;
    };

    uint64_t flags;
} ia32_vmx_vmfunc_register;

#define IA32_VMX_PROCBASED_CTLS3                                     0x00000492
typedef union {
    struct {
        uint64_t loadiwkey_exiting : 1;
        uint64_t enable_hlat : 1;
        uint64_t ept_paging_write : 1;
        uint64_t guest_paging : 1;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls3_register;

#define IA32_VMX_EXIT_CTLS2                                          0x00000493
typedef union {
    struct {
        uint64_t reserved : 64;
    };

    uint64_t flags;
} ia32_vmx_exit_ctls2_register;

/**
 * @defgroup ia32_a_pmc \
 *           IA32_A_PMC(n)
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */

#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union {
    struct {
        uint64_t lmce_en : 1;
    };

    uint64_t flags;
} ia32_mcg_ext_ctl_register;

#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union {
    struct {
        uint64_t lock : 1;
        uint64_t reserved_1 : 15;
        uint64_t sgx_svn_sinit : 8;
    };

    uint64_t flags;
} ia32_sgx_svn_status_register;

#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union {
    struct {
        uint64_t reserved_1 : 7;
        uint64_t base_physical_address : 41;
    };

    uint64_t flags;
} ia32_rtit_output_base_register;

#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union {
    struct {
        uint64_t lower_mask : 7;
        uint64_t mask_or_table_offset : 25;
        uint64_t output_offset : 32;
    };

    uint64_t flags;
} ia32_rtit_output_mask_ptrs_register;

#define IA32_RTIT_CTL                                                0x00000570
typedef union {
    struct {
        uint64_t trace_en : 1;
        uint64_t cyc_en : 1;
        uint64_t os : 1;
        uint64_t user : 1;
        uint64_t pwr_evt_en : 1;
        uint64_t fup_on_ptw : 1;
        uint64_t fabric_en : 1;
        uint64_t cr3_filter : 1;
        uint64_t topa : 1;
        uint64_t mtc_en : 1;
        uint64_t tsc_en : 1;
        uint64_t dis_retc : 1;
        uint64_t ptw_en : 1;
        uint64_t branch_en : 1;
        uint64_t mtc_freq : 4;
        uint64_t reserved_1 : 1;
        uint64_t cyc_thresh : 4;
        uint64_t reserved_2 : 1;
        uint64_t psb_freq : 4;
        uint64_t reserved_3 : 4;
        uint64_t addr0_cfg : 4;
        uint64_t addr1_cfg : 4;
        uint64_t addr2_cfg : 4;
        uint64_t addr3_cfg : 4;
        uint64_t reserved_4 : 8;
        uint64_t inject_psb_pmi_on_enable : 1;
    };

    uint64_t flags;
} ia32_rtit_ctl_register;

#define IA32_RTIT_STATUS                                             0x00000571
typedef union {
    struct {
        uint64_t filter_en : 1;
        uint64_t contex_en : 1;
        uint64_t trigger_en : 1;
        uint64_t reserved_1 : 1;
        uint64_t error : 1;
        uint64_t stopped : 1;
        uint64_t pend_psb : 1;
        uint64_t pend_topa_pmi : 1;
        uint64_t reserved_2 : 24;
        uint64_t packet_byte_cnt : 17;
    };

    uint64_t flags;
} ia32_rtit_status_register;

#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union {
    struct {
        uint64_t reserved_1 : 5;
        uint64_t cr3_value_to_match : 59;
    };

    uint64_t flags;
} ia32_rtit_cr3_match_register;

/**
 * @defgroup ia32_rtit_addr \
 *           IA32_RTIT_ADDR(x)
 * @{
 */
 /**
  * @defgroup ia32_rtit_addr_a \
  *           IA32_RTIT_ADDR(n)_A
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup ia32_rtit_addr_b \
    *           IA32_RTIT_ADDR(n)_B
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union {
    struct {
        uint64_t virtual_address : 48;
        uint64_t sign_ext_va : 16;
    };

    uint64_t flags;
} ia32_rtit_addr_register;

/**
 * @}
 */

#define IA32_DS_AREA                                                 0x00000600
#define IA32_U_CET                                                   0x000006A0
typedef union {
    struct {
        uint64_t sh_stk_en : 1;
        uint64_t wr_shstk_en : 1;
        uint64_t endbr_en : 1;
        uint64_t leg_iw_en : 1;
        uint64_t no_track_en : 1;
        uint64_t suppress_dis : 1;
        uint64_t reserved_1 : 4;
        uint64_t suppress : 1;
        uint64_t tracker : 1;
        uint64_t eb_leg_bitmap_base : 52;
    };

    uint64_t flags;
} ia32_u_cet_register;

#define IA32_S_CET                                                   0x000006A2
typedef union {
    struct {
        uint64_t sh_stk_en : 1;
        uint64_t wr_shstk_en : 1;
        uint64_t endbr_en : 1;
        uint64_t leg_iw_en : 1;
        uint64_t no_track_en : 1;
        uint64_t suppress_dis : 1;
        uint64_t reserved_1 : 4;
        uint64_t suppress : 1;
        uint64_t tracker : 1;
        uint64_t eb_leg_bitmap_base : 52;
    };

    uint64_t flags;
} ia32_s_cet_register;

#define IA32_PL0_SSP                                                 0x000006A4
#define IA32_PL1_SSP                                                 0x000006A5
#define IA32_PL2_SSP                                                 0x000006A6
#define IA32_PL3_SSP                                                 0x000006A7
#define IA32_INTERRUPT_SSP_TABLE_ADDR                                0x000006A8
#define IA32_TSC_DEADLINE                                            0x000006E0
#define IA32_PM_ENABLE                                               0x00000770
typedef union {
    struct {
        uint64_t hwp_enable : 1;
    };

    uint64_t flags;
} ia32_pm_enable_register;

#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union {
    struct {
        uint64_t highest_performance : 8;
        uint64_t guaranteed_performance : 8;
        uint64_t most_efficient_performance : 8;
        uint64_t lowest_performance : 8;
    };

    uint64_t flags;
} ia32_hwp_capabilities_register;

#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union {
    struct {
        uint64_t minimum_performance : 8;
        uint64_t maximum_performance : 8;
        uint64_t desired_performance : 8;
        uint64_t energy_performance_preference : 8;
        uint64_t activity_window : 10;
    };

    uint64_t flags;
} ia32_hwp_request_pkg_register;

#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union {
    struct {
        uint64_t en_guaranteed_performance_change : 1;
        uint64_t en_excursion_minimum : 1;
    };

    uint64_t flags;
} ia32_hwp_interrupt_register;

#define IA32_HWP_REQUEST                                             0x00000774
typedef union {
    struct {
        uint64_t minimum_performance : 8;
        uint64_t maximum_performance : 8;
        uint64_t desired_performance : 8;
        uint64_t energy_performance_preference : 8;
        uint64_t activity_window : 10;
        uint64_t package_control : 1;
    };

    uint64_t flags;
} ia32_hwp_request_register;

#define IA32_HWP_STATUS                                              0x00000777
typedef union {
    struct {
        uint64_t guaranteed_performance_change : 1;
        uint64_t reserved_1 : 1;
        uint64_t excursion_to_minimum : 1;
    };

    uint64_t flags;
} ia32_hwp_status_register;

#define IA32_X2APIC_APICID                                           0x00000802
#define IA32_X2APIC_VERSION                                          0x00000803
#define IA32_X2APIC_TPR                                              0x00000808
#define IA32_X2APIC_PPR                                              0x0000080A
#define IA32_X2APIC_EOI                                              0x0000080B
#define IA32_X2APIC_LDR                                              0x0000080D
#define IA32_X2APIC_SIVR                                             0x0000080F
/**
 * @defgroup ia32_x2apic_isr \
 *           IA32_X2APIC_ISR(n)
 * @{
 */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
 /**
  * @}
  */

  /**
   * @defgroup ia32_x2apic_tmr \
   *           IA32_X2APIC_TMR(n)
   * @{
   */
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
   /**
    * @}
    */

    /**
     * @defgroup ia32_x2apic_irr \
     *           IA32_X2APIC_IRR(n)
     * @{
     */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
     /**
      * @}
      */

#define IA32_X2APIC_ESR                                              0x00000828
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F
#define IA32_X2APIC_ICR                                              0x00000830
#define IA32_X2APIC_LVT_TIMER                                        0x00000832
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833
#define IA32_X2APIC_LVT_PMI                                          0x00000834
#define IA32_X2APIC_LVT_LINT0                                        0x00000835
#define IA32_X2APIC_LVT_LINT1                                        0x00000836
#define IA32_X2APIC_LVT_ERROR                                        0x00000837
#define IA32_X2APIC_INIT_COUNT                                       0x00000838
#define IA32_X2APIC_CUR_COUNT                                        0x00000839
#define IA32_X2APIC_DIV_CONF                                         0x0000083E
#define IA32_X2APIC_SELF_IPI                                         0x0000083F
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union {
    struct {
        uint64_t enable : 1;
        uint64_t reserved_1 : 29;
        uint64_t lock : 1;
        uint64_t debug_occurred : 1;
    };

    uint64_t flags;
} ia32_debug_interface_register;

#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union {
    struct {
        uint64_t enable : 1;
    };

    uint64_t flags;
} ia32_l3_qos_cfg_register;

#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union {
    struct {
        uint64_t enable : 1;
    };

    uint64_t flags;
} ia32_l2_qos_cfg_register;

#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union {
    struct {
        uint64_t event_id : 8;
        uint64_t reserved_1 : 24;
        uint64_t resource_monitoring_id : 32;
    };

    uint64_t flags;
} ia32_qm_evtsel_register;

#define IA32_QM_CTR                                                  0x00000C8E
typedef union {
    struct {
        uint64_t resource_monitored_data : 62;
        uint64_t unavailable : 1;
        uint64_t error : 1;
    };

    uint64_t flags;
} ia32_qm_ctr_register;

#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union {
    struct {
        uint64_t resource_monitoring_id : 32;
        uint64_t cos : 32;
    };

    uint64_t flags;
} ia32_pqr_assoc_register;

#define IA32_BNDCFGS                                                 0x00000D90
typedef union {
    struct {
        uint64_t enable : 1;
        uint64_t bnd_preserve : 1;
        uint64_t reserved_1 : 10;
        uint64_t bound_directory_base_address : 52;
    };

    uint64_t flags;
} ia32_bndcfgs_register;

#define IA32_XSS                                                     0x00000DA0
typedef union {
    struct {
        uint64_t reserved_1 : 8;
        uint64_t trace_packet_configuration_state : 1;
    };

    uint64_t flags;
} ia32_xss_register;

#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union {
    struct {
        uint64_t hdc_pkg_enable : 1;
    };

    uint64_t flags;
} ia32_pkg_hdc_ctl_register;

#define IA32_PM_CTL1                                                 0x00000DB1
typedef union {
    struct {
        uint64_t hdc_allow_block : 1;
    };

    uint64_t flags;
} ia32_pm_ctl1_register;

#define IA32_THREAD_STALL                                            0x00000DB2
typedef struct {
    uint64_t stall_cycle_cnt;
} ia32_thread_stall_register;

#define IA32_EFER                                                    0xC0000080
typedef union {
    struct {
        uint64_t syscall_enable : 1;
        uint64_t reserved_1 : 7;
        uint64_t ia32e_mode_enable : 1;
        uint64_t reserved_2 : 1;
        uint64_t ia32e_mode_active : 1;
        uint64_t execute_disable_bit_enable : 1;
    };

    uint64_t flags;
} ia32_efer_register;

#define IA32_STAR                                                    0xC0000081
#define IA32_LSTAR                                                   0xC0000082
#define IA32_CSTAR                                                   0xC0000083
#define IA32_FMASK                                                   0xC0000084
#define IA32_FS_BASE                                                 0xC0000100
#define IA32_GS_BASE                                                 0xC0000101
#define IA32_KERNEL_GS_BASE                                          0xC0000102
#define IA32_TSC_AUX                                                 0xC0000103
typedef union {
    struct {
        uint64_t tsc_auxiliary_signature : 32;
    };

    uint64_t flags;
} ia32_tsc_aux_register;

/**
 * @}
 */

 /**
  * @defgroup paging \
  *           Paging
  * @{
  */
  /**
   * @defgroup paging_32 \
   *           32-Bit Paging
   * @{
   */
typedef union {
    struct {
        uint32_t present : 1;
        uint32_t write : 1;
        uint32_t supervisor : 1;
        uint32_t page_level_write_through : 1;
        uint32_t page_level_cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t dirty : 1;
        uint32_t large_page : 1;
        uint32_t global : 1;
        uint32_t ignored_1 : 3;
        uint32_t pat : 1;
        uint32_t page_frame_number_low : 8;
        uint32_t reserved_1 : 1;
        uint32_t page_frame_number_high : 10;
    };

    uint32_t flags;
} pde_4mb_32;

typedef union {
    struct {
        uint32_t present : 1;
        uint32_t write : 1;
        uint32_t supervisor : 1;
        uint32_t page_level_write_through : 1;
        uint32_t page_level_cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t ignored_1 : 1;
        uint32_t large_page : 1;
        uint32_t ignored_2 : 4;
        uint32_t page_frame_number : 20;
    };

    uint32_t flags;
} pde_32;

typedef union {
    struct {
        uint32_t present : 1;
        uint32_t write : 1;
        uint32_t supervisor : 1;
        uint32_t page_level_write_through : 1;
        uint32_t page_level_cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t dirty : 1;
        uint32_t pat : 1;
        uint32_t global : 1;
        uint32_t ignored_1 : 3;
        uint32_t page_frame_number : 20;
    };

    uint32_t flags;
} pte_32;

typedef union {
    struct {
        uint32_t present : 1;
        uint32_t write : 1;
        uint32_t supervisor : 1;
        uint32_t page_level_write_through : 1;
        uint32_t page_level_cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t dirty : 1;
        uint32_t large_page : 1;
        uint32_t global : 1;
        uint32_t ignored_1 : 3;
        uint32_t page_frame_number : 20;
    };

    uint32_t flags;
} pt_entry_32;

/**
 * @defgroup paging_structures_entry_count_32 \
 *           Paging structures entry counts
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup paging_64 \
    *           64-Bit (4-Level) Paging
    * @{
    */
typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t reserved_1 : 1;
        uint64_t must_be_zero : 1;
        uint64_t ignored_1 : 3;
        uint64_t restart : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_2 : 4;
        uint64_t ignored_2 : 11;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pml4e_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t large_page : 1;
        uint64_t global : 1;
        uint64_t ignored_1 : 2;
        uint64_t restart : 1;
        uint64_t pat : 1;
        uint64_t reserved_1 : 17;
        uint64_t page_frame_number : 18;
        uint64_t reserved_2 : 4;
        uint64_t ignored_2 : 7;
        uint64_t protection_key : 4;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pdpte_1gb_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t reserved_1 : 1;
        uint64_t large_page : 1;
        uint64_t ignored_1 : 3;
        uint64_t restart : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_2 : 4;
        uint64_t ignored_2 : 11;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pdpte_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t large_page : 1;
        uint64_t global : 1;
        uint64_t ignored_1 : 2;
        uint64_t restart : 1;
        uint64_t pat : 1;
        uint64_t reserved_1 : 8;
        uint64_t page_frame_number : 27;
        uint64_t reserved_2 : 4;
        uint64_t ignored_2 : 7;
        uint64_t protection_key : 4;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pde_2mb_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t reserved_1 : 1;
        uint64_t large_page : 1;
        uint64_t ignored_1 : 3;
        uint64_t restart : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_2 : 4;
        uint64_t ignored_2 : 11;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pde_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t pat : 1;
        uint64_t global : 1;
        uint64_t ignored_1 : 2;
        uint64_t restart : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_1 : 4;
        uint64_t ignored_2 : 7;
        uint64_t protection_key : 4;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pte_64;

typedef union {
    struct {
        uint64_t present : 1;
        uint64_t write : 1;
        uint64_t supervisor : 1;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t large_page : 1;
        uint64_t global : 1;
        uint64_t ignored_1 : 2;
        uint64_t restart : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_1 : 4;
        uint64_t ignored_2 : 7;
        uint64_t protection_key : 4;
        uint64_t execute_disable : 1;
    };

    uint64_t flags;
} pt_entry_64;

/**
 * @defgroup paging_structures_entry_count_64 \
 *           Paging structures entry counts
 * @{
 */
#define PML4_ENTRY_COUNT_64                                          0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

typedef enum {
    invpcid_individual_address = 0x00000000,
    invpcid_single_context = 0x00000001,
    invpcid_all_context_with_globals = 0x00000002,
    invpcid_all_context = 0x00000003,
} invpcid_type;

typedef union {
    struct {
        uint64_t pcid : 12;
        uint64_t reserved1 : 52;
        uint64_t linear_address : 64;
    };

    uint64_t flags;
} invpcid_descriptor;

/**
 * @defgroup segment_descriptors \
 *           Segment descriptors
 * @{
 */
#pragma pack(push, 1)
typedef struct {
    uint16_t limit;
    uint32_t base_address;
} segment_descriptor_register_32;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct {
    uint16_t limit;
    uint64_t base_address;
} segment_descriptor_register_64;
#pragma pack(pop)

typedef union {
    struct {
        uint32_t reserved_1 : 8;
        uint32_t type : 4;
        uint32_t descriptor_type : 1;
        uint32_t descriptor_privilege_level : 2;
        uint32_t present : 1;
        uint32_t reserved_2 : 4;
        uint32_t available_bit : 1;
        uint32_t long_mode : 1;
        uint32_t default_big : 1;
        uint32_t granularity : 1;
    };

    uint32_t flags;
} segment_access_rights;

typedef struct {
    uint16_t segment_limit_low;
    uint16_t base_address_low;
    union {
        struct {
            uint32_t base_address_middle : 8;
            uint32_t type : 4;
            uint32_t descriptor_type : 1;
            uint32_t descriptor_privilege_level : 2;
            uint32_t present : 1;
            uint32_t segment_limit_high : 4;
            uint32_t available_bit : 1;
            uint32_t long_mode : 1;
            uint32_t default_big : 1;
            uint32_t granularity : 1;
            uint32_t base_address_high : 8;
        };

        uint32_t flags;
    };

} segment_descriptor_32;

typedef struct {
    uint16_t segment_limit_low;
    uint16_t base_address_low;
    union {
        struct {
            uint32_t base_address_middle : 8;
            uint32_t type : 4;
            uint32_t descriptor_type : 1;
            uint32_t descriptor_privilege_level : 2;
            uint32_t present : 1;
            uint32_t segment_limit_high : 4;
            uint32_t available_bit : 1;
            uint32_t long_mode : 1;
            uint32_t default_big : 1;
            uint32_t granularity : 1;
            uint32_t base_address_high : 8;
        };

        uint32_t flags;
    };

    uint32_t base_address_upper;
    uint32_t must_be_zero;
} segment_descriptor_64;

typedef struct {
    uint16_t offset_low;
    uint16_t segment_selector;
    union {
        struct {
            uint32_t interrupt_stack_table : 3;
            uint32_t must_be_zero_0 : 5;
            uint32_t type : 4;
            uint32_t must_be_zero_1 : 1;
            uint32_t descriptor_privilege_level : 2;
            uint32_t present : 1;
            uint32_t offset_middle : 16;
        };

        uint32_t flags;
    };

    uint32_t offset_high;
    uint32_t reserved;
} segment_descriptor_interrupt_gate_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup segment_descriptor_code_and_data_type \
 *           Code- and Data-Segment Descriptor Types
 * @{
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_R                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RA                              0x00000001
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RW                              0x00000002
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RWA                             0x00000003
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RE                              0x00000004
#define SEGMENT_DESCRIPTOR_TYPE_DATA_REA                             0x00000005
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RWE                             0x00000006
#define SEGMENT_DESCRIPTOR_TYPE_DATA_RWEA                            0x00000007
#define SEGMENT_DESCRIPTOR_TYPE_CODE_E                               0x00000008
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EA                              0x00000009
#define SEGMENT_DESCRIPTOR_TYPE_CODE_ER                              0x0000000A
#define SEGMENT_DESCRIPTOR_TYPE_CODE_ERA                             0x0000000B
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EC                              0x0000000C
#define SEGMENT_DESCRIPTOR_TYPE_CODE_ECA                             0x0000000D
#define SEGMENT_DESCRIPTOR_TYPE_CODE_ERC                             0x0000000E
#define SEGMENT_DESCRIPTOR_TYPE_CODE_ERCA                            0x0000000F
 /**
  * @}
  */

  /**
   * @defgroup segment_descriptor_system_type \
   *           System Descriptor Types
   * @{
   */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
   /**
    * @}
    */

typedef union {
    struct {
        uint16_t request_privilege_level : 2;
        uint16_t table_indicator : 1;
        uint16_t index : 13;
    };

    uint16_t flags;
} segment_selector;

/**
 * @}
 */

#pragma pack(push, 1)
typedef struct {
    uint32_t reserved_0;
    uint64_t rsp0;
    uint64_t rsp1;
    uint64_t rsp2;
    uint64_t reserved_1;
    uint64_t ist1;
    uint64_t ist2;
    uint64_t ist3;
    uint64_t ist4;
    uint64_t ist5;
    uint64_t ist6;
    uint64_t ist7;
    uint64_t reserved_2;
    uint16_t reserved_3;
    uint16_t io_map_base;
} task_state_segment_64;
#pragma pack(pop)

/**
 * @defgroup vmx \
 *           VMX
 * @{
 */
 /**
  * @{
  */
  /**
   * @defgroup vmx_basic_exit_reasons \
   *           VMX Basic Exit Reasons
   * @{
   */
#define VMX_EXIT_REASON_XCPT_OR_NMI                                  0x00000000
#define VMX_EXIT_REASON_EXT_INT                                      0x00000001
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003
#define VMX_EXIT_REASON_SIPI                                         0x00000004
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005
#define VMX_EXIT_REASON_SMI                                          0x00000006
#define VMX_EXIT_REASON_INT_WINDOW                                   0x00000007
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009
#define VMX_EXIT_REASON_CPUID                                        0x0000000A
#define VMX_EXIT_REASON_GETSEC                                       0x0000000B
#define VMX_EXIT_REASON_HLT                                          0x0000000C
#define VMX_EXIT_REASON_INVD                                         0x0000000D
#define VMX_EXIT_REASON_INVLPG                                       0x0000000E
#define VMX_EXIT_REASON_RDPMC                                        0x0000000F
#define VMX_EXIT_REASON_RDTSC                                        0x00000010
#define VMX_EXIT_REASON_RSM                                          0x00000011
#define VMX_EXIT_REASON_VMCALL                                       0x00000012
#define VMX_EXIT_REASON_VMCLEAR                                      0x00000013
#define VMX_EXIT_REASON_VMLAUNCH                                     0x00000014
#define VMX_EXIT_REASON_VMPTRLD                                      0x00000015
#define VMX_EXIT_REASON_VMPTRST                                      0x00000016
#define VMX_EXIT_REASON_VMREAD                                       0x00000017
#define VMX_EXIT_REASON_VMRESUME                                     0x00000018
#define VMX_EXIT_REASON_VMWRITE                                      0x00000019
#define VMX_EXIT_REASON_VMXOFF                                       0x0000001A
#define VMX_EXIT_REASON_VMXON                                        0x0000001B
#define VMX_EXIT_REASON_MOV_CRX                                      0x0000001C
#define VMX_EXIT_REASON_MOV_DRX                                      0x0000001D
#define VMX_EXIT_REASON_IO_INSTR                                     0x0000001E
#define VMX_EXIT_REASON_RDMSR                                        0x0000001F
#define VMX_EXIT_REASON_WRMSR                                        0x00000020
#define VMX_EXIT_REASON_ERR_INVALID_GUEST_STATE                      0x00000021
#define VMX_EXIT_REASON_ERR_MSR_LOAD                                 0x00000022
#define VMX_EXIT_REASON_MWAIT                                        0x00000024
#define VMX_EXIT_REASON_MTF                                          0x00000025
#define VMX_EXIT_REASON_MONITOR                                      0x00000027
#define VMX_EXIT_REASON_PAUSE                                        0x00000028
#define VMX_EXIT_REASON_ERR_MACHINE_CHECK                            0x00000029
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D
#define VMX_EXIT_REASON_XDTR_ACCESS                                  0x0000002E
#define VMX_EXIT_REASON_TR_ACCESS                                    0x0000002F
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030
#define VMX_EXIT_REASON_EPT_MISCONFIG                                0x00000031
#define VMX_EXIT_REASON_INVEPT                                       0x00000032
#define VMX_EXIT_REASON_RDTSCP                                       0x00000033
#define VMX_EXIT_REASON_PREEMPT_TIMER                                0x00000034
#define VMX_EXIT_REASON_INVVPID                                      0x00000035
#define VMX_EXIT_REASON_WBINVD                                       0x00000036
#define VMX_EXIT_REASON_XSETBV                                       0x00000037
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038
#define VMX_EXIT_REASON_RDRAND                                       0x00000039
#define VMX_EXIT_REASON_INVPCID                                      0x0000003A
#define VMX_EXIT_REASON_VMFUNC                                       0x0000003B
#define VMX_EXIT_REASON_ENCLS                                        0x0000003C
#define VMX_EXIT_REASON_RDSEED                                       0x0000003D
#define VMX_EXIT_REASON_PML_FULL                                     0x0000003E
#define VMX_EXIT_REASON_XSAVES                                       0x0000003F
#define VMX_EXIT_REASON_XRSTORS                                      0x00000040
   /**
    * @}
    */

    /**
     * @defgroup vmx_instruction_error_numbers \
     *           VM-Instruction Error Numbers
     * @{
     */
#define VMX_ERROR_VMCALL                                             0x00000001
#define VMX_ERROR_VMCLEAR_INVALID_PHYS_ADDR                          0x00000002
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_PTR                          0x00000003
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005
#define VMX_ERROR_VMRESUME_CORRUPTED_VMCS                            0x00000006
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008
#define VMX_ERROR_VMPTRLD_INVALID_PHYS_ADDR                          0x00000009
#define VMX_ERROR_VMPTRLD_VMXON_PTR                                  0x0000000A
#define VMX_ERROR_VMPTRLD_WRONG_VMCS_REVISION                        0x0000000B
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXEC_PTR                      0x00000010
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXEC_VMCS                     0x00000011
#define VMX_ERROR_VMENTRY_EXEC_VMCS_PTR                              0x00000012
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION                       0x00000016
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018
#define VMX_ERROR_VMENTRY_INVALID_VM_EXEC_CTRL                       0x00000019
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A
#define VMX_ERROR_INVEPTVPID_INVALID_OPERAND                         0x0000001C
     /**
      * @}
      */

      /**
       * @defgroup vmx_exceptions \
       *           Virtualization Exceptions
       * @{
       */
typedef struct {
    uint32_t reason;
    uint32_t exception_mask;
    uint64_t exit;
    uint64_t guest_linear_address;
    uint64_t guest_physical_address;
    uint16_t current_eptp_index;
} vmx_ve_except_info;

/**
 * @}
 */

 /**
  * @defgroup vmx_basic_exit_information \
  *           Basic VM-Exit Information
  * @{
  */
typedef union {
    struct {
        uint64_t breakpoint_condition : 4;
        uint64_t reserved_1 : 9;
        uint64_t debug_register_access_detected : 1;
        uint64_t single_instruction : 1;
    };

    uint64_t flags;
} vmx_exit_qualification_debug_exception;

typedef union {
    struct {
        uint64_t selector : 16;
        uint64_t reserved_1 : 14;
        uint64_t type : 2;
#define VMX_EXIT_QUALIFICATION_TYPE_CALL                             0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET                             0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP                              0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_IDT                              0x00000003
    };

    uint64_t flags;
} vmx_exit_qualification_task_switch;

typedef union {
    struct {
        uint64_t cr_number : 4;
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008
        uint64_t access_type : 2;
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003
        uint64_t lmsw_operand_type : 1;
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        uint64_t reserved_1 : 1;
        uint64_t gp_register : 4;
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        uint64_t reserved_2 : 4;
        uint64_t lmsw_source_data : 16;
    };

    uint64_t flags;
} vmx_exit_qualification_cr_access;

typedef union {
    struct {
        uint64_t dr_number : 3;
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        uint64_t reserved_1 : 1;
        uint64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        uint64_t reserved_2 : 3;
        uint64_t gp_register : 4;
    };

    uint64_t flags;
} vmx_exit_qualification_dr_access;

typedef union {
    struct {
        uint64_t size_of_access : 3;
#define VMX_EXIT_QUALIFICATION_WIDTH_1B                              0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2B                              0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4B                              0x00000003
        uint64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001
        uint64_t string_instruction : 1;
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001
        uint64_t rep_prefixed : 1;
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001
        uint64_t operand_encoding : 1;
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMM                          0x00000001
        uint64_t reserved_1 : 9;
        uint64_t port_number : 16;
    };

    uint64_t flags;
} vmx_exit_qualification_io_inst;

typedef union {
    struct {
        uint64_t page_offset : 12;
        uint64_t access_type : 4;
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTR_FETCH               0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTR                   0x0000000F
    };

    uint64_t flags;
} vmx_exit_qualification_apic_access;

typedef union {
    struct {
        uint64_t data_read : 1;
        uint64_t data_write : 1;
        uint64_t instruction_fetch : 1;
        uint64_t entry_present : 1;
        uint64_t entry_write : 1;
        uint64_t entry_execute : 1;
        uint64_t entry_execute_for_user_mode : 1;
        uint64_t valid_guest_linear_address : 1;
        uint64_t ept_translated_access : 1;
        uint64_t user_mode_linear_address : 1;
        uint64_t readable_writable_page : 1;
        uint64_t execute_disable_page : 1;
        uint64_t nmi_unblocking : 1;
        uint64_t shadow_stack_access : 1;
        uint64_t supervisor_shadow_stack : 1;
        uint64_t guest_paging_verification : 1;
        uint64_t asynchronous_to_instruction : 1;
    };

    uint64_t flags;
} vmx_exit_qualification_ept_violation;

/**
 * @}
 */

 /**
  * @defgroup vmx_vmexit_instruction_information \
  *           Information for VM Exits Due to Instruction Execution
  * @{
  */
typedef union {
    struct {
        uint64_t reserved_1 : 7;
        uint64_t address_size : 3;
        uint64_t reserved_2 : 5;
        uint64_t segment_register : 3;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_ins_outs;

typedef union {
    struct {
        uint64_t scaling : 2;
        uint64_t reserved_1 : 5;
        uint64_t address_size : 3;
        uint64_t reserved_2 : 5;
        uint64_t segment_register : 3;
        uint64_t gp_register : 4;
        uint64_t gp_register_invalid : 1;
        uint64_t base_register : 4;
        uint64_t base_register_invalid : 1;
        uint64_t register_2 : 4;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_invalidate;

typedef union {
    struct {
        uint64_t scaling : 2;
        uint64_t reserved_1 : 5;
        uint64_t address_size : 3;
        uint64_t reserved_2 : 1;
        uint64_t operand_size : 1;
        uint64_t reserved_3 : 3;
        uint64_t segment_register : 3;
        uint64_t gp_register : 4;
        uint64_t gp_register_invalid : 1;
        uint64_t base_register : 4;
        uint64_t base_register_invalid : 1;
        uint64_t instruction_identity : 2;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_gdtr_idtr_access;

typedef union {
    struct {
        uint64_t scaling : 2;
        uint64_t reserved_1 : 1;
        uint64_t reg_1 : 4;
        uint64_t address_size : 3;
        uint64_t memory_register : 1;
        uint64_t reserved_2 : 4;
        uint64_t segment_register : 3;
        uint64_t gp_register : 4;
        uint64_t gp_register_invalid : 1;
        uint64_t base_register : 4;
        uint64_t base_register_invalid : 1;
        uint64_t instruction_identity : 2;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_ldtr_tr_access;

typedef union {
    struct {
        uint64_t reserved_1 : 3;
        uint64_t destination_register : 4;
        uint64_t reserved_2 : 4;
        uint64_t operand_size : 2;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_rdrand_rdseed;

typedef union {
    struct {
        uint64_t scaling : 2;
        uint64_t reserved_1 : 5;
        uint64_t address_size : 3;
        uint64_t reserved_2 : 5;
        uint64_t segment_register : 3;
        uint64_t gp_register : 4;
        uint64_t gp_register_invalid : 1;
        uint64_t base_register : 4;
        uint64_t base_register_invalid : 1;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_vmx_and_xsaves;

typedef union {
    struct {
        uint64_t scaling : 2;
        uint64_t reserved_1 : 1;
        uint64_t register_1 : 4;
        uint64_t address_size : 3;
        uint64_t memory_register : 1;
        uint64_t reserved_2 : 4;
        uint64_t segment_register : 3;
        uint64_t gp_register : 4;
        uint64_t gp_register_invalid : 1;
        uint64_t base_register : 4;
        uint64_t base_register_invalid : 1;
        uint64_t register_2 : 4;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_vmread_vmwrite;

/**
 * @}
 */

typedef union {
    struct {
        uint32_t type : 4;
        uint32_t descriptor_type : 1;
        uint32_t descriptor_privilege_level : 2;
        uint32_t present : 1;
        uint32_t reserved_1 : 4;
        uint32_t available_bit : 1;
        uint32_t long_mode : 1;
        uint32_t default_big : 1;
        uint32_t granularity : 1;
        uint32_t unusable : 1;
    };

    uint32_t flags;
} vmx_segment_access_rights;

typedef union {
    struct {
        uint32_t blocking_by_sti : 1;
        uint32_t blocking_by_mov_ss : 1;
        uint32_t blocking_by_smi : 1;
        uint32_t blocking_by_nmi : 1;
        uint32_t enclave_interruption : 1;
    };

    uint32_t flags;
} vmx_interruptibility_state;

typedef enum {
    vmx_active = 0x00000000,
    vmx_hlt = 0x00000001,
    vmx_shutdown = 0x00000002,
    vmx_wait_for_sipi = 0x00000003,
} vmx_guest_activity_state;

typedef union {
    struct {
        uint64_t b0 : 1;
        uint64_t b1 : 1;
        uint64_t b2 : 1;
        uint64_t b3 : 1;
        uint64_t reserved_1 : 8;
        uint64_t enabled_breakpoint : 1;
        uint64_t reserved_2 : 1;
        uint64_t bs : 1;
        uint64_t reserved_3 : 1;
        uint64_t rtm : 1;
    };

    uint64_t flags;
} vmx_pending_debug_exceptions;

/**
 * @}
 */

typedef union {
    struct {
        uint32_t basic_exit_reason : 16;
        uint32_t always0 : 1;
        uint32_t reserved1 : 10;
        uint32_t enclave_mode : 1;
        uint32_t pending_mtf_vm_exit : 1;
        uint32_t vm_exit_from_vmx_root : 1;
        uint32_t reserved2 : 1;
        uint32_t vm_entry_failure : 1;
    };

    uint32_t flags;
} vmx_vmexit_reason;

typedef struct {
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    uint8_t io_a[4096];
    uint8_t io_b[4096];
} vmx_io_bitmap;

typedef struct {
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    uint8_t rdmsr_low[1024];
    uint8_t rdmsr_high[1024];
    uint8_t wrmsr_low[1024];
    uint8_t wrmsr_high[1024];
} vmx_msr_bitmap;

/**
 * @defgroup ept \
 *           The extended page-table mechanism
 * @{
 */
typedef union {
    struct {
        uint64_t memory_type : 3;
        uint64_t page_walk_length : 3;
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003
        uint64_t enable_access_and_dirty_flags : 1;
        uint64_t enable_supervisor_shadow_stack_pages : 1;
        uint64_t reserved_1 : 4;
        uint64_t page_frame_number : 36;
    };

    uint64_t flags;
} eptp;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t reserved_1 : 5;
        uint64_t accessed : 1;
        uint64_t reserved_2 : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_3 : 1;
        uint64_t page_frame_number : 36;
    };

    uint64_t flags;
} epml4e;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t memory_type : 3;
        uint64_t ignore_pat : 1;
        uint64_t large_page : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_1 : 19;
        uint64_t page_frame_number : 18;
        uint64_t reserved_2 : 9;
        uint64_t verify_guest_paging : 1;
        uint64_t paging_write_access : 1;
        uint64_t reserved_3 : 1;
        uint64_t supervisor_shadow_stack : 1;
        uint64_t reserved_4 : 2;
        uint64_t suppress_ve : 1;
    };

    uint64_t flags;
} epdpte_1gb;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t reserved_1 : 5;
        uint64_t accessed : 1;
        uint64_t reserved_2 : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_3 : 1;
        uint64_t page_frame_number : 36;
    };

    uint64_t flags;
} epdpte;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t memory_type : 3;
        uint64_t ignore_pat : 1;
        uint64_t large_page : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_1 : 10;
        uint64_t page_frame_number : 27;
        uint64_t reserved_2 : 9;
        uint64_t verify_guest_paging : 1;
        uint64_t paging_write_access : 1;
        uint64_t reserved_3 : 1;
        uint64_t supervisor_shadow_stack : 1;
        uint64_t reserved_4 : 2;
        uint64_t suppress_ve : 1;
    };

    uint64_t flags;
} epde_2mb;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t reserved_1 : 5;
        uint64_t accessed : 1;
        uint64_t reserved_2 : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_3 : 1;
        uint64_t page_frame_number : 36;
    };

    uint64_t flags;
} epde;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t memory_type : 3;
        uint64_t ignore_pat : 1;
        uint64_t reserved_1 : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_2 : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_3 : 9;
        uint64_t verify_guest_paging : 1;
        uint64_t paging_write_access : 1;
        uint64_t reserved_4 : 1;
        uint64_t supervisor_shadow_stack : 1;
        uint64_t sub_page_write_permissions : 1;
        uint64_t reserved_5 : 1;
        uint64_t suppress_ve : 1;
    };

    uint64_t flags;
} epte;

typedef union {
    struct {
        uint64_t read_access : 1;
        uint64_t write_access : 1;
        uint64_t execute_access : 1;
        uint64_t memory_type : 3;
        uint64_t ignore_pat : 1;
        uint64_t large_page : 1;
        uint64_t accessed : 1;
        uint64_t dirty : 1;
        uint64_t user_mode_execute : 1;
        uint64_t reserved_1 : 1;
        uint64_t page_frame_number : 36;
        uint64_t reserved_2 : 15;
        uint64_t suppress_ve : 1;
    };

    uint64_t flags;
} ept_entry;

/**
 * @defgroup ept_table_level \
 *           EPT Table level numbers
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup ept_entry_count \
   *           EPT Entry counts
   * @{
   */
#define EPML4_ENTRY_COUNT                                            0x00000200
#define EPDPTE_ENTRY_COUNT                                           0x00000200
#define EPDE_ENTRY_COUNT                                             0x00000200
#define EPTE_ENTRY_COUNT                                             0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum {
    invept_single_context = 0x00000001,
    invept_all_context = 0x00000002,
} invept_type;

typedef enum {
    invvpid_individual_address = 0x00000000,
    invvpid_single_context = 0x00000001,
    invvpid_all_context = 0x00000002,
    invvpid_single_context_retaining_globals = 0x00000003,
} invvpid_type;

typedef struct {
    uint64_t ept_pointer;
    uint64_t reserved;
} invept_descriptor;

typedef struct {
    uint16_t vpid;
    uint16_t reserved1;
    uint32_t reserved2;
    uint64_t linear_address;
} invvpid_descriptor;

typedef union {
    struct {
        uint64_t reserved_1 : 3;
        uint64_t page_level_write_through : 1;
        uint64_t page_level_cache_disable : 1;
        uint64_t reserved_2 : 7;
        uint64_t page_frame_number : 36;
    };

    uint64_t flags;
} hlatp;

typedef struct {
    struct {
        uint32_t revision_id : 31;
        uint32_t shadow_vmcs_indicator : 1;
    };

    uint32_t abort_indicator;
    uint8_t data[4088];
} vmcs;

typedef struct {
    struct {
        uint32_t revision_id : 31;
        uint32_t must_be_zero : 1;
    };

    uint8_t data[4092];
} vmxon;

/**
 * @defgroup vmcs_fields \
 *           VMCS (VM Control Structure)
 * @{
 */
typedef union {
    struct {
        uint16_t access_type : 1;
        uint16_t index : 9;
        uint16_t type : 2;
        uint16_t must_be_zero : 1;
        uint16_t width : 2;
    };

    uint16_t flags;
} vmcs_component_encoding;

/**
 * @defgroup vmcs_16_bit \
 *           16-Bit Fields
 * @{
 */
 /**
  * @defgroup vmcs_16_bit_control_fields \
  *           16-Bit Control Fields
  * @{
  */
#define VMCS_CTRL_VPID                                               0x00000000
#define VMCS_CTRL_POSTED_INTR_NOTIFY_VECTOR                          0x00000002
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
#define VMCS_CTRL_HLAT_PREFIX_SIZE                                   0x00000006
  /**
   * @}
   */

   /**
    * @defgroup vmcs_16_bit_guest_state_fields \
    *           16-Bit Guest-State Fields
    * @{
    */
#define VMCS_GUEST_ES_SEL                                            0x00000800
#define VMCS_GUEST_CS_SEL                                            0x00000802
#define VMCS_GUEST_SS_SEL                                            0x00000804
#define VMCS_GUEST_DS_SEL                                            0x00000806
#define VMCS_GUEST_FS_SEL                                            0x00000808
#define VMCS_GUEST_GS_SEL                                            0x0000080A
#define VMCS_GUEST_LDTR_SEL                                          0x0000080C
#define VMCS_GUEST_TR_SEL                                            0x0000080E
#define VMCS_GUEST_INTR_STATUS                                       0x00000810
#define VMCS_GUEST_PML_INDEX                                         0x00000812
    /**
     * @}
     */

     /**
      * @defgroup vmcs_16_bit_host_state_fields \
      *           16-Bit Host-State Fields
      * @{
      */
#define VMCS_HOST_ES_SEL                                             0x00000C00
#define VMCS_HOST_CS_SEL                                             0x00000C02
#define VMCS_HOST_SS_SEL                                             0x00000C04
#define VMCS_HOST_DS_SEL                                             0x00000C06
#define VMCS_HOST_FS_SEL                                             0x00000C08
#define VMCS_HOST_GS_SEL                                             0x00000C0A
#define VMCS_HOST_TR_SEL                                             0x00000C0C
      /**
       * @}
       */

       /**
        * @}
        */

        /**
         * @defgroup vmcs_64_bit \
         *           64-Bit Fields
         * @{
         */
         /**
          * @defgroup vmcs_64_bit_control_fields \
          *           64-Bit Control Fields
          * @{
          */
#define VMCS_CTRL_IO_BITMAP_A                                        0x00002000
#define VMCS_CTRL_IO_BITMAP_B                                        0x00002002
#define VMCS_CTRL_MSR_BITMAP                                         0x00002004
#define VMCS_CTRL_VMEXIT_MSR_STORE                                   0x00002006
#define VMCS_CTRL_VMEXIT_MSR_LOAD                                    0x00002008
#define VMCS_CTRL_VMENTRY_MSR_LOAD                                   0x0000200A
#define VMCS_CTRL_EXEC_VMCS_PTR                                      0x0000200C
#define VMCS_CTRL_PML_ADDR                                           0x0000200E
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010
#define VMCS_CTRL_VAPIC_PAGEADDR                                     0x00002012
#define VMCS_CTRL_APIC_ACCESSADDR                                    0x00002014
#define VMCS_CTRL_POSTED_INTR_DESC                                   0x00002016
#define VMCS_CTRL_VMFUNC_CTRLS                                       0x00002018
#define VMCS_CTRL_EPTP                                               0x0000201A
#define VMCS_CTRL_EOI_BITMAP_0                                       0x0000201C
#define VMCS_CTRL_EOI_BITMAP_1                                       0x0000201E
#define VMCS_CTRL_EOI_BITMAP_2                                       0x00002020
#define VMCS_CTRL_EOI_BITMAP_3                                       0x00002022
#define VMCS_CTRL_EPTP_LIST                                          0x00002024
#define VMCS_CTRL_VMREAD_BITMAP                                      0x00002026
#define VMCS_CTRL_VMWRITE_BITMAP                                     0x00002028
#define VMCS_CTRL_VIRTXCPT_INFO_ADDR                                 0x0000202A
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E
#define VMCS_CTRL_SPP_TABLE_POINTER                                  0x00002030
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032
#define VMCS_CTRL_PROC_EXEC3                                         0x00002034
#define VMCS_CTRL_ENCLV_EXITING_BITMAP                               0x00002036
#define VMCS_CTRL_HLATP                                              0x00002040
#define VMCS_CTRL_SECONDARY_EXIT                                     0x00002044
          /**
           * @}
           */

           /**
            * @defgroup vmcs_64_bit_read_only_data_fields \
            *           64-Bit Read-Only Data Field
            * @{
            */
#define VMCS_GUEST_PHYS_ADDR                                         0x00002400
            /**
             * @}
             */

             /**
              * @defgroup vmcs_64_bit_guest_state_fields \
              *           64-Bit Guest-State Fields
              * @{
              */
#define VMCS_GUEST_VMCS_LINK_PTR                                     0x00002800
#define VMCS_GUEST_DEBUGCTL                                          0x00002802
#define VMCS_GUEST_PAT                                               0x00002804
#define VMCS_GUEST_EFER                                              0x00002806
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808
#define VMCS_GUEST_PDPTE0                                            0x0000280A
#define VMCS_GUEST_PDPTE1                                            0x0000280C
#define VMCS_GUEST_PDPTE2                                            0x0000280E
#define VMCS_GUEST_PDPTE3                                            0x00002810
#define VMCS_GUEST_BNDCFGS                                           0x00002812
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
#define VMCS_GUEST_LBR_CTL                                           0x00002816
#define VMCS_GUEST_PKRS                                              0x00002818
              /**
               * @}
               */

               /**
                * @defgroup vmcs_64_bit_host_state_fields \
                *           64-Bit Host-State Fields
                * @{
                */
#define VMCS_HOST_PAT                                                0x00002C00
#define VMCS_HOST_EFER                                               0x00002C02
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
#define VMCS_HOST_PKRS                                               0x00002C06
                /**
                 * @}
                 */

                 /**
                  * @}
                  */

                  /**
                   * @defgroup vmcs_32_bit \
                   *           32-Bit Fields
                   * @{
                   */
                   /**
                    * @defgroup vmcs_32_bit_control_fields \
                    *           32-Bit Control Fields
                    * @{
                    */
#define VMCS_CTRL_PIN_EXEC                                           0x00004000
#define VMCS_CTRL_PROC_EXEC                                          0x00004002
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004
#define VMCS_CTRL_PAGEFAULT_ERROR_MASK                               0x00004006
#define VMCS_CTRL_PAGEFAULT_ERROR_MATCH                              0x00004008
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A
#define VMCS_CTRL_PRIMARY_EXIT                                       0x0000400C
#define VMCS_CTRL_EXIT_MSR_STORE_COUNT                               0x0000400E
#define VMCS_CTRL_EXIT_MSR_LOAD_COUNT                                0x00004010
#define VMCS_CTRL_ENTRY                                              0x00004012
#define VMCS_CTRL_ENTRY_MSR_LOAD_COUNT                               0x00004014
#define VMCS_CTRL_ENTRY_INTERRUPTION_INFO                            0x00004016
#define VMCS_CTRL_ENTRY_EXCEPTION_ERRCODE                            0x00004018
#define VMCS_CTRL_ENTRY_INSTR_LENGTH                                 0x0000401A
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C
#define VMCS_CTRL_PROC_EXEC2                                         0x0000401E
#define VMCS_CTRL_PLE_GAP                                            0x00004020
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                    /**
                     * @}
                     */

                     /**
                      * @defgroup vmcs_32_bit_read_only_data_fields \
                      *           32-Bit Read-Only Data Fields
                      * @{
                      */
#define VMCS_VM_INSTR_ERROR                                          0x00004400
#define VMCS_EXIT_REASON                                             0x00004402
#define VMCS_EXIT_INTERRUPTION_INFO                                  0x00004404
#define VMCS_EXIT_INTERRUPTION_ERROR_CODE                            0x00004406
#define VMCS_IDT_VECTORING_INFO                                      0x00004408
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A
#define VMCS_EXIT_INSTR_LENGTH                                       0x0000440C
#define VMCS_EXIT_INSTR_INFO                                         0x0000440E
                      /**
                       * @}
                       */

                       /**
                        * @defgroup vmcs_32_bit_guest_state_fields \
                        *           32-Bit Guest-State Fields
                        * @{
                        */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800
#define VMCS_GUEST_CS_LIMIT                                          0x00004802
#define VMCS_GUEST_SS_LIMIT                                          0x00004804
#define VMCS_GUEST_DS_LIMIT                                          0x00004806
#define VMCS_GUEST_FS_LIMIT                                          0x00004808
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826
#define VMCS_GUEST_SMBASE                                            0x00004828
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A
#define VMCS_GUEST_PREEMPT_TIMER_VALUE                               0x0000482E
                        /**
                         * @}
                         */

                         /**
                          * @defgroup vmcs_32_bit_host_state_fields \
                          *           32-Bit Host-State Field
                          * @{
                          */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                          /**
                           * @}
                           */

                           /**
                            * @}
                            */

                            /**
                             * @defgroup vmcs_natural_width \
                             *           Natural-Width Fields
                             * @{
                             */
                             /**
                              * @defgroup vmcs_natural_width_control_fields \
                              *           Natural-Width Control Fields
                              * @{
                              */
#define VMCS_CTRL_CR0_MASK                                           0x00006000
#define VMCS_CTRL_CR4_MASK                                           0x00006002
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006
#define VMCS_CTRL_CR3_TARGET_VAL0                                    0x00006008
#define VMCS_CTRL_CR3_TARGET_VAL1                                    0x0000600A
#define VMCS_CTRL_CR3_TARGET_VAL2                                    0x0000600C
#define VMCS_CTRL_CR3_TARGET_VAL3                                    0x0000600E
                              /**
                               * @}
                               */

                               /**
                                * @defgroup vmcs_natural_width_read_only_data_fields \
                                *           Natural-Width Read-Only Data Fields
                                * @{
                                */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400
#define VMCS_IO_RCX                                                  0x00006402
#define VMCS_IO_RSI                                                  0x00006404
#define VMCS_IO_RDI                                                  0x00006406
#define VMCS_IO_RIP                                                  0x00006408
#define VMCS_EXIT_GUEST_LINEAR_ADDR                                  0x0000640A
                                /**
                                 * @}
                                 */

                                 /**
                                  * @defgroup vmcs_natural_width_guest_state_fields \
                                  *           Natural-Width Guest-State Fields
                                  * @{
                                  */
#define VMCS_GUEST_CR0                                               0x00006800
#define VMCS_GUEST_CR3                                               0x00006802
#define VMCS_GUEST_CR4                                               0x00006804
#define VMCS_GUEST_ES_BASE                                           0x00006806
#define VMCS_GUEST_CS_BASE                                           0x00006808
#define VMCS_GUEST_SS_BASE                                           0x0000680A
#define VMCS_GUEST_DS_BASE                                           0x0000680C
#define VMCS_GUEST_FS_BASE                                           0x0000680E
#define VMCS_GUEST_GS_BASE                                           0x00006810
#define VMCS_GUEST_LDTR_BASE                                         0x00006812
#define VMCS_GUEST_TR_BASE                                           0x00006814
#define VMCS_GUEST_GDTR_BASE                                         0x00006816
#define VMCS_GUEST_IDTR_BASE                                         0x00006818
#define VMCS_GUEST_DR7                                               0x0000681A
#define VMCS_GUEST_RSP                                               0x0000681C
#define VMCS_GUEST_RIP                                               0x0000681E
#define VMCS_GUEST_RFLAGS                                            0x00006820
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826
#define VMCS_GUEST_S_CET                                             0x00006C28
#define VMCS_GUEST_SSP                                               0x00006C2A
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x00006C2C
                                  /**
                                   * @}
                                   */

                                   /**
                                    * @defgroup vmcs_natural_width_host_state_fields \
                                    *           Natural-Width Host-State Fields
                                    * @{
                                    */
#define VMCS_HOST_CR0                                                0x00006C00
#define VMCS_HOST_CR3                                                0x00006C02
#define VMCS_HOST_CR4                                                0x00006C04
#define VMCS_HOST_FS_BASE                                            0x00006C06
#define VMCS_HOST_GS_BASE                                            0x00006C08
#define VMCS_HOST_TR_BASE                                            0x00006C0A
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12
#define VMCS_HOST_RSP                                                0x00006C14
#define VMCS_HOST_RIP                                                0x00006C16
#define VMCS_HOST_S_CET                                              0x00006C18
#define VMCS_HOST_SSP                                                0x00006C1A
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
                                    /**
                                     * @}
                                     */

                                     /**
                                      * @}
                                      */

                                      /**
                                       * @}
                                       */

typedef enum {
    external_interrupt = 0x00000000,
    non_maskable_interrupt = 0x00000002,
    hardware_exception = 0x00000003,
    software_interrupt = 0x00000004,
    privileged_software_exception = 0x00000005,
    software_exception = 0x00000006,
    other_event = 0x00000007,
} interruption_type;

typedef union {
    struct {
        uint32_t vector : 8;
        uint32_t interruption_type : 3;
        uint32_t deliver_error_code : 1;
        uint32_t reserved_1 : 19;
        uint32_t valid : 1;
    };

    uint32_t flags;
} vmentry_interrupt_info;

typedef union {
    struct {
        uint32_t vector : 8;
        uint32_t interruption_type : 3;
        uint32_t error_code_valid : 1;
        uint32_t nmi_unblocking : 1;
        uint32_t reserved_1 : 18;
        uint32_t valid : 1;
    };

    uint32_t flags;
} vmexit_interrupt_info;

/**
 * @}
 */

 /**
  * @defgroup apic \
  *           Advanced Programmable Interrupt Controller (APIC)
  * @{
  */
#define APIC_BASE                                                    0xFEE00000
#define APIC_ID                                                      0x00000020
#define APIC_VERSION                                                 0x00000030
#define APIC_TPR                                                     0x00000080
#define APIC_APR                                                     0x00000090
#define APIC_PPR                                                     0x000000A0
#define APIC_EOI                                                     0x000000B0
#define APIC_REMOTE_READ                                             0x000000C0
#define APIC_LOGICAL_DESTINATION                                     0x000000D0
#define APIC_DESTINATION_FORMAT                                      0x000000E0
#define APIC_SIV                                                     0x000000F0
#define APIC_ISR_31_0                                                0x00000100
#define APIC_ISR_63_32                                               0x00000110
#define APIC_ISR_95_64                                               0x00000120
#define APIC_ISR_127_96                                              0x00000130
#define APIC_ISR_159_128                                             0x00000140
#define APIC_ISR_191_160                                             0x00000150
#define APIC_ISR_223_192                                             0x00000160
#define APIC_ISR_255_224                                             0x00000170
#define APIC_TMR_31_0                                                0x00000180
#define APIC_TMR_63_32                                               0x00000190
#define APIC_TMR_95_64                                               0x000001A0
#define APIC_TMR_127_96                                              0x000001B0
#define APIC_TMR_159_128                                             0x000001C0
#define APIC_TMR_191_160                                             0x000001D0
#define APIC_TMR_223_192                                             0x000001E0
#define APIC_TMR_255_224                                             0x000001F0
#define APIC_IRR_31_0                                                0x00000200
#define APIC_IRR_63_32                                               0x00000210
#define APIC_IRR_95_64                                               0x00000220
#define APIC_IRR_127_96                                              0x00000230
#define APIC_IRR_159_128                                             0x00000240
#define APIC_IRR_191_160                                             0x00000250
#define APIC_IRR_223_192                                             0x00000260
#define APIC_IRR_255_224                                             0x00000270
#define APIC_ERROR_STATUS                                            0x00000280
#define APIC_CMCI                                                    0x000002F0
#define APIC_ICR_0_31                                                0x00000300
#define APIC_ICR_32_63                                               0x00000310
#define APIC_LVT_TIMER                                               0x00000320
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340
#define APIC_LVT_LINT0                                               0x00000350
#define APIC_LVT_LINT1                                               0x00000360
#define APIC_LVT_ERROR                                               0x00000370
#define APIC_INITIAL_COUNT                                           0x00000380
#define APIC_CURRENT_COUNT                                           0x00000390
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
  /**
   * @}
   */

typedef union {
    struct {
        uint32_t carry_flag : 1;
        uint32_t read_as_1 : 1;
        uint32_t parity_flag : 1;
        uint32_t reserved_1 : 1;
        uint32_t auxiliary_carry_flag : 1;
        uint32_t reserved_2 : 1;
        uint32_t zero_flag : 1;
        uint32_t sign_flag : 1;
        uint32_t trap_flag : 1;
        uint32_t interrupt_enable_flag : 1;
        uint32_t direction_flag : 1;
        uint32_t overflow_flag : 1;
        uint32_t io_privilege_level : 2;
        uint32_t nested_task_flag : 1;
        uint32_t reserved_3 : 1;
        uint32_t resume_flag : 1;
        uint32_t virtual_8086_mode_flag : 1;
        uint32_t alignment_check_flag : 1;
        uint32_t virtual_interrupt_flag : 1;
        uint32_t virtual_interrupt_pending_flag : 1;
        uint32_t identification_flag : 1;
    };

    uint32_t flags;
} efl;

typedef union {
    struct {
        uint64_t carry_flag : 1;
        uint64_t read_as_1 : 1;
        uint64_t parity_flag : 1;
        uint64_t reserved_1 : 1;
        uint64_t auxiliary_carry_flag : 1;
        uint64_t reserved_2 : 1;
        uint64_t zero_flag : 1;
        uint64_t sign_flag : 1;
        uint64_t trap_flag : 1;
        uint64_t interrupt_enable_flag : 1;
        uint64_t direction_flag : 1;
        uint64_t overflow_flag : 1;
        uint64_t io_privilege_level : 2;
        uint64_t nested_task_flag : 1;
        uint64_t reserved_3 : 1;
        uint64_t resume_flag : 1;
        uint64_t virtual_8086_mode_flag : 1;
        uint64_t alignment_check_flag : 1;
        uint64_t virtual_interrupt_flag : 1;
        uint64_t virtual_interrupt_pending_flag : 1;
        uint64_t identification_flag : 1;
    };

    uint64_t flags;
} rfl;

/**
 * @defgroup exceptions \
 *           Exceptions
 * @{
 */
typedef union {
    struct {
        uint32_t cpec : 15;
        uint32_t encl : 1;
    };

    uint32_t flags;
} control_protection_exception;

typedef enum {
    divide_error = 0x00000000,
    debug = 0x00000001,
    nmi = 0x00000002,
    breakpoint = 0x00000003,
    overflow = 0x00000004,
    bound_range_exceeded = 0x00000005,
    invalid_opcode = 0x00000006,
    device_not_available = 0x00000007,
    double_fault = 0x00000008,
    coprocessor_segment_overrun = 0x00000009,
    invalid_tss = 0x0000000A,
    segment_not_present = 0x0000000B,
    stack_segment_fault = 0x0000000C,
    general_protection = 0x0000000D,
    page_fault = 0x0000000E,
    x87_floating_point_error = 0x00000010,
    alignment_check = 0x00000011,
    machine_check = 0x00000012,
    simd_floating_point_error = 0x00000013,
    virtualization_exception = 0x00000014,
    control_protection = 0x00000015,
} exception_vector;

typedef union {
    struct {
        uint32_t external_event : 1;
        uint32_t descriptor_location : 1;
        uint32_t gdt_ldt : 1;
        uint32_t index : 13;
    };

    uint32_t flags;
} exception_error_code;

typedef union {
    struct {
        uint32_t present : 1;
        uint32_t write : 1;
        uint32_t user_mode_access : 1;
        uint32_t reserved_bit_violation : 1;
        uint32_t execute : 1;
        uint32_t protection_key_violation : 1;
        uint32_t shadow_stack : 1;
        uint32_t hlat : 1;
        uint32_t reserved_1 : 7;
        uint32_t sgx : 1;
    };

    uint32_t flags;
} page_fault_exception;

/**
 * @}
 */

 /**
  * @defgroup memory_type \
  *           Memory caching type
  * @{
  */
#define MEMORY_TYPE_UC                                               0x00000000
#define MEMORY_TYPE_WC                                               0x00000001
#define MEMORY_TYPE_WT                                               0x00000004
#define MEMORY_TYPE_WP                                               0x00000005
#define MEMORY_TYPE_WB                                               0x00000006
#define MEMORY_TYPE_UC_MINUS                                         0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
  /**
   * @}
   */

   /**
    * @defgroup vtd \
    *           VTD
    * @{
    */
typedef struct {
    union {
        struct {
            uint64_t present : 1;
            uint64_t reserved_1 : 11;
            uint64_t context_table_pointer : 52;
        };

        uint64_t flags;
    } lower64;

    union {
        struct {
            uint64_t reserved : 64;
        };

        uint64_t flags;
    } upper64;

} vtd_root_entry;

typedef struct {
    union {
        struct {
            uint64_t present : 1;
            uint64_t fault_processing_disable : 1;
            uint64_t translation_type : 2;
            uint64_t reserved_1 : 8;
            uint64_t second_level_page_translation_pointer : 52;
        };

        uint64_t flags;
    } lower64;

    union {
        struct {
            uint64_t address_width : 3;
            uint64_t ignored : 4;
            uint64_t reserved_1 : 1;
            uint64_t domain_identifier : 10;
        };

        uint64_t flags;
    } upper64;

} vtd_context_entry;

/**
 * @defgroup vtd_entry_count \
 *           Table entry counts
 * @{
 */
#define VTD_ROOT_ENTRY_COUNT                                         0x00000100
#define VTD_CONTEXT_ENTRY_COUNT                                      0x00000100
 /**
  * @}
  */

#define VTD_VERSION                                                  0x00000000
typedef union {
    struct {
        uint32_t minor : 4;
        uint32_t major : 4;
    };

    uint32_t flags;
} vtd_version_register;

#define VTD_CAPABILITY                                               0x00000008
typedef union {
    struct {
        uint64_t number_of_domains_supported : 3;
        uint64_t advanced_fault_logging : 1;
        uint64_t required_write_buffer_flushing : 1;
        uint64_t protected_low_memory_region : 1;
        uint64_t protected_high_memory_region : 1;
        uint64_t caching_mode : 1;
        uint64_t supported_adjusted_guest_address_widths : 5;
        uint64_t reserved_1 : 3;
        uint64_t maximum_guest_address_width : 6;
        uint64_t zero_length_read : 1;
        uint64_t deprecated : 1;
        uint64_t fault_recording_register_offset : 10;
        uint64_t second_level_large_page_support : 4;
        uint64_t reserved_2 : 1;
        uint64_t page_selective_invalidation : 1;
        uint64_t number_of_fault_recording_registers : 8;
        uint64_t maximum_address_mask_value : 6;
        uint64_t write_draining : 1;
        uint64_t read_draining : 1;
        uint64_t first_level_1gbyte_page_support : 1;
        uint64_t reserved_3 : 2;
        uint64_t posted_interrupts_support : 1;
        uint64_t first_level_5level_paging_support : 1;
        uint64_t reserved_4 : 1;
        uint64_t enhanced_set_interrupt_remap_table_pointer_support : 1;
        uint64_t enhanced_set_root_table_pointer_support : 1;
    };

    uint64_t flags;
} vtd_capability_register;

#define VTD_EXTENDED_CAPABILITY                                      0x00000010
typedef union {
    struct {
        uint64_t page_walk_coherency : 1;
        uint64_t queued_invalidation_support : 1;
        uint64_t device_tlb_support : 1;
        uint64_t interrupt_remapping_support : 1;
        uint64_t extended_interrupt_mode : 1;
        uint64_t deprecated1 : 1;
        uint64_t pass_through : 1;
        uint64_t snoop_control : 1;
        uint64_t iotlb_register_offset : 10;
        uint64_t reserved_1 : 2;
        uint64_t maximum_handle_mask_value : 4;
        uint64_t deprecated2 : 1;
        uint64_t memory_type_support : 1;
        uint64_t nested_translation_support : 1;
        uint64_t reserved_2 : 1;
        uint64_t deprecated3 : 1;
        uint64_t page_request_support : 1;
        uint64_t execute_request_support : 1;
        uint64_t reserved_3 : 2;
        uint64_t no_write_flag_support : 1;
        uint64_t extended_accessed_flag_support : 1;
        uint64_t pasid_size_supported : 5;
        uint64_t process_address_space_id_support : 1;
        uint64_t device_tlb_invalidation_throttle : 1;
        uint64_t page_request_drain_support : 1;
        uint64_t scalable_mode_translation_support : 1;
        uint64_t virtual_command_support : 1;
        uint64_t second_level_accessed_dirty_support : 1;
        uint64_t second_level_translation_support : 1;
        uint64_t first_level_translation_support : 1;
        uint64_t scalable_mode_page_walk_coherency : 1;
        uint64_t rid_pasid_support : 1;
        uint64_t reserved_4 : 2;
        uint64_t abort_dma_mode_support : 1;
        uint64_t rid_priv_support : 1;
    };

    uint64_t flags;
} vtd_extended_capability_register;

#define VTD_GLOBAL_COMMAND                                           0x00000018
typedef union {
    struct {
        uint32_t reserved_1 : 23;
        uint32_t compatibility_format_interrupt : 1;
        uint32_t set_interrupt_remap_table_pointer : 1;
        uint32_t interrupt_remapping_enable : 1;
        uint32_t queued_invalidation_enable : 1;
        uint32_t write_buffer_flush : 1;
        uint32_t enable_advanced_fault_logging : 1;
        uint32_t set_fault_log : 1;
        uint32_t set_root_table_pointer : 1;
        uint32_t translation_enable : 1;
    };

    uint32_t flags;
} vtd_global_command_register;

#define VTD_GLOBAL_STATUS                                            0x0000001C
typedef union {
    struct {
        uint32_t reserved_1 : 23;
        uint32_t compatibility_format_interrupt_status : 1;
        uint32_t interrupt_remapping_table_pointer_status : 1;
        uint32_t interrupt_remapping_enable_status : 1;
        uint32_t queued_invalidation_enable_status : 1;
        uint32_t write_buffer_flush_status : 1;
        uint32_t advanced_fault_logging_status : 1;
        uint32_t fault_log_status : 1;
        uint32_t root_table_pointer_status : 1;
        uint32_t translation_enable_status : 1;
    };

    uint32_t flags;
} vtd_global_status_register;

#define VTD_ROOT_TABLE_ADDRESS                                       0x00000020
typedef union {
    struct {
        uint64_t reserved_1 : 10;
        uint64_t translation_table_mode : 2;
        uint64_t root_table_address : 52;
    };

    uint64_t flags;
} vtd_root_table_address_register;

#define VTD_CONTEXT_COMMAND                                          0x00000028
typedef union {
    struct {
        uint64_t domain_id : 16;
        uint64_t source_id : 16;
        uint64_t function_mask : 2;
        uint64_t reserved_1 : 25;
        uint64_t context_actual_invalidation_granularity : 2;
        uint64_t context_invalidation_request_granularity : 2;
        uint64_t invalidate_context_cache : 1;
    };

    uint64_t flags;
} vtd_context_command_register;

#define VTD_INVALIDATE_ADDRESS                                       0x00000000
typedef union {
    struct {
        uint64_t address_mask : 6;
        uint64_t invalidation_hint : 1;
        uint64_t reserved_1 : 5;
        uint64_t page_address : 52;
    };

    uint64_t flags;
} vtd_invalidate_address_register;

#define VTD_IOTLB_INVALIDATE                                         0x00000008
typedef union {
    struct {
        uint64_t reserved_1 : 32;
        uint64_t domain_id : 16;
        uint64_t drain_writes : 1;
        uint64_t drain_reads : 1;
        uint64_t reserved_2 : 7;
        uint64_t iotlb_actual_invalidation_granularity : 2;
        uint64_t reserved_3 : 1;
        uint64_t iotlb_invalidation_request_granularity : 2;
        uint64_t reserved_4 : 1;
        uint64_t invalidate_iotlb : 1;
    };

    uint64_t flags;
} vtd_iotlb_invalidate_register;

/**
 * @}
 */

typedef union {
    struct {
        uint64_t x87 : 1;
        uint64_t sse : 1;
        uint64_t avx : 1;
        uint64_t bndreg : 1;
        uint64_t bndcsr : 1;
        uint64_t opmask : 1;
        uint64_t zmm_hi256 : 1;
        uint64_t zmm_hi16 : 1;
        uint64_t reserved_1 : 1;
        uint64_t pkru : 1;
    };

    uint64_t flags;
} xcr0;

/**
 * @}
 */

#if defined(_MSC_EXTENSIONS)
#pragma warning(pop)
#endif

```

`kernel/ext/portable_executable/data_directory.cpp`:

```cpp
#include "data_directory.hpp"

bool portable_executable::data_directory_t::present() const
{
	return this->size != 0;
}

```

`kernel/ext/portable_executable/data_directory.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

#include "export_directory.hpp"

namespace portable_executable
{
    static constexpr pe_crt::size_t max_data_directories = 16;

    struct data_directory_t
    {
        pe_crt::uint32_t virtual_address;
        pe_crt::uint32_t size;

        bool present() const;
    };

#pragma warning(push)
#pragma warning(disable: 4201)

    struct data_directories_t
    {
        union
        {
            struct
            {
                data_directory_t export_directory;
                data_directory_t import_directory;
                data_directory_t resource_directory;
                data_directory_t exception_directory;
                data_directory_t security_directory;
                data_directory_t basereloc_directory;
                data_directory_t debug_directory;
                data_directory_t architecture_directory;
                data_directory_t globalptr_directory;
                data_directory_t tls_directory;
                data_directory_t load_config_directory;
                data_directory_t bound_import_directory;
                data_directory_t iat_directory;
                data_directory_t delay_import_directory;
                data_directory_t com_descriptor_directory;
                data_directory_t _reserved0;
            };

            data_directory_t entries[max_data_directories];
        };
    };

#pragma warning(pop)
}
```

`kernel/ext/portable_executable/dos_header.cpp`:

```cpp
#include "dos_header.hpp"

bool portable_executable::dos_header_t::valid() const
{
    return this->e_magic == dos_magic;
}

portable_executable::nt_headers_t* portable_executable::dos_header_t::nt_headers()
{
    return reinterpret_cast<nt_headers_t*>(reinterpret_cast<pe_crt::uintptr_t>(this) + this->e_lfanew);
}

const portable_executable::nt_headers_t* portable_executable::dos_header_t::nt_headers() const
{
    return reinterpret_cast<const nt_headers_t*>(reinterpret_cast<pe_crt::uintptr_t>(this) + this->e_lfanew);
}
```

`kernel/ext/portable_executable/dos_header.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

#include "nt_headers.hpp"

namespace portable_executable
{
    static constexpr pe_crt::uint16_t dos_magic = 0x5A4D;

    struct dos_header_t
    {
        pe_crt::uint16_t e_magic;
        pe_crt::uint16_t e_cblp;
        pe_crt::uint16_t e_cp;
        pe_crt::uint16_t e_crlc;
        pe_crt::uint16_t e_cparhdr;
        pe_crt::uint16_t e_minalloc;
        pe_crt::uint16_t e_maxalloc;
        pe_crt::uint16_t e_ss;
        pe_crt::uint16_t e_sp;
        pe_crt::uint16_t e_csum;
        pe_crt::uint16_t e_ip;
        pe_crt::uint16_t e_cs;
        pe_crt::uint16_t e_lfarlc;
        pe_crt::uint16_t e_ovno;
        pe_crt::uint16_t e_res[4];
        pe_crt::uint16_t e_oemid;
        pe_crt::uint16_t e_oeminfo;
        pe_crt::uint16_t e_res2[10];
        pe_crt::uint32_t e_lfanew;

        bool valid() const;

        nt_headers_t* nt_headers();

        const nt_headers_t* nt_headers() const;
    };
}
```

`kernel/ext/portable_executable/export_directory.cpp`:

```cpp
#include "export_directory.hpp"

#include "pe_crt/crt_string.hpp"

portable_executable::exports_iterator_t::exports_iterator_t(const pe_crt::uint8_t* module, const pe_crt::uint32_t* names, const pe_crt::uint32_t* functions, const pe_crt::uint16_t* ordinals, pe_crt::uint32_t index) :
	module(module), names(names), functions(functions), ordinals(ordinals), index(index)
{

}

portable_executable::exports_iterator_t::value_type portable_executable::exports_iterator_t::operator*() const
{
	pe_crt::uint32_t name_offset = this->names[this->index];

	pe_crt::uint16_t ordinal_offset = this->ordinals[this->index];

	pe_crt::uint32_t functions_offset = this->functions[ordinal_offset];

	auto export_name = reinterpret_cast<const char*>(this->module + name_offset);

	value_type type;

	pe_crt::strcpy(type.name, export_name);
	type.address = const_cast<pe_crt::uint8_t*>(this->module + functions_offset);

	return type;
}

portable_executable::exports_iterator_t& portable_executable::exports_iterator_t::operator++()
{
	++this->index;

	return *this;
}

bool portable_executable::exports_iterator_t::operator==(const exports_iterator_t& other)
{
	return this->index == other.index;
}

bool portable_executable::exports_iterator_t::operator!=(const exports_iterator_t& other)
{
	return this->index != other.index;
}

```

`kernel/ext/portable_executable/export_directory.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_type_traits.hpp"
#include "pe_crt/crt_types.hpp"
#include "pe_crt/crt_memory.hpp"

namespace portable_executable
{
    struct export_entry_t
    {
        char name[256];

        pe_crt::uint8_t* address;

        export_entry_t() : address(nullptr) { pe_crt::memset(this->name, 0, sizeof this->name); }
    };

    class exports_iterator_t
    {
    private:
        const pe_crt::uint8_t* module = nullptr;
        const pe_crt::uint32_t* names = nullptr;
        const pe_crt::uint32_t* functions = nullptr;
        const pe_crt::uint16_t* ordinals = nullptr;
        pe_crt::uint32_t index = 0;

    public:
        exports_iterator_t(const pe_crt::uint8_t* module, const pe_crt::uint32_t* names, const pe_crt::uint32_t* functions, const pe_crt::uint16_t* ordinals, pe_crt::uint32_t index);

        using value_type = export_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        exports_iterator_t& operator++();

        bool operator==(const exports_iterator_t& other);

        bool operator!=(const exports_iterator_t& other);
    };

    template<typename T>
    class exports_range_t
    {
    private:
        using pointer_type = typename pe_crt::conditional<pe_crt::is_const<T>::value, const pe_crt::uint8_t*, pe_crt::uint8_t*>::type;
        using uint32_pointer = typename pe_crt::conditional<pe_crt::is_const<T>::value, const pe_crt::uint32_t*, pe_crt::uint32_t*>::type;
        using uint16_pointer = typename pe_crt::conditional<pe_crt::is_const<T>::value, const pe_crt::uint16_t*, pe_crt::uint16_t*>::type;

        pointer_type m_module = nullptr;
        uint32_pointer m_names = nullptr;
        uint32_pointer m_functions = nullptr;
        uint16_pointer m_ordinals = nullptr;

        pe_crt::uint32_t m_num_exports = 0;

    public:
        exports_range_t() = default;

        exports_range_t(pointer_type module, uint32_pointer names, uint32_pointer functions, uint16_pointer ordinals, pe_crt::uint32_t num_exports) :
            m_module(module), m_names(names), m_functions(functions), m_ordinals(ordinals), m_num_exports(num_exports)
        {

        }

        T begin() const
        {
            return { this->m_module, this->m_names, this->m_functions, this->m_ordinals, 0 };
        }

        T end() const
        {
            return { this->m_module, this->m_names, this->m_functions, this->m_ordinals, this->m_num_exports };
        }
    };

    struct export_directory_t
    {
        pe_crt::uint32_t characteristics;
        pe_crt::uint32_t time_date_stamp;
        pe_crt::uint16_t major_version;
        pe_crt::uint16_t minor_version;
        pe_crt::uint32_t name;
        pe_crt::uint32_t base;
        pe_crt::uint32_t number_of_functions;
        pe_crt::uint32_t number_of_names;
        pe_crt::uint32_t address_of_functions;
        pe_crt::uint32_t address_of_names;
        pe_crt::uint32_t address_of_name_ordinals;
    };
}
```

`kernel/ext/portable_executable/file_header.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

namespace portable_executable
{
    struct file_header_t
    {
        pe_crt::uint16_t machine;
        pe_crt::uint16_t number_of_sections;
        pe_crt::uint32_t time_date_stamp;
        pe_crt::uint32_t pointer_to_symbol_table;
        pe_crt::uint32_t number_of_symbols;
        pe_crt::uint16_t sizeof_optional_header;
        pe_crt::uint16_t characteristics;
    };
}

```

`kernel/ext/portable_executable/image.cpp`:

```cpp
#include "image.hpp"

#include "pe_crt/crt_string.hpp"

portable_executable::dos_header_t* portable_executable::image_t::dos_header()
{
	return &this->m_dos_header;
}

const portable_executable::dos_header_t* portable_executable::image_t::dos_header() const
{
	return &this->m_dos_header;
}

portable_executable::nt_headers_t* portable_executable::image_t::nt_headers()
{
	return this->dos_header()->nt_headers();
}

const portable_executable::nt_headers_t* portable_executable::image_t::nt_headers() const
{
	return this->dos_header()->nt_headers();
}

portable_executable::section_header_t* portable_executable::image_t::find_section(const char* name)
{
	for (auto& section : this->sections())
	{
		if (pe_crt::strstr(section.name, name))
		{
			return &section;
		}
	}

	return nullptr;
}

const portable_executable::section_header_t* portable_executable::image_t::find_section(const char* name) const
{
	for (const auto& section : this->sections())
	{
		if (pe_crt::strstr(section.name, name))
		{
			return &section;
		}
	}

	return nullptr;
}

portable_executable::pe_crt::uint8_t* portable_executable::image_t::find_export(const char* name) const
{
	for (const auto& [export_name, export_address] : this->exports())
	{
		if (pe_crt::strstr(export_name, name))
		{
			return export_address;
		}
	}

	return nullptr;
}

portable_executable::pe_crt::uint8_t* portable_executable::image_t::signature_scan(const char* signature) const
{
	constexpr auto in_range = [=](char x, char a, char b) -> bool
	{
		return x >= a && x <= b;
	};

	constexpr auto get_bits = [=](char x) -> pe_crt::int8_t
	{
		if (x >= 'a' && x <= 'f')
		{
			x -= 0x20;
		}

		if (in_range(x, 'A', 'F'))
		{
			return x - 'A' + 0xA;
		}
		else if (in_range(x, '0', '9'))
		{
			return x - '0';
		}

		return 0;
	};

	constexpr auto get_byte = [=](const char* x) -> pe_crt::uint8_t
	{
		return static_cast<pe_crt::uint8_t>((get_bits(x[0]) << 4) | get_bits(x[1]));
	};

	constexpr auto compute_pattern_size = [](const char* pattern) -> pe_crt::size_t
	{
		pe_crt::size_t pattern_size = 0;

		while (*pattern)
		{
			if (*pattern == ' ')
			{
				pattern++;

				continue;
			}

			if (*pattern == '?')
			{
				pattern_size++;
				pattern++;

				continue;
			}

			if (((*pattern >= '0' && *pattern <= '9') ||
				(*pattern >= 'A' && *pattern <= 'F') ||
				(*pattern >= 'a' && *pattern <= 'f')) && 
				((*(pattern + 1) >= '0' && *(pattern + 1) <= '9') ||
				(*(pattern + 1) >= 'A' && *(pattern + 1) <= 'F')
				|| (*(pattern + 1) >= 'a' && *(pattern + 1) <= 'f')))
			{
				pattern_size++;
				pattern += 2;

				continue;
			}

			pattern++;
		}

		return pattern_size;
	};

	pe_crt::size_t pattern_size = compute_pattern_size(signature);

	if (!pattern_size)
	{
		return nullptr;
	}

	for (const auto& section : this->sections())
	{
		const pe_crt::uint8_t* section_start = this->as<const pe_crt::uint8_t*>() + section.virtual_address;
		const pe_crt::uint8_t* section_end = section_start + section.virtual_size;

		for (const pe_crt::uint8_t* byte = section_start; byte < (section_end - pattern_size); byte++)
		{
			const char* temp_signature = signature;

			bool found = true;

			for (pe_crt::size_t j = 0; j < pattern_size; j++)
			{
				if (*temp_signature != '?' && get_byte(temp_signature) != byte[j])
				{
					found = false;
					break;
				}

				temp_signature += *temp_signature != '\?' ? 3 : 2;
			}

			if (found)
			{
				return const_cast<pe_crt::uint8_t*>(byte);
			}
		}
	}

	return nullptr;
}

portable_executable::pe_crt::uint8_t* portable_executable::image_t::signature_scan(const pe_crt::uint8_t* pattern, pe_crt::size_t pattern_size) const
{
	for (const auto& section : this->sections())
	{
		const pe_crt::uint8_t* section_start = this->as<const pe_crt::uint8_t*>() + section.virtual_address;
		const pe_crt::uint8_t* section_end = section_start + section.virtual_size;

		for (const pe_crt::uint8_t* byte = section_start; byte < (section_end - pattern_size); byte++)
		{
			bool found = true;

			for (pe_crt::size_t j = 0; j < pattern_size; j++)
			{
				if (pattern[j] != 0x00 && pattern[j] != byte[j])
				{
					found = false;
					break;
				}
			}

			if (found)
			{
				return const_cast<pe_crt::uint8_t*>(byte);
			}
		}
	}

	return nullptr;
}

```

`kernel/ext/portable_executable/image.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

#include "dos_header.hpp"
#include "nt_headers.hpp"

#include "section_header.hpp"
#include "export_directory.hpp"
#include "imports_directory.hpp"
#include "relocations_directory.hpp"

namespace portable_executable
{
	class image_t
	{
	private:
		dos_header_t m_dos_header;

	public:
		template<typename T = pe_crt::uintptr_t>
		const T as() const
		{
			return reinterpret_cast<T>(this);
		}

		template<typename T = pe_crt::uintptr_t>
		T as()
		{
			return reinterpret_cast<T>(this);
		}

		dos_header_t* dos_header();

		const dos_header_t* dos_header() const;
		
		nt_headers_t* nt_headers();

		const nt_headers_t* nt_headers() const;

		section_iterator_t<section_header_t> sections()
		{
			return { this->nt_headers()->section_headers(), this->nt_headers()->num_sections() };
		}

		section_iterator_t<const section_header_t> sections() const
		{
			return { this->nt_headers()->section_headers(), this->nt_headers()->num_sections() };
		}

		exports_range_t<exports_iterator_t> exports()
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.export_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<pe_crt::uint8_t*>(this);

			auto export_directory = reinterpret_cast<export_directory_t*>(module + data_directory.virtual_address);

			auto names = reinterpret_cast<pe_crt::uint32_t*>(module + export_directory->address_of_names);
			auto functions = reinterpret_cast<pe_crt::uint32_t*>(module + export_directory->address_of_functions);
			auto ordinals = reinterpret_cast<pe_crt::uint16_t*>(module + export_directory->address_of_name_ordinals);

			return { module, names, functions, ordinals, export_directory->number_of_names };
		}

		exports_range_t<const exports_iterator_t> exports() const
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.export_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const pe_crt::uint8_t*>(this);

			auto export_directory = reinterpret_cast<const export_directory_t*>(module + data_directory.virtual_address);

			auto names = reinterpret_cast<const pe_crt::uint32_t*>(module + export_directory->address_of_names);
			auto functions = reinterpret_cast<const pe_crt::uint32_t*>(module + export_directory->address_of_functions);
			auto ordinals = reinterpret_cast<const pe_crt::uint16_t*>(module + export_directory->address_of_name_ordinals);

			return { module, names, functions, ordinals, export_directory->number_of_names };
		}

		imports_range_t<imports_iterator_t> imports()
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.import_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<pe_crt::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		imports_range_t<const imports_iterator_t> imports() const
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.import_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const pe_crt::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		relocations_range_t<relocations_iterator_t> relocations()
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.basereloc_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<pe_crt::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		relocations_range_t<const relocations_iterator_t> relocations() const
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.basereloc_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const pe_crt::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		section_header_t* find_section(const char* name);

		const section_header_t* find_section(const char* name) const;

		pe_crt::uint8_t* find_export(const char* name) const;

		// IDA signatures
		pe_crt::uint8_t* signature_scan(const char* signature) const;

		// byte signatures
		pe_crt::uint8_t* signature_scan(const pe_crt::uint8_t* pattern, pe_crt::size_t pattern_size) const;
	};
}
```

`kernel/ext/portable_executable/imports_directory.cpp`:

```cpp
#include "imports_directory.hpp"

#include "pe_crt/crt_string.hpp"

portable_executable::imports_iterator_t::imports_iterator_t(const pe_crt::uint8_t* module, const import_descriptor_t* descriptor) :
	module(module), current_descriptor(descriptor)
{
    if (this->current_descriptor && this->current_descriptor->first_thunk)
    {
        this->current_thunk = reinterpret_cast<const thunk_data_t*>(this->module + current_descriptor->first_thunk);
        this->original_thunk = reinterpret_cast<const thunk_data_t*>(this->module + current_descriptor->misc.original_first_thunk);
    }
}

portable_executable::imports_iterator_t::value_type portable_executable::imports_iterator_t::operator*() const
{
    value_type value;

    if (this->original_thunk->is_ordinal)
    {
        auto import_name = reinterpret_cast<const char*>(this->module + this->original_thunk->ordinal);

        pe_crt::strcpy(value.module_name, import_name);
    }
    else
    {
        auto import_by_name = reinterpret_cast<const import_by_name_t*>(this->module + this->original_thunk->address);

        pe_crt::strcpy(value.module_name, import_by_name->name);
    }
    
    auto module_name = reinterpret_cast<const char*>(this->module + this->current_descriptor->name);

    pe_crt::strcpy(value.module_name, module_name);

    value.address = reinterpret_cast<pe_crt::uint8_t*>(this->current_thunk->function);

    return value;
}

portable_executable::imports_iterator_t& portable_executable::imports_iterator_t::operator++()
{
    if (this->current_thunk && this->current_thunk->address)
    {
        ++this->current_thunk;
        ++this->original_thunk;

        if (!this->current_thunk->address)
        {
            ++this->current_descriptor;

            while (this->current_descriptor && this->current_descriptor->first_thunk)
            {
                this->current_thunk = reinterpret_cast<const thunk_data_t*>(this->module + this->current_descriptor->first_thunk);
                this->original_thunk = reinterpret_cast<const thunk_data_t*>(this->module + this->current_descriptor->misc.original_first_thunk);

                if (this->current_thunk->address)
                {
                    break;
                }

                ++this->current_descriptor;
            }

            if (!this->current_descriptor || !this->current_descriptor->first_thunk)
            {
                this->current_descriptor = nullptr;
                this->current_thunk = nullptr;
            }
        }
    }

    return *this;
}

bool portable_executable::imports_iterator_t::operator==(const imports_iterator_t& other)
{
    return this->current_descriptor == other.current_descriptor && this->current_thunk == other.current_thunk;
}

bool portable_executable::imports_iterator_t::operator!=(const imports_iterator_t& other)
{
    return this->current_descriptor != other.current_descriptor || this->current_thunk != other.current_thunk;
}

```

`kernel/ext/portable_executable/imports_directory.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_type_traits.hpp"
#include "pe_crt/crt_types.hpp"

namespace portable_executable
{
    struct import_descriptor_t
    {
        union
        {
            pe_crt::uint32_t characteristics;
            pe_crt::uint32_t original_first_thunk;
        } misc;

        pe_crt::uint32_t time_date_stamp;
        pe_crt::uint32_t forwarder_chain;
        pe_crt::uint32_t name;
        pe_crt::uint32_t first_thunk;
    };

#pragma warning(push)
#pragma warning(disable: 4201)

    struct thunk_data_t
    {
        union
        {
            pe_crt::uint64_t forwarder_string;
            pe_crt::uint64_t function;
            pe_crt::uint64_t address;

            struct
            {
                pe_crt::uint64_t ordinal : 16;
                pe_crt::uint64_t _reserved0 : 47;
                pe_crt::uint64_t is_ordinal : 1;
            };
        };
    };

#pragma warning(pop)

    struct import_by_name_t
    {
        pe_crt::uint16_t hint;
        char name[1];
    };

    struct import_entry_t
    {
        char module_name[256];
        char import_name[256];

        pe_crt::uint8_t* address;
    };

    class imports_iterator_t
    {
    private:
        const pe_crt::uint8_t* module = nullptr;

        const import_descriptor_t* current_descriptor = nullptr;
        const thunk_data_t* current_thunk = nullptr;
        const thunk_data_t* original_thunk = nullptr;

    public:
        imports_iterator_t(const pe_crt::uint8_t* module, const import_descriptor_t* descriptor);

        using value_type = import_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        imports_iterator_t& operator++();

        bool operator==(const imports_iterator_t& other);

        bool operator!=(const imports_iterator_t& other);
    };
    
    template<typename T>
    class imports_range_t
    {
    private:
        using pointer_type = typename pe_crt::conditional<pe_crt::is_const<T>::value, const pe_crt::uint8_t*, pe_crt::uint8_t*>::type;
        using import_descriptor_type = typename pe_crt::conditional<pe_crt::is_const<T>::value, const import_descriptor_t*, import_descriptor_t*>::type;

        pointer_type m_module = nullptr;

        import_descriptor_type m_import_descriptor = nullptr;

    public:
        imports_range_t() = default;

        imports_range_t(pointer_type module, pe_crt::uint32_t imports_rva) :
            m_module(module), m_import_descriptor(reinterpret_cast<import_descriptor_type>(module + imports_rva))
        {

        }

        T begin() const
        {
            return { this->m_module, this->m_import_descriptor };
        }

        T end() const
        {
            return { this->m_module, nullptr };
        }
    };
}
```

`kernel/ext/portable_executable/nt_headers.cpp`:

```cpp
#include "nt_headers.hpp"

bool portable_executable::nt_headers_t::valid() const
{
	return this->signature == nt_magic;
}

portable_executable::section_header_t* portable_executable::nt_headers_t::section_headers()
{
	return reinterpret_cast<section_header_t*>(reinterpret_cast<portable_executable::pe_crt::uintptr_t>(&this->optional_header) + this->file_header.sizeof_optional_header);
}

const portable_executable::section_header_t* portable_executable::nt_headers_t::section_headers() const
{
	return reinterpret_cast<const section_header_t*>(reinterpret_cast<portable_executable::pe_crt::uintptr_t>(&this->optional_header) + this->file_header.sizeof_optional_header);
}

portable_executable::pe_crt::uint16_t portable_executable::nt_headers_t::num_sections() const
{
	return this->file_header.number_of_sections;
}
```

`kernel/ext/portable_executable/nt_headers.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

#include "file_header.hpp"
#include "optional_header.hpp"

#include "section_header.hpp"

namespace portable_executable
{
    static constexpr pe_crt::uint32_t nt_magic = 0x00004550;

    struct nt_headers_t
    {
        pe_crt::uint32_t signature;
        file_header_t file_header;
        optional_header_t optional_header;

        bool valid() const;

        section_header_t* section_headers();

        const section_header_t* section_headers() const;

        pe_crt::uint16_t num_sections() const;
    };
} 
```

`kernel/ext/portable_executable/optional_header.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

#include "data_directory.hpp"

namespace portable_executable
{
    struct optional_header_t
    {
        pe_crt::uint16_t magic;
        pe_crt::uint8_t major_linker_version;
        pe_crt::uint8_t minor_linker_version;
        pe_crt::uint32_t size_of_code;
        pe_crt::uint32_t size_of_initialized_data;
        pe_crt::uint32_t size_of_uninitialized_data;
        pe_crt::uint32_t address_of_entry_point;
        pe_crt::uint32_t base_of_code;
        pe_crt::uint64_t image_base;
        pe_crt::uint32_t section_alignment;
        pe_crt::uint32_t file_alignment;
        pe_crt::uint16_t major_operating_system_version;
        pe_crt::uint16_t minor_operating_system_version;
        pe_crt::uint16_t major_image_version;
        pe_crt::uint16_t minor_image_version;
        pe_crt::uint16_t major_subsystem_version;
        pe_crt::uint16_t minor_subsystem_version;
        pe_crt::uint32_t win32_version_value;
        pe_crt::uint32_t size_of_image;
        pe_crt::uint32_t size_of_headers;
        pe_crt::uint32_t check_sum;
        pe_crt::uint16_t subsystem;
        pe_crt::uint16_t dll_characteristics;
        pe_crt::uint64_t size_of_stack_reserve;
        pe_crt::uint64_t size_of_stack_commit;
        pe_crt::uint64_t size_of_heap_reserve;
        pe_crt::uint64_t size_of_heap_commit;
        pe_crt::uint32_t loader_flags;
        pe_crt::uint32_t number_of_rva_and_sizes;
        data_directories_t data_directories;
    };
}
```

`kernel/ext/portable_executable/pe_crt/crt_memory.cpp`:

```cpp
#include "crt_memory.hpp"

#if !defined(__clang__)
#include <intrin.h>
#endif

void portable_executable::pe_crt::memcpy(void* destination, const void* source, pe_crt::size_t size)
{
#if defined(__clang__)
    __asm__ __volatile__(
        "1:\n\t"
        "movb (%1), %%al\n\t"
        "movb %%al, (%0)\n\t"
        "inc %0\n\t"
        "inc %1\n\t"
        "dec %2\n\t"
        "jnz 1b\n"
        : "=r" (destination), "=r" (source), "=r" (size)
        : "0" (destination), "1" (source), "2" (size)
        : "memory", "%al");
#else
    __movsb(static_cast<pe_crt::uint8_t*>(destination), static_cast<const pe_crt::uint8_t*>(source), size);
#endif
}

void portable_executable::pe_crt::memset(void* destination, pe_crt::uint8_t value, pe_crt::size_t size)
{
#if defined(__clang__)
    __asm__ __volatile__(
        "1:\n\t"
        "movb %1, (%0)\n\t"
        "inc %0\n\t"
        "dec %2\n\t"
        "jnz 1b\n"
        : "=r" (destination), "=r" (value), "=r" (size)
        : "0" (destination), "1" (value), "2" (size)
        : "memory");
#else
    __stosb(static_cast<pe_crt::uint8_t*>(destination), value, size);
#endif
}
```

`kernel/ext/portable_executable/pe_crt/crt_memory.hpp`:

```hpp
#pragma once

#include "crt_types.hpp"

namespace portable_executable::pe_crt
{
	void memcpy(void* destination, const void* source, pe_crt::size_t size);

	void memset(void* destination, pe_crt::uint8_t value, pe_crt::size_t size);
}
```

`kernel/ext/portable_executable/pe_crt/crt_string.cpp`:

```cpp
#include "crt_string.hpp"

portable_executable::pe_crt::size_t portable_executable::pe_crt::strlen(const char* str)
{
    const char* temp;

    for (temp = str; *temp; ++temp);

    return (temp - str);
}

portable_executable::pe_crt::size_t portable_executable::pe_crt::wstrlen(const wchar_t* str)
{
	const wchar_t* temp;

	for (temp = str; *temp; ++temp);

	return (temp - str) / sizeof(wchar_t);
}

portable_executable::pe_crt::int32_t portable_executable::pe_crt::strcmp(const char* str1, const char* str2)
{
    for (; *str1 == *str2; str1++, str2++)
    {
        if (*str1 == '\0')
        {
            return 0;
        }
    }

    return ((*reinterpret_cast<const pe_crt::uint8_t*>(str1) < *reinterpret_cast<const pe_crt::uint8_t*>(str2)) ? -1 : +1);
}

portable_executable::pe_crt::int32_t portable_executable::pe_crt::strncmp(const char* s1, const char* s2, pe_crt::size_t n)
{
	if (n == 0)
	{
		return 0;
	}

	do
	{
		if (*s1 != *s2++)
		{
			return (*reinterpret_cast<const pe_crt::uint8_t*>(s1) - *reinterpret_cast<const pe_crt::uint8_t*>(--s2));
		}

		if (*s1++ == 0)
		{
			break;
		}
	}
	while (--n != 0);

	return 0;
}

portable_executable::pe_crt::int32_t portable_executable::pe_crt::wstrncmp(const wchar_t* s1, const wchar_t* s2, pe_crt::size_t n)
{
	if (n == 0)
	{
		return 0;
	}

	do
	{
		if (*s1 != *s2++)
		{
			return (*reinterpret_cast<const pe_crt::uint8_t*>(s1) - *reinterpret_cast<const pe_crt::uint8_t*>(--s2));
		}

		if (*s1++ == 0)
		{
			break;
		}
	} while (--n != 0);

	return 0;
}

portable_executable::pe_crt::wchar_t* portable_executable::pe_crt::wcsstr(const wchar_t* s, const wchar_t* find)
{
	wchar_t c, sc;

	pe_crt::size_t len;

	if ((c = *find++) != 0)
	{
		len = pe_crt::wstrlen(find);

		do
		{
			do
			{
				if ((sc = *s++) == 0)
				{
					return nullptr;
				}
			}
			while (sc != c);
		}
		while (pe_crt::wstrncmp(s, find, len) != 0);

		s--;
	}

	return const_cast<wchar_t*>(s);
}

char* portable_executable::pe_crt::strstr(const char* s, const char* find)
{
	char c, sc;

	pe_crt::size_t len;

	if ((c = *find++) != 0)
	{
		len = pe_crt::strlen(find);

		do
		{
			do
			{
				if ((sc = *s++) == 0)
				{
					return nullptr;
				}
			} while (sc != c);
		} while (pe_crt::strncmp(s, find, len) != 0);

		s--;
	}

	return const_cast<char*>(s);
}

char* portable_executable::pe_crt::strcpy(char* to, const char* from)
{
	char* save = to;

	for (; (*to = *from) != '\0'; ++from, ++to);

	return(save);
}

```

`kernel/ext/portable_executable/pe_crt/crt_string.hpp`:

```hpp
#pragma once

#include "crt_types.hpp"

namespace portable_executable::pe_crt
{
	pe_crt::size_t strlen(const char* str);
	pe_crt::size_t wstrlen(const wchar_t* str);

	pe_crt::int32_t strcmp(const char* str1, const char* str2);

	pe_crt::int32_t strncmp(const char* s1, const char* s2, pe_crt::size_t n);
	pe_crt::int32_t wstrncmp(const wchar_t* s1, const wchar_t* s2, pe_crt::size_t n);

	char* strstr(const char* s, const char* find);
	wchar_t* wcsstr(const wchar_t* s, const wchar_t* find);

	char* strcpy(char* to, const char* from);
}
```

`kernel/ext/portable_executable/pe_crt/crt_type_traits.hpp`:

```hpp
#pragma once

namespace portable_executable::pe_crt
{
    template <bool _Test, class _Ty1, class _Ty2>
    struct conditional
    {
        using type = _Ty1;
    };

    template <class _Ty1, class _Ty2>
    struct conditional<false, _Ty1, _Ty2>
    {
        using type = _Ty2;
    };

    template <class _Ty, _Ty _Val>
    struct integral_constant
    {
        static constexpr _Ty value = _Val;

        using value_type = _Ty;
        using type = integral_constant;

        constexpr operator value_type() const noexcept
        {
            return value;
        }

        constexpr value_type operator()() const noexcept
        {
            return value;
        }
    };

    template <bool _Val>
    using bool_constant = integral_constant<bool, _Val>;

    template <class>
    constexpr bool is_const_v = false;

    template <class _Ty>
    constexpr bool is_const_v<const _Ty> = true;

    template <class _Ty>
    struct is_const : bool_constant<is_const_v<_Ty>>
    {

    };
}
```

`kernel/ext/portable_executable/pe_crt/crt_types.hpp`:

```hpp
#pragma once

namespace portable_executable::pe_crt
{
	using int8_t		= __int8;
	using int16_t		= __int16;
	using int32_t		= __int32;
	using int64_t		= __int64;

	using uint8_t		= unsigned __int8;
	using uint16_t		= unsigned __int16;
	using uint32_t		= unsigned __int32;
	using uint64_t		= unsigned __int64;

	using size_t = unsigned __int64;
	using uintptr_t = unsigned __int64;

	using wchar_t = unsigned __int16;
}
```

`kernel/ext/portable_executable/relocations_directory.cpp`:

```cpp
#include "relocations_directory.hpp"

void portable_executable::relocations_iterator_t::load_block(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor)
{
    this->current_raw_relocation_block_descriptor = raw_relocation_block_descriptor;

    if (this->current_raw_relocation_block_descriptor && this->current_raw_relocation_block_descriptor->virtual_address)
    {
        const pe_crt::uint64_t real_block_size = this->current_raw_relocation_block_descriptor->size_of_block - sizeof(raw_relocation_block_descriptor_t);

        this->current_relocation_block.max_entry_index = static_cast<pe_crt::uint32_t>(real_block_size / sizeof(relocation_entry_descriptor_t));
        this->current_relocation_block.current_entry_index = 1;

        this->current_descriptor = reinterpret_cast<const relocation_entry_descriptor_t*>(this->current_raw_relocation_block_descriptor + 1);
    }
}

portable_executable::relocations_iterator_t::relocations_iterator_t(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor)
{
    if (raw_relocation_block_descriptor)
    {
        this->load_block(raw_relocation_block_descriptor);
    }
}

portable_executable::relocations_iterator_t::value_type portable_executable::relocations_iterator_t::operator*() const
{
    return { *this->current_descriptor, this->current_raw_relocation_block_descriptor->virtual_address };
}

portable_executable::relocations_iterator_t& portable_executable::relocations_iterator_t::operator++()
{
    if (this->current_descriptor && this->current_relocation_block.current_entry_index < this->current_relocation_block.max_entry_index)
    {
        ++this->current_descriptor;

        this->current_relocation_block.current_entry_index++;
    }
    else if (this->current_raw_relocation_block_descriptor && this->current_raw_relocation_block_descriptor->virtual_address)
    {
        this->load_block(reinterpret_cast<const raw_relocation_block_descriptor_t*>(reinterpret_cast<pe_crt::uint64_t>(this->current_raw_relocation_block_descriptor) + this->current_raw_relocation_block_descriptor->size_of_block));
    }
    else
    {
        this->current_descriptor = nullptr;
    }

    return *this;
}

bool portable_executable::relocations_iterator_t::operator==(const relocations_iterator_t& other)
{
    return this->current_descriptor == other.current_descriptor;
}

bool portable_executable::relocations_iterator_t::operator!=(const relocations_iterator_t& other)
{
    return this->current_descriptor != other.current_descriptor;
}

```

`kernel/ext/portable_executable/relocations_directory.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_type_traits.hpp"
#include "pe_crt/crt_types.hpp"

namespace portable_executable
{
    enum class relocation_type_t : pe_crt::uint16_t
    {
        absolute,
        high,
        low,
        high_low,
        high_adj,
        machine_specific_5,
        reserved,
        machine_specific_7,
        machine_specific_8,
        machine_specific_9,
        dir64
    };

    struct relocation_entry_descriptor_t
    {
        pe_crt::uint16_t offset : 12;
        relocation_type_t type : 4;
    };

    struct raw_relocation_block_descriptor_t
    {
        pe_crt::uint32_t virtual_address;
        pe_crt::uint32_t size_of_block;
    };

    struct relocation_block_t
    {
        pe_crt::uint32_t current_entry_index;
        pe_crt::uint32_t max_entry_index;
    };

    struct relocation_entry_t
    {
        relocation_entry_descriptor_t descriptor;
        pe_crt::uint32_t virtual_address;
    };

    class relocations_iterator_t
    {
    private:
        const raw_relocation_block_descriptor_t* current_raw_relocation_block_descriptor = nullptr;
        relocation_block_t current_relocation_block = { };

        const relocation_entry_descriptor_t* current_descriptor = nullptr;

        void load_block(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor);

    public:
        relocations_iterator_t() = default;

        relocations_iterator_t(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor);

        using value_type = relocation_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        relocations_iterator_t& operator++();

        bool operator==(const relocations_iterator_t& other);

        bool operator!=(const relocations_iterator_t& other);
    };

    template<typename T>
    class relocations_range_t
    {
    private:
        using pointer_type = typename pe_crt::conditional<pe_crt::is_const<T>::value, const pe_crt::uint8_t*, pe_crt::uint8_t*>::type;
        using relocation_descriptor_type = typename pe_crt::conditional<pe_crt::is_const<T>::value, const raw_relocation_block_descriptor_t*, raw_relocation_block_descriptor_t*>::type;

        pointer_type m_module = nullptr;

        const raw_relocation_block_descriptor_t* m_raw_relocation_block_descriptor = nullptr;

    public:
        relocations_range_t() = default;

        relocations_range_t(pointer_type module, pe_crt::uint32_t relocations_rva) :
            m_module(module), m_raw_relocation_block_descriptor(reinterpret_cast<relocation_descriptor_type>(module + relocations_rva))
        {

        }

        T begin() const
        {
            return { this->m_raw_relocation_block_descriptor };
        }

        T end() const
        {
            return { nullptr };
        }
    };
}
```

`kernel/ext/portable_executable/section_header.hpp`:

```hpp
#pragma once

#include "pe_crt/crt_types.hpp"

namespace portable_executable
{
    static constexpr pe_crt::size_t section_name_size_limit = 8;

#pragma warning(push)
#pragma warning(disable: 4201)

    union section_characteristics_t
    {
        struct
        {
            pe_crt::uint32_t _pad0 : 5;
            pe_crt::uint32_t cnt_code : 1;
            pe_crt::uint32_t cnt_init_data : 1;
            pe_crt::uint32_t cnt_uninit_data : 1;
            pe_crt::uint32_t _pad1 : 1;
            pe_crt::uint32_t lnk_info : 1;
            pe_crt::uint32_t _pad2 : 1;
            pe_crt::uint32_t lnk_remove : 1;
            pe_crt::uint32_t lnk_comdat : 1;
            pe_crt::uint32_t _pad3 : 1;
            pe_crt::uint32_t no_defer_spec_exc : 1;
            pe_crt::uint32_t mem_far : 1;
            pe_crt::uint32_t _pad4 : 1;
            pe_crt::uint32_t mem_purgeable : 1;
            pe_crt::uint32_t mem_locked : 1;
            pe_crt::uint32_t mem_preload : 1;
            pe_crt::uint32_t alignment : 4;
            pe_crt::uint32_t lnk_nreloc_ovfl : 1;
            pe_crt::uint32_t mem_discardable : 1;
            pe_crt::uint32_t mem_not_cached : 1;
            pe_crt::uint32_t mem_not_paged : 1;
            pe_crt::uint32_t mem_shared : 1;
            pe_crt::uint32_t mem_execute : 1;
            pe_crt::uint32_t mem_read : 1;
            pe_crt::uint32_t mem_write : 1;
        };

        pe_crt::uint32_t flags;
    };

#pragma warning(pop)

    struct section_header_t
    {
        char name[section_name_size_limit];
        pe_crt::uint32_t virtual_size;
        pe_crt::uint32_t virtual_address;
        pe_crt::uint32_t size_of_raw_data;
        pe_crt::uint32_t pointer_to_raw_data;
        pe_crt::uint32_t pointer_to_relocations;
        pe_crt::uint32_t pointer_to_linenumbers;
        pe_crt::uint16_t number_of_relocations;
        pe_crt::uint16_t number_of_linenumbers;
        section_characteristics_t characteristics;
    };

    template<typename T>
    class section_iterator_t
    {
    private:
        T* m_base = nullptr;

        pe_crt::uint16_t m_num_sections = 0;

    public:
        section_iterator_t(T* base, pe_crt::uint16_t num_sections) : m_base(base), m_num_sections(num_sections)
        {

        }

        T* begin() const
        {
            return this->m_base;
        }

        T* end() const
        {
            return this->m_base + this->m_num_sections;
        }
    };
}
```

`kernel/src/context/context.cpp`:

```cpp
#include "context.h"
#include "../crypto/crypto.h"
#include "../memory/memory.h"
#include "../os/ntkrnl/ntkrnl.h"
#include <portable_executable/image.hpp>
#include <string_encryption.h>
#include <ntifs.h>

#define d_context_xor_key 0xAC54EF7B5AD4E

// this function must be heavily virtualized in production
bool context::load()
{
	uint64_t ntoskrnl_base_address = ntkrnl::pre_initialization::find_ntoskrnl_base();

	if (ntoskrnl_base_address == 0)
	{
		return false;
	}

	const portable_executable::image_t* ntoskrnl_image = reinterpret_cast<const portable_executable::image_t*>(ntoskrnl_base_address);

	t_ex_allocate_pool_2 ex_allocate_pool_2 = reinterpret_cast<t_ex_allocate_pool_2>(ntoskrnl_image->find_export(d_encrypt_string("ExAllocatePool2")));

	if (ex_allocate_pool_2 == nullptr)
	{
		return false;
	}

	s_context* context = reinterpret_cast<s_context*>(ex_allocate_pool_2(POOL_FLAG_NON_PAGED, sizeof(s_context), 'drac'));

	if (context == nullptr)
	{
		return false;
	}

	memset(context, 0, sizeof(s_context));

	context->imports.ex_allocate_pool_2 = ex_allocate_pool_2;
	context->ntoskrnl_base_address = ntoskrnl_base_address;
	context->initial_system_process = ntkrnl::get_current_process(); // will be the initial system process on driver entry

	encrypted_context_pointer = crypto::xor64(reinterpret_cast<uint64_t>(context), d_context_xor_key);

	return true;
}

void context::unload()
{
	if (encrypted_context_pointer == 0)
	{
		return;
	}

	context::s_context* context = get_decrypted();

	memory::free_pool(context, reinterpret_cast<uint64_t>(context));

	encrypted_context_pointer = 0;
}

context::s_context* context::get_decrypted()
{
	// todo: implement return address check, we dont want this to be called from anywhere outside of our driver

	return reinterpret_cast<s_context*>(crypto::xor64(encrypted_context_pointer, d_context_xor_key));
}

```

`kernel/src/context/context.h`:

```h
#pragma once
#include <communication_types.h>
#include "../memory/page_tables_def.h"
#include "../crypto/crypto_def.h"
#include "../imports/imports_def.h"

#define d_pool_tag 'drac'

namespace context
{
	bool load();
	void unload();

	// we store pointers for structures that may need to be rewritten to (eg: protected processes)
	// stuff such as imports will never need to be written though
	struct s_context
	{
		communication::s_protected_processes protected_processes;
		imports::s_imports imports;

		struct
		{
			page_tables::s_page_table* page_tables = nullptr;
			cr3 pt_cr3 = { };
		} memory;

		struct
		{
			crypto::s_hash ntoskrnl_text_hash = { };

			crypto::s_hash_list_entry* kernel_module_hash_list_head = nullptr;
		} integrity;

		uint64_t ntoskrnl_base_address = 0;
		uint64_t initial_system_process = 0;
	};

	// holds pointer to encrypted s_context
	// todo: replace xor encryption with something stronger
	inline uint64_t encrypted_context_pointer = 0;

	s_context* get_decrypted();
}

```

`kernel/src/crypto/crypto.cpp`:

```cpp
#include "crypto.h"
#include "../memory/memory.h"

#include <string_encryption.h>

#include <ntifs.h>
#include <bcrypt.h>

#include "../log.h"

bool crypto::s_hash::is_same(s_hash& other)
{
	if (this->buffer == nullptr || other.buffer == nullptr || this->buffer_size != other.buffer_size)
	{
		return false;
	}

	return (memcmp(this->buffer, other.buffer, other.buffer_size) == 0);
}

void crypto::s_hash::free_hash_buffer(context::s_context* context)
{
	if (this->buffer != nullptr)
	{
		memory::free_pool(context, reinterpret_cast<uint64_t>(this->buffer));

		this->buffer = nullptr;
	}
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::allocate_memory_for_entry(context::s_context* context)
{
	return reinterpret_cast<crypto::s_hash_list_entry*>(memory::allocate_pool(context, sizeof(s_hash_list_entry), POOL_FLAG_NON_PAGED));
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::create_first_entry(context::s_context* context)
{
	crypto::s_hash_list_entry* first_entry = allocate_memory_for_entry(context);

	if (first_entry == nullptr)
	{
		return nullptr;
	}

	first_entry->set_previous(nullptr);
	first_entry->set_next(nullptr);

	return first_entry;
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::add_entry(context::s_context* context)
{
	if (this->get_next() != nullptr)
	{
		return nullptr;
	}

	crypto::s_hash_list_entry* new_entry = this->allocate_memory_for_entry(context);

	if (new_entry == nullptr)
	{
		return nullptr;
	}

	this->set_next(new_entry);
	new_entry->set_previous(this);

	return new_entry;
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::add_entry(context::s_context* context, s_hash hash)
{
	crypto::s_hash_list_entry* new_entry = this->add_entry(context);

	if (new_entry != nullptr)
	{
		new_entry->buffer = hash.buffer;
		new_entry->buffer_size = hash.buffer_size;
	}

	return new_entry;
}

void crypto::s_hash_list_entry::delete_self(context::s_context* context)
{
	this->free_hash_buffer(context);

	s_hash_list_entry* next_entry = this->get_next();
	s_hash_list_entry* previous_entry = this->get_previous();

	if (next_entry != nullptr)
	{
		next_entry->set_previous(previous_entry);
	}

	if (previous_entry != nullptr)
	{
		previous_entry->set_next(next_entry);
	}

	memory::free_pool(context, reinterpret_cast<uint64_t>(this));
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::get_next()
{
	return this->next;
}

void crypto::s_hash_list_entry::set_next(s_hash_list_entry* new_next)
{
	this->next = new_next;
}

crypto::s_hash_list_entry* crypto::s_hash_list_entry::get_previous()
{
	return this->previous;
}

void crypto::s_hash_list_entry::set_previous(s_hash_list_entry* new_previous)
{
	this->previous = new_previous;
}

uint64_t crypto::s_hash_list_entry::get_identifier()
{
	return this->identifier;
}

void crypto::s_hash_list_entry::set_identifier(uint64_t new_identifier)
{
	this->identifier = new_identifier;
}

uint64_t crypto::xor64(uint64_t input, uint64_t key)
{
	return input ^= key;
}

int32_t crypto_algorithm_get_property(context::s_context* context, BCRYPT_ALG_HANDLE algorithm_handle, LPCWSTR property, uint32_t* buffer_size_out)
{
	uint32_t bytes_returned = 0;

	return context->imports.bcrypt_get_property(algorithm_handle, property, reinterpret_cast<uint8_t*>(buffer_size_out), sizeof(uint32_t), &bytes_returned, 0);
}

int32_t crypto_set_up_algorithm_property(context::s_context* context, BCRYPT_ALG_HANDLE algorithm_handle, LPCWSTR property, uint8_t** buffer_out, uint32_t* buffer_size_out)
{
	int32_t status = crypto_algorithm_get_property(context, algorithm_handle, property, buffer_size_out);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	*buffer_out = reinterpret_cast<uint8_t*>(memory::allocate_pool(context, *buffer_size_out, POOL_FLAG_NON_PAGED));

	if (*buffer_out == 0)
	{
		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	return STATUS_SUCCESS;
}

int32_t crypto_set_up_algorithm(context::s_context* context, BCRYPT_ALG_HANDLE* algorithm_handle, LPCWSTR algorithm_id, uint64_t* hash_buffer, uint32_t* hash_size, uint64_t* hash_object_buffer, uint32_t* hash_object_size)
{
	uint32_t status = context->imports.bcrypt_open_algorithm_provider(algorithm_handle, algorithm_id, nullptr, 0);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	status = crypto_set_up_algorithm_property(context, *algorithm_handle, d_encrypt_string(BCRYPT_OBJECT_LENGTH), reinterpret_cast<uint8_t**>(hash_object_buffer), hash_object_size);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	return crypto_set_up_algorithm_property(context, *algorithm_handle, d_encrypt_string(BCRYPT_HASH_LENGTH), reinterpret_cast<uint8_t**>(hash_buffer), hash_size);
}

int32_t crypto_close_algorithm(context::s_context* context, BCRYPT_ALG_HANDLE algorithm_handle)
{
	return algorithm_handle != nullptr ? context->imports.bcrypt_close_algorithm_provider(algorithm_handle, 0) : STATUS_INVALID_PARAMETER;
}

int32_t crypto_destroy_hash_handle(context::s_context* context, BCRYPT_HASH_HANDLE hash_handle)
{
	return hash_handle != nullptr ? context->imports.bcrypt_destroy_hash(hash_handle) : STATUS_INVALID_PARAMETER;
}

int32_t crypto_algorithm_generate_hash(context::s_context* context, BCRYPT_ALG_HANDLE algorithm_handle, uint8_t* buffer, uint32_t buffer_size, uint64_t hash_buffer, uint32_t hash_size, uint64_t hash_object_buffer, uint32_t hash_object_size)
{
	BCRYPT_HASH_HANDLE hash_handle = nullptr;

	int32_t status = context->imports.bcrypt_create_hash(algorithm_handle, &hash_handle, reinterpret_cast<uint8_t*>(hash_object_buffer), hash_object_size, nullptr, 0, 0);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	status = context->imports.bcrypt_hash_data(hash_handle, buffer, buffer_size, 0);

	if (NT_SUCCESS(status) == false)
	{
		crypto_destroy_hash_handle(context, hash_handle);

		return status;
	}

	status = context->imports.bcrypt_finish_hash(hash_handle, reinterpret_cast<uint8_t*>(hash_buffer), hash_size, 0);

	crypto_destroy_hash_handle(context, hash_handle);

	return status;
}

// note: pool described by: (*hash_buffer) must beed freed eventually after returned hash buffer is no longer needed
int32_t crypto_algorithm_hash_buffer(context::s_context* context, LPCWSTR algorithm_id, uint8_t* buffer, uint32_t buffer_size, uint8_t** hash_buffer, uint32_t* hash_size)
{
	BCRYPT_ALG_HANDLE algorithm_handle = nullptr;

	uint64_t hash_object_buffer = 0;
	uint32_t hash_object_size = 0;

	int32_t status = crypto_set_up_algorithm(context, &algorithm_handle, algorithm_id, reinterpret_cast<uint64_t*>(hash_buffer), hash_size, &hash_object_buffer, &hash_object_size);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	status = crypto_algorithm_generate_hash(context, algorithm_handle, buffer, buffer_size, reinterpret_cast<uint64_t>(*hash_buffer), *hash_size, hash_object_buffer, hash_object_size);

	memory::free_pool(context, hash_object_buffer);

	crypto_close_algorithm(context, algorithm_handle);

	if (NT_SUCCESS(status) == false)
	{
		return status;
	}

	return STATUS_SUCCESS;
}

int32_t crypto::sha256(context::s_context* context, uint8_t* buffer, uint32_t buffer_size, uint8_t** hash_buffer, uint32_t* hash_size)
{
	return crypto_algorithm_hash_buffer(context, d_encrypt_string(BCRYPT_SHA256_ALGORITHM), buffer, buffer_size, hash_buffer, hash_size);
}

int32_t crypto::sha256(context::s_context* context, uint8_t* buffer, uint32_t buffer_size, crypto::s_hash* hash_out)
{
	return sha256(context, buffer, buffer_size, &hash_out->buffer, &hash_out->buffer_size);
}

```

`kernel/src/crypto/crypto.h`:

```h
#pragma once
#include "crypto_def.h"

namespace crypto
{
	uint64_t xor64(uint64_t input, uint64_t key);

	int32_t sha256(context::s_context* context, uint8_t* buffer, uint32_t buffer_size, uint8_t** hash_buffer, uint32_t* hash_size);
	int32_t sha256(context::s_context* context, uint8_t* buffer, uint32_t buffer_size, crypto::s_hash* hash_out);
}

```

`kernel/src/crypto/crypto_def.h`:

```h
#pragma once
#include "generic_types.h"

namespace context { struct s_context; }

namespace crypto
{
	class s_hash
	{
	public:
		uint8_t* buffer;
		uint32_t buffer_size;

		bool is_same(s_hash& other);
		void free_hash_buffer(context::s_context* context);
	};

	class s_hash_list_entry : public s_hash
	{
	private:
		s_hash_list_entry* next;
		s_hash_list_entry* previous;

		uint64_t identifier;

		static s_hash_list_entry* allocate_memory_for_entry(context::s_context* context);

	public:
		static s_hash_list_entry* create_first_entry(context::s_context* context);

		s_hash_list_entry* add_entry(context::s_context* context);
		s_hash_list_entry* add_entry(context::s_context* context, s_hash hash);

		void delete_self(context::s_context* context);

		s_hash_list_entry* get_next();
		void set_next(s_hash_list_entry* new_next);

		s_hash_list_entry* get_previous();
		void set_previous(s_hash_list_entry* new_previous);

		uint64_t get_identifier();
		void set_identifier(uint64_t new_identifier);
	};
}

```

`kernel/src/detections/handles/permission_stripping.cpp`:

```cpp
#include "permission_stripping.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../log.h"
#include <ntifs.h>

#define d_process_query_limited_information 0x1000

void handles::permission_stripping::on_pre_handle_operation(communication::s_protected_processes* protected_processes, _OB_PRE_OPERATION_INFORMATION* information, uint64_t current_process, uint64_t target_process)
{
	if (current_process == target_process)
	{
		return;
	}

	uint64_t target_process_id = ntkrnl::get_process_id(target_process);

	if (target_process_id == protected_processes->anticheat_usermode_id || target_process_id == protected_processes->protected_process_id)
	{
		// todo: send flags when we get here and be able to differenciate between malicious creators or not
		// might have to monitor whitelisted processes too to prevent people abusing them by injecting dlls into them and then opening handles from there

		information->Operation == OB_OPERATION_HANDLE_CREATE ?
			information->Parameters->CreateHandleInformation.DesiredAccess = (SYNCHRONIZE | d_process_query_limited_information) :
			information->Parameters->DuplicateHandleInformation.DesiredAccess = (SYNCHRONIZE | d_process_query_limited_information);

		d_log("[darken-anticheat] blocked handle being opened to (process id: 0x%llx) from (process id: 0x%llx).\n", target_process_id, ntkrnl::get_process_id(current_process));
	}
}

```

`kernel/src/detections/handles/permission_stripping.h`:

```h
#pragma once
#include "../../context/context.h"

struct _OB_PRE_OPERATION_INFORMATION;

namespace handles
{
	namespace permission_stripping
	{
		void on_pre_handle_operation(communication::s_protected_processes* protected_processes, _OB_PRE_OPERATION_INFORMATION* information, uint64_t current_process, uint64_t target_process);
	}
}

```

`kernel/src/detections/hypervisor/reserved_msr_usage.cpp`:

```cpp
#include "reserved_msr_usage.h"
#include "../../log.h"

#include <ntifs.h>
#include <intrin.h>

communication::e_detection_status hypervisor::check_reserved_msr_usage()
{
	// reserved ranges
	for (uint32_t i = 0x40000000u; i <= 0x4000FFFFu; i++)
	{
		__try
		{
			// if this doesn't throw an exception, then we are likely in a virtualized environment and these ranges are being used to communicate between host and guest
			__readmsr(i);

			// should ever not get here if msr read throws exception
			d_log("[darken-anticheat] found usage of reserved MSR (index: 0x%x).\n", i);

			return communication::e_detection_status::flagged;
		}
		__except (1)
		{

		}
	}

	return communication::e_detection_status::clean;
}

```

`kernel/src/detections/hypervisor/reserved_msr_usage.h`:

```h
#pragma once
#include <communication_types.h>

namespace hypervisor
{
	communication::e_detection_status check_reserved_msr_usage();
}

```

`kernel/src/detections/integrity/data_section_integrity.cpp`:

```cpp
#include "data_section_integrity.h"
#include "../../crypto/crypto.h"
#include "../../context/context.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../structures/kldr_data_table_entry.h"
#include "../../memory/memory.h"
#include <portable_executable/image.hpp>
#include "../../log.h"

#include <ntifs.h>
#include <intrin.h>

bool are_pages_executable(context::s_context* context, int64_t start_virtual_address, uint64_t end_virtual_address)
{
	_disable();

	cr3 original_cr3 = memory::current_context::read_cr3();

	memory::current_context::write_cr3(context->memory.pt_cr3);

	bool found_executable_page = false;

	uint64_t current_virtual_address = start_virtual_address;

	while (current_virtual_address < end_virtual_address)
	{
		uint64_t size_left_of_page = 0;

		uint64_t physical_address = memory::translate_virtual_address({ current_virtual_address }, original_cr3, &size_left_of_page, &found_executable_page);

		// if for some reason invalid pfn, we just assume its a 4kb page, and keep on searching
		// 
		// reason why we dont just break:
		// if we broke on invalid pfn (assuming rest of section is invalid),
		// then attackers could just set first page in a section to an invalid pfn, and the rest be valid
		if (physical_address == 0)
		{
			size_left_of_page = 0x1000 - (current_virtual_address & 0xFFF);
		}

		if (found_executable_page == true)
		{
			break;
		}

		current_virtual_address += size_left_of_page;
	}

	memory::current_context::write_cr3(original_cr3);

	_enable();

	return found_executable_page;
}

bool is_data_section_executable(context::s_context* context, uint64_t image_base_address)
{
	const portable_executable::image_t* image = reinterpret_cast<const portable_executable::image_t*>(image_base_address);

	for (const auto& current_section : image->sections())
	{
		bool should_section_be_executable = current_section.characteristics.mem_execute == 1;

		if (should_section_be_executable == false)
		{
			uint64_t section_start_virtual_address = image_base_address + current_section.virtual_address;

			uint64_t section_end_virtual_address = section_start_virtual_address + current_section.virtual_size;

			if (are_pages_executable(context, section_start_virtual_address, section_end_virtual_address) == true)
			{
				return true;
			}
		}
	}

	return false;
}

struct s_driver_section_processor_callback_ctx
{
	context::s_context* global_context;
	bool has_found_tampered_page;
};

bool driver_section_processor_callback(uint64_t current_module_info, void* context_in)
{
	_KLDR_DATA_TABLE_ENTRY* current_module = reinterpret_cast<_KLDR_DATA_TABLE_ENTRY*>(current_module_info);
	s_driver_section_processor_callback_ctx* context = reinterpret_cast<s_driver_section_processor_callback_ctx*>(context_in);

	context->has_found_tampered_page = is_data_section_executable(context->global_context, reinterpret_cast<uint64_t>(current_module->DllBase));

	if (context->has_found_tampered_page == true)
	{
		d_log("[darken-anticheat] kernel module '%ls' has a data section set to executable.\n", current_module->BaseDllName.Buffer);

		return true;
	}

	return false;
}

communication::e_detection_status integrity::data_section::is_any_driver_data_section_executable(context::s_context* context)
{
	s_driver_section_processor_callback_ctx callback_ctx = { };

	callback_ctx.global_context = context;

	ntkrnl::enumerate_system_modules(context, driver_section_processor_callback, &callback_ctx);

	return callback_ctx.has_found_tampered_page == true ? communication::e_detection_status::flagged : communication::e_detection_status::clean;
}

```

`kernel/src/detections/integrity/data_section_integrity.h`:

```h
#pragma once
#include <communication_types.h>
#include "../../crypto/crypto_def.h"

namespace integrity::data_section
{
	communication::e_detection_status is_any_driver_data_section_executable(context::s_context* context);
}

```

`kernel/src/detections/integrity/integrity.cpp`:

```cpp
#include "integrity.h"
#include "../../crypto/crypto.h"
#include "../../context/context.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../structures/kldr_data_table_entry.h"

#include <portable_executable/image.hpp>
#include <string_encryption.h>

#include "../../log.h"
#include <ntifs.h>

int32_t integrity::calculate_image_section_hash(context::s_context* context, uint64_t image_base, const char* section_name, crypto::s_hash* hash_out)
{
	if (image_base == 0)
	{
		return STATUS_INVALID_PARAMETER;
	}

	const portable_executable::image_t* image = reinterpret_cast<const portable_executable::image_t*>(image_base);

	const portable_executable::section_header_t* text_section = image->find_section(section_name);

	if (text_section == nullptr)
	{
		return STATUS_NOT_FOUND;
	}

	return crypto::sha256(context, reinterpret_cast<uint8_t*>(image_base + text_section->virtual_address), text_section->virtual_size, hash_out);
}

communication::e_detection_status integrity::validate_ntoskrnl_integrity(context::s_context* context)
{
	crypto::s_hash current_ntoskrnl_text_hash = { };
	
	int32_t hash_status = integrity::calculate_image_section_hash(context, context->ntoskrnl_base_address, d_encrypt_string(".text"), &current_ntoskrnl_text_hash);

	if (NT_SUCCESS(hash_status) == false)
	{
		return communication::e_detection_status::runtime_error;
	}

	bool is_hash_same = context->integrity.ntoskrnl_text_hash.is_same(current_ntoskrnl_text_hash);

	current_ntoskrnl_text_hash.free_hash_buffer(context);

	if (is_hash_same == true)
	{
		return communication::e_detection_status::clean;
	}
	else
	{
		d_log("[darken-anticheat] hash of ntoskrnl's .text section does not match (.text changed).\n");

		return communication::e_detection_status::flagged;
	}
}

struct s_hash_callback_ctx
{
	context::s_context* global_context;

	communication::e_detection_status status = communication::e_detection_status::clean;
};

void add_system_module_to_list(context::s_context* context, uint64_t module_base_address, crypto::s_hash& current_module_hash, crypto::s_hash_list_entry* last_valid_list_entry)
{
	crypto::s_hash_list_entry* new_entry = nullptr;

	if (context->integrity.kernel_module_hash_list_head == nullptr)
	{
		context->integrity.kernel_module_hash_list_head = new_entry = crypto::s_hash_list_entry::create_first_entry(context);
	}
	else
	{
		new_entry = last_valid_list_entry->add_entry(context);
	}

	if (new_entry != nullptr)
	{
		new_entry->set_identifier(module_base_address);

		new_entry->buffer = current_module_hash.buffer;
		new_entry->buffer_size = current_module_hash.buffer_size;
	}
}

bool hash_kernel_module_callback(uint64_t current_module_info, void* context_in)
{
	_KLDR_DATA_TABLE_ENTRY* current_module = reinterpret_cast<_KLDR_DATA_TABLE_ENTRY*>(current_module_info);
	s_hash_callback_ctx* context = reinterpret_cast<s_hash_callback_ctx*>(context_in);

	uint64_t module_base_address = reinterpret_cast<uint64_t>(current_module->DllBase);

	crypto::s_hash current_module_hash = { };

	int32_t hash_status = integrity::calculate_image_section_hash(context->global_context, module_base_address, d_encrypt_string(".text"), &current_module_hash);

	if (NT_SUCCESS(hash_status) == false)
	{
		context->status = communication::e_detection_status::runtime_error;

		return true;
	}

	crypto::s_hash_list_entry* list_entry = context->global_context->integrity.kernel_module_hash_list_head;
	crypto::s_hash_list_entry* last_valid_list_entry = list_entry;

	bool current_module_in_list = false;

	while (list_entry != nullptr)
	{
		if (list_entry->get_identifier() == module_base_address)
		{
			if (list_entry->is_same(current_module_hash) == false)
			{
				d_log("[darken-anticheat] module '%ls' has a differing .text section.\n", current_module->BaseDllName.Buffer);

				context->status = communication::e_detection_status::flagged;

				return true;
			}

			current_module_in_list = true;

			break;
		}

		last_valid_list_entry = list_entry;
		list_entry = list_entry->get_next();
	}

	if (current_module_in_list == false)
	{
		add_system_module_to_list(context->global_context, module_base_address, current_module_hash, last_valid_list_entry);
	}

	return false;
}

communication::e_detection_status integrity::validate_kernel_drivers_integrity(context::s_context* context)
{
	s_hash_callback_ctx ctx = { };

	ctx.global_context = context;
	ctx.status = communication::e_detection_status::clean;

	ntkrnl::enumerate_system_modules(context, hash_kernel_module_callback, &ctx, 2);

	return ctx.status;
}

```

`kernel/src/detections/integrity/integrity.h`:

```h
#pragma once
#include <communication_types.h>
#include "../../crypto/crypto_def.h"

namespace integrity
{
	int32_t calculate_image_section_hash(context::s_context* context, uint64_t image_base, const char* section_name, crypto::s_hash* hash_out);

	communication::e_detection_status validate_ntoskrnl_integrity(context::s_context* context);
	communication::e_detection_status validate_kernel_drivers_integrity(context::s_context* context);
}

```

`kernel/src/detections/patchguard/patchguard.h`:

```h
#pragma once

extern "C" void _trigger_patchguard_bugcheck();

```

`kernel/src/detections/patchguard/patchguard_assembler.asm`:

```asm
.code
    _trigger_patchguard_bugcheck proc
        int 20h
        ret
    _trigger_patchguard_bugcheck endp
END
```

`kernel/src/detections/process/process_thread.cpp`:

```cpp
#include "process_thread.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../offsets/offsets.h"
#include "../../memory/memory.h"
#include "../../log.h"

#include "../../structures/ldr_data_table_entry.h"
#include "../../structures/_peb.h"
#include <ntifs.h>
#include <intrin.h>

extern "C" NTKERNELAPI PPEB PsGetProcessPeb(PEPROCESS);

#pragma warning(push)
#pragma warning(disable: 6387) // explanation to this given in identical line in: /src/system/system_thread.cpp

communication::e_detection_status process::process_thread::is_suspicious_thread_present(context::s_context* context, communication::s_is_suspicious_process_thread_present is_suspicious_process_thread_present)
{
	if (is_suspicious_process_thread_present.process_id == 0)
	{
		return communication::e_detection_status::runtime_error;
	}

	uint64_t protected_eprocess = ntkrnl::get_eprocess(is_suspicious_process_thread_present.process_id);

	if (protected_eprocess == 0)
	{
		return communication::e_detection_status::runtime_error;
	}

	PPEB protected_process_peb = reinterpret_cast<PPEB>(ntkrnl::get_process_peb(protected_eprocess));

	_disable();

	cr3 original_cr3 = memory::current_context::read_cr3();

	memory::current_context::write_cr3(context->memory.pt_cr3);

	bool is_process_peb_virtual_address_valid = memory::is_address_valid(reinterpret_cast<uint64_t>(protected_process_peb), ntkrnl::get_process_directory_table_base(protected_eprocess));

	memory::current_context::write_cr3(original_cr3);

	_enable();

	if (is_process_peb_virtual_address_valid == false)
	{
		d_log("[darken-anticheat][process::process_thread::is_suspicious_thread_present] unable to get peb of protected process with id: 0x%llx.\n", is_suspicious_process_thread_present.process_id);

		return communication::e_detection_status::runtime_error;
	}

	KAPC_STATE apc_state = { };

	// todo: implement our own 'attaching' by directly reading memory of process
	context->imports.ke_stack_attach_process(protected_eprocess, &apc_state);

	uint64_t our_executing_thread = ntkrnl::get_current_thread();

	// context to this enumeration given in /src/system/system_thread.cpp
	for (uint64_t current_thread_id = 4; current_thread_id <= 0x4000; current_thread_id += 4)
	{
		uint64_t current_ethread = 0;

		if (NT_SUCCESS(context->imports.ps_lookup_thread_by_thread_id(current_thread_id, &current_ethread)) == false)
		{
			continue;
		}

		if (our_executing_thread == current_ethread || context->imports.ps_is_system_thread(current_ethread) == 1)
		{
			continue;
		}

		uint64_t current_ethread_process = ntkrnl::get_thread_eprocess(current_ethread);

		if (current_ethread_process == 0)
		{
			continue;
		}

		uint64_t current_ethread_process_id = ntkrnl::get_process_id(current_ethread_process);

		if (current_ethread_process_id != is_suspicious_process_thread_present.process_id)
		{
			continue;
		}

		uint64_t current_thread_win32_start_address = *reinterpret_cast<uint64_t*>(current_ethread + offsets::ethread::win32_start_address);

		bool is_thread_inside_registered_module = false;

		PLIST_ENTRY module_list_head = &protected_process_peb->Ldr->InMemoryOrderModuleList;

		for (PLIST_ENTRY module_list = module_list_head->Flink; module_list != module_list_head; module_list = module_list->Flink)
		{
			_LDR_DATA_TABLE_ENTRY* current_module = CONTAINING_RECORD(module_list, _LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

			uint64_t module_base = reinterpret_cast<uint64_t>(current_module->DllBase);
			uint64_t module_size = static_cast<uint64_t>(current_module->SizeOfImage);

			// check if thread start address is inside an existing module, if it isn't then we will then flag the user

			if (module_base <= current_thread_win32_start_address && current_thread_win32_start_address <= module_base + module_size)
			{
				is_thread_inside_registered_module = true;

				break;
			}
		}

		if (is_thread_inside_registered_module == false)
		{
			d_log("[darken-anticheat] thread id: %llx has a Win32StartAddress (0x%llx) which resides outside of a valid module of process with id: %llx.\n", current_thread_id, current_thread_win32_start_address, is_suspicious_process_thread_present.process_id);

			context->imports.ke_unstack_detach_process(&apc_state);

			return communication::e_detection_status::flagged;
		}
	}

	context->imports.ke_unstack_detach_process(&apc_state);

	return communication::e_detection_status::clean;
}

#pragma warning(pop)

```

`kernel/src/detections/process/process_thread.h`:

```h
#pragma once
#include "../../context/context.h"

namespace process
{
	namespace process_thread
	{
		communication::e_detection_status is_suspicious_thread_present(context::s_context* context, communication::s_is_suspicious_process_thread_present is_suspicious_process_thread_present);
	}
}

```

`kernel/src/detections/system/non_maskable_interrupts.cpp`:

```cpp
#include "non_maskable_interrupts.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../memory/memory.h"
#include "../../log.h"
#include <ntifs.h>
#include <intrin.h>

#include "../../structures/kaffinity_ex.h"
#include "../../structures/machine_frame.h"
#include <ia32/ia32.h>

struct s_nmi_per_core_info
{
	uint64_t rip;
	bool processed;
};

uint8_t nmi_callback_handler(s_nmi_per_core_info* context, uint8_t handled)
{
	UNREFERENCED_PARAMETER(handled);

	uint8_t current_processor_number = ntkrnl::get_current_processor_number();

	s_nmi_per_core_info* current_core_info = &context[current_processor_number];

	if (current_core_info->processed == true)
	{
		return TRUE;
	}

	task_state_segment_64* current_task_state_segment = reinterpret_cast<task_state_segment_64*>(ntkrnl::get_current_tss_base());
	s_machine_frame* machine_frame = reinterpret_cast<s_machine_frame*>(current_task_state_segment->ist3 - sizeof(s_machine_frame));

	current_core_info->rip = machine_frame->rip;
	current_core_info->processed = true;

	return TRUE;
}

void fire_nmi_on_core(context::s_context* context, _KAFFINITY_EX* processor_affinity, uint32_t processor_number)
{
	context->imports.ke_initialize_affinity_ex(processor_affinity);
	context->imports.ke_add_processor_affinity_ex(processor_affinity, processor_number);

	context->imports.hal_send_nmi(processor_affinity);
}

bool dispatch_nmi_on_all_cores(context::s_context* context, s_nmi_per_core_info* nmi_per_core_info, _KAFFINITY_EX* processor_affinity, uint32_t processor_count, uint32_t our_current_processor_number)
{
	uint64_t callback_handle = context->imports.ke_register_nmi_callback(nmi_callback_handler, nmi_per_core_info);

	if (callback_handle == 0)
	{
		return false;
	}

	for (uint32_t i = 0; i < processor_count; i++)
	{
		if (i == our_current_processor_number)
		{
			continue;
		}

		fire_nmi_on_core(context, processor_affinity, i);
	}

	LARGE_INTEGER sleep_period = { .QuadPart = -100000 };

	context->imports.ke_delay_execution_thread(KernelMode, FALSE, &sleep_period);

	context->imports.ke_deregister_nmi_callback(callback_handle);

	return true;
}

communication::e_detection_status system::non_maskable_interrupts::send_and_analyze(context::s_context* context)
{
	_KAFFINITY_EX* processor_affinity = reinterpret_cast<_KAFFINITY_EX*>(memory::allocate_pool(context, sizeof(_KAFFINITY_EX), POOL_FLAG_NON_PAGED));

	if (processor_affinity == nullptr)
	{
		return communication::e_detection_status::runtime_error;
	}

	uint32_t processor_count = context->imports.ke_query_active_processor_count(nullptr);

	// todo: allocate 1 less core info (due to us not launching on our current core obviously)
	s_nmi_per_core_info* nmi_per_core_info = reinterpret_cast<s_nmi_per_core_info*>(memory::allocate_pool(context, sizeof(s_nmi_per_core_info) * processor_count, POOL_FLAG_NON_PAGED));

	if (nmi_per_core_info == nullptr)
	{
		memory::free_pool(context, reinterpret_cast<uint64_t>(processor_affinity));

		return communication::e_detection_status::runtime_error;
	}

	_disable();

	uint32_t our_current_processor_number = static_cast<uint32_t>(ntkrnl::get_current_processor_number());

	bool were_nmis_dispatch_successfully = dispatch_nmi_on_all_cores(context, nmi_per_core_info, processor_affinity, processor_count, our_current_processor_number);

	_enable();

	if (were_nmis_dispatch_successfully == false)
	{
		memory::free_pool(context, reinterpret_cast<uint64_t>(processor_affinity));
		memory::free_pool(context, reinterpret_cast<uint64_t>(nmi_per_core_info));

		return communication::e_detection_status::runtime_error;
	}

	for (uint32_t i = 0; i < processor_count; i++)
	{
		if (i == our_current_processor_number)
		{
			continue;
		}

		s_nmi_per_core_info current_core_info = nmi_per_core_info[i];

		if (current_core_info.processed == false)
		{
			// should probably signal that this core's interrupt callback wasn't processed, is a flag if happens often

			d_log("[darken-anticheat] processor: %u failed to process nmi callback in time.\n", i);

			return communication::e_detection_status::runtime_error;
		}

		// check if in lower 256 pml4es, we will start to handle usermode rips (if they belong to our process) later on

		if (current_core_info.rip < (256ull << 39))
		{
			continue;
		}

		if (ntkrnl::is_address_within_system_module(context, current_core_info.rip) == false)
		{
			d_log("[darken-anticheat] interrupted processor: %u was interrupted in kernel code which had a rip outside of a valid module (0x%llx).\n", i, current_core_info.rip);

			memory::free_pool(context, reinterpret_cast<uint64_t>(processor_affinity));
			memory::free_pool(context, reinterpret_cast<uint64_t>(nmi_per_core_info));

			return communication::e_detection_status::flagged;
		}
	}

	memory::free_pool(context, reinterpret_cast<uint64_t>(processor_affinity));
	memory::free_pool(context, reinterpret_cast<uint64_t>(nmi_per_core_info));

	return communication::e_detection_status::clean;
}

```

`kernel/src/detections/system/non_maskable_interrupts.h`:

```h
#pragma once
#include "../../context/context.h"

namespace system
{
	namespace non_maskable_interrupts
	{
		communication::e_detection_status send_and_analyze(context::s_context* context);
	}
}

```

`kernel/src/detections/system/system_thread.cpp`:

```cpp
#include "system_thread.h"
#include "../../context/context.h"
#include "../../os/ntkrnl/ntkrnl.h"
#include "../../offsets/offsets.h"
#include "../../structures/kldr_data_table_entry.h"
#include "../../log.h"

#include <ntifs.h>

bool is_thread_attached_to_process(uint64_t ethread, uint64_t eprocess)
{
	uint64_t thread_eprocess = *reinterpret_cast<uint64_t*>(ethread + offsets::kthread::apc_state + offsets::kapc_state::process);

	return thread_eprocess == eprocess;
}

#pragma warning(push)
#pragma warning(disable: 6387) // for some reason msvc is throwing a warning that current_thread_id could be 0, even when i added a check before executing PsLookupThreadByThreadId

communication::e_detection_status system::system_thread::is_suspicious_thread_present(context::s_context* context)
{
	uint64_t our_executing_thread = ntkrnl::get_current_thread();

	// todo: enumerate pspcid table to find threads 'manually'
	// with my testing on Windows 11 24H2, thread ids go past 0x3000 boundary
	// i believe that 0x4000 is the limit but feel free to make a change if its not

	// reason we dont just enumerate the system process's thread list is because it can be unlinked easily
	// for this they need to unlink it from pspcid table which is a lot more tedious than just modifying a linked list
	for (uint64_t current_thread_id = 4; current_thread_id <= 0x4000; current_thread_id += 4)
	{
		uint64_t current_ethread = 0;

		// they can just remove it from pspcid table
		// and we won't be able to find their thread by these means anymore
		// todo: iterate system process thread linked list (can also be unlinked from)
		if (NT_SUCCESS(context->imports.ps_lookup_thread_by_thread_id(current_thread_id, &current_ethread)) == false)
		{
			continue;
		}

		if (context->imports.ps_is_system_thread(current_ethread) == false)
		{
			continue;
		}

		uint64_t current_ethread_process = ntkrnl::get_thread_eprocess(current_ethread);

		if (current_ethread_process == 0)
		{
			continue;
		}

		uint64_t current_ethread_process_id = ntkrnl::get_process_id(current_ethread_process);

		if (current_ethread_process_id != context->protected_processes.anticheat_usermode_id && current_ethread_process_id != context->protected_processes.protected_process_id)
		{
			// will detect KeStackAttachProcess and hence MmCopyVirtualMemory
			if (is_thread_attached_to_process(current_ethread, context->protected_processes.anticheat_usermode_id) == true
				|| is_thread_attached_to_process(current_ethread, context->protected_processes.protected_process_id) == true)
			{
				d_log("[darken-anticheat] thread id: %llx was attached to a protected process.\n", current_thread_id);

				return communication::e_detection_status::flagged;
			}
		}

		if (current_ethread_process_id != 4)
		{
			continue;
		}

		if (our_executing_thread == current_ethread) // won't happen cause our currently executing thread is not one pertaining to the system process
		{
			continue;
		}

		// check if Win32StartAddress is outside of any legitimate kernel module.
		// can be bypassed by changing the value in the ETHREAD struct
		// or using a (jmp rcx) gadget which is in legitimate module and passing the real start address as context

		uint64_t current_thread_win32_start_address = ntkrnl::get_thread_win32_start_address(current_ethread);

		if (current_thread_win32_start_address == 0) // yes, people do set it to 0 for some odd reason
		{
			d_log("[darken-anticheat] thread id: %llx has a NULL Win32StartAddress.\n", current_thread_id);

			return communication::e_detection_status::flagged;
		}

		if (ntkrnl::is_address_within_system_module(context, current_thread_win32_start_address) == false)
		{
			d_log("[darken-anticheat] thread id: %llx has a Win32StartAddress (0x%llx) which resides outside of a valid kernel module.\n", current_thread_id, current_thread_win32_start_address);

			return communication::e_detection_status::flagged;
		}
	}

	return communication::e_detection_status::clean;
}

#pragma warning(pop)

```

`kernel/src/detections/system/system_thread.h`:

```h
#pragma once
#include "../../context/context.h"

namespace system
{
	namespace system_thread
	{
		communication::e_detection_status is_suspicious_thread_present(context::s_context* context);
	}
}

```

`kernel/src/imports/imports.cpp`:

```cpp
#include "imports.h"
#include "../context/context.h"
#include "../os/ntkrnl/ntkrnl.h"

#include "../structures/kldr_data_table_entry.h"

#include <wdm.h>
#include "../log.h"

#include <portable_executable/image.hpp>
#include <string_encryption.h>

uint32_t* find_hvl_enlightenments(const portable_executable::image_t* ntoskrnl_image)
{
	// reference is to HvlEnlightenments in subroutine HvlRescindEnlightenments
	uint8_t* code_reference = ntoskrnl_image->signature_scan(d_encrypt_string("F0 83 25 ? ? ? ? ? F0 83 25"));

	if (code_reference == nullptr)
	{
		d_log("[darken-anticheat] failed to find reference to HvlEnlightenments.\n");

		return nullptr;
	}

	return reinterpret_cast<uint32_t*>((code_reference + 8) + *reinterpret_cast<uint32_t*>(code_reference + 3));
}

uint8_t* find_hvl_switch_virtual_address_space(const portable_executable::image_t* ntoskrnl_image)
{
	return ntoskrnl_image->signature_scan(d_encrypt_string("48 83 EC ? 48 C7 44 24 ? ? ? ? ? 48 8B D1"));
}

void resolve_ntoskrnl_imports(context::s_context* context, const portable_executable::image_t* ntoskrnl_image)
{
	context->imports.nt_build_number = reinterpret_cast<uint16_t*>(ntoskrnl_image->find_export(d_encrypt_string("NtBuildNumber")));
	context->imports.ps_loaded_module_list = reinterpret_cast<uint64_t>(ntoskrnl_image->find_export(d_encrypt_string("PsLoadedModuleList")));
	context->imports.ps_process_type = reinterpret_cast<uint64_t>(ntoskrnl_image->find_export(d_encrypt_string("PsProcessType")));
	context->imports.hvl_enlightenments = find_hvl_enlightenments(ntoskrnl_image);

	// ex_allocate_pool_2 set in context::load

	context->imports.ex_free_pool_with_tag = reinterpret_cast<t_ex_free_pool_with_tag>(ntoskrnl_image->find_export(d_encrypt_string("ExFreePoolWithTag")));
	context->imports.iof_complete_request = reinterpret_cast<t_iof_complete_request>(ntoskrnl_image->find_export(d_encrypt_string("IofCompleteRequest")));
	context->imports.ob_register_callbacks = reinterpret_cast<t_ob_register_callbacks>(ntoskrnl_image->find_export(d_encrypt_string("ObRegisterCallbacks")));
	context->imports.ob_unregister_callbacks = reinterpret_cast<t_ob_unregister_callbacks>(ntoskrnl_image->find_export(d_encrypt_string("ObUnRegisterCallbacks")));
	context->imports.io_create_symbolic_link = reinterpret_cast<t_io_create_symbolic_link>(ntoskrnl_image->find_export(d_encrypt_string("IoCreateSymbolicLink")));
	context->imports.io_create_device = reinterpret_cast<t_io_create_device>(ntoskrnl_image->find_export(d_encrypt_string("IoCreateDevice")));
	context->imports.io_delete_device = reinterpret_cast<t_io_delete_device>(ntoskrnl_image->find_export(d_encrypt_string("IoDeleteDevice")));
	context->imports.io_delete_symbolic_link = reinterpret_cast<t_io_delete_symbolic_link>(ntoskrnl_image->find_export(d_encrypt_string("IoDeleteSymbolicLink")));
	context->imports.ps_lookup_thread_by_thread_id = reinterpret_cast<t_ps_lookup_thread_by_thread_id>(ntoskrnl_image->find_export(d_encrypt_string("PsLookupThreadByThreadId")));
	context->imports.ps_is_system_thread = reinterpret_cast<t_ps_is_system_thread>(ntoskrnl_image->find_export(d_encrypt_string("PsIsSystemThread")));
	context->imports.ke_stack_attach_process = reinterpret_cast<t_ke_stack_attach_process>(ntoskrnl_image->find_export(d_encrypt_string("KeStackAttachProcess")));
	context->imports.ke_unstack_detach_process = reinterpret_cast<t_ke_unstack_detach_process>(ntoskrnl_image->find_export(d_encrypt_string("KeUnstackDetachProcess")));
	context->imports.mm_get_physical_address = reinterpret_cast<t_mm_get_physical_address>(ntoskrnl_image->find_export(d_encrypt_string("MmGetPhysicalAddress")));
	context->imports.mm_get_virtual_for_physical = reinterpret_cast<t_mm_get_virtual_for_physical>(ntoskrnl_image->find_export(d_encrypt_string("MmGetVirtualForPhysical")));
	context->imports.ke_query_active_processor_count = reinterpret_cast<t_ke_query_active_processor_count>(ntoskrnl_image->find_export(d_encrypt_string("KeQueryActiveProcessorCount")));
	context->imports.hal_send_nmi = reinterpret_cast<t_hal_send_nmi>(ntoskrnl_image->find_export(d_encrypt_string("HalSendNMI")));
	context->imports.ke_initialize_affinity_ex = reinterpret_cast<t_ke_initialize_affinity_ex>(ntoskrnl_image->find_export(d_encrypt_string("KeInitializeAffinityEx")));
	context->imports.ke_add_processor_affinity_ex = reinterpret_cast<t_ke_add_processor_affinity_ex>(ntoskrnl_image->find_export(d_encrypt_string("KeAddProcessorAffinityEx")));
	context->imports.ke_register_nmi_callback = reinterpret_cast<t_ke_register_nmi_callback>(ntoskrnl_image->find_export(d_encrypt_string("KeRegisterNmiCallback")));
	context->imports.ke_deregister_nmi_callback = reinterpret_cast<t_ke_deregister_nmi_callback>(ntoskrnl_image->find_export(d_encrypt_string("KeDeregisterNmiCallback")));
	context->imports.ke_delay_execution_thread = reinterpret_cast<t_ke_delay_execution_thread>(ntoskrnl_image->find_export(d_encrypt_string("KeDelayExecutionThread")));
	context->imports.hvl_switch_virtual_address_space = reinterpret_cast<t_hvl_switch_virtual_address_space>(find_hvl_switch_virtual_address_space(ntoskrnl_image));
}

// bcrypt related imports
void resolve_cng_imports(context::s_context* context, const portable_executable::image_t* cng_image)
{
	context->imports.bcrypt_open_algorithm_provider = reinterpret_cast<t_bcrypt_open_algorithm_provider>(cng_image->find_export(d_encrypt_string("BCryptOpenAlgorithmProvider")));
	context->imports.bcrypt_get_property = reinterpret_cast<t_bcrypt_get_property>(cng_image->find_export(d_encrypt_string("BCryptGetProperty")));
	context->imports.bcrypt_close_algorithm_provider = reinterpret_cast<t_bcrypt_close_algorithm_provider>(cng_image->find_export(d_encrypt_string("BCryptCloseAlgorithmProvider")));
	context->imports.bcrypt_create_hash = reinterpret_cast<t_bcrypt_create_hash>(cng_image->find_export(d_encrypt_string("BCryptCreateHash")));
	context->imports.bcrypt_destroy_hash = reinterpret_cast<t_bcrypt_destroy_hash>(cng_image->find_export(d_encrypt_string("BCryptDestroyHash")));
	context->imports.bcrypt_hash_data = reinterpret_cast<t_bcrypt_hash_data>(cng_image->find_export(d_encrypt_string("BCryptHashData")));
	context->imports.bcrypt_finish_hash = reinterpret_cast<t_bcrypt_finish_hash>(cng_image->find_export(d_encrypt_string("BCryptFinishHash")));
}

bool imports::load(context::s_context* context)
{
	const portable_executable::image_t* ntoskrnl_image = reinterpret_cast<const portable_executable::image_t*>(context->ntoskrnl_base_address);

	resolve_ntoskrnl_imports(context, ntoskrnl_image);

	_KLDR_DATA_TABLE_ENTRY* cng_ldr_info = reinterpret_cast<_KLDR_DATA_TABLE_ENTRY*>(ntkrnl::get_system_module_ldr_info(context, d_encrypt_string(L"cng.sys")));

	if (cng_ldr_info == nullptr)
	{
		d_log("[darken-anticheat] failed to locate cng.sys.\n");

		return false;
	}

	const portable_executable::image_t* cng_image = reinterpret_cast<const portable_executable::image_t*>(cng_ldr_info->DllBase);

	resolve_cng_imports(context, cng_image);

	return true;
}

```

`kernel/src/imports/imports.h`:

```h
#pragma once
#include "../context/context.h"

namespace imports
{
	bool load(context::s_context* context);
}

```

`kernel/src/imports/imports_def.h`:

```h
#pragma once
#include "generic_types.h"

// ntoskrnl.exe
typedef void(__stdcall* t_iof_complete_request)(void* irp, int8_t priority_boost);
typedef uint64_t(__stdcall* t_ex_allocate_pool_2)(uint64_t pool_flags, uint64_t number_of_bytes, uint32_t tag);
typedef void(__stdcall* t_ex_free_pool_with_tag)(uint64_t pool, uint32_t tag);
typedef uint32_t(__stdcall* t_ob_register_callbacks)(void* callback_registration, void** registration_handle);
typedef void(__stdcall* t_ob_unregister_callbacks)(void* registration_handle);
typedef uint32_t(__stdcall* t_io_create_symbolic_link)(void* symbolic_link_name, void* device_name);
typedef uint32_t(__stdcall* t_io_create_device)(void* driver_object, uint32_t device_extension_size, void* device_name, uint32_t device_type, uint32_t device_characteristics, uint8_t exclusive, void* device_object);
typedef void(__stdcall* t_io_delete_device)(void* device_object);
typedef uint32_t(__stdcall* t_io_delete_symbolic_link)(void* symbolic_link_name);
typedef uint32_t(__stdcall* t_ps_lookup_thread_by_thread_id)(uint64_t thread_id, void* thread_out);
typedef uint8_t(__stdcall* t_ps_is_system_thread)(uint64_t thread);
typedef void(__stdcall* t_ke_stack_attach_process)(uint64_t eprocess, void* apc_state);
typedef void(__stdcall* t_ke_unstack_detach_process)(void* apc_state);
typedef uint64_t(__stdcall* t_mm_get_physical_address)(uint64_t virtual_address);
typedef uint64_t(__stdcall* t_mm_get_virtual_for_physical)(uint64_t physical_address);
typedef void(__stdcall* t_hal_send_nmi)(void* affinity);
typedef uint32_t(__stdcall* t_ke_query_active_processor_count)(void* active_processors_affinity);
typedef void(__stdcall* t_ke_initialize_affinity_ex)(void* affinity);
typedef void(__stdcall* t_ke_add_processor_affinity_ex)(void* affinity, uint32_t index);
typedef uint64_t(__stdcall* t_ke_register_nmi_callback)(void* handler_function, void* context);
typedef uint32_t(__stdcall* t_ke_deregister_nmi_callback)(uint64_t callback_handle);
typedef uint32_t(__stdcall* t_ke_delay_execution_thread)(int8_t wait_mode, uint8_t alertable, void* interval);
typedef uint64_t(__fastcall* t_hvl_switch_virtual_address_space)(int64_t cr3);

// cng.sys
typedef uint32_t(__stdcall* t_bcrypt_open_algorithm_provider)(void** algorithm_handle_ptr, const wchar_t* algorithm_id, const wchar_t* implementation, uint32_t flags);
typedef uint32_t(__stdcall* t_bcrypt_get_property)(void* algorithm_handle, const wchar_t* property, uint8_t* output_buffer, uint32_t size_of_output_buffer, uint32_t* bytes_returned, uint32_t flags);
typedef uint32_t(__stdcall* t_bcrypt_close_algorithm_provider)(void* algorithm_handle, uint32_t flags);
typedef uint32_t(__stdcall* t_bcrypt_create_hash)(void* algorithm_handle, void** hash_handle_ptr, uint8_t* hash_object_buffer, uint32_t hash_object_buffer_size, uint8_t* secret_buffer, uint32_t secret_size, uint32_t size);
typedef uint32_t(__stdcall* t_bcrypt_destroy_hash)(void* hash_handle);
typedef uint32_t(__stdcall* t_bcrypt_hash_data)(void* hash_handle, uint8_t* data_to_hash_buffer, uint32_t data_to_hash_buffer_size, uint32_t flags);
typedef uint32_t(__stdcall* t_bcrypt_finish_hash)(void* hash_handle, uint8_t* hash_out_buffer, uint32_t hash_out_buffer_size, uint32_t flags);

namespace imports
{
	struct s_imports
	{
		// ntoskrnl.exe
		uint16_t* nt_build_number;
		uint64_t ps_loaded_module_list;
		uint64_t ps_process_type;
		uint32_t* hvl_enlightenments;

		t_ex_allocate_pool_2 ex_allocate_pool_2;
		t_ex_free_pool_with_tag ex_free_pool_with_tag;
		t_iof_complete_request iof_complete_request;
		t_ob_register_callbacks ob_register_callbacks;
		t_ob_unregister_callbacks ob_unregister_callbacks;
		t_io_create_symbolic_link io_create_symbolic_link;
		t_io_create_device io_create_device;
		t_io_delete_device io_delete_device;
		t_io_delete_symbolic_link io_delete_symbolic_link;
		t_ps_lookup_thread_by_thread_id ps_lookup_thread_by_thread_id;
		t_ps_is_system_thread ps_is_system_thread;
		t_ke_stack_attach_process ke_stack_attach_process;
		t_ke_unstack_detach_process ke_unstack_detach_process;
		t_mm_get_physical_address mm_get_physical_address;
		t_mm_get_virtual_for_physical mm_get_virtual_for_physical;
		t_ke_query_active_processor_count ke_query_active_processor_count;
		t_ke_initialize_affinity_ex ke_initialize_affinity_ex;
		t_ke_add_processor_affinity_ex ke_add_processor_affinity_ex;
		t_hal_send_nmi hal_send_nmi;
		t_ke_register_nmi_callback ke_register_nmi_callback;
		t_ke_deregister_nmi_callback ke_deregister_nmi_callback;
		t_ke_delay_execution_thread ke_delay_execution_thread;
		t_hvl_switch_virtual_address_space hvl_switch_virtual_address_space;

		// cng.sys
		t_bcrypt_open_algorithm_provider bcrypt_open_algorithm_provider;
		t_bcrypt_get_property bcrypt_get_property;
		t_bcrypt_close_algorithm_provider bcrypt_close_algorithm_provider;
		t_bcrypt_create_hash bcrypt_create_hash;
		t_bcrypt_destroy_hash bcrypt_destroy_hash;
		t_bcrypt_hash_data bcrypt_hash_data;
		t_bcrypt_finish_hash bcrypt_finish_hash;
	};
}

```

`kernel/src/log.h`:

```h
#pragma once

#ifndef d_log

#ifdef DEBUG

#define d_dpfltr_ihvdriver_id 77

// not going to manually import these, as in production we will not be in debug mode
// if you require debug prints in production then manually import them
#define d_log(format, ...) DbgPrintEx(d_dpfltr_ihvdriver_id, 0, format, __VA_ARGS__)
#define d_wide_log(format, ...) DbgPrintEx(d_dpfltr_ihvdriver_id, 0, format, __VA_ARGS__)
#else
#define d_log(format, ...)
#define d_wide_log(format, ...)
#endif

#endif
```

`kernel/src/main.cpp`:

```cpp
#include "detections/hypervisor/reserved_msr_usage.h"
#include "detections/system/non_maskable_interrupts.h"
#include "detections/system/system_thread.h"
#include "detections/process/process_thread.h"
#include "detections/integrity/integrity.h"
#include "detections/integrity/data_section_integrity.h"
#include "context/context.h"
#include "detections/patchguard/patchguard.h"
#include "os/ntkrnl/ntkrnl.h"
#include "os/callbacks/handles/handles.h"
#include "imports/imports.h"
#include "memory/page_tables.h"
#include "offsets/offsets.h"
#include "log.h"

#include <string_encryption.h>
#include <ntifs.h>

#define d_control_code(code) CTL_CODE(FILE_DEVICE_UNKNOWN, code, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

namespace driver_info
{
	UNICODE_STRING device_name = RTL_CONSTANT_STRING(L"\\Device\\darken-ac");
	UNICODE_STRING device_symbolic_name = RTL_CONSTANT_STRING(L"\\DosDevices\\darken-ac");
}

NTSTATUS ioctl_manage_call(PDEVICE_OBJECT device_object, PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	irp->IoStatus.Information = 0ull;
	irp->IoStatus.Status = STATUS_SUCCESS;

	context::s_context* context = context::get_decrypted();

	context->imports.iof_complete_request(irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

NTSTATUS ioctl_call_processor(PDEVICE_OBJECT device_object, PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	context::s_context* context = context::get_decrypted();

	// IoGetCurrentIrpStackLocation is force inlined
	uint32_t code = IoGetCurrentIrpStackLocation(irp)->Parameters.DeviceIoControl.IoControlCode;

	communication::s_call_info* call_info = reinterpret_cast<communication::s_call_info*>(irp->AssociatedIrp.SystemBuffer);

	switch (code)
	{
	case d_control_code(communication::e_control_code::test):
	{
		call_info->detection_status = communication::e_detection_status::clean;

		break;
	}
	case d_control_code(communication::e_control_code::initialise_protected_processes):
	{
		if ((context->protected_processes.anticheat_usermode_id == 0 && context->protected_processes.protected_process_id == 0)
			|| (context->protected_processes.protected_process_id != 0 && ntkrnl::get_eprocess(context->protected_processes.protected_process_id)) // this line is checking if cached protected process is no longer running, leaving a new context ready to be used
			)
		{
			context->protected_processes = call_info->protected_processes;

			call_info->detection_status = communication::e_detection_status::clean;
		}
		else
		{
			call_info->detection_status = communication::e_detection_status::runtime_error;
		}

		break;
	}
	case d_control_code(communication::e_control_code::is_suspicious_system_thread_present):
	{
		call_info->detection_status = system::system_thread::is_suspicious_thread_present(context);

		break;
	}
	case d_control_code(communication::e_control_code::is_suspicious_process_thread_present):
	{
		call_info->detection_status = process::process_thread::is_suspicious_thread_present(context, call_info->is_suspicious_process_thread_present);

		break;
	}
	case d_control_code(communication::e_control_code::check_reserved_msr_usage):
	{
		call_info->detection_status = hypervisor::check_reserved_msr_usage();

		break;
	}
	case d_control_code(communication::e_control_code::trigger_patchguard_bugcheck):
	{
		_trigger_patchguard_bugcheck();

		call_info->detection_status = communication::e_detection_status::clean;

		break;
	}
	case d_control_code(communication::e_control_code::send_and_analyze_non_maskable_interrupts):
	{
		call_info->detection_status = system::non_maskable_interrupts::send_and_analyze(context);

		break;
	}
	case d_control_code(communication::e_control_code::validate_ntoskrnl_integrity):
	{
		call_info->detection_status = integrity::validate_ntoskrnl_integrity(context);

		break;
	}
	case d_control_code(communication::e_control_code::validate_kernel_drivers_integrity):
	{
		call_info->detection_status = integrity::validate_kernel_drivers_integrity(context);

		break;
	}
	case d_control_code(communication::e_control_code::is_any_driver_data_section_executable):
	{
		call_info->detection_status = integrity::data_section::is_any_driver_data_section_executable(context);

		break;
	}
	default:
	{
		d_log("[darken-anticheat] ioctl code is invalid, received %lu.\n", code);

		break;
	}
	}

	irp->IoStatus.Information = sizeof(communication::s_call_info);
	irp->IoStatus.Status = STATUS_SUCCESS;

	context->imports.iof_complete_request(irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

void free_context_integrity_data(context::s_context* context)
{
	context->integrity.ntoskrnl_text_hash.free_hash_buffer(context);

	crypto::s_hash_list_entry* kernel_module_hash_list_entry = context->integrity.kernel_module_hash_list_head;

	while (kernel_module_hash_list_entry != nullptr)
	{
		kernel_module_hash_list_entry->delete_self(context);

		kernel_module_hash_list_entry = kernel_module_hash_list_entry->get_next();
	}
}

void driver_unload(PDRIVER_OBJECT driver_object)
{
	context::s_context* context = context::get_decrypted();

	t_io_delete_device io_delete_device = context->imports.io_delete_device;
	t_io_delete_symbolic_link io_delete_symbolic_link = context->imports.io_delete_symbolic_link;

	free_context_integrity_data(context);

	callbacks::handles::unload(context);
	page_tables::unload(context);

	context = nullptr;

	context::unload();

	io_delete_device(driver_object->DeviceObject);
	io_delete_symbolic_link(&driver_info::device_symbolic_name);
}

NTSTATUS driver_entry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(registry_path);

	driver_object->DriverUnload = driver_unload;

	if (context::load() == false)
	{
		d_log("[darken-anticheat] failed to set up initial context.\n");

		return STATUS_ABANDONED;
	}

	context::s_context* context = context::get_decrypted();

	if (imports::load(context) == false)
	{
		d_log("[darken-anticheat] failed to manually load imports.\n");

		return STATUS_ABANDONED;
	}

	if (offsets::load(context) == false)
	{
		d_log("[darken-anticheat] failed to calculate offsets, are we on an unsupported Windows version?\n");

		return STATUS_ABANDONED;
	}

	if (page_tables::load(context) == false)
	{
		d_log("[darken-anticheat] failed to set up page table.\n");

		return STATUS_ABANDONED;
	}

	if (callbacks::handles::load(context) == false)
	{
		d_log("[darken-anticheat] failed to load process handle permission stripping.\n");

		return STATUS_ABANDONED;
	}

	int32_t ntoskrnl_hash_status = integrity::calculate_image_section_hash(context, context->ntoskrnl_base_address, d_encrypt_string(".text"), &context->integrity.ntoskrnl_text_hash);

	if (NT_SUCCESS(ntoskrnl_hash_status) == false)
	{
		d_log("[darken-anticheat] failed to calculate initial 'ntoskrnl.exe' hash.\n");

		return STATUS_ABANDONED;
	}

	driver_object->MajorFunction[IRP_MJ_CREATE] = ioctl_manage_call;
	driver_object->MajorFunction[IRP_MJ_CLOSE] = ioctl_manage_call;
	driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ioctl_call_processor;

	NTSTATUS sanity_status = context->imports.io_create_symbolic_link(&driver_info::device_symbolic_name, &driver_info::device_name);

	if (NT_SUCCESS(sanity_status) == false)
	{
		d_log("[darken-anticheat] unable to create symbolic link between device names.\n");

		return sanity_status;
	}

	sanity_status = context->imports.io_create_device(driver_object, 0, &driver_info::device_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &driver_object->DeviceObject);

	if (NT_SUCCESS(sanity_status) == false)
	{
		d_log("[darken-anticheat] unable to create io device.\n");

		return sanity_status;
	}

	// NOTE: if you are testing on a system with patchguard disabled, uncommenting this next line WILL crash your system
	//patchguard::trigger_bugcheck(); // im not sure about this line yet, control over the idt could lead them straight to this routine

	d_log("[darken-anticheat] loaded successfully.\n");

	return STATUS_SUCCESS;
}

```

`kernel/src/memory/memory.cpp`:

```cpp
#include "memory.h"
#include "page_tables.h"
#include "../context/context.h"

#include <intrin.h>
#include "../os/hvl/enlightenments.h"

struct s_pte
{
	uint64_t physical_address;
	uint32_t size;

	uint8_t is_executable;
};

void process_translation_pte_info(uint64_t* size_left_of_page, bool* is_executable, uint64_t page_size, uint64_t page_offset, uint64_t execute_disable)
{
	if (size_left_of_page)
	{
		*size_left_of_page = page_size - page_offset;
	}

	if (is_executable)
	{
		*is_executable = (execute_disable == 0);
	}
}

uint64_t memory::translate_virtual_address(s_virtual_address virtual_address, cr3 directory_table_base, uint64_t* size_left_of_page, bool* is_executable)
{
	if (virtual_address.address == 0 || directory_table_base.flags == 0)
	{
		return 0;
	}

	pml4e_64* pml4 = reinterpret_cast<pml4e_64*>(page_tables::pt_access_virtual_address + (directory_table_base.address_of_page_directory << 12));

	pml4e_64 pml4e = pml4[virtual_address.pml4_idx];

	if (pml4e.present == 0)
	{
		return 0;
	}

	pdpte_64* pdpt = reinterpret_cast<pdpte_64*>(page_tables::pt_access_virtual_address + (pml4e.page_frame_number << 12));

	pdpte_64 pdpte = pdpt[virtual_address.pdpt_idx];

	if (pdpte.present == 0)
	{
		return 0;
	}

	if (pdpte.large_page == 1)
	{
		pdpte_1gb_64 pdpte_1gb = { .flags = pdpte.flags };

		uint64_t page_offset = virtual_address.offset + (virtual_address.pt_idx << 12) + (virtual_address.pd_idx << 21);

		process_translation_pte_info(size_left_of_page, is_executable, 0x40000000, page_offset, pml4e.execute_disable | pdpte_1gb.execute_disable);

		return page_offset + (pdpte_1gb.page_frame_number << 30);
	}

	pde_64* pd = reinterpret_cast<pde_64*>(page_tables::pt_access_virtual_address + (pdpte.page_frame_number << 12));

	pde_64 pde = pd[virtual_address.pd_idx];

	if (pde.present == 0)
	{
		return 0;
	}

	if (pde.large_page == 1)
	{
		pde_2mb_64 pde_2mb = { .flags = pde.flags };

		uint64_t page_offset = virtual_address.offset + (virtual_address.pt_idx << 12);

		process_translation_pte_info(size_left_of_page, is_executable, 0x200000, page_offset, pde_2mb.execute_disable | pml4e.execute_disable | pdpte.execute_disable);

		return page_offset + (pde_2mb.page_frame_number << 21);
	}

	pte_64* pt = reinterpret_cast<pte_64*>(page_tables::pt_access_virtual_address + (pde.page_frame_number << 12));

	pte_64 pte = pt[virtual_address.pt_idx];

	if (pte.present == 0)
	{
		return 0;
	}

	process_translation_pte_info(size_left_of_page, is_executable, 0x1000, virtual_address.offset, pte.execute_disable | pde.execute_disable | pml4e.execute_disable | pdpte.execute_disable);

	return virtual_address.offset + (pte.page_frame_number << 12);
}

bool memory::is_address_valid(uint64_t virtual_address, uint64_t directory_table_base)
{
	return translate_virtual_address({ virtual_address }, { .flags = directory_table_base }) != 0;
}

uint64_t memory::allocate_pool(context::s_context* context, uint64_t size, uint64_t flags, uint32_t tag)
{
	return context->imports.ex_allocate_pool_2(flags, size, tag);
}

void memory::free_pool(context::s_context* context, uint64_t pool_address, uint32_t tag)
{
	context->imports.ex_free_pool_with_tag(pool_address, tag);
}

void memory::current_context::write_cr3(cr3 value)
{
	if (hvl::get_enlightenments() & 1)
	{
		context::get_decrypted()->imports.hvl_switch_virtual_address_space(value.flags);
	}
	else
	{
		__writecr3(value.flags);
	}
}

cr3 memory::current_context::read_cr3()
{
	return { .flags = __readcr3() };
}

```

`kernel/src/memory/memory.h`:

```h
#pragma once
#include "../structures/virtual_address.h"
#include "../context/context.h"
#include <ia32/ia32.h>

namespace memory
{
	// note: cr3 must hold page_tables::pt_cr3 when invoking this function
	uint64_t translate_virtual_address(s_virtual_address virtual_address, cr3 directory_table_base, uint64_t* size_left_of_page = nullptr, bool* is_executable = nullptr);

	bool is_address_valid(uint64_t virtual_address, uint64_t directory_table_base);
	uint64_t allocate_pool(context::s_context* context, uint64_t size, uint64_t flags, uint32_t tag = d_pool_tag);
	void free_pool(context::s_context* context, uint64_t pool_address, uint32_t tag = d_pool_tag);

	namespace current_context
	{
		void write_cr3(cr3 value);

		cr3 read_cr3();
	}
}

```

`kernel/src/memory/page_tables.cpp`:

```cpp
#include "page_tables.h"
#include "page_tables_def.h"
#include "../os/ntkrnl/ntkrnl.h"
#include "../memory/memory.h"
#include <ntifs.h>

bool page_tables::load(context::s_context* context)
{
	s_page_table* page_tables = reinterpret_cast<s_page_table*>(memory::allocate_pool(context, sizeof(s_page_table), POOL_FLAG_NON_PAGED));

	if (page_tables == nullptr)
	{
		return false;
	}

	memset(page_tables, 0, sizeof(s_page_table));

	pml4e_64* target_pml4e = &page_tables->pml4[d_pml4e_to_map_into];

	target_pml4e->present = 1;
	target_pml4e->write = 1;
	target_pml4e->page_frame_number = context->imports.mm_get_physical_address(reinterpret_cast<uint64_t>(&page_tables->pdpt)) >> 12;

	for (uint32_t i = 0; i < 512; i++)
	{
		pdpte_1gb_64* current_pdpte = &page_tables->pdpt[i];

		current_pdpte->present = 1;
		current_pdpte->write = 1;
		current_pdpte->large_page = 1;
		current_pdpte->page_frame_number = i;
	}

	// need to copy over kernel entries now otherwise our code wont be even able to execute when we load these page tables into cr3 reg
	// 
	// im going to get virtual address of the system pml4 through MmGetVirtualForPhysical
	// as opposed to reading from the physical address using MmCopyMemory due to MmCopyMemory being slower

	uint64_t system_directory_table_base_physical = ntkrnl::get_process_directory_table_base(context->initial_system_process);

	if (system_directory_table_base_physical == 0) // never should happen
	{
		return false;
	}

	pml4e_64* system_directory_table_base_virtual = reinterpret_cast<pml4e_64*>(context->imports.mm_get_virtual_for_physical(system_directory_table_base_physical));

	if (system_directory_table_base_virtual == nullptr)
	{
		return false;
	}

	memcpy(&page_tables->pml4[256], &system_directory_table_base_virtual[256], sizeof(pml4e_64) * 256);

	context->memory.pt_cr3.address_of_page_directory = context->imports.mm_get_physical_address(reinterpret_cast<uint64_t>(&page_tables->pml4)) >> 12;
	context->memory.page_tables = page_tables;

	return true;
}

void page_tables::unload(context::s_context* context)
{
	s_page_table* page_tables = context->memory.page_tables;

	if (page_tables != nullptr)
	{
		memory::free_pool(context, reinterpret_cast<uint64_t>(page_tables));
	}
}

```

`kernel/src/memory/page_tables.h`:

```h
#pragma once
#include "../context/context.h"
#include <ia32/ia32.h>

// should not pass 255, otherwise will be overwriting potential kernel entries
#define d_pml4e_to_map_into 1ull

namespace page_tables
{
	bool load(context::s_context* context);
	void unload(context::s_context* context);
}

```

`kernel/src/memory/page_tables_def.h`:

```h
#pragma once
#include <ia32/ia32.h>

// should not pass 255, otherwise will be overwriting potential kernel entries
#define d_pml4e_to_map_into 1ull

namespace page_tables
{
	// we are going to use 'huge pages' (pdpt describing 1gb each), which should be fine for any cpu made after late 2000s
	// if this will cause a collision with some systems, then we will map pds in too for each pdpte in our held pml4e
	struct s_page_table
	{
		pml4e_64 pml4[512];
		pdpte_1gb_64 pdpt[512]; // pdpt that will be mapped into the pml4e we control
	};

	inline constexpr uint64_t pt_access_virtual_address = d_pml4e_to_map_into << 39;
}

```

`kernel/src/offsets/offsets.cpp`:

```cpp
#include "offsets.h"
#include "../context/context.h"
#include <ntifs.h>

bool offsets::load(context::s_context* context)
{
	uint16_t build_number = *context->imports.nt_build_number;

	if (26100 <= build_number) // windows 11 24h2 +
	{
		eprocess::unique_process_id = 0x1D0;
		eprocess::section_base_address = 0x2B0;
		eprocess::peb = 0x2E0;

		ethread::start_address = 0x4E0;
		ethread::cid = 0x508;
		ethread::win32_start_address = 0x560;
	}
	else if (22000 <= build_number) // Windows 11 Insider Preview -> Windows 11 23H2
	{
		eprocess::unique_process_id = 0x440;
		eprocess::section_base_address = 0x520;
		eprocess::peb = 0x550;

		ethread::start_address = 0x4A0;
		ethread::cid = 0x4C8;
		ethread::win32_start_address = 0x520;
	}
	else if (19041 <= build_number) // Windows 10 2004 -> Windows 10 22H2
	{
		eprocess::unique_process_id = 0x440;
		eprocess::section_base_address = 0x520;
		eprocess::peb = 0x550;

		ethread::start_address = 0x450;
		ethread::cid = 0x478;
		ethread::win32_start_address = 0x4D0;
	}
	else if (18362 <= build_number) // Windows 10 1903 -> Windows 10 1909
	{
		eprocess::unique_process_id = 0x2E0;
		eprocess::section_base_address = 0x3C8;

		ethread::start_address = 0x620;
		ethread::cid = 0x648;
		ethread::win32_start_address = 0x6A0;
	}
	else if (15063 <= build_number) // Windows 10 1703 -> Windows 10 1809
	{
		eprocess::unique_process_id = 0x2E0;

		ethread::start_address = 0x610;
		ethread::cid = 0x638;
		ethread::win32_start_address = 0x690;
	}
	else if (14393 <= build_number) // Windows 10 1607 only
	{
		ethread::start_address = 0x608;
		ethread::cid = 0x630;
		ethread::win32_start_address = 0x688;
	}
	else if (10240 <= build_number) // Windows 10 1507 -> Windows 10 1511
	{
		// compile-time values are already defined for this version range
	}
	else
	{
		// is before Windows 10 1507 (first release version of Windows 10)

		return false;
	}

	eprocess::active_process_links = eprocess::unique_process_id + 8;

	return true;
}

```

`kernel/src/offsets/offsets.h`:

```h
#pragma once
#include "../context/context.h"

// when people reverse engineer our driver, they are going to grab a hypervisor
// and place breakpoints on nearly every export in ntoskrnl
// to make it harder for them, we are going to try minimize the amount of imports we use
// 
// hence we now can't use functions such as PsGetCurrentProcessId or PsLookupProcessByProcessId
// todo: use disassembler to figure out offsets by analyzing aforementioned functions

// starts at Windows 10 1507 up until Windows 11 24H2
namespace offsets
{
	bool load(context::s_context* context);

	namespace kthread
	{
		inline uint64_t apc_state = 0x98; // doesn't change at all (last checked: Windows 11 24H2)
		inline uint64_t process = 0x220; // doesn't change at all (last checked: Windows 11 24H2)
	}

	namespace ethread
	{
		inline uint64_t start_address = 0x600; // doesn't change until Windows 10 1607, Windows 10 2004, Windows 11 24H2 (last checked: Windows 11 24H2)
		inline uint64_t cid = 0x628; // doesn't change until Windows 10 1607, Windows 10 2004, Windows 11 24H2(last checked: Windows 11 24H2)
		inline uint64_t win32_start_address = 0x680; // doesn't change until Windows 10 1607, Windows 10 2004, Windows 11 24H2 (last checked: Windows 11 24H2)
	}

	namespace kapc_state
	{
		inline uint64_t process = 0x20; // doesn't change at all (last checked: Windows 11 24H2)
	}

	namespace kpcr
	{
		inline uint64_t tss_base = 0x8; // never changes
	}

	namespace eprocess
	{
		inline uint64_t directory_table_base = 0x28;
		inline uint64_t unique_process_id = 0x2E8; // doesn't change until Windows 10 1703, Windows 10 2004, Windows 11 24H2 (last checked: Windows 11 24H2)
		inline uint64_t active_process_links = 0; // always the same as (unique_process_id + 8) (last checked: Windows 11 24H2)
		inline uint64_t section_base_address = 0x3C0; // doesn't change until Windows 10 1903, Windows 10 2004, Windows 11 24H2 (last checked: Windows 11 24H2)
		inline uint64_t peb = 0x3F8; // doesn't change until Windows 10 2004, Windows 11 24H2 (last checked: Windows 11 24H2)
	}

	namespace ldr_data_table_entry
	{
		inline uint64_t in_memory_order_links = 0x10;
	}
}

```

`kernel/src/os/callbacks/handles/handles.cpp`:

```cpp
#include "handles.h"
#include "../../../detections/handles/permission_stripping.h"
#include "../../../os/ntkrnl/ntkrnl.h"
#include "../../../log.h"
#include <ntifs.h>

namespace callbacks::handles
{
	void* registration_handle = nullptr;
}

#define d_process_query_limited_information 0x1000

OB_PREOP_CALLBACK_STATUS pre_operation_detour(communication::s_protected_processes* protected_processes, POB_PRE_OPERATION_INFORMATION pre_operation_information)
{
	// context hasn't been initialised yet. todo: monitor if protected processes structure has been tampered

	if (protected_processes->anticheat_usermode_id == 0 && protected_processes->protected_process_id == 0)
	{
		return OB_PREOP_SUCCESS;
	}

	uint64_t current_process = ntkrnl::get_current_process();
	uint64_t target_process = reinterpret_cast<uint64_t>(pre_operation_information->Object);

	if (current_process == 0 || target_process == 0) // undefined behaviour
	{
		return OB_PREOP_SUCCESS;
	}

	handles::permission_stripping::on_pre_handle_operation(protected_processes, pre_operation_information, current_process, target_process);

	return OB_PREOP_SUCCESS;
}

void post_operation_detour(void* registration_context, POB_POST_OPERATION_INFORMATION operation_information)
{
	UNREFERENCED_PARAMETER(registration_context);
	UNREFERENCED_PARAMETER(operation_information);
}

bool callbacks::handles::load(context::s_context* context)
{
	OB_OPERATION_REGISTRATION ob_operation_registration = { };

	ob_operation_registration.ObjectType = reinterpret_cast<POBJECT_TYPE*>(context->imports.ps_process_type);
	ob_operation_registration.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	ob_operation_registration.PreOperation = reinterpret_cast<POB_PRE_OPERATION_CALLBACK>(pre_operation_detour);
	ob_operation_registration.PostOperation = post_operation_detour;

	OB_CALLBACK_REGISTRATION callback_registration = { };

	callback_registration.OperationRegistration = &ob_operation_registration;
	callback_registration.RegistrationContext = &context->protected_processes;
	callback_registration.Version = OB_FLT_REGISTRATION_VERSION;
	callback_registration.Altitude = RTL_CONSTANT_STRING(L"361337"); // 360000 - 389999: FSFilter Activity Monitor
	callback_registration.OperationRegistrationCount = 1;

	return NT_SUCCESS(context->imports.ob_register_callbacks(&callback_registration, &registration_handle));
}

void callbacks::handles::unload(context::s_context* context)
{
	if (registration_handle != nullptr)
	{
		context->imports.ob_unregister_callbacks(registration_handle);

		registration_handle = nullptr;
	}
}


```

`kernel/src/os/callbacks/handles/handles.h`:

```h
#pragma once
#include "../../../context/context.h"

namespace callbacks
{
	namespace handles
	{
		bool load(context::s_context* context);
		void unload(context::s_context* context);
	}
}

```

`kernel/src/os/hvl/enlightenments.cpp`:

```cpp
#include "enlightenments.h"
#include "../../context/context.h"

uint32_t hvl::get_enlightenments()
{
	return *context::get_decrypted()->imports.hvl_enlightenments;
}

```

`kernel/src/os/hvl/enlightenments.h`:

```h
#pragma once
#include "generic_types.h"

namespace hvl
{
	uint32_t get_enlightenments();
}

```

`kernel/src/os/ntkrnl/ntkrnl.cpp`:

```cpp
#include "ntkrnl.h"
#include "../../offsets/offsets.h"
#include "../../structures/kldr_data_table_entry.h"
#include <portable_executable/pe_crt/crt_string.hpp>

#include <ntifs.h>
#include <intrin.h>

#define d_lstar_msr 0xC0000082

uint64_t ntkrnl::get_eprocess(uint64_t target_process_id)
{
	context::s_context* context = context::get_decrypted();

	if (target_process_id == 4)
	{
		return context->initial_system_process;
	}

	return get_eprocess(target_process_id, context->initial_system_process);
}

uint64_t ntkrnl::get_eprocess(uint64_t target_process_id, uint64_t valid_eprocess)
{
	PLIST_ENTRY list_head = reinterpret_cast<PLIST_ENTRY>(valid_eprocess + offsets::eprocess::active_process_links);

	for (PLIST_ENTRY current_entry = list_head->Flink; current_entry != list_head; current_entry = current_entry->Flink)
	{
		uint64_t current_entry_eprocess = reinterpret_cast<uint64_t>(current_entry) - offsets::eprocess::active_process_links;
		uint64_t current_entry_process_id = get_process_id(current_entry_eprocess);

		if (current_entry_process_id == target_process_id)
		{
			return current_entry_eprocess;
		}
	}

	return 0;
}

uint64_t ntkrnl::get_process_id(uint64_t eprocess)
{
	return *reinterpret_cast<uint64_t*>(eprocess + offsets::eprocess::unique_process_id);
}

uint64_t ntkrnl::get_process_base_address(uint64_t eprocess)
{
	return *reinterpret_cast<uint64_t*>(eprocess + offsets::eprocess::section_base_address);
}

uint64_t ntkrnl::get_process_directory_table_base(uint64_t eprocess)
{
	return *reinterpret_cast<uint64_t*>(eprocess + offsets::eprocess::directory_table_base);
}

uint64_t ntkrnl::get_process_peb(uint64_t eprocess)
{
	return *reinterpret_cast<uint64_t*>(eprocess + offsets::eprocess::peb);
}

uint64_t ntkrnl::get_thread_eprocess(uint64_t ethread)
{
	return *reinterpret_cast<uint64_t*>(ethread + offsets::kthread::process);
}

uint64_t ntkrnl::get_thread_apc_eprocess(uint64_t ethread)
{
	return *reinterpret_cast<uint64_t*>(ethread + offsets::kthread::apc_state + offsets::kapc_state::process);
}

uint64_t ntkrnl::get_thread_win32_start_address(uint64_t ethread)
{
	return *reinterpret_cast<uint64_t*>(ethread + offsets::ethread::win32_start_address);
}

uint64_t ntkrnl::get_thread_process_id(uint64_t ethread)
{
	return *reinterpret_cast<uint64_t*>(ethread + offsets::ethread::cid);
}

uint8_t ntkrnl::get_current_processor_number()
{
	return __readgsbyte(0x184);
}

uint64_t ntkrnl::get_current_pcr()
{
	// evaluates to reading qword from gs:18h
	return __readgsqword(FIELD_OFFSET(KPCR, Self));
}

uint64_t ntkrnl::get_tss_base_from_pcr(uint64_t pcr)
{
	return *reinterpret_cast<uint64_t*>(pcr + offsets::kpcr::tss_base);
}

uint64_t ntkrnl::get_current_tss_base()
{
	uint64_t current_pcr = get_current_pcr();

	return get_tss_base_from_pcr(current_pcr);
}

uint64_t ntkrnl::get_current_process()
{
	uint64_t current_thread = get_current_thread();

	if (current_thread == 0)
	{
		return 0;
	}

	return get_thread_eprocess(current_thread);
}

uint64_t ntkrnl::get_current_thread()
{
	return __readgsqword(0x188);
}

void ntkrnl::enumerate_system_modules(context::s_context* context, t_enumerate_modules_callback callback, void* ctx, int64_t start_index)
{
	PLIST_ENTRY ps_loaded_module_list = reinterpret_cast<PLIST_ENTRY>(context->imports.ps_loaded_module_list);

	int64_t current_index = 0;

	for (PLIST_ENTRY current_list_entry = ps_loaded_module_list->Flink; current_list_entry != ps_loaded_module_list; current_list_entry = current_list_entry->Flink, current_index++)
	{
		if (start_index <= current_index)
		{
			_KLDR_DATA_TABLE_ENTRY* current_module_info = CONTAINING_RECORD(current_list_entry, _KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

			if (callback(reinterpret_cast<uint64_t>(current_module_info), ctx) == true)
			{
				return;
			}
		}
	}
}

struct s_module_name_search_callback_ctx
{
	const wchar_t* name;
	uint64_t module_ldr_info;
};

bool check_module_has_certain_name_callback(uint64_t current_module_info, void* context_in)
{
	_KLDR_DATA_TABLE_ENTRY* current_module = reinterpret_cast<_KLDR_DATA_TABLE_ENTRY*>(current_module_info);

	s_module_name_search_callback_ctx* module_name_search_context = reinterpret_cast<s_module_name_search_callback_ctx*>(context_in);

	if (portable_executable::pe_crt::wcsstr(current_module->BaseDllName.Buffer, module_name_search_context->name) != nullptr)
	{
		module_name_search_context->module_ldr_info = current_module_info;

		return true;
	}

	return false;
}

uint64_t ntkrnl::get_system_module_ldr_info(context::s_context* context, const wchar_t* name)
{
	s_module_name_search_callback_ctx callback_ctx = { };

	callback_ctx.name = name;

	ntkrnl::enumerate_system_modules(context, check_module_has_certain_name_callback, &callback_ctx);

	return callback_ctx.module_ldr_info;
}

struct s_thread_in_module_callback_ctx
{
	uint64_t address;
	bool is_in_module;
};

bool check_address_in_module_callback(uint64_t current_module_info, void* context)
{
	_KLDR_DATA_TABLE_ENTRY* current_module = reinterpret_cast<_KLDR_DATA_TABLE_ENTRY*>(current_module_info);

	uint64_t win32_thread_start_address = *reinterpret_cast<uint64_t*>(context);

	uint64_t current_module_base_address = reinterpret_cast<uint64_t>(current_module->DllBase);
	uint64_t current_module_end_address = current_module_base_address + current_module->SizeOfImage;

	if (current_module_base_address < win32_thread_start_address && win32_thread_start_address <= current_module_end_address)
	{
		reinterpret_cast<s_thread_in_module_callback_ctx*>(context)->is_in_module = true;

		return true;
	}

	return false;
}

bool ntkrnl::is_address_within_system_module(context::s_context* context, uint64_t address)
{
	s_thread_in_module_callback_ctx callback_ctx = { };

	callback_ctx.address = address;

	ntkrnl::enumerate_system_modules(context, check_address_in_module_callback, &callback_ctx);

	return callback_ctx.is_in_module;
}

uint64_t ntkrnl::pre_initialization::find_ntoskrnl_base()
{
	// thanks to papstuc for the idea of walking back from lstar msr
	uint64_t ki_system_call_handler = __readmsr(d_lstar_msr);

	// ntoskrnl is always aligned to 2mb where large pages is supported
	// todo: check large page support

	// todo: add some sanity check so we dont go too far down, should always be found though
	for (uint64_t system_2mb_boundary = ki_system_call_handler & 0xFFFFFFFFFFE00000; system_2mb_boundary != 0; system_2mb_boundary -= 0x200000)
	{
		uint16_t header_magic = *reinterpret_cast<uint16_t*>(system_2mb_boundary);

		if (header_magic == 0x5a4d)
		{
			return system_2mb_boundary;
		}
	}

	return 0;
}

```

`kernel/src/os/ntkrnl/ntkrnl.h`:

```h
#pragma once
#include "../../context/context.h"

namespace ntkrnl
{
	uint64_t get_eprocess(uint64_t target_process_id);

	// valid_eprocess is any eprocess in the system, so we can traverse the linked list
	uint64_t get_eprocess(uint64_t target_process_id, uint64_t valid_eprocess);

	uint64_t get_process_id(uint64_t eprocess);
	uint64_t get_process_base_address(uint64_t eprocess);
	uint64_t get_process_directory_table_base(uint64_t eprocess);
	uint64_t get_process_peb(uint64_t eprocess);

	uint64_t get_thread_eprocess(uint64_t ethread);
	uint64_t get_thread_apc_eprocess(uint64_t ethread);
	uint64_t get_thread_win32_start_address(uint64_t ethread);
	uint64_t get_thread_process_id(uint64_t ethread);

	uint8_t get_current_processor_number();
	uint64_t get_current_pcr();
	uint64_t get_tss_base_from_pcr(uint64_t pcr);
	uint64_t get_current_tss_base();

	uint64_t get_current_process();
	uint64_t get_current_thread();

	// return value signals if needs to continue enumerating
	// current_module_info will contain a pointer to: _KLDR_DATA_TABLE_ENTRY
	typedef bool(*t_enumerate_modules_callback)(uint64_t current_module_info, void* ctx);

	void enumerate_system_modules(context::s_context* context, t_enumerate_modules_callback callback, void* ctx, int64_t start_index = 0);

	uint64_t get_system_module_ldr_info(context::s_context* context, const wchar_t* name);
	bool is_address_within_system_module(context::s_context* context, uint64_t address);

	namespace pre_initialization
	{
		// note: to be used only when in when setting up context (to resolve imports before we have any indication of build number to get offsets)
		uint64_t find_ntoskrnl_base();
	}
}

```

`kernel/src/structures/_peb.h`:

```h
#pragma once
#include "peb_ldr_data.h"

#pragma warning(push)
#pragma warning(disable: 4201)

//0x7c8 bytes (sizeof)
struct _PEB
{
    UCHAR InheritedAddressSpace;                                            //0x0
    UCHAR ReadImageFileExecOptions;                                         //0x1
    UCHAR BeingDebugged;                                                    //0x2
    union
    {
        UCHAR BitField;                                                     //0x3
        struct
        {
            UCHAR ImageUsesLargePages : 1;                                    //0x3
            UCHAR IsProtectedProcess : 1;                                     //0x3
            UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
            UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
            UCHAR IsPackagedProcess : 1;                                      //0x3
            UCHAR IsAppContainer : 1;                                         //0x3
            UCHAR IsProtectedProcessLight : 1;                                //0x3
            UCHAR IsLongPathAwareProcess : 1;                                 //0x3
        };
    };
    UCHAR Padding0[4];                                                      //0x4
    VOID* Mutant;                                                           //0x8
    VOID* ImageBaseAddress;                                                 //0x10
    struct _PEB_LDR_DATA* Ldr;                                              //0x18
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 //0x20
    VOID* SubSystemData;                                                    //0x28
    VOID* ProcessHeap;                                                      //0x30
    struct _RTL_CRITICAL_SECTION* FastPebLock;                              //0x38
    union _SLIST_HEADER* volatile AtlThunkSListPtr;                         //0x40
    VOID* IFEOKey;                                                          //0x48
    union
    {
        ULONG CrossProcessFlags;                                            //0x50
        struct
        {
            ULONG ProcessInJob : 1;                                           //0x50
            ULONG ProcessInitializing : 1;                                    //0x50
            ULONG ProcessUsingVEH : 1;                                        //0x50
            ULONG ProcessUsingVCH : 1;                                        //0x50
            ULONG ProcessUsingFTH : 1;                                        //0x50
            ULONG ProcessPreviouslyThrottled : 1;                             //0x50
            ULONG ProcessCurrentlyThrottled : 1;                              //0x50
            ULONG ProcessImagesHotPatched : 1;                                //0x50
            ULONG ReservedBits0 : 24;                                         //0x50
        };
    };
    UCHAR Padding1[4];                                                      //0x54
    union
    {
        VOID* KernelCallbackTable;                                          //0x58
        VOID* UserSharedInfoPtr;                                            //0x58
    };
    ULONG SystemReserved;                                                   //0x60
    ULONG AtlThunkSListPtr32;                                               //0x64
    VOID* ApiSetMap;                                                        //0x68
    ULONG TlsExpansionCounter;                                              //0x70
    UCHAR Padding2[4];                                                      //0x74
    VOID* TlsBitmap;                                                        //0x78
    ULONG TlsBitmapBits[2];                                                 //0x80
    VOID* ReadOnlySharedMemoryBase;                                         //0x88
    VOID* SharedData;                                                       //0x90
    VOID** ReadOnlyStaticServerData;                                        //0x98
    VOID* AnsiCodePageData;                                                 //0xa0
    VOID* OemCodePageData;                                                  //0xa8
    VOID* UnicodeCaseTableData;                                             //0xb0
    ULONG NumberOfProcessors;                                               //0xb8
    ULONG NtGlobalFlag;                                                     //0xbc
    union _LARGE_INTEGER CriticalSectionTimeout;                            //0xc0
    ULONGLONG HeapSegmentReserve;                                           //0xc8
    ULONGLONG HeapSegmentCommit;                                            //0xd0
    ULONGLONG HeapDeCommitTotalFreeThreshold;                               //0xd8
    ULONGLONG HeapDeCommitFreeBlockThreshold;                               //0xe0
    ULONG NumberOfHeaps;                                                    //0xe8
    ULONG MaximumNumberOfHeaps;                                             //0xec
    VOID** ProcessHeaps;                                                    //0xf0
    VOID* GdiSharedHandleTable;                                             //0xf8
    VOID* ProcessStarterHelper;                                             //0x100
    ULONG GdiDCAttributeList;                                               //0x108
    UCHAR Padding3[4];                                                      //0x10c
    struct _RTL_CRITICAL_SECTION* LoaderLock;                               //0x110
    ULONG OSMajorVersion;                                                   //0x118
    ULONG OSMinorVersion;                                                   //0x11c
    USHORT OSBuildNumber;                                                   //0x120
    USHORT OSCSDVersion;                                                    //0x122
    ULONG OSPlatformId;                                                     //0x124
    ULONG ImageSubsystem;                                                   //0x128
    ULONG ImageSubsystemMajorVersion;                                       //0x12c
    ULONG ImageSubsystemMinorVersion;                                       //0x130
    UCHAR Padding4[4];                                                      //0x134
    ULONGLONG ActiveProcessAffinityMask;                                    //0x138
    ULONG GdiHandleBuffer[60];                                              //0x140
    VOID(*PostProcessInitRoutine)();                                       //0x230
    VOID* TlsExpansionBitmap;                                               //0x238
    ULONG TlsExpansionBitmapBits[32];                                       //0x240
    ULONG SessionId;                                                        //0x2c0
    UCHAR Padding5[4];                                                      //0x2c4
    union _ULARGE_INTEGER AppCompatFlags;                                   //0x2c8
    union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x2d0
    VOID* pShimData;                                                        //0x2d8
    VOID* AppCompatInfo;                                                    //0x2e0
    struct _UNICODE_STRING CSDVersion;                                      //0x2e8
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 //0x2f8
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                //0x300
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    //0x308
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 //0x310
    ULONGLONG MinimumStackCommit;                                           //0x318
    VOID* SparePointers[4];                                                 //0x320
    ULONG SpareUlongs[5];                                                   //0x340
    VOID* WerRegistrationData;                                              //0x358
    VOID* WerShipAssertPtr;                                                 //0x360
    VOID* pUnused;                                                          //0x368
    VOID* pImageHeaderHash;                                                 //0x370
    union
    {
        ULONG TracingFlags;                                                 //0x378
        struct
        {
            ULONG HeapTracingEnabled : 1;                                     //0x378
            ULONG CritSecTracingEnabled : 1;                                  //0x378
            ULONG LibLoaderTracingEnabled : 1;                                //0x378
            ULONG SpareTracingBits : 29;                                      //0x378
        };
    };
    UCHAR Padding6[4];                                                      //0x37c
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x380
    ULONGLONG TppWorkerpListLock;                                           //0x388
    struct _LIST_ENTRY TppWorkerpList;                                      //0x390
    VOID* WaitOnAddressHashTable[128];                                      //0x3a0
    VOID* TelemetryCoverageHeader;                                          //0x7a0
    ULONG CloudFileFlags;                                                   //0x7a8
    ULONG CloudFileDiagFlags;                                               //0x7ac
    CHAR PlaceholderCompatibilityMode;                                      //0x7b0
    CHAR PlaceholderCompatibilityModeReserved[7];                           //0x7b1
    struct _LEAP_SECOND_DATA* LeapSecondData;                               //0x7b8
    union
    {
        ULONG LeapSecondFlags;                                              //0x7c0
        struct
        {
            ULONG SixtySecondEnabled : 1;                                     //0x7c0
            ULONG Reserved : 31;                                              //0x7c0
        };
    };
    ULONG NtGlobalFlag2;                                                    //0x7c4
};

#pragma warning(pop)

```

`kernel/src/structures/kaffinity_ex.h`:

```h
#pragma once
#include <ntdef.h>

//0xa8 bytes (sizeof)
struct _KAFFINITY_EX
{
    USHORT Count;                                                           //0x0
    USHORT Size;                                                            //0x2
    ULONG Reserved;                                                         //0x4
    ULONGLONG Bitmap[20];                                                   //0x8
};

```

`kernel/src/structures/kldr_data_table_entry.h`:

```h
#pragma once
#include <ntdef.h>

//0xa0 bytes (sizeof)
struct _KLDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    VOID* ExceptionTable;                                                   //0x10
    ULONG ExceptionTableSize;                                               //0x18
    VOID* GpValue;                                                          //0x20
    struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;                        //0x28
    VOID* DllBase;                                                          //0x30
    VOID* EntryPoint;                                                       //0x38
    ULONG SizeOfImage;                                                      //0x40
    struct _UNICODE_STRING FullDllName;                                     //0x48
    struct _UNICODE_STRING BaseDllName;                                     //0x58
    ULONG Flags;                                                            //0x68
    USHORT LoadCount;                                                       //0x6c
    union
    {
        USHORT SignatureLevel : 4;                                            //0x6e
        USHORT SignatureType : 3;                                             //0x6e
        USHORT Unused : 9;                                                    //0x6e
        USHORT EntireField;                                                 //0x6e
    } u1;                                                                   //0x6e
    VOID* SectionPointer;                                                   //0x70
    ULONG CheckSum;                                                         //0x78
    ULONG CoverageSectionSize;                                              //0x7c
    VOID* CoverageSection;                                                  //0x80
    VOID* LoadedImports;                                                    //0x88
    VOID* Spare;                                                            //0x90
    ULONG SizeOfImageNotRounded;                                            //0x98
    ULONG TimeDateStamp;                                                    //0x9c
};

```

`kernel/src/structures/ldr_data_table_entry.h`:

```h
#pragma once
#include <ntdef.h>
#include "ldr_dll_load_reason.h"

#pragma warning(push)
#pragma warning(disable: 4201)

//0x120 bytes (sizeof)
struct _LDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
    struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
    VOID* DllBase;                                                          //0x30
    VOID* EntryPoint;                                                       //0x38
    ULONG SizeOfImage;                                                      //0x40
    struct _UNICODE_STRING FullDllName;                                     //0x48
    struct _UNICODE_STRING BaseDllName;                                     //0x58
    union
    {
        UCHAR FlagGroup[4];                                                 //0x68
        ULONG Flags;                                                        //0x68
        struct
        {
            ULONG PackagedBinary : 1;                                         //0x68
            ULONG MarkedForRemoval : 1;                                       //0x68
            ULONG ImageDll : 1;                                               //0x68
            ULONG LoadNotificationsSent : 1;                                  //0x68
            ULONG TelemetryEntryProcessed : 1;                                //0x68
            ULONG ProcessStaticImport : 1;                                    //0x68
            ULONG InLegacyLists : 1;                                          //0x68
            ULONG InIndexes : 1;                                              //0x68
            ULONG ShimDll : 1;                                                //0x68
            ULONG InExceptionTable : 1;                                       //0x68
            ULONG ReservedFlags1 : 2;                                         //0x68
            ULONG LoadInProgress : 1;                                         //0x68
            ULONG LoadConfigProcessed : 1;                                    //0x68
            ULONG EntryProcessed : 1;                                         //0x68
            ULONG ProtectDelayLoad : 1;                                       //0x68
            ULONG ReservedFlags3 : 2;                                         //0x68
            ULONG DontCallForThreads : 1;                                     //0x68
            ULONG ProcessAttachCalled : 1;                                    //0x68
            ULONG ProcessAttachFailed : 1;                                    //0x68
            ULONG CorDeferredValidate : 1;                                    //0x68
            ULONG CorImage : 1;                                               //0x68
            ULONG DontRelocate : 1;                                           //0x68
            ULONG CorILOnly : 1;                                              //0x68
            ULONG ChpeImage : 1;                                              //0x68
            ULONG ReservedFlags5 : 2;                                         //0x68
            ULONG Redirected : 1;                                             //0x68
            ULONG ReservedFlags6 : 2;                                         //0x68
            ULONG CompatDatabaseProcessed : 1;                                //0x68
        };
    };
    USHORT ObsoleteLoadCount;                                               //0x6c
    USHORT TlsIndex;                                                        //0x6e
    struct _LIST_ENTRY HashLinks;                                           //0x70
    ULONG TimeDateStamp;                                                    //0x80
    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                //0x88
    VOID* Lock;                                                             //0x90
    struct _LDR_DDAG_NODE* DdagNode;                                        //0x98
    struct _LIST_ENTRY NodeModuleLink;                                      //0xa0
    struct _LDRP_LOAD_CONTEXT* LoadContext;                                 //0xb0
    VOID* ParentDllBase;                                                    //0xb8
    VOID* SwitchBackContext;                                                //0xc0
    struct _RTL_BALANCED_NODE BaseAddressIndexNode;                         //0xc8
    struct _RTL_BALANCED_NODE MappingInfoIndexNode;                         //0xe0
    ULONGLONG OriginalBase;                                                 //0xf8
    union _LARGE_INTEGER LoadTime;                                          //0x100
    ULONG BaseNameHashValue;                                                //0x108
    enum _LDR_DLL_LOAD_REASON LoadReason;                                   //0x10c
    ULONG ImplicitPathOptions;                                              //0x110
    ULONG ReferenceCount;                                                   //0x114
    ULONG DependentLoadFlags;                                               //0x118
    UCHAR SigningLevel;                                                     //0x11c

    // on windows 11, we have these next fields:
    //ULONG CheckSum;                                                         //0x120
    //VOID* ActivePatchImageBase;                                             //0x128
    //enum _LDR_HOT_PATCH_STATE HotPatchState;                                //0x130
};

#pragma warning(pop)

```

`kernel/src/structures/ldr_dll_load_reason.h`:

```h
#pragma once

//0x4 bytes (sizeof)
enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency = 0,
    LoadReasonStaticForwarderDependency = 1,
    LoadReasonDynamicForwarderDependency = 2,
    LoadReasonDelayloadDependency = 3,
    LoadReasonDynamicLoad = 4,
    LoadReasonAsImageLoad = 5,
    LoadReasonAsDataLoad = 6,
    LoadReasonEnclavePrimary = 7,
    LoadReasonEnclaveDependency = 8,
    LoadReasonPatchImage = 9,
    LoadReasonUnknown = -1
};

```

`kernel/src/structures/machine_frame.h`:

```h
#pragma once
#include <communication_types.h>

struct s_machine_frame
{
	uint64_t rip;
	uint64_t cs;
	uint64_t rflags;
	uint64_t rsp;
	uint64_t ss;
};
```

`kernel/src/structures/peb_ldr_data.h`:

```h
#pragma once
#include <ntdef.h>

//0x58 bytes (sizeof)
struct _PEB_LDR_DATA
{
    ULONG Length;                                                           //0x0
    UCHAR Initialized;                                                      //0x4
    VOID* SsHandle;                                                         //0x8
    struct _LIST_ENTRY InLoadOrderModuleList;                               //0x10
    struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x20
    struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x30
    VOID* EntryInProgress;                                                  //0x40
    UCHAR ShutdownInProgress;                                               //0x48
    VOID* ShutdownThreadId;                                                 //0x50
};

```

`kernel/src/structures/virtual_address.h`:

```h
#pragma once
#include <generic_types.h>

#pragma warning(push)
#pragma warning(disable: 4201)

union s_virtual_address
{
    uint64_t address;

    struct
    {
        uint64_t offset : 12;
        uint64_t pt_idx : 9;
        uint64_t pd_idx : 9;
        uint64_t pdpt_idx : 9;
        uint64_t pml4_idx : 9;
        uint64_t reserved : 16; // could add support for 5 level paging in future
    };
};

#pragma warning(pop)

```

`protected-process/darken-anticheat-protected-process.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{883e7fcb-4c56-455e-8e43-1a8c408f0e49}</ProjectGuid>
    <RootNamespace>darkenanticheatprotectedprocess</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`protected-process/darken-anticheat-protected-process.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`protected-process/src/main.cpp`:

```cpp
#include <iostream>

int main()
{
	std::cout << "[darken-anticheat] - started sample protected process.\n";

	system("pause");

	return 0;
}

```

`user-process/darken-anticheat-user-process.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b7f6045d-9539-42c1-90ad-0876124e489d}</ProjectGuid>
    <RootNamespace>darkenanticheatuser</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)user-shared;$(SolutionDir)global-shared;$(IncludePath)</IncludePath>
    <SourcePath>$(SourcePath)</SourcePath>
    <PublicModuleDirectories>$(PublicModuleDirectories)</PublicModuleDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(SolutionDir)user-shared;$(SolutionDir)global-shared;$(IncludePath)</IncludePath>
    <SourcePath>$(SourcePath)</SourcePath>
    <PublicModuleDirectories>$(PublicModuleDirectories)</PublicModuleDirectories>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_DARKEN_USER_PROCESS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>wintrust.lib;ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_DARKEN_USER_PROCESS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>wintrust.lib;ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\user-shared\detections\anti_debug\anti_debug.cpp" />
    <ClCompile Include="..\user-shared\detections\hypervisor\hypervisor.cpp" />
    <ClCompile Include="..\user-shared\detections\modules\modules.cpp" />
    <ClCompile Include="..\user-shared\detections\patchguard\patchguard.cpp" />
    <ClCompile Include="..\user-shared\detections\process\process.cpp" />
    <ClCompile Include="..\user-shared\detections\threads\threads.cpp" />
    <ClCompile Include="..\user-shared\driver\driver.cpp" />
    <ClCompile Include="..\user-shared\utilities\datatype\datatype.cpp" />
    <ClCompile Include="..\user-shared\utilities\filesystem\filesystem.cpp" />
    <ClCompile Include="..\user-shared\utilities\pe\pe.cpp" />
    <ClCompile Include="..\user-shared\utilities\system\system.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\protected_process\protected_process.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\log\log.h" />
    <ClInclude Include="src\protected_process\protected_process.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`user-process/darken-anticheat-user-process.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\anti_debug\anti_debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\modules\modules.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\utilities\pe\pe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\utilities\datatype\datatype.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\utilities\filesystem\filesystem.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\protected_process\protected_process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\driver\driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\threads\threads.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\patchguard\patchguard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\process\process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\detections\hypervisor\hypervisor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\user-shared\utilities\system\system.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\log\log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\protected_process\protected_process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`user-process/src/main.cpp`:

```cpp
#include <driver/driver.h>
#include <detections/detections.h>
#include "protected_process/protected_process.h"

#include <Windows.h>

#include <thread>
#include <chrono>
#include <iostream>

int main()
{
	std::cout << "[darken-anticheat] started usermode process of anticheat.\n";

	if (driver::load() == false)
	{
		std::cout << "[darken-anticheat] unable to load driver.\n";

		return false;
	}

	std::cout << "[darken-anticheat] loaded driver successfully.\n";

	if (protected_process::load() == false)
	{
		std::cout << "[darken-anticheat] unable to load protected process.\n";

		return false;
	}

	std::cout << "[darken-anticheat] loaded protected process successfully.\n";

	while (true)
	{
		d_check_detection(detections::anti_debug::is_peb_debug_flag_present);
		d_check_detection(detections::modules::local_process::is_unsigned_module_present);
		d_check_detection(detections::modules::kernel::is_unsigned_module_present);
		d_check_detection(detections::modules::kernel::validate_ntoskrnl_integrity);
		d_check_detection(detections::modules::kernel::validate_kernel_drivers_integrity);
		d_check_detection(detections::modules::kernel::is_any_driver_data_section_executable);
		d_check_detection(detections::threads::is_suspicious_system_thread_present);
		d_check_detection(detections::threads::non_maskable_interrupts::send_and_analyze);
		d_check_detection(detections::process::is_suspicious_thread_present, static_cast<std::uint64_t>(GetCurrentProcessId()));
		d_check_detection(detections::process::is_suspicious_thread_present, protected_process::process_id);
		d_check_detection(detections::hypervisor::check_reserved_msr_usage);

		// if patchguard checks are being violated or if patchguard context not present
		// then uncommenting next line will cause a system crash
		//d_check_detection(detections::patchguard::trigger_bugcheck);

		std::this_thread::sleep_for(std::chrono::milliseconds(250));
	}

	driver::unload();

	return 0;
}

```

`user-process/src/protected_process/protected_process.cpp`:

```cpp
#include "protected_process.h"
#include <driver/driver.h>

#include <Windows.h>
#include <string>

#define d_protected_process_file_name "darken-anticheat-protected-process.exe"

bool protected_process::load()
{
    PROCESS_INFORMATION process_information = { };
    STARTUPINFO startup_info = { };

    startup_info.cb = sizeof(STARTUPINFO);

    std::string current_executable_path(MAX_PATH, '\0');
    GetModuleFileNameA(nullptr, current_executable_path.data(), MAX_PATH);

    std::string current_directory = current_executable_path.substr(0, current_executable_path.find_last_of('\\'));

    std::string protected_process_path = current_directory + '\\' + d_protected_process_file_name;

    if (CreateProcessA(protected_process_path.c_str(), nullptr, nullptr, nullptr, false, CREATE_NEW_CONSOLE, nullptr, nullptr, &startup_info, &process_information))
    {
        CloseHandle(process_information.hProcess);
        CloseHandle(process_information.hThread);

        communication::s_call_info call_info = { };

        call_info.protected_processes.anticheat_usermode_id = static_cast<std::uint64_t>(GetCurrentProcessId());
        call_info.protected_processes.protected_process_id = static_cast<std::uint64_t>(process_information.dwProcessId);

        process_id = call_info.protected_processes.protected_process_id;

        return driver::send_call(communication::e_control_code::initialise_protected_processes, call_info).detection_status == communication::e_detection_status::clean;
    }

    return false;
}

```

`user-process/src/protected_process/protected_process.h`:

```h
#pragma once
#include <cstdint>

namespace protected_process
{
	bool load();

	inline std::uint64_t process_id = 0;
}

```

`user-process/vcpkg.json`:

```json
{
  "dependencies": [
    "boost-beast"
  ]
}
```

`user-shared/detections/anti_debug/anti_debug.cpp`:

```cpp
#include "anti_debug.h"
#include <Windows.h>
#include <winternl.h>

communication::e_detection_status detections::anti_debug::is_peb_debug_flag_present()
{
	PPEB process_peb = reinterpret_cast<PPEB>(__readgsqword(0x60));

	return process_peb->BeingDebugged == 1 ? communication::e_detection_status::flagged : communication::e_detection_status::clean;
}

```

`user-shared/detections/anti_debug/anti_debug.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace anti_debug
	{
		communication::e_detection_status is_peb_debug_flag_present();
	}
}

```

`user-shared/detections/detections.h`:

```h
#pragma once

#ifndef _detections_include_guard
#define _detections_include_guard
#include "anti_debug/anti_debug.h"
#include "patchguard/patchguard.h"
#include "hypervisor/hypervisor.h"
#include "process/process.h"
#include "threads/threads.h"
#include "modules/modules.h"
#endif

#ifndef d_check_detection
// will add 'release' version later which will contain a way to broadcast to server
#define d_check_detection(function, ...)\
	{ communication::e_detection_status detection_status = function(__VA_ARGS__);\
	if (detection_status == communication::e_detection_status::flagged)\
	{\
		std::cout << "[darken-anticheat] flagged: '" << #function << "'.\n";\
	}\
	else if (detection_status == communication::e_detection_status::runtime_error)\
	{\
		std::cout << "[darken-anticheat] runtime error at function: '" << #function << "'.\n";\
	}}
#endif

```

`user-shared/detections/hypervisor/hypervisor.cpp`:

```cpp
#include "hypervisor.h"
#include <driver/driver.h>

communication::e_detection_status detections::hypervisor::check_reserved_msr_usage()
{
    return driver::send_call(communication::e_control_code::check_reserved_msr_usage, { }).detection_status;
}

```

`user-shared/detections/hypervisor/hypervisor.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace hypervisor
	{
		communication::e_detection_status check_reserved_msr_usage();
	}
}
```

`user-shared/detections/modules/modules.cpp`:

```cpp
#include "modules.h"
#include <driver/driver.h>
#include <utilities/pe/pe.h>
#include <utilities/system/system.h>
#include <utilities/datatype/datatype.h>

#include <Windows.h>
#include <winternl.h>

#include <filesystem>
#include <vector>

namespace detections
{
	namespace modules
	{
		namespace local_process
		{
			std::vector<std::wstring> modules_checked_already = { };
		}

		namespace kernel
		{
			std::vector<std::string> modules_checked_already = { };
		}
	}
}

// todo: check for 'expected' modules to see if list has been tampered with
communication::e_detection_status detections::modules::local_process::is_unsigned_module_present()
{
	PPEB process_peb = reinterpret_cast<PPEB>(__readgsqword(0x60));

	LIST_ENTRY peb_ldr_data = process_peb->Ldr->InMemoryOrderModuleList;

	// start AFTER the first entry (the process executable itself) as it may not be signed.
	// if you get a certificate going for the protected process / user process feel free to monitor the process executable too
	for (PLIST_ENTRY current_module = peb_ldr_data.Flink->Flink; current_module->Blink != peb_ldr_data.Blink; current_module = current_module->Flink)
	{
		PLDR_DATA_TABLE_ENTRY module_entry = CONTAINING_RECORD(current_module, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

		std::wstring module_path = std::wstring(module_entry->FullDllName.Buffer, module_entry->FullDllName.Length / 2);

		if (std::find(modules_checked_already.begin(), modules_checked_already.end(), module_path) != modules_checked_already.end())
		{
			continue;
		}

		if (utilities::pe::is_digitally_signed(module_path) == false)
		{
			return communication::e_detection_status::flagged;
		}

		modules_checked_already.push_back(module_path);
	}

	return communication::e_detection_status::clean;
}

communication::e_detection_status detections::modules::kernel::is_unsigned_module_present()
{
	std::vector<std::string> loaded_kernel_modules = utilities::system::query_loaded_kernel_modules();

	if (loaded_kernel_modules.empty() == true)
	{
		return communication::e_detection_status::runtime_error;
	}

	for (std::string& module_path : loaded_kernel_modules)
	{
		if (std::find(modules_checked_already.begin(), modules_checked_already.end(), module_path) != modules_checked_already.end())
		{
			continue;
		}

		// todo: exclude the anticheat driver

		// check if it exists due to dump drivers sometimes not being on disk
		// todo: find a better way to identify dump drivers
		if (std::filesystem::exists(module_path) == true && utilities::pe::is_digitally_signed(utilities::datatype::ascii_string::to_unicode(module_path)) == false)
		{
			return communication::e_detection_status::flagged;
		}

		modules_checked_already.push_back(module_path);
	}


	return communication::e_detection_status::clean;
}

communication::e_detection_status detections::modules::kernel::validate_ntoskrnl_integrity()
{
	return driver::send_call(communication::e_control_code::validate_ntoskrnl_integrity, { }).detection_status;
}

communication::e_detection_status detections::modules::kernel::validate_kernel_drivers_integrity()
{
	return driver::send_call(communication::e_control_code::validate_kernel_drivers_integrity, { }).detection_status;
}

communication::e_detection_status detections::modules::kernel::is_any_driver_data_section_executable()
{
	return driver::send_call(communication::e_control_code::is_any_driver_data_section_executable, { }).detection_status;
}

```

`user-shared/detections/modules/modules.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace modules
	{
		namespace local_process
		{
			communication::e_detection_status is_unsigned_module_present();
		}

		namespace kernel
		{
			communication::e_detection_status is_unsigned_module_present();
			communication::e_detection_status validate_ntoskrnl_integrity();
			communication::e_detection_status validate_kernel_drivers_integrity();
			communication::e_detection_status is_any_driver_data_section_executable();
		}
	}
}

```

`user-shared/detections/patchguard/patchguard.cpp`:

```cpp
#include "patchguard.h"
#include <driver/driver.h>

communication::e_detection_status detections::patchguard::trigger_bugcheck()
{
    return driver::send_call(communication::e_control_code::trigger_patchguard_bugcheck, { }).detection_status;
}

```

`user-shared/detections/patchguard/patchguard.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace patchguard
	{
		// should always return clean, if not, then means that io request was tampered or intercepted
		communication::e_detection_status trigger_bugcheck();
	}
}
```

`user-shared/detections/process/process.cpp`:

```cpp
#include "process.h"
#include <driver/driver.h>

communication::e_detection_status detections::process::is_suspicious_thread_present(std::uint64_t process_id)
{
    communication::s_call_info call_info = { };

    call_info.is_suspicious_process_thread_present.process_id = process_id;

    return driver::send_call(communication::e_control_code::is_suspicious_process_thread_present, call_info).detection_status;
}

```

`user-shared/detections/process/process.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace process
	{
		communication::e_detection_status is_suspicious_thread_present(std::uint64_t process_id);
	}
}

```

`user-shared/detections/threads/threads.cpp`:

```cpp
#include "threads.h"
#include <driver/driver.h>

communication::e_detection_status detections::threads::is_suspicious_system_thread_present()
{
    return driver::send_call(communication::e_control_code::is_suspicious_system_thread_present, { }).detection_status;
}

communication::e_detection_status detections::threads::non_maskable_interrupts::send_and_analyze()
{
    return driver::send_call(communication::e_control_code::send_and_analyze_non_maskable_interrupts, { }).detection_status;
}


```

`user-shared/detections/threads/threads.h`:

```h
#pragma once
#include <communication_types.h>

namespace detections
{
	namespace threads
	{
		communication::e_detection_status is_suspicious_system_thread_present();

		namespace non_maskable_interrupts
		{
			communication::e_detection_status send_and_analyze();
		}
	}
}
```

`user-shared/driver/driver.cpp`:

```cpp
#include "driver.h"
#include <Windows.h>

namespace driver
{
	void* device_handle = nullptr;
}

bool driver::load()
{
	device_handle = CreateFileA("\\\\.\\darken-ac", GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE, 0UL, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);

	return device_handle != nullptr && device_handle != INVALID_HANDLE_VALUE;
}

void driver::unload()
{
	if (device_handle != nullptr && device_handle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(device_handle);

		device_handle = nullptr;
	}
}

communication::s_call_info driver::send_call(communication::e_control_code control_code, communication::s_call_info call_info)
{
	if (device_handle == nullptr || device_handle == INVALID_HANDLE_VALUE)
	{
		return { };
	}

	if (DeviceIoControl(device_handle, CTL_CODE(FILE_DEVICE_UNKNOWN, control_code, METHOD_BUFFERED, FILE_SPECIAL_ACCESS), &call_info, sizeof(communication::s_call_info), &call_info, sizeof(communication::s_call_info), nullptr, nullptr) == 0)
	{
		return { };
	}

	return call_info;
}

```

`user-shared/driver/driver.h`:

```h
#pragma once
#include <communication_types.h>

namespace driver
{
	bool load();
	void unload();

	communication::s_call_info send_call(communication::e_control_code control_code, communication::s_call_info);
}

```

`user-shared/imports.h`:

```h
#pragma once

#define d_import(function) function

```

`user-shared/utilities/datatype/datatype.cpp`:

```cpp
#include "datatype.h"
#include <imports.h>
#include <Windows.h>
#include <iomanip>
#include <sstream>

std::string utilities::datatype::guid::to_string(GUID guid)
{
    std::ostringstream string_stream = { };

    string_stream << std::hex << std::uppercase << std::setfill('0');
    string_stream << std::setw(8) << guid.Data1;
    string_stream << std::setw(4) << guid.Data2;
    string_stream << std::setw(4) << guid.Data3;

    for (int i = 0; i < 8; i++)
    {
        string_stream << std::setw(2) << static_cast<int>(guid.Data4[i]);
    }

    return string_stream.str();
}

std::string utilities::datatype::uint32::to_hexadecimal_string(std::uint32_t integral_number)
{
    std::ostringstream string_stream = { };

    string_stream << std::setw(1) << std::hex << integral_number;

    return string_stream.str();
}

std::wstring utilities::datatype::ascii_string::to_unicode(std::string_view string_to_convert)
{
    int32_t source_length = static_cast<int32_t>(string_to_convert.length());

    int32_t character_count = d_import(MultiByteToWideChar)(CP_ACP, 0, string_to_convert.data(), source_length, nullptr, 0);

    std::wstring unicode_string(character_count, L'\0');

    d_import(MultiByteToWideChar)(CP_ACP, 0, string_to_convert.data(), source_length, unicode_string.data(), character_count);

    return unicode_string;
}

```

`user-shared/utilities/datatype/datatype.h`:

```h
#pragma once
#include <string>
#include <guiddef.h>

namespace utilities
{
	namespace datatype
	{
		namespace guid
		{
			std::string to_string(GUID guid);
		}

		namespace uint32
		{
			std::string to_hexadecimal_string(std::uint32_t integral_number);
		}

		namespace ascii_string
		{
			std::wstring to_unicode(std::string_view string_to_convert);
		}
	}
}

```

`user-shared/utilities/filesystem/filesystem.cpp`:

```cpp
#include "filesystem.h"
#include <filesystem>
#include <fstream>

std::vector<std::uint8_t> utilities::filesystem::read_file(std::wstring_view path)
{
	std::ifstream file(path.data(), std::ios::binary);

	if (file.is_open() == false)
	{
		return { };
	}

	return std::vector<std::uint8_t>(std::istreambuf_iterator<char>(file), { });
}

```

`user-shared/utilities/filesystem/filesystem.h`:

```h
#pragma once
#include <string>
#include <vector>

namespace utilities
{
	namespace filesystem
	{
		std::vector<std::uint8_t> read_file(std::wstring_view path);
	}
}

```

`user-shared/utilities/pe/pe.cpp`:

```cpp
#include "pe.h"
#include "../filesystem/filesystem.h"
#include <imports.h>

#include <Windows.h>
#include <Softpub.h>
#include <mscat.h>
#include <wintrust.h>

struct s_catalog_and_hash_info
{
	std::wstring catalog_path;
	std::vector<uint8_t> hash;
};

s_catalog_and_hash_info get_catalog_and_hash_info(HANDLE file_handle);

bool win_verify_trust(uint32_t trust_info_choice, void* trust_info_data);

bool utilities::pe::has_embedded_signature(std::wstring_view binary_path)
{
	WINTRUST_FILE_INFO file_info = { };

	file_info.cbStruct = sizeof(WINTRUST_FILE_INFO);
	file_info.pcwszFilePath = binary_path.data();
	file_info.hFile = nullptr;
	file_info.pgKnownSubject = nullptr;

	return win_verify_trust(WTD_CHOICE_FILE, &file_info);
}

bool utilities::pe::has_catalog_signature(std::wstring_view binary_path)
{
	HANDLE file_handle = d_import(CreateFileW)(binary_path.data(), FILE_GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

	if (file_handle == nullptr || file_handle == INVALID_HANDLE_VALUE)
	{
		return false;
	}

	s_catalog_and_hash_info catalog_and_hash_info = get_catalog_and_hash_info(file_handle);

	if (catalog_and_hash_info.catalog_path.empty() == true || catalog_and_hash_info.hash.empty() == true)
	{
		d_import(CloseHandle)(file_handle);

		return false;
	}

	WINTRUST_CATALOG_INFO wintrust_catalog_info = { };

	wintrust_catalog_info.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
	wintrust_catalog_info.pcwszCatalogFilePath = catalog_and_hash_info.catalog_path.data();
	wintrust_catalog_info.pcwszMemberFilePath = binary_path.data();
	wintrust_catalog_info.hMemberFile = file_handle;
	wintrust_catalog_info.pbCalculatedFileHash = catalog_and_hash_info.hash.data();
	wintrust_catalog_info.cbCalculatedFileHash = static_cast<uint32_t>(catalog_and_hash_info.hash.size());

	bool is_digitally_signed = win_verify_trust(WTD_CHOICE_CATALOG, &wintrust_catalog_info);

	d_import(CloseHandle)(file_handle);

	return is_digitally_signed;
}

bool utilities::pe::is_digitally_signed(std::wstring_view binary_path)
{
	return has_embedded_signature(binary_path) || has_catalog_signature(binary_path);
}

s_catalog_and_hash_info get_catalog_and_hash_info(HANDLE file_handle)
{
	uint32_t hash_length = 0;

	if (d_import(CryptCATAdminCalcHashFromFileHandle)(file_handle, reinterpret_cast<DWORD*>(&hash_length), nullptr, 0) == 0)
	{
		return { };
	}

	std::vector<uint8_t> hash_data(hash_length);

	if (d_import(CryptCATAdminCalcHashFromFileHandle)(file_handle, reinterpret_cast<DWORD*>(&hash_length), hash_data.data(), 0) == 0)
	{
		return { };
	}

	HCATADMIN catalog_admin_handle = nullptr;

	if (d_import(CryptCATAdminAcquireContext)(&catalog_admin_handle, nullptr, 0) == 0)
	{
		return { };
	}

	HCATINFO catalog_info_handle = d_import(CryptCATAdminEnumCatalogFromHash)(catalog_admin_handle, hash_data.data(), hash_length, 0, nullptr);

	if (catalog_info_handle == nullptr || catalog_info_handle == INVALID_HANDLE_VALUE)
	{
		d_import(CryptCATAdminReleaseContext)(catalog_admin_handle, 0);

		return { };
	}

	CATALOG_INFO catalog_info = { };

	catalog_info.cbStruct = sizeof(CATALOG_INFO);

	if (d_import(CryptCATCatalogInfoFromContext)(catalog_info_handle, &catalog_info, 0) == 0)
	{
		d_import(CryptCATAdminReleaseCatalogContext)(catalog_admin_handle, catalog_info_handle, 0);
		d_import(CryptCATAdminReleaseContext)(catalog_admin_handle, 0);

		return { };
	}

	std::wstring catalog_file_path = catalog_info.wszCatalogFile;

	d_import(CryptCATAdminReleaseCatalogContext)(catalog_admin_handle, catalog_info_handle, 0);
	d_import(CryptCATAdminReleaseContext)(catalog_admin_handle, 0);

	return { catalog_file_path, hash_data };
}

bool win_verify_trust(uint32_t trust_info_choice, void* trust_info_data)
{
	WINTRUST_DATA win_trust_data = { };

	win_trust_data.cbStruct = sizeof(win_trust_data);
	win_trust_data.dwUIChoice = WTD_UI_NONE;
	win_trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
	win_trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
	win_trust_data.dwUnionChoice = trust_info_choice;
	win_trust_data.dwStateAction = WTD_STATEACTION_VERIFY;
	win_trust_data.pFile = reinterpret_cast<WINTRUST_FILE_INFO*>(trust_info_data); // (file, catalog, cert, etc) infos pointers are all within a union, so this is ambiguous

	GUID wvt_policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	bool is_digitally_signed = d_import(WinVerifyTrust)(nullptr, &wvt_policy_guid, &win_trust_data) == ERROR_SUCCESS;

	win_trust_data.dwStateAction = WTD_STATEACTION_CLOSE;

	d_import(WinVerifyTrust)(nullptr, &wvt_policy_guid, &win_trust_data);

	return is_digitally_signed;
}

```

`user-shared/utilities/pe/pe.h`:

```h
#pragma once
#include <string>

namespace utilities
{
	namespace pe
	{
		bool has_embedded_signature(std::wstring_view binary_path);
		bool has_catalog_signature(std::wstring_view binary_path);

		bool is_digitally_signed(std::wstring_view binary_path);
	}
}

```

`user-shared/utilities/system/system.cpp`:

```cpp
#include "system.h"
#include "system_def.h"
#include <Windows.h>
#include <winternl.h>

#include <utilities/filesystem/filesystem.h>
#include <imports.h>

std::vector<std::string> utilities::system::query_loaded_kernel_modules()
{
	uint32_t information_size = 0;

	constexpr SYSTEM_INFORMATION_CLASS system_information_class = static_cast<SYSTEM_INFORMATION_CLASS>(11);

	d_import(NtQuerySystemInformation)(system_information_class, 0, 0, reinterpret_cast<ULONG*>(&information_size));

	if (information_size == 0)
	{
		return { };
	}

	std::vector<uint8_t> information_buffer(information_size);

	if (NT_SUCCESS(d_import(NtQuerySystemInformation)(system_information_class, information_buffer.data(), information_size, reinterpret_cast<ULONG*>(&information_size))) == false)
	{
		return { };
	}

	s_rtl_process_modules* system_process_modules = reinterpret_cast<s_rtl_process_modules*>(information_buffer.data());

	std::vector<std::string> loaded_modules_list = { };

	for (uint32_t i = 0; i < system_process_modules->module_count; i++)
	{
		std::string module_path = system_process_modules->modules[i].full_path_name;

		loaded_modules_list.push_back(module_path);
	}

	return loaded_modules_list;
}

```

`user-shared/utilities/system/system.h`:

```h
#pragma once
#include <vector>
#include <string>

namespace utilities
{
	namespace system
	{
		std::vector<std::string> query_loaded_kernel_modules();
	}
}

```

`user-shared/utilities/system/system_def.h`:

```h
#pragma once
#include <cstdint>

struct s_rtl_process_module_information
{
	uint64_t section;
	uint64_t mapped_base;
	uint64_t image_base;
	uint32_t image_size;
	uint32_t flags;
	uint16_t load_order_index;
	uint16_t init_order_index;
	uint16_t load_count;
	uint16_t offset_to_file_name;
	char full_path_name[256];
};

struct s_rtl_process_modules
{
	uint32_t module_count;
	s_rtl_process_module_information modules[1];
};

```