Project Path: arc_gmh5225_ow_unpack_gh_7cwwc

Source Tree:

```txt
arc_gmh5225_ow_unpack_gh_7cwwc
├── README.md
└── src
    ├── Decryptor.cpp
    ├── Decryptor.h
    ├── Decryptor_v1.cpp
    ├── Decryptor_v1.h
    ├── Helpers.cpp
    ├── Helpers.h
    ├── Main.cpp
    ├── Main.h
    ├── PE.cpp
    ├── PE.h
    ├── XorTable.cpp
    ├── XorTable.h
    ├── asm_.asm
    └── resource.h

```

`README.md`:

```md
# ow_unpack

reupload of C&D'ed ow_unpack source code

```

`src/Decryptor.cpp`:

```cpp
#include "Main.h"
#include "Decryptor.h"

namespace decryptor
{
	bool DecryptHeader(const std::vector<char>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);
		if (!pNtHeaders)
			return nullptr;

		std::uintptr_t xtable_loc = 0x0;
		if (!LocateXorTable(buffer, xtable_loc))
			return false;

		std::vector<char> xtable;
		if (!DumpXorTable(buffer, xtable, helpers::RVAToFileOffset(pNtHeaders, xtable_loc), 0x1D00))
			return false;

		int index = 0;
		DecryptDword((std::uintptr_t)((BYTE *)pNtHeaders + 0x94), xtable, index);

		DWORD importsRVA_save = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
		PIMAGE_IMPORT_DESCRIPTOR firstImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE *)basePtr + helpers::RVAToFileOffset(pNtHeaders, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size));

		std::size_t importsSize = 0;
		std::uintptr_t pIt = (std::uintptr_t)firstImportDesc;

		do
		{
			DecryptImportDescriptor(pIt, xtable, index);

			BYTE * nameAddr = (BYTE *)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(DWORD *)(pIt + 0xC));
			DecryptString((std::uintptr_t)nameAddr, xtable, index);

			std::uintptr_t importTableAddr = (std::uintptr_t)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(DWORD *)(pIt + 0x0));

			std::uintptr_t pIt2 = importTableAddr;

			do
			{
				DecryptQword(pIt2, xtable, index);

				if (*(DWORD *)(pIt2 + 0x4) >> 31 == 1)
				{
					//*(DWORD *)(pIt2 + 0x4) = (*(DWORD *)(pIt2 + 0x4) << 1) >> 1;
				}
				else
				{
					DecryptImportByName((std::uintptr_t)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(unsigned __int64 *)(pIt2)), xtable, index);
				}

				pIt2 += 0x8;
			} while (*(DWORD *)(pIt2) != 0x0);

			pIt += 0x14;
			importsSize += 0x14;
		} while (*(DWORD *)(pIt) != 0x0);

		pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = importsRVA_save;
		pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = (DWORD)importsSize;
	}

	bool DecryptTextSection(const std::vector<char>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);
		if (!pNtHeaders)
			return nullptr;

		std::uintptr_t xtable_loc = 0x0;
		if (!LocateXorTable(buffer, xtable_loc))
			return false;

		std::vector<char> xtable;
		if (!DumpXorTable(buffer, xtable, helpers::RVAToFileOffset(pNtHeaders, xtable_loc), 0x1D00))
			return false;

		PIMAGE_SECTION_HEADER pTextSec = pe::GetSection(basePtr, 0x000000747865742E/*".text\0\0\0"*/);

		std::uintptr_t va = 0x140000000 + pTextSec->VirtualAddress;
		std::uintptr_t startSec = (std::uintptr_t)basePtr + pTextSec->PointerToRawData; //+ helpers::RVAToFileOffset(pNtHeaders, pTextSec->VirtualAddress);		
		std::uintptr_t sizeSec = pTextSec->SizeOfRawData;
		std::uintptr_t endSec = startSec + sizeSec;

		std::uintptr_t currentPage = startSec;
		std::size_t pageSize = 0x1000;

		pfnSetProgressBarRange(0, 100, 1);

		while (currentPage < endSec)
		{
			//pFunc("Decrypting page 0x" + helpers::ToHexString(va) + "-0x" + helpers::ToHexString(va + pageSize) + " " + std::to_string(std::round(((float)(va - (0x140000000 + pTextSec->VirtualAddress) + pageSize) / (float)(sizeSec)) * 100.0f)) + "%");
			DecryptPage(currentPage, va, xtable, 0x140000000 + pTextSec->VirtualAddress);

			va += pageSize;
			currentPage += pageSize;
			
			pfnProgressProgressBar((float)((float)(currentPage - startSec) / endSec) * 1000);
		}

		return true;
	}

	bool LocateXorTable(const std::vector<char>& buffer, std::uintptr_t& xtable_loc)
	{
		LPVOID ptr = (LPVOID)buffer.data();
		PIMAGE_SECTION_HEADER pDataSec = pe::GetSection(ptr, 0x000000617461642E/*".data\0\0\0"*/);

		if (pDataSec == nullptr)
			return false;

		xtable_loc = pDataSec->VirtualAddress;

		return xtable_loc != 0x0;
	}

	bool DumpXorTable(const std::vector<char>& buffer, std::vector<char>& xtable, std::uintptr_t address, std::size_t size)
	{
		for (std::uintptr_t i = address; i < address + size; i++)
			xtable.emplace_back(buffer[i]);

		return true;
	}

	int ComputeInitialIndex(std::uintptr_t address, std::uintptr_t sectionVA)
	{
		__int64 base = (address - sectionVA);
		__int64 i = ComputeImpl(base);
		return i;
	}

	void DecryptByte(std::uintptr_t address, std::ptrdiff_t offset, const std::vector<char>& xtable, int idx)
	{
		*(char *)(address) = *(char *)(address) ^ xtable[idx + (offset & 0xFF)];
	}

	bool DecryptPage(std::uintptr_t phys_address, std::uintptr_t virt_address, const std::vector<char>& xtable, std::uintptr_t sectionVA)
	{
		std::uintptr_t ptr = phys_address;
		
		int idx = ComputeInitialIndex(virt_address & 0xFFFFFFFFFFFFF000, sectionVA);

		ptr = (ptr /*& 0xFFFFFFFFFFFFF000*/) + 1;
		int count = 0x400;
		int offset = 2;

		do
		{
			ptr += 4;
			DecryptByte(ptr - 5, offset - 2, xtable, idx);
			DecryptByte(ptr - 4, offset - 1, xtable, idx);
			DecryptByte(ptr - 3, offset, xtable, idx);
			int offset2 = offset + 1;
			offset += 4;
			DecryptByte(ptr - 2, offset2, xtable, idx);
			count -= 1;
		} while (count > 0);

		return true;
	}

	void DecryptDword(std::uintptr_t address, const std::vector<char>& xtable, int& idx)
	{
		std::uintptr_t ptr = address;

		do
		{
			ptr += 1;
			int offset = idx & 0xFF;
			idx += 1;
			*(char *)(ptr - 1) = *(char *)(ptr - 1) ^ xtable[offset];
		} while (idx < 4);
	}

	bool DecryptImportDescriptor(std::uintptr_t address, const std::vector<char>& xtable, int& idx)
	{
		int size = 0;
		std::uintptr_t ptr = address;

		do
		{
			ptr += 1;
			int offset = idx & 0xFF;
			size += 1;
			idx += 1;
			*(char *)(ptr - 1) = *(char *)(ptr - 1) ^ xtable[offset];
		} while (size < 0x14);

		return true;
	}

	bool DecryptString(std::uintptr_t address, const std::vector<char>& xtable, int& idx)
	{
		std::uintptr_t ptr = address;

		char first = *(char *)(ptr) ^ xtable[idx & 0xFF];
		*(char *)(ptr) = first;

		char unxored = first;

		if (first == 0x00)
			return false;
		else
		{
			do
			{
				ptr += 1;
				idx += 1;
				unxored = *(char *)(ptr) ^ xtable[idx & 0xFF];
				*(char *)(ptr) = unxored;
			} while (unxored != 0x00);
		}

		return true;
	}

	void DecryptQword(std::uintptr_t address, const std::vector<char>& xtable, int& idx)
	{
		std::uintptr_t ptr = address;
		int count = 0;

		do
		{
			*(char *)(ptr) = *(char *)(ptr) ^ xtable[idx & 0xFF];
			idx += 1;
			ptr += 1;
			count += 1;
		} while (count < 8);
	}

	bool DecryptImportByName(std::uintptr_t address, const std::vector<char>& xtable, int& idx)
	{
		return DecryptString(address + 2, xtable, idx);
	}

	bool RenameFakeTextSection(const std::vector<char>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		PIMAGE_SECTION_HEADER pFakeTextSec = pe::GetSection(basePtr, 0x000C00747865742E/*".text\0\f\0"*/);

		*(unsigned __int64*)pFakeTextSec->Name = 0x0072656b6361702e;

		PIMAGE_SECTION_HEADER pPackerSec = pe::GetSection(basePtr, 0x0072656b6361702e/*".packer\0"*/);

		return pPackerSec != nullptr;
	}

	bool RemoveObfuscationLayer(const std::vector<char>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		static std::vector<std::uint8_t> lpush = { 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 };
		static std::vector<std::uint8_t> lop = { 0xc8, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe5, 0xe6, 0xe7, 0xf0, 0xf1, 0xf2, 0xf3, 0xf6, 0xf5, 0xf7 };
		static std::vector<std::uint8_t> lpop = { 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f };
		static std::vector<std::uint8_t> lbranch = { 0x71, 0x73 };

		PIMAGE_SECTION_HEADER pTextSec = pe::GetSection(basePtr, 0x000000747865742E/*".text\0\0\0"*/);
		PIMAGE_SECTION_HEADER pPackerSec = pe::GetSection(basePtr, 0x0072656b6361702e/*".packer\0"*/);

		std::vector<PIMAGE_SECTION_HEADER> vsec = { pTextSec, pPackerSec };

		if (!pTextSec || !pPackerSec)
			return false;

		for (PIMAGE_SECTION_HEADER sechdr : vsec)
		{
			pfnSetProgressBarRange(0, 100, 10);

			std::uintptr_t secStart = (std::uintptr_t)basePtr + sechdr->PointerToRawData;
			std::uintptr_t secSize = sechdr->SizeOfRawData;

			std::string pattern = "?? 81 ?? ?? ?? ?? ?? ?? ?? ??";

			const std::uint8_t wildcard = 0xCC;
			std::vector<std::uint8_t> vpattern;

			const char delimiter = ' ';

			// setup pattern
			std::vector<std::string> tokens;
			std::string token;

			std::stringstream ss(pattern);

			while (std::getline(ss, token, delimiter))
			{
				if (token == "??")
					vpattern.emplace_back(wildcard);
				else
				{
					std::istringstream hex(token);
					std::uint32_t byte;
					hex >> std::hex >> byte;

					vpattern.emplace_back(byte);
				}
			}

			if (vpattern.size() != 10)
				return false;

			const std::uint8_t *cstart = (const std::uint8_t *)secStart;
			const std::uint8_t *cend = cstart + secSize;

			for (;;)
			{
				const std::uint8_t *res = std::search(cstart, cend, vpattern.begin(), vpattern.end(),
					[&wildcard](std::uint8_t v1, std::uint8_t v2)
				{
					return (v1 == v2 || v2 == wildcard);
				});

				if (res >= cend)
					break;

				std::uintptr_t found = reinterpret_cast<std::uintptr_t>(res);

				std::uint8_t opc_push = *(std::uint8_t*)(found);
				std::uint8_t opc_op = *(std::uint8_t*)(found + 2);
				std::uint8_t opc_pop = *(std::uint8_t*)(found + 7);
				std::uint8_t opc_branch = *(std::uint8_t*)(found + 8);

				if (std::find(lpush.begin(), lpush.end(), opc_push) != lpush.end()
					&& std::find(lop.begin(), lop.end(), opc_op) != lop.end()
					&& std::find(lpop.begin(), lpop.end(), opc_pop) != lpop.end()
					&& std::find(lbranch.begin(), lbranch.end(), opc_branch) != lbranch.end())
				{
					std::uint8_t size_val = *(std::uint8_t*)(found + 9);

					std::uint8_t opc_mov = *(std::uint8_t*)(found + size_val + 10);

					if (opc_mov == 0x8B)
					{
						std::uint8_t opc_branch2 = *(std::uint8_t*)(found + size_val + 18);

						if (opc_branch2 == 0x74)
							size_val += 10;
					}

					for (std::uintptr_t p = found; p < found + 10 + size_val; p++)
						*(std::uint8_t*)(p) = 0x90;
				}

				pfnProgressProgressBar(((double)((std::uintptr_t)res - (std::uintptr_t)secStart) / (double)((std::uintptr_t)cend)) * 1000);

				cstart = res + vpattern.size();
			}
		}

		return true;
	}
}
```

`src/Decryptor.h`:

```h
#pragma once

#include <vector>
#include <cmath>

#include "PE.h"
#include "Helpers.h"

namespace decryptor
{
	extern "C" __int16 ComputeImpl(__int64);

	bool DecryptHeader(const std::vector<char>& buffer);
	bool DecryptTextSection(const std::vector<char>& buffer);
	bool LocateXorTable(const std::vector<char>& buffer, std::uintptr_t& xtable_loc);
	bool DumpXorTable(const std::vector<char>& buffer, std::vector<char>& xtable, std::uintptr_t address, std::size_t size);
	int ComputeInitialIndex(std::uintptr_t address, std::uintptr_t sectionVA);
	void DecryptByte(std::uintptr_t address, std::ptrdiff_t offset, const std::vector<char>& xtable, int idx);
	bool DecryptPage(std::uintptr_t phys_address, std::uintptr_t virt_address, const std::vector<char>& xtable, std::uintptr_t sectionVA);
	void DecryptDword( std::uintptr_t address, const std::vector<char>& xtable, int& idx);
	bool DecryptImportDescriptor(std::uintptr_t address, const std::vector<char>& xtable, int& idx);
	bool DecryptString(std::uintptr_t address, const std::vector<char>& xtable, int& idx);
	void DecryptQword(std::uintptr_t address, const std::vector<char>& xtable, int& idx);
	bool DecryptImportByName(std::uintptr_t address, const std::vector<char>& xtable, int& idx);
	bool RenameFakeTextSection(const std::vector<char>& buffer);
	bool RemoveObfuscationLayer(const std::vector<char>& buffer);
}


```

`src/Decryptor_v1.cpp`:

```cpp
#include "Main.h"
#include "Decryptor_v1.h"

namespace decryptor_v1
{
	bool GatherData(const std::vector<std::uint8_t>& buffer, XorTable& xtable)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);

		if (pNtHeaders == nullptr)
			return false;

		std::uintptr_t xtbl_address = LocateXorTable(buffer);
		xtable.SetAddress(xtbl_address);

		std::size_t xtbl_size = ComputeXorTableSize(buffer, helpers::RVAToFileOffset(pNtHeaders, xtable.GetAddress()));
		xtable.SetSize(xtbl_size);

		DumpXorTable(buffer, xtable, helpers::RVAToFileOffset(pNtHeaders, xtable.GetAddress()), xtable.GetSize());

		PIMAGE_SECTION_HEADER pPackerSec = pe::GetSection(basePtr, 0x0072656b6361702e/*".packer\0"*/);

		if (pPackerSec == nullptr)
			return false;

		std::uintptr_t packerSecStart = (std::uintptr_t)basePtr + pPackerSec->PointerToRawData;		
		std::uintptr_t packerSecSize = pPackerSec->SizeOfRawData;
		std::uintptr_t packerSecEnd = packerSecStart + packerSecSize;

		std::vector<std::uintptr_t> leaSearchRes;
		helpers::FindPattern(packerSecStart, packerSecSize, 0, "48 8D ?? ?? ?? ?? ??", leaSearchRes, nullptr);

		if (leaSearchRes.empty())
			return false;

		std::uintptr_t leaInst = 0x0;
		for (std::uintptr_t ptr : leaSearchRes)
		{
			std::uintptr_t a = xtable.GetAddress();
			std::uint32_t c = *(std::uint32_t*)(ptr + 3);
			std::uintptr_t b = helpers::RelativeToAbsolute(helpers::FileOffsetToRVA(pNtHeaders, ptr - (std::uintptr_t)basePtr), c, 7);
			if (a == b)
			{
				leaInst = ptr;
			}
		}

		std::uintptr_t imulStart = leaInst - 0x100;

		std::vector<std::uintptr_t> imulSearchRes;
		helpers::FindPattern(imulStart, leaInst - imulStart, 0, "?? 69 ?? ?? ?? ?? ??", imulSearchRes, [](std::uintptr_t p) -> std::uintptr_t
		{
			if (*(std::uint32_t*)(p + 3) > 0x0 && *(std::uint32_t*)(p + 3) < 0xFFF)
				return p;
			else
				return 0x0;
		});

		if (imulSearchRes.empty())
			return false;

		xtable.SetXModulo(*(std::uint32_t*)(*std::find_if(imulSearchRes.rbegin(), imulSearchRes.rend(), [](std::uintptr_t p) -> bool
		{
			return p != 0x0;
		}) + 3));
		xtable.SetIModulo(xtable.GetSize() / xtable.GetXModulo());

		return true;
	}

	std::uintptr_t LocateXorTable(const std::vector<std::uint8_t>& buffer)
	{
		std::uintptr_t address = 0x0;

		LPVOID ptr = (LPVOID)buffer.data();
		PIMAGE_SECTION_HEADER pDataSec = pe::GetSection(ptr, 0x000000617461642E/*".data\0\0\0"*/);

		if (pDataSec == nullptr)
			return 0x0;

		address = pDataSec->VirtualAddress;

		return address;
	}

	std::size_t ComputeXorTableSize(const std::vector<std::uint8_t>& buffer, std::uintptr_t xtbl_address)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);

		if (pNtHeaders == nullptr)
			return 0;

		std::size_t size = (std::size_t)(helpers::RVAToFileOffset(pNtHeaders, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) - xtbl_address);
		return size;
	}

	bool DumpXorTable(const std::vector<std::uint8_t>& buffer, XorTable& xtable, std::uintptr_t xtbl_address, std::size_t xtbl_size)
	{
		for (std::uintptr_t i = xtbl_address; i < xtbl_address + xtbl_size; i++)
			xtable.GetData().emplace_back(buffer[i]);

		return true;
	}

	bool DecryptHeader(const std::vector<std::uint8_t>& buffer, XorTable& xtable)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);
		if (!pNtHeaders)
			return false;

		int index = 0;
		DecryptDword((std::uintptr_t)((BYTE *)pNtHeaders + 0x94), xtable, index);

		DWORD importsRVA_save = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
		PIMAGE_IMPORT_DESCRIPTOR firstImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE *)basePtr + helpers::RVAToFileOffset(pNtHeaders, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size));

		std::size_t importsSize = 0;
		std::uintptr_t pIt = (std::uintptr_t)firstImportDesc;

		do
		{
			DecryptImportDescriptor(pIt, xtable, index);

			BYTE * nameAddr = (BYTE *)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(DWORD *)(pIt + 0xC));
			DecryptString((std::uintptr_t)nameAddr, xtable, index);

			std::uintptr_t importTableAddr = (std::uintptr_t)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(DWORD *)(pIt + 0x0));

			std::uintptr_t pIt2 = importTableAddr;

			do
			{
				DecryptQword(pIt2, xtable, index);

				if (*(DWORD *)(pIt2 + 0x4) >> 31 == 1)
				{
					//*(DWORD *)(pIt2 + 0x4) = (*(DWORD *)(pIt2 + 0x4) << 1) >> 1;
				}
				else
				{
					DecryptImportByName((std::uintptr_t)basePtr + helpers::RVAToFileOffset(pNtHeaders, *(unsigned __int64 *)(pIt2)), xtable, index);
				}

				pIt2 += 0x8;
			} while (*(DWORD *)(pIt2) != 0x0);

			pIt += 0x14;
			importsSize += 0x14;
		} while (*(DWORD *)(pIt) != 0x0);

		pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = importsRVA_save;
		pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = importsSize;

		return true;
	}

	void DecryptDword(std::uintptr_t address, XorTable& xtable, int& idx)
	{
		std::uintptr_t ptr = address;

		do
		{
			ptr += 1;
			int offset = idx % xtable.GetXModulo();
			idx += 1;
			*(char *)(ptr - 1) = *(char *)(ptr - 1) ^ xtable.GetData()[offset];
		} while (idx < 4);
	}

	bool DecryptImportDescriptor(std::uintptr_t address, XorTable& xtable, int& idx)
	{
		int size = 0;
		std::uintptr_t ptr = address;

		do
		{
			ptr += 1;
			int offset = idx % xtable.GetXModulo();
			size += 1;
			idx += 1;
			*(char *)(ptr - 1) = *(char *)(ptr - 1) ^ xtable.GetData()[offset];
		} while (size < 0x14);

		return true;
	}

	bool DecryptString(std::uintptr_t address, XorTable& xtable, int& idx)
	{
		std::uintptr_t ptr = address;

		char first = *(char *)(ptr) ^ xtable.GetData()[idx % xtable.GetXModulo()];
		*(char *)(ptr) = first;

		char unxored = first;

		if (first = 0x00)
			return false;
		else
		{
			do
			{
				ptr += 1;
				idx += 1;
				unxored = *(char *)(ptr) ^ xtable.GetData()[idx % xtable.GetXModulo()];
				*(char *)(ptr) = unxored;
			} while (unxored != 0x00);
		}

		return true;
	}

	void DecryptQword(std::uintptr_t address, XorTable& xtable, int& idx)
	{
		std::uintptr_t ptr = address;
		int count = 0;

		do
		{
			*(char *)(ptr) = *(char *)(ptr) ^ xtable.GetData()[idx % xtable.GetXModulo()];
			idx += 1;
			ptr += 1;
			count += 1;
		} while (count < 8);
	}

	bool DecryptImportByName(std::uintptr_t address, XorTable& xtable, int& idx)
	{
		return DecryptString(address + 2, xtable, idx);
	}

	bool DecryptTextSection(const std::vector<std::uint8_t>& buffer, XorTable& xtable)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		PIMAGE_NT_HEADERS pNtHeaders = pe::GetNtHeaders(basePtr);
		if (!pNtHeaders)
			return nullptr;

		PIMAGE_SECTION_HEADER pTextSec = pe::GetSection(basePtr, 0x000000747865742E/*".text\0\0\0"*/);

		std::uintptr_t va = 0x140000000 + pTextSec->VirtualAddress;
		std::uintptr_t startSec = (std::uintptr_t)basePtr + pTextSec->PointerToRawData; //+ helpers::RVAToFileOffset(pNtHeaders, pTextSec->VirtualAddress);		
		std::uintptr_t sizeSec = pTextSec->SizeOfRawData;
		std::uintptr_t endSec = startSec + sizeSec;

		std::uintptr_t currentPage = startSec;
		std::size_t pageSize = 0x1000;

		pfnSetProgressBarRange(0, 100, 1);

		while (currentPage < endSec)
		{
			//pFunc("Decrypting page 0x" + helpers::ToHexString(va) + "-0x" + helpers::ToHexString(va + pageSize) + " " + std::to_string(std::round(((float)(va - (0x140000000 + pTextSec->VirtualAddress) + pageSize) / (float)(sizeSec)) * 100.0f)) + "%");
			DecryptPage(currentPage, va, xtable, 0x140000000 + pTextSec->VirtualAddress);

			va += pageSize;
			currentPage += pageSize;

			pfnProgressProgressBar((float)((float)(currentPage - startSec) / endSec) * 1000);
		}

		return true;
	}

	bool DecryptPage(std::uintptr_t phys_address, std::uintptr_t virt_address, XorTable& xtable, std::uintptr_t sectionVA)
	{
		std::uintptr_t ptr = phys_address;

		int idx = xtable.ComputeInitialIndex(virt_address & 0xFFFFFFFFFFFFF000, sectionVA);

		std::uintptr_t current_byte = 0x0;
		std::size_t page_size = 0x1000;

		while (current_byte < page_size)
		{
			*(std::uint8_t*)(ptr + current_byte) = *(std::uint8_t*)(ptr + current_byte) ^ xtable.GetData()[(xtable.GetXModulo() * idx) + current_byte % xtable.GetXModulo()];
			current_byte++;
		}

		return true;
	}

	bool RemoveObfuscationLayer(const std::vector<std::uint8_t>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		static std::vector<std::uint8_t> lpush = { 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 };
		static std::vector<std::uint8_t> lop = { 0xc8, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe5, 0xe6, 0xe7, 0xf0, 0xf1, 0xf2, 0xf3, 0xf6, 0xf5, 0xf7 };
		static std::vector<std::uint8_t> lpop = { 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f };
		static std::vector<std::uint8_t> lbranch = { 0x71, 0x73 };

		PIMAGE_SECTION_HEADER pTextSec = pe::GetSection(basePtr, 0x000000747865742E/*".text\0\0\0"*/);
		PIMAGE_SECTION_HEADER pPackerSec = pe::GetSection(basePtr, 0x0072656b6361702e/*".packer\0"*/);

		std::vector<PIMAGE_SECTION_HEADER> vsec = { pTextSec, pPackerSec };

		if (!pTextSec || !pPackerSec)
			return false;

		for (PIMAGE_SECTION_HEADER sechdr : vsec)
		{
			pfnSetProgressBarRange(0, 100, 10);

			std::uintptr_t secStart = (std::uintptr_t)basePtr + sechdr->PointerToRawData;
			std::uintptr_t secSize = sechdr->SizeOfRawData;

			std::string pattern = "?? 81 ?? ?? ?? ?? ?? ?? ?? ??";

			const std::uint8_t wildcard = 0xCC;
			std::vector<std::uint8_t> vpattern;

			const char delimiter = ' ';

			// setup pattern
			std::vector<std::string> tokens;
			std::string token;

			std::stringstream ss(pattern);

			while (std::getline(ss, token, delimiter))
			{
				if (token == "??")
					vpattern.emplace_back(wildcard);
				else
				{
					std::istringstream hex(token);
					std::uint32_t byte;
					hex >> std::hex >> byte;

					vpattern.emplace_back(byte);
				}
			}

			if (vpattern.size() != 10)
				return false;

			const std::uint8_t *cstart = (const std::uint8_t *)secStart;
			const std::uint8_t *cend = cstart + secSize;

			for (;;)
			{
				const std::uint8_t *res = std::search(cstart, cend, vpattern.begin(), vpattern.end(),
					[&wildcard](std::uint8_t v1, std::uint8_t v2)
				{
					return (v1 == v2 || v2 == wildcard);
				});

				if (res >= cend)
					break;

				std::uintptr_t found = reinterpret_cast<std::uintptr_t>(res);

				std::uint8_t opc_push = *(std::uint8_t*)(found);
				std::uint8_t opc_op = *(std::uint8_t*)(found + 2);
				std::uint8_t opc_pop = *(std::uint8_t*)(found + 7);
				std::uint8_t opc_branch = *(std::uint8_t*)(found + 8);

				if (std::find(lpush.begin(), lpush.end(), opc_push) != lpush.end()
					&& std::find(lop.begin(), lop.end(), opc_op) != lop.end()
					&& std::find(lpop.begin(), lpop.end(), opc_pop) != lpop.end()
					&& std::find(lbranch.begin(), lbranch.end(), opc_branch) != lbranch.end())
				{
					std::uint8_t size_val = *(std::uint8_t*)(found + 9);

					std::uint8_t opc_mov = *(std::uint8_t*)(found + size_val + 10);

					if (opc_mov == 0x8B)
					{
						std::uint8_t opc_branch2 = *(std::uint8_t*)(found + size_val + 18);

						if (opc_branch2 == 0x74)
							size_val += 10;
					}

					for (std::uintptr_t p = found; p < found + 10 + size_val; p++)
						*(std::uint8_t*)(p) = 0x90;
				}

				pfnProgressProgressBar(((double)((std::uintptr_t)res - (std::uintptr_t)secStart) / (double)((std::uintptr_t)cend)) * 1000);

				cstart = res + vpattern.size();
			}
		}

		return true;
	}

	bool RenameFakeTextSection(const std::vector<std::uint8_t>& buffer)
	{
		LPVOID basePtr = (LPVOID)buffer.data();

		if (!pe::IsValidDosHeader(basePtr))
			return false;

		if (!pe::IsValidNtHeaders(basePtr))
			return false;

		PIMAGE_SECTION_HEADER pFakeTextSec = pe::GetSection(basePtr, 0x000C00747865742E/*".text\0\f\0"*/);

		*(unsigned __int64*)pFakeTextSec->Name = 0x0072656b6361702e;

		PIMAGE_SECTION_HEADER pPackerSec = pe::GetSection(basePtr, 0x0072656b6361702e/*".packer\0"*/);

		return pPackerSec != nullptr;
	}
}
```

`src/Decryptor_v1.h`:

```h
#pragma once

#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>

#include "PE.h"
#include "Helpers.h"
#include "XorTable.h"

namespace decryptor_v1
{
	// data stuff
	bool GatherData(const std::vector<std::uint8_t>& buffer, XorTable& xtable);
	std::uintptr_t LocateXorTable(const std::vector<std::uint8_t>& buffer);
	std::size_t ComputeXorTableSize(const std::vector<std::uint8_t>& buffer, std::uintptr_t xtbl_address);
	bool DumpXorTable(const std::vector<std::uint8_t>& buffer, XorTable& xtable, std::uintptr_t xtbl_address, std::size_t xtbl_size);

	// misc stuff
	bool RenameFakeTextSection(const std::vector<std::uint8_t>& buffer);
	
	// header stuff
	bool DecryptHeader(const std::vector<std::uint8_t>& buffer, XorTable& xtable);

	void DecryptDword(std::uintptr_t address, XorTable & xtable, int & idx);

	bool DecryptImportDescriptor(std::uintptr_t address, XorTable & xtable, int & idx);

	bool DecryptString(std::uintptr_t address, XorTable & xtable, int & idx);

	void DecryptQword(std::uintptr_t address, XorTable & xtable, int & idx);

	bool DecryptImportByName(std::uintptr_t address, XorTable & xtable, int & idx);

	// text section stuff
	bool DecryptTextSection(const std::vector<std::uint8_t>& buffer, XorTable & xtable);

	bool DecryptPage(std::uintptr_t phys_address, std::uintptr_t virt_address, XorTable & xtable, std::uintptr_t sectionVA);

	// obfuscation stuff
	bool RemoveObfuscationLayer(const std::vector<std::uint8_t>& buffer);
}

```

`src/Helpers.cpp`:

```cpp
#include "Helpers.h"

namespace helpers
{
	bool ReadFileToBuffer(std::string filename, std::vector<std::uint8_t>& buffer)
	{
		std::ifstream in(filename, std::ios::binary);

		if (!in.good())
			return false;

		in.seekg(0, in.end);
		std::ifstream::pos_type length = in.tellg();

		std::vector<char> tmp;

		buffer.resize(length);
		tmp.resize(length);
		
		in.seekg(0, in.beg);
		in.read(tmp.data(), length);
		in.close();

		buffer.assign(tmp.begin(), tmp.end());

		return true;
	}

	std::uintptr_t RVAToFileOffset(PIMAGE_NT_HEADERS pNtHeaders, DWORD RelativeVirtualAddress)
	{
		// Get pointer on PE Section Header
		PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((BYTE *)pNtHeaders + sizeof(IMAGE_FILE_HEADER) + 4 + pNtHeaders->FileHeader.SizeOfOptionalHeader); // 4 byte offset to handle the Signature field in _IMAGE_NT_HEADERS

																																										  // Get number of sections
		WORD numberOfSections = pNtHeaders->FileHeader.NumberOfSections;

		// Determine in which section points RVA
		int i = 0;
		PIMAGE_SECTION_HEADER pSection = nullptr;

		// Iterate sections
		while (i < numberOfSections && !pSection)
		{
			if (RelativeVirtualAddress >= pSectionHeader->VirtualAddress && RelativeVirtualAddress < (pSectionHeader->VirtualAddress + (pSectionHeader->Misc.VirtualSize == 0 ? pSectionHeader->SizeOfRawData : pSectionHeader->Misc.VirtualSize)))
				pSection = pSectionHeader;

			i++;
			pSectionHeader++;
		}

		if (i >= numberOfSections || !pSection)
			return 0;

		// Compute file offset
		std::uintptr_t r = (RelativeVirtualAddress - pSection->VirtualAddress) + pSection->PointerToRawData;
		return r;
	}

	std::uintptr_t FileOffsetToRVA(PIMAGE_NT_HEADERS pNtHeaders, DWORD Offset)
	{
		// Get pointer on PE Section Header
		PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((BYTE *)pNtHeaders + sizeof(IMAGE_FILE_HEADER) + 4 + pNtHeaders->FileHeader.SizeOfOptionalHeader); // 4 byte offset to handle the Signature field in _IMAGE_NT_HEADERS

																																										  // Get number of sections
		WORD numberOfSections = pNtHeaders->FileHeader.NumberOfSections;

		// Determine in which section points RVA
		int i = 0;
		PIMAGE_SECTION_HEADER pSection = nullptr;

		// Iterate sections
		while (i < numberOfSections && !pSection)
		{
			if (Offset >= pSectionHeader->PointerToRawData && Offset < (pSectionHeader->PointerToRawData + (pSectionHeader->SizeOfRawData == 0 ? pSectionHeader->Misc.VirtualSize : pSectionHeader->SizeOfRawData)))
				pSection = pSectionHeader;

			i++;
			pSectionHeader++;
		}

		if (i >= numberOfSections || !pSection)
			return 0;

		// Compute file offset
		std::uintptr_t r = (Offset + pSection->VirtualAddress) - pSection->PointerToRawData;
		return r;
	}

	void FindPattern(std::uintptr_t start, std::size_t lenght, int position, const std::string& pattern, std::vector<std::uintptr_t>& results, std::function<std::uintptr_t(std::uintptr_t p)> func)
	{
		if (pattern.empty())
			return;

		//credit : darthton blackbone source
		const std::uint8_t *cstart = (const std::uint8_t *)start;
		const std::uint8_t *cend = cstart + lenght;

		const std::uint8_t wildcard = 0xCC;
		std::vector<std::uint8_t> vpattern;

		const char delimiter = ' ';

		// setup pattern
		std::vector<std::string> tokens;
		std::string token;

		std::stringstream ss(pattern);

		while (std::getline(ss, token, delimiter))
		{
			if (token == "??")
				vpattern.emplace_back(wildcard);
			else
			{
				std::istringstream hex(token);
				std::uint32_t byte;
				hex >> std::hex >> byte;

				vpattern.emplace_back(byte);
			}
		}

		for (;;)
		{
			const std::uint8_t *res = std::search(cstart, cend, vpattern.begin(), vpattern.end(),
				[&wildcard](std::uint8_t v1, std::uint8_t v2)
			{
				return (v1 == v2 || v2 == wildcard);
			});

			if (res >= cend)
				break;

			if (position != 0)
				res = res + position;

			if (func)
			{
				std::uintptr_t newAddr = func(reinterpret_cast<std::uintptr_t>(res));
				results.emplace_back(newAddr);
			}
			else
				results.emplace_back(reinterpret_cast<std::uintptr_t>(res));

			cstart = res + vpattern.size();
		}
	}

	void FindPattern(std::uintptr_t start, std::size_t lenght, int position, const std::string& pattern, std::vector<std::uintptr_t>& results, std::function<std::uintptr_t(std::uintptr_t p)> func, bool relative)
	{
		if(relative)
			FindPattern(start, lenght, position, pattern, results,
				[&](std::uintptr_t p) -> std::uintptr_t
				{
					std::uintptr_t offset = p - start;

					if (offset + 4 >= start + lenght)
						throw std::out_of_range("rva");

					int relAddr = *(int*)&((const std::uint8_t *)start)[offset];
					return p + 4 + relAddr;
				});
		else
			FindPattern(start, lenght, position, pattern, results, nullptr);
	}

	std::uintptr_t RelativeToAbsolute(std::uintptr_t address, std::ptrdiff_t rva, std::size_t inst_size)
	{
		return address + rva + inst_size;
	}
}
```

`src/Helpers.h`:

```h
#pragma once
#include <Windows.h>

#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <functional>
#include <algorithm>
#include <exception>

namespace helpers
{
	template<typename T>
	inline std::string ToHexString(T number)
	{
		std::stringstream stream;
		stream << std::hex << number;
		return stream.str();
	}

	bool ReadFileToBuffer(std::string filename, std::vector<std::uint8_t>& buffer);
	std::uintptr_t RVAToFileOffset(PIMAGE_NT_HEADERS pNtHeaders, DWORD RelativeVirtualAddress);
	std::uintptr_t FileOffsetToRVA(PIMAGE_NT_HEADERS pNtHeaders, DWORD Offset);
	std::uintptr_t RelativeToAbsolute(std::uintptr_t address, std::ptrdiff_t rva, std::size_t inst_size);
	void FindPattern(std::uintptr_t start, std::size_t lenght, int position, const std::string& pattern, std::vector<std::uintptr_t>& results, std::function<std::uintptr_t(std::uintptr_t p)> func);
	void FindPattern(std::uintptr_t start, std::size_t lenght, int position, const std::string& pattern, std::vector<std::uintptr_t>& results, std::function<std::uintptr_t(std::uintptr_t p)> func, bool relative);
}

```

`src/Main.cpp`:

```cpp
#include "Main.h"

SetProgressBarRange_t pfnSetProgressBarRange;
ProgressProgressBar_t pfnProgressProgressBar;

int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	WNDCLASSEX windowClass = { 0 };
	windowClass.cbSize = sizeof(WNDCLASSEX);

	sInstance = hInstance;
	sClassName = "ow_unpack";
	sWindowName = "ow_unpack v1.2";

	if (!GetClassInfoEx(sInstance, sClassName.c_str(), &windowClass))
	{
		windowClass.style = CS_HREDRAW | CS_VREDRAW;
		windowClass.lpfnWndProc = WndCallback;
		windowClass.cbClsExtra = 0;
		windowClass.cbWndExtra = 0;
		windowClass.hInstance = sInstance;
		windowClass.hIcon = LoadIcon(sInstance, MAKEINTRESOURCE(IDI_ICON1));
		windowClass.hCursor = LoadCursor(nullptr, IDC_ARROW);
		windowClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
		windowClass.lpszMenuName = nullptr;
		windowClass.lpszClassName = sClassName.c_str();
		windowClass.hIconSm = LoadIcon(sInstance, MAKEINTRESOURCE(IDI_ICON1));

		if (!RegisterClassEx(&windowClass))
		{
			MessageBox(nullptr, "Cannot register window", sWindowName.c_str(), MB_OK | MB_ICONERROR);
			return EXIT_FAILURE;
		}
	}

	sWindowHandle = CreateWindowEx(	WS_EX_STATICEDGE,
									sClassName.c_str(),
									sWindowName.c_str(),
									WS_OVERLAPPEDWINDOW,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									402,
									232,
									nullptr,
									nullptr,
									sInstance,
									nullptr);

	if (!sWindowHandle)
	{
		MessageBox(nullptr, "Cannot create window", sWindowName.c_str(), MB_OK | MB_ICONERROR);
		return EXIT_FAILURE;
	}

	SetWindowLong(sWindowHandle, GWL_STYLE, WS_POPUP | WS_MINIMIZEBOX);

	pfnSetProgressBarRange = SetProgressBarRange;
	pfnProgressProgressBar = ProgressProgressBar;

	ShowWindow(sWindowHandle, SW_SHOW);
	UpdateWindow(sWindowHandle);

	MSG msg;
	while (GetMessage(&msg, nullptr, NULL, NULL))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return msg.wParam;
}

LRESULT __stdcall WndCallback(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	HBITMAP splashHandle;

	switch (Message)
	{
	case WM_CREATE:
		InitCommonControls();
		pictureBoxHandle = CreateWindowEx(	NULL,
											"Static",
											nullptr,
											WS_CHILD | WS_VISIBLE | SS_BITMAP,
											1,
											1,
											400,
											150,
											hwnd,
											(HMENU)IDC_PICTURE_BOX,
											sInstance,
											nullptr);

		splashHandle = (HBITMAP)LoadImage(sInstance, MAKEINTRESOURCE(IDB_BITMAP1), IMAGE_BITMAP, 0, 0, NULL);
		SendMessage(pictureBoxHandle, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)splashHandle);

		fileBoxHandle = CreateWindowEx(	NULL,
										"Edit",
										"No file selected",
										WS_BORDER | WS_CHILD | WS_VISIBLE | ES_READONLY,
										0,
										152,
										250,
										25,
										hwnd,
										(HMENU)IDC_FILE_BOX,
										sInstance,
										nullptr);

		fileButtonHandle = CreateWindowEx(	NULL,
											"Button",
											"file",
											WS_BORDER | WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_FLAT,
											250,
											152,
											75,
											25,
											hwnd,
											(HMENU)IDC_FILE_BUTTON,
											sInstance,
											nullptr);

		workButtonHandle = CreateWindowEx(	NULL,
											"Button",
											"decrypt",
											WS_BORDER | WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_FLAT,
											325,
											152,
											75,
											25,
											hwnd,
											(HMENU)IDC_WORK_BUTTON,
											sInstance,
											nullptr);

		statusBoxHandle = CreateWindowEx(	NULL,
											"Edit",
											"Idle",
											WS_BORDER | WS_CHILD | WS_VISIBLE | ES_READONLY,
											0,
											178,
											400,
											25,
											hwnd,
											(HMENU)IDC_STATUS_BOX,
											sInstance,
											nullptr);

		quitButtonHandle = CreateWindowEx(	NULL,
											"Button",
											"x",
											WS_BORDER | WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_FLAT,
											380,
											1,
											20,
											20,
											hwnd,
											(HMENU)IDC_QUIT_BUTTON,
											sInstance,
											nullptr);

		aboutButtonHandle = CreateWindowEx(	NULL,
											"Button",
											"?",
											WS_BORDER | WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_FLAT,
											360,
											1,
											20,
											20,
											hwnd,
											(HMENU)IDC_ABOUT_BUTTON,
											sInstance,
											nullptr);

		progressBarHandle = CreateWindowEx(	NULL,
											PROGRESS_CLASS,
											nullptr,
											WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
											0,
											205,
											400,
											25,
											hwnd,
											(HMENU)IDC_PROGRESSBAR,
											sInstance,
											nullptr);
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_PICTURE_BOX:
			break;
		case IDC_FILE_BOX:
			break;
		case IDC_FILE_BUTTON:
			LocateFile();
			break;
		case IDC_WORK_BUTTON:
			CreateThread(nullptr, 0, Work, (LPVOID)sFilename.c_str(), NULL, nullptr);
			break;
		case IDC_STATUS_BOX:
			break;
		case IDC_QUIT_BUTTON:
			PostQuitMessage(0);
			break;
		case IDC_ABOUT_BUTTON:
			MessageBox(nullptr, "ow_unpack - an unpacker/decryptor for Blizzard's Overwatch Game\n\nCode by Midi12\nArt by Extasy Hosting", sWindowName.c_str(), MB_OK);
			break;
		default:
			break;
		}
		break;
	case WM_CTLCOLORSTATIC:
		if ((HWND)lParam == pictureBoxHandle || (HWND)lParam == quitButtonHandle)
		{
			HDC hdc = (HDC)wParam;
			SetBkMode(hdc, TRANSPARENT);
			return (LRESULT)GetStockObject(HOLLOW_BRUSH);
		}
		break;
	case WM_NCHITTEST:
	{
		LRESULT hit = DefWindowProc(hwnd, Message, wParam, lParam);
		if (hit == HTCLIENT) hit = HTCAPTION;
		return hit;
	}
		break;
	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		LRESULT res = DefWindowProc(hwnd, Message, wParam, lParam);
		HideCaret(fileBoxHandle);
		HideCaret(statusBoxHandle);
		return res;
		break;
	}

	return 0;
}

void UpdateStatusBox(const std::string& msg)
{
	SetWindowText(statusBoxHandle, msg.c_str());
}

void UpdateFileBox(const std::string& filepath)
{
	SetWindowText(fileBoxHandle, filepath.c_str());
}

void LocateFile(void)
{
	OPENFILENAME ofn = { 0 };
	ofn.lStructSize = sizeof(OPENFILENAME);

	char filepath[MAX_PATH] = "";

	ofn.hwndOwner = fileBoxHandle;
	ofn.lpstrFilter = "Overwatch.exe\0Overwatch.exe\0All Files(*.*)\0*.*\0";
	ofn.lpstrFile = filepath;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST;
	ofn.lpstrDefExt = "exe";

	if (GetOpenFileName(&ofn))
	{
		sFilename = ofn.lpstrFile;
		
		char *shortName = nullptr;
		int len = GetShortPathName(ofn.lpstrFile, nullptr, 0);

		if (len != 0)
		{
			shortName = new char[len];
			GetShortPathName(ofn.lpstrFile, shortName, len);
			UpdateFileBox(shortName);
			delete[] shortName;
		}
		else
		{
			UpdateFileBox(ofn.lpstrFile);
		}
	}
	else
	{
		sFilename = "";
		UpdateFileBox("No file selected");
	}
}

DWORD __stdcall Work(LPVOID lpParameter)
{
	std::string filepath = (char *)lpParameter;

	std::vector<std::uint8_t> fileBuffer;

	if (!helpers::ReadFileToBuffer(filepath, fileBuffer))
	{
		UpdateStatusBox("Cannot open " + filepath);
		return -1;
	}

	XorTable xtbl;

	UpdateStatusBox("Renaming .text\\0\\f\\0 fake section to .packer ...");
	decryptor_v1::RenameFakeTextSection(fileBuffer);

	UpdateStatusBox("Gathering necessary data ...");
	decryptor_v1::GatherData(fileBuffer, xtbl);

	UpdateStatusBox("Decrypting & fixing imports ...");
	decryptor_v1::DecryptHeader(fileBuffer, xtbl);

	UpdateStatusBox("Decrypting .text section ...");
	decryptor_v1::DecryptTextSection(fileBuffer, xtbl);

	UpdateStatusBox("Removing obfuscation layer ...");
	decryptor_v1::RemoveObfuscationLayer(fileBuffer);
	
	SetProgressBarRange(0, 100, 10);

	UpdateStatusBox("Writing file to disk ...");
	std::string ext = filepath.substr(filepath.rfind('.'));
	std::ofstream out(filepath.substr(0, filepath.rfind('.')) + ".clean" + ext, std::ios::binary | std::ios::trunc);
	if (!out.good())
	{
		UpdateStatusBox("Cannot create " + filepath.substr(0, filepath.rfind('.')) + ".clean" + ext);
		return -1;
	}

	ProgressProgressBar(33);
	std::copy(fileBuffer.begin(), fileBuffer.end(), std::ostreambuf_iterator<char>(out));
	ProgressProgressBar(66);

	if (out.fail())
	{
		UpdateStatusBox("Cannot write buffer to disk");
		return -1;
	}

	ProgressProgressBar(100);
	UpdateStatusBox("Done :)");

	CreateThread(nullptr, 0, TimerIdle, nullptr, 0, nullptr);

	return 0;
}

DWORD __stdcall TimerIdle(LPVOID lpParameter)
{
	Sleep(5000);
	UpdateStatusBox("Idle");
	SetProgressBarRange(0, 100, 10);
	ProgressProgressBar(0);
	return 0;
}

void SetProgressBarRange(int min_, int max_, int step)
{
	SendMessage(progressBarHandle, PBM_SETRANGE, 0, MAKELPARAM(min_, max_));
	SendMessage(progressBarHandle, PBM_SETSTEP, (WPARAM)step, 0);
}

void ProgressProgressBar(int progress)
{
	SendMessage(progressBarHandle, PBM_SETPOS, progress, 0);
}
```

`src/Main.h`:

```h
#pragma once
#pragma once

#include <Windows.h>
#include <gdiplus.h>
#include <CommCtrl.h>
#pragma comment(lib,"comctl32.lib")

#include <string>
#include <vector>

#include "resource.h"

#include "Helpers.h"
//#include "Decryptor.h"
#include "Decryptor_v1.h"

#define IDC_PICTURE_BOX 102
#define IDC_FILE_BOX 103
#define IDC_FILE_BUTTON 104
#define IDC_WORK_BUTTON 105
#define IDC_STATUS_BOX 106
#define IDC_QUIT_BUTTON 107
#define IDC_ABOUT_BUTTON 108
#define IDC_PROGRESSBAR 110

LRESULT __stdcall WndCallback(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);

void UpdateStatusBox(const std::string& msg);
void UpdateFileBox(const std::string& filepath);
void SetProgressBarRange(int min_, int max_, int step);
void ProgressProgressBar(int progress);

typedef void (*SetProgressBarRange_t)(int min_, int max_, int step);
typedef void (*ProgressProgressBar_t)(int progress);

void LocateFile(void);
DWORD __stdcall Work(LPVOID lpParameter);
DWORD __stdcall TimerIdle(LPVOID lpParameter);

static HINSTANCE sInstance;
static std::string sClassName;
static std::string sWindowName;
static HWND sWindowHandle;

static std::string sFilename;

static HWND pictureBoxHandle, fileBoxHandle, fileButtonHandle, workButtonHandle, statusBoxHandle, quitButtonHandle, aboutButtonHandle, progressBarHandle;

extern SetProgressBarRange_t pfnSetProgressBarRange;
extern ProgressProgressBar_t pfnProgressProgressBar;
```

`src/PE.cpp`:

```cpp
#include "PE.h"

namespace pe
{
	bool IsValidDosHeader(LPVOID ptr)
	{
		PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)ptr;

		return pDosHeader->e_magic == 'ZM';
	}

	bool IsValidNtHeaders(LPVOID ptr)
	{
		PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)ptr;

		if (!IsValidDosHeader(pDosHeader))
			return false;

		PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE *)pDosHeader + pDosHeader->e_lfanew);

		return pNtHeaders->Signature == 'EP';
	}

	PIMAGE_NT_HEADERS GetNtHeaders(LPVOID ptr)
	{
		if (!IsValidDosHeader(ptr) || !IsValidNtHeaders(ptr))
			return nullptr;

		PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)ptr;
		return (PIMAGE_NT_HEADERS)((BYTE *)pDosHeader + pDosHeader->e_lfanew);
	}

	PIMAGE_SECTION_HEADER GetSection(LPVOID ptr, unsigned __int64 name)
	{
		if (!IsValidDosHeader(ptr) || !IsValidNtHeaders(ptr))
			return nullptr;

		PIMAGE_NT_HEADERS pNtHeaders = GetNtHeaders(ptr);

		WORD numberOfSections = pNtHeaders->FileHeader.NumberOfSections;

		PIMAGE_SECTION_HEADER pSec = nullptr;
		PIMAGE_SECTION_HEADER pIt = (PIMAGE_SECTION_HEADER)((BYTE *)pNtHeaders + sizeof(IMAGE_FILE_HEADER) + 4 + pNtHeaders->FileHeader.SizeOfOptionalHeader); // 4 byte offset to handle the Signature field in _IMAGE_NT_HEADERS

		int i = 0;

		// Iterate sections
		while (i < numberOfSections && !pSec)
		{
			if (*(unsigned __int64 *)pIt->Name == name)
			/*if (pIt->Name[0] == sectionName[0]
				&& pIt->Name[1] == sectionName[1]
				&& pIt->Name[2] == sectionName[2]
				&& pIt->Name[3] == sectionName[3]
				&& pIt->Name[4] == sectionName[4]
				&& pIt->Name[5] == sectionName[5]
				&& pIt->Name[6] == sectionName[6]
				&& pIt->Name[7] == sectionName[7])*/
			{
				pSec = pIt;
			}

			i++;
			pIt++;
		}

		return pSec;
	}
}

```

`src/PE.h`:

```h
#pragma once

#include <Windows.h>

namespace pe
{
	bool IsValidDosHeader(LPVOID ptr);
	bool IsValidNtHeaders(LPVOID ptr);
	PIMAGE_NT_HEADERS GetNtHeaders(LPVOID ptr);
	PIMAGE_SECTION_HEADER GetSection(LPVOID ptr, unsigned __int64 name);
}


```

`src/XorTable.cpp`:

```cpp
#include "XorTable.h"

XorTable::XorTable() :
	mAddress(0),
	mSize(0),
	mData(),
	mIModulo(-1),
	mXModulo(-1)
{
}

XorTable::~XorTable()
{
}

bool XorTable::IsValid(void) const
{
	return this->mData.size() >= 0 && this->mIModulo != -1 && this->mXModulo != -1;
}

std::uintptr_t XorTable::GetAddress(void) const
{
	return this->mAddress;
}

std::vector<std::uint8_t>& const XorTable::GetData(void)
{
	return this->mData;
}

std::size_t XorTable::GetSize(void) const
{
	return this->mSize;
}

std::uint32_t XorTable::GetIModulo(void) const
{
	return this->mIModulo;
}

std::uint32_t XorTable::GetXModulo(void) const
{
	return this->mXModulo;
}

void XorTable::SetAddress(std::uintptr_t address)
{
	this->mAddress = address;
}

void XorTable::SetSize(std::size_t size)
{
	this->mSize = size;
}

void XorTable::SetIModulo(std::uint32_t imod)
{
	this->mIModulo = imod;
}

void XorTable::SetXModulo(std::uint32_t xmod)
{
	this->mXModulo = xmod;
}

std::uint32_t XorTable::ComputeInitialIndex(std::uintptr_t address, std::uintptr_t section_va) const
{
	return (address - section_va) / 0x1000 % this->mIModulo;
}

```

`src/XorTable.h`:

```h
#pragma once

#include <cstdint>
#include <vector>

class XorTable
{
public:
	XorTable();
	~XorTable();

	bool IsValid(void) const;
	
	std::uintptr_t GetAddress(void) const;
	std::vector<std::uint8_t>& GetData(void);
	std::size_t GetSize(void) const;
	std::uint32_t GetIModulo(void) const;
	std::uint32_t GetXModulo(void) const;

	void SetAddress(std::uintptr_t address);
	void SetSize(std::size_t size);
	void SetIModulo(std::uint32_t imod);
	void SetXModulo(std::uint32_t xmod);

	std::uint32_t ComputeInitialIndex(std::uintptr_t address, std::uintptr_t section_va) const;

private:
	std::uintptr_t mAddress;
	std::vector<std::uint8_t> mData;
	std::size_t mSize;
	std::uint32_t mIModulo;
	std::uint32_t mXModulo;
};


```

`src/asm_.asm`:

```asm
.DATA
.CODE

ComputeImpl PROC
	and edx, 0FFFh
	lea r8, [rdx+rax]
	mov rax, 469EE58469EE5847h
	sar r8, 0Ch
	imul r8
	sar rdx, 3
	mov rcx, rax
	shr rcx, 3Fh
	add rcx, rax
	imul rcx, rdx, 1Dh
	sub r8, rcx
	imul r8, 100h
	mov rax, r8
	ret
ComputeImpl ENDP

END
```

`src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// fichier Include Microsoft Visual C++.
// Utilisé par ow_unpack.rc
//
#define IDB_BITMAP1                     101
#define IDI_ICON1                       109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```